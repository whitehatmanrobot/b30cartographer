    else
        {
            bOk = false;
            ResultStream << "ERROR:Reading IdleWinStationPoolCount registry" << endl;

        }

    }
    else
    {
        bOk = false;
        ResultStream << "SYSTEM\\CurrentControlSet\\Control\\Terminal Server" << endl;
    }

    return bOk;


}

bool g_IsTermsrvRunning = false;
bool IsTerminalServiceRunning ()
{
	return g_IsTermsrvRunning;
}

EResult IsTerminalServiceRunning  (ostrstream &ResultStream)
{
	EResult eRes = eUnknown;
    bool bReturn = false;

    SC_HANDLE hServiceController = OpenSCManager(CTSTestData::GetMachineNamePath(), NULL, GENERIC_READ);
    if (hServiceController)
    {

        SC_HANDLE hTermServ = OpenService(hServiceController, _T("TermService"), SERVICE_QUERY_STATUS);
        if (hTermServ)
        {
            SERVICE_STATUS tTermServStatus;
            if (QueryServiceStatus(hTermServ, &tTermServStatus))
            {
                bReturn = (tTermServStatus.dwCurrentState == SERVICE_RUNNING);
				if (bReturn)
				{
					ResultStream << "Passed";
					eRes = ePassed;
					g_IsTermsrvRunning = true;
				}
				else
				{
					ResultStream << "Failed, Termsrv is not running";
					eRes = eFailed;
				}

            }
            else
            {
                ResultStream << "Failed to get service status, Error = " << GetLastError();
				eRes = eFailedToExecute;
            }

            VERIFY(CloseServiceHandle(hTermServ));

        }
        else
        {
            ResultStream << "Failed to open TermServ service, Error = " << GetLastError() << endl;
			eRes = eFailedToExecute;
        }

        VERIFY(CloseServiceHandle(hServiceController));
    }
    else
    {
        ResultStream << "Failed to Open Service Controller, Error = " << GetLastError() << endl;
		eRes = eFailedToExecute;
    }

	return eRes;
}


EResult CheckVideoKeys (ostrstream &ResultStream)
{
    //    HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server\VIDEO\rdpdd","VgaCompatible",0x00000000,"\Device\Video0"
    //    HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server\VIDEO\rdpdd","\Device\Video0",0x00000000,"\REGISTRY\Machine\System\ControlSet001\Services\RDPDD\Device0"

    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\VIDEO\\rdpdd"), KEY_READ, CTSTestData::GetMachineName()))
    {
        LPTSTR str = 0;
        DWORD dwSize = 0;
        if (ERROR_SUCCESS == reg.ReadRegString(_T("VgaCompatible"), &str, &dwSize))
        {
            if (0 == _tcsicmp(str, _T("\\Device\\Video0")))
            {
                if (ERROR_SUCCESS == reg.ReadRegString(_T("\\Device\\Video0"), &str, &dwSize))
                {
                    if ((0 == _tcsicmp(str, _T("\\REGISTRY\\Machine\\System\\ControlSet001\\Services\\RDPDD\\Device0"))) ||
                        (0 == _tcsicmp(str, _T("\\REGISTRY\\Machine\\System\\CurrentControlSet\\Services\\RDPDD\\Device0"))))
                    {
						ResultStream << "Passed";
						return ePassed;
                    }
                    else
                    {
                    }
                }
                else
                {
                }
            }
            else
            {

            }

        }
        else
        {
        }
    }
    else
    {
    }

	ResultStream << "Failed";
	return eFailed;
}

TCHAR szCompName[256];
EResult GetCompName (ostrstream &ResultStream)
{
	USES_CONVERSION;
	if (!CTSTestData::GetMachineName())
	{

		DWORD dwCompName = 256;
		if (GetComputerName(szCompName, &dwCompName))
		{
			ResultStream << T2A(szCompName);
			return ePassed;
		}
		return eFailedToExecute;
	}
	else
	{
		_tcscpy(szCompName, CTSTestData::GetMachineName());
		ResultStream << T2A(CTSTestData::GetMachineName());
		return ePassed;
	}
}

bool g_bIsInDomain = false;
EResult GetDomName (ostrstream &ResultStream)
{
	USES_CONVERSION;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomainInfo = NULL;
    DWORD dwErr;

    //
    // Check if we're in a workgroup
    //
    dwErr = DsRoleGetPrimaryDomainInformation(CTSTestData::GetMachineName(),
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *) &pDomainInfo);

    if (ERROR_SUCCESS != dwErr)
	{
		ResultStream << "<Unknown Domain>";
		return eFailedToExecute;
	}

    switch (pDomainInfo->MachineRole)
    {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            ResultStream << "<Workgroup>";
			return ePassed;
		default:
			break;
    }

    if (pDomainInfo->DomainNameFlat)
	{
        ResultStream << T2A(pDomainInfo->DomainNameFlat);
		g_bIsInDomain = true;
		return ePassed;
	}
    else if (pDomainInfo->DomainNameDns)
	{
        ResultStream << T2A(pDomainInfo->DomainNameDns);
		g_bIsInDomain = true;
		return ePassed;

	}
    else
	{
        ResultStream << "<Unknown Domain>";
		return eFailedToExecute;
	}
}


EResult GetIPAddress (ostrstream &ResultStream)
{
	USES_CONVERSION;
	WCHAR wszIPAddress[128];
	//
	//get host address
	//
	WORD wVersionRequested = MAKEWORD( 1, 1 ); 
	WSADATA wsaData;
	if (0 == WSAStartup(wVersionRequested,&wsaData))
    {
        hostent *h;
        if (NULL != (h=gethostbyname ( T2A(CTSTestData::GetMachineName()) )))
        {
            in_addr *inaddr=(struct in_addr *)*h->h_addr_list;

            MultiByteToWideChar(CP_ACP,0,inet_ntoa(*inaddr),-1,wszIPAddress,128);
			ResultStream << W2A(wszIPAddress);
			return ePassed;

        }
    }

	ResultStream << "Error Getting IP";
	return eFailedToExecute;
}



EResult IsRDPNPinNetProviders (ostrstream &ResultStream)
// TCHAR *IsRDPNPinNetProviders ()
{
    TCHAR NEWORK_PROVIDER_ORDER_KEY[] = _T("SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order");
    TCHAR PROVIDER_ORDER_VALUE[]      = _T("ProviderOrder");
    TCHAR RDPNP_ENTRY[]               = _T("RDPNP");
	bool bRdpNpExists				  = false;

	// read network privider key.
	CRegistry regNetOrder;
	LPTSTR szOldValue;
	DWORD dwSize;
	if ((ERROR_SUCCESS == regNetOrder.OpenKey(HKEY_LOCAL_MACHINE, NEWORK_PROVIDER_ORDER_KEY, KEY_READ, CTSTestData::GetMachineName())) && 
	   (ERROR_SUCCESS == regNetOrder.ReadRegString(PROVIDER_ORDER_VALUE, &szOldValue, &dwSize)))
	{
		bRdpNpExists = (_tcsstr(szOldValue, RDPNP_ENTRY) != NULL);
	
	}
	else
	{
		ResultStream << "Error: Failed to Read Registry!";
		return eFailedToExecute;
	}

	if (TSEnabled () == bRdpNpExists)
	{
		ResultStream << "Passed";
		return ePassed;
	}
	else
	{
		if (bRdpNpExists)
		{
			ResultStream << "Error: RDPNP, exists in ProviderOrder, but TS is disabled!";
			return eFailed;
		}
		else
		{
			if (IsIt50TS())
			{
				// rdp np is only for 51+ so its ok if its missing for 50.
				ResultStream << "Passed";
				return ePassed;
			}
			else
			{
				ResultStream << "ERROR, RDPNP is missing from ProviderOrder";
				return eFailed;
			}
		}
	}
}


EResult IsMultiConnectionAllowed (ostrstream &ResultStream)
// TCHAR *IsMultiConnectionAllowed ()
{
	// SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon","AllowMultipleTSSessions
	CRegistry regWL;
	DWORD dwAllowMultipal;
	if ((ERROR_SUCCESS == regWL.OpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), KEY_READ, CTSTestData::GetMachineName())) &&
		(ERROR_SUCCESS == regWL.ReadRegDWord(_T("AllowMultipleTSSessions"), &dwAllowMultipal)))
	{
		if (dwAllowMultipal)
		{
			ResultStream << "Yes";
		}
		else
		{
			ResultStream << "No";
		}

		return ePassed;
	}

	if (IsIt50TS())
	{
		ResultStream <<  "Yes";
		return ePassed;
	}
	else
	{
		ResultStream <<  "ERROR, registry missing";
		return eFailedToExecute;
	}
}

EResult LogonType (ostrstream &ResultStream)
// TCHAR *LogonType ()
{
	if (!g_bIsInDomain)
	{
		CRegistry regWL;
		DWORD dwLogonType;
		if ((ERROR_SUCCESS == regWL.OpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), KEY_READ, CTSTestData::GetMachineName())) &&
			(ERROR_SUCCESS == regWL.ReadRegDWord(_T("LogonType"), &dwLogonType)))
		{
			if (dwLogonType == 0)
			{
				ResultStream <<  "Classic Gina";
			}
			else
			{
				ResultStream <<  "New Fancy";
			}
			return ePassed;
		}

		if (IsIt50TS())
		{
			ResultStream << "Classic Gina";
			return ePassed;
		}
		else
		{
			ResultStream << "ERROR, registry missing";
			return eFailedToExecute;
		}
	}
	else
	{
		ResultStream << "Classic Gina";
		return ePassed;
	}
}

EResult IsTermSrvInSystemContext (ostrstream &ResultStream)
// bool IsTermSrvInSystemContext ()
{
    USES_CONVERSION;
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermService"), KEY_READ, CTSTestData::GetMachineName()))
    {
        TCHAR *szObjectName;
        DWORD dwSize;
        if ( ERROR_SUCCESS == reg.ReadRegString( _T("ObjectName"), &szObjectName, &dwSize))
        {
            if (0 == _tcsicmp(szObjectName, _T("LocalSystem")))
            {
				ResultStream << "Passed";
				return ePassed;

            }
            else
            {
				ResultStream << "ERROR:Termsrv is set to run using (" << T2A(szObjectName) << ") context." << endl;
				return eFailed;
            }
        }
        else
        {
			ResultStream << "failed to read Objectname";
			return eFailedToExecute;
        }
    }
    else
    {
		ResultStream << "failed to open termsrv registry";
		return eFailedToExecute;
    }
}
EResult IsBetaSystem (ostrstream &ResultStream)
{
	ASSERT (IsItLocalMachine()); 
	if (IsBetaSystem())
	{
		ResultStream << "Its a beta system";
	}
	else
	{
		ResultStream << "Its a retail build";
	}

	return ePassed;
}

EResult AreRemoteLogonEnabled (ostrstream &ResultStream)
{
	CRegistry oRegTermsrv;
	if (ERROR_SUCCESS == oRegTermsrv.OpenKey(
								HKEY_LOCAL_MACHINE, 
								_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), 
								KEY_READ, 
								CTSTestData::GetMachineName()
								))
	{
		DWORD dwSize = 0;
		LPTSTR szWinstationDisabled = NULL;
		if (ERROR_SUCCESS == oRegTermsrv.ReadRegString(_T("WinStationsDisabled"), &szWinstationDisabled, &dwSize))
		{
			if (_tcscmp(_T("0"), szWinstationDisabled) == 0)
			{
				ResultStream << "Passed";
				return ePassed;
			}
			else
			{
				USES_CONVERSION;
				ResultStream << "Failed, WinStationsDisabled is (" << T2A(szWinstationDisabled) << ")";
				return eFailed;
			}
		}
		else
		{
			ResultStream << "Failed to red registry";
			return eFailedToExecute;
		}
	}
	else
	{
		ResultStream << "Failed to read registry";
		return eFailedToExecute;
	}

}

EResult IsListenerSessionPresent(ostrstream &ResultStream)
{
    PWTS_SESSION_INFO pWtsSessionInfo;
    DWORD dwCount;
    bool bReturn = false;
	

	HANDLE hServer = WTS_CURRENT_SERVER_HANDLE;
	if (CTSTestData::GetMachineName())
	{
		TCHAR szMachineName[256];
		_tcscpy(szMachineName, CTSTestData::GetMachineName());
		hServer = WTSOpenServer (szMachineName);
	}

    if (WTSEnumerateSessions(
        hServer,
        0,
        1,
        &pWtsSessionInfo,
        &dwCount
         ))
    {
        for (DWORD i = 0; i < dwCount; i++)
        {
            if (pWtsSessionInfo[i].State == WTSListen)
            {
                bReturn = true;
                break;
            }
        }

        WTSFreeMemory(pWtsSessionInfo);
    }
    else
    {
		ResultStream << "WTSEnumerateSessions failed!";
		return eFailedToExecute;
    }

	if (CTSTestData::GetMachineName())
		WTSCloseServer(hServer);

	if (bReturn)
	{
		ResultStream << "Passed!";
		return ePassed;
	}
	else
	{
		ResultStream << "Failed!";
		return eFailed;
	}
}


ULONG ulClientBuildNumber = 0xffffffff;
bool GetClientVersion(ULONG *pulClientBuildNumber)
{
	ASSERT(AreWeInsideSession());
	ASSERT(pulClientBuildNumber);
	if (ulClientBuildNumber == 0xffffffff)
	{
		LPTSTR pBuffer = NULL;
		DWORD dwBytesReturned = 0;
		if (WTSQuerySessionInformation(
			WTS_CURRENT_SERVER_HANDLE,
			WTS_CURRENT_SESSION,
			WTSClientBuildNumber,
			&pBuffer,
			&dwBytesReturned))
		{
			if (pBuffer && dwBytesReturned)
			{
				ulClientBuildNumber  =  ULONG(*pBuffer);
				*pulClientBuildNumber = ulClientBuildNumber;
				WTSFreeMemory(pBuffer);
				return true;
			}
			else
			{
				return false;
			}
			
		}
		else
		{
			return false;
		}
	}
	else
	{
		*pulClientBuildNumber = ulClientBuildNumber;
		return true;
	}
}

USHORT gusClientProtocol = 0xffff;
bool GetClientProtocol (USHORT *pusClientProtocol)
{
	ASSERT(AreWeInsideSession());
	ASSERT(pusClientProtocol);
	if (gusClientProtocol == 0xffff)
	{
		LPTSTR pBuffer = NULL;
		DWORD dwBytesReturned = 0;
		if (WTSQuerySessionInformation(
			WTS_CURRENT_SERVER_HANDLE,
			WTS_CURRENT_SESSION,
			WTSClientProtocolType,
			&pBuffer,
			&dwBytesReturned))
		{
			if (pBuffer && dwBytesReturned)
			{
				gusClientProtocol =  USHORT(*pBuffer);
				*pusClientProtocol = gusClientProtocol;
				WTSFreeMemory(pBuffer);
				return true;
			}
			else
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}
	else
	{
		*pusClientProtocol = gusClientProtocol;
		return true;
	}
}

EResult GetClientVersion(ostrstream &ResultStream)
{
	ULONG ulClientVersion;
	ASSERT(AreWeInsideSession());
	if (GetClientVersion(&ulClientVersion))
	{
		ResultStream << ulClientVersion;
		return ePassed;
	}
	else
	{
		ResultStream << "Failed to retrive client version";
		return eFailedToExecute;
	}

}

EResult GetClientProtocol(ostrstream &ResultStream)
{
	USHORT usClientProtocol;
	ASSERT(AreWeInsideSession());
	if (GetClientProtocol(&usClientProtocol))
	{
		switch (usClientProtocol)
		{
		case WTS_PROTOCOL_TYPE_CONSOLE:
			ResultStream << "WTS_PROTOCOL_TYPE_CONSOLE(" <<  usClientProtocol << ")";
			break;
		case WTS_PROTOCOL_TYPE_ICA:
			ResultStream << "WTS_PROTOCOL_TYPE_ICA(" <<  usClientProtocol << ")";
			break;
		case WTS_PROTOCOL_TYPE_RDP:
			ResultStream << "WTS_PROTOCOL_TYPE_RDP(" <<  usClientProtocol << ")";
			break;
		default:
			ResultStream << "Unknown Protocol Value(" <<  usClientProtocol << ")";
			break;
		}
		return ePassed;
	}
	else
	{
		ResultStream << "Failed to retrive client protocol";
		return eFailedToExecute;
	}
}	


EResult DoesClientSupportAudioRedirection (ostrstream &ResultStream)
{
	ASSERT(AreWeInsideSession());

	const USHORT GOOD_CLIENT_VERSION_FOR_AUDIO_REDIRECTION = 2252;
	ULONG ulClientVersion;
	USHORT usClientProtocol;
	
	if (GetClientVersion(&ulClientVersion) && GetClientProtocol(&usClientProtocol))
	{
		if (ulClientVersion >= GOOD_CLIENT_VERSION_FOR_AUDIO_REDIRECTION && usClientProtocol == WTS_PROTOCOL_TYPE_RDP)
		{
			ResultStream << "Passed";
			return ePassed;
		}
		else
		{
			if (ulClientVersion < GOOD_CLIENT_VERSION_FOR_AUDIO_REDIRECTION )
			{
				ResultStream << "Failed. You client is old, it does not support audio redirection.";
			}
			else if(usClientProtocol != WTS_PROTOCOL_TYPE_RDP)
			{
				ResultStream << "Failed. You client is not Microsoft RDP, it may not support audio redirection.";
			}
			else
			{
				ASSERT(false);
			}
			
			return eFailed;
		}
	}
	else
	{
		ResultStream  << "Failed to get client version";
		return eFailedToExecute;
	}
}

EResult DoesClientSupportPrinterRedirection (ostrstream &ResultStream)
{
	ASSERT(AreWeInsideSession());

	const USHORT GOOD_CLIENT_VERSION_FOR_PRINTER_REDIRECTION = 2100; // BUGBUG :get good value for this from tADB
	ULONG ulClientVersion;
	USHORT usClientProtocol;
	
	if (GetClientVersion(&ulClientVersion) && GetClientProtocol(&usClientProtocol))
	{
		if (ulClientVersion >= GOOD_CLIENT_VERSION_FOR_PRINTER_REDIRECTION && usClientProtocol == WTS_PROTOCOL_TYPE_RDP)
		{
			ResultStream << "Passed";
			return ePassed;
		}
		else
		{
			if (ulClientVersion < GOOD_CLIENT_VERSION_FOR_PRINTER_REDIRECTION )
			{
				ResultStream << "Failed. You client is old, it does not support printer redirection.";
			}
			else if(usClientProtocol != WTS_PROTOCOL_TYPE_RDP)
			{
				ResultStream << "Failed. You client is not Microsoft RDP, it may not support printer redirection.";
			}
			else
			{
				ASSERT(false);
			}
			
			return eFailed;
		}
	}
	else
	{
		ResultStream  << "Failed to get client version";
		return eFailedToExecute;
	}
}

EResult DoesClientSupportFileRedirection (ostrstream &ResultStream)
{
	ASSERT(AreWeInsideSession());

	const USHORT GOOD_CLIENT_VERSION_FOR_FILE_REDIRECTION = 2200; // BUGBUG :get good value for this from tADB
	ULONG ulClientVersion;
	USHORT usClientProtocol;
	
	if (GetClientVersion(&ulClientVersion) && GetClientProtocol(&usClientProtocol))
	{
		if (ulClientVersion >= GOOD_CLIENT_VERSION_FOR_FILE_REDIRECTION && usClientProtocol == WTS_PROTOCOL_TYPE_RDP)
		{
			ResultStream << "Passed";
			return ePassed;
		}
		else
		{
			if (ulClientVersion < GOOD_CLIENT_VERSION_FOR_FILE_REDIRECTION )
			{
				ResultStream << "Failed. You client is old, it does not support file redirection.";
			}
			else if(usClientProtocol != WTS_PROTOCOL_TYPE_RDP)
			{
				ResultStream << "Failed. You client is not Microsoft RDP, it may not support file redirection.";
			}
			else
			{
				ASSERT(false);
			}
			
			return eFailed;
		}
	}
	else
	{
		ResultStream  << "Failed to get client version";
		return eFailedToExecute;
	}
}



EResult DoesClientSupportClipboardRedirection (ostrstream &ResultStream)
{
	ASSERT(AreWeInsideSession());

	const USHORT GOOD_CLIENT_VERSION_FOR_FILE_REDIRECTION = 2100; // BUGBUG :get good value for this from Nadim
	ULONG ulClientVersion;
	USHORT usClientProtocol;
	
	if (GetClientVersion(&ulClientVersion) && GetClientProtocol(&usClientProtocol))
	{
		if (ulClientVersion >= GOOD_CLIENT_VERSION_FOR_FILE_REDIRECTION && usClientProtocol == WTS_PROTOCOL_TYPE_RDP)
		{
			ResultStream << "Passed";
			return ePassed;
		}
		else
		{
			if (ulClientVersion < GOOD_CLIENT_VERSION_FOR_FILE_REDIRECTION )
			{
				ResultStream << "Failed. You client is old, it does not support Clipboard redirection.";
			}
			else if(usClientProtocol != WTS_PROTOCOL_TYPE_RDP)
			{
				ResultStream << "Failed. You client is not Microsoft RDP, it may not support Clipboard redirection.";
			}
			else
			{
				ASSERT(false);
			}
			
			return eFailed;
		}
	}
	else
	{
		ResultStream  << "Failed to get client version";
		return eFailedToExecute;
	}
}

// #define TS_POLICY_SUB_TREE L"Software\\Policies\\Microsoft\\Windows NT\\Terminal Services"


bool GetWinstationInformation(WINSTATIONINFORMATION **ppInfo)
{
	ASSERT(ppInfo);
	ASSERT(AreWeInsideSession());
	static bool sbGotWinstaInfo = false;
    static WINSTATIONINFORMATION WSInfo;
	ULONG ReturnLength;

	if (sbGotWinstaInfo)
	{
		*ppInfo = &WSInfo; 
		return true;
	}

	if (WinStationQueryInformation(
			WTS_CURRENT_SERVER_HANDLE,
			WTS_CURRENT_SESSION,
			WinStationInformation,
			&WSInfo,
			sizeof(WSInfo),
			&ReturnLength
		))
	{
		sbGotWinstaInfo = true;
		*ppInfo = &WSInfo; 
		return true;
	}

	return false;
}

bool GetWinstationConfiguration (WINSTATIONCONFIG **ppInfo)
{
	ASSERT(ppInfo);
	ASSERT(AreWeInsideSession());
	static bool sbGotWinstaConfig = false;
	static WINSTATIONCONFIG WSConfig;
	ULONG ReturnLength;

	if (sbGotWinstaConfig)
	{
		*ppInfo = &WSConfig; 
		return true;
	}

	if (WinStationQueryInformation(
			WTS_CURRENT_SERVER_HANDLE,
			WTS_CURRENT_SESSION,
			WinStationConfiguration,
			&WSConfig,
			sizeof(WSConfig),
			&ReturnLength
		))
	{
		sbGotWinstaConfig = true;
		*ppInfo = &WSConfig; 
		return true;
	}

	return false;

}

EResult GetUserName(ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONINFORMATION *pWSInfo = NULL;

	if (GetWinstationInformation(&pWSInfo))
	{
		TCHAR szUser[256];
		_tcscpy(szUser, pWSInfo->Domain);
		_tcscat(szUser, _T("\\"));
		_tcscat(szUser, pWSInfo->UserName);
		ResultStream << T2A(szUser);
		return ePassed;
	}

	ResultStream << "Failed to get UserName";
	return eFailedToExecute;
}

EResult GetPolicy (ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		/*
		ResultStream << "fPromptForPassword" << pWSInfo->User.fPromptForPassword << "," << endl;
		ResultStream << "fResetBroken" << pWSInfo->User.fResetBroken << "," << endl;
		ResultStream << "fReconnectSame " << pWSInfo->User.fReconnectSame << "," << endl;
		ResultStream << "fLogonDisabled " << pWSInfo->User.fLogonDisabled << "," << endl;;
		ResultStream << "fWallPaperDisabled" << pWSInfo->User.fWallPaperDisabled << "," << endl;
		ResultStream << "fAutoClientDrives" << pWSInfo->User.fAutoClientDrives << "," << endl;
		ResultStream << "fAutoClientLpts" << pWSInfo->User.fAutoClientLpts << "," << endl;
		ResultStream << "fForceClientLptDef" << pWSInfo->User.fForceClientLptDef << "," << endl;
		ResultStream << "fRequireEncryption" << pWSInfo->User.fRequireEncryption << "," << endl;
		ResultStream << "fDisableEncryption" << pWSInfo->User.fDisableEncryption << "," << endl;
		ResultStream << "fUnused1" << pWSInfo->User.fUnused1 << "," << endl;
		ResultStream << "fHomeDirectoryMapRoot" << pWSInfo->User.fHomeDirectoryMapRoot << "," << endl;
		ResultStream << "fUseDefaultGina" << pWSInfo->User.fUseDefaultGina << "," << endl;
		*/

		/*
    ULONG fDisableCpm : 1;
for printing
    ULONG fDisableCdm : 1;
for drive
    ULONG fDisableCcm : 1;
for com port
    ULONG fDisableLPT : 1;
for lpt port
    ULONG fDisableClip : 1;
for clipboard redirection
    ULONG fDisableExe : 1;

    ULONG fDisableCam : 1;
for audio redirection

    ULONG ColorDepth : 3;
Color depth.

		*/
		ResultStream << "printer redirection = " << pWSInfo->User.fDisableCpm << endl;
		ResultStream << "drive redirection = " << pWSInfo->User.fDisableCdm << endl;
		ResultStream << "com port redirection = " << pWSInfo->User.fDisableCcm << endl;
		ResultStream << "LPT port redirection = " << pWSInfo->User.fDisableLPT << endl;
		ResultStream << "Clipboard redirection =" << pWSInfo->User.fDisableClip << endl;
		ResultStream << "fDisableExe = " << pWSInfo->User.fDisableExe << endl;
		ResultStream << "Audio Redireciton = " << pWSInfo->User.fDisableCam << endl;

		return ePassed;

	}
	else
	{
		ResultStream << "Failed to get config data";
		return eFailedToExecute;
	}
}

EResult CanRedirectPrinter (ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		if (pWSInfo->User.fDisableCpm)
		{
			ResultStream << "Failed. Printer Redirection is disabled either by Group Policy or TSCC settings.";
			return eFailed;
		}
		else
		{
			ResultStream << "Passed";
			return ePassed;
		}
	}
	else
	{
		ResultStream << "Failed to retrive config data";
		return eFailedToExecute;
	}
}

EResult CanRedirectDrives(ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		if (pWSInfo->User.fDisableCdm)
		{
			ResultStream << "Failed. Local Drive Redirection is disabled either by Group Policy or TSCC settings.";
			return eFailed;
		}
		else
		{
			ResultStream << "Passed";
			return ePassed;
		}
	}
	else
	{
		ResultStream << "Failed to retrive config data";
		return eFailedToExecute;
	}
}

EResult CanRedirectClipboard(ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		if (pWSInfo->User.fDisableClip)
		{
			ResultStream << "Failed. Clipboard redirection is disabled either by Group Policy or TSCC settings.";
			return eFailed;
		}
		else
		{
			ResultStream << "Passed";
			return ePassed;
		}
	}
	else
	{
		ResultStream << "Failed to retrive config data";
		return eFailedToExecute;
	}
}

EResult CanRedirectCom(ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		if (pWSInfo->User.fDisableCcm)
		{
			ResultStream << "Failed. Com port Redirection is disabled either by Group Policy or TSCC settings.";
			return eFailed;
		}
		else
		{
			ResultStream << "Passed";
			return ePassed;
		}
	}
	else
	{
		ResultStream << "Failed to retrive config data";
		return eFailedToExecute;
	}
}

EResult CanRedirectAudio(ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		if (pWSInfo->User.fDisableCam)
		{
			ResultStream << "Failed. Audio Redirection is disabled either by Group Policy or TSCC settings.";
			return eFailed;
        }
        else
		{
			ResultStream << "Passed";
			return ePassed;
		}
	}
	else
	{
		ResultStream << "Failed to retrive config data";
		return eFailedToExecute;
	}
}

EResult CanClientPlayAudio(ostrstream &ResultStream)
{
    EResult     rv = eFailedToExecute;
    HANDLE      hStream = NULL;
    PSNDSTREAM  Stream = NULL;

    hStream = OpenFileMapping(
                    FILE_MAP_ALL_ACCESS,
                    FALSE,
                    TSSND_STREAMNAME
                );

    if (NULL == hStream)
    {
        ResultStream << "Can't open audio stream";
        goto exitpt;
    }

    Stream = (PSNDSTREAM)MapViewOfFile(
                    hStream,
                    FILE_MAP_ALL_ACCESS,
                    0, 0,       // offset
                    sizeof(*Stream)
                    );

    if (NULL == Stream)
    {
        ResultStream << "Can't lock audio stream memory";
        goto exitpt;
    }

    if ( 0 != (TSSNDCAPS_ALIVE & Stream->dwSoundCaps) )
    {
        ResultStream << "Passed";
        rv = ePassed;
    }
    else
    {
        ResultStream << "Client doesn't have audio hardware or audio redirection is not enabled on the client side";
        rv = eFailed;
    }

exitpt:

    if ( NULL != Stream )
        UnmapViewOfFile( Stream );

    if ( NULL != hStream )
        CloseHandle( hStream );

    return rv;
}

EResult NotConsoleAudio( ostrstream &ResultStream )
{
    EResult rv = eFailedToExecute;


    if (NtCurrentPeb()->SessionId == 0 || IsItPTS())
    {
        HANDLE hConsoleAudioEvent = OpenEvent(SYNCHRONIZE, FALSE, L"Global\\WinMMConsoleAudioEvent");

        if (hConsoleAudioEvent != NULL)
        {
            DWORD status = WaitForSingleObject(hConsoleAudioEvent, 0);

            if (status == WAIT_OBJECT_0)
            {
                ResultStream << "Client audio settings are: Leave at remote computer";
                rv = eFailed;
            }
            else
            {
                ResultStream << "Passed";
                rv = ePassed;
            }

            CloseHandle(hConsoleAudioEvent);
        }
        else
        {
            ResultStream << "Failed to open Global\\WinMMConsoleAudioEvent";
    		rv = eFailedToExecute;
        }
    }
    else
    {
        ResultStream << "Not running on remote console or Whistler Professional";
        rv = ePassed;
    }

    return rv;
}

EResult CanRedirectLPT (ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		if (pWSInfo->User.fDisableLPT)
		{
			ResultStream << "Failed. LPT port Redirection is disabled either by Group Policy or TSCC settings.";
			return eFailed;
		}
		else
		{
			ResultStream << "Passed";
			return ePassed;
		}
	}
	else
	{
		ResultStream << "Failed to retrive config data";
		return eFailedToExecute;
	}
}

bool CanRunAllTests()
{
	return DoIHaveEnufPermissions();
}

bool CanRunGeneralInfo ()
{
	return DoIHaveEnufPermissions();
}
bool CanRunCantConnect ()
{
	return (CanPing() && DoIHaveEnufPermissions());
}
bool CanRunCantPrint ()
{
	return AreWeInsideSession();
}
bool CanRunCantCopyPaste ()
{
	return AreWeInsideSession();
}
bool CanRunFileRedirect ()
{
	return AreWeInsideSession();
}
bool CanRunLptRedirect ()
{
	return AreWeInsideSession();
}
bool CanRunComRedirect ()
{
	return AreWeInsideSession();
}
bool CanRunAudioRedirect ()
{
	return AreWeInsideSession();
}

TCHAR *WhyCantRunAllTests()
{
	ASSERT(!CanRunAllTests());
	if (!DoIHaveEnufPermissions())
	{
		return _T("You do not have sufficient permissions to run this test against target system.");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunAllTests");
	}
}
TCHAR *WhyCantRunGeneralInfo()
{
	ASSERT(!CanRunGeneralInfo());
	if (!DoIHaveEnufPermissions())
	{
		return _T("You do not have sufficient permissions to run this test against target system.");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunGeneralInfo");
	}
}
TCHAR *WhyCantRunCantConnect()
{
	ASSERT(!CanRunCantConnect());
	if (!CanPing())
	{
		return _T("Ping test Failed for target machine. Please make sure target machine is on the network");
	}
	if (!DoIHaveEnufPermissions())
	{
		return _T("You do not have sufficient permissions to run this test against target system.");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunCantConnect");
	}
}
TCHAR *WhyCantRunCantPrint()
{
	ASSERT(!CanRunCantPrint());
	if (!AreWeInsideSession())
	{
		return _T("For diagnosing this problem, you mush run these troubleshooter within the session. Plese create a remote desktop session to the target machine, and then troubleshoot");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunCantPrint");
	}

}
TCHAR *WhyCantRunCantCopyPaste()
{
	ASSERT(!CanRunCantCopyPaste());
	if (!AreWeInsideSession())
	{
		return _T("For diagnosing this problem, you mush run these troubleshooter within the session. Plese create a remote desktop session to the target machine, and then troubleshoot");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunCantCopyPaste");
	}
}
TCHAR *WhyCantRunFileRedirect()
{
	ASSERT(!CanRunFileRedirect());
	if (!AreWeInsideSession())
	{
		return _T("For diagnosing this problem, you mush run these troubleshooter within the session. Plese create a remote desktop session to the target machine, and then troubleshoot");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunFileRedirect");
	}
}
TCHAR *WhyCantRunLptRedirect()
{
	ASSERT(!CanRunLptRedirect());
	if (!AreWeInsideSession())
	{
		return _T("For diagnosing this problem, you mush run these troubleshooter within the session. Plese create a remote desktop session to the target machine, and then troubleshoot");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunLptRedirect");
	}
}
TCHAR *WhyCantRunComRedirect()
{
	ASSERT(!CanRunComRedirect());
	if (!AreWeInsideSession())
	{
		return _T("For diagnosing this problem, you mush run these troubleshooter within the session. Plese create a remote desktop session to the target machine, and then troubleshoot");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunComRedirect");
	}
}
TCHAR *WhyCantRunAudioRedirect()
{
	ASSERT(!CanRunAudioRedirect());
	if (!AreWeInsideSession())
	{
		return _T("For diagnosing this problem, you mush run these troubleshooter within the session. Plese create a remote desktop session to the target machine, and then troubleshoot");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunAudioRedirect");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\tsdgns.h ===
// tsdgns.h : Declaration of the CTSDiagnosis

#ifndef __TSDIAGNOSIS_H_
#define __TSDIAGNOSIS_H_

// #import "F:\nt\termsrv\setup\tsdiag\dll\obj\i386\tsdiag.dll" raw_interfaces_only, raw_native_types, no_namespace, named_guids 
// #import "tsdiag.tlb" raw_interfaces_only, raw_native_types, no_namespace, named_guids 
#include "resource.h"       // main symbols


#include "testdata.h"		// for CTSTestData 


/////////////////////////////////////////////////////////////////////////////
// CTSDiagnosis
class ATL_NO_VTABLE CTSDiagnosis : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTSDiagnosis, &CLSID_TSDiagnosis>,
	public IDispatchImpl<ITSDiagnosis, &IID_ITSDiagnosis, &LIBID_TSDIAGLib>,
	public IDispatchImpl<ITSDiagnosis2, &IID_ITSDiagnosis2, &LIBID_TSDIAGLib>
{

	enum
	{
		eFailed = 0,
		ePassed = 1,
		eUnknown = 2
	};

	
public:
	CTSDiagnosis();
	~CTSDiagnosis();

DECLARE_REGISTRY_RESOURCEID(IDR_TSDIAGNOSIS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTSDiagnosis)
	COM_INTERFACE_ENTRY(ITSDiagnosis2)
	COM_INTERFACE_ENTRY(ITSDiagnosis)
	COM_INTERFACE_ENTRY2(IDispatch, ITSDiagnosis2)
	COM_INTERFACE_ENTRY2(IDispatch, ITSDiagnosis)
END_COM_MAP()

// ITSDiagnosis

public:
	STDMETHOD(ExecuteIt)(BSTR strCommand);
	STDMETHOD(get_TestDetails)(int i, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_TestType)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_TestResult)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_TestResultString)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(RunTest)(int i);
	STDMETHOD(get_TestDescription)(int i, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_TestCount)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_TestApplicable)(int i, /*[out, retval]*/ BOOL *pbApplicable);
	STDMETHOD(put_RemoteMachineName)(BSTR newVal);
	STDMETHOD(get_SuiteApplicable) (DWORD dw, BOOL *pVal);
	STDMETHOD(get_SuiteErrorText) (DWORD dw, BSTR  *pVal);

public:
// ITSDiagnosis2
	STDMETHOD(ExecuteCommand)(BSTR strCommand);
	STDMETHOD(put_MachineName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Suites)(/*[out, retval]*/ VARIANT *pVal);

private:
	DWORD GetTotalTestCount ();
	
	bstr_t m_bstrTestResultString;
	long m_lTestResult;
	
	// CTSTestData m_TSTests;
	DWORD m_dwSuite;
/*
// ITSDiagnosis
	STDMETHOD(get_TestCount)(LONG * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_TestDescription)(INT i, BSTR * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_TestApplicable)(INT i, LONG * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(RunTest)(INT i)
	{
		return E_NOTIMPL;
	}
	STDMETHOD(get_TestResult)(LONG * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_TestDetails)(INT i, BSTR * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_SuiteApplicable)(ULONG dwSuite, LONG * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_SuiteErrorText)(ULONG dwSuite, BSTR * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}

// ITSDiagnosis2
	STDMETHOD(ExecuteCommand)(BSTR strCommand)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(MachineName)(BSTR newVal);
	{
		return E_NOTIMPL;
	}
	
	STDMETHOD(Suites)(VARIANT *pVal);
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
*/
	};

#endif //__TSDIAGNOSIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\tstst.h ===
#ifndef ___TSTST_H___
#define ___TSTST_H___

#include "tst.h"		// basic test structures.



// tests.

PFN_TEST_FUNC GetCompName;
PFN_TEST_FUNC GetDomName;
PFN_TEST_FUNC GetIPAddress;
PFN_TEST_FUNC GetProductType;
PFN_TEST_FUNC GetProductSuite ;
PFN_TEST_FUNC GetTSVersion;
PFN_TEST_FUNC IsItServer;
PFN_TEST_FUNC IsTSOClogPresent;
PFN_TEST_FUNC DidTsOCgetCompleteInstallationMessage;
PFN_TEST_FUNC IsClusteringInstalled ;
PFN_TEST_FUNC DoesProductSuiteContainTS;
PFN_TEST_FUNC DidOCMInstallTSEnable;
PFN_TEST_FUNC TSEnabled;
PFN_TEST_FUNC IsKernelTSEnable;
PFN_TEST_FUNC IsTerminalServerRegistryOk;
PFN_TEST_FUNC GetWinstationList ; 
PFN_TEST_FUNC IsTerminalServiceRunning;
PFN_TEST_FUNC IsTerminalServiceStartBitSet;
PFN_TEST_FUNC IsTermSrvInSystemContext;
PFN_TEST_FUNC IsListenerSessionPresent;
PFN_TEST_FUNC AreRemoteLogonEnabled;
PFN_TEST_FUNC IsGroupPolicyOk;
PFN_TEST_FUNC AreConnectionsAllowed;
PFN_TEST_FUNC IsRdpDrInstalledProperly;
PFN_TEST_FUNC IsRDPNPinNetProviders ;
PFN_TEST_FUNC IsMultiConnectionAllowed ;
PFN_TEST_FUNC LogonType ;
PFN_TEST_FUNC CheckVideoKeys;
PFN_TEST_FUNC GetTSMode ;
PFN_TEST_FUNC VerifyModeRegistry;
PFN_TEST_FUNC GetModePermissions;
PFN_TEST_FUNC Check_StackBinSigatures;
PFN_TEST_FUNC GetCypherStrenthOnRdpwd ;
PFN_TEST_FUNC IsBetaSystem ;
PFN_TEST_FUNC HasLicenceGracePeriodExpired ;
PFN_TEST_FUNC GetClientVersion;
PFN_TEST_FUNC DoesClientSupportAudioRedirection;
PFN_TEST_FUNC CanClientPlayAudio;
PFN_TEST_FUNC NotConsoleAudio;
PFN_TEST_FUNC DoesClientSupportPrinterRedirection;
PFN_TEST_FUNC DoesClientSupportFileRedirection;
PFN_TEST_FUNC DoesClientSupportClipboardRedirection;
PFN_TEST_FUNC GetUserName;
PFN_TEST_FUNC GetPolicy;
PFN_TEST_FUNC CanRedirectAudio;
PFN_TEST_FUNC CanRedirectCom;
PFN_TEST_FUNC CanRedirectClipboard;
PFN_TEST_FUNC CanRedirectDrives;
PFN_TEST_FUNC CanRedirectPrinter;
PFN_TEST_FUNC CanRedirectLPT;



PFN_SuiteErrorReason WhyCantRunAllTests;
PFN_SuiteErrorReason WhyCantRunGeneralInfo;
PFN_SuiteErrorReason WhyCantRunCantConnect;
PFN_SuiteErrorReason WhyCantRunCantPrint;
PFN_SuiteErrorReason WhyCantRunCantCopyPaste;
PFN_SuiteErrorReason WhyCantRunFileRedirect;
PFN_SuiteErrorReason WhyCantRunLptRedirect;
PFN_SuiteErrorReason WhyCantRunComRedirect;
PFN_SuiteErrorReason WhyCantRunAudioRedirect;

PFN_SUITE_FUNC CanRunAllTests;
PFN_SUITE_FUNC CanRunGeneralInfo;
PFN_SUITE_FUNC CanRunCantConnect;
PFN_SUITE_FUNC CanRunCantPrint;
PFN_SUITE_FUNC CanRunCantCopyPaste;
PFN_SUITE_FUNC CanRunFileRedirect;
PFN_SUITE_FUNC CanRunLptRedirect;
PFN_SUITE_FUNC CanRunComRedirect;
PFN_SUITE_FUNC CanRunAudioRedirect;



// helpers

// BOOL AreEffectiveConnectionAllowed ();
PFN_BOOL IsTSOClogPresent;
PFN_BOOL AreWeInsideSession;
PFN_BOOL IsUserRemoteAdmin;
PFN_BOOL IsItLocalServer;
PFN_BOOL IsItLocalMachine;
PFN_BOOL IsIt51TS;
PFN_BOOL IsIt50TS;
PFN_BOOL IsTerminalServiceRunning;
PFN_BOOL IsItServer;
PFN_BOOL IsAudioEnabled;
PFN_BOOL IsItRemoteConsole;






#endif // ___TSTST_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\vermak.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/////////////////////////////////////////////////////////////////////////////
// VERSION INFO
#include <ntverp.h>


#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Terminal Server Setup Test"
#define VER_INTERNALNAME_STR        "tstst"
#define VER_ORIGINALFILENAME_STR    "tstst.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\dll\testdata.cpp ===
// testdata.cpp


#include "stdafx.h"

#define ____InsideTestData____
#include "testdata.h"
#include "tstst.h"
#include "resource.h"




/////////////////////////////////////////////////////////////////////////////
// CTSDiagnosis

enum ETSTestSuite
{
	eFirstSuite = 0,
	eAllTestsSuite	= 0,
	eGeneralInformation = 1,
	eCantConnect = 2,
	eCantPrint = 3,
	eCantCopyPaste = 4,
	eCantFileRedirect = 5,
	eCantLptRedirect = 6,
	eCantComRedirect = 7,
	eCantAudioRedirect = 8,
	eLastSuite = eCantAudioRedirect,
	eSuiteCount = eLastSuite + 1
};

const DWORD ALL_TEST_SUITE_MASK	= 		(0x1 << eAllTestsSuite);
const DWORD GENERAL_SUITE_MASK	=		(0x1 << eGeneralInformation);
const DWORD CANT_CONNECT_SUITE_MASK =	(0x1 << eCantConnect);
const DWORD CANT_PRINT_SUITE_MASK =		(0x1 << eCantPrint);
const DWORD CANT_COPYPASTE_SUITE_MASK = (0x1 << eCantCopyPaste);
const DWORD CANT_FILE_REDIRECT_SUITE_MASK = (0x1 << eCantFileRedirect);
const DWORD CANT_LPT_REDIRECT_SUITE_MASK = (0x1 << eCantLptRedirect);
const DWORD CANT_COM_REDIRECT_SUITE_MASK = (0x1 << eCantComRedirect);
const DWORD CANT_AUDIO_REDIRECT_SUITE_MASK = (0x1 << eCantAudioRedirect);



#define  RemoteTABText "" \
"<HTML>\n" \
"<BODY>\n" \
"<OBJECT id=TSDiag classid=clsid:50B5F461-FDC2-40D4-B2C5-1C2EE0CDA190></OBJECT>\n" \
"Remote connections are disabled for this computer. To enable them, use <A href=javascript:ExecuteIt('control.exe%20sysdm.cpl,,5');>Remote Tab</A>\n" \
"</BODY>\n" \
"<SCRIPT LANGUAGE=javascript>\n" \
"function ExecuteIt(str)\n" \
"{\n" \
"var tsdiagObject =  new ActiveXObject(\"TSDiag.TSDiagnosis\");\n" \
"tsdiagObject.ExecuteIt(str);\n" \
"}\n" \
"</SCRIPT>\n" \
"</HTML>\n"

#define  GroupPolicyText "" \
"<HTML>\n" \
"<BODY>\n" \
"<OBJECT id=TSDiag classid=clsid:50B5F461-FDC2-40D4-B2C5-1C2EE0CDA190></OBJECT>\n" \
"Remote connections are disabled for this computer through Group Policy. you need to contact the administrator to set the right group policy. you can view current group policy configuration using <A href=javascript:ExecuteIt('gpedit.msc');>gpedit.msc</A>\n" \
"</BODY>\n" \
"<SCRIPT LANGUAGE=javascript>\n" \
"function ExecuteIt(str)\n" \
"{\n" \
"var tsdiagObject =  new ActiveXObject(\"TSDiag.TSDiagnosis\");\n" \
"tsdiagObject.ExecuteIt(str);\n" \
"}\n" \
"</SCRIPT>\n" \
"</HTML>\n"

#define  ServiceStartTypeProblemsText "" \
"<HTML>\n" \
"<BODY>\n" \
"<OBJECT id=TSDiag classid=clsid:50B5F461-FDC2-40D4-B2C5-1C2EE0CDA190></OBJECT>\n" \
"Terminal Server service Start Type is wrong on this computer. In order to work properly start Type for Terminal server must be Manual Start. If this test fails, to correct this problem open <A href=javascript:ExecuteIt('services.msc');>Services snapin</A> and change Terminal Services Service Start Type to manual start.\n" \
"</BODY>\n" \
"<SCRIPT LANGUAGE=javascript>\n" \
"function ExecuteIt(str)\n" \
"{\n" \
"var tsdiagObject =  new ActiveXObject(\"TSDiag.TSDiagnosis\");\n" \
"tsdiagObject.ExecuteIt(str);\n" \
"}\n" \
"</SCRIPT>\n" \
"</HTML>\n"

#define  ServiceContextTypeProblemsText "" \
"<HTML>\n" \
"<BODY>\n" \
"<OBJECT id=TSDiag classid=clsid:50B5F461-FDC2-40D4-B2C5-1C2EE0CDA190></OBJECT>\n" \
"Terminal Server service must be in the system context to work properly. If this test fails, use the <A href=javascript:ExecuteIt('services.msc');>Services snapin</A> to change the Terminal Server service to use System Account." \
"</BODY>\n" \
"<SCRIPT LANGUAGE=javascript>\n" \
"function ExecuteIt(str)\n" \
"{\n" \
"var tsdiagObject =  new ActiveXObject(\"TSDiag.TSDiagnosis\");\n" \
"tsdiagObject.ExecuteIt(str);\n" \
"}\n" \
"</SCRIPT>\n" \
"</HTML>\n"

TVerificationTest theTests[] =
{
	{IDS_MACHINENAME,
		NULL,
		GetCompName,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_MACHINENAME_FAILED,
		0},

	{IDS_DOMAINNAME,
		NULL,
		GetDomName,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_DOMAINNAME_FAILED,
		0
		},

	{IDS_IP_ADDRESS,
		NULL,
		GetIPAddress,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IP_ADDRESS_FAILED,
		0},

	{IDS_PRODUCTTYPE,
		IsItLocalMachine,
		GetProductType,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_PRODUCTTYPE_FAILED,
		0},

	{IDS_PRODUCTSUITE,
		IsItLocalMachine,
		GetProductSuite,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_PRODUCTSUITE_FAILED,
		0},

	{IDS_TSVERSION,
		NULL,
		GetTSVersion,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_TSVERSION_FAILED,
		0},

	{IDS_ISSERVER,
		IsIt50TS,
		IsItServer,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_ISSERVER_FAILED,
		0},

	{IDS_CLIENT_VERSION,
		AreWeInsideSession,
		GetClientVersion,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_CLIENT_VERSION_FAILED,
		0},

	{IDS_SESSION_USERNAME,
		AreWeInsideSession,
		GetUserName,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_SESSION_USERNAME_FAILED,
		0},

	{IDS_IS_TSOCLOG_PRESENT,
		IsUserRemoteAdmin,
		IsTSOClogPresent,
		ALL_TEST_SUITE_MASK |  CANT_CONNECT_SUITE_MASK,
		IDS_IS_TSOCLOG_PRESENT_FAILED,
		0},

	{IDS_DID_SETUP_FINISH,
		IsTSOClogPresent,
		DidTsOCgetCompleteInstallationMessage,
		ALL_TEST_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_DID_SETUP_FINISH_FAILED,
		0},

	{IDS_CLUSTERING_INSTALLED,
		IsIt50TS,
		IsClusteringInstalled,
		ALL_TEST_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_CLUSTERING_INSTALLED_FAILED,
		0},

	{IDS_IS_TSPRODUCT,
		IsItServer,
		DoesProductSuiteContainTS,
		ALL_TEST_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_IS_TSPRODUCT_FAILED,
		0},

	{IDS_DID_OCM_INSTALL_TS,
		IsIt50TS,
		DidOCMInstallTSEnable,
		ALL_TEST_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_DID_OCM_INSTALL_TS_FAILED,
		0},

	{IDS_IS_TS_ENABLED,
		NULL,
		TSEnabled,
		ALL_TEST_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_IS_TS_ENABLED_FAILED,
		0},

	{IDS_IS_KERNEL_TSENABLED,
		IsItLocalServer,
		IsKernelTSEnable,
		ALL_TEST_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_IS_KERNEL_TSENABLED_FAILED,
		0},

	{IDS_IS_TSREGISTRY_OK,
		NULL,
		IsTerminalServerRegistryOk,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IS_TSREGISTRY_OK_FAILED,
		0},

	{IDS_WINSTATIONS_OK,
		NULL,
		GetWinstationList,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK | GENERAL_SUITE_MASK,
		IDS_WINSTATIONS_OK_FAILED,
		0},

	{IDS_IS_TERMSRV_RUNNING,
		NULL,
		IsTerminalServiceRunning,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IS_TERMSRV_RUNNING_FAILED,
		0},

	{IDS_IS_TS_STARTBIT_OK,
		IsUserRemoteAdmin,
		IsTerminalServiceStartBitSet,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IS_TS_STARTBIT_OK_FAILED,
		0},

	{IDS_IS_TS_IN_SYSTEM_CONTEXT,
		IsUserRemoteAdmin,
		IsTermSrvInSystemContext,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IS_TS_IN_SYSTEM_CONTEXT_FAILED,
		0},

	{IDS_IS_LISTNER_PRESENT,
		IsTerminalServiceRunning,
		IsListenerSessionPresent,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IS_LISTNER_PRESENT_FAILED,
		0},

	{IDS_REMOTELOGON_ENABLED,
		NULL,
		AreRemoteLogonEnabled,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_REMOTELOGON_ENABLED_FAILED,
		0},

	{IDS_REMOTE_CONNECTION_GP,
		IsIt51TS,
		IsGroupPolicyOk,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_REMOTE_CONNECTION_GP_FAILED,
		0},

	{IDS_REMOTE_CONNECTION_LOCAL,
		IsIt51TS,
		AreConnectionsAllowed,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_REMOTE_CONNECTION_LOCAL_FAILED,
		0},

	{IDS_RDPDR_INSTALLED,
		IsItLocalMachine,
		IsRdpDrInstalledProperly,
		ALL_TEST_SUITE_MASK | CANT_PRINT_SUITE_MASK,
		IDS_RDPDR_INSTALLED_FAILED,
		0},

	{IDS_RDPNP_INSTALLED,
		IsIt51TS,
		IsRDPNPinNetProviders,
		ALL_TEST_SUITE_MASK | CANT_FILE_REDIRECT_SUITE_MASK,
		IDS_RDPNP_INSTALLED_FAILED,
		0},

	{IDS_MULTIPAL_CONNECTION_ALLOWED,
		IsIt51TS,
		IsMultiConnectionAllowed,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK,
		IDS_MULTIPAL_CONNECTION_ALLOWED_FAILED,
		0},

	{IDS_LOGON_UI,
		IsIt51TS,
		LogonType,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK,
		IDS_LOGON_UI_FAILED,
		0},
/*
	{"Are Video keys setup right?................",
		NULL,
		CheckVideoKeys,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK,
		"Just another setup test."		},
*/

	{IDS_TS_MODE,
		NULL,
		GetTSMode,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK,
		IDS_TS_MODE_FAILED,
		0},

	{IDS_IS_MODE_REGISTRYOK,
		NULL,
		VerifyModeRegistry,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK,
		IDS_IS_MODE_REGISTRYOK_FAILED,
		0},

	{IDS_PERM_MODE,
		NULL,
		GetModePermissions,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK,
		IDS_PERM_MODE_FAILED,
		0},

	{IDS_STACK_BINARIES_SIGNED,
		IsItLocalMachine,
		Check_StackBinSigatures,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_STACK_BINARIES_SIGNED_FAILED,
		0},

	{IDS_ENCRYPTION_LEVEL,
		IsUserRemoteAdmin,
		GetCypherStrenthOnRdpwd,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_ENCRYPTION_LEVEL_FAILED,
		0},

	{IDS_IS_BETA_SYSTEM,
		IsItLocalMachine,
		IsBetaSystem,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IS_BETA_SYSTEM_FAILED,
		0},

	{IDS_GRACE_PERIOD_OK,
		IsItLocalMachine,
		HasLicenceGracePeriodExpired,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_GRACE_PERIOD_OK_FAILED,
		0},

	{IDS_CLIENT_SUPPORT_AUDIO,
		AreWeInsideSession,
 		DoesClientSupportAudioRedirection,
		ALL_TEST_SUITE_MASK | CANT_AUDIO_REDIRECT_SUITE_MASK,
		IDS_CLIENT_SUPPORT_AUDIO_FAILED,
		0},

	{IDS_CLIENT_SUPPORT_PRINTER,
		AreWeInsideSession,
		DoesClientSupportPrinterRedirection,
		ALL_TEST_SUITE_MASK | CANT_PRINT_SUITE_MASK,
		IDS_CLIENT_SUPPORT_PRINTER_FAILED,
		0},

	{IDS_CLIENT_SUPPORT_FILE,
		AreWeInsideSession,
		DoesClientSupportFileRedirection ,
		ALL_TEST_SUITE_MASK | CANT_FILE_REDIRECT_SUITE_MASK,
		IDS_CLIENT_SUPPORT_FILE_FAILED,
		0},

	{IDS_CLIENT_SUPPORT_CLIPBOARD,
		AreWeInsideSession,
		DoesClientSupportClipboardRedirection,
		ALL_TEST_SUITE_MASK | CANT_COPYPASTE_SUITE_MASK,
		IDS_CLIENT_SUPPORT_CLIPBOARD_FAILED,
		0},

	{IDS_TERMSRV_CONFIG_PRINTER,
		AreWeInsideSession,
		CanRedirectPrinter,
		ALL_TEST_SUITE_MASK | CANT_PRINT_SUITE_MASK,
		IDS_TERMSRV_CONFIG_PRINTER_FAILED,
		0},

	{IDS_TERMSRV_CONFIG_AUDIO,
		AreWeInsideSession, 
		CanRedirectAudio,
		ALL_TEST_SUITE_MASK | CANT_AUDIO_REDIRECT_SUITE_MASK,
		IDS_TERMSRV_CONFIG_AUDIO_FAILED,
		0},

    {IDS_TERMSRV_CLIENT_AUDIO_ENABLED,
        IsAudioEnabled,
        CanClientPlayAudio,
        ALL_TEST_SUITE_MASK | CANT_AUDIO_REDIRECT_SUITE_MASK,
        IDS_TERMSRV_CLIENT_AUDIO_ENABLED_FAILED,
        0},

    {IDS_TERMSRV_CLIENT_AUDIO_SETTINGS,
        IsItRemoteConsole,
        NotConsoleAudio,
        ALL_TEST_SUITE_MASK | CANT_AUDIO_REDIRECT_SUITE_MASK,
        IDS_TERMSRV_CLIENT_AUDIO_SETTINGS_FAILED,
        0},

	{IDS_TERMSRV_CONFIG_COM,
		AreWeInsideSession,
		CanRedirectCom,
		ALL_TEST_SUITE_MASK | CANT_COM_REDIRECT_SUITE_MASK,
		IDS_TERMSRV_CONFIG_COM_FAILED,
		0},

	{IDS_TERMSRV_CONFIG_CLIPBOARD,
		AreWeInsideSession,
		CanRedirectClipboard,
		ALL_TEST_SUITE_MASK | CANT_COPYPASTE_SUITE_MASK,
		IDS_TERMSRV_CONFIG_CLIPBOARD_FAILED,
		0},

	{IDS_TERMSRV_CONFIG_FILE,
		AreWeInsideSession,
		CanRedirectDrives,
		ALL_TEST_SUITE_MASK | CANT_FILE_REDIRECT_SUITE_MASK,
		IDS_TERMSRV_CONFIG_FILE_FAILED,
		0},

	{IDS_TERMSRV_CONFIG_LPT,
		AreWeInsideSession,
		CanRedirectLPT,
		ALL_TEST_SUITE_MASK | CANT_LPT_REDIRECT_SUITE_MASK,
		IDS_TERMSRV_CONFIG_LPT_FAILED,
		0},

};

TTestSuite m_pSuites[eSuiteCount] = 
{
	{_T("All Tests"), CanRunAllTests, WhyCantRunAllTests, 0, NULL},
	{_T("General Information"), CanRunGeneralInfo, WhyCantRunGeneralInfo, 0, NULL},
	{_T("Cant Connect"), CanRunCantConnect, WhyCantRunCantConnect, 0, NULL},
	{_T("Cant Print"), CanRunCantPrint, WhyCantRunCantPrint, 0, NULL},
	{_T("eCantCopyPaste"), CanRunCantCopyPaste, WhyCantRunCantCopyPaste, 0, NULL},
	{_T("eCantFileRedirect"), CanRunFileRedirect, WhyCantRunFileRedirect, 0, NULL},
	{_T("eCantLptRedirect"), CanRunLptRedirect, WhyCantRunLptRedirect, 0, NULL},
	{_T("eCantComRedirect"), CanRunComRedirect, WhyCantRunComRedirect, 0, NULL},
	{_T("eCantAudioRedirect"), CanRunAudioRedirect, WhyCantRunAudioRedirect, 0, NULL}
};

CTSTestData::CTSTestData()
{
	// generate the test database for suites.

	m_lpMachineName = NULL;
	for (DWORD dwSuite = 0; dwSuite < eSuiteCount; dwSuite++)
	{
		// get the test count for this suite.
		DWORD dwThisSuiteMask = 0x1  << dwSuite;
		m_pSuites[dwSuite].dwTestCount = 0;
		for (DWORD dwTest = 0; dwTest < sizeof(theTests) / sizeof(theTests[0]); dwTest++)
		{
			// if this test is for the given suite.
			if (theTests[dwTest].SuiteMask & dwThisSuiteMask)
			{
				m_pSuites[dwSuite].dwTestCount++;
			}
		}

		if (m_pSuites[dwSuite].dwTestCount > 0)
		{
			m_pSuites[dwSuite].aiTests = new int[m_pSuites[dwSuite].dwTestCount];
		}

		//
		// now fill up the test array with test indexes.
		//
		for (DWORD dwTest = 0, dwTestIndex = 0; dwTest < sizeof(theTests) / sizeof(theTests[0]); dwTest++)
		{
			// if this test is for the given suite.
			if (theTests[dwTest].SuiteMask & dwThisSuiteMask)
			{
				ASSERT(dwTestIndex < m_pSuites[dwSuite].dwTestCount);
				m_pSuites[dwSuite].aiTests[dwTestIndex] = dwTest;
				dwTestIndex++;
			}
		}

	}
}

CTSTestData::~CTSTestData()
{
	for (DWORD dwSuite = 0; dwSuite < eSuiteCount; dwSuite++)
	{
		if (m_pSuites[dwSuite].aiTests)
			delete [] m_pSuites[dwSuite].aiTests;
	}

	if (m_lpMachineName)
		delete [] m_lpMachineName;
}


DWORD CTSTestData::GetSuiteCount () const
{
	return eSuiteCount;
}

LPCTSTR CTSTestData::GetSuiteName	(DWORD dwSuite) const
{
	return m_pSuites[dwSuite].szSuiteName;
}



DWORD CTSTestData::GetTestCount (DWORD dwSuite) const
{
	ASSERT(m_pSuites);
	ASSERT( dwSuite < GetSuiteCount() );
	return m_pSuites[dwSuite].dwTestCount;
}

PTVerificationTest CTSTestData::GetTest (DWORD dwSuite, DWORD dwTestNumber) const
{

	ASSERT(m_pSuites);
	ASSERT( dwSuite < GetSuiteCount() );
	ASSERT( dwTestNumber < GetTestCount(dwSuite) );

	return &(theTests[m_pSuites[dwSuite].aiTests[dwTestNumber]]);
}

LPTSTR CTSTestData::m_lpMachineName = NULL;
BOOL CTSTestData::SetMachineName	(LPCTSTR lpMachineName)
{
	if (m_lpMachineName)
	{
		delete [] m_lpMachineName;
		m_lpMachineName = NULL;
	}

	

	if (lpMachineName && _tcslen(lpMachineName) > 1)
	{
		m_lpMachineName = new TCHAR[_tcslen(lpMachineName) + 1 + 2];
		if (!m_lpMachineName)
		{
			return FALSE;
		}
		_tcscpy(m_lpMachineName, _T("\\\\"));
		_tcscat(m_lpMachineName, lpMachineName);
		
	}

	return TRUE;
}

LPCTSTR CTSTestData::GetMachineNamePath  ()
{
	return m_lpMachineName;
}

LPCTSTR CTSTestData::GetMachineName  ()
{
	if (m_lpMachineName)
		return m_lpMachineName + 2;
	else
		return NULL;
}

bool CTSTestData::CanExecuteSuite (DWORD dwSuite) const
{
	ASSERT(m_pSuites);
	ASSERT( dwSuite < GetSuiteCount() );
	return (*m_pSuites[dwSuite].pfnCanRunSuite)();
}
LPCTSTR CTSTestData::GetSuiteErrorText (DWORD dwSuite) const
{
	ASSERT(m_pSuites);
	ASSERT( dwSuite < GetSuiteCount() );
	ASSERT(!CanExecuteSuite(dwSuite));
	return (*m_pSuites[dwSuite].pfnSuiteErrorReason)();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( EventLogUtilities )
EXTERN_PROXY_FILE( eventutil )
EXTERN_PROXY_FILE( evntutl )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( EventLogUtilities ),
  REFERENCE_PROXY_FILE( eventutil ),
  REFERENCE_PROXY_FILE( evntutl ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\dlldatax.c ===
// wrapper for dlldata.c
#pragma warning( disable : 4206 )
#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "EventLogUtilities_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__3E6D10EE_E066_49F3_B1D1_59401B4AD3DC__INCLUDED_)
#define AFX_DLLDATAX_H__3E6D10EE_E066_49F3_B1D1_59401B4AD3DC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__3E6D10EE_E066_49F3_B1D1_59401B4AD3DC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\event.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Event.h : Declaration of the CEvent

#ifndef __EVENT_H_
#define __EVENT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CEvent
class ATL_NO_VTABLE CEvent : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEvent, &CLSID_Event>,
	public ISupportErrorInfo,
	public IDispatchImpl<IEvent, &IID_IEvent, &LIBID_EventLogUtilities>
{
private:
	long m_EventID; // Note:  EventID is displayed as WORD instead of DWORD in the System's EventViewer
	long m_EventCategory; // origionally a WORD (unsigned short)
	eEventType m_EventType;
	_bstr_t m_Description;
	_bstr_t m_SourceName;
	_bstr_t m_EventLogName;
	_bstr_t m_ComputerName;
	_bstr_t m_UserName;
	DATE m_OccurrenceTime;
	BYTE* m_pSid;
	SAFEARRAY* m_pDataArray;
	wchar_t** m_ppArgList;
	unsigned int m_NumberOfStrings;

	// Internal only functions
	HRESULT CheckDefaultDescription(wchar_t** Arguments);
	HRESULT ParseEventBlob(EVENTLOGRECORD* pEventStructure);
	HRESULT SetUser();
public:
	CEvent() : m_EventID(0), m_EventCategory(0), m_OccurrenceTime(0), m_pSid(NULL), m_pDataArray(NULL), m_NumberOfStrings(0), m_ppArgList(NULL)
	{
		m_Description = "";
		m_SourceName = "";
		m_ComputerName = "";
		m_UserName = "";
		m_EventLogName = "";
	}

	~CEvent()
	{
		unsigned int i;
		if (m_pSid) delete []m_pSid;
		if (m_ppArgList)
		{
			for (i=0;i<m_NumberOfStrings;i++)
					delete [] m_ppArgList[i];
				delete []m_ppArgList;
		}
//		if (m_pDataArray) SafeArrayDestroy(m_pDataArray);  // causes access violation
	}

	// Internal functions
	HRESULT Init(EVENTLOGRECORD* pEventStructure, const LPCTSTR szEventLogName);

DECLARE_REGISTRY_RESOURCEID(IDR_EVENT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEvent)
	COM_INTERFACE_ENTRY(IEvent)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IEvent
	STDMETHOD(get_EventID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_EventType)(/*[out, retval]*/ eEventType *pVal);
	STDMETHOD(get_Category)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Source)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_User)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_OccurrenceTime)(/*[out, retval]*/ DATE *pVal);
	STDMETHOD(get_ComputerName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Data)(/*[out, retval]*/ VARIANT *pVal);
};

#endif //__EVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\events.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Events.cpp : Implementation of CEvents
#include "stdafx.h"
#include "Evntutl.h"
#include "Events.h"

/////////////////////////////////////////////////////////////////////////////
// CEvents

STDMETHODIMP CEvents::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IEvents
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*
	Function:  get_Count
	Inputs:  empty long
	Outputs:  number events available
	Purpose:  Allows user to determine the number of Events in a Log
*/
STDMETHODIMP CEvents::get_Count(long *pVal)
{
	HRESULT hr = S_OK;

	if (!GetNumberOfEventLogRecords(m_hLog, &m_Count)) hr = HRESULT_FROM_WIN32(GetLastError());

	if (pVal) *pVal = m_Count;
	else hr = E_POINTER;

	return hr;
}

/*
	Function: get_NewEnum
	Inputs:   empty IUnknown pointer
	Outputs:  IEnumVariant object filled with Event objects
	Purpose:  Allows user to use For Each syntax to do operations on all Events in a log
	Notes:    Events are returned oldest first
*/
STDMETHODIMP CEvents::get__NewEnum(LPUNKNOWN *pVal)
{
	HRESULT hr = S_OK;

	if (NULL == pVal) return E_POINTER;
	*pVal = NULL;

	if (SUCCEEDED(hr))
	{
		EnumVar* pEVar = new EnumVar;

		hr = pEVar->Init(&m_pVector[0], &m_pVector[m_Count], NULL, AtlFlagCopy);
		if (SUCCEEDED(hr))
			hr = pEVar->QueryInterface(IID_IEnumVARIANT, (void**) pVal);

		if FAILED(hr)
			if (pEVar) delete pEVar;
	}

	return hr;
}

/*
	Function: get_Item
	Inputs:   Valid integer Index , empty Variant
	Outputs:  variant dispatch pointer to an Event object
	Purpose:  Allows user to access individual EventLogs by number
	Notes:    Events are returned oldest first
*/
STDMETHODIMP CEvents::get_Item(long Index, VARIANT *pVal)
{
	HRESULT hr = S_OK;

	// perform checks and exit if there is a problem
	if (NULL == pVal) return E_POINTER;
	if ((Index < 1) || (Index > long(m_Count))) return E_INVALIDARG;

	VariantInit(pVal);
	pVal->vt = VT_UNKNOWN;
	pVal->punkVal = NULL;
	VariantCopy(pVal, &m_pVector[Index-1]);

	return hr;
}

/*
	Function:  Init
	Inputs:  none
	Outputs:  HRESULT indicating what error if any occured
	Purpose:  Prepares a variant array filled with Log objects for 3 default logs.
*/
HRESULT CEvents::Init(HANDLE hLog, const LPCTSTR szEventLogName)
{
	HRESULT hr = S_OK;
	CComObject<CEvent>* pEvent;
	BYTE* pBuffer;
	EVENTLOGRECORD* pEventStructure;
	const unsigned long MaxEventLength = 80000;
	DWORD BytesRead = 0, BytesRequired = 0;
	unsigned long i = 0;

	if (hLog)
	{
		m_hLog = hLog;
		GetNumberOfEventLogRecords(m_hLog, &m_Count);
		if (m_pVector != NULL) delete []m_pVector;
		m_pVector = new CComVariant[m_Count];
		if (m_pVector)
		{
			pBuffer = new BYTE [MaxEventLength];
			if (pBuffer)
			{
				pEventStructure = (EVENTLOGRECORD*) pBuffer;
				// This loop fills a buffer with EventLog structures until there are no more to read
				while (ReadEventLog(m_hLog, EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ, 
								 0, pEventStructure, MaxEventLength, &BytesRead, &BytesRequired))
				{
					// This inner loop should cut the buffer into individual EventLog structures
					// and fill the Variant array with the resulting Event objects.
					// It should finish when all the bytes read have been processed.
					while (BytesRead > 0)
					{
						// create a CEvent object
						hr = CComObject<CEvent>::CreateInstance(&pEvent);
						if (SUCCEEDED(hr))
						{
							hr = pEvent->Init(pEventStructure, szEventLogName);
							if (SUCCEEDED(hr))
							{
								// get IDispatch pointer and set the return pointer
								CComVariant& var = m_pVector[i];
								var.vt = VT_DISPATCH;
								hr = pEvent->QueryInterface(IID_IDispatch, (void**)&var.pdispVal);
								if (FAILED(hr)) BytesRead = 0; // dont do any more processing
								i++;
							}
							else BytesRead = 0;  // dont do any more processing
						}
						else BytesRead = 0;
						BytesRead -= pEventStructure->Length;  // decrement inner loop
						// set pEventStructure to the next EventLog structure
						pEventStructure = (EVENTLOGRECORD *)((BYTE*) pEventStructure + pEventStructure->Length);
					}
					if (FAILED(hr)) break;  // dont do any more processing
					pEventStructure = (EVENTLOGRECORD*) pBuffer;
				}
					delete [] pBuffer;
			}
			else hr = E_OUTOFMEMORY;
		}
		else hr = E_OUTOFMEMORY;
	}
	else hr = E_HANDLE;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\events.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Events.h : Declaration of the CEvents

#ifndef __EVENTS_H_
#define __EVENTS_H_

#include "resource.h"       // main symbols
#include "Event.h"

/////////////////////////////////////////////////////////////////////////////
// CEvents
class ATL_NO_VTABLE CEvents : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CEvents, &CLSID_Events>,
	public ISupportErrorInfo,
	public IDispatchImpl<IEvents, &IID_IEvents, &LIBID_EventLogUtilities>
{
private:
	unsigned long m_Count;
	CComVariant* m_pVector;
	HANDLE m_hLog;

public:
	CEvents() : m_Count(0), m_pVector(NULL), m_hLog(NULL)
	{
	}

	~CEvents()
	{
		if (m_pVector) delete [] m_pVector;
	}

	// Internal functions
	HRESULT Init(HANDLE hLog, const LPCTSTR szEventLogName);  // requires a vaild Log handle to be set

DECLARE_REGISTRY_RESOURCEID(IDR_EVENTS)
DECLARE_NOT_AGGREGATABLE(CEvents)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEvents)
	COM_INTERFACE_ENTRY(IEvents)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IEvents
	STDMETHOD(get_Item)(/*[in]*/ long Index, /*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
};

#endif //__EVENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\log.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Log.cpp : Implementation of CLog
#include "stdafx.h"
#include "Evntutl.h"
#include "Log.h"

/////////////////////////////////////////////////////////////////////////////
// CLog

STDMETHODIMP CLog::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ILog
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*
	Function:  get_Events
	Inputs:  empty variant pointer
	Outputs:  variant dispatch pointer to a filled Events collection
	Purpose:  provide access to IEvents interface, open an event log if not already open
	Notes:  This op is very expensive when calling m_pEvents->Init()
*/
STDMETHODIMP CLog::get_Events(VARIANT *pVal)
{
	HRESULT hr = S_OK;

	VariantInit(pVal);

	IDispatch* pDisp;
	m_pEvents->QueryInterface (IID_IDispatch, (void**) &pDisp);
	pVal->vt = VT_DISPATCH;
	pVal->pdispVal = pDisp;

	// Need to open the log before users can start retreiving events.
	if (!m_Name) hr = E_INVALIDARG;
	else
	{
		if (!m_hLog)  // if removed, calling Log.Events will refresh the collection
		{
			m_hLog = OpenEventLog(m_ServerName, m_Name);
			if (m_hLog) m_pEvents->Init(m_hLog, m_Name);
			else hr = E_HANDLE;
		}
	}

	return hr;
}

/*
	Function:  get_Name
	Inputs:  empty BSTR
	Outputs:  BSTR containing the name of the EventLog
	Purpose:  Allows user to access the name of the active EventLog
*/
STDMETHODIMP CLog::get_Name(BSTR *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_Name.copy();
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_Server
	Inputs:  empty BSTR
	Outputs:  BSTR containing the name of the server for the EventLog
	Purpose:  Allows user to access the name of the active Server
*/
STDMETHODIMP CLog::get_Server(BSTR *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_ServerName.copy();
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  put_Server
	Inputs:  BSTR containing the name of the server for the EventLog
	Outputs:  HRESULT showing error code in case of failure, does not change input
	Purpose:  Allows user to alter the name of the active Server
*/
STDMETHODIMP CLog::put_Server(BSTR newVal)
{
	m_ServerName = newVal;

	return S_OK;
}

/*
	Function:  Clear
	Inputs:  none
	Outputs:  HRESULT showing error code in case of failure
	Purpose:  Allows user to wipe EventLog clean
	Note:  The function does NOT backup the EventLog first
*/
STDMETHODIMP CLog::Clear()
{
	HRESULT hr = S_OK;

	if (!m_hLog) m_hLog = OpenEventLog(m_ServerName, m_Name);
	if (m_hLog)
	{
		if (ClearEventLog(m_hLog, NULL)) m_hLog = NULL;
		else hr = E_FAIL;
	}
	else hr = E_HANDLE;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\event.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Event.cpp : Implementation of CEvent

#include "stdafx.h"
#include "Evntutl.h"
#include "Event.h"

/////////////////////////////////////////////////////////////////////////////
// CEvent

STDMETHODIMP CEvent::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IEvent
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*
	Function:  get_Server
	Inputs:  empty BSTR
	Outputs:  BSTR containing the Description for the Event (calculated)
	Purpose:  Allows user to access the description for an Event
*/
STDMETHODIMP CEvent::get_Description(BSTR *pVal)
{
	HRESULT hr = S_OK;
	unsigned int i;

	if (pVal)
	{
		if (m_Description.length() == 0)
		{
			hr = CheckDefaultDescription(m_ppArgList);
			if (SUCCEEDED(hr)) *pVal = m_Description.copy();

			if (m_ppArgList)
			{
				// delete the ArgList
				for (i=0;i<m_NumberOfStrings;i++)
					delete [] m_ppArgList[i];
				delete []m_ppArgList;
				m_ppArgList = NULL;
			}
		}
	}
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_Source
	Inputs:  empty BSTR
	Outputs:  BSTR containing the name of the component which caused the Event
	Purpose:  Allows user to access the name of the component which caused the Event
*/
STDMETHODIMP CEvent::get_Source(BSTR *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_SourceName.copy();
	else hr = E_POINTER;

	return hr;
}


/*
	Function: get_User
	Inputs:   empty BSTR
	Outputs:  BSTR containing the name and domain of the user who caused the Event
	Purpose:  Allows user to access the name and domain of the user who caused the Event
	Notes:    The first time this function is called, it will do a SID lookup
*/
STDMETHODIMP CEvent::get_User(BSTR *pVal)
{
	HRESULT hr = S_OK;

	if (pVal)
	{
		if (m_UserName.length() == 0)
		{
			SetUser();
		}
		*pVal = m_UserName.copy();
	}
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_ComputerName
	Inputs:  empty BSTR
	Outputs:  BSTR containing the name of the server on which the Event occured
	Purpose:  Allows user to access the name of the the server on which the Event occured
*/
STDMETHODIMP CEvent::get_ComputerName(BSTR *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_ComputerName.copy();
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_EventID
	Inputs:  empty long
	Outputs:  long containing the ID of the Event
	Purpose:  Allows user to access the ID which can be used to lookup a message for the event
	Notes:    Since description is provided, this function is not very useful, however,
			  it is provided for completeness
*/
STDMETHODIMP CEvent::get_EventID(long *pVal)
{
	HRESULT hr = S_OK;
//	m_EventID = m_EventID & 0xFFFF;  // The EventLog viewer uses this mask before displaying ID's
	if (pVal) *pVal = m_EventID;
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_Category
	Inputs:  empty long
	Outputs:  long containing the category ID for the event
	Purpose:  Allows user to access the category ID for the event
*/
STDMETHODIMP CEvent::get_Category(long *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_EventCategory;
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_EventType
	Inputs:  empty enumeration
	Outputs:  enumeration containing the type of event that occured
	Purpose:  Allows user to access the type of event that occured
*/
STDMETHODIMP CEvent::get_EventType(eEventType *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_EventType;
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_OccurenceTime
	Inputs:  empty DATE structure
	Outputs:  DATE structure containing the local system time when the event occured
	Purpose:  Allows user to access the time when the event occured
*/
STDMETHODIMP CEvent::get_OccurrenceTime(DATE *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_OccurrenceTime;
	else hr = E_POINTER;

	return hr;
}

/*
	Function: get_Data
	Inputs:   empty variant
	Outputs:  variant containing an array of bytes
	Purpose:  Allows user to access the data set by the event.  This may or may not be set,
			  and is frequently not useful
*/
STDMETHODIMP CEvent::get_Data(VARIANT *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) 
	{
		pVal->vt = VT_ARRAY | VT_UI1;
		pVal->parray = m_pDataArray;
	}
	else hr = E_POINTER;

	return hr;
}

/*
	Function: Init
	Inputs:   pointer to an EVENTLOGRECORD structure
	Outputs:  does not modify input
	Purpose:  fill Event object properties which do not require loading external libs
*/
HRESULT CEvent::Init(EVENTLOGRECORD* pEventStructure, const LPCTSTR szEventLogName)
{
	HRESULT hr = S_OK;
	m_EventLogName = szEventLogName;
	hr = ParseEventBlob(pEventStructure);

	return hr;
}

/*
	Function: ParseEventBlob
	Inputs:   pointer to an EVENTLOGRECORD structure
	Outputs:  does not modify input
	Purpose:  Parse an EVENTLOGRECORD and set the appropriate internal structures of Event
*/
HRESULT CEvent::ParseEventBlob(EVENTLOGRECORD* pEventStructure)
{
	HRESULT hr = S_OK;
	wchar_t* wTempString;
	BYTE* pSourceName;
	BYTE* pComputerName;
	SAFEARRAYBOUND rgsabound[1];
	ULONG StringsToRetrieve = 0, CharsRead = 0, i = 0;
	long Index[1];
	BYTE pTemp;

	m_EventID = pEventStructure->EventID;
	m_EventCategory = pEventStructure->EventCategory;

	switch (pEventStructure->EventType)
	{
	case EVENTLOG_ERROR_TYPE:
		m_EventType = ErrorEvent;
		break;
	case EVENTLOG_WARNING_TYPE:
		m_EventType = WarningEvent;
		break;
	case EVENTLOG_INFORMATION_TYPE:
		m_EventType = InformationEvent;
		break;
	case EVENTLOG_AUDIT_SUCCESS:
		m_EventType = AuditSuccess;
		break;
	case EVENTLOG_AUDIT_FAILURE:
		m_EventType = AuditFailure;
		break;
	default:
		hr = E_FAIL;
	}

	// parse strings from the memory blob
	// Set source name
	pSourceName = (BYTE*) &(pEventStructure->DataOffset) + sizeof(pEventStructure->DataOffset);
	wTempString = (wchar_t*)pSourceName;
	m_SourceName = wTempString;
	// Set computer name
	pComputerName = (BYTE*)pSourceName + ((wcslen(wTempString)+1) * sizeof(wchar_t));
	wTempString = (wchar_t*)pComputerName;
	m_ComputerName = wTempString;

	// Set SID
	if ((pEventStructure->StringOffset - pEventStructure->UserSidOffset) != 0)
	{
		m_pSid = new BYTE[pEventStructure->UserSidLength];  // scope = CEvent, deleted in ~CEvent() or SetSID() whichever comes first
        if (m_pSid != NULL) {
            for (i = 0; i<pEventStructure->UserSidLength; i++)
                m_pSid[i] = (BYTE)(*((BYTE*)pEventStructure + pEventStructure->UserSidOffset + i * sizeof(BYTE)));
        }
	}

	// Set Occurence time
	// this code is copied from MSDN
	FILETIME FileTime, LocalFileTime;
    SYSTEMTIME SysTime;
    __int64 lgTemp;
    __int64 SecsTo1970 = 116444736000000000;

    lgTemp = Int32x32To64(pEventStructure->TimeGenerated,10000000) + SecsTo1970;

    FileTime.dwLowDateTime = (DWORD) lgTemp;
    FileTime.dwHighDateTime = (DWORD)(lgTemp >> 32);

    FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
    FileTimeToSystemTime(&LocalFileTime, &SysTime);
	if(!SystemTimeToVariantTime(&SysTime, &m_OccurrenceTime)) hr = GetLastError();

	// Set Data (create and fill a SafeArray)
	if (pEventStructure->DataLength>0)
	{
		rgsabound[0].lLbound = 0;
		rgsabound[0].cElements = pEventStructure->DataLength;
		m_pDataArray = SafeArrayCreate(VT_UI1, 1, rgsabound);

		for (i=0;i<pEventStructure->DataLength;i++)
		{
			Index[0] = i;
			pTemp = (BYTE) (pEventStructure->DataOffset + i * sizeof(BYTE));
			hr = SafeArrayPutElement(m_pDataArray, Index, &pTemp);
			if (FAILED(hr)) i = pEventStructure->DataLength;
		}
	}

	// Set the description
	m_Description = "";
	if (m_SourceName.length() != 0)
	{
		// prepare the ArgList
		m_NumberOfStrings = pEventStructure->NumStrings;
		m_ppArgList = new wchar_t*[m_NumberOfStrings];  // scope = CEvent, deleted when ~CEvent or get_Description is called whichever is first
		for (i=0;i<m_NumberOfStrings;i++)
			m_ppArgList[i] = new wchar_t[(pEventStructure->DataOffset - pEventStructure->StringOffset)]; // can't be larger than the length of all the strings we got
		for (i=0;i<m_NumberOfStrings;i++)
		{
			wTempString = (wchar_t*) (((BYTE*)(pEventStructure)) + pEventStructure->StringOffset + CharsRead * sizeof(wchar_t));
			wcscpy(m_ppArgList[i], wTempString);
			CharsRead = CharsRead + wcslen(wTempString) + 1; // + 1 for the null
		}
	}
	else  // if there is no module to load a default description, just put all the string args in the description
	{
		StringsToRetrieve = pEventStructure->NumStrings;
		while (StringsToRetrieve > 0)
		{
			wTempString = (wchar_t*) (((BYTE*)(pEventStructure)) + pEventStructure->StringOffset + CharsRead * sizeof(wchar_t));
			m_Description = m_Description + " " + wTempString;
			CharsRead = CharsRead + wcslen(wTempString) + 1; // + 1 for the null
			StringsToRetrieve--;
		}
	}

	return hr;
}

/*
	Function: CheckDefaultDescription
	Inputs:   pointer pointer to a wide character
	Outputs:  does not modify input
	Purpose:  format a message from an EventID, set of input strings, and a source module
*/
HRESULT CEvent::CheckDefaultDescription(wchar_t** Arguments)
{
	HRESULT hr = S_OK;
	BYTE* wMessagePath = NULL;
	ULONG BufferSize = 40000;
	ULONG* lPathLength = NULL;
	wchar_t* wOrigionalPath = NULL;
	wchar_t* wExpandedPath = NULL;
	wchar_t* pBuffer = NULL;
	_bstr_t btRegKey;
	_bstr_t btTempString;
	HMODULE hiLib;
	HKEY hKey;
    try{
        lPathLength = new ULONG;
        if (lPathLength)
        {
            *lPathLength = 256*2;
            wMessagePath = new BYTE[*lPathLength];
            if (wMessagePath)
            {
                // get registry value for Source module path
                btRegKey = "SYSTEM\\CurrentControlSet\\Services\\Eventlog\\" + m_EventLogName;
                btRegKey = btRegKey + "\\";
                btRegKey = btRegKey + m_SourceName;
                hr = RegOpenKey(HKEY_LOCAL_MACHINE, btRegKey, &hKey);
                if (hKey)
                {
                    hr = RegQueryValueEx(hKey, L"EventMessageFile", NULL, NULL, wMessagePath, lPathLength);
                    if (hr == 0)
                    {
                        wOrigionalPath = (wchar_t*) wMessagePath;
                        wExpandedPath = new wchar_t[(int)*lPathLength];
                        if (wExpandedPath)
                        {
                            ExpandEnvironmentStrings(wOrigionalPath, wExpandedPath, *lPathLength);
                            btTempString = wExpandedPath;

                            // open the Source module
                            hiLib = LoadLibraryEx(btTempString, NULL, LOAD_LIBRARY_AS_DATAFILE);
                            hr = GetLastError();
                            if (hiLib)
                            {
                                pBuffer = new wchar_t[BufferSize];
                                if (pBuffer)
                                {
                                    SetLastError(0);
                                    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_FROM_SYSTEM | 
                                                  FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                                  hiLib, m_EventID, 0, pBuffer, BufferSize,
                                                  reinterpret_cast<va_list*>(Arguments));
                                    hr = HRESULT_FROM_WIN32(GetLastError());
                                    m_Description = m_Description + pBuffer;

                                    delete []pBuffer;
                                    pBuffer = NULL;
                                }
                                else hr = E_OUTOFMEMORY;

                                FreeLibrary(hiLib);
                            }
                            delete [] wExpandedPath;
                            wExpandedPath = NULL;
                        }
                        else hr = E_OUTOFMEMORY;
                    }
                    else hr = HRESULT_FROM_WIN32(hr);

                    RegCloseKey(hKey);
                }
                else hr = HRESULT_FROM_WIN32(hr);

                delete []wMessagePath;
                wMessagePath = NULL;
            }
            else hr = E_OUTOFMEMORY;

            delete lPathLength;
            lPathLength = NULL;
        }
        else hr = E_OUTOFMEMORY;

    } catch(...){
        if (lPathLength != NULL) {
            delete lPathLength;
        }
        if (wMessagePath != NULL) {
            delete []wMessagePath;
        }
        if (wExpandedPath != NULL) {
            delete [] wExpandedPath;
        }
        if (pBuffer != NULL) {
            delete []pBuffer;
        }
    }

	return hr;
}

/*
	Function:  SetUser
	Inputs:  none
	Outputs:  HRESULT indicating what error if any occured
	Purpose:  finds alias and domain for a given SID
*/
HRESULT CEvent::SetUser()
{
	HRESULT hr = S_OK;
	SID_NAME_USE SidNameUse;
	wchar_t* wUserName;
	wchar_t* wDomainName;
	SID* pSid;
	unsigned long UserNameLength = 256;

	// Set user name and sid
	if (m_pSid !=NULL)
	{
		pSid = (SID*)m_pSid;
		wUserName = new wchar_t[UserNameLength];
		if (wUserName)
		{
			wDomainName = new wchar_t[UserNameLength];
			if (wDomainName)
			{
				m_UserName = "";
				if (LookupAccountSid(NULL, pSid, wUserName, &UserNameLength, wDomainName,
					 &UserNameLength, &SidNameUse))
					 m_UserName = m_UserName + wDomainName + L"\\" + wUserName;
				else hr = HRESULT_FROM_WIN32(GetLastError());
				delete []wDomainName;
			}
			else hr = E_OUTOFMEMORY;
			delete []wUserName;
		}
		else hr = E_OUTOFMEMORY;
		delete []m_pSid;
		m_pSid = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\evntutl.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// EventLogUtilities.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for EventLogUtilities.idl by adding the following
//      files to the Outputs.
//          EventLogUtilities_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f EventLogUtilitiesps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "Evntutl.h"
#include "dlldatax.h"

#include "EvntUtl_i.c"
#include "View.h"
// #include "Logs.h"
#include "Log.h"
// #include "Events.h"
#include "Event.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_View, CView)
// OBJECT_ENTRY(CLSID_Logs, CLogs)
OBJECT_ENTRY(CLSID_Log, CLog)
// OBJECT_ENTRY(CLSID_Events, CEvents)
OBJECT_ENTRY(CLSID_Event, CEvent)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_EventLogUtilities);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	MessageBox(NULL, TEXT("Registering eventutl.dll"), TEXT("evntutl.dll"), MB_OK);
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\log.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Log.h : Declaration of the CLog

#ifndef __LOG_H_
#define __LOG_H_

#include "resource.h"       // main symbols
#include "Events.h"

/////////////////////////////////////////////////////////////////////////////
// CLog
class ATL_NO_VTABLE CLog : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CLog, &CLSID_Log>,
	public ISupportErrorInfo,
	public IDispatchImpl<ILog, &IID_ILog, &LIBID_EventLogUtilities>
{
private:
	CComObject<CEvents>* m_pEvents;
	HANDLE m_hLog;

public:
	_bstr_t m_Name;
	_bstr_t m_ServerName;

	CLog() : m_hLog(NULL)
	{
		m_pEvents = new CComObject<CEvents>;
		if (m_pEvents)
			m_pEvents->AddRef();
	}

	~CLog()
	{
		if (m_hLog)	CloseEventLog(m_hLog);
		if (m_pEvents) m_pEvents->Release();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_LOG)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLog)
	COM_INTERFACE_ENTRY(ILog)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ILog: Interface methods and properties
	STDMETHOD(get_Events)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_Server)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Server)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(Clear)();
};

#endif //__LOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\evntutl.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for evntutl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __evntutl_h__
#define __evntutl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IView_FWD_DEFINED__
#define __IView_FWD_DEFINED__
typedef interface IView IView;
#endif 	/* __IView_FWD_DEFINED__ */


#ifndef __ILogs_FWD_DEFINED__
#define __ILogs_FWD_DEFINED__
typedef interface ILogs ILogs;
#endif 	/* __ILogs_FWD_DEFINED__ */


#ifndef __ILog_FWD_DEFINED__
#define __ILog_FWD_DEFINED__
typedef interface ILog ILog;
#endif 	/* __ILog_FWD_DEFINED__ */


#ifndef __IEvents_FWD_DEFINED__
#define __IEvents_FWD_DEFINED__
typedef interface IEvents IEvents;
#endif 	/* __IEvents_FWD_DEFINED__ */


#ifndef __IEvent_FWD_DEFINED__
#define __IEvent_FWD_DEFINED__
typedef interface IEvent IEvent;
#endif 	/* __IEvent_FWD_DEFINED__ */


#ifndef __ILogs_FWD_DEFINED__
#define __ILogs_FWD_DEFINED__
typedef interface ILogs ILogs;
#endif 	/* __ILogs_FWD_DEFINED__ */


#ifndef __IEvents_FWD_DEFINED__
#define __IEvents_FWD_DEFINED__
typedef interface IEvents IEvents;
#endif 	/* __IEvents_FWD_DEFINED__ */


#ifndef __View_FWD_DEFINED__
#define __View_FWD_DEFINED__

#ifdef __cplusplus
typedef class View View;
#else
typedef struct View View;
#endif /* __cplusplus */

#endif 	/* __View_FWD_DEFINED__ */


#ifndef __Log_FWD_DEFINED__
#define __Log_FWD_DEFINED__

#ifdef __cplusplus
typedef class Log Log;
#else
typedef struct Log Log;
#endif /* __cplusplus */

#endif 	/* __Log_FWD_DEFINED__ */


#ifndef __Event_FWD_DEFINED__
#define __Event_FWD_DEFINED__

#ifdef __cplusplus
typedef class Event Event;
#else
typedef struct Event Event;
#endif /* __cplusplus */

#endif 	/* __Event_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_evntutl_0000 */
/* [local] */ 

typedef 
enum eEventType
    {	ErrorEvent	= 0,
	WarningEvent	= 1,
	InformationEvent	= 2,
	AuditSuccess	= 3,
	AuditFailure	= 4
    } 	eEventType;



extern RPC_IF_HANDLE __MIDL_itf_evntutl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_evntutl_0000_v0_0_s_ifspec;

#ifndef __IView_INTERFACE_DEFINED__
#define __IView_INTERFACE_DEFINED__

/* interface IView */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CACECD29-3108-4132-9A4E-53B54FFDAFA0")
    IView : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Logs( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Server( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IView * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IView * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IView * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IView * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Logs )( 
            IView * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Server )( 
            IView * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Server )( 
            IView * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IViewVtbl;

    interface IView
    {
        CONST_VTBL struct IViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IView_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IView_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IView_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IView_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IView_get_Logs(This,pVal)	\
    (This)->lpVtbl -> get_Logs(This,pVal)

#define IView_get_Server(This,pVal)	\
    (This)->lpVtbl -> get_Server(This,pVal)

#define IView_put_Server(This,newVal)	\
    (This)->lpVtbl -> put_Server(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IView_get_Logs_Proxy( 
    IView * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IView_get_Logs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IView_get_Server_Proxy( 
    IView * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IView_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IView_put_Server_Proxy( 
    IView * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IView_put_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IView_INTERFACE_DEFINED__ */


#ifndef __ILogs_INTERFACE_DEFINED__
#define __ILogs_INTERFACE_DEFINED__

/* interface ILogs */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ILogs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AAA9B130-C64E-400F-BC63-BA9C946082A6")
    ILogs : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILogs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILogs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILogs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ILogs * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ILogs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ILogs * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILogs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ILogs * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ILogs * This,
            /* [retval][out] */ LPUNKNOWN *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ILogs * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } ILogsVtbl;

    interface ILogs
    {
        CONST_VTBL struct ILogsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILogs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILogs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILogs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILogs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILogs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILogs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILogs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILogs_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define ILogs_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define ILogs_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ILogs_get_Count_Proxy( 
    ILogs * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB ILogs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ILogs_get__NewEnum_Proxy( 
    ILogs * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB ILogs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ILogs_get_Item_Proxy( 
    ILogs * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB ILogs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILogs_INTERFACE_DEFINED__ */


#ifndef __ILog_INTERFACE_DEFINED__
#define __ILog_INTERFACE_DEFINED__

/* interface ILog */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ILog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FC21F08-F75C-4818-B42C-8A59DB3E33E7")
    ILog : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Events( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Server( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ILog * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ILog * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ILog * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILog * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Events )( 
            ILog * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ILog * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Server )( 
            ILog * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Server )( 
            ILog * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ILog * This);
        
        END_INTERFACE
    } ILogVtbl;

    interface ILog
    {
        CONST_VTBL struct ILogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILog_get_Events(This,pVal)	\
    (This)->lpVtbl -> get_Events(This,pVal)

#define ILog_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define ILog_get_Server(This,pVal)	\
    (This)->lpVtbl -> get_Server(This,pVal)

#define ILog_put_Server(This,newVal)	\
    (This)->lpVtbl -> put_Server(This,newVal)

#define ILog_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ILog_get_Events_Proxy( 
    ILog * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB ILog_get_Events_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ILog_get_Name_Proxy( 
    ILog * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ILog_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ILog_get_Server_Proxy( 
    ILog * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ILog_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ILog_put_Server_Proxy( 
    ILog * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ILog_put_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILog_Clear_Proxy( 
    ILog * This);


void __RPC_STUB ILog_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILog_INTERFACE_DEFINED__ */


#ifndef __IEvents_INTERFACE_DEFINED__
#define __IEvents_INTERFACE_DEFINED__

/* interface IEvents */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B70B0436-726F-4742-B08E-1AEE6D6C6AA9")
    IEvents : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IEvents * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IEvents * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IEvents * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IEvents * This,
            /* [retval][out] */ LPUNKNOWN *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IEvents * This,
            /* [in] */ long Index,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } IEventsVtbl;

    interface IEvents
    {
        CONST_VTBL struct IEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEvents_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IEvents_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define IEvents_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvents_get_Count_Proxy( 
    IEvents * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IEvents_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvents_get__NewEnum_Proxy( 
    IEvents * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB IEvents_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvents_get_Item_Proxy( 
    IEvents * This,
    /* [in] */ long Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IEvents_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEvents_INTERFACE_DEFINED__ */


#ifndef __IEvent_INTERFACE_DEFINED__
#define __IEvent_INTERFACE_DEFINED__

/* interface IEvent */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5FF33202-DD46-4C30-809D-BD868D6A6D29")
    IEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventID( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventType( 
            /* [retval][out] */ eEventType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Category( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Source( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_User( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OccurrenceTime( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Data( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IEvent * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IEvent * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventID )( 
            IEvent * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventType )( 
            IEvent * This,
            /* [retval][out] */ eEventType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IEvent * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IEvent * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Source )( 
            IEvent * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_User )( 
            IEvent * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OccurrenceTime )( 
            IEvent * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ComputerName )( 
            IEvent * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Data )( 
            IEvent * This,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } IEventVtbl;

    interface IEvent
    {
        CONST_VTBL struct IEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEvent_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEvent_get_EventID(This,pVal)	\
    (This)->lpVtbl -> get_EventID(This,pVal)

#define IEvent_get_EventType(This,pVal)	\
    (This)->lpVtbl -> get_EventType(This,pVal)

#define IEvent_get_Category(This,pVal)	\
    (This)->lpVtbl -> get_Category(This,pVal)

#define IEvent_get_Description(This,pVal)	\
    (This)->lpVtbl -> get_Description(This,pVal)

#define IEvent_get_Source(This,pVal)	\
    (This)->lpVtbl -> get_Source(This,pVal)

#define IEvent_get_User(This,pVal)	\
    (This)->lpVtbl -> get_User(This,pVal)

#define IEvent_get_OccurrenceTime(This,pVal)	\
    (This)->lpVtbl -> get_OccurrenceTime(This,pVal)

#define IEvent_get_ComputerName(This,pVal)	\
    (This)->lpVtbl -> get_ComputerName(This,pVal)

#define IEvent_get_Data(This,pVal)	\
    (This)->lpVtbl -> get_Data(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_EventID_Proxy( 
    IEvent * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IEvent_get_EventID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_EventType_Proxy( 
    IEvent * This,
    /* [retval][out] */ eEventType *pVal);


void __RPC_STUB IEvent_get_EventType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_Category_Proxy( 
    IEvent * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IEvent_get_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_Description_Proxy( 
    IEvent * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEvent_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_Source_Proxy( 
    IEvent * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEvent_get_Source_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_User_Proxy( 
    IEvent * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEvent_get_User_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_OccurrenceTime_Proxy( 
    IEvent * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IEvent_get_OccurrenceTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_ComputerName_Proxy( 
    IEvent * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IEvent_get_ComputerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IEvent_get_Data_Proxy( 
    IEvent * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IEvent_get_Data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEvent_INTERFACE_DEFINED__ */



#ifndef __EventLogUtilities_LIBRARY_DEFINED__
#define __EventLogUtilities_LIBRARY_DEFINED__

/* library EventLogUtilities */
/* [helpstring][version][uuid] */ 




EXTERN_C const IID LIBID_EventLogUtilities;

EXTERN_C const CLSID CLSID_View;

#ifdef __cplusplus

class DECLSPEC_UUID("FF184146-A804-4FB1-BDA7-1E05052C5553")
View;
#endif

EXTERN_C const CLSID CLSID_Log;

#ifdef __cplusplus

class DECLSPEC_UUID("07C97B1B-4042-4DD3-9FDD-56EC7677E30E")
Log;
#endif

EXTERN_C const CLSID CLSID_Event;

#ifdef __cplusplus

class DECLSPEC_UUID("32FB0C7C-96CA-4263-A1FE-215A0AF69B34")
Event;
#endif
#endif /* __EventLogUtilities_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\logs.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Logs.h : Declaration of the CLogs

#ifndef __LOGS_H_
#define __LOGS_H_

#include "resource.h"       // main symbols
#include "Log.h"

/////////////////////////////////////////////////////////////////////////////
// CLogs
class ATL_NO_VTABLE CLogs : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CLogs, &CLSID_Logs>,
	public ISupportErrorInfo,
	public IDispatchImpl<ILogs, &IID_ILogs, &LIBID_EventLogUtilities>
{
private:
	ULONG m_Count;
	CComVariant* m_pVector;
	_bstr_t m_btCurrentLogName;

public:
	_bstr_t m_ServerName;

	CLogs() : m_Count(0), m_pVector(NULL)
	{
	}

	~CLogs()
	{
		delete [] m_pVector;
	}

	// Internal functions
	HRESULT Init();

DECLARE_REGISTRY_RESOURCEID(IDR_LOGS)
DECLARE_NOT_AGGREGATABLE(CLogs)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLogs)
	COM_INTERFACE_ENTRY(ILogs)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ILogs
	STDMETHOD(get_Item)(/*[in]*/ VARIANT Index, /*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
};

#endif //__LOGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\logs.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Logs.cpp : Implementation of CLogs
#include "stdafx.h"
#include "Evntutl.h"
#include "Logs.h"

/////////////////////////////////////////////////////////////////////////////
// CLogs

STDMETHODIMP CLogs::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ILogs
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*
	Function:  get_Count
	Inputs:  empty long
	Outputs:  number event logs available
	Purpose:  Allows user to determine the number of DEFAULT EventLogs
			  Custom EventLogs are not visible in the count
*/
STDMETHODIMP CLogs::get_Count(long *pVal)
{
	*pVal = m_Count;

	return S_OK;
}

/*
	Function:  get_NewEnum
	Inputs:  empty IUnknown pointer
	Outputs:  IEnumVariant object filled with names of default EventLogs
	Purpose:  Allows user to use For Each syntax to do operations on all
			  DEFAULT EventLogs
*/
STDMETHODIMP CLogs::get__NewEnum(LPUNKNOWN *pVal)
{
	HRESULT hr = S_OK;

	if (NULL == pVal) return E_POINTER;
	*pVal = NULL;

	EnumVar* pEVar = new EnumVar;

	hr = pEVar->Init(&m_pVector[0], &m_pVector[m_Count], NULL, AtlFlagCopy);
	if (SUCCEEDED(hr)) 
		hr = pEVar->QueryInterface(IID_IEnumVARIANT, (void**) pVal);

	if FAILED(hr)
		if (pEVar) delete pEVar;
	return hr;
}

/*
	Function:  get_Item
	Inputs:  Valid Index (containing integer for default or BSTR for Default and Custom), empty Variant
	Outputs:  variant dispatch pointer to a Log object
	Purpose:  Allows user to access individual EventLogs by name or default EventLogs by number
*/
STDMETHODIMP CLogs::get_Item(VARIANT Index, VARIANT *pVal)
{
	HRESULT hr = S_OK;
	CComObject<CLog>* pLog;
	ILog* ptLog;
	LPDISPATCH pDisp = NULL;
	_bstr_t bstrCurrentName;
	_bstr_t bstrCheck;
	CComBSTR bstrTemp;
	bool bfound = false;
	unsigned int i = 0;

	if (NULL == pVal) return E_POINTER;
	VariantInit(pVal);
	pVal->vt = VT_UNKNOWN;
	pVal->punkVal = NULL;

	switch(Index.vt)
	{
	case VT_I4 :
	case VT_UI2:
	case VT_UINT:
	case VT_INT:
		{
			if ((Index.iVal > 0) && (UINT(Index.iVal) < m_Count + 1))
				VariantCopy(pVal, &m_pVector[Index.iVal - 1]);
			else hr = E_INVALIDARG;
		}
		break;

	case VT_BSTR :
		{
			if (!Index.bstrVal)
				hr = E_INVALIDARG;
			else
			{
				m_btCurrentLogName = Index.bstrVal;
				// This loop should check the existing VariantArray for a log with name = Index
				// it completes when the item is found or all default logs have been checked
				while ((i<m_Count) && (false == bfound))
				{
					hr = m_pVector[i].pdispVal->QueryInterface(IID_ILog, (void**) &ptLog);
					hr = ptLog->get_Name(&bstrTemp);
					bstrCurrentName = bstrTemp;
					if (bstrCurrentName == m_btCurrentLogName)
					{
						VariantCopy(pVal, &m_pVector[i]);
						bfound = true;
					}
					ptLog->Release();
					i++;
				}
				if (false == bfound)
				{
					hr = CComObject<CLog>::CreateInstance(&pLog);
					bstrCurrentName = Index.bstrVal;
					pLog->m_Name = bstrCurrentName;
					pLog->m_ServerName = m_ServerName;
					hr = pLog->QueryInterface(IID_IDispatch, (void**)&pDisp);
					pLog->AddRef();
					pVal->vt = VT_DISPATCH;
					pVal->pdispVal = pDisp;
				}
			}
		}
		break;

	default:
		hr = E_INVALIDARG;
		break;
	}

	return hr;
}

/*
	Function:  Init
	Inputs:  none
	Outputs:  HRESULT indicating what error if any occured
	Purpose:  Prepares a variant array filled with Log objects for 3 default logs.
*/
HRESULT CLogs::Init()
{
	HRESULT hr = S_OK;
	UINT i;

	//	Default Logs: "Application" "Security" "System"
	static wchar_t* LogNames[] = {L"Application", L"Security", L"System"};

	m_Count = 3;

	if (m_pVector !=NULL) delete [] m_pVector;

	m_pVector = new CComVariant[m_Count];
	CComObject<CLog>* pLog;
	LPDISPATCH pDisp = NULL;

	for (i = 0; i < m_Count; i++)
	{
		// create a CLog object
		hr = CComObject<CLog>::CreateInstance(&pLog);
		if (SUCCEEDED(hr))
		{
			pLog->m_Name = LogNames[i];
			pLog->m_ServerName = m_ServerName.copy();

			// get IDispatch pointer
			hr = pLog->QueryInterface(IID_IDispatch, (void**)&pDisp);
			if (SUCCEEDED(hr))
			{
				// create a variant reference and set the type of object
				CComVariant& var = m_pVector[i];
				var.vt = VT_DISPATCH;
				var.pdispVal = pDisp;
			}
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tstst\conv.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    conv.h

Abstract:

    UNICODE / ASCII conversion macros

Author:

    Hakki T. Bostanci (hakkib) 5-Aug-1998

Revision History:

--*/

#ifndef USES_CONVERSION

// USES_CONVERSION must be defined in every function that uses the
// conversion macros

#define USES_CONVERSION int __nLength; PCWSTR __pUnicode; PCSTR __pAscii

//////////////////////////////////////////////////////////////////////////
//
// W2A
//
// Routine Description:
//   Converts a UNICODE string to ASCII. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          UNICODE string
//
// Return Value:
//   the converted ASCII string
//

#define W2A(pStr)								                \
												                \
	((__pUnicode = pStr) == 0 ? (PSTR) 0 : (	                \
												                \
	__nLength = WideCharToMultiByte(				            \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		0,										                \
		0,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pAscii = (PCSTR) _alloca(__nLength * sizeof(CHAR)),       \
												                \
	WideCharToMultiByte(						                \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		(PSTR) __pAscii,						                \
		__nLength,								                \
		0,										                \
		0										                \
	),											                \
												                \
	(PSTR) __pAscii))							                \


//////////////////////////////////////////////////////////////////////////
//
// A2W
//
// Routine Description:
//   Converts an ASCII string to UNICODE. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          ASCII string
//
// Return Value:
//   the converted UNICODE string
//

#define A2W(pStr)								                \
												                \
	((__pAscii = pStr) == 0 ? (PWSTR) 0 : (					    \
												                \
	__nLength = MultiByteToWideChar(				            \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pUnicode = (PCWSTR) _alloca(__nLength * sizeof(WCHAR)),	\
												                \
	MultiByteToWideChar(						                \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		(PWSTR) __pUnicode,							            \
		__nLength									            \
	),											                \
												                \
	(PWSTR) __pUnicode))							            \

//////////////////////////////////////////////////////////////////////////
//
// T2A, A2T, T2W, W2T
//
// Routine Description:
//   These macros expand to the corresponding correct form according to the
//   #definition of UNICODE. 
//
//   We use the cryptic form (__nLength, __pAscii, __pUnicode, pStr) to avoid 
//   the compiler warning "symbol defined but not used" due to the variables 
//   defined in USES_CONVERSION macro.
//

#ifdef UNICODE
	#define T2A(pStr) W2A(pStr)
	#define A2T(pStr) A2W(pStr)
	#define T2W(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define W2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2DA(pStr) W2A(pStr)
	#define A2DT(pStr) A2W(pStr)
	#define T2DW(pStr) _wcsdupa(pStr)
	#define W2DT(pStr) _wcsdupa(pStr)
#else //UNICODE
	#define T2A(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define A2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2W(pStr) A2W(pStr)
	#define W2T(pStr) W2A(pStr)
	#define T2DA(pStr) _strdupa(pStr)
	#define A2DT(pStr) _strdupa(pStr)
	#define T2DW(pStr) A2W(pStr)
	#define W2DT(pStr) W2A(pStr)
#endif //UNICODE


//////////////////////////////////////////////////////////////////////////
//
// _tcsdupa
//
// Routine Description:
//   Duplicates a string to a buffer allocated off the stack using _alloca
//
// Arguments:
//	 pStr          input string
//
// Return Value:
//   duplicated string
//

#define _wcsdupa(pStr)                                                  \
                                                                        \
    (__pAscii, (__pUnicode = pStr) == 0 ? (PWSTR) 0 : (                 \
                                                                        \
    __nLength = wcslen(__pUnicode) + 1,                                 \
                                                                        \
    wcscpy((PWSTR) _alloca(__nLength * sizeof(WCHAR)), __pUnicode)))    \


#define _strdupa(pStr)                                                  \
                                                                        \
    (__pUnicode, (__pAscii = pStr) == 0 ? (PSTR) 0 : (                  \
                                                                        \
    __nLength = strlen(__pAscii) + 1,                                   \
                                                                        \
    strcpy((PSTR) _alloca(__nLength * sizeof(CHAR)), __pAscii)))        \


#ifdef UNICODE 
#define _tcsdupa _wcsdupa
#else
#define _tcsdupa _strdupa
#endif


#endif //USES_CONVERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tstst\drdetect.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    drdetect

Abstract:

    Detect whether RDPDR was properly installed.

Environment:

    User mode

Author:

    Tadb

--*/

#include "stdafx.h"
#include <setupapi.h>

////////////////////////////////////////////////////////////
//
//  Internal Defines
//

#define RDPDRPNPID      _T("ROOT\\RDPDR")
#define RDPDRDEVICEID   TEXT("Root\\RDPDR\\0000")

const GUID GUID_DEVCLASS_SYSTEM =
{ 0x4d36e97dL, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } };


ULONG RDPDRINST_DetectInstall()
/*++

Routine Description:

    Return the number of RDPDR.SYS devices found.

Arguments:

    NA

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
{
    HDEVINFO            devInfoSet;
    SP_DEVINFO_DATA     deviceInfoData;
    DWORD               iLoop;
    BOOL                bMoreDevices;
    ULONG               count;
    TCHAR               pnpID[256];


    GUID *pGuid=(GUID *)&GUID_DEVCLASS_SYSTEM;

    //
    //  Get the set of all devices with the RDPDR PnP ID.
    //
    devInfoSet = SetupDiGetClassDevs(pGuid, NULL, NULL,
                                   DIGCF_PRESENT);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "Error getting RDPDR devices from PnP.  Error code:  %ld.",
                GetLastError());
        return 0;
    }

    // Get the first device.
    iLoop=0;
    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, iLoop, &deviceInfoData);

    // Get the details for all matching device interfaces.
    count = 0;
    while (bMoreDevices)
    {
        // Get the PnP ID for the device.
        if (!SetupDiGetDeviceRegistryProperty(devInfoSet, &deviceInfoData,
                                SPDRP_HARDWAREID, NULL, (BYTE *)pnpID,
                                sizeof(pnpID), NULL)) {
            fprintf(stderr, "Error fetching PnP ID in RDPDR device node remove.  Error code:  %ld.",
                        GetLastError());
        }

        // If the current device matches the RDPDR PNP ID
        if (!_tcscmp(pnpID, RDPDRPNPID)) {
            count++;
        }

        // Get the next one device interface.
        bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, ++iLoop, &deviceInfoData);
    }

    // Release the device info list.
    SetupDiDestroyDeviceInfoList(devInfoSet);

    return count;
}


//
//      Unit-Test
//
//void __cdecl main()
//{
//    ULONG count;
//    count = RDPDRINST_DetectInstall();
//    printf("Found %ld instance(s) of RDPDR.SYS.\n", count);
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by EventLogUtilities.rc
//
#define IDS_PROJNAME                    100
#define IDR_VIEW                        101
#define IDR_LOGS                        102
#define IDR_LOG                         103
#define IDR_EVENTS                      104
#define IDR_EVENT                       105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tstst\stdafx.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__0829672C_6402_4F1B_A4E1_E4D00F7F4C04__INCLUDED_)
#define AFX_STDAFX_H__0829672C_6402_4F1B_A4E1_E4D00F7F4C04__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>
#include <wchar.h>

#include "Types.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0829672C_6402_4F1B_A4E1_E4D00F7F4C04__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\view.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// View.cpp : Implementation of CView
#include "stdafx.h"
#include "Evntutl.h"
#include "View.h"

/////////////////////////////////////////////////////////////////////////////
// CView

STDMETHODIMP CView::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IView
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*
	Function:  get_Logs
	Inputs:  empty variant
	Outputs:  variant dispatch pointer to an ILogs interface
	Purpose:  Provide access to ILogs
*/
STDMETHODIMP CView::get_Logs(VARIANT *pVal)
{
	HRESULT hr = S_OK;

	VariantInit(pVal);

	IDispatch* pDisp;
	hr = m_pLogs->QueryInterface (IID_IDispatch, (void**) &pDisp);
	if (SUCCEEDED(hr))
	{
		pVal->vt = VT_DISPATCH;
		pVal->pdispVal = pDisp;

		m_pLogs->m_ServerName = m_ServerName.copy();
		hr = m_pLogs->Init();
	}

	return hr;
}

/*
	Function:  get_Server
	Inputs:  empty BSTR
	Outputs:  BSTR containing the current value of the server member variable
	Purpose:  Allows user to see which Server's EventLog will be displayed
*/
STDMETHODIMP CView::get_Server(BSTR *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_ServerName.copy();
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  put_Server
	Inputs:  BSTR containing a valid server name
	Outputs:  none
	Purpose:  Allows user to set which Server's EventLog will be displayed
*/
STDMETHODIMP CView::put_Server(BSTR newVal)
{
	m_ServerName = newVal;
	m_pLogs->m_ServerName = m_ServerName.copy();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tstst\audio.cpp ===
#include    "nt.h"
#include    "ntrtl.h"
#include    "nturtl.h"
#include    "stdafx.h"
#include    <windows.h>
#include    <winsta.h>
#include    <rdpsndp.h>
#include    <rdpstrm.h>
#include    <stdio.h>
#include    <strstrea.h>

extern ostrstream szMoreInfo;
BOOL
IsTSRedirectingAudio( VOID )
{
    BOOL rv;
    static  BOOL    bChecked = FALSE;
    static  BOOL    RemoteConsoleAudio = 0;    // Allow audio play at
                                               // the console
                                               // when console session is
                                               // remoted
    // is not consle ?
    //
    rv = !(USER_SHARED_DATA->ActiveConsoleId ==
      NtCurrentPeb()->SessionId);

    // console, we don't redirect
    if ( !rv )
    {
        szMoreInfo << "Running on the console" << endl;
        goto exitpt;
    } else
        szMoreInfo << "Running in a session" << endl;

    // check if audio is redirected on PTS
    //
    if ( !bChecked )
    {
        WINSTATIONCLIENT ClientData;
        ULONG Length;

        if (WinStationQueryInformation(SERVERNAME_CURRENT,
                                        LOGONID_CURRENT,
                                        WinStationClient,
                                        &ClientData,
                                        sizeof(ClientData),
                                        &Length ))
        {
            RemoteConsoleAudio = ClientData.fRemoteConsoleAudio;
        }
        else {
            szMoreInfo << "WinStatinQueryInformation failed=" <<
                    GetLastError() << endl;
            RemoteConsoleAudio = 0;
        }
    }

    rv = !RemoteConsoleAudio;

exitpt:
    return rv;
}

BOOL
IsTSAudioDriverEnabled( VOID )
{
    BOOL rv = FALSE;
    WINSTATIONCONFIG config;
    BOOLEAN          fSuccess;
    DWORD            returnedLength;

    fSuccess = WinStationQueryInformation(NULL, LOGONID_CURRENT,
                    WinStationConfiguration, &config,
                    sizeof(config), &returnedLength);
    if (!fSuccess)
    {
        szMoreInfo << "WinStatinQueryInformation failed=" <<
                GetLastError() <<endl;
        goto exitpt;
    }

    rv = !config.User.fDisableCam;

exitpt:
    return rv;
}

BOOL
DumpStreamInfo( VOID )
{
    BOOL        rv = TRUE;
    HANDLE      hEv = NULL;
    HANDLE      hStream = NULL;
    PSNDSTREAM  Stream = NULL;
    DWORD       dw;

    hEv = OpenEvent(EVENT_ALL_ACCESS,
                    FALSE,
                    TSSND_DATAREADYEVENT);

    if ( NULL == hEv )
    {
        szMoreInfo << "ERROR: Can't open DataReady event=" <<
            GetLastError() <<endl;
        rv = FALSE;
    } else {
        szMoreInfo << "OK: DataReady event exist" << endl;
        dw = WaitForSingleObject( hEv, 0 );
        if ( WAIT_OBJECT_0 == dw )
        {
            szMoreInfo << "WARNING: DataReady event is signaled (playing sound ?)" <<endl;
            SetEvent( hEv );
            rv = FALSE;
        } else
            szMoreInfo << "OK: DataReady event is not signaled" <<endl;
        CloseHandle( hEv );
    }


    hEv = OpenEvent(EVENT_ALL_ACCESS,
            FALSE,
            TSSND_STREAMISEMPTYEVENT);
    if ( NULL == hEv )
    {
        szMoreInfo << "ERROR: Can't open StreamEmpty event=" <<
            GetLastError() <<endl;
        rv = FALSE;
    } else {
        szMoreInfo << "OK: StreamEmpty event exist" <<endl;
        dw = WaitForSingleObject( hEv, 0 );
        if ( WAIT_OBJECT_0 == dw )
        {
            szMoreInfo << "WARNING: StreamEmpty is signaled  (playing sound ?)" <<endl;
            rv = FALSE;
        } else {
            szMoreInfo << "OK: StreamEmpty event is not signaled" <<endl;
            SetEvent( hEv );
        }
        CloseHandle( hEv );
    }

    hEv = OpenEvent(EVENT_ALL_ACCESS,
            FALSE,
            TSSND_WAITTOINIT);
    if ( NULL == hEv )
    {
        szMoreInfo << "ERROR: Can't open WaitToInit event=" <<
            GetLastError() <<endl;
        rv = FALSE;
    }
    else {
        szMoreInfo << "OK: WaitToInit event exist" <<endl;
        dw = WaitForSingleObject( hEv, 0 );
        if ( WAIT_OBJECT_0 == dw )
        {
            szMoreInfo << "OK: WaitToInit is signaled" <<endl;
        } else {
            szMoreInfo << "WARNING: WaitToInit is NOT signaled" <<endl;
            rv = FALSE;
        }
        CloseHandle( hEv );
    }

    hEv = OpenMutex(SYNCHRONIZE,
            FALSE,
            TSSND_STREAMMUTEX);
    if ( NULL == hEv )
    {
        szMoreInfo << "ERROR: Can't open Stream mutex=" <<
            GetLastError() <<endl;
        rv = FALSE;
    } else {
        szMoreInfo << "OK: Stream mutex exist" <<endl;
        dw = WaitForSingleObject( hEv, 3000 );
        if ( WAIT_OBJECT_0 != dw )
        {
            szMoreInfo << "WARNING: Can't acquire Stream mutext after more than 3 seconds" <<endl;
            rv = FALSE;
        } else {
            szMoreInfo << "OK: Stream mutext acquired" <<endl;
            ReleaseMutex( hEv );
        }
        CloseHandle( hEv );
    }

    hStream = OpenFileMapping(
                    FILE_MAP_ALL_ACCESS,
                    FALSE,
                    TSSND_STREAMNAME
                );

    if (NULL == hStream)
    {
        szMoreInfo << "ERROR: Can't open the stream mapping" <<
            GetLastError() <<endl;
        rv = FALSE;
        goto exitpt;
    }

    Stream = (PSNDSTREAM)MapViewOfFile(
                    hStream,
                    FILE_MAP_ALL_ACCESS,
                    0, 0,       // offset
                    sizeof(*Stream)
                    );

    if (NULL == Stream)
    {
        szMoreInfo << "ERROR: Can't map the stream view: " <<
                 GetLastError() <<endl;
        rv = FALSE;
        goto exitpt;
    }

    szMoreInfo << "SNDSTREAM:" <<endl;
    szMoreInfo << "bNewVolume:            0x" << hex << Stream->bNewVolume <<endl;
    szMoreInfo << "bNewPitch:             0x" << hex << Stream->bNewPitch <<endl;

    szMoreInfo << "dwSoundCaps:           0x" << hex << Stream->dwSoundCaps <<endl;
    if ( 0 != (TSSNDCAPS_ALIVE & Stream->dwSoundCaps) )
        szMoreInfo << "\tTSSNDCAPS_ALIVE" <<endl;
    if ( 0 != (TSSNDCAPS_VOLUME & Stream->dwSoundCaps) )
        szMoreInfo << "\tTSSNDCAPS_VOLUME" << endl;
    if ( 0 != (TSSNDCAPS_PITCH & Stream->dwSoundCaps) )
        szMoreInfo << "\tTSSNDCAPS_PITCH" <<endl;

    szMoreInfo << "dwVolume:              0x" << hex << Stream->dwVolume <<endl;
    szMoreInfo << "dwPitch:               0x" << hex << Stream->dwPitch <<endl;

    dw = Stream->cLastBlockQueued;
    szMoreInfo << "cLastBlockQueued:      0x" << hex << dw <<endl;
    dw = Stream->cLastBlockSent;
    szMoreInfo << "cLastBlockSent:        0x" << hex << dw <<endl;
    dw = Stream->cLastBlockConfirmed;
    szMoreInfo << "cLastBlockConfirmed:   0x" << hex << dw <<endl;

exitpt:
    if ( rv )
        szMoreInfo << "OK: Stream seems good" <<endl;
    else
        szMoreInfo << "ERROR: Stream doesn't seem very healthy" <<endl;

    if ( NULL != Stream )
        UnmapViewOfFile( Stream );

    if ( NULL != hStream )
        CloseHandle( hStream );

    return rv;
}

BOOL
IsAudioOk(
    VOID
    )
{
    INT rv = TRUE;

    if ( !IsTSRedirectingAudio() )
    {
        szMoreInfo << "Audio is not redirected" <<endl;
        goto exitpt;
    }

    if ( !IsTSAudioDriverEnabled() )
    {
        szMoreInfo << "TS Auidio driver is disabled" <<endl;
        goto exitpt;
    }

    szMoreInfo << "Audio redirection is enabled. Dumping stream info" <<endl;

    rv = DumpStreamInfo();

exitpt:
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tstst\vermak.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/////////////////////////////////////////////////////////////////////////////
// VERSION INFO
#include <ntverp.h>


#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Terminal Server Setup Test"
#define VER_INTERNALNAME_STR        "tstst"
#define VER_ORIGINALFILENAME_STR    "tstst.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\view.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// View.h : Declaration of the CView

#ifndef __VIEW_H_
#define __VIEW_H_

#include "resource.h"       // main symbols
#include "Logs.h"

/////////////////////////////////////////////////////////////////////////////
// CView
class ATL_NO_VTABLE CView : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CView, &CLSID_View>,
	public ISupportErrorInfo,
	public IDispatchImpl<IView, &IID_IView, &LIBID_EventLogUtilities>
{
private:
	CComObject<CLogs>* m_pLogs;
	_bstr_t m_ServerName;

public:

	CView()
	{
/*
// Don't know if I want to set ServerName initially
		char* lpBuffer;
		DWORD BufferLength;
		const unsigned int MaxComputerNameLength = 32;

		lpBuffer = new char[MaxComputerNameLength];
		BufferLength = GetEnvironmentVariable("COMPUTERNAME", lpBuffer, MaxComputerNameLength);
		m_ServerName = lpBuffer;
*/
		m_pLogs = new CComObject<CLogs>;
		m_pLogs->AddRef();
//		m_pLogs->Init();
	}

	~CView()
	{
		if (m_pLogs) m_pLogs->Release();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_VIEW)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CView)
	COM_INTERFACE_ENTRY(IView)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IView
	STDMETHOD(get_Server)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Server)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Logs)(/*[out, retval]*/ VARIANT *pVal);
};

#endif //__VIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tsdiag\evntutl\types.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////

typedef CComObject<
				CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> >
			> EnumVar;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tstst\event.cpp ===
#include "stdafx.h"
// #include "winbase.h"

#define MAX_INSERT_STRS     5

TCHAR *aszTSEventSources[] = { _T("TermService"), _T("TermDD"), _T("TermServDevices") };

BOOL ExtractEvents();
BOOL ExtractAllTSEvents()
{
    cout << endl;
    return ExtractEvents ();
}

BOOL ExtractEvents ()
{
    USES_CONVERSION;
    BOOL bFoundEvents = FALSE;



    HANDLE hEventLog = OpenEventLog(NULL, _T("System"));
    if (hEventLog)
    {

        const DWORD dwBytesToRead =  1024*10;

        char *pBuff = new char[dwBytesToRead];
        if (pBuff)
        {
            DWORD dwBytesRead, dwBytesNeeded;

            while (ReadEventLog(hEventLog,
                        EVENTLOG_BACKWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                        0,
                        PVOID(pBuff),
                        dwBytesToRead,
                        &dwBytesRead,
                        &dwBytesNeeded))
            {
                if (dwBytesRead == 0)
                    break;

                for (PEVENTLOGRECORD pEventLogRecord = ( PEVENTLOGRECORD ) pBuff;
                    PCHAR(pEventLogRecord) + pEventLogRecord->Length < pBuff + dwBytesRead;
                    pEventLogRecord = (EVENTLOGRECORD *)(PCHAR(pEventLogRecord) + pEventLogRecord->Length)
                    )
                {
                    LPCTSTR szSource = LPCTSTR(PBYTE(pEventLogRecord) + sizeof(EVENTLOGRECORD));


                    //
                    // check if event source is among interesting ones.
                    //

                    LPCTSTR szEventSource = NULL;
                    for (int i = 0; i < (sizeof(aszTSEventSources) / sizeof(aszTSEventSources[0])); i++)
                    {
                        if (_tcsicmp(szSource, aszTSEventSources[i]) == 0)
                            szEventSource = aszTSEventSources[i];
                    }

                    if (!szEventSource)
                        continue;


                    //
                    // prepare the array of insert strings for FormatMessage - the
                    // insert strings are in the log entry.
                    //
                    char *aInsertStrings[MAX_INSERT_STRS];

                    char *p = (char *) ((LPBYTE) pEventLogRecord + pEventLogRecord->StringOffset);
                    for (i = 0; i < pEventLogRecord->NumStrings && i < MAX_INSERT_STRS; i++)
                    {
                        aInsertStrings[i] = p;
                        p += strlen(p) + 1;     // point to next string
                    }



                    //
                    // Get the binaries to look message in from registry.
                    //

                    TCHAR szSourceKey[1024];
                    _tcscpy(szSourceKey, _T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\"));
                    _tcscat(szSourceKey, szEventSource);

                    CRegistry oReg;
                    TCHAR szSourcePath[MAX_PATH];

                    if (oReg.OpenKey(HKEY_LOCAL_MACHINE, szSourceKey, KEY_READ) == ERROR_SUCCESS)
                    {
                        LPTSTR str;
                        DWORD dwSize;
                        if (ERROR_SUCCESS == oReg.ReadRegString(_T("EventMessageFile"), &str, &dwSize))
                        {

                            ExpandEnvironmentStrings(str, szSourcePath, MAX_PATH);
                        }
                        else
                        {
                            cout << "       Error Reading Registry (" << T2A(szSourceKey) << ")/(EventMessageFiles)" << endl;
                            continue;
                        }

                    }
                    else
                    {
                        cout << "       Error Reading Registry (" << T2A(szSourceKey) << endl;
                        continue;
                    }

                    //
                    // Binary String in registry could contain multipal binaries seperated by ;
                    //

                    TCHAR *szModule;
                    szModule = _tcstok(szSourcePath, _T(";"));

                    //
                    // for each binary found
                    //

                    DWORD dwBytesTransfered = 0;
                    do
                    {
                        HINSTANCE hModule = LoadLibrary(szModule);

                        TCHAR szMessage[1024];
                        dwBytesTransfered = FormatMessage(
                                            FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                            hModule,
                                            pEventLogRecord->EventID,
                                            0,
                                            szMessage,
                                            1024,
					    (va_list *)aInsertStrings);

                        if (dwBytesTransfered)
                        {
                            bFoundEvents = TRUE;
                            TCHAR szTimeString[512];
                            time_t timeGenerated = pEventLogRecord->TimeGenerated;
                            _tcsftime(szTimeString, 512, _T("%c"), localtime( (const time_t *)&timeGenerated ));
                            cout <<  "       " << T2A(szTimeString) << ": ( " << T2A(szEventSource) << " ) : " << T2A(szMessage);
                        }
                        else
                        {
                            cout << "       FormatMessage Failed. lasterror = " << GetLastError() << endl;
                        }

                        szModule = _tcstok(NULL, _T(";"));

                    }
                    while (!dwBytesTransfered && szModule);

                }


            }

        }

    }
    else
    {
        cout << "       Failed to Open Event log." << endl;
        return FALSE;
    }

    return bFoundEvents;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tstst\tscert.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

#include "stdafx.h"

#define MemAlloc malloc // for certfy.inc
#define MemFree free

#include "../../tscert/inc/pubblob.h"    // needed by certvfy.inc
#include "../../tscert/inc/certvfy.inc"  // VerifyFile()


BOOL FileExists (char *pszFullNameAndPath); // from tstst.cpp

BOOL CheckifBinaryisSigned(TCHAR *szFile)
{
    USES_CONVERSION;
    TCHAR szFullFile[MAX_PATH +1];
    RTL_CRITICAL_SECTION VfyLock;

    if (ExpandEnvironmentStrings(szFile, szFullFile, MAX_PATH))
    {
        if (FileExists(T2A(szFullFile)))
        {
            RtlInitializeCriticalSection( &VfyLock );

            if ( VerifyFile( T2W(szFullFile), &VfyLock ) )
            {
                return TRUE;
            }
        }

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tstst\stdafx.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Module Name:
 *
 *      hydraoc.h
 *
 *  Abstract:
 *
 *      Common Header file for the HydraOC Component.
 *      HydraOc Component is an optional component which installs Termainal Server (Hydra)
 *
 *  Author:
 *
 *
 *  Environment:
 *
 *    User Mode
 */

#ifndef _stdafx_h_
#define _stdafx_h_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <devguid.h>
#include <initguid.h>
#include <objbase.h>
#include <tchar.h>
#include <time.h>
#include <stdio.h>
#include <setupapi.h>
#include <prsht.h>
#include <loadperf.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commdlg.h>
#include <lm.h>
#include <lmerr.h>
#include <lmserver.h>
#include <iostream.h>
#include <fstream.h>
#include <stdlib.h>
#include <string.h>
#include <clusapi.h>        // for GetNodeClusterState
#include <malloc.h>
#include <stddef.h>
#include <wincrypt.h>
#include <imagehlp.h>



#include "conv.h"
#include "Registry.h"       // CRegistry

#define AssertFalse() ASSERT(FALSE)
#define VERIFY(x)     RTL_VERIFY(x)

#endif // _stdafx_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\data.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "security.h"

/*
 * List of accounts we allow file access for
 */

ADMIN_ACCOUNTS AllowAccounts[] = {
    { L"Administrators", NULL },
    { L"SYSTEM",         NULL },
    { CURRENT_USER,      NULL }
};

DWORD AllowAccountEntries = sizeof(AllowAccounts)/sizeof(ADMIN_ACCOUNTS);

ACCESS_MASK AllowAccess = STANDARD_RIGHTS_ALL | FILE_ALL_ACCESS;

/*
 * List of accounts to deny file access for
 */

ADMIN_ACCOUNTS DenyAccounts[] = {
    { L"", NULL }
};

DWORD DenyAccountEntries = 0;

ACCESS_MASK DeniedAccess = STANDARD_RIGHTS_ALL | FILE_ALL_ACCESS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\cpmutil.c ===
/*************************************************************************
*
* cpmutil.c
*
* System Library Client Printer functions
*
*  These functions tend to be includes in the spooler, printman,
*  and various port monitor DLL's. So they are here for common code.
*
* Copyright Microsoft, 1998
*
*
*
*
*************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "winsta.h"
#include "syslib.h"

#if DBG
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*****************************************************************************
 *
 *  IsClientPrinterPort
 *
 *   Return whether the name is a client printer port
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
IsClientPrinterPort(
    PWCHAR pName
    )
{
    BOOL Result;
    PORTNAMETYPE Type;

    //
    // This just does a brute force compare
    //
    if( pName == NULL ) {
        return( FALSE );
    }

    if( _wcsicmp( L"Client\\LPT1:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\LPT2:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\LPT3:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\LPT4:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\COM1:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\COM2:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\COM3:", pName ) == 0 ) {
        return( TRUE );
    }
    if( _wcsicmp( L"Client\\COM4:", pName ) == 0 ) {
        return( TRUE );
    }

    //
    // See if its a specific port
    //
    Result = ParseDynamicPortName(
                 pName,
                 NULL,
                 NULL,
                 &Type
                 );

    if( Type != PortNameUnknown ) {
        return( TRUE );
    }

    return( FALSE );
}

/*****************************************************************************
 *
 *  ExtractDosNamePtr
 *
 *   Extract the DOS name from a client port string.
 *
 *   Returns a pointer to the DOS name which is contained within
 *   the argument string.
 *
 *   Does not modify the argument string.
 *
 * ENTRY:
 *   pName (input)
 *     Input name string
 *
 * EXIT:
 *   NULL: No DOS name
 *   !=NULL Pointer to DOS name
 *
 ****************************************************************************/

PWCHAR
ExtractDosNamePtr(
    PWCHAR pName
    )
{
    PWCHAR this, prev;
    LPWSTR Ptr;
    ULONG Len, i, Count;
    WCHAR NameBuf[USERNAME_LENGTH+9];

    if( pName == NULL ) {
        return NULL;
    }

    // Make sure it starts with "Client\"
    if( _wcsnicmp( pName, L"Client\\", 7 ) != 0 ) {
        return NULL;
    }

    // Count the '\'s
    prev = pName;
    Count = 0;
    while( 1 ) {
        this = wcschr( prev, L'\\' );
        if( this == NULL ) {
            break;
        }
        // Now we must skip over the '\' character
        this++;
        Count++;
        prev = this;
    }

    if( Count == 0 ) {
        DBGPRINT(("ExtractDosNamePtr: Bad Dynamic name format No separators :%ws:\n",pName));
        return NULL;
    }

    //
    // Might be Client\LPTx:
    //
    // NOTE: Windows printers currently do not support
    //       a generic name.
    //
    if( Count == 1 ) {

        Len = wcslen( pName );
        if( Len < 11 ) {
            DBGPRINT(("ExtractDosNamePtr: Bad Dynamic name format Len < 11 :%ws:\n",pName));
            return NULL;
        }

        // Skip over "Client\"
        Ptr = pName + 7;

        return( Ptr );
    }

    // Skip over "Client\"
    Ptr = pName + 7;

    //
    // Here we must skip over the ICAName# or WinStationName
    //
    while( *Ptr ) {

        if( *Ptr == '\\' ) {
            break;
        }
        Ptr++;
    }

    //
    // Ptr now points to the '\\' after the
    // WinStation or ICA name. After this slash,
    // is the rest of the printer or port name.
    //
    Ptr++;

    return( Ptr );
}

/*****************************************************************************
 *
 *  ExtractDosName
 *
 *   Extract the DOS name from a client port string.
 *
 *   Returns the DOS name which is in a newly allocated string.
 *
 *   Does not modify the argument string.
 *
 * ENTRY:
 *   pName (input)
 *     Input name string
 *
 * EXIT:
 *   NULL: No DOS name
 *   !=NULL Pointer to DOS name
 *
 ****************************************************************************/

PWCHAR
ExtractDosName(
    PWCHAR pName
    )
{
    PWCHAR Ptr;
    PWCHAR pNewName = NULL;

    Ptr = ExtractDosNamePtr( pName );
    if( Ptr == NULL ) return NULL;

    pNewName = RtlAllocateHeap( RtlProcessHeap(), 0, (wcslen( Ptr )+1)*sizeof(WCHAR) );
    if( pNewName == NULL ) return NULL;

    wcscpy( pNewName, Ptr );

    return( pNewName );
}

/*****************************************************************************
 *
 *  ParseDynamicPortName
 *
 *   Parse a dynamic port name into its components.
 *   (NOTE: This is also in \nt\private\windows\spooler\localspl\citrix\cpmsup.c)
 *
 *   A dynamic port name is of the form:
 *
 *   Client\WinStationName\LPTx:,    where WinStationName is the hardwire name
 *   Client\ICAName#\LPTx:,          where ICAName is the ICA configured client name
 *   Client\LPTx:
 *   Client\IcaName#\Windows_Printer_Name
 *                                   where Windows_Printer_Name is
 *                                   the remote windows client print
 *                                   manager printer name.
 *
 *   Client\IcaName#\\\ntbuild\print1
 *                                   where Windows_Printer_Name is
 *                                   the remote windows client print
 *                                   manager printer name.
 *
 * ENTRY:
 *   pName (input)
 *     Name to be parsed
 *
 * EXIT:
 *   TRUE  - Name parsed successfully
 *   FALSE - Name is incorrect.
 *
 ****************************************************************************/

BOOL
ParseDynamicPortName(
    LPWSTR pName,
    LPWSTR pUser,
    LPWSTR pDosPort,
    PORTNAMETYPE *pType
    )
{
    PWCHAR this, prev;
    LPWSTR Ptr;
    ULONG Len, i, Count;
    WCHAR NameBuf[USERNAME_LENGTH+9];

    if( pName == NULL ) {
        *pType = PortNameUnknown;
        return(FALSE);
    }

    // Make sure it starts with "Client\"
    if( _wcsnicmp( pName, L"Client\\", 7 ) != 0 ) {
        *pType = PortNameUnknown;
        return(FALSE);
    }

    // Count the '\'s
    prev = pName;
    Count = 0;
    while( 1 ) {
        this = wcschr( prev, L'\\' );
        if( this == NULL ) {
            break;
        }
        // Now we must skip over the '\' character
        this++;
        Count++;
        prev = this;
    }

    if( Count == 0 ) {
        DBGPRINT(("ParseDynamicName: Bad Dynamic name format No separators :%ws:\n",pName));
        *pType = PortNameUnknown;
        return(FALSE);
    }

    //
    // Might be Client\LPTx:
    //
    // NOTE: Windows printers currently do not support
    //       a generic name.
    //
    if( Count == 1 ) {

        Len = wcslen( pName );
        if( Len < 11 ) {
            *pType = PortNameUnknown;
            DBGPRINT(("ParseDynamicName: Bad Dynamic name format Len < 11 :%ws:\n",pName));
            return(FALSE);
        }

        // Skip over "Client\"
        Ptr = pName + 7;

        if( !((_wcsnicmp( Ptr, L"LPT", 3 ) == 0)
                 ||
            (_wcsnicmp( Ptr, L"COM", 3 ) == 0)
                 ||
            (_wcsnicmp( Ptr, L"AUX", 3 ) == 0)) ) {

            *pType = PortNameUnknown;
            DBGPRINT(("ParseDynamicName: Bad Dynamic name format Not LPT!COM!AUX :%ws:\n",pName));
            return(FALSE);
        }

        // Range check the number
        if( (Ptr[3] < L'1') || (Ptr[3] > L'4') ) {
            *pType = PortNameUnknown;
            DBGPRINT(("ParseDynamicName: Bad Dynamic name format Number Range:%ws:\n",pName));
            return(FALSE);
        }

        Ptr = ExtractDosNamePtr( pName );
        if( Ptr == NULL ) {
            // Bad Dos component
            *pType = PortNameUnknown;
            DBGPRINT(("ParseDynamicName: Bad Dynamic name format DosName :%ws:\n",pName));
            return(FALSE);
        }

        // Copy out the Dos name
        if( pDosPort )
            wcscpy( pDosPort, Ptr );

        // Set the rest of the flags
        if( pUser )
            pUser[0] = 0;

        *pType = PortNameGeneric;

        return(TRUE);
    }

#ifdef notdef
    //
    // The rest of the formats have two '\'s
    //
    if( Count != 2 ) {
        DBGPRINT(("ParseDynamicName: Bad Dynamic name format Must be 2 :%ws:\n",pName));
        *pType = PortNameUnknown;
        return(FALSE);
    }

    // Get the Dos Name, which could also be a Windows printer name
    Ptr = ExtractDosNamePtr( pName );
    if( Ptr == NULL ) {
        // Bad Dos component
        *pType = PortNameUnknown;
        return(FALSE);
    }

    // Copy out the Dos name
    if( pDosPort )
        wcscpy( pDosPort, Ptr );
#endif

    // Skip over "Client\"
    Ptr = pName + 7;

    //
    // Now copy the ICAName#, or WinStationName to a local
    // buffer for further processing

    i = 0;
    NameBuf[i] = 0;

    while( *Ptr ) {

        if( *Ptr == '\\' ) {
            NameBuf[i] = 0;
            break;
        }
        NameBuf[i] = *Ptr;
        Ptr++;
        i++;
    }

    //
    // Ptr now points to the '\\' after the
    // WinStation or ICA name. After this slash,
    // is the rest of the printer or port name.
    //
    Ptr++;

    // Copy out the Dos name
    if( pDosPort )
        wcscpy( pDosPort, Ptr );

    //
    // See if this is an ICA name, or a WinStation name
    //
    Ptr = wcschr( NameBuf, L'#' );
    if( Ptr != NULL ) {

        // NULL terminate the ICAName and copy it out
        *Ptr = (WCHAR)NULL;
        if( pUser )
            wcscpy( pUser, NameBuf );

        // Set the type to an ICA named roving WinStation
        *pType = PortNameICA;
    }
    else {

        //
        // The name will be treated as a WinStation name
        //
        if( pUser )
            wcscpy( pUser, NameBuf );

        *pType = PortNameHardWire;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\dirwalk.c ===
/*************************************************************************
*
* dirwalk.c
*
* Walk a tree setting ACL's on an NT system.
*
* Copyright Microsoft, 1998
*
*
*
*************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <process.h>

#include <winsta.h>
#include <syslib.h>

#include "security.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


// Global variables
PWCHAR gpAvoidDir = NULL;

CRITICAL_SECTION SyslibCritSect;


typedef BOOLEAN (CALLBACK* NODEPROC)( PWCHAR, PWIN32_FIND_DATAW, DWORD, DWORD );

BOOLEAN
EnumerateDirectory(
    PWCHAR   pRoot,
    DWORD    Level,
    NODEPROC pProc
    );

BOOLEAN
NodeEnumProc(
    PWCHAR pParent,
    PWIN32_FIND_DATA p,
    DWORD  Level,
    DWORD  Index
    );

PWCHAR
AddWildCard(
    PWCHAR pRoot
    );

PWCHAR
AddBackSlash(
    PWCHAR pRoot
    );

FILE_RESULT
xxxProcessFile(
    PWCHAR pParent,
    PWIN32_FIND_DATAW p,
    DWORD  Level,
    DWORD  Index
    );

/*****************************************************************************
 *
 *  CtxGetSyslibCritSect
 *
 *   Returns the library global critical section pointer.
 *   Critical section will be initialised if necessary
 *
 * ENTRY:
 *    VOID - Caller must ensure that only one threads a times calls this
 *           function. The function will not itself guarantie mutual exclusion.
 * EXIT:
 *   Pointer to critical section. NULL if failure.
 *
 ****************************************************************************/


PCRITICAL_SECTION
CtxGetSyslibCritSect(void)
{
    static BOOLEAN fInitialized = FALSE;
    NTSTATUS Status;

    if( !fInitialized ){

            Status = RtlInitializeCriticalSection(&SyslibCritSect);
            if (NT_SUCCESS(Status)) {
                fInitialized = TRUE;
            }else{
                return NULL;
            }

    }
    return(&SyslibCritSect);
}


/*****************************************************************************
 *
 *  SetFileTree
 *
 *   Walk the given tree calling the processing function for each node.
 *
 * ENTRY:
 *   pRoot (input)
 *     Full WIN32 path to directory to walk
 *
 *   pVoidDir (input)
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
SetFileTree(
    PWCHAR   pRoot,
    PWCHAR   pAvoidDir
    )
{
    BOOLEAN rc;
    PWCHAR pRootNew;
    static BOOLEAN fInitialized = FALSE;
    PRTL_CRITICAL_SECTION pLock = CtxGetSyslibCritSect(); 

    // if critical section could not be created, do nothing.

    if (pLock == NULL) {
        return FALSE;
    }
    DBGPRINT(( "entering SetFileTree(pRoot=%ws,pAvoidDir=%ws)\n", pRoot, pAvoidDir ));

    EnterCriticalSection(pLock);
    // If this is the console make sure the user hasn't changed

    if ((NtCurrentPeb()->SessionId == 0) && fInitialized) {
        CheckUserSid();

    } else if ( !fInitialized ) {
       fInitialized = TRUE;
       if ( !InitSecurity() ) {
          DBGPRINT(( "problem initializing security; we're outta here.\n" ));
          LeaveCriticalSection(pLock);
          return( 1 ); // (non-zero for error...)// Should be return FALSE!?
       }
    }
    LeaveCriticalSection(pLock);

    gpAvoidDir = pAvoidDir;

    // be sure to apply security to root directory
    pRootNew = AddBackSlash(pRoot);
    if(pRootNew) {
        DBGPRINT(( "processing file %ws\n", pRootNew ));
        xxxProcessFile(pRootNew, NULL, 0, 0);
        LocalFree(pRootNew);
    }

    rc = EnumerateDirectory( pRoot, 0, NodeEnumProc );
    DBGPRINT(( "leaving SetFileTree()\n" ));
    return( rc );
}

/*****************************************************************************
 *
 *  EnumerateDirectory
 *
 *   Walk the given directory calling the processing function for each file.
 *
 * ENTRY:
 *   pRoot (input)
 *     Full WIN32 path to directory to walk
 *
 *   Level (input)
 *     Level we are in a given tree. Useful for formating output
 *
 *   pProc (input)
 *     Procedure to call for each non-directory file
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
EnumerateDirectory(
    PWCHAR   pRoot,
    DWORD    Level,
    NODEPROC pProc
    )
{
    BOOL rc;
    DWORD Result;
    HANDLE hf;
    DWORD Index;
    WIN32_FIND_DATA Data;
    PWCHAR pRootNew;

    DBGPRINT(( "entering EnumerateDirectory(pRoot=%ws,Level=%ld,pProc=NodeEnumProc)\n",pRoot,Level ));

    if( pRoot == NULL ) {
        DBGPRINT(( "leaving EnumerateDirectory(), return=FALSE\n" ));
        return( FALSE );
    }

    // Make sure it is not one we want to avoid
    if( gpAvoidDir ) {
        DWORD Len = wcslen( gpAvoidDir );

        if( _wcsnicmp( pRoot, gpAvoidDir, Len ) == 0 ) {
            DBGPRINT(( "leaving EnumerateDirectory(), return=FALSE\n" ));
            return( FALSE );
        }
    }

    pRootNew = AddWildCard( pRoot );
    if( pRootNew == NULL ) {
        DBGPRINT(( "leaving EnumerateDirectory(), return=FALSE\n" ));
        return( FALSE );
    }

    Index = 0;

    DBGPRINT(("FindFirstFileW: %ws\n",pRootNew));

    hf = FindFirstFileW(
             pRootNew,
             &Data
             );

    if( hf == INVALID_HANDLE_VALUE ) {
        DBGPRINT(("EnumerateDirectory: Error %d opening root %ws\n",GetLastError(),pRootNew));
        LocalFree( pRootNew );
        DBGPRINT(( "leaving EnumerateDirectory(), return=FALSE\n" ));
        return(FALSE);
    }

    while( 1 ) {

        // pass the parent without the wildcard added
        pProc( pRoot, &Data, Level, Index );

        rc = FindNextFile(
                 hf,
                 &Data
                 );

        if( !rc ) {
            Result = GetLastError();
            if( Result == ERROR_NO_MORE_FILES ) {
                FindClose( hf );
                LocalFree( pRootNew );
                DBGPRINT(( "leaving EnumerateDirectory(), return=TRUE\n" ));
                return( TRUE );
            }
            else {
                DBGPRINT(("EnumerateDirectory: Error %d, Index 0x%x\n",Result,Index));
                FindClose( hf );
                LocalFree( pRootNew );
                DBGPRINT(( "leaving EnumerateDirectory(), return=FALSE\n" ));
                return( FALSE );
            }
        }

        Index++;
    }

// UNREACHABLE.

}

/*****************************************************************************
 *
 *  NodeEnumProc
 *
 *   Process the enumerated file
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
NodeEnumProc(
    PWCHAR pParent,
    PWIN32_FIND_DATAW p,
    DWORD  Level,
    DWORD  Index
    )
{
    BOOLEAN rc;
    PWCHAR  pParentNew;
    DWORD   ParentCount, ChildCount;

    //
    // We must append the directory to our parent path to get the
    // new full path.
    //

    ParentCount = wcslen( pParent );
    ChildCount  = wcslen( p->cFileName );

    pParentNew = LocalAlloc( LMEM_FIXED, (ParentCount + ChildCount + 2)*sizeof(WCHAR) );

    if( pParentNew == NULL ) return( FALSE );

    wcscpy( pParentNew, pParent );
    wcscat( pParentNew, L"\\" );
    wcscat( pParentNew, p->cFileName );

    if( p->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

        // Skip "." and ".."
        if( wcscmp( L".", p->cFileName ) == 0 ) {
            LocalFree( pParentNew );
            return( TRUE );
        }

        if( wcscmp( L"..", p->cFileName ) == 0 ) {
            LocalFree( pParentNew );
            return( TRUE );
        }

        TRACE0(("%ws:\n",pParentNew));

        xxxProcessFile( pParentNew, p, Level, Index );

        // For directories, we recurse
        rc = EnumerateDirectory( pParentNew, Level+1, NodeEnumProc );

        LocalFree( pParentNew );

        return( rc );
    }

    TRACE0(("%ws\n",pParentNew));

    xxxProcessFile( pParentNew, p, Level, Index );

    LocalFree( pParentNew );

    return( TRUE );
}

/*****************************************************************************
 *
 *  AddWildCard
 *
 *   Add the wild card search specifier
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PWCHAR
AddWildCard(
    PWCHAR pRoot
    )
{
    DWORD  Count;
    PWCHAR pNew;
    PWCHAR WildCard = L"\\*";

    Count = wcslen( pRoot );
    pNew = LocalAlloc( LMEM_FIXED, (Count + wcslen(WildCard) + 1)*sizeof(WCHAR) );

    if( pNew == NULL ) {
        return( NULL );
    }

    wcscpy( pNew, pRoot );
    wcscat( pNew, WildCard );

    return( pNew );
}

/*****************************************************************************
 *
 *  AddBackSlash
 *
 *   Add the backslash character to path
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PWCHAR
AddBackSlash(
    PWCHAR pRoot
    )
{
    DWORD  Count;
    PWCHAR pNew;
    PWCHAR BackSlash = L"\\";

    Count = wcslen( pRoot );
    pNew = LocalAlloc( LMEM_FIXED, (Count + wcslen(BackSlash) + 1)*sizeof(WCHAR) );

    if( pNew == NULL ) {
        return( NULL );
    }

    wcscpy( pNew, pRoot );

    // only add backslash if string doesn't already have it
    if(*(pRoot+Count-1) != L'\\')
        wcscat( pNew, BackSlash );

    return( pNew );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tstst\tstst.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation



#include "stdafx.h"
#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>
#include <dsrole.h>


//
// global utilities and veraibles.
//

char szOutput[2048];
ostrstream szMoreInfo(szOutput, 4096);


TCHAR *ReturnBuffer()
{
    static TCHAR szReturnTchar[512];
    return szReturnTchar;
}


const OSVERSIONINFOEX *GetOSVersionInfo()
{
    static OSVERSIONINFOEX gOsVersion;
    static bGotOnce = FALSE;
    if (!bGotOnce)
    {
        ZeroMemory(&gOsVersion, sizeof(OSVERSIONINFOEX));
        gOsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        GetVersionEx( (LPOSVERSIONINFO ) &gOsVersion);
        bGotOnce = TRUE;
    }

    return &gOsVersion;
}



// #include <strstream>
#include "winsock2.h"


// ostringstream sz

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(P)          (P)
#endif

#define OLD_VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))


BOOL CheckifBinaryisSigned        (TCHAR *szFile);  // from tscert.cpp
BOOL EnumerateLicenseServers      ();               // from timebomb.cpp
TCHAR *IsBetaSystem                 ();
BOOL HasLicenceGracePeriodExpired ();               // from timebomb.cpp
BOOL ExtractAllTSEvents();


BOOL ValidateProductSuite (LPSTR SuiteName);
BOOL IsTerminalServicesEnabled ( VOID );
DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, BOOL *pbFound);
BOOL DoesHydraKeysExists ();
TCHAR *IsServer ();
BOOL IsKernelTSEnable ();
BOOL TSEnabled ();
BOOL DoesProductSuiteContainTS ();
BOOL IsTerminalServerRegistryOk ();
TCHAR *IsTerminalServiceStartBitSet ();
BOOL IsTermDDStartBitSet ();
BOOL GetTSOCLogFileName (char *strFileName, UINT uiSize);
BOOL DidTsOCgetCompleteInstallationMessage ();
BOOL FileExists (char *pszFullNameAndPath);
BOOL IsTSOClogPresent ();
BOOL DidOCMInstallTSEnable();
TCHAR *IsClusteringInstalled ();
BOOL IsRemoteAdminMode ();
BOOL CheckModeRegistry (BOOL bAppCompat);
BOOL IsTerminalServiceRunning ();
BOOL CheckVideoKeys ();
BOOL CheckModePermissions(DWORD *pdwSecurtyMode);
BOOL IsFile128Bit(LPTSTR szFile, BOOL *pb128Bit);
ULONG RDPDRINST_DetectInstall();    // defined in drdetect.cpp
BOOL IsAudioOk( VOID );


TCHAR *aszStack[] = {
//  _T("noexport\%SystemRoot%\\system32\\drivers\\rdpwdd.sys"),
    _T("%SystemRoot%\\system32\\drivers\\termdd.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdasync.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdipx.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdnetb.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdpipe.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdspx.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdtcp.sys"),
    _T("%SystemRoot%\\system32\\drivers\\rdpwd.sys"),
    _T("%SystemRoot%\\system32\\rdpdd.dll"),
    _T("%SystemRoot%\\system32\\rdpwsx.dll")
};

TCHAR Version[256];
TCHAR *GetTSVersion()
{
	CRegistry oRegTermsrv;
	DWORD cbVersion = 0;
	LPTSTR szVersion = NULL;

	if ((ERROR_SUCCESS == oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ)) &&
		(ERROR_SUCCESS == oRegTermsrv.ReadRegString(_T("ProductVersion"), &szVersion, &cbVersion)))
	{
		_tcscpy(Version, szVersion);
		return Version;
	}

	return _T("Error finding Version.");
}

BOOL IsIt50TS()
{
	return (0 == _tcsicmp(Version, _T("5.0")));
}

BOOL IsIt51TS()
{
	return (0 == _tcsicmp(Version, _T("5.1")));
}


TCHAR *IsLicenceGracePeriodOk ()
{
    return  (HasLicenceGracePeriodExpired () ? _T("Yep, Its expired") : _T("Its Not expired"));
}


BOOL Check_termdd()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\termdd.sys"));
}
BOOL Check_tdasync()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\tdasync.sys"));
}
BOOL Check_tdipx()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\tdipx.sys"));
}
BOOL Check_tdnetb()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\tdnetb.sys"));
}
BOOL Check_tdpipe()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\tdpipe.sys"));
}
BOOL Check_tdspx()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\tdspx.sys"));
}
BOOL Check_tdtcp()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\tdtcp.sys"));
}
BOOL Check_rdpwd()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\drivers\\rdpwd.sys"));
}
BOOL Check_rdpdd()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\rdpdd.dll"));
}
BOOL Check_rdpwsx()
{
    return CheckifBinaryisSigned(_T("%SystemRoot%\\system32\\rdpwsx.dll"));
}


BOOL IsRdpDrInstalledProperly ()
{
    return RDPDRINST_DetectInstall();
}


TCHAR *GetModePermissions()
{
    CRegistry reg;
    DWORD dwSecurityMode;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ))
    {
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSUserEnabled"), &dwSecurityMode))
        {
            if (dwSecurityMode == 0)
            {
                return _T("Its W2k Compatible");
            }
            else if (dwSecurityMode == 1)
            {
                return _T("Its TS4 Compatible");

            }
            else
            {
                szMoreInfo << "SYSTEM\\CurrentControlSet\\Control\\Terminal Server/TSUserEnabled has wrong value" << dwSecurityMode << endl;
                return NULL;

            }
        }
    }

    return NULL;

}

BOOL CheckModePermissions (DWORD *pdwSecurtyMode)
{
//    PERM_WIN2K = 0,
//    PERM_TS4 = 1

    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ))
    {
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSUserEnabled"), pdwSecurtyMode))
        {
            return (*pdwSecurtyMode== 0) || (*pdwSecurtyMode== 1);
        }
    }

    return FALSE;
}

TCHAR *GetCypherStrenthOnRdpwd ()
{
    BOOL bFile128bit;
    if ( IsFile128Bit(_T("%SystemRoot%\\system32\\drivers\\rdpwd.sys"), &bFile128bit) )
    {
        return bFile128bit ? _T("128 Bit") : _T("56 Bit");
    }
    else
    {
        return NULL;
    }

}


BOOL IsFile128Bit(LPTSTR szFile, BOOL *pb128Bit)
{
    USES_CONVERSION;
    DWORD dwHandle;

    TCHAR szFullFile[MAX_PATH +1];

    BOOL bSuccess = FALSE;

    if (ExpandEnvironmentStrings(szFile, szFullFile, MAX_PATH))
    {
        if (FileExists(T2A(szFullFile)))
        {
            DWORD dwSize = GetFileVersionInfoSize(szFullFile, &dwHandle);
            if (dwSize > 0)
            {
                BYTE *pbData = new BYTE[dwSize];
                if (pbData)
                {
                    if (GetFileVersionInfo(szFullFile, 0, dwSize, pbData))
                    {
                        TCHAR *szFileDescription;
                        UINT uiLen = 0;
                        if (VerQueryValue(pbData, _T("\\StringFileInfo\\040904B0\\FileDescription"), (LPVOID *)&szFileDescription, &uiLen))
                        {
                            if (_tcsstr(szFileDescription, _T("Not for Export")))
                            {
                                *pb128Bit = TRUE;
                                bSuccess = TRUE;

                            }
                            else if (_tcsstr(szFileDescription, _T("Export Version")))
                            {
                                *pb128Bit = FALSE;
                                bSuccess = TRUE;
                            }
                        }
                    }

                    delete [] pbData;

                }

            }
        }
    }

    return bSuccess;
}



BOOL ValidateProductSuite (LPSTR SuiteName)
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPSTR ProductSuite = NULL;
    LPSTR p;

    Rslt = RegOpenKeyA(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\ProductOptions",
        &hKey
        );

    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueExA( hKey, "ProductSuite", NULL, &Type, NULL, &Size );
    if (Rslt != ERROR_SUCCESS || !Size)
        goto exit;

    ProductSuite = (LPSTR) LocalAlloc( LPTR, Size );
    if (!ProductSuite)
        goto exit;

    Rslt = RegQueryValueExA( hKey, "ProductSuite", NULL, &Type,
        (LPBYTE) ProductSuite, &Size );
     if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    p = ProductSuite;
    while (*p)
    {
        if (lstrcmpA( p, SuiteName ) == 0)
        {
            rVal = TRUE;
            break;
        }
        p += (lstrlenA( p ) + 1);
    }

exit:
    if (ProductSuite)
        LocalFree( ProductSuite );

    if (hKey)
        RegCloseKey( hKey );

    return rVal;
}


BOOL IsTerminalServicesEnabled( VOID )
{
    BOOL    bResult = FALSE;
    DWORD   dwVersion;
    OSVERSIONINFOEXA osVersionInfo;
    DWORDLONG dwlConditionMask = 0;
    HMODULE hmodK32 = NULL;
    typedef ULONGLONG (*PFnVerSetConditionMask) ( ULONGLONG, ULONG, UCHAR );
    typedef BOOL      (*PFnVerifyVersionInfoA) (POSVERSIONINFOEXA, DWORD, DWORDLONG);
    PFnVerSetConditionMask pfnVerSetConditionMask;
    PFnVerifyVersionInfoA pfnVerifyVersionInfoA;


    dwVersion = GetVersion();

    /* are we running NT ? */
    if (!(dwVersion & 0x80000000))
    {
        // Is it NT 50 or greater ?
        if (LOBYTE(LOWORD(dwVersion)) > 4)
        {
            /* In NT5 we need to use the Product Suite APIs
             Don't static link because it won't load on non-NT5 systems */

            hmodK32 = GetModuleHandleA( "KERNEL32.DLL" );
            if (hmodK32)
            {
                pfnVerSetConditionMask = (PFnVerSetConditionMask )GetProcAddress( hmodK32, "VerSetConditionMask");

                if (pfnVerSetConditionMask)
                {
                    /* get the condition mask. */
                    dwlConditionMask = (*pfnVerSetConditionMask)(dwlConditionMask, VER_SUITENAME, VER_AND);

                    pfnVerifyVersionInfoA = (PFnVerifyVersionInfoA)GetProcAddress( hmodK32, "VerifyVersionInfoA") ;

                    if (pfnVerifyVersionInfoA != NULL)
                    {

                        ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));
                        osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
                        osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;
                        bResult = (*pfnVerifyVersionInfoA)(
                                          &osVersionInfo,
                                          VER_SUITENAME,
                                          dwlConditionMask);
                    }
                }
            }
        }
        else
        {
            /* This is NT 40 */
            bResult = ValidateProductSuite( "Terminal Server" );
        }
    }

    return bResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, BOOL *pbFound)
* checks if parameter string exists in given multistring.
* returns error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, BOOL *pbFound)
{
    ASSERT(szkey && *szkey);
    ASSERT(szvalue && *szvalue);
    ASSERT(szCheckForString&& *szCheckForString);
    ASSERT(*szkey != '\\');
    ASSERT(pbFound);

    // not yet found.
    *pbFound = FALSE;

    CRegistry reg;
    DWORD dwError = reg.OpenKey(hkey, szkey, KEY_READ);  // open up the required key.
    if (dwError == NO_ERROR)
    {
        LPTSTR szSuiteValue;
        DWORD dwSize;
        dwError = reg.ReadRegMultiString(szvalue, &szSuiteValue, &dwSize);
        if (dwError == NO_ERROR)
        {
            LPCTSTR pTemp = szSuiteValue;
            while(_tcslen(pTemp) > 0 )
            {
                if (_tcscmp(pTemp, szCheckForString) == 0)
                {
                    *pbFound = TRUE;
                    break;
                }

                pTemp += _tcslen(pTemp) + 1; // point to the next string within the multistring.
                if ( DWORD(pTemp - szSuiteValue) > (dwSize / sizeof(TCHAR)))
                    break; // temporary pointer passes the size of the szSuiteValue something is wrong with szSuiteValue.
            }
        }
    }

    return dwError;

}


BOOL DoesHydraKeysExists()
{
    BOOL bStringExists = FALSE;
    DWORD dw = IsStringInMultiString(
        HKEY_LOCAL_MACHINE,
        _T("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
        _T("ProductSuite"),
        _T("Terminal Server"),
        &bStringExists);

    return (dw == ERROR_SUCCESS) && bStringExists;
}






TCHAR *IsItAppServer ()
{
    return ((GetOSVersionInfo()->wSuiteMask & VER_SUITE_TERMINAL) &&
           !(GetOSVersionInfo()->wSuiteMask & VER_SUITE_SINGLEUSERTS)) ? _T("Yes") : _T("No");
}


BOOL IsItServer ()
{
    return GetOSVersionInfo()->wProductType != VER_NT_WORKSTATION;
}


TCHAR *GetProductType ()
{
    BYTE wProductType = GetOSVersionInfo()->wProductType;
    _tcscpy(ReturnBuffer(), _T(""));

    if (wProductType == VER_NT_WORKSTATION)
    {
        _tcscat(ReturnBuffer(), _T("VER_NT_WORKSTATION "));
    }

    if (wProductType == VER_NT_DOMAIN_CONTROLLER)
    {
        _tcscat(ReturnBuffer(), _T("VER_NT_DOMAIN_CONTROLLER"));
    }

    if (wProductType == VER_NT_SERVER)
    {
        _tcscat(ReturnBuffer(), _T("VER_NT_SERVER"));
    }

    return ReturnBuffer();

}

TCHAR *GetProductSuite ()
{
    WORD wProductSuite = GetOSVersionInfo()->wSuiteMask;
    _tcscpy(ReturnBuffer(), _T(""));

    if (wProductSuite & VER_SERVER_NT)
    {
        _tcscat(ReturnBuffer(), _T("VER_SERVER_NT "));

    }
    if (wProductSuite & VER_WORKSTATION_NT)
    {
        _tcscat(ReturnBuffer(), _T("VER_WORKSTATION_NT "));

    }
    if (wProductSuite & VER_SUITE_SMALLBUSINESS)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_SMALLBUSINESS "));

    }
    if (wProductSuite & VER_SUITE_ENTERPRISE)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_ENTERPRISE "));

    }
    if (wProductSuite & VER_SUITE_BACKOFFICE)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_BACKOFFICE "));

    }
    if (wProductSuite & VER_SUITE_COMMUNICATIONS)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_COMMUNICATIONS "));

    }
    if (wProductSuite & VER_SUITE_TERMINAL)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_TERMINAL "));

    }
    if (wProductSuite & VER_SUITE_SMALLBUSINESS_RESTRICTED)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_SMALLBUSINESS_RESTRICTED "));

    }
    if (wProductSuite & VER_SUITE_EMBEDDEDNT)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_EMBEDDEDNT "));

    }
    if (wProductSuite & VER_SUITE_DATACENTER)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_DATACENTER "));

    }
    if (wProductSuite & VER_SUITE_SINGLEUSERTS)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_SINGLEUSERTS "));

    }
    if (wProductSuite & VER_SUITE_PERSONAL)
    {
        _tcscat(ReturnBuffer(), _T("VER_SUITE_PERSONAL "));

    }
    return ReturnBuffer();
}


TCHAR *IsServer ()
{
    return IsItServer() ? _T("Its a Server") : _T("Its a WorkStation");
}



BOOL IsKernelTSEnable ()
{
    return IsTerminalServicesEnabled();
}

BOOL TSEnabled ()
{

    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ))
    {
        DWORD dwTSEnabled = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSEnabled"), &dwTSEnabled))
        {
            return dwTSEnabled == 1;
        }
    }

    return FALSE;
}

BOOL DoesProductSuiteContainTS ()
{
    return DoesHydraKeysExists ();
}

BOOL IsTerminalServerRegistryOk ()
{
    CRegistry reg1;
    CRegistry reg2;
    CRegistry reg3;

    return
    (ERROR_SUCCESS == reg1.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ)) &&
    (ERROR_SUCCESS == reg2.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations"), KEY_READ)) &&
    (ERROR_SUCCESS == reg3.OpenKey(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"), KEY_READ));
}

TCHAR *GetWinstationList ()
{
    TCHAR szWinstationList[256];
    BOOL bFoundNonConsoleWinstation = FALSE;
    _tcscpy(szWinstationList, _T(""));
    CRegistry reg2;
    if (ERROR_SUCCESS == reg2.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations"), KEY_READ))
    {
        LPTSTR szWinstation;
        DWORD dwSize;
        BOOL bFirst = TRUE;

        if (ERROR_SUCCESS == reg2.GetFirstSubKey(&szWinstation, &dwSize))
        {
            do
            {
                if (0 != _tcsicmp(szWinstation, _T("Console")))
                {
                    bFoundNonConsoleWinstation = TRUE;
                }

                if (!bFirst)
                {
                    _tcscat(szWinstationList, _T(", "));
                }

                _tcscat(szWinstationList, szWinstation);
                bFirst = FALSE;
            }
            while (ERROR_SUCCESS == reg2.GetNextSubKey(&szWinstation, &dwSize));
        }
    }

    if (_tcslen(szWinstationList) == 0)
    {
        _tcscpy(szWinstationList, _T("Error, No winstations found."));
    }

    if (!bFoundNonConsoleWinstation)
    {
        szMoreInfo << "ERROR, No non Console Winstation not found" << endl;
    }

    _tcscpy(ReturnBuffer(), szWinstationList);
    return ReturnBuffer();

}

TCHAR *IsTerminalServiceStartBitSet ()
{

    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermService"), KEY_READ))
    {
        DWORD dwTermServStartBit = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("Start"), &dwTermServStartBit))
        {
            switch (dwTermServStartBit)
            {
                case 2:
                return _T("AutoStart");
                break;

                case 3:
                return _T("Manual Start");
                break;

                case 4:
                return _T("Error, Disabled");
                break;

                default:
                return _T("ERROR:Wrong value for startbit");
            }

        }
    }

    return _T("Error, Reading startbig");
}

BOOL IsTermDDStartBitSet ()
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermDD"), KEY_READ))
    {
        DWORD dwTermDDStartBit = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("Start"), &dwTermDDStartBit))
        {
            return dwTermDDStartBit == 2;
        }
    }

    return FALSE;
}

TCHAR *AreEffectiveConnectionAllowed ()
{
    HMODULE hmodRegAPI = LoadLibrary( _T("RegApi.dll") );

    if (hmodRegAPI)
    {

        typedef BOOLEAN (*PFDenyConnectionPolicy) ();
        PFDenyConnectionPolicy pfnDenyConnectionPolicy;

        pfnDenyConnectionPolicy = (PFDenyConnectionPolicy) GetProcAddress( hmodRegAPI, "RegDenyTSConnectionsPolicy");
        if (pfnDenyConnectionPolicy)
        {
              return (*pfnDenyConnectionPolicy)() ? _T("Not Allowed") : _T("Allowed");

        }
        else
        {
            szMoreInfo << "Failed to get proc RegDenyTSConnectionsPolicy" << endl;
            return _T("Failed");
        }
    }
    else
    {
       szMoreInfo << "Failed to Load regapi.dll" << endl;
       return _T("Failed");
    }


}

TCHAR *AreConnectionsAllowed ()
{
	DWORD dwError;
	CRegistry oRegTermsrv;

	dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ);
	if (ERROR_SUCCESS == dwError)
	{
		DWORD dwDenyConnect;
		dwError = oRegTermsrv.ReadRegDWord(_T("fDenyTSConnections"), &dwDenyConnect);
		if (ERROR_SUCCESS == dwError)
		{
			return dwDenyConnect ? _T("No, Not allowed") : _T("Yes");
		}
	}

	//
	// could not read registry, It means - for 51 connection not allowed. For 50 Connections allowed.
	//

	return IsIt51TS() ? _T("Error, Value not found") : _T("Yes");
}

BOOL GetTSOCLogFileName(char *strFileName, UINT uiSize)
{
    if (!GetSystemWindowsDirectoryA(strFileName, uiSize))
        return FALSE;

    strcat(strFileName, "\\tsoc.log");
    ASSERT(strlen(strFileName) < uiSize);
    return TRUE;
}

char *IncompleteMessage = "Error:TSOC Did not get OC_COMPLETE_INSTALLATION.";
BOOL DidTsOCgetCompleteInstallationMessage ()
{

    if (!IsTSOClogPresent())
    {
        szMoreInfo << "tsoc.log does not exist." << endl;
        return FALSE;
    }

    char strTSOCLog[256];
    GetTSOCLogFileName(strTSOCLog, 256);

	ifstream ifSrc(strTSOCLog);
	if(!ifSrc)
    {
        szMoreInfo << "Failed to open tsoc.log file." << endl;
        return FALSE;
    }


    char tempSrc[256];
	while(!ifSrc.eof())
	{
		ifSrc.getline(tempSrc, 256);
        if (strstr(tempSrc, IncompleteMessage))
        {
            return FALSE;
        }
	}

    return TRUE;
}

BOOL FileExists(char *pszFullNameAndPath)
{
    ASSERT(pszFullNameAndPath);

    if (pszFullNameAndPath && pszFullNameAndPath[0])
    {
        HANDLE hFile = CreateFileA(pszFullNameAndPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
					              NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	    if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
            return TRUE;
        }
    }

    return FALSE;
}

BOOL IsTSOClogPresent ()
{
    char strTSOCLog[256];
    GetTSOCLogFileName(strTSOCLog, 256);
    return FileExists(strTSOCLog);
}

BOOL DidOCMInstallTSEnable()
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\SubComponents"), KEY_READ))
    {
        DWORD dwTSEnabled = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("tsenable"), &dwTSEnabled))
        {
            return dwTSEnabled == 1;
        }
    }

    return FALSE;
}

TCHAR *IsClusteringInstalled ()
{
    DWORD dwClusterState;
    if (ERROR_SUCCESS == GetNodeClusterState(NULL, &dwClusterState))
    {
        if (dwClusterState != ClusterStateNotInstalled)
        {
            return _T("***Failed. Clustering is installed, this is not compatible with Terminal Server.");
       }

    }

    return _T("Passed");
}


TCHAR *GetTSMode (void)
{
    return IsRemoteAdminMode() ? _T("Remote Admin") : _T("Application Server");
}

BOOL IsRemoteAdminMode ()
{
    // HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server","TSAppCompat",0x00010001,0x0
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ))
    {
        DWORD dwAppCompat = 1;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSAppCompat"), &dwAppCompat))
        {
            return dwAppCompat == 0;
        }
        else
        {
            // if the registry TSAppCompat does not exist it means we are in app server mode.
            return FALSE;

        }
    }
    else
    {
        szMoreInfo << "ERROR:SYSTEM\\CurrentControlSet\\Control\\Terminal Server not found!" << endl;
    }

    // this return is bogus.
    return TRUE;

}

BOOL VerifyModeRegistry()
{
    return CheckModeRegistry(!IsRemoteAdminMode());
}

BOOL CheckModeRegistry (BOOL bAppCompat)
{
    USES_CONVERSION;
    BOOL bOk = TRUE;

    CRegistry reg;

    if (IsItServer())
    {
        CRegistry reg1;

        // check registry value
        // for appcompat mode
            //HKLM ,"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon","AppSetup",0x00000000,"UsrLogon.Cmd"
        // and for remote admin mode
            //HKLM ,"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon","AppSetup",0x00000000,""


        if ( ERROR_SUCCESS == reg1.OpenKey( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), KEY_READ))
        {
            LPTSTR str;
            DWORD dwSize;
            if (ERROR_SUCCESS == reg1.ReadRegString(_T("AppSetup"), &str, &dwSize))
            {
                if (bAppCompat)
                {
                    if (_tcsicmp(str, _T("UsrLogon.Cmd")) != 0)
                    {
                        bOk = FALSE;
                        szMoreInfo << "ERROR: Wrong value (" << T2A(str) << ") for AppSetup, contact makarp/breenh" << endl;
                    }

                }
                else
                {
                    if (_tcslen(str) != 0)
                    {
                        bOk = FALSE;
                        szMoreInfo << "ERROR: Wrong value (" << T2A(str) << ") for AppSetup, contact makarp/breenh" << endl;

                    }

                }

            }
            else
            {
                szMoreInfo << "ERROR reading appsetup registry" << endl;
                bOk = FALSE;
            }

        }
        else
        {
            szMoreInfo << "ERROR:reading SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon" << endl;
            bOk = FALSE;
        }

    }


    // check registry value
    // for appcompat mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\PriorityControl","Win32PrioritySeparation", 0x00010001,0x26
    // and for remote admin mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\PriorityControl","Win32PrioritySeparation", 0x00010001,0x18

    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\PriorityControl"), KEY_READ))
    {
        DWORD dwPriority;
        if (ERROR_SUCCESS == reg.ReadRegDWord(_T("Win32PrioritySeparation"), &dwPriority))
        {
            if (bAppCompat)
            {
                if (0x26 != dwPriority)
                {
                    bOk = FALSE;
                    szMoreInfo << "ERROR: Wrong Win32PrioritySeparation (" << dwPriority << ")" << endl;
                }

            }
            else if (IsItServer())
            {
                if (0x18 != dwPriority)
                {
                    bOk = FALSE;
                    szMoreInfo << "ERROR: Wrong Win32PrioritySeparation (" << dwPriority << ")" << endl;
                }

            }
        }
        else
        {
            bOk = FALSE;
            szMoreInfo << "ERROR:Reading Win32PrioritySeparation registry" << endl;

        }

    }
    else
    {
        bOk = FALSE;
        szMoreInfo << "ERROR:Reading PriorityControl registry" << endl;
    }


    // check registry value
    // for appcompat mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server","IdleWinStationPoolCount",0x00010001,0x2
    // and for remote admin mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server","IdleWinStationPoolCount",0x00010001,0x0


    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ))
    {
        DWORD dwIdleWinstations;
        if (ERROR_SUCCESS == reg.ReadRegDWord(_T("IdleWinStationPoolCount"), &dwIdleWinstations))
        {
            if (bAppCompat)
            {
                if (0x2 != dwIdleWinstations)
                {
                    bOk = FALSE;
                    szMoreInfo << "ERROR: Wrong IdleWinStationPoolCount (" << dwIdleWinstations << ")" << endl;
                }

            }
            else
            {
                if (0 != dwIdleWinstations)
                {
                    bOk = FALSE;
                    szMoreInfo << "ERROR: Wrong IdleWinStationPoolCount (" << dwIdleWinstations << ")" << endl;
                }

            }

        }
        else
        {
            bOk = FALSE;
            szMoreInfo << "ERROR:Reading IdleWinStationPoolCount registry" << endl;

        }

    }
    else
    {
        bOk = FALSE;
        szMoreInfo << "SYSTEM\\CurrentControlSet\\Control\\Terminal Server" << endl;
    }

    return bOk;


}

BOOL IsTerminalServiceRunning ()
{

    BOOL bReturn = FALSE;

    SC_HANDLE hServiceController = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (hServiceController)
    {

        SC_HANDLE hTermServ = OpenService(hServiceController, _T("TermService"), SERVICE_QUERY_STATUS);
        if (hTermServ)
        {
            SERVICE_STATUS tTermServStatus;
            if (QueryServiceStatus(hTermServ, &tTermServStatus))
            {
                bReturn = (tTermServStatus.dwCurrentState == SERVICE_RUNNING);
            }
            else
            {
                szMoreInfo << "Failed to get service status, Error = " << GetLastError() << endl;

            }

            VERIFY(CloseServiceHandle(hTermServ));

        }
        else
        {
            szMoreInfo << "Failed to open TermServ service, Error = " << GetLastError() << endl;
        }

        VERIFY(CloseServiceHandle(hServiceController));
    }
    else
    {
        szMoreInfo << "Failed to Open Service Controller, Error = " << GetLastError() << endl;
    }

    return bReturn;
}


BOOL CheckVideoKeys ()
{
    //    HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server\VIDEO\rdpdd","VgaCompatible",0x00000000,"\Device\Video0"
    //    HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server\VIDEO\rdpdd","\Device\Video0",0x00000000,"\REGISTRY\Machine\System\ControlSet001\Services\RDPDD\Device0"

    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\VIDEO\\rdpdd"), KEY_READ))
    {
        LPTSTR str = 0;
        DWORD dwSize = 0;
        if (ERROR_SUCCESS == reg.ReadRegString(_T("VgaCompatible"), &str, &dwSize))
        {
            if (0 == _tcsicmp(str, _T("\\Device\\Video0")))
            {
                if (ERROR_SUCCESS == reg.ReadRegString(_T("\\Device\\Video0"), &str, &dwSize))
                {
                    if ((0 == _tcsicmp(str, _T("\\REGISTRY\\Machine\\System\\ControlSet001\\Services\\RDPDD\\Device0"))) ||
                        (0 == _tcsicmp(str, _T("\\REGISTRY\\Machine\\System\\CurrentControlSet\\Services\\RDPDD\\Device0"))))
                    {
                        return TRUE;
                    }
                    else
                    {
                    }
                }
                else
                {
                }
            }
            else
            {

            }

        }
        else
        {
        }
    }
    else
    {
    }

    return FALSE;
}

TCHAR szCompName[256];
TCHAR *GetCompName ()
{
    DWORD dwCompName = 256;

    if (GetComputerName(szCompName, &dwCompName))
    {
        return szCompName;

    }

    return NULL;

}


TCHAR szDomNameWorkgroup[] = _T("<Workgroup>");
TCHAR szDomNameUnknown[] = _T("<Unknown>");
TCHAR *GetDomName ()
{
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomainInfo = NULL;
    DWORD dwErr;

    //
    // Check if we're in a workgroup
    //
    dwErr = DsRoleGetPrimaryDomainInformation(NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *) &pDomainInfo);

    if (ERROR_SUCCESS != dwErr)
        return szDomNameUnknown;

    switch (pDomainInfo->MachineRole)
    {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            return szDomNameWorkgroup;
            break;      // just in case
    }

    if (pDomainInfo->DomainNameFlat)
        return pDomainInfo->DomainNameFlat;
    else if (pDomainInfo->DomainNameDns)
        return pDomainInfo->DomainNameDns;
    else
        return szDomNameUnknown;
}

WCHAR wszIPAddress[128] = L"<error>";
TCHAR *GetIPAddress ()
{
	//get host address
	WORD wVersionRequested = MAKEWORD( 1, 1 ); 
	WSADATA wsaData;
	if (0 == WSAStartup(wVersionRequested,&wsaData))
    {
        char szHostName[256];

        if (0 == gethostname ( szHostName , 256 ))
        {
            hostent *h;
            if (NULL != (h=gethostbyname ( szHostName )))
            {
                in_addr *inaddr=(struct in_addr *)*h->h_addr_list;

                MultiByteToWideChar(CP_ACP,0,inet_ntoa(*inaddr),-1,wszIPAddress,128);
            }
        }
    }

    return wszIPAddress;
}




TCHAR *IsRDPNPinNetProviders ()
{
    TCHAR NEWORK_PROVIDER_ORDER_KEY[] = _T("SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order");
    TCHAR PROVIDER_ORDER_VALUE[]      = _T("ProviderOrder");
    TCHAR RDPNP_ENTRY[]               = _T("RDPNP");
	BOOL bRdpNpExists				  = FALSE;

	// read network privider key.
	CRegistry regNetOrder;
	LPTSTR szOldValue;
	DWORD dwSize;
	if ((ERROR_SUCCESS == regNetOrder.OpenKey(HKEY_LOCAL_MACHINE, NEWORK_PROVIDER_ORDER_KEY), KEY_READ) && 
	   (ERROR_SUCCESS == regNetOrder.ReadRegString(PROVIDER_ORDER_VALUE, &szOldValue, &dwSize)))
	{
		bRdpNpExists = (_tcsstr(szOldValue, RDPNP_ENTRY) != NULL);
	
	}

	if (TSEnabled () == bRdpNpExists)
	{
		return (_T("Passed"));
	}
	else
	{
		if (bRdpNpExists)
		{
			return _T("Error: RDPNP, exists in ProviderOrder, but TS is disabled!");
		}
		else
		{
			if (IsIt50TS())
			{
				// rdp np is only for 51+ so its ok if its missing for 50.
				return _T("Passed");
			}
			else
			{
				return _T("ERROR, RDPNP is missing from ProviderOrder");
			}
		}
	}
}



TCHAR *IsMultiConnectionAllowed ()
{
	// SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon","AllowMultipleTSSessions
	CRegistry regWL;
	DWORD dwAllowMultipal;
	if ((ERROR_SUCCESS == regWL.OpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), KEY_READ)) &&
		(ERROR_SUCCESS == regWL.ReadRegDWord(_T("AllowMultipleTSSessions"), &dwAllowMultipal)))
	{
		return dwAllowMultipal ? _T("Yes") : _T("No");
	}

	if (IsIt50TS())
	{
		return _T("Yes");
	}
	else
	{
		return _T("ERROR, registry missing");
	}
}

TCHAR *LogonType ()
{
	if (0 == _tcsicmp(GetDomName(), szDomNameWorkgroup))
	{
		CRegistry regWL;
		DWORD dwLogonType;
		if ((ERROR_SUCCESS == regWL.OpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), KEY_READ)) &&
			(ERROR_SUCCESS == regWL.ReadRegDWord(_T("LogonType"), &dwLogonType)))
		{
			return dwLogonType == 0 ? _T("Classic Gina") : _T("New Fancy");
		}

		if (IsIt50TS())
		{
			return _T("Classic");
		}
		else
		{
			return _T("ERROR, registry missing");
		}
	}
	else
	{
		return _T("Classic Gina");
	}
}

BOOL IsTermSrvInSystemContext ()
{
    USES_CONVERSION;
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermService"), KEY_READ))
    {
        TCHAR *szObjectName;
        DWORD dwSize;
        if ( ERROR_SUCCESS == reg.ReadRegString( _T("ObjectName"), &szObjectName, &dwSize))
        {
            if (0 == _tcsicmp(szObjectName, _T("LocalSystem")))
            {
                return TRUE;
            }
            else
            {
                szMoreInfo << "ERROR:Termsrv is set to run using (" << T2A(szObjectName) << ") context." << endl;
            }
        }
        else
        {
            szMoreInfo << "failed to read Objectname" << endl;
        }
    }
    else
    {
        szMoreInfo << "failed to open termsrv registry" << endl;
    }

    return FALSE;

}


BOOL DontRun ()
{
    szMoreInfo << "test not run because its not required." << endl;
    return FALSE;
}
BOOL DoRun ()
{
    szMoreInfo << "this test must be run." << endl;
    return TRUE;
}

TCHAR *SystemDirectory()
{
    TCHAR sysdir[MAX_PATH];
    sysdir[0] = '\0';
    if (GetSystemDirectory(sysdir, MAX_PATH) >= MAX_PATH) {
        sysdir[MAX_PATH -1] = '\0';
    }
    _tcscpy(ReturnBuffer(), sysdir);
    return  ReturnBuffer();
}


int
#if !defined(_MIPS_) && !defined(_ALPHA_) && !defined(_PPC_)
_cdecl
#endif
main( int  argc , char ** /* argv */)
{
    typedef BOOL    (PFN_BOOL)(void);
    typedef TCHAR * (PFN_TestSubjective)(void);


    USES_CONVERSION;

    struct TVerificationTest
    {
        char szTestName[256];                   // descriptive name of the test
        PFN_BOOL           *pfnNeedRunTest;     // pointer to function that will be called to decide if the test need run, test is run if NULL.
        PFN_TestSubjective *pfnSubTest;         // pointer to function if the test returns TCHAR *
        PFN_BOOL           *pfnObjTest;         // pointer to function if the test returns BOOL
    }
    theTests[] =
    {
//        {"DontRun...............................", DontRun, GetCompName, NULL},
//        {"DoRun...............................", DoRun, GetCompName, NULL},

        {"Machine Name...............................", NULL, GetCompName, NULL},
        {"Domain Name................................", NULL, GetDomName, NULL},
        {"IP Address.................................", NULL, GetIPAddress, NULL},
        {"System Dir.................................", NULL, SystemDirectory, NULL},
		{"ProductType................................", NULL, GetProductType, NULL},
		{"ProductSuite...............................", NULL, GetProductSuite, NULL},
		{"TS Version.................................", NULL, GetTSVersion, NULL},
        {"Is this a server machine?..................", NULL, IsServer, NULL},
        {"Is tsoc.log Present?.......................", NULL, NULL, IsTSOClogPresent},
        {"Did TsOC get CompleteInstallationMessage...", NULL, NULL, DidTsOCgetCompleteInstallationMessage},
        {"Is Clustering Services installed...........", NULL, IsClusteringInstalled, NULL},
        {"Does ProductSuite Contain TS?..............", NULL, NULL, DoesProductSuiteContainTS},
        {"Did OCM Install TSEnable...................", IsIt50TS, NULL, DidOCMInstallTSEnable},
        {"Is TSEnabled registry alright?.............", NULL, NULL, TSEnabled},
        {"Is Kernel TSEnabled?.......................", IsItServer, NULL, IsKernelTSEnable},
        {"Is Terminal Server Registry Ok?............", NULL, NULL, IsTerminalServerRegistryOk},
        {"GetWinstationList..........................", NULL, GetWinstationList, NULL},
        {"Is TermServ Start Bit Ok?..................", NULL, IsTerminalServiceStartBitSet, NULL},
        {"Is TermServ service running?...............", NULL, NULL, IsTerminalServiceRunning},
        {"Is TermSrv in System Context?..............", NULL, NULL, IsTermSrvInSystemContext},
        {"AreEffectiveConnectionAllowed..............", IsIt51TS, AreEffectiveConnectionAllowed, NULL },
        {"Are Connections Allowed?...................", IsIt51TS, AreConnectionsAllowed, NULL},
        {"Is RdpDr Installed Properly?...............", NULL, NULL, IsRdpDrInstalledProperly},
		{"Is RdpNP in NetProviders?..................", IsIt51TS, IsRDPNPinNetProviders, NULL},
		{"Are Multipal Connections Allowed...........", IsIt51TS, IsMultiConnectionAllowed, NULL},
		{"Logon UI type..............................", IsIt51TS, LogonType, NULL},
        {"Are Video keys setup right?................", NULL, NULL, CheckVideoKeys},
        {"What mode is Terminal Server set in?.......", NULL, GetTSMode, NULL},
        {"Is mode specific registry ok?..............", NULL, NULL, VerifyModeRegistry},
        {"What is permission Mode set to?............", NULL, GetModePermissions, NULL},
        {"Check termdd signature.....................", NULL, NULL, Check_termdd},
        {"Check tdpipe signature.....................", NULL, NULL, Check_tdpipe},
        {"Check tdtcp signature......................", NULL, NULL, Check_tdtcp},
        {"Check rdpwd signature......................", NULL, NULL, Check_rdpwd},
        {"Check rdpdd signature......................", NULL, NULL, Check_rdpdd},
        {"Check rdpwsx signature.....................", NULL, NULL, Check_rdpwsx},
        {"Is it 56 bit or 128?.......................", NULL, GetCypherStrenthOnRdpwd, NULL},
        {"Is this a Beta System?.....................", NULL, IsBetaSystem, NULL},
        {"Has Licence GracePeriod Expired............", NULL, IsLicenceGracePeriodOk, NULL},
        {"Audio test.................................", IsIt51TS, NULL, IsAudioOk}
    };

    BOOL bEverythingOk = TRUE;
    for (int i=0; i < sizeof(theTests)/sizeof(theTests[0]); i++)
    {
        ASSERT(theTests[i].pfnObjTest || theTests[i].pfnSubTest);
        ASSERT(!(theTests[i].pfnObjTest && theTests[i].pfnSubTest));

        if (theTests[i].pfnNeedRunTest && !(*(theTests[i].pfnNeedRunTest))())
        {
            // we asre asked to skip the test.
            cout << theTests[i].szTestName << "Skipped Test" << endl;
        }
        else
        {
            if (theTests[i].pfnObjTest)
            {
                BOOL bResult = (*(theTests[i].pfnObjTest))();
                cout << theTests[i].szTestName <<  (bResult ? "Passed" : "Failed") << endl;
                if (!bResult)
                    bEverythingOk = FALSE;

            }
            else
            {
                char *szStr = T2A((*(theTests[i].pfnSubTest))());
                if (szStr)
                {
                    cout << theTests[i].szTestName << szStr  << endl;
                }
            }
        }


        //
        // if previous test had any details to tell us
        //

        if (szMoreInfo.pcount())
        {
            char *pStr = szMoreInfo.str();
            cout << "   Details:" << pStr;
            cout << "------------------------------------------------" << endl;

            bEverythingOk = FALSE;
            ZeroMemory(pStr, 512);
            szMoreInfo.seekp(ios::beg);

        }



    }

    cout << endl;



    if (argc == 1 ) // if some argumnent is provided skip these time consuming test.
    {

        cout << "Enumerating Licensing Servers (May take some time)...";
        cout.flush();
        if (EnumerateLicenseServers())
        {
                cout << ".....Passed, Found Some!" << endl;

        }
        else
        {
            cout << ".....Failed. No License Server Found." << endl;
        }

        cout << "Extracting Related Events from Event Log...";
        cout.flush();
        if (ExtractAllTSEvents())
        {
                cout << ".....Found Some. See if they give any clue." << endl;

        }
        else
        {
            cout << ".....Found None." << endl;
        }


    }



    cout << endl;
    if (bEverythingOk)
    {
        cout << endl;
        cout << "**************************************************************" << endl;
        cout << "*** Nothing wrong with TS could detected by this utility.  ***" << endl;
        cout << "*** If you think something is wrong contact the developer. ***" << endl;
        cout << "**************************************************************" << endl;
        return 0;

    }

    return 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\setup\tstst\timebomb.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include "license.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "secstore.h"
#include "..\conv.h"

#define LICENSING_TIME_BOMB L"TIMEBOMB_832cc540-3244-11d2-b416-00c04fa30cc4"
#define RTMLICENSING_TIME_BOMB L"RTMTSTB_832cc540-3244-11d2-b416-00c04fa30cc4"

#define LICENSING_TIME_BOMB_5_0 L"TIMEBOMB_832cc540-3244-11d2-b416-00c04fa30cc4"
#define RTMLICENSING_TIME_BOMB_5_0 L"RTMTSTB_832cc540-3244-11d2-b416-00c04fa30cc4"

// L$ means only readable from the local machine

#define BETA_LICENSING_TIME_BOMB_5_1 L"L$BETA3TIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define RTM_LICENSING_TIME_BOMB_5_1 L"L$RTMTIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define BETA_LICENSING_TIME_BOMB_LATEST_VERSION BETA_LICENSING_TIME_BOMB_5_1

#define RTM_LICENSING_TIME_BOMB_LATEST_VERSION RTM_LICENSING_TIME_BOMB_5_1

#define X509_CERT_PRIVATE_KEY_NAME \
    L"L$HYDRAENCKEY_dd2d98db-2316-11d2-b414-00c04fa30cc4"

///////////////////////////////////////////////////////////////////

typedef BOOL
(* TLSISBETANTSERVER)();

BOOL FIsBetaSystem ()
{
    HMODULE hmodTlsAPI = LoadLibrary( _T("mstlsapi.dll") );

    if (hmodTlsAPI)
    {
        TLSISBETANTSERVER pfnTLSIsBetaNTServer;
        BOOL fBeta = FALSE;
        
        pfnTLSIsBetaNTServer = (TLSISBETANTSERVER) GetProcAddress(hmodTlsAPI,"TLSIsBetaNTServer");

        if (NULL != pfnTLSIsBetaNTServer)
        {
            fBeta = pfnTLSIsBetaNTServer();
        }

        FreeLibrary(hmodTlsAPI);

        return fBeta;
    }
    else
    {
        return FALSE;
    }
}

TCHAR *IsBetaSystem ()
{
    return (FIsBetaSystem() ? _T("Its Beta") : _T("Its RTM"));
}

BOOL HasLicenceGracePeriodExpired ()
{
    DWORD status;
    DWORD  cbByte;
    PBYTE  pbByte = NULL;
    LPWSTR szTimeBombKey;
    FILETIME timebomb;
    FILETIME filetimeCurrent;
    DWORD dwVersion;

    dwVersion = GetVersion();

    if ((dwVersion & 0x80000000)
        || (LOBYTE(LOWORD(dwVersion)) <= 4))
    {
        cout << endl << "       Pre-Windows 2000.  No grace period" << endl;
        return FALSE;
    }
    else if ((LOBYTE(LOWORD(dwVersion)) == 5)
             && (HIBYTE(LOWORD(dwVersion)) == 0))
    {
        // Windows 2000

        if (FIsBetaSystem())
            szTimeBombKey = LICENSING_TIME_BOMB_5_0;
        else
            szTimeBombKey = RTMLICENSING_TIME_BOMB_5_0;
    }
    else if ((LOBYTE(LOWORD(dwVersion)) == 5)
             && (HIBYTE(LOWORD(dwVersion)) == 1))
    {
        // Whistler

        if (FIsBetaSystem())
            szTimeBombKey = BETA_LICENSING_TIME_BOMB_5_1;
        else
            szTimeBombKey = RTM_LICENSING_TIME_BOMB_5_1;
    }
    else
    {
        cout << endl << "       Unknown OS.  Assume no grace period" << endl;
        return FALSE;
    }

    status = RetrieveKey(
                         szTimeBombKey,
                         &pbByte,
                         &cbByte
                         );


    if(status == ERROR_SUCCESS && pbByte)
    {
        timebomb = *(FILETIME *)pbByte;


        GetSystemTimeAsFileTime(&filetimeCurrent);

        // yes license has expired if filetimeCurrent >= timebomb

        return (CompareFileTime(&timebomb, &filetimeCurrent) < 1);

    }
    else
    {
        // It hasn't been set yet, so we're not expired

        return FALSE;
    }
}

static gdwCount = 0;

BOOL ServerEnumCallBack(
    IN TLS_HANDLE hHandle,
    IN LPCTSTR pszServerName,
    IN HANDLE /* dwUserData */)
{
    USES_CONVERSION;

    if (hHandle)
    {
        cout << endl << "       Found #" << ++gdwCount << ":"<< T2A(pszServerName);
    }


    return 0;
}



typedef HANDLE
(* TLSCONNECTTOANYLSSERVER)(  
    DWORD dwTimeOut
);

typedef DWORD 
(* ENUMERATETLSSERVERNEW)(  
    TLSENUMERATECALLBACK fCallBack, 
    HANDLE dwUserData,
    DWORD dwTimeOut,
    BOOL fRegOnly
);


typedef DWORD 
(* ENUMERATETLSSERVEROLD)(  
    LPCTSTR szDomain,
    LPCTSTR szScope, 
    DWORD dwPlatformType, 
    TLSENUMERATECALLBACK fCallBack, 
    HANDLE dwUserData,
    DWORD dwTimeOut,
    BOOL fRegOnly
);

BOOL EnumerateLicenseServers ()
{
    HMODULE hmodTlsAPI = LoadLibrary( _T("mstlsapi.dll") );

    if (hmodTlsAPI)
    {
        DWORD dwResult;

        // load TLSShutdown to see if we have the new APIs
        if (NULL == GetProcAddress(hmodTlsAPI,"TLSShutdown"))
        {
            ENUMERATETLSSERVEROLD pfnEnumerateTlsServer;

            pfnEnumerateTlsServer = (ENUMERATETLSSERVEROLD) GetProcAddress(hmodTlsAPI,"EnumerateTlsServer");

            if (NULL != pfnEnumerateTlsServer)
            {

                dwResult = pfnEnumerateTlsServer(
                            NULL,
                            NULL,
                            LSKEYPACKPLATFORMTYPE_UNKNOWN,
                            ServerEnumCallBack,
                            0,
                            0,
                            FALSE);
            }
            else
            {
                cout << endl << "       Failed to GetProcAddress,ErrorCode = " << GetLastError() << endl;

                return FALSE;
            }
        }
        else
        {
            if (NULL != GetProcAddress(hmodTlsAPI,"TLSGetSupportFlags"))
            {
                // Use newer discovery function

                TLSCONNECTTOANYLSSERVER pfnTLSConnectToAnyLsServer;
                TLS_HANDLE hServer;

                pfnTLSConnectToAnyLsServer = (TLSCONNECTTOANYLSSERVER) GetProcAddress(hmodTlsAPI,"TLSConnectToAnyLsServer");

                if (NULL != pfnTLSConnectToAnyLsServer)
                {
                    hServer = pfnTLSConnectToAnyLsServer(INFINITE);

                    if (NULL != hServer)
                    {
                        return TRUE;
                    }
                    else
                    {
                        return FALSE;
                    }
                }
                else
                {
                    cout << endl << "       Failed to GetProcAddress TLSConnectToAnyLsServer,ErrorCode = " << GetLastError() << endl;
                    
                    return FALSE;
                }
            }
            else
            {
                ENUMERATETLSSERVERNEW pfnEnumerateTlsServer;

                pfnEnumerateTlsServer = (ENUMERATETLSSERVERNEW) GetProcAddress(hmodTlsAPI,"EnumerateTlsServer");

                if (NULL != pfnEnumerateTlsServer)
                {
                    dwResult = pfnEnumerateTlsServer(
                                                     ServerEnumCallBack,
                                                     0,
                                                     0,
                                                     FALSE);
                }
                else
                {
                    cout << endl << "       Failed to GetProcAddress,ErrorCode = " << GetLastError() << endl;
                    
                    return FALSE;
                }
            }
        }
        
        FreeLibrary(hmodTlsAPI);
        
        if (dwResult != NO_ERROR)
            cout << endl << "       Failed to EnumerateTlsServer,ErrorCode = " << dwResult << endl;


        if (gdwCount > 0)
            cout << endl;

        return gdwCount > 0;

    }
    else
    {
        cout << endl << "       Failed to load mstlsapi.dll,ErrorCode = " << GetLastError() << endl;

        return FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\makefile.inc ===
#
#       Do not delete this file, needed to build .lib file.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\deldir.c ===
/*************************************************************************
*
* deldir.c
*
* Functions to delete all the files and subdirectories under a given
* directory (similar to rm -rf).
*
* Copyright Microsoft, 1998
*
*
*************************************************************************/

/* include files */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "winsta.h"
#include "syslib.h"

#if DBG
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*
 * Data Structure
 */
typedef struct dirent {
    ULONG  d_attr;                      /* file attributes */
    WCHAR  d_name[MAX_PATH+1];          /* file name */
    WCHAR  d_first;
    HANDLE d_handle;
} DIR, *PDIR;


/*
 * procedure prototypes
 */
void remove_file( PWCHAR, ULONG );
PDIR opendir( PWCHAR );
PDIR readdir( PDIR );
int closedir( PDIR );
BOOL QueryFlatTempKey( VOID );
BOOLEAN SetFileTree( PWCHAR pRoot, PWCHAR pAvoidDir );


/*****************************************************************************
 *
 *  RemoveDir
 *
 *  Delete the given subdirectory and all files and subdirectories within it.
 *
 * ENTRY:
 *   PWCHAR (In) dirname - directory to delete
 *
 * EXIT:
 *   SUCCESS: TRUE
 *   FAILURE: FALSE
 *
 ****************************************************************************/
BOOL RemoveDir(PWCHAR dirname)
{
   DIR    *dirp, *direntp;
   WCHAR  pathname[MAX_PATH];
   PWCHAR namep;
   ULONG  ulattr;

   if ((dirp = opendir(dirname)) == NULL) {
      return(FALSE);
   }

   wcscpy( pathname, dirname );
   if ( pathname[wcslen(pathname)-1] != L'\\' &&
        pathname[wcslen(pathname)-1] != L'/' )
      wcscat( pathname, L"\\" );
   namep = pathname + wcslen(pathname);

   while ( direntp = readdir( dirp ) ) {
      if ( wcscmp( direntp->d_name, L"." ) &&
           wcscmp( direntp->d_name, L".." ) ) {
         wcscpy( namep, direntp->d_name );
         if ( direntp->d_attr & FILE_ATTRIBUTE_DIRECTORY ) {
            RemoveDir( pathname );
         } else {
            remove_file( pathname, direntp->d_attr );
         }
      }
   }

   closedir( dirp );

   /*
    * If directory is read-only, make it writable before trying to remove it
    */
   ulattr = GetFileAttributes(dirname);
   if ((ulattr != 0xffffffff) &&
       (ulattr & FILE_ATTRIBUTE_READONLY)) {
      SetFileAttributes(dirname, (ulattr & ~FILE_ATTRIBUTE_READONLY));
   }
   if (!RemoveDirectory(dirname)) {
      DBGPRINT(("RemoveDir: unable to remove directory=%ws\n", dirname));
      if (ulattr & FILE_ATTRIBUTE_READONLY) {           // set back to readonly
         SetFileAttributes(dirname, ulattr);
      }
   }
   return(TRUE);
}


/*****************************************************************************
 *
 *  remove_file
 *
 *  Delete the given file.
 *
 * ENTRY:
 *   PWCHAR (In) fname - file to delete
 *   ULONG  (In) attr  - attributes of file to delete
 *
 * EXIT:
 *   void
 *
 ****************************************************************************/
void remove_file(PWCHAR fname, ULONG attr)
{
   /*
    * If file is read-only, then make it writable before trying to remove it
    */
   if (attr & FILE_ATTRIBUTE_READONLY) {
      if (!SetFileAttributes(fname, (attr & ~FILE_ATTRIBUTE_READONLY))) {
         DBGPRINT(("remove_file: unable to remove file=%ws\n", fname));
         return;
      }
   }

   /*
    * remove the file
    */
   if (!DeleteFile(fname)) {
      if (!(attr & FILE_ATTRIBUTE_READONLY)) {  // if file was read-only,
         DBGPRINT(("remove_file: unable to remove file=%ws\n", fname));
         SetFileAttributes(fname, attr);        // then change it back
      }
   }
}


/*****************************************************************************
 *
 *  opendir
 *
 *  "Open" (FindFirstFile) the specified directory.
 *
 * ENTRY:
 *   PWCHAR (In) dirname - directory to open
 *
 * EXIT:
 *   SUCCESS:  pointer to DIR struct
 *   FAILURE:  NULL
 *
 ****************************************************************************/
PDIR opendir( PWCHAR dirname )
{
   PDIR dirp;
   unsigned count = 1;
   WIN32_FIND_DATA fileinfo;
   WCHAR pathname[MAX_PATH], sep;
   unsigned rc;

   if ((dirp = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(DIR))) == NULL) {
      DBGPRINT(("opendir: unable to allocate DIR structure.\n"));
      return( NULL );
   }

   memset( dirp, 0, sizeof(DIR) );

   /*
    * Build pathname to use for FindFirst call
    */
   wcscpy( pathname, dirname );
   if ( pathname[1] == L':' && pathname[2] == L'\0' )
      wcscat( pathname, L".\\*.*" );
   else if ( pathname[0] == '\0' ||
             (sep = pathname[wcslen(pathname)-1]) == L'\\' || sep == L'/' )
      wcscat( pathname, L"*.*" );
   else
      wcscat( pathname, L"\\*.*" );

   if ((dirp->d_handle =
       FindFirstFile(pathname, &fileinfo)) == INVALID_HANDLE_VALUE) {
      rc = GetLastError();
      DBGPRINT(("opendir: unable to open directory=%ws, rc=%d\n", dirname, rc));
   } else {
      rc = 0;
   }

   if (rc == NO_ERROR) {
      dirp->d_attr = fileinfo.dwFileAttributes;
      wcscpy(dirp->d_name, fileinfo.cFileName);
      dirp->d_first = TRUE;
      return( dirp );
   }

   if ( rc != ERROR_NO_MORE_FILES ) {
      closedir( dirp );
      return( NULL );
   }

   return( dirp );
}


/*****************************************************************************
 *
 *  readdir
 *
 *  Get the next file/directory to be deleted
 *
 * ENTRY:
 *   PDIR (In) dirp - pointer to open directory structure
 *
 * EXIT:
 *   SUCCESS:  pointer to DIR struct
 *   FAILURE:  NULL
 *
 ****************************************************************************/
PDIR readdir( PDIR dirp )
{
   WIN32_FIND_DATA fileinfo;
   unsigned count = 1;
   unsigned rc;

   if ( !dirp ) {
      return( NULL );
   }

   if ( dirp->d_first ) {
      dirp->d_first = FALSE;
      return( dirp );
   }

   if ( !(rc = FindNextFile( dirp->d_handle, &fileinfo )) ) {
      rc = GetLastError();
      DBGPRINT(("readdir: FindNextFile failed, rc=%d\n", rc));
   } else {
      rc = 0;
   }

   if ( rc == NO_ERROR ) {
      dirp->d_attr = fileinfo.dwFileAttributes;
      wcscpy(dirp->d_name, fileinfo.cFileName);
      return( dirp );
   }

   return( NULL );
}


/*****************************************************************************
 *
 *  closedir
 *
 *  Close an open directory handle
 *
 * ENTRY:
 *   PDIR (In) dirp - pointer to open directory structure
 *
 * EXIT:
 *   SUCCESS:  0
 *   FAILURE:  -1
 *
 ****************************************************************************/

int closedir( PDIR dirp )
{

   if ( !dirp ) {
      return( -1 );
   }

   FindClose( dirp->d_handle );

   RtlFreeHeap( RtlProcessHeap(), 0, dirp );

   return( 0 );
}


/*****************************************************************************
 *
 *  CtxCreateTempDir
 *
 *  Create and set the temporary environment variable for this user.
 *
 * ENTRY:
 *   PWSTR pwcEnvVar (In): Pointer to environment variable to set
 *   PWSTR pwcLogonID (In): Pointer to user's logon ID
 *   PVOID *pEnv (In): Pointer to pointer (a handle) to environment to query/set
 *   PWSTR ppTempName (Out/Optional): Pointer to location to return name
 *                                    of temp directory that was created
 *
 * EXIT:
 *   SUCCESS:  Returns TRUE
 *   FAILURE:  Returns FALSE
 *
 ****************************************************************************/

BOOL
CtxCreateTempDir( PWSTR pwcEnvVar, PWSTR pwcLogonId, PVOID *pEnv, 
                  PWSTR *ppTempName, PCTX_USER_DATA pCtxUserData )
{
    WCHAR Buffer[MAX_PATH];
    WCHAR RootPath[]=L"x:\\";
    ULONG Dtype;
    UNICODE_STRING Name, Value;
    ULONG  ulattr;
    NTSTATUS Status;
    BOOL bRC;
    HANDLE ImpersonationHandle;

    Value.Buffer = Buffer;
    Value.Length = 0;
    Value.MaximumLength = sizeof(Buffer);
    RtlInitUnicodeString(&Name, pwcEnvVar);

    //
    // Get the temp directory variable
    //
    Status = RtlQueryEnvironmentVariable_U( *pEnv, &Name, &Value );
    if ( !NT_SUCCESS(Status) )
        return( FALSE );

    //
    // If temp directory points to a network (or client) drive,
    // or is not accessible, then change it to point to the \temp
    // directory on the %SystemRoot% drive.
    //
    // Took out check for DRIVE_REMOTE, per incident 34313hq.      KLB 09-13-96
    //
    // Need to impersonate user during logon cause drive mapped under
    // impersonation.   cjc 12-18-96
    //
    RootPath[0] = Buffer[0];
    if (pCtxUserData) {
        ImpersonationHandle = CtxImpersonateUser(pCtxUserData, NULL);

        if (!ImpersonationHandle) {

            return( FALSE );
        }

    }


    Dtype = GetDriveType( RootPath );
    if (pCtxUserData) {
        CtxStopImpersonating(ImpersonationHandle);
    }
    if ( Dtype == DRIVE_NO_ROOT_DIR || Dtype == DRIVE_UNKNOWN ||
         Dtype == DRIVE_CDROM ) {
        UNICODE_STRING SystemRoot;

        RtlInitUnicodeString( &SystemRoot, L"SystemRoot" );
        Status = RtlQueryEnvironmentVariable_U( *pEnv, &SystemRoot, &Value );
        if ( !NT_SUCCESS(Status) )
            return( FALSE );
        lstrcpy( &Buffer[3], L"temp" );
    }

    //
    // See if the directory already exists and if not try to create it
    //
    ulattr = GetFileAttributesW(Buffer);
    if ( ulattr == 0xffffffff ) {
        bRC = CreateDirectory( Buffer, NULL );
        DBGPRINT(( "CreateDirectory(%ws) %s.\n", Buffer, bRC ? "successful" : "failed" ));
        if ( !bRC ) {
            return( FALSE );
        }
    }
    else if ( !(ulattr & FILE_ATTRIBUTE_DIRECTORY) ) {
        return ( FALSE );
    }

    // Append the logonid onto the temp env. variable.  We ONLY do this if the
    // registry key for "Flat Temporary Directories" is not set.  If it is,
    // then they want to put their temp directory under the user's directory,
    // and DON'T want it to be in a directory under that.  This is related to
    // incident 34313hq.                                           KLB 09-16-96
    if ( !QueryFlatTempKey() ) {
       if ( lstrlen(Buffer) + lstrlen(pwcLogonId) >= MAX_PATH ) {
           return( FALSE );
       }
       lstrcat(Buffer, L"\\");
       lstrcat(Buffer, pwcLogonId);

       //
       // See if the directory already exists and if not try to create it
       // with the new
       //
       ulattr = GetFileAttributesW(Buffer);
       if ( ulattr == 0xffffffff ) {
           bRC = CreateDirectory( Buffer, NULL );
           DBGPRINT(( "CreateDirectory(%ws) %s.\n", Buffer, bRC ? "successful" : "failed" ));
           if ( !bRC ) {
               return( FALSE );
           }
       }
       else if ( !(ulattr & FILE_ATTRIBUTE_DIRECTORY) ) {
           return ( FALSE );
       }
    }

    //
    // Need to set security on the new directory.  This is done by simply
    // calling code from JohnR's ACLSET utility that we brought over here.
    // KLB 09-25-96
    //
    SetFileTree( Buffer, NULL );

    // Must re-init Value since length of string has changed
    RtlInitUnicodeString( &Value, Buffer );
    RtlSetEnvironmentVariable( pEnv, &Name, &Value );
    RtlSetEnvironmentVariable( NULL, &Name, &Value );

    if ( ppTempName )
        *ppTempName = _wcsdup( Buffer );

    return( TRUE );
} // end of CtxCreateTempDir()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\inimap.c ===
/*************************************************************************
*
* inimap.c
*
* Functions to query/set ini file mapping for the WinStation and set the
* application
*
* Copyright Microsoft, 1998
*
*
*************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "winsta.h"
#include "syslib.h"

#if DBG
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

#define CITRIX_COMPAT_TEBVALID 0x80000000  // Compat flags in Teb are valid


/*****************************************************************************
 *
 *  SetCtxAppCompatFlags
 *
 *   Set the application's current compatibility flags, this will only update
 *   the current compatibility flags, not the flags in the registry.
 *
 * ENTRY:
 *   ULONG ulAppFlags (IN) - Desired compatibility flags
 *
 * EXIT:
 *   Returns TRUE to indicate success
 *
 ****************************************************************************/
BOOL SetCtxAppCompatFlags(ULONG ulAppFlags)
{
#if 0
    NtCurrentTeb()->CtxCompatFlags = ulAppFlags;
    NtCurrentTeb()->CtxCompatFlags |= CITRIX_COMPAT_TEBVALID;
#endif
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\dumpsd.c ===
// Include NT headers
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include "windows.h"

void CtxDumpSid( PSID, PCHAR, PULONG );
void DumpAcl( PACL, PCHAR, PULONG );
void DumpAce( PACE_HEADER, PCHAR, PULONG );

#if DBG
void
DumpSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSD
    )
{
    PISECURITY_DESCRIPTOR p = (PISECURITY_DESCRIPTOR)pSD;
    PSID pSid;
    PACL pAcl;
    PCHAR pTmp;
    ULONG Size;

    //
    // This is done under an exception handler in case someone passes in
    // a totally bogus security descriptor
    //
    try {

        DbgPrint("DUMP_SECURITY_DESCRIPTOR: Revision %d, Sbz1 %d, Control 0x%x\n",
            p->Revision, p->Sbz1, p->Control );

        if ( p->Control & SE_SELF_RELATIVE ) {
            DbgPrint("Self Relative\n");
        }

        DbgPrint("PSID Owner 0x%x\n",p->Owner);

        // If this is self relative, must offset the pointers
        if( p->Owner != NULL ) {
            if( p->Control & SE_SELF_RELATIVE ) {
                pTmp = (PCHAR)pSD;
                pTmp += (UINT_PTR)p->Owner;
                CtxDumpSid( (PSID)pTmp, (PCHAR)p, &Size );
            }
            else {
                // can reference it directly
                CtxDumpSid( p->Owner, (PCHAR)p, &Size );
            }
        }


        DbgPrint("PSID Group 0x%x\n",p->Group);

        // If this is self relative, must offset the pointers
        if( p->Group != NULL ) {
            if( p->Control & SE_SELF_RELATIVE ) {
                pTmp = (PCHAR)pSD;
                pTmp += (UINT_PTR)p->Group;
                CtxDumpSid( (PSID)pTmp, (PCHAR)p, &Size );
            }
            else {
                // can reference it directly
                CtxDumpSid( p->Group, (PCHAR)p, &Size );
            }
        }

        DbgPrint("\n");

        DbgPrint("PACL Sacl 0x%x\n",p->Sacl);

        // If this is self relative, must offset the pointers
        if( p->Sacl != NULL ) {
            if( p->Control & SE_SELF_RELATIVE ) {
                pTmp = (PCHAR)pSD;
                pTmp += (UINT_PTR)p->Sacl;
                DumpAcl( (PSID)pTmp, (PCHAR)p, &Size );
            }
            else {
                // can reference it directly
                DumpAcl( p->Sacl, (PCHAR)p, &Size );
            }
        }

        DbgPrint("\n");

        DbgPrint("PACL Dacl 0x%x\n",p->Dacl);

        // If this is self relative, must offset the pointers
        if( p->Dacl != NULL ) {
            if( p->Control & SE_SELF_RELATIVE ) {
                pTmp = (PCHAR)pSD;
                pTmp += (UINT_PTR)p->Dacl;
                DumpAcl( (PSID)pTmp, (PCHAR)p, &Size );
            }
            else {
                // can reference it directly
                DumpAcl( p->Dacl, (PCHAR)p, &Size );
            }
        }


    } except( EXCEPTION_EXECUTE_HANDLER) {
          DbgPrint("DUMP_SECURITY_DESCRIPTOR: Exception %d accessing descriptor\n",GetExceptionCode());
          return;
    }
}
#endif

#if DBG
void
CtxDumpSid(
    PSID   pSid,
    PCHAR  pBase,
    PULONG pSize
    )
{
    PISID p;
    ULONG i;
    BOOL  OK;
    DWORD szUserName;
    DWORD szDomain;
    SID_NAME_USE UserSidType;
    WCHAR UserName[256];
    WCHAR Domain[256];
    ULONG Size = 0;

    p = (PISID)pSid;

    DbgPrint("Revision %d, SubAuthorityCount %d\n", p->Revision, p->SubAuthorityCount);

    Size += 2;   // Revision, SubAuthorityCount

    DbgPrint("IdentifierAuthority: %x %x %x %x %x %x\n",
        p->IdentifierAuthority.Value[0],
        p->IdentifierAuthority.Value[1],
        p->IdentifierAuthority.Value[2],
        p->IdentifierAuthority.Value[3],
        p->IdentifierAuthority.Value[4],
        p->IdentifierAuthority.Value[5] );

    Size += 6;   // IdentifierAuthority

    for( i=0; i < p->SubAuthorityCount; i++ ) {

        DbgPrint("SubAuthority[%d] 0x%x\n", i, p->SubAuthority[i]);

        Size += sizeof(ULONG);
    }

    if( pSize ) {
        *pSize = Size;
    }

    szUserName = sizeof(UserName);
    szDomain = sizeof(Domain);

    // Now print its account
    OK = LookupAccountSidW(
             NULL, // Computer Name
             pSid,
             UserName,
             &szUserName,
             Domain,
             &szDomain,
             &UserSidType
             );

    if( OK ) {
        DbgPrint("Account Name %ws, Domain %ws, Type %d, SidSize %d\n",UserName,Domain,UserSidType,Size);
    }
    else {
        DbgPrint("Error looking up account name %d, SizeSid %d\n",GetLastError(),Size);
    }

}
#endif

#if DBG
void
DumpAcl(
    PACL   pAcl,
    PCHAR  pBase,
    PULONG pSize
    )
{
    USHORT i;
    PCHAR  pTmp;
    ULONG  Size, MySize;
    PACL   p = pAcl;
    PCHAR  pCur = (PCHAR)pAcl;

    MySize = 0;

    DbgPrint("AclRevision %d, Sbz1 %d, AclSize %d, AceCount %d, Sbz2 %d\n",
        p->AclRevision, p->Sbz1, p->AclSize, p->AceCount, p->Sbz2 );

    // bump over the ACL header to point to the first ACE
    pCur += sizeof( ACL );

    MySize += sizeof( ACL );

    for( i=0; i < p->AceCount; i++ ) {

        DumpAce( (PACE_HEADER)pCur, pBase, &Size );

        pCur += Size;
        MySize += Size;
    }

    // ACL consistency check
    if( p->AclSize != MySize ) {
        DbgPrint("Inconsistent ACL Entry! p->AclSize %d, RealSize %d\n",p->AclSize,MySize);
    }

    // return the size of this ACL
    *pSize = MySize;
    return;
}
#endif

#if DBG
void
DumpAce(
    PACE_HEADER pAce,
    PCHAR  pBase,
    PULONG pSize
    )
{
    PACE_HEADER p = pAce;
    PACCESS_ALLOWED_ACE pAl;
    PACCESS_DENIED_ACE pAd;
    PSYSTEM_AUDIT_ACE pSa;
    PSYSTEM_ALARM_ACE pSl;
    PCHAR pTmp;
    ULONG MySize, Size;


    DbgPrint("ACE_HEADER: Type %d, Flags 0x%x, Size %d\n",
        p->AceType, p->AceFlags, p->AceSize );


    switch( p->AceType ) {

    case ACCESS_ALLOWED_ACE_TYPE:
	    pAl = (PACCESS_ALLOWED_ACE)p;
	    DbgPrint("ACCESS_ALLOWED_ACE: AccessMask 0x%x, Sid 0x%x\n",pAl->Mask,pAl->SidStart);

	    MySize = sizeof(ACCESS_ALLOWED_ACE);

            if( pAl->SidStart ) {
	        pTmp = (PCHAR)&pAl->SidStart;
		CtxDumpSid( (PSID)pTmp, pBase, &Size );
	        MySize += Size;
                // Adjust for the first ULONG of the ACE
		// being part of the Sid
                MySize -= sizeof(ULONG);
	    }

	    break;

    case ACCESS_DENIED_ACE_TYPE:
	    pAd = (PACCESS_DENIED_ACE)p;
	    DbgPrint("ACCESS_DENIED_ACE: AccessMask 0x%x, Sid 0x%x\n",pAd->Mask,pAd->SidStart);

	    MySize = sizeof(ACCESS_DENIED_ACE);

            if( pAd->SidStart ) {
	        pTmp = (PCHAR)&pAd->SidStart;
		CtxDumpSid( (PSID)pTmp, pBase, &Size );
		MySize += Size;
                // Adjust for the first ULONG of the ACE
		// being part of the Sid
                MySize -= sizeof(ULONG);
	    }

	    break;

    case SYSTEM_AUDIT_ACE_TYPE:
	    pSa = (PSYSTEM_AUDIT_ACE)p;
	    DbgPrint("SYSTEM_AUDIT_ACE: AccessMask 0x%x, Sid 0x%x\n",pSa->Mask,pSa->SidStart);

	    MySize = sizeof(SYSTEM_AUDIT_ACE);

            if( pSa->SidStart ) {
 	        pTmp = (PCHAR)&pSa->SidStart;
		CtxDumpSid( (PSID)pTmp, pBase, &Size );
		MySize += Size;
                // Adjust for the first ULONG of the ACE
		// being part of the Sid
                MySize -= sizeof(ULONG);
	    }

	    break;

    case SYSTEM_ALARM_ACE_TYPE:
	    pSl = (PSYSTEM_ALARM_ACE)p;
	    DbgPrint("SYSTEM_ALARM_ACE: AccessMask 0x%x, Sid 0x%x\n",pSl->Mask,pSl->SidStart);

	    MySize = sizeof(SYSTEM_ALARM_ACE);

            if( pSl->SidStart ) {
	        pTmp = (PCHAR)&pSl->SidStart;
		CtxDumpSid( (PSID)pTmp, pBase, &Size );
		MySize += Size;
                // Adjust for the first ULONG of the ACE
		// being part of the Sid
                MySize -= sizeof(ULONG);
	    }

	    break;

    default:
            DbgPrint("Unknown ACE type %d\n", p->AceType);
    }

    // Check its consistency
    if( p->AceSize != MySize ) {
        DbgPrint("Inconsistent ACE Entry! p->AceSize %d, RealSize %d\n",p->AceSize,MySize);
    }

    // return the size so the caller can update the pointer
    *pSize = p->AceSize;

    DbgPrint("\n");

    return;
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\execclt.c ===
/*************************************************************************
*
* execclt.c
*
* Exec service client.
*
* This allows the starting of a program on any CITRIX WinStation under
* the account of the logged on user, or the SYSTEM account for services.
*
* Copyright Microsoft, 1998
*
* Log:
*
*
*
*************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <lmsname.h>
#include <windows.h>
#include <stdio.h>
#include <execsrv.h>
#include <winsta.h>
#include <syslib.h>

#pragma warning (error:4312)

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


//
// Forward references
//

PWCHAR
MarshallStringW(
    PWCHAR pSource,
    PCHAR  pBase,
    ULONG  MaxSize,
    PCHAR  *ppPtr,
    PULONG pCount
    );

VOID
AnsiToUnicode(
    WCHAR *,
    ULONG,
    CHAR *
    );


/*****************************************************************************
 *
 *  WinStationCreateProcessA
 *
 *   ANSI version of WinStationCreateProcessW
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
WinStationCreateProcessA(
    ULONG  LogonId,
    BOOL   System,
    PCHAR  lpszImageName,
    PCHAR  lpszCommandLine,
    PSECURITY_ATTRIBUTES psaProcess,
    PSECURITY_ATTRIBUTES psaThread,
    BOOL   fInheritHandles,
    DWORD  fdwCreate,
    LPVOID lpvEnvironment,
    LPCSTR lpszCurDir,
    LPSTARTUPINFOA pStartInfo,
    LPPROCESS_INFORMATION pProcInfo
    )
{
    ULONG  Len;
    STARTUPINFOW Info;
    BOOL   Result = FALSE;
    PWCHAR pImage = NULL;
    PWCHAR pCmdLine = NULL;
    PWCHAR pCurDir = NULL;
    PWCHAR pDesk = NULL;
    PWCHAR pTitle = NULL;

    // Convert the valid ANSI strings to UNICODE

    if( lpszImageName ) {
        Len = (strlen(lpszImageName)+1)*sizeof(WCHAR);
        pImage = LocalAlloc( LMEM_FIXED, Len );
        if( pImage == NULL ) goto Cleanup;
        AnsiToUnicode( pImage, Len, lpszImageName );
    }
    if( lpszCommandLine ) {
        Len = (strlen(lpszCommandLine)+1)*sizeof(WCHAR);
        pCmdLine = LocalAlloc( LMEM_FIXED, Len );
        if( pCmdLine == NULL ) goto Cleanup;
        AnsiToUnicode( pCmdLine, Len, lpszCommandLine );
    }
    if( lpszCurDir ) {
        Len = (strlen(lpszCurDir)+1)*sizeof(WCHAR);
        pCurDir = LocalAlloc( LMEM_FIXED, Len );
        if( pCurDir == NULL ) goto Cleanup;
        AnsiToUnicode( pCurDir, Len, (CHAR*)lpszCurDir );
    }
    if( pStartInfo->lpDesktop ) {
        Len = (strlen(pStartInfo->lpDesktop)+1)*sizeof(WCHAR);
        pDesk = LocalAlloc( LMEM_FIXED, Len );
        if( pDesk == NULL ) goto Cleanup;
        AnsiToUnicode( pDesk, Len, pStartInfo->lpDesktop );
    }
    if( pStartInfo->lpTitle ) {
        Len = (strlen(pStartInfo->lpTitle)+1)*sizeof(WCHAR);
        pTitle = LocalAlloc( LMEM_FIXED, Len );
        if( pTitle == NULL ) goto Cleanup;
        AnsiToUnicode( pTitle, Len, pStartInfo->lpTitle );
    }

    Info.cb = sizeof(STARTUPINFOW);
    Info.lpReserved = (PWCHAR)pStartInfo->lpReserved;
    Info.lpDesktop = pDesk;
    Info.lpTitle = pTitle;
    Info.dwX = pStartInfo->dwX;
    Info.dwY = pStartInfo->dwY;
    Info.dwXSize = pStartInfo->dwXSize;
    Info.dwYSize = pStartInfo->dwYSize;
    Info.dwXCountChars = pStartInfo->dwXCountChars;
    Info.dwYCountChars = pStartInfo->dwYCountChars;
    Info.dwFillAttribute = pStartInfo->dwFillAttribute;
    Info.dwFlags = pStartInfo->dwFlags;
    Info.wShowWindow = pStartInfo->wShowWindow;
    Info.cbReserved2 = pStartInfo->cbReserved2;
    Info.lpReserved2 = pStartInfo->lpReserved2;
    Info.hStdInput = pStartInfo->hStdInput;
    Info.hStdOutput = pStartInfo->hStdOutput;
    Info.hStdError = pStartInfo->hStdError;

    Result = WinStationCreateProcessW(
                 LogonId,
                 System,
                 pImage,
                 pCmdLine,
                 psaProcess,
                 psaThread,
                 fInheritHandles,
                 fdwCreate,
                 lpvEnvironment,
                 pCurDir,
                 &Info,
                 pProcInfo
             );

Cleanup:
    if( pImage ) LocalFree( pImage );
    if( pCmdLine ) LocalFree( pCmdLine );
    if( pCurDir ) LocalFree( pCurDir );
    if( pDesk ) LocalFree( pDesk );
    if( pTitle ) LocalFree( pTitle );

    return( Result );
}


/*****************************************************************************
 *
 *  WinStationCreateProcessW
 *
 *   Create a process on the given WinStation (LogonId)
 *
 * ENTRY:
 *   LogonId (input)
 *     LogonId of WinStation to create process on
 *
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
WinStationCreateProcessW(
    ULONG  LogonId,
    BOOL   System,
    PWCHAR lpszImageName,
    PWCHAR lpszCommandLine,
    PSECURITY_ATTRIBUTES psaProcess,
    PSECURITY_ATTRIBUTES psaThread,
    BOOL   fInheritHandles,
    DWORD  fdwCreate,
    LPVOID lpvEnvionment,
    LPWSTR lpszCurDir,
    LPSTARTUPINFOW pStartInfo,
    LPPROCESS_INFORMATION pProcInfo
    )
{
    BOOL   Result;
    HANDLE hPipe = NULL;
    WCHAR  szPipeName[MAX_PATH];
    PCHAR  ptr;
    ULONG  Count, AmountWrote, AmountRead;
    DWORD  MyProcId;
    PEXECSRV_REQUEST pReq;
    EXECSRV_REPLY    Rep;
    CHAR Buf[EXECSRV_BUFFER_SIZE];
    ULONG  MaxSize = EXECSRV_BUFFER_SIZE;

    if( lpszImageName )
        TRACE0(("EXECCLIENT: lpszImageName %ws\n",lpszImageName));

    if( lpszCommandLine )
        TRACE0(("EXECCLIENT: lpszCommandLine %ws\n",lpszCommandLine));

    // Winlogon handles all now. System flag tells it what to do
    swprintf(szPipeName, EXECSRV_SYSTEM_PIPE_NAME, LogonId);

    hPipe = CreateFileW(
                szPipeName,
                GENERIC_READ|GENERIC_WRITE,
                0,    // File share mode
                NULL, // default security
                OPEN_EXISTING,
                0,    // Attrs and flags
                NULL  // template file handle
                );

    if( hPipe == INVALID_HANDLE_VALUE ) {
        DBGPRINT(("EXECCLIENT: Could not create pipe name %ws\n", szPipeName));
        return(FALSE);
    }

    /*
     * Get the handle to the current process
     */
    MyProcId = GetCurrentProcessId();

    /*
     * setup the marshalling
     */
    ptr = Buf;
    Count = 0;

    pReq = (PEXECSRV_REQUEST)ptr;
    ptr   += sizeof(EXECSRV_REQUEST);
    Count += sizeof(EXECSRV_REQUEST);

    // set the basic parameters
    pReq->System = System;
    pReq->RequestingProcessId = MyProcId;
    pReq->fInheritHandles = fInheritHandles;
    pReq->fdwCreate = fdwCreate;

    // marshall the ImageName string
    if( lpszImageName ) {
        pReq->lpszImageName = MarshallStringW( lpszImageName, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->lpszImageName = NULL;
    }

    // marshall in the CommandLine string
    if( lpszCommandLine ) {
        pReq->lpszCommandLine = MarshallStringW( lpszCommandLine, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->lpszCommandLine = NULL;
    }

    // marshall in the CurDir string
    if( lpszCurDir ) {
        pReq->lpszCurDir = MarshallStringW( lpszCurDir, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->lpszCurDir = NULL;
    }

    // marshall in the StartupInfo structure
    RtlMoveMemory( &pReq->StartInfo, pStartInfo, sizeof(STARTUPINFO) );

    // Now marshall the strings in STARTUPINFO
    if( pStartInfo->lpDesktop ) {
        pReq->StartInfo.lpDesktop = MarshallStringW( pStartInfo->lpDesktop, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->StartInfo.lpDesktop = NULL;
    }

    if( pStartInfo->lpTitle ) {
        pReq->StartInfo.lpTitle = MarshallStringW( pStartInfo->lpTitle, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->StartInfo.lpTitle = NULL;
    }

    //
    // WARNING: This version does not pass the following:
    //
    //  Also saProcess and saThread are ignored right now and use
    //  the users default security on the remote WinStation
    //
    // Set things that are always NULL
    //
    pReq->StartInfo.lpReserved = NULL;  // always NULL
    pReq->lpvEnvironment = NULL;    
    pReq->hToken = NULL;

    // now fill in the total count
    pReq->Size = Count;

    /*
     * Now send the buffer out to the server
     */
    Result = WriteFile(
                 hPipe,
                 Buf,
                 Count,
                 &AmountWrote,
                 NULL
                 );

    if( !Result ) {
        DBGPRINT(("EXECCLIENT: Error %d sending request\n",GetLastError()));
        goto Cleanup;
    }

    /*
     * Now read the reply
     */
    Result = ReadFile(
                 hPipe,
                 &Rep,
                 sizeof(Rep),
                 &AmountRead,
                 NULL
                 );

    if( !Result ) {
        DBGPRINT(("EXECCLIENT: Error %d reading reply\n",GetLastError()));
        goto Cleanup;
    }

    /*
     * Check the result
     */
    if( !Rep.Result ) {
        DBGPRINT(("EXECCLIENT: Error %d in reply\n",Rep.LastError));
        // set the error in the current thread to the returned error
        Result = Rep.Result;
        SetLastError( Rep.LastError );
        goto Cleanup;
    }

    /*
     * We copy the PROCESS_INFO structure from the reply
     * to the caller.
     *
     * The remote site has duplicated the handles into our
     * process space for hProcess and hThread so that they will
     * behave like CreateProcessW()
     */

     RtlMoveMemory( pProcInfo, &Rep.ProcInfo, sizeof( PROCESS_INFORMATION ) );

Cleanup:
    CloseHandle(hPipe);

    DBGPRINT(("EXECCLIENT: Result 0x%x\n", Result));

    return(Result);
}

/*****************************************************************************
 *
 *  MarshallStringW
 *
 *   Marshall in a UNICODE_NULL terminated WCHAR string
 *
 * ENTRY:
 *   pSource (input)
 *     Pointer to source string
 *
 *   pBase (input)
 *     Base buffer pointer for normalizing the string pointer
 *
 *   MaxSize (input)
 *     Maximum buffer size available
 *
 *   ppPtr (input/output)
 *     Pointer to the current context pointer in the marshall buffer.
 *     This is updated as data is marshalled into the buffer
 *
 *   pCount (input/output)
 *     Current count of data in the marshall buffer.
 *     This is updated as data is marshalled into the buffer
 *
 * EXIT:
 *   NULL - Error
 *   !=NULL "normalized" pointer to the string in reference to pBase
 *
 ****************************************************************************/

PWCHAR
MarshallStringW(
    PWCHAR pSource,
    PCHAR  pBase,
    ULONG  MaxSize,
    PCHAR  *ppPtr,
    PULONG pCount
    )
{
    ULONG Len;
    PCHAR ptr;

    Len = wcslen( pSource );
    Len++; // include the NULL;

    Len *= sizeof(WCHAR); // convert to bytes
    if( (*pCount + Len) > MaxSize ) {
        return( NULL );
    }

    RtlMoveMemory( *ppPtr, pSource, Len );

    // the normalized ptr is the current count
    ptr = LongToPtr(*pCount);

    *ppPtr += Len;
    *pCount += Len;

    return((PWCHAR)ptr);
}

/*******************************************************************************
 *
 *  AnsiToUnicode
 *
 *     convert an ANSI (CHAR) string into a UNICODE (WCHAR) string
 *
 * ENTRY:
 *
 *    pUnicodeString (output)
 *       buffer to place UNICODE string into
 *    lUnicodeMax (input)
 *       maximum number of characters to write into pUnicodeString
 *    pAnsiString (input)
 *       ANSI string to convert
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
AnsiToUnicode( WCHAR * pUnicodeString,
               ULONG lUnicodeMax,
               CHAR * pAnsiString )
{
    ULONG ByteCount;

    RtlMultiByteToUnicodeN( pUnicodeString, lUnicodeMax, &ByteCount,
                            pAnsiString, (strlen(pAnsiString) + 1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\file.c ===
/*************************************************************************
*
* file.c
*
* Process the security on a file
*
* Copyright Microsoft, 1998
*
*
*
*************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <process.h>

#include <winsta.h>
#include <syslib.h>

#include "security.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

// External data

// data.c
extern ACCESS_MASK DeniedAccess;

// security.c
extern PSID  SeCreatorOwnerSid;
extern PSID  SeCreatorGroupSid;


FILE_RESULT
xxxSetFileSecurity(
    PWCHAR pFile
    );

/*****************************************************************************
 *
 *  xxxProcessFile
 *
 *   Process the given file for access security holes
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

FILE_RESULT
xxxProcessFile(
    PWCHAR pFile,
    PWIN32_FIND_DATAW p,
    DWORD  Level,
    DWORD  Index
    )
{
    FILE_RESULT rc;

    rc = xxxSetFileSecurity( pFile );

    return( rc );
}


/*****************************************************************************
 *
 *  xxxSetFileSecurity
 *
 *   Set the security properties for the given file
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

FILE_RESULT
xxxSetFileSecurity(
    PWCHAR pFile
    )
{
    BOOL rc;
    BOOL DaclPresent;
    BOOL Default;
    BOOL OwnerDefaulted;
    BOOL GroupDefaulted;
    FILE_RESULT Result, ReturnResult;
    DWORD Size, Index;
    PACL pACL = NULL;
    PVOID pAce = NULL;
    SECURITY_INFORMATION Info = 0;
    DWORD Error;
    PSECURITY_DESCRIPTOR pSelfSd = NULL;

    // Absolute SD values
    PSECURITY_DESCRIPTOR pAbsSd = NULL;
    DWORD AbsSdSize = 0;
    PACL  pAbsAcl = NULL;
    DWORD AbsAclSize = 0;
    PACL  pAbsSacl = NULL;
    DWORD AbsSaclSize = 0;
    PSID  pAbsOwner = NULL;
    DWORD AbsOwnerSize = 0;
    PSID  pAbsGroup = NULL;
    DWORD AbsGroupSize = 0;

    DBGPRINT(( "entering xxxSetFileSecurity(pFile=%ws)\n", pFile ));

    /*
     * Get the files current security descriptor
     */

    Size = 0;
    rc = GetFileSecurityW(
             pFile,
             DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION,
             NULL,    // pSelfSd
             0,
             &Size
             );

    if( rc ) {
        Error = GetLastError();

        ReportFileResult(
            FileAccessErrorUserFormat,
            0,                           // Access
            pFile,
            NULL,                        // pAccountName
            NULL,                        // pDomainName
            "%d has no DACL",
            Error
            );

        DBGPRINT(( "leaving xxxSetFileSecurity(1); returning=FileAccessError\n" ));
        return( FileAccessError );
    }
    else {
        pSelfSd = LocalAlloc( LMEM_FIXED, Size );
        if( pSelfSd == NULL ) {

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "Out of memory skipped entry"
                );

            DBGPRINT(( "leaving xxxSetFileSecurity(2); returning=0\n" ));
            return( FALSE );
        }

        rc = GetFileSecurityW(
                 pFile,
                 DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION,
                 pSelfSd,
                 Size,
                 &Size
                 );

        if( !rc ) {
            Error = GetLastError();

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "%d Could not get DACL",
                Error
                );

            LocalFree( pSelfSd );
            DBGPRINT(( "leaving xxxSetFileSecurity(3); returning=FileAccessError\n" ));
            return( FileAccessError );
        }
    }

    //
    // Now convert the self relative SD to an absolute one.
    //

    rc = MakeAbsoluteSD (
             pSelfSd,
             pAbsSd,
             &AbsSdSize,
             pAbsAcl,
             &AbsAclSize,
             pAbsSacl,
             &AbsSaclSize,
             pAbsOwner,
             &AbsOwnerSize,
             pAbsGroup,
             &AbsGroupSize
             );

    if( !rc ) {
        Error = GetLastError();

        if( Error != ERROR_INSUFFICIENT_BUFFER ) {

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "%d converting SECURITY_DESCRIPTOR",
                Error
                );

               LocalFree( pSelfSd );
            DBGPRINT(( "leaving xxxSetFileSecurity(4); returning=FileAccessError\n" ));
               return( FileAccessError );
        }

        // Allocate buffers and now really get the SD
        pAbsSd    = LocalAlloc( LMEM_FIXED, AbsSdSize );
        pAbsAcl   = LocalAlloc( LMEM_FIXED, AbsAclSize );
        pAbsSacl  = LocalAlloc( LMEM_FIXED, AbsSaclSize );
        pAbsOwner = LocalAlloc( LMEM_FIXED, AbsOwnerSize );
        pAbsGroup = LocalAlloc( LMEM_FIXED, AbsGroupSize );

        if( !( pAbsSd && pAbsAcl && pAbsSacl && pAbsOwner && pAbsGroup ) ) {

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "Allocating memory"
                );

               if( pAbsSd ) LocalFree( pAbsSd );
               if( pAbsAcl ) LocalFree( pAbsAcl );
               if( pAbsSacl ) LocalFree( pAbsSacl );
               if( pAbsOwner ) LocalFree( pAbsOwner );
               if( pAbsGroup ) LocalFree( pAbsGroup );
               LocalFree( pSelfSd );
               DBGPRINT(( "leaving xxxSetFileSecurity(5); returning=FileAccessError\n" ));
               return( FileAccessError );
        }

        // Try it again
        rc = MakeAbsoluteSD (
                 pSelfSd,
                 pAbsSd,
                 &AbsSdSize,
                 pAbsAcl,
                 &AbsAclSize,
                 pAbsSacl,
                 &AbsSaclSize,
                 pAbsOwner,
                 &AbsOwnerSize,
                 pAbsGroup,
                 &AbsGroupSize
                 );

        if( !rc ) {
            Error = GetLastError();

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "%d Making ABSOLUTE SD",
                Error
                );

               if( pAbsSd ) LocalFree( pAbsSd );
               if( pAbsAcl ) LocalFree( pAbsAcl );
               if( pAbsSacl ) LocalFree( pAbsSacl );
               if( pAbsOwner ) LocalFree( pAbsOwner );
               if( pAbsGroup ) LocalFree( pAbsGroup );
               LocalFree( pSelfSd );
               DBGPRINT(( "leaving xxxSetFileSecurity(6); returning=FileAccessError\n" ));
               return( FileAccessError );
        }
    }

    //
    // Get our new trusted ACL
    //
    pACL = GetSecureAcl();
    if( pACL == NULL ) {

        ReportFileResult(
            FileAccessErrorUserFormat,
            0,                           // Access
            pFile,
            NULL,                        // pAccountName
            NULL,                        // pDomainName
            "Could not get New ACL"
            );
        
        if( pAbsSd ) LocalFree( pAbsSd );
        if( pAbsAcl ) LocalFree( pAbsAcl );
        if( pAbsSacl ) LocalFree( pAbsSacl );
        if( pAbsOwner ) LocalFree( pAbsOwner );
        if( pAbsGroup ) LocalFree( pAbsGroup );
        LocalFree( pSelfSd );
        DBGPRINT(( "leaving xxxSetFileSecurity(7); returning=FileAccessError\n" ));
        return( FileAccessError );
    }

    //
    // Now set the trusted ACL onto the security descriptor
    //

    rc = SetSecurityDescriptorDacl(
             pAbsSd,
             TRUE,   // DACL present
             pACL,
             FALSE   // Not default
             );

    if( !rc ) {
        Error = GetLastError();

        ReportFileResult(
            FileAccessErrorUserFormat,
            0,                           // Access
            pFile,
            NULL,                        // pAccountName
            NULL,                        // pDomainName
            "Could not set new ACL in Security Descriptor %d",
            Error
            );

        if( pAbsSd ) LocalFree( pAbsSd );
        if( pAbsAcl ) LocalFree( pAbsAcl );
        if( pAbsSacl ) LocalFree( pAbsSacl );
        if( pAbsOwner ) LocalFree( pAbsOwner );
        if( pAbsGroup ) LocalFree( pAbsGroup );
        LocalFree( pSelfSd );
        DBGPRINT(( "leaving xxxSetFileSecurity(8); returning=FileAccessError\n" ));
        return( FileAccessError );
    }

    Info |= DACL_SECURITY_INFORMATION;

    //
    // If the owner is not one of the admins, we will grab
    // it and local admin will now own it
    //

    if( pAbsOwner && !IsAllowSid( pAbsOwner ) ) {

        // Make the local admin own it
        rc = SetSecurityDescriptorOwner(
                 pAbsSd,
                 GetAdminSid(),
                 FALSE   // Not defaulted
                 );

        if( !rc ) {
            Error = GetLastError();

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "Could not set file owner %d",
                Error
            );

            if( pAbsSd ) LocalFree( pAbsSd );
            if( pAbsAcl ) LocalFree( pAbsAcl );
            if( pAbsSacl ) LocalFree( pAbsSacl );
            if( pAbsOwner ) LocalFree( pAbsOwner );
            if( pAbsGroup ) LocalFree( pAbsGroup );
            LocalFree( pSelfSd );
            DBGPRINT(( "leaving xxxSetFileSecurity(9); returning=FileAccessError\n" ));
            return( FileAccessError );
        }
        else {
            Info |= OWNER_SECURITY_INFORMATION;
        }
    }

#ifdef notdef       // WWM - don't worry about the group
    if( pAbsGroup && !IsAllowSid( pAbsGroup ) ) {

        // Make the local admin group own it
        rc = SetSecurityDescriptorGroup(
                 pAbsSd,
                 GetLocalAdminGroupSid(),
                 FALSE   // Not defaulted
                 );

        if( !rc ) {
            Error = GetLastError();

            ReportFileResult(
                FileAccessErrorUserFormat,
                0,                           // Access
                pFile,
                NULL,                        // pAccountName
                NULL,                        // pDomainName
                "Could not set file group %d",
                Error
            );

            if( pAbsSd ) LocalFree( pAbsSd );
            if( pAbsAcl ) LocalFree( pAbsAcl );
            if( pAbsSacl ) LocalFree( pAbsSacl );
            if( pAbsOwner ) LocalFree( pAbsOwner );
            if( pAbsGroup ) LocalFree( pAbsGroup );
            LocalFree( pSelfSd );
            DBGPRINT(( "leaving xxxSetFileSecurity(10); returning=FileAccessError\n" ));
            return( FileAccessError );
        }
        else {
            Info |= GROUP_SECURITY_INFORMATION;
        }
    }
#endif 

    //
    // Now set the new security descriptor onto the file
    //

    rc = SetFileSecurityW(
             pFile,
             Info,
             pAbsSd
             );

    if( !rc ) {
        Error = GetLastError();

        ReportFileResult(
            FileAccessErrorUserFormat,
            0,                           // Access
            pFile,
            NULL,                        // pAccountName
            NULL,                        // pDomainName
            "Could not set new Security Descriptor %d",
            Error
            );

        if( pAbsSd ) LocalFree( pAbsSd );
        if( pAbsAcl ) LocalFree( pAbsAcl );
        if( pAbsSacl ) LocalFree( pAbsSacl );
        if( pAbsOwner ) LocalFree( pAbsOwner );
        if( pAbsGroup ) LocalFree( pAbsGroup );
        LocalFree( pSelfSd );
        DBGPRINT(( "leaving xxxSetFileSecurity(11); returning=FileAccessError\n" ));
        return( FileAccessError );
    }

    if( pAbsSd ) LocalFree( pAbsSd );
    if( pAbsAcl ) LocalFree( pAbsAcl );
    if( pAbsSacl ) LocalFree( pAbsSacl );
    if( pAbsOwner ) LocalFree( pAbsOwner );
    if( pAbsGroup ) LocalFree( pAbsGroup );
    LocalFree( pSelfSd );
    DBGPRINT(( "leaving xxxSetFileSecurity(12); returning=FileOk\n" ));
    return( FileOk );
}


#ifdef notdef
    //
    // Get the owner SID
    //
    rc = GetSecurityDescriptorOwner(
             pSelfSd,
             &Owner,
             &OwnerDefaulted
             );

    if( !rc ) {
        // No owner info
        Owner = NULL;
    }

    //
    // Get the group SID
    //
    rc = GetSecurityDescriptorGroup(
             pSelfSd,
             &Group,
             &GroupDefaulted
             );

    if( !rc ) {
        // No group info
        Group = NULL;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\report.c ===
/*************************************************************************
*
* report.c
*
* Report module
*
*  Copyright Microsoft, 1998
*
*
*  This module puts all reporting in one place to accommadate changes.
*
*
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>              // Make a bunch of default NT templates
#include <process.h>

#include <winsta.h>
#include <syslib.h>

#include "security.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


//
// Forward references
//
VOID
PrintFileAccessMask(
    ACCESS_MASK Mask
    );


/*****************************************************************************
 *
 *  ReportFileResult
 *
 *   Generates a report on a file access check
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
ReportFileResult(
    FILE_RESULT Code,
    ACCESS_MASK Access,
    PWCHAR      pFile,
    PWCHAR      pAccountName,
    PWCHAR      pDomainName,
    PCHAR       UserFormat,
    ...
    )
{
    va_list arglist;
    UCHAR Buffer[512];
    int cb;
    DWORD Len;

    va_start(arglist, UserFormat);

    //
    // New format:
    //
    //    6      28                          xxx
    //  ACCESS ACCOUNT                      FILE
    //  ______ ____________________________ _______________________________________
    //

    if( Code == FileOk ) {
        ; // Do nothing, future options may report an OK list
        return (TRUE );
    }
    else if( Code == FileAccessError ) {
        DBGPRINT(("***WARNING*** Error accessing security information on file %ws\n",pFile));
        DBGPRINT(("The account in which the utility is run may not have access to the file\n"));
        DBGPRINT(("Use FileManager to take ownership of this file\n"));
        return (TRUE );
    }
    else if( Code == FileAccessErrorUserFormat ) {

        // Use the user supplied format string in the error report
        cb = _vsnprintf(Buffer, sizeof(Buffer), UserFormat, arglist);
        if (cb == -1) {         // detect buffer overflow
            cb = sizeof(Buffer);
            Buffer[sizeof(Buffer) - 1] = '\n';
        }

        DBGPRINT(("***ERROR*** %s on file %ws\n",Buffer,pFile));
        return( TRUE );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\registry.c ===
/*************************************************************************
*
* registry.c
*
* Functions to provide easy access to security (ACLs).
*
* Copyright Microsoft, 1998
*
*
*************************************************************************/

/* include files */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "winsta.h"
#include "syslib.h"
#include "regapi.h"

#if DBG
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*
 * Data Structure
 */
/// NONE YET...


/*
 * Definitions
 */
#define SZENABLE TEXT("1")


/*
 * procedure prototypes
 */
BOOL QueryFlatTempKey( VOID );


/*****************************************************************************
 *
 *  QueryFlatTempKey
 *
 *  ENTRY: Nothing.
 *
 *  EXIT:  TRUE  - enabled
 *         FALSE - disabled (key doesn't exist or isn't "1")
 *
 *
 ****************************************************************************/

BOOL
QueryFlatTempKey( VOID )
{
    DWORD  dwType = REG_SZ;
    DWORD  dwSize = 3 * sizeof(WCHAR);
    WCHAR  szValue[3];
    HKEY   Handle;
    LONG   rc;

    // 
    // Ideally, I could just call TS's  RegGetMachinePolicy() and get the policy. But
    // that makes a lot of reg reads and I just don't want to slow down the
    // login cycle.
    // So, for now, I will read the reg policy tree directly.
    // 08/15/2000 AraBern
    //


    // see if there is a policy value:
    {
         DWORD dwType;
         DWORD perSessionTempDir;
         LONG  Err;
         HKEY  hKey;
         DWORD dwSize = sizeof(DWORD);

        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            TS_POLICY_SUB_TREE,
            0,
            KEY_QUERY_VALUE,
            &hKey);
    
        if(Err == ERROR_SUCCESS)
        {
                         
            Err = RegQueryValueEx(hKey,
                         REG_TERMSRV_PERSESSIONTEMPDIR ,
                         NULL,
                         &dwType,
                         (LPBYTE)&perSessionTempDir,
                         &dwSize);


            RegCloseKey(hKey);
            
            if(Err == ERROR_SUCCESS)
            {
                // if we have per session temp folders, then obviously we can't allow flat temp.
                if (perSessionTempDir ) 
                {
                    return FALSE;
                }
                // else is a fall thru, since not having per session does not mean having flat temp.

            }
            // else is a fall thru to the below block
    
        }
    }

    // by now we have no policy present, so if the flat temp is set.

    /*
     *  Open registry
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REG_CONTROL_TSERVER,
                       0,
                       KEY_READ,
                       &Handle ) != ERROR_SUCCESS ) {
        return FALSE;
    }

    /*
     *  Read registry value
     */
    rc = RegQueryValueExW( Handle,
                           REG_CITRIX_FLATTEMPDIR,
                           NULL,
                           &dwType,
                           (PUCHAR)&szValue,
                           &dwSize );

    /*
     *  Close registry and key handle
     */
    RegCloseKey( Handle );

    return( (rc == ERROR_SUCCESS) && (lstrcmp(szValue,SZENABLE) == 0) );

} // end of QueryFlatTempKey()


// FROM regapi\reguc.c : this function has been modified to get rid of all
// registry accesses.
/*******************************************************************************
 *
 *  RegDefaultUserConfigQueryW (UNICODE)
 *
 *    Query the Default User Configuration from the indicated server's registry.
 *
 * ENTRY:
 *    pServerName (input)
 *       Points to string of server to access (NULL for current machine).
 *    pUserConfig (input)
 *       Pointer to a USERCONFIGW structure that will receive the default
 *       user configuration information.
 *    UserConfigLength (input)
 *       Specifies the length in bytes of the pUserConfig buffer.
 *    pReturnLength (output)
 *       Receives the number of bytes placed in the pUserConfig buffer.
 *
 * EXIT:
 *    Always will return ERROR_SUCCESS, unless UserConfigLength is incorrect.
 *
 ******************************************************************************/

LONG WINAPI
RegDefaultUserConfigQueryW( WCHAR * pServerName,
                            PUSERCONFIGW pUserConfig,
                            ULONG UserConfigLength,
                            PULONG pReturnLength )
{
    UNREFERENCED_PARAMETER( pServerName );

    /*
     * Validate length and zero-initialize the destination
     * USERCONFIGW buffer.
     */
    if ( UserConfigLength < sizeof(USERCONFIGW) )
        return( ERROR_INSUFFICIENT_BUFFER );

    /*
     * Initialize to an initial default.
     */
    memset(pUserConfig, 0, UserConfigLength);

    pUserConfig->fInheritAutoLogon = TRUE;

    pUserConfig->fInheritResetBroken = TRUE;

    pUserConfig->fInheritReconnectSame = TRUE;

    pUserConfig->fInheritInitialProgram = TRUE;

    pUserConfig->fInheritCallback = FALSE;

    pUserConfig->fInheritCallbackNumber = TRUE;

    pUserConfig->fInheritShadow = TRUE;

    pUserConfig->fInheritMaxSessionTime = TRUE;

    pUserConfig->fInheritMaxDisconnectionTime = TRUE;

    pUserConfig->fInheritMaxIdleTime = TRUE;

    pUserConfig->fInheritAutoClient = TRUE;

    pUserConfig->fInheritSecurity = FALSE;

    pUserConfig->fPromptForPassword = FALSE;

    pUserConfig->fResetBroken = FALSE;

    pUserConfig->fReconnectSame = FALSE;

    pUserConfig->fLogonDisabled = FALSE;

    pUserConfig->fAutoClientDrives = TRUE;

    pUserConfig->fAutoClientLpts = TRUE;

    pUserConfig->fForceClientLptDef = TRUE;

    pUserConfig->fDisableEncryption = TRUE;

    pUserConfig->fHomeDirectoryMapRoot = FALSE;

    pUserConfig->fUseDefaultGina = FALSE;

    pUserConfig->fDisableCpm = FALSE;

    pUserConfig->fDisableCdm = FALSE;

    pUserConfig->fDisableCcm = FALSE;

    pUserConfig->fDisableLPT = FALSE;

    pUserConfig->fDisableClip = FALSE;

    pUserConfig->fDisableExe = FALSE;

    pUserConfig->fDisableCam = FALSE;

    pUserConfig->UserName[0] = 0;

    pUserConfig->Domain[0] = 0;

    pUserConfig->Password[0] = 0;

    pUserConfig->WorkDirectory[0] = 0;

    pUserConfig->InitialProgram[0] = 0;

    pUserConfig->CallbackNumber[0] = 0;

    pUserConfig->Callback = Callback_Disable;

    pUserConfig->Shadow = Shadow_EnableInputNotify;

    pUserConfig->MaxConnectionTime = 0;

    pUserConfig->MaxDisconnectionTime = 0;

    pUserConfig->MaxIdleTime = 0;

    pUserConfig->KeyboardLayout = 0;

    pUserConfig->MinEncryptionLevel = 1;

    pUserConfig->fWallPaperDisabled = FALSE;

    pUserConfig->NWLogonServer[0] = 0;

    pUserConfig->WFProfilePath[0] = 0;

    pUserConfig->WFHomeDir[0] = 0;

    pUserConfig->WFHomeDirDrive[0] = 0;


    *pReturnLength = sizeof(USERCONFIGW);

    return( ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\security.c ===
/*************************************************************************
*
* security.c
*
* NT Security routines
*
* copyright notice: Copyright 1997, Microsoft
*
*************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <ntseapi.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <windows.h>
#include <string.h>
#include <wcstr.h>
#include "seopaque.h"
#include "sertlp.h"

#include <process.h>

#include <winsta.h>
#include <syslib.h>
#include <lmcons.h> // for DNLEN  KLB 09-18-96

#include "security.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

typedef struct _SIDLIST {
    struct _SIDLIST *Next;
    USHORT          SidCrc;
    PWCHAR          pAccountName;
    PWCHAR          pDomainName;
} SIDLIST, *PSIDLIST;

static PSIDLIST SidCache = NULL;

// Computer Name
WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH+1];

// Admins only ACL
PACL  pAdminsOnlyAcl = NULL;
DWORD AdminsOnlyAclSize = 0;

//
// Universal well known SIDs
//

PSID  SeNullSid;
PSID  SeWorldSid;
PSID  SeLocalSid;
PSID  SeCreatorOwnerSid;
PSID  SeCreatorGroupSid;

//
// Sids defined by NT
//

PSID SeNtAuthoritySid;
PSID SeDialupSid;
PSID SeNetworkSid;
PSID SeBatchSid;
PSID SeInteractiveSid;
PSID SeServiceSid;
PSID SeLocalGuestSid;
PSID SeLocalSystemSid;
PSID SeLocalAdminSid;
PSID SeLocalManagerSid;
PSID SeAliasAdminsSid;
PSID SeAliasUsersSid;
PSID SeAliasGuestsSid;
PSID SeAliasPowerUsersSid;
PSID SeAliasAccountOpsSid;
PSID SeAliasSystemOpsSid;
PSID SeAliasPrintOpsSid;
PSID SeAliasBackupOpsSid;
PSID SeAliasReplicatorSid;

static SID_IDENTIFIER_AUTHORITY    SepNullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepWorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepLocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepCreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
static SID_IDENTIFIER_AUTHORITY    SepNtAuthority = SECURITY_NT_AUTHORITY;

//
// Sid of primary domain, and admin account in that domain
//

PSID SepPrimaryDomainSid;
PSID SepPrimaryDomainAdminSid;


// External data
extern ADMIN_ACCOUNTS AllowAccounts[];
extern DWORD AllowAccountEntries;
extern ACCESS_MASK AllowAccess;

extern ADMIN_ACCOUNTS DenyAccounts[];
extern DWORD DenyAccountEntries;
extern ACCESS_MASK DeniedAccess;


// Forward and external references

BOOLEAN
InitializeBuiltinSids();

BOOL
LoadAccountSids();

BOOL
BuildSecureAcl();

BOOL
xxxLookupBuiltinAccount(
    PWCHAR pSystemName,
    PWCHAR pAccountName,
    PSID   *ppSid
    );

BOOL
GetCurrentUserSid( PSID *ppSid );


/*****************************************************************************
 *
 *  InitSecurity
 *
 *   Initialize the security package
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   TRUE  - no error
 *   FALSE - error
 *
 ****************************************************************************/

BOOL
InitSecurity(
    )
{
    BOOL rc;
    DWORD Size = sizeof(ComputerName)/sizeof(WCHAR);

    rc = GetComputerNameW( ComputerName, &Size );
    if( !rc ) {
        DBGPRINT(("***ERROR*** %d Could not get computer name\n",GetLastError() ));
        return( FALSE );
    }

    rc = InitializeBuiltinSids();
    if( !rc ) {
        DBGPRINT(("***ERROR*** Some built-in accounts not loaded\n"));
        return( FALSE );
    }

    rc = LoadAccountSids();
    if( !rc ) {
        DBGPRINT(("***ERROR*** Some accounts not loaded\n"));
        return( FALSE );
    }

    rc = BuildSecureAcl();
    if( !rc ) {
        DBGPRINT(("***ERROR*** Could not build ACL\n"));
        return( FALSE );
    }

    return( TRUE );
}

/*****************************************************************************
 *
 *  LoadAccountSids
 *
 *   Load the list of account access SIDS.
 *
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
LoadAccountSids()
{
    BOOL rc, Final;
    NTSTATUS Status;
    SID_IDENTIFIER_AUTHORITY gSystemSidAuthority = SECURITY_NT_AUTHORITY;


    Final = TRUE;

    //
    // Get the SID's for all of the allow accounts
    //

    //
    // Get the SID of the built-in Administrators group
    //

    Status = RtlAllocateAndInitializeSid(
                     &gSystemSidAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,0,0,0,0,0,
                     &(AllowAccounts[ADMIN_ACCOUNT].pSid));
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("SYSLIB: Couldn't allocate Administrators SID (0x%x)\n", Status ));
        Final = FALSE;
    }

    //
    // SYSTEM
    //

    Status = RtlAllocateAndInitializeSid(
                     &gSystemSidAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,0,0,0,0,0,0,
                     &(AllowAccounts[SYSTEM_ACCOUNT].pSid));
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("SYSLIB: Couldn't allocate SYSTEM SID (0x%x)\n", Status ));
        Final = FALSE;
    }

    //
    // Get the current user's Sid
    //
    rc = xxxLookupAccountName(
             ComputerName,
             CURRENT_USER,
             &(AllowAccounts[USER_ACCOUNT].pSid)
             );

    if ( !rc ) {
        // It might be a special builtin account
        rc = xxxLookupBuiltinAccount(
             ComputerName,
             CURRENT_USER,
             &(AllowAccounts[USER_ACCOUNT].pSid)
             );

        if( !rc ) {
            DBGPRINT(("***WARNING*** Could not find SID for current user account, Error %d\n", GetLastError() ));
            Final = FALSE;
        }
    }

#ifdef notdef
    //
    // Lookup the SID's for all of the deny accounts
    //

    for( Index = 0; Index < DenyAccountEntries; Index++ ) {

        p = &DenyAccounts[Index];

        rc = xxxLookupAccountName(
                 ComputerName,
                 p->Name,
                 &p->pSid
                 );

        if( !rc ) {
            // It might be a special builtin account
            rc = xxxLookupBuiltinAccount(
                     ComputerName,
                     p->Name,
                     &p->pSid
                     );

            if( !rc ) {
                DBGPRINT(("***WARNING*** Could not find SID for account %ws Error %d\n",p->Name,GetLastError() ));
                Final = FALSE;
            }
        }
    }
#endif

    // Lower level function outputs if any accounts are invalid

    return( Final );
}

/*****************************************************************************
 *
 *  IsAllowSid
 *
 *   Returns whether the supplied SID is in the allow group
 *
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
IsAllowSid(
    PSID pSid
    )
{
    DWORD Index;
    PADMIN_ACCOUNTS p;
    BOOL  AllowSid = FALSE;

    for( Index = 0; Index < AllowAccountEntries; Index++ ) {

        p = &AllowAccounts[Index];

        if( p->pSid && EqualSid( pSid, p->pSid ) ) {
            // The Sid is for an allowed account
            AllowSid = TRUE;
            break;
        }
    }

    return( AllowSid );
}


/*****************************************************************************
 *
 *  xxxLookupAccountName
 *
 *   Wrapper to lookup the SID for a given account name
 *
 *   Returns a pointer to the SID in newly allocated memory
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
xxxLookupAccountName(
    PWCHAR pSystemName,
    PWCHAR pAccountName,
    PSID   *ppSid
    )
{
    BOOL  rc;
    DWORD Size, DomainSize, Error;
    SID_NAME_USE Type;
    PWCHAR pDomain = NULL;
    PSID pSid = NULL;
    WCHAR Buf;
    WCHAR pCurrentUser[MAX_ACCOUNT_NAME];   // KLB 09-16-96
    DWORD dwCurrentUser = MAX_ACCOUNT_NAME; // KLB 09-16-96
    WCHAR pAccountToLookup[MAX_ACCOUNT_NAME+DNLEN+1]; // KLB 09-18-96
    LPWSTR pLogon32DomainName = NULL; // KLB 09-19-96
    WINSTATIONINFORMATION WinInfo; // KLB 09-30-96
    ULONG ReturnLength; // KLB 09-30-96

    Size = 0;
    DomainSize = 0;

    /*
     * Open the WinStation and Query its information.
     */
    memset( &WinInfo,    0, sizeof(WINSTATIONINFORMATION) );
    rc = WinStationQueryInformation( SERVERNAME_CURRENT,
                                     LOGONID_CURRENT,
                                     WinStationInformation,
                                     (PVOID)&WinInfo,
                                     sizeof(WINSTATIONINFORMATION),
                                     &ReturnLength );
    if ( !rc ) {
        DBGPRINT(("error querying winstation information %d.\n", GetLastError() ));
        return( FALSE );
    }
    if( ReturnLength != sizeof(WINSTATIONINFORMATION) ) {
        DBGPRINT(("winstation info version mismatch!\n"));
        return( FALSE );
    }

    if (lstrcmpi(pAccountName,CURRENT_USER) == 0) {
       lstrcpy( pAccountToLookup, WinInfo.Domain );
       lstrcat( pAccountToLookup, L"\\" );
       lstrcat( pAccountToLookup, WinInfo.UserName );
    } else {
       lstrcpy( pAccountToLookup, pAccountName );
    }
    DBGPRINT(( "looking up account %ws\n", pAccountToLookup ));

    rc = LookupAccountNameW(
             pSystemName,
             pAccountToLookup, // KLB 09-16-96
             &Buf,    // pSid
             &Size,
             &Buf,    // pDomain
             &DomainSize,
             &Type
             );

    if( rc ) {
        DBGPRINT(("Internal error on account name %ws\n",pAccountToLookup));
        return( FALSE );
    }
    else {
        Error = GetLastError();
        if( Error != ERROR_INSUFFICIENT_BUFFER ) {
            DBGPRINT(("***ERROR*** %d looking up SID for account name %ws skipped without processing!\n",Error,pAccountToLookup));
            return( FALSE );
        }

        pSid = LocalAlloc( LMEM_FIXED, Size );
        if( pSid == NULL ) {
            DBGPRINT(("***ERROR*** Out of memory, skipped account %ws without processing!\n",pAccountToLookup));
            return( FALSE );
        }

        pDomain = LocalAlloc( LMEM_FIXED, DomainSize*sizeof(WCHAR) );
        if( pDomain == NULL ) {
            DBGPRINT(("***ERROR*** Out of memory, skipped account %ws without processing!\n",pAccountToLookup));
            LocalFree( pSid );
            return( FALSE );
        }

        rc = LookupAccountNameW(
                 pSystemName,
                 pAccountToLookup,
                 pSid,
                 &Size,
                 pDomain,
                 &DomainSize,
                 &Type
                 );

        if( !rc ) {
            DBGPRINT(("***ERROR*** %d looking up SID for account name %ws skipped without processing!\n",Error,pAccountToLookup));
            LocalFree( pSid );
            LocalFree( pDomain );
            return( FALSE );
        }

        *ppSid = pSid;

        LocalFree( pDomain );
        DBGPRINT(( "leaving xxxLookupAccountName(); pSid is okay, returning TRUE.\n" ));
        return( TRUE );
    }
}

/*****************************************************************************
 *
 *  InitializeBuiltinSids
 *
 *   Initialize the built in SIDS
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
InitializeBuiltinSids()
{

    ULONG SidWithZeroSubAuthorities;
    ULONG SidWithOneSubAuthority;
    ULONG SidWithTwoSubAuthorities;
    ULONG SidWithThreeSubAuthorities;

    SID_IDENTIFIER_AUTHORITY NullSidAuthority;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority;
    SID_IDENTIFIER_AUTHORITY SeNtAuthority;

    NullSidAuthority         = SepNullSidAuthority;
    WorldSidAuthority        = SepWorldSidAuthority;
    LocalSidAuthority        = SepLocalSidAuthority;
    CreatorSidAuthority      = SepCreatorSidAuthority;
    SeNtAuthority            = SepNtAuthority;

    //
    //  The following SID sizes need to be allocated
    //

    SidWithZeroSubAuthorities  = RtlLengthRequiredSid( 0 );
    SidWithOneSubAuthority     = RtlLengthRequiredSid( 1 );
    SidWithTwoSubAuthorities   = RtlLengthRequiredSid( 2 );
    SidWithThreeSubAuthorities = RtlLengthRequiredSid( 3 );

    //
    //  Allocate and initialize the universal SIDs
    //

    SeNullSid         = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, SidWithOneSubAuthority);
    SeWorldSid        = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, SidWithOneSubAuthority);
    SeLocalSid        = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, SidWithOneSubAuthority);
    SeCreatorOwnerSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, SidWithOneSubAuthority);
    SeCreatorGroupSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, SidWithOneSubAuthority);

    //
    // Fail initialization if we didn't get enough memory for the universal
    // SIDs.
    //

    if ( (SeNullSid         == NULL) ||
         (SeWorldSid        == NULL) ||
         (SeLocalSid        == NULL) ||
         (SeCreatorOwnerSid == NULL) ||
         (SeCreatorGroupSid == NULL)
       ) {

        return( FALSE );
    }

    RtlInitializeSid( SeNullSid,         &NullSidAuthority, 1 );
    RtlInitializeSid( SeWorldSid,        &WorldSidAuthority, 1 );
    RtlInitializeSid( SeLocalSid,        &LocalSidAuthority, 1 );
    RtlInitializeSid( SeCreatorOwnerSid, &CreatorSidAuthority, 1 );
    RtlInitializeSid( SeCreatorGroupSid, &CreatorSidAuthority, 1 );

    *(RtlSubAuthoritySid( SeNullSid, 0 ))         = SECURITY_NULL_RID;
    *(RtlSubAuthoritySid( SeWorldSid, 0 ))        = SECURITY_WORLD_RID;
    *(RtlSubAuthoritySid( SeLocalSid, 0 ))        = SECURITY_LOCAL_RID;
    *(RtlSubAuthoritySid( SeCreatorOwnerSid, 0 )) = SECURITY_CREATOR_OWNER_RID;
    *(RtlSubAuthoritySid( SeCreatorGroupSid, 0 )) = SECURITY_CREATOR_GROUP_RID;

    //
    // Allocate and initialize the NT defined SIDs
    //

    SeNtAuthoritySid  = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithZeroSubAuthorities);
    SeDialupSid       = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeNetworkSid      = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeBatchSid        = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeInteractiveSid  = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeServiceSid      = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeLocalGuestSid   = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeLocalSystemSid  = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeLocalAdminSid   = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);
    SeLocalManagerSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithOneSubAuthority);

    SeAliasAdminsSid     = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasUsersSid      = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasGuestsSid     = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasPowerUsersSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasAccountOpsSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasSystemOpsSid  = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasPrintOpsSid   = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasBackupOpsSid  = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);
    SeAliasReplicatorSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,  SidWithTwoSubAuthorities);


    //
    // Fail initialization if we didn't get enough memory for the NT SIDs.
    //

    if ( (SeNtAuthoritySid      == NULL) ||
         (SeDialupSid           == NULL) ||
         (SeNetworkSid          == NULL) ||
         (SeBatchSid            == NULL) ||
         (SeInteractiveSid      == NULL) ||
         (SeServiceSid          == NULL) ||
         (SeLocalGuestSid       == NULL) ||
         (SeLocalSystemSid      == NULL) ||
         (SeLocalAdminSid       == NULL) ||
         (SeLocalManagerSid     == NULL) ||
         (SeAliasAdminsSid      == NULL) ||
         (SeAliasUsersSid       == NULL) ||
         (SeAliasGuestsSid      == NULL) ||
         (SeAliasPowerUsersSid  == NULL) ||
         (SeAliasAccountOpsSid  == NULL) ||
         (SeAliasSystemOpsSid   == NULL) ||
         (SeAliasReplicatorSid  == NULL) ||
         (SeAliasPrintOpsSid    == NULL) ||
         (SeAliasBackupOpsSid   == NULL)
       ) {

        return( FALSE );
    }

    RtlInitializeSid( SeNtAuthoritySid,     &SeNtAuthority, 0 );
    RtlInitializeSid( SeDialupSid,          &SeNtAuthority, 1 );
    RtlInitializeSid( SeNetworkSid,         &SeNtAuthority, 1 );
    RtlInitializeSid( SeBatchSid,           &SeNtAuthority, 1 );
    RtlInitializeSid( SeInteractiveSid,     &SeNtAuthority, 1 );
    RtlInitializeSid( SeServiceSid,         &SeNtAuthority, 1 );
    RtlInitializeSid( SeLocalGuestSid,      &SeNtAuthority, 1 );
    RtlInitializeSid( SeLocalSystemSid,     &SeNtAuthority, 1 );
    RtlInitializeSid( SeLocalAdminSid,      &SeNtAuthority, 1 );
    RtlInitializeSid( SeLocalManagerSid,    &SeNtAuthority, 1 );

    RtlInitializeSid( SeAliasAdminsSid,     &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasUsersSid,      &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasGuestsSid,     &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasPowerUsersSid, &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasAccountOpsSid, &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasSystemOpsSid,  &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasPrintOpsSid,   &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasBackupOpsSid,  &SeNtAuthority, 2);
    RtlInitializeSid( SeAliasReplicatorSid, &SeNtAuthority, 2);


    *(RtlSubAuthoritySid( SeDialupSid,          0 )) = SECURITY_DIALUP_RID;
    *(RtlSubAuthoritySid( SeNetworkSid,         0 )) = SECURITY_NETWORK_RID;
    *(RtlSubAuthoritySid( SeBatchSid,           0 )) = SECURITY_BATCH_RID;
    *(RtlSubAuthoritySid( SeInteractiveSid,     0 )) = SECURITY_INTERACTIVE_RID;
    *(RtlSubAuthoritySid( SeServiceSid,         0 )) = SECURITY_SERVICE_RID;
//    *(RtlSubAuthoritySid( SeLocalGuestSid,      0 )) = SECURITY_LOCAL_GUESTS_RID;
    *(RtlSubAuthoritySid( SeLocalSystemSid,     0 )) = SECURITY_LOCAL_SYSTEM_RID;
//    *(RtlSubAuthoritySid( SeLocalAdminSid,      0 )) = SECURITY_LOCAL_ADMIN_RID;
//    *(RtlSubAuthoritySid( SeLocalManagerSid,    0 )) = SECURITY_LOCAL_MANAGER_RID;


    *(RtlSubAuthoritySid( SeAliasAdminsSid,     0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasUsersSid,      0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasGuestsSid,     0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasPowerUsersSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasAccountOpsSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasSystemOpsSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasPrintOpsSid,   0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasBackupOpsSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasReplicatorSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;

    *(RtlSubAuthoritySid( SeAliasAdminsSid,     1 )) = DOMAIN_ALIAS_RID_ADMINS;
    *(RtlSubAuthoritySid( SeAliasUsersSid,      1 )) = DOMAIN_ALIAS_RID_USERS;
    *(RtlSubAuthoritySid( SeAliasGuestsSid,     1 )) = DOMAIN_ALIAS_RID_GUESTS;
    *(RtlSubAuthoritySid( SeAliasPowerUsersSid, 1 )) = DOMAIN_ALIAS_RID_POWER_USERS;
    *(RtlSubAuthoritySid( SeAliasAccountOpsSid, 1 )) = DOMAIN_ALIAS_RID_ACCOUNT_OPS;
    *(RtlSubAuthoritySid( SeAliasSystemOpsSid,  1 )) = DOMAIN_ALIAS_RID_SYSTEM_OPS;
    *(RtlSubAuthoritySid( SeAliasPrintOpsSid,   1 )) = DOMAIN_ALIAS_RID_PRINT_OPS;
    *(RtlSubAuthoritySid( SeAliasBackupOpsSid,  1 )) = DOMAIN_ALIAS_RID_BACKUP_OPS;
    *(RtlSubAuthoritySid( SeAliasReplicatorSid, 1 )) = DOMAIN_ALIAS_RID_REPLICATOR;

    return( TRUE );
}


/*****************************************************************************
 *
 *  xxxLookupBuiltinAccount
 *
 *   Wrapper to lookup the SID for a given built in account name
 *
 *   Returns a pointer to the SID in newly allocated memory
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
xxxLookupBuiltinAccount(
    PWCHAR pSystemName,
    PWCHAR pAccountName,
    PSID   *ppSid
    )
{
    USHORT SidLen;
    SID_NAME_USE Type;
    PSID pSid = NULL;

    if( _wcsicmp( L"NULL_SID", pAccountName ) == 0 ) {
        pSid = SeNullSid;
        Type = SidTypeInvalid;
    }

    if( pSid == NULL ) {
        SetLastError( ERROR_NONE_MAPPED );
        return( FALSE );
    }

    SidLen = (USHORT)GetLengthSid( pSid );
    *ppSid = LocalAlloc(LMEM_FIXED, SidLen );
    if( *ppSid == NULL ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return( FALSE );
    }

    RtlMoveMemory( *ppSid, pSid, SidLen );

    return( TRUE );

#ifdef notdef

    if( EqualSid( SeNullSid, pSid ) ) {
        pName = L"NULL_SID";
        Type = SidTypeInvalid;
    }

    if( EqualSid( SeWorldSid, pSid ) ) {
        pName = L"WORLD";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeLocalSid, pSid ) ) {
        pName = L"LOCAL_ACCOUNT";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeCreatorOwnerSid, pSid ) ) {
        pName = L"CREATOR_OWNER";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeCreatorGroupSid, pSid ) ) {
        pName = L"CREATOR_GROUP";
        Type = SidTypeWellKnownGroup;
    }

    //
    // Look at the NT SIDS
    //

    if( EqualSid( SeNtAuthoritySid, pSid ) ) {
        pName = L"NTAUTHORITY";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeDialupSid, pSid ) ) {
        pName = L"DIALUP";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeNetworkSid, pSid ) ) {
        pName = L"NETWORK";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeBatchSid, pSid ) ) {
        pName = L"BATCH";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeInteractiveSid, pSid ) ) {
        pName = L"INTERACTIVE";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeServiceSid, pSid ) ) {
        pName = L"SERVICE";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeLocalGuestSid, pSid ) ) {
        pName = L"LOCALGUEST";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeLocalSystemSid, pSid ) ) {
        pName = L"LOCALSYSTEM";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeLocalAdminSid, pSid ) ) {
        pName = L"LOCALADMIN";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeLocalManagerSid, pSid ) ) {
        pName = L"LOCALMANAGER";
        Type = SidTypeWellKnownGroup;
    }

    if( EqualSid( SeAliasAdminsSid, pSid ) ) {
        pName = L"ALIAS_ADMINS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasUsersSid, pSid ) ) {
        pName = L"ALIAS_USERS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasGuestsSid, pSid ) ) {
        pName = L"ALIAS_GUESTS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasPowerUsersSid, pSid ) ) {
        pName = L"ALIAS_POWERUSERS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasAccountOpsSid, pSid ) ) {
        pName = L"ALIAS_ACCOUNT_OPS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasSystemOpsSid, pSid ) ) {
        pName = L"ALIAS_SYSTEM_OPS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasPrintOpsSid, pSid ) ) {
        pName = L"ALIAS_PRINT_OPS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasBackupOpsSid, pSid ) ) {
        pName = L"ALIAS_BACKUP_OPS";
        Type = SidTypeAlias;
    }

    if( EqualSid( SeAliasReplicatorSid, pSid ) ) {
        pName = L"ALIAS_REPLICATOR";
        Type = SidTypeAlias;
    }
#endif
}

/*****************************************************************************
 *
 *  GetSecureAcl
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PACL
GetSecureAcl()
{
    return( pAdminsOnlyAcl );
}

/*****************************************************************************
 *
 *  BuildSecureAcl
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
BuildSecureAcl()
{
    BOOL  rc;
    DWORD Index, Error;
    PADMIN_ACCOUNTS p;
    DWORD AclSize;
    PACL  pAcl = NULL;
    PACCESS_ALLOWED_ACE pAce = NULL;

    /*
     * Calculate the ACL size
     */
    AclSize = sizeof(ACL);

    //
    // Reserve memory for the deny ACE's
    //
    for( Index = 0; Index < DenyAccountEntries; Index++ ) {

        p = &DenyAccounts[Index];

        if( p->pSid ) {
            AclSize += sizeof(ACCESS_DENIED_ACE);
            AclSize += (GetLengthSid( p->pSid ) - sizeof(DWORD));
        }
    }

    //
    // Reserve memory for the allowed ACE's
    //
    for( Index = 0; Index < AllowAccountEntries; Index++ ) {

        p = &AllowAccounts[Index];

        if( p->pSid ) {
            AclSize += sizeof(ACCESS_ALLOWED_ACE);
            AclSize += (GetLengthSid( p->pSid ) - sizeof(DWORD));
        }
    }

    pAcl = LocalAlloc( LMEM_FIXED, AclSize );
    if( pAcl == NULL ) {
        DBGPRINT(("Could not allocate memory\n"));
        return( FALSE );
    }

    rc = InitializeAcl(
             pAcl,
             AclSize,
             ACL_REVISION
             );

    if( !rc ) {
        DBGPRINT(("Error %d InitializeAcl\n",GetLastError()));
        LocalFree( pAcl );
        return( FALSE );
    }

    /*
     * Add a deny all ACE for each account in the deny list
     */
    for( Index = 0; Index < DenyAccountEntries; Index++ ) {

        p = &DenyAccounts[Index];

        rc = AddAccessDeniedAce(
                 pAcl,
                 ACL_REVISION,
                 FILE_ALL_ACCESS,
                 p->pSid
                 );

        if( !rc ) {
            Error = GetLastError();
            DBGPRINT(("***ERROR*** adding deny ACE %d for account %ws\n",Error,p->Name));
        }
    }

    /*
     * Add an allow all ACE for each account in the allow list
     */
    for( Index = 0; Index < AllowAccountEntries; Index++ ) {

        p = &AllowAccounts[Index];

        rc = AddAccessAllowedAce(
                 pAcl,
                 ACL_REVISION,
                 FILE_ALL_ACCESS,
                 p->pSid
                 );

        if( !rc ) {
            Error = GetLastError();
            DBGPRINT(("***ERROR*** adding allow ACE %d for account %ws\n",Error,p->Name));
        }
    }

    pAdminsOnlyAcl = pAcl;
    AdminsOnlyAclSize = AclSize;

    //
    // Put the inherit flags on the ACE's
    //
    for( Index=0; Index < pAcl->AceCount; Index++ ) {

        rc = GetAce( pAcl, Index, (PVOID)&pAce );
        if( !rc ) {
            continue;
        }

        pAce->Header.AceFlags |= (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE);
   }

   return( TRUE );
}

/*****************************************************************************
 *
 *  GetLocalAdminSid
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PSID
GetLocalAdminSid()
{
    return( SeLocalAdminSid );
}

/*****************************************************************************
 *
 *  GetAdminSid
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *
 ****************************************************************************/

PSID
GetAdminSid()
{
    return( AllowAccounts[ADMIN_ACCOUNT].pSid );
}

/*****************************************************************************
 *
 *  GetLocalAdminGroupSid
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PSID
GetLocalAdminGroupSid()
{
    return( SeAliasAdminsSid );
}


/*****************************************************************************
 *
 *  GetLocalAdminGroupSid
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL CheckUserSid()
{
    BOOL rc;
    PSID pSid;
    PSID pPrevSid;

    rc = xxxLookupAccountName(
         ComputerName,
         AllowAccounts[USER_ACCOUNT].Name,
         &pSid
         );

    if( !rc ) {
        // It might be a special builtin account
        rc = xxxLookupBuiltinAccount(
                 ComputerName,
                 AllowAccounts[USER_ACCOUNT].Name,
                 &pSid
                 );
    }

    pPrevSid = AllowAccounts[USER_ACCOUNT].pSid;
    if (rc && (!pPrevSid || !EqualSid( pSid, pPrevSid ))) {
        AllowAccounts[USER_ACCOUNT].pSid = pSid;
        if (pAdminsOnlyAcl) {
            LocalFree( pAdminsOnlyAcl );
            pAdminsOnlyAcl = NULL;
            AdminsOnlyAclSize = 0;
        }
        rc = BuildSecureAcl();
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\secutil.c ===
/*************************************************************************
*
* secutil.c
*
* Security Related utility functions
*
* copyright notice: Copyright 1998, Microsoft.
*
*
*
*************************************************************************/

// Include NT headers
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>

#include "windows.h"
#include <winsta.h>
#include <syslib.h>


/*****************************************************************************
 *
 *  TestUserForAdmin
 *
 *   Returns whether the current thread is running under admin
 *   security.
 *
 * ENTRY:
 *
 * EXIT:
 *   TRUE/FALSE - whether user is specified admin
 *
 ****************************************************************************/

BOOL 
TestUserForAdmin( VOID )
{
    BOOL IsMember, IsAnAdmin;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    PSID AdminSid;


    IsAnAdmin = FALSE;

    if (NT_SUCCESS(RtlAllocateAndInitializeSid(
                                     &SystemSidAuthority,
                                     2,
                                     SECURITY_BUILTIN_DOMAIN_RID,
                                     DOMAIN_ALIAS_RID_ADMINS,
                                     0, 0, 0, 0, 0, 0,
                                     &AdminSid
                                     ) ) )
    {
        CheckTokenMembership( NULL,
                              AdminSid,
                              &IsAnAdmin);
        RtlFreeSid(AdminSid);
    }

    return IsAnAdmin;

}



/*****************************************************************************
 *
 *  TestUserForGroup
 *
 *   Returns whether the current thread is a member of the requested group.
 *
 * ENTRY:
 *   pwszGrouName (input)
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/
/* unused
BOOL
TestUserForGroup( PWCHAR pwszGroupName )
{
    HANDLE Token;
    ULONG InfoLength;
    PTOKEN_GROUPS TokenGroupList;
    ULONG GroupIndex;
    BOOL GroupMember = FALSE;
    PSID pGroupSid = NULL;
    DWORD cbGroupSid = 0;
    NTSTATUS Status;
    PWCHAR pwszDomain = NULL;
    DWORD cbDomain = 0;
    SID_NAME_USE peUse;

    //
    // Open current thread/process token
    //
    Status = NtOpenThreadToken( NtCurrentThread(), TOKEN_QUERY, FALSE, &Token );
    if ( !NT_SUCCESS( Status ) ) {
        Status = NtOpenProcessToken( NtCurrentProcess(), TOKEN_QUERY, &Token );
        if ( !NT_SUCCESS( Status ) ) {
            return( FALSE );
        }
    }

    //
    // Retrieve the requested sid
    //
    if ( !LookupAccountNameW( NULL, 
                              pwszGroupName,
                              pGroupSid, 
                              &cbGroupSid,
                              pwszDomain, 
                              &cbDomain,
                              &peUse ) ) {

        //
        //  other eror
        //
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER  ) {
            NtClose(Token);
            return(FALSE);
        }

        //
        //  alloc group sid
        //
        pGroupSid = LocalAlloc(LPTR, cbGroupSid);
        if (pGroupSid == NULL) {
            NtClose(Token);
            return(FALSE);
        }
    
        //
        //  alloc domain name
        //
        cbDomain *= sizeof(WCHAR);
        pwszDomain = LocalAlloc(LPTR, cbDomain);
        if (pwszDomain == NULL) {
            LocalFree(pGroupSid);
            NtClose(Token);
            return(FALSE);
        }
    
        //
        // Retrieve the requested sid 
        //
        if ( !LookupAccountNameW( NULL, 
                                  pwszGroupName,
                                  pGroupSid, 
                                  &cbGroupSid,
                                  pwszDomain, 
                                  &cbDomain,
                                  &peUse ) ) {
            LocalFree(pGroupSid);
            LocalFree(pwszDomain);
            NtClose( Token );
            return( FALSE );
        }
    }
    else {
#if DBG
        DbgPrint("***ERROR*** this path should never get hit\n");
#endif
        NtClose( Token );
        return( FALSE );
    }

    ASSERT(pGroupSid != NULL);
    ASSERT(pwszDomain != NULL);

    //
    // Get a list of groups in the token
    //
    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenGroups,              // TokenInformationClass
                 NULL,                     // TokenInformation
                 0,                        // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );
    if ((Status != STATUS_SUCCESS) && (Status != STATUS_BUFFER_TOO_SMALL)) {
        LocalFree(pwszDomain);
        LocalFree(pGroupSid);
        NtClose(Token);
        return( FALSE );
    }

    TokenGroupList = LocalAlloc(LPTR, InfoLength);
    if (TokenGroupList == NULL) {
        LocalFree(pwszDomain);
        LocalFree(pGroupSid);
        NtClose(Token);
        return(FALSE);
    }

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenGroups,              // TokenInformationClass
                 TokenGroupList,           // TokenInformation
                 InfoLength,               // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );
    if (!NT_SUCCESS(Status)) {
        LocalFree(TokenGroupList);
        LocalFree(pwszDomain);
        LocalFree(pGroupSid);
        NtClose(Token);
        return(FALSE);
    }

    //
    // Search group list for membership
    //
    GroupMember = FALSE;
    for (GroupIndex=0; GroupIndex < TokenGroupList->GroupCount; GroupIndex++ ) {
        if (RtlEqualSid(TokenGroupList->Groups[GroupIndex].Sid, pGroupSid)) {
            GroupMember = TRUE;
            break;
        }
    }

    //
    // Tidy up
    //
    LocalFree(TokenGroupList);
    LocalFree(pwszDomain);
    LocalFree(pGroupSid);
    NtClose(Token);

    return(GroupMember);
}
*/

/***************************************************************************\
* FUNCTION: CtxImpersonateUser
*
* PURPOSE:  Impersonates the user by setting the users token
*           on the specified thread. If no thread is specified the token
*           is set on the current thread.
*
* RETURNS:  Handle to be used on call to StopImpersonating() or NULL on failure
*           If a non-null thread handle was passed in, the handle returned will
*           be the one passed in. (See note)
*
* NOTES:    Take care when passing in a thread handle and then calling
*           StopImpersonating() with the handle returned by this routine.
*           StopImpersonating() will close any thread handle passed to it -
*           even yours !
*
* HISTORY:
*
*   04-21-92 Davidc       Created.
*   12-18-96 cjc     copied from \windows\gina\msgina\wlsec.c
*
\***************************************************************************/


HANDLE
CtxImpersonateUser(
    PCTX_USER_DATA UserData,
    HANDLE      ThreadHandle
    )
{
    NTSTATUS Status, IgnoreStatus;
    HANDLE  UserToken = UserData->UserToken;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ImpersonationToken;
    BOOL ThreadHandleOpened = FALSE;

    if (ThreadHandle == NULL) {

        //
        // Get a handle to the current thread.
        // Once we have this handle, we can set the user's impersonation
        // token into the thread and remove it later even though we ARE
        // the user for the removal operation. This is because the handle
        // contains the access rights - the access is not re-evaluated
        // at token removal time.
        //

        Status = NtDuplicateObject( NtCurrentProcess(),     // Source process
                                    NtCurrentThread(),      // Source handle
                                    NtCurrentProcess(),     // Target process
                                    &ThreadHandle,          // Target handle
                                    THREAD_SET_THREAD_TOKEN,// Access
                                    0L,                     // Attributes
                                    DUPLICATE_SAME_ATTRIBUTES
                                  );
        if (!NT_SUCCESS(Status)) {
            return(NULL);
        }

        ThreadHandleOpened = TRUE;
    }


    //
    // If the usertoken is NULL, there's nothing to do
    //

    if (UserToken != NULL) {

        //
        // UserToken is a primary token - create an impersonation token version
        // of it so we can set it on our thread
        //

        InitializeObjectAttributes(
                            &ObjectAttributes,
                            NULL,
                            0L,
                            NULL,
                            UserData->NewThreadTokenSD);

        SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly = FALSE;

        ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


        Status = NtDuplicateToken( UserToken,
                                   TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES |
                                        TOKEN_QUERY,
                                   &ObjectAttributes,
                                   FALSE,
                                   TokenImpersonation,
                                   &ImpersonationToken
                                 );
        if (!NT_SUCCESS(Status)) {

            if (ThreadHandleOpened) {
                IgnoreStatus = NtClose(ThreadHandle);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            return(NULL);
        }



        //
        // Set the impersonation token on this thread so we 'are' the user
        //

        Status = NtSetInformationThread( ThreadHandle,
                                         ThreadImpersonationToken,
                                         (PVOID)&ImpersonationToken,
                                         sizeof(ImpersonationToken)
                                       );
        //
        // We're finished with our handle to the impersonation token
        //

        IgnoreStatus = NtClose(ImpersonationToken);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Check we set the token on our thread ok
        //

        if (!NT_SUCCESS(Status)) {

            if (ThreadHandleOpened) {
                IgnoreStatus = NtClose(ThreadHandle);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            return(NULL);
        }
    }


    return(ThreadHandle);

}


/***************************************************************************\
* FUNCTION: CtxStopImpersonating
*
* PURPOSE:  Stops impersonating the client by removing the token on the
*           current thread.
*
* PARAMETERS: ThreadHandle - handle returned by ImpersonateUser() call.
*
* RETURNS:  TRUE on success, FALSE on failure
*
* NOTES: If a thread handle was passed in to ImpersonateUser() then the
*        handle returned was one and the same. If this is passed to
*        StopImpersonating() the handle will be closed. Take care !
*
* HISTORY:
*
*   04-21-92 Davidc       Created.
*   12-18-96 cjc     copied from \windows\gina\msgina\wlsec.c
*
\***************************************************************************/

BOOL
CtxStopImpersonating(
    HANDLE  ThreadHandle
    )
{
    NTSTATUS Status, IgnoreStatus;
    HANDLE ImpersonationToken;


    if (ThreadHandle == NULL) {
       return FALSE;
    }
    //
    // Remove the user's token from our thread so we are 'ourself' again
    //

    ImpersonationToken = NULL;

    Status = NtSetInformationThread( ThreadHandle,
                                     ThreadImpersonationToken,
                                     (PVOID)&ImpersonationToken,
                                     sizeof(ImpersonationToken)
                                   );
    //
    // We're finished with the thread handle
    //

    IgnoreStatus = NtClose(ThreadHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    return(NT_SUCCESS(Status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\security.h ===
/*
 * List of accounts we allow file access for
 */
#define MAX_ACCOUNT_NAME 32
#define CURRENT_USER L"%user%"

// These are the accounts we want to have access to the directory
#define ADMIN_ACCOUNT  0
#define SYSTEM_ACCOUNT 1
#define USER_ACCOUNT   2

typedef struct _ADMIN_ACCOUNTS {
    WCHAR Name[MAX_ACCOUNT_NAME];
    PSID  pSid;
} ADMIN_ACCOUNTS, *PADMIN_ACCOUNTS;

/*
 * Operation result codes to allow a separate reporting module
 */
typedef enum _FILE_RESULT {
    FileOk,                   // File can not be written by users
    FileAccessError,          // Error occured, disposition unknown
    FileAccessErrorUserFormat // Error, user formatted message
} FILE_RESULT;

BOOL
InitSecurity(
    );

BOOL
IsAllowSid(
    PSID pSid
    );

BOOL
xxxLookupAccountName(
    PWCHAR pSystemName,
    PWCHAR pAccountName,
    PSID   *ppSid
    );

BOOLEAN
SetFileTree(
    PWCHAR   pRoot,
    PWCHAR   pAvoidDir
    );

BOOL
ReportFileResult(
    FILE_RESULT Code,
    ACCESS_MASK Access,
    PWCHAR      pFile,
    PWCHAR      pAccountName,
    PWCHAR      pDomainName,
    PCHAR       UserFormat,
    ...
    );

PACL
GetSecureAcl();

PSID
GetLocalAdminSid();

PSID
GetAdminSid();

PSID
GetLocalAdminGroupSid();

BOOL
CheckUserSid();

#if DBG
void
DumpSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSD
    );

void
DumpAcl(
    PACL   pAcl,
    PCHAR  pBase,
    PULONG pSize
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\allusrsm.c ===
/*************************************************************************
*
* allusrsm.c
*
* Move items from a user's start menu to the All Users start menu
*
* copyright notice: Copyright 1998 Micrsoft
*
*  When entering install mode, if the start menu snapshot file already
*  exists, don't overwrite it.  Otherwise, some shortcuts may not get moved
*  over.  This fixes a problem where an App reboots the machine when it
*  finishes installing, without giving the user a chance to switch back to
*  execute mode.  Now, when the user logs in again, the menu shortcuts will
*  be moved because winlogon always does a "change user /install" and then
*  "change user /execute".  (That's to support RunOnce programs.)
*  MS 1057
*
*
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <userenv.h>
#include <shlobj.h>

// This program takes a snapshot of the Current User's start menu and
// saves it to a file.  When run with the /c option, it compares the
// snapshot to the present contents of the Current User's start menu.
// Each new or changed file/directory is then moved to the All Users
// start menu.  Additionally, Read permission is granted to the Everyone
// group for each moved file or directory.



typedef struct File_Struct {
   struct File_Struct *Next;        // Only used in Memory
   WCHAR       FileName[MAX_PATH];
   BOOL        TimeValid;
   SYSTEMTIME  Time;
   } FILENODE, *PFILENODE;


typedef struct Path_Struct {
   DWORD      FilesInDir;
   struct Path_Struct *Next;  // Only used in Memory
   PFILENODE  FileHead;       // Only used in Memory
   PFILENODE  FileTail;       // Only used in Memory
   WCHAR      PathStr[MAX_PATH];
   } PATHNODE, *PPATHNODE;


typedef struct Tree_Struct {
   DWORD     NumPaths;
   PPATHNODE PathHead;
   PPATHNODE PathTail;
   } TREENODE, *PTREENODE;


typedef struct RemoveDir_Struct {
        WCHAR PathStr[MAX_PATH];
        struct RemoveDir_Struct *Next;
} REMOVEDIRLIST, *PPREMOVEDIRLIST;




int RunMode;
WCHAR SaveName[MAX_PATH];
WCHAR CurUserDir[MAX_PATH];
WCHAR AllUserDir[MAX_PATH];
int CurUserDirLen;
WCHAR StartMenu[MAX_PATH]=L"";


void ReadTree(PTREENODE Tree, WCHAR *Dir);

#define SD_SIZE (65536 + SECURITY_DESCRIPTOR_MIN_LENGTH)

////////////////////////////////////////////////////////////////////////////

 BOOLEAN FileExists( WCHAR *path )
{
    return( GetFileAttributes(path) == -1 ? FALSE : TRUE );
}

////////////////////////////////////////////////////////////////////////////

 NTSTATUS CreateNewSecurityDescriptor( PSECURITY_DESCRIPTOR *ppNewSD,
                                             PSECURITY_DESCRIPTOR pSD,
                                             PACL pAcl )
/*++
Routine Description:
   From a SD and a Dacl, create a new SD. The new SD will be fully self
   contained (it is self relative) and does not have pointers to other
   structures.

Arguments:
     ppNewSD - used to return the new SD. Caller should free with LocalFree
     pSD     - the self relative SD we use to build the new SD
     pAcl    - the new DACL that will be used for the new SD

Return Value:
     NTSTATUS code
--*/
{
    PACL pSacl;
    PSID psidGroup, psidOwner;
    BOOLEAN fSaclPres;
    BOOLEAN fSaclDef, fGroupDef, fOwnerDef;
    ULONG NewSDSize;
    SECURITY_DESCRIPTOR NewSD;
    PSECURITY_DESCRIPTOR pNewSD;
    NTSTATUS Status;

    // extract the originals from the security descriptor
    Status = RtlGetSaclSecurityDescriptor(pSD, &fSaclPres, &pSacl, &fSaclDef);
    if (!NT_SUCCESS(Status))
       return(Status);

    Status = RtlGetOwnerSecurityDescriptor(pSD, &psidOwner, &fOwnerDef);
    if (!NT_SUCCESS(Status))
       return(Status);

    Status = RtlGetGroupSecurityDescriptor(pSD, &psidGroup, &fGroupDef);
    if (!NT_SUCCESS(Status))
       return(Status);

    // now create a new SD and set the info in it. we cannot return this one
    // since it has pointers to old SD.
    Status = RtlCreateSecurityDescriptor(&NewSD, SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(Status))
       return(Status);


    Status = RtlSetDaclSecurityDescriptor(&NewSD, TRUE, pAcl, FALSE);
    if (!NT_SUCCESS(Status))
       return(Status);

    Status = RtlSetSaclSecurityDescriptor(&NewSD, fSaclPres, pSacl, fSaclDef);
    if (!NT_SUCCESS(Status))
       return(Status);

    Status = RtlSetOwnerSecurityDescriptor(&NewSD, psidOwner, fOwnerDef);
    if (!NT_SUCCESS(Status))
       return(Status);

    Status = RtlSetGroupSecurityDescriptor(&NewSD, psidGroup, fGroupDef);
    if (!NT_SUCCESS(Status))
       return(Status);

    // calculate size needed for the returned SD and allocated it
    NewSDSize = RtlLengthSecurityDescriptor(&NewSD);
    pNewSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LMEM_FIXED, NewSDSize);
    if (pNewSD == NULL)
       return(STATUS_INSUFFICIENT_RESOURCES);


    // convert the absolute to self relative
    Status = RtlAbsoluteToSelfRelativeSD(&NewSD, pNewSD, &NewSDSize);
    if (NT_SUCCESS(Status))
        *ppNewSD = pNewSD;
    else
        LocalFree(pNewSD);

    return(Status);
} // CreateNewSecurityDescriptor

/////////////////////////////////////////////////////////////////////////

//  Add Read and Execute permissions for built in "Everyone" Group to
//  the indicated file.

 BOOLEAN APIENTRY AddEveryoneRXPermissionW( LPCWSTR lpFileName)
{
   NTSTATUS Status;
   BOOLEAN ExitVal = FALSE;

   HANDLE FileHandle=NULL;
   OBJECT_ATTRIBUTES Obja;
   UNICODE_STRING FileName;
   RTL_RELATIVE_NAME RelativeName;
   BOOLEAN TranslationStatus;
   IO_STATUS_BLOCK IoStatusBlock;
   PVOID FreeBuffer;

   PSECURITY_DESCRIPTOR pSD = NULL;
   PSECURITY_DESCRIPTOR pNewSD = NULL;
   DWORD LengthNeeded = 0;

   static PACCESS_ALLOWED_ACE pNewAce = NULL;
   static USHORT NewAceSize;

   ACL  Acl;
   PACL pAcl, pNewAcl = NULL;
   BOOLEAN fDaclPresent, fDaclDef;
   USHORT NewAclSize;

   ////////////////////////////////////////////////////////////////////////
   //  First time through this routine, create an ACE for the built-in
   //  "Everyone" group.
   ////////////////////////////////////////////////////////////////////////

   if (pNewAce == NULL)
      {
      PSID  psidEveryone = NULL;
      SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;

      // Get the SID of the built-in Everyone group
      Status = RtlAllocateAndInitializeSid( &WorldSidAuthority, 1,
                       SECURITY_WORLD_RID, 0,0,0,0,0,0,0, &psidEveryone);
      if (!NT_SUCCESS(Status))
         goto ErrorExit;

      // allocate and initialize new ACE
      NewAceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
                   RtlLengthSid(psidEveryone));

      pNewAce = (PACCESS_ALLOWED_ACE) LocalAlloc(LMEM_FIXED, NewAceSize);
      if (pNewAce == NULL)
         goto ErrorExit;

      pNewAce->Header.AceFlags = (UCHAR) CONTAINER_INHERIT_ACE |
                                         OBJECT_INHERIT_ACE ;
      pNewAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
      pNewAce->Header.AceSize = NewAceSize;
      pNewAce->Mask = FILE_GENERIC_READ | FILE_EXECUTE;
      RtlCopySid(RtlLengthSid(psidEveryone), (PSID)(&pNewAce->SidStart),
                 psidEveryone);
      }

   ////////////////////////////////////////////////////////////////////////
   //  Open the indicated file.
   ////////////////////////////////////////////////////////////////////////

   TranslationStatus = RtlDosPathNameToNtPathName_U( lpFileName,
                                         &FileName, NULL, &RelativeName );
   if ( !TranslationStatus )
      goto ErrorExit;

   FreeBuffer = FileName.Buffer;

   if ( RelativeName.RelativeName.Length )
      FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
   else
      RelativeName.ContainingDirectory = NULL;

   InitializeObjectAttributes( &Obja, &FileName, OBJ_CASE_INSENSITIVE,
                             RelativeName.ContainingDirectory, NULL );

   Status = NtOpenFile( &FileHandle, READ_CONTROL | WRITE_DAC, &Obja, &IoStatusBlock,
                  FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 0 );

   RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

   if (!NT_SUCCESS(Status))
      goto ErrorExit;

   ////////////////////////////////////////////////////////////////////////
   //  Retrieve the security descriptor for the file and then get the
   //  file's DACL from it.
   ////////////////////////////////////////////////////////////////////////

   pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LMEM_FIXED, SD_SIZE);
   if (pSD == NULL)
      goto ErrorExit;

   Status = NtQuerySecurityObject( FileHandle, DACL_SECURITY_INFORMATION,
                                   pSD, SD_SIZE, &LengthNeeded );
   if (!NT_SUCCESS(Status))
      goto ErrorExit;

   // extract the originals from the security descriptor
   Status = RtlGetDaclSecurityDescriptor(pSD, &fDaclPresent, &pAcl, &fDaclDef);
   if (!NT_SUCCESS(Status))
      goto ErrorExit;

   ////////////////////////////////////////////////////////////////////////
   //  Create a new DACL by copying the existing DACL and appending the
   //  "Everyone" ACE.
   ////////////////////////////////////////////////////////////////////////

   // if no DACL present, we create one
   if ((fDaclPresent == FALSE) || (pAcl == NULL))
      {
      Status = RtlCreateAcl(&Acl, sizeof(Acl), ACL_REVISION) ;
      if (!NT_SUCCESS(Status))
         goto ErrorExit;

      pAcl = &Acl;
      }

   // Copy the DACL into a larger buffer and add the new ACE to the end.
   NewAclSize = pAcl->AclSize + NewAceSize;
   pNewAcl = (PACL) LocalAlloc(LMEM_FIXED, NewAclSize);
   if (!pNewAcl)
      goto ErrorExit;

   RtlCopyMemory(pNewAcl, pAcl, pAcl->AclSize);
   pNewAcl->AclSize = NewAclSize;

   Status = RtlAddAce(pNewAcl, ACL_REVISION, pNewAcl->AceCount,
                        pNewAce, NewAceSize);
   if (!NT_SUCCESS(Status))
      goto ErrorExit;

   ////////////////////////////////////////////////////////////////////////
   //  Create self-relative security descriptor with new DACL.  Then
   //  save the security descriptor back to the file.
   ////////////////////////////////////////////////////////////////////////

   Status = CreateNewSecurityDescriptor(&pNewSD, pSD, pNewAcl);
   if (!NT_SUCCESS(Status))
      goto ErrorExit;

   Status = NtSetSecurityObject(FileHandle, DACL_SECURITY_INFORMATION, pNewSD);
   if (!NT_SUCCESS(Status))
      goto ErrorExit;

   ExitVal = TRUE;

ErrorExit:

   if (FileHandle != NULL)
      NtClose(FileHandle);

   if (pNewAcl != NULL)
      LocalFree(pNewAcl);

   if (pNewSD != NULL)
      LocalFree(pNewSD);

   if (pSD != NULL)
      LocalFree(pSD);

   return(ExitVal);
}

////////////////////////////////////////////////////////////////////////////

#if 0
 BOOLEAN APIENTRY AddEveryoneRXPermissionA( WCHAR * lpFileName)
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpFileName);
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) )
       {
        ULONG dwErrorCode;

        dwErrorCode = RtlNtStatusToDosError( Status );
        SetLastError( dwErrorCode );
        return FALSE;
       }

    return ( AddEveryoneRXPermissionW((LPCWSTR)Unicode->Buffer) );
}
#endif

////////////////////////////////////////////////////////////////////////////

// return -1 for dates invalid, 0 for equal, 1 for f1 newer, 2 for f2 newer

 int CheckDates(PFILENODE FN1, PFILENODE FN2)
{
   SYSTEMTIME f1s = FN1->Time;
   SYSTEMTIME f2s = FN2->Time;

   if (FN1->TimeValid == FALSE || FN2->TimeValid == FALSE)
      return -1;

   if (f1s.wYear > f2s.wYear)     return 1;
   if (f1s.wYear < f2s.wYear)     return 2;

   if (f1s.wMonth > f2s.wMonth)   return 1;
   if (f1s.wMonth < f2s.wMonth)   return 2;

   if (f1s.wDay > f2s.wDay)       return 1;
   if (f1s.wDay < f2s.wDay)       return 2;

   if (f1s.wHour > f2s.wHour)     return 1;
   if (f1s.wHour < f2s.wHour)     return 2;

   if (f1s.wMinute > f2s.wMinute) return 1;
   if (f1s.wMinute < f2s.wMinute) return 2;

   if (f1s.wSecond > f2s.wSecond) return 1;
   if (f1s.wSecond < f2s.wSecond) return 2;

   return 0;
}

////////////////////////////////////////////////////////////////////////////

 PPATHNODE GetPathNode(PTREENODE Tree, WCHAR *Dir)
{
   PPATHNODE p;

   // Handle Empty List
   if (Tree->PathTail == NULL)
      {
      p = (PPATHNODE) LocalAlloc(0,sizeof(PATHNODE));
      if (p == NULL)
         return NULL;
      Tree->PathHead = p;
      Tree->PathTail = p;
      Tree->NumPaths++;
      p->Next = NULL;
      p->FileHead = NULL;
      p->FileTail = NULL;
      p->FilesInDir = 0;
      wcscpy(p->PathStr,Dir);
      return p;
      }

   // Last Node Matches
   if (wcscmp(Tree->PathTail->PathStr,Dir) == 0)
      return Tree->PathTail;

   // Need to add a node
   p = (PPATHNODE) LocalAlloc(0,sizeof(PATHNODE));
   if (p == NULL)
      return NULL;
   Tree->PathTail->Next = p;
   Tree->PathTail = p;
   Tree->NumPaths++;
   p->Next = NULL;
   p->FileHead = NULL;
   p->FileTail = NULL;
   p->FilesInDir = 0;
   wcscpy(p->PathStr,Dir);
   return p;
}

////////////////////////////////////////////////////////////////////////////

 void AddFileNode(PTREENODE Tree, WCHAR *Dir, PFILENODE FileNode)
{
   PPATHNODE PathNode = GetPathNode(Tree, Dir);

   if (FileNode == NULL)
      return;

   if (PathNode == NULL)
      {
      LocalFree(FileNode);
      return;
      }

   // New node is always the last.
   FileNode->Next = NULL;

   // If list isn't empty, link to last node in list
   // Otherwise, set head pointer.
   if (PathNode->FileTail != NULL)
      PathNode->FileTail->Next = FileNode;
   else
      PathNode->FileHead = FileNode;

   // Put new node on end of list.
   PathNode->FileTail = FileNode;
   PathNode->FilesInDir++;
}

////////////////////////////////////////////////////////////////////////////

 void ProcessFile(PTREENODE Tree, LPWIN32_FIND_DATA LocalData, WCHAR *LocalDir)
{
    PFILENODE FileNode;

    // Don't handle directories
    if ((LocalData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
       return;

    // Allocate a file node
    FileNode = (PFILENODE) LocalAlloc(0,sizeof(FILENODE));
    if (FileNode == NULL)
       return;

    // Fill in the Local Fields
    wcscpy(FileNode->FileName, LocalData->cFileName);
    FileNode->TimeValid = FileTimeToSystemTime(&LocalData->ftLastWriteTime,
                                                  &FileNode->Time);

    // Add to the list
    AddFileNode(Tree, LocalDir, FileNode);
}

////////////////////////////////////////////////////////////////////////////

 void ProcessDir(PTREENODE Tree, LPWIN32_FIND_DATA FindData, WCHAR *Dir)
{
   WCHAR NewDir[MAX_PATH];
   PPATHNODE PathNode;

   // Only Handle Directories
   if ((FindData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
      return;

   // Don't recurse into these directories
   if (wcscmp(FindData->cFileName, L".") == 0)
      return;
   if (wcscmp(FindData->cFileName, L"..") == 0)
      return;

   wcscpy(NewDir,Dir);
   wcscat(NewDir,L"\\");
   wcscat(NewDir,FindData->cFileName);

   // This creates a node for the directory.  Nodes get automatically
   // created when adding files, but that doesn't handle empty
   // directories.  This does.
   PathNode = GetPathNode(Tree, NewDir);

   ReadTree(Tree, NewDir);
}

////////////////////////////////////////////////////////////////////////////

//  Creates an in-memory representation of the Current User's start menu.

 void ReadTree(PTREENODE Tree, WCHAR *Dir)
{
   HANDLE FindHandle;
   WIN32_FIND_DATA FindData;
   int retval;

   // First compare all files in current directory.
   retval = SetCurrentDirectory(Dir);
   if (retval == 0)
      {
      // printf("Unable to find directory %s\n",Dir);
      return;
      }

   FindHandle = FindFirstFile(L"*.*", &FindData);
   if (FindHandle != INVALID_HANDLE_VALUE)
      {
      ProcessFile(Tree, &FindData, Dir);

      while (FindNextFile(FindHandle, &FindData) != FALSE)
         ProcessFile(Tree, &FindData, Dir);

      FindClose(FindHandle);
      }


   // Next, handle subdirectories.
   retval = SetCurrentDirectory(Dir);
   if (retval == 0)
      {
      // printf("Unable to find directory %s\n",Dir);
      return;
      }

   FindHandle = FindFirstFile(L"*.*", &FindData);
   if (FindHandle != INVALID_HANDLE_VALUE)
      {
      ProcessDir(Tree, &FindData, Dir);

      while (FindNextFile(FindHandle, &FindData) != FALSE)
         ProcessDir(Tree, &FindData, Dir);

      FindClose(FindHandle);
      }
}

////////////////////////////////////////////////////////////////////////////

 int WriteTreeToDisk(PTREENODE Tree)
{
   PPATHNODE PN;
   PFILENODE FN;
   HANDLE hFile;
   DWORD BytesWritten;
   DWORD i;

   hFile = CreateFile(SaveName, GENERIC_WRITE, 0, NULL,
                      CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
   if (hFile == INVALID_HANDLE_VALUE)
      return(-1);  // error

   // DbgPrint("Tree->NumPaths is %d\n",Tree->NumPaths);
   if (WriteFile(hFile,&Tree->NumPaths,sizeof(DWORD),&BytesWritten, NULL) == 0)
      {
      CloseHandle(hFile);
      return(-1); // error
      }

   for (PN = Tree->PathHead; PN != NULL; PN = PN->Next)
      {
      if (WriteFile(hFile,PN,sizeof(PATHNODE),&BytesWritten, NULL) == 0)
         {
         CloseHandle(hFile);
         return(-1); // error
         }

      // DbgPrint("\n%s (%d)\n",PN->PathStr, PN->FilesInDir);
      FN = PN->FileHead;
      for (i = 0; i < PN->FilesInDir; i++)
          {
          if (WriteFile(hFile,FN,sizeof(FILENODE),&BytesWritten, NULL) == 0)
             {
             CloseHandle(hFile);
             return(-1); // error
             }

          // DbgPrint("      %s \n", FN->FileName);
          FN = FN->Next;
          }
      }

   CloseHandle(hFile);
   return(0);
}

////////////////////////////////////////////////////////////////////////////

 int ReadTreeFromDisk(PTREENODE Tree)
{
   PATHNODE  LocalPath;
   PPATHNODE PN;
   PFILENODE FN;
   HANDLE hFile;
   DWORD BytesRead;
   DWORD i,j;
   DWORD NumFiles, NumTrees;

   hFile = CreateFile(SaveName, GENERIC_READ, 0, NULL,
                      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
   if (hFile == INVALID_HANDLE_VALUE)
      return(-1);

   if (ReadFile(hFile,&NumTrees,sizeof(DWORD),&BytesRead, NULL) == 0)
      {
      CloseHandle(hFile);
      return(-1); // error
      }

   for (i = 0; i < NumTrees; i++)
      {
      if (ReadFile(hFile,&LocalPath,sizeof(PATHNODE),&BytesRead, NULL) == 0)
         {
         CloseHandle(hFile);
         return(-1); // error
         }

      PN = GetPathNode(Tree, LocalPath.PathStr);
      if (PN == NULL)
         {
         CloseHandle(hFile);
         return(-1); // error
         }

      NumFiles = LocalPath.FilesInDir;
      // DbgPrint("\n<<%s (%d)\n",PN->PathStr, NumFiles);

      for (j = 0; j < NumFiles; j++)
          {
          // Allocate a file node
          FN = (PFILENODE) LocalAlloc(0,sizeof(FILENODE));
          if (FN == NULL)
             {
             CloseHandle(hFile);
             return(-1); // error
             }

          if (ReadFile(hFile,FN,sizeof(FILENODE),&BytesRead, NULL) == 0)
             {
             CloseHandle(hFile);
             LocalFree(FN);
             return(-1); // error
             }

          AddFileNode(Tree, PN->PathStr, FN);
          // DbgPrint("      %d: %s >>\n", j, FN->FileName);
          }
      }

   CloseHandle(hFile);
   return(0);
}

////////////////////////////////////////////////////////////////////////////

//  Finds a path in a menu tree.  If not found, NULL is returned.

 PPATHNODE FindPath(PTREENODE Tree, PPATHNODE PN)
{
   PPATHNODE FoundPN;

   for (FoundPN = Tree->PathHead; FoundPN != NULL; FoundPN = FoundPN->Next)
      {
      if (_wcsicmp(FoundPN->PathStr,PN->PathStr) == 0)
         return FoundPN;
      }

   return NULL;
}

////////////////////////////////////////////////////////////////////////////

//  Finds a file in a directory node.  If not found, NULL is returned.

 PFILENODE FindFile(PPATHNODE PN, PFILENODE FN)
{
   PFILENODE FoundFN;

   for (FoundFN = PN->FileHead; FoundFN != NULL; FoundFN = FoundFN->Next)
      {
      if (_wcsicmp(FoundFN->FileName,FN->FileName) == 0)
         return FoundFN;
      }

   return NULL;
}



////////////////////////////////////////////////////////////////////////////
/* ============================================================== 
  Function Name         :       wcsrevchr
  Description           :       Reverse wcschr
                            Finds a character in a string starting from the end
  Arguments             :       
  Return Value          :       PWCHAR
============================================================== */
PWCHAR wcsrevchr( PWCHAR string, WCHAR ch )
{
   int cLen, iCount;

   cLen = wcslen(string);
   string += cLen;

   for (iCount = cLen; iCount && *string != ch ; iCount--, string--)
           ;

   if (*string == ch)
           return string;
   else
           return NULL;

}




////////////////////////////////////////////////////////////////////////////

// Create the indicated directory.  This function creates any parent
// directories that are needed too.
//
//  Return:  TRUE  = directory now exists
//           FALSE = directory couldn't be created

 BOOLEAN TsCreateDirectory( WCHAR *DirName )
{
   BOOL RetVal;
   WCHAR *LastSlash;

   //
   //  Try to create the specified directory.  If the create works or
   //  the directory already exists, return TRUE.  If the called failed
   //  because the path wasn't found, continue.  This occurs if the
   //  parent directory doesn't exist.
   //

   RetVal = CreateDirectory(DirName, NULL);
   if ((RetVal == TRUE) || (GetLastError() == ERROR_ALREADY_EXISTS))
      return(TRUE);

   if (GetLastError() != ERROR_PATH_NOT_FOUND)
      return(FALSE);

   //
   //  Remove the last component of the path and try creating the
   //  parent directory.  Upon return, add the last component back
   //  in and try to create the specified directory again.
   //

   

//  Desc : BUG 267014 - replaced
// LastSlash = wcschr(DirName, L'\\');
// Given a full pathname, previous always returns the drive letter.
// Next line returns path components
   LastSlash = wcsrevchr(DirName, L'\\');

   if (LastSlash == NULL)  // Can't reduce path any more
      return(FALSE);

   *LastSlash = L'\0';
   RetVal = TsCreateDirectory(DirName);
   *LastSlash = L'\\';

   if (RetVal == FALSE)  // Couldn't create parent directory
      return(FALSE);

   RetVal = CreateDirectory(DirName, NULL);
   if ((RetVal == TRUE) || (GetLastError() == ERROR_ALREADY_EXISTS))
      return(TRUE);

   return(FALSE);
}

////////////////////////////////////////////////////////////////////////////

//  Moves a file from the current start menu to the All Users start menu.
//  Creates any directories that may be needed in the All Users menu.

 void TsMoveFile(PPATHNODE PN, PFILENODE FN)
{
   WCHAR Src[MAX_PATH];
   WCHAR Dest[MAX_PATH];

   // Normalize Source Path
   wcscpy(Src,PN->PathStr);
   if (Src[wcslen(Src)-1] != L'\\')
      wcscat(Src,L"\\");

   // Create Destination Path.
   wcscpy(Dest,AllUserDir);
   wcscat(Dest,&Src[CurUserDirLen]);

   // If directory doesn't exist, make it.  The default permission is fine.
   if (TsCreateDirectory(Dest) != TRUE)
      return;

   wcscat(Src,FN->FileName);
   wcscat(Dest,FN->FileName);

   // Move Fails if the target already exists.  This could happen
   // if we're copying a file that has a newer timestamp.
   if ( GetFileAttributes(Dest) != -1 )
      DeleteFile(Dest);

   // DbgPrint("Moving File %s \n         to %s\n",Src,Dest);
   if (MoveFile(Src, Dest) == FALSE)
      return;

   AddEveryoneRXPermissionW(Dest);
}

////////////////////////////////////////////////////////////////////////////

//  Compare the current start menu with the original.  Copy any new or
//  changed files to the All Users menu.

 void ProcessChanges(PTREENODE OrigTree, PTREENODE NewTree)
{
   PPATHNODE NewPN, OrigPN;
   PFILENODE NewFN, OrigFN;
   BOOL fRet; 
   PPREMOVEDIRLIST pRemDirList = NULL, pTemp;

   for (NewPN = NewTree->PathHead; NewPN != NULL; NewPN = NewPN->Next)
      {

      // DbgPrint("PC: Dir is %s\n",NewPN->PathStr);
      // If directory not found in original tree, move it over
      OrigPN = FindPath(OrigTree, NewPN);
      if (OrigPN == NULL)
      {
             for (NewFN = NewPN->FileHead; NewFN != NULL; NewFN = NewFN->Next)
             {
                 // DbgPrint("    Move File is %s\n",NewFN->FileName);
                 TsMoveFile(NewPN,NewFN);
             }
            //  Desc : BUG 267014 - replaced        
            //         RemoveDirectory(NewPN->PathStr);
            //      We have a problem if NewPN doesn't contain file items but subfolders.
            //      In this case, we do not enter the above loop, as there is nothing to move
            //      But the folder can't be removed because it contains a tree that haven't been moved yet.
            //      To remove it, we store its name in a LIFO stack. Stack items are removed when the loop exits
    
            fRet = RemoveDirectory(NewPN->PathStr);

            if (!fRet && GetLastError() == ERROR_DIR_NOT_EMPTY) {
#if DBG
                     DbgPrint("Adding to List--%S\n", NewPN->PathStr);
#endif
                     if (pRemDirList) {
                            pTemp = (PPREMOVEDIRLIST)LocalAlloc(LMEM_FIXED,sizeof(REMOVEDIRLIST));
                            wcscpy(pTemp->PathStr, NewPN->PathStr);
                            pTemp->Next = pRemDirList;
                            pRemDirList = pTemp;
                     }
                     else {
                             pRemDirList = (PPREMOVEDIRLIST)LocalAlloc(LMEM_FIXED, sizeof(REMOVEDIRLIST));
                             wcscpy(pRemDirList->PathStr, NewPN->PathStr);
                             pRemDirList->Next = NULL;
                     }
            }
 
        continue;
      }

      // Directory was found, check the files
      for (NewFN = NewPN->FileHead; NewFN != NULL; NewFN = NewFN->Next)
          {
          // DbgPrint("    File is %s\n",NewFN->FileName);
          // File wasn't found, move it
          OrigFN = FindFile(OrigPN,NewFN);
          if (OrigFN == NULL)
             {
             TsMoveFile(NewPN,NewFN);
             continue;
             }

          // Check TimeStamp, if New Scan is more recent, move it.
          if (CheckDates(NewFN,OrigFN) == 1)
             {
             TsMoveFile(NewPN,NewFN);
             continue;
             }
          }
      }

//  Desc :  BUG 267014 - added
//                      Directories stack removal
   if (pRemDirList) {
           while (pRemDirList) {
                   pTemp = pRemDirList;
                   pRemDirList = pRemDirList->Next;
                   RemoveDirectory(pTemp->PathStr);
                   LocalFree(pTemp);
           }
   }


}

////////////////////////////////////////////////////////////////////////////

//  Frees the in-memory representation of a start menu

 void FreeTree(PTREENODE Tree)
{
   PPATHNODE PN,NextPN;
   PFILENODE FN,NextFN;

   for (PN = Tree->PathHead; PN != NULL; PN = NextPN)
       {
       for (FN = PN->FileHead; FN != NULL; FN = NextFN)
           {
           NextFN = FN->Next;
           LocalFree(FN);
           }

       NextPN = PN->Next;
       LocalFree(PN);
       }

    Tree->PathHead = NULL;
    Tree->PathTail = NULL;
    Tree->NumPaths = 0;
}

////////////////////////////////////////////////////////////////////////////

//  Updates the "All User" menu by moving new items from the Current User's
//  start menu.  In RunMode 0, a snapshot of the Current User's start menu
//  is taken.  After modifications to the Current User's start menu are done,
//  this function is called again with RunMode 1.  Then, it compares the
//  current state of the start menu with the saved snapshot.  Any new or
//  modified files are copied over to the corresponding location in the
//  "All User" start menu.
//
//  RunMode 0 is invoked when the system is changed into install mode and
//  mode 1 is called when the system returns to execute mode.

int TermsrvUpdateAllUserMenu(int RunMode)
{
   TREENODE OrigTree;
   TREENODE NewTree;
   WCHAR p[MAX_PATH];
   int retval;
   PMESSAGE_RESOURCE_ENTRY MessageEntry;
   PVOID DllHandle;
   NTSTATUS Status;
   DWORD dwlen;

   OrigTree.PathHead = NULL;
   OrigTree.PathTail = NULL;
   OrigTree.NumPaths = 0;
   NewTree.PathHead = NULL;
   NewTree.PathTail = NULL;
   NewTree.NumPaths = 0;

   retval = GetEnvironmentVariable(L"UserProfile", p, MAX_PATH);
   if (retval == 0)
      return(-1);

   if (!StartMenu[0]) {
      HINSTANCE hInst;
      typedef HRESULT (* LPFNSHGETFOLDERPATH)(HWND, int, HANDLE, DWORD, LPWSTR);
      LPFNSHGETFOLDERPATH  lpfnSHGetFolderPath;
      WCHAR ssPath[MAX_PATH];
      WCHAR *LastSlash;

      wcscpy( StartMenu, L"\\Start Menu");

      hInst = LoadLibrary(L"SHELL32.DLL");
      if (hInst) {
         lpfnSHGetFolderPath = (LPFNSHGETFOLDERPATH)GetProcAddress(hInst,"SHGetFolderPathW");
         if (lpfnSHGetFolderPath) {
            if (S_OK == lpfnSHGetFolderPath(NULL, CSIDL_STARTMENU, NULL, 0, ssPath)) {
               LastSlash = wcsrevchr(ssPath, L'\\');
               if (LastSlash) {
                  wcscpy(StartMenu, LastSlash);
               }
            }
         }
         FreeLibrary(hInst);
      }
   }
   wcscpy(SaveName,p);
   wcscat(SaveName,L"\\TsAllUsr.Dat");
   wcscpy(CurUserDir,p);
   wcscat(CurUserDir,StartMenu);
   CurUserDirLen = wcslen(CurUserDir);

   dwlen = sizeof(AllUserDir)/sizeof(WCHAR);
   if (GetAllUsersProfileDirectory(AllUserDir, &dwlen))
      {

      wcscat(AllUserDir,StartMenu);

#if DBG
       DbgPrint("SaveName is '%S'\n",SaveName);
       DbgPrint("CurUserDir is '%S'\n",CurUserDir);
       DbgPrint("AllUserDir is '%S'\n",AllUserDir);
#endif

      if (RunMode == 0)
         {
         // If the start menu snapshot already exists, don't overwrite it.
         // The user may enter "change user /install" twice, or an app may
         // force a reboot without changing back to execute mode.  The
         // existing file is older.  If we overwrite it, then some shortcuts
         // won't get moved.
         if (FileExists(SaveName) != TRUE)
            {
            ReadTree(&OrigTree, CurUserDir);
            if (WriteTreeToDisk(&OrigTree) == -1)
               DeleteFile(SaveName);
            FreeTree(&OrigTree);
            }
         }

      else if (RunMode == 1)
         {
         if (ReadTreeFromDisk(&OrigTree) == -1)
            {
            FreeTree(&OrigTree);
            DeleteFile(SaveName);  // Could be a bad file.  If it doesn't
                                   // exist, this won't hurt anything.
            return(-1);
            }

         ReadTree(&NewTree, CurUserDir);
         ProcessChanges(&OrigTree,&NewTree);
         DeleteFile(SaveName);
         FreeTree(&OrigTree);
         FreeTree(&NewTree);
         }
      }

   return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\inimap.c ===
/*************************************************************************
*
* inimap.c
*
* Handle Copy-On-Reference Ini File Mapping
*
* copyright notice: Copyright 1998 Micrsoft
*
*
*************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define LOCAL
#include "regmap.h"

//#include "basedll.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

#define IS_NEWLINE_CHAR( c )  ((c == 0x0D) || (c == 0x0A))

/*
 *  INI_BUF_SIZE defines the maximum number of characters that can
 *  be on a single INI file line.  If a line contains more than this
 *  number of characters, the additional characters will be lost.
 */
#define INI_BUF_SIZE 1024


/* Internal Functions */

BOOL
TermsrvDoesFileExist(
    PUNICODE_STRING pFileName
    );

BOOL
TermsrvBuildSysIniPath(
    PUNICODE_STRING pIniPath,
    PUNICODE_STRING pSysPath,
    PUNICODE_STRING pUserPath
    );

BOOL
TermsrvCopyIniFile(
    PUNICODE_STRING pSysPath,
    PUNICODE_STRING pUserPath,
    PUNICODE_STRING pFileName
    );

BOOL
TermsrvGetUnicodeRemainder(
    PUNICODE_STRING pFullPath,
    PUNICODE_STRING pPrefix,
    PUNICODE_STRING pRemainder
    );

NTSTATUS
TermsrvIniCopyLoop(
    HANDLE SrcHandle,
    HANDLE DestHandle
    );

NTSTATUS
TermsrvPutString(
    HANDLE DestHandle,
    PCHAR  pStr,
    ULONG  StringSize
    );

NTSTATUS
TermsrvProcessBuffer(
    PCHAR  *ppStr,
    PULONG pStrSize,
    PULONG pStrBufSize,
    PBOOL  pSawNL,
    PCHAR  pIOBuf,
    PULONG pIOBufIndex,
    PULONG pIOBufFillSize
    );

NTSTATUS
TermsrvGetString(
    HANDLE SrcHandle,
    PCHAR  *ppStringPtr,
    PULONG pStringSize,
    PCHAR  pIOBuf,
    ULONG  IOBufSize,
    PULONG pIOBufIndex,
    PULONG pIOBufFillSize
    );

NTSTATUS
TermsrvIniCopyAndChangeLoop(
    HANDLE SrcHandle,
    HANDLE DestHandle,
    PUNICODE_STRING pUserFullPath,
    PUNICODE_STRING pSysFullPath
    );

BOOL
TermsrvReallocateBuf(
    PCHAR  *ppStr,
    PULONG pStrBufSize,
    ULONG  NewSize
    );


PCHAR
Ctxstristr( PCHAR pstring1,
            PCHAR pstring2
          );


NTSTATUS
TermsrvCheckKeys(HANDLE hKeySysRoot,
             HANDLE hKeyUsrRoot,
             PKEY_BASIC_INFORMATION pKeySysInfo,
             PKEY_FULL_INFORMATION pKeyUsrInfo,
             ULONG ulcsys,
             ULONG ulcusr,
             DWORD  indentLevel);

NTSTATUS
TermsrvCloneKey(HANDLE hKeySys,
            HANDLE hKeyUsr,
            PKEY_FULL_INFORMATION pDefKeyInfo,
            BOOL fCreateSubKeys);

void TermsrvCheckNewRegEntries(IN LPCWSTR wszBaseKeyName);

BOOL
TermsrvGetUserSyncTime(PULONG pultime);

BOOL
TermsrvSetUserSyncTime(void);

NTSTATUS 
TermsrvCheckNewIniFilesInternal(IN LPCWSTR wszBaseKeyName);

NTSTATUS 
GetFullKeyPath(
        IN HANDLE hKeyParent,
        IN LPCWSTR wszKey,
        OUT LPWSTR *pwszKeyPath);

PWINSTATIONQUERYINFORMATIONW pWinStationQueryInformationW;

DWORD g_debugIniMap=FALSE;

DWORD IsDebugIniMapEnabled()
{
    HKEY    hKey;
    DWORD   rc;
    DWORD   res=0;
    DWORD   size;

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install",
                  0, KEY_READ, &hKey );

    size = sizeof(DWORD);

    if (rc == ERROR_SUCCESS )
    {
        rc = RegQueryValueEx( hKey, L"debug",  NULL , NULL , (LPBYTE ) &res, & size  ) ;

        if (rc != ERROR_SUCCESS )
        {
            res = FALSE;
        }
        RegCloseKey( hKey );
    }

    return res;
}

void    Indent( ULONG indent)
{
    ULONG   i;
    for ( i = 1; i <indent ; i++ )
    {
        DbgPrint("%ws", L"\t");
    }
}

// last param is a unicode string
void Debug1( DWORD indent, DWORD line, WCHAR *where, UNICODE_STRING *pS )
{
    WCHAR   s[1024];

    if (g_debugIniMap)
    {
        wcsncpy( s, pS->Buffer, pS->Length );
    
        s[pS->Length + 1 ] = L'\0';
    
        Indent( indent );
        DbgPrint("L: %4d, %10ws: %ws \n", line, where, s );
    }

}


// last param two params, one is the wchar str and the last one is the length. Boy I miss c++ and func overloading...
void Debug2( DWORD indent, DWORD line, WCHAR *where, WCHAR *pS , DWORD length)
{
    WCHAR   s[1024];

    if (g_debugIniMap)
    {
        wcsncpy( s, pS, length );
    
        s[length + 1 ] = L'\0';
    
        Indent( indent );
        DbgPrint("L: %4d, %10ws: %ws \n", line, where, s );
    }

}

void DebugTime( DWORD indent, DWORD line, WCHAR *comment, LARGE_INTEGER li )
{
    if (g_debugIniMap)
    {
        Indent( indent );
        DbgPrint("L: %4d, %5ws : %I64x \n",  line , comment , li.QuadPart );
    }
}

/*****************************************************************************
 *
 *  TermsrvGetUserSyncTime
 *
 *  This routine will get the last time we sync'd up this user's .ini files
 *  and registry values with the system versions.
 *
 * ENTRY:
 *   PULONG pultime: pointer to receive last sync time (in seconds since 1970)
 *
 * EXIT:
 *   SUCCESS:
 *      returns TRUE
 *   FAILURE:
 *      returns FALSE
 *
 ****************************************************************************/

BOOL TermsrvGetUserSyncTime(PULONG pultime)
{
    ULONG ullen, ultmp;
    NTSTATUS Status;
    HANDLE hKey, hKeyRoot;
    OBJECT_ATTRIBUTES ObjectAttr;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo;
    UNICODE_STRING UniString, UserSID;
    PWCHAR pwch;

    // Allocate a buffer for the key value name and time info
    ullen = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG);
    pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ullen);

    // If we didn't get the buffer, return
    if (!pKeyValInfo) {
        return(FALSE);
    }

    Status = RtlOpenCurrentUser(KEY_READ,
                                &hKeyRoot);

    if (NT_SUCCESS(Status)) {

        // Now open up the Citrix key for this user
        RtlInitUnicodeString(&UniString,
                             USER_SOFTWARE_TERMSRV);

        InitializeObjectAttributes(&ObjectAttr,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   hKeyRoot,
                                   NULL);

        Status = NtCreateKey(&hKey,
                             KEY_READ,
                             &ObjectAttr,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &ultmp);

        NtClose(hKeyRoot);
    }

    // If we opened the key, and it was already there, get the value
    if (NT_SUCCESS(Status) && (ultmp == REG_OPENED_EXISTING_KEY)) {
        RtlInitUnicodeString(&UniString, TERMSRV_USER_SYNCTIME);
        Status = NtQueryValueKey(hKey,
                                 &UniString,
                                 KeyValuePartialInformation,
                                 pKeyValInfo,
                                 ullen,
                                 &ultmp);

        NtClose(hKey);
        if (NT_SUCCESS(Status)) {
            *pultime = *(PULONG)pKeyValInfo->Data;
        }
    } else {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }

    RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
    return(NT_SUCCESS(Status));
}


/*****************************************************************************
 *
 *  TermsrvSetUserSyncTime
 *
 *  This routine will set the current time as this user's last .ini file
 *  sync time.
 *
 * ENTRY:
 *
 * EXIT:
 *   SUCCESS:
 *      returns TRUE
 *   FAILURE:
 *      returns FALSE
 *
 ****************************************************************************/

BOOL TermsrvSetUserSyncTime(void)
{
    ULONG ultmp;
    NTSTATUS Status;
    HANDLE hKey, hKeyRoot;
    OBJECT_ATTRIBUTES ObjectAttr;
    UNICODE_STRING UniString;
    PWCHAR pwch;
    FILETIME FileTime;

    Status = RtlOpenCurrentUser(KEY_WRITE,
                                &hKeyRoot);

    if (NT_SUCCESS(Status)) {

        // Now open up the Citrix key for this user
        RtlInitUnicodeString(&UniString,
                             USER_SOFTWARE_TERMSRV);

        InitializeObjectAttributes(&ObjectAttr,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   hKeyRoot,
                                   NULL);

        Status = NtCreateKey(&hKey,
                             KEY_WRITE,
                             &ObjectAttr,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &ultmp);
        NtClose(hKeyRoot);
    }

    // If we opened the key, and set the sync time value
    if (NT_SUCCESS(Status)) {
        // Get the system time, convert to local time, and convert to seconds
        GetSystemTimeAsFileTime(&FileTime);
        RtlTimeToSecondsSince1970((PLARGE_INTEGER)&FileTime,
                                  &ultmp);

        RtlInitUnicodeString(&UniString,
                             TERMSRV_USER_SYNCTIME);

        // Now store it under the citrix key in the registry
        Status = NtSetValueKey(hKey,
                               &UniString,
                               0,
                               REG_DWORD,
                               &ultmp,
                               sizeof(ultmp));

        NtClose(hKey);
    } else {
        Status = STATUS_OBJECT_NAME_NOT_FOUND;
    }

    return(NT_SUCCESS(Status));
}



/*****************************************************************************
 *
 *  TermsrvCORIniFile
 *
 *   Copy On Reference an Ini file
 *
 *   This function is called to copy an ini file from the system
 *   directory to a users local ini file directory.
 *
 *   The path supplied is the fully translated TERMSRV INI file path,
 *   whichs points to a users directory.
 *
 *   This string is used to find the system ini file, and copy it to the
 *   users directory.
 *
 *   All paths are NT paths, NOT WIN32 paths.
 *
 *   Example:
 *
 *   \DosDevices\U:\users\default\windows\win.ini is the path given
 *
 *   %SystemRoot%\win.ini is the "default" location with ini mapping off.
 *
 *   If \DosDevices\U:\users\default\windows\win.ini does not exist, test to see if
 *   %SystemRoot%\win.ini exists, and if does, copy the system version
 *   to the users directory.
 *
 *   NOTE: If the path is to the normal unmapped system directory, just
 *         return since there is no mapping occuring.
 *
 * ENTRY:
 *   pUserFullPath (input)
 *     Translated TERMSRV INI path name
 *
 * EXIT:
 *
 ****************************************************************************/

VOID
TermsrvCORIniFile(
    PUNICODE_STRING pUserFullPath
    )
{
    DWORD Result;
    BOOL  rc;
    UNICODE_STRING SysFullPath;
    UNICODE_STRING UserBasePath;

    /*
     * If in install mode, just return to make
     * everything behave as stock NT.
     */
    if ( IsSystemLUID() || TermsrvAppInstallMode() ) {
        TRACE0(("TermsrvCORIniFile: INI file mapping is OFF\n"));
        return;
    }

    if (!TermsrvPerUserWinDirMapping()) {
        return;
    }

    /*
     * If a NULL file name, just return
     */
    if( (pUserFullPath == NULL) || (pUserFullPath->Buffer == NULL) ) {
        TRACE0(("TermsrvCORIniFile: NULL File INI file name\n"));
        return;
    }

    /*
     * Test if user file exists
     */
    if( TermsrvDoesFileExist( pUserFullPath ) ) {

        TRACE0(("TermsrvCORIniFile: File %ws Exists\n",pUserFullPath->Buffer));
        //
        // Nothing to do if the user already has a copy
        //
        return;
    }
    else {
        TRACE0(("TermsrvCORIniFile: File %ws DOES NOT Exist!\n",pUserFullPath->Buffer));
    }

    /*
     * The requested ini file does not exist in the users local
     * directory. We must change the path name to point to the system
     * directory, and test if the ini file exists there.
     */

    /*
     * Build full system path to the Ini file.
     *
     * This also parses out the users base path and returns that as well.
     */
    if( !TermsrvBuildSysIniPath( pUserFullPath, &SysFullPath, &UserBasePath ) ) {

        TRACE0(("TermsrvCORIniFile: Error building Sys Ini Path!\n"));
        return;
    }

    /*
     * Test if system version exists
     */
    if( !TermsrvDoesFileExist( &SysFullPath ) ) {
        //
        // It does not exist in the system directory either,
        // so we just return.
        //
        TRACE0(("TermsrvCORIniFile: Path %ws does not exist in system dir, Length %d\n",SysFullPath.Buffer,SysFullPath.Length));
        TRACE0(("TermsrvCORIniFile: UserPath %ws\n",pUserFullPath->Buffer));
        RtlFreeHeap( RtlProcessHeap(), 0, SysFullPath.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, UserBasePath.Buffer );
        return;
    }

    /*
     * Now Copy it.
     *
     * The copy routine could also translate any paths internal to the
     * ini file that point to the system directory, to point to the user
     * directory in the base path.
     */
    rc = TermsrvCopyIniFile( &SysFullPath, &UserBasePath, pUserFullPath);

#if DBG
    if( !rc ) {
        DBGPRINT(("TermsrvCORIniFile: Could not copy file %ws to %ws\n",SysFullPath.Buffer,pUserFullPath->Buffer));
    }
#endif

    RtlFreeHeap( RtlProcessHeap(), 0, SysFullPath.Buffer );
    RtlFreeHeap( RtlProcessHeap(), 0, UserBasePath.Buffer );

    return;
}


/*****************************************************************************
 *
 *  TermsrvDoesFileExist
 *
 *   Returns whether the file exists or not.
 *
 *   Must use NT, not WIN32 pathnames.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
TermsrvDoesFileExist(
    PUNICODE_STRING pFileName
    )
{
    NTSTATUS Status;
    FILE_BASIC_INFORMATION BasicInfo;
    OBJECT_ATTRIBUTES Obja;

    InitializeObjectAttributes(
        &Obja,
        pFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    /*
     * Now query it
     */
    Status = NtQueryAttributesFile( &Obja, &BasicInfo );

    if( NT_SUCCESS( Status ) ) {
        return( TRUE );
    }

    return( FALSE );
}


/*****************************************************************************
 *
 *  TermsrvBuildSysIniPath
 *
 *   Builds the full ini path to pointing to the system directory
 *   from the users private ini path.
 *
 *   Also returns the users base ini path directory to be used by
 *   the ini file path conversion when copying.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
TermsrvBuildSysIniPath(
    PUNICODE_STRING pUserFullPath,
    PUNICODE_STRING pSysFullPath,
    PUNICODE_STRING pUserBasePath
    )
{
    BOOL     rc = FALSE;
    NTSTATUS Status;
    UNICODE_STRING SysBasePath;
    UNICODE_STRING IniPathTail;
    UNICODE_STRING UniSysDir;
    WCHAR CtxWindowsPath[MAX_PATH+1];
    UNICODE_STRING CtxWindowsDir = {
        sizeof(CtxWindowsPath),
        sizeof(CtxWindowsPath),
        CtxWindowsPath
    };
    OBJECT_ATTRIBUTES ObjectAttr;
    HKEY   hKey = 0;
    ULONG  ul;
    PKEY_VALUE_FULL_INFORMATION pKeyValInfo;
    WCHAR SystemWindowsDirectory[MAX_PATH+1];

    if (!TermsrvPerUserWinDirMapping()) {
        return FALSE;
    }

    SysBasePath.Buffer = NULL;

    pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH
                                 );
    if (pKeyValInfo) {
        RtlInitUnicodeString(&UniSysDir,
                             TERMSRV_COMPAT
                            );

        InitializeObjectAttributes(&ObjectAttr,
                                   &UniSysDir,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        Status = NtOpenKey(&hKey, KEY_READ, &ObjectAttr);

        if (NT_SUCCESS(Status)) {

            RtlInitUnicodeString(&UniSysDir, L"SYSDIR");
            Status = NtQueryValueKey(hKey,
                                     &UniSysDir,
                                     KeyValueFullInformation,
                                     pKeyValInfo,
                                     sizeof(KEY_VALUE_FULL_INFORMATION) +
                                         MAX_PATH,
                                     &ul
                                    );

            if (NT_SUCCESS(Status)) {
                NtClose(hKey);

                if (ul = wcslen((PWCHAR)((PCHAR)pKeyValInfo +
                                    pKeyValInfo->DataOffset))) {

                    RtlInitUnicodeString(&UniSysDir,
                                         (PWCHAR)((PCHAR)pKeyValInfo +
                                             pKeyValInfo->DataOffset)
                                        );

                    // Convert to an NT path
                    rc = RtlDosPathNameToNtPathName_U(
                             UniSysDir.Buffer,
                             &SysBasePath,
                             NULL,
                             NULL
                            );

                    // Was this a valid path?  If not, use actual system directory.
                    if (rc && !TermsrvDoesFileExist(&SysBasePath)) {
                        RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
                        SysBasePath.Buffer = NULL;
                        rc = FALSE;
                    }

                    // if the path is the root, get rid of last backslash
                    if (ul == 3 && SysBasePath.Buffer) {
                        SysBasePath.Buffer[SysBasePath.Length/sizeof(WCHAR)] = L'\0';
                        SysBasePath.Length -= 2;
                    }
                }
            }
        }
    }

    GetSystemWindowsDirectory(SystemWindowsDirectory,(MAX_PATH * sizeof(WCHAR)));

    if (!rc) {

        /*
         * We must convert the SystemWindowsDirectory from a WIN32 path to
         * an NT path.
         */
        rc = RtlDosPathNameToNtPathName_U( SystemWindowsDirectory,
                                           &SysBasePath,
                                           NULL,
                                           NULL
                                         );
    }

    if (pKeyValInfo) {
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
    }

    TRACE0(("BaseWindowsDirectory is %ws\n",SystemWindowsDirectory));

    if( !rc ) {
        DBGPRINT(("BuildSysIniPath: Error translating system path to NT path %ws\n",SystemWindowsDirectory));
        return( FALSE );
    }

    TRACE0(("BuildSysIniPath: NT SYS path is %ws\n",SysBasePath.Buffer));

    /*
     * Get the users windows path prefix
     */
    Status = GetPerUserWindowsDirectory( &CtxWindowsDir );
    if( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("BuildSysIniPath: Could not get TermsrvWindowsDir 0x%x\n",Status));
        RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
        return( FALSE );
    }

    /*
     * Now convert it into an NT path
     */
    rc = RtlDosPathNameToNtPathName_U(
             CtxWindowsDir.Buffer,
             pUserBasePath,
             NULL,
             NULL
             );

    if( !rc ) {
        DBGPRINT(("BuildSysIniPath: Could not convert TermsrvWindowsDir %d\n",rc));
        RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
        return( FALSE );
    }

    TRACE0(("BuildSysIniPath: Users Ini PathBase is %ws\n",pUserBasePath->Buffer));

    //
    // Here we have:
    //
    // SysBasePath, UserBasePath
    //
    // UserFullPath, must now build SysFullPath
    //

    rc = TermsrvGetUnicodeRemainder( pUserFullPath, pUserBasePath, &IniPathTail );

    if( !rc ) {
        WCHAR szShortPath[MAX_PATH];
        WCHAR szPath[MAX_PATH];
        UNICODE_STRING ShortPath;

        //
        // GetShortPathName doesn't take NT Path. Strip out "\??\"
        //
        if (!wcsncmp(pUserBasePath->Buffer,L"\\??\\",4)) {
            wcsncpy(szPath,&(pUserBasePath->Buffer[4]),(pUserBasePath->Length - 4));
        } else {
            wcsncpy(szPath,pUserBasePath->Buffer,pUserBasePath->Length);
        }
        if (GetShortPathNameW(szPath,szShortPath,MAX_PATH)) {

            if (!wcsncmp(pUserBasePath->Buffer,L"\\??\\",4)) {
                wcscpy(szPath,L"\\??\\");
                wcscat(szPath,szShortPath);
            } else {
                wcscpy(szPath,szShortPath);
            }

            RtlInitUnicodeString(&ShortPath,szPath);
            rc = TermsrvGetUnicodeRemainder( pUserFullPath, &ShortPath, &IniPathTail );
        }

        if (!rc) {
            RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
            RtlFreeHeap( RtlProcessHeap(), 0, pUserBasePath->Buffer );
            return( FALSE );
        }
    }

    pSysFullPath->Length = 0;
    pSysFullPath->MaximumLength = (MAX_PATH+1)*sizeof(WCHAR);
    pSysFullPath->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, pSysFullPath->MaximumLength );

    if( pSysFullPath->Buffer == NULL ) {
        DBGPRINT(("BuildSysPath: Error in memory allocate\n"));
        RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, IniPathTail.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, pUserBasePath->Buffer );
        return( FALSE );
    }

    TRACE0(("BuildSysPath: IniPathTail :%ws:, Length %d\n",IniPathTail.Buffer,IniPathTail.Length));
    RtlCopyUnicodeString( pSysFullPath, &SysBasePath );

     if ((pSysFullPath->Buffer[pSysFullPath->Length/sizeof(WCHAR) -1 ] != L'\\') &&
        (IniPathTail.Buffer[0] != L'\\')) {     // check whether need "\\"
        Status = RtlAppendUnicodeToString(pSysFullPath, L"\\");
        if ( !NT_SUCCESS( Status) ) {
            DBGPRINT(("BuildSysPath: Error appending UnicodeStirng\n",Status));
            return( FALSE );
        }
     }

    Status = RtlAppendUnicodeStringToString( pSysFullPath, &IniPathTail );

    if( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("BuildSysPath: Error 0x%x appending UnicodeString\n",Status));
        RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, IniPathTail.Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, pUserBasePath->Buffer );
        RtlFreeHeap( RtlProcessHeap(), 0, pSysFullPath->Buffer );
        return( FALSE );
    }

    TRACE0(("BuildSysPath: SysFullPath :%ws:, Length %d\n",pSysFullPath->Buffer,pSysFullPath->Length));

    /*
     * Free the local resources allocated
     */
    RtlFreeHeap( RtlProcessHeap(), 0, SysBasePath.Buffer );
    RtlFreeHeap( RtlProcessHeap(), 0, IniPathTail.Buffer );

    return( TRUE );
}


/*****************************************************************************
 *
 *  TermsrvGetUnicodeRemainder
 *
 *   Given the full path, and a prefix, return the remainder of
 *   the UNICODE_STRING in newly allocated buffer space.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   TRUE  - no error
 *   FALSE - error
 *
 ****************************************************************************/

BOOL
TermsrvGetUnicodeRemainder(
    PUNICODE_STRING pFullPath,
    PUNICODE_STRING pPrefix,
    PUNICODE_STRING pRemainder
    )
{
    WCHAR c1, c2;
    USHORT Index, RemIndex;
    USHORT PathLen, PrefixLen, RemLen;

    PathLen = pFullPath->Length / sizeof(WCHAR);
    PrefixLen = pPrefix->Length / sizeof(WCHAR);

    if( (PathLen == 0) || (PrefixLen == 0) ) {
        TRACE1(("TermsrvGetUnicodeRemainder: 0 PathLength Full %d, Prefix %d\n",PathLen,PrefixLen));
        return( FALSE );
    }

    Index = 0;
    while( PathLen && PrefixLen ) {

        c1 = pFullPath->Buffer[Index];
        c2 = pPrefix->Buffer[Index];

        // Do a fast case insensitive compare
        if( (c1 != c2) && (towupper(c1) != towupper(c2)) ) {
            TRACE1(("TermsrvGetUnicodeRemainder: Non matching character Index %d\n",Index));
            return( FALSE );
        }

        PathLen--;
        PrefixLen--;
        Index++;
    }

    // If prefix is longer, its an error
    if( PrefixLen ) {
        TRACE1(("TermsrvGetUnicodeRemainder: Prefix is longer\n"));
        return(FALSE);
    }

    // If PathLen is 0, there is no remainder.
    if( PathLen == 0 ) {
        RemLen = 0;
    }
    else {
        RemLen = PathLen;
    }

    // Allocate memory for remainder, including a UNICODE_NULL
    pRemainder->Length = RemLen*sizeof(WCHAR);
    pRemainder->MaximumLength = (RemLen+1)*sizeof(WCHAR);
    pRemainder->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, pRemainder->MaximumLength );
    if( pRemainder->Buffer == NULL ) {
        TRACE1(("TermsrvGetUnicodeRemainder: Memory allocation error\n"));
        return( FALSE );
    }

    RemIndex  = 0;
    while( RemLen ) {

        pRemainder->Buffer[RemIndex] = pFullPath->Buffer[Index];

        Index++;
        RemIndex++;
        RemLen--;
    }

    // Now include the UNICODE_NULL
    pRemainder->Buffer[RemIndex] = UNICODE_NULL;

    TRACE0(("TermsrvGetUnicodeRemainder: Remainder %ws\n",pRemainder->Buffer));

    return( TRUE );
}


/*****************************************************************************
 *
 *  TermsrvCopyIniFile
 *
 *   Copies the INI file from the system directory to the
 *   users directory.
 *
 *   Any paths inside the INI file that match pUserBasePath and do not point
 *   to a shareable application resource will be translated.
 *
 * ENTRY:
 *  PUNICODE_STRING pSysFullPath (In)  - Path of ini file in system dir (source)
 *  PUNICODE_STRING pUserBasePath (In) - Optional, User's windows home dir
 *  PUNICODE_STRING pUserFullPath (In) - Path of ini file in user's home dir (dest)
 *
 * Notes:
 *  If pUserBasePath is NULL, no path substitution is done as the ini file is
 *  copied from the system directory to the user's home directory.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
TermsrvCopyIniFile(
    PUNICODE_STRING pSysFullPath,
    PUNICODE_STRING pUserBasePath,
    PUNICODE_STRING pUserFullPath
    )
{
    NTSTATUS Status;
    HANDLE SrcHandle, DestHandle;
    OBJECT_ATTRIBUTES SrcObja;
    OBJECT_ATTRIBUTES DestObja;
    IO_STATUS_BLOCK   SrcIosb;
    IO_STATUS_BLOCK   DestIosb;
    PWCHAR            pwch, pwcIniName;
    ULONG             ulCompatFlags;

    TRACE0(("TermsrvCopyIniFile: From %ws, TO -> %ws\n",pSysFullPath->Buffer,pUserFullPath->Buffer));
    TRACE0(("UserBasePath %ws\n",pUserBasePath->Buffer));

    /*
     * This must all be done at the NT level
     */
    InitializeObjectAttributes(
        &SrcObja,
        pSysFullPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    InitializeObjectAttributes(
        &DestObja,
        pUserFullPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    // Open the src
    SrcIosb.Status = STATUS_SUCCESS;
    Status = NtOpenFile(
                 &SrcHandle,
                 FILE_GENERIC_READ,
                 &SrcObja,
                 &SrcIosb,
                 FILE_SHARE_READ|FILE_SHARE_WRITE,
                 FILE_SYNCHRONOUS_IO_NONALERT    // OpenOptions
                 );

    if( NT_SUCCESS(Status) ) {
        // Get final I/O status
        Status = SrcIosb.Status;
    }

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("TermsrvCopyIniFile: Error 0x%x opening SrcFile %ws\n",Status,pSysFullPath->Buffer));
        return( FALSE );
    }

    // Create the destination file
    DestIosb.Status = STATUS_SUCCESS;
    Status = NtCreateFile(
                 &DestHandle,
                 FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                 &DestObja,
                 &DestIosb,
                 NULL,        // Allocation size
                 FILE_ATTRIBUTE_NORMAL, // dwFlagsAndAttributes
                 FILE_SHARE_WRITE,      // dwShareMode
                 FILE_OVERWRITE_IF,           // CreateDisposition
                 FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, // CreateFlags
                 NULL, // EaBuffer
                 0     // EaLength
                 );

    if( NT_SUCCESS(Status) ) {
        // Get final I/O status
        Status = DestIosb.Status;
    }

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("TermsrvCopyIniFile: Error 0x%x Creating DestFile %ws\n",Status,pUserFullPath->Buffer));
        NtClose( SrcHandle );
        return( FALSE );
    }

    TRACE0(("TermsrvCopyFile: Create Disposition 0x%x\n",DestIosb.Information));

    // Get the ini file name
    pwch = wcsrchr(pSysFullPath->Buffer, L'\\') + 1;
    pwcIniName = RtlAllocateHeap( RtlProcessHeap(),
                                  0,
                                  (wcslen(pwch) + 1)*sizeof(WCHAR));
    if(!pwcIniName)
    {
        DBGPRINT(("TermsrvCopyIniFile: Error Allocating pwcIniName\n"));
        NtClose( SrcHandle );
        NtClose( DestHandle );
        return( FALSE );
    }

    wcscpy(pwcIniName, pwch);
    pwch = wcsrchr(pwcIniName, L'.');
    if (pwch) {
        *pwch = L'\0';
    }

    GetTermsrCompatFlags(pwcIniName, &ulCompatFlags, CompatibilityIniFile);

    RtlFreeHeap( RtlProcessHeap(), 0, pwcIniName );

    /*
     * Now do the copy loop
     */
    if (pUserBasePath && !(ulCompatFlags & TERMSRV_COMPAT_ININOSUB)) {
        Status = TermsrvIniCopyAndChangeLoop( SrcHandle,
                                          DestHandle,
                                          pUserBasePath,
                                          pSysFullPath
                                        );
    } else {
        Status = TermsrvIniCopyLoop( SrcHandle, DestHandle );
    }

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("TermsrvCopyIniFile: Error 0x%x Doing copy loop\n",Status));
        NtClose( SrcHandle );
        NtClose( DestHandle );
        return( FALSE );
    }

    /*
     * Close the file handles
     */
    NtClose( SrcHandle );
    NtClose( DestHandle );

    return( TRUE );
}

/*****************************************************************************
 *
 *  TermsrvIniCopyLoop
 *
 *   Actual copy loop. This copies the src ini file to the destination
 *   ini file.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
TermsrvIniCopyLoop(
    HANDLE SrcHandle,
    HANDLE DestHandle
    )
{
    NTSTATUS Status;
    PCHAR  pBuf = NULL;
    IO_STATUS_BLOCK   Iosb;

    pBuf = LocalAlloc( LPTR, INI_BUF_SIZE );
    if ( !pBuf ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    while( 1 ) {

        Iosb.Status = STATUS_SUCCESS;
        Status = NtReadFile(
                     SrcHandle,
                     NULL,      // Event
                     NULL,      // APC routine
                     NULL,      // APC context
                     &Iosb,
                     pBuf,
                     INI_BUF_SIZE,
                     NULL,      // ByteOffset (not used since in synchronous I/O)
                     NULL       // Key
                     );

        if( Status == STATUS_PENDING ) {
            Status = NtWaitForSingleObject( SrcHandle, FALSE, NULL );
        }

        if( NT_SUCCESS(Status) ) {
            // Get final I/O status
            Status = Iosb.Status;
        }

        if( !NT_SUCCESS(Status) ) {
            if( Status == STATUS_END_OF_FILE ) {
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }
            DBGPRINT(("TermsrvIniCopyLoop: Error 0x%x doing NtReadFile\n",Status));
            goto Cleanup;
        }

        Iosb.Status = STATUS_SUCCESS;
        Status = NtWriteFile(
                     DestHandle,
                     NULL,      // Event
                     NULL,      // APC routine
                     NULL,      // APC context
                     &Iosb,
                     pBuf,
                     (ULONG)Iosb.Information,  // Actual amount read
                     NULL,      // ByteOffset (not used since in synchronous I/O)
                     NULL       // Key
                     );

        if( Status == STATUS_PENDING ) {
            Status = NtWaitForSingleObject( DestHandle, FALSE, NULL );
        }

        if( NT_SUCCESS(Status) ) {
            // Get final I/O status
            Status = Iosb.Status;
        }

        if( !NT_SUCCESS(Status) ) {
            DBGPRINT(("TermsrvIniCopyLoop: Error 0x%x doing NtWriteFile\n",Status));
            goto Cleanup;
        }

    } // end while(1)

Cleanup:

    if ( pBuf ) {
        LocalFree( pBuf );
    }
    return( Status );
}

/*****************************************************************************
 *
 *  TermsrvIniCopyAndChangeLoop
 *
 *   Actual copy loop. This copies the src ini file to the destination
 *   ini file. It also handles any path translations.
 *
 * ENTRY:
 *  HANDLE SrcHandle (In) - Source file handle
 *  HANDLE DestHandle (In) - Destination file handle
 *  PUNICODE_STRING pUserFullPath (In) - Ptr to Uni string with user's home
 *                                       windows dir
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
TermsrvIniCopyAndChangeLoop(
    HANDLE SrcHandle,
    HANDLE DestHandle,
    PUNICODE_STRING pUserFullPath,
    PUNICODE_STRING pSysFullPath
    )
{
    PCHAR pStr, pch, ptemp, pnext;
    PWCHAR pwch;
    NTSTATUS Status;
    ULONG StringSize;
    CHAR  IOBuf[512];
    ULONG IOBufSize = 512;
    ULONG IOBufIndex = 0;
    ULONG IOBufFillSize = 0;
    ANSI_STRING AnsiUserDir, AnsiSysDir;
    UNICODE_STRING UniString;

    // Get the DOS filename from the NT file name
    if (pwch = wcschr(pUserFullPath->Buffer, L':')) {
        pwch--;
    } else {
        pwch = pUserFullPath->Buffer;
    }

    RtlInitUnicodeString( &UniString, pwch );

    Status = RtlUnicodeStringToAnsiString( &AnsiUserDir,
                                           &UniString,
                                           TRUE
                                         );
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("TermsrvIniCopyAndChangeLoop: Error 0x%x converting user dir\n", Status));
        return(Status);
    }

    // Get the system directory from the fully qualified system path
    if (pwch = wcschr(pSysFullPath->Buffer, L':')) {
        pwch--;
    } else {
        pwch = pUserFullPath->Buffer;
    }

    RtlInitUnicodeString( &UniString, pwch );

    Status = RtlUnicodeStringToAnsiString( &AnsiSysDir,
                                           &UniString,
                                           TRUE
                                         );

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("TermsrvIniCopyAndChangeLoop: Error 0x%x converting system dir\n", Status));
        RtlFreeAnsiString( &AnsiUserDir );
        return(Status);
    }

    pch = strrchr(AnsiSysDir.Buffer, '\\');

    // unless something has gone wrong, we should always have a pch since a full-path always
    // has at least "\" in it, and actually in our case, we have atleast two slashes inside,
    // since we are dealing with a string such as "\A\file.ini", where 'A' is a folder
    // name that has at least one letter in it
    if (pch)
    {

        if ((pch - AnsiSysDir.Buffer) > 2) {
            *pch = '\0';
        } else {
            *(pch+1) = '\0';
        }
        AnsiSysDir.Length = (USHORT) strlen(AnsiSysDir.Buffer);

        while( 1 ) {

            pStr = NULL;
            StringSize = 0;

            /*
             * Get a string from the source ini file
             */
            Status = TermsrvGetString(
                         SrcHandle,
                         &pStr,
                         &StringSize,
                         IOBuf,
                         IOBufSize,
                         &IOBufIndex,
                         &IOBufFillSize
                         );

            if( !NT_SUCCESS(Status) ) {

                ASSERT( pStr == NULL );

                RtlFreeAnsiString( &AnsiUserDir );
                RtlFreeAnsiString( &AnsiSysDir );

                if( Status == STATUS_END_OF_FILE ) {
                    return( STATUS_SUCCESS );
                }
                return( Status );
            }

            /*
             * Process the string for any ini path translations
             */
            ASSERT( pStr != NULL );

            // Go through the string looking for anything that contains the system
            // directory.
            if (pch = Ctxstristr(pStr, AnsiSysDir.Buffer)) {
                // See if this entry might point to an ini file
                if ((ptemp = strchr(pch, '.')) && !(_strnicmp(ptemp, ".ini", 4))) {

                    // Check to make sure this is the right string to replace
                    pnext = pch + AnsiSysDir.Length + 1;
                    while (pch && (pnext < ptemp)) {
                        // Check for another entry
                        if (*pnext == ',') {
                            pch = Ctxstristr(pnext, AnsiSysDir.Buffer);
                            if (pch) {
                                pnext = pch + AnsiSysDir.Length + 1;
                            }
                        }
                        pnext++;
                    }

                    // Check that this .ini is in the system directory
                    pnext = pch + AnsiSysDir.Length + 1;
                    while (pch && (pnext < ptemp)) {
                        if (*pnext == '\\') {
                            pch = NULL;
                        }
                        pnext++;
                    }

                    if (pch && (pch < ptemp)) {
                        ptemp = RtlAllocateHeap( RtlProcessHeap(),
                                                 0,
                                                 StringSize + AnsiUserDir.Length );
                        strncpy(ptemp, pStr, (size_t)(pch - pStr));       // copy up to sys dir
                        ptemp[pch - pStr] = '\0';
                        strcat(ptemp, AnsiUserDir.Buffer);      // subst user dir
                        if (AnsiSysDir.Length == 3) {
                            strcat(ptemp, "\\");
                        }
                        strcat(ptemp, pch + AnsiSysDir.Length); // append rest of line
                        RtlFreeHeap( RtlProcessHeap(), 0, pStr );
                        StringSize = strlen(ptemp);
                        pStr = ptemp;
                    }
                }
            }

            /*
             * Write out the translated string
             */
            Status = TermsrvPutString(
                         DestHandle,
                         pStr,
                         StringSize
                         );

              RtlFreeHeap( RtlProcessHeap(), 0, pStr );

            if( !NT_SUCCESS(Status) ) {
                DBGPRINT(("TermsrvIniCopyLoop: Error 0x%x doing NtWriteFile\n",Status));
                RtlFreeAnsiString( &AnsiUserDir );
                RtlFreeAnsiString( &AnsiSysDir );
                return( Status );
            }

        } // end while(1)
    }
    else
    {
        return STATUS_UNSUCCESSFUL;

    }
}


/*****************************************************************************
 *
 *  TermsrvGetString
 *
 *   This function gets a "string" from an ini file and returns it to the
 *   caller. Since processing must be done in memory on the strings, they
 *   are returned NULL terminated, but this NULL is NOT included in the
 *   returned string size. Of course, buffer size calculations take this
 *   NULL into account. Strings retain any <CR><LF> characters and are
 *   not stripped out like the C runtime.
 *
 *   The I/O buffer used is passed in by the caller. If the IoBufIndex is
 *   not 0, this is an indication that there is still data left in the buffer
 *   from a previous operation. This data is used before reading additional
 *   data from the file handle. This handles the case where string breaks
 *   do not occur at buffer boundries.
 *
 *   Strings are returned in newly allocated memory on the process heap.
 *   The caller is reponsible for freeing them when done.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
TermsrvGetString(
    HANDLE SrcHandle,
    PCHAR  *ppStringPtr,
    PULONG pStringSize,
    PCHAR  pIOBuf,
    ULONG  IOBufSize,
    PULONG pIOBufIndex,
    PULONG pIOBufFillSize
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK   Iosb;
    BOOL  SawNL = FALSE;
    ULONG StrSize = 0;
    ULONG StrBufSize = 512;
    PCHAR pStr = NULL;

    /*
     * first process any left over data in the current I/O buffer
     */
    if( *pIOBufIndex < *pIOBufFillSize ) {

        Status = TermsrvProcessBuffer(
                     &pStr,
                     &StrSize,
                     &StrBufSize,
                     &SawNL,
                     pIOBuf,
                     pIOBufIndex,
                     pIOBufFillSize
                     );

        if( Status == STATUS_SUCCESS ) {
            *ppStringPtr = pStr;
            *pStringSize = StrSize;
            return( STATUS_SUCCESS );
        }
        else if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
            /*
             * emptied the buffer
             */
            *pIOBufIndex = 0;
            *pIOBufFillSize = 0;

            // fall through to read more data
        }
        else {
            // Error
            if( pStr ) {
                RtlFreeHeap( RtlProcessHeap(), 0, pStr );
            }
            *ppStringPtr = NULL;
            *pStringSize = 0;
            return( Status );
        }
    }

    while( 1 ) {

        ASSERT( *pIOBufIndex == 0 );
        ASSERT( *pIOBufFillSize == 0 );

        Iosb.Status = STATUS_SUCCESS;
        Status = NtReadFile(
                     SrcHandle,
                     NULL,      // Event
                     NULL,      // APC routine
                     NULL,      // APC context
                     &Iosb,
                     pIOBuf,
                     IOBufSize,
                     NULL,      // ByteOffset (not used since in synchronous I/O)
                     NULL       // Key
                     );

        if( Status == STATUS_PENDING ) {
            Status = NtWaitForSingleObject( SrcHandle, FALSE, NULL );
        }

        if( NT_SUCCESS(Status) ) {
            // Get final I/O status
            Status = Iosb.Status;
        }

        if( !NT_SUCCESS(Status) ) {

        if( (Status == STATUS_END_OF_FILE) && (StrSize != 0) ) {

                // Force the string finished
                pStr[StrSize] = (CHAR)NULL;
                *pStringSize = StrSize;
                *ppStringPtr = pStr;
                return( STATUS_SUCCESS );
            }

            // Free the buffer
            if( pStr ) {
                RtlFreeHeap( RtlProcessHeap(), 0, pStr );
            }
            *ppStringPtr = NULL;
            *pStringSize = 0;
            if (Status != STATUS_END_OF_FILE)
                DBGPRINT(("TermsrvIniCopyLoop: Error 0x%x doing NtReadFile\n",Status));
            return( Status );
        }

        // Fill in the count
        *pIOBufFillSize = (ULONG)Iosb.Information;

        /*
         * Now process this buffer of data
         */
        Status = TermsrvProcessBuffer(
                     &pStr,
                     &StrSize,
                     &StrBufSize,
                     &SawNL,
                     pIOBuf,
                     pIOBufIndex,
                     pIOBufFillSize
                     );

        if( Status == STATUS_SUCCESS ) {
            *ppStringPtr = pStr;
            *pStringSize = StrSize;
            return( STATUS_SUCCESS );
        }
        else if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
            /*
             * emptied the buffer
             */
            *pIOBufIndex = 0;
            *pIOBufFillSize = 0;

            // fall through to read more data
        }
        else {
            // Error
            if( pStr ) {
                RtlFreeHeap( RtlProcessHeap(), 0, pStr );
            }
            *ppStringPtr = NULL;
            *pStringSize = 0;
            return( Status );
        }
    } // end while(1)
}

/*****************************************************************************
 *
 *  TermsrvProcessBuffer
 *
 *   Process a buffer of data.
 *
 *   This uses state passed in by the caller since the string can be
 *   partially built, and the buffer may not be fully processed when
 *   a string completes.
 *
 *   Can return if it completes a string with data still in buffer.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
TermsrvProcessBuffer(
    PCHAR  *ppStr,
    PULONG pStrSize,
    PULONG pStrBufSize,
    PBOOL  pSawNL,
    PCHAR  pIOBuf,
    PULONG pIOBufIndex,
    PULONG pIOBufFillSize
    )
{
    PCHAR pStr;
    ULONG Index;
    BOOL  SawNL;

    /*
     * See if we are starting a new string
     */
    if( *ppStr == NULL ) {

        pStr = RtlAllocateHeap( RtlProcessHeap(), 0, *pStrBufSize );
        if( pStr == NULL ) {
            DBGPRINT(("TermsrvProcessBuf: Memory allocation failure\n"));
            return( STATUS_NO_MEMORY );
        }

        // Set it to our caller
        *ppStr = pStr;
    }

    /*
     * Get passed in state to local variables
     */
    pStr = *ppStr;
    Index = *pStrSize;
    SawNL = *pSawNL;

    while ( *pIOBufIndex < *pIOBufFillSize ) {

        pStr[Index] = pIOBuf[*pIOBufIndex];
        if( IS_NEWLINE_CHAR( pStr[Index] ) ) {

            /*
             * Mark the we saw an end of string character.
             * We will keep putting them into the buffer until a
             * non-NL character is encountered. This handles the
             * variations for <CR><LF>, <CR> alone, or <CR><LF><CR>
             * if its been mangled by a buggy editor.
             */
            SawNL = TRUE;
        }
        else {
            /*
             * If we saw a previous NL character, and this character
             * is not one, we do not take this one, but put a NULL in
             * its place and return. NOTE: Do not bump the count, since
             * the count does not include the NULL.
             */
            if( SawNL ) {
                pStr[Index] = (CHAR)NULL;
                *pStrSize = Index;
                return( STATUS_SUCCESS );
            }
        }

        Index++;
        (*pIOBufIndex)++;
        if( Index >= *pStrBufSize ) {

            // Grow the string buffer
            if( !TermsrvReallocateBuf( &pStr, pStrBufSize, (*pStrBufSize) * 2 ) ) {
                if( pStr ) {
                    RtlFreeHeap( RtlProcessHeap(), 0, pStr );
                }
                *ppStr = NULL;
                DBGPRINT(("TermsrvIniCopyLoop: Memory re-allocation failure\n"));
                return( STATUS_NO_MEMORY );
            }
            // Memory buffer has been re-allocated
            *ppStr = pStr;
            *pStrBufSize = (*pStrBufSize) * 2;
        }
    }

    *pStrSize = Index;
    *pSawNL = SawNL;

    /*
     * emptied the buffer without building a whole string
     */
    return( STATUS_MORE_PROCESSING_REQUIRED );
}

/*****************************************************************************
 *
 *  TermsrvReallocateBuf
 *
 *   Grow the buffer, copy data to new buffer.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
TermsrvReallocateBuf(
    PCHAR  *ppStr,
    PULONG pStrBufSize,
    ULONG  NewSize
    )
{
    PCHAR ptr;
    ULONG CopyCount;

    CopyCount = *pStrBufSize;

    ptr = RtlAllocateHeap( RtlProcessHeap(), 0, NewSize );
    if( ptr == NULL ) {
        return( FALSE );
    }

    RtlMoveMemory( ptr, *ppStr, CopyCount );

    RtlFreeHeap( RtlProcessHeap(), 0, *ppStr );

    *ppStr = ptr;

    return( TRUE );
}

/*****************************************************************************
 *
 *  TermsrvPutString
 *
 *   Write out the current string to the destination file handle
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
TermsrvPutString(
    HANDLE DestHandle,
    PCHAR  pStr,
    ULONG  StringSize
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK   Iosb;

    Iosb.Status = STATUS_SUCCESS;

    Status = NtWriteFile(
                 DestHandle,
                 NULL,      // Event
                 NULL,      // APC routine
                 NULL,      // APC context
                 &Iosb,
                 pStr,
                 StringSize,
                 NULL,      // ByteOffset (not used since in synchronous I/O)
                 NULL       // Key
                 );

    if( Status == STATUS_PENDING ) {
        Status = NtWaitForSingleObject( DestHandle, FALSE, NULL );
    }

    if( NT_SUCCESS(Status) ) {
        // Get final I/O status
        Status = Iosb.Status;
    }

    return( Status );
}


/*****************************************************************************
 *
 *  TermsrvCheckNewIniFiles
 *
 *  This routine will check the timestamps of the .ini files installed by the
 *  system administrator, and see if any of the user's .ini file are out of
 *  date, and if so, they will be renamed.
 *
 * ENTRY:
 *
 * EXIT:
 *   No return value.
 *
 ****************************************************************************/

void TermsrvCheckNewIniFiles(void)
{
    NTSTATUS Status;

    #if defined (_IA64_)
    Status = TermsrvCheckNewIniFilesInternal(REG_NTAPI_SOFTWARE_WOW6432_TSERVER);
    if (!NT_SUCCESS(Status)) {
        return;
    }
    #endif //_IA64_

    Status = TermsrvCheckNewIniFilesInternal(REG_NTAPI_SOFTWARE_TSERVER);
    if (!NT_SUCCESS(Status)) {
        return;
    }

    // Update the user's sync time in the registry
    TermsrvSetUserSyncTime();
}

/*****************************************************************************
 *
 *  TermsrvCheckNewIniFilesInternal
 *
 *  This routine will check the timestamps of the .ini files installed by the
 *  system administrator, and see if any of the user's .ini file are out of
 *  date, and if so, they will be renamed.
 *
 * ENTRY:
 *       LPCWSTR wszBaseKeyName
 *
 * EXIT:
 *   No return value.
 *
 ****************************************************************************/

NTSTATUS
TermsrvCheckNewIniFilesInternal(
        IN LPCWSTR wszBaseKeyName)
{
    PWCHAR pwch;
    UNICODE_STRING UniString, UniUserDir, UniNTDir = {0,0,NULL};
    OBJECT_ATTRIBUTES ObjectAttr;
    FILE_NETWORK_OPEN_INFORMATION BasicInfo;
    HANDLE hKey = NULL, hWinDir = NULL;
    NTSTATUS Status;
    ULONG ulcnt, ullen, ultmp;
    WCHAR wcWinDir[MAX_PATH], wcbuff[MAX_PATH];
    PKEY_VALUE_FULL_INFORMATION pKeyValInfo;
    PKEY_BASIC_INFORMATION pKeyInfo;
    IO_STATUS_BLOCK IOStatus;

    g_debugIniMap = IsDebugIniMapEnabled();

    // Allocate a buffer for the key value name and time info
    ullen = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
            sizeof(ULONG);
    pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ullen);

    // If we didn't get the buffer, return
    if (!pKeyValInfo) {
        return STATUS_NO_MEMORY;
    }

    // Open up the registry key to get the last sync time for this user
    wcscpy(wcbuff,wszBaseKeyName);
    wcscat(wcbuff,TERMSRV_INIFILE_TIMES_SHORT);

    RtlInitUnicodeString(&UniString,
                         wcbuff);
    InitializeObjectAttributes(&ObjectAttr,
                               &UniString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&hKey, KEY_READ, &ObjectAttr);

    // If we successfully opened the key, check if there are any new entries
    if (NT_SUCCESS(Status)) {

        // Since we already allocated a hunk of memory, use the value buffer
        // for the key info query
        pKeyInfo = (PKEY_BASIC_INFORMATION)pKeyValInfo;

        // Get the last time anyone wrote to "IniFile Times" key
        Status = NtQueryKey(hKey,
                            KeyBasicInformation,
                            pKeyInfo,
                            ullen,
                            &ultmp);

        // We got the last write time OK, now get the last time we sync'd
        if (NT_SUCCESS(Status) && TermsrvGetUserSyncTime(&ultmp)) {

            // Convert the time value to seconds since 1970
            RtlTimeToSecondsSince1970 (&pKeyInfo->LastWriteTime,
                                       &ulcnt);

            // If no .ini files or reg entries have been updated since the last
            // time we sync'd this user, just return
            if (ultmp >= ulcnt) {
                NtClose(hKey);
                RtlFreeHeap(RtlProcessHeap(), 0, pKeyValInfo);
                return STATUS_SUCCESS;
            }
        }

        TermsrvCheckNewRegEntries(wszBaseKeyName);

        // Set up UniUserDir to point at wcbuff
        UniUserDir.Buffer = wcWinDir;
        UniUserDir.Length = 0;
        UniUserDir.MaximumLength = sizeof(wcbuff);

        Status = GetPerUserWindowsDirectory(&UniUserDir);

        if (NT_SUCCESS(Status)) {

            // Convert to an NT path
            if (RtlDosPathNameToNtPathName_U(UniUserDir.Buffer,
                                             &UniNTDir,
                                             NULL,
                                             NULL)) {
                InitializeObjectAttributes(&ObjectAttr,
                                           &UniNTDir,
                                           OBJ_CASE_INSENSITIVE,
                                           NULL,
                                           NULL);

                // Open the user's windows directory
                IOStatus.Status = STATUS_SUCCESS;
                Status = NtOpenFile(&hWinDir,
                                    FILE_GENERIC_READ,
                                    &ObjectAttr,
                                    &IOStatus,
                                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                                    FILE_SYNCHRONOUS_IO_NONALERT);
            } else {
                Status = STATUS_NO_SUCH_FILE;
            }
        }

        // Go through each of the keys, checking if it's newer than the user's
        // version of the file, and if so rename it
        ulcnt = 0;
        wcscat(wcWinDir, L"\\");
        UniUserDir.Length += 2;         // add in length of \ seperator
        while (NT_SUCCESS(Status)) {
            Status = NtEnumerateValueKey(hKey,
                                         ulcnt++,
                                         KeyValueFullInformation,
                                         pKeyValInfo,
                                         ullen,
                                         &ultmp);
            if (NT_SUCCESS(Status)) {

                RtlMoveMemory(wcbuff, pKeyValInfo->Name, pKeyValInfo->NameLength);
                wcbuff[pKeyValInfo->NameLength/sizeof(WCHAR)] = L'\0';

                // Get rid of the .ini extension
                if (pwch = wcschr(wcbuff, L'.')) {
                    *pwch = L'\0';
                }

                // Get the compatibility flags for this .ini file
                GetTermsrCompatFlags(wcbuff,
                                     &ultmp,
                                     CompatibilityIniFile);

                // If we removed the extension, put it back
                if (pwch) {
                    *pwch = '.';
                }

                // If the INISYNC compat bit is set, don't rename the file
                if ((ultmp & (TERMSRV_COMPAT_INISYNC | TERMSRV_COMPAT_WIN16)) !=
                     (TERMSRV_COMPAT_INISYNC | TERMSRV_COMPAT_WIN16)) {

                    RtlInitUnicodeString(&UniString, wcbuff);

                    // Query the last write time of the .ini file
                    InitializeObjectAttributes(&ObjectAttr,
                                               &UniString,
                                               OBJ_CASE_INSENSITIVE,
                                               hWinDir,
                                               NULL);

                    // Get the last write time
                    if (NT_SUCCESS(NtQueryFullAttributesFile( &ObjectAttr,
                                                              &BasicInfo ))) {

                        // Convert the last write time to seconds
                        RtlTimeToSecondsSince1970(&BasicInfo.LastWriteTime,
                                                  &ultmp);

                        // Check if the system version is newer than the user's
                        // version
                        if (*(PULONG)((PCHAR)pKeyValInfo +
                                      pKeyValInfo->DataOffset) > ultmp) {

                            // Concatenate the .ini name onto the user's path
                            wcscpy(wcWinDir + (UniUserDir.Length/sizeof(WCHAR)),
                                   wcbuff);

                            // Create the target name to rename the file
                            // (inifile.ctx)
                            wcscpy(wcbuff, wcWinDir);
                            pwch = wcsrchr(wcbuff, L'.');
                            if (pwch) {
                                wcscpy(pwch, L".ctx");
                            } else {
                                wcscat(pwch, L".ctx");
                            }

                            // Rename the .ini file
                            MoveFileExW(wcWinDir,
                                        wcbuff,
                                        MOVEFILE_REPLACE_EXISTING);
                        }
                    }
                }
            }
        }

        // Close the handles, if they were opened
        if (hKey) {
            NtClose(hKey);
        }
        if (hWinDir) {
            NtClose(hWinDir);
        }

    }


    // Free the memory we allocated
    RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
    if (UniNTDir.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, UniNTDir.Buffer);
    }

    return STATUS_SUCCESS;
}



/*****************************************************************************
 *
 *  TermsrvCheckKeys
 *
 *  This recursive routine will check for any subkeys under the system root
 *  key passed in.  It will delete the corresponding key in the user's
 *  software registry if the user's key is older than the system key.  If the
 *  INISYNC bit is set for this registry key or the key is still has subkeys,
 *  it won't be deleted.  If the key doesn't exist in the user's registry,
 *  it will be added.
 *
 * ENTRY:
 *  HANDLE hKeySysRoot: handle to key in system section of registry
 *  HANDLE hKeyUsrRoot: handle to key in user section of registry
 *  PKEY_BASIC_INFORMATION pKeySysInfo: Ptr to buffer for key basic info struc
 *  PKEY_FULL_INFORMATION pKeyUsrInfo: Ptr to buffer for full key info struc
 *  ULONG ulcsys: Size of SysInfo buffer
 *  ULONG ulcusr: Size of UsrInfo buffer
 *
 * EXIT:
 *   SUCCESS:
 *      STATUS_SUCCESS
 *   FAILURE:
 *      NTSTATUS Return Code
 *
 ****************************************************************************/
NTSTATUS TermsrvCheckKeys(HANDLE hKeySysRoot,
                      HANDLE hKeyUsrRoot,
                      PKEY_BASIC_INFORMATION pKeySysInfo,
                      PKEY_FULL_INFORMATION pKeyUsrInfo,
                      ULONG ulcsys,
                      ULONG ulcusr,
                      DWORD indentLevel )
{
    NTSTATUS Status = STATUS_SUCCESS, Status2;
    ULONG ultemp, ulcnt = 0;
    UNICODE_STRING UniPath, UniString;
    OBJECT_ATTRIBUTES ObjAttr;
    HANDLE hKeyUsr = NULL, hKeySys = NULL;
    LPWSTR wcbuff = NULL;
    ULONG aulbuf[4];
    PKEY_FULL_INFORMATION pKeyUsrFullInfoSaved = NULL ;
    ULONG   sizeFullInfo;
    PKEY_VALUE_PARTIAL_INFORMATION pValKeyInfo =
        (PKEY_VALUE_PARTIAL_INFORMATION)aulbuf;

    ++indentLevel;
    
    Status = GetFullKeyPath(hKeyUsrRoot,NULL,&wcbuff);
    if(!NT_SUCCESS(Status)) {
        return Status;
    }

    // Get the compatibility flags for this entry
    GetTermsrCompatFlags(wcbuff,
                         &ultemp,
                         CompatibilityRegEntry);

    LocalFree(wcbuff);

    // If the INISYNC or NOREGMAP bits are set for this entry,
    // return, since there's nothing to do
    if ((ultemp & TERMSRV_COMPAT_WIN32) &&
         (ultemp & (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_INISYNC))) {
        return(STATUS_NO_MORE_ENTRIES);
    }

    // Save the current info for the current user key
    // @@@
    if (!hKeyUsrRoot)
    {
        DBGPRINT(("ERROR : LINE : %4d, why is this null? \n", __LINE__ ));
        return(STATUS_NO_MORE_ENTRIES );
    }

    // use a zero length query to get the actual length
    Status = NtQueryKey(hKeyUsrRoot,
                   KeyFullInformation,
                   pKeyUsrFullInfoSaved,
                   0,
                   &ultemp) ;

	if ( !NT_SUCCESS( Status ) )
	{
		if (Status == STATUS_BUFFER_TOO_SMALL )
		{
			sizeFullInfo = ultemp;
		
			pKeyUsrFullInfoSaved = RtlAllocateHeap(RtlProcessHeap(), 0, sizeFullInfo );

			if ( ! pKeyUsrFullInfoSaved )
			{
				return STATUS_NO_MEMORY;
			}

			Status = NtQueryKey(hKeyUsrRoot,
					   KeyFullInformation,
					   pKeyUsrFullInfoSaved,
					   sizeFullInfo,
					   &ultemp);
			
			if( !NT_SUCCESS(Status ) )
			{
				DBGPRINT(("ERROR : LINE : %4d, Status =0x%lx , ultemp=%d\n", __LINE__ , Status, ultemp));
				RtlFreeHeap( RtlProcessHeap(), 0, pKeyUsrFullInfoSaved);
				return( Status );
			}		

		}
		else
		{

            DBGPRINT(("ERROR : LINE : %4d, Status =0x%lx \n", __LINE__ , Status ));
			return Status;
		}
	}

    // Go through each of the subkeys, checking for user keys that are older
    // than the system version of the keys
    while (NT_SUCCESS(Status)) {

        Status = NtEnumerateKey(hKeySysRoot,
                                ulcnt++,
                                KeyBasicInformation,
                                pKeySysInfo,
                                ulcsys,
                                &ultemp);

        // See if there are any user keys under this key that are out of date
        if (NT_SUCCESS(Status)) {

            // Null terminate the key name
            pKeySysInfo->Name[pKeySysInfo->NameLength/sizeof(WCHAR)] = L'\0';

            // Create a unicode string for the key name
            RtlInitUnicodeString(&UniPath, pKeySysInfo->Name);

            InitializeObjectAttributes(&ObjAttr,
                                       &UniPath,
                                       OBJ_CASE_INSENSITIVE,
                                       hKeySysRoot,
                                       NULL);

            Debug1( indentLevel, __LINE__, L"system", &UniPath );

            // Open up the system key
            Status2 = NtOpenKey(&hKeySys,
                                KEY_READ,
                                &ObjAttr);

            // We opened up the system key, now open the user key
            if (NT_SUCCESS(Status2)) {

                // Setup the object attr struc for the user key
                InitializeObjectAttributes(&ObjAttr,
                                           &UniPath,
                                           OBJ_CASE_INSENSITIVE,
                                           hKeyUsrRoot,
                                           NULL);

                // Open up the user key
                Status2 = NtOpenKey(&hKeyUsr,
                                    MAXIMUM_ALLOWED,
                                    &ObjAttr);

                // Check if there are any subkeys under this key
                if (NT_SUCCESS(Status2)) {

                    Debug1(indentLevel, __LINE__, L"user", &UniPath );

                    TermsrvCheckKeys(hKeySys,
                                 hKeyUsr,
                                 pKeySysInfo,
                                 pKeyUsrInfo,
                                 ulcsys,
                                 ulcusr,
                                 indentLevel);

                    NtClose(hKeyUsr);
                }

                // key doesn't exist, clone system key to user
                else {
                    
                    Status2 = GetFullKeyPath(hKeyUsrRoot,pKeySysInfo->Name,&wcbuff);
                    
                    if(NT_SUCCESS(Status2)) {

                        // don't clone if mapping off for this registry entry
                        GetTermsrCompatFlags(wcbuff,
                                             &ultemp,
                                             CompatibilityRegEntry);
                        
                        LocalFree(wcbuff);

                        if (((ultemp & (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) !=
                             (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP) ))
                        {
                            Status2 = NtQueryKey(hKeySys,
                                                 KeyFullInformation,
                                                 pKeyUsrInfo,
                                                 ulcusr,
                                                 &ultemp);

                            if (NT_SUCCESS(Status2)) {

                                // don't clone if key previously deleted
                                RtlInitUnicodeString(&UniString, TERMSRV_COPYONCEFLAG);
                                Status2 = NtQueryValueKey(hKeySys,
                                                          &UniString,
                                                          KeyValuePartialInformation,
                                                          pValKeyInfo,
                                                          sizeof(aulbuf),
                                                          &ultemp);

                                if (!(NT_SUCCESS(Status2) && (pValKeyInfo->Data))) {
                                    // Setup the unicode string for the class
                                    RtlInitUnicodeString(&UniString,
                                                         pKeyUsrInfo->ClassLength ?
                                                            pKeyUsrInfo->Class : NULL);

                                    Debug1(indentLevel, __LINE__, L"creating user key", ObjAttr.ObjectName  );

                                    Status2 = NtCreateKey(&hKeyUsr,
                                                          MAXIMUM_ALLOWED,
                                                          &ObjAttr,
                                                          0,
                                                          &UniString,
                                                          REG_OPTION_NON_VOLATILE,
                                                          &ultemp);

                                    if (NT_SUCCESS(Status2)) {

                                        Debug1(indentLevel, __LINE__, L"cloning key", ObjAttr.ObjectName  );

                                        TermsrvCloneKey(hKeySys,
                                                    hKeyUsr,
                                                    pKeyUsrInfo,
                                                    TRUE);
                                    }
                                }
                            }
                        }
                    }
                }
                NtClose(hKeySys);
            }
        }
    }

    // Get the info for the user key
    if (NtQueryKey(hKeyUsrRoot,
                   KeyFullInformation,
                   pKeyUsrInfo,
                   ulcusr,
                   &ultemp) == STATUS_SUCCESS) {

        // Now get the info for the system key (again)
        if (NtQueryKey(hKeySysRoot,
                       KeyBasicInformation,
                       pKeySysInfo,
                       ulcsys,
                       &ultemp) == STATUS_SUCCESS) {

            // Get the compatibility flags for this registry entry
            pKeySysInfo->Name[pKeySysInfo->NameLength/sizeof(WCHAR)] = L'\0';
            GetTermsrCompatFlags(pKeySysInfo->Name,
                                 &ultemp,
                                 CompatibilityRegEntry);

            
            //check if it's older than the system version
            if( pKeyUsrFullInfoSaved->LastWriteTime.QuadPart <
                 pKeySysInfo->LastWriteTime.QuadPart) 
            {
                DebugTime(indentLevel, __LINE__, L"User key time", pKeyUsrFullInfoSaved->LastWriteTime );
                DebugTime(indentLevel, __LINE__, L"Sys  key time", pKeySysInfo->LastWriteTime);

                Debug2( indentLevel, __LINE__, L"Key Old, values being cloned",  pKeySysInfo->Name, pKeySysInfo->NameLength );

                if(NtQueryKey(hKeySysRoot,
                             KeyFullInformation,
                             pKeyUsrInfo,
                             ulcusr,
                             &ultemp) == STATUS_SUCCESS) {

                    TermsrvCloneKey(hKeySysRoot,
                                    hKeyUsrRoot,
                                    pKeyUsrInfo,//actually it is system key information
                                    FALSE);
                }
            }
        }
    }

    RtlFreeHeap( RtlProcessHeap(), 0, pKeyUsrFullInfoSaved);
    return(Status);
}




/*****************************************************************************
 *
 *  TermsrvCheckNewRegEntries
 *
 *  This routine will check the user's registry keys, and see if any of them
 *  are older than the system versions.  If so, the old key will be removed.
 *
 * ENTRY:
 *        IN LPCWSTR wszBaseKeyName
 *
 * EXIT:
 *   No return value.
 *
 ****************************************************************************/

void 
TermsrvCheckNewRegEntries(
        IN LPCWSTR wszBaseKeyName)
{
    NTSTATUS Status;
    ULONG ulcsys, ulcusr;
    UNICODE_STRING UniPath;
    OBJECT_ATTRIBUTES ObjAttr;
    PKEY_BASIC_INFORMATION pKeySysInfo = NULL;
    PKEY_FULL_INFORMATION pKeyUserInfo = NULL;
    HANDLE hKeyUser, hKeySys = NULL;
    WCHAR wcuser[MAX_PATH], wcsys[MAX_PATH];

    DWORD   indentLevel = 0;

    // Oct 15, 1999
    // This is BAD ! The Status bit was not initiazted to zero, which causes intermitent
    // execution by this function. The problem is that even if the status bit is init'd
    // to zero, then we can get the wrong behavior which will cause Office97 installation to
    // go wrong.
    // See BUG ID 412419
    // Here is what woudl happen: Install any app ( say TsClient). This would cause
    // an update to a Key in HKDU called Explorer\ShellFolders, just a refresh (no real change).
    // Then, if Admin did an logout and login, the call from UserInit.EXE into this
    // function (assuming by chance Status=0 was on the stack) would cause deletion of
    // that key (ShellFolder). But once Explorer starts, it writes to the ShellFolder with
    // a subset of original 19 values.
    // The problem is that if then, you decide to install Office97, setup.exe would look
    // in the same key for a value called "template" which is now missing. Explorer
    // would then create it, but it would point to some other than default location.
    // When all was done, our office97 compat script would be looking to where the
    // "template" value used to point (the default location), not where it is pointing now.
    //
    // we decide to disable this func by calling return right here, and instead, rely
    // on the TS mechanism to fault in keys.

    // Oct 31, 1999
    // I have decided to initialize the status var and let this func run, in addition to
    // marking the Explorer\ShellFolders as a do-not propagate key tree.
    //
    // It was discovered that after installing Office2000, when a user clicks on the
    // start-menu-> Open Office Docs link, MSI starts to run since user's hive is missing some
    // keys.
    //
    // The reason MSI does not see the keys in HKCU is because MSI has the TS-aware bit set,
    // which means that there are no faulting-in for any keys. The same is true for the Explorer.
    // On the other hand, when an app such as Office runs, since it is not ts-aware, we
    // fault in the keys that office touches. I verified this to work as expected.
    // The problem is that when you click on "Open Office Documents", you do so from the
    // explorer and when Explorer opens keys in the registry, since explorer is TS-aware,
    // those keys are not faulted in. I have verified that if you mark explorer as a non-TS-aware
    // app, the problem goes away.
    // We made a recent change in TS code (B-bug 412419, bld 2156+) to fix a different
    // problem which has now uncovered the reliance of the Explorer to get keys
    // faulted in during login.
    //      Specifically, TS used to fault in all keys at login time,
    //      regardless of the need. Post 2156, TS faults in only keys upon
    //      access by non-ts-aware apps. This was to fix a bug based on
    //      what we considered to be our most informed and well tested opinion. That
    //      has turned out to be wrong.
    // It is too risky to mark explorer non-ts-aware this late, so we must change the fix for 412419.
    // This should also make Bruno Amice very happy, since the fix will be as it was
    // advocated by him.
    Status = STATUS_SUCCESS;


    // Get a buffer for the system key info
    ulcsys = sizeof(KEY_BASIC_INFORMATION) + MAX_PATH*sizeof(WCHAR);
    pKeySysInfo = RtlAllocateHeap(RtlProcessHeap(),
                                   0,
                                   ulcsys);
    if (!pKeySysInfo) {
        Status = STATUS_NO_MEMORY;
    }

    // Get a buffer for the user key info
    if (NT_SUCCESS(Status)) {

        ulcusr = sizeof(KEY_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR);
        pKeyUserInfo = RtlAllocateHeap(RtlProcessHeap(),
                                       0,
                                       ulcusr);
        if (!pKeyUserInfo) {
            Status = STATUS_NO_MEMORY;
        }
    }

    // We have the necessary buffers, start checking the keys
    if (NT_SUCCESS(Status)) {

        // Build a string that points to Citrix\Install\Software
        wcscpy(wcsys, wszBaseKeyName);
        wcscat(wcsys, TERMSRV_INSTALL_SOFTWARE_SHORT);


        // Build up a string for this user's software section
        Status = RtlFormatCurrentUserKeyPath( &UniPath );
        if (NT_SUCCESS(Status)) {
            wcscpy(wcuser, UniPath.Buffer);
            wcscat(wcuser, L"\\Software");

            // Free the original user path
            RtlFreeHeap( RtlProcessHeap(), 0, UniPath.Buffer );
        }

        if (NT_SUCCESS(Status)) {
            // Create a unicode string for the system key path
            RtlInitUnicodeString(&UniPath, wcsys);

            InitializeObjectAttributes(&ObjAttr,
                                       &UniPath,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            Debug1(indentLevel, __LINE__, L"system", &UniPath );

            Status = NtOpenKey(&hKeySys,
                               KEY_READ,
                               &ObjAttr);
        }

        if (NT_SUCCESS(Status)) {
            // Create a unicode string for the user key path
            RtlInitUnicodeString(&UniPath, wcuser);

            InitializeObjectAttributes(&ObjAttr,
                                       &UniPath,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            Debug1(indentLevel, __LINE__, L"user", &UniPath );

            Status = NtOpenKey(&hKeyUser,
                               KEY_READ | DELETE,
                               &ObjAttr);
        }

        // Go through each of the keys, checking if the system version is
        // newer than the user version
        if (NT_SUCCESS(Status)) {
            TermsrvCheckKeys(hKeySys,
                         hKeyUser,
                         pKeySysInfo,
                         pKeyUserInfo,
                         ulcsys,
                         ulcusr,
                         indentLevel );

            // Close the user key
            NtClose(hKeyUser);
        }

        // If we allocated the system key, close it
        if (hKeySys) {
            NtClose(hKeySys);
        }
    }

    // Free up any memory we allocated
    if (pKeySysInfo) {
        RtlFreeHeap( RtlProcessHeap(), 0, pKeySysInfo);
    }
    if (pKeyUserInfo) {
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyUserInfo);
    }

}


/*****************************************************************************
 *
 *  Ctxstristr
 *
 *  This is a case insensitive version of strstr.
 *
 * ENTRY:
 *   PCHAR pstring1 (In) - String to search in
 *   PCHAR pstring2 (In) - String to search for
 *
 * EXIT:
 *   TRUE  - User ini file should be sync'd
 *   FALSE - User ini file should be sync'd
 *
 ****************************************************************************/

PCHAR
Ctxstristr(
    PCHAR pstring1,
    PCHAR pstring2)
{
    PCHAR pch, ps1, ps2;

    pch = pstring1;

    while (*pch)
    {
        ps1 = pch;
        ps2 = pstring2;

        while (*ps1 && *ps2 && !(toupper(*ps1) - toupper(*ps2))) {
                   ps1++;
            ps2++;
        }

        if (!*ps2) {
            return(pch);
        }

        pch++;
    }
    return(NULL);
}

/*****************************************************************************
 *
 *  TermsrvLogInstallIniFile
 *
 *  This routine will write the time the .ini file was last updated into the
 *  Terminal Server\install section of the registry.
 *
 * ENTRY:
 *
 * EXIT:
 *   TRUE  - Success
 *   FALSE - Failure
 *
 ****************************************************************************/

BOOL TermsrvLogInstallIniFile(PUNICODE_STRING NtFileName)
{
    PWCHAR pwch;
    UNICODE_STRING UniString;
    OBJECT_ATTRIBUTES ObjectAttr;
    FILE_NETWORK_OPEN_INFORMATION BasicInfo;
    HANDLE hKey;
    NTSTATUS Status;
    ULONG ultmp;

    if (!TermsrvPerUserWinDirMapping()) {
        return FALSE;
    }

    // Open up the registry key to store the last write time of the file
    RtlInitUnicodeString(&UniString,
                         TERMSRV_INSTALL);

    InitializeObjectAttributes(&ObjectAttr,
                               &UniString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    // Open or create the Terminal Server\Install path
    Status = NtCreateKey(&hKey,
                         KEY_WRITE,
                         &ObjectAttr,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         &ultmp);

    // Now open or create the IniFile Times key
    if (NT_SUCCESS(Status)) {
        NtClose(hKey);

        RtlInitUnicodeString(&UniString,
                             TERMSRV_INIFILE_TIMES);

        InitializeObjectAttributes(&ObjectAttr,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
        Status = NtCreateKey(&hKey,
                             KEY_WRITE,
                             &ObjectAttr,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             &ultmp);
    }

    // Opened up the registry key, now get the last write time of the file
    if (NT_SUCCESS(Status)) {

        // Query the last write time of the .ini file
        InitializeObjectAttributes(&ObjectAttr,
                                   NtFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
        Status = NtQueryFullAttributesFile( &ObjectAttr, &BasicInfo );

        // Got the last write time, convert to seconds and write it out
        if (NT_SUCCESS(Status)) {

            // Just save the .ini filename, get rid of the path
            pwch = wcsrchr(NtFileName->Buffer, L'\\') + 1;
            if (!pwch) {
                pwch = NtFileName->Buffer;
            }

            // Convert to seconds (so it fits in a DWORD)
            RtlTimeToSecondsSince1970 (&BasicInfo.LastWriteTime,
                                       &ultmp);

            RtlInitUnicodeString(&UniString,
                                 pwch);

            // Write it out the .ini file name and the last write time
            Status = NtSetValueKey(hKey,
                                   &UniString,
                                   0,
                                   REG_DWORD,
                                   &ultmp,
                                   sizeof(ultmp));
        }
        // Close the registry key
        NtClose(hKey);
    }

    return(NT_SUCCESS(Status));
}
/**********************************************************************
*
*  BOOL TermsrvLogInstallIniFileEx( WCHAR *pDosFileName )
*
*  This wraps TermsrvLogInstallIniFile() for dos name files instead of
*  NT-file-objects
*
*  The file name must have the full path since func will try to get
*  access time for that file.
*
*  EXIT:
*    TRUE  - Success
*    FALSE - Failure
**********************************************************************/

BOOL TermsrvLogInstallIniFileEx( WCHAR *pDosFileName )
{
    UNICODE_STRING uniString;

    BOOL rc= FALSE;

    if ( RtlDosPathNameToNtPathName_U( pDosFileName, &uniString, 0, 0 ) )
    {
        if ( rc = TermsrvLogInstallIniFile( & uniString ) )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, uniString.Buffer );
        }
    }

    return rc;
}

/**********************************************************************
*
*  GetFullKeyPath()
*  
*  PURPOSE: 
*              Creates full key path given the key handle and subkey name.
*  
*  PARAMETERS: 
*              IN HANDLE hKeyParent - key handle 
*              IN LPCWSTR wszKey    - subkey name (may be NULL)
*              OUT LPWSTR *pwszKeyPath - on return contains a full key path
*              (caller must freee allocated memory with LocalFree()).
*
*  EXIT: NTSTATUS
*    
**********************************************************************/
NTSTATUS 
GetFullKeyPath(
        IN HANDLE hKeyParent,
        IN LPCWSTR wszKey,
        OUT LPWSTR *pwszKeyPath)
{
    NTSTATUS Status = STATUS_NO_MEMORY;
    PKEY_NAME_INFORMATION pNameInfo;
    ULONG cbSize = 0;
    
    *pwszKeyPath = NULL;

    cbSize = sizeof(KEY_NAME_INFORMATION) + MAX_PATH*sizeof(WCHAR);

    pNameInfo = (PKEY_NAME_INFORMATION) LocalAlloc(LPTR, cbSize);

    if(pNameInfo)
    {
        Status = NtQueryKey(
                        hKeyParent,
                        KeyNameInformation,
                        pNameInfo,
                        cbSize,
                        &cbSize);

        if(Status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pNameInfo);
            pNameInfo = (PKEY_NAME_INFORMATION) LocalAlloc(LPTR, cbSize);
            
            if(pNameInfo)
            {
                Status = NtQueryKey(
                            hKeyParent,
                            KeyNameInformation,
                            pNameInfo,
                            cbSize,
                            &cbSize);
            }
            else
            {
                return STATUS_NO_MEMORY;
            }
        }

        if(NT_SUCCESS(Status))
        {
            cbSize = pNameInfo->NameLength + sizeof(WCHAR);
            if(wszKey)
            {
                cbSize += wcslen(wszKey)*sizeof(WCHAR) + sizeof(L'\\');
            }
            
            *pwszKeyPath = (LPWSTR) LocalAlloc(LPTR, cbSize);

            if(*pwszKeyPath)
            {
                memcpy(*pwszKeyPath,pNameInfo->Name,pNameInfo->NameLength);
                (*pwszKeyPath)[pNameInfo->NameLength/sizeof(WCHAR)] = 0;
                
                if(wszKey)
                {
                    wcscat(*pwszKeyPath,L"\\");
                    wcscat(*pwszKeyPath,wszKey);
                }
            }
            else
            {
                Status = STATUS_NO_MEMORY;
            }
        }

        LocalFree(pNameInfo);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\syslib\winsta.c ===
/*************************************************************************
*
* winsta.c
*
* System Library WinStation utilities
*
*  This file contains common routines needed in many places in the
*  system. An example is that (3) separate DLL's in the spooler need
*  functions to deal with the current user of a WinStation. IE: Get
*  name, find which LogonId, get name by logonid, etc.
*
*  This common library at least keeps the source management in one
*  place. This is likely to become another Hydra DLL's in the future
*  to reduce memory.
*
*
*
*
*************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include "winsta.h"
#include "syslib.h"

#pragma warning (error:4312)

#if DBG
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


//
// Structure for FindUserOnWinStation
//
typedef struct _FINDUSERDATA {
    LPWSTR   pName;
    ULONG    ResultLogonId;
} FINDUSERDATA, *PFINDUSERDATA;


/*****************************************************************************
 *
 *  WinStationGetUserName
 *
 *   Return the user name for the WinStation
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
WinStationGetUserName(
    ULONG  LogonId,
    PWCHAR pBuf,
    ULONG  BufSize
    )
{
    BOOL Result;
    ULONG ReturnLength;
    WINSTATIONINFORMATION WSInfo;

    memset( &WSInfo, 0, sizeof(WSInfo) );

    // Query it
    Result = WinStationQueryInformation(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationInformation,
                 &WSInfo,
                 sizeof(WSInfo),
                 &ReturnLength
                 );

    if( !Result ) {
        DBGPRINT(("GetWinStationInfo: Error %d getting info on WinStation %d\n",GetLastError(),LogonId));
        return( FALSE );
    }

    // Scale BufSize to UNICODE characters
    if( BufSize >= sizeof(WCHAR) ) {
        BufSize /= sizeof(WCHAR);
    }
    else {
        BufSize = 0;
    }

    if( (BufSize > 1) && WSInfo.UserName[0] ) {
        wcsncpy( pBuf, WSInfo.UserName, BufSize );
        pBuf[BufSize-1] = (WCHAR)NULL;
    }
    else {
        pBuf[0] = (WCHAR)NULL;
    }

    return( TRUE );
}


/*****************************************************************************
 *
 *  SearchUserCallback
 *
 *   Callback for search function
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
SearchUserCallback(
    ULONG CurrentIndex,
    PLOGONIDW pInfo,
    ULONG_PTR lParam
    )
{
    BOOL Result;
    PFINDUSERDATA p;
    WCHAR UserName[USERNAME_LENGTH+1];

    // Only active WinStations are valid
    if( pInfo->State != State_Active ) {
        // continue the search
        return( TRUE );
    }

    // Check the user on the WinStation
    Result = WinStationGetUserName( pInfo->LogonId, UserName, sizeof(UserName) );
    if( !Result ) {
        DBGPRINT(("SearchUserCallback: Error getting WinStation User Name LogonId %d\n",pInfo->LogonId,GetLastError()));
        // continue the search
        return( TRUE );
    }

    p = (PFINDUSERDATA)lParam;

    if( _wcsicmp(p->pName, UserName) == 0 ) {
        TRACE0(("SearchUserCallback: Found username %ws on WinStation LogonId %d\n",UserName,pInfo->LogonId));
        // Found it, return the LogonId
        p->ResultLogonId = pInfo->LogonId;
        // Stop the search
        return( FALSE );
    }

    // continue the search
    return( TRUE );
}

/*****************************************************************************
 *
 *  FindUsersWinStation
 *
 *  Find the given users WinStation.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
FindUsersWinStation(
    PWCHAR   pName,
    PULONG   pLogonId
    )
{
    BOOL Result;
    FINDUSERDATA Data;

    ASSERT( pLogonId != NULL );

    // If a NULL name, we are not going to find it.
    if( (pName == NULL) ||
        (pName[0] == (WCHAR)NULL) ) {
        TRACE0(("FindUsersWinStation: NULL user name\n"));
        return( FALSE );
    }

    Data.ResultLogonId = (ULONG)(-1);
    Data.pName = pName;

    //
    // Use the WinStation Enumerator to check all the WinStations
    //
    Result = WinStationEnumeratorW(
                 0,                        // StartIndex
                 SearchUserCallback,       // enumerator callback function
                 (ULONG_PTR)&Data              // lParam is our structure
                 );

    if( !Result ) {
        // Problem with enumerator
        DBGPRINT(("FindUsersWinStation: Problem with enumerator\n"));
        return(FALSE);
    }

    //
    // If ResultLogonId != (-1), a WinStation was found for the user
    //
    if( Data.ResultLogonId != (ULONG)(-1) ) {
        TRACE0(("FindUsersWinStation: Found LogonId %d\n",Data.ResultLogonId));
        *pLogonId = Data.ResultLogonId;
        return(TRUE);
    }

    TRACE0(("FindUsersWinStation: Could not find user %ws\n",pName));
    return(FALSE);
}


/*****************************************************************************
 *
 *  WinStationGetIcaNameA
 *
 *   ANSI version
 *
 *   Get the ICA name from the supplied WinStations Logonid
 *
 *   Returns it in newly allocated memory that must be freed with
 *   RtlFreeHeap().
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PCHAR
WinStationGetICANameA(
    ULONG LogonId
    )
{
    BOOL   Result;
    ULONG ReturnLength;
    PCHAR pName = NULL;
    WINSTATIONCLIENTA ClientInfo;
    WINSTATIONINFORMATIONA WSInfo;
    CHAR NameBuf[MAX_PATH+1];

    memset( &WSInfo, 0, sizeof(WSInfo) );

    Result = WinStationQueryInformationA(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationInformation,
                 &WSInfo,
                 sizeof(WSInfo),
                 &ReturnLength
                 );

    if( !Result ) {
        DBGPRINT(("GetWinStationICANameA: Error %d getting info on WinStation\n",GetLastError()));
        return( NULL );
    }

    memset( &ClientInfo, 0, sizeof(ClientInfo) );

    // Query its Info
    Result = WinStationQueryInformationA(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationClient,
                 &ClientInfo,
                 sizeof(ClientInfo),
                 &ReturnLength
                 );

    if( !Result ) {
        DBGPRINT(("GetWinStationICANameA: Error %d getting client info\n",GetLastError()));
        return( NULL );
    }

    //
    // If the ClientName is NULL, then we use the user
    // as the ICA name.
    //
    if( ClientInfo.ClientName[0] == (CHAR)NULL ) {
#ifdef notdef // spec change...
            if( ClientInfo.SerialNumber )
                wsprintf( NameBuf, L"%ws-%d", WSInfo.UserName, ClientInfo.SerialNumber);
            else
#endif
            sprintf( NameBuf, "%s", WSInfo.UserName);

    }
    else {
        // copy out the Client name
        strcpy( NameBuf, ClientInfo.ClientName );
    }

    ReturnLength = strlen( NameBuf ) + 1;

    pName = RtlAllocateHeap( RtlProcessHeap(), 0, ReturnLength );
    if( pName == NULL ) {
        return( NULL );
    }

    strcpy( pName, NameBuf );

    return( pName );
}


/*****************************************************************************
 *
 *  WinStationGetIcaNameW
 *
 *   UNICODE Version
 *
 *   Get the ICA name from the supplied WinStations Logonid
 *
 *   Returns it in newly allocated memory that must be freed with
 *   RtlFreeHeap().
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PWCHAR
WinStationGetICANameW(
    ULONG LogonId
    )
{
    BOOL   Result;
    ULONG ReturnLength;
    PWCHAR pName = NULL;
    WINSTATIONCLIENT ClientInfo;
    WINSTATIONINFORMATION WSInfo;
    WCHAR NameBuf[MAX_PATH+1];

    memset( &WSInfo, 0, sizeof(WSInfo) );

    Result = WinStationQueryInformationW(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationInformation,
                 &WSInfo,
                 sizeof(WSInfo),
                 &ReturnLength
                 );

    if( !Result ) {
        DBGPRINT(("GetWinStationICANameW: Error %d getting info on WinStation\n",GetLastError()));
        return( NULL );
    }

    memset( &ClientInfo, 0, sizeof(ClientInfo) );

    // Query its Info
    Result = WinStationQueryInformationW(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationClient,
                 &ClientInfo,
                 sizeof(ClientInfo),
                 &ReturnLength
                 );

    if( !Result ) {
        DBGPRINT(("GetWinStationICANameW: Error %d getting client info\n",GetLastError()));
        return( NULL );
    }

    //
    // If the ClientName is NULL, then we use the user
    // as the ICA name.
    //
    if( ClientInfo.ClientName[0] == (WCHAR)NULL ) {
#ifdef notdef // spec change...
            if( ClientInfo.SerialNumber )
                wsprintf( NameBuf, L"%ws-%d", WSInfo.UserName, ClientInfo.SerialNumber);
            else
#endif
            wsprintf( NameBuf, L"%ws", WSInfo.UserName);

    }
    else {
        // copy out the Client name
        wcscpy( NameBuf, ClientInfo.ClientName );
    }

    ReturnLength = wcslen( NameBuf ) + 1;
    ReturnLength *= sizeof(WCHAR);

    pName = RtlAllocateHeap( RtlProcessHeap(), 0, ReturnLength );
    if( pName == NULL ) {
        return( NULL );
    }

    wcscpy( pName, NameBuf );

    return( pName );
}


/*****************************************************************************
 *
 *  WinStationIsHardWire
 *
 *   Returns whether the WinStation is hardwired. IE: No modem
 *   or network. Like a dumb terminal.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN
WinStationIsHardWire(
    ULONG LogonId
    )
{
    return( FALSE );
}

/*****************************************************************************
 *
 *  GetWinStationUserToken
 *
 *   Return the token for the user currently logged onto the WinStation
 *
 * ENTRY:
 *   LogonId (input)
 *     LogonId of WinStation
 *
 *   pUserToken (output)
 *     Variable to place the returned token handle if successfull.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
GetWinStationUserToken(
    ULONG LogonId,
    PHANDLE pUserToken
    )
{
    BOOL   Result;
    ULONG  ReturnLength;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE ImpersonationToken;
    WINSTATIONUSERTOKEN Info;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;


    //
    // This gets the token of the user logged onto the WinStation
    // if we are an admin caller.
    //

    // This is so that CSRSS can dup the handle to our process
    Info.ProcessId = LongToHandle(GetCurrentProcessId());
    Info.ThreadId = LongToHandle(GetCurrentThreadId());

    Result = WinStationQueryInformation(
                 SERVERNAME_CURRENT,
                 LogonId,
                 WinStationUserToken,
                 &Info,
                 sizeof(Info),
                 &ReturnLength
                 );

    if( !Result ) {
        DBGPRINT(("GetWinStationUserToken: Error %d getting UserToken LogonId %d\n",GetLastError(),LogonId));
        return( FALSE );
    }

    //
    // The token returned is a duplicate of a primary token.
    //
    // We must make it into an IMPERSONATION TOKEN or the
    // AccessCheck() routine will fail since it only operates
    // against impersonation tokens.
    //

    InitializeObjectAttributes( &ObjA, NULL, 0L, NULL, NULL );

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjA.SecurityQualityOfService = &SecurityQualityOfService;

    Status = NtDuplicateToken( Info.UserToken,
                               0, // inherit granted accesses TOKEN_IMPERSONATE
                               &ObjA,
                               FALSE,
                               TokenImpersonation,
                               &ImpersonationToken );

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("GetWinStationUserToken: Error %d duping UserToken to impersonation LogonId %d\n",GetLastError(),LogonId));
        NtClose( Info.UserToken );
        return( FALSE );
    }

    // return the impersonation token
    *pUserToken = ImpersonationToken;

    NtClose( Info.UserToken );

    return( TRUE );
}

//
// This is not in winnt.h, but in ntseapi.h which we can not
// include readily since we are a WIN32 program as we 'hide' this
// new information type from WIN32 programs.
//

/*****************************************************************************
 *
 *  GetClientLogonId
 *
 *   Get the logonid from the client who we should be impersonating. If any
 *   errors, we return 0 to mean the Console Logon Id since this may be a
 *   remote network call.
 *
 * ENTRY:
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

ULONG
GetClientLogonId()
{
    BOOL          Result;
    HANDLE        TokenHandle;
    ULONG         LogonId, ReturnLength;

    //
    // We should be impersonating the client, so we will get the
    // LogonId from out token.
    //
    // We may not have a valid one if this is a remote network
    // connection.

    Result = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_QUERY,
                 FALSE,              // Use impersonation
                 &TokenHandle
                 );

    if( Result ) {

        // This identifies which WinStation is making this request.
        //

        Result = GetTokenInformation(
                     TokenHandle,
                     TokenSessionId,
                     &LogonId,
                     sizeof(LogonId),
                     &ReturnLength
                     );

        if( Result ) {
#if DBG
            if( ReturnLength != sizeof(LogonId) ) {
                DbgPrint("LOCALSPOOL: CompleteRead: ReturnLength %d != sizeof(LogonId)\n", ReturnLength );
            }
#endif
        }
        else {
            DBGPRINT(("SYSLIB: Error getting token information %d\n", GetLastError()));
            LogonId = 0; // Default to console
        }
        CloseHandle( TokenHandle );
    }
    else {
        TRACE0(("SYSLIB: Error opening token %d\n", GetLastError()));
        LogonId = 0;
    }

    return( LogonId );
}

/*****************************************************************************
 *
 *  WinStationEnumeratorW
 *
 *   Enumerator for WinStations
 *
 * ENTRY:
 *   StartIndex (input)
 *     WinStation Index to start Enumeration at
 *
 *   pProc (input)
 *     Pointer to function that gets called for each WinStation
 *     entry.
 *
 *     EXAMPLE:
 *
 *     BOOLEAN
 *     EnumCallBack(
 *         ULONG CurrentIndex,   // Current Index of this entry
 *         PLOGONIDW pInfo,      // WinStation Entry
 *         ULONG_PTR lParam      // Passed through from caller of WinStationEnumeratorW
 *         );
 *
 *     If the EnumCallback function returns TRUE, the WinStationEnumeratorW()
 *     continues the search. If it returns FALSE, the search is stopped.
 *
 *   lParam (input)
 *     Caller supplied argument passed through to caller supplied function
 *
 * EXIT:
 *   TRUE  - no error
 *   FALSE - Error
 *
 ****************************************************************************/

BOOLEAN
WinStationEnumeratorW(
    ULONG StartIndex,
    WINSTATIONENUMPROC pProc,
    ULONG_PTR lParam
    )
{
    BOOLEAN Result;
    ULONG Entries, i;
    ULONG ByteCount, ReqByteCount, Index;
    ULONG Error, CurrentIndex;
    PLOGONIDW ptr;
    ULONG QuerySize = 32;
    PLOGONIDW SmNameCache = NULL;   // WinStation namelist

    Index = StartIndex;
    CurrentIndex = StartIndex;

    Entries = QuerySize;
    ByteCount = Entries * sizeof( LOGONIDW );
    SmNameCache = (PLOGONIDW)RtlAllocateHeap( RtlProcessHeap(), 0, ByteCount );
    if ( SmNameCache == NULL )
        return(FALSE);

    while( 1 ) {

        ReqByteCount = ByteCount;
        ptr = SmNameCache;
        Result = WinStationEnumerate_IndexedW( SERVERNAME_CURRENT, &Entries, ptr, &ByteCount, &Index );

        if( !Result ) {
            Error = GetLastError();
            if( Error == ERROR_NO_MORE_ITEMS ) {
                // Done
                RtlFreeHeap( RtlProcessHeap(), 0, SmNameCache );
                return(TRUE);
            }
            else if( Error == ERROR_ALLOTTED_SPACE_EXCEEDED ) {
                // Entries contains the maximum query size
                if( QuerySize <= Entries ) {
                    DBGPRINT(("CPMMON: SM Query Size < RetCapable. ?View Memory Leak? Query %d, Capable %d\n", QuerySize, Entries ));
                    QuerySize--; // See when it recovers. On retail, it will still work.
                }
                else {
                    // We asked for more than it can handle
                    QuerySize = Entries;
                }

                Entries = QuerySize;
                ByteCount = Entries * sizeof( LOGONIDW );
                SmNameCache = (PLOGONIDW)RtlReAllocateHeap( RtlProcessHeap(), 0,
                                                            SmNameCache, ByteCount );
                if ( SmNameCache == NULL )
                    return(FALSE);

                continue;
            }
            else {
                // Other error
                DBGPRINT(("CPMMON: Error emumerating WinStations %d\n",Error));
                RtlFreeHeap( RtlProcessHeap(), 0, SmNameCache );
                return(FALSE);
            }
        }

        ASSERT( ByteCount <= ReqByteCount );

        // We got some entries, now call the enumerator function

        for( i=0; i < Entries; i++ ) {
            Result = pProc( CurrentIndex, &SmNameCache[i], lParam );
            CurrentIndex++;
            if( !Result ) {
                // The Enumerator proc wants us to stop the search
                RtlFreeHeap( RtlProcessHeap(), 0, SmNameCache );
                return(TRUE);
            }
        }
    } // Outer while

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\compatfl.c ===
/*************************************************************************
* compatfl.c
*
* Routines used to get Citrix application compatibility flags
*
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

typedef VOID (*GETDOSAPPNAME)(LPSTR);

ULONG gCompatFlags = 0xFFFFFFFF;
DWORD gpTermsrvTlsIndex = 0xFFFFFFFF;



WCHAR *
Ctx_wcsistr( WCHAR * pString, WCHAR * pPattern )
{
    WCHAR * pBuf1;
    WCHAR * pBuf2;
    WCHAR * pCh;

    if ( pString == NULL )
        return( NULL );

    pBuf1 = RtlAllocateHeap( RtlProcessHeap(), 0, (wcslen(pString) * sizeof(WCHAR)) + sizeof(WCHAR) );
    if ( pBuf1 == NULL )
        return( NULL );

    wcscpy( pBuf1, pString );

    pBuf2 = _wcslwr( pBuf1 );

    pCh = wcsstr( pBuf2, pPattern );

    RtlFreeHeap( RtlProcessHeap(), 0, pBuf1 );

    if ( pCh == NULL )
        return( NULL );

    return( pString + (pCh - pBuf2) );
}

//*****************************************************************************
// GetAppTypeAndModName
//
//    Returns the application type and module name of the running application.
//
//    Parameters:
//      LPDWORD pdwAppType     (IN)  - (IN optional) ptr to app type
//                             (OUT) - Application Type
//      PWCHAR ModName         (OUT) - Module Name
//      Length                 (IN)  - Maximum length of ModName including NULL
//
//    Return Value:
//      TRUE on successfully finding the application name, FALSE otherwise.
//
//    Notes:
//
//      If the caller knows that this is a win32 app, they can set pdwAppType
//      to TERMSRV_COMPAT_WIN32 to save some overhead.
//
//*****************************************************************************

BOOL GetAppTypeAndModName(OUT LPDWORD pdwAppType, OUT PWCHAR ModName, ULONG Length)
{
    PWCHAR  pwch, pwchext;
    WCHAR   pwcAppName[MAX_PATH+1];
    CHAR    pszAppName[MAX_PATH+1];
    HANDLE  ntvdm = NULL;
    GETDOSAPPNAME GetDOSAppNamep = NULL;
    ANSI_STRING   AnsiString;
    UNICODE_STRING UniString;
    PRTL_PERTHREAD_CURDIR  pRtlInfo;
    PRTL_USER_PROCESS_PARAMETERS pUserParam;

    // Get the path of the executable name
    pUserParam = NtCurrentPeb()->ProcessParameters;

    // Get the executable name, if there's no \ just use the name as it is
    pwch = wcsrchr(pUserParam->ImagePathName.Buffer, L'\\');
    if (pwch) {
        pwch++;
    } else {
        pwch = pUserParam->ImagePathName.Buffer;
    }
    wcscpy(pwcAppName, pwch);
    pwch = pwcAppName;

    // If it's not a Win32 app, do the extra work to get the image name
    if (!(*pdwAppType & TERMSRV_COMPAT_WIN32)) {

        *pdwAppType = TERMSRV_COMPAT_WIN32;  // Default to a Win32 app

        // Check if it's a DOS or Win16 app by checking if the app is ntvdm.exe
        if (!_wcsicmp(pwch, L"ntvdm.exe")) {
            pRtlInfo = RtlGetPerThreadCurdir();

            // If there's per-thread data, it's a Win16 app
            if (pRtlInfo) {
                *pdwAppType = TERMSRV_COMPAT_WIN16;
                wcscpy(pwcAppName, pRtlInfo->ImageName->Buffer);
            } else {
                // Load NTVDM
                if ((ntvdm = LoadLibrary(L"ntvdm.exe"))) {

                    // Get the address of GetDOSAppName
                    if ((GetDOSAppNamep = (GETDOSAPPNAME)GetProcAddress(
                                                          ntvdm,
                                                          "GetDOSAppName"))) {
                        RtlInitUnicodeString(&UniString, pwcAppName);
                        UniString.MaximumLength = MAX_PATH;


                        //
                        // Use pszAppName only if not NULL otherwise we are processing the PIF
                        // so go w/ NTVDM as the name.
                        //
                        GetDOSAppNamep(pszAppName);

                        if (*pszAppName != '\0') {
                           RtlInitAnsiString(&AnsiString, pszAppName);
                           RtlAnsiStringToUnicodeString(&UniString,
                                                        &AnsiString,
                                                        FALSE);
                        }
                        pwch = UniString.Buffer;
                        *pdwAppType = TERMSRV_COMPAT_DOS;
                        FreeLibrary(ntvdm);
                    } else {
#if DBG
                        DbgPrint( "KERNEL32: Couldn't get GetDOSAppName entry point\n" );
#endif
                        FreeLibrary(ntvdm);
                        return (FALSE);
                    }
                } else {
#if DBG
                    DbgPrint( "KERNEL32: Couldn't load ntvdm.exe\n" );
#endif
                    return(FALSE);
                }
            }
        } else if (!_wcsicmp(pwch, L"os2.exe")) {

            *pdwAppType = TERMSRV_COMPAT_OS2;

            // Look in the command line for /p, which is fully qualified path
            pwch = wcsstr(pUserParam->CommandLine.Buffer, L"/P");

            if (!pwch) {
                pwch = wcsstr(pUserParam->CommandLine.Buffer, L"/p");
            }

            if (pwch) {
                pwch += 3;          // skip over /p and blank
                if (pwchext = wcschr(pwch, L' ')) {
                    wcsncpy(pwcAppName, pwch, (size_t)(pwchext - pwch));
                    pwcAppName[pwchext - pwch] = L'\0';
                } else {
                    return (FALSE);
                }
            } else{
                return (FALSE);
            }
        }

        // Get rid of the app's path, if necessary
        if (pwch = wcsrchr(pwcAppName, L'\\')) {
            pwch++;
        } else {
            pwch = pwcAppName;
        }
    }

    // Remove the extension
    if (pwchext = wcsrchr(pwch, L'.')) {
        *pwchext = '\0';
    }

    // Copy out the Module name
    if (((wcslen(pwch) + 1) * sizeof(WCHAR)) > Length) {
        return(FALSE);
    }

    wcscpy(ModName, pwch);
    return(TRUE);

}

//*****************************************************************************
// GetCtxPhysMemoryLimits
//
//    Returns the Physical Memory limits for the current application.
//
//    Parameters:
//      LPDWORD pdwAppType     (IN)  - (IN optional) ptr to app type
//                             (OUT) - Application Type
//      LPDWORD pdwPhysMemLim  (OUT) - Value of physical memory limit
//
//    Return Value:
//      TRUE on successfully finding a limit, ZERO if no limit.
//
//    Notes:
//
//      If the caller knows that this is a win32 app, they can set pdwAppType
//      to TERMSRV_COMPAT_WIN32 to save some overhead.
//
//*****************************************************************************
ULONG GetCtxPhysMemoryLimits(OUT LPDWORD pdwAppType, OUT LPDWORD pdwPhysMemLim)
{
    WCHAR   ModName[MAX_PATH+1];
    ULONG   ulrc = FALSE;
    ULONG dwCompatFlags;

    *pdwPhysMemLim = 0;

    if (!GetAppTypeAndModName(pdwAppType, ModName, sizeof(ModName))) {
        goto CtxGetPhysMemReturn;
    }

    // Get the compatibility flags to look for memory limits flag
    ulrc = GetTermsrCompatFlags(ModName, &dwCompatFlags, CompatibilityApp);
    if ( ulrc & ((dwCompatFlags & TERMSRV_COMPAT_PHYSMEMLIM ) &&
                  (dwCompatFlags & *pdwAppType)) ) {

        NTSTATUS NtStatus;
        OBJECT_ATTRIBUTES ObjectAttributes;
        UNICODE_STRING UniString;
        HKEY   hKey = 0;
        ULONG  ul, ulcbuf;
        ULONG  DataLen;
        PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;
        LPWSTR UniBuff = NULL;

        RtlInitUnicodeString( &UniString, NULL ); // we test for this below
        ulrc = TRUE;
        *pdwPhysMemLim = TERMSRV_COMPAT_DEFAULT_PHYSMEMLIM;

        ul = sizeof(TERMSRV_COMPAT_APP) + (wcslen(ModName) + 1)*sizeof(WCHAR);

        UniBuff = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ul);

        if (UniBuff) {
            wcscpy(UniBuff, TERMSRV_COMPAT_APP);
            wcscat(UniBuff, ModName);

            RtlInitUnicodeString(&UniString, UniBuff);
        }

        // Determine the value info buffer size
        ulcbuf = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
                 sizeof(ULONG);

        pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                      0,
                                      ulcbuf);

        // Did everything initialize OK?
        if (UniString.Buffer && pKeyValInfo) {
            InitializeObjectAttributes(&ObjectAttributes,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL
                                      );

            NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

            if (NT_SUCCESS(NtStatus)) {

                RtlInitUnicodeString(&UniString, TERMSRV_PHYSMEMLIM );
                NtStatus = NtQueryValueKey(hKey,
                                           &UniString,
                                           KeyValuePartialInformation,
                                           pKeyValInfo,
                                           ulcbuf,
                                           &DataLen);

                if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type)) {
                    *pdwPhysMemLim = *(PULONG)pKeyValInfo->Data;
                    ulrc = TRUE;
                }
                NtClose(hKey);
            }
        }
        // Free up the buffers we allocated
        // Need to zero out the buffers, because some apps (MS Internet Assistant)
        // won't install if the heap is not zero filled.
        if (UniBuff) {
            memset(UniBuff, 0, ul);
            RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
        }
        if (pKeyValInfo) {
            memset(pKeyValInfo, 0, ulcbuf);
            RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
        }
    }
    else {
        ulrc = FALSE;
    }

CtxGetPhysMemReturn:
//#if DBG
//DbgPrint("CtxGetPhysMemLim returning %d; PhysMemLim=%d\n", ulrc, *pdwPhysMemLim);
//#endif
    return(ulrc);
}


//*****************************************************************************
// GetCtxAppCompatFlags -
//
//    Returns the Citrix compatibility flags for the current application.
//
//    Parameters:
//      LPDWORD pdwCompatFlags (OUT) - Ptr to DWORD return value for flags
//      LPDWORD pdwAppType     (IN)  - (IN optional) ptr to app type
//                             (OUT) - Application Type
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    Notes:
//
//      If the caller knows that this is a win32 app, they can set pdwAppType
//      to TERMSRV_COMPAT_WIN32 to save some overhead.
//
//    Flag values are defined in syslib.h:
//
//      TERMSRV_COMPAT_DOS      - Compatibility flags are for DOS app
//      TERMSRV_COMPAT_OS2      - Compatibility flags are for OS2 app
//      TERMSRV_COMPAT_WIN16    - Compatibility flags are for Win16 app
//      TERMSRV_COMPAT_WIN32    - Compatibility flags are for Win32 app
//      TERMSRV_COMPAT_ALL      - Compatibility flags are for any app
//      TERMSRV_COMPAT_USERNAME - Return Username instead of Computername
//      TERMSRV_COMPAT_MSBLDNUM - Return MS build number, not Citrix build no.
//      TERMSRV_COMPAT_INISYNC  - Sync user ini file with system version
//*****************************************************************************
ULONG GetCtxAppCompatFlags(OUT LPDWORD pdwCompatFlags, OUT LPDWORD pdwAppType)
{
    WCHAR   ModName[MAX_PATH+1];

    if (gCompatFlags != 0xFFFFFFFF) {
        //DbgPrint( "GetCtxAppCompatFlags: Return cached compatflags %lx\n",gCompatFlags );
        if (!(*pdwAppType & TERMSRV_COMPAT_WIN32)) {
            *pdwAppType = TERMSRV_COMPAT_WIN32;  // Default to a Win32 app
        }
        *pdwCompatFlags = gCompatFlags;
        return TRUE;
    }

    if (!GetAppTypeAndModName(pdwAppType, ModName, sizeof(ModName))) {
        return (FALSE);
    }

    // Get the flags

    return (GetTermsrCompatFlags(ModName, pdwCompatFlags, CompatibilityApp));
}


//*****************************************************************************
// GetTermsrCompatFlags -
//
//    Returns the Citrix compatibility flags for the specified task.
//
//    Parameters:
//      LPWSTR  lpModName      (IN)  - Image name to look up in registry
//      LPDWORD pdwCompatFlags (OUT) - Ptr to DWORD return value for flags
//      TERMSRV_COMPATIBILITY_CLASS CompatType (IN) - Indicates app or inifile
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    Notes:
//      Assumes it's being called in the context of the current application -
//      we use the current Teb to get the compatibility flags.
//
//      Flag values are defined in syslib.h.
//
//*****************************************************************************

ULONG GetTermsrCompatFlags(LPWSTR lpModName,
                           LPDWORD pdwCompatFlags,
                           TERMSRV_COMPATIBILITY_CLASS CompatType)
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UniString;
    HKEY   hKey = 0;
    ULONG  ul, ulcbuf;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;
    ULONG  ulRetCode = FALSE;
    LPWSTR UniBuff = NULL;

    *pdwCompatFlags = 0;

    // If terminal services aren't enabled, just return
    if (!IsTerminalServer()) {
        return(TRUE);
    }

    UniString.Buffer = NULL;

    if (CompatType == CompatibilityApp) {

        if (gCompatFlags != 0xFFFFFFFF) {
            //DbgPrint( "GetTermsrCompatFlags: Return cached compatflags (gCompatFlags)%lx for app %ws\n",gCompatFlags,lpModName );
            *pdwCompatFlags = gCompatFlags;
            return TRUE;
        }

        // Look and see if the compat flags in the Teb are valid (right now
        // they're only valid for Win16 apps).  Don't set them for DOS apps
        // unless you can have a mechanism to have unique values for each
        // DOS app in a VDM.
//      if (wcsstr(NtCurrentPeb()->ProcessParameters->ImagePathName.Buffer, L"ntvdm.exe")) {
//          PVOID Ra;
//          ASSERT(gpTermsrvTlsIndex != 0xFFFFFFFF);
//          Ra = TlsGetValue( gpTermsrvTlsIndex );
//          if (Ra != NULL) {
//              //DbgPrint( "GetTermsrCompatFlags: Return cached compatflags (Ra)%lx for app %ws\n",Ra,lpModName );
//              *pdwCompatFlags = (DWORD)PtrToUlong(Ra);
//              return TRUE;
//          }
//      }
#if 0
        if (NtCurrentTeb()->CtxCompatFlags & TERMSRV_COMPAT_TEBVALID) {
            *pdwCompatFlags = NtCurrentTeb()->CtxCompatFlags;
            return(TRUE);
        }
#endif

        ul = sizeof(TERMSRV_COMPAT_APP) + (wcslen(lpModName) + 1)*sizeof(WCHAR);

        UniBuff = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ul);

        if (UniBuff) {
            wcscpy(UniBuff, TERMSRV_COMPAT_APP);
            wcscat(UniBuff, lpModName);

            RtlInitUnicodeString(&UniString, UniBuff);
        }
    } else {
        RtlInitUnicodeString(&UniString,
                             (CompatType == CompatibilityIniFile) ?
                             TERMSRV_COMPAT_INIFILE : TERMSRV_COMPAT_REGENTRY
                            );
    }

    // Determine the value info buffer size
    ulcbuf = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
             sizeof(ULONG);

    pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ulcbuf);

    // Did everything initialize OK?
    if (UniString.Buffer && pKeyValInfo) {
        InitializeObjectAttributes(&ObjectAttributes,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(NtStatus)) {

            // If we're not checking for a registry entry, just try to get
            // the value for the key
            if (CompatType != CompatibilityRegEntry) {
                RtlInitUnicodeString(&UniString,
                    CompatType == CompatibilityApp ? COMPAT_FLAGS : lpModName);
                NtStatus = NtQueryValueKey(hKey,
                                           &UniString,
                                           KeyValuePartialInformation,
                                           pKeyValInfo,
                                           ulcbuf,
                                           &ul);

                if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type)) {
                    *pdwCompatFlags = *(PULONG)pKeyValInfo->Data;
                    ulRetCode = TRUE;
                }


                //
                // Cache the appcompatiblity flags
                //
//              if (CompatType == CompatibilityApp) {
//                  if (wcsstr(NtCurrentPeb()->ProcessParameters->ImagePathName.Buffer, L"ntvdm.exe")) {
//                      TlsSetValue(gpTermsrvTlsIndex,(PVOID)((*pdwCompatFlags)| TERMSRV_COMPAT_TEBVALID));
//                      //DbgPrint( "GetTermsrCompatFlags: Setting cached compatflags (gCompatFlags)%lx for WOW app %ws\n",((*pdwCompatFlags)| TERMSRV_COMPAT_TEBVALID),lpModName );
//                  } else {
//                      gCompatFlags = *pdwCompatFlags;
//                      //DbgPrint( "GetTermsrCompatFlags: Setting cached compatflags (gCompatFlags)%lx for app %ws\n",gCompatFlags,lpModName );
//                  }
//              }



            // For registry keys, we need to enumerate all of the keys, and
            // check if the the substring matches our current path.
            } else {
                PWCH pwch;
                ULONG ulKey = 0;
                PKEY_VALUE_FULL_INFORMATION pKeyFullInfo;

                pKeyFullInfo = (PKEY_VALUE_FULL_INFORMATION)pKeyValInfo;

                // Get to the software section
                pwch = Ctx_wcsistr(lpModName, L"\\software");

                // Skip past the next backslash
                if (pwch) {
                    pwch = wcschr(pwch + 1, L'\\');
                }

                // We don't need to look for a key if this isn't in the user
                // software section
                if (pwch) {

                    // Skip over the leading backslash
                    pwch++;

                    // Go through each value, looking for this path
                    while (NtEnumerateValueKey(hKey,
                                               ulKey++,
                                               KeyValueFullInformation,
                                               pKeyFullInfo,
                                               ulcbuf,
                                               &ul) == STATUS_SUCCESS) {

                        if (!_wcsnicmp(pKeyFullInfo->Name,
                                      pwch,
                                      pKeyFullInfo->NameLength/sizeof(WCHAR))) {
                            *pdwCompatFlags = *(PULONG)((PCHAR)pKeyFullInfo +
                                                     pKeyFullInfo->DataOffset);
                            ulRetCode = TRUE;
                            break;
                        }
                    }
                }

            }
            NtClose(hKey);
        }
    }

    // Free up the buffers we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    if (UniBuff) {
        memset(UniBuff, 0, UniString.MaximumLength);
        RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
    }
    if (pKeyValInfo) {
        memset(pKeyValInfo, 0, ulcbuf);
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
    }

    return(ulRetCode);
}

//*****************************************************************************
// CtxGetBadAppFlags -
//
//    Gets the Citrix badapp and compatibility flags for the specified task.
//
//    Parameters:
//      LPWSTR  lpModName      (IN)  - Image name to look up in registry
//      PBADAPP pBadApp        (OUT) - Structure to used to return flags
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    Flag values are defined in syslib.h.
//
//*****************************************************************************

BOOL CtxGetBadAppFlags(LPWSTR lpModName, PBADAPP pBadApp)
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UniString;
    HKEY hKey = 0;
    ULONG ul, ulcnt, ulcbuf, ulrc = FALSE;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = NULL;
    LPWSTR UniBuff;
    PWCHAR pwch;
    static ULONG badappregdefaults[3] = {1,15,5};
    static BOOL  fgotdefaults = FALSE;
    WCHAR  *pbadappNameValue[] = {
                   COMPAT_MSGQBADAPPSLEEPTIMEINMILLISEC,
                                   COMPAT_FIRSTCOUNTMSGQPEEKSSLEEPBADAPP,
                                   COMPAT_NTHCOUNTMSGQPEEKSSLEEPBADAPP,
                                   COMPAT_FLAGS
                                 };


    // Get the executable name only, no path.
    pwch = wcsrchr(lpModName, L'\\');
    if (pwch) {
        pwch++;
    } else {
        pwch = lpModName;
    }

    // Get the buffers we need
    ul = sizeof(TERMSRV_COMPAT_APP) + (wcslen(pwch) + 1)*sizeof(WCHAR);

    UniBuff = RtlAllocateHeap(RtlProcessHeap(), 0, ul);

    ulcbuf = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG);

    pKeyValueInfo = RtlAllocateHeap(RtlProcessHeap(), 0, ulcbuf);

    if (UniBuff && pKeyValueInfo) {

        if (!fgotdefaults) {
            // Get the default values from the registry
            RtlInitUnicodeString(&UniString,
                TERMSRV_REG_CONTROL_NAME
                );

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL
                                      );

            NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

            if (NT_SUCCESS(NtStatus)) {

                for (ulcnt = 0; ulcnt < 3; ulcnt++) {

                    RtlInitUnicodeString(&UniString, pbadappNameValue[ulcnt]);
                    NtStatus = NtQueryValueKey(hKey,
                                               &UniString,
                                               KeyValuePartialInformation,
                                               pKeyValueInfo,
                                               ulcbuf,
                                               &ul);

                    if (NT_SUCCESS(NtStatus) &&
                        (REG_DWORD == pKeyValueInfo->Type)) {
                        badappregdefaults[ulcnt] = *(PULONG)pKeyValueInfo->Data;
                    }
                }
                NtClose(hKey);
            }
            fgotdefaults = TRUE;
        }

        wcscpy(UniBuff, TERMSRV_COMPAT_APP);
        wcscat(UniBuff, pwch);

        // Remove the extension
        if (pwch = wcsrchr(UniBuff, L'.')) {
            *pwch = '\0';
        }

        RtlInitUnicodeString(&UniString,
                             UniBuff
                            );

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(NtStatus)) {

            ulrc = TRUE;
            for (ulcnt = 0; ulcnt < 4; ulcnt++) {

                RtlInitUnicodeString(&UniString, pbadappNameValue[ulcnt]);
                NtStatus = NtQueryValueKey(hKey,
                                           &UniString,
                                           KeyValuePartialInformation,
                                           pKeyValueInfo,
                                           ulcbuf,
                                           &ul);

                if (NT_SUCCESS(NtStatus) &&
                    (REG_DWORD == pKeyValueInfo->Type)) {
                    switch (ulcnt) {
                        case 0:
                            pBadApp->BadAppTimeDelay =
                                RtlEnlargedIntegerMultiply(
                                    *(PULONG)pKeyValueInfo->Data,
                                    -10000 );
                            break;
                        case 1:
                            pBadApp->BadAppFirstCount =
                                *(PULONG)pKeyValueInfo->Data;
                            break;
                        case 2:
                            pBadApp->BadAppNthCount =
                                *(PULONG)pKeyValueInfo->Data;
                            break;
                        case 3:
                            pBadApp->BadAppFlags =
                                *(PULONG)pKeyValueInfo->Data;
                            break;
                    }
                } else {
                    switch (ulcnt) {
                        case 0:
                            pBadApp->BadAppTimeDelay =
                                RtlEnlargedIntegerMultiply(
                                    badappregdefaults[ulcnt],
                                    -10000 );
                            break;
                        case 1:
                            pBadApp->BadAppFirstCount = badappregdefaults[ulcnt];
                            break;
                        case 2:
                            pBadApp->BadAppNthCount = badappregdefaults[ulcnt];
                            break;
                        case 3:
                            pBadApp->BadAppFlags = 0;
                            break;
                    }
                }
            }
            NtClose(hKey);
        }
    }

    // Free the memory we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    if (UniBuff) {
        memset(UniBuff, 0, UniString.MaximumLength);
        RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
    }
    if (pKeyValueInfo) {
        memset(pKeyValueInfo, 0, ulcbuf);
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValueInfo );
    }

    return(ulrc);
}


//*****************************************************************************
// GetCitrixCompatClipboardFlags -
//
//    Returns the Citrix compatibility clipboard flags for the specified
//    application
//
//    Parameters:
//      LPWSTR  lpModName      (IN)  - Image name to look up in registry
//      LPDWORD pdwCompatFlags (OUT) - Ptr to DWORD return value for clipboard flags
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    Notes:
//      Flag values are defined in syslib.h.
//
//*****************************************************************************

ULONG
GetCitrixCompatClipboardFlags(LPWSTR lpModName,
                              LPDWORD pdwClipboardFlags)
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UniString;
    HKEY   hKey = 0;
    ULONG  ul, ulcbuf;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValInfo = NULL;
    ULONG  ulRetCode = FALSE;
    LPWSTR UniBuff = NULL;

    UniString.Buffer = NULL;

    ul = sizeof(TERMSRV_COMPAT_APP) + (wcslen(lpModName) + 1)*sizeof(WCHAR);

    UniBuff = RtlAllocateHeap(RtlProcessHeap(),
                              0,
                              ul);

    if (UniBuff) {
       wcscpy(UniBuff, TERMSRV_COMPAT_APP);
       wcscat(UniBuff, lpModName);

       RtlInitUnicodeString(&UniString, UniBuff);
    }

    // Determine the value info buffer size
    ulcbuf = sizeof(KEY_VALUE_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR) +
             sizeof(ULONG);

    pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ulcbuf);

    // Did everything initialize OK?
    if (UniString.Buffer && pKeyValInfo) {
        InitializeObjectAttributes(&ObjectAttributes,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(NtStatus)) {

            RtlInitUnicodeString(&UniString, COMPAT_CLIPBOARDFLAGS );
            NtStatus = NtQueryValueKey(hKey,
                                       &UniString,
                                       KeyValuePartialInformation,
                                       pKeyValInfo,
                                       ulcbuf,
                                       &ul);

            if (NT_SUCCESS(NtStatus) && (REG_DWORD == pKeyValInfo->Type)) {
                *pdwClipboardFlags = *(PULONG)pKeyValInfo->Data;
                ulRetCode = TRUE;
            }

            NtClose(hKey);
        }
    }

    // Free up the buffers we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    if (UniBuff) {
        memset(UniBuff, 0, UniString.MaximumLength);
        RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
    }
    if (pKeyValInfo) {
        memset(pKeyValInfo, 0, ulcbuf);
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValInfo );
    }

    return(ulRetCode);
}


//*****************************************************************************
// CitrixGetAppModuleName -
//
//    Extracts the module name for a given process handle.  The directory
//    path and the file extension are stripped off.
//
//    Parameters:
//      HANDLE  ProcHnd        (IN)  - Handle to the process
//      LPWSTR  buffer         (IN)  - buffer used to return the module
//      LPWSTR  lpModName      (IN)  - Available size of the buffer in bytes
//      LPDWORD pdwCompatFlags (OUT) - Ptr to DWORD return value for clipboard flags
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    Notes:
//      Function only works for 32 bit windows applications
//
//*****************************************************************************


BOOLEAN
CitrixGetAppModuleName ( HANDLE ProcHnd, LPWSTR Buffer, ULONG Length )
{
   PROCESS_BASIC_INFORMATION ProcInfo;
   ULONG retLen;
   PEB peb;
   RTL_USER_PROCESS_PARAMETERS params;
   WCHAR pwcAppName[MAX_PATH];
   PWCHAR pwch;

   if ( NtQueryInformationProcess( ProcHnd, ProcessBasicInformation,
                                    (PVOID) &ProcInfo, sizeof(ProcInfo),
                                    &retLen ) ) {
      return ( FALSE );
   }

   if ( !ProcInfo.PebBaseAddress ) {
      return ( FALSE );
   }

   if ( ! ReadProcessMemory(ProcHnd, (PVOID)ProcInfo.PebBaseAddress, &peb,
                            sizeof(peb), NULL ) ) {
      return ( FALSE );
   }

   if ( !ReadProcessMemory(ProcHnd, peb.ProcessParameters, &params,
                           sizeof(params), NULL ) ) {
      return ( FALSE );
   }

   if ( !ReadProcessMemory( ProcHnd, params.ImagePathName.Buffer, pwcAppName,
                            sizeof(pwcAppName), NULL) ) {
      return ( FALSE );
   }

   pwch = wcsrchr(pwcAppName, L'\\');
   if ( pwch ) {
      pwch++;
   }
   else {
      pwch = pwcAppName;
   }

   if ( wcslen(pwch) >= (Length / sizeof(WCHAR)) ) {
      return ( FALSE );
   }

   wcscpy(Buffer, pwch);

   // Remove the extension
   if (pwch = wcsrchr(Buffer, L'.')) {
       *pwch = '\0';
   }
   return ( TRUE );
}

// Globals for logging
// We cache the compatibility flags for the running 32 bit app.
// If the logging is enabled for ntvdm, we'll check the flags of the
// Win16 or DOS app on each object create.

DWORD CompatFlags = 0;
BOOL CompatGotFlags = FALSE;
DWORD CompatAppType = TERMSRV_COMPAT_WIN32;

void CtxLogObjectCreate(PUNICODE_STRING ObjName, PCHAR ObjType,
                        PVOID RetAddr)
{
    CHAR RecBuf[2 * MAX_PATH];
    CHAR ObjNameA[MAX_PATH];
    PCHAR DllName;
    WCHAR FileName[MAX_PATH];
    WCHAR ModName[MAX_PATH];
    ANSI_STRING AnsiString;
    PRTL_PROCESS_MODULES LoadedModules;
    PRTL_PROCESS_MODULE_INFORMATION Module;

    HANDLE LogFile;
    OVERLAPPED Overlapped;
    NTSTATUS Status;
    ULONG i;
    DWORD BytesWritten;
    DWORD lCompatFlags;    // For Win16 or DOS Apps
    DWORD AppType = 0;
    ULONG AllocSize = 4096;
    BOOL NameFound = FALSE;


    // Determine the log file name
    if (GetEnvironmentVariableW(OBJ_LOG_PATH_VAR, FileName, MAX_PATH)) {
        if (GetAppTypeAndModName(&AppType,ModName,sizeof(ModName))) {
            if (AppType != TERMSRV_COMPAT_WIN32 ) {
                // Logging was enabled for ntvdm - check the
                // compatibility flags of the Win16 or DOS app
                if (!GetTermsrCompatFlags(ModName,
                                          &lCompatFlags,
                                          CompatibilityApp) ||
                    !(lCompatFlags & TERMSRV_COMPAT_LOGOBJCREATE))
                    return;
            }
            if ((wcslen(FileName) + wcslen(ModName) + 2) <= MAX_PATH) {
                lstrcatW(FileName, L"\\");
                lstrcatW(FileName,ModName);
                lstrcatW(FileName,L".log");
            } else
                return;
        } else
           return;
    } else
        return;

    //Format the log record
    AnsiString.Buffer = ObjNameA;
    AnsiString.MaximumLength = MAX_PATH;
    RtlUnicodeStringToAnsiString(&AnsiString, ObjName, FALSE);

    // Try to get the DLL name of the caller
    AllocSize = 4096;
    for (;;) {
        LoadedModules = (PRTL_PROCESS_MODULES)
            RtlAllocateHeap(RtlProcessHeap(), 0, AllocSize);
        if (!LoadedModules) {
            return;
        }

        Status = LdrQueryProcessModuleInformation(LoadedModules, AllocSize, NULL);
        if (NT_SUCCESS(Status)) {
            break;
        }
        if (Status == STATUS_INFO_LENGTH_MISMATCH) {
            RtlFreeHeap( RtlProcessHeap(), 0, LoadedModules );
            LoadedModules = NULL;
            AllocSize += 4096;
            continue;
        }
        // Other error;
        RtlFreeHeap( RtlProcessHeap(), 0, LoadedModules );
        return;
    }

    for (i=0,Module = &LoadedModules->Modules[0];
         i<LoadedModules->NumberOfModules;
         i++, Module++ ) {
        if ((RetAddr >= Module->ImageBase) &&
            ((ULONG_PTR) RetAddr < (((ULONG_PTR)Module->ImageBase) + Module->ImageSize))) {
            NameFound = TRUE;
            DllName = Module->FullPathName;
            break;
        }
    }

    if (!NameFound) {
        DllName = "DLL Not Found";
    }

    sprintf(RecBuf,"Create %s name: %s Return Addr: %p (%s)\n",
            ObjType, ObjNameA, RetAddr, DllName);

    if (LoadedModules) {
        RtlFreeHeap( RtlProcessHeap(), 0, LoadedModules );
        LoadedModules = NULL;
    }

    // Write log record
    if ((LogFile = CreateFileW(FileName, GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL, OPEN_ALWAYS, 0, NULL)) ==
        INVALID_HANDLE_VALUE ) {
        return;
    }

    // Lock the file exclusive since we always write at the end.
    // We get mutual exclusion by always locking the first 64k bytes
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;
    Overlapped.hEvent = NULL;
    LockFileEx(LogFile, LOCKFILE_EXCLUSIVE_LOCK, 0, 0x10000, 0, &Overlapped);

    // Write at the end of the file
    SetFilePointer(LogFile, 0, NULL, FILE_END);
    WriteFile(LogFile, RecBuf, strlen(RecBuf), &BytesWritten, NULL);
    UnlockFileEx(LogFile, 0, 0x10000, 0, &Overlapped);

    CloseHandle(LogFile);

}

//*****************************************************************************
// CtxGetCrossWinStationDebug -
//
//    Gets the Citrix Cross Winstation debug flag
//
//    Parameters:
//       NONE
//    Return Value:
//      TRUE   Cross WinStation Debug enabled
//      FALSE  CrosS WinStation Debug Disabled
//
//
//*****************************************************************************

BOOL CtxGetCrossWinStationDebug()
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UniString;
    HKEY hKey = 0;
    ULONG ul, ulcnt, ulcbuf, ulrc = FALSE;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = NULL;
    LPWSTR UniBuff;
    ULONG Flag = 0;

    // Get the buffers we need
    ul = sizeof(TERMSRV_REG_CONTROL_NAME);

    UniBuff = RtlAllocateHeap(RtlProcessHeap(), 0, ul);

    ulcbuf = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG);

    pKeyValueInfo = RtlAllocateHeap(RtlProcessHeap(), 0, ulcbuf);

    if (UniBuff && pKeyValueInfo) {

        RtlInitUnicodeString(&UniString, TERMSRV_REG_CONTROL_NAME );

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(NtStatus)) {

            RtlInitUnicodeString(&UniString, TERMSRV_CROSS_WINSTATION_DEBUG);
            NtStatus = NtQueryValueKey(hKey,
                                       &UniString,
                                       KeyValuePartialInformation,
                                       pKeyValueInfo,
                                       ulcbuf,
                                       &ul);

            if ( NT_SUCCESS(NtStatus) ) {
                if ( REG_DWORD == pKeyValueInfo->Type ) {
                    Flag = *(PULONG)pKeyValueInfo->Data;
                }
            }
            NtClose(hKey);
        }
    }

    // Free the memory we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    if (UniBuff) {
        memset(UniBuff, 0, UniString.MaximumLength);
        RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
    }
    if (pKeyValueInfo) {
        memset(pKeyValueInfo, 0, ulcbuf);
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValueInfo );
    }

    return( Flag ? TRUE : FALSE );
}


//*****************************************************************************
// CtxGetModuleBadClpbrdAppFlags -
//
//    Gets the Citrix BadClpbrdApp and compatibility flags for the specified
//    module.
//
//    Parameters:
//      LPWSTR  lpModName      (IN)  - Image name to look up in registry
//      PBADCLPBRDAPP pBadClpbrdApp        (OUT) - Structure to used to return flags
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    The BADCLPBRDAPP structure is defined in:
//           base\client\citrix\compatfl.h and user\inc\user.h.
//
//*****************************************************************************

BOOL CtxGetModuleBadClpbrdAppFlags(LPWSTR lpModName, PBADCLPBRDAPP pBadClpbrdApp)
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UniString;
    HKEY hKey = 0;
    ULONG ul, ulcnt, ulcbuf, ulrc = FALSE;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = NULL;
    LPWSTR UniBuff;
    PWCHAR pwch;
    WCHAR  *pbadappNameValue[] = { COMPAT_OPENCLIPBOARDRETRIES,
                                                   COMPAT_OPENCLIPBOARDDELAYINMILLISECS,
                                   COMPAT_CLIPBOARDFLAGS,
                                   NULL
                                 };


    // Get the executable name only, no path.
    pwch = wcsrchr(lpModName, L'\\');
    if (pwch) {
        pwch++;
    } else {
        pwch = lpModName;
    }

    // Get the buffers we need
    ul = sizeof(TERMSRV_COMPAT_APP) + (wcslen(pwch) + 1)*sizeof(WCHAR);

    UniBuff = RtlAllocateHeap(RtlProcessHeap(), 0, ul);

    ulcbuf = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG);

    pKeyValueInfo = RtlAllocateHeap(RtlProcessHeap(), 0, ulcbuf);

    if (UniBuff && pKeyValueInfo) {
        wcscpy(UniBuff, TERMSRV_COMPAT_APP);
        wcscat(UniBuff, pwch);

        // Remove the extension
        if (pwch = wcsrchr(UniBuff, L'.')) {
            *pwch = '\0';
        }

        RtlInitUnicodeString(&UniString,
                             UniBuff
                            );

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                  );

        NtStatus = NtOpenKey(&hKey, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(NtStatus)) {

            ulrc = TRUE;
            for (ulcnt = 0; pbadappNameValue[ulcnt]; ulcnt++) {

                RtlInitUnicodeString(&UniString, pbadappNameValue[ulcnt]);
                NtStatus = NtQueryValueKey(hKey,
                                           &UniString,
                                           KeyValuePartialInformation,
                                           pKeyValueInfo,
                                           ulcbuf,
                                           &ul);

                if (NT_SUCCESS(NtStatus) &&
                    (REG_DWORD == pKeyValueInfo->Type)) {
                    switch (ulcnt) {
                        case 0:
                            pBadClpbrdApp->BadClpbrdAppEmptyRetries =
                                *(PULONG)pKeyValueInfo->Data;
                            break;
                        case 1:
                            pBadClpbrdApp->BadClpbrdAppEmptyDelay =
                                    *(PULONG)pKeyValueInfo->Data;
                            break;
                        case 2:
                            pBadClpbrdApp->BadClpbrdAppFlags =
                                *(PULONG)pKeyValueInfo->Data;
                            break;
                    }
                } else {
                    switch (ulcnt) {
                        case 0:
                            pBadClpbrdApp->BadClpbrdAppEmptyRetries = 0;
                            break;
                        case 1:
                            pBadClpbrdApp->BadClpbrdAppEmptyDelay = 50;
                            break;
                        case 2:
                            pBadClpbrdApp->BadClpbrdAppFlags = 0;
                            break;
                    }
                }
            }
            NtClose(hKey);
        }
    }

    // Free the memory we allocated
    // Need to zero out the buffers, because some apps (MS Internet Assistant)
    // won't install if the heap is not zero filled.
    if (UniBuff) {
        memset(UniBuff, 0, UniString.MaximumLength);
        RtlFreeHeap( RtlProcessHeap(), 0, UniBuff );
    }
    if (pKeyValueInfo) {
        memset(pKeyValueInfo, 0, ulcbuf);
        RtlFreeHeap( RtlProcessHeap(), 0, pKeyValueInfo );
    }

    return(ulrc);
}

//*****************************************************************************
// CtxGetBadClpbrdAppFlags -
//
//    Gets the Citrix BadClpbrdApp and compatibility flags for the
//    current task.
//
//    Parameters:
//      LPWSTR  lpModName      (IN)  - Image name to look up in registry
//      PBADCLPBRDAPP pBadClpbrdApp        (OUT) - Structure to used to return flags
//
//    Return Value:
//      TRUE on success, FALSE on failure.
//
//    The BADCLPBRDAPP structure is defined in:
//           base\client\citrix\compatfl.h and user\inc\user.h.
//
//*****************************************************************************

BOOL CtxGetBadClpbrdAppFlags(OUT PBADCLPBRDAPP pBadClpbrdApp)
{
    WCHAR   ModName[MAX_PATH+1];
    DWORD dwAppType = 0;

    if (!GetAppTypeAndModName(&dwAppType, ModName, sizeof(ModName))) {
        return (FALSE);
    }

    // Get the flags
    return (CtxGetModuleBadClpbrdAppFlags(ModName, pBadClpbrdApp));
}


//*****************************************************************************
//
// Same as GetTermsrCompatFlags(), except that the first argument is name
// of an executable module with possible path and extention.
// This func will strip path and extension, and then call GetTermsrCompatFlags()
// with just the module name
//
//*****************************************************************************
ULONG GetTermsrCompatFlagsEx(LPWSTR lpModName,
                           LPDWORD pdwCompatFlags,
                           TERMSRV_COMPATIBILITY_CLASS CompatType)
{
    // drop the path and extension from the module name
    WCHAR   *p, *e;
    int     size;

    size = wcslen(lpModName);

    p = &lpModName[size-1];     // move to to the end of string

    // walk back to the start, break if you hit a back-slash
    while (p != lpModName)
    {
        if ( *p == TEXT('\\') )
        {   ++p; //move past the back-slash
            break;
        }
        --p;
    }

    // p is at the begining of the name of an executable.

    // get rid of the extension, set end pointer e to the start of str
    // move forward until you hit '.'
    e = p;
    while (*e)
    {
        if (*e == TEXT('.') )

        {
            *e = TEXT('\0');  // terminate at "."
            break;
        }
        e++;
    }

    // 'p' is the module/executable name, no path, and no extension.
    return ( GetTermsrCompatFlags( p,  pdwCompatFlags, CompatType) );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\compatfl.h ===
/*************************************************************************
*
* compatfl.h
*
* Function declarations for Citrix application compatibility flags
*
* copyright notice: Microsoft 1998
*
*
*************************************************************************/

#ifndef _COMPATFLH_
#define _COMPATFLH_

#include <winsta.h>
#include <syslib.h>
#include <regapi.h>

//
// Default limit for physical memory returned by GLobalMemoryStatus
// when physical memory limit is set in the compatibility flags.
//

#define TERMSRV_COMPAT_DEFAULT_PHYSMEMLIM   (32*1024*1024)

// Private Compatibility flags to indicate if flags in TEB are valid
// Other flags values are in syslib.h

#define TERMSRV_COMPAT_BADAPPVALID \
                                0x40000000  // Bad app flags in Teb are valid
#define TERMSRV_COMPAT_TEBVALID \
                                0x80000000  // Compat flags in Teb are valid

#define TERMSRV_COMPAT                   NTAPI_COMPAT_REG_NAME
#define TERMSRV_COMPAT_APP               NTAPI_COMPAT_APPS_REG_PREFIX
#define TERMSRV_COMPAT_DLLS              NTAPI_COMPAT_DLLS_REG_PREFIX
#define TERMSRV_COMPAT_INIFILE           NTAPI_COMPAT_INI_REG_NAME
#define TERMSRV_COMPAT_REGENTRY          NTAPI_COMPAT_REGENTRY_REG_NAME
#define TERMSRV_INIFILE_TIMES            NTAPI_INIFILE_TIMES_REG_NAME
#define USER_SOFTWARE_TERMSRV            REG_SOFTWARE_TSERVER
#define TERMSRV_REG_CONTROL_NAME         REG_NTAPI_CONTROL_TSERVER
#define TERMSRV_CROSS_WINSTATION_DEBUG   REG_CITRIX_CROSSWINSTATIONDEBUG
#define TERMSRV_USER_SYNCTIME            COMPAT_USER_LASTUSERINISYNCTIME
#define TERMSRV_PHYSMEMLIM               COMPAT_PHYSICALMEMORYLIMIT

#define TERMSRV_INIFILE_TIMES_SHORT      L"\\" REG_INSTALL L"\\" REG_INIFILETIMES
#define TERMSRV_INSTALL_SOFTWARE_SHORT   L"\\" REG_INSTALL L"\\Software"
// Define the file information class values
//
// WARNING:  The order of the following values are assumed by the I/O system.
//           Any changes made here should be reflected there as well.
//


typedef struct _BADAPP {
    ULONG BadAppFlags;
    ULONG BadAppFirstCount;
    ULONG BadAppNthCount;
    LARGE_INTEGER BadAppTimeDelay;
} BADAPP, *PBADAPP;

typedef struct _BADCLPBRDAPP {
    ULONG BadClpbrdAppFlags;
    ULONG BadClpbrdAppEmptyRetries;
    ULONG BadClpbrdAppEmptyDelay;
} BADCLPBRDAPP, *PBADCLPBRDAPP;

ULONG GetTermsrCompatFlags(LPWSTR, LPDWORD, TERMSRV_COMPATIBILITY_CLASS);
ULONG GetTermsrCompatFlagsEx(LPWSTR, LPDWORD, TERMSRV_COMPATIBILITY_CLASS);
ULONG GetCtxAppCompatFlags(LPDWORD, LPDWORD);
ULONG GetCtxPhysMemoryLimits(LPDWORD, LPDWORD);
BOOL CtxGetBadAppFlags(LPWSTR, PBADAPP);
BOOL CtxGetBadClpbrdAppFlags(PBADCLPBRDAPP);
BOOL CtxGetModuleBadClpbrdAppFlags(LPWSTR, PBADCLPBRDAPP);
BOOL GetAppTypeAndModName(LPDWORD, PWCHAR, ULONG);

// Defines for compatibility flag caching in kernel32.dll
extern ULONG CompatFlags;
extern BOOL  CompatGotFlags;
extern DWORD CompatAppType;
extern void CtxLogObjectCreate(PUNICODE_STRING, PCHAR, PVOID);

#define CacheCompatFlags \
{ \
    if (!CompatGotFlags ) { \
        GetCtxAppCompatFlags(&CompatFlags, &CompatAppType); \
        CompatGotFlags = TRUE; \
    } \
}

#define LogObjectCreation(ObjName,ObjType,RetAddr) \
{ \
    CacheCompatFlags \
    if (CompatFlags & TERMSRV_COMPAT_LOGOBJCREATE) { \
        CtxLogObjectCreate(ObjName,ObjType,RetAddr); \
    } \
}

// Environment variable for object creation log file
#define OBJ_LOG_PATH_VAR L"TERMSRV_COMPAT_LOGPATH"




#define  DEBUG_IAT   0x80000000  // use the registry to set value of "IAT" to 0x8000000 for debug output.
                                 // value of the optional debug IAT flag read from the registry.
                                 // Currently, only 0x1 and 0x8000000 have meaning, the first disables
                                 // calls to LoabLib, and the 2nd enables debug output.


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\inipath.h ===
/*************************************************************************
*
* inipath.h
*
* Function declarations for INI file mapping
*
* copyright notice: Copyright 1998, Microsoft Corporation
*
*
*
*************************************************************************/

#define CtxFreeSID LocalFree


/*
 * Forward references
 */

NTSTATUS
GetPerUserWindowsDirectory(
    OUT PUNICODE_STRING pFQName
    );

ULONG GetTermsrvAppCompatFlags(OUT LPDWORD pdwCompatFlags, OUT LPDWORD pdwAppType);

NTSTATUS
BuildIniFileName(
    OUT PUNICODE_STRING pFQName,
    IN  PUNICODE_STRING pBaseFileName
    );

NTSTATUS
GetEnvPath(
    OUT PUNICODE_STRING pFQPath,
    IN  PUNICODE_STRING pDriveVariableName,
    IN  PUNICODE_STRING pPathVariableName
    );

NTSTATUS
ConvertSystemRootToUserDir(
    OUT PUNICODE_STRING pFQPath,
    IN PUNICODE_STRING BaseWindowsDirectory
    );

BOOL CtxCreateSecurityDescriptor( PSECURITY_ATTRIBUTES psa );
BOOL CtxFreeSecurityDescriptor( PSECURITY_ATTRIBUTES psa );

NTSTATUS
CtxAddAccessAllowedAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN DWORD index
    );


//BOOL CtxSyncUserIniFile(PINIFILE_PARAMETERS a);

//BOOL CtxLogInstallIniFile(PINIFILE_PARAMETERS a);

BOOL IsSystemLUID(VOID);

BOOLEAN TermsrvPerUserWinDirMapping();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\keynode.cpp ===
/****************************************************************************/
// keynode.cpp
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/


#include <stdio.h>
#include "KeyNode.h"

extern ULONG   g_length_TERMSRV_USERREGISTRY_DEFAULT;
extern ULONG   g_length_TERMSRV_INSTALL;
extern WCHAR   g_debugFileName[MAX_PATH];
extern FILE    *g_debugFilePointer;
extern BOOLEAN g_debugIO;

KeyBasicInfo::KeyBasicInfo():
    pNameSz(NULL)
{
    size = sizeof(KEY_BASIC_INFORMATION) + MAX_PATH*sizeof(WCHAR);
    pInfo = ( KEY_BASIC_INFORMATION *)RtlAllocateHeap(RtlProcessHeap(), 0, size );

    if (!pInfo) {
        status = STATUS_NO_MEMORY;
        pInfo=NULL;
    }
    else
        status = STATUS_SUCCESS;

}

KeyBasicInfo::~KeyBasicInfo()
{
    if (pInfo)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pInfo);
    }

    if (pNameSz)
    {
        delete pNameSz;
    }
}

PCWSTR KeyBasicInfo::NameSz()
{
    if (Ptr()->NameLength < 2 * MAX_PATH )
    {
        if (!pNameSz)
        {
            pNameSz = new WCHAR [ MAX_PATH  + 1 ];
        }

        // the reason we re do this every call of NameSz() is because
        // Ptr() might changes, since KeyBasicInfo is being used as a
        // scratch pad and passed around for storing pointers to some
        // basic set of info on any key.

        // see if allocation was successful
        if ( pNameSz )
        {
            for ( ULONG i=0; i < Ptr()->NameLength / sizeof(WCHAR) ; i++)
            {
                pNameSz[i] = ( (USHORT)Ptr()->Name[i] );
            }
            pNameSz[i]=L'\0';
        }
    }

    return pNameSz;

}

#if 0 // NOT USED yet!
KeyNodeInfo::KeyNodeInfo()
{
    size = sizeof(KEY_NODE_INFORMATION) + MAX_PATH*sizeof(WCHAR);
    pInfo = ( KEY_NODE_INFORMATION *)RtlAllocateHeap(RtlProcessHeap(), 0, size );

    if (!pInfo) {
        status = STATUS_NO_MEMORY;
        pInfo=NULL;
    }
    else
        status = STATUS_SUCCESS;


}
KeyNodeInfo::~KeyNodeInfo()
{
    if (pInfo)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pInfo);
    }
}

#endif

KeyFullInfo::KeyFullInfo() :
    pInfo(NULL)
{
    size = sizeof(KEY_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR);
    pInfo = ( KEY_FULL_INFORMATION *)RtlAllocateHeap(RtlProcessHeap(), 0, size );

    if (!pInfo) {
        status = STATUS_NO_MEMORY;
        pInfo=NULL;
    }
    else
        status = STATUS_SUCCESS;


}

KeyFullInfo::~KeyFullInfo()
{
    if (pInfo)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pInfo);
    }

}

KeyNode::KeyNode(HANDLE root, ACCESS_MASK access, PCWSTR name ) :
    root(NULL), hKey(NULL),
    accessMask(NULL),basic(NULL),full(NULL),
    pFullPath(NULL), pNameSz(NULL)
{
    hKey = NULL;
    PCWSTR n = name;
    accessMask = access;

    RtlInitUnicodeString(&uniName, n);

    InitializeObjectAttributes(&ObjAttr,
                           &uniName,
                           OBJ_CASE_INSENSITIVE,
                           root,
                           NULL);
    status=STATUS_SUCCESS;
}

KeyNode::KeyNode(KeyNode *pParent, KeyBasicInfo   *pInfo ) :
    root(NULL), hKey(NULL),
    accessMask(NULL),basic(NULL), full(NULL),
    pFullPath(NULL), pNameSz(NULL)
{
    hKey = NULL;
    PCWSTR n = pInfo->Ptr()->Name;
    accessMask = pParent->Masks();

    RtlInitUnicodeString(&uniName, n);
    uniName.Length = (USHORT) pInfo->Ptr()->NameLength;

    InitializeObjectAttributes(&ObjAttr,
                           &uniName,
                           OBJ_CASE_INSENSITIVE,
                           pParent->Key(),
                           NULL);
    status=STATUS_SUCCESS;

}


KeyNode::~KeyNode()
{
    Close();

    if (basic)
    {
        delete basic;
    }

    if (full)
    {
        delete full;
    }

    if (pFullPath)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pFullPath);
    }

    if( pNameSz )
    {
        delete pNameSz;
    }

}

NTSTATUS KeyNode::Open()
{
    status = NtOpenKey(&hKey,
                    accessMask,
                    &ObjAttr);


    if ( !NT_SUCCESS( status))
    {
       hKey=NULL;
       // Debug(DBG_OPEN_FAILED );
    }

    return status;

}

NTSTATUS KeyNode::Close()
{

    if ( hKey )
    {
        status = NtClose( hKey );
        hKey = 0;
    }

    return status;
}

NTSTATUS KeyNode::Create( UNICODE_STRING *uClass)
{
    ULONG   ultmp;
    status = NtCreateKey(&hKey,
                         accessMask,
                         &ObjAttr,
                         0,
                         uClass,
                         REG_OPTION_NON_VOLATILE,
                         &ultmp);
    // Debug(DBG_CREATE);

    return status;
}



// Recursively create the reg path given by the uniName member variable
// Upon completion, open the reg key for access.

NTSTATUS KeyNode::CreateEx( UNICODE_STRING *uClass)
{
    ULONG   wsize = uniName.Length/sizeof(WCHAR);
    PWCHAR pTmpFullPath = new WCHAR[  uniName.Length + sizeof( WCHAR ) ];

    if(!pTmpFullPath)
    {
        status = STATUS_NO_MEMORY;
        return status;
    }

    wcsncpy(pTmpFullPath, uniName.Buffer , wsize);
    pTmpFullPath[ wsize ] = L'\0';

    PWCHAR    p;
    WCHAR     sep[]= {L"\\"};
    p = wcstok( pTmpFullPath, sep);

    // we know how many keys to create now.
    // start over again
    wcsncpy(pTmpFullPath, uniName.Buffer , wsize );
    pTmpFullPath[ wsize ] = L'\0';

    KeyNode *pKN1=NULL, *pKN2=NULL;
    p = wcstok( pTmpFullPath, sep);

    // the first item is "Registry", make it "\Registry" since we are opening
    // from the root.
    PWCHAR pTmpName = new WCHAR[  wcslen(p) + sizeof( WCHAR ) ];

    if(!pTmpName)
    {
        DELETE_AND_NULL(pTmpFullPath);
        status = STATUS_NO_MEMORY;
        return status;
    }

    wcscpy(pTmpName, L"\\");
    wcscat( pTmpName , p );

    NTSTATUS st = STATUS_SUCCESS;
    while( p != NULL )
    {
        // @@@
        // ADD error handling, else you will create keys in the wrong places instead of bailing out.
        // @@@

        if ( pKN2 )
        {
            // ---- STEP 3 ---

            // NOT-first time around

            p = wcstok( NULL, sep);

            if ( p )    // we have more sub keys
            {
                pKN1 = new KeyNode( pKN2->Key(),  accessMask,  p );
                if (pKN1)
                {
                    st = pKN1->Open();

                    // if Open fails, then key does not exist, so create it
                    if ( !NT_SUCCESS( st ))
                    {
                        st = pKN1->Create();
                    }
                }
                else
                {
                    status = STATUS_NO_MEMORY;
                    break;
                }
            }
        }
        else
        {
            // ---- STEP 1 ---

            // First time around, we are opening \Registry node, use
            // pTmpName instead of "p"
            pKN1 = new KeyNode( NULL, accessMask , pTmpName );
            if (pKN1)
            {
                st = pKN1->Open();
            }
            else
            {
                status = STATUS_NO_MEMORY ;
                break;
            }

        }

        p = wcstok( NULL, sep);

        if (p)  // we have more sub keys
        {

            // ---- STEP 2 ---

            pKN2 = new KeyNode( pKN1->Key(), accessMask, p );
            if (pKN2 )
            {
                st = pKN2->Open();
                if ( !NT_SUCCESS( pKN2->Status() ))
                {
                    st = pKN2->Create();
                }
            }
            else
            {
                status = STATUS_NO_MEMORY;
                DELETE_AND_NULL (pKN1);
                break;
            }

            DELETE_AND_NULL (pKN1);
            pKN1 = pKN2;
        }
    }

    DELETE_AND_NULL( pKN2 );

    // since the last node was created above, now we can open ourselfs incase
    // caller wants to use us.
    if ( NT_SUCCESS(status) )
    {
        Open();
    }

    DELETE_AND_NULL(pTmpName);

    DELETE_AND_NULL(pTmpFullPath);

    return status;

}

NTSTATUS KeyNode::Delete()
{
    if (hKey)
    {
        status = NtDeleteKey( hKey );
        // Debug(DBG_DELETE);
    }

    return status;
}


NTSTATUS KeyNode::DeleteSubKeys()
{
    if (hKey && NT_SUCCESS( status ))
    {
        KeyBasicInfo    basicInfo;
        status = basicInfo.Status();

        if (NT_SUCCESS( status )) 
        {
            status = EnumerateAndDeleteSubKeys( this, &basicInfo );
        }
    }
    return status;
}

NTSTATUS KeyNode::EnumerateAndDeleteSubKeys(
    IN KeyNode      *pSource,
    IN KeyBasicInfo *pBasicInfo )
{
    NTSTATUS  st = STATUS_SUCCESS;

    ULONG   ulCount=0;
    ULONG   ultemp;

    while (NT_SUCCESS(st) && st != STATUS_NO_MORE_ENTRIES )
    {
        ULONG       ultemp;
        NTSTATUS    st2;

        st = NtEnumerateKey(    pSource->Key(),
                                    ulCount,
                                    pBasicInfo->Type(),
                                    pBasicInfo->Ptr(),
                                    pBasicInfo->Size(),
                                    &ultemp);

        if (NT_SUCCESS(st) && st != STATUS_NO_MORE_ENTRIES )
        {
            pBasicInfo->Ptr()->Name[ pBasicInfo->Ptr()->NameLength/sizeof(WCHAR) ] = L'\0';

            KeyNode SourcesubKey(pSource, pBasicInfo);

            if (NT_SUCCESS( SourcesubKey.Open() )  )
            {

                // enumerate sub key down.
                st2 = EnumerateAndDeleteSubKeys(
                            &SourcesubKey,
                            pBasicInfo );

            }

            st = SourcesubKey.Delete();
        }

    }

    return st;
}

#if 0
NTSTATUS KeyNode::Query( KEY_NODE_INFORMATION **result , ULONG   *resultSize)
{

    if ( hKey )
    {
        // first time around we allocate memory and keep using it
        // as our scratch pad
        if (!node )
        {
            node = new KeyNodeInfo();
        }

        status = NtQueryKey(hKey,
            node->Type(),     //        Keynode,
            node->Ptr(),
            node->Size(),
            resultSize);

        *result = node->Ptr();
    }
    else
        status = STATUS_OBJECT_NAME_NOT_FOUND; // need to call open or key is not found

    return status;

}
#endif

NTSTATUS KeyNode::Query( KEY_FULL_INFORMATION **result , ULONG   *pResultSize)
{

    if ( hKey )
    {
        // first time around we allocate memory and keep using it
        // as our scratch pad
        if (!full )
        {
            full = new KeyFullInfo();
        }

        if (full)
        {
            status = NtQueryKey(hKey,
                full->Type(),     //        KeyFullInformation,
                full->Ptr(),
                full->Size(),
                pResultSize);
    
            *result = full->Ptr();
        }
        else
            status = STATUS_NO_MEMORY ;
    }
    else
        status = STATUS_OBJECT_NAME_NOT_FOUND; // need to call open or key is not found

    return status;

}

NTSTATUS KeyNode::GetPath( PWCHAR *pwch )
{
    ULONG ultemp;
    ULONG ulWcharLength;          //Keep track of the WCHAR string length

    status = STATUS_SUCCESS;

    // A key handle or root directory was specified, so get its path
    if (hKey)
    {
        ultemp = sizeof(UNICODE_STRING) + sizeof(WCHAR)*MAX_PATH*2;
        pFullPath = RtlAllocateHeap(RtlProcessHeap(),
                                  0,
                                  ultemp);

        // Got the buffer OK, query the path
        if (pFullPath)
        {
            // Get the path for key or root directory
            status = NtQueryObject(hKey ,
                                   ObjectNameInformation,
                                   (PVOID)pFullPath,
                                   ultemp,
                                   NULL);

            if (!NT_SUCCESS(status))
            {
                RtlFreeHeap(RtlProcessHeap(), 0, pFullPath);
                return(status);
            }
        }
        else
        {
            return(STATUS_NO_MEMORY);
        }

        // Build the full path to the key to be created
        *pwch = ((PUNICODE_STRING)pFullPath)->Buffer;

        // Make sure the string is zero terminated
        ulWcharLength = ((PUNICODE_STRING)pFullPath)->Length / sizeof(WCHAR);
        (*pwch)[ulWcharLength] = L'\0';

    }
    else
        status = STATUS_OBJECT_NAME_NOT_FOUND; // need to call open or key is not found


    return(status);
}

void KeyNode::Debug( DebugType type )
{
    if ( debug )
    {
        ULONG i;

        switch( type )
        {
        case DBG_DELETE :
            fwprintf( g_debugFilePointer ,
                    L"Deleted key=%lx; status=%lx, name=", status, hKey );
            DbgPrint("Deleted key=%lx; status=%lx, name=", status, hKey );
            break;

        case DBG_OPEN_FAILED:
            fwprintf( g_debugFilePointer,
                    L"Unable to Open, status=%lx, name=", hKey, status );
            DbgPrint("Unable to Open, status=%lx, name=", hKey, status );
            break;

        case DBG_KEY_NAME:
            fwprintf( g_debugFilePointer,
                    L"hKey=%lx, name=", hKey);
            DbgPrint("hKey=%lx, name=", hKey);
            break;

        case DBG_CREATE:
            fwprintf( g_debugFilePointer,
                    L"Created hKey=%lx, status=%lx,name=", hKey, status);
            DbgPrint("Created hKey=%lx, status=%lx,name=", hKey, status );
            break;
        }

        fwprintf( g_debugFilePointer, L"%s\n",NameSz() );
        fflush( g_debugFilePointer );
        DbgPrint("%s\n",(char *)NameSz() );
    }
}


PCWSTR KeyNode::NameSz()
{
    if (!pNameSz)
    {
        pNameSz = new WCHAR [ uniName.Length / sizeof(WCHAR) + 1 ];

        if (pNameSz)
        {
            for ( ULONG i=0; i < uniName.Length / sizeof(WCHAR) ; i++)
            {
                pNameSz[i] = ( (USHORT)uniName.Buffer[i] );
            }
            pNameSz[i]=L'\0';
        }
        else
        {
            status = STATUS_NO_MEMORY;
        }
    }

    return pNameSz;
}

NTSTATUS KeyNode::GetFullInfo( KeyFullInfo   **p)
{
    // do a self query
    if ( !full )
    {
        ULONG   size;
        KEY_FULL_INFORMATION    *tmp;
        Query( &tmp , &size );
    }

    *p = full;

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\inipath.c ===
/*************************************************************************
*
* inipath.c
*
* Routines to manage per user mapping of Ini file paths
*
* copyright notice: Copyright 1998, Microsoft Corporation
*
*
*
*************************************************************************/
#include "precomp.h"
#pragma hdrstop


//*** Instance data
ULONG ulWinDirFlags = 0;            // State of user's Windows directory

#define WINDIR_FLAGS_VALID          0x01    // The flags are initialized
#define WINDIR_USER_WINDIR_OK       0x02    // User's Windows dir exists

#define WINDOWS_DIR L"WINDOWS"
UNICODE_STRING WindowsDir = { sizeof(WINDOWS_DIR) - sizeof(UNICODE_NULL) , sizeof(WINDOWS_DIR) + sizeof(UNICODE_NULL), WINDOWS_DIR };

WCHAR gpwszDefaultUserName[MAX_PATH+1];

/******************************************************************************
 *
 *  TermsrvPerUserWinDirMapping
 *
 *
/******************************************************************************/
BOOLEAN TermsrvPerUserWinDirMapping() {

#ifdef PERUSERBYREQUEST
    PRTL_USER_PROCESS_PARAMETERS pUserParam;
    PWCHAR  pwch, pwchext;
    WCHAR   pwcAppName[MAX_PATH+1];
    ULONG ulCompat=0, ulAppType=0;

    // Get the path of the executable name
    pUserParam = NtCurrentPeb()->ProcessParameters;

    // Get the executable name, if there's no \ just use the name as it is
    pwch = wcsrchr(pUserParam->ImagePathName.Buffer, L'\\');
    if (pwch) {
        pwch++;
    } else {
        pwch = pUserParam->ImagePathName.Buffer;
    }
    wcscpy(pwcAppName, pwch);
    pwch = pwcAppName;

    if (_wcsicmp(pwch, L"ntvdm.exe")) {

        // If not a 16 bit app
        // Check if we should return the per user windows dir for this app
        GetCtxAppCompatFlags(&ulCompat, &ulAppType);
        if (!(ulCompat & TERMSRV_COMPAT_PERUSERWINDIR) ||
            !(ulCompat & ulAppType)) {
            //
            // Let the standard GetWindowsDirectory call return the actual path
            //
            return FALSE;

         }
    }

    return TRUE;
#else
    ULONG ulCompat=0, ulAppType = 0;


    // Check if we should return the system windows dir for this app
    GetCtxAppCompatFlags(&ulCompat, &ulAppType);
    if ((ulCompat & CITRIX_COMPAT_SYSWINDIR) &&
        (ulCompat & ulAppType)) {
        return FALSE;
    } else {
        return TRUE;
    }

#endif
}

/******************************************************************************
 *
 *  TermsrvBuildIniFileName
 *
 *  Build the INI file name based on the INIPATH or HOMEPATH (if no INIPATH)
 *
 *  ENTRY:
 *     pFQName (output)
 *       Buffer to place fully qualified INI file name
 *     pBaseFileName (input)
 *       pointer to buffer containing base INI file name
 *
 *  EXIT:
 *      NTSTATUS
 *
 *****************************************************************************/
NTSTATUS
TermsrvBuildIniFileName(
    OUT PUNICODE_STRING pFQName,
    IN PUNICODE_STRING pBaseFileName
    )
{
    NTSTATUS Status;
    USHORT   indexLastWChar;
    ULONG ulCompat, ulAppType=0;


//Added By SalimC
    /*
     * If in install mode, use the base windows directory
     * like a stock NT.
     */
    if( IsSystemLUID() || TermsrvAppInstallMode() ) {

        return( STATUS_UNSUCCESSFUL );
    }
//END SalimC

    if (!TermsrvPerUserWinDirMapping()) {
        return( STATUS_UNSUCCESSFUL );
    }
#if 0
    GetCtxAppCompatFlags(&ulCompat, &ulAppType);
    if (((ulCompat & TERMSRV_COMPAT_SYSWINDIR) && (ulCompat & ulAppType))) {

        return STATUS_UNSUCCESSFUL;

    }
#endif

    Status = GetPerUserWindowsDirectory( pFQName );
    if ( NT_SUCCESS( Status ) ) {
       /*
        * Add a '\' if one's not already there
        */
       if ( indexLastWChar = pFQName->Length / sizeof( WCHAR ) ) {
          if ( pFQName->Buffer[--indexLastWChar] != L'\\' ) {
             Status = RtlAppendUnicodeToString( pFQName, L"\\" );
          }
       }

       /*
        * Append the base file name to the fully qualified directory name
        */
       if ( NT_SUCCESS( Status ) ) {
           Status = RtlAppendUnicodeStringToString( pFQName, pBaseFileName );
       }
    }

    return( Status );
}

/******************************************************************************
 *
 *  GetPerUserWindowsDirectory
 *
 *  Get the user's INI file directory
 *
 *  ENTRY:
 *     pFQName (output)
 *       Buffer to place fully qualified INI file name
 *
 *  EXIT:
 *      NTSTATUS
 *
 *****************************************************************************/
NTSTATUS
GetPerUserWindowsDirectory(
    OUT PUNICODE_STRING pFQName
    )
{
    NTSTATUS Status;
    int      indexLastWChar;
    USHORT   Length;
#if 0 //Bug fix #340691: Inherit the security
    PSECURITY_ATTRIBUTES psa = NULL;
#endif //Bug fix #340691: Inherit the security
    UNICODE_STRING UserProfilePath;
    WCHAR*   pwszFQProfileName;
#if DBG
    char pszFile[MAX_PATH+1];
#endif

    UNICODE_STRING BaseHomePathVariableName, BaseHomeDriveVariableName;

    /*
     * If in install mode, use the base windows directory
     * like a stock NT.
     */
    if( IsSystemLUID() || TermsrvAppInstallMode() ) {
        //Status = GetEnvPath( pFQName, NULL, &BaseWindowsDirectory );
        return( STATUS_UNSUCCESSFUL );
    }

    /*
     * Check for HOMEDRIVE and HOMEPATH
     */
    RtlInitUnicodeString(&BaseHomeDriveVariableName,L"HOMEDRIVE");
    RtlInitUnicodeString(&BaseHomePathVariableName,L"HOMEPATH");

    if (!NT_SUCCESS(Status = GetEnvPath( pFQName, &BaseHomeDriveVariableName,
                         &BaseHomePathVariableName ))){

        if (Status == STATUS_BUFFER_TOO_SMALL) {

            // Need 2 bytes for the "\" character to cat FQN and WindowsDir
            Length = pFQName->Length + sizeof(WCHAR) + WindowsDir.Length;

#if DBG
            DbgPrint("pFQName->Length = %u        WindowsDir.Length = %u    Length = %u\n",
                        pFQName->Length, WindowsDir.Length, Length);
#endif


            pFQName->Length = Length;
#if DBG
            DbgPrint("\nGetEnvPath return STATUS_BUFFER_TOO_SMALL\n");
#endif
        } else {
#if DBG
            DbgPrint("GetEnvPath failed with Status %lx\n",Status);
#endif

        }

        return Status;
    }

    /*
     * If the user profile is Default User then use the
     * base windows directory.
     */

    if (pwszFQProfileName = wcsrchr( pFQName->Buffer, L'\\' )) {

        if (_wcsnicmp(pwszFQProfileName+1, gpwszDefaultUserName, MAX_PATH+1) == 0) {

            return STATUS_UNSUCCESSFUL;
        }
    }

    /*
    * Check buffer length
    */
    Length = pFQName->Length + sizeof(WCHAR) + WindowsDir.Length;

// take into account the NULL terminator character
    if (pFQName->MaximumLength < Length + 1)  {
      // Need 2 bytes for the NULL terminator
       Length += sizeof(WCHAR);
       pFQName->Length = Length;
       Status = STATUS_BUFFER_TOO_SMALL;
       goto done;
    }


    /*
    * Add a trailing backslash if one's not already there
    */
    if ( indexLastWChar = pFQName->Length / sizeof( WCHAR ) ) {

        if ( pFQName->Buffer[--indexLastWChar] != L'\\' ) {

            if (NT_SUCCESS(RtlAppendUnicodeToString( pFQName, L"\\" ))) {

                /*
                 * Append "WINDOWS" to home dir
                 */
                Status = RtlAppendUnicodeStringToString( pFQName, &WindowsDir );
            }

        } else {

            Status = RtlAppendUnicodeStringToString( pFQName, &WindowsDir );
        }

    }

    if (NT_SUCCESS(Status)) {

       // Check if we've already tried to create the user's windows path
       if (ulWinDirFlags & WINDIR_FLAGS_VALID) {
          if (ulWinDirFlags & WINDIR_USER_WINDIR_OK) {
             goto done;
          } else {
             Status = STATUS_OBJECT_PATH_INVALID;
          }
       }
    }

    if ( NT_SUCCESS(Status) ) {

       WCHAR Buffer[MAX_PATH+1];
       SECURITY_ATTRIBUTES sa;
       BOOL  fDirCreated = FALSE;

       // Mark this process's windows directory flags as valid
       ulWinDirFlags |= WINDIR_FLAGS_VALID;
#if 0 //Bug fix #340691: Inherit the security
       /*
        * Since creating a security descriptor calls LookupAccountName,
        * which is very time consuming, we only do that if we have to
        * create the directory (which should rarely happen anyway).
        */
       if ( CreateDirectoryW( (LPCWSTR)pFQName->Buffer, NULL ) &&
            RemoveDirectoryW( (LPCWSTR)pFQName->Buffer )       &&
            CtxCreateSecurityDescriptor( &sa ) )  {
          psa = &sa;
       }
       /*
        * Create windows directory if it doesn't exist
        */
       if ( !CreateDirectoryW( (LPCWSTR)pFQName->Buffer, psa ) ) {
#endif //Bug fix #340691: Inherit the security
       if ( !CreateDirectoryW( (LPCWSTR)pFQName->Buffer, NULL ) ) {

          if ( (Status = GetLastError()) == ERROR_ALREADY_EXISTS ) {
             Status = STATUS_SUCCESS;
          }

#if DBG
          else {
              wcstombs( pszFile, pFQName->Buffer, sizeof(pszFile) );
              DbgPrint( "KERNEL32: Error (%d) creating dir '%s'\n",
                        Status, pszFile );
          }
#endif
       } else {
           fDirCreated = TRUE;
       }

       if (NT_SUCCESS(Status)) {


          /*
           * Create system directory if it doesn't exist
           * (ignore return code)
           */
          wcscpy( Buffer, pFQName->Buffer );
          wcscat( Buffer, L"\\system" );

          /*
           * If the user's WINDOWS directory already existed but the
           * WINDOWS\SYSTEM directory didn't, we need to create the
           * security descriptor (this scenario is even rarer).
           */
#if 0 //Bug fix #340691: Inherit the security
          if ( !psa && !fDirCreated &&
               CreateDirectoryW( (LPCWSTR)Buffer, NULL ) &&
               RemoveDirectoryW( (LPCWSTR)Buffer )       &&
               CtxCreateSecurityDescriptor( &sa ) )  {
              psa = &sa;
          }


          if ( !CreateDirectoryW( (LPCWSTR)Buffer, psa ) ) {
#endif
          if ( !CreateDirectoryW( (LPCWSTR)Buffer, NULL ) ) {
#if DBG
             if ( GetLastError() != ERROR_ALREADY_EXISTS ) {
                 wcstombs( pszFile, Buffer, sizeof(pszFile) );
                 DbgPrint( "KERNEL32: Error (%d) creating dir '%s'\n",
                           GetLastError(), pszFile );
             }
#endif
          }

          ulWinDirFlags |= WINDIR_USER_WINDIR_OK;
       }
    }


done:
#if 0 //Bug fix #340691: Inherit the security
    if ( psa ) {
       CtxFreeSecurityDescriptor( psa );
    }
#endif //Bug fix #340691: Inherit the security
#if DDBG
    wcstombs( pszFile, pFQName->Buffer, sizeof(pszFile) );
    DbgPrint( "KERNEL32: ctxwindir='%s'\n", Status ? "Error" : pszFile );
#endif

    return( Status );
}

/******************************************************************************
 *
 *  GetEnvPath
 *
 *  Retrieve a fully qualified path derived from a drive and dir env variable
 *
 *  ENTRY:
 *     pFQPath (output)
 *       Buffer to place fully qualified path name
 *     pDriveVariableName (input)
 *       pointer to buffer containing env variable name for drive
 *       if NULL, pPathVariableName is a FQPath and no env vars are used
 *     pPathVariableName (input)
 *       pointer to buffer containing env variable name for dir
 *
 *  EXIT:
 *      NTSTATUS
 *
 *      If NTSTATUS is STATUS_BUFFER_TOO_SMALL, pFQPath->Length will be set
 *      to the buffer size needed.
 *
 *****************************************************************************/
NTSTATUS
GetEnvPath(
    OUT PUNICODE_STRING pFQPath,
    IN  PUNICODE_STRING pDriveVariableName,
    IN  PUNICODE_STRING pPathVariableName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING Path;
    USHORT         Length;

    if ( pDriveVariableName ) {
       /*
        * First let's figure out how big the buffer needs to be
        * We need to do this in case the buffer is too small and we
        * need to return the required size
        */
       RtlInitUnicodeString( &Path, NULL );

       /*
        * See if an env variable is defined for the drive
        */
       Status = RtlQueryEnvironmentVariable_U( NULL, pDriveVariableName,
                                               &Path);
       switch ( Status ) {
          case STATUS_BUFFER_TOO_SMALL:
             Length = Path.Length; // Count how big this the drive spec is
             break;
          case STATUS_SUCCESS:
             Status = STATUS_OBJECT_NAME_NOT_FOUND; // Something's wrong!
          default:
             goto done;
             break;
       }

       /*
        * See if an env variable is defined for the directory
        */
       Path.Length = 0;
       Status = RtlQueryEnvironmentVariable_U( NULL, pPathVariableName,
                                               &Path);
       switch ( Status ) {
          case STATUS_BUFFER_TOO_SMALL:
             Length += Path.Length; // Count how big this the dir spec is
             break;
          case STATUS_SUCCESS:
             Status = STATUS_OBJECT_NAME_NOT_FOUND; // Something's wrong!
          default:
             goto done;
             break;
       }

       /*
        * If the buffer is too small, return the max size needed
        */
       if ( Length + sizeof(WCHAR) > pFQPath->MaximumLength ) {
          Status = STATUS_BUFFER_TOO_SMALL;
          pFQPath->Length = Length + sizeof(WCHAR); // return size
          goto done;
       }

       /*
        * Get the env variable for the drive - should work if we got this far
        */
       if ( Status = RtlQueryEnvironmentVariable_U( NULL, pDriveVariableName,
                                                    pFQPath) ) {
          goto done;
       }

       /*
        * Setup a receive buffer that points to the proper spot in pFQPath
        */
       Length = pFQPath->Length; // Save the drive length
       Path.Length = 0;
       Path.MaximumLength = pFQPath->MaximumLength - Length;
       (ULONG_PTR)Path.Buffer = (ULONG_PTR)pFQPath->Buffer + (ULONG)Length;

       /*
        * Get the env variable for the directory - should work if we got this far
        * Then append it to the end of the drive spec
        */
       if ( Status = RtlQueryEnvironmentVariable_U( NULL, pPathVariableName,
                                                    &Path) ) {
          goto done;
       }

       /*
        * Fix up the structure and we're done
        */
       pFQPath->Length = Path.Length + Length;

    } else {

       /*
        * pPathVariableName is really the FQ directory name
        */
       if ( (pPathVariableName->Length + sizeof(WCHAR)) > pFQPath->MaximumLength ) {
          Status = STATUS_BUFFER_TOO_SMALL;
          pFQPath->Length = pPathVariableName->Length + sizeof(WCHAR); // return size
       } else {
          RtlCopyUnicodeString( pFQPath, pPathVariableName );
       }
    }

done:
    return( Status );
}

/******************************************************************************
 *
 *  TermsrvConvertSysRootToUserDir
 *
 *  People who use INI files should never have to fully qualify them, but some
 *  people do anyway.  What's more, some people do it wrong.  For example,
 *  Microsoft PowerPoint 4.0 will call GetSystemDir (not GetWindowsDir) and
 *  will strip off "\system" to build a fully qualified path.
 *
 *  ENTRY:
 *     pFQPath (input/output)
 *       Buffer containing fully qualified path name
 *
 *  EXIT:
 *      NTSTATUS
 *
 *      If NTSTATUS is not STATUS_SUCCESS, the directory was not converted
 *
 *****************************************************************************/
NTSTATUS
TermsrvConvertSysRootToUserDir(
    OUT PUNICODE_STRING pFQPath,
    IN PUNICODE_STRING BaseWindowsDirectory
    )
{
    NTSTATUS       Status = STATUS_UNSUCCESSFUL;
    PWSTR          p;
    INT_PTR        c;
    WCHAR          buffer[MAX_PATH+1];
    UNICODE_STRING BaseFileName;
#if DDBG
    char           pszFile[MAX_PATH+1];
#endif

     ULONG ulCompat, ulAppType=0;

    /*
     * If in install mode, use the base windows directory
     * like a stock NT.
     */
    if( IsSystemLUID() || TermsrvAppInstallMode() ) {
        goto done;
    }


#if 0
    GetCtxAppCompatFlags(&ulCompat, &ulAppType);
    if (((ulCompat & TERMSRV_COMPAT_SYSWINDIR) && (ulCompat & ulAppType))) {
        goto done;
    }
#endif
    if (!TermsrvPerUserWinDirMapping()) {
        goto done;
    }


    /*
     * Check for NULL pointers
     */
    if ( !pFQPath || !pFQPath->Buffer ) {
#if DBG
        DbgPrint( "KERNEL32: Bogus ini path\n" );
#endif
        goto done;
    }

    /*
     * Validate and isolate the path
     */
    if ( !(p = wcsrchr( pFQPath->Buffer, L'\\' ) ) ) {
#if DBG
       DbgPrint( "KERNEL32: No backslash in ini path\n" );
#endif
       goto done;
    }
    c = (INT_PTR)((ULONG_PTR)p - (ULONG_PTR)pFQPath->Buffer);

#if DDBG
    wcstombs( pszFile, BaseWindowsDirectory->Buffer, sizeof(pszFile) );
    DbgPrint( "KERNEL32: c(%d) c2(%d) BaseWinDir: '%s'\n",
              c, (int)BaseWindowsDirectory->Length, pszFile );
    wcstombs( pszFile, p, sizeof(pszFile) );
    DbgPrint( "KERNEL32:  BaseFileName: '%s'\n", pszFile );
#endif

    if ( c != (INT_PTR)BaseWindowsDirectory->Length ) {
#if DDBG
       DbgPrint( "KERNEL32: Path length diff from BaseWinDir length\n" );
#endif
       goto done;
    }

    /*
     * See if the path is the same as the base windows directory
     */
    c /= sizeof(WCHAR);
    if ( _wcsnicmp( BaseWindowsDirectory->Buffer, pFQPath->Buffer, (size_t)c ) ) {
#if DDBG
        DbgPrint( "KERNEL32: Path diff from BaseWinDir\n" );
#endif
        goto done;
    }

    /*
     * Use the user's directory instead
     */
    wcscpy( buffer, ++p );
    RtlInitUnicodeString( &BaseFileName, buffer );
    Status = TermsrvBuildIniFileName( pFQPath, &BaseFileName );

done:

#if DDBG
    wcstombs( pszFile, pFQPath->Buffer, sizeof(pszFile) );
    DbgPrint( "KERNEL32: Exit(%x) ConvertSystemRootToUserDir: '%s'\n",
              Status, pszFile );
#endif

    return( Status );
}

/******************************************************************************
 *
 *  CtxCreateSecurityDescriptor
 *
 *  This routine will create a security descriptor based on the specified
 *  generic flags.  If this function succeeds, the caller needs to call
 *  CtxFreeSecurityDescriptor() when it is done using the descriptor.
 *
 *  ENTRY:
 *     psa (output)
 *       Pointer to uninitialized security attributes structure
 *
 *  EXIT:
 *      TRUE if successful, FALSE if error occurred
 *
 *      (GetLastError() can be called to retrieve error code)
 *
 *****************************************************************************/
#if 0 //Bug fix #340691: Inherit the security
BOOL CtxCreateSecurityDescriptor( PSECURITY_ATTRIBUTES psa )
{
    BOOL  fSuccess = FALSE;
    NTSTATUS Status;
    PSID  psidAdmin, psidUser;
    UINT  cb = sizeof( SECURITY_DESCRIPTOR ) + 2 * sizeof(PSID);
    UINT  cbAcl = sizeof(ACL);
    PACL  pAcl;
    PSID *ppsidAdmin, *ppsidUser;
    SID_IDENTIFIER_AUTHORITY gSystemSidAuthority = SECURITY_NT_AUTHORITY;
    HANDLE  hUserToken;
    PTOKEN_USER pTokenUser = NULL;
    DWORD   cbNeeded;

    /*
     * Initialize pointers to dynamic memory blocks
     */
    psa->lpSecurityDescriptor = NULL;
    psidAdmin = NULL;
    psidUser  = NULL;

    /*
     * Get the SID of the bult-in Administrators group
     */
    Status = RtlAllocateAndInitializeSid(
                     &gSystemSidAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,0,0,0,0,0,
                     &psidAdmin);
    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("KERNEL32: Couldn't allocate Administrators SID (0x%x)\n", Status );
#endif
        goto done;
    }

    /*
     * Get the SID for the current user from their process token
     */
    Status = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &hUserToken);
    if (Status == STATUS_NO_TOKEN) {
        Status = NtOpenProcessToken(
                         NtCurrentProcess(),
                         TOKEN_QUERY,
                         &hUserToken);
    }
    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("KERNEL32: Couldn't access process' token (0x%x)\n", Status );
#endif
        RtlFreeHeap( RtlProcessHeap(), 0, psidAdmin );
        goto done;
    }
    Status =  NtQueryInformationToken(
                      hUserToken,
                      TokenUser,
                      NULL,
                      0,
                      &cbNeeded );
    if (Status == STATUS_BUFFER_TOO_SMALL) {
        pTokenUser = (PTOKEN_USER)RtlAllocateHeap( RtlProcessHeap(), 0, cbNeeded );
        if (pTokenUser != NULL) {
            Status =  NtQueryInformationToken(
                              hUserToken,
                              TokenUser,
                              (LPVOID)pTokenUser,
                              cbNeeded,
                              &cbNeeded );
            if (NT_SUCCESS(Status)) {
                /*
                 * Make a copy of the user's SID
                 */
                psidUser = RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthSid(pTokenUser->User.Sid) );
                if (psidUser != NULL) {
                    Status = RtlCopySid( RtlLengthSid(pTokenUser->User.Sid), psidUser, pTokenUser->User.Sid );
                } else {
                    Status = STATUS_NO_MEMORY;
                }
            }
        } else {
            Status = STATUS_NO_MEMORY;
        }
    }

    if (pTokenUser != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, pTokenUser );
    }
    NtClose(hUserToken);

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("KERNEL32: Couldn't query user's token (0x%x)\n", Status );
#endif
        RtlFreeHeap( RtlProcessHeap(), 0, psidAdmin );
        if (psidUser != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, psidUser );
        }
        goto done;
    }

    /*
     * Figure out how much memory we need to allocate for the SD
     */
    cbAcl += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid( psidUser ) - sizeof(DWORD);
    cbAcl += sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid( psidAdmin ) - sizeof(DWORD);

    /*
     * Allocate all the memory we need for the security descriptor
     */
    if ( !(psa->lpSecurityDescriptor =
             (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb + cbAcl ) ) ) {
#if DBG
        DbgPrint("KERNEL32: No memory to create security descriptor (%d)\n",
                  cb + cbAcl);
#endif
        goto done;
    }

    /*
     * Divvy up our memory block to include SIDs and ACLs
     */
    ppsidAdmin = (PSID*)((ULONG_PTR)psa->lpSecurityDescriptor + sizeof(SECURITY_DESCRIPTOR));
    ppsidUser  = (PSID*)((ULONG_PTR)ppsidAdmin + sizeof(PSID));
    pAcl = (PACL)((ULONG_PTR)ppsidUser + sizeof(PSID));
    /*
     * Save the SIDs - the SIDs must not be freed until we're done
     * using the security descriptor
     */
    *ppsidAdmin = psidAdmin;
    *ppsidUser  = psidUser;

    /*
     * Initialize the rest of the security attributes structure
     */
    psa->nLength = sizeof( SECURITY_ATTRIBUTES );
    psa->bInheritHandle = FALSE;

    /*
     * Initialize the security descriptor
     */
    if ( Status = RtlCreateSecurityDescriptor(
                                            psa->lpSecurityDescriptor,
                                            SECURITY_DESCRIPTOR_REVISION ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) initializing security descriptor\n",
                  Status );
#endif
        goto done;
    }

    /*
     * Set the owner
     */
    if ( Status = RtlSetOwnerSecurityDescriptor( psa->lpSecurityDescriptor,
                                                 NULL, FALSE ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) setting security descriptor owner\n",
                  Status );
#endif
        goto done;
    }

    /*
     * Set the group
     */
    if ( Status = RtlSetGroupSecurityDescriptor( psa->lpSecurityDescriptor,
                                      psidAdmin, FALSE ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) setting security descriptor owner\n",
                  Status );
#endif
        goto done;
    }

    /*
     * Initialize the ACL
     */
    if ( Status = RtlCreateAcl( pAcl, cbAcl, ACL_REVISION ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) initializing ACL\n",
                  Status );
#endif
        goto done;
    }

    /*
     * Add user ACE
     */
    if ( Status = CtxAddAccessAllowedAce( pAcl, ACL_REVISION, GENERIC_ALL, psidUser, 0 ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) adding user ACE\n", Status );
#endif
        goto done;
    }

    /*
     * Add Administrators ACE
     */
    if ( Status = CtxAddAccessAllowedAce( pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin, 1 ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) adding admin ACE\n", Status );
#endif
        goto done;
    }

    /*
     * Set the discretionary ACL
     */
    if ( Status = RtlSetDaclSecurityDescriptor( psa->lpSecurityDescriptor,
                                                TRUE, pAcl, FALSE ) ) {
#if DBG
        DbgPrint( "KERNEL32: Error (%08X) setting security descriptor owner\n",
                  Status );
#endif
        goto done;
    }

    fSuccess = TRUE;

done:
    if ( !fSuccess && psa->lpSecurityDescriptor ) {
       CtxFreeSecurityDescriptor( psa );
    }
    return( fSuccess );
}

/******************************************************************************
 *
 *  CtxFreeSecurityDescriptor
 *
 *  This routine will free resources allocated in a corresponding
 *  CtxCreateSecurityDescriptor() call.
 *
 *  ENTRY:
 *     psa (input)
 *       Pointer to security attributes
 *
 *  EXIT:
 *      TRUE if successful, FALSE if error occurred
 *
 *      (GetLastError() can be called to retrieve error code)
 *
 *****************************************************************************/
BOOL CtxFreeSecurityDescriptor( PSECURITY_ATTRIBUTES psa )
{
    BOOL fSuccess = TRUE;
    PSID *ppsidAdmin, *ppsidUser;

    if ( psa->lpSecurityDescriptor ) {
        ppsidAdmin = (PSID*)((ULONG_PTR)psa->lpSecurityDescriptor + sizeof(SECURITY_DESCRIPTOR));
        ppsidUser  = (PSID*)((ULONG_PTR)ppsidAdmin + sizeof(PSID));
       if ( *ppsidUser ) {
           CtxFreeSID( *ppsidUser );
       }
       if ( *ppsidAdmin ) {
           CtxFreeSID( *ppsidAdmin );
       }
       fSuccess = !LocalFree( psa->lpSecurityDescriptor );
#if DDBG
       DbgPrint( "KERNEL32: fSuccess(%d) freeing security descriptor (%08X)\n",
                  fSuccess, psa->lpSecurityDescriptor );
#endif
    }

    return( fSuccess );
}

NTSTATUS
CtxAddAccessAllowedAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ACCESS_MASK AccessMask,
    IN PSID Sid,
    IN DWORD index
    )
{
    NTSTATUS Status;
    ACE_HEADER *pHeader;

    /*
     * First add the ACL
     */
    if ( !(Status = RtlAddAccessAllowedAce( Acl, AceRevision,
                                            AccessMask, Sid ) ) ) {
        /*
         * Get the ACE
         */
        if ( Status = RtlGetAce( Acl, index, &pHeader ) ) {
#if DBG
            DbgPrint( "KERNEL32: Error (%X) from RtlGetAce\n", Status );
#endif
            goto done;
        }

        /*
         * Now set the inheritence bits
         */
        pHeader->AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    }

done:
    return( Status );
}
#endif //Bug fix #340691: Inherit the security

// from \nt\private\windows\gina\userenv\globals.h
#define PROFILE_LIST_PATH            L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"
#define DEFAULT_USER_PROFILE         L"DefaultUserProfile"
#define DEFAULT_USER                 L"Default User"

BOOL GetDefaultUserProfileName(
    LPWSTR lpProfileDir,
    LPDWORD lpcchSize
    )
{
    WCHAR*   pwszProfileName;
    BYTE     pKeyValueInfo[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+(MAX_PATH+1)*sizeof(WCHAR)];
    ULONG    ulSize;
    DWORD    dwLength;
    BOOL     bRetVal = FALSE;
    HKEY     hKey;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    UnicodeString;


    //
    // Query for the Default User profile name
    //

    RtlInitUnicodeString(&UnicodeString, PROFILE_LIST_PATH);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);


    Status = NtOpenKey( &hKey,
                        KEY_READ,
                        &ObjectAttributes );

    //lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE, PROFILE_LIST_PATH,
    //                        0, KEY_READ, &hKey);

    if (!NT_SUCCESS(Status)) {
#if DBG
        DbgPrint("TSAppCmp:GetDefaultUserProfileName:  Failed to open profile list key with 0x%x.",Status);
#endif
        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }

    //lResult = RegQueryValueExW(hKey, DEFAULT_USER_PROFILE, NULL, &dwType,
    //                           (LPBYTE) wszProfileName, &dwSize);

    RtlInitUnicodeString(&UnicodeString, DEFAULT_USER_PROFILE);

    Status = NtQueryValueKey( hKey,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              pKeyValueInfo,
                              sizeof(pKeyValueInfo),
                              &ulSize);

    pwszProfileName = (WCHAR*)(((PKEY_VALUE_PARTIAL_INFORMATION)pKeyValueInfo)->Data);

    if (!NT_SUCCESS(Status)) {
        lstrcpy (pwszProfileName, DEFAULT_USER);
    }

    NtClose(hKey);


    //
    // Save the result if possible
    dwLength = lstrlen(pwszProfileName) + 1;

    if (lpProfileDir) {

        if (*lpcchSize >= dwLength) {
            lstrcpy (lpProfileDir, pwszProfileName);
            bRetVal = TRUE;

        } else {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }

    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
    }


    *lpcchSize = dwLength;

    return bRetVal;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\objrules.h ===
/*************************************************************************
* objrules.h
*
* Defines and function declarations for Object Rule caching
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

#include <winsta.h>
#include <syslib.h>
#include <regapi.h>

// Registry keys under application compatibility section
// (CITRIX_COMPAT_APP)\\<appname>

#define TERMSRV_COMPAT_OBJRULES      REG_OBJRULES
#define TERMSRV_COMPAT_DLLRULES      REG_DLLRULES

// Registry values under ObjectRules and DllRules
#define USER_GLOBAL_SEMAPHORES      COMPAT_RULES_USER_GLOBAL_SEMAPHORES
#define USER_GLOBAL_EVENTS          COMPAT_RULES_USER_GLOBAL_EVENTS
#define USER_GLOBAL_MUTEXES         COMPAT_RULES_USER_GLOBAL_MUTEXES
#define USER_GLOBAL_SECTIONS        COMPAT_RULES_USER_GLOBAL_SECTIONS
#define SYSTEM_GLOBAL_SEMAPHORES    COMPAT_RULES_SYSTEM_GLOBAL_SEMAPHORES
#define SYSTEM_GLOBAL_EVENTS        COMPAT_RULES_SYSTEM_GLOBAL_EVENTS
#define SYSTEM_GLOBAL_MUTEXES       COMPAT_RULES_SYSTEM_GLOBAL_MUTEXES
#define SYSTEM_GLOBAL_SECTIONS      COMPAT_RULES_SYSTEM_GLOBAL_SECTIONS

// Object Rule Structure

typedef struct ObjRule {
    struct ObjRule *Next;
    BOOL WildCard;
    ULONG MatchLen;     // Wildcard match length
    BOOL SystemGlobal;  // If TRUE, object is system global, otherwise USER_GLOBAL
    WCHAR ObjName[1];
} OBJRULE, *POBJRULE;


typedef struct ObjRuleList {
    POBJRULE First;
    POBJRULE Last;
} OBJRULELIST, *POBJRULELIST;

typedef struct RuleInitEntry {
    POBJRULELIST ObjRuleList;
    PWCHAR  UserGlobalValue;
    PWCHAR  SystemGlobalValue;
} RULEINITENTRY, *PRULEINITENTRY;


extern OBJRULELIST SemaRuleList;
extern OBJRULELIST MutexRuleList;
extern OBJRULELIST SectionRuleList;
extern OBJRULELIST EventRuleList;

extern void CtxLookupObjectRule(POBJRULELIST,LPCWSTR,LPWSTR);
extern void CtxInitObjRuleCache(void);

// Macro used by object creation APIs
#define LookupObjRule(RuleList,ObjName,ObjNameExt) \
{ \
    if ((RuleList)->First) { \
        CtxLookupObjectRule(RuleList,ObjName,ObjNameExt); \
    } \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\precomp.h ===
#define _HYDRA_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <tsappcmp.h>
#include "winsta.h"
#include "winbasep.h"
#include "inipath.h"
#include "syslib.h"
#include "compatfl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\msihooks.cpp ===
/****************************************************************************************
* MSI will call these APIs to ask TS to propogate changes from .Default to the TS hive. 
*                                                                                       
* NTSTATUS TermServPrepareAppInstallDueMSI()                                            
*
* NTSTATUS TermServProcessAppIntallDueMSI( BOOLEAN cleanup )                            
* 
* These API need not be called in the same boot cycles, many boot cycles could
* happen in between.
*
* Copyright (C) 1997-1999 Microsoft Corp.
****************************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <stdio.h>
#include <windows.h>
#include <winuser.h>
#include <stdlib.h>
#include <tsappcmp.h>
#include <stdio.h>
#include <fcntl.h>

#include "KeyNode.h"
#include "ValInfo.h"

// real externs!
extern "C" {
void TermsrvLogRegInstallTime(void);
}

// forward declaration
extern        NTSTATUS DeleteReferenceHive(WCHAR *);
extern        NTSTATUS CreateReferenceHive( WCHAR *, WCHAR *);
extern        NTSTATUS DeltaDeleteKeys(WCHAR *, WCHAR *, WCHAR *);
extern        NTSTATUS DeltaUpdateKeys(WCHAR *, WCHAR *, WCHAR *);

ULONG   g_length_TERMSRV_USERREGISTRY_DEFAULT;
ULONG   g_length_TERMSRV_INSTALL;
WCHAR   g_debugFileName[MAX_PATH];
FILE    *g_debugFilePointer=NULL;
BOOLEAN g_debugIO = FALSE;
BOOLEAN KeyNode::debug=FALSE; // init the static

#define TERMSRV_USERREGISTRY_DEFAULT TEXT("\\Registry\\USER\\.Default")

// This is for debug I/O, output looks better with it.
void    Indent( ULONG indent)
{

    for ( ULONG i = 1; i <indent ; i++ )
    {
        fwprintf( g_debugFilePointer, L"  ");
    }
}

// a key name is written to the log file based on the contect of pBasicInfo
void DebugKeyStamp( NTSTATUS status, KeyBasicInfo *pBasicInfo, int indent , WCHAR *pComments=L"" )
{
    Indent(indent);
    fwprintf( g_debugFilePointer,L"%ws, status=%lx, %ws\n",pBasicInfo->NameSz(), status , pComments);
    fflush( g_debugFilePointer );                             
    DbgPrint("%ws\n",pBasicInfo->NameSz());
}

// a debug stamp is written to the log file, including the line number where error happened
void DebugErrorStamp(NTSTATUS status , int lineNumber, ValueFullInfo    *pValue=NULL)
{
    fwprintf( g_debugFilePointer, 
        L"ERROR ?!? status = %lx, linenumber:%d\n", status, lineNumber);
    if (pValue)
    {
        pValue->Print(g_debugFilePointer);
    }
    fflush(g_debugFilePointer); 
}

// use this func to track the status value which is used to bail out in 
// case of an error.
// this is only used in teh debug build, see below
BOOL    NT_SUCCESS_OR_ERROR_STAMP( NTSTATUS    status,  ULONG   lineNumber) 
{
    if ( g_debugIO )
    {   
        if ( ( (ULONG)status) >=0xC0000000 )
        {
            DebugErrorStamp( status, lineNumber );
        }
    }

    return ( (NTSTATUS)(status) >= 0 );
}

#ifdef DBG
#define NT_SUCCESS_EX(Status) NT_SUCCESS_OR_ERROR_STAMP( (Status), __LINE__ )
#else
#define NT_SUCCESS_EX(Status) NT_SUCCESS(Status)
#endif

/***************************************************************************
*
*  All three branch-walker functions use this method to alter the status code, and
*  if necessary, log an error message to the log file
*
***************************************************************************/
NTSTATUS AlterStatus( NTSTATUS status , int lineNumber )
{
    switch( status )
    {
    case STATUS_ACCESS_DENIED:
        // this should never happen since we run in the system context
        if ( g_debugIO )
        {
            DebugErrorStamp( status, lineNumber );
        }
        status = STATUS_SUCCESS;
        break;

    case STATUS_SUCCESS:
        break;

    case STATUS_NO_MORE_ENTRIES:
        status = STATUS_SUCCESS;
        break;

    default:
        if ( g_debugIO )
        {
            DebugErrorStamp( status, lineNumber );
        }
        break;


    }
    return status;
}

/******************************************************************************
*
* Based on a special reg key/value init the debug flags and pointers which are
* used to log debug info into a log file. When called with start=TRUE, the
* relevant data structs are initialized. When called with start=FALSE, the log
* file is closed.
*
******************************************************************************/
void InitDebug( BOOLEAN start)
{
    if ( start )
    {
        KeyNode tsHiveNode (NULL, KEY_READ, TERMSRV_INSTALL );
    
        if ( NT_SUCCESS( tsHiveNode.Open() ) )
        {
            ValuePartialInfo    debugValue( &tsHiveNode );
            if ( NT_SUCCESS( debugValue.Status() ) && NT_SUCCESS( debugValue.Query(L"TS_MSI_DEBUG") ) )
            {
                g_debugIO = TRUE;
                KeyNode::debug=TRUE;
                for (ULONG i =0; i < debugValue.Ptr()->DataLength/sizeof(WCHAR); i++)
                {
                    g_debugFileName[i] = ((WCHAR*)(debugValue.Ptr()->Data))[i];
                }
                g_debugFileName[i] = L'\0';
    
                g_debugFilePointer = _wfopen( g_debugFileName, L"a+" );
                fwprintf( g_debugFilePointer, L"----\n");
            }
        }
    }
    else
    {
        if ( g_debugFilePointer )
        {
            fclose(g_debugFilePointer);
        }
    }
}

/***************************************************************************
*
* Function:
*  TermServPrepareAppInstallDueMSI()
*
* Description:
*  MSI service calls this function prior to starting an installation cycle.
*  When called, this function blows away the RefHive (in case it was around 
*  with some stale data...), and then it creates a fresh copy of 
*  .Default\Software as the new RefHive.
*
* Return:
*   NTSTATUS
*
***************************************************************************/
NTSTATUS TermServPrepareAppInstallDueMSI()
{
    NTSTATUS    status = STATUS_SUCCESS;

    WCHAR   sourceHive[MAX_PATH];
    WCHAR   referenceHive[MAX_PATH];
    WCHAR   destinationHive[MAX_PATH];

    wcscpy(sourceHive,  TERMSRV_USERREGISTRY_DEFAULT );
    wcscat(sourceHive, L"\\Software");
    g_length_TERMSRV_USERREGISTRY_DEFAULT = wcslen( TERMSRV_USERREGISTRY_DEFAULT );

    wcscpy(referenceHive, TERMSRV_INSTALL );
    wcscat(referenceHive, L"\\RefHive");
    g_length_TERMSRV_INSTALL = wcslen( TERMSRV_INSTALL );

    InitDebug( TRUE );

    if ( g_debugIO)
    {
        fwprintf( g_debugFilePointer,L"In %ws\n",
                  L"TermServPrepareAppInstallDueMSI");
        fflush( g_debugFilePointer );
    }

    // delete the existing hive (if any )
    status = DeleteReferenceHive( referenceHive );

    if ( NT_SUCCESS( status ) )
    {
        // 1-COPY
        // copy all keys under .Default\Software into a special location 
        // under our TS hive, let's call it the RefHive
        status = CreateReferenceHive(sourceHive, referenceHive);

    }

    InitDebug( FALSE );

    return status;
}

/**********************************************************************************
*
* Function:
*  TermServProcessAppInstallDueMSI
* 
* Description:
*  MSI service calls this function after calling TermServPrepareAppInstallDueMSI(), 
*  and after MSI finishing making an installation which updated the .Default 
*  hive (since MSI runs in the system context). 
*  This function will compare the content of .Default\SW to RefHive and then 
*  first it will create all new (missing) keys and values. Then it will 
*  compare any existing keys from .Default\SW with the equivalent RefHive, and
*  if value is different, it will delete the equivalent value from our TS hive
*  and then create a new value identical to what was found in .Default
*
* Return:
*   NTSTATUS
*
**********************************************************************************/
NTSTATUS TermServProcessAppInstallDueMSI( BOOLEAN cleanup)
{
    NTSTATUS    status = STATUS_SUCCESS;
    WCHAR   sourceHive[MAX_PATH];
    WCHAR   referenceHive[MAX_PATH];
    WCHAR   destinationHive[MAX_PATH];

    wcscpy(sourceHive,  TERMSRV_USERREGISTRY_DEFAULT );
    wcscat(sourceHive, L"\\Software");
    g_length_TERMSRV_USERREGISTRY_DEFAULT = wcslen( TERMSRV_USERREGISTRY_DEFAULT );

    wcscpy(referenceHive, TERMSRV_INSTALL );
    wcscat(referenceHive, L"\\RefHive");
    g_length_TERMSRV_INSTALL = wcslen( TERMSRV_INSTALL );

    wcscpy(destinationHive, TERMSRV_INSTALL );
    wcscat(destinationHive, L"\\Software");

    InitDebug( TRUE );

    if ( g_debugIO)
    {
        fwprintf( g_debugFilePointer,L"In %ws, cleanup=%lx\n",
                  L"TermServProcessAppIntallDueMSI", cleanup);
        fflush( g_debugFilePointer );
    }

    if ( !cleanup )
    {
        // 2-DELETE
        // compare .Dfeault keys to the equivalent keys in RefHive. If keys are
        // missing from .Default, then delete the equivalent keys from our
        // HKLM\...\TS\ hive
         status = DeltaDeleteKeys(sourceHive, referenceHive, destinationHive);
    
        if (NT_SUCCESS( status ) )
        {
            // Steps 3 and 4 are now combined.
            // 3-CREATE
            // compare .Default keys to the equivalent keys in RefHive, if keys are
            // present in .Default that are missing from RefHive, then, add those keys
            // to our HKLM\...\TS hive
            // 4-CHANGE
            // compare keys of .Default to RefHive. Those keys that are newer than 
            // RefHive, then, update the equivalent keys in HKLM\...\TS
        
            status = DeltaUpdateKeys(sourceHive, referenceHive, destinationHive);

            if (NT_SUCCESS( status ))
            {
                // update the time stamp in our hive since we want the standared TS reg key
                // propogation to take place.
                TermsrvLogRegInstallTime();


            }
        }
    }
    else
    {
        // blow away the existing reference hive, 
        status = DeleteReferenceHive( referenceHive ); 
    }

    InitDebug( FALSE );

    return status;
}

/*******************************************************************
*
* Function:
*  EnumerateAndCreateRefHive
*
* Parameters:
*  pSource points to the parent node, the branch we copy 
*  pref points to our RefHive which we are creating as a ref image
*  pBasicInfo is a scratch pad passed around which is used to 
*  extract basic Key information
*  pindextLevel is used to format the debug log output file
*
* Descritption:
*  Create a copy of the .Default\Sofwtare as our RefHive
*
* Return:
*  NTSTATUS
*******************************************************************/
NTSTATUS EnumerateAndCreateRefHive(    
    IN KeyNode      *pSource,
    IN KeyNode      *pRef,
    IN KeyBasicInfo *pBasicInfo,
    IN ULONG        *pIndentLevel
    )
{
    NTSTATUS    status=STATUS_SUCCESS;
    ULONG   ulCount=0;

    UNICODE_STRING  UniString;

    (*pIndentLevel)++;

    while( NT_SUCCESS(status)) 
    {
        ULONG       ultemp;

        status = NtEnumerateKey(    pSource->Key(),
                                    ulCount++,
                                    pBasicInfo->Type() , // keyInformationClass,
                                    pBasicInfo->Ptr(),   // pKeyInfo,
                                    pBasicInfo->Size(),  // keyInfoSize,
                                    &ultemp);

        if (NT_SUCCESS(status))                        
        {
            if ( g_debugIO)
            {
                DebugKeyStamp( status , pBasicInfo, *pIndentLevel );
            }
            
            // open a sub key
            KeyNode SourceSubKey(      pSource, pBasicInfo);

            // create the Ref sub key
            KeyNode RefSubKey( pRef, pBasicInfo);

            if (NT_SUCCESS_EX( status = SourceSubKey.Open() ) )
            {
                if ( NT_SUCCESS_EX( status = RefSubKey.Create() ) ) 
                {
                    NTSTATUS                status3;
                    KEY_FULL_INFORMATION    *ptrInfo;
                    ULONG                   size;
    
                    if (NT_SUCCESS(SourceSubKey.Query( &ptrInfo, &size )))
                    {
                        ValueFullInfo   valueFullInfo( &SourceSubKey );
                        ValueFullInfo   RefValue( &RefSubKey );
    
                        if ( NT_SUCCESS_EX( status = valueFullInfo.Status()) 
                             && NT_SUCCESS_EX(status = RefValue.Status()) )
                        {
                            for (ULONG ulkey = 0; ulkey < ptrInfo->Values; ulkey++) 
                            {
                                status = NtEnumerateValueKey(SourceSubKey.Key(),
                                                 ulkey,
                                                 valueFullInfo.Type(),
                                                 valueFullInfo.Ptr(),
                                                 valueFullInfo.Size(),
                                                 &ultemp);
    
                                if (NT_SUCCESS( status ))
                                {
                                    status = RefValue.Create( &valueFullInfo );
                                    // if status is not good, we bail out, since var "status" is set here
                                }
                                // else, no more entries left, we continue
                            }
                        }
                        // else, out of memory, status is set, we bail out.
                    }
                    // else, no values are present, continue with sub-key enums

                    if (NT_SUCCESS( status ) )
                    {
                        // enumerate sub key down.
                        status = EnumerateAndCreateRefHive(
                                    &SourceSubKey,
                                    &RefSubKey,
                                    pBasicInfo, 
                                    pIndentLevel
                                   );
                    }
                }
                // else, an error, status is set, so we bail out
    
            }// else, open on source has failed, var-status is set, we bail out

            status = AlterStatus( status, __LINE__ );
            // else, an error, status is set, so we bail out
        }
        // else, no more left

    }

    (*pIndentLevel)--;

    return( status );
}

/*******************************************************************
*
* Function:
*  EnumerateAndDeltaDeleteKeys
*
* Parameters:
*  pSource points to a node under .Dfeault
*  pref points to a node under our RefHive 
*  pDestination is a node under our TS\install\SW hive
*  pBasicInfo is a scratch pad passed around which is used to 
*  extract basic Key information
*  pindextLevel is used to format the debug log output file
*
* Descritption:
*  compare source to ref, if keys/values in source are deleted, then
*  delete the equivalent key/value from destination 
*
* Return:
*   NTSTATUS
*******************************************************************/
NTSTATUS EnumerateAndDeltaDeleteKeys( 
        IN KeyNode      *pSource,   // this is under the latest updated .Default\SW hive
        IN KeyNode      *pRef,      // this was a ref-copy of .Default\SW before the update
        IN KeyNode      *pDestination,// this is opur private TS-hive 
        IN KeyBasicInfo *pBasicInfo, 
        IN ULONG        *pIndentLevel)
{
    NTSTATUS    status=STATUS_SUCCESS, st2;
    ULONG   ulCount=0;

    UNICODE_STRING          UniString;
    ULONG                   size;

    (*pIndentLevel)++;

    while (NT_SUCCESS(status)) 
    {
        ULONG       ultemp;

        status = NtEnumerateKey(    pRef->Key(),
                                    ulCount++,
                                    pBasicInfo->Type() , // keyInformationClass,
                                    pBasicInfo->Ptr(),  // pKeyInfo,
                                    pBasicInfo->Size(),  // keyInfoSize,
                                    &ultemp);

        // pBasicInfo was filled up thru NtEnumerateKey() above

        if (NT_SUCCESS(status))                        
        {
            if ( g_debugIO)
            {
                DebugKeyStamp( status , pBasicInfo, *pIndentLevel );
            }
            
            KeyNode RefSubKey(    pRef,   pBasicInfo);
            KeyNode SourceSubKey( pSource,pBasicInfo);
            KeyNode DestinationSubKey( pDestination, pBasicInfo);

            RefSubKey.Open();
            SourceSubKey.Open();
            DestinationSubKey.Open();

            if (NT_SUCCESS( RefSubKey.Status() )  )
            {
                if ( ! NT_SUCCESS( SourceSubKey.Status () ) )
                {
                    // key is missing from the .Default\SW hive, we should delete
                    // the same sub-tree from our TS\Install\SW hive
                    if ( NT_SUCCESS( DestinationSubKey.Status()) )  
                    {
                        DestinationSubKey.DeleteSubKeys();
                        NTSTATUS st = DestinationSubKey.Delete();

                        if ( g_debugIO)
                        {
                            DebugKeyStamp( st, pBasicInfo, *pIndentLevel );
                        }
                                
                    }
                    // else
                    // As long as the key is missing from
                    // Ts\install\Hive, we will regard this condition as acceptable.
                }
                else
                {
                    // see if any values have been deleted

                    // don't bother unless the destination key exists, otherwise, no values 
                    // will be there to delete...
                    if ( NT_SUCCESS( DestinationSubKey.Status() ) )
                    {

                        KEY_FULL_INFORMATION    *ptrInfo;
                        ULONG   size;
    
                        if (NT_SUCCESS_EX(status = RefSubKey.Query( &ptrInfo, &size )))
                        {
                            // from the key-full-information, create a key-value-full-information     

                            ValueFullInfo   refValueFullInfo( &RefSubKey );
                            ValueFullInfo   sourceValue( &SourceSubKey );
                             
                            // if no allocation errors, then...
                            if ( NT_SUCCESS_EX( status = refValueFullInfo.Status() ) 
                                 && NT_SUCCESS_EX( status = sourceValue.Status() ) )
                            {
                                for (ULONG ulkey = 0; ulkey < ptrInfo->Values; ulkey++) 
                                {
                                    if ( NT_SUCCESS_EX (
                                        status = NtEnumerateValueKey(RefSubKey.Key(),
                                                     ulkey,
                                                     refValueFullInfo.Type(),
                                                     refValueFullInfo.Ptr(),
                                                     refValueFullInfo.Size(),
                                                     &ultemp)  )  )
                                    {
                                                         
                                        // for every value, see if the same value
                                        // exists in the SourceSubKey. If it doesn't
                                        // then delete the corresponding value from 
                                        // TS's hive
        
                                        sourceValue.Query( refValueFullInfo.SzName() );
    
                                        // if .Default\SW is missing a value, then delete the
                                        // corresponding value from our TS\ hive
                                        if ( sourceValue.Status() == STATUS_OBJECT_NAME_NOT_FOUND )
                                        {
                                            ValuePartialInfo    destinationValue( &DestinationSubKey);

                                            if (NT_SUCCESS_EX( status = destinationValue.Status () ) )
                                            {
                                                destinationValue.Delete( refValueFullInfo.SzName() );
                                            }
                                            // else, alloc error, status is set
                                        }
                                        else 
                                        {
                                            if ( !NT_SUCCESS_EX ( status = sourceValue.Status() ) )
                                            {
                                                if ( g_debugIO )
                                                {
                                                    DebugErrorStamp(status, __LINE__ );
                                                }
                                                // else, we will bail out here since var-status is set
                                            }
                                            // else, no error 
                                        }
                                        // if-else
                                    }
                                    // else, no more entries

                                } // for loop
                            }
                            // else, we have an error due to no memory, var-status is set
                        }
                        // else, we have an error since we can not get info on this existing ref key, var-status is set
            
                        if ( NT_SUCCESS( status ) )
                        {
                            // we were able to open the source key, which means that
                            // key was not deleted from .default. 
                            // so keep enuming away...
                            status = EnumerateAndDeltaDeleteKeys( 
                                &SourceSubKey,
                                &RefSubKey,
                                &DestinationSubKey,
                                pBasicInfo ,
                                pIndentLevel);
        
                        }
                        //else, status is bad, no point to traverse, we are bailing out
                    }
                    //else, there is no destination sub key to bother with deletion
                }
                // if-else
            }
            // else, ref had no more sub-keys

            status = AlterStatus( status, __LINE__ );
        }
        // else, no more entries
    }

    (*pIndentLevel)--;

    // the typical status would be: STATUS_NO_MORE_ENTRIES 
    return status;
}

/*******************************************************************
*
* Function:
*  EnumerateAndDeltaUpdateKeys
*
* Parameters:
*  pSource points to a node under .Dfeault
*  pref points to a node under our RefHive 
*  pDestination is a node under our TS\install\SW hive
*  pBasicInfo is a scratch pad passed around which is used to 
*  extract basic Key information
*  pindextLevel is used to format the debug log output file
*
* Descritption:
*  compare source to ref, if new keys/values in source have been created
*  then create the equivalent keys in our Ts\Install\SW branch (pDestination)
*  Also, check all values in pSource to values in pRef, if not the same
*  then delete the equivalent pDestination and create a new value
*  identical to value from pSource
*
* Return:
*   NTSTATUS
*******************************************************************/
NTSTATUS EnumerateAndDeltaUpdateKeys( 
        IN KeyNode      *pSource,   // this is under the latest updated .Default\SW hive
        IN KeyNode      *pRef,      // this was a ref-copy of .Default\SW before the update
        IN KeyNode      *pDestination,// this is opur private TS-hive 
        IN KeyBasicInfo *pBasicInfo, 
        IN ULONG        *pIndentLevel)
{
    NTSTATUS    status=STATUS_SUCCESS, st2;
    ULONG   ulCount=0;

    UNICODE_STRING          UniString;
    ULONG                   size;

    (*pIndentLevel)++;

    while (NT_SUCCESS_EX(status)) 
    {
        ULONG       ultemp;

        status = NtEnumerateKey(    pSource->Key(),
                                    ulCount++,
                                    pBasicInfo->Type() , // keyInformationClass,
                                    pBasicInfo->Ptr(),  // pKeyInfo,
                                    pBasicInfo->Size(),  // keyInfoSize,
                                    &ultemp);

        // pBasicInfo was filled up thru NtEnumerateKey() above

        if (NT_SUCCESS_EX(status))                        
        {
            if ( g_debugIO)
            {
                DebugKeyStamp( status , pBasicInfo, *pIndentLevel );
            }
            
            KeyNode RefSubKey(    pRef,   pBasicInfo);
            KeyNode SourceSubKey( pSource,pBasicInfo);

            // calling Open() on this may fail, and we will need to delete and recreate it if required.
            KeyNode *pDestinationSubKey = new KeyNode( pDestination, pBasicInfo);

            RefSubKey.Open();
            SourceSubKey.Open();

            if ( pDestinationSubKey )
            {
                pDestinationSubKey->Open();

                if (NT_SUCCESS_EX( status = SourceSubKey.Status() )  )
                {
                    // key is missing from the ref-hive, we should add
                    // the same sub-tree into our TS\Install\SW hive
                    if ( RefSubKey.Status() == STATUS_OBJECT_NAME_NOT_FOUND 
                         || RefSubKey.Status() == STATUS_OBJECT_PATH_SYNTAX_BAD)  
                    {
                        // @@@
                        // we expect the key not to exist, if it does, then what? delete it?
                        if ( !NT_SUCCESS( pDestinationSubKey->Status()) )
                        {
                            // here is what were are doing with the strings: 
                            // 1) get the path below the "\Registry\User\.Default", which would be
                            // something like "\Software\SomeDir\SomeDirOther\etc", this is the sub-path
                            // 2) create a new node at the destination, which would be something like:
                            // \HKLM\SW\MS\Windows NT\CurrentVersion\TS\INstall + the sub path
                            // we got above.

                            PWCHAR  pwch;
                            SourceSubKey.GetPath( &pwch );
        
                            // this is the trailing part of the key-path missing from our TS hive
                            PWCHAR  pDestinationSubPath = &pwch[g_length_TERMSRV_USERREGISTRY_DEFAULT ];
                            PWCHAR  pDestinationFullPath= new WCHAR [ g_length_TERMSRV_INSTALL + 
                                                    wcslen( pDestinationSubPath) + sizeof(WCHAR )];
                            wcscpy( pDestinationFullPath, TERMSRV_INSTALL );
                            wcscat( pDestinationFullPath, pDestinationSubPath );

        
                            DELETE_AND_NULL( pDestinationSubKey ); 
                            // create a new KeyNode object where the root will be TERMSRV_INSTALL,
                            // below which we will create a sub-layer of nodes, or  a single node.
                            pDestinationSubKey = new KeyNode( NULL , pDestination->Masks(), pDestinationFullPath);

                            // create the new key/branch/values
                            status = pDestinationSubKey->CreateEx() ;

                            if ( g_debugIO )
                            {
                                DebugKeyStamp( status, pBasicInfo, *pIndentLevel , L"[KEY WAS CREATED]");
                            }

                        } 
            
                    }                     
                    else
                    {
                        // if we have anything but success, set status and bail out
                        if ( !NT_SUCCESS_EX( status = RefSubKey.Status()) )
                        {
                            if ( g_debugIO )
                            {
                                DebugErrorStamp(status, __LINE__ );
                            }
                        }
                    }

                    // Key (if it is NEW) is NOT missing from destination hive at this point
                    // either it did exist, or was created in the above block of code

                    // check if there are any new values in this node.

                    KEY_FULL_INFORMATION    *ptrInfo;
                    ULONG                   size;

                    NTSTATUS st3 = SourceSubKey.Query( &ptrInfo, &size );

                    if (NT_SUCCESS( st3 ))
                    {
                        ValueFullInfo    sourceValueFullInfo( &SourceSubKey );

                        if ( NT_SUCCESS_EX( status = sourceValueFullInfo.Status() ) )
                        {
                            for (ULONG ulkey = 0; ulkey < ptrInfo->Values; ulkey++) 
                            {
                                status = NtEnumerateValueKey(SourceSubKey.Key(),
                                                 ulkey,
                                                 sourceValueFullInfo.Type(),
                                                 sourceValueFullInfo.Ptr(),
                                                 sourceValueFullInfo.Size(),
                                                 &ultemp);
                                                 
                                // @@@
                                if ( ! NT_SUCCESS( status ))
                                {
                                    DebugErrorStamp( status, __LINE__ );
                                }

                                // if the ref key is missing a value, then add
                                // value to the destination key.

                                KEY_VALUE_PARTIAL_INFORMATION *pValuePartialInfo;
                                ValuePartialInfo    refValuePartialInfo( &RefSubKey );

                                if ( NT_SUCCESS_EX( status = refValuePartialInfo.Status() ) )
                                {
                                    refValuePartialInfo.Query( sourceValueFullInfo.SzName() );
        
                                    // if .Default\SW has a value that is missing from the ref hive, then add 
                                    // corresponding value into our TS\ hive
                                    if ( !NT_SUCCESS( refValuePartialInfo.Status()) )
                                    {
                                        // make sure pDestinationSubKey exists, else, create the key first before we
                                        // write a value. It is possible that even though the key did exists in the ref
                                        // hive at the start, a new value was added for the first time, which means that the
                                        // ts hive is getting the key and the value for the first time.
                                        if ( !NT_SUCCESS( pDestinationSubKey->Status() ) )
                                        {
                                            // here is what were are doing with the strings: 
                                            // 1) get the path below the "\Registry\User\.Default", which would be
                                            // something like "\Software\SomeDir\SomeDirOther\etc", this is the sub-path
                                            // 2) create a new node at the destination, which would be something like:
                                            // \HKLM\SW\MS\Windows NT\CurrentVersion\TS\INstall + the sub path
                                            // we got above.
                    
                                            PWCHAR  pwch;
                                            SourceSubKey.GetPath( &pwch );
                        
                                            // this is the trailing part of the key-path missing from our TS hive
                                            PWCHAR  pDestinationSubPath = &pwch[g_length_TERMSRV_USERREGISTRY_DEFAULT ];
                                            PWCHAR  pDestinationFullPath= new WCHAR [ g_length_TERMSRV_INSTALL + 
                                                                    wcslen( pDestinationSubPath) + sizeof(WCHAR )];
                                            wcscpy( pDestinationFullPath, TERMSRV_INSTALL );
                                            wcscat( pDestinationFullPath, pDestinationSubPath );
                    
                        
                                            DELETE_AND_NULL( pDestinationSubKey ); 
                                            // create a new KeyNode object where the root will be TERMSRV_INSTALL,
                                            // below which we will create a sub-layer of nodes, or  a single node.
                                            pDestinationSubKey = new KeyNode( NULL , pDestination->Masks(), pDestinationFullPath);
                    
                                            // create the new key/branch/values
                                            status = pDestinationSubKey->CreateEx();
                                            if ( g_debugIO )
                                            {
                                                DebugKeyStamp( status,  pBasicInfo, *pIndentLevel, L"[KEY WAS CREATED]" );
                                            }

                                        }
                                        //else, no problem, key did exist and we don't need to create it
                    
                                        // set value at the destination node
                                        ValueFullInfo   destinationValue( pDestinationSubKey );
                                        if ( NT_SUCCESS_EX( status = destinationValue.Status()) )
                                        {
                                            status = destinationValue.Create( &sourceValueFullInfo );

                                            NT_SUCCESS_EX( status );
                                            // if status is error, we bail out.
                                        }
                                        //else, out of memory, var-status is set and we bail out.
                                        
                                    }                          
                                    else    // values are not missing, see if they are the same
                                    {
                                        // compare the two data buffers, if the one from SourceSubKey is
                                        // different than the one from the RefSubKey, then delete
                                        // and create one in DestinationSubKey
        
                                        ValueFullInfo   sourceValue( &SourceSubKey);
                                        ValueFullInfo   refValue   ( &RefSubKey   );

                                        if (NT_SUCCESS_EX( status = refValue.Status()) 
                                            && NT_SUCCESS_EX( status = sourceValue.Status())
                                            )
                                        {
                                            sourceValue.Query( sourceValueFullInfo.SzName() );
                                            refValue.Query   ( sourceValueFullInfo.SzName() );
            
                                            if (NT_SUCCESS( refValue.Status()) 
                                                && NT_SUCCESS( sourceValue.Status()))
                                            {
                                                BOOLEAN theSame = sourceValue.Compare( &refValue );
                
                                                if (! theSame )
                                                {

                                                    // make sure pDestinationSubKey exists, else, create the key first before we
                                                    // write a value. It is possible that even though the key did exists in the ref
                                                    // hive at the start, a new value was added for the first time, which means that the
                                                    // ts hive is getting the key and the value for the first time.
                                                    if ( !NT_SUCCESS( pDestinationSubKey->Status() ) )
                                                    {
                                                        // here is what were are doing with the strings: 
                                                        // 1) get the path below the "\Registry\User\.Default", which would be
                                                        // something like "\Software\SomeDir\SomeDirOther\etc", this is the sub-path
                                                        // 2) create a new node at the destination, which would be something like:
                                                        // \HKLM\SW\MS\Windows NT\CurrentVersion\TS\INstall + the sub path
                                                        // we got above.
                                
                                                        PWCHAR  pwch;
                                                        SourceSubKey.GetPath( &pwch );
                                    
                                                        // this is the trailing part of the key-path missing from our TS hive
                                                        PWCHAR  pDestinationSubPath = &pwch[g_length_TERMSRV_USERREGISTRY_DEFAULT ];
                                                        PWCHAR  pDestinationFullPath= new WCHAR [ g_length_TERMSRV_INSTALL + 
                                                                                wcslen( pDestinationSubPath) + sizeof(WCHAR )];
                                                        wcscpy( pDestinationFullPath, TERMSRV_INSTALL );
                                                        wcscat( pDestinationFullPath, pDestinationSubPath );
                                
                                    
                                                        DELETE_AND_NULL( pDestinationSubKey ); 
                                                        // create a new KeyNode object where the root will be TERMSRV_INSTALL,
                                                        // below which we will create a sub-layer of nodes, or  a single node.
                                                        pDestinationSubKey = new KeyNode( NULL , pDestination->Masks(), pDestinationFullPath);
                                
                                                        // create the new key/branch/values
                                                        status = pDestinationSubKey->CreateEx();
                                                        if ( g_debugIO )
                                                        {
                                                            DebugKeyStamp( status,  pBasicInfo, *pIndentLevel , L"KEY WAS CREATED");
                                                        }
                
                                                    }
                                                    //else, no problem, key did exist and we don't need to create it
                   
                                                    ValueFullInfo   destinationValue( pDestinationSubKey );
                                                    if ( NT_SUCCESS( destinationValue.Status() ) )
                                                    {
                                                        // don't care if it exists or not, delete it first
                                                        destinationValue.Delete( sourceValueFullInfo.SzName() );
                                                    }
                                                    // else, there is no destination value to delete

                                                    // update/create item under destination

                                                    // Create a destination value identical to the source value
                                                    status = destinationValue.Create( &sourceValue );

                                                    // if status is error, we will bail out
                                                    if (!NT_SUCCESS_EX( status ))
                                                    {
                                                        if (g_debugIO)
                                                        {
                                                            DebugErrorStamp(status, __LINE__,
                                                                            &sourceValue );
                                                        }
                                                    }
                                                }
                                            }
                                            // else, values don't exits, doesn't make sense, maybe some dbug code here?
                                        }
                                        // else, var-status is set, we bail out.
                                    }
                                    //if-else
                                }
                                //else, out of memory, var-status is set, we bail out
                            }
                            // for-loop
                        }
                        //else, out of memory, var-status is set, we bail out
                    }
                    else
                    {
                        // this sbould not really happen, but for now...
                        if ( g_debugIO )
                        {
                            DebugErrorStamp( status, __LINE__ );
                        }
                    }


                    // by now, either both source and destination nodes exist, or
                    // a new destination node was just created above. In any case, 
                    // we can continue the traversal.
                    if ( NT_SUCCESS( status ) )
                    {
                        status = EnumerateAndDeltaUpdateKeys( 
                            &SourceSubKey,
                            &RefSubKey,
                             pDestinationSubKey,
                            pBasicInfo ,
                            pIndentLevel);

                        NT_SUCCESS_EX( status );
                    }
                    //else, we are bailing out
                }
                // else, var-status is set, we bail out.

                // done with this sub key, 
                DELETE_AND_NULL( pDestinationSubKey );
            }
            else
            {
                status = STATUS_NO_MEMORY;
            }

            status = AlterStatus( status, __LINE__ );
        }
        // else, no more entries
    }
    // no more entries


    (*pIndentLevel)--;
    // the typical status would be: STATUS_NO_MORE_ENTRIES 
    return status;
}

// delete the ref-hive as specific by the uniRef string
NTSTATUS DeleteReferenceHive(WCHAR *uniRef)
{
    if ( g_debugIO)
    {
        fwprintf( g_debugFilePointer,L"In %ws\n",
                  L"----DeleteReferenceHive");
        fflush( g_debugFilePointer );
    }

    NTSTATUS status = STATUS_SUCCESS;

    KeyNode Old( NULL, KEY_WRITE | KEY_READ | DELETE, uniRef );
    if ( NT_SUCCESS( Old.Open() ) )
    {
        Old.DeleteSubKeys();
        status = Old.Delete();   // delete the head of the branch
    }
    Old.Close();

    return status;
}

/****************************************************************
*
* Function:
*  CreateReferenceHive
*
* Parameters:                                                          
*  uniSource (source     ) string points to the node under .Default    
*  uniRef    (ref        ) string point to TS\Install\RefHive         
*  UniDest   (Destination) string points to TS\Install\Software     
* 
* Description:
*  from the .Default (source) hive, copy into TS\install\RefHive
*  source hive is specified by the uniSoure string, and the
*  ref-hive is specified by the uniRef string.
*
* Return:
*      NTSTATUS, if successful, then STATUS_SUCCESS
*
****************************************************************/
NTSTATUS CreateReferenceHive(WCHAR *uniSource, WCHAR *uniRef)
{
    if ( g_debugIO)
    {
        fwprintf( g_debugFilePointer,L"In %ws\n",
                  L"----CreateReferenceHive");
        fflush( g_debugFilePointer );
    }

    // 1-COPY
    // copy all keys under .Default\Software into a special location 
    // under our TS hive, let's call it the RefHive
    // This will act as the reference hive

    NTSTATUS status = STATUS_SUCCESS;
    ULONG   indentLevel=0;

    // start creating our cache Ref hive

    KeyNode Ref( NULL, MAXIMUM_ALLOWED, uniRef );

    // if we were able to create our RefHive, then continue...
    if ( NT_SUCCESS_EX( status = Ref.Create() ) )
    {
        KeyNode Source(NULL, KEY_READ, uniSource );
    
        // open the source reg-key-path
        if (NT_SUCCESS_EX( status = Source.Open() ))
        {
            KeyBasicInfo    kBasicInfo;
    
            if (NT_SUCCESS_EX( status = kBasicInfo.Status() )) 
            {
                // this will be a recursive call, so we are saving allocation
                // cycles by passing kBasicInfo as scratch pad.
                status = EnumerateAndCreateRefHive(     &Source,
                                    &Ref,
                                    &kBasicInfo, 
                                    &indentLevel);
                
            }
        }
    
    }

    if ( status == STATUS_NO_MORE_ENTRIES)
    {
        status = STATUS_SUCCESS;
    }

    return status;
}

/************************************************************************
*                                                                       
* Function:                                                             
*  DeltaDeleteKeys(WCHAR *uniSource, WCHAR *uniRef, WCHAR *uniDest)     
*                                                                       
*  Parameters:                                                          
*  uniSource (source     ) string points to the node under .Default    
*  uniRef    (ref        ) string point to TS\Install\RefHive         
*  UniDest   (Destination) string points to TS\Install\Software     
*                                                                       
* Description:                                                          
*  compare .Dfeault keys to the equivalent keys in RefHive. If keys are 
*  missing from .Default, then delete the equivalent keys from our      
*  HKLM\...\TS\ hive                                                    
*                                                                      
* Return:                                                             
*      NTSTATUS, if successful, then STATS_SUCCESS                   
*                                                                   
************************************************************************/
NTSTATUS DeltaDeleteKeys(WCHAR *uniSource, WCHAR *uniRef, WCHAR *uniDest)
{
    if ( g_debugIO)
    {
        fwprintf( g_debugFilePointer,L"In %ws\n",
                  L"----DeltaDeleteKeys");
        fflush( g_debugFilePointer );
    }

    // Step2-DELETE
    // compare .Dfeault keys to the equivalent keys in RefHive. If keys are
    // missing from .Default, then delete the equivalent keys from our
    // HKLM\...\TS\ hive

    KeyNode Source( NULL, KEY_READ, uniSource );
    KeyNode Ref( NULL, MAXIMUM_ALLOWED, uniRef );
    KeyNode Destination( NULL, MAXIMUM_ALLOWED, uniDest );

    Source.Open();
    Ref.Open();
    Destination.Open();

    ULONG   indentLevel=0;
    NTSTATUS    status = STATUS_SUCCESS;

    if ( NT_SUCCESS_EX( status = Source.Status() ) &&
         NT_SUCCESS_EX( status = Ref.Status() ) && 
         NT_SUCCESS_EX( status = Destination.Status()  ) )
    {
        KeyBasicInfo     basicInfo;
        
        if( NT_SUCCESS_EX( status = basicInfo.Status() ) )
        {
            // walk and compare, if missing from Source, then delete from Destination
            status = EnumerateAndDeltaDeleteKeys( 
                &Source,
                &Ref,
                &Destination,
                &basicInfo, 
                &indentLevel);
        }
    }

    if ( status == STATUS_NO_MORE_ENTRIES)
    {
        status = STATUS_SUCCESS;
    }

    return status;
}

/************************************************************************
*                                                                       
* Function:                                                             
*  DeltaUpdateKeys(WCHAR *uniSource, WCHAR *uniRef, WCHAR *uniDest)     
*                                                                       
*  Parameters:                                                          
*  uniSource (source     ) string points to the node under .Default     
*  uniRef    (ref        ) string point to TS\Install\RefHive          
*  UniDest   (Destination) string points to TS\Install\Software       
*                                                                    
* Description:                                                      
*  Step-3 CREATE/Update keys and values
*  compare .Default keys to the equivalent keys in RefHive, if keys are
*  present in .Default that are missing from RefHive, then, add those keys
*  to our HKLM\...\TS hive. Do the same for the values.
*  Then, compare values from .Default to values in .Ref. If values have
*  changed, then delete the value from our destination hive and create a
*  new one with the appropriate data from .Default
*                                                                     
* Return:                                                             
*      NTSTATUS, if successful, then STATS_SUCCESS                   
*                                                                   
************************************************************************/
NTSTATUS DeltaUpdateKeys    (WCHAR *uniSource, WCHAR *uniRef, WCHAR *uniDest)
{
    if ( g_debugIO)
    {
        fwprintf( g_debugFilePointer,L"In %ws\n",
                  L"----DeltaUpdateKeys");
        fflush( g_debugFilePointer );
    }
    // 3-CREATE
    // compare .Default keys to the equivalent keys in RefHive, if keys are
    // present in .Default that are missing from RefHive, then, add those keys
    // to our HKLM\...\TS hive
    KeyNode Source( NULL, KEY_READ, uniSource );
    KeyNode Ref( NULL, MAXIMUM_ALLOWED, uniRef );
    KeyNode Destination( NULL, MAXIMUM_ALLOWED, uniDest );

    Source.Open();
    Ref.Open();
    Destination.Open();

    NTSTATUS status;
    ULONG   indentLevel=0;

    if ( NT_SUCCESS_EX( status = Source.Status() ) &&
         NT_SUCCESS_EX( status = Ref.Status() ) && 
         NT_SUCCESS_EX( status = Destination.Status()  ) )
    {

        KeyBasicInfo     basicInfo;

        // Constructor in KeyBasicInfo above allocates memory for pInfo 
        // check if memory allocation of pInfo succeeded
        status = basicInfo.Status();
        if (status != STATUS_SUCCESS) {
            return status;
        }

        // walk and compare, if missing from Source, then delete from Destination
        status = EnumerateAndDeltaUpdateKeys( 
            &Source,
            &Ref,
            &Destination,
            &basicInfo, 
            &indentLevel);
    }

    if ( status == STATUS_NO_MORE_ENTRIES)
    {
        status = STATUS_SUCCESS;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\objrules.c ===
/*************************************************************************
* objrules.c
*
* Routines for caching registry object rules and looking up object names.
*
* Copyright (C) 1997-1999 Microsoft Corp.
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <objrules.h>
#include <ntverp.h>

OBJRULELIST SemaRuleList;
OBJRULELIST MutexRuleList;
OBJRULELIST SectionRuleList;
OBJRULELIST EventRuleList;
ULONG NumRuleLists;

RULEINITENTRY RuleInitTab[] =
{
    {&SemaRuleList,    USER_GLOBAL_SEMAPHORES, SYSTEM_GLOBAL_SEMAPHORES},
    {&MutexRuleList,   USER_GLOBAL_MUTEXES,    SYSTEM_GLOBAL_MUTEXES},
    {&SectionRuleList, USER_GLOBAL_SECTIONS,   SYSTEM_GLOBAL_SECTIONS},
    {&EventRuleList,   USER_GLOBAL_EVENTS,     SYSTEM_GLOBAL_EVENTS},
};

//*****************************************************************************
// InitRuleList
//
//    Initializes an object rule list to empty.
//
//    Parameters:
//        POBJRULLIST            (IN)  - ptr to object rule list 
//    Return Value:
//        None.
//*****************************************************************************
void InitRuleList(POBJRULELIST pObjRuleList)
{
    pObjRuleList->First = (POBJRULE) NULL;
    pObjRuleList->Last  = (POBJRULE) NULL;
}

//*****************************************************************************
// GetMultiSzValue
//
//    Retrieves the REG_MULTI_SZ value ValueName under key hKey.
//
//    Parameters:
//        hKey                  The registry key
//        ValueName             The registry value name (NULL Terminated)
//        pValueInfo            Pointer to Pointer receiving a
//                              PKEY_VALUE_PARTIAL_INFORMATION structure
//                              upon successful return. This structure
//                              contains the registry data and its length.
//    Return Value:
//        Returns TRUE if successful, otherwise FALSE.
//        If successful, pValueInfo is updated with a pointer to a
//        structure. The caller must free the structure.
//*****************************************************************************

BOOL GetMultiSzValue(HKEY hKey, PWSTR ValueName,
                     PKEY_VALUE_PARTIAL_INFORMATION *pValueInfo)
{
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;
    UNICODE_STRING UniString;
    ULONG BufSize;
    ULONG DataLen;
    NTSTATUS NtStatus;
    BOOL Retried = FALSE;

    // Determine the value info buffer size
    BufSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_PATH*sizeof(WCHAR);

    for (;;) {
        ValueInfo = RtlAllocateHeap(RtlProcessHeap(), 0, BufSize);

        if (ValueInfo)
        {
            RtlInitUnicodeString(&UniString, ValueName);
            NtStatus = NtQueryValueKey(hKey,
                                       &UniString,
                                       KeyValuePartialInformation,
                                       ValueInfo,
                                       BufSize,
                                       &DataLen);
        
            if (NT_SUCCESS(NtStatus) && (REG_MULTI_SZ == ValueInfo->Type)) {
                *pValueInfo = ValueInfo;
                return(TRUE);
            }
    
            if (!Retried && (NtStatus == STATUS_BUFFER_OVERFLOW)) {
                BufSize = DataLen;
                RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
                Retried = TRUE;
                continue;
            }
            // Key not present or other type of error
            RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
            return(FALSE);
        }
        else
        {
            return(FALSE);
        }
    }

}

//*****************************************************************************
// AddRule
//
//    Adds an object rule a rule list.
//
//    Parameters:
//        RuleList              The rule list.
//        ObjName               The name of the object.
//        SystemGlobalRule      If true, the object is to be SYSTEM_GLOBAL.
//    Return Value:
//        None.
//*****************************************************************************

void AddRule(POBJRULELIST RuleList, PWSTR ObjName, BOOL SystemGlobalRule) 
{
    ULONG AllocSize;
    ULONG Length;
    POBJRULE pObjRule;

#if DBG
    DbgPrint("Adding Rule: %ws SystemGlobal: %d\n",ObjName,SystemGlobalRule);
#endif
    Length = wcslen(ObjName);
    AllocSize = sizeof(OBJRULE) + (Length + 1) * sizeof(WCHAR);
    if (pObjRule = RtlAllocateHeap(RtlProcessHeap(), 0, AllocSize)) {
        wcscpy(pObjRule->ObjName, ObjName);
        pObjRule->SystemGlobal = SystemGlobalRule;
        if (ObjName[Length-1] == L'*') {
            pObjRule->WildCard = TRUE;
            pObjRule->MatchLen = Length - 1;
            // Insert rule at the end of the list
            pObjRule->Next = NULL;
            if (RuleList->First == NULL) {
                RuleList->First = RuleList->Last = pObjRule;
            } else {
                RuleList->Last->Next = pObjRule;
                RuleList->Last = pObjRule;
            }
        } else {
            pObjRule->WildCard = FALSE;
            // Insert rule at the begining
            if (RuleList->First == NULL) {
                RuleList->First = RuleList->Last = pObjRule;
                pObjRule->Next = NULL;
            } else {
                pObjRule->Next = RuleList->First;
                RuleList->First = pObjRule;
            }
        }
    }
}

//*****************************************************************************
// LoadRule
//
//    Caches all rules for a given registry value (REG_MULTI_SZ).
//
//    Parameters:
//        RuleList              The rule list.
//        hKey                  The registry key.
//        ValueName             The name of theregistry value.
//        SystemGlobalRule      If true, the object is to be SYSTEM_GLOBAL.
//    Return Value:
//        None.
//*****************************************************************************

void LoadRule (POBJRULELIST RuleList, HKEY hKey,
               PWSTR ValueName, BOOL SystemGlobalRule)
{
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo = NULL;
    PWSTR Token;
    PWSTR EndData;

    if (!GetMultiSzValue(hKey,ValueName,&ValueInfo)) {
        return;
    }
    EndData = (PWSTR) (ValueInfo->Data + ValueInfo->DataLength);
    for (Token = (PWSTR)ValueInfo->Data;
         (*Token && (Token < EndData));
         Token++) {
        AddRule(RuleList, Token, SystemGlobalRule);
        while (*Token) {
            Token++;
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
}

//*****************************************************************************
// LoadRules
//
//    Caches all rules for in an OBJECTRULES directory.
//    (e.g. Citrix\Compatibility\Applications\<APPNAME>\ObjectRules).
//
//    Parameters:
//        hKey              The registry key of the ObjectRules directory.
//    Return Value:
//        None.
//*****************************************************************************

void LoadRules (HANDLE hKey)
{
    ULONG i;
    PRULEINITENTRY pTab;

    for (i=0, pTab=RuleInitTab;i<NumRuleLists;i++,pTab++) {
        LoadRule(pTab->ObjRuleList, hKey, pTab->UserGlobalValue, FALSE);
        LoadRule(pTab->ObjRuleList, hKey, pTab->SystemGlobalValue, TRUE);
    }
}

#define BuildObjRulePath(BasePath,ModName) \
{ \
    wcscpy(KeyName,BasePath ); \
    wcscat(KeyName,ModName); \
    wcscat(KeyName,L"\\"); \
    wcscat(KeyName,TERMSRV_COMPAT_OBJRULES); \
    RtlInitUnicodeString(&UniString, KeyName); \
    InitializeObjectAttributes(&ObjectAttributes, \
                               &UniString, \
                               OBJ_CASE_INSENSITIVE, \
                               NULL, \
                               NULL); \
}

//*****************************************************************************
// CtxInitObjRuleCache
//
//    Loads all object rules for a given application. Called at DLL process
//    attach time.
//    Rules are in Citrix\Compatibility\Applications\<APPNAME>\ObjectRules
//    Also loads all rules for DLLs listed in:
//    Citrix\Compatibility\Applications\<APPNAME>\ObjectRules\Dlls
//    Parameters:
//        None.
//    Return Value:
//        None.
//*****************************************************************************

void CtxInitObjRuleCache(void)
{
    WCHAR ModName[MAX_PATH+1];
    WCHAR KeyName[sizeof(TERMSRV_COMPAT_APP)/sizeof(WCHAR)+
                  sizeof(TERMSRV_COMPAT_OBJRULES)/sizeof(WCHAR)+MAX_PATH+2];
    UNICODE_STRING UniString;
    PWSTR DllName;
    PWSTR EndData;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo = NULL;
    HKEY   hKey = 0;
    DWORD  AppType;
    ULONG i;

    // Initialize list to empty
    NumRuleLists = sizeof(RuleInitTab) / sizeof(RULEINITENTRY);
    for (i=0; i<NumRuleLists ;i++ ) {
        InitRuleList(RuleInitTab[i].ObjRuleList);
    }

    // Get the module name
    if (!GetAppTypeAndModName(&AppType,ModName, sizeof(ModName))) {
        return;
    }

    // Determine of the ObjRules Key exists for this app
    BuildObjRulePath(TERMSRV_COMPAT_APP,ModName)
    if (!NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &ObjectAttributes))) {
        return;
    }
    LoadRules(hKey);
    

    if (!GetMultiSzValue(hKey,TERMSRV_COMPAT_DLLRULES,&ValueInfo)) {
        CloseHandle(hKey);
        return;
    }

    CloseHandle(hKey);

    // Load the DLL Rules
    EndData = (PWSTR) (ValueInfo->Data + ValueInfo->DataLength);

    for(DllName = (PWSTR) ValueInfo->Data;
        (*DllName && (DllName < EndData));
        DllName++) {
        BuildObjRulePath(TERMSRV_COMPAT_DLLS, DllName)
        if (NT_SUCCESS(NtOpenKey(&hKey, KEY_READ, &ObjectAttributes))) {
            LoadRules(hKey);
            CloseHandle(hKey);
        }
        while (*DllName) {
            DllName++;
        }
    }

    RtlFreeHeap(RtlProcessHeap(), 0, ValueInfo);
}

//*****************************************************************************
// CtxLookupObjectRule
//
//    Searches for an object rule for the named object. If a rule is found,
//    the object attributes are modifed to reflect the desired setting of 
//    USER_GLOBAL or SYSTEM_GLOBAL. If no rule is found, the object
//    atributes are unmodified.
//
//    Parameters:
//        RuleList          The rule list to search (based on object type)
//        ObjName           The name of the object.
//        ObjAttributes     The object attribute structure.
//        None.
//    Return Value:
//        None.
//*****************************************************************************
void CtxLookupObjectRule(POBJRULELIST RuleList, LPCWSTR ObjName, LPWSTR ObjNameExt)
{
    POBJRULE ObjRule;
    
#define ApplyRule \
{ \
    if (ObjRule->SystemGlobal) { \
        wcscpy(ObjNameExt,L"Global\\");  \
    } else { \
        wcscpy(ObjNameExt,L"Local\\");  \
    } \
}

    for (ObjRule = RuleList->First; ObjRule; ObjRule = ObjRule->Next) {
        if (!ObjRule->WildCard) {
            if (!_wcsicmp(ObjName, ObjRule->ObjName)) {
#if DBG
                DbgPrint("Object rule found for %ws System Global: %d\n",
                          ObjName, ObjRule->SystemGlobal);
#endif
                ApplyRule
                return;
            }
        } else {
            if (!_wcsnicmp(ObjName, ObjRule->ObjName, ObjRule->MatchLen)) {
#if DBG
                DbgPrint("Object rule found for %ws System Global: %d\n",
                          ObjName, ObjRule->SystemGlobal);
#endif
                ApplyRule
                return;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\keynode.h ===
/****************************************************************************/
// keynode.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#ifndef _TS_APP_CMP_KEY_NODE_H_
#define _TS_APP_CMP_KEY_NODE_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <ntregapi.h>
#include <windows.h>


// some utility macros
#define DELETE_AND_NULL( x ) {if (x) {delete x;} x = NULL;}

// ---------------- KEY BASIC INFO 
// Use this object as scratch pad when aquirng basic key information.
class   KeyBasicInfo 
{
public:
    KeyBasicInfo();
    ~KeyBasicInfo();

    ULONG               Size()      { return size ; }
    KEY_BASIC_INFORMATION   *Ptr()  { return pInfo; }
    KEY_INFORMATION_CLASS   Type()  { return KeyBasicInformation ; }
    NTSTATUS               Status() { return status; }

    PCWSTR      NameSz();// this allocates memory, so it's here for debug only


private:
    ULONG                   size;
    KEY_BASIC_INFORMATION   *pInfo;
    ULONG                   status;
    WCHAR                   *pNameSz;
};


#if 0   // not used yet!
// ---------------- KEY NODE INFO 
class   KeyNodeInfo
{
public:
    KeyNodeInfo();
    ~KeyNodeInfo();

    ULONG               Size()      { return size ; }
    KEY_NODE_INFORMATION    *Ptr()  { return pInfo; }
    KEY_INFORMATION_CLASS   Type()  { return KeyNodeInformation ; }
    NTSTATUS               Status() { return status; }

private:
    ULONG   size;
    KEY_NODE_INFORMATION    *pInfo;
    ULONG                   status;
};

#endif

// ---------------- KEY FULL INFO 
// Use this class to create objects that are used as scratch pad when 
// acquiring full-key-info.
class   KeyFullInfo
{
public:
    KeyFullInfo();      // does memory allocation, check status
    ~KeyFullInfo();

    ULONG               Size()      { return size ; }
    KEY_FULL_INFORMATION    *Ptr()  { return pInfo; }
    KEY_INFORMATION_CLASS   Type()  { return KeyFullInformation ; }
    NTSTATUS               Status() { return status; }

private:
    ULONG   size;
    KEY_FULL_INFORMATION    *pInfo;
    ULONG                   status;
};


// This class is used to describe a key-node, which is equivalent to a reg-key abstraction.
// All key operation are caried thru this class, with the exception of key-enum, which is still 
// handled as a raw NT call.
// 
// All Methods set status, which can be acquired by calling Status(), or, in most
// cases, it is returned by the Method called.
class   KeyNode
{
public:
    KeyNode(HANDLE root, ACCESS_MASK access, PCWSTR name ); // init stuff
    KeyNode(KeyNode *parent, KeyBasicInfo   *info );        // init stuff
    ~KeyNode();

    NTSTATUS GetPath( PWCHAR *pwch ); // get the full path to this key

    NTSTATUS Open();        // casue the key to be opened, as defined by params passed to the constructorA
    NTSTATUS Close();       // will close the key (presumed open)

    NTSTATUS Create(UNICODE_STRING *uClass=NULL);           // create a single new key under an existing key

    NTSTATUS CreateEx( UNICODE_STRING *uClass=NULL);        // Create a single branch that potentially has 
                                                            // a multiple levels of new keys such as 
                                                            // x1/x2/x3 under an existing key-X. 
                                                            // Key path specified to the constructire MUST be
                                                            // a full path, starting with \Registry\etc

    NTSTATUS Delete();                                  // delete an existing key
    NTSTATUS DeleteSubKeys();                           // delete the sub tree

    NTSTATUS GetFullInfo( KeyFullInfo   **p);

    NTSTATUS    Query( KEY_BASIC_INFORMATION **result , ULONG *resultSize );
    NTSTATUS    Query( KEY_NODE_INFORMATION  **result , ULONG *resultSize );
    NTSTATUS    Query( KEY_FULL_INFORMATION  **result , ULONG *resultSize );

    NTSTATUS    Status()        {return status;}
    HANDLE      Key()           {return hKey; }
    WCHAR      *Name()          {return uniName.Buffer ;}             
    ACCESS_MASK Masks()         {return accessMask ; }


    enum DebugType 
        {   
            DBG_OPEN, 
            DBG_OPEN_FAILED, 
            DBG_DELETE, 
            DBG_KEY_NAME,
            DBG_CREATE
        };

    void     Debug(DebugType );

    // if debug=TRUE, then the Debug() func will spit out stuff
static BOOLEAN debug;
   
private:                                        
    NTSTATUS EnumerateAndDeleteSubKeys( KeyNode *, KeyBasicInfo *); 

    PCWSTR      NameSz();   // this allocates memory, so it's here for debug 
                        // since you don't really need this,  and it's private

    WCHAR       *pNameSz;

    HANDLE  root;
    HANDLE  hKey;
    UNICODE_STRING  uniName;
    OBJECT_ATTRIBUTES ObjAttr;
    ACCESS_MASK accessMask;
    NTSTATUS    status;

    // key infos
    KeyBasicInfo        *basic;
    KeyFullInfo         *full;

    PVOID                   pFullPath;  // full reg key path, as in \Registr\...blah...blah...\Ts...\blah
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\regmap.c ===
/*************************************************************************
*
* regmap.c
*
* Handle Copy-On-Reference Registry Entry Mapping
*
* copyright notice: Copyright 1996-1997, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* Author:  Bill Madden
*
* NOTE for Hydra (butchd 9/26/97): In comments below, substitute
*
*   SOFTWARE\Citrix
*
* with
*
*   SOFTWARE\Microsoft\Windows NT\CurrentVersion\Terminal Server
*
* Here's a brief(?) summary of how the registry mapping works.  The goal is 
* that an administrator can install an application, and then all users can 
* use it, without any per-user configuration.  The current design is that 
* the administrator puts the system into installation mode (change user 
* /install), installs the application, and then returns the system to 
* execute mode (change user /execute).  There are hooks in the API's used to 
* create keys and values in the registry (BaseRegCreateKey, BaseRegSetValue, 
* BaseRegRestoreKey, etc), and the hooks create a copy of the registry keys 
* created under \HKEY_LOCAL_MACHINE\SOFTWARE\Citrix\Install (both for the 
* user specific keys and the local machine keys).  The local machine keys 
* are added so that if sometime in the future we need to know all of the 
* registry values created by an application, there is a copy of them 
* available. 
*
* When a user starts a Win32 app for the first time, the app will open the 
* keys it needs to query.  If the key doesn't exist underneath 
* HKEY_CURRENT_USER, there are hooks in the base registry API's to catch the 
* error and then search underneath the Citrix/Install section to see if the 
* key exists there.  If the key exists in the install section, we copy the 
* key, its values, and its subkeys to the current user's registry.  This 
* way we only have to hook opens, and not every registry API.  This helps 
* reduce the overhead associated with this registry mapping.
*
* Some apps (such as the office short cut bar) delete entries and need to 
* recreate the entries themselves.  When an app deletes a key and the 
* system is in execute mode, we will set a value under the key indicating 
* that we should only copy the key to the user once.  What this currently 
* means, is that if this is the only key being created, we won't create it 
* when that flag is set.  However, if we are creating this key because we 
* created its parent, we will still create the key.  
* 
* The other part of the registry mapping support is that when a user logs
* in, userinit calls a routine (CtxCheckNewRegEntries) which checks if any 
* of the system keys are newer than any of the corresponding user keys.  If 
* they are, the user keys are deleted (we're assuming that if the system 
* key is newer, than the admin has installed a newer version of an 
* application).  This deleting can be disabled by setting a value under 
* HKEY_LOCAL_MACHINE\Software\Citrix\Compatibility\IniFiles\xxx where xxx 
* is the key name, and the value should be 0x48.
*
*************************************************************************/

#include "precomp.h"
#pragma hdrstop


#include <rpc.h>
#include <regmap.h>
#include <aclapi.h>
#include <shlwapi.h>


/* External Functions */

ULONG GetCtxAppCompatFlags(LPDWORD, LPDWORD);

/* Internal Functions */
PWCHAR GetUserSWKey(PWCHAR pPath, PBOOL fUserReg, PBOOL bClassesKey);
PWCHAR Ctxwcsistr(PWCHAR pstring1, PWCHAR pstring2);
NTSTATUS TermsrvGetRegPath(IN HANDLE hKey,
                       IN POBJECT_ATTRIBUTES pObjectAttr,
                       IN PWCHAR pInstPath,
                       IN ULONG  ulbuflen);
NTSTATUS TermsrvGetInstallPath(IN PWCHAR pUserPath,
                           IN PWCHAR *ppInstPath);
NTSTATUS TermsrvCreateKey(IN PWCHAR pSrcPath,
                      IN PWCHAR pDstPath,
                      IN BOOL fCloneValues,
                      IN BOOL fCloneSubKeys,
                      OUT PHANDLE phKey);
NTSTATUS TermsrvCloneKey(HANDLE hSrcKey,
                     HANDLE hDstKey,
                     PKEY_FULL_INFORMATION pDefKeyInfo,
                     BOOL   fCreateSubKeys);
void TermsrvLogRegInstallTime(void);

BOOL ExistsInOmissionList(PWCHAR pwch);
BOOL ExistsInEnumeratedKeys(HKEY hOmissionKey, PKEY_FULL_INFORMATION pDefKeyInfo, PWCHAR pwch);


/*****************************************************************************
 *
 *  TermsrvCreateRegEntry
 *
 *   If in installation mode, create the registry entry in the citrix 
 *   install user section of the registry.  If the system is in execution 
 *   mode, verify that the key values and subkeys have been created.
 *
 * ENTRY:
 *  IN HANDLE hKey:                     Handle of new key just created
 *  IN ULONG TitleIndex:                Title Index
 *  IN PUNICODE_STRING pUniClass:       Ptr to unicode string of class
 *  IN ULONG ulCreateOpt:               Creation options
 *  
 *
 * EXIT:
 *  TRUE: Entry created in install section or cloned from install section
 *  FALSE: Entry not created or cloned
 *
 ****************************************************************************/

BOOL TermsrvCreateRegEntry(IN HANDLE hKey,
                       IN POBJECT_ATTRIBUTES pObjAttr,
                       IN ULONG TitleIndex,
                       IN PUNICODE_STRING pUniClass OPTIONAL,
                       IN ULONG ulCreateOpt)
{
    NTSTATUS Status;             
    ULONG ultemp;
    OBJECT_ATTRIBUTES InstObjectAttr;
    UNICODE_STRING UniString;
    HKEY   hNewKey = NULL;
    PWCHAR  wcbuff = NULL;
    PWCHAR pUserPath;
    BOOL fMapping;
    BOOL fUserReg;
    PKEY_FULL_INFORMATION pDefKeyInfo = NULL;

    // Get the current state of ini file mapping
    fMapping = !TermsrvAppInstallMode();

    // Get a buffer to hold the path of the key
    ultemp = sizeof(WCHAR)*MAX_PATH*2;
    pUserPath = RtlAllocateHeap(RtlProcessHeap(), 
                                0, 
                                ultemp);

    // Get the full path associated with this key
    if (pUserPath) {
        Status = TermsrvGetRegPath(hKey,
                               NULL,
                               pUserPath,
                               ultemp);
    } else {
        Status = STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(Status)) {

        // Get the corresponding path in the install section
        Status = TermsrvGetInstallPath(pUserPath, 
                                    &wcbuff);
    
        if (NT_SUCCESS(Status)) {

            // Set up an object attribute structure to point to the
            // path of the key in the install section
            RtlInitUnicodeString(&UniString, wcbuff);
            InitializeObjectAttributes(&InstObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       pObjAttr->SecurityDescriptor);

            // If we're in install mode, create the key in the default
            // install section
            if (!fMapping) {
                
                // Inherit the default security for the install section
                InstObjectAttr.SecurityDescriptor = NULL;
            
                Status = NtCreateKey(&hNewKey,
                                     KEY_WRITE,
                                     &InstObjectAttr,
                                     TitleIndex,
                                     pUniClass,
                                     ulCreateOpt,
                                     &ultemp);
        
                if (!NT_SUCCESS(Status)) {
                    // Need to build up the path to the registry key
                    Status = TermsrvCreateKey(pUserPath,
                                          wcbuff,
                                          FALSE,
                                          FALSE,
                                          &hNewKey);
                }

                // Update the registry entry for the last time a registry
                // entry was added
                if (NT_SUCCESS(Status)) {
                    TermsrvLogRegInstallTime();
                }

            // The system is in execute mode, try to copy the key from the
            // installation section
            } else {
                HANDLE hUserKey = NULL;
                ULONG ulAppType = TERMSRV_COMPAT_WIN32;

                // First verify that this is in the user software section
                if (!GetUserSWKey(pUserPath, &fUserReg, NULL)) {
                    Status = STATUS_NO_MORE_FILES;
                }

                // If mapping is on, but disabled for this app, return
                GetCtxAppCompatFlags(&ultemp, &ulAppType);
                if ((ultemp & (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32)) == 
                    (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32)) {
                    Status = STATUS_NO_MORE_FILES;
                }

                // Check if registry mapping is disabled for this key path
                GetTermsrCompatFlags(pUserPath, &ultemp, CompatibilityRegEntry);
                if ((ultemp & (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) ==
                    (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) {
                    Status = STATUS_NO_MORE_FILES;
                }

                if (NT_SUCCESS(Status)) {
                    // Open up a key for the install section 
                    Status = NtOpenKey(&hNewKey, 
                                       KEY_READ,
                                       &InstObjectAttr);
                }

                if (NT_SUCCESS(Status)) {
                    // Set an attribute structure to point at the user path
                    RtlInitUnicodeString(&UniString, pUserPath);
                    InitializeObjectAttributes(&InstObjectAttr,
                                               &UniString,
                                               OBJ_CASE_INSENSITIVE,
                                               NULL,
                                               pObjAttr->SecurityDescriptor);
    
                    // Open the user path so we can write to it
                    Status = NtOpenKey(&hUserKey, 
                                       KEY_WRITE,
                                       &InstObjectAttr);
                }
    
                // Get the key info
                if (NT_SUCCESS(Status)) {

                    // Get a buffer for the key info
                    ultemp = sizeof(KEY_FULL_INFORMATION) + 
                             MAX_PATH*sizeof(WCHAR);
                    pDefKeyInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                                  0, 
                                                  ultemp);

                    if (pDefKeyInfo) {
                        Status = NtQueryKey(hNewKey,
                                            KeyFullInformation,
                                            pDefKeyInfo,
                                            ultemp,
                                            &ultemp);
                    } else {
                        Status = STATUS_NO_MEMORY;
                    }
                } 

                // Copy all of the values and subkeys for this key from the
                // install section to the user section
                if (NT_SUCCESS(Status)) {
                    Status =  TermsrvCloneKey(hNewKey,
                                          hUserKey,
                                          pDefKeyInfo,
                                          TRUE);
                    if (pDefKeyInfo) {
                        RtlFreeHeap(RtlProcessHeap(), 0, pDefKeyInfo);
                    }
                }
                if (hUserKey) {
                    NtClose(hUserKey);
                }
            }
            if (hNewKey) {
                NtClose(hNewKey);
            }
        } 
    }

    if (pUserPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, pUserPath);
    }
    
    if (wcbuff) {
        RtlFreeHeap(RtlProcessHeap(), 0, wcbuff);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*****************************************************************************
 *
 *  TermsrvOpenRegEntry
 *
 *   If the system is in execute mode, copy application registry entries 
 *   from the default user to the current user.  
 *
 * ENTRY:
 *  OUT PHANDLE pUserKey:
 *      Pointer to return key handle if opened
 *  IN ACCESS_MASK DesiredAccess:
 *      Desired access to the key
 *  IN POBJECT_ATTRIBUTES ObjectAttributes:
 *      Object attribute structure for key to open
 *
 * EXIT:
 *  TRUE: Entry moved from install to current user
 *  FALSE: Entry not moved
 *
 ****************************************************************************/

BOOL TermsrvOpenRegEntry(OUT PHANDLE pUserhKey,
                     IN ACCESS_MASK DesiredAccess,
                     IN POBJECT_ATTRIBUTES pUserObjectAttr)
{
    NTSTATUS Status;        
    ULONG ultemp=0;
    ULONG ulAppType = TERMSRV_COMPAT_WIN32;
    HKEY   hNewKey;
    WCHAR  wcbuff[MAX_PATH*2];
    PWCHAR pwch, pUserPath;
    BOOL   fUserReg;

    // If running in install mode, return
    if (TermsrvAppInstallMode() ) {
        return(FALSE);
    }

    // If mapping is on, but disabled for this app, return
    GetCtxAppCompatFlags(&ultemp, &ulAppType);
    if ((ultemp & (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32)) == 
         (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32)) {
        return(FALSE);
    }

    // Get a buffer to hold the user's path in the registry
    ultemp = sizeof(WCHAR)*MAX_PATH*2;
    pUserPath = RtlAllocateHeap(RtlProcessHeap(), 
                                0, 
                                ultemp);
    if (pUserPath) {
        // Get the full path associated with this object attribute structure
        Status = TermsrvGetRegPath(NULL,
                               pUserObjectAttr,
                               pUserPath,
                               ultemp);
    } else {
        Status = STATUS_NO_MEMORY;
    }

    // Create the key for this user
    if (NT_SUCCESS(Status)) {
    
        Status = STATUS_NO_SUCH_FILE;

        //DbgPrint("Attempting to open key %ws\n",pUserPath);
        // Check if they are trying to open the key under HKEY_CURRENT_USER
        pwch = GetUserSWKey(pUserPath, &fUserReg, NULL);
        
        if (pwch) {
            // Check if registry mapping is disabled for this key 
            GetTermsrCompatFlags(pUserPath, &ultemp, CompatibilityRegEntry);
            if ((ultemp & (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) !=
                (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) {

                wcscpy(wcbuff, TERMSRV_INSTALL);
                wcscat(wcbuff, pwch);
    
                Status = TermsrvCreateKey(wcbuff,
                                      pUserPath,
                                      TRUE,
                                      TRUE,
                                      &hNewKey);
    
                if (NT_SUCCESS(Status)) {
                    NtClose(hNewKey);
                }
            } else {

                Status = STATUS_NO_MORE_FILES;
            }

        // App is trying to open the key under HKEY_LOCAL_MACHINE, mask off 
        // the access bits they don't have by default
        } else if (!_wcsnicmp(pUserPath,
                      TERMSRV_MACHINEREGISTRY,
                      wcslen(TERMSRV_MACHINEREGISTRY)) &&
                   (DesiredAccess & 
                    (WRITE_DAC | WRITE_OWNER | KEY_CREATE_LINK))) {
            DesiredAccess &= ~(WRITE_DAC | WRITE_OWNER | KEY_CREATE_LINK);
            Status = STATUS_SUCCESS;
        }
    } else {
        Status = STATUS_NO_SUCH_FILE;
    }

    if (pUserPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, pUserPath);
    }

    // We successfully copied the key, so actually do the open
    if (NT_SUCCESS(Status)) {
        Status = NtOpenKey(pUserhKey,
                           DesiredAccess,
                           pUserObjectAttr);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*****************************************************************************
 *
 *  TermsrvSetValueKey
 *
 *   If the system is in install (ini mapping off) mode, set the entry in 
 *   the citrix install user section of the registry.  If the system is in
 *   execute (ini mapping on) mode, do nothing.
 *
 * ENTRY:
 *  HANDLE hKey:               Open key to query value from
 *  PUNICODE_STRING ValueName: Ptr to unicode value name to set
 *  ULONG TitleIndex:          Title Index
 *  ULONG Type:                Type of data
 *  PVOID Data:                Ptr to data
 *  ULONG DataSize:            Data length
 *
 * EXIT:
 *  TRUE: Entry created in install section
 *  FALSE: Entry not created
 *
 ****************************************************************************/
BOOL TermsrvSetValueKey(HANDLE hKey,
                    PUNICODE_STRING ValueName,
                    ULONG TitleIndex,
                    ULONG Type,
                    PVOID Data,
                    ULONG DataSize)
{
    NTSTATUS Status;        
    ULONG ultemp;
    PWCHAR pwch, pUserPath;
    PWCHAR wcbuff = NULL;
    UNICODE_STRING UniString;
    OBJECT_ATTRIBUTES InstObjectAttr;
    HKEY   hNewKey;

    // If  not in install mode, return
    if ( !TermsrvAppInstallMode() ) {
        return(FALSE);
    }

    // Allocate a buffer to hold the path to the key in the registry
    ultemp = sizeof(WCHAR)*MAX_PATH*2;
    pUserPath = RtlAllocateHeap(RtlProcessHeap(), 
                                0, 
                                ultemp);

    // Get the path of this key
    if (pUserPath) {
        Status = TermsrvGetRegPath(hKey,
                               NULL,
                               pUserPath,
                               ultemp);
    } else {
        Status = STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(Status)) {
    
        // Get the path to the entry in the install section of the registry
        Status = TermsrvGetInstallPath(pUserPath,
                                   &wcbuff);

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&UniString, wcbuff);
            InitializeObjectAttributes(&InstObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);
        
            // Open the key in under the install section
            Status = NtOpenKey(&hNewKey,
                               KEY_WRITE,
                               &InstObjectAttr);
    
            // If we couldn't open it, try creating the key
            if (!NT_SUCCESS(Status)) {
                Status = TermsrvCreateKey(pUserPath, 
                                      wcbuff,
                                      TRUE,
                                      FALSE,
                                      &hNewKey);
            }

            // If the key was opened, set the value in the install section
            if (NT_SUCCESS(Status)) {
                Status = NtSetValueKey(hNewKey,
                                       ValueName,
                                       TitleIndex,
                                       Type,
                                       Data,
                                       DataSize);
                NtClose(hNewKey);

                // Update the registry entry for the last time a registry
                // entry was added
                if (NT_SUCCESS(Status)) {
                    TermsrvLogRegInstallTime();
                }
            }
        }
    }

    if (pUserPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, pUserPath);
    }
    
    if (wcbuff) {
        RtlFreeHeap(RtlProcessHeap(), 0, wcbuff);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*****************************************************************************
 *
 *  TermsrvDeleteKey
 *
 *   If the system is in install mode, delete the registry entry in the citrix 
 *   install section of the registry.  If the system is in execution mode,
 *   mark the entry in the install section as being deleted.
 *
 * ENTRY:
 *  HANDLE hKey: Handle of key in user section to delete
 *
 * EXIT:
 *  TRUE: Entry deleted in install section
 *  FALSE: Entry not created
 *
 ****************************************************************************/

BOOL TermsrvDeleteKey(HANDLE hKey)
{
    NTSTATUS Status;        
    ULONG ultemp=0;
    ULONG ulAppType = TERMSRV_COMPAT_WIN32;
    OBJECT_ATTRIBUTES ObjectAttr;
    PKEY_BASIC_INFORMATION pKeyInfo;
    UNICODE_STRING UniString;
    HKEY   hNewKey;
    PWCHAR  wcbuff = NULL;
    PWCHAR pwch, pUserPath;
    BOOL fMapping;


    // Get the current state of ini file/registry mapping, default to execute
    fMapping = !TermsrvAppInstallMode();

    // If mapping is on, but disabled for this app, return
    if (fMapping) {
        GetCtxAppCompatFlags(&ultemp, &ulAppType);
        if ((ultemp & (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32)) == 
            (TERMSRV_COMPAT_NOREGMAP | TERMSRV_COMPAT_WIN32)) {
            return(FALSE);
        }
    }

    // Allocate a buffer to hold the path of the key
    ultemp = sizeof(WCHAR)*MAX_PATH*2;
    pUserPath = RtlAllocateHeap(RtlProcessHeap(), 
                                0, 
                                ultemp);

    // Get the path to the user's key
    if (pUserPath) {
        Status = TermsrvGetRegPath(hKey,
                               NULL,
                               pUserPath,
                               ultemp);
    } else {
        Status = STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(Status)) {

        // Get the corresponding path in the install section
        Status = TermsrvGetInstallPath(pUserPath,
                                   &wcbuff);

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&UniString, wcbuff);
            InitializeObjectAttributes(&ObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);
        
            // Open the key in the install section to mark it or delete it
            if (fMapping) {
                Status = NtOpenKey(&hNewKey,
                                   KEY_READ | KEY_WRITE,
                                   &ObjectAttr);
                                  
            } else {
                Status = NtOpenKey(&hNewKey,
                                   KEY_READ | KEY_WRITE | DELETE,
                                   &ObjectAttr);
            }
        }
    
        if (NT_SUCCESS(Status)) {
    
            // If in execute mode, set the copy once flag, but preserve the
            // last write time of this key
            if (fMapping) {
                PKEY_VALUE_PARTIAL_INFORMATION pValKeyInfo;
                PKEY_BASIC_INFORMATION pKeyInfo;
                NTSTATUS SubStatus;
                ULONG ulcbuf;

                // Get a buffer 
                ulcbuf = sizeof(KEY_BASIC_INFORMATION) + MAX_PATH*sizeof(WCHAR);
                pKeyInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                           0, 
                                           ultemp);

                // If we got the buffer, see if the copy once flag exists
                if (pKeyInfo) {
                    RtlInitUnicodeString(&UniString, TERMSRV_COPYONCEFLAG);
                    pValKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)pKeyInfo;
                    SubStatus = NtQueryValueKey(hNewKey,
                                                &UniString,
                                                KeyValuePartialInformation,
                                                pValKeyInfo,
                                                ulcbuf,
                                                &ultemp);

                    // If we couldn't get the value of the key, or it's not
                    // what it should be, reset it
                    if (!NT_SUCCESS(SubStatus) || 
                        (pValKeyInfo->Type != REG_DWORD) || 
                        (*pValKeyInfo->Data != 1)) {

                        // Get the last update time of the key
                        SubStatus = NtQueryKey(hNewKey,
                                               KeyBasicInformation,
                                               pKeyInfo,
                                               ultemp,
                                               &ultemp);

                        // Set the copy once flag
                        ultemp = 1;
                        Status = NtSetValueKey(hNewKey,
                                               &UniString,
                                               0,
                                               REG_DWORD,
                                               &ultemp,
                                               sizeof(ultemp));
        
                        // Restore the lastwritetime of the key
                        if (NT_SUCCESS(SubStatus)) {
                            NtSetInformationKey(hNewKey,
                                                KeyWriteTimeInformation,
                                                &pKeyInfo->LastWriteTime,
                                                sizeof(pKeyInfo->LastWriteTime));
                        }
                    }  

                    // Free up our buffer
                    RtlFreeHeap(RtlProcessHeap(), 0, pKeyInfo);
                }

            // For install mode, delete our copy of the key
            } else {
                Status = NtDeleteKey( hNewKey );
            }
            NtClose( hNewKey );
        }
    }

    if (pUserPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, pUserPath);
    }
    
    if (wcbuff) {
        RtlFreeHeap(RtlProcessHeap(), 0, wcbuff);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*****************************************************************************
 *
 *  TermsrvDeleteValue
 *
 *   Delete the registry value in the citrix install user section of the 
 *   registry.
 *
 * ENTRY:
 *  HANDLE hKey:               Handle of key in install section
 *  PUNICODE_STRING pUniValue: Ptr to unicode value name to delete
 *
 * EXIT:
 *  TRUE: Entry deleted in install section
 *  FALSE: Entry not created
 *
 ****************************************************************************/

BOOL TermsrvDeleteValue(HANDLE hKey,
                    PUNICODE_STRING pUniValue)
{
    NTSTATUS Status;        
    OBJECT_ATTRIBUTES ObjectAttr;
    WCHAR wcUserPath[MAX_PATH*2];
    PWCHAR wcInstPath = NULL;
    UNICODE_STRING UniString;
    HANDLE  hInstKey;

    // If not in install mode, return
    if ( !TermsrvAppInstallMode() ) {
        return(FALSE);
    }

    // Get the path to the key in the user section
    Status = TermsrvGetRegPath(hKey,
                           NULL,
                           wcUserPath,
                           sizeof(wcUserPath)/sizeof(WCHAR));

    if (NT_SUCCESS(Status)) {

        // Get the corresponding path in the install section
        Status = TermsrvGetInstallPath(wcUserPath,
                                   &wcInstPath);

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&UniString, wcInstPath);
            InitializeObjectAttributes(&ObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            // Open the install path key to delete the value
            Status = NtOpenKey(&hInstKey,
                               MAXIMUM_ALLOWED,
                               &ObjectAttr);

            // Delete the value
            if (NT_SUCCESS(Status)) {
                Status = NtDeleteValueKey(hInstKey,
                                          pUniValue);
                NtClose( hInstKey );
            }
        }
    }
    
    if (wcInstPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, wcInstPath);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*****************************************************************************
 *
 *  TermsrvRestoreKey
 *
 *   If the system is in installation mode and the application is trying to
 *   restore a key into the user or machine section of the registry, also
 *   restore the key into our install section.
 *
 * ENTRY:
 *  HANDLE hKey:  Handle of key in user section
 *  HANDLE hFile: Handle of file to load in
 *  ULONG Flags:  Restore key flags
 *
 * EXIT:
 *  TRUE: Entry created in install section
 *  FALSE: Entry not created
 *
 ****************************************************************************/

BOOL TermsrvRestoreKey(IN HANDLE hKey,
                   IN HANDLE hFile,
                   IN ULONG Flags)
{
    NTSTATUS Status;        
    OBJECT_ATTRIBUTES ObjectAttr;
    WCHAR wcUserPath[MAX_PATH*2];
    PWCHAR wcInstPath = NULL;
    UNICODE_STRING UniString;
    HANDLE  hInstKey;

    // If not in install mode or it's
    // a memory only restore, return
    if ( !TermsrvAppInstallMode() ||
        (Flags & REG_WHOLE_HIVE_VOLATILE)) {
        return(FALSE);
    }

    // Get the path to the key in the user section
    Status = TermsrvGetRegPath(hKey,
                           NULL,
                           wcUserPath,
                           sizeof(wcUserPath)/sizeof(WCHAR));

    if (NT_SUCCESS(Status)) {

        // Get the corresponding path in the install section
        Status = TermsrvGetInstallPath(wcUserPath,
                                   &wcInstPath);

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&UniString, wcInstPath);
            InitializeObjectAttributes(&ObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            // Open the install path key to load the key into
            Status = NtOpenKey(&hInstKey,
                               KEY_WRITE,
                               &ObjectAttr);

            // If we couldn't open it, try creating the key
            if (!NT_SUCCESS(Status)) {
                Status = TermsrvCreateKey(wcUserPath, 
                                      wcInstPath,
                                      TRUE,
                                      FALSE,
                                      &hInstKey);
            }

            // Restore the key into the user section
            if (NT_SUCCESS(Status)) {
                Status = NtRestoreKey(hInstKey,
                                      hFile,
                                      Flags);
                NtClose( hInstKey );

                // Update the registry entry for the last time a registry
                // entry was added
                if (NT_SUCCESS(Status)) {
                    TermsrvLogRegInstallTime();
                }
            }
        }
    }
    
    if (wcInstPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, wcInstPath);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/*****************************************************************************
 *
 *  TermsrvSetKeySecurity
 *
 *   If the system is in installation mode and the application is trying to
 *   set the security of an entry in the the user or machine section of the 
 *   registry, also set the security of the key in the install section.
 *
 * ENTRY:
 *  HANDLE hKey:                   Handle in user section to set security
 *  SECURITY_INFORMATION SecInfo:  Security info struct
 *  PSECURITY_DESCRIPTOR pSecDesc: Ptr to security descriptor
 *
 * EXIT:
 *  TRUE:  Security set in install section
 *  FALSE: Error
 *
 ****************************************************************************/

BOOL TermsrvSetKeySecurity(IN HANDLE hKey,  
                       IN SECURITY_INFORMATION SecInfo,
                       IN PSECURITY_DESCRIPTOR pSecDesc)
{
    NTSTATUS Status;        
    OBJECT_ATTRIBUTES ObjectAttr;
    WCHAR wcUserPath[MAX_PATH*2];
    PWCHAR wcInstPath = NULL;
    UNICODE_STRING UniString;
    HANDLE  hInstKey;

    // If not in install mode, return
    if ( !TermsrvAppInstallMode() ) {
        return(FALSE);
    }

    // Get the path to the key in the user section
    Status = TermsrvGetRegPath(hKey,
                           NULL,
                           wcUserPath,
                           sizeof(wcUserPath)/sizeof(WCHAR));

    if (NT_SUCCESS(Status)) {

        // Get the corresponding path in the install section
        Status = TermsrvGetInstallPath(wcUserPath,
                                   &wcInstPath);

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&UniString, wcInstPath);
            InitializeObjectAttributes(&ObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            // Open the install path key to load the key into
            Status = NtOpenKey(&hInstKey,
                               KEY_WRITE | WRITE_OWNER | WRITE_DAC,
                               &ObjectAttr);

            // Set the security
            if (NT_SUCCESS(Status)) {

                Status = NtSetSecurityObject(hKey,
                                             SecInfo,
                                             pSecDesc);
                NtClose( hInstKey );
            }
        }
    }
    
    if (wcInstPath) {
        RtlFreeHeap(RtlProcessHeap(), 0, wcInstPath);
    }

    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}



/*****************************************************************************
 *
 *  TermsrvGetRegPath
 *
 *   From the handle or a pointer to the object attributes, return the
 *   object's path in the registry.
 *
 * ENTRY:
 *  HANDLE hKey:       Handle of an open key to get the path of
 *  POBJECT_ATTRIBUTES Ptr to open attribute structure to get the path of
 *  PWCHAR pInstPath   Ptr to return buffer
 *  ULONG  ulbuflen    Length of return buffer
 *
 * NOTES:
 *  Either hKey or pObjectAttr must be specified, but not both.
 *
 * EXIT:
 *  NTSTATUS return code
 *
 ****************************************************************************/

NTSTATUS TermsrvGetRegPath(IN HANDLE hKey,
                       IN POBJECT_ATTRIBUTES pObjectAttr,
                       IN PWCHAR pUserPath,
                       IN ULONG  ulbuflen)
{
    NTSTATUS Status = STATUS_SUCCESS;             
    ULONG ultemp;
    ULONG ulWcharLength;          //Keep track of the WCHAR string length
    PWCHAR pwch;
    PVOID  pBuffer = NULL;

    // Make sure only one of hKey or pObjectAttr was specified
    if ((hKey && pObjectAttr) || (!hKey && !pObjectAttr)) {
        return(STATUS_INVALID_PARAMETER);
    }

    // A key handle or root directory was specified, so get its path
    if (hKey || (pObjectAttr && pObjectAttr->RootDirectory)) {
        ultemp = sizeof(UNICODE_STRING) + sizeof(WCHAR)*MAX_PATH*2;
        pBuffer = RtlAllocateHeap(RtlProcessHeap(), 
                                  0, 
                                  ultemp);

        // Got the buffer OK, query the path
        if (pBuffer) {
            // Get the path for key or root directory
            Status = NtQueryObject(hKey ? hKey : pObjectAttr->RootDirectory,
                                   ObjectNameInformation,
                                   (PVOID)pBuffer,
                                   ultemp,
                                   NULL);
            if (!NT_SUCCESS(Status)) {
                RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
                return(Status);
            }
        } else {
            return(STATUS_NO_MEMORY);
        }

        // Build the full path to the key to be created
        pwch = ((PUNICODE_STRING)pBuffer)->Buffer;

        // BBUG 417564. Bad apps close HKLM, but we might need it here.
        if (!pwch) {
            RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
            return(STATUS_INVALID_HANDLE); 
        }

        // Make sure the string is zero terminated
        ulWcharLength = ((PUNICODE_STRING)pBuffer)->Length / sizeof(WCHAR); 
        pwch[ulWcharLength] = 0;                   

        // If using Object Attributes and there's room, tack on the object name 
        if (pObjectAttr) {
            if ((((PUNICODE_STRING)pBuffer)->Length + 
                  pObjectAttr->ObjectName->Length + sizeof(WCHAR)) < ultemp) {
                wcscat(pwch, L"\\");
                //Increment the length of the string
                ulWcharLength += 1;
                //Append the relative path to the root path (Don't use wcscat. The string may not
                // be zero terminated
                wcsncpy(&pwch[ulWcharLength], pObjectAttr->ObjectName->Buffer, pObjectAttr->ObjectName->Length / sizeof (WCHAR));
                // Make sure the string is zero terminated
                ulWcharLength += (pObjectAttr->ObjectName->Length / sizeof(WCHAR));
                pwch[ulWcharLength] = 0;
            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }

    } else {

        // No root directory, they specified the entire path
        pwch = pObjectAttr->ObjectName->Buffer;
        //Make sure it is zero terminated
        pwch[pObjectAttr->ObjectName->Length / sizeof(WCHAR)] = 0;
    }

    // Make sure the path will fit in the buffer
    if ((Status == STATUS_SUCCESS) && 
        (wcslen(pwch)*sizeof(WCHAR) < ulbuflen)) {
        wcscpy(pUserPath, pwch);
    } else {
        Status = STATUS_BUFFER_TOO_SMALL;
    }

    if (pBuffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
    }

    return(Status);
}

/*****************************************************************************
 *
 *  TermsrvGetInstallPath
 *
 *   From the path to the user entry in the registry, get the path to the
 *   entry in the default install section.
 *
 * ENTRY:
 *  IN PWCHAR pUserPath:    Ptr to path of key in user section
 *  IN PWCHAR *ppInstPath:    Ptr to ptr to return path of key in install section
 *
 * NOTES:
 *  Caller must use RtlFreeHeap to free memory allocated for ppInstPath!
 *
 * EXIT:
 *  NTSTATUS return code
 *
 ****************************************************************************/

NTSTATUS TermsrvGetInstallPath(IN PWCHAR pUserPath,
                           IN PWCHAR *ppInstPath)
{
    NTSTATUS Status = STATUS_NO_SUCH_FILE;
    PWCHAR pwch = NULL;
    BOOL fUserReg;
    BOOL bClassesKey = FALSE;
    
    *ppInstPath = NULL;

    // Check if the app is accessing the user or local machine section
    pwch = GetUserSWKey(pUserPath, &fUserReg, &bClassesKey);
           
    // Copy the path to the user's buffer
    if (pwch || bClassesKey) 
    {
        ULONG  ulInstBufLen = ( wcslen(TERMSRV_INSTALL) + wcslen(SOFTWARE_PATH) + wcslen(CLASSES_PATH) +  1 )*sizeof(WCHAR);
        if (pwch)
            ulInstBufLen += wcslen(pwch) * sizeof(WCHAR);

        *ppInstPath = RtlAllocateHeap(RtlProcessHeap(), 
                                0, 
                                ulInstBufLen);
        if(*ppInstPath) {

            wcscpy(*ppInstPath, TERMSRV_INSTALL);
            if (bClassesKey)
            {
                wcscat(*ppInstPath, SOFTWARE_PATH);
                wcscat(*ppInstPath, CLASSES_PATH);
            }
            if (pwch)
                wcscat(*ppInstPath, pwch);

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_NO_MEMORY;
        }
    }

    return(Status);
}


/*****************************************************************************
 *
 *  TermsrvCreateKey
 *
 *  This routine will create (or open) the specified path in the registry.
 *  If the path doesn't exist in the registry, it will be created.
 *
 * ENTRY:
 *   PWCHAR pSrcPath:      Source path to copy keys from (optional)
 *   PWCHAR pDstPath:      Destination path to create
 *   BOOL   fCloneValues:  TRUE means to clone all values under this key
 *   BOOL   fCloneSubKeys: TRUE means to create all subkeys under this key
 *   PHANDLE phKey:        Pointer for key created
 *
 * EXIT:
 *   NTSTATUS return code
 *
 ****************************************************************************/

NTSTATUS TermsrvCreateKey(IN PWCHAR pSrcPath,
                      IN PWCHAR pDstPath,
                      BOOL fCloneValues,
                      BOOL fCloneSubKeys,
                      OUT PHANDLE phKey)
{
    NTSTATUS Status;
    PWCHAR pSource = NULL, pDest = NULL;
    HANDLE hDstKey, hDstRoot, hSrcKey, hSrcRoot;
    ULONG  ultemp, NumSubKeys, ulcnt, ulbufsize, ulkey;
    UNICODE_STRING    UniString, UniClass;
    OBJECT_ATTRIBUTES ObjectAttr;
    PKEY_FULL_INFORMATION pDefKeyInfo = NULL;
    ULONG aulbuf[4];
    PKEY_VALUE_PARTIAL_INFORMATION pValKeyInfo = 
        (PKEY_VALUE_PARTIAL_INFORMATION)aulbuf;
    BOOL fClassesKey = FALSE, fUserReg;

    // Check if we are trying to copy values into the user's registry
    pDest = GetUserSWKey(pDstPath, &fUserReg, NULL);
    if (fUserReg) {
        if (fCloneValues || fCloneSubKeys) {

            // Skip to software section of the default install user
            pSource = pSrcPath + wcslen(TERMSRV_INSTALL);

            // If copying CLASSES, set Clone to FALSE so don't clone
            // until we're at the CLASSES key

            // Actually, this func is not called for copying classes, I belive that feature is/was 
            // turned off in W2K, which means that any time this func is called, we for sure are 
            // dealing with either HKCU\SW or HKLM, but never HKCU\SW\Clasess.
            // Nov 30, 2000
            //
            if (pDest)
            {
                if (!_wcsnicmp(pDest,
                              TERMSRV_SOFTWARECLASSES,
                              wcslen(TERMSRV_SOFTWARECLASSES))) {
                   fClassesKey = TRUE;
                   fCloneValues = fCloneSubKeys = FALSE;
                }
            }
        }

    // Trying to copy to citrix install section?
    } else if (!_wcsnicmp(pDstPath,
                         TERMSRV_INSTALL,
                         wcslen(TERMSRV_INSTALL))) {

        // Skip to software section of the default install user
        pDest = pDstPath + wcslen(TERMSRV_INSTALL);

        // If copying from MACHINE\..\CLASSES, set Clone values to FALSE
        // so we don't clone until we're at the CLASSES key.
        if (pSrcPath && !_wcsnicmp(pSrcPath,
                                  TERMSRV_CLASSES,
                                  wcslen(TERMSRV_CLASSES))) {
            fClassesKey = TRUE;
            pSource = Ctxwcsistr(pSrcPath, SOFTWARE_PATH); 
            fCloneValues = fCloneSubKeys = FALSE;
        }
        // If we're cloning, set up the source path
        else if (fCloneValues || fCloneSubKeys) {

            // Is this from the user section?
            pSource = GetUserSWKey(pSrcPath, &fUserReg, NULL);

            // Must be from the local machine section
            if (!fUserReg) {
                pSource = Ctxwcsistr(pSrcPath, L"\\machine");
            }
        }
    }
                         
    // Make sure the paths are valid
    if (!pDest || ((fCloneValues || fCloneSubKeys) && !pSource)) {
        return(STATUS_NO_SUCH_FILE);
    }

    // Initialize the number of subkeys to be created
    NumSubKeys = 1;

    while ((pDest = wcschr(pDest, L'\\')) != NULL) {
        *pDest = L'\0';
        pDest++;
        NumSubKeys++;
    }

    // If we need to clone values or keys from the source path, get the
    // buffers we'll need, and tokenize the source path
    if (fCloneValues || fCloneSubKeys || fClassesKey) {

        // Allocate a buffer for the class of the source key
        ulbufsize = sizeof(KEY_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR);
        pDefKeyInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                      0, 
                                      ulbufsize);
        if (pDefKeyInfo) {
            while ((pSource = wcschr(pSource, L'\\')) != NULL) {
                *pSource = L'\0';
                pSource++;
            }
            pSource = pSrcPath;
        } else {
            fCloneValues = fCloneSubKeys = fClassesKey = FALSE;
        }
    }

    hSrcRoot = hDstRoot = NULL;
    pDest = pDstPath;

    // Go through each key in the path, creating it if it doesn't exist
    for (ulcnt = 0; ulcnt < NumSubKeys; ulcnt++) {

        if ((*pDest == L'\0') &&
            (ulcnt != NumSubKeys - 1)) {
            pDest++;
            pSource++;
            continue;
        } 
        // If we're at CLASSES key, we need to clone the whole key
        else if (fClassesKey && !_wcsicmp(pDest, L"classes")) {
            fCloneValues = fCloneSubKeys = TRUE;
        }  

        // If we're copying values from the source, open up the source so we
        // can get the values and subkeys
        // Also need to check for ClassesKey cause we'll be cloning later and
        // we need some setup done
        if (fCloneValues || fCloneSubKeys || fClassesKey) {

            // Set up the attribute structure for the source path
            RtlInitUnicodeString(&UniString, pSource);
            InitializeObjectAttributes(&ObjectAttr,
                                       &UniString,
                                       OBJ_CASE_INSENSITIVE,
                                       hSrcRoot,
                                       NULL);

            // Open the source key
            Status = NtOpenKey(&hSrcKey, 
                               KEY_READ,
                               &ObjectAttr);

            // Get the source key info and value
            if (NT_SUCCESS(Status)) {
                // Close the source root, if necessary
                if (hSrcRoot) {
                    NtClose(hSrcRoot);
                }
                hSrcRoot = hSrcKey;

                Status = NtQueryKey(hSrcKey,
                                    KeyFullInformation,
                                    pDefKeyInfo,
                                    ulbufsize,
                                    &ultemp);

                if (NT_SUCCESS(Status)) {
                    RtlInitUnicodeString(&UniString, TERMSRV_COPYONCEFLAG);
                    Status = NtQueryValueKey(hSrcKey,
                                             &UniString,
                                             KeyValuePartialInformation,
                                             pValKeyInfo,
                                             sizeof(aulbuf),
                                             &ultemp);
                    if (NT_SUCCESS(Status) && (pValKeyInfo->Data)) {
                        break;
                    }
                }
            } else {
                break;
            }

            // Setup the unicode string for the class
            if ( pDefKeyInfo->ClassLength ) { 
                pDefKeyInfo->Class[pDefKeyInfo->ClassLength/sizeof(WCHAR)] = UNICODE_NULL;
                RtlInitUnicodeString(&UniClass, pDefKeyInfo->Class );
            } else
                RtlInitUnicodeString(&UniClass, NULL);

            // Advance to the next key
            pSource += wcslen( pSource ) + 1;
        } else {
            // Set the class to NULL
            RtlInitUnicodeString(&UniClass, NULL);
        }

        // Set up the attribute structure for the destination
        RtlInitUnicodeString(&UniString, pDest);
        InitializeObjectAttributes(&ObjectAttr,
                                   &UniString,
                                   OBJ_CASE_INSENSITIVE,
                                   hDstRoot,
                                   NULL);
                       
        // Open/Create the destination key
        Status = NtCreateKey(&hDstKey,
                             MAXIMUM_ALLOWED,
                             &ObjectAttr,
                             0,
                             &UniClass,
                             REG_OPTION_NON_VOLATILE,
                             &ultemp);

        // If the key was created (NOT opened) copy the values and subkeys
        if (NT_SUCCESS(Status) && 
            ((ultemp == REG_CREATED_NEW_KEY) && 
             (fCloneSubKeys || fCloneValues))) {
            Status = TermsrvCloneKey(hSrcKey,
                                 hDstKey,
                                 pDefKeyInfo,
                                 fCloneSubKeys);
        }

        // Close the intermediate key.
        if( hDstRoot != NULL ) {
            NtClose( hDstRoot );
        }

        // Initialize the next object directory (i.e. parent key) 
        hDstRoot = hDstKey;

        // If creating the key failed, break out of the loop
        if( !NT_SUCCESS( Status )) {
            break;
        }

        pDest += wcslen( pDest ) + 1;
    }

    // Close the source root, if necessary
    if (hSrcRoot) {
        NtClose(hSrcRoot);
    }

    if ( !NT_SUCCESS( Status ) && hDstRoot) {
        NtClose(hDstRoot);
        hDstKey = NULL;
    }

    if (pDefKeyInfo) {
        RtlFreeHeap(RtlProcessHeap(), 0, pDefKeyInfo);
    }

    *phKey = hDstKey;
    return(Status);
}


/*****************************************************************************
 *
 *  TermsrvCloneKey
 *
 *  This routine will recursively create (or open) the specified path in the 
 *  registry.  If the path doesn't exist in the registry, it will be created.
 *
 * ENTRY:
 *  HANDLE hSrcKey:  Handle for source key
 *  HANDLE hDstKey:  Handle for destination key
 *  PKEY_FULL_INFORMATION pDefKeyInfo:  Ptr to key info structure of source
 *  BOOL fCreateSubKeys: TRUE means to recursively clone subkeys
 *
 * EXIT:
 *   NTSTATUS return code
 *
 ****************************************************************************/

NTSTATUS TermsrvCloneKey(HANDLE hSrcKey,
                     HANDLE hDstKey,
                     PKEY_FULL_INFORMATION pDefKeyInfo,
                     BOOL fCreateSubKeys)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ulbufsize, ultemp, ulkey, ulcursize;
    UNICODE_STRING    UniString, UniClass;
    OBJECT_ATTRIBUTES ObjectAttr;
    PKEY_NODE_INFORMATION pKeyNodeInfo;
    PKEY_VALUE_FULL_INFORMATION pKeyValInfo;
    PKEY_VALUE_BASIC_INFORMATION pKeyCurInfo;
    PKEY_FULL_INFORMATION pKeyNewInfo;
    HANDLE hNewDst, hNewSrc;
    SECURITY_DESCRIPTOR SecDesc;

#ifdef CLONE_SECURITY
    // Get the security access for the source key
    Status = NtQuerySecurityObject(hSrcKey,
                                   OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION  |
                                    SACL_SECURITY_INFORMATION,
                                   &SecDesc,
                                   sizeof(SecDesc),
                                   &ultemp);

    // Set the security access for the destination key
    if (NT_SUCCESS(Status)) {
        Status = NtSetSecurityObject(hDstKey,
                                     OWNER_SECURITY_INFORMATION |
                                      GROUP_SECURITY_INFORMATION |
                                      DACL_SECURITY_INFORMATION  |
                                      SACL_SECURITY_INFORMATION,
                                     &SecDesc);
    }
#endif

    // Create the values for this key
    if (pDefKeyInfo->Values) {

        ulbufsize = sizeof(KEY_VALUE_FULL_INFORMATION) + 
                    (pDefKeyInfo->MaxValueNameLen + 1)*sizeof(WCHAR) +
                    pDefKeyInfo->MaxValueDataLen; 
    
        pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                      0, 
                                      ulbufsize);

        // Get a buffer to hold current value of the key (for existance check)
        ulcursize = sizeof(KEY_VALUE_BASIC_INFORMATION) + 
                    (pDefKeyInfo->MaxNameLen + 1)*sizeof(WCHAR);

        pKeyCurInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                      0, 
                                      ulcursize);

        if (pKeyValInfo && pKeyCurInfo) {
            for (ulkey = 0; ulkey < pDefKeyInfo->Values; ulkey++) {
                Status = NtEnumerateValueKey(hSrcKey,
                                             ulkey,
                                             KeyValueFullInformation,
                                             pKeyValInfo,
                                             ulbufsize,
                                             &ultemp);

                // If successful and this isn't our "copy once" flag, copy
                // the value to the user's keys
                if (NT_SUCCESS(Status) &&
                    (wcsncmp(pKeyValInfo->Name, TERMSRV_COPYONCEFLAG,
                             sizeof(TERMSRV_COPYONCEFLAG)/sizeof(WCHAR)-1))) {
                    UniString.Buffer = pKeyValInfo->Name;
                    UniString.Length = (USHORT)pKeyValInfo->NameLength;
                    UniString.MaximumLength = UniString.Length + 2;

                    // Check if the value exists
                    Status = NtQueryValueKey(hDstKey,
                                             &UniString,
                                             KeyValueBasicInformation,
                                             pKeyCurInfo,
                                             ulcursize,
                                             &ultemp);

                    // Value doesn't exist, go ahead and create it
                    if (!NT_SUCCESS(Status)) {
                        Status = NtSetValueKey(hDstKey,
                                               &UniString,
                                               0,
                                               pKeyValInfo->Type,
                                               (PCHAR)pKeyValInfo + 
                                                 pKeyValInfo->DataOffset,
                                               pKeyValInfo->DataLength);
                    }
                }
            }
            RtlFreeHeap(RtlProcessHeap(), 0, pKeyValInfo);
            RtlFreeHeap(RtlProcessHeap(), 0, pKeyCurInfo);
        } else {
            if (pKeyValInfo) {
                RtlFreeHeap(RtlProcessHeap(), 0, pKeyValInfo);
            }
            Status = STATUS_NO_MEMORY;
        }
    }

    // If requested, create all of the child keys
    if (fCreateSubKeys && pDefKeyInfo->SubKeys) {

        // Allocate a buffer to get name and class of key to create
        ulbufsize = sizeof(KEY_NODE_INFORMATION) + 2*MAX_PATH*sizeof(WCHAR);
        pKeyNodeInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                       0, 
                                       ulbufsize);

        // Allocate a buffer for subkey info
        ulbufsize = sizeof(KEY_FULL_INFORMATION) + MAX_PATH*sizeof(WCHAR);
        pKeyNewInfo = RtlAllocateHeap(RtlProcessHeap(), 
                                      0, 
                                      ulbufsize);
    
        if (pKeyNodeInfo && pKeyNewInfo) {
            for (ulkey = 0; ulkey < pDefKeyInfo->SubKeys; ulkey++) {
                Status = NtEnumerateKey(hSrcKey,
                                        ulkey,
                                        KeyNodeInformation,
                                        pKeyNodeInfo,
                                        ulbufsize,
                                        &ultemp);
    
                if (NT_SUCCESS(Status)) {
                    // Init the unicode string for the class
                    UniClass.Buffer = (PWCHAR)((PCHAR)pKeyNodeInfo + 
                                               pKeyNodeInfo->ClassOffset);
                    UniClass.Length = (USHORT)pKeyNodeInfo->ClassLength;
                    UniClass.MaximumLength = UniString.Length + 2;
    
                    // Init the unicode string for the name
                    UniString.Buffer = pKeyNodeInfo->Name;
                    UniString.Length = (USHORT)pKeyNodeInfo->NameLength;
                    UniString.MaximumLength = UniString.Length + 2;
            
                    InitializeObjectAttributes(&ObjectAttr,
                                               &UniString,
                                               OBJ_CASE_INSENSITIVE,
                                               hDstKey,
                                               NULL);
                                   
                    Status = NtCreateKey(&hNewDst,
                                         MAXIMUM_ALLOWED,
                                         &ObjectAttr,
                                         0,
                                         &UniClass,
                                         REG_OPTION_NON_VOLATILE,
                                         &ultemp);
    
                    if (NT_SUCCESS(Status)) {
                        InitializeObjectAttributes(&ObjectAttr,
                                                   &UniString,
                                                   OBJ_CASE_INSENSITIVE,
                                                   hSrcKey,
                                                   NULL);
            
                        Status = NtOpenKey(&hNewSrc, 
                                           KEY_READ,
                                           &ObjectAttr);
            
                        // Get the key info
                        if (NT_SUCCESS(Status)) {
                            Status = NtQueryKey(hNewSrc,
                                                KeyFullInformation,
                                                pKeyNewInfo,
                                                ulbufsize,
                                                &ultemp);

                            if (NT_SUCCESS(Status) &&
                                (pKeyNewInfo->SubKeys || 
                                 pKeyNewInfo->Values)) {
                                Status = TermsrvCloneKey(hNewSrc, 
                                                     hNewDst, 
                                                     pKeyNewInfo, 
                                                     TRUE);
                            }
                            NtClose(hNewSrc);
                        }
                        NtClose(hNewDst);
                    }
                }
            }
            RtlFreeHeap(RtlProcessHeap(), 0, pKeyNodeInfo);
            RtlFreeHeap(RtlProcessHeap(), 0, pKeyNewInfo);
        } else {
            if (pKeyNodeInfo) {
                RtlFreeHeap(RtlProcessHeap(), 0, pKeyNodeInfo);
            }
            Status = STATUS_NO_MEMORY;
        }
    }
    return(Status);
}


/*****************************************************************************
 *
 *  Ctxwcsistr
 *
 *  This is a case insensitive version of wcsstr.
 *
 * ENTRY:
 *   PWCHAR pstring1 (In) - String to search in
 *   PWCHAR pstring2 (In) - String to search for
 *
 * EXIT:
 *   Success: 
 *       pointer to substring
 *   Failure: 
 *       NULL
 *
 ****************************************************************************/

PWCHAR 
Ctxwcsistr(PWCHAR pstring1,
           PWCHAR pstring2)
{
    PWCHAR pch, ps1, ps2;

    pch = pstring1;

    while (*pch)
    {
        ps1 = pch;
        ps2 = pstring2;
     
        while (*ps1 && *ps2 && !(towupper(*ps1) - towupper(*ps2))) {
            ps1++;
            ps2++;
        }
     
        if (!*ps2) {
            return(pch);
        }
     
        pch++;
    }
    return(NULL);
}


/*****************************************************************************
 *
 *  IsSystemLUID
 *
 *  This routines checks if we are running under the system context, and if
 *  so returns false.  We want all of the registry mapping support disable
 *  for system services.
 *
 *  Note we don't check the thread's token, so impersonation doesn't work.
 *
 * ENTRY:
 *
 * EXIT:
 *   TRUE:
 *       Called from within system context
 *   FALSE:   
 *       Regular context
 *
 ****************************************************************************/

#define SIZE_OF_STATISTICS_TOKEN_INFORMATION    \
     sizeof( TOKEN_STATISTICS ) 

BOOL IsSystemLUID(VOID)
{
    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_STATISTICS_TOKEN_INFORMATION ];
    ULONG       ReturnLength;
    static LUID CurrentLUID = { 0, 0 };
    LUID        SystemLUID = SYSTEM_LUID;

    if ( CurrentLUID.LowPart == 0 && CurrentLUID.HighPart == 0 ) {
        if ( !OpenProcessToken( GetCurrentProcess(),
                                TOKEN_READ,
                                &TokenHandle ))
        {
            return(TRUE);
        }
    
        if ( !GetTokenInformation( TokenHandle,
                                   TokenStatistics,
                                   TokenInformation,
                                   sizeof( TokenInformation ),
                                   &ReturnLength ))
        {
            return(TRUE);
        }
    
        CloseHandle( TokenHandle );

        RtlCopyLuid(&CurrentLUID, 
                    &(((PTOKEN_STATISTICS)TokenInformation)->AuthenticationId));
    }

    if (RtlEqualLuid(&CurrentLUID, &SystemLUID)) {
        return(TRUE);
    } else {
        return(FALSE );
    }
}


/*****************************************************************************
 *
 *  TermsrvLogRegInstallTime
 *
 *  This routines updates the LatestRegistryKey value in the registry to
 *  contain the current time.
 *
 * ENTRY:
 *
 * EXIT:
 *   No return value
 *
 ****************************************************************************/

void TermsrvLogRegInstallTime()
{
    UNICODE_STRING UniString;
    HANDLE hKey;
    FILETIME FileTime;
    ULONG ultmp;
    NTSTATUS Status;
    WCHAR wcbuff[MAX_PATH];

    // Open up the registry key to store the last write time of the file
    wcscpy(wcbuff, TERMSRV_INIFILE_TIMES);

    // Create or open the path to the IniFile Times key
    Status = TermsrvCreateKey(NULL,
                          wcbuff,
                          FALSE,
                          FALSE,
                          &hKey);

    // Opened up the registry key, now set the value to the current time
    if (NT_SUCCESS(Status)) {

        GetSystemTimeAsFileTime(&FileTime);
        RtlTimeToSecondsSince1970((PLARGE_INTEGER)&FileTime,
                                  &ultmp);

        RtlInitUnicodeString(&UniString,
                             INIFILE_TIMES_LATESTREGISTRYKEY);

        // Now store it under the citrix key in the registry
        Status = NtSetValueKey(hKey,
                               &UniString,
                               0,
                               REG_DWORD,
                               &ultmp,
                               sizeof(ultmp));
        // Close the registry key
        NtClose(hKey);
    }
}

/*****************************************************************************
 *
 *  TermsrvOpenUserClasses
 *
 *   If the system is in execute mode, open \SOFTWARE\CLASSES key under 
 *   HKEY_CURRENT_USER.  If CLASSES doesen't exist under TERMSRV\INSTALL
 *   or HKEY_CURRENT_USER, copy it from \MACHINE\SOFTWARE\CLASSES.  
 *
 * ENTRY:
 *  IN ACCESS_MASK DesiredAccess:
 *      Desired access to the key
 *  OUT PHANDLE phKey:
 *      Pointer to return key handle if opened
 *
 * EXIT:
 *  NT_STATUS return code 
 *
 ****************************************************************************/

BOOL TermsrvOpenUserClasses(IN ACCESS_MASK DesiredAccess, 
                        OUT PHANDLE pUserhKey) 
{
    NTSTATUS Status;        
    ULONG ultemp;
    ULONG ulAppType = TERMSRV_COMPAT_WIN32;
    HKEY   hDstKey;
    WCHAR  wcbuff[MAX_PATH],wcClassbuff[TERMSRV_CLASSES_SIZE];
    PWCHAR pUserPath;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UniString;

    // set return handle to 0 cause OpenClassesRoot checks it
    *pUserhKey = 0;
    

    //Disable it for now
    return(STATUS_NO_SUCH_FILE);
    
        
        // If called under a system service or  in install mode, return
    if ( IsSystemLUID() || TermsrvAppInstallMode() ) {
        return(STATUS_NO_SUCH_FILE);
    }

    // If mapping is on, but disabled for CLASSES, return
    GetTermsrCompatFlags(TERMSRV_CLASSES, &ultemp, CompatibilityRegEntry);
    if ((ultemp & (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) ==
        (TERMSRV_COMPAT_WIN32 | TERMSRV_COMPAT_NOREGMAP)) {
        return(STATUS_NO_SUCH_FILE);
    }


    // Open MACHINE\SOFTWARE\CLASSES key
    RtlInitUnicodeString(&UniString, TERMSRV_CLASSES);
    InitializeObjectAttributes(
        &Obja,
        &UniString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&hDstKey,
                       KEY_READ,
                       &Obja);

    if (!NT_SUCCESS(Status)) {
        return(STATUS_NO_SUCH_FILE);
    }

    NtClose(hDstKey);

    // Need to put this in buffer cause CtxCreateKey modifies the string.
    wcscpy(wcClassbuff, TERMSRV_CLASSES);

    // Try to open TERMSRV\INSTALL\SOFTWARE\CLASSES; if it doesn't exist,
    // clone it from MACHINE\SOFTWARE\CLASSES.
    wcscpy(wcbuff, TERMSRV_INSTALLCLASSES);
    Status = TermsrvCreateKey(wcClassbuff,
                          wcbuff,
                          TRUE,
                          TRUE,
                          &hDstKey);
    
    if (NT_SUCCESS(Status)) {
        NtClose(hDstKey);
    }

    // Try to open HKEY_CURRENT_USER\SOFTWARE\CLASSES; if it doesn't exist,
    // clone it from TERMSRV\INSTALL\SOFTWARE\CLASSES.
    Status = RtlOpenCurrentUser( DesiredAccess, pUserhKey );

    if (NT_SUCCESS(Status)) {
       ultemp = sizeof(WCHAR)*MAX_PATH;
       Status = TermsrvGetRegPath(*pUserhKey,
                              NULL,
                              (PWCHAR)&wcbuff,
                              ultemp);
       NtClose(*pUserhKey);
       if (NT_SUCCESS(Status)) {
          wcscat(wcbuff, TERMSRV_SOFTWARECLASSES);
          wcscpy(wcClassbuff, TERMSRV_INSTALLCLASSES);
          Status = TermsrvCreateKey(wcClassbuff,
                                wcbuff,
                                TRUE,
                                TRUE,
                                pUserhKey);
       }
    }

    return(Status);
}

/*****************************************************************************
 *
 *  TermsrvGetPreSetValue
 *
 *   Get any preset value during install.
 *
 * ENTRY:
 *  
 *  IN HANDLE hKey:               Key user wants to set
 *  IN PUNICODE_STRING pValueName: Value name user wants to set
 *  IN ULONG  Type:               Type of value
 *  OUT PVOID *Data:              Pre-set data
 *  OUT PULONG DataSize:          Size of preset data
 *
 * NOTES:
 *
 * EXIT:
 *  NTSTATUS return code
 *
 ****************************************************************************/

NTSTATUS TermsrvGetPreSetValue(  IN HANDLE hKey,
                             IN PUNICODE_STRING pValueName,
                             IN ULONG  Type,
                            OUT PVOID *Data
                           )
{

#define DEFAULT_VALUE_SIZE          128

    NTSTATUS Status = STATUS_NO_SUCH_FILE;
    PWCHAR pwch = NULL;
    WCHAR pUserPath[MAX_PATH];
    WCHAR ValuePath[2 * MAX_PATH];
    ULONG ultemp;
    UNICODE_STRING UniString;
    OBJECT_ATTRIBUTES Obja;
    ULONG BufferLength;
    PVOID KeyValueInformation;
    ULONG ResultLength;
    HANDLE hValueKey;
    BOOL fUserReg;

    // If running in execute mode, return
    if ( !TermsrvAppInstallMode() ) {
        return(STATUS_NO_SUCH_FILE);
    }

    ultemp = sizeof(WCHAR)*MAX_PATH;

    // Get the path of this key
    Status = TermsrvGetRegPath(hKey,
                           NULL,
                           pUserPath,
                           ultemp);

    if (!NT_SUCCESS(Status)) 
        return Status;

    // Check if the app is accessing the local machine section
    // or the user section.

    pwch = GetUserSWKey(pUserPath, &fUserReg, NULL);
    if (!fUserReg) {
        if (!_wcsnicmp(pUserPath,
                       TERMSRV_VALUE,
                       wcslen(TERMSRV_VALUE))) {
            Status = STATUS_NO_SUCH_FILE;
            return Status;
        } else if (!_wcsnicmp(pUserPath,
                      TERMSRV_MACHINEREGISTRY,
                      wcslen(TERMSRV_MACHINEREGISTRY))) {
            pwch = Ctxwcsistr(pUserPath, L"\\machine");
        } else {
            Status = STATUS_NO_SUCH_FILE;
            return Status;
        }
    }

    if ( pwch == NULL )
    {
        Status = STATUS_NO_SUCH_FILE;
        return Status;
    }

    // Get the path to the preset value section

    wcscpy(ValuePath, TERMSRV_VALUE);
    wcscat(ValuePath, pwch);

    // Open Value key
    RtlInitUnicodeString(&UniString, ValuePath);

    InitializeObjectAttributes(
        &Obja,
        &UniString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenKey(&hValueKey,
                       KEY_READ,
                       &Obja);

    if (!NT_SUCCESS(Status)) {
        return(STATUS_NO_SUCH_FILE);
    }

    // Allocate space for the "new" value

    BufferLength = DEFAULT_VALUE_SIZE + sizeof( KEY_VALUE_PARTIAL_INFORMATION );

    KeyValueInformation = RtlAllocateHeap( RtlProcessHeap( ), 0, BufferLength );
    if ( !KeyValueInformation ) {
         NtClose(hValueKey);
         return STATUS_NO_MEMORY;
    }

    Status = NtQueryValueKey( hValueKey,
                              pValueName,
                              KeyValuePartialInformation,
                              KeyValueInformation,
                              BufferLength,
                              &ResultLength
                            );

    // If we didn't allocate enough space, try again

    if ( Status == STATUS_BUFFER_OVERFLOW ) {

        RtlFreeHeap(RtlProcessHeap(), 0, KeyValueInformation);

        BufferLength = ResultLength;

        KeyValueInformation = RtlAllocateHeap( RtlProcessHeap( ), 0,
                                               BufferLength
                                              );
        if ( !KeyValueInformation ) {
            NtClose(hValueKey);
            return STATUS_NO_MEMORY;
        }

        //
        // This one should succeed
        //

        Status = NtQueryValueKey( hValueKey,
                                  pValueName,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  BufferLength,
                                  &ResultLength
                                );
    }

    NtClose(hValueKey);

    if (!NT_SUCCESS(Status)) {
        Status = STATUS_NO_SUCH_FILE;
    }
    else
    {
        //
        // Make sure the types match.
        // If they do, return the new value.
        //

        if ( Type == (( PKEY_VALUE_PARTIAL_INFORMATION )
                                        KeyValueInformation )->Type )
            *Data = KeyValueInformation;
        else
            Status = STATUS_NO_SUCH_FILE;
    }

    return(Status);
}


/*****************************************************************************
 *
 *  IsUserSWPath
 *
 *   Determine if user is accessing registry key user \registry\user\xxx\software
 *
 * ENTRY:
 *  
 *  IN PWCHAR pPath:    Registry path to check
 *  OUT PBOOL pUserReg: If this key is under registry\user
 *
 * NOTES:
 *
 * EXIT:
 *  Returns: pointer to \software key of user registry (or NULL if not 
 *           user software key)
 *  pUserReg:  TRUE if registry path is HKCU (\registry\user)
 *
 ****************************************************************************/
PWCHAR GetUserSWKey(PWCHAR pPath, PBOOL pUserReg, PBOOL bClassesKey) 
{
    PWCHAR pwch = NULL;
    PWCHAR pwchClassesTest = NULL;
    PWCHAR pwClassesKey = NULL;
    ULONG ultemp = 0;

    if (pUserReg)
        *pUserReg = FALSE;

    if (bClassesKey)
        *bClassesKey = FALSE;

    if (!pPath)
        return NULL;

    if (!_wcsnicmp(pPath,                                              
                   TERMSRV_USERREGISTRY,                               
                   sizeof(TERMSRV_USERREGISTRY)/sizeof(WCHAR) - 1))
    {      
        if (pUserReg)
            *pUserReg = TRUE;

        // Skip over first part of path + backslash                   
        pwch = pPath + (sizeof(TERMSRV_USERREGISTRY)/sizeof(WCHAR)); 

        if (pwch)
        {
            //First test for classes
            if (wcschr(pwch, L'\\'))
                pwchClassesTest = wcschr(pwch, L'\\') - sizeof(CLASSES_SUBSTRING)/sizeof(WCHAR) + 1;
            else
                pwchClassesTest = pwch + wcslen(pwch) - sizeof(CLASSES_SUBSTRING)/sizeof(WCHAR) + 1;
            if (pwchClassesTest)
            {
                if (!_wcsnicmp(pwchClassesTest, CLASSES_SUBSTRING, sizeof(CLASSES_SUBSTRING)/sizeof(WCHAR) - 1))
                {
                    ultemp = (sizeof(SOFTWARE_PATH) + sizeof(CLASSES_PATH) + wcslen(pwch) + 1) * sizeof(WCHAR);
                    pwClassesKey = RtlAllocateHeap(RtlProcessHeap(), 0, ultemp);

                    wcscpy(pwClassesKey, SOFTWARE_PATH);
                    wcscat(pwClassesKey, CLASSES_PATH);

                    // Skip over user sid
                    pwch = wcschr(pwch, L'\\');        
                    if (pwch)
                        wcscat(pwClassesKey, pwch);

                    if (ExistsInOmissionList(pwClassesKey))
                        pwch = NULL;
                    else
                    {
                        if (bClassesKey)
                            *bClassesKey = TRUE;
                    }

                    if (pwClassesKey) 
                        RtlFreeHeap(RtlProcessHeap(), 0, pwClassesKey);

                    return (pwch);
                }
            }

            // Skip over user sid
            pwch = wcschr(pwch, L'\\');        
            if (pwch)
            {
                if (_wcsnicmp(pwch, SOFTWARE_PATH, sizeof(SOFTWARE_PATH)/sizeof(WCHAR) - 1))
                    return NULL;                                              

                if (ExistsInOmissionList(pwch))
                    return NULL;
            }
        } 
    }

    return(pwch);
}

/*****************************************************************************
 *
 *  ExistsInOmissionList
 *
 *   Determine whether the registry key exists in the list of registry values
 *      that should not be copied
 *
 * ENTRY:
 *  
 *  IN PWCHAR pPath:    Registry path to check
 *
 *
 * EXIT:
 *  Returns: True if the key matches one of those in the list 
 *
 ****************************************************************************/
BOOL ExistsInOmissionList(PWCHAR pwch)
{
    BOOL bExists = FALSE;
    NTSTATUS Status;             
    HKEY hOmissionKey = NULL;
    PKEY_FULL_INFORMATION pDefKeyInfo = NULL;
    ULONG ultemp = 0;

    // Get the key info
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_ENTRIES, 0, KEY_READ, &hOmissionKey);

    // Get a buffer for the key info
    ultemp = sizeof(KEY_FULL_INFORMATION) + MAX_PATH * sizeof(WCHAR);
    pDefKeyInfo = RtlAllocateHeap(RtlProcessHeap(), 0, ultemp);

    if (pDefKeyInfo) 
    {
        Status = NtQueryKey(hOmissionKey,
                            KeyFullInformation,
                            pDefKeyInfo,
                            ultemp,
                            &ultemp);
    }
    else 
        Status = STATUS_NO_MEMORY;

    if (NT_SUCCESS(Status))
        bExists = ExistsInEnumeratedKeys(hOmissionKey, pDefKeyInfo, pwch);

    if (pDefKeyInfo) 
        RtlFreeHeap(RtlProcessHeap(), 0, pDefKeyInfo);

    return bExists;
}

/*****************************************************************************
 *
 *  ExistsInEnumeratedKeys
 *
 *   Determine whether the registry key exists in the list of registry
 *      values passed in thru the pDefKeyInfo structure
 *
 * ENTRY:
 *  
 *  IN HKEY hOmissionKey: Key containing the values against which to compare pwch
 *  IN PKEY_FULL_INFORMATION pDefKeyInfo: Structure containing information about
 *                                          the list of values against which 
 *                                          to compare pwch
 *
 *  IN PWCHAR pwch: Key to check against the list
 *
 *
 * EXIT:
 *  Returns: True if the key matches one of those in the list 
 *
 ****************************************************************************/
BOOL ExistsInEnumeratedKeys(HKEY hOmissionKey, PKEY_FULL_INFORMATION pDefKeyInfo, PWCHAR pwch)
{
    BOOL bExists = FALSE;
    PKEY_VALUE_BASIC_INFORMATION pKeyValInfo = NULL;
    ULONG ulbufsize = 0;
    ULONG ulkey = 0;
    ULONG ultemp = 0;

    if (!hOmissionKey || !pDefKeyInfo || !pwch)
        return FALSE;

    // Traverse the values for this key
    if (pDefKeyInfo->Values) 
    {
        ulbufsize = sizeof(KEY_VALUE_BASIC_INFORMATION) + 
                    (pDefKeyInfo->MaxValueNameLen + 1) * sizeof(WCHAR) +
                    pDefKeyInfo->MaxValueDataLen; 
    
        pKeyValInfo = RtlAllocateHeap(RtlProcessHeap(), 0, ulbufsize);

        // Get a buffer to hold current value of the key (for existence check)
        if (pKeyValInfo) 
        {
            for (ulkey = 0; ulkey < pDefKeyInfo->Values; ulkey++) 
            {
                NtEnumerateValueKey(hOmissionKey,
                                        ulkey,
                                        KeyValueBasicInformation,
                                        pKeyValInfo,
                                        ulbufsize,
                                        &ultemp);

                if ((pwch + (sizeof(SOFTWARE_PATH)/sizeof(WCHAR))) && (pKeyValInfo->Name))
                {
                    if (!_wcsnicmp(pwch + (sizeof(SOFTWARE_PATH)/sizeof(WCHAR)), pKeyValInfo->Name,
                        (pKeyValInfo->NameLength/sizeof(WCHAR))))
                    {
                        bExists = TRUE;
                    }
                }
            }
        }

        if (pKeyValInfo) 
            RtlFreeHeap(RtlProcessHeap(), 0, pKeyValInfo);
    }

    return bExists;
}


/*****************************************************************************
 *
 *  TermsrvRemoveClassesKey
 *
 *   Delete the classes key for the current user and then set a  
 *   registry flag indicating that this has been done (we only 
 *   want this to be done the first time the user logs in).
 *
 * ENTRY: None
 *  
 *  
 *
 * EXIT: True if the classes key was deleted (even if it was empty
 *          or didn't exist) and false otherwise
 *  
 *
 ****************************************************************************/

BOOL TermsrvRemoveClassesKey(LPTSTR sSid)
{
    BOOL bDeletionPerformed = FALSE;

    HKEY hPerformed;
    HKEY hDeletionFlag;

    ULONG ulFlagPathLen = 0;
    PWCHAR pFlagPath = NULL;

    ULONG ulClassesPathLen = 0;
    PWCHAR pClassesPath = NULL;
            
    if (!sSid)
        return FALSE;

    ulFlagPathLen = (wcslen(sSid) + wcslen(TERMSRV_APP_PATH) + wcslen(CLASSES_DELETED) + 1) * sizeof(WCHAR);
    pFlagPath = RtlAllocateHeap(RtlProcessHeap(), 0, ulFlagPathLen);
    if (pFlagPath)
    {
        wcscpy(pFlagPath, sSid);
        wcscat(pFlagPath, TERMSRV_APP_PATH);
        wcscat(pFlagPath, CLASSES_DELETED);

        //Make sure the operation hasn't already been performed for this user
        if (RegOpenKeyEx(HKEY_USERS, pFlagPath, 0, KEY_READ, &hPerformed) == ERROR_FILE_NOT_FOUND)
        {
            //It hasn't, so delete the software\classes key
            ulClassesPathLen = (wcslen(TERMSRV_APP_PATH) + wcslen(SOFTWARE_PATH) + wcslen(CLASSES_PATH) + 1) * sizeof(WCHAR); 
            pClassesPath = RtlAllocateHeap(RtlProcessHeap(), 0, ulClassesPathLen);
            if (pClassesPath)
            {
                wcscpy(pClassesPath, sSid);
                wcscat(pClassesPath, SOFTWARE_PATH);
                wcscat(pClassesPath, CLASSES_PATH);

                SHDeleteKey(HKEY_USERS, pClassesPath);

                RegCreateKeyEx(HKEY_USERS, pFlagPath, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ, NULL, &hDeletionFlag, NULL);
                RegCloseKey(hDeletionFlag);

                bDeletionPerformed = TRUE;
            }

            if (pClassesPath)
                RtlFreeHeap(RtlProcessHeap(), 0, pClassesPath);
        }
        else
            RegCloseKey(hPerformed);
    }

    if (pFlagPath)
        RtlFreeHeap(RtlProcessHeap(), 0, pFlagPath);

    return bDeletionPerformed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tscert\inc\certvfy.inc ===
#ifndef certvfy_inc
#define certvfy_inc
#include <wintrust.h>

#define WIN_CERT_TYPE_STACK_DLL_SIGNATURE WIN_CERT_TYPE_TS_STACK_SIGNED

typedef struct _DIGEST_PARA {
    HCRYPTHASH      hHash;
} DIGEST_PARA, *PDIGEST_PARA;

/*****************************************************************************
 *
 *  DigestFile
 *
 *   Callback function for ImageGetDigestStream
 *
 * ENTRY:
 *   hDigest (input)
 *     Digest handle - pointer to a DIGEST_PARA structure
 *   pb (input)
 *     Pointer to a buffer of data to hash
 *   cb (input)
 *     Number of bytes in the buffer of data pointed to by pb
 *
 * EXIT:
 *   TRUE - no error
 *   FALSE - use GetLastError() to obtain error information
 *
 ****************************************************************************/
static
BOOL
WINAPI
DigestFile(
    DIGEST_HANDLE hDigest,
    PBYTE pb,
    DWORD cb
    )
{
    PDIGEST_PARA pdp = (PDIGEST_PARA)hDigest;


    if (pb == (PBYTE)-1) {
        return( TRUE );
    } else {
        return( CryptHashData(pdp->hHash, pb, cb, 0) );
    }
}


/*****************************************************************************
 *
 *  OpenImageFile
 *
 *   Return a handle to the opened PE image file
 *
 * ENTRY:
 *   wszFile (input)
 *     Path of file to open
 *   dwAccess (input)
 *     Desired access
 *
 * EXIT:
 *   INVALID_HANDLE_VALUE - File cannot be opened for the desired access
 *
 ****************************************************************************/
static
HANDLE
OpenImageFile(
    LPCWSTR wszFile,
    DWORD dwAccess
    )
{
    HANDLE hFile;
    if (wszFile) {
        hFile = CreateFile(
            wszFile,
            dwAccess,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );
        return hFile;
    } else {
        return INVALID_HANDLE_VALUE;
    }
}

///////////////////////////////////////////////////////////////////////
//
// Verify Code, Data, and Resources of a PE image file
//
///////////////////////////////////////////////////////////////////////
static
BOOL
VerifyFile(
    LPWSTR wszFile,
    PRTL_CRITICAL_SECTION VfyLock
    )
{
    HCRYPTPROV  hProv;
    HCRYPTKEY   hSigPublicKey = 0;
    BOOL        fResult = FALSE;  // preset ERROR case
    HANDLE      hFile;
    DWORD       dwErr = ERROR_SUCCESS;
    DWORD       dwSignatureLen;
    DWORD       dwCert;
    DWORD       cCert;
    DWORD       dwCertIndex;
    DIGEST_PARA dp;
    LPWIN_CERTIFICATE pCertHdr;
    WIN_CERTIFICATE Hdr;

    if ( (hFile = OpenImageFile(
            wszFile,
            GENERIC_READ )) == INVALID_HANDLE_VALUE ) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during OpenImageFile\n", GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
              "Error %x during OpenImageFile\n", GetLastError()) );
#endif
        goto OpenImageFileError;
    }

    RtlEnterCriticalSection( VfyLock );
    if (!CryptAcquireContext(
            &hProv,
            NULL,
            MS_DEF_PROV,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT)) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during CryptAcquireContext\n", GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "Error %x during CryptAcquireContext\n",GetLastError()) );
#endif
        RtlLeaveCriticalSection( VfyLock );
        goto CryptAcquireContextError;
    }
    RtlLeaveCriticalSection( VfyLock );

    memset( &dp, 0, sizeof(dp));
    if (!CryptCreateHash(
            hProv,
            CALG_MD5,
            0,
            0,
            &dp.hHash)) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during CryptCreateHash\n", GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Error %x during CryptCreateHash\n", GetLastError()) );
#endif
        goto CryptCreateHashError;
    }

    if (!ImageGetDigestStream(
            hFile,
            0,
            DigestFile,
            (DIGEST_HANDLE)&dp)) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during ImageGetDigestStream\n", GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
              "Error %x during ImageGetDigestStream\n", GetLastError()) );
#endif
        goto ImageGetDigestStreamError;

    }

    cCert = 0;
    if (!ImageEnumerateCertificates(
            hFile,
            WIN_CERT_TYPE_STACK_DLL_SIGNATURE,
            &cCert,
            &dwCertIndex,
            1               // IndexCount
            )) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during ImageEnumerateCertificates\n",
            GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
              "Error %x during ImageEnumerateCertificates\n",GetLastError()) );
#endif
        goto ImageEnumerateCertificatesError;
    }
    if (cCert == 0) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error there were no Certificates of type %x found\n",
            WIN_CERT_TYPE_STACK_DLL_SIGNATURE) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Error there were no Certificates of type %x found\n",
               WIN_CERT_TYPE_STACK_DLL_SIGNATURE) );
#endif
        goto ImageEnumerateCertificatesError;
    }

    // Determine size of Certificate.
    if(!ImageGetCertificateHeader(
            hFile,
            dwCertIndex,
            &Hdr)) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during ImageGetCertificateHeader!\n",
            GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Error %x during ImageGetCertificateHeader!\n",
               GetLastError()) );
#endif
        goto ImageGetCertificateHeaderError;
    }

    dwCert = Hdr.dwLength;
    dwSignatureLen = dwCert - offsetof( WIN_CERTIFICATE, bCertificate );
#ifdef SIGN_DEBUG
    SIGN_DBGP( ("Signature length = %d\n", dwSignatureLen) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Signature length = %d\n", dwSignatureLen) );
#endif
    if (NULL == (pCertHdr = (LPWIN_CERTIFICATE) MemAlloc(dwCert))) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Out of memory Cert!\n") );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "Out of memory Cert!\n") );
#endif
        goto CertAllocError;
    }

#ifdef SIGN_DEBUG
    SIGN_DBGP( ("Requested Cert size = %d\n", dwCert) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
              "Requested Cert size = %d\n", dwCert) );
#endif
    if (!ImageGetCertificateData(
            hFile,
            dwCertIndex,
            pCertHdr,
            &dwCert)) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during ImageGetCertificate\n", GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Error %x during ImageGetCertificate\n", GetLastError()) );
#endif
        goto ImageGetCertificateError;
    }
#ifdef SIGN_DEBUG
    SIGN_DBGP( ("Returned Cert size = %d\n", dwCert) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Returned Cert size = %d\n", dwCert) );
#endif

    if (!CryptImportKey(
            hProv,
            PublicKeySigBlob,            // from #include "../inc/keyblobs.h"
            sizeof( PublicKeySigBlob ),
            0,
            0,
            &hSigPublicKey)) {
#ifdef SIGN_DEBUG
        SIGN_DBGP( ("Error %x during CryptImportKey!\n", GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Error %x during CryptImportKey!\n", GetLastError()) );
#endif
        goto CryptGetUserKeyError;
    }

#ifdef SIGN_DEBUG
    SIGN_DBGP( ("Signature (from Certificate):\n") );
    {
        unsigned int cnt=0;
        while ( cnt < dwSignatureLen ) {
            int i;
            for ( i=0; (i < 16) && (cnt < dwSignatureLen); cnt++,i++) {
                SIGN_DBGP( ("%02x ", pCertHdr->bCertificate[cnt]) );
            }
            SIGN_DBGP( ("\n") );
        }
    }
#endif
#ifdef SIGN_DEBUG_WINSTA
    TRACE((hTrace,TC_ICASRV,TT_API1, "Signature (from Certificate):\n") );
    {
        unsigned int cnt=0;
        while ( cnt < dwSignatureLen ) {
            int i;
            for ( i=0; (i < 16) && (cnt < dwSignatureLen); cnt++,i++) {
                TRACE((hTrace,TC_ICASRV,TT_API1, "%02x ",
                       pCertHdr->bCertificate[cnt]) );
            }
            TRACE((hTrace,TC_ICASRV,TT_API1, "\n"));
        }
    }
#endif

    // Verify signature.
    if(!CryptVerifySignature(
            dp.hHash,
            &pCertHdr->bCertificate[0],
            dwSignatureLen,
            hSigPublicKey,
            NULL,
            0)) {
        if(GetLastError() == NTE_BAD_SIGNATURE) {
#ifdef SIGN_DEBUG
            SIGN_DBGP( ("Signature did not match!\n") );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,"Signature did not match!\n") );
#endif
        } else {
#ifdef SIGN_DEBUG
            SIGN_DBGP( ("Error %x during CryptVerifySignature!\n",
                GetLastError()) );
#endif
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "Error %x during CryptVerifySignature!\n", GetLastError()) );
#endif
        }
        goto CryptVerifySignatureError;
    }

    fResult = TRUE;

CryptVerifySignatureError:
    CryptDestroyKey(hSigPublicKey);

CryptGetUserKeyError:
ImageGetCertificateError:
    MemFree( pCertHdr );

CertAllocError:
ImageGetCertificateHeaderError:
ImageEnumerateCertificatesError:
ImageGetDigestStreamError:
    CryptDestroyHash( dp.hHash );

CryptCreateHashError:
    dwErr = GetLastError();
    CryptReleaseContext( hProv, 0 );
    SetLastError( dwErr );

CryptAcquireContextError:
    CloseHandle( hFile );

OpenImageFileError:
    return fResult;
}
#endif // certvfy_inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\valinfo.cpp ===
/****************************************************************************/
// valinfo.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include "ValInfo.h"

ValueFullInfo::ValueFullInfo( KeyNode *pKey ) :
    pInfo(NULL), pSzName(NULL), pKeyNode(NULL)

{
    pKeyNode = pKey;

    KeyFullInfo    *pKeyInfo;
    if ( NT_SUCCESS ( status = pKeyNode->GetFullInfo( &pKeyInfo) ) )
    {
        size = sizeof(KEY_VALUE_FULL_INFORMATION) + 
                   (pKeyInfo->Ptr()->MaxValueNameLen + 1)*sizeof(WCHAR) +
                    pKeyInfo->Ptr()->MaxValueDataLen; 
    
        pInfo = ( KEY_VALUE_FULL_INFORMATION *)RtlAllocateHeap(RtlProcessHeap(), 0, size );
    
        if (!pInfo) {
            status = STATUS_NO_MEMORY;
        }
        else
            status = STATUS_SUCCESS;
    }
}

PCWSTR ValueFullInfo::SzName()
{
    if (!pSzName)
    {
        ULONG size =  pInfo->NameLength + sizeof(WCHAR);
        pSzName = (PWSTR) RtlAllocateHeap(RtlProcessHeap(), 0, size );

        if (!pSzName) 
        {
            status = STATUS_NO_MEMORY;
        }
        else
        {
            wcsncpy( pSzName, pInfo->Name, pInfo->NameLength/sizeof(WCHAR) );
            pSzName[ pInfo->NameLength/sizeof( WCHAR)  ] = L'\0';
            status = STATUS_SUCCESS;
        }
    }

    return pSzName;

}

BOOLEAN ValueFullInfo::Compare( ValueFullInfo *pOther )
{
    status = STATUS_SUCCESS; // we don't expect errors in here
    if ( pOther->Ptr()->Type != Ptr()->Type)
    {
        return FALSE;
    }

    if ( pOther->Ptr()->DataLength != Ptr()->DataLength)
    {
        return FALSE;
    }

    if ( pOther->Ptr()->NameLength != Ptr()->NameLength)
    {
        return FALSE;
    }


    for (ULONG i = 0; i < Ptr()->NameLength / sizeof( WCHAR) ; i++)
    {
        if ( Ptr()->Name[i] != pOther->Ptr()->Name[i])
        {
            return FALSE;
        }

    }

    for (i = 0; i < Ptr()->DataLength; i++)
    {
        if ( ((PCHAR)( (PCHAR)Ptr() + Ptr()->DataOffset ))[i] != 
             ((PCHAR) ( (PCHAR)(pOther->Ptr()) + 
                        pOther->Ptr()->DataOffset) )[i] )
            return FALSE;
    }

    return TRUE;
}

ValueFullInfo::~ValueFullInfo()
{
    if (pInfo)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pInfo);
    }

    if ( pSzName )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pSzName );
    }
}


NTSTATUS ValueFullInfo::Query(PCWSTR  pValueName )
{
    ULONG   resultSize;
    ULONG   numberOfAttempts=0;

    if ( NT_SUCCESS( pKeyNode->Status() ) )
    {
        UNICODE_STRING  tmpName;
        RtlInitUnicodeString( &tmpName, pValueName);

        status = NtQueryValueKey( pKeyNode->Key() ,
                                 &tmpName,
                                 Type(),
                                 Ptr(),
                                 Size(),
                                 &resultSize);                 

        if ( (status == STATUS_BUFFER_OVERFLOW ) || 
            ( status == STATUS_BUFFER_TOO_SMALL ) )
        {
            // @@@ this can never happen right? 
            // Since the key param imposes a max size on any valule 
            // under the key.
        }

    }
    else
        status = STATUS_OBJECT_NAME_NOT_FOUND; // need to call open or key is not found

    return status;

}

NTSTATUS ValueFullInfo::Delete(PCWSTR  pValueName )
{
    UNICODE_STRING  tmpName;
    RtlInitUnicodeString( &tmpName, pValueName);

    if (NT_SUCCESS( status = pKeyNode->Status() ) )
    {
        status = NtDeleteValueKey( pKeyNode->Key(), &tmpName );
    }

    return status;
}

NTSTATUS ValueFullInfo::Create( ValueFullInfo   *pNew )
{
    UNICODE_STRING  uniString;

    uniString.Buffer = pNew->Ptr()->Name;
    uniString.Length = (USHORT)pNew->Ptr()->NameLength;
    uniString.MaximumLength = uniString.Length + 2;

    if (NT_SUCCESS( status = pKeyNode->Status() ) )
    {
        status = NtSetValueKey( pKeyNode->Key(),
            &uniString,
            0,
            pNew->Ptr()->Type,
            (PCHAR)pNew->Ptr()+ 
            pNew->Ptr()->DataOffset,
            pNew->Ptr()->DataLength);
    }

    return status;


}

void ValueFullInfo::Print( FILE *fp )
{
    fwprintf( fp, L"name=%ws, size= %d, type=%d \n",
              SzName(), Size(), Type() );

     fwprintf( fp, L"DataOffset=%d, DataLength=%d, NameLength=%d \n",
               Ptr()->DataOffset, Ptr()->DataLength, Ptr()->NameLength );

     for ( ULONG i =0; i < Ptr()->NameLength + Ptr()->DataLength; i++)
     {
         if ( !(i % 32) )
         {
             fwprintf(fp,L"\n");
             fwprintf(fp,L"i=%3d ,",i);
         }
         fwprintf( fp, L"%2x ", ((BYTE *)(Ptr()->Name))[i] );
     }
     fwprintf(fp,L"\n");
     fflush( fp );
}

ValuePartialInfo::ValuePartialInfo( KeyNode *pKey , ULONG defaultSize ):
    pInfo(NULL), pKeyNode(NULL)
{
    pKeyNode = pKey;

    if (defaultSize)
    {
        size = defaultSize;
    } 
    else
    {
        size = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(ULONG);
        pInfo = ( KEY_VALUE_PARTIAL_INFORMATION *)RtlAllocateHeap(
            RtlProcessHeap(), 0, size );
    }

    if (!pInfo) {
        status = STATUS_NO_MEMORY;
        pInfo=NULL;
    }
    else
        status = STATUS_SUCCESS;

}

ValuePartialInfo::~ValuePartialInfo()
{
    if (pInfo)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, pInfo);
    }

}


NTSTATUS ValuePartialInfo::Query( PCWSTR  pValueName )
{
    ULONG   resultSize;
    ULONG   numberOfAttempts=0;

    UNICODE_STRING  tmpName;
    RtlInitUnicodeString( &tmpName, pValueName);

tryAgain:
    status = NtQueryValueKey(pKeyNode->Key(),
                                 &tmpName,
                                 Type(),
                                 Ptr(),
                                 Size(),
                                 &resultSize);                 

    if ( (status == STATUS_BUFFER_OVERFLOW ) || 
        ( status == STATUS_BUFFER_TOO_SMALL ) )
    {

        RtlFreeHeap( RtlProcessHeap(), 0, pInfo);

        size = resultSize;
        pInfo = ( KEY_VALUE_PARTIAL_INFORMATION *)RtlAllocateHeap(
            RtlProcessHeap(), 0, size );

        numberOfAttempts++;
        if ( numberOfAttempts < 10 )
        {
            goto tryAgain;
        }
        // else, we bail out, don't want to hang here, let the caller worry about this.
    }

    return status;
}

NTSTATUS ValuePartialInfo::Delete(PCWSTR  pValueName )
{
    UNICODE_STRING  tmpName;
    RtlInitUnicodeString( &tmpName, pValueName);

    status = NtDeleteValueKey( pKeyNode->Key(), &tmpName );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\tsappcmp.c ===
/*************** ************************************************************/
// tsappcmp.c
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern void InitRegisterSupport();

PWINSTATIONQUERYINFORMATIONW pWinStationQueryInformationW;

extern DWORD gpTermsrvTlsIndex;

BOOL GetDefaultUserProfileName(LPWSTR lpProfileDir, LPDWORD lpcchSize);
extern WCHAR gpwszDefaultUserName[];

extern void FreeLDRTable();

DWORD    g_dwFlags=0;


/*
 * Read flags, if flags don't exit, then assume default behavior.
 * The default behavior is the same as dwFlags = 0x0
 * The default behavior will result is the loadlib func calls to be patched by our
 * redirected func TLoadLibraryExW().
 *
 */
void ReadImportTablePatchFLagsAndAppCompatMode( DWORD *pdwFlags, BOOLEAN  *pInAppCompatMode  )
{
    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    UCHAR Buffer[100];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
    ULONG KeyValueLength = 100;
    ULONG ResultLength;

    *pdwFlags=0;
    *pInAppCompatMode=FALSE;

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Terminal Server"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        return;     // so nothing found, just return since we do have a default behavior.
    }

    RtlInitUnicodeString(
    &KeyName,
    REG_TERMSRV_APPCOMPAT 
    );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );
    
    
    if (NT_SUCCESS(NtStatus)) 
    {
    
        //
        // Check that the data is the correct size and type - a DWORD.
        //
    
        if ((KeyValueInformation->DataLength >= sizeof(DWORD)) &&
            (KeyValueInformation->Type == REG_DWORD)) 
            {
                *pInAppCompatMode = * (PBOOLEAN) KeyValueInformation->Data;
            }
    }

    RtlInitUnicodeString(
        &KeyName,
        TERMSRV_COMPAT_IAT_FLAGS 
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );


    if (NT_SUCCESS(NtStatus)) 
    {

        //
        // Check that the data is the correct size and type - a DWORD.
        //

        if ((KeyValueInformation->DataLength >= sizeof(DWORD)) &&
            (KeyValueInformation->Type == REG_DWORD)) 
            {
                *pdwFlags = * (PDWORD) KeyValueInformation->Data;
            }
    }

    NtClose(KeyHandle);

}

BOOL WINAPI LibMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{

    static ULONG    attachCount=0;
    static BOOLEAN  inAppCompatMode=FALSE;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            PWCHAR  pwch, pwchext;
            WCHAR   pwcAppName[MAX_PATH+1];
            PRTL_USER_PROCESS_PARAMETERS pUserParam;
            DWORD dwSize;

            attachCount++;

            ReadImportTablePatchFLagsAndAppCompatMode( &g_dwFlags , &inAppCompatMode );    // this will initialize our global flag for IAT and debug

            if ( g_dwFlags &  DEBUG_IAT )
            {
                DbgPrint("tsappcmp: LibMain: DLL_PROCESS_ATTACH called, attach count = %d  \n", attachCount );
            }

            if ( inAppCompatMode )
            {
                // Get the path of the executable name
                pUserParam = NtCurrentPeb()->ProcessParameters;
    
                // Get the executable name, if there's no \ just use the name as it is
                pwch = wcsrchr(pUserParam->ImagePathName.Buffer, L'\\');
                if (pwch) {
                    pwch++;
                } else {
                    pwch = pUserParam->ImagePathName.Buffer;
                }
                wcscpy(pwcAppName, pwch);
                pwch = pwcAppName;
    
    
                #if DBGX
                DbgPrint("\nApp-name : %ws\n", pwch );
                #endif
    
    
                // Check if it's a DOS or Win16 app by checking if the app is ntvdm.exe
                // Only disable ThreadLibrary calls if not ntvdm.
                if (_wcsicmp(pwch, L"ntvdm.exe")) {
    
                    DisableThreadLibraryCalls (hInstance);
                } else {
                    gpTermsrvTlsIndex = TlsAlloc();
                    ASSERT(gpTermsrvTlsIndex != 0xFFFFFFFF);
                }
    
                // Init support for the register command
                InitRegisterSupport();
    
                dwSize = MAX_PATH;
                if (!GetDefaultUserProfileName(gpwszDefaultUserName, &dwSize)) {
                    gpwszDefaultUserName[0] = L'\0';
                }
            }

            break;
        }

        case DLL_THREAD_ATTACH:
        {
            if (inAppCompatMode )
            {
                TlsSetValue(gpTermsrvTlsIndex,NULL);
            }
        }

        case DLL_PROCESS_DETACH:
        {
            attachCount--;

            if ( g_dwFlags &  DEBUG_IAT )
            {
                DbgPrint("tsappcmp: LibMain: DLL_PROCESS_DETACH called, attach count = %d  \n", attachCount );
            }

            if (inAppCompatMode )
            {
    
                if (attachCount==0 )
                {
                    FreeLDRTable();
                }
            }
        }

        break;

    }

    return TRUE;
}

PWCHAR TermsrvFormatObjectName(LPCWSTR OldName)
{

PWCHAR pstrNewObjName = NULL;

#if 0
SIZE_T Size;

    Size = ( wcslen(OldName) * sizeof(WCHAR)) + sizeof(L"Local\\") + sizeof(WCHAR);

    pstrNewObjName = RtlAllocateHeap(RtlProcessHeap(),
                                     LMEM_FIXED | LMEM_ZEROINIT,
                                     Size);


    if (pstrNewObjName) {

        swprintf(pstrNewObjName,L"Local\\%ws",OldName);

    }
#endif

    return pstrNewObjName;

}

DWORD TermsrvGetComputerName( LPWSTR lpBuffer, LPDWORD nSize )
{
    ULONG   ulCompatFlags=0, ulAppType = 0;
    WINSTATIONINFORMATIONW WSInfo;

    ULONG ValueLength;
    HMODULE hwinsta = NULL;


    GetCtxAppCompatFlags(&ulCompatFlags, &ulAppType);

    // Return the username instead of the computername?
    if ((ulCompatFlags & TERMSRV_COMPAT_USERNAME) &&
        (ulCompatFlags & ulAppType)) {

        if ( !pWinStationQueryInformationW ) {
            /*
             *  Get handle to winsta.dll
             */
            if ( (hwinsta = LoadLibraryA( "WINSTA" )) != NULL ) {

                pWinStationQueryInformationW   = (PWINSTATIONQUERYINFORMATIONW)
                    GetProcAddress( hwinsta, "WinStationQueryInformationW" );
            }
        }

        // Fetch the WinStation's basic information
        if ( pWinStationQueryInformationW ) {
            if ( (*pWinStationQueryInformationW)(SERVERNAME_CURRENT,
                                                 LOGONID_CURRENT,
                                                 WinStationInformation,
                                                 &WSInfo,
                                                 sizeof(WSInfo),
                                                 &ValueLength ) ) {

                // Check if username will fit in buffer
                if (wcslen(WSInfo.UserName) >= *nSize) {
                    return ERROR_BUFFER_OVERFLOW;
                } else {
                    wcscpy(lpBuffer, WSInfo.UserName);
                    return ERROR_SUCCESS;
                }
            }
        }
    }
    return ERROR_RETRY;



}


void TermsrvAdjustPhyMemLimits (
                 IN OUT LPDWORD TotalPhys,
                 IN OUT LPDWORD AvailPhys,
                 IN DWORD SysPageSize
                    )
{
ULONG ulAppType = 0;
DWORD PhysicalMemory;

    if ( GetCtxPhysMemoryLimits(&ulAppType, &PhysicalMemory) ) {

        if (*TotalPhys > PhysicalMemory ) {

            *TotalPhys = PhysicalMemory;
        }
    }

    if ( *AvailPhys > *TotalPhys ) {
        //  Reset the Available Physical Memory to be smaller than the
        //  Total Physical Memory.  It is made smaller to avoid
        //  possible divide by zero errors when Available and Total are
        //  equal
        *AvailPhys = *TotalPhys - SysPageSize;
    }
 return;
}


UINT
APIENTRY
TermsrvGetWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    )

{
ANSI_STRING AnsiString;
NTSTATUS Status;
ULONG cbAnsiString;
UNICODE_STRING Path;


    //
    // If in install mode return the system windows dir
    //
    if (TermsrvAppInstallMode()) {

        return 0;

    }

    if (!TermsrvPerUserWinDirMapping()) {

        return 0;
    }

    // if buffer looks real, then init it to zero 
    if ( lpBuffer ) {

        *lpBuffer = '\0'; // in case we have an error, the shell folks want this to be null
                           // BUG 453487
    }


    Path.Length = 0;
    Path.MaximumLength = (USHORT)(uSize * sizeof( WCHAR ));
    if ( Path.Buffer = LocalAlloc( LPTR, Path.MaximumLength ) ) {

        Status = GetPerUserWindowsDirectory( &Path );

        if ( NT_SUCCESS(Status) ) {
            AnsiString.MaximumLength = (USHORT)(uSize);
            AnsiString.Buffer = lpBuffer;

            Status = RtlUnicodeStringToAnsiString(
                        &AnsiString,
                        &Path,
                        FALSE
                        );

        } else if ( (Status == STATUS_BUFFER_TOO_SMALL) || (Status == STATUS_BUFFER_OVERFLOW ) ) {

           DbgPrint( "KERNEL32: GetWindowsDirectoryA: User buffer too small (%u) need(%u)\n",
                     uSize, Path.Length >> 1 );

           return( Path.Length >> 1 );

        }

        LocalFree( Path.Buffer );

    } else {

       Status = STATUS_NO_MEMORY;
        DbgPrint( "KERNEL32: GetWindowsDirectoryA: No memory\n" );

    }

    if ( Status == STATUS_BUFFER_TOO_SMALL ) {

       DbgPrint( "KERNEL32: GetWindowsDirectoryA: User buffer too small (%u) need(%u)\n",
                 uSize, Path.Length >> 1 );

       return( Path.Length >> 1 );

    } else if ( !NT_SUCCESS(Status) ) {

        return 0;

    }
    return AnsiString.Length;

}


UINT
APIENTRY
TermsrvGetWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    )
{

    UNICODE_STRING Path;
    NTSTATUS Status;



    //
    // If in install mode return the system windows dir
    //
    if (TermsrvAppInstallMode()) {

        return 0;

    }

    if (!TermsrvPerUserWinDirMapping()) {

        return 0;
    }


    // if buffer looks real, then init it to zero 
    if ( lpBuffer ) {

        *lpBuffer = '\0'; // in case we have an error, the shell folks want this to be null
                           // BUG 453487
    }

    /*
     * If it fails, return 0
     * If buffer too small, return len (not includding NULL)
     * If buffer ok, return len (not inc. NULL) and fill buffer
     * (GetPerUserWindowsDirectory will do all of this for us!)
     */
    Path.Length        = 0;
    Path.MaximumLength = (USHORT)(uSize * sizeof( WCHAR ));
    Path.Buffer        = lpBuffer;


    Status = GetPerUserWindowsDirectory( &Path );

    if ( Status == STATUS_SUCCESS ) {
       /*
        * Add a NULL to the end (if it fits!)
        */
       if ( Path.Length + sizeof( WCHAR ) <= Path.MaximumLength ) {
          lpBuffer[(Path.Length>>1)] = UNICODE_NULL;
       }
    }

    return( Path.Length / sizeof(WCHAR) );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\valinfo.h ===
/****************************************************************************/
// valinfo.cpp
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#ifndef _TS_APP_SMP_VAL_INFO_
#define _TS_APP_SMP_VAL_INFO_

#include <stdio.h>

#include "KeyNode.h"


class   ValueFullInfo
{
public:
    ValueFullInfo(  KeyNode *pKey );  

    ~ValueFullInfo();

    ULONG                           Size()      { return size ; }
    KEY_VALUE_FULL_INFORMATION      *Ptr()  { return pInfo; }
    KEY_VALUE_INFORMATION_CLASS     Type()  { return KeyValueFullInformation; }
    NTSTATUS                        Status() { return status; }

    PCWSTR                          SzName();

    NTSTATUS                        Query(  PCWSTR  pValueName );
    NTSTATUS                        Delete( PCWSTR  pValueName );
    NTSTATUS                        Create( ValueFullInfo   *pNew );


    BOOLEAN                         Compare( ValueFullInfo *pOther ); // compare self to other, 
                                    // TRUE mean the two values are the same.

    void                            Print( FILE *fp); // for debug dump
private:
    ULONG                           size;
    KEY_VALUE_FULL_INFORMATION      *pInfo;
    ULONG                           status;
    PWSTR                           pSzName;
    KeyNode                         *pKeyNode;
};


class   ValuePartialInfo
{
public:
    ValuePartialInfo(  KeyNode *pKey , ULONG   defaultSize=0);  

    ~ValuePartialInfo();

    ULONG                           Size()      { return size ; }
    KEY_VALUE_PARTIAL_INFORMATION   *Ptr()  { return pInfo; }
    KEY_VALUE_INFORMATION_CLASS     Type()  { return KeyValuePartialInformation; }
    NTSTATUS                        Status() { return status; }

    NTSTATUS                        Query(  PCWSTR  pValueName );
    NTSTATUS                        Delete( PCWSTR  pValueName );

private:
    ULONG                           size;
    KEY_VALUE_PARTIAL_INFORMATION   *pInfo;
    ULONG                           status;
    KeyNode                         *pKeyNode;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\regmap.h ===
/*************************************************************************
*
* regmap.h
*
* Function declarations for Citrix registry merging/mapping
*
* copyright notice: Copyright 1996, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
*
* Author:  Bill Madden 
*
* $Log:   N:\NT\PRIVATE\WINDOWS\SCREG\WINREG\SERVER\CITRIX\VCS\REGMAP.H  $
*  
*     Rev 1.2   06 May 1996 11:51:42   terryt
*  FaxWorks Btrieve force good install values
*  
*     Rev 1.1   29 Mar 1996 15:42:00   Charlene
*  multiuser file associations via CLASSES key
*  
*     Rev 1.0   24 Jan 1996 10:53:32   billm
*  Initial revision.
*  
*************************************************************************/


#include <winsta.h>
#include <syslib.h>

#define IS_NEWLINE_CHAR( c )  ((c == 0x0D) || (c == 0x0A))
#define SOFTWARE_PATH L"\\Software"
#define CLASSES_PATH L"\\Classes"
#define CLASSES_SUBSTRING L"_Classes"
#define CLASSES_DELETED L"\\ClassesRemoved"
#define REGISTRY_ENTRIES L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Compatibility\\Registry Entries"
#define TERMSRV_APP_PATH L"\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"

BOOL TermsrvCreateRegEntry(IN HANDLE hKey,
                       IN POBJECT_ATTRIBUTES pObjAttr,
                       IN ULONG TitleIndex,
                       IN PUNICODE_STRING pUniClass OPTIONAL,
                       IN ULONG ulCreateOpt);

BOOL TermsrvOpenRegEntry(OUT PHANDLE pUserhKey,
                     IN ACCESS_MASK DesiredAccess,
                     IN POBJECT_ATTRIBUTES pUserObjectAttr);

BOOL TermsrvSetValueKey(HANDLE hKey,
                    PUNICODE_STRING ValueName,
                    ULONG TitleIndex,
                    ULONG Type,
                    PVOID Data,
                    ULONG DataSize);

BOOL TermsrvDeleteKey(HANDLE hKey);

BOOL TermsrvDeleteValue(HANDLE hKey,
                    PUNICODE_STRING pUniValue);

BOOL TermsrvRestoreKey(IN HANDLE hKey,
                   IN HANDLE hFile,
                   IN ULONG Flags);

BOOL TermsrvSetKeySecurity(IN HANDLE hKey,  
                       IN SECURITY_INFORMATION SecInfo,
                       IN PSECURITY_DESCRIPTOR pSecDesc);

BOOL TermsrvOpenUserClasses(IN ACCESS_MASK DesiredAccess, 
                        OUT PHANDLE pUserhKey) ;

NTSTATUS TermsrvGetPreSetValue(  IN HANDLE hKey,
                             IN PUNICODE_STRING pValueName,
                             IN ULONG  Type,
                            OUT PVOID *Data
                           );

BOOL TermsrvRemoveClassesKey();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tscert\inc\privblob.h ===
unsigned char PrivateKeySigBlob[] = {
// This data is generated by obj\i386\certinit.
// Key Blob - 596 bytes
0x07, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 
0x52, 0x53, 0x41, 0x32, 0x00, 0x04, 0x00, 0x00, 
0x01, 0x00, 0x01, 0x00, 0xb1, 0xb6, 0x1b, 0x6c, 
0x05, 0xa5, 0x4e, 0xd4, 0xab, 0x64, 0xdb, 0x96, 
0x56, 0x2c, 0x96, 0xfa, 0xcf, 0x15, 0x6d, 0x73, 
0x6e, 0xbb, 0x14, 0xc6, 0xe8, 0xed, 0xd8, 0x4b, 
0xb9, 0x50, 0x66, 0x30, 0x21, 0xb0, 0x00, 0x6d, 
0x4f, 0x56, 0xe6, 0xd0, 0x99, 0x28, 0xd1, 0xf0, 
0x4a, 0xde, 0x82, 0x76, 0x25, 0xd2, 0x4c, 0xff, 
0x4e, 0x07, 0x45, 0x0c, 0x09, 0x3c, 0xd4, 0x7d, 
0x79, 0x1b, 0xab, 0x94, 0x60, 0xdc, 0x5a, 0x0b, 
0xaa, 0x1b, 0xc3, 0xc1, 0x87, 0x93, 0xda, 0xbc, 
0xb1, 0xee, 0xd0, 0x66, 0x8c, 0x94, 0x2c, 0x26, 
0x1a, 0xfa, 0x0c, 0x41, 0x20, 0x59, 0x2e, 0xda, 
0x8f, 0xa2, 0x79, 0x66, 0x0f, 0xe7, 0x10, 0xc0, 
0x89, 0x61, 0xe5, 0x56, 0x94, 0xc4, 0xb9, 0x35, 
0x61, 0x2d, 0xf9, 0x2f, 0x58, 0xb2, 0xe3, 0x09, 
0x52, 0x25, 0x20, 0x1f, 0x03, 0xcd, 0xab, 0xee, 
0xe5, 0x1b, 0xa9, 0xdb, 0x03, 0x93, 0xdb, 0x2f, 
0xc3, 0x15, 0xd1, 0xe7, 0x2e, 0xa0, 0xce, 0xb0, 
0x9b, 0x4d, 0x9f, 0x17, 0xd4, 0xe4, 0x9e, 0xfc, 
0xb0, 0x72, 0x5b, 0x78, 0x58, 0xbd, 0xef, 0x73, 
0x3c, 0xbe, 0x52, 0x09, 0xfd, 0x62, 0x08, 0x2e, 
0x7e, 0x50, 0x80, 0x6b, 0x00, 0x20, 0xbb, 0xfd, 
0xfd, 0x3b, 0x38, 0xde, 0x92, 0x5d, 0x0e, 0xf9, 
0xe4, 0xa5, 0xc6, 0x84, 0x07, 0xd8, 0xa4, 0x7a, 
0xa9, 0xf8, 0x59, 0xed, 0x3b, 0x47, 0xe9, 0x3b, 
0x03, 0x34, 0xa8, 0x54, 0xa3, 0x1c, 0x0c, 0xae, 
0x93, 0x1b, 0x1b, 0xa9, 0x27, 0xca, 0x12, 0x88, 
0xb0, 0x0c, 0xe4, 0x40, 0xbe, 0xb1, 0x4e, 0xa7, 
0x39, 0x2c, 0x62, 0x5a, 0xc7, 0x53, 0xcf, 0xb4, 
0x49, 0x20, 0x0b, 0xc5, 0x76, 0x61, 0x69, 0xa5, 
0x85, 0x17, 0xe0, 0x2b, 0x50, 0x9e, 0x57, 0xc1, 
0x5a, 0xc8, 0x6a, 0x31, 0x09, 0xd0, 0x8e, 0x2e, 
0xd0, 0x4e, 0xeb, 0xec, 0xc9, 0xda, 0x91, 0x03, 
0xf5, 0x6b, 0x64, 0x0d, 0xbc, 0x98, 0x64, 0xdc, 
0x68, 0xe7, 0x7d, 0x8c, 0x6e, 0x67, 0xcc, 0x69, 
0x9c, 0x69, 0xc0, 0x3f, 0xaa, 0xb8, 0xa9, 0x12, 
0xdc, 0x39, 0x55, 0x31, 0x83, 0xd6, 0x07, 0xf2, 
0x25, 0x9b, 0x44, 0xf4, 0xfd, 0xa2, 0xfa, 0xad, 
0xbf, 0x52, 0x1b, 0x90, 0x01, 0x8b, 0xb5, 0xd4, 
0x3d, 0x2a, 0xff, 0x60, 0x77, 0x9f, 0x56, 0xb3, 
0x36, 0xd8, 0x5a, 0x33, 0x0d, 0x3f, 0xfe, 0x92, 
0x05, 0x1d, 0x57, 0x21, 0x72, 0x65, 0x00, 0x96, 
0xc8, 0x10, 0x1c, 0xea, 0x51, 0xaf, 0xeb, 0x6a, 
0xcd, 0xc7, 0xa1, 0x5d, 0x65, 0x2d, 0x92, 0xb7, 
0x0d, 0x44, 0x50, 0x17, 0xe6, 0x93, 0xf9, 0x3e, 
0x44, 0x39, 0xcd, 0x30, 0x59, 0xb2, 0xae, 0xfd, 
0x1e, 0x9b, 0x5b, 0x64, 0x6c, 0xc7, 0xa4, 0x30, 
0x54, 0x01, 0x0f, 0x7f, 0x9d, 0xd4, 0x76, 0xc5, 
0x0d, 0xe7, 0x62, 0x99, 0x31, 0x45, 0x2c, 0x2d, 
0xf1, 0xf1, 0xf6, 0x36, 0x47, 0x32, 0x02, 0x9c, 
0xb4, 0xec, 0x6a, 0x37, 0x56, 0xee, 0x92, 0x43, 
0x3b, 0x6c, 0x51, 0xb8, 0x18, 0x09, 0x56, 0x1a, 
0x1a, 0x7c, 0xec, 0x76, 0x41, 0x44, 0xef, 0x2e, 
0x9b, 0x56, 0xcb, 0x97, 0x52, 0x29, 0x64, 0x3e, 
0x03, 0x59, 0x98, 0xe4, 0xcd, 0x4a, 0xf8, 0xd3, 
0x80, 0xb4, 0xd2, 0x4e, 0x7e, 0x58, 0x11, 0xe2, 
0x71, 0x92, 0x80, 0x45, 0xc5, 0xb2, 0xcd, 0x65, 
0xff, 0x96, 0xe9, 0xc8, 0x84, 0x58, 0x49, 0x20, 
0x26, 0x2d, 0x8e, 0x4e, 0x74, 0xd5, 0x60, 0xa5, 
0x0a, 0x7c, 0xe0, 0x3a, 0xe0, 0x1f, 0x86, 0xea, 
0xb0, 0x93, 0x5e, 0x38, 0xfb, 0xc9, 0x9d, 0xc9, 
0x13, 0xfb, 0x4e, 0x91, 0x16, 0x0a, 0x2a, 0x2a, 
0xe5, 0xb9, 0x76, 0x54, 0x9a, 0xe8, 0x35, 0x0d, 
0x32, 0x5e, 0x53, 0x5d, 0x29, 0x9b, 0x4d, 0xa5, 
0xae, 0xe5, 0xae, 0xb6, 0x67, 0xb7, 0xb2, 0xc6, 
0x6b, 0xb2, 0x37, 0x39, 0x8b, 0xd1, 0x0c, 0x6a, 
0xf3, 0x7d, 0xc6, 0xbf, 0xc1, 0x9d, 0x46, 0x96, 
0x7f, 0xa0, 0x7a, 0xc0, 0xa9, 0x36, 0x63, 0x06, 
0x9d, 0x5a, 0x21, 0x8a, 0xa3, 0x3a, 0xef, 0x44, 
0x23, 0xb2, 0xb6, 0x06, 0xcb, 0xda, 0xd1, 0x71, 
0xaf, 0x9f, 0xf9, 0x60, 0x69, 0x35, 0xc1, 0xe9, 
0xcc, 0x3f, 0x59, 0x45, 0x89, 0xa8, 0xea, 0xd2, 
0x54, 0x30, 0xaf, 0x7e, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsappcmp\register.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    register.c

Abstract:

    Terminal server register command support functions

Author:


Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

//
// Terminal Server 4.0 has a feature that allows DLL's to be registered SYSTEM
// global. This means all named objects are in the system name space. Such
// a DLL is identified by a bit set in LoaderFlags in the image header.
//
// This module supports this feature by redirecting WIN32 named object API's
// for DLL's with this bit set to a set of functions inside of
// tsappcmp.dll. These stub functions will process the object name and
// call the real kernel32.dll WIN32 functions.
//
// The redirection is accomplished by updating the Import Address Table (IAT)
// after the loader has snapped its thunks. This results in no modification
// of the underlying program or DLL, just updating of the run time system
// linkage table for this process.
//
// ***This only occurs on Terminal Server, and for applications or DLL's
// with this bit set***
//


// \nt\public\sdk\inc\ntimage.h
// GlobalFlags in image, currently not used
#define IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL    0x01000000

#define GLOBALPATHA     "Global\\"
#define GLOBALPATHW     L"Global\\"
#define GLOBALPATHSIZE  7 * sizeof( WCHAR );


extern DWORD   g_dwFlags;              
                               
enum { 
    Index_Func_CreateEventA = 0,
    Index_Func_CreateEventW,                    
    Index_Func_OpenEventA,                      
    Index_Func_OpenEventW,                      
    Index_Func_CreateSemaphoreA,                
    Index_Func_CreateSemaphoreW,                
    Index_Func_OpenSemaphoreA,                  
    Index_Func_OpenSemaphoreW,                  
    Index_Func_CreateMutexA,                    
    Index_Func_CreateMutexW,                    
    Index_Func_OpenMutexA,                      
    Index_Func_OpenMutexW,                      
    Index_Func_CreateFileMappingA,              
    Index_Func_CreateFileMappingW,              
    Index_Func_OpenFileMappingA,                
    Index_Func_OpenFileMappingW
};

enum {
    Index_Func_LoadLibraryA = 0,
    Index_Func_LoadLibraryW    ,
    Index_Func_LoadLibraryExA  ,
    Index_Func_LoadLibraryExW 
};

typedef struct _LDR_TABLE {
    struct _LDR_TABLE       *pNext;
    PLDR_DATA_TABLE_ENTRY   pItem;
} LDR_TABLE;

LDR_TABLE   g_LDR_TABLE_LIST_HEAD;

typedef HANDLE ( APIENTRY Func_CreateEventA )( LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName );

HANDLE
APIENTRY
TCreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    );

typedef HANDLE ( APIENTRY Func_CreateEventW) ( LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName );

HANDLE
APIENTRY
TCreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );

typedef HANDLE ( APIENTRY Func_OpenEventA) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName );

HANDLE
APIENTRY
TOpenEventA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );

typedef  HANDLE ( APIENTRY Func_OpenEventW ) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName );

HANDLE
APIENTRY
TOpenEventW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

typedef HANDLE ( APIENTRY Func_CreateSemaphoreA) ( LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName );

HANDLE
APIENTRY
TCreateSemaphoreA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName
    );

typedef HANDLE ( APIENTRY Func_CreateSemaphoreW) ( LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName ) ;

HANDLE
APIENTRY
TCreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    ) ;

typedef HANDLE ( APIENTRY Func_OpenSemaphoreA) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName );

HANDLE
APIENTRY
TOpenSemaphoreA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );

typedef HANDLE ( APIENTRY Func_OpenSemaphoreW ) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName );

HANDLE
APIENTRY
TOpenSemaphoreW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

typedef HANDLE ( APIENTRY Func_CreateMutexA ) ( LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName );

HANDLE
APIENTRY
TCreateMutexA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCSTR lpName
    );


typedef HANDLE ( APIENTRY Func_CreateMutexW) ( LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName );

HANDLE
APIENTRY
TCreateMutexW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    );


typedef HANDLE ( APIENTRY Func_OpenMutexA ) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName );

HANDLE
APIENTRY
TOpenMutexA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );

typedef HANDLE ( APIENTRY Func_OpenMutexW) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName );

HANDLE
APIENTRY
TOpenMutexW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

typedef HANDLE ( APIENTRY Func_CreateFileMappingA) ( HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName );

HANDLE
APIENTRY
TCreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );


typedef HANDLE ( APIENTRY Func_CreateFileMappingW ) ( HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName );

HANDLE
APIENTRY
TCreateFileMappingW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );

typedef HANDLE ( APIENTRY Func_OpenFileMappingA ) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName ) ;

HANDLE
APIENTRY
TOpenFileMappingA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    ) ;

typedef HANDLE ( APIENTRY Func_OpenFileMappingW ) ( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName );

HANDLE
APIENTRY
TOpenFileMappingW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    ) ;

typedef HMODULE ( WINAPI Func_LoadLibraryExA )(LPCSTR , HANDLE , DWORD  );

HMODULE 
TLoadLibraryExA(
	LPCSTR lpLibFileName,
	HANDLE hFile,
	DWORD dwFlags
);


typedef HMODULE ( WINAPI Func_LoadLibraryExW )( LPCWSTR , HANDLE , DWORD  );

HMODULE 
TLoadLibraryExW(
	LPCWSTR lpwLibFileName,
	HANDLE hFile,
	DWORD dwFlags
);

typedef HMODULE ( WINAPI Func_LoadLibraryA )( LPCSTR );

HMODULE
TLoadLibraryA(
    LPCSTR lpLibFileName
    );

typedef HMODULE ( WINAPI Func_LoadLibraryW )( LPCWSTR );

HMODULE
TLoadLibraryW(
    LPCWSTR lpwLibFileName
    ) ;

typedef struct _TSAPPCMP_API_HOOK_TABLE
{
    PVOID   orig;   // original API to hook
    PVOID   hook;   // new hook for that API
    WCHAR   name[ 22 * sizeof( WCHAR ) ];       // longest func name
} TSAPPCMP_API_HOOK_TABLE, PTSAPPCMP_API_HOOK_TABLE;

#define NUM_OF_OBJECT_NAME_FUNCS_TO_HOOK        16

TSAPPCMP_API_HOOK_TABLE ObjectNameFuncsToHook[ NUM_OF_OBJECT_NAME_FUNCS_TO_HOOK ] = 
    {
        {NULL,          TCreateEventA,         L"TCreateEventA" },
        {NULL,          TCreateEventW,         L"TCreateEventW" },
        {NULL,            TOpenEventA,           L"TOpenEventA" },
        {NULL,            TOpenEventW,           L"TOpenEventW" },
        {NULL,      TCreateSemaphoreA,     L"TCreateSemaphoreA" },
        {NULL,      TCreateSemaphoreW,     L"TCreateSemaphoreW" },
        {NULL,        TOpenSemaphoreA,       L"TOpenSemaphoreA" },
        {NULL,        TOpenSemaphoreW,       L"TOpenSemaphoreW" },
        {NULL,          TCreateMutexA,         L"TCreateMutexA" },
        {NULL,          TCreateMutexW,         L"TCreateMutexW" },
        {NULL,            TOpenMutexA,          L"TOpenMutexA"  },
        {NULL,            TOpenMutexW,          L"TOpenMutexW"  },
        {NULL,    TCreateFileMappingA,   L"TCreateFileMappingA" },
        {NULL,    TCreateFileMappingW,   L"TCreateFileMappingW" },
        {NULL,      TOpenFileMappingA,     L"TOpenFileMappingA" },
        {NULL,      TOpenFileMappingW,     L"TOpenFileMappingW" },
    };

#define NUM_OF_LOAD_LIB_FUNCS_TO_HOOK           4

TSAPPCMP_API_HOOK_TABLE LoadLibFuncsToHook[ NUM_OF_LOAD_LIB_FUNCS_TO_HOOK ] = 
    {
        {NULL        ,    TLoadLibraryA    , L"TLoadLibraryA"    },
        {NULL        ,    TLoadLibraryW    , L"TLoadLibraryW"    },
        {NULL        ,    TLoadLibraryExA  , L"TLoadLibraryExA"  },
        {NULL        ,    TLoadLibraryExW  , L"TLoadLibraryExW"  }
    };

void
TsWalkProcessDlls();

//
// we don't want to support the load-lib and object name redirection hack on ia64 machines.
//
BOOLEAN Is_X86_OS()
{
    SYSTEM_INFO SystemInfo;
    BOOLEAN bReturn = FALSE;

    ZeroMemory(&SystemInfo, sizeof(SystemInfo));

    GetSystemInfo(&SystemInfo);

    if ( SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL )
    {
        bReturn  = TRUE;
    }

    return bReturn;
}
// See if pEntry is already in our list, if so, then we have already
// processed this image, return FALSE
// Else, add entry to this list and return TRUE so that it is processed this time around.
BOOLEAN ShouldEntryBeProcessed( PLDR_DATA_TABLE_ENTRY pEntry )
{
    LDR_TABLE   *pCurrent,  *pNew ;

    // initialize our pointers to point to the head of the list
    pCurrent = g_LDR_TABLE_LIST_HEAD.pNext ;

    while (pCurrent)
    {
        if ( pEntry == pCurrent->pItem)
        {
            return FALSE;
        }

        pCurrent = pCurrent->pNext;
    }

    // we need to add to our list 
   
    pNew = LocalAlloc( LMEM_FIXED, sizeof( LDR_TABLE ) );

    pCurrent = g_LDR_TABLE_LIST_HEAD.pNext ;

    if (pNew)
    {
        pNew->pItem = pEntry;
        pNew->pNext = pCurrent;
        g_LDR_TABLE_LIST_HEAD.pNext = pNew;     // add to the head
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}

// Free memory allocated for the LDR_TABLE
void FreeLDRTable()
{
    LDR_TABLE   *pCurrent, *pTmp;

    pCurrent = g_LDR_TABLE_LIST_HEAD.pNext ;
    
    while ( pCurrent )
    {
        pTmp = pCurrent;
        pCurrent = pCurrent->pNext;
        LocalFree( pTmp );
    }

    if ( g_dwFlags &  DEBUG_IAT )
    {
        DbgPrint("tsappcmp: done with FreeLDRTable() \n");
    }
}

LPSTR
GlobalizePathA(
    LPCSTR pPath
    )

/*++

Routine Description:

    Convert an ANSI path to a GLOBAL path

--*/

{
    DWORD Len;
    LPSTR pNewPath;

    if( pPath == NULL ) {
	return( NULL );
    }

    //
    // Add code to determine if per object
    // override is in effect and do not globalize
    //

    Len = strlen(pPath) + GLOBALPATHSIZE + 1;

    pNewPath = LocalAlloc(LMEM_FIXED, Len);
    if( pNewPath == NULL ) {
        return( NULL );
    }

    strcpy( pNewPath, GLOBALPATHA );
    strcat( pNewPath, pPath );

    return( pNewPath );
}

LPWSTR
GlobalizePathW(
    LPCWSTR pPath
    )

/*++

Routine Description:

    Convert a WCHAR path to a GLOBAL path

--*/

{
    DWORD Len;
    LPWSTR pNewPath;

    if( pPath == NULL ) {
	return( NULL );
    }

    //
    // Add code to determine if per object
    // override is in effect and do not globalize.
    //

    Len = wcslen(pPath) + GLOBALPATHSIZE + 1;
    Len *= sizeof(WCHAR);

    pNewPath = LocalAlloc(LMEM_FIXED, Len);
    if( pNewPath == NULL ) {
        return( NULL );
    }

    wcscpy( pNewPath, GLOBALPATHW );
    wcscat( pNewPath, pPath );

    return( pNewPath );
}

// Thunks for WIN32 named object functions

HANDLE
APIENTRY
TCreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateEventW


--*/
{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_CreateEventA *) ObjectNameFuncsToHook[ Index_Func_CreateEventA ].orig )( lpEventAttributes, bManualReset, bInitialState, pNewPath );
    // h = CreateEventA( lpEventAttributes, bManualReset, bInitialState, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    if ( g_dwFlags &  DEBUG_IAT )
    {
        if( pNewPath )
            DbgPrint("TCreateEventW: Thunked, New name %ws\n",pNewPath);
    }

    h = ( ( Func_CreateEventW *) ObjectNameFuncsToHook[ Index_Func_CreateEventW ].orig ) ( lpEventAttributes, bManualReset, bInitialState, pNewPath );
    // h = CreateEventW( lpEventAttributes, bManualReset, bInitialState, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenEventA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenNamedEventW

--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_OpenEventA *) ObjectNameFuncsToHook[ Index_Func_OpenEventA ].orig )( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenEventA( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenEventW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_OpenEventW *) ObjectNameFuncsToHook[ Index_Func_OpenEventW ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenEventW( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateSemaphoreA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateSemaphoreW


--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_CreateSemaphoreA *) ObjectNameFuncsToHook[ Index_Func_CreateSemaphoreA ].orig )( lpSemaphoreAttributes, lInitialCount, lMaximumCount, pNewPath );
    // h = CreateSemaphoreA( lpSemaphoreAttributes, lInitialCount, lMaximumCount, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_CreateSemaphoreW *) ObjectNameFuncsToHook[ Index_Func_CreateSemaphoreW ].orig ) ( lpSemaphoreAttributes, lInitialCount, lMaximumCount, pNewPath );
    // h = CreateSemaphoreW( lpSemaphoreAttributes, lInitialCount, lMaximumCount, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenSemaphoreA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenSemaphoreW

--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_OpenSemaphoreA *) ObjectNameFuncsToHook[ Index_Func_OpenSemaphoreA ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenSemaphoreA( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenSemaphoreW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_OpenSemaphoreW *) ObjectNameFuncsToHook[ Index_Func_OpenSemaphoreW ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenSemaphoreW( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateMutexA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateMutexW

--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_CreateMutexA *) ObjectNameFuncsToHook[ Index_Func_CreateMutexA ].orig ) ( lpMutexAttributes, bInitialOwner, pNewPath );
    // h = CreateMutexA( lpMutexAttributes, bInitialOwner, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateMutexW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_CreateMutexW *) ObjectNameFuncsToHook[ Index_Func_CreateMutexW ].orig ) ( lpMutexAttributes, bInitialOwner, pNewPath );
    // h = CreateMutexW( lpMutexAttributes, bInitialOwner, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenMutexA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenMutexW

--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_OpenMutexA *) ObjectNameFuncsToHook[ Index_Func_OpenMutexA ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenMutexA( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenMutexW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_OpenMutexW *) ObjectNameFuncsToHook[ Index_Func_OpenMutexW ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenMutexW( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateFileMappingW

--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_CreateFileMappingA *) ObjectNameFuncsToHook[ Index_Func_CreateFileMappingA ].orig )( hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, pNewPath );
    // h = CreateFileMappingA( hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TCreateFileMappingW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_CreateFileMappingW *) ObjectNameFuncsToHook[ Index_Func_CreateFileMappingW ].orig ) ( hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, pNewPath );
    // h = CreateFileMappingW( hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenFileMappingA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to OpenFileMappingW

--*/

{
    HANDLE h;
    LPSTR pNewPath = GlobalizePathA(lpName);

    h = ( ( Func_OpenFileMappingA *) ObjectNameFuncsToHook[ Index_Func_OpenFileMappingA ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenFileMappingA( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}

HANDLE
APIENTRY
TOpenFileMappingW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    HANDLE h;
    LPWSTR pNewPath = GlobalizePathW(lpName);

    h = ( ( Func_OpenFileMappingW *) ObjectNameFuncsToHook[ Index_Func_OpenFileMappingW ].orig ) ( dwDesiredAccess, bInheritHandle, pNewPath );
    // h = OpenFileMappingW( dwDesiredAccess, bInheritHandle, pNewPath );

    if( pNewPath ) LocalFree(pNewPath);

    return h;
}



HMODULE 
TLoadLibraryExA(
	LPCSTR lpLibFileName,
	HANDLE hFile,
	DWORD dwFlags
)
{
    HMODULE h;

    h = ( (Func_LoadLibraryExA *)(LoadLibFuncsToHook[Index_Func_LoadLibraryExA ].orig) )( lpLibFileName, hFile, dwFlags );
    //     h = LoadLibraryExA( lpLibFileName, hFile, dwFlags );

    if( h ) {
        TsWalkProcessDlls();
    }

    return( h );
}


HMODULE TLoadLibraryExW(
	LPCWSTR lpwLibFileName,
	HANDLE hFile,
	DWORD dwFlags
)
{
    HMODULE h;

    h = ( ( Func_LoadLibraryExW *) LoadLibFuncsToHook[Index_Func_LoadLibraryExW ].orig )(  lpwLibFileName, hFile, dwFlags );
    // h = LoadLibraryExW( lpwLibFileName, hFile, dwFlags );

    if( h ) {
        TsWalkProcessDlls();
    }

    return( h );
}


HMODULE
TLoadLibraryA(
    LPCSTR lpLibFileName
    )

/*++

Routine Description:

   Re-walk all the DLL's in the process since a new set of DLL's may
   have been loaded.

   We must rewalk all since the new DLL lpLibFileName may bring in
   other DLL's by import reference.

--*/

{
    HMODULE h;

    h = ( ( Func_LoadLibraryA *) LoadLibFuncsToHook[Index_Func_LoadLibraryA ].orig )( lpLibFileName );
    // h = LoadLibraryA( lpLibFileName );

    if( h ) {
        TsWalkProcessDlls();
    }

    return( h );
}



HMODULE
TLoadLibraryW(
    LPCWSTR lpwLibFileName
    )

/*++

Routine Description:

   Re-walk all the DLL's in the process since a new set of DLL's may
   have been loaded.

   We must rewalk all since the new DLL lpLibFileName may bring in
   other DLL's by import reference.

--*/

{
    HMODULE h;

    h = ( ( Func_LoadLibraryW * )LoadLibFuncsToHook[Index_Func_LoadLibraryW ].orig )( lpwLibFileName );
    // h = LoadLibraryW( lpwLibFileName );

    if( h ) {
        TsWalkProcessDlls();
    }

    return( h );
}

BOOL
TsRedirectRegisteredImage(
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry , 
    BOOLEAN     redirectObjectNameFunctions,
    BOOLEAN     redirectLoadLibraryFunctions
    );


void
TsWalkProcessDlls()

/*++

Routine Description:

   Walk all the DLL's in the process and redirect WIN32 named object
   functions for any that are registered SYSTEM global.

   This function is intended to be called at tsappcmp.dll init time
   to process all DLL's loaded before us.

   A hook is installed by tsappcmp.dll to process DLL's that load
   after this call.

--*/

{
    PLDR_DATA_TABLE_ENTRY Entry;
    PLIST_ENTRY Head,Next;
    PIMAGE_NT_HEADERS NtHeaders;
    UNICODE_STRING ThisDLLName;
    BOOLEAN     rc;

    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
    __try
    {
        if (!RtlCreateUnicodeString(&ThisDLLName, TEXT("TSAPPCMP.DLL"))) {
           //
           // No memory to create string
           //
           return;
        }

        Head = &NtCurrentPeb()->Ldr->InLoadOrderModuleList;
        Next = Head->Flink;

        while ( Next != Head ) 
        {
            Entry = CONTAINING_RECORD(Next, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
            Next = Next->Flink;

            rc = ShouldEntryBeProcessed( Entry );

            if (rc)
            {
                if ( (SSIZE_T)Entry->DllBase < 0 )
                {
                    // Not hooking kernel-mode DLL 
    
                    if ( g_dwFlags &  DEBUG_IAT )
                    {
                        DbgPrint(" > Not hooking kernel mode DLL : %wZ\n",&Entry->BaseDllName);
                    }
    
                    continue;
                }
        
                if ( g_dwFlags &  DEBUG_IAT )
                {
            	    if( Entry->BaseDllName.Buffer )
                            DbgPrint("tsappcmp: examining %wZ\n",&Entry->BaseDllName);
                }
    
        	    //
                // when we unload, the memory order links flink field is nulled.
                // this is used to skip the entry pending list removal.
                //
    
                if ( !Entry->InMemoryOrderLinks.Flink ) {
                    continue;
                }
    
        	    NtHeaders = RtlImageNtHeader( Entry->DllBase );
                    if( NtHeaders == NULL ) {
                        continue;
                    }
    
                if( NtHeaders->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE)
                {
                    if ( g_dwFlags &  DEBUG_IAT )
                    {
                        DbgPrint("tsappcmp: %wZ is ts-aware, we are exiting TsWalkProcessDlls() now\n",&Entry->BaseDllName);
                    }
                    return;     // we do not mess around with the IAT of TS-aware apps.
                }
    
                if (Entry->BaseDllName.Buffer && !RtlCompareUnicodeString(&Entry->BaseDllName, &ThisDLLName, TRUE)) {
                    continue;
                }
        
        	    if( NtHeaders->OptionalHeader.LoaderFlags & IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL ) 
                {
                    // 2nd param is redirectObjectNameFunctions   
                    // 3rd param is redirectLoadLibraryFunctions   
        	        TsRedirectRegisteredImage( Entry , TRUE, TRUE );     // hooks object name and loadl lib funcs ( all of them )
                }
                else
                {
                    if (! (g_dwFlags & TERMSRV_COMPAT_DONT_PATCH_IN_LOAD_LIBS ) )
                    {
                        // 2nd param is redirectObjectNameFunctions   
                        // 3rd param is redirectLoadLibraryFunctions   
                        TsRedirectRegisteredImage( Entry , FALSE, TRUE );   // only hook lib funcs ( comment error earlier_)
                    }
                }
            }
            else
            {
                if ( g_dwFlags & DEBUG_IAT )
                {
                    if( Entry->BaseDllName.Buffer )
                            DbgPrint("tsappcmp: SKIPPING already walked image : %wZ\n",&Entry->BaseDllName);
                }

            }
        }
        RtlFreeUnicodeString(&ThisDLLName);
    }
    __finally
    {
        RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);
    }
}

void
InitRegisterSupport()
/*++

Routine Description:

    Initialize the register command support by walking
    all DLL's and inserting our thunks.

--*/

{
    int     i;

    g_LDR_TABLE_LIST_HEAD.pNext = NULL; 

    if (!Is_X86_OS() )
    {
        DbgPrint("Object name redirection not supported on non-x86 platforms\n");
        return;
    }

    if ( g_dwFlags &  DEBUG_IAT )
    {
        DbgPrint("InitRegisterSupport() called with dwFlags = 0x%lx\n", g_dwFlags);
    }

    LoadLibFuncsToHook[ Index_Func_LoadLibraryA ].orig         = LoadLibraryA;   
    LoadLibFuncsToHook[ Index_Func_LoadLibraryW ].orig         = LoadLibraryW;  
    LoadLibFuncsToHook[ Index_Func_LoadLibraryExA ].orig       = LoadLibraryExA;
    LoadLibFuncsToHook[ Index_Func_LoadLibraryExW ].orig       = LoadLibraryExW; 

    ObjectNameFuncsToHook[ Index_Func_CreateEventA ].orig       = CreateEventA;
    ObjectNameFuncsToHook[ Index_Func_CreateEventW ].orig       = CreateEventW;          
    ObjectNameFuncsToHook[ Index_Func_OpenEventA ].orig         = OpenEventA;            
    ObjectNameFuncsToHook[ Index_Func_OpenEventW ].orig         = OpenEventW;            
    ObjectNameFuncsToHook[ Index_Func_CreateSemaphoreA ].orig   = CreateSemaphoreA;      
    ObjectNameFuncsToHook[ Index_Func_CreateSemaphoreW ].orig   = CreateSemaphoreW;      
    ObjectNameFuncsToHook[ Index_Func_OpenSemaphoreA ].orig     = OpenSemaphoreA;        
    ObjectNameFuncsToHook[ Index_Func_OpenSemaphoreW ].orig     = OpenSemaphoreW;        
    ObjectNameFuncsToHook[ Index_Func_CreateMutexA ].orig       = CreateMutexA;          
    ObjectNameFuncsToHook[ Index_Func_CreateMutexW ].orig       = CreateMutexW;          
    ObjectNameFuncsToHook[ Index_Func_OpenMutexA ].orig         = OpenMutexA;            
    ObjectNameFuncsToHook[ Index_Func_OpenMutexW ].orig         = OpenMutexW;            
    ObjectNameFuncsToHook[ Index_Func_CreateFileMappingA ].orig = CreateFileMappingA;    
    ObjectNameFuncsToHook[ Index_Func_CreateFileMappingW ].orig = CreateFileMappingW;    
    ObjectNameFuncsToHook[ Index_Func_OpenFileMappingA ].orig   = OpenFileMappingA;      
    ObjectNameFuncsToHook[ Index_Func_OpenFileMappingW ].orig   = OpenFileMappingW;      

    if ( g_dwFlags &  DEBUG_IAT )
    {
        for (i = 0; i < NUM_OF_LOAD_LIB_FUNCS_TO_HOOK ; ++i)
        {
           DbgPrint(" Use %ws at index = %2d for an indirect call to 0x%lx \n", LoadLibFuncsToHook[i].name, i, LoadLibFuncsToHook[i].orig  );
        }
    
        for (i = 0; i < NUM_OF_OBJECT_NAME_FUNCS_TO_HOOK ; ++i)
        {
           DbgPrint(" Use %ws at index = %2d for an indirect call to 0x%lx \n", ObjectNameFuncsToHook[i].name, i, ObjectNameFuncsToHook[i].orig );
        }
    }


    TsWalkProcessDlls();
}

BOOL
TsRedirectRegisteredImage(
    PLDR_DATA_TABLE_ENTRY LdrDataTableEntry , 
    BOOLEAN     redirectObjectNameFunctions,
    BOOLEAN     redirectLoadLibraryFunctions
    )
{
/*++

Routine Description:

   Redirect WIN32 named object functions from kernel32.dll to tsappcmp.dll

--*/

    PIMAGE_DOS_HEADER           pIDH;
    PIMAGE_NT_HEADERS           pINTH;
    PIMAGE_IMPORT_DESCRIPTOR    pIID;
    PIMAGE_NT_HEADERS           NtHeaders;
    PBYTE                       pDllBase;
    DWORD                       dwImportTableOffset;
    DWORD                       dwOldProtect, dwOldProtect2;
    SIZE_T                      dwProtectSize;
    NTSTATUS                    status; 



    //
    // Determine the location and size of the IAT.  If found, scan the
    // IAT address to see if any are pointing to RtlAllocateHeap.  If so
    // replace when with a pointer to a unique thunk function that will
    // replace the tag with a unique tag for this image.
    //

    if ( g_dwFlags &  DEBUG_IAT )
    {
        if( LdrDataTableEntry->BaseDllName.Buffer )
            DbgPrint("tsappcmp: walking %wZ\n",&LdrDataTableEntry->BaseDllName);
    }

    pDllBase   = LdrDataTableEntry->DllBase;
    pIDH       = (PIMAGE_DOS_HEADER)pDllBase;

    //
    // Get the import table
    //
    pINTH = (PIMAGE_NT_HEADERS)(pDllBase + pIDH->e_lfanew);

    dwImportTableOffset = pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    
    if (dwImportTableOffset == 0) {
        //
        // No import table found. This is probably ntdll.dll
        //
        return TRUE;
    }
    
    if ( g_dwFlags &  DEBUG_IAT )
    {
        DbgPrint("\n > pDllBase = 0x%lx, IAT offset = 0x%lx  \n", pDllBase, dwImportTableOffset );
    }
    pIID = (PIMAGE_IMPORT_DESCRIPTOR)(pDllBase + dwImportTableOffset);
    
    //
    // Loop through the import table and search for the APIs that we want to patch
    //
    while (TRUE) 
    {        
        
        LPSTR             pszImportEntryModule;
        PIMAGE_THUNK_DATA pITDA;

        // Return if no first thunk (terminating condition)
        
        if (pIID->FirstThunk == 0) {
            break;
        }

        if ( g_dwFlags &  DEBUG_IAT )
        {
            DbgPrint(" > pIID->FirstThunk = 0x%lx \n", pIID->FirstThunk );
        }

        pszImportEntryModule = (LPSTR)(pDllBase + pIID->Name);

                //
        // We have APIs to hook for this module!
        //
        pITDA = (PIMAGE_THUNK_DATA)(pDllBase + (DWORD)pIID->FirstThunk);

        if ( g_dwFlags &  DEBUG_IAT )
        {
            DbgPrint(" >> PITDA = 0x%lx \n", pITDA );
        }

        while (TRUE) {

            DWORD   dwDllIndex;
            PVOID   dwFuncAddr;
            int     i;

            //
            // Done with all the imports from this module? (terminating condition)
            //
            if (pITDA->u1.Ordinal == 0) 
            {
                if ( g_dwFlags &  DEBUG_IAT )
                {
                    DbgPrint(" >> Existing inner loop with PITDA = 0x%lx \n", pITDA );
                }
                break;
            }

            // Make the code page writable and overwrite new function pointer in import table
            
            dwProtectSize = sizeof(DWORD);

            dwFuncAddr = (PVOID)&pITDA->u1.Function;
            
            status = NtProtectVirtualMemory(NtCurrentProcess(),
                                            (PVOID)&dwFuncAddr,
                                            &dwProtectSize,
                                            PAGE_READWRITE,
                                            &dwOldProtect);
            
            if (NT_SUCCESS(status)) 
            {
                // hook API of interest.

                if (redirectObjectNameFunctions)
                {
                    for (i = 0; i < NUM_OF_OBJECT_NAME_FUNCS_TO_HOOK ; i ++)
                    {
                        if ( ObjectNameFuncsToHook[i].orig ==  (PVOID) pITDA->u1.Function  )
                        {
                            (PVOID)pITDA->u1.Function  = ObjectNameFuncsToHook[i].hook;
    
                            if ( g_dwFlags &  DEBUG_IAT )
                            {
                                DbgPrint(" > Func was hooked : 0x%lx thru %ws \n", ObjectNameFuncsToHook[i].orig ,
                                     ObjectNameFuncsToHook[i].name );
                            }
                        }
                    }
                }
                
                if (redirectLoadLibraryFunctions )
                {
                    for (i = 0; i < NUM_OF_LOAD_LIB_FUNCS_TO_HOOK ; i ++)
                    {
                        if ( LoadLibFuncsToHook[i].orig ==  (PVOID) pITDA->u1.Function  )
                        {
                            (PVOID)pITDA->u1.Function  = LoadLibFuncsToHook[i].hook;
                    
                            if ( g_dwFlags &  DEBUG_IAT )
                            {
                                DbgPrint(" > Func was hooked : 0x%lx thru %ws \n", LoadLibFuncsToHook[i].orig ,
                                     LoadLibFuncsToHook[i].name );
                            }
                        }
                    }

                }

                dwProtectSize = sizeof(DWORD);
                
                status = NtProtectVirtualMemory(NtCurrentProcess(),
                                                (PVOID)&dwFuncAddr,
                                                &dwProtectSize,
                                                dwOldProtect,
                                                &dwOldProtect2);
                if (!NT_SUCCESS(status)) 
                {
                    DbgPrint((" > Failed to change back the protection\n"));
                }
            } 
            else 
            {
                DbgPrint(" > Failed 0x%X to change protection to PAGE_READWRITE. Addr 0x%lx \n", status, &(pITDA->u1.Function) );
            }
            pITDA++;
        }
        pIID++;
    }
    return TRUE;
}

#if 0
void
TsLoadDllCallback(
    PLDR_DATA_TABLE_ENTRY Entry
    )

/*++

Routine Description:

   This function is called when a new DLL is loaded.
   It is registered as a callback from LDR, same as WX86

   Hook goes into ntos\dll\ldrsnap.c,LdrpRunInitializeRoutines()

   This function is currently not used since a hook on LoadLibrary
   is used instead to avoid modifications to ntdll.dll.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    NtHeaders = RtlImageNtHeader( Entry->DllBase );
    if( NtHeaders == NULL ) {
        return;
    }

    if( NtHeaders->OptionalHeader.LoaderFlags & IMAGE_LOADER_FLAGS_SYSTEM_GLOBAL ) {
	TsRedirectRegisteredImage( Entry );
    }

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tscert\inc\pubblob.h ===
unsigned char PublicKeySigBlob[] = {
// This data is generated by obj\i386\certinit.
// Key Blob - 148 bytes
0x06, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 
0x52, 0x53, 0x41, 0x31, 0x00, 0x04, 0x00, 0x00, 
0x01, 0x00, 0x01, 0x00, 0xb1, 0xb6, 0x1b, 0x6c, 
0x05, 0xa5, 0x4e, 0xd4, 0xab, 0x64, 0xdb, 0x96, 
0x56, 0x2c, 0x96, 0xfa, 0xcf, 0x15, 0x6d, 0x73, 
0x6e, 0xbb, 0x14, 0xc6, 0xe8, 0xed, 0xd8, 0x4b, 
0xb9, 0x50, 0x66, 0x30, 0x21, 0xb0, 0x00, 0x6d, 
0x4f, 0x56, 0xe6, 0xd0, 0x99, 0x28, 0xd1, 0xf0, 
0x4a, 0xde, 0x82, 0x76, 0x25, 0xd2, 0x4c, 0xff, 
0x4e, 0x07, 0x45, 0x0c, 0x09, 0x3c, 0xd4, 0x7d, 
0x79, 0x1b, 0xab, 0x94, 0x60, 0xdc, 0x5a, 0x0b, 
0xaa, 0x1b, 0xc3, 0xc1, 0x87, 0x93, 0xda, 0xbc, 
0xb1, 0xee, 0xd0, 0x66, 0x8c, 0x94, 0x2c, 0x26, 
0x1a, 0xfa, 0x0c, 0x41, 0x20, 0x59, 0x2e, 0xda, 
0x8f, 0xa2, 0x79, 0x66, 0x0f, 0xe7, 0x10, 0xc0, 
0x89, 0x61, 0xe5, 0x56, 0x94, 0xc4, 0xb9, 0x35, 
0x61, 0x2d, 0xf9, 0x2f, 0x58, 0xb2, 0xe3, 0x09, 
0x52, 0x25, 0x20, 0x1f, 0x03, 0xcd, 0xab, 0xee, 
0xe5, 0x1b, 0xa9, 0xdb, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tscert\tscrtini\privblob.h ===
unsigned char PrivateKeySigBlob[] = {
// This data is generated by obj\i386\certinit.
// Key Blob - 596 bytes
0x07, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 
0x52, 0x53, 0x41, 0x32, 0x00, 0x04, 0x00, 0x00, 
0x01, 0x00, 0x01, 0x00, 0xb1, 0xb6, 0x1b, 0x6c, 
0x05, 0xa5, 0x4e, 0xd4, 0xab, 0x64, 0xdb, 0x96, 
0x56, 0x2c, 0x96, 0xfa, 0xcf, 0x15, 0x6d, 0x73, 
0x6e, 0xbb, 0x14, 0xc6, 0xe8, 0xed, 0xd8, 0x4b, 
0xb9, 0x50, 0x66, 0x30, 0x21, 0xb0, 0x00, 0x6d, 
0x4f, 0x56, 0xe6, 0xd0, 0x99, 0x28, 0xd1, 0xf0, 
0x4a, 0xde, 0x82, 0x76, 0x25, 0xd2, 0x4c, 0xff, 
0x4e, 0x07, 0x45, 0x0c, 0x09, 0x3c, 0xd4, 0x7d, 
0x79, 0x1b, 0xab, 0x94, 0x60, 0xdc, 0x5a, 0x0b, 
0xaa, 0x1b, 0xc3, 0xc1, 0x87, 0x93, 0xda, 0xbc, 
0xb1, 0xee, 0xd0, 0x66, 0x8c, 0x94, 0x2c, 0x26, 
0x1a, 0xfa, 0x0c, 0x41, 0x20, 0x59, 0x2e, 0xda, 
0x8f, 0xa2, 0x79, 0x66, 0x0f, 0xe7, 0x10, 0xc0, 
0x89, 0x61, 0xe5, 0x56, 0x94, 0xc4, 0xb9, 0x35, 
0x61, 0x2d, 0xf9, 0x2f, 0x58, 0xb2, 0xe3, 0x09, 
0x52, 0x25, 0x20, 0x1f, 0x03, 0xcd, 0xab, 0xee, 
0xe5, 0x1b, 0xa9, 0xdb, 0x03, 0x93, 0xdb, 0x2f, 
0xc3, 0x15, 0xd1, 0xe7, 0x2e, 0xa0, 0xce, 0xb0, 
0x9b, 0x4d, 0x9f, 0x17, 0xd4, 0xe4, 0x9e, 0xfc, 
0xb0, 0x72, 0x5b, 0x78, 0x58, 0xbd, 0xef, 0x73, 
0x3c, 0xbe, 0x52, 0x09, 0xfd, 0x62, 0x08, 0x2e, 
0x7e, 0x50, 0x80, 0x6b, 0x00, 0x20, 0xbb, 0xfd, 
0xfd, 0x3b, 0x38, 0xde, 0x92, 0x5d, 0x0e, 0xf9, 
0xe4, 0xa5, 0xc6, 0x84, 0x07, 0xd8, 0xa4, 0x7a, 
0xa9, 0xf8, 0x59, 0xed, 0x3b, 0x47, 0xe9, 0x3b, 
0x03, 0x34, 0xa8, 0x54, 0xa3, 0x1c, 0x0c, 0xae, 
0x93, 0x1b, 0x1b, 0xa9, 0x27, 0xca, 0x12, 0x88, 
0xb0, 0x0c, 0xe4, 0x40, 0xbe, 0xb1, 0x4e, 0xa7, 
0x39, 0x2c, 0x62, 0x5a, 0xc7, 0x53, 0xcf, 0xb4, 
0x49, 0x20, 0x0b, 0xc5, 0x76, 0x61, 0x69, 0xa5, 
0x85, 0x17, 0xe0, 0x2b, 0x50, 0x9e, 0x57, 0xc1, 
0x5a, 0xc8, 0x6a, 0x31, 0x09, 0xd0, 0x8e, 0x2e, 
0xd0, 0x4e, 0xeb, 0xec, 0xc9, 0xda, 0x91, 0x03, 
0xf5, 0x6b, 0x64, 0x0d, 0xbc, 0x98, 0x64, 0xdc, 
0x68, 0xe7, 0x7d, 0x8c, 0x6e, 0x67, 0xcc, 0x69, 
0x9c, 0x69, 0xc0, 0x3f, 0xaa, 0xb8, 0xa9, 0x12, 
0xdc, 0x39, 0x55, 0x31, 0x83, 0xd6, 0x07, 0xf2, 
0x25, 0x9b, 0x44, 0xf4, 0xfd, 0xa2, 0xfa, 0xad, 
0xbf, 0x52, 0x1b, 0x90, 0x01, 0x8b, 0xb5, 0xd4, 
0x3d, 0x2a, 0xff, 0x60, 0x77, 0x9f, 0x56, 0xb3, 
0x36, 0xd8, 0x5a, 0x33, 0x0d, 0x3f, 0xfe, 0x92, 
0x05, 0x1d, 0x57, 0x21, 0x72, 0x65, 0x00, 0x96, 
0xc8, 0x10, 0x1c, 0xea, 0x51, 0xaf, 0xeb, 0x6a, 
0xcd, 0xc7, 0xa1, 0x5d, 0x65, 0x2d, 0x92, 0xb7, 
0x0d, 0x44, 0x50, 0x17, 0xe6, 0x93, 0xf9, 0x3e, 
0x44, 0x39, 0xcd, 0x30, 0x59, 0xb2, 0xae, 0xfd, 
0x1e, 0x9b, 0x5b, 0x64, 0x6c, 0xc7, 0xa4, 0x30, 
0x54, 0x01, 0x0f, 0x7f, 0x9d, 0xd4, 0x76, 0xc5, 
0x0d, 0xe7, 0x62, 0x99, 0x31, 0x45, 0x2c, 0x2d, 
0xf1, 0xf1, 0xf6, 0x36, 0x47, 0x32, 0x02, 0x9c, 
0xb4, 0xec, 0x6a, 0x37, 0x56, 0xee, 0x92, 0x43, 
0x3b, 0x6c, 0x51, 0xb8, 0x18, 0x09, 0x56, 0x1a, 
0x1a, 0x7c, 0xec, 0x76, 0x41, 0x44, 0xef, 0x2e, 
0x9b, 0x56, 0xcb, 0x97, 0x52, 0x29, 0x64, 0x3e, 
0x03, 0x59, 0x98, 0xe4, 0xcd, 0x4a, 0xf8, 0xd3, 
0x80, 0xb4, 0xd2, 0x4e, 0x7e, 0x58, 0x11, 0xe2, 
0x71, 0x92, 0x80, 0x45, 0xc5, 0xb2, 0xcd, 0x65, 
0xff, 0x96, 0xe9, 0xc8, 0x84, 0x58, 0x49, 0x20, 
0x26, 0x2d, 0x8e, 0x4e, 0x74, 0xd5, 0x60, 0xa5, 
0x0a, 0x7c, 0xe0, 0x3a, 0xe0, 0x1f, 0x86, 0xea, 
0xb0, 0x93, 0x5e, 0x38, 0xfb, 0xc9, 0x9d, 0xc9, 
0x13, 0xfb, 0x4e, 0x91, 0x16, 0x0a, 0x2a, 0x2a, 
0xe5, 0xb9, 0x76, 0x54, 0x9a, 0xe8, 0x35, 0x0d, 
0x32, 0x5e, 0x53, 0x5d, 0x29, 0x9b, 0x4d, 0xa5, 
0xae, 0xe5, 0xae, 0xb6, 0x67, 0xb7, 0xb2, 0xc6, 
0x6b, 0xb2, 0x37, 0x39, 0x8b, 0xd1, 0x0c, 0x6a, 
0xf3, 0x7d, 0xc6, 0xbf, 0xc1, 0x9d, 0x46, 0x96, 
0x7f, 0xa0, 0x7a, 0xc0, 0xa9, 0x36, 0x63, 0x06, 
0x9d, 0x5a, 0x21, 0x8a, 0xa3, 0x3a, 0xef, 0x44, 
0x23, 0xb2, 0xb6, 0x06, 0xcb, 0xda, 0xd1, 0x71, 
0xaf, 0x9f, 0xf9, 0x60, 0x69, 0x35, 0xc1, 0xe9, 
0xcc, 0x3f, 0x59, 0x45, 0x89, 0xa8, 0xea, 0xd2, 
0x54, 0x30, 0xaf, 0x7e, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tscert\tscrtdel\tscrtdel.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <wincrypt.h>
#include <imagehlp.h>

#define WIN_CERT_TYPE_STACK_DLL_SIGNATURE WIN_CERT_TYPE_TS_STACK_SIGNED

BOOL UnSignFile( LPWSTR wszFile );

/*****************************************************************************/
void _cdecl main(int argc, char *argv[])
{

    WCHAR szSourceFile[ MAX_PATH + 1];
    DWORD dwBc;
    
    if (argc != 2) {
        printf( "Usage: %s PE_File_Name\n", argv[0] );
        exit(1);
    }

    if(RtlMultiByteToUnicodeN( szSourceFile, sizeof(szSourceFile), &dwBc,
        argv[1], (strlen(argv[1]) + 1) ) == STATUS_SUCCESS)
    {

        if(!UnSignFile(szSourceFile)) {
	    printf("Error removing signature!\n");
	    exit(1);
        }

        printf("Signature removed successfully.\n");
        exit(0);
    }
    else
    {
        printf("RtlMultiByteToUnicode function failed.\n");
    }
}


//////////////////////////////////////////////////////////////
//
// Open a file in the appropriate permissions / mode for doing
// our signing stuff
//
//////////////////////////////////////////////////////////////
HANDLE OpenImageFile( LPCWSTR wszFile, DWORD dwAccess )
{
    HANDLE hFile;
    if (wszFile) {
        hFile = CreateFile( wszFile,
                            dwAccess,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        return hFile;
    } else {
        return INVALID_HANDLE_VALUE;
    }
}

///////////////////////////////////////////////////////////////////////
//
// Unsign Code, Data, and Resources of a PE image file
//
///////////////////////////////////////////////////////////////////////
BOOL
UnSignFile(
    LPWSTR wszFile
    )
{
    BOOL        fResult = FALSE;  // preset ERROR case
    HANDLE      hFile;
    DWORD       dwCertIndex;
    DWORD       cCert;

    if ( !(hFile = OpenImageFile( wszFile, GENERIC_WRITE | GENERIC_READ )) ) {
	printf("Error %x during OpenImageFile\n", GetLastError() );
        goto OpenImageFileError;
    }

    // Remove any and all Stack DLL Signature Certificates from PE file
    while (TRUE) {
        cCert = 0;
        dwCertIndex = 0;
        if (!ImageEnumerateCertificates(
                hFile,
                WIN_CERT_TYPE_STACK_DLL_SIGNATURE,
                &cCert,
                &dwCertIndex,
                1               // IndexCount
                )) {
            break;
        }

        if (cCert == 0) {
            break;
        }
        if (!ImageRemoveCertificate(hFile, dwCertIndex)) {
            goto ImageRemoveCertificateError;
        }
    }
    
    fResult = TRUE;

ImageRemoveCertificateError:
OpenImageFileError:
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tscert\tscrtini\pubblob.h ===
unsigned char PublicKeySigBlob[] = {
// This data is generated by obj\i386\certinit.
// Key Blob - 148 bytes
0x06, 0x02, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 
0x52, 0x53, 0x41, 0x31, 0x00, 0x04, 0x00, 0x00, 
0x01, 0x00, 0x01, 0x00, 0xb1, 0xb6, 0x1b, 0x6c, 
0x05, 0xa5, 0x4e, 0xd4, 0xab, 0x64, 0xdb, 0x96, 
0x56, 0x2c, 0x96, 0xfa, 0xcf, 0x15, 0x6d, 0x73, 
0x6e, 0xbb, 0x14, 0xc6, 0xe8, 0xed, 0xd8, 0x4b, 
0xb9, 0x50, 0x66, 0x30, 0x21, 0xb0, 0x00, 0x6d, 
0x4f, 0x56, 0xe6, 0xd0, 0x99, 0x28, 0xd1, 0xf0, 
0x4a, 0xde, 0x82, 0x76, 0x25, 0xd2, 0x4c, 0xff, 
0x4e, 0x07, 0x45, 0x0c, 0x09, 0x3c, 0xd4, 0x7d, 
0x79, 0x1b, 0xab, 0x94, 0x60, 0xdc, 0x5a, 0x0b, 
0xaa, 0x1b, 0xc3, 0xc1, 0x87, 0x93, 0xda, 0xbc, 
0xb1, 0xee, 0xd0, 0x66, 0x8c, 0x94, 0x2c, 0x26, 
0x1a, 0xfa, 0x0c, 0x41, 0x20, 0x59, 0x2e, 0xda, 
0x8f, 0xa2, 0x79, 0x66, 0x0f, 0xe7, 0x10, 0xc0, 
0x89, 0x61, 0xe5, 0x56, 0x94, 0xc4, 0xb9, 0x35, 
0x61, 0x2d, 0xf9, 0x2f, 0x58, 0xb2, 0xe3, 0x09, 
0x52, 0x25, 0x20, 0x1f, 0x03, 0xcd, 0xab, 0xee, 
0xe5, 0x1b, 0xa9, 0xdb, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tscert\tscrtini\tscrtini.c ===
/******************************************************************************\
*       Adapted by Bruce Fortune (Citrix Systems, Inc.) from MS Online Source 
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1996 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>

#define SIGKEYSIZE 1024

#define PUBBLOBFILE "pubblob.h"
#define PRIVBLOBFILE "privblob.h"

//
// LINE_VALS - maximum number of byte values printed on each line of
//             the "blob" files
//
#define LINE_VALS 8

char *pszProgname; // program name - from argv[0]


BOOL
OpenBlobFile(
    FILE **file,
    CHAR *fname
    )
{
    *file = fopen( fname, "wt" );
    if ( !*file ) {
        return(FALSE);
    }
    return(TRUE);
}

void
DumpKeyBlob(
    FILE *file,
    DWORD dwBlobType,
    HCRYPTKEY hKey,
    HCRYPTKEY hExportKey )
{
    int dwBlobCount;
    if (!CryptExportKey(
            hKey,
            hExportKey,
            dwBlobType,
            0,
            NULL,
            &dwBlobCount)) {
        printf( "Error %x during CryptExportKey 1!\n", GetLastError());
        exit(1);
    } else {
        PBYTE pBlob;
        pBlob = (PBYTE) malloc( dwBlobCount );
        if ( !pBlob || !CryptExportKey(
                hKey,
                hExportKey,
                dwBlobType,
                0,
                pBlob,
                &dwBlobCount)) {
            printf("Error %x during malloc/CryptExportKey 2!\n",
                GetLastError());
            exit(1);
        } else {
            int cnt=0;
            fprintf( file, "// This data is generated by %s.\n", pszProgname );
            fprintf( file, "// Key Blob - %d bytes\n",
                dwBlobCount );
            while ( cnt < dwBlobCount ) {
                int i;
                for ( i=0; (i < LINE_VALS) && (cnt < dwBlobCount); cnt++,i++) {
                    fprintf( file, "0x%02x, ", *(pBlob+cnt) );
                }
                fprintf( file, "\n" );
            }
            free( pBlob );
        }
    }
}

/*****************************************************************************/
void _cdecl main(int argc, char *argv[])
{
    HCRYPTPROV hProv;
    HCRYPTKEY hSigKey;
    CHAR szUserName[100];
    DWORD dwUserNameLen = 100;
    FILE *blobfile;

    pszProgname = argv[0];

    // Attempt to acquire a handle to the default key container.
    if(!CryptAcquireContext(&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, 0)) {
	// Some sort of error occured.

	// Create default key container.
	if(!CryptAcquireContext(&hProv, NULL, MS_DEF_PROV,
                PROV_RSA_FULL, CRYPT_NEWKEYSET)) {
	    printf("Error creating key container!\n");
	    exit(1);
	}

	// Get name of default key container.
	if(!CryptGetProvParam(hProv, PP_CONTAINER, szUserName,
                &dwUserNameLen, 0)) {
	    // Error getting key container name.
	    szUserName[0] = 0;
	}

	printf("Create key container '%s'\n",szUserName);
    }

    // Attempt to get handle to signature key.
    // Commented out the following 2 lines. We always gerenate a new signature key. TSE4.0
    // uses the existing key which seems to generate the same key all the time.
    //    if( !CryptGetUserKey(hProv, AT_SIGNATURE, &hSigKey)) {
    //	if( GetLastError() == NTE_NO_KEY) {
    //
    // Create signature key pair.
    //
    printf("Creating signature key pair...");

    if (!CryptGenKey( hProv,
                      AT_SIGNATURE,
                      (SIGKEYSIZE << 16 ) | CRYPT_EXPORTABLE,
                      &hSigKey)) {
        printf("Error %x during CryptGenKey!\n", GetLastError());
        exit(1);
    } else {
        // Get Public Key BLOB
        if ( !OpenBlobFile( &blobfile, PUBBLOBFILE ) ) {
            printf( "Error %x during OpenBlobFile!\n", GetLastError() );
            exit(1);
        }
        fprintf( blobfile, "unsigned char PublicKeySigBlob[] = {\n" );
        DumpKeyBlob( blobfile, PUBLICKEYBLOB, hSigKey, 0 );
        fprintf( blobfile, "};\n" );

    }

    
#if 0 // Commented out the following code. We always gerenate a new signature key. TSE4.0
      // uses the existing key which seems to generate the same key all the time.

	} else {
	    printf("Error %x during CryptGetUserKey!\n", GetLastError());
	    exit(1);
	}
    } else {
        // Get Public Key BLOB
        printf( "Using existing keys..." );
        if ( !OpenBlobFile( &blobfile, PUBBLOBFILE ) ) {
            printf( "Error %x during OpenBlobFile!\n", GetLastError() );
            exit(1);
        }
        fprintf( blobfile, "unsigned char PublicKeySigBlob[] = {\n" );
        DumpKeyBlob( blobfile, PUBLICKEYBLOB, hSigKey, 0 );
        fprintf( blobfile, "};\n" );
    }
#endif

    // Get Private Key BLOB
    if ( !OpenBlobFile( &blobfile, PRIVBLOBFILE ) ) {
        printf( "Error %x during OpenBlobFile - %s!\n",
            GetLastError(),
            PRIVBLOBFILE );
        exit(1);
    }
    fprintf( blobfile, "unsigned char PrivateKeySigBlob[] = {\n" );
    DumpKeyBlob( blobfile, PRIVATEKEYBLOB, hSigKey, 0 );
    fprintf( blobfile, "};\n" );
    CryptDestroyKey(hSigKey);

    CryptReleaseContext(hProv,0);

    printf( " successful.\n" );
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tscert\tscrtadd\tscrtadd.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <wincrypt.h>
#include <imagehlp.h>

#ifdef IN_TERMSRV
#else
#define MemAlloc malloc
#define MemFree free
#endif

#ifdef SIGN_DEBUG
#define SIGN_DBGP(x) printf x
#else // SIGN_DEBUG
#define SIGN_DBGP(x)
#endif // SIGN_DEBUG

#include "../inc/privblob.h"

#define WIN_CERT_TYPE_STACK_DLL_SIGNATURE WIN_CERT_TYPE_TS_STACK_SIGNED

BOOL SignFile( LPWSTR wszFile );

/*****************************************************************************/
void _cdecl main(int argc, char *argv[])
{

    WCHAR szSourceFile[ MAX_PATH + 1];
    DWORD dwBc;

    if (argc != 2) {
        printf( "Usage: %s PE_File_Name\n", argv[0] );
        exit(1);
    }

    if(RtlMultiByteToUnicodeN( szSourceFile, sizeof(szSourceFile), &dwBc,
        argv[1], (strlen(argv[1]) + 1) ) == STATUS_SUCCESS)
    {

        if( szSourceFile == NULL || !SignFile(szSourceFile) ) {
	    printf("Error signing file!\n");
	    exit(1);
        }

        printf("Signature added successfully.\n");
        exit(0);
    }
    else
    {
        printf("Error conversion from Ansi to Unicode.\n");
        exit(1);
    }
}


typedef struct _DIGEST_PARA {
    HCRYPTHASH      hHash;
} DIGEST_PARA, *PDIGEST_PARA;


BOOL
WINAPI
DigestFile(
    DIGEST_HANDLE hDigest,
    PBYTE pb,
    DWORD cb )
{
    PDIGEST_PARA pdp = (PDIGEST_PARA)hDigest;

    if (pb == (PBYTE)-1) {
        return( TRUE );
    } else {
        return( CryptHashData(pdp->hHash, pb, cb, 0) );
    }
}


//////////////////////////////////////////////////////////////
//
// Open a file in the appropriate permissions / mode for doing
// our signing stuff
//
//////////////////////////////////////////////////////////////
HANDLE OpenImageFile( LPCWSTR wszFile, DWORD dwAccess )
{
    HANDLE hFile;
    if (wszFile) {
        hFile = CreateFile( wszFile,
                            dwAccess,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        return hFile;
    } else {
        return INVALID_HANDLE_VALUE;
    }
}

///////////////////////////////////////////////////////////////////////
//
// Sign Code, Data, and Resources of a PE image file, and add the
// signature to the file in the form of a "WIN_CERTIFICATE".
//
///////////////////////////////////////////////////////////////////////
BOOL
SignFile(
    LPWSTR wszFile
    )
{
    HCRYPTPROV  hProv;
    HCRYPTKEY   hPrivateKeySig = 0;
    BOOL        fResult = FALSE;  // preset ERROR case
    HANDLE      hFile;
    DWORD       dwErr = ERROR_SUCCESS;
    DWORD       dwSignatureLen;
    DWORD       dwCert;
    DWORD       dwCertIndex;
    DWORD       cCert;
    DIGEST_PARA dp;
    PBYTE       pbSignature;
    LPWIN_CERTIFICATE pCertHdr;

    if ( !(hFile = OpenImageFile( wszFile, GENERIC_WRITE | GENERIC_READ )) ) {
	printf("Error %x during OpenImageFile\n", GetLastError() );
        goto OpenImageFileError;
    }

    if (!CryptAcquireContext(
            &hProv,
            NULL,
            MS_DEF_PROV,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT))
    {
  	    SIGN_DBGP( ("Error %x during CryptAcquireContext\n", GetLastError()) );
        goto CryptAcquireContextError;
    }

    if (!CryptImportKey(
            hProv,
            PrivateKeySigBlob,  // from #include "../inc/privblob.h"
            sizeof( PrivateKeySigBlob ),
            0,
            CRYPT_EXPORTABLE,
            &hPrivateKeySig)) {
        SIGN_DBGP( ("Error %x during CryptImportKey!\n", GetLastError()) );
        goto CryptImportKeyError;
    }

    memset( &dp, 0, sizeof(dp));
    if (!CryptCreateHash(
            hProv,
            CALG_MD5,
            0,
            0,
            &dp.hHash)) {
	SIGN_DBGP( ("Error %x during CryptCreateHash\n", GetLastError()) );
        goto CryptCreateHashError;
    }

    if (!ImageGetDigestStream(
            hFile,
            0,
            DigestFile,
            (DIGEST_HANDLE)&dp)) {
	SIGN_DBGP( ("Error %x during ImageGetDigestStream\n", GetLastError()) );
        goto ImageGetDigestStreamError;

    }

    //
    // Sign hash object.
    //

    // Determine size of signature.
    dwSignatureLen = 0;
    if(!CryptSignHash(
            dp.hHash,
            AT_SIGNATURE,
            NULL,
            0,
            NULL,
            &dwSignatureLen)) {
	SIGN_DBGP( ("Error %x during CryptSignHash 1! SigLen = %d\n",
            GetLastError(),
            dwSignatureLen) );
	goto CryptSignHash1Error;
    }

    // Allocate memory for 'pbSignature'.
    if((pbSignature = MemAlloc(dwSignatureLen)) == NULL) {
	SIGN_DBGP( ("Out of memory Sig!\n") );
	goto SigAllocError;
    }

    // Sign hash object (with signature key).
    if(!CryptSignHash(
            dp.hHash,
            AT_SIGNATURE,
            NULL,
            0,
            pbSignature,
            &dwSignatureLen)) {
	SIGN_DBGP( ("Error %x during CryptSignHash 2!\n", GetLastError()) );
	goto CryptSignHash2Error;
    }

    SIGN_DBGP( ("Signature length = %d\n", dwSignatureLen) );
    dwCert = offsetof( WIN_CERTIFICATE, bCertificate ) + dwSignatureLen;
    if (NULL == (pCertHdr = (LPWIN_CERTIFICATE) MemAlloc(dwCert))) {
	SIGN_DBGP( ("Out of memory Cert!\n") );
        goto CertAllocError;
    }

    // Put the signature and key into the WIN_CERTIFICATE structure
    pCertHdr->dwLength = dwCert;
    pCertHdr->wRevision = WIN_CERT_REVISION_1_0;
    pCertHdr->wCertificateType = WIN_CERT_TYPE_STACK_DLL_SIGNATURE;
    memcpy( &pCertHdr->bCertificate[0], pbSignature, dwSignatureLen );

    {
        unsigned int cnt=0;
        while ( cnt < dwSignatureLen ) {
            int i;
            for ( i=0; (i < 16) && (cnt < dwSignatureLen); cnt++,i++) {
                SIGN_DBGP( ("%02x ", pCertHdr->bCertificate[cnt]) );
            }
            SIGN_DBGP( ("\n") );
        }
    }

    // Remove any and all Stack DLL Signature Certificates from PE file
    while (TRUE) {
        cCert = 0;
        dwCertIndex = 0;
        if (!ImageEnumerateCertificates(
                hFile,
                WIN_CERT_TYPE_STACK_DLL_SIGNATURE,
                &cCert,
                &dwCertIndex,
                1               // IndexCount
                )) {
            break;
        }
        if (cCert == 0) {
            break;
        }
        if (!ImageRemoveCertificate(hFile, dwCertIndex)) {
            SIGN_DBGP( ("Error %x during ImageRemoveCertificate\n",
                GetLastError()) );
            goto ImageRemoveCertificateError;
        }
    }

    if (!ImageAddCertificate(
            hFile,
            pCertHdr,
            &dwCertIndex)) {
	SIGN_DBGP( ("Error %x during ImageAddCertificate\n", GetLastError()) );
        goto ImageAddCertificateError;
    }

    fResult = TRUE;

ImageAddCertificateError:
ImageRemoveCertificateError:
    MemFree( pCertHdr );

CertAllocError:
CryptSignHash2Error:
    MemFree( pbSignature );

SigAllocError:
CryptSignHash1Error:
ImageGetDigestStreamError:
    CryptDestroyHash( dp.hHash );

CryptCreateHashError:
    CryptDestroyKey(hPrivateKeySig);

CryptImportKeyError:
    dwErr = GetLastError();
    CryptReleaseContext( hProv, 0 );
    SetLastError( dwErr );

CryptAcquireContextError:
    CloseHandle( hFile );

OpenImageFileError:
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\configdlg.cpp ===
// configdlg.cpp : implements TSConfigDlg dialog.
//

#include "stdafx.h"
#include "resource.h"
#include "configdlg.h"

const CONNECTION_TIME_DIGIT_MAX  = 5;       // 5 digits max
const CONNECTION_TIME_DEFAULT    = 120;     // 120 minutes
const CONNECTION_TIME_MIN        = 1;       // 1 minute
const CONNECTION_TIME_MAX        = 71582;   // 71582 minutes (max msec for ULONG)

const DISCONNECTION_TIME_DIGIT_MAX = 5;       // 5 digits max
const DISCONNECTION_TIME_DEFAULT   = 10;      // 10 minutes
const DISCONNECTION_TIME_MIN       = 1;       // 1 minute
const DISCONNECTION_TIME_MAX       = 71582;   // 71582 minutes (max msec for ULONG)

const IDLE_TIME_DIGIT_MAX  = 5;       // 5 digits max
const IDLE_TIME_DEFAULT    = 10;      // 10 minutes
const IDLE_TIME_MIN        = 1;       // 1 minute
const IDLE_TIME_MAX        = 71582;   // 71582 minutes (max msec for ULONG)

const TIME_RESOLUTION  = 60000;   // stored as msec-seen as minutes


// forword declard.
DWORD wchar2TCHAR(TCHAR *dest, const WCHAR *src);
extern HINSTANCE GetInstance();
BOOL TSConfigDlg::m_sbWindowLogSet = FALSE;


// property page dialog procedure : handles dialog messages.
BOOL CALLBACK TSConfigDlg::PropertyPageDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        // LPARAM points to the property sheet page.
        // this will give us this pointer to access the class.

        TSConfigDlg *pDlg =  reinterpret_cast<TSConfigDlg*>(LPPROPSHEETPAGE(lParam)->lParam);

        ASSERT(NULL != pDlg);
        ASSERT(pDlg->AssertClass());
        SetWindowLong(hwndDlg, DWL_USER, long(pDlg));

        // ok now hereafter we can access the class pointer.
        // maks_done: check mfc implementation, how do they do it ?
        // what mfc does is - its hooks into the wnd creation process
        // and keeps a map of hwnd vs objects.

        m_sbWindowLogSet = TRUE;

        return pDlg->OnInitDialog(hwndDlg, wParam, lParam);

    }



    // now we have set DWL_USER as class pointer during INIT DIALOG.
    if (m_sbWindowLogSet)
    {
        TSConfigDlg *pDlg = reinterpret_cast<TSConfigDlg*>(GetWindowLong(hwndDlg, DWL_USER));
        ASSERT(NULL != pDlg);
        ASSERT(pDlg->AssertClass());

        if (uMsg == WM_COMMAND)
            return pDlg->OnCommand(wParam, lParam);

        if (uMsg == WM_NOTIFY)
        {
            LOGMESSAGE3(_T("Received WM_NOTIFY:hwnddlg =%ul,wParam=%u,lParam=%ul"), hwndDlg, wParam, lParam);
            return pDlg->OnNotify(wParam, lParam);
        }

    }

    return 0;
}

// Property Sheet Procedure : gets notified about CREATE, RELEASE events
UINT CALLBACK TSConfigDlg::PropSheetPageProc (
    HWND /* hWnd */,		             // [in] Window handle - always null
    UINT uMsg,                   // [in,out] Either the create or delete message
    LPPROPSHEETPAGE pPsp		 // [in,out] Pointer to the property sheet struct
    )
{
  ASSERT( NULL != pPsp );

  // We need to recover a pointer to the current instance.  We can't just use
  // "this" because we are in a static function
  TSConfigDlg* pMe   = reinterpret_cast<TSConfigDlg*>(pPsp->lParam);
  ASSERT( NULL != pMe );
  ASSERT(pMe->AssertClass());

  switch( uMsg )
  {
    case PSPCB_CREATE:
      break;

    case PSPCB_RELEASE:

        // this variable makes dialog proc setwindowlong on dialog handle.
        m_sbWindowLogSet = FALSE;
        delete pMe;
        return 1; //(pfnOrig)(hWnd, uMsg, pPsp);
  }

  return 1;

} // end PropSheetPageProc()



TSConfigDlg::TSConfigDlg (LPWSTR wMachineName, LPWSTR wUserName)
{
    ASSERT(wMachineName);
    ASSERT(wUserName);

    ASSERT(wcslen(wMachineName) < SIZE_MAX_SERVERNAME);
    ASSERT(wcslen(wUserName)    < SIZE_MAX_USERNAME);
    
    VERIFY( wchar2TCHAR(m_Username, wUserName) < SIZE_MAX_USERNAME);
    VERIFY( wchar2TCHAR(m_Servername, wMachineName) < SIZE_MAX_SERVERNAME);

    LOGMESSAGE0(_T("TSConfigDlg::TSConfigDlg ()"));

    m_tPropSheetPage.dwSize         = sizeof (PROPSHEETPAGE);
    m_tPropSheetPage.hInstance      = GetInstance ();
    m_tPropSheetPage.pszTemplate    = MAKEINTRESOURCE(IDD);
    m_tPropSheetPage.dwFlags        = PSP_USECALLBACK;
    m_tPropSheetPage.pfnDlgProc     = PropertyPageDlgProc;
    m_tPropSheetPage.pfnCallback    = PropSheetPageProc;
    m_tPropSheetPage.lParam         = long(this);
    
    m_sbWindowLogSet = FALSE;
    m_id = IDD_TS_USER_CONFIG_EDIT;
}



BOOL TSConfigDlg::AssertClass() const
{
    return m_id == IDD_TS_USER_CONFIG_EDIT;
}

TSConfigDlg::~TSConfigDlg ()
{
    LOGMESSAGE0(_T("TSConfigDlg::~TSConfigDlg ()"));
}

BOOL TSConfigDlg::OnInitDialog(
    HWND hwndDlg,
    WPARAM /* wParam */,
    LPARAM /* lParam */
    )
{
    m_hDlg = hwndDlg;

    // get the user info and initialize dialog class members with it.
    GetUserInfo();

    // initializes the controls.
    InitControls();

    return 1; // non zero since we are not calling setfocus
}


APIERR TSConfigDlg::SetUserInfo ()
{
    APIERR err;
    USERCONFIG UserConfig;

    /* If the object is not 'dirty', no need to save info.
     */
//    if ( !_fDirty )
//        return NERR_Success;

    /* Zero-initialize USERCONFIG structure and copy member variable
     * contents there.
     */
    ZeroMemory( &UserConfig, sizeof(USERCONFIG) );
    MembersToUCStruct( &UserConfig );

    /*
     * Save user's configuration.
     */
    err = RegUserConfigSet( 
            GetServername(),            // servername
            GetUsername(),              // username
            &UserConfig,
            sizeof(UserConfig) 
            );

//  Don't reset 'dirty' flag to behave properly with new RegUserConfig APIs
//  (we might get called twice, just like the UsrMgr objects to, so we want
//   to happily write our our data twice, just like they do)
//    _fDirty = FALSE;

//
//  By not setting _fDirty = FALSE here we try to check the validity of the RemoteWFHomeDir whenever OK is pressed
//  This is because MS used 2 structures to hold its HomeDir, and could compare the two.  We only have one and rely
//  on this dirty flag.  This flag is used in USERPROP_DLG::I_PerformOne_Write(...) and is set in the
//  USER_CONFIG::GetInfo and USER_CONFIG::GetDefaults and USERPROF_DLG_NT::PerformOne()
//
    tDialogData._fWFHomeDirDirty = FALSE;


    return err;

}

APIERR TSConfigDlg::GetUserInfo ()
{
    APIERR err;
    ULONG Length;
    USERCONFIG UserConfig;

    // calll regapi function for getting user configuration
    err = RegUserConfigQuery ( 
            GetServername(),            // servername
            GetUsername(),              // username
            &UserConfig,                // address for userconfig buffer
            sizeof(UserConfig),         // size of buffer
            &Length                     // returned size
            );

    if ( err == NERR_Success )
    {
        ASSERT(Length == sizeof(UserConfig));
    }
    else
    {
        LOGMESSAGE3(_T("RegUserConfigQuery failed for %s\\%s. Error = %ul"), GetServername(), GetUsername(), err);
        LOGMESSAGE0(_T("Getting Deafult user config"));
        
        err = RegDefaultUserConfigQuery( 
            GetServername(),            // servername
            &UserConfig,                // address for userconfig buffer
            sizeof(UserConfig),         // size of buffer
            &Length                     // returned length    
            );

        if (err != NERR_Success)
        {
            LOGMESSAGE3(_T("RegDefaultUserConfigQuery failed for %s\\%s. Error = %ul"), GetServername(), GetUsername(), err);
            
            // maks_todo: must initialize defaults known to us over here.
            return err;
        }
    }
    
    UCStructToMembers( &UserConfig );


    tDialogData._fWFHomeDirDirty = FALSE;
    tDialogData._fDirty = FALSE;
    
    return err;
}



/*******************************************************************

    NAME:       USER_CONFIG::UCStructToMembers

    SYNOPSIS:   Copies a given USERCONFIG structure elements into
                corresponding member variables.

    ENTRY:      pUCStruct - pointer to USERCONFIG structure.

********************************************************************/
void TSConfigDlg::UCStructToMembers( PUSERCONFIG pUCStruct )
{
    ASSERT(pUCStruct);

    tDialogData._fAllowLogon = (BOOL)!pUCStruct->fLogonDisabled;
    tDialogData._ulConnection = pUCStruct->MaxConnectionTime;
    tDialogData._ulDisconnection = pUCStruct->MaxDisconnectionTime;
    tDialogData._ulIdle = pUCStruct->MaxIdleTime;
    _tcscpy(tDialogData._nlsInitialProgram, pUCStruct->InitialProgram);
    _tcscpy(tDialogData._nlsWorkingDirectory, pUCStruct->WorkDirectory );
    tDialogData._fClientSpecified = pUCStruct->fInheritInitialProgram;
    tDialogData._fAutoClientDrives = pUCStruct->fAutoClientDrives;
    tDialogData._fAutoClientLpts = pUCStruct->fAutoClientLpts;
    tDialogData._fForceClientLptDef = pUCStruct->fForceClientLptDef;
    tDialogData._iEncryption = (INT)pUCStruct->MinEncryptionLevel;
    tDialogData._fDisableEncryption = pUCStruct->fDisableEncryption;
    tDialogData._fHomeDirectoryMapRoot = pUCStruct->fHomeDirectoryMapRoot;
    tDialogData._iBroken = (INT)pUCStruct->fResetBroken;
    tDialogData._iReconnect = (INT)pUCStruct->fReconnectSame;
    tDialogData._iCallback = (INT)pUCStruct->Callback;
    _tcscpy(tDialogData._nlsPhoneNumber, pUCStruct->CallbackNumber );
    tDialogData._iShadow = (INT)pUCStruct->Shadow;
    _tcscpy(tDialogData._nlsNWLogonServer, pUCStruct->NWLogonServer );
    _tcscpy(tDialogData._nlsWFProfilePath, pUCStruct->WFProfilePath );
    _tcscpy(tDialogData._nlsWFHomeDir, pUCStruct->WFHomeDir );
    _tcscpy(tDialogData._nlsWFHomeDirDrive, pUCStruct->WFHomeDirDrive);

}


/*******************************************************************

    NAME:       USER_CONFIG::MembersToUCStruct

    SYNOPSIS:   Copies member variables into a given USERCONFIG
                structure elements.

    ENTRY:      pUCStruct - pointer to USERCONFIG structure.

********************************************************************/

void TSConfigDlg::MembersToUCStruct( PUSERCONFIG pUCStruct ) const
{
    ASSERT(pUCStruct);

    pUCStruct->fLogonDisabled = !tDialogData._fAllowLogon;
    pUCStruct->MaxConnectionTime = tDialogData._ulConnection;
    pUCStruct->MaxDisconnectionTime = tDialogData._ulDisconnection;
    pUCStruct->MaxIdleTime = tDialogData._ulIdle;
    _tcscpy( pUCStruct->InitialProgram, tDialogData._nlsInitialProgram);
    _tcscpy( pUCStruct->WorkDirectory, tDialogData._nlsWorkingDirectory);
    pUCStruct->fInheritInitialProgram = tDialogData._fClientSpecified;
    pUCStruct->fAutoClientDrives = tDialogData._fAutoClientDrives;
    pUCStruct->fAutoClientLpts = tDialogData._fAutoClientLpts;
    pUCStruct->fForceClientLptDef = tDialogData._fForceClientLptDef;
    pUCStruct->MinEncryptionLevel = (BYTE)tDialogData._iEncryption;
    pUCStruct->fDisableEncryption = tDialogData._fDisableEncryption;
    pUCStruct->fHomeDirectoryMapRoot = tDialogData._fHomeDirectoryMapRoot;
    pUCStruct->fResetBroken = tDialogData._iBroken;
    pUCStruct->fReconnectSame = tDialogData._iReconnect;
    pUCStruct->Callback = (CALLBACKCLASS)tDialogData._iCallback;
    _tcscpy( pUCStruct->CallbackNumber, tDialogData._nlsPhoneNumber);
    pUCStruct->Shadow = (SHADOWCLASS)tDialogData._iShadow;
    _tcscpy( pUCStruct->NWLogonServer, tDialogData._nlsNWLogonServer);
    _tcscpy( pUCStruct->WFProfilePath, tDialogData._nlsWFProfilePath);
    _tcscpy( pUCStruct->WFHomeDir, tDialogData._nlsWFHomeDir);
    _tcscpy( pUCStruct->WFHomeDirDrive, tDialogData._nlsWFHomeDirDrive);
}

BOOL TSConfigDlg::OnNotify (WPARAM wParam, LPARAM lParam)
{
    int idCtrl = (int) wParam; 
    NMHDR *pnmh = (LPNMHDR) lParam; 

//    typedef struct tagNMHDR {     
//        HWND hwndFrom;     
//        UINT idFrom;     
//        UINT code; 
//    } NMHDR; 

    ASSERT(pnmh);
    switch(pnmh->code)
    {
        case PSN_KILLACTIVE:
            LOGMESSAGE0(_T("Its KillActive Notification"));
            
            if (VerifyChanges())
                // verify passed, allow the page to lose the activation
                SetWindowLong(GetDlgHandle(), DWL_MSGRESULT, FALSE);
            else
                // no verify failed, prevent the page from losing the activation
                SetWindowLong(GetDlgHandle(), DWL_MSGRESULT, TRUE);;

            break;

        case PSN_APPLY:
            LOGMESSAGE0(_T("Its Apply Notification"));
            ApplyChanges();
            break;

        case PSN_RESET:
            // cancel changes.
            LOGMESSAGE0(_T("Its Apply Reset"));
            break;
            
        default:
            break;

    }

    return 1;

}

BOOL TSConfigDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    
    WORD wNotifyCode = HIWORD(wParam); // notification code
    WORD wID = LOWORD(wParam);         // item, control, or accelerator identifier 
    HWND hwndCtl = (HWND) lParam;      // handle of control  
    
    //if (wNotifyCode == 0 || wNotifyCode == 1)
     //   return 1;

    // dispatch the command messages accordingly.
    switch(wID)
    {
    case IDC_UCE_ALLOWLOGON:
        ALLOWLOGONEvent(wNotifyCode);
        break;

    case IDC_UCE_CONNECTION_NONE:
        CONNECTION_NONEEvent(wNotifyCode);
        break;

    case IDC_UCE_DISCONNECTION_NONE:
        DISCONNECTION_NONEEvent(wNotifyCode);
        break;

    case IDC_UCE_IDLE_NONE:
        IDLE_NONEEvent(wNotifyCode);
        break;

    case IDC_UCE_INITIALPROGRAM_INHERIT:
        INITIALPROGRAM_INHERITEvent(wNotifyCode);
        break;

    case IDC_UCE_SECURITY_DISABLEAFTERLOGON:
        SECURITY_DISABLEAFTERLOGONEvent(wNotifyCode);
        break;

    default:
        break;

    }
    
    return 1;   // since we do not process message.
}

BOOL TSConfigDlg::InitControls ()
{
    TCHAR str[SIZE_SMALL_STRING_BUFFER];

    
    struct 
    {
        UINT uiControlID;
        UINT uiNoOfStrings;
        UINT auiStringList[7];

    } atListControls[] =
    { 
        { 
            IDC_UCE_SECURITY_ENCRYPT,
            2,
            {
                IDS_UCE_ENCRYPT_NONE,
                IDS_UCE_ENCRYPT_LEVEL1,
            }
        },
        {
            IDC_UCE_BROKEN,
            2,
            {
                IDS_UCE_BROKEN_DISCONNECT,
                IDS_UCE_BROKEN_RESET,
            }
        },
        {
            IDC_UCE_RECONNECT,
            2,
            {
                IDS_UCE_RECONNECT_ANY,
                IDS_UCE_RECONNECT_PREVIOUS,
            }
        },
        {
            IDC_UCE_CALLBACK,
            3,
            {
                IDS_UCE_CALLBACK_DISABLE,
                IDS_UCE_CALLBACK_ROVING,
                IDS_UCE_CALLBACK_FIXED,
            }
        },
        {
            IDC_UCE_SHADOW,
            5,
            {
                IDS_UCE_SHADOW_DISABLE,
                IDS_UCE_SHADOW_INPUT_NOTIFY,
                IDS_UCE_SHADOW_INPUT_NONOTIFY,
                IDS_UCE_SHADOW_NOINPUT_NOTIFY,
                IDS_UCE_SHADOW_NOINPUT_NONOTIFY,
            }
        }
    };

    // for each list/combo box control
    for (int j = 0; j < sizeof(atListControls)/sizeof(atListControls[0]); j++)
    {
        // add all the strings specified for the control
        for (UINT i = 0; i < atListControls[j].uiNoOfStrings; i++)
        {
            DWORD dwSize = LoadString(
                GetInstance (), 
                atListControls[j].auiStringList[i],
                str,
                SIZE_SMALL_STRING_BUFFER);
        
            ASSERT(dwSize != 0 && dwSize <= SIZE_SMALL_STRING_BUFFER - 1);

            SendDlgItemMessage(
                GetDlgHandle(), 
                atListControls[j].uiControlID, 
                CB_ADDSTRING, 
                0, 
                LPARAM(str));
        }
    }

    // we dont want tristate buttons for now
    // as we are not supporting multipal users
    // lets make all the controls no tristate.
    int aCheckBoxes[] =
    {
        IDC_UCE_ALLOWLOGON,
        IDC_UCE_CONNECTION_NONE,
        IDC_UCE_DISCONNECTION_NONE,
        IDC_UCE_IDLE_NONE,
        IDC_UCE_INITIALPROGRAM_INHERIT,
        IDC_UCE_SECURITY_DISABLEAFTERLOGON
    };

    for (int i = 0; i < sizeof(aCheckBoxes)/sizeof(aCheckBoxes[0]); i++)
    {
        HWND hControlWnd = GetDlgItem(GetDlgHandle(), aCheckBoxes[i]);
        ASSERT(hControlWnd);

        //DWORD dwStyle = GetWindowLong(hControlWnd, GWL_STYLE);
        //dwStyle = dwStyle & ~BS_3STATE;

        SendMessage (hControlWnd, BM_SETSTYLE, LOWORD(BS_AUTOCHECKBOX), MAKELPARAM(0, 0));
    }


    // set text limit for the edit boxes.
    // EM_SETLIMITTEXT
    // wParam = (WPARAM) cbMax;    // new text limits, in bytes
    // lParam = 0;                 // not used, must be zero


    struct
    {
        UINT uiEditControlid;
        UINT uiLimitText;
    } atTextLimits[] =
    {
        {IDC_UCE_CONNECTION,    CONNECTION_TIME_DIGIT_MAX},
        {IDC_UCE_DISCONNECTION, DISCONNECTION_TIME_DIGIT_MAX},
        {IDC_UCE_IDLE,          IDLE_TIME_DIGIT_MAX},
        {IDC_UCE_INITIALPROGRAM_COMMANDLINE, MAX_INIT_PROGRAM_SIZE},
        {IDC_UCE_INITIALPROGRAM_WORKINGDIRECTORY, MAX_INIT_DIR_SIZE}
    };


    for (i = 0; i < sizeof(atTextLimits)/sizeof(atTextLimits[0]); i++)
    {
        HWND hControlWnd = GetDlgItem(GetDlgHandle(), atTextLimits[i].uiEditControlid);
        ASSERT(hControlWnd);

        //DWORD dwStyle = GetWindowLong(hControlWnd, GWL_STYLE);
        //dwStyle = dwStyle & ~BS_3STATE;
        SendMessage (hControlWnd, EM_SETLIMITTEXT, atTextLimits[i].uiLimitText, MAKELPARAM(0, 0));
    }


    return MembersToControls();

}

BOOL TSConfigDlg::VerifyChanges ()
{
    // do the necessary varification here.

    // if data entered is good return TRUE
    // otherwise display message and return FALSE

    TDialogData tTemp;
    return ControlsToMembers(&tTemp);
}

BOOL TSConfigDlg::ApplyChanges ()
{
    ASSERT(VerifyChanges());

    // control to members fails if the data is controls is bad.
    // but since we have varified the changes before getting call to apply changes
    // it must pass.
    VERIFY( ControlsToMembers(&tDialogData) );
    SetUserInfo();

    return TRUE;
}


BOOL TSConfigDlg::MembersToControls ()
{
    VERIFY( SetAllowLogon ( tDialogData._fAllowLogon ));
    VERIFY( SetConnectionTimeOut( tDialogData._ulConnection ));
    VERIFY( SetDisConnectionTimeOut( tDialogData._ulDisconnection ));
    VERIFY( SetIdleTimeOut( tDialogData._ulIdle ));
    VERIFY( SetCommandLineAndWorkingDirectory(tDialogData._fClientSpecified, tDialogData._nlsWorkingDirectory, tDialogData._nlsInitialProgram));
    VERIFY( SetSecurity(tDialogData._iEncryption, tDialogData._fDisableEncryption));
    VERIFY( SetBrokenConnectionOption(tDialogData._iBroken));
    VERIFY( SetReconnectDisconnection(tDialogData._iReconnect));
    VERIFY( SetCallBackOptonAndPhoneNumber(tDialogData._iCallback, tDialogData._nlsPhoneNumber));
    VERIFY( SetShadowing(tDialogData._iShadow));

    return TRUE;
}

BOOL TSConfigDlg::ControlsToMembers (TDialogData *pDlgData)
{
    ASSERT(pDlgData);
    if ( !GetAllowLogon (&pDlgData->_fAllowLogon))
        return FALSE;
    if ( !GetConnectionTimeOut(&pDlgData->_ulConnection))
        return FALSE;
    if ( !GetDisConnectionTimeOut(&pDlgData->_ulDisconnection))
        return FALSE;
    if ( !GetIdleTimeOut(&pDlgData->_ulIdle))
        return FALSE;
    if ( !GetCommandLineAndWorkingDirectory(&pDlgData->_fClientSpecified, pDlgData->_nlsWorkingDirectory, pDlgData->_nlsInitialProgram))
        return FALSE;
    if ( !GetSecurity(&pDlgData->_iEncryption, &pDlgData->_fDisableEncryption))
        return FALSE;
    if ( !GetBrokenConnectionOption(&pDlgData->_iBroken))
        return FALSE;
    if ( !GetReconnectDisconnection(&pDlgData->_iReconnect))
        return FALSE;
    if ( !GetCallBackOptonAndPhoneNumber(&pDlgData->_iCallback, pDlgData->_nlsPhoneNumber))
        return FALSE;
    if ( !GetShadowing(&pDlgData->_iShadow))
        return FALSE;

    return TRUE;
}


BOOL TSConfigDlg::GetAllowLogon (BOOL *pbAllowLogon)
{
    ASSERT(pbAllowLogon);
    *pbAllowLogon = IsChecked(IDC_UCE_ALLOWLOGON);

    return TRUE;
}

BOOL TSConfigDlg::SetAllowLogon (BOOL bAllowLogon)
{
    SetCheck(IDC_UCE_ALLOWLOGON, bAllowLogon);
    return TRUE;
}


BOOL TSConfigDlg::GetConnectionTimeOut(ULONG *pValue)
{

    ASSERT(pValue);
    BOOL bResult = FALSE;

    if (IsChecked(IDC_UCE_CONNECTION_NONE))
    {
        // maks_todo: assert that edit control is disabled.
        // maks_todo : assert that edit control has value == 0
        *pValue = 0;
        bResult = TRUE;

    }
    else
    {
        // last parameter tells if the value is signed or unsigned.
        // we ask it not to look for - sign.
        // maks_todo:BUT WE MAY WANT TO CHNAGE THIS
        *pValue = GetDlgItemInt(GetDlgHandle(), IDC_UCE_CONNECTION, &bResult, FALSE);

        if (!bResult || *pValue == 0 || *pValue > 71582)
        {
            MessageBox(GetDlgHandle(), _T("The Connection Timeout value must 1 to 71582 minutes. Check the 'No Timeout' if you wish to specify no connection timeout"), _T("Termainl Server Properties"), MB_OK);
            bResult = FALSE;
        }
    
    }

    // users talk in terms of mins.
    // we talk about msecs.
    *pValue = *pValue * TIME_RESOLUTION;


    return bResult;
}

BOOL TSConfigDlg::SetConnectionTimeOut(ULONG iValue)
{
    // users talk in terms of mins.
    // we talk about msecs.
    iValue = iValue / TIME_RESOLUTION;

    SetCheck(IDC_UCE_CONNECTION_NONE, iValue == 0);
    EnableControl(IDC_UCE_CONNECTION, iValue != 0);
    SetDlgItemInt(GetDlgHandle(), IDC_UCE_CONNECTION, iValue, TRUE); // maks_todo : look into last param.

    return TRUE;
}


BOOL TSConfigDlg::GetDisConnectionTimeOut(ULONG *pValue)
{
    ASSERT(pValue);
    BOOL bResult = FALSE;

    if (IsChecked(IDC_UCE_DISCONNECTION_NONE))
    {
        // maks_todo: assert that edit control is disabled.
        // maks_todo : assert that edit control has value == 0
        *pValue = 0;
        bResult = TRUE;

    }
    else
    {
        // last parameter tells if the value is signed or unsigned.
        // we ask it not to look for - sign.
        // maks_todo:BUT WE MAY WANT TO CHNAGE THIS
        *pValue = GetDlgItemInt(GetDlgHandle(), IDC_UCE_DISCONNECTION, &bResult, FALSE);
        
        if (!bResult || *pValue == 0 || *pValue > 71582)
        {
            MessageBox(GetDlgHandle(), _T("The Disconnection Timeout value must 1 to 71582 minutes. Check the 'No Timeout' if you wish to specify no Disconnection timeout"), _T("Termainl Server Properties"), MB_OK);
            bResult = FALSE;
        }

    }

    *pValue = *pValue * TIME_RESOLUTION;


    return bResult;
}

BOOL TSConfigDlg::SetDisConnectionTimeOut(ULONG iValue)
{
    // users talk in terms of mins.
    // we talk about msecs.
    iValue = iValue / TIME_RESOLUTION;

    SetCheck(IDC_UCE_DISCONNECTION_NONE, iValue == 0);

    EnableControl(IDC_UCE_DISCONNECTION, iValue != 0);
    SetDlgItemInt(GetDlgHandle(), IDC_UCE_DISCONNECTION, iValue, TRUE); // maks_todo : look into last param.

    return TRUE;

}


BOOL TSConfigDlg::GetIdleTimeOut(ULONG *pValue)
{
    ASSERT(pValue);
    BOOL bResult = FALSE;

    if (IsChecked(IDC_UCE_IDLE_NONE))
    {
        // maks_todo: assert that edit control is disabled.
        // maks_todo : assert that edit control has value == 0
        *pValue = 0;
        bResult = TRUE;
        
    }
    else
    {
        // last parameter tells if the value is signed or unsigned.
        // we ask it not to look for - sign.
        // maks_todo:BUT WE MAY WANT TO CHNAGE THIS
        *pValue = GetDlgItemInt(GetDlgHandle(), IDC_UCE_IDLE, &bResult, FALSE);

        if (!bResult || *pValue == 0 || *pValue > 71582)
        {
            MessageBox(GetDlgHandle(), _T("The Idle Timeout value must 1 to 71582 minutes. Check the 'No Timeout' if you wish to specify no Idle timeout"), _T("Termainl Server Properties"), MB_OK);
            bResult = FALSE;
        }

    }

    *pValue = *pValue * TIME_RESOLUTION;


    return bResult;
}

BOOL TSConfigDlg::SetIdleTimeOut(ULONG iValue)
{
    // users talk in terms of mins.
    // we talk about msecs.
    iValue = iValue / TIME_RESOLUTION;

    SetCheck(IDC_UCE_IDLE_NONE, iValue == 0);
    EnableControl(IDC_UCE_IDLE, iValue != 0);
    SetDlgItemInt(GetDlgHandle(), IDC_UCE_IDLE, iValue, TRUE); // maks_todo : look into last param.

    return TRUE;
}

BOOL TSConfigDlg::SetCommandLineAndWorkingDirectory(BOOL bUserInherited, LPCTSTR dir, LPCTSTR cmd)
{
    ASSERT(dir);
    ASSERT(cmd);

    if (bUserInherited)
        SetCheck(IDC_UCE_INITIALPROGRAM_INHERIT, bUserInherited);
    
    // enable/disable edits according to check box status.
    EnableControl(IDL_UCE_INITIALPROGRAM_COMMANDLINE1, !bUserInherited);
    EnableControl(IDL_UCE_INITIALPROGRAM_WORKINGDIRECTORY1, !bUserInherited);
    EnableControl(IDC_UCE_INITIALPROGRAM_COMMANDLINE, !bUserInherited);
    EnableControl(IDC_UCE_INITIALPROGRAM_WORKINGDIRECTORY, !bUserInherited);

    // set the text into edits.
    SetDlgItemText(GetDlgHandle(), IDC_UCE_INITIALPROGRAM_COMMANDLINE, cmd);
    SetDlgItemText(GetDlgHandle(), IDC_UCE_INITIALPROGRAM_WORKINGDIRECTORY, dir);

    return TRUE;
}

BOOL TSConfigDlg::GetCommandLineAndWorkingDirectory(BOOL *pbUserInherited, LPTSTR dir, LPTSTR cmd)
{
    ASSERT(dir);
    ASSERT(cmd);

    *pbUserInherited = IsChecked(IDC_UCE_INITIALPROGRAM_INHERIT);
    
    // set the text into edits.
    GetDlgItemText(GetDlgHandle(), IDC_UCE_INITIALPROGRAM_COMMANDLINE, cmd, MAX_INIT_PROGRAM_SIZE);
    GetDlgItemText(GetDlgHandle(), IDC_UCE_INITIALPROGRAM_WORKINGDIRECTORY, dir, MAX_INIT_DIR_SIZE);

    return TRUE;
}


BOOL TSConfigDlg::SetSecurity(int iLevel, BOOL bDisableAfterLogon)
{
    SetComboCurrentSel(IDC_UCE_SECURITY_ENCRYPT, iLevel);
    SetCheck(IDC_UCE_SECURITY_DISABLEAFTERLOGON, bDisableAfterLogon);
    return TRUE;
}

BOOL TSConfigDlg::GetSecurity(int *piLevel, BOOL *pbDisableAfterLogon)
{
    ASSERT(piLevel);
    ASSERT(pbDisableAfterLogon);

    *piLevel = GetComboCurrentSel(IDC_UCE_SECURITY_ENCRYPT);
    *pbDisableAfterLogon = IsChecked(IDC_UCE_SECURITY_DISABLEAFTERLOGON);
    return TRUE;
}

BOOL TSConfigDlg::SetBrokenConnectionOption(int iLevel)
{
    SetComboCurrentSel(IDC_UCE_BROKEN, iLevel);
    return TRUE;
}

BOOL TSConfigDlg::GetBrokenConnectionOption(int *piLevel)
{
    *piLevel = GetComboCurrentSel(IDC_UCE_BROKEN);
    return TRUE;
}

BOOL TSConfigDlg::SetReconnectDisconnection(int iLevel)
{
    
    SetComboCurrentSel(IDC_UCE_RECONNECT, iLevel);
    return TRUE;
}

BOOL TSConfigDlg::GetReconnectDisconnection(int *piLevel)
{
    
    *piLevel = GetComboCurrentSel(IDC_UCE_RECONNECT);
    return TRUE;
}

BOOL TSConfigDlg::SetCallBackOptonAndPhoneNumber(int iCallBack, LPCTSTR PhoneNo)
{
    SetComboCurrentSel(IDC_UCE_CALLBACK, iCallBack);
    SetDlgItemText(GetDlgHandle(), IDC_UCE_PHONENUMBER, PhoneNo);

    // enable/disable phone # accordingly.
    EnableControl(IDL_UCE_PHONENUMBER, iCallBack != 0);
    EnableControl(IDC_UCE_PHONENUMBER, iCallBack != 0);

    return TRUE;
}

BOOL TSConfigDlg::GetCallBackOptonAndPhoneNumber(int *piCallBack, LPTSTR PhoneNo)
{
    *piCallBack = GetComboCurrentSel(IDC_UCE_CALLBACK);
    GetDlgItemText(GetDlgHandle(), IDC_UCE_PHONENUMBER, PhoneNo, MAX_PHONENO_SIZE);

    return TRUE;
}

BOOL TSConfigDlg::SetShadowing(int iLevel)
{
    SetComboCurrentSel(IDC_UCE_SHADOW, iLevel);
    return TRUE;
}

BOOL TSConfigDlg::GetShadowing(int *piLevel)
{
    *piLevel = GetComboCurrentSel(IDC_UCE_SHADOW);
    return TRUE;
}


// Utility function.
DWORD wchar2TCHAR(TCHAR *dest, const WCHAR *src)
{
    ASSERT(dest && src);

#ifdef UNICODE
    _tcscpy(dest, src);
#else
    DWORD count;
    count = WideCharToMultiByte(CP_ACP,
                                0,
                                src,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);
    
    return WideCharToMultiByte(CP_ACP,
                               0,
                               src,
                               -1,
                               dest,
                               count,
                               NULL,
                               NULL);

#endif
    return _tcslen(dest);
}


BOOL TSConfigDlg::ALLOWLOGONEvent(WORD wNotifyCode)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
        break;
    default:
        break;
    }

    return TRUE;
}

BOOL TSConfigDlg::CONNECTION_NONEEvent(WORD wNotifyCode)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
        EnableControl(IDC_UCE_CONNECTION, !IsChecked(IDC_UCE_CONNECTION_NONE));

        //EnableControl(IDC_UCE_CONNECTION, iValue != 0);
        break;
    default:
        break;
    }

    return TRUE;
}

BOOL TSConfigDlg::DISCONNECTION_NONEEvent(WORD wNotifyCode)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
        EnableControl(IDC_UCE_DISCONNECTION, !IsChecked(IDC_UCE_DISCONNECTION_NONE));
        break;
    default:
        break;
    }

    return TRUE;
}

BOOL TSConfigDlg::IDLE_NONEEvent(WORD wNotifyCode)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
        EnableControl(IDC_UCE_IDLE, !IsChecked(IDC_UCE_IDLE_NONE));
        break;
    default:
        break;
    }

    return TRUE;
}

BOOL TSConfigDlg::INITIALPROGRAM_INHERITEvent(WORD wNotifyCode)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
        EnableControl(IDL_UCE_INITIALPROGRAM_COMMANDLINE1,
            !IsChecked(IDC_UCE_INITIALPROGRAM_INHERIT));

        EnableControl(IDL_UCE_INITIALPROGRAM_WORKINGDIRECTORY1,
            !IsChecked(IDC_UCE_INITIALPROGRAM_INHERIT));

        EnableControl(IDC_UCE_INITIALPROGRAM_COMMANDLINE,
            !IsChecked(IDC_UCE_INITIALPROGRAM_INHERIT));

        EnableControl(IDC_UCE_INITIALPROGRAM_WORKINGDIRECTORY,
            !IsChecked(IDC_UCE_INITIALPROGRAM_INHERIT));

        break;
    default:
        break;
    }

    return TRUE;
}

BOOL TSConfigDlg::SECURITY_DISABLEAFTERLOGONEvent(WORD /* wNotifyCode */ )
{
    return TRUE;
}


BOOL TSConfigDlg::IsChecked(UINT controlId)
{
    ASSERT(GetDlgItem(GetDlgHandle(), controlId));
    return BST_CHECKED == SendDlgItemMessage(GetDlgHandle(), controlId, BM_GETCHECK, 0, 0);
}

void TSConfigDlg::SetCheck(UINT controlId, BOOL bCheck)
{
    ASSERT(GetDlgItem(GetDlgHandle(), controlId));
    SendDlgItemMessage(GetDlgHandle(), controlId, BM_SETCHECK, bCheck ? BST_CHECKED : BST_UNCHECKED, 0);
}

void TSConfigDlg::EnableControl(UINT controlId, BOOL bEnable)
{
    ASSERT(GetDlgItem(GetDlgHandle(), controlId));
    EnableWindow(GetDlgItem(GetDlgHandle(), controlId), bEnable);
}

int TSConfigDlg::GetComboCurrentSel(UINT controlId)
{
    ASSERT(GetDlgItem(GetDlgHandle(), controlId));
    return SendDlgItemMessage(GetDlgHandle(), controlId, CB_GETCURSEL, 0, 0);
}

void TSConfigDlg::SetComboCurrentSel(UINT controlId, int iSel)
{
    ASSERT(GetDlgItem(GetDlgHandle(), controlId));
    SendDlgItemMessage(GetDlgHandle(), controlId, CB_SETCURSEL, iSel, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tscert\tscrtvfy\tscrtvfy.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <wincrypt.h>
#include <imagehlp.h>

#define MemAlloc malloc
#define MemFree free

#ifdef SIGN_DEBUG
#define SIGN_DBGP(x) printf x
#else // SIGN_DEBUG
#define SIGN_DBGP(x)
#endif // SIGN_DEBUG

#include "../inc/pubblob.h"    // needed by certvfy.inc
#include "../inc/certvfy.inc"  // VerifyFile()

RTL_CRITICAL_SECTION VfyLock;

/*****************************************************************************/
void _cdecl main(int argc, char *argv[])
{
    WCHAR szSourceFile[ MAX_PATH + 1];
    DWORD dwBc;

    if ( argc != 2 ) {
        printf( "Usage: %s PE_File_Name\n", argv[0] );
        exit(1);
    }

    RtlMultiByteToUnicodeN( szSourceFile, sizeof(szSourceFile), &dwBc,
        argv[1], (strlen(argv[1]) + 1) ); 

    RtlInitializeCriticalSection( &VfyLock );

    if( !VerifyFile( szSourceFile, &VfyLock ) ) {
	printf("Error verifying file!\n");
	exit(1);
    }

    printf("Verification successful.\n");
    exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\interfaces.h ===
// Interfaces.h: Definition of the TSUserExInterfaces class
//
//////////////////////////////////////////////////////////////////////

#if !defined(__TSUSEREX_INTERFACES__)
#define __TSUSEREX_INTERFACES__



#include "resource.h"
#include "tsusrsht.h"
//#include "configdlg.h"


#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// #include "ConfigDlg.h"    // for ConfigDlg

class TSUserExInterfaces :
        public IExtendPropertySheet,
        public ISnapinHelp,
		public IShellExtInit,
		public IShellPropSheetExt,
#ifdef _RTM_

        public ISnapinAbout,
#endif

        public CComObjectRoot,
        public CComCoClass<TSUserExInterfaces, &CLSID_TSUserExInterfaces>
{
public:

    TSUserExInterfaces();
    ~TSUserExInterfaces();


BEGIN_COM_MAP(TSUserExInterfaces)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(ISnapinHelp)
		COM_INTERFACE_ENTRY(IShellExtInit)
		COM_INTERFACE_ENTRY(IShellPropSheetExt)
#ifdef _RTM_

        COM_INTERFACE_ENTRY(ISnapinAbout)
#endif

END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_USEREX_INTERFACES)

    //
    // IExtendPropertySheet
    //

    STDMETHOD(  CreatePropertyPages )(
        LPPROPERTYSHEETCALLBACK lpProvider,     // pointer to the callback interface
        LONG_PTR handle,                            // handle for routing notification
        LPDATAOBJECT lpIDataObject              // pointer to the data object);
        );

    STDMETHOD(  QueryPagesFor   )(
        LPDATAOBJECT lpDataObject               // pointer to the data object
        );
    //
    // ISnapinHelp
    //

    STDMETHOD( GetHelpTopic )(
        LPOLESTR * 
        );

	//
	// IShellExtInit
	//

	STDMETHOD( Initialize )(
		LPCITEMIDLIST pidlFolder,
		LPDATAOBJECT lpdobj,
		HKEY hkeyProgID
	);
	
	//
	// IShellPropSheetExt
	//

	STDMETHOD( AddPages )(
		LPFNADDPROPSHEETPAGE lpfnAddPage,
		LPARAM lParam
	);


	STDMETHOD( ReplacePage )(
		UINT uPageID,
		LPFNADDPROPSHEETPAGE lpfnReplacePage,
		LPARAM lParam
   );






#ifdef _RTM_

    //
    // ISnapinAbout
    //
    STDMETHOD( GetSnapinDescription )( 
            LPOLESTR * );
        
    STDMETHOD( GetProvider )( 
            LPOLESTR * );
        
    STDMETHOD( GetSnapinVersion )( 
            LPOLESTR *lpVersion );
        
    STDMETHOD( GetSnapinImage )( 
            HICON *hAppIcon );
        
    STDMETHOD( GetStaticFolderImage )( 
            /* [out] */ HBITMAP *,
            /* [out] */ HBITMAP *,
            /* [out] */ HBITMAP *,
            /* [out] */ COLORREF *);
#endif


private:

    // TSConfigDlg *m_pUserConfigPage;
    CTSUserSheet *m_pTSUserSheet;

	LPDATAOBJECT m_pDsadataobj;	
  

    //ConfigDlg  *m_pMergedPage;
};


#endif // __TSUSEREX_INTERFACES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\logmsg.cpp ===
// LogMsg.cpp: implementation of the LogMsg class.
//
//////////////////////////////////////////////////////////////////////
#define _LOGMESSAGE_CPP_
#include "stdafx.h"
#include <windows.h>
#include <tchar.h>
#include <time.h>
#include <stdio.h>
#include "LogMsg.h"


DWORD TCharStringToAnsiString(const TCHAR *tsz ,char *asz);


// maks_todo: is there any standard file to be used for  logs.
//////////////////////////////////////////////////////////////////////
// constants
//////////////////////////////////////////////////////////////////////
const UINT        LOG_ENTRY_SIZE             = 1024;
const UINT        S_SIZE                     = 1024;
LPCTSTR           UNINITIALIZED              = _T("uninitialized");


//////////////////////////////////////////////////////////////////////
// globals. 
////////////////////////////////////////////////////////////////////////
LogMsg thelog(26);  // used by LOGMESSAGE macros.


//////////////////////////////////////////////////////////////////////
// Construction / destruction
////////////////////////////////////////////////////////////////////////
LogMsg::LogMsg(int value)
{
    m_temp = value;
    _tcscpy(m_szLogFile, UNINITIALIZED);
}

LogMsg::~LogMsg()
{
    LOGMESSAGE0(_T("********Terminating Log"));
}

/*--------------------------------------------------------------------------------------------------------
* DWORD LogMsg::Init(LPCTSTR szLogFile, LPCTSTR szLogModule)
* creates/opens the szLogFile for logging messages.
* must be called befour using the Log Function.
* -------------------------------------------------------------------------------------------------------*/
DWORD LogMsg::Init(LPCTSTR szLogFile, LPCTSTR szLogModule)
{
    ASSERT(szLogFile);
    ASSERT(szLogModule);
    
    // dont call this function twice.
    // maks_todo:why is the constructor not getting called?
    // maks_todo:enable this assert.
    //ASSERT(_tcscmp(m_szLogFile, UNINITIALIZED) == 0);

    ASSERT(_tcslen(szLogFile) < MAX_PATH);
    ASSERT(_tcslen(szLogModule) < MAX_PATH);

    _tcscpy(m_szLogFile, szLogFile);
    _tcscpy(m_szLogModule, szLogModule);

    
    TCHAR   time[S_SIZE];
    TCHAR   date[S_SIZE];
    
    _tstrdate(date);
    _tstrtime(time);

    TCHAR output_unicode[LOG_ENTRY_SIZE];
    _stprintf(output_unicode, _T("\r\n\r\n*******Initializing Message Log:%s %s %s\r\n\r\n"), m_szLogModule, date, time);
    ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);

    char output[LOG_ENTRY_SIZE];
    TCharStringToAnsiString(output_unicode, output);


    // open the log file
    HANDLE hfile = CreateFile(m_szLogFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        hfile = CreateFile(m_szLogFile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        DWORD  bytes;
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }

    return GetLastError();
}


/*--------------------------------------------------------------------------------------------------------
* void log(TCHAR *fmt, ...)
* writes message to the log file. (LOGFILE)
* -------------------------------------------------------------------------------------------------------*/
DWORD LogMsg::Log(LPCTSTR file, int line, TCHAR *fmt, ...)
{
    ASSERT(file);
    ASSERT(fmt);
    ASSERT(_tcscmp(m_szLogFile, UNINITIALIZED) != 0);
    
     // write down file and line info into the buffer..
    TCHAR   fileline_unicode[LOG_ENTRY_SIZE];
    _stprintf(fileline_unicode, _T("%s:File:%s Line:%d:"), m_szLogModule, file, line);

    char fileline[LOG_ENTRY_SIZE];
    TCharStringToAnsiString(fileline_unicode, fileline);

    
    
    // create the output string
    TCHAR  output_unicode[LOG_ENTRY_SIZE];
    va_list vaList;
    va_start(vaList, fmt);
    _vstprintf(output_unicode, fmt, vaList);
    va_end(vaList);

    ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);

    char   output[LOG_ENTRY_SIZE];
    TCharStringToAnsiString(output_unicode, output);

    ASSERT(strlen(output) < LOG_ENTRY_SIZE);

    
    // open the log file
    HANDLE hfile = CreateFile(m_szLogFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        
        DWORD  bytes;
        const LPCSTR CRLF = "\r\n";
        WriteFile(hfile, fileline, strlen(fileline) * sizeof(char), &bytes, NULL);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        WriteFile(hfile, CRLF, strlen(CRLF) * sizeof(char), &bytes, NULL);
        
        CloseHandle(hfile);
    }

    return GetLastError();
}

/*--------------------------------------------------------------------------------------------------------
* TCharStringToAnsiString(const TCHAR *tsz ,char *asz)
* converts the given TCHAR * to char *
* -------------------------------------------------------------------------------------------------------*/

DWORD TCharStringToAnsiString(const TCHAR *tsz ,char *asz)
{
    DWORD count;

    ASSERT(tsz && asz);

#ifdef UNICODE
    count = WideCharToMultiByte(CP_ACP,
                                0,
                                tsz,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!count || count > S_SIZE)
        return count;

    return WideCharToMultiByte(CP_ACP,
                               0,
                               tsz,
                               -1,
                               asz,
                               count,
                               NULL,
                               NULL);
#else
    _tcscpy(asz, tsz);
    return _tcslen(asz);
#endif
}



// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\configdlg.h ===
//
// configdlg.h : definition of TSConfigDlg
// the class defines the User Configuration Property page for Termainl Server
//

#if !defined(_TSCONFIGDLG_)
#define _TSCONFIGDLG_

#include "resource.h"
#include <winsta.h>

typedef LONG    APIERR; // err


#define SIZE_MAX_SERVERNAME                 256
#define SIZE_MAX_USERNAME                   256
#define SIZE_SMALL_STRING_BUFFER            256
#define MAX_INIT_DIR_SIZE                   256
#define MAX_INIT_PROGRAM_SIZE               256
#define MAX_PHONENO_SIZE                    256

class TSConfigDlg
{

public:

    enum { IDD = IDD_TS_USER_CONFIG_EDIT };

    static BOOL CALLBACK PropertyPageDlgProc( HWND hwndDlg,  UINT uMsg,  WPARAM wParam,  LPARAM lParam  );
    static UINT CALLBACK PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    static BOOL m_sbWindowLogSet;

private:

    // dialog data.
    struct TDialogData
    {
        BOOL        _fDirty;
        TCHAR       _nlsUserName[MAX_PATH];
        TCHAR       _nlsServerName[MAX_PATH];

        BOOL        _fAllowLogon;
        ULONG       _ulConnection;
        ULONG       _ulDisconnection;
        ULONG       _ulIdle;
        TCHAR       _nlsInitialProgram[MAX_INIT_PROGRAM_SIZE+1];
        TCHAR       _nlsWorkingDirectory[MAX_INIT_DIR_SIZE+1];
        BOOL        _fClientSpecified;
        BOOL        _fAutoClientDrives;
        BOOL        _fAutoClientLpts;
        BOOL        _fForceClientLptDef;
        INT         _iEncryption;
        BOOL        _fDisableEncryption;
        BOOL        _fHomeDirectoryMapRoot;
        INT         _iBroken;
        INT         _iReconnect;
        INT         _iCallback;
        TCHAR       _nlsPhoneNumber[MAX_PHONENO_SIZE];
        INT         _iShadow;
        TCHAR       _nlsNWLogonServer[MAX_PATH];
        TCHAR       _nlsWFProfilePath[MAX_PATH];

        TCHAR       _nlsWFHomeDir[MAX_PATH];
        TCHAR       _nlsWFHomeDirDrive[MAX_PATH];
        BOOL        _fWFHomeDirDirty;

    } tDialogData;


public:

             TSConfigDlg        (LPWSTR wMachineName, LPWSTR wUserName);
    virtual  ~TSConfigDlg       ();
   
    BOOL AssertClass() const;
    
    BOOL OnCommand          (WPARAM wParam, LPARAM lParam);
    BOOL OnNotify           (WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog       (HWND hwndDlg, WPARAM wParam, LPARAM lParam);

    

    APIERR GetUserInfo ();
    APIERR SetUserInfo ();
    
    void UCStructToMembers( PUSERCONFIG pUCStruct );
    void MembersToUCStruct( PUSERCONFIG pUCStruct ) const;

    BOOL MembersToControls ();          
    BOOL ControlsToMembers (TDialogData *);
    
    BOOL InitControls ();
    BOOL VerifyChanges ();
    BOOL ApplyChanges ();


public:

    // control helpers.
    inline BOOL IsChecked  (UINT controlId);
    inline void SetCheck   (UINT controlId, BOOL bCheck);
    inline void EnableControl(UINT controlId, BOOL bEnable);
    inline int  GetComboCurrentSel(UINT controlId);
    inline void SetComboCurrentSel(UINT controlId, int iSel);

public : // access class members

    inline PROPSHEETPAGE *GetPSP ()
    {return &m_tPropSheetPage;}

    inline HWND GetDlgHandle () const
    {return m_hDlg;}

    inline LPTSTR GetServername ()
    {return m_Username;}

    inline LPTSTR GetUsername ()
    {return m_Servername;}

private:

    UINT          m_id;
    PROPSHEETPAGE m_tPropSheetPage;
    HWND          m_hDlg;
    TCHAR         m_Username[SIZE_MAX_USERNAME];
    TCHAR         m_Servername[SIZE_MAX_SERVERNAME];


public:
    
    // get/set data to/from dialog box controls.
    BOOL GetAllowLogon (BOOL *pbAllowLogon);
    BOOL SetAllowLogon (BOOL bAllowLogon);
    BOOL GetConnectionTimeOut(ULONG *pValue);
    BOOL SetConnectionTimeOut(ULONG iValue);
    BOOL GetDisConnectionTimeOut(ULONG *pValue);
    BOOL SetDisConnectionTimeOut(ULONG iValue);
    BOOL GetIdleTimeOut(ULONG *pValue);
    BOOL SetIdleTimeOut(ULONG iValue);
    BOOL SetCommandLineAndWorkingDirectory(BOOL bUseInherited, LPCTSTR dir, LPCTSTR cmd);
    BOOL GetCommandLineAndWorkingDirectory(BOOL *pbUseInherited, LPTSTR dir, LPTSTR cmd);
    BOOL SetSecurity(int iLevel, BOOL bDisableAfterLogon);
    BOOL GetSecurity(int *piLevel, BOOL *pbDisableAfterLogon);
    BOOL SetBrokenConnectionOption(int iLevel);
    BOOL GetBrokenConnectionOption(int *piLevel);
    BOOL SetReconnectDisconnection(int iLevel);
    BOOL GetReconnectDisconnection(int *piLevel);
    BOOL SetCallBackOptonAndPhoneNumber(int iCallBack, LPCTSTR PhoneNo);
    BOOL GetCallBackOptonAndPhoneNumber(int *piCallBack, LPTSTR PhoneNo);
    BOOL SetShadowing(int iLevel);
    BOOL GetShadowing(int *piLevel);

public:

    BOOL ALLOWLOGONEvent                    (WORD wNotifyCode);
    BOOL CONNECTION_NONEEvent               (WORD wNotifyCode);
    BOOL IDLE_NONEEvent                     (WORD wNotifyCode);
    BOOL DISCONNECTION_NONEEvent            (WORD wNotifyCode);
    BOOL INITIALPROGRAM_INHERITEvent        (WORD wNotifyCode);
    BOOL SECURITY_DISABLEAFTERLOGONEvent    (WORD wNotifyCode);
/*    
    inline void SetUserName( const TCHAR * pszUserName )
        { 
        ASSERT(pszUserName);
        ASSERT(_tcslen(pszUserName) < MAX_PATH);
        _tcscpy(_nlsUserName, pszUserName); 
        }

    inline VOID SetDirty()
        { _fDirty = TRUE; }

    // member data functions
    inline BOOL QueryAllowLogon() const
        { return _fAllowLogon; }

    inline VOID SetAllowLogon( BOOL fAllowLogon )
      { _fAllowLogon = fAllowLogon; }

    inline ULONG QueryConnection() const
        { return _ulConnection; }

    inline VOID SetConnection( ULONG ulConnection ) 
        { _ulConnection = ulConnection; }

    inline ULONG QueryDisconnection() const
        { return _ulDisconnection; }

    inline VOID SetDisconnection( ULONG ulDisconnection )
        { _ulDisconnection = ulDisconnection; }

    inline ULONG QueryIdle() const
        { return _ulIdle; }

    inline VOID SetIdle( ULONG ulIdle )
        { _ulIdle = ulIdle; }

    inline const TCHAR * QueryInitialProgram() const
        { return (LPCTSTR)_nlsInitialProgram;}

    inline void SetInitialProgram( const TCHAR * pszInitialProgram )
        { 
        ASSERT(pszInitialProgram);
        ASSERT(_tcslen(pszInitialProgram) < MAX_PATH);
        _tcscpy(_nlsInitialProgram, pszInitialProgram);
        }

    inline const TCHAR * QueryWorkingDirectory() const
        { return (LPCTSTR) _nlsWorkingDirectory; }

    inline void SetWorkingDirectory( const TCHAR * pszWorkingDirectory ) 
        { 
        ASSERT(pszWorkingDirectory);
        ASSERT(_tcslen(pszWorkingDirectory) < MAX_PATH);
        _tcscpy(_nlsWorkingDirectory, pszWorkingDirectory);
        }

    inline BOOL QueryClientSpecified() const
        { return _fClientSpecified; }

    inline VOID SetClientSpecified( BOOL fClientSpecified )
        { _fClientSpecified = fClientSpecified; }

    inline BOOL QueryAutoClientDrives() const
        { return _fAutoClientDrives; }

    inline VOID SetAutoClientDrives( BOOL fAutoClientDrives )
        { _fAutoClientDrives = fAutoClientDrives; }

    inline BOOL QueryAutoClientLpts() const
        { return _fAutoClientLpts; }

    inline VOID SetAutoClientLpts( BOOL fAutoClientLpts )
        { _fAutoClientLpts = fAutoClientLpts; }

    inline BOOL QueryForceClientLptDef() const  
        { return _fForceClientLptDef; }
    inline VOID SetForceClientLptDef( BOOL fForceClientLptDef )
        { _fForceClientLptDef = fForceClientLptDef; }

    inline INT QueryEncryption() const
        { return _iEncryption; }

    inline VOID SetEncryption( INT iEncryption )
        { _iEncryption = iEncryption; }

    inline BOOL QueryDisableEncryption() const
        { return _fDisableEncryption; }

    inline VOID SetDisableEncryption( BOOL fDisableEncryption )
        { _fDisableEncryption = fDisableEncryption; }

    inline BOOL QueryHomeDirectoryMapRoot() const
        { return _fHomeDirectoryMapRoot; }

    inline VOID SetHomeDirectoryMapRoot( BOOL fHomeDirectoryMapRoot )
        { _fHomeDirectoryMapRoot = fHomeDirectoryMapRoot; }

    inline INT QueryBroken() const
        { return _iBroken; }

    inline VOID SetBroken( INT iBroken )
        { _iBroken = iBroken; }

    inline INT QueryReconnect() const
        { return _iReconnect; }

    inline VOID SetReconnect( INT iReconnect )
        { _iReconnect = iReconnect; }

    inline INT QueryCallback() const
        { return _iCallback; }

    inline VOID SetCallback( INT iCallback )
        { _iCallback = iCallback; }

    inline const TCHAR * QueryPhoneNumber() const
        { return (LPCTSTR)_nlsPhoneNumber; }

    inline void SetPhoneNumber( const TCHAR * pszPhoneNumber )
        { 
            ASSERT(pszPhoneNumber);
            ASSERT(_tcslen(pszPhoneNumber) < MAX_PATH);
            _tcscpy(_nlsPhoneNumber, pszPhoneNumber);
        }

    inline INT QueryShadow() const
        { return _iShadow; }

    inline VOID SetShadow( INT iShadow )
        { _iShadow = iShadow; }

    inline const TCHAR * QueryNWLogonServer() const
        { return (LPCTSTR)_nlsNWLogonServer; }

    inline void SetNWLogonServer( const TCHAR * pszNWLogonServer )
        { 
            ASSERT(pszNWLogonServer);
            ASSERT(_tcslen(pszNWLogonServer) < MAX_PATH);
            _tcscpy(_nlsNWLogonServer, pszNWLogonServer);
        }

    inline const TCHAR * QueryServerName() const
        { return (LPCTSTR)_nlsServerName; }


    inline const TCHAR * QueryWFProfilePath() const
        { return (LPCTSTR)_nlsWFProfilePath; }

    inline void SetWFProfilePath( const TCHAR * pszWFProfilePath )
        { 
            ASSERT(pszWFProfilePath);
            ASSERT(_tcslen(pszWFProfilePath) < MAX_PATH);
            _tcscpy(_nlsWFProfilePath, pszWFProfilePath);
        }

    inline const TCHAR * QueryWFHomeDir() const
        { return (LPCTSTR)_nlsWFHomeDir; }

    inline void SetWFHomeDir( const TCHAR * pszWFHomeDir )
        { 
            ASSERT(pszWFHomeDir);
            ASSERT(_tcslen(pszWFHomeDir) < MAX_PATH);
            _tcscpy(_nlsWFHomeDir, pszWFHomeDir);
        }

    inline const TCHAR * QueryWFHomeDirDrive() const
        { return (LPCTSTR)_nlsWFHomeDirDrive; }

    inline void SetWFHomeDirDrive( const TCHAR * pszWFHomeDirDrive )
        {
            ASSERT(pszWFHomeDirDrive);
            ASSERT(_tcslen(pszWFHomeDirDrive) < MAX_PATH);
            _tcscpy(_nlsWFHomeDirDrive, pszWFHomeDirDrive);
        }

    inline VOID SetWFHomeDirDirty()
        { _fWFHomeDirDirty = TRUE; }

    inline BOOL QueryWFHomeDirDirty() const
        { return _fWFHomeDirDirty; }
*/


};

#endif

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\logmsg.h ===
// LogMsg.h: interface for the LogMsg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_)
#define AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class LogMsg
{

    

private:

    TCHAR m_szLogFile[MAX_PATH];
    TCHAR m_szLogModule[MAX_PATH];
    int m_temp;

public:
	
    
                LogMsg          (int value);
	virtual     ~LogMsg         ();

    DWORD       Init            (LPCTSTR szLogFile, LPCTSTR szLogModule);
    DWORD       Log             (LPCTSTR file, int line, TCHAR *fmt, ...);

 //   static LogMsg GetLogObject();

};

// instantiated in LogMsg.cpp.
#ifndef _LOGMESSAGE_CPP_

extern LogMsg thelog;

#endif

// maks_todo : how to make sure that we get compiler error if we use macro with fewer parameters when we should have used macro with more parameters ?
// for example : LOGERROR1(_T("Show Two Values %s, %s"), firstvalue, secondvalue) how to catch this error during compilation ?
#define LOGMESSAGEINIT(logfile, module)                 thelog.Init(logfile, module)
#define LOGMESSAGE0(msg)                                thelog.Log(_T(__FILE__), __LINE__, msg)
#define LOGMESSAGE1(msg, arg1)                          thelog.Log(_T(__FILE__), __LINE__, msg, arg1)
#define LOGMESSAGE2(msg, arg1, arg2)                    thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2)
#define LOGMESSAGE3(msg, arg1, arg2, arg3)              thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3)
#define LOGMESSAGE4(msg, arg1, arg2, arg3, arg4)        thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3, arg4)
#define LOGMESSAGE5(msg, arg1, arg2, arg3, arg4, arg5)  thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3, arg4, arg5)

#endif // !defined(AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\maksassert.cpp ===
/*
*  Copyright (c) 1996  Microsoft Corporation
*
*  Module Name:
*
*      maksassert.cpp
*
*  Abstract:
*
*      Implementas the assert functions.
*      maks_todo : use common assert macros instead.
*
*  Author:
*
*      Makarand Patwardhan  - March 6, 1998
*
*  Comments
*   This file is here only because I could not find the right friendly assert includes.
*    maks_todo : should be removed later.
*/

#include "stdafx.h"
#include "maksassert.h"


void MaksAssert(LPCTSTR exp, LPCTSTR file, int line)
{
    TCHAR szMsg[1024];
    _stprintf(szMsg, _T("assertion [%s] failed at [%s,%d]. Want to Debug?\n"), exp, file, line);
    
    LOGMESSAGE0(szMsg);
    OutputDebugString(szMsg);

    if (MessageBox(0, szMsg, _T("HydraOc.dll"), MB_YESNO  ) == IDYES )
    {
        if (IsDebuggerPresent ())
        {
            DebugBreak();
        }
        else
        {
            MessageBox(0,_T("hey sorry, I dont know how to attach a process to debuuger!"), _T("HydraOc.dll"), MB_OK);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\interfaces.cpp ===
// Interfaces.cpp : Implementation of TSUserExInterfaces class.

#include "stdafx.h"

#if 1 //POST_BETA_3
#include <sspi.h>
#include <secext.h>
#include <dsgetdc.h>
#endif //POST_BETA_3

#include "tsuserex.h"
//#include "ConfigDlg.h"    // for CTSUserProperties
#include "tsusrsht.h"

#include "Interfaces.h"
//#include "logmsg.h"
#include "limits.h" // USHRT_MAX
#ifdef _RTM_
#include <ntverp.h> // VER_PRODUCTVERSION_DW
#endif
#include <winsta.h>
//#include "ntdsapi.h" // enbable for "having some fun macro"

// clipboard format to retreive the machine name and account name associated
// with a data object created by local user manager

#define CCF_LOCAL_USER_MANAGER_MACHINE_NAME TEXT("Local User Manager Machine Focus Name")


#define ByteOffset(base, offset) (((LPBYTE)base)+offset)


BOOL g_bPagesHaveBeenInvoked = FALSE;
/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet implementation


HRESULT GetMachineAndUserName(IDataObject *pDataObject, LPWSTR pMachineName, LPWSTR pUserName , PBOOL pbDSAType , PSID *ppUserSid )
{
    ASSERT_(pUserName);
    ASSERT_(pMachineName);
	ASSERT_(pDataObject != NULL );

    // register the display formats.
    // first 2 formats supported by local user manager snapin
    static UINT s_cfMachineName =   RegisterClipboardFormat(CCF_LOCAL_USER_MANAGER_MACHINE_NAME);
    static UINT s_cfDisplayName =   RegisterClipboardFormat(CCF_DISPLAY_NAME);;
    static UINT s_cfDsObjectNames = RegisterClipboardFormat(CFSTR_DSOBJECTNAMES); // this format is supported by dsadmin snapin.

    ASSERT_(s_cfMachineName);
    ASSERT_(s_cfDisplayName);
    ASSERT_(s_cfDsObjectNames);


    FORMATETC fmte          = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	
	STGMEDIUM medium        = { TYMED_HGLOBAL, NULL, NULL };

    HRESULT hr = S_OK;

    ASSERT_(USHRT_MAX > s_cfDsObjectNames);

    // first we will try dsdataobject format. This means we are running in context of dsadmin

    fmte.cfFormat = ( USHORT )s_cfDsObjectNames;

    hr = pDataObject->GetData(&fmte, &medium);

    if( SUCCEEDED( hr ) )
    {
        // CFSTR_DSOBJECTNAMES is supported.
        // It means we are dealing with dsadmin
        // lets get username, and domain name from the dsadmin.
		
        LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)medium.hGlobal;

        *pbDSAType = TRUE;

        if( pDsObjectNames->cItems < 1 )
        {
			ODS( L"TSUSEREX : @GetMachineAndUserName DS Object names < 1\n" );

            return E_FAIL;
        }

        LPWSTR pwszObjName = ( LPWSTR )ByteOffset( pDsObjectNames , pDsObjectNames->aObjects[0].offsetName );

		KdPrint( ( "TSUSEREX : adspath is %ws\n" , pwszObjName ) );

        // first stage get the server name from the adspath
        // since IADsPathname does not live off a normal IADs Directory object
        // so me must cocreate the object set the path and then retrieve the server name
        // hey this saves us wire-tripping

        // IADsPathname *pPathname = NULL;

        IADsObjectOptions *pADsOptions = NULL;

        IADs *pADs = NULL;

        hr = ADsGetObject( pwszObjName, IID_IADs, (void**)&pADs );

        if( FAILED( hr ) )
        {
            KdPrint( ( "TSUSEREX : no means of binding to adspath -- hresult =  0x%x\n" , hr ) );

            return hr;
        }       

        VARIANT varServerName;

        VariantInit(&varServerName);
        
        hr = pADs->QueryInterface( IID_IADsObjectOptions , ( void ** )&pADsOptions );

        KdPrint( ( "TSUSEREX : binded to adsobject queried for IID_IADsObjectOptions returned 0x%x\n" , hr ) );

        if( SUCCEEDED( hr ) )
        {
            hr = pADsOptions->GetOption( ADS_OPTION_SERVERNAME, &varServerName);

            pADsOptions->Release( );

            KdPrint( ( "TSUSEREX: GetOption returned 0x%x\n" , hr ) ) ;
        }

        if( SUCCEEDED( hr ) )
        {
            lstrcpy( pMachineName , V_BSTR( &varServerName ) );

            KdPrint( ( "TSUSEREX: Server name is %ws\n" , pMachineName ) ) ;
        }
        
        VariantClear( &varServerName );


        if( FAILED( hr ) )
        {
            // ADS_FORMAT_SERVER is not supported this could mean we're dealing with an WinNT format
            // or a DS Provider that is poorly implemented

            KdPrint( ( "IADsPathname could not obtain server name 0x%x\n" , hr ) );

            // let's go wire tapping to get the server name

            VARIANT v;

            LPTSTR szDName = NULL;

            ULONG ulDName = 0;

            VariantInit(&v);

            hr = pADs->Get(L"distinguishedName", &v);

            if( FAILED( hr ) )
            {
                KdPrint( ( "TSUSEREX :  pADs->Get( DN ) returned 0x%x\n", hr )  );

                return hr;
            }

            ASSERT_( V_VT( &v ) == VT_BSTR );

            if( !TranslateNameW( V_BSTR(&v), NameFullyQualifiedDN, NameCanonical, szDName, &ulDName) )
			{
				KdPrint( ( "TSUSEREX : TranslateNameW failed with 0x%x\n", GetLastError( ) ) );

				return E_FAIL;
			}

			szDName = ( LPTSTR )new TCHAR[ ulDName + 1 ];

			if( szDName == NULL )
			{
				KdPrint( ( "TSUSEREX : could not allocate space for szDName\n" ) );

				return E_OUTOFMEMORY;
			}

			if( !TranslateNameW( V_BSTR(&v), NameFullyQualifiedDN, NameCanonical, szDName, &ulDName) )
			{
				KdPrint( ( "TSUSEREX : TranslateNameW failed 2nd pass with 0x%x\n", GetLastError( ) ) );

                delete[] szDName;

				return E_FAIL;
			}


            // perform LEFT$( szDName , up to '/' )

            KdPrint( ( "TSUSEREX : TranslateNameW cracked the name to %ws\n" , szDName ) );

            LPTSTR pszTemp = szDName;

            while( pszTemp != NULL )
            {
                if( *pszTemp == L'/' )
                {
                    *pszTemp = 0;

                    break;
                }

                pszTemp++;
            }

			
            KdPrint( ("TranslateName with my LEFT$ returned %ws\n",szDName ) );

            // get the domaincontroller name of the remote machine

            DOMAIN_CONTROLLER_INFO *pdinfo;

            DWORD dwStatus = DsGetDcName( NULL , szDName , NULL , NULL , 0 , &pdinfo );

            KdPrint( ( "TSUSEREX : DsGetDcName: %ws returned 0x%x\n", pdinfo->DomainControllerName , dwStatus ) );

            if( dwStatus == NO_ERROR )
            {
                lstrcpy( pMachineName , pdinfo->DomainControllerName );

                NetApiBufferFree( pdinfo );
            }

			if( szDName != NULL )
			{
				delete[] szDName;
			}

            VariantClear( &v );

        } // END else


        pADs->Release( );


        IADsUser *pADsUser = NULL;

        hr = ADsGetObject( pwszObjName, IID_IADsUser, (void**)&pADsUser);

        if( FAILED( hr ) )
        {
            KdPrint( ( "TSUSEREX: ADsGetObject failed to get the user object 0x%x\n",hr ) );

            return hr;
        }

        VARIANT var;
		VARIANT varSid;

        VariantInit(&var);
		VariantInit(&varSid);

		hr = pADsUser->Get(L"ObjectSid", &varSid);

		if( FAILED( hr ) )
        {
			ODS( L"TSUSEREX : IADsUser::Get( ObjectSid ) failed \n" );

            return hr;
        }

        if( !( varSid.vt & VT_ARRAY) )
        {
			ODS( L"TSUSEREX : Object SID is not a VT_ARRAY\n" );

            return E_FAIL;
        }

        PSID pSid = NULL;

		PSID pUserSid = NULL;

        SafeArrayAccessData( varSid.parray, &pSid );

        if( !IsValidSid( pSid ) )
        {
			ODS( L"TSUSEREX : pSid is invalid\n" );

            return E_FAIL;
        }

		DWORD dwSidSize = GetLengthSid( pSid );
		
		pUserSid = new BYTE[ dwSidSize ];

		if( pUserSid == NULL )
		{
			ODS( L"TSUSEREX : failed to allocate pUserSid\n" );

            return E_FAIL;
		}

		CopySid( dwSidSize , pUserSid , pSid );

		*ppUserSid = pUserSid;

		SafeArrayUnaccessData( varSid.parray );

		VariantClear( &varSid );
		

        hr = pADsUser->Get( L"samAccountName" , &var );

        pADsUser->Release();

        if( FAILED( hr ) )
        {
			KdPrint( ( "TSUSEREX : ADsUser::Get( name ) failed 0x%x\n", hr ) );

            return hr;
        }


        ASSERT_( V_VT( &var ) == VT_BSTR );

        lstrcpy( pUserName , V_BSTR( &var ) );

        KdPrint( ( "TSUSEREX : Server name %ws user name is %ws\n" , pMachineName , pUserName ) );

        VariantClear( &var );

        ReleaseStgMedium(&medium);
    }
    else
    {
        // CFSTR_DSOBJECTNAMES is NOT supported.
        // It means we are dealing with local user manager.
        // we must be able to get
        // Allocate medium for GetDataHere.

        medium.hGlobal = GlobalAlloc(GMEM_SHARE, MAX_PATH * sizeof(WCHAR));

        if( !medium.hGlobal )
        {
			ODS( L"TSUSEREX : GlobalAlloc failed in GetMachineAndUserName\n" );

            return E_OUTOFMEMORY;
        }

        *pbDSAType = FALSE;

        // since we are doing data conversion.
        // check for possible data loss.

        ASSERT_(USHRT_MAX > s_cfMachineName);

        // request the machine name from the dataobject.

        fmte.cfFormat = (USHORT)s_cfMachineName;

        hr = pDataObject->GetDataHere(&fmte, &medium);

        if( FAILED( hr ) )
        {
			ODS( L"TSUSEREX : @GetMachineAndUserName GetDataHere for s_cfMachineName failed\n" );

            return hr;
        }

        // copy the machine name into our buffer

        if( ( LPWSTR )medium.hGlobal != NULL && pMachineName != NULL )
        {
            wcscpy(pMachineName, (LPWSTR)medium.hGlobal );
        }

		// administer local accounts only for Terminal Servers

		SERVER_INFO_101 *psi101;
        HANDLE hTServer = NULL;

		DWORD dwNetStatus = NetServerGetInfo( pMachineName , 101 , ( LPBYTE * )&psi101 );

		if( dwNetStatus != NERR_Success )
		{
			KdPrint( ( "TSUSEREX:GetMachineAndUserName -- NetServerGetInfo failed with 0x%x\n", dwNetStatus ) );

			return E_FAIL;
		}

		if( psi101 == NULL )
		{
			KdPrint( ( "TSUSEREX:GetMachineAndUserName -- NetServerGetInfo failed getting sinfo101 0x%x\n",dwNetStatus ) );
			
			return E_FAIL;
		}
        KdPrint( ("TSUSEREX:NetServerGetInfo server bits returnd 0x%x and nttype is 0x%x\n", psi101->sv101_type , SV_TYPE_SERVER_NT ) );
        
		BOOL fServer = ( BOOL )( psi101->sv101_type & ( DWORD )SV_TYPE_SERVER_NT );

		NetApiBufferFree( ( LPVOID )psi101 );
        
		if( !fServer )
		{

			KdPrint( ( "TSUSEREX : viewing local account on non-TS ( exiting )\n" ) );

			return E_FAIL;
		}

        hTServer = WinStationOpenServer( pMachineName );
        if( hTServer == NULL )
        {
            KdPrint( ( "TSUSEREX: This OS does not support terminal services\n" ) ) ;
            return E_FAIL;
        }
        WinStationCloseServer( hTServer );

        // since we are doing data conversion.
        // check for possible data loss.

        ASSERT_(USHRT_MAX > s_cfDisplayName);

        // request data  about user name.

        fmte.cfFormat = (USHORT)s_cfDisplayName;

        hr = pDataObject->GetDataHere( &fmte , &medium );

        if( FAILED( hr ) )
        {
			ODS( L"TSUSEREX : @GetMachineAndUserName GetDataHere for s_cfDisplayName failed\n" );

            return hr;
        }

        // copy the user name into our buffer and release the medium.

        if( ( LPWSTR )medium.hGlobal != NULL && pUserName != NULL )
        {
            wcscpy( pUserName , ( LPWSTR )medium.hGlobal );
        }

        ReleaseStgMedium( &medium );
    }

    return S_OK;
}

//-----------------------------------------------------------------------------------------------------
TSUserExInterfaces::TSUserExInterfaces()
{
    // LOGMESSAGE0(_T("TSUserExInterfaces::TSUserExInterfaces()..."));
    // m_pUserConfigPage = NULL;
    m_pTSUserSheet = NULL;

	m_pDsadataobj = NULL;
}

//-----------------------------------------------------------------------------------------------------
TSUserExInterfaces::~TSUserExInterfaces()
{
   ODS( L"Good bye\n" );
}

//-----------------------------------------------------------------------------------------------------
HRESULT TSUserExInterfaces::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,    // pointer to the callback interface
    LONG_PTR ,                                 // handle for routing notification
    LPDATAOBJECT lpIDataObject)            // pointer to the data object);
{
    //
    // Test for valid parameters
    //

    if( lpIDataObject == NULL || IsBadReadPtr( lpIDataObject , sizeof( LPDATAOBJECT ) ) )
    {
		ODS( L"TSUSEREX : @ CreatePropertyPages IDataObject is invalid\n " );

        return E_INVALIDARG;
    }

    if( lpProvider == NULL )
    {
		ODS( L"TSUSEREX @ CreatePropertyPages LPPROPERTYSHEETCALLBACK is invalid\n" );

        return E_INVALIDARG;
    }

    WCHAR wUserName[ MAX_PATH ];

    WCHAR wMachineName[ MAX_PATH ];

    BOOL bDSAType;



    if( g_bPagesHaveBeenInvoked )
    {
        ODS( L"TSUSEREX : TSUserExInterfaces::CreatePropertyPages pages have been invoked\n" );

        return E_FAIL;
    }


    PSID pUserSid = NULL;


    if( FAILED( GetMachineAndUserName( lpIDataObject , wMachineName , wUserName , &bDSAType , &pUserSid ) ) )
    {
		ODS( L"TSUSEREX : GetMachineAndUserName failed @CreatePropertyPages \n" );

        return E_FAIL;
    }

    //
    // Test to see if we are being called twice
    //

    if( m_pTSUserSheet != NULL )
    {
        return E_FAIL;
    }

    //
    // MMC likes to release IEXtendPropertySheet ( this object )
    // so we cannot free CTSUserSheet in TSUserExInterfaces::dtor
    // CTSUserSheet must release itself!!!
    //

    m_pTSUserSheet = new CTSUserSheet( );

    if( m_pTSUserSheet != NULL )
    {
		ODS( L"TSUSEREX : CreatePropertyPages mem allocation succeeded\n" );		

        m_pTSUserSheet->SetDSAType( bDSAType );

        VERIFY_S( TRUE , m_pTSUserSheet->SetServerAndUser( &wMachineName[0] , &wUserName[0] ) );

        m_pTSUserSheet->CopyUserSid( pUserSid );

        VERIFY_S( S_OK , m_pTSUserSheet->AddPagesToPropSheet( lpProvider ) );
    }

    return S_OK;

}

//-----------------------------------------------------------------------------------------------------
HRESULT TSUserExInterfaces::QueryPagesFor(  LPDATAOBJECT /* lpDataObject */  )
{
    return S_OK;
}

//-----------------------------------------------------------------------------------------------------
// this has not been checked in yet!!!
//-----------------------------------------------------------------------------------------------------
STDMETHODIMP TSUserExInterfaces::GetHelpTopic( LPOLESTR *ppszHelp )
{
	ODS( L"TSUSEREX : GetHelpTopic\n" );

    if( ppszHelp == NULL )
    {
        return E_INVALIDARG;
    }

    TCHAR tchHelpFile[ 80 ];

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_TSUSERHELP , tchHelpFile , sizeof( tchHelpFile ) / sizeof( TCHAR ) ) );

    // mmc will call CoTaskMemFree

    *ppszHelp = ( LPOLESTR )CoTaskMemAlloc( sizeof( TCHAR ) * MAX_PATH );

    if( *ppszHelp != NULL )
    {
        if( GetSystemWindowsDirectory( *ppszHelp , MAX_PATH ) != 0 )
        {
            lstrcat( *ppszHelp , tchHelpFile );
        }
        else
        {
            lstrcpy( *ppszHelp , tchHelpFile );
        }

        ODS( *ppszHelp );

        ODS( L"\n" );

        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//-----------------------------------------------------------------------------------------------------
// IShellExtInit

STDMETHODIMP TSUserExInterfaces::Initialize(
		LPCITEMIDLIST ,
		LPDATAOBJECT lpdobj,
		HKEY
	)
{
	m_pDsadataobj = lpdobj;

	return S_OK;
}
	
//-----------------------------------------------------------------------------------------------------
// IShellPropSheetExt - this interface is used only for dsadmin based tools
//						for this reason the DSAType flag is set to true.

STDMETHODIMP TSUserExInterfaces::AddPages(
		LPFNADDPROPSHEETPAGE lpfnAddPage,
		LPARAM lParam
	)
{
	//
    // Test for valid parameters
    //

    if( m_pDsadataobj == NULL )
    {
		ODS( L"TSUSEREX : @ AddPages IDataObject is invalid\n " );

        return E_INVALIDARG;
    }

    if( lpfnAddPage == NULL )
    {
		ODS( L"TSUSEREX @ AddPages LPFNADDPROPSHEETPAGE is invalid\n" );

        return E_INVALIDARG;
    }

    WCHAR wUserName[ MAX_PATH ];

    WCHAR wMachineName[ MAX_PATH ];

    BOOL bDSAType;

	PSID pUserSid = NULL;


    if( FAILED( GetMachineAndUserName( m_pDsadataobj , wMachineName , wUserName , &bDSAType , &pUserSid ) ) )
    {
		ODS( L"TSUSEREX : GetMachineAndUserName @AddPages failed \n" );

        return E_FAIL;
    }

    ODS( L"TSUSEREX : DSATYPE in AddPages\n" );

    g_bPagesHaveBeenInvoked = TRUE;

    //
    // Test to see if we are being called twice
    //

    if( m_pTSUserSheet != NULL )
    {
        return E_FAIL;
    }

    //
    // MMC likes to release IEXtendPropertySheet ( this object )
    // so we cannot free CTSUserSheet in TSUserExInterfaces::dtor
    // CTSUserSheet must release itself!!!
    //

    m_pTSUserSheet = new CTSUserSheet( );

    if( m_pTSUserSheet != NULL )
    {
		ODS( L"TSUSEREX : AddPages mem allocation succeeded\n" );

        m_pTSUserSheet->SetDSAType( bDSAType );

		m_pTSUserSheet->CopyUserSid( pUserSid );
		
        VERIFY_S( TRUE , m_pTSUserSheet->SetServerAndUser( &wMachineName[0] , &wUserName[0] ) );

        VERIFY_S( S_OK , m_pTSUserSheet->AddPagesToDSAPropSheet( lpfnAddPage , lParam ) );
    }
	return S_OK;
}

//-----------------------------------------------------------------------------------------------------

STDMETHODIMP TSUserExInterfaces::ReplacePage(
		UINT ,
		LPFNADDPROPSHEETPAGE ,
		LPARAM
   )
{
	return E_FAIL;
}


#ifdef _RTM_ // add ISnapinAbout
//-----------------------------------------------------------------------------------------------------
STDMETHODIMP TSUserExInterfaces::GetSnapinDescription(
            LPOLESTR *ppOlestr )
{
    TCHAR tchMessage[] = TEXT("This extension allows the administrator to configure Terminal Services user properties. This extension is only enabled on Terminal Servers.");

    ODS( L"TSUSEREX: GetSnapinDescription called\n" );

    *ppOlestr = ( LPOLESTR )CoTaskMemAlloc( ( lstrlen( tchMessage ) + 1 ) * sizeof( TCHAR ) );

    if( *ppOlestr != NULL )
    {
        lstrcpy( *ppOlestr , tchMessage );

        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//-----------------------------------------------------------------------------------------------------
STDMETHODIMP TSUserExInterfaces::GetProvider(
            LPOLESTR *ppOlestr )
{
    TCHAR tchMessage[] = TEXT("Microsoft Corporation");

    ODS( L"TSUSEREX: GetProvider called\n" );

    *ppOlestr = ( LPOLESTR )CoTaskMemAlloc( ( lstrlen( tchMessage ) + 1 ) * sizeof( TCHAR ) );

    if( *ppOlestr != NULL )
    {
        lstrcpy( *ppOlestr , tchMessage );

        return S_OK;
    }

    return E_OUTOFMEMORY;

}

//-----------------------------------------------------------------------------------------------------
STDMETHODIMP TSUserExInterfaces::GetSnapinVersion(
            LPOLESTR *ppOlestr )
{
    char chMessage[ 32 ] = VER_PRODUCTVERSION_STR;

    TCHAR tchMessage[32];

    ODS( L"TSUSEREX: GetSnapinVersion called\n" );

    int iCharCount = MultiByteToWideChar( CP_ACP , 0 , chMessage , sizeof( chMessage ) , tchMessage , sizeof( tchMessage ) / sizeof( TCHAR ) );

    //wsprintf( tchMessage , TEXT( "%d" ) , VER_PRODUCTVERSION_DW );

    *ppOlestr = ( LPOLESTR )CoTaskMemAlloc( ( iCharCount + 1 ) * sizeof( TCHAR ) );

    if( *ppOlestr != NULL )
    {
        lstrcpy( *ppOlestr , tchMessage );

        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//-----------------------------------------------------------------------------------------------------
STDMETHODIMP TSUserExInterfaces::GetSnapinImage(
            HICON * )
{
    return E_NOTIMPL;
}

//-----------------------------------------------------------------------------------------------------
STDMETHODIMP TSUserExInterfaces::GetStaticFolderImage(
            /* [out] */ HBITMAP *,
            /* [out] */ HBITMAP *,
            /* [out] */ HBITMAP *,
            /* [out] */ COLORREF *)
{
    return E_NOTIMPL;
}

#endif //_RTM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\register.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    register.cpp

    FILE HISTORY:

*/

#include "stdafx.h"
#include "register.h"
#include "registry.h"

#define EXTENSION_TYPE_NAMESPACE		( 0x00000001 )
#define EXTENSION_TYPE_CONTEXTMENU		( 0x00000002 )
#define EXTENSION_TYPE_TOOLBAR			( 0x00000004 )
#define EXTENSION_TYPE_PROPERTYSHEET	( 0x00000008 )
#define EXTENSION_TYPE_TASK         	( 0x00000010 )

//#include "compdata.h"
//#include "tregkey.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// MMC Snapin specific registry stuff

// REVIEW_MARCOC: need to get MMC helpers for this
// registry keys matching ACTIVEC\CORE\STRINGS.CPP

const TCHAR NODE_TYPES_KEY[] = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
const TCHAR SNAPINS_KEY[] = TEXT("Software\\Microsoft\\MMC\\SnapIns");

const TCHAR g_szHKLM[] = TEXT("HKEY_LOCAL_MACHINE");
const TCHAR g_szStandAlone[] = TEXT("StandAlone");
const TCHAR g_szAbout[] = TEXT("About");
const TCHAR g_szNameString[] = TEXT("NameString");

const TCHAR g_szNodeTypes[] = TEXT("NodeTypes");
const TCHAR g_szRequiredExtensions[] = TEXT("RequiredExtensions");

const TCHAR g_szExtensions[] = TEXT("Extensions");
const TCHAR g_szNameSpace[] = TEXT("NameSpace");
const TCHAR g_szContextMenu[] = TEXT("ContextMenu");
const TCHAR g_szToolbar[] = TEXT("Toolbar");
const TCHAR g_szPropertySheet[] = TEXT("PropertySheet");
const TCHAR g_szTask[] = TEXT("Task");
const TCHAR g_szDynamicExtensions[] = TEXT("Dynamic Extensions");

/*!--------------------------------------------------------------------------
	RegisterSnapin
	Registers a snapin based on GUIDs
	Author:
 ---------------------------------------------------------------------------*/
DWORD RegisterSnapinGUID
(
	const GUID* pSnapinCLSID,
	const GUID* pStaticNodeGUID,
	const GUID* pAboutGUID,
	LPCWSTR     lpszNameString,
	LPCWSTR     lpszVersion,
	BOOL		bStandalone
)
{
	OLECHAR szSnapinClassID[128] = {0},
			szStaticNodeGuid[128] = {0},
			szAboutGuid[128] = {0};

	::StringFromGUID2(*pSnapinCLSID, szSnapinClassID, 128);
	::StringFromGUID2(*pStaticNodeGUID, szStaticNodeGuid, 128);
	::StringFromGUID2(*pAboutGUID, szAboutGuid, 128);

	return RegisterSnapin(szSnapinClassID, szStaticNodeGuid, szAboutGuid,
						  lpszNameString, lpszVersion, bStandalone);
}

/*!--------------------------------------------------------------------------
	CHiddenWnd::WindowProc
	Resisters a snapin based on the GUID strings
	Author:
 ---------------------------------------------------------------------------*/
DWORD RegisterSnapin
(
	LPCWSTR lpszSnapinClassID,
	LPCWSTR lpszStaticNodeGuid,
	LPCWSTR lpszAboutGuid,
	LPCWSTR lpszNameString,
	LPCWSTR lpszVersion,
	BOOL	bStandalone
)
{
	CRegistry regkeySnapins;

   	LONG lRes = regkeySnapins.OpenKey(HKEY_LOCAL_MACHINE, SNAPINS_KEY);
	ASSERT(lRes == ERROR_SUCCESS);

	if (lRes != ERROR_SUCCESS)
	{
        return lRes;
	}

	//
	// Create this key for our snapin
	//
	CRegistry regkeyThisSnapin;
	lRes = regkeyThisSnapin.CreateKey(regkeySnapins, lpszSnapinClassID);

	ASSERT(lRes == ERROR_SUCCESS);

	if (lRes != ERROR_SUCCESS)
	{
        return lRes;
	}

	//
	// Add in the values that go in this key:
	//     NameString, About, Provider, and Version.
	//
	lRes = regkeyThisSnapin.WriteRegString(g_szNameString, lpszNameString);

	if (lRes != ERROR_SUCCESS)
	{
        return lRes;
	}

	lRes = regkeyThisSnapin.WriteRegString(g_szAbout, lpszAboutGuid);

    if (lRes != ERROR_SUCCESS)
	{
        return lRes;
	}

	lRes = regkeyThisSnapin.WriteRegString( _T("Provider"), _T("Microsoft"));
   
	if (lRes != ERROR_SUCCESS)
	{
        return lRes;
	}

	lRes = regkeyThisSnapin.WriteRegString(_T("Version"), lpszVersion);

	ASSERT(lRes == ERROR_SUCCESS);

	//
	// Create the NodeTypes subkey
	//
	CRegistry regkeySnapinNodeTypes;
	lRes = regkeySnapinNodeTypes.CreateKey(regkeyThisSnapin, g_szNodeTypes);

	ASSERT(lRes == ERROR_SUCCESS);

	if (lRes != ERROR_SUCCESS)
	{
        return lRes;
	}

	CRegistry regkeySnapinThisNodeType;
	lRes = regkeySnapinThisNodeType.CreateKey(regkeySnapinNodeTypes, lpszStaticNodeGuid);

	if (lRes != ERROR_SUCCESS)
	{
        return lRes;
	}

	//
	// If this snapin can run by itself then create the Standalone subkey
	//
	if (bStandalone)
	{
		CRegistry regkeySnapinStandalone;
		lRes = regkeySnapinStandalone.CreateKey(regkeyThisSnapin, g_szStandAlone);

		ASSERT(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
            return lRes;
		}
	}

	return lRes;
}

/*!--------------------------------------------------------------------------
	UnregisterSnapin
		Removes snapin specific registry entries
	Author:
 ---------------------------------------------------------------------------*/
DWORD UnregisterSnapinGUID
(
	const GUID* pSnapinCLSID
)
{
//	USES_CONVERSION;
	OLECHAR szSnapinClassID[128];
	
	::StringFromGUID2(*pSnapinCLSID,szSnapinClassID,128);
	
	return UnregisterSnapin(szSnapinClassID);
}

/*!--------------------------------------------------------------------------
	UnregisterSnapin
		Removes snapin specific registry entries
	Author:
 ---------------------------------------------------------------------------*/
DWORD UnregisterSnapin
(
	LPCWSTR lpszSnapinClassID
)
{
	CRegistry regkeySnapins;
	LONG lRes = regkeySnapins.OpenKey(HKEY_LOCAL_MACHINE, SNAPINS_KEY);

	ASSERT(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
        return lRes;
	}

	lRes = regkeySnapins.RecurseDeleteKey(lpszSnapinClassID);

	return lRes;
}

/*!--------------------------------------------------------------------------
	RegisterNodeType
		Registers a particular node type
	Author:
 ---------------------------------------------------------------------------*/
//HRESULT
//RegisterNodeTypeGUID
//(
//	const GUID* pGuidSnapin,
//	const GUID* pGuidNode,
//	LPCWSTR     lpszNodeDescription
//)
//{
//	USES_CONVERSION;
//	OLECHAR swzGuidSnapin[128];
//	OLECHAR swzGuidNode[128];
//
//	::StringFromGUID2(*pGuidSnapin,swzGuidSnapin,128);
//	::StringFromGUID2(*pGuidNode,swzGuidNode,128);
//
//	return RegisterNodeType(swzGuidSnapin, swzGuidNode, lpszNodeDescription);
//}
//
/*!--------------------------------------------------------------------------
	RegisterNodeType
		Registers a particular node type
	Author:
 ---------------------------------------------------------------------------*/
//HRESULT
//RegisterNodeType
//(
//	LPCWSTR lpszGuidSnapin,
//	LPCWSTR lpszGuidNode,
//	LPCWSTR lpszNodeDescription
//)
//{
//	// register this node type under the snapin
//	CRegistry	regkeySnapins;
//	CRegistry	regkeySnapinGuid;
//	CRegistry	regkeySnapinGuidNodeTypes;
//	CRegistry	regkeyNode;
//	CRegistry   regkeyThisNodeType;
//	CRegistry   regkeyNodeTypes;
//	DWORD	lRes;
//	//HRESULT	hr = hrOK;
//
//	lRes = regkeySnapins.OpenKey(HKEY_LOCAL_MACHINE, SNAPINS_KEY);
//	ASSERT(lRes == ERROR_SUCCESS);
//	if ( lRes != ERROR_SUCCESS)
//	{
//		SetRegError(0, HRESULT_FROM_WIN32(lRes),
//					IDS_ERR_REG_OPEN_CALL_FAILED,
//					g_szHKLM, SNAPINS_KEY, NULL);
//		CWRg( lRes );
//	}
//
//	lRes = regkeySnapinGuid.CreateKey(regkeySnapins, lpszGuidSnapin);
//	ASSERT(lRes == ERROR_SUCCESS);
//	if (lRes != ERROR_SUCCESS)
//		SetRegError(0, HRESULT_FROM_WIN32(lRes),
//					IDS_ERR_REG_CREATE_CALL_FAILED,
//					g_szHKLM, SNAPINS_KEY, lpszGuidSnapin, NULL);
//	CWRg( lRes );
//
//	lRes = regkeySnapinGuidNodeTypes.CreateKey(regkeySnapinGuid, g_szNodeTypes);
//	ASSERT(lRes == ERROR_SUCCESS);
//	if (lRes != ERROR_SUCCESS)
//		SetRegError(0, HRESULT_FROM_WIN32(lRes),
//					IDS_ERR_REG_CREATE_CALL_FAILED,
//					g_szHKLM, SNAPINS_KEY, lpszGuidSnapin,
//					g_szNodeTypes, NULL);
//	CWRg( lRes );
//
//	lRes = regkeyNode.CreateKey(regkeySnapinGuidNodeTypes, lpszGuidNode);
//	ASSERT(lRes == ERROR_SUCCESS);
//	if (lRes != ERROR_SUCCESS)
//		SetRegError(0, HRESULT_FROM_WIN32(lRes),
//					IDS_ERR_REG_CREATE_CALL_FAILED,
//					g_szHKLM, SNAPINS_KEY, lpszGuidSnapin,
//					g_szNodeTypes, lpszGuidNode, NULL);
//	CWRg( lRes );
//
//	// set the description
//	lRes = regkeyNode.WriteRegString(NULL, lpszNodeDescription);
//	ASSERT(lRes == ERROR_SUCCESS);
//
//	// now register the node type in the global list so that people
//	// can extend it
//	lRes = regkeyNodeTypes.OpenKey(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
//	ASSERT(lRes == ERROR_SUCCESS);
//	if (lRes != ERROR_SUCCESS)
//	{
//		SetRegError(0, HRESULT_FROM_WIN32(lRes),
//					IDS_ERR_REG_OPEN_CALL_FAILED,
//					g_szHKLM, NODE_TYPES_KEY, NULL);
//		CWRg( lRes );
//	}
//
//	lRes = regkeyThisNodeType.CreateKey(regkeyNodeTypes, lpszGuidNode);
//	ASSERT(lRes == ERROR_SUCCESS);
//	if (lRes != ERROR_SUCCESS)
//		SetRegError(0, HRESULT_FROM_WIN32(lRes),
//					IDS_ERR_REG_CREATE_CALL_FAILED,
//					g_szHKLM, NODE_TYPES_KEY, lpszGuidNode, NULL);
//	CWRg( lRes );
//
//	lRes = regkeyThisNodeType.WriteRegString(NULL, lpszNodeDescription);
//	ASSERT(lRes == ERROR_SUCCESS);
//	CWRg( lRes );
//
//Error:
//	return hr;
//}
//
///*!--------------------------------------------------------------------------
//	UnregisterNodeType
//		Removes registry entries for a node
//	Author:
// ---------------------------------------------------------------------------*/
//HRESULT
//UnregisterNodeTypeGUID
//(
//	const GUID* pGuid
//)
//{
//	USES_CONVERSION;
//	OLECHAR szGuid[128];
//
//	::StringFromGUID2(*pGuid,szGuid,128);
//
//	return UnregisterNodeType(szGuid);
//}
//
///*!--------------------------------------------------------------------------
//	UnregisterNodeType
//		Removes registry entries for a node
//	Author:
// ---------------------------------------------------------------------------*/
//HRESULT
//UnregisterNodeType
//(
//	LPCWSTR lpszNodeGuid
//)
//{
//	CRegistry regkeyNodeTypes;
//	LONG lRes = regkeyNodeTypes.OpenKey(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
//	ASSERT(lRes == ERROR_SUCCESS);
//
//	if (lRes != ERROR_SUCCESS)
//	{
//		SetRegError(0, HRESULT_FROM_WIN32(lRes),
//					IDS_ERR_REG_OPEN_CALL_FAILED,
//					g_szHKLM, NODE_TYPES_KEY, NULL);
//		return HRESULT_FROM_WIN32(lRes); // failed to open
//	}
//
//	lRes = regkeyNodeTypes.RecurseDeleteKey(lpszNodeGuid);
//	ASSERT(lRes == ERROR_SUCCESS);
//
//	return HRESULT_FROM_WIN32(lRes);
//}
//
/*!--------------------------------------------------------------------------
//	RegisterAsExtensionGUID
//		Registers a particular node type as an extension of another node
//	Author:
 ---------------------------------------------------------------------------*/
DWORD RegisterAsExtensionGUID
(
	const GUID* pGuidNodeToExtend,
	const GUID* pGuidExtensionSnapin,
	LPCWSTR     lpszSnapinDescription,
	DWORD		dwExtensionType
)
{
	return RegisterAsRequiredExtensionGUID(pGuidNodeToExtend,
									       pGuidExtensionSnapin,
										   lpszSnapinDescription,
										   dwExtensionType,
										   NULL);
}

// adds a node type to an existing snapin.
DWORD AddNodeType 
(
	const GUID* pSnapinCLSID,
	const GUID* pStaticNodeGUID
)
{
//    const TCHAR SNAPINS_KEY[] = TEXT("Software\\Microsoft\\MMC\\SnapIns");
//    const TCHAR NODE_TYPES[] = TEXT("NodeTypes");
  
    // prepare the string
    OLECHAR szSnapinGuid[128] = {0};
    OLECHAR szNodeGuid[128] = {0};
    ::StringFromGUID2(*pSnapinCLSID, szSnapinGuid, 128);
    ::StringFromGUID2(*pStaticNodeGUID, szNodeGuid, 128);

    TCHAR szSnapin[256];
    _tcscpy(szSnapin, SNAPINS_KEY);
    _tcscat(szSnapin, _T("\\"));
    _tcscat(szSnapin, szSnapinGuid);

    ASSERT(_tcslen(szSnapin) < 256);
    
    CRegistry RegSnapin;
    LONG lRes = RegSnapin.OpenKey(HKEY_LOCAL_MACHINE, szSnapin);

    if (lRes == ERROR_SUCCESS)
    {
        CRegistry RegnNodeTypes;
        lRes = RegnNodeTypes.CreateKey(RegSnapin, g_szNodeTypes);

        if (lRes == ERROR_SUCCESS)
        {
            CRegistry RegTheNode;
            lRes = RegTheNode.CreateKey(RegnNodeTypes, szNodeGuid);



            
        }
    }

    return lRes;
}

///*!--------------------------------------------------------------------------
//	RegisterAsExtension
//		Registers a particular node type as an extension of another node
//	Author:
// ---------------------------------------------------------------------------*/
//HRESULT
//RegisterAsExtension
//(
//	LPCWSTR lpszNodeToExtendGuid,
//	LPCWSTR lpszExtensionSnapin,
//	LPCWSTR lpszSnapinDescription,
//	DWORD	dwExtensionType
//)
//{
//	return RegisterAsRequiredExtension(lpszNodeToExtendGuid,
//									   lpszExtensionSnapin,
//									   lpszSnapinDescription,
//									   dwExtensionType,
//									   NULL);
//}
///*!--------------------------------------------------------------------------
//	RegisterAsExtensionGUID
//		Registers a particular node type as an extension of another node
//	Author:
// ---------------------------------------------------------------------------*/
DWORD RegisterAsRequiredExtensionGUID
(
	const GUID* pGuidNodeToExtend,
	const GUID* pGuidExtensionSnapin,
	LPCWSTR     lpszSnapinDescription,
	DWORD		dwExtensionType,
	const GUID* pGuidRequiredPrimarySnapin
)
{
	USES_CONVERSION;
	OLECHAR szGuidNodeToExtend[128];
	OLECHAR szGuidExtensionSnapin[128];
	OLECHAR szGuidRequiredPrimarySnapin[128];
    OLECHAR * pszGuidRequiredPrimarySnapin = NULL;

	::StringFromGUID2(*pGuidNodeToExtend, szGuidNodeToExtend, 128);
	::StringFromGUID2(*pGuidExtensionSnapin, szGuidExtensionSnapin, 128);

	if (pGuidRequiredPrimarySnapin)
	{
		ASSERT(pGuidExtensionSnapin);

		::StringFromGUID2(*pGuidRequiredPrimarySnapin, szGuidRequiredPrimarySnapin, 128);
		pszGuidRequiredPrimarySnapin = szGuidRequiredPrimarySnapin;

		::StringFromGUID2(*pGuidExtensionSnapin, szGuidExtensionSnapin, 128);
	}

	return RegisterAsRequiredExtension(szGuidNodeToExtend,
									   szGuidExtensionSnapin,
									   lpszSnapinDescription,
									   dwExtensionType,
									   pszGuidRequiredPrimarySnapin);
}

/*!--------------------------------------------------------------------------
	RegisterAsRequiredExtension
		Registers a particular node type as an extension of another node
		and if necessary a required snapin
	Author:
 ---------------------------------------------------------------------------*/
DWORD RegisterAsRequiredExtension
(
	LPCTSTR lpszNodeToExtendGuid,
	LPCTSTR lpszExtensionSnapinGuid,
	LPCTSTR lpszSnapinDescription,
	DWORD	dwExtensionType,
	LPCTSTR lpszRequiredPrimarySnapin
)
{
	CRegistry regkeyNodeTypes;

    LONG lRes = regkeyNodeTypes.OpenKey(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
    
	ASSERT(lRes == ERROR_SUCCESS);

	if (lRes != ERROR_SUCCESS)
	{
        return lRes;
	}

    TCHAR strRegKey[256];
	// CString strRegKey;

    
//	strRegKey = lpszNodeToExtendGuid;
//	strRegKey +=  _T("\\");
//	strRegKey += g_szExtensions;
//	strRegKey += _T("\\");
    
    _tcscpy(strRegKey, lpszNodeToExtendGuid);
    _tcscat(strRegKey, _T("\\"));
    _tcscat(strRegKey, g_szExtensions);
    _tcscat(strRegKey, _T("\\"));
    
    ASSERT(_tcslen(strRegKey) < 256);


	// check to see if we this is a required extension, if so register
	if (lpszRequiredPrimarySnapin)
	{
		CRegistry regkeyNode, regkeyDynExt;
		CRegistry regkeyExtension;
		//CString strNodeToExtend, strDynExtKey;
        //LPTSTR strNodeToExtend[256];
        //LPTSTR strDynExtKey[256];

        //strNodeToExtend = lpszNodeToExtendGuid;
        // _tcscpy(strNodeToExtend, lpszNodeToExtendGuid);


		// open the snapin that we are registering as a required snapin
		lRes = regkeyNode.CreateKey(regkeyNodeTypes, lpszNodeToExtendGuid);
        
		ASSERT(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
            return lRes;
		}

		// now create the required extensions key and add the subkey
		lRes = regkeyDynExt.CreateKey(regkeyNode, g_szDynamicExtensions);

		ASSERT(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
            return lRes;
		}

		// now set the value
		lRes = regkeyDynExt.WriteRegString(lpszExtensionSnapinGuid, lpszSnapinDescription);

		ASSERT(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
            return lRes;
        }
	}

	if (dwExtensionType & EXTENSION_TYPE_NAMESPACE)
	{
		CRegistry regkeyNameSpace;
		// CString strNameSpaceRegKey = strRegKey + g_szNameSpace;
        TCHAR strNameSpaceRegKey[256];
        
        _tcscpy(strNameSpaceRegKey, strRegKey);
        _tcscat(strNameSpaceRegKey, g_szNameSpace);


		regkeyNameSpace.CreateKey(regkeyNodeTypes, strNameSpaceRegKey);

		lRes = regkeyNameSpace.WriteRegString(lpszExtensionSnapinGuid, lpszSnapinDescription);

		ASSERT(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
			// Trace0("RegisterAsExtension: Unable to create NameSpace extension key\n");
            return lRes;
		}
	}

	if (dwExtensionType & EXTENSION_TYPE_CONTEXTMENU)
	{
		CRegistry regkeyContextMenu;
		// CString strContextMenuRegKey = strRegKey + g_szContextMenu;
        
        TCHAR strContextMenuRegKey[256];
        _tcscpy(strContextMenuRegKey, strRegKey);
        _tcscat(strContextMenuRegKey, g_szContextMenu);



		regkeyContextMenu.CreateKey(regkeyNodeTypes, strContextMenuRegKey);

		lRes = regkeyContextMenu.WriteRegString(lpszExtensionSnapinGuid, lpszSnapinDescription);
		ASSERT(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
			// Trace0("RegisterAsExtension: Unable to create ContextMenu extension key\n");
			return lRes;

		}
	}

	if (dwExtensionType & EXTENSION_TYPE_TOOLBAR)
	{
		CRegistry regkeyToolbar;
		//CString strToolbarRegKey = strRegKey + g_szToolbar;
        
        TCHAR strToolbarRegKey[256];
        _tcscpy(strToolbarRegKey, strRegKey);
        _tcscat(strToolbarRegKey, g_szToolbar);

		regkeyToolbar.CreateKey(regkeyNodeTypes, strToolbarRegKey);

		lRes = regkeyToolbar.WriteRegString(lpszExtensionSnapinGuid, lpszSnapinDescription);
		ASSERT(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
			// Trace0("RegisterAsExtension: Unable to create Toolbar extension key\n");
			return lRes;

		}
	}

	if (dwExtensionType & EXTENSION_TYPE_PROPERTYSHEET)
	{
		CRegistry regkeyPropertySheet;
		// CString strPropertySheetRegKey = strRegKey + g_szPropertySheet;
        
        TCHAR strPropertySheetRegKey[256];
        _tcscpy(strPropertySheetRegKey, strRegKey);
        _tcscat(strPropertySheetRegKey, g_szPropertySheet);

		regkeyPropertySheet.CreateKey(regkeyNodeTypes, strPropertySheetRegKey);

		lRes = regkeyPropertySheet.WriteRegString(lpszExtensionSnapinGuid, lpszSnapinDescription);

		ASSERT(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
			// Trace0("RegisterAsExtension: Cannot create PropertySheet extension key\n");
            return lRes;
		}
	}

	if (dwExtensionType & EXTENSION_TYPE_TASK)
	{
		CRegistry regkeyTask;
		//CString strTaskRegKey = strRegKey + g_szTask;
        TCHAR strTaskRegKey[256];
        _tcscpy(strTaskRegKey, strRegKey);
        _tcscat(strTaskRegKey, g_szTask);


		regkeyTask.CreateKey(regkeyNodeTypes, strTaskRegKey);

		lRes = regkeyTask.WriteRegString(lpszExtensionSnapinGuid, lpszSnapinDescription);
		ASSERT(lRes == ERROR_SUCCESS);

		if (lRes != ERROR_SUCCESS)
		{
			//Trace0("RegisterAsExtension: Cannot create Task extension key\n");
			return lRes; // failed to create
		}
	}

	return lRes;
}

///*!--------------------------------------------------------------------------
//	UnregisterAsExtensionGUID
//		Removes registry entries for a node as an extension
//	Author:
// ---------------------------------------------------------------------------*/
//HRESULT
//UnregisterAsExtensionGUID
//(
//	const GUID* pGuidNodeToExtend,
//	const GUID* pGuidExtensionSnapin,
//	DWORD		dwExtensionType
//)
//{
//	return UnregisterAsRequiredExtensionGUID(pGuidNodeToExtend,
//											 pGuidExtensionSnapin,
//											 dwExtensionType,
//											 NULL);
//}
//
///*!--------------------------------------------------------------------------
//	UnregisterAsExtension
//		Removes registry entries for a node as an extension
//	Author:
// ---------------------------------------------------------------------------*/
//HRESULT
//UnregisterAsExtension
//(
//	LPCWSTR lpszNodeToExtendGuid,
//	LPCWSTR lpszExtendingNodeGuid,
//	DWORD	dwExtensionType
//)
//{
//	return UnregisterAsRequiredExtension(lpszNodeToExtendGuid,
//										 lpszExtendingNodeGuid,
//										 dwExtensionType,
//										 NULL);
//}
//
///*!--------------------------------------------------------------------------
//	UnregisterAsRequiredExtensionGUID
//		Removes registry entries for a node as an extension
//	Author:
// ---------------------------------------------------------------------------*/
//HRESULT
//UnregisterAsRequiredExtensionGUID
//(
//	const GUID* pGuidNodeToExtend,
//	const GUID* pGuidExtensionSnapin,
//	DWORD		dwExtensionType,
//	const GUID* pGuidRequiredPrimarySnapin
//)
//{
//	USES_CONVERSION;
//	OLECHAR szGuidNodeToExtend[128];
//	OLECHAR szGuidExtensionSnapin[128];
//	OLECHAR szGuidRequiredPrimarySnapin[128];
//	OLECHAR szGuidRequiredExtensionSnapin[128];
//	OLECHAR * pszGuidRequiredPrimarySnapin = NULL;
//
//	::StringFromGUID2(*pGuidNodeToExtend, szGuidNodeToExtend, 128);
//	::StringFromGUID2(*pGuidExtensionSnapin, szGuidExtensionSnapin, 128);
//
//	if (pGuidRequiredPrimarySnapin)
//	{
//		ASSERT(pGuidExtensionSnapin);
//
//		::StringFromGUID2(*pGuidRequiredPrimarySnapin, szGuidRequiredPrimarySnapin, 128);
//		pszGuidRequiredPrimarySnapin = szGuidRequiredPrimarySnapin;
//
//		::StringFromGUID2(*pGuidExtensionSnapin, szGuidExtensionSnapin, 128);
//	}
//
//	return UnregisterAsRequiredExtension(szGuidNodeToExtend,
//										 szGuidExtensionSnapin,
//										 dwExtensionType,
//										 pszGuidRequiredPrimarySnapin);
//
//}
//
///*!--------------------------------------------------------------------------
//	UnregisterAsRequiredExtension
//		Removes registry entries for a node as an extension
//	Author:
// ---------------------------------------------------------------------------*/
//HRESULT
//UnregisterAsRequiredExtension
//(
//	LPCWSTR lpszNodeToExtendGuid,
//	LPCWSTR lpszExtensionSnapinGuid,
//	DWORD	dwExtensionType,
//	LPCWSTR lpszRequiredPrimarySnapin
//)
//{
//	CRegistry regkeyNodeTypes;
//	CString strDynamicExtensions;
//
//	LONG lRes = regkeyNodeTypes.OpenKey(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY);
//	ASSERT(lRes == ERROR_SUCCESS);
//
//	if (lRes != ERROR_SUCCESS)
//	{
//		SetRegError(0, HRESULT_FROM_WIN32(lRes),
//					IDS_ERR_REG_OPEN_CALL_FAILED,
//					g_szHKLM, NODE_TYPES_KEY, NULL);
//		return HRESULT_FROM_WIN32(lRes); // failed to open
//	}
//
//	CRegistry regkeyNodeToExtend;
//	lRes = regkeyNodeToExtend.OpenKey(regkeyNodeTypes, lpszNodeToExtendGuid);
//	if (lRes != ERROR_SUCCESS)
//	{
//		SetRegError(0, HRESULT_FROM_WIN32(lRes),
//					IDS_ERR_REG_OPEN_CALL_FAILED,
//					g_szHKLM,
//					NODE_TYPES_KEY,
//					lpszNodeToExtendGuid, NULL);
//		Trace1("UnregisterAsExtension: Node To extend (%s) does not exist\n", lpszNodeToExtendGuid);
//		return HRESULT_FROM_WIN32(lRes); // failed to create
//	}
//
//    // check to see if we need to remove the dynamic extension stuff
//	if (lpszRequiredPrimarySnapin)
//	{
//		CRegistry regkeyDynExt;
//
//		// open dynamic extensions key
//		lRes = regkeyDynExt.OpenKey(regkeyNodeToExtend, g_szDynamicExtensions);
//    	if (lRes == ERROR_SUCCESS)
//		{
//			// now remove the value
//    		regkeyDynExt.DeleteValue(lpszExtensionSnapinGuid);
//		}
//	}
//
//	CRegistry regkeyExtensionKey;
//	lRes = regkeyExtensionKey.OpenKey(regkeyNodeToExtend, g_szExtensions);
//	if (lRes != ERROR_SUCCESS)
//	{
//		SetRegError(0, HRESULT_FROM_WIN32(lRes),
//					IDS_ERR_REG_OPEN_CALL_FAILED,
//					g_szHKLM,
//					NODE_TYPES_KEY,
//					lpszNodeToExtendGuid,
//					g_szExtensions, NULL);
//		Trace0("UnregisterAsExtension: Node To extend Extensions subkey does not exist\n");
//		return HRESULT_FROM_WIN32(lRes); // failed to create
//	}
//
//	if (dwExtensionType & EXTENSION_TYPE_NAMESPACE)
//	{
//		CRegistry regkeyNameSpace;
//		lRes = regkeyNameSpace.OpenKey(regkeyExtensionKey, g_szNameSpace);
//		ASSERT(lRes == ERROR_SUCCESS);
//
//		while (lRes != ERROR_SUCCESS)
//		{
//			SetRegError(0, HRESULT_FROM_WIN32(lRes),
//						IDS_ERR_REG_OPEN_CALL_FAILED,
//						g_szHKLM,
//						NODE_TYPES_KEY,
//						lpszNodeToExtendGuid,
//						g_szExtensions,
//						g_szNameSpace, NULL);
//			Trace0("UnregisterAsExtension: Node To extend NameSpace subkey does not exist\n");
//			//return HRESULT_FROM_WIN32(lRes); // failed to create
//			break;
//		}
//
//		regkeyNameSpace.DeleteValue(lpszExtensionSnapinGuid);
//	}
//
//	if (dwExtensionType & EXTENSION_TYPE_CONTEXTMENU)
//	{
//		CRegistry regkeyContextMenu;
//		lRes = regkeyContextMenu.OpenKey(regkeyExtensionKey, g_szContextMenu);
//		ASSERT(lRes == ERROR_SUCCESS);
//
//		while (lRes != ERROR_SUCCESS)
//		{
//			SetRegError(0, HRESULT_FROM_WIN32(lRes),
//						IDS_ERR_REG_OPEN_CALL_FAILED,
//						g_szHKLM,
//						NODE_TYPES_KEY,
//						lpszNodeToExtendGuid,
//						g_szExtensions,
//						g_szContextMenu, NULL);
//			Trace0("UnregisterAsExtension: Node To extend ContextMenu subkey does not exist\n");
//			//return HRESULT_FROM_WIN32(lRes); // failed to create
//			break;
//		}
//
//		regkeyContextMenu.DeleteValue(lpszExtensionSnapinGuid);
//	}
//
//	if (dwExtensionType & EXTENSION_TYPE_TOOLBAR)
//	{
//		CRegistry regkeyToolbar;
//		lRes = regkeyToolbar.OpenKey(regkeyExtensionKey, g_szToolbar);
//		ASSERT(lRes == ERROR_SUCCESS);
//
//		while (lRes != ERROR_SUCCESS)
//		{
//			SetRegError(0, HRESULT_FROM_WIN32(lRes),
//						IDS_ERR_REG_OPEN_CALL_FAILED,
//						g_szHKLM,
//						NODE_TYPES_KEY,
//						lpszNodeToExtendGuid,
//						g_szExtensions,
//						g_szToolbar, NULL);
//			Trace0("UnregisterAsExtension: Node To extend Toolbar subkey does not exist\n");
//			//return HRESULT_FROM_WIN32(lRes); // failed to create
//			break;
//		}
//
//		regkeyToolbar.DeleteValue(lpszExtensionSnapinGuid);
//	}
//
//	if (dwExtensionType & EXTENSION_TYPE_PROPERTYSHEET)
//	{
//		CRegistry regkeyPropertySheet;
//		lRes = regkeyPropertySheet.OpenKey(regkeyExtensionKey, g_szPropertySheet);
//		ASSERT(lRes == ERROR_SUCCESS);
//
//		while (lRes != ERROR_SUCCESS)
//		{
//			SetRegError(0, HRESULT_FROM_WIN32(lRes),
//						IDS_ERR_REG_OPEN_CALL_FAILED,
//						g_szHKLM,
//						NODE_TYPES_KEY,
//						lpszNodeToExtendGuid,
//						g_szExtensions,
//						g_szPropertySheet, NULL);
//			Trace0("UnregisterAsExtension: Node To extend PropertySheet subkey does not exist\n");
//			//return HRESULT_FROM_WIN32(lRes); // failed to create
//            break;
//		}
//
//		regkeyPropertySheet.DeleteValue(lpszExtensionSnapinGuid);
//	}
//
//	return HRESULT_FROM_WIN32(lRes);
//}
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\maksassert.h ===
#ifndef _maksassert_h_
#define _maksassert_h_
/*
*  Copyright (c) 1996  Microsoft Corporation
*
*  Module Name:
*
*      maksassert.h
*
*  Abstract:
*
*      Defines assert, verify macros.
*      remove maksassert.h and maksassert.cpp from project when we get a good assert.
*       // maks_todo : remove this code when we get proper ASSERT headers.
*
*  Author:
*
*      Makarand Patwardhan  - March 6, 1998
*
*  Comments
*   This file is here only because I could not find the right friendly assert includes.
*    maks_todo : should be removed later.
*/



#ifdef DBG

void MaksAssert(LPCTSTR exp, LPCTSTR file, int line);

#define ASSERT(exp) (void)( (exp) || (MaksAssert(_T(#exp), _T(__FILE__), __LINE__), 0) )
#define VERIFY(exp) (void)( (exp) || (MaksAssert(_T(#exp), _T(__FILE__), __LINE__), 0) )

#else

#define	ASSERT(exp)
#define VERIFY(exp) (exp)

#endif



#endif // _maksassert_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\register.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    register.h

    FILE HISTORY:
        
*/

#ifndef _REGISTER_H
#define _REGISTER_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#ifndef __mmc_h__
#include <mmc.h>
#endif


#define EXTENSION_TYPE_NAMESPACE		( 0x00000001 )
#define EXTENSION_TYPE_CONTEXTMENU		( 0x00000002 )
#define EXTENSION_TYPE_TOOLBAR			( 0x00000004 )
#define EXTENSION_TYPE_PROPERTYSHEET	( 0x00000008 )
#define EXTENSION_TYPE_TASK         	( 0x00000010 )

// functions to register/unregister a snapin
DWORD RegisterSnapinGUID(const GUID* pSnapinCLSID, 
						  const GUID* pStaticNodeGUID, 
						  const GUID* pAboutGUID, 
						  LPCWSTR lpszNameStringNoValueName, 
						  LPCWSTR lpszVersion, 
						  BOOL bStandalone);

DWORD RegisterSnapin(LPCWSTR lpszSnapinClassID, 
					   LPCWSTR lpszStaticNodeGuid, 
					   LPCWSTR lpszAboutGuid, 
					   LPCWSTR lpszNameString, 
					   LPCWSTR lpszVersion,
					   BOOL bStandalone);

DWORD UnregisterSnapinGUID(const GUID* pSnapinCLSID);
DWORD UnregisterSnapin(LPCWSTR lpszSnapinClassID);

DWORD AddNodeType(const GUID* pSnapinCLSID, const GUID* pStaticNodeGUID);

// functions to register/unregister node types
HRESULT RegisterNodeTypeGUID(const GUID* pGuidSnapin, 
										  const GUID* pGuidNode, 
										  LPCWSTR lpszNodeDescription);
HRESULT RegisterNodeType(LPCWSTR lpszGuidSnapin, 
									  LPCWSTR lpszGuidNode, 
									  LPCWSTR lpszNodeDescription);



HRESULT UnregisterNodeTypeGUID(const GUID* pGuid);
HRESULT UnregisterNodeType(LPCWSTR lpszNodeGuid);

// functions to register as an extension
DWORD RegisterAsExtensionGUID(const GUID* pGuidNodeToExtend, 
											 const GUID* pGuidExtendingNode, 
											 LPCWSTR	 lpszNodeDescription,
											 DWORD		 dwExtensionType);

HRESULT RegisterAsExtension(LPCWSTR	lpszNodeToExtendGuid, 
										 LPCWSTR	lpszExtendingNodeGuid, 
										 LPCWSTR	lpszNodeDescription,
										 DWORD		dwExtensionType);

DWORD RegisterAsRequiredExtensionGUID(const GUID* pGuidNodeToExtend, 
													 const GUID* pGuidExtensionSnapin, 
													 LPCWSTR	 lpszNodeDescription,
													 DWORD		 dwExtensionType,
													 const GUID* pGuidRequiredPrimarySnapin);


DWORD RegisterAsRequiredExtension(LPCWSTR	lpszNodeToExtendGuid, 
												 LPCWSTR	lpszExtensionSnapin, 
												 LPCWSTR	lpszNodeDescription,
												 DWORD		dwExtensionType,
												 LPCWSTR	lpszRequiredPrimarySnapin);

// functions to unregister as an extension
HRESULT UnregisterAsExtensionGUID(const GUID* pGuidNodeToExtend, 
											   const GUID* pGuidExtension, 
											   DWORD	   dwExtensionType);
HRESULT UnregisterAsExtension(LPCWSTR lpszNodeToExtendGuid, 
										   LPCWSTR lpszExtension, 
										   DWORD   dwExtensionType);

HRESULT UnregisterAsRequiredExtensionGUID(const GUID* pGuidNodeToExtend, 
													   const GUID* pGuidExtension, 
													   DWORD	   dwExtensionType,
													   const GUID* pGuidRequiredPrimarySnapin);

HRESULT UnregisterAsRequiredExtension(LPCWSTR lpszNodeToExtendGuid, 
												   LPCWSTR lpszExtensionGuid, 
												   DWORD   dwExtensionType,
												   LPCWSTR lpszRequiredPrimarySnapin);




// Registry error reporting API helpers
void ReportRegistryError(DWORD dwReserved, HRESULT hr, UINT nFormat, LPCTSTR pszFirst, va_list argptr);

void SetRegError(DWORD dwReserved, HRESULT hr, UINT nFormat, LPCTSTR pszFirst, ...);
#endif _REGISTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B52C1E46_1DD2_11D1_BC43_00C04FC31FD3__INCLUDED_)
#define AFX_STDAFX_H__B52C1E46_1DD2_11D1_BC43_00C04FC31FD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/*
#if defined(DBG) && !defined(_DEBUG)

// since we are using mfc, we should have _DEBUG defind if DBG is
// you might also want to set DEBUG_CRTS in source file to get rid of the linker errors.
#error DBG Defined but _DEBUG is not!

#endif

#if defined(_DEBUG) &&  !defined(DBG)

// since we are using mfc, we should have not have _DEBUG defind if DBG is not
#error _DEBUG defined but DBG is not!

#endif
*/



#define STRICT
/*
#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxmt.h>
#include <afxdlgs.h>
*/
/*
#include <windows.h>
//#include <tchar.h>
#include <time.h>
#include <stdio.h>
#include <setupapi.h>
#include <prsht.h>
*/
// #define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#ifdef _WIN32_IE
#undef _WIN32_IE
#endif
#define _WIN32_IE 0x0400


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef _RTM_
#include <ntsam.h>
#endif
/*#include <ntlsa.h>
*/

#include <windows.h>
#include <prsht.h>
#include <commctrl.h>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
 #include <shlobj.h>
#include <dsclient.h>
#include <mmc.h>
#include <lm.h>
#include <aclapi.h>

#include "winsta.h"
#ifdef _RTM_
#ifdef __cplusplus
extern "C" {
#endif
#include <regsam.h>
#ifdef __cplusplus
}
#endif
#endif
// for 'trace' debuging (sample remnants)
#ifdef DBG
#define ODS OutputDebugString
#define VERIFY_E( retval , expr ) \
    if( ( expr ) == retval ) \
    {  \
       ODS( L#expr ); \
       ODS( L" returned "); \
       ODS( L#retval ); \
       ODS( L"\n" ); \
    } \

#define VERIFY_S( retval , expr ) \
    if( ( expr ) != retval ) \
{\
      ODS( L#expr ); \
      ODS( L" failed to return " ); \
      ODS( L#retval ); \
      ODS( L"\n" ); \
}\

#define ASSERT_( expr ) \
    if( !( expr ) ) \
    { \
       char tchAssertErr[ 256 ]; \
       wsprintfA( tchAssertErr , "Assertion in expression ( %s ) failed\nFile - %s\nLine - %d\nDo you wish to Debug?", #expr , (__FILE__) , __LINE__ ); \
       if( MessageBoxA( NULL , tchAssertErr , "ASSERTION FAILURE" , MB_YESNO | MB_ICONERROR )  == IDYES ) \
       {\
            DebugBreak( );\
       }\
    } \

#else

#define ODS
#define VERIFY_E( retval , expr ) ( expr )
#define VERIFY_S( retval , expr ) ( expr )
#define ASSERT_( expr )

#endif

//#define ASSERT _ASSERT
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B52C1E46_1DD2_11D1_BC43_00C04FC31FD3__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\registry.h ===
/*--------------------------------------------------------------------------------------------------------
*  Copyright (c) 1998  Microsoft Corporation
*
*  Module Name:
*
*      Registry.h
*
*  Abstract:
*
*      declaration of a simple registry class CRegistry.
*
*
*
*  Author:
*
*      Makarand Patwardhan  - April 9, 1997
*
* -------------------------------------------------------------------------------------------------------*/

#if !defined(AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_)
#define AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include <winreg.h>


class CRegistry
{
private:

    LPBYTE      m_pMemBlock;
    HKEY        m_hKey;
    int         m_iEnumIndex;
    int         m_iEnumValueIndex;

    DWORD       ReadReg             (LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype);
    void *      Allocate            (DWORD dwSize);

#ifdef DBG
    DWORD       m_dwSizeDebugOnly;
#endif

public:
                CRegistry           ();
    virtual     ~CRegistry          ();
    void        Release             ();

    operator    HKEY                ()    {return m_hKey;}


    DWORD       OpenKey             (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS);
    DWORD       CreateKey           (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS, DWORD *pDisposition = NULL);

    DWORD       DeleteValue         (LPCTSTR lpValue);
    DWORD       RecurseDeleteKey    (LPCTSTR lpSubKey);
    
    DWORD       ReadRegString       (LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw);
    DWORD       ReadRegDWord        (LPCTSTR lpValue, DWORD *pdw);
    DWORD       ReadRegMultiString  (LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw);
    DWORD       ReadRegBinary       (LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw);

    DWORD       WriteRegString      (LPCTSTR lpValueName, LPCTSTR lpStr);
    DWORD       WriteRegMultiString (LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize);

    DWORD       GetFirstSubKey      (LPTSTR *lppStr, DWORD *pdw);
    DWORD       GetNextSubKey       (LPTSTR *lppStr, DWORD *pdw);

    DWORD       GetFirstValue       (LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType);
    DWORD       GetNextValue        (LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType);
};

#endif // !defined(AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_)

//EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tsuserex.rc
//
#define IDD_CUSTOMIZE                   101
#define IDR_USEREX_INTERFACES           102
#define IDD_PAGE_PROFILE                102
#define IDR_EXTCOPYNOUI                 105
#define IDD_PAGE_TIMEOUTS               133
#define IDD_PAGE_ENVIRO                 134
#define IDD_PAGE_SHADOW                 137
#define IDC_EDIT_HOURS                  1000
#define IDC_RADIO_DISCON                1001
#define IDC_EDIT_MINUTES                1001
#define IDC_RADIO_RESET                 1002
#define IDC_STATIC_ME                   1002
#define IDC_EDIT_WDIR                   1003
#define IDC_EDIT_CMDLINE                1004
#define IDC_SPIN_CTRL                   1004
#define IDC_CHECK_USEDEFAULT            1005
#define IDC_COMBO_CONNECT               1006
#define IDC_CHECK_CCDL                  1007
#define IDC_STATIC_WD                   1008
#define IDC_COMBO_DISCON                1009
#define IDC_STATIC_CMD                  1010
#define IDC_STATIC_CONNECTION           1010
#define IDC_COMBO_IDLE                  1011
#define IDC_EDIT_USRPROFILE             1012
#define IDC_STATIC_DISCON               1012
#define IDC_USER_PROFILE                1013
#define IDC_STATIC_IDLE                 1013
#define IDC_RADIO_WATCH                 1014
#define IDC_STATIC_ONBROKENCON          1014
#define IDC_RADIO_CONTROL               1015
#define IDC_STATIC_RECONDISCON          1015
#define IDC_RADIO_ANYCLIENT             1016
#define IDC_CHECK_NOTIFY                1017
#define IDC_RADIO_PREVCLIENT            1018
#define IDC_CHECK_CCPL                  1019
#define IDC_CHECK_DMCP                  1020
#define IDC_RADIO_LOCAL                 1021
#define IDC_EDIT_LOCALPATH              1022
#define IDC_CHECK_SHADOW                1023
#define IDC_RADIO_REMOTE                1024
#define IDC_EDIT_REMOTEPATH             1025
#define IDC_CHECK_ALLOWLOGON            1026
#define IDC_COMBO_DRIVES                1027
#define IDC_TSP_DRIVE                   1028
#define IDS_COMBO_TIME1                 18614
#define IDS_COMBO_TIME2                 18615
#define IDS_COMBO_TIME3                 18616
#define IDS_COMBO_TIME4                 18617
#define IDS_COMBO_TIME5                 18618
#define IDS_COMBO_TIME6                 18619
#define IDS_BACKSLASH                   18631
#define IDS_ERROR_PATH                  18632
#define IDS_ERROR_REMOTEPATH            18633
#define IDS_ERROR_NETPATH               18634
#define IDS_WARN_PATH                   18635
#define IDS_ERROR_TITLE                 18636
#define IDS_WARN_TITLE                  18637
#define IDS_HELPFILE                    18638
#define IDS_ERROR_NUMERICENTRY          18639
#define IDS_NOTIMEOUT                   18640
#define IDS_CUSTOMIZE                   18641
#define IDS_DIGIT_DOT_DIGIT_TU          18644
#define IDS_DIGIT_TU                    18645
#define IDS_DAYS                        18647
#define IDS_DAY                         18648
#define IDS_HOURS                       18649
#define IDS_HOUR                        18650
#define IDS_MINUTES                     18651
#define IDS_MINUTE                      18652
#define IDS_D                           18653
#define IDS_H                           18654
#define IDS_M                           18655
#define IDS_HR                          18656
#define IDS_HRS                         18657
#define IDS_MIN                         18658
#define IDS_ERROR_TOOMANYDIGITS         18659
#define IDS_ERROR_PARSEINVALID          18660
#define IDS_ERROR_MAXVALEXCEEDED        18661
#define IDS_NAMESTRING_SNAPIN           18662
#define IDS_PROVIDER_SNAPIN             18663
#define IDS_VERSION_SNAPIN              18664
#define IDS_TSGETPROPSFAILED            18665
#define IDS_TSGETPROPTITLE              18666
#define IDS_COMBO_CONNECTION            18667
#define IDS_COMBO_DISCONNECTION         18668
#define IDS_COMBO_IDLECONNECTION        18669
#define IDS_TSOPSFAILED                 18670
#define IDS_TSUSERHELP                  18671
#define IDS_USERNAME                    18672
#define IDS_HOME_DIR_EXISTS				18673
#define IDS_HOME_DIR_CREATE_FAILED		18674
#define IDS_HOME_DIR_CREATE_NO_ACCESS	18675
#define IDS_ERR_CREATE_DIR				18676

#define ID_WHATSTHIS_WHATSTHIS          40002
    
#define IDC_STATIC_LEVELOFCTRL          -2
#define IDC_STATIC                      -1
#define IDC_TSP_DIRECTORY               -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\tsuserex.cpp ===
// tsuserex.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL,
//		run nmake -f tsexusrmps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "tsuserex.h"       // generated file. class ids.
#include "tsuserex_i.c"     // generated file. class ids.
#include "interfaces.h"     // Definition of the TSUserExInterfaces class
#ifdef _RTM_
#include "tsusrcpy.h"
#endif

#define GUIDSIZE 40

TCHAR tchSnapinRegKey[] = TEXT( "Software\\Microsoft\\MMC\\SnapIns\\" );

TCHAR tchNodeRegKey[] = TEXT( "Software\\Microsoft\\MMC\\NodeTypes\\" );

TCHAR tchExtKey[] = TEXT( "\\Extensions\\PropertySheet" );

HRESULT Local_RegisterNodeType( const GUID *pGuidNodeType , const GUID *pGuidExtension  , LPTSTR szDescription );

HRESULT Local_RegisterSnapinExt( const GUID *pGuidToRegister , const GUID *pAboutGuid , LPTSTR szNameString , LPTSTR szProvider , LPTSTR szVersion );

HRESULT Local_VerifyNodeType( const GUID *pGuidSnapin , const GUID *pGuidSnapinNodeTypeToVerify );

HINSTANCE ghInstance;
HINSTANCE GetInstance()
{
    return ghInstance;
}

CComModule _Module;

// this object has IExtendPropertySheet interface.
BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_TSUserExInterfaces, TSUserExInterfaces)
#ifdef _RTM_
    OBJECT_ENTRY(CLSID_ExtCopyNoUI, CExtCopyNoUI )
#endif
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
        ghInstance = hInstance;

		_Module.Init(ObjectMap, hInstance);

		DisableThreadLibraryCalls(hInstance);
        

	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        // LOGMESSAGE0(_T("DllMain::Process being Detached..."));
		_Module.Term();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    // LOGMESSAGE1(_T("DllCanUnloadNow..Returing %s"), _Module.GetLockCount()==0 ? _T("S_OK") : _T("S_FALSE"));
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    // LOGMESSAGE0(_T("DllGetClassObject.."));
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

/* extern */ const CLSID CLSID_LocalUser =
{  /* 5d6179c8-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179c8,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};
/* extern */ const GUID NODETYPE_User =
{ /* 5d6179cc-17ec-11d1-9aa9-00c04fd8fe93 */
   0x5d6179cc,
   0x17ec,
   0x11d1,
   {0x9a, 0xa9, 0x00, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};


// /* extern */ const GUID NODETYPE_DSUser =
//{ /* 228D9A84-C302-11CF-9AA4-00AA004A5691 */
//   0x228D9A84,
//   0xC302,
//   0x11CF,
//   {0x9A, 0xA4, 0x00, 0xAA, 0x00, 0x4A, 0x56, 0x91}
//};


// DS Snapin CLSID - {E355E538-1C2E-11d0-8C37-00C04FD8FE93}
const GUID CLSID_DSSnapin =
{
    0xe355e538, 
    0x1c2e, 
    0x11d0, 
    {0x8c, 0x37, 0x0, 0xc0, 0x4f, 0xd8, 0xfe, 0x93}
};


/* extern */ const GUID NODETYPE_DSUser =
{ /* BF967ABA-0DE6-11D0-A285-00AA003049E2 */
   0xBF967ABA,
   0x0DE6,
   0x11D0,
   {0xA2, 0x85, 0x00, 0xAA, 0x00, 0x30, 0x49, 0xE2}
};
// bf967aba0de611d0a28500aa003049e2



STDAPI DllRegisterServer(void)
{ 
    TCHAR tchNameString[ 160 ];
    TCHAR tchProvider[ 160 ];
    TCHAR tchVersion[ 16 ];

    HRESULT hr = _Module.RegisterServer(TRUE);

    if( SUCCEEDED( hr ) )
    {
        //	register it as extension to localsecurity snapin

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NAMESTRING_SNAPIN , tchNameString , sizeof( tchNameString ) / sizeof( TCHAR ) ) );

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROVIDER_SNAPIN , tchProvider , sizeof( tchProvider ) / sizeof( TCHAR ) ) );

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_VERSION_SNAPIN , tchVersion , sizeof( tchVersion ) / sizeof( TCHAR ) ) );


        hr = Local_RegisterSnapinExt( &CLSID_TSUserExInterfaces ,
                                      &CLSID_TSUserExInterfaces ,
                                      tchNameString ,
                                      tchProvider ,
                                      tchVersion
                                     );
    }

    if( SUCCEEDED( hr ) )
    {
        hr = Local_RegisterNodeType( &NODETYPE_User , &CLSID_TSUserExInterfaces , _T( "Terminal Server property page extension" ) );
    }

    if( SUCCEEDED( hr ) )
    {
        // the dsadmin snapin does not list all its node, as there are lot of them
        // so before registring ourself to extend the node,
        // lets write the nodeType we are going to extend into registry ourselves
        
        hr = Local_VerifyNodeType( &CLSID_DSSnapin , &NODETYPE_DSUser );
    }

    if( SUCCEEDED( hr ) )
    {
        hr = Local_RegisterNodeType( &NODETYPE_DSUser , &CLSID_TSUserExInterfaces , _T( "Terminal Server property page extension" ) );
    }

    return hr;
}

//---------------------------------------------------------------------------
// Local_VerifyNodeType
// Checks first to see if NodeType exists, if not it'll create it
//---------------------------------------------------------------------------
HRESULT Local_VerifyNodeType( const GUID *pGuidSnapin , const GUID *pGuidSnapinNodeTypeToVerify )
{
    OLECHAR szSnapin[ GUIDSIZE ];

    OLECHAR szSnapinNodeType[ GUIDSIZE ];

    HKEY hKey;

    ASSERT_( pGuidSnapin != NULL );

    ASSERT_( pGuidSnapinNodeTypeToVerify != NULL );

    TCHAR tchRegKeyName[ MAX_PATH ];

    if( StringFromGUID2( *pGuidSnapin , szSnapin , GUIDSIZE ) == 0 )
    {
        return E_INVALIDARG;
    }

    if( StringFromGUID2( *pGuidSnapinNodeTypeToVerify , szSnapinNodeType , GUIDSIZE ) == 0 )
    {
        return E_INVALIDARG;
    }
    
    lstrcpy( tchRegKeyName , tchSnapinRegKey );

    lstrcat( tchRegKeyName , szSnapin );

    lstrcat( tchRegKeyName , _T( "\\NodeTypes\\" ) );

    lstrcat( tchRegKeyName , szSnapinNodeType );

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE , tchRegKeyName , 0 , KEY_READ , &hKey ) != ERROR_SUCCESS )
    {
        // Key does not exist
        // Create the nodetype in snapin and in NodeType

        DWORD disp;

        if( RegCreateKeyEx( HKEY_LOCAL_MACHINE , tchRegKeyName , 0 , NULL , REG_OPTION_NON_VOLATILE , KEY_ALL_ACCESS , NULL , &hKey , &disp ) != ERROR_SUCCESS )
        {
            return E_FAIL;
        }

        RegCloseKey( hKey );

        lstrcpy( tchRegKeyName , tchNodeRegKey );

        lstrcat( tchRegKeyName , szSnapinNodeType );

        if( RegCreateKeyEx( HKEY_LOCAL_MACHINE , tchRegKeyName , 0 , NULL , REG_OPTION_NON_VOLATILE , KEY_ALL_ACCESS , NULL , &hKey , &disp ) != ERROR_SUCCESS )
        {
            return E_FAIL;
        }

    }

    RegCloseKey( hKey );

    return S_OK;
}

//---------------------------------------------------------------------------
// Local_RegisterSnapinExt
// Creates the extension node reg keys 
//---------------------------------------------------------------------------
HRESULT Local_RegisterSnapinExt( const GUID *pGuidToRegister , const GUID *pAboutGuid , LPTSTR szNameString , LPTSTR szProvider , LPTSTR szVersion )
{
    OLECHAR szGuid[ GUIDSIZE ];

    TCHAR tchRegKeyName[ MAX_PATH ];

    HKEY hKey;

    HKEY hSubKey = NULL;

    HRESULT hr = E_FAIL;

    ASSERT_( pGuidToRegister != NULL );
    ASSERT_( pAboutGuid != NULL );
    ASSERT_( szNameString != NULL );
    ASSERT_( szProvider != NULL );
    ASSERT_( szVersion != NULL );

    lstrcpy( tchRegKeyName , tchSnapinRegKey );

    if( StringFromGUID2( *pGuidToRegister , szGuid , GUIDSIZE ) == 0 )
    {
        return E_INVALIDARG;
    }

    lstrcat( tchRegKeyName , szGuid );

    DWORD disp;

    do
    {
        if( RegCreateKeyEx( HKEY_LOCAL_MACHINE , tchRegKeyName , 0 , NULL , REG_OPTION_NON_VOLATILE , KEY_ALL_ACCESS , NULL , &hKey , &disp ) == ERROR_SUCCESS )
        {
            // if the key exist overwrite any and all values

            OLECHAR szAboutGuid[ GUIDSIZE ];

            if( StringFromGUID2( *pAboutGuid , szAboutGuid , GUIDSIZE ) > 0 )
            {
                RegSetValueEx( hKey , L"About" , 0 , REG_SZ , ( LPBYTE )szAboutGuid , sizeof( szAboutGuid ) );
            }

            // these calls should not fail but I'll test for it

            VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKey , L"NameString" , 0 , REG_SZ , ( LPBYTE )szNameString , sizeof( TCHAR ) * ( lstrlen( szNameString ) + 1 ) ) );

            VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKey , L"Provider" , 0 , REG_SZ , ( LPBYTE )szProvider , sizeof( TCHAR ) * ( lstrlen( szProvider ) + 1 ) ) );

            VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKey , L"Version" , 0 , REG_SZ , ( LPBYTE )szVersion , sizeof( TCHAR ) * ( lstrlen( szVersion ) + 1 ) ) );

            /*
			lstrcpy( tchRegKeyName , L"NodeTypes\\" );

            lstrcat( tchRegKeyName , szGuid );

            if( RegCreateKeyEx( hKey , tchRegKeyName , 0 , NULL , REG_OPTION_NON_VOLATILE , KEY_ALL_ACCESS , NULL , &hSubKey , &disp ) == ERROR_SUCCESS )
            {
                hr = S_OK;
            }
			*/
			hr = S_OK;
        }
    
    } while( 0 );

    RegCloseKey( hSubKey );

    RegCloseKey( hKey );

    return hr;

}

//---------------------------------------------------------------------------
// Local_RegisterNodeType
// pGuidToExt is the snapin we want to extend
// pGuidNodeType is the node in the snapin we'll register under
// pGuidExtension is us the property sheet extension
//---------------------------------------------------------------------------
HRESULT Local_RegisterNodeType( const GUID *pGuidNodeType , const GUID *pGuidExtension  , LPTSTR szDescription )
{    
    OLECHAR szGuidNode[ GUIDSIZE ];

    OLECHAR szGuidExt[ GUIDSIZE ];

    TCHAR tchRegKeyName[ MAX_PATH ];

    HKEY hKey;

    ASSERT_( pGuidNodeType != NULL );
    ASSERT_( pGuidExtension != NULL );
    ASSERT_( szDescription != NULL );

    lstrcpy( tchRegKeyName , tchNodeRegKey );


    if( StringFromGUID2( *pGuidNodeType , szGuidNode , GUIDSIZE ) == 0 )
    {
        return E_INVALIDARG;
    }

    if( StringFromGUID2( *pGuidExtension , szGuidExt , GUIDSIZE ) == 0 )
    {
        return E_INVALIDARG;
    }

    lstrcat( tchRegKeyName , szGuidNode );

    lstrcat( tchRegKeyName , tchExtKey );

    if( RegCreateKey( HKEY_LOCAL_MACHINE , tchRegKeyName , &hKey ) != ERROR_SUCCESS )
    {
        return E_FAIL;
    }

    RegSetValueEx( hKey , szGuidExt , 0 , REG_SZ , ( LPBYTE )szDescription , sizeof( TCHAR ) * ( lstrlen( szDescription ) + 1 ) );

    RegCloseKey( hKey );

    return S_OK;
}

//---------------------------------------------------------------------------
// Delete a key and all of its descendents.
//---------------------------------------------------------------------------
LONG RecursiveDeleteKey( HKEY hKeyParent , LPTSTR lpszKeyChild )
{
	// Open the child.
	HKEY hKeyChild;

	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild , 0 , KEY_ALL_ACCESS, &hKeyChild);

	if (lRes != ERROR_SUCCESS)
	{
		return lRes;
	}

	// Enumerate all of the decendents of this child.

	FILETIME time;

	TCHAR szBuffer[256];

	DWORD dwSize = sizeof( szBuffer ) / sizeof( TCHAR );

	while( RegEnumKeyEx( hKeyChild , 0 , szBuffer , &dwSize , NULL , NULL , NULL , &time ) == S_OK )
	{
        // Delete the decendents of this child.

		lRes = RecursiveDeleteKey(hKeyChild, szBuffer);

		if (lRes != ERROR_SUCCESS)
		{
			RegCloseKey(hKeyChild);

			return lRes;
		}

		dwSize = sizeof( szBuffer ) / sizeof( TCHAR );
	}

	// Close the child.

	RegCloseKey( hKeyChild );

	// Delete this child.

	return RegDeleteKey( hKeyParent , lpszKeyChild );
}

//---------------------------------------------------------------------------
// Local_UnRegisterSnapinExt
// reconstruct the enter key then delete key
//---------------------------------------------------------------------------
HRESULT Local_UnRegisterSnapinExt( const GUID *pGuidExt )
{
    TCHAR tchRegKeyName[ MAX_PATH ];

    OLECHAR szGuidExt[ GUIDSIZE ];

    ASSERT_( pGuidExt != NULL );
        
    lstrcpy( tchRegKeyName , tchSnapinRegKey );

    if( StringFromGUID2( *pGuidExt , szGuidExt , GUIDSIZE ) == 0 )
    {
        return E_INVALIDARG;
    }

    lstrcat( tchRegKeyName , szGuidExt );

    if( RecursiveDeleteKey( HKEY_LOCAL_MACHINE , tchRegKeyName ) == ERROR_SUCCESS )
    {
        return S_OK;
    }

    return S_FALSE;
}

//---------------------------------------------------------------------------
// Local_UnregisterNodeType
//---------------------------------------------------------------------------
HRESULT Local_UnregisterNodeType( const GUID *pGuid , const GUID *pDeleteThisGuid )
{
    OLECHAR szGuid[ GUIDSIZE ];

    OLECHAR szDeleteThisGuid[ GUIDSIZE ];
    
    HKEY hKey;

    ASSERT_( pGuid != NULL );
    ASSERT_( pDeleteThisGuid != NULL );

    TCHAR tchRegKeyName[ MAX_PATH ];

    lstrcpy( tchRegKeyName , tchNodeRegKey );

	if( StringFromGUID2( *pGuid , szGuid , GUIDSIZE ) == 0 )
    {
        return E_FAIL;
    }

    if( StringFromGUID2( *pDeleteThisGuid , szDeleteThisGuid , GUIDSIZE ) == 0 )
    {
        return E_FAIL;
    }
    
    lstrcat( tchRegKeyName , szGuid );
    
    lstrcat( tchRegKeyName , tchExtKey );
    
    if( RegOpenKey( HKEY_LOCAL_MACHINE , tchRegKeyName , &hKey ) != ERROR_SUCCESS )
    {
        return E_FAIL;
    }

    if( RegDeleteValue( hKey , szDeleteThisGuid ) == ERROR_SUCCESS )
    {
        RegCloseKey( hKey );
        
        return S_OK;
    }

    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    Local_UnRegisterSnapinExt( &CLSID_TSUserExInterfaces );

    Local_UnregisterNodeType( &NODETYPE_User , &CLSID_TSUserExInterfaces );

    Local_UnregisterNodeType( &NODETYPE_DSUser , &CLSID_TSUserExInterfaces );

    try
    {

    _Module.UnregisterServer();

    }

    catch( ... )
    {
        ODS( L"TSUSEREX : Exception thrown" );

        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\tsusrsht.cpp ===
//---------------------------------------------------------------------------
// Copyright (c) 1998, Microsoft Corporation
// All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential
//
// Author: alhen
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "tsusrsht.h"
//#include <dsgetdc.h>
#include <icanon.h>
#include <shlwapi.h>

// extern BOOL g_bPagesHaveBeenInvoked;
/*NTSTATUS GetDomainName( PWCHAR ServerNamePtr, // name of server to get domain of
                        LPTSTR DomainNamePtr // alloc and set ptr (free with NetApiBufferFree)
                       );
*/


WNDPROC CTimeOutDlg::m_pfWndproc = 0;

//-------------------------------------------------------------------------------
/*
static TOKTABLE tokday[ 4 ] = {
    { NULL , IDS_D },
    { NULL , IDS_DAY },
    { NULL , IDS_DAYS },
    { NULL , ( DWORD )-1 }
};

static TOKTABLE tokhour[ 6 ] = {
    { NULL , IDS_H     },
    { NULL , IDS_HR    },
    { NULL , IDS_HRS   },
    { NULL , IDS_HOUR  },
    { NULL , IDS_HOURS },
    { NULL , ( DWORD )-1 }
};

static TOKTABLE tokmin[ 5 ] = {
    { NULL , IDS_M       },
    { NULL , IDS_MIN     },
    { NULL , IDS_MINUTE  },
    { NULL , IDS_MINUTES },
    { NULL , ( DWORD )-1 }
};

  */
TCHAR * GetNextToken( TCHAR *pszString , TCHAR *tchToken );

void ErrorMessage1( HWND hParent , DWORD dwStatus );
void ErrorMessage2( HWND hParent , DWORD dwStatus );
void xxErrorMessage( HWND hParent , DWORD dwStatus , UINT );


//-------------------------------------------------------------------------------
// CTUSerDlg::ctor
//-------------------------------------------------------------------------------
CTSUserSheet::CTSUserSheet( )
{
    m_pstrMachinename = NULL;

    m_pstrUsername    = NULL;

    m_cref            = 0;

    m_bIsConfigLoaded = FALSE;

    m_szRemoteServerName[0] = 0;

	m_pUserSid = NULL;

    for( int tt = 0 ; tt < NUM_OF_PAGES ; ++tt )
    {
        m_pDlg[ tt ] = NULL;
    }
}

//-------------------------------------------------------------------------------
// CTUSerDlg::dtor
//-------------------------------------------------------------------------------
CTSUserSheet::~CTSUserSheet()
{
    if( m_pstrMachinename != NULL )
    {
        delete[] m_pstrMachinename;
    }

    if( m_pstrUsername != NULL )
    {
        delete[] m_pstrUsername;
    }

    for( int tt = 0 ; tt < NUM_OF_PAGES ; ++tt )
    {
        if( m_pDlg[ tt ] != NULL )
        {
            delete m_pDlg[ tt ];
        }
    }

	if( m_pUserSid != NULL )
	{
		delete[] m_pUserSid;		
	}

    ODS( TEXT("Main object released!\n") );
}

//-------------------------------------------------------------------------------
// AddRef
//-------------------------------------------------------------------------------
UINT CTSUserSheet::AddRef( )
{
    return ++m_cref;
}

//-------------------------------------------------------------------------------
// Release
//-------------------------------------------------------------------------------
UINT CTSUserSheet::Release( )
{
    if( --m_cref == 0 )
    {
        delete this;

        return 0;
    }
    return m_cref;
}

//-------------------------------------------------------------------------------
// SetServerAndUser
//-------------------------------------------------------------------------------
BOOL CTSUserSheet::SetServerAndUser( LPWSTR pwstrMachineName , LPWSTR pwstrUserName )
{
    if( pwstrMachineName != NULL && pwstrUserName != NULL )
    {
        KdPrint( ("TSUSEREX : SystemName %ws UserName %ws\n",pwstrMachineName,pwstrUserName) );

        DWORD dwLen = wcslen( pwstrMachineName );

        m_pstrMachinename = ( LPTSTR )new TCHAR [ dwLen + 1 ];

        if( m_pstrMachinename != NULL )
        {
            COPYWCHAR2TCHAR( m_pstrMachinename , pwstrMachineName );
        }

        dwLen = wcslen( pwstrUserName );

        m_pstrUsername = ( LPTSTR )new TCHAR[ dwLen + 1 ];

        if( m_pstrUsername != NULL )
        {
            COPYWCHAR2TCHAR( m_pstrUsername , pwstrUserName );
        }

        return TRUE;
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// AddPagesToPropSheet
//-------------------------------------------------------------------------------
HRESULT CTSUserSheet::AddPagesToPropSheet( LPPROPERTYSHEETCALLBACK pProvider )
{
    PROPSHEETPAGE psp;

    //
    // List of objects goes here
    //

    m_pDlg[0] = new CEnviroDlg( this );

    m_pDlg[1] = new CTimeOutDlg( this );

    m_pDlg[2] = new CShadowDlg( this );

    m_pDlg[3] = new CProfileDlg( this );

    //
    // Let each object initialize there own propsheet
    //

    for( int idx = 0; idx < NUM_OF_PAGES; ++idx )
    {
        if( m_pDlg[ idx ] != NULL )
        {
            if( !m_pDlg[ idx ]->GetPropertySheetPage( psp ) )
            {
                continue;
            }

            if( FAILED( pProvider->AddPage( CreatePropertySheetPage( &psp ) ) ) )
            {
                return E_FAIL;
            }

        }

    }

    return S_OK;
}

//-------------------------------------------------------------------------------
// AddPagesToDSAPropSheet
//-------------------------------------------------------------------------------
HRESULT CTSUserSheet::AddPagesToDSAPropSheet( LPFNADDPROPSHEETPAGE lpfnAddPage , LPARAM lp )
{
	PROPSHEETPAGE psp;

    //
    // List of objects goes here
    //

    m_pDlg[0] = new CEnviroDlg( this );

    m_pDlg[1] = new CTimeOutDlg( this );

    m_pDlg[2] = new CShadowDlg( this );

    m_pDlg[3] = new CProfileDlg( this );

    //
    // Let each object initialize there own propsheet
    //

    for( int idx = 0; idx < NUM_OF_PAGES; ++idx )
    {
        if( m_pDlg[ idx ] != NULL )
        {
            if( !m_pDlg[ idx ]->GetPropertySheetPage( psp ) )
            {
                continue;
            }

            lpfnAddPage( CreatePropertySheetPage( &psp ) , lp );
        }

    }

    return S_OK;
}

//-------------------------------------------------------------------------------
// SetUserConfig
//-------------------------------------------------------------------------------
BOOL CTSUserSheet::SetUserConfig( USERCONFIG& uc , PDWORD pdwStatus )
{
    ASSERT_( pdwStatus != NULL );

    if( IsBadReadPtr( &uc , sizeof( USERCONFIG ) ) )
    {
        return FALSE;
    }

    //
    //
    // mov         esi,dword ptr [uc]
    // mov         edi,dword ptr [this]
    // add         edi,1Ch
    // mov         ecx,27Ah
    // rep movs    dword ptr es:[edi],dword ptr [esi]
    //
    // is the codegen for struct = struct
    //
    m_userconfig = uc;

#if BETA_3

    TCHAR tchServerName[ MAX_PATH ];

    if( m_bDC )
    {
        ODS( L"TSUSEREX - Saving settings on remote or local-dc system\n" );

        lstrcpy( tchServerName , m_szRemoteServerName );
    }
    else
    {
        lstrcpy( tchServerName , m_pstrMachinename );
    }

#endif // BETA_3

    if( ( *pdwStatus = RegUserConfigSet( m_pstrMachinename , m_pstrUsername ,  &m_userconfig , sizeof( USERCONFIG ) ) ) == ERROR_SUCCESS )
    {
        return TRUE;
    }

    return FALSE;

}

//-------------------------------------------------------------------------------
// GetCurrentUserConfig
//-------------------------------------------------------------------------------
USERCONFIG& CTSUserSheet::GetCurrentUserConfig( PDWORD pdwStatus )
{
    *pdwStatus = ERROR_SUCCESS;

    if( !m_bIsConfigLoaded )
    {
        m_bIsConfigLoaded = GetUserConfig( pdwStatus );
    }

    // ASSERT_( m_bIsConfigLoaded );

    return m_userconfig;
}

//-------------------------------------------------------------------------------
// GetUserConfig
//-------------------------------------------------------------------------------
BOOL CTSUserSheet::GetUserConfig( PDWORD pdwStatus )
{
    ASSERT_( pdwStatus != NULL );
    //
    // This should only be called once
    //

    DWORD cbWritten = 0;

#if BETA_3

    PSERVER_INFO_101 psinfo;

    // check to see if we're trying to administer a local system that happens to be a dc

    *pdwStatus = NetServerGetInfo( NULL , 101 , ( LPBYTE * )&psinfo );

    KdPrint( ("TSUSEREX : NetServerGetInfo returned 0x%x\n",*pdwStatus ) );

    KdPrint( ("TSUSEREX : LastError was 0x%x\n",GetLastError( ) ) );

    if( *pdwStatus == NERR_Success )
    {
        // used to avoid access violation

        if( psinfo != NULL )
        {
            KdPrint( ("TSUSEREX : PSERVER_INFO_101 returned 0x%x\n",psinfo->sv101_type ) );

            m_bDC = ( BOOL )( psinfo->sv101_type & ( SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL ) );

            if( m_bDC )
            {
                // get the domaincontroller name of the remote machine

                DOMAIN_CONTROLLER_INFO *pdinfo;

                // m_pstrMachinename is really the domain name.  This was obtain
                // from LookUpAccountSid in interfaces.cpp

                *pdwStatus = DsGetDcName( NULL , m_pstrMachinename , NULL , NULL , DS_PDC_REQUIRED , &pdinfo );

                KdPrint( ( "TSUSEREX : DsGetDcName: %ws returned 0x%x\n", pdinfo->DomainControllerName , *pdwStatus ) );

                if( *pdwStatus == NO_ERROR )
                {
                    lstrcpy( m_szRemoteServerName , pdinfo->DomainControllerName );

                    NetApiBufferFree( pdinfo );
                }
                else
                {
                    m_szRemoteServerName[0] = 0;
                }

            }

            // not documented in the docs but NetServerGetInfo leaves it up to the caller to free up this blob

            NetApiBufferFree( psinfo );

        }

        TCHAR tchServerName[ MAX_PATH ];

        if( m_bDC )
        {
            lstrcpy( tchServerName , m_szRemoteServerName );
        }
        else
        {
            lstrcpy( tchServerName , m_pstrMachinename );
        }



        if( ( *pdwStatus = ( DWORD )RegUserConfigQuery( tchServerName , m_pstrUsername , &m_userconfig , sizeof( USERCONFIG ) , &cbWritten ) ) == ERROR_SUCCESS )
        {
            return TRUE;
        }

    }

#endif // BETA_3

    if( ( *pdwStatus = ( DWORD )RegUserConfigQuery( m_pstrMachinename , m_pstrUsername , &m_userconfig , sizeof( USERCONFIG ) , &cbWritten ) ) == ERROR_SUCCESS )
    {
        return TRUE;
    }


    ODS( L"TSUSEREX: We're getting default properties\n" );

    RegDefaultUserConfigQuery( m_pstrMachinename , &m_userconfig , sizeof( USERCONFIG ) , &cbWritten );

    return FALSE;
}

void CTSUserSheet::CopyUserSid( PSID psid )
{
	if( !IsValidSid( psid ) )
	{
		ODS( L"TSUSEREX : CTSUserSheet::CopyUserSid invalid arg\n" ) ;

		return;
	}

	m_pUserSid = psid;

}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

//-------------------------------------------------------------------------------
// Base class initi
//-------------------------------------------------------------------------------
CDialogBase::CDialogBase( )
{
     m_hWnd = NULL;
}

//-------------------------------------------------------------------------------
// Base initialization
//-------------------------------------------------------------------------------
BOOL CDialogBase::OnInitDialog( HWND hwnd , WPARAM , LPARAM )
{
    m_hWnd = hwnd;

    return FALSE;
}

//-------------------------------------------------------------------------------
// OnNotify - base class method
//-------------------------------------------------------------------------------
BOOL CDialogBase::OnNotify( int , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_APPLY )
    {
        if( !m_bPersisted )
        {
            m_bPersisted = PersistSettings( hDlg );
        }
    }

    else if( pnmh->code == PSN_KILLACTIVE )
    {
        if( !m_bPersisted )
        {
            if( !IsValidSettings( hDlg ) )
            {
                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , PSNRET_INVALID_NOCHANGEPAGE );

                return TRUE;
            }

        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// OnCOntextMenu -- base class operation
//-------------------------------------------------------------------------------
BOOL CDialogBase::OnContextMenu( HWND hwnd , POINT& )
{
    TCHAR tchHelpFile[ MAX_PATH ];

    if( m_hWnd == GetParent( hwnd ) )
    {
        //
        // Make sure its not a dummy window
        //

        if( GetDlgCtrlID( hwnd ) <= ( int )-1 )
        {
            return FALSE;
        }

        DWORD rgdw[ 2 ];

        rgdw[ 0 ] = GetDlgCtrlID( hwnd );

        rgdw[ 1 ] = GetWindowContextHelpId( hwnd );

        LoadString( _Module.GetModuleInstance( ) , IDS_HELPFILE , tchHelpFile , sizeof( tchHelpFile ) / sizeof( TCHAR ) );

        WinHelp( hwnd , tchHelpFile , HELP_CONTEXTMENU , (ULONG_PTR)&rgdw );

    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// Each control has a helpid assign to them.  Some controls share the same topic
// check for these.
//-------------------------------------------------------------------------------
BOOL CDialogBase::OnHelp( HWND hwnd , LPHELPINFO lphi )
{
    TCHAR tchHelpFile[ MAX_PATH ];

    //
    // For the information to winhelp api
    //

    if( IsBadReadPtr( lphi , sizeof( HELPINFO ) ) )
    {
        return FALSE;
    }

    if( lphi->iCtrlId <= -1 )
    {
        return FALSE;
    }

    LoadString( _Module.GetModuleInstance( ) , IDS_HELPFILE , tchHelpFile , sizeof( tchHelpFile ) / sizeof( TCHAR ) );

    WinHelp( hwnd , tchHelpFile , HELP_CONTEXTPOPUP , lphi->dwContextId );

    return TRUE;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

//-------------------------------------------------------------------------------
// CEnviroDlg::ctor
//-------------------------------------------------------------------------------
CEnviroDlg::CEnviroDlg( CTSUserSheet *pUSht )
{
    m_pUSht = pUSht;
}

//-------------------------------------------------------------------------------
// InitDialog for ProfileDlg
//-------------------------------------------------------------------------------
BOOL CEnviroDlg::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht ,sizeof(  CTSUserSheet ) ) )
    {
        return FALSE;
    }

    m_pUSht->AddRef( );

    USERCONFIG uc;

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    // This means any true problems from obtaining user info from the sam
    // will disable this dialog

    if( dwStatus != ERROR_FILE_NOT_FOUND && dwStatus != ERROR_SUCCESS )
    {
        INT nId[ ] = {
                        IDC_CHECK_USEDEFAULT,
                        IDC_EDIT_CMDLINE,
                        IDC_EDIT_WDIR,
                        IDC_CHECK_CCDL,
                        IDC_CHECK_CCPL,
                        IDC_CHECK_DMCP,
                        -1
        };

        for( int idx = 0; nId[ idx ] != -1 ; ++idx )
        {
            EnableWindow( GetDlgItem( hwnd , nId[ idx ] ) , FALSE );
        }

        ErrorMessage1( hwnd , dwStatus );

        return FALSE;
    }

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_CMDLINE  ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_WDIR  ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );

    //
    // Set controls to default status
    //

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_USEDEFAULT ) , BM_SETCHECK , !( WPARAM )uc.fInheritInitialProgram , 0 );

    SetWindowText( GetDlgItem( hwnd , IDC_EDIT_WDIR ) , uc.WorkDirectory );

    SetWindowText( GetDlgItem( hwnd , IDC_EDIT_CMDLINE ) , uc.InitialProgram ) ;

    EnableWindow( GetDlgItem( hwnd , IDC_EDIT_WDIR ) , !uc.fInheritInitialProgram );

    EnableWindow( GetDlgItem( hwnd , IDC_EDIT_CMDLINE ) , !uc.fInheritInitialProgram );

    EnableWindow( GetDlgItem( hwnd , IDC_STATIC_WD ) , !uc.fInheritInitialProgram );

    EnableWindow( GetDlgItem( hwnd , IDC_STATIC_CMD ) , !uc.fInheritInitialProgram );

    //
    // The controls are initially enabled - - resetting them is done
    // via WM_COMMAND
    //

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_CCDL ) , BM_SETCHECK , ( WPARAM )uc.fAutoClientDrives , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_CCPL ) , BM_SETCHECK , ( WPARAM )uc.fAutoClientLpts , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_DMCP ) , BM_SETCHECK , ( WPARAM )uc.fForceClientLptDef , 0 );

    m_bPersisted = TRUE;

    return CDialogBase::OnInitDialog( hwnd , wp , lp );
}

//-------------------------------------------------------------------------------
// Environment Dialog Page
// -- static methods lacks this ptr
//-------------------------------------------------------------------------------
INT_PTR CALLBACK CEnviroDlg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CEnviroDlg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CEnviroDlg *pDlg = ( CEnviroDlg * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CEnviroDlg ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CEnviroDlg * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CEnviroDlg ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_RBUTTONUP:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            HWND hChild = ChildWindowFromPoint( hwnd , pt );

            ClientToScreen( hwnd , &pt );

            pDlg->OnContextMenu( hChild , pt );
        }

        break;

     case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

    }

    return 0;
}

//-------------------------------------------------------------------------------
// Basic control notification handler
//-------------------------------------------------------------------------------
void CEnviroDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtl )
{
    switch( wNotifyCode )
    {

    case BN_CLICKED:

        if( wID == IDC_CHECK_USEDEFAULT )
        {
            //
            // Remember if its checked we want to disable the options
            //
            HWND hwnd = GetParent( hwndCtl );

            BOOL bChecked = SendMessage( hwndCtl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

            EnableWindow( GetDlgItem( hwnd , IDC_EDIT_WDIR ) , bChecked );

            EnableWindow( GetDlgItem( hwnd , IDC_EDIT_CMDLINE ) , bChecked );

            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_WD ) , bChecked );

            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_CMD ) , bChecked );

        }   // FALL THROUGH !!!!

    case EN_CHANGE:

        m_bPersisted = FALSE;

        break;

    case ALN_APPLY:

        SendMessage( GetParent( hwndCtl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        break;
    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
    }

}

//-------------------------------------------------------------------------------
// OnDestroy
//-------------------------------------------------------------------------------
BOOL CEnviroDlg::OnDestroy( )
{
    if( !IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        ODS(TEXT("Releasing from CEnviroDlg\n"));

        m_pUSht->Release( );
    }

    return CDialogBase::OnDestroy( );
}

//-------------------------------------------------------------------------------
// GetPropertySheetPage - each dialog object should be responsible for its own data
//-------------------------------------------------------------------------------
BOOL CEnviroDlg::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetModuleInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_PAGE_ENVIRO );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CEnviroDlg::DlgProc;

    return TRUE;
}

//-------------------------------------------------------------------------------
// PersistSettings
//-------------------------------------------------------------------------------
BOOL CEnviroDlg::PersistSettings( HWND hDlg )
{
    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    TCHAR tchBuffer[ DIRECTORY_LENGTH + 1 ];

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    //
    // if use default is checked -- lets flag it and move on to client devices
    //

    //
    // if the chkbx is unchecked we inherit from client side settings
    //

    uc.fInheritInitialProgram = SendMessage( GetDlgItem( hDlg , IDC_CHECK_USEDEFAULT ) , BM_GETCHECK ,
        0 , 0 ) == BST_CHECKED ? FALSE : TRUE;

    if( !uc.fInheritInitialProgram )
    {
        //
        // Read buffer and commit to USERCONFIG buffer
        //

        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_WDIR ) , &tchBuffer[ 0 ] , sizeof( tchBuffer ) / sizeof( TCHAR ) );

        lstrcpy( uc.WorkDirectory , tchBuffer );

        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_CMDLINE ) , &tchBuffer[ 0 ] , sizeof( tchBuffer ) / sizeof( TCHAR ) );

        lstrcpy( uc.InitialProgram , tchBuffer );
    }

    uc.fAutoClientDrives  = SendMessage( GetDlgItem( hDlg , IDC_CHECK_CCDL ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

    uc.fAutoClientLpts    = SendMessage( GetDlgItem( hDlg , IDC_CHECK_CCPL ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

    uc.fForceClientLptDef = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DMCP ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

    if( !m_pUSht->SetUserConfig( uc , &dwStatus ) )
    {
        ErrorMessage2( hDlg , dwStatus );

        return TRUE;
    }


    PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY ) , ( LPARAM )hDlg );

    SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

    return TRUE;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

DWORD rgdwTime[] = { 0 , 1 , 5 , 10 , 15 , 30 , 60 , 120 , 180 , 1440 , 2880 , ( DWORD )-1 };

//-------------------------------------------------------------------------------
// CTimeOutDlg::ctor
//-------------------------------------------------------------------------------
CTimeOutDlg::CTimeOutDlg( CTSUserSheet *pUSht )
{
    m_pUSht = pUSht;

    ZeroMemory( &m_cbxst , sizeof( CBXSTATE ) * 3 );

    m_wAction = ( WORD)-1;

    m_wCon = ( WORD )-1;

    ZeroMemory( &m_tokday , sizeof( TOKTABLE ) * 4  );

    ZeroMemory( &m_tokhour , sizeof( TOKTABLE ) * 6 );

    ZeroMemory( &m_tokmin , sizeof( TOKTABLE ) * 5 );
}

//-------------------------------------------------------------------------------
void CTimeOutDlg::InitTokTables( )
{
    TOKTABLE tday[4] = { { NULL , IDS_D },
                         { NULL , IDS_DAY },
                         { NULL , IDS_DAYS },
                         { NULL , ( DWORD )-1 }
                       };

    TOKTABLE thour[ 6 ] = {
                            { NULL , IDS_H     },
                            { NULL , IDS_HR    },
                            { NULL , IDS_HRS   },
                            { NULL , IDS_HOUR  },
                            { NULL , IDS_HOURS },
                            { NULL , ( DWORD )-1 }
                          };

    TOKTABLE tmin[ 5 ] = {
                            { NULL , IDS_M       },
                            { NULL , IDS_MIN     },
                            { NULL , IDS_MINUTE  },
                            { NULL , IDS_MINUTES },
                            { NULL , ( DWORD )-1 }
                         };

    CopyMemory( &m_tokday[0] , &tday[0] , sizeof( TOKTABLE )  * 4 );
    CopyMemory( &m_tokhour[0] , &thour[0] , sizeof( TOKTABLE )  * 6 );
    CopyMemory( &m_tokmin[0] , &tmin[0] , sizeof( TOKTABLE )  * 5 );


}
//-------------------------------------------------------------------------------
// InitDialog for TimeOutDlg
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    TCHAR tchBuffer[ 80 ];

    DWORD dwStatus;

    USERCONFIG uc;

    if( IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        return FALSE;
    }

    m_pUSht->AddRef( );

    InitTokTables( );

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    if( dwStatus != ERROR_FILE_NOT_FOUND && dwStatus != ERROR_SUCCESS )
    {
        INT nId[ ] = {
                        IDC_COMBO_CONNECT,
                        IDC_COMBO_DISCON,
                        IDC_COMBO_IDLE,
                        IDC_RADIO_RESET,
                        IDC_RADIO_DISCON,
                        IDC_RADIO_PREVCLIENT,
                        IDC_RADIO_ANYCLIENT,
                        -1
        };

        for( int idx = 0; nId[ idx ] != -1 ; ++idx )
        {
            EnableWindow( GetDlgItem( hwnd , nId[ idx ] ) , FALSE );
        }

        ErrorMessage1( hwnd , dwStatus );

        return FALSE;
    }
    //
    // First thing is to set the default values for all the controls
    //

    HWND hCombo[ 3 ] =
    {

        GetDlgItem( hwnd , IDC_COMBO_CONNECT ),

        GetDlgItem( hwnd , IDC_COMBO_DISCON ),

        GetDlgItem( hwnd , IDC_COMBO_IDLE )
    };


    for( int idx = 0; rgdwTime[ idx ] != ( DWORD)-1; ++idx )
    {
        if( rgdwTime[ idx ] == 0 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchBuffer , sizeof( tchBuffer ) / sizeof( TCHAR ) );
        }
        else
        {
            ConvertToDuration( rgdwTime[ idx ] , tchBuffer );
        }

        for( int inner = 0 ; inner < 3 ; ++inner )
        {
            SendMessage( hCombo[ inner ] , CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );

            SendMessage( hCombo[ inner ] , CB_SETITEMDATA , idx , rgdwTime[ idx ] );
        }
    }

    ULONG ulTime;

    if( uc.MaxConnectionTime > 0 )
    {
        ulTime = uc.MaxConnectionTime / kMilliMinute;

        // hCombo[ 0 ] == IDC_COMBO_CONNECT

        InsertSortedAndSetCurSel( hCombo[ 0 ] , ulTime );

    }
    else
    {
        SendMessage( hCombo[ 0 ] , CB_SETCURSEL , 0 , 0 );
    }

    //
    // Set the current or default disconnection timeout
    //

    if( uc.MaxDisconnectionTime > 0 )
    {
        ulTime = uc.MaxDisconnectionTime / kMilliMinute;

        // hCombo[ 1 ] == IDC_COMBO_DISCON

        InsertSortedAndSetCurSel( hCombo[ 1 ] , ulTime );

    }
    else
    {
        SendMessage( hCombo[ 1] , CB_SETCURSEL , 0 , 0 );
    }

    //
    // Set the current or default idle timeout
    //

    if( uc.MaxIdleTime > 0 )
    {
        ulTime = uc.MaxIdleTime / kMilliMinute;

        // hCombo[ 2 ] == IDC_COMBO_IDLE

        InsertSortedAndSetCurSel( hCombo[ 2 ] , ulTime );

    }
    else
    {
        SendMessage( hCombo[ 2 ] , CB_SETCURSEL , 0 , 0 );
    }

    //
    // Set remaining controls to current settings
    //

    if( uc.fResetBroken )
    {
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_RESET ) , BM_CLICK , 0 , 0 );

        m_wAction = IDC_RADIO_RESET;
    }
    else
    {
       SendMessage( GetDlgItem( hwnd , IDC_RADIO_DISCON ) , BM_CLICK , 0 , 0 );

       m_wAction = IDC_RADIO_DISCON;
    }

    if( uc.fReconnectSame )
    {
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_PREVCLIENT ) , BM_CLICK , 0 ,0 );

        m_wCon = IDC_RADIO_PREVCLIENT;
    }
    else
    {
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_ANYCLIENT ) , BM_CLICK , 0 , 0 );

        m_wCon = IDC_RADIO_ANYCLIENT;

    }

    LoadAbbreviates( );

    m_bPersisted = TRUE;

    return CDialogBase::OnInitDialog( hwnd , wp , lp );

}

//-------------------------------------------------------------------------------
// TimeOutDlg Dialog Page
// -- static methods lacks this ptr
//-------------------------------------------------------------------------------
INT_PTR CALLBACK CTimeOutDlg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CTimeOutDlg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CTimeOutDlg *pDlg = ( CTimeOutDlg * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CTimeOutDlg ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CTimeOutDlg * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CTimeOutDlg ) ) )
        {
            return FALSE;
        }
    }


    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_RBUTTONUP:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            HWND hChild = ChildWindowFromPoint( hwnd , pt );

            ClientToScreen( hwnd , &pt );

            pDlg->OnContextMenu( hChild , pt );
        }

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }
    }

    return 0;
}

//-------------------------------------------------------------------------------
// release the parent reference
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnDestroy( )
{
    xxxUnLoadAbbreviate( &m_tokday[0] );

    xxxUnLoadAbbreviate( &m_tokhour[0] );

    xxxUnLoadAbbreviate( &m_tokmin[0] );

    if( !IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        ODS(TEXT("Releasing from CTimeOutDlg\n"));

        m_pUSht->Release( );
    }

    return CDialogBase::OnDestroy( );
}

//-------------------------------------------------------------------------------
// GetPropertySheetPage - each dialog object should be responsible for its own data
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetModuleInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_PAGE_TIMEOUTS );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CTimeOutDlg::DlgProc;

    return TRUE;
}

//-------------------------------------------------------------------------------
// OnCommand
//-------------------------------------------------------------------------------
void CTimeOutDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtl )
{
    switch( wNotifyCode )
    {

    case CBN_EDITCHANGE:

        OnCBEditChange( hwndCtl );

        m_bPersisted = FALSE;

        break;

    case CBN_SELCHANGE:

        if( SendMessage( hwndCtl , CB_GETDROPPEDSTATE , 0 ,0  ) == TRUE )
        {
            return;
        }

        OnCBNSELCHANGE( hwndCtl );    // FALLTHROUGH

//        m_bPersisted = FALSE;

        break;

    case BN_CLICKED:

        if( wID == IDC_RADIO_DISCON || wID == IDC_RADIO_RESET )
        {
            if( m_wAction != wID )
            {
                m_wAction = wID;

                m_bPersisted = FALSE;
            }
        }
        else if( wID == IDC_RADIO_PREVCLIENT || wID == IDC_RADIO_ANYCLIENT )
        {
            if( m_wCon != wID )
            {
                m_wCon = wID;

                m_bPersisted = FALSE;
            }
        }



        break;

    //case CBN_DROPDOWN:               // FALLTHROUGH

    case CBN_KILLFOCUS:

        ODS( L"CBN_KILLFOCUS\n");

        if( !OnCBDropDown( hwndCtl ) )
        {
            return;
        }

        m_bPersisted = FALSE;

        break;

    case ALN_APPLY:

        SendMessage( GetParent( hwndCtl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return;

    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
    }

}

//-------------------------------------------------------------------------------
// Update the entry if it has been modified by user
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnCBDropDown( HWND hCombo )
{
    TCHAR tchBuffer[ 80 ];

    ULONG ulTime = 0;

    int i = GetCBXSTATEindex( hCombo );

    if( i < 0 )
    {
        return FALSE;
    }

    if( m_cbxst[ i ].bEdit )
    {
        GetWindowText( hCombo , tchBuffer , sizeof( tchBuffer ) / sizeof( TCHAR ) );

        if( ParseDurationEntry( tchBuffer , &ulTime ) == E_SUCCESS )
        {
            InsertSortedAndSetCurSel( hCombo , ulTime );
        }
    }

    return m_cbxst[ i ].bEdit;

}
//-------------------------------------------------------------------------------
// Use this flag to distinguish between hand entry or listbox selection
// setting it to true implies that the use has edit the cbx via typing
//-------------------------------------------------------------------------------
void CTimeOutDlg::OnCBEditChange( HWND hCombo )
{
    int i = GetCBXSTATEindex( hCombo );

    if( i > -1 )
    {
        m_cbxst[ i ].bEdit = TRUE;
    }
}

//-------------------------------------------------------------------------------
// Determine if user wants to enter a custom time
//-------------------------------------------------------------------------------
void CTimeOutDlg::OnCBNSELCHANGE( HWND hwnd )
{
    if( SaveChangedSelection( hwnd ) )
    {
        m_bPersisted = FALSE;
    }
}

//-------------------------------------------------------------------------------
// Saves selected item.
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::SaveChangedSelection( HWND hCombo )
{
    LRESULT idx = SendMessage( hCombo , CB_GETCURSEL , 0 , 0 );

    int i = GetCBXSTATEindex( hCombo );

    if( i > -1 )
    {
        if( idx != ( LRESULT )m_cbxst[ i ].icbxSel )
        {
            m_cbxst[ i ].icbxSel = (int)idx;

            m_cbxst[ i ].bEdit = FALSE;

            return TRUE;
        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// Restore previous setting
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::RestorePreviousValue( HWND hwnd )
{
    int iSel;

    if( ( iSel = GetCBXSTATEindex( hwnd ) ) > -1 )
    {
        SendMessage( hwnd , CB_SETCURSEL , m_cbxst[ iSel ].icbxSel , 0 );

        return TRUE;
    }

    return FALSE;
}
//-------------------------------------------------------------------------------
// returns the indx in m_cbxst of which hcombo is assoc. with
//-------------------------------------------------------------------------------
int CTimeOutDlg::GetCBXSTATEindex( HWND hCombo )
{
    int idx = -1;

    switch( GetDlgCtrlID( hCombo ) )
    {
    case IDC_COMBO_CONNECT:

        idx = 0;

        break;

    case IDC_COMBO_DISCON:

        idx = 1;

        break;

    case IDC_COMBO_IDLE:

        idx = 2;

        break;
    }

    return idx;
}

//-------------------------------------------------------------------------------
// ConvertToMinutes -- helper for CTimeOutDlg::OnNotify
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ConvertToMinutes( HWND hwndCtl , PULONG pulMinutes )
{
    TCHAR tchBuffer[ 80 ];

    TCHAR tchErrTitle[ 80 ];

    TCHAR tchErrMsg[ 256 ];

    TCHAR tchErrItem[ 80 ];

    TCHAR tchErrTot[ 336 ];

    int nComboResID[] = { IDS_COMBO_CONNECTION , IDS_COMBO_DISCONNECTION , IDS_COMBO_IDLECONNECTION };

    int idx = GetCBXSTATEindex( hwndCtl );

    if( idx < 0 )
    {
        return FALSE;
    }

    LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , sizeof( tchErrTitle ) / sizeof( TCHAR ) );

    if( m_cbxst[ idx ].bEdit )
    {
        ODS( TEXT( "Manual Entry parsing\n") );

        if( GetWindowText( hwndCtl , tchBuffer , sizeof( tchBuffer ) / sizeof( TCHAR ) ) < 1 )
        {
            *pulMinutes = 0;

            return TRUE;
        }

        LRESULT lr = ParseDurationEntry( tchBuffer , pulMinutes );

        if( lr != E_SUCCESS )
        {
            LoadString( _Module.GetResourceInstance( ) , nComboResID[ idx ] , tchErrItem , sizeof( tchErrItem ) / sizeof( TCHAR ) );

            if( lr == E_PARSE_VALUEOVERFLOW )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TOOMANYDIGITS , tchErrMsg , sizeof( tchErrMsg ) / sizeof( TCHAR ) );

                wsprintf( tchErrTot , tchErrMsg , tchErrItem );

                MessageBox( hwndCtl , tchErrTot , tchErrTitle , MB_OK | MB_ICONERROR );

                SetFocus( hwndCtl );
            }
            else if( lr == E_PARSE_MISSING_DIGITS || lr == E_PARSE_INVALID )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_PARSEINVALID , tchErrMsg , sizeof( tchErrMsg ) / sizeof( TCHAR ) );

                wsprintf( tchErrTot , tchErrMsg , tchErrItem );

                MessageBox( hwndCtl , tchErrTot , tchErrTitle , MB_OK | MB_ICONERROR );

                SetFocus( hwndCtl );
            }
            return FALSE;
        }
    }
    else
    {
        ODS( L"Getting current selection\n" );

        LONG_PTR iCurSel = SendMessage( hwndCtl , CB_GETCURSEL , 0 , 0 );
        LONG_PTR lData;

        // See if user wants "No Timeout"

        if( iCurSel == 0 )
        {
            *pulMinutes = 0;

           return TRUE;
        }

        if( ( lData = SendMessage( hwndCtl , CB_GETITEMDATA , iCurSel , 0 ) ) == CB_ERR  )
        {
            *pulMinutes = 0;
        } else {

            *pulMinutes = (ULONG)lData;
        }
    }

    if( *pulMinutes > kMaxTimeoutMinute )
    {
        LoadString( _Module.GetResourceInstance( ) , nComboResID[ idx ] , tchErrItem , sizeof( tchErrItem ) / sizeof( TCHAR ) );

        LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_MAXVALEXCEEDED , tchErrMsg , sizeof( tchErrMsg ) / sizeof( TCHAR ) );

        wsprintf( tchErrTot , tchErrMsg , tchErrItem );

        MessageBox( hwndCtl , tchErrTot , tchErrTitle , MB_OK | MB_ICONERROR );

        SetFocus( hwndCtl );

        return FALSE;
    }

    *pulMinutes *= kMilliMinute;

    return TRUE;
}


//-------------------------------------------------------------------------------
// PersistSettings
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::PersistSettings( HWND hDlg )
{
    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_CONNECT ) , &uc.MaxConnectionTime ) )
    {
        return FALSE;
    }

    if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_DISCON ) , &uc.MaxDisconnectionTime ) )
    {
        return FALSE;
    }

    if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_IDLE ) , &uc.MaxIdleTime ) )
    {
        return FALSE;
    }   

    uc.fResetBroken = SendMessage( GetDlgItem( hDlg , IDC_RADIO_RESET ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

    uc.fReconnectSame = SendMessage( GetDlgItem( hDlg , IDC_RADIO_PREVCLIENT ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

    if( !m_pUSht->SetUserConfig( uc , &dwStatus ) )
    {
        ErrorMessage2( hDlg , dwStatus );

        return TRUE;
    }

    PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

    SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

    return TRUE;

}

//-------------------------------------------------------------------------------
// Making sure the user has entered valid info
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::IsValidSettings( HWND hDlg )
{
    DWORD dwDummy;

    if( IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    uc = m_pUSht->GetCurrentUserConfig( &dwDummy );

    if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_CONNECT ) , &uc.MaxConnectionTime ) )
    {
        return FALSE;
    }

    if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_DISCON ) , &uc.MaxDisconnectionTime ) )
    {
        return FALSE;
    }

    if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_IDLE ) , &uc.MaxIdleTime ) )
    {
        return FALSE;
    }

    return TRUE;
}

#if 0
//-------------------------------------------------------------------------------
// Lets cut to the chase and find out if this is even worth parsing
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::DoesContainDigits( LPTSTR pszString )
{
    while( *pszString )
    {
        if( iswdigit( *pszString ) )
        {
            return TRUE;
        }

        pszString++;
    }

    return FALSE;
}


//-------------------------------------------------------------------------------
LRESULT CTimeOutDlg::ParseDurationEntry( LPTSTR pszTime , PULONG pTime )
{
    TCHAR tchNoTimeout[ 80 ];

    LPTSTR pszTemp = pszTime;

    UINT uDec = 0;

    float fFrac = 0.0f;

    float fT;

    UINT uPos = 1;

    LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchNoTimeout , sizeof( tchNoTimeout ) / sizeof( TCHAR ) );

    if( lstrcmpi( pszTime , tchNoTimeout ) == 0 )
    {
        *pTime = 0;

        return E_SUCCESS;
    }

    if( !DoesContainDigits( pszTime ) )
    {
        return E_PARSE_MISSING_DIGITS;
    }

    while( *pszTemp )
    {
        if( !iswdigit( *pszTemp ) )
        {
            break;
        }

        // check for overflow

        if( uDec >= 1000000000 )
        {
            return E_PARSE_VALUEOVERFLOW ;
        }

        uDec *= 10;

        uDec += ( *pszTemp - '0' );

        pszTemp++;

    }

    TCHAR tchSDecimal[ 5 ];

    GetLocaleInfo( LOCALE_USER_DEFAULT , LOCALE_SDECIMAL , tchSDecimal , sizeof( tchSDecimal ) / sizeof( TCHAR ) );

    if( *pszTemp == *tchSDecimal )
    {
        pszTemp++;

        while( *pszTemp )
        {
            if( !iswdigit( *pszTemp ) )
            {
                break;
            }

            // check for overflow

            if( uDec >= 1000000000 )
            {
                return E_PARSE_VALUEOVERFLOW;
            }

            uPos *= 10;

            fFrac += ( ( float )( *pszTemp - '0' ) ) / ( float )uPos; //+ 0.05f;

            pszTemp++;
        }
    }

    // remove white space

    while( *pszTemp == L' ' )
    {
        pszTemp++;
    }


    if( *pszTemp != NULL )
    {
        if( IsToken( pszTemp , TOKEN_DAY ) )
        {
            *pTime = uDec * 24 * 60;

            fT = ( fFrac * 1440.0f + 0.5f );

            *pTime += ( ULONG )fT;

            return E_SUCCESS;
        }
        else if( IsToken( pszTemp , TOKEN_HOUR ) )
        {
            *pTime = uDec * 60;

            fT = ( fFrac * 60.0f + 0.5f );

            *pTime += ( ULONG )fT;

            return E_SUCCESS;
        }
        else if( IsToken( pszTemp , TOKEN_MINUTE ) )
        {
            // minutes are rounded up in the 1/10 place

            fT = fFrac + 0.5f;

            *pTime = uDec;

            *pTime += ( ULONG )( fT );

            return E_SUCCESS;

        }

    }

    if( *pszTemp == NULL )
    {

        // if no text is defined considered the entry in hours

        *pTime = uDec * 60;

         fT = ( fFrac * 60.0f + 0.5f );

        *pTime += ( ULONG )fT ;

        return E_SUCCESS;
    }


    return E_PARSE_INVALID;

}

#endif


//-------------------------------------------------------------------------------
// Adds strings to table from resource
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::LoadAbbreviates( )
{
    xxxLoadAbbreviate( &m_tokday[0] );

    xxxLoadAbbreviate( &m_tokhour[0] );

    xxxLoadAbbreviate( &m_tokmin[0] );

    return TRUE;
}

//-------------------------------------------------------------------------------
// Take cares some repetitive work for us
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::xxxLoadAbbreviate( PTOKTABLE ptoktbl )
{
    int idx;

    int nSize;

    TCHAR tchbuffer[ 80 ];

    if( ptoktbl == NULL )
    {
        return FALSE;
    }

    for( idx = 0; ptoktbl[ idx ].dwresourceid != ( DWORD )-1 ; ++idx )
    {
        nSize = LoadString( _Module.GetResourceInstance( ) , ptoktbl[ idx ].dwresourceid , tchbuffer , sizeof( tchbuffer ) / sizeof( TCHAR ) );

        if( nSize > 0 )
        {
            ptoktbl[ idx ].pszAbbrv = ( TCHAR *)new TCHAR[ nSize + 1 ];

            if( ptoktbl[ idx ].pszAbbrv != NULL )
            {
                lstrcpy( ptoktbl[ idx ].pszAbbrv , tchbuffer );
            }
        }
    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// Frees up allocated resources
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::xxxUnLoadAbbreviate( PTOKTABLE ptoktbl )
{
    if( ptoktbl == NULL )
    {
        return FALSE;
    }

    for( int idx = 0; ptoktbl[ idx ].dwresourceid != ( DWORD )-1 ; ++idx )
    {
        if( ptoktbl[ idx ].pszAbbrv != NULL )
        {
            delete[] ptoktbl[ idx ].pszAbbrv;

        }
    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// tear-off token tables
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::IsToken( LPTSTR pszString , TOKEN tok )
{
    TOKTABLE *ptoktable;

    if( tok == TOKEN_DAY )
    {
        ptoktable = &m_tokday[0];
    }
    else if( tok == TOKEN_HOUR )
    {
        ptoktable = &m_tokhour[0];
    }
    else if( tok == TOKEN_MINUTE )
    {
        ptoktable = &m_tokmin[0];
    }
    else
    {
        return FALSE;
    }


    for( int idx = 0 ; ptoktable[ idx ].dwresourceid != -1 ; ++idx )
    {
        if( lstrcmpi( pszString , ptoktable[ idx ].pszAbbrv ) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;

}

#if 0
//-------------------------------------------------------------------------------
// Converts the number minutes into a formated string
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ConvertToDuration( ULONG ulTime , LPTSTR pszDuration )
{
    INT_PTR dw[3];

    TCHAR tchTimeUnit[ 40 ];

    TCHAR tchTimeFormat[ 40 ];

    TCHAR tchOutput[ 80 ];

    ASSERT_( ulTime != 0 );

    int iHour= ( int ) ( ( float )ulTime / 60.0f );

    int iDays = iHour / 24;

    dw[ 2 ] = ( INT_PTR )&tchTimeUnit[ 0 ];

    LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_DOT_DIGIT_TU , tchTimeFormat , sizeof( tchTimeFormat ) / sizeof( TCHAR ) );

    if( iDays != 0 )
    {
        int iRemainingHours = iHour % 24;

        float fx = ( float )iRemainingHours / 24.0f + 0.05f;

        int iRemainingMinutes = ulTime % 60;

        float mfx = ( float )iRemainingMinutes / 60.0f + 0.05f;

        //if( ( iRemainingHours != 0 || iRemainingMinutes != 0 ) && iDays < 2 )

        if( mfx > 0.05f || ( fx > 0.05f && fx < 0.10f && iDays < 2 ) )//
        {
            iRemainingMinutes = ( int ) ( mfx * 10 );

            dw[ 0 ] = iHour;

            dw[ 1 ] = iRemainingMinutes;

            iDays = 0;

            LoadString( _Module.GetResourceInstance( ) , IDS_HOURS , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );

        }
        else
        {
            iRemainingHours = ( int )( fx * 10 );

            LoadString( _Module.GetResourceInstance( ) , IDS_DAYS , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );

            dw[ 0 ] = iDays;

            dw[ 1 ] = iRemainingHours;
        }

        if( dw[ 1 ] == 0 )
        {
            // formatted string requires two arguments

            dw[ 1 ] = ( INT_PTR )&tchTimeUnit[ 0 ];

            LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , sizeof( tchTimeFormat ) / sizeof( TCHAR ) );

            if( iDays == 1 )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_DAY , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
            }
        }

    }

    else if( iHour != 0 )
    {
        int iRemainingMinutes = ulTime % 60;

        float fx = ( float )iRemainingMinutes / 60.0f ;//+ 0.05f;

        if( fx > 0.0f && fx < 0.10f && iHour < 2 )//
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );

            LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , sizeof( tchTimeFormat ) / sizeof( TCHAR ) );

            dw[ 0 ] = ulTime ;

            dw[ 1 ] = ( INT_PTR )&tchTimeUnit[ 0 ];

            if( ulTime > 1 )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
            }
            else
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_MINUTE , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
            }
        }//
        else
        {
            fx += 0.05f;

            iRemainingMinutes = ( int ) ( fx * 10 );

            dw[ 0 ] = iHour;

            dw[ 1 ] = iRemainingMinutes;

            LoadString( _Module.GetResourceInstance( ) , IDS_HOURS , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );

            if( iRemainingMinutes == 0 )
            {
                dw[ 1 ] = ( INT_PTR )&tchTimeUnit[ 0 ];

                LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , sizeof( tchTimeFormat ) / sizeof( TCHAR ) );

                if( iHour == 1 )
                {
                    LoadString( _Module.GetResourceInstance( ) , IDS_HOUR , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
                }
            }
        }
    }
    else
    {
        LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );

        LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , sizeof( tchTimeFormat ) / sizeof( TCHAR ) );

        dw[ 0 ] = ulTime ;

        dw[ 1 ] = ( INT_PTR )&tchTimeUnit[ 0 ];

        if( ulTime > 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTE , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }
    }

    FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchTimeFormat , 0 , 0 , tchOutput , sizeof( tchOutput )/sizeof( TCHAR ) , ( va_list * )&dw );

    lstrcpy( pszDuration , tchOutput );

    return TRUE;
}

#endif

//-------------------------------------------------------------------------------
// Place entry in listbox and set as current selection
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::InsertSortedAndSetCurSel( HWND hCombo , DWORD dwMinutes )
{
    ASSERT_( dwMinutes != ( DWORD )-1 );

    TCHAR tchBuffer[ 80 ];

    LRESULT iCount = SendMessage( hCombo , CB_GETCOUNT , 0 , 0 );

    for( INT_PTR idx = 0 ; idx < iCount ; ++idx )
    {
        // Don't insert an item that's already in the list

        if( dwMinutes == ( DWORD )SendMessage( hCombo , CB_GETITEMDATA , idx , 0 ) )
        {
            SendMessage( hCombo , CB_SETCURSEL , idx , 0 ) ;

            SaveChangedSelection( hCombo );

            return TRUE;
        }

        if( dwMinutes < ( DWORD )SendMessage( hCombo , CB_GETITEMDATA , idx , 0 ) )
        {
            break;
        }
    }

    // hey if the value has exceeded the max timeout don't bother entering it in our list

    if( dwMinutes > kMaxTimeoutMinute )
    {
        return FALSE;
    }

    if( ConvertToDuration ( dwMinutes , tchBuffer ) )
    {
        idx = SendMessage( hCombo , CB_INSERTSTRING , idx , ( LPARAM )&tchBuffer[ 0 ] );

        if( idx != CB_ERR )
        {
            SendMessage( hCombo , CB_SETITEMDATA , idx , dwMinutes );

        }

        SendMessage( hCombo , CB_SETCURSEL , idx , 0 ) ;
    }

    // must call this here because CB_SETCURSEL does not send CBN_SELCHANGE

    SaveChangedSelection( hCombo );

    return TRUE;
}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

//-------------------------------------------------------------------------------
// CShadowDlg::ctor
//-------------------------------------------------------------------------------
CShadowDlg::CShadowDlg( CTSUserSheet *pUSht )
{
    m_pUSht = pUSht;

    m_wOldRad = ( WORD )-1;
}

//-------------------------------------------------------------------------------
// CShadowDlg Dialog Page
// -- static methods lacks this ptr
//-------------------------------------------------------------------------------
INT_PTR CALLBACK CShadowDlg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CShadowDlg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CShadowDlg *pDlg = ( CShadowDlg * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CShadowDlg ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CShadowDlg * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CShadowDlg ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_RBUTTONUP:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            HWND hChild = ChildWindowFromPoint( hwnd , pt );

            ClientToScreen( hwnd , &pt );

            pDlg->OnContextMenu( hChild , pt );
        }

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

    }

    return 0;
}

//-------------------------------------------------------------------------------
// InitDialog for CShadowDlg
//-------------------------------------------------------------------------------
BOOL CShadowDlg::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht ,sizeof(  CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    m_pUSht->AddRef( );

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    // No userconfig loaded most likey access denied donot allow users to modify anything

    if( dwStatus != ERROR_FILE_NOT_FOUND && dwStatus != ERROR_SUCCESS )
    {
        INT nId[ ] = {
                        IDC_CHECK_SHADOW,
                        IDC_RADIO_WATCH,
                        IDC_RADIO_CONTROL,
                        IDC_CHECK_NOTIFY,
                        -1
        };

        for( int idx = 0; nId[ idx ] != -1 ; ++idx )
        {
            EnableWindow( GetDlgItem( hwnd , nId[ idx ] ) , FALSE );
        }

        ErrorMessage1( hwnd , dwStatus );

        return FALSE;
    }

    if( uc.Shadow == Shadow_Disable )
    {
        SendMessage( GetDlgItem( hwnd , IDC_CHECK_SHADOW ) , BM_SETCHECK , ( WPARAM )FALSE , 0  );

        EnableWindow( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , FALSE );

        EnableWindow( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , FALSE );

        EnableWindow( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , FALSE );

        EnableWindow( GetDlgItem( hwnd , IDC_STATIC_LEVELOFCTRL ) , FALSE );
    }
    else
    {
        //
        // Controls are initially enabled,  set current status
        //

        SendMessage( GetDlgItem( hwnd , IDC_CHECK_SHADOW ) , BM_SETCHECK , ( WPARAM )TRUE , 0  );

        switch( uc.Shadow )
        {
        case Shadow_EnableInputNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , BM_CLICK , 0 , 0 );

            break;

        case Shadow_EnableInputNoNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )FALSE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , BM_CLICK , 0 , 0 );

            break;

        case Shadow_EnableNoInputNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , BM_CLICK , 0 , 0 );

            break;

        case Shadow_EnableNoInputNoNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )FALSE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , BM_CLICK , 0 , 0 );

            break;
        }

        m_wOldRad = ( WORD )( IsDlgButtonChecked( hwnd , IDC_RADIO_WATCH ) ? IDC_RADIO_WATCH : IDC_RADIO_CONTROL ) ;

    }

    m_bPersisted = TRUE;

    return CDialogBase::OnInitDialog( hwnd , wp , lp );
}


//-------------------------------------------------------------------------------
// release the parent reference
//-------------------------------------------------------------------------------
BOOL CShadowDlg::OnDestroy( )
{
    if( !IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        ODS(TEXT("Releasing from CShadowDlg\n"));

        m_pUSht->Release( );
    }

    return CDialogBase::OnDestroy( );
}

//-------------------------------------------------------------------------------
// GetPropertySheetPage - each dialog object should be responsible for its own data
//-------------------------------------------------------------------------------
BOOL CShadowDlg::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetModuleInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_PAGE_SHADOW );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CShadowDlg::DlgProc;

    return TRUE;
}

//-------------------------------------------------------------------------------
// Basic control notification handler
//-------------------------------------------------------------------------------
void CShadowDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtl )
{
    switch( wNotifyCode )
    {
    case BN_CLICKED:
        if( wID == IDC_CHECK_SHADOW )
        {
            HWND hwnd = GetParent( hwndCtl );

            BOOL bChecked = SendMessage( hwndCtl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_SHADOW ) , BM_SETCHECK , ( WPARAM )bChecked , 0  );

            EnableWindow( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , bChecked );

            EnableWindow( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , bChecked );

            EnableWindow( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , bChecked );

            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_LEVELOFCTRL ) , bChecked );

            //
            // if neither radio buttons are selected force IDC_RADIO_CONTROL to be selected
            //

            if(
                ( SendMessage( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , BM_GETSTATE , 0 , 0 ) == BST_UNCHECKED )
                &&
                ( SendMessage( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , BM_GETSTATE , 0 , 0 ) == BST_UNCHECKED )
               )
            {
                SendMessage( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , BM_SETCHECK , ( WPARAM )BST_CHECKED , 0 );

                m_wOldRad = IDC_RADIO_CONTROL;
            }

            m_bPersisted = FALSE;

            SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );

        }
        else if( wID == IDC_RADIO_WATCH || wID == IDC_RADIO_CONTROL )
        {
            if( wID != m_wOldRad )
            {
                m_wOldRad = wID;

                m_bPersisted = FALSE;

                SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
            }
        }
        else if( wID == IDC_CHECK_NOTIFY )
        {
            m_bPersisted = FALSE;

            SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
        }


        break;

    case ALN_APPLY:

        SendMessage( GetParent( hwndCtl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        break;
    }
}

//-------------------------------------------------------------------------------
// PersisitSettings
//-------------------------------------------------------------------------------
BOOL CShadowDlg::PersistSettings( HWND hDlg )
{
    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    //
    // Record all changes
    //

    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_SHADOW ) , BM_GETCHECK , 0 , 0 ) != BST_CHECKED )
    {
        uc.Shadow = Shadow_Disable;
    }

    else
    {
        BOOL bCheckNotify = (BOOL)SendMessage( GetDlgItem( hDlg , IDC_CHECK_NOTIFY ) , BM_GETCHECK , 0 , 0 );

        BOOL bRadioControl = (BOOL)SendMessage( GetDlgItem( hDlg , IDC_RADIO_CONTROL ) , BM_GETCHECK , 0 , 0 );

        if( bCheckNotify )
        {
            if( bRadioControl )
            {
                uc.Shadow = Shadow_EnableInputNotify;
            }
            else
            {
                uc.Shadow = Shadow_EnableNoInputNotify;
            }
        }
        else
        {
            if( bRadioControl )
            {
                uc.Shadow = Shadow_EnableInputNoNotify;
            }
            else
            {
                uc.Shadow = Shadow_EnableNoInputNoNotify;
            }
        }
    }

    if( !m_pUSht->SetUserConfig( uc , &dwStatus ) )
    {
        ErrorMessage2( hDlg , dwStatus );

        return TRUE;
    }

    PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

    SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

    return TRUE;

}

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

CProfileDlg::CProfileDlg( CTSUserSheet *pUsh )
{
    m_pUSht = pUsh;

    m_wOldRadio = ( WORD )-1;
    
    m_ncbxOld = -1;
}

//-------------------------------------------------------------------------------
// GetPropertySheetPage - each dialog object should be responsible for its own data
//-------------------------------------------------------------------------------
BOOL CProfileDlg::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetModuleInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_PAGE_PROFILE );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CProfileDlg::DlgProc;

    return TRUE;
}

//-------------------------------------------------------------------------------
// CProfileDlg Dialog Page
// -- static methods lacks this ptr
//-------------------------------------------------------------------------------
INT_PTR CALLBACK CProfileDlg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CProfileDlg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CProfileDlg *pDlg = ( CProfileDlg * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CProfileDlg ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CProfileDlg * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CProfileDlg ) ) )
        {
            return FALSE;
        }
    }


    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_RBUTTONUP:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            HWND hChild = ChildWindowFromPoint( hwnd , pt );

            ClientToScreen( hwnd , &pt );

            pDlg->OnContextMenu( hChild , pt );
        }

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

    }

    return 0;
}

//-------------------------------------------------------------------------------
// InitDialog for CProfileDlg
//-------------------------------------------------------------------------------
BOOL CProfileDlg::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    TCHAR tchDrv[3];

    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht ,sizeof(  CTSUserSheet ) ) )
    {
        return FALSE;
    }

    USERCONFIG uc;

    m_pUSht->AddRef( );

    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    if( dwStatus != ERROR_FILE_NOT_FOUND && dwStatus != ERROR_SUCCESS )
    {
        INT nId[ ] = {
                        IDC_CHECK_ALLOWLOGON,
                        IDC_COMBO_DRIVES,
                        IDC_EDIT_REMOTEPATH,
                        IDC_RADIO_REMOTE,
                        IDC_EDIT_LOCALPATH,
                        IDC_RADIO_LOCAL,
                        IDC_EDIT_USRPROFILE,
                        -1
        };

        for( int idx = 0; nId[ idx ] != -1 ; ++idx )
        {
            EnableWindow( GetDlgItem( hwnd , nId[ idx ] ) , FALSE );
        }

        ErrorMessage1( hwnd , dwStatus );

        return FALSE;
    }

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_ALLOWLOGON ) , BM_SETCHECK , ( WPARAM )( !uc.fLogonDisabled ) , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_LOCALPATH  ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_REMOTEPATH  ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_USRPROFILE  ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );


    for( TCHAR DrvLetter = 'C'; DrvLetter <= 'Z'; DrvLetter++ )
    {
        tchDrv[0] = DrvLetter;

        tchDrv[1] = ':';

        tchDrv[2] = 0;

        SendMessage( GetDlgItem( hwnd , IDC_COMBO_DRIVES ) , CB_ADDSTRING , 0 , ( LPARAM )&tchDrv[ 0 ] );
    }

	if( PathIsUNC( uc.WFHomeDir ) )
	{
		ODS( L"TSUSEREX: Path is UNC\n" );

		CharUpper( &uc.WFHomeDirDrive[0] );

		if( uc.WFHomeDirDrive[ 0 ] >= 'C' && uc.WFHomeDirDrive[ 0 ] <= 'Z' )
        {
            m_ncbxOld = (int)SendMessage( GetDlgItem( hwnd , IDC_COMBO_DRIVES ) , CB_SETCURSEL , ( WPARAM )( uc.WFHomeDirDrive[ 0 ] - 'C' ) , 0 );
        }
		else
		{
			// default it to Z drive

			m_ncbxOld = (int)SendMessage( GetDlgItem( hwnd , IDC_COMBO_DRIVES ) , CB_SETCURSEL , ( WPARAM )( 'Z' - 'C' ) , 0 );
		}


        SetWindowText( GetDlgItem( hwnd , IDC_EDIT_REMOTEPATH ) , uc.WFHomeDir );

        //SendMessage( GetDlgItem( hwnd , IDC_RADIO_REMOTE ) , BM_CLICK , 0 , 0 );
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_REMOTE ) , BM_SETCHECK , ( WPARAM )BST_CHECKED , 0 );
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_LOCAL ) , BM_SETCHECK , ( WPARAM )BST_UNCHECKED , 0 );

        m_wOldRadio = IDC_RADIO_REMOTE;
    }
	else
    {
		ODS( L"TSUSEREX: Path is Local\n" );
        SendMessage( GetDlgItem( hwnd , IDC_EDIT_LOCALPATH ) , WM_SETTEXT , 0 , ( LPARAM )&uc.WFHomeDir[ 0 ] );

        // SendMessage( GetDlgItem( hwnd , IDC_RADIO_LOCAL ) , BM_CLICK , 0 , 0 );
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_LOCAL ) , BM_SETCHECK , ( WPARAM )BST_CHECKED , 0 );
        SendMessage( GetDlgItem( hwnd , IDC_RADIO_REMOTE ) , BM_SETCHECK , ( WPARAM )BST_UNCHECKED , 0 );

        m_wOldRadio = IDC_RADIO_LOCAL;
    }

    EnableRemoteHomeDirectory( hwnd , ( BOOL )( m_wOldRadio == IDC_RADIO_REMOTE ) );


    SendMessage( GetDlgItem( hwnd , IDC_EDIT_USRPROFILE ) , WM_SETTEXT , 0 , ( LPARAM )&uc.WFProfilePath[ 0 ] );

    m_bPersisted = TRUE;

    m_bTSHomeFolderChanged = FALSE;

    return CDialogBase::OnInitDialog( hwnd , wp , lp );
}

//-------------------------------------------------------------------------------
// EnableRemoteHomeDirectory -- basically enables or disables dlg controls
//-------------------------------------------------------------------------------
BOOL CProfileDlg::EnableRemoteHomeDirectory( HWND hwnd , BOOL bHDMR )
{
    //
    // Local home directory
    //

    EnableWindow( GetDlgItem( hwnd , IDC_EDIT_LOCALPATH ) , !bHDMR );

    //
    // Network'd home directory
    //

    EnableWindow( GetDlgItem( hwnd , IDC_COMBO_DRIVES ) , bHDMR );
   
    EnableWindow( GetDlgItem( hwnd , IDC_EDIT_REMOTEPATH ) , bHDMR );
    
    return TRUE;
}


//-------------------------------------------------------------------------------
// release the parent reference
//-------------------------------------------------------------------------------
BOOL CProfileDlg::OnDestroy( )
{
    if( !IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        ODS(TEXT("Releasing from CProfileDlg\n"));

        m_pUSht->Release( );
    }

    return CDialogBase::OnDestroy( );
}

//-------------------------------------------------------------------------------
// Basic control notification handler
//-------------------------------------------------------------------------------
void CProfileDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtl )
{
    switch( wNotifyCode )
    {
    case EN_CHANGE:

        m_bPersisted = FALSE;

        if( wID == IDC_EDIT_REMOTEPATH || wID == IDC_EDIT_LOCALPATH )
        {
            ODS( L"EN_CHANGE m_bTSHomeFolderChanged = TRUE;\n" );

            m_bTSHomeFolderChanged = TRUE;
        }

        SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );

        break;

    //case CBN_DROPDOWN:
    case CBN_SELCHANGE:
        {
            int nCurSel = (int)SendMessage( hwndCtl , CB_GETCURSEL , 0 , 0 );
        
            if( m_ncbxOld != nCurSel )
            {
                m_ncbxOld = nCurSel;

                ODS( L"CBN_SELCHANGE m_bTSHomeFolderChanged = TRUE;\n" );

                m_bTSHomeFolderChanged = TRUE;

                m_bPersisted = FALSE;
            
                SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
            }
        }
        
        break;        

    case BN_CLICKED:

        if( wID == IDC_RADIO_REMOTE || wID == IDC_RADIO_LOCAL )
        {
            if( wID != m_wOldRadio )
            {
                EnableRemoteHomeDirectory( GetParent( hwndCtl ) , ( BOOL )( wID == IDC_RADIO_REMOTE ) );

                m_wOldRadio = wID;

                m_bPersisted = FALSE;
                
                ODS( L"Setting m_bTSHomeFolderChanged to true\n" );

                m_bTSHomeFolderChanged = TRUE;

                SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
            }

            if( wID == IDC_RADIO_LOCAL )
            {
                SetFocus( GetDlgItem( GetParent( hwndCtl ) , IDC_EDIT_LOCALPATH ) );

                SendMessage( GetDlgItem( GetParent( hwndCtl ) , IDC_EDIT_LOCALPATH ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );
            }
            else if( wID == IDC_RADIO_REMOTE )
            {
                if( SendMessage( GetDlgItem( GetParent( hwndCtl ) , IDC_COMBO_DRIVES ) , 
                                 CB_GETCURSEL,
                                 0,
                                 0 ) == CB_ERR )
                {
                    SendMessage( GetDlgItem( GetParent( hwndCtl ) , IDC_COMBO_DRIVES ) ,
                                 CB_SETCURSEL,
                                 ( WPARAM )( 'Z' - 'C' ),
                                 0 );
                }

                SetFocus( GetDlgItem( GetParent( hwndCtl ) , IDC_COMBO_DRIVES ) );
            }

        }
        else if( wID == IDC_CHECK_ALLOWLOGON )
        {
            m_bPersisted = FALSE;

            SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
        }

        break;

    case ALN_APPLY:

        SendMessage( GetParent( hwndCtl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        break;
    }


}

//-------------------------------------------------------------------------------
// PersistSettings -- remember TRUE is bad FALSE is good
//-------------------------------------------------------------------------------
BOOL CProfileDlg::PersistSettings( HWND hDlg )
{
    BOOL bRet = TRUE;;

    DWORD dwStatus;

    if( IsBadReadPtr( m_pUSht , sizeof( CTSUserSheet ) ) )
    {
        return TRUE;
    }


    USERCONFIG uc;


    uc = m_pUSht->GetCurrentUserConfig( &dwStatus );

    //
    // expensive but necessary id34393
    //
    if( !m_pUSht->SetUserConfig( uc , &dwStatus ) )
    {
        ErrorMessage2( hDlg , dwStatus );

        m_bTSHomeFolderChanged = FALSE;

        return TRUE;
    }

    //
    // Determine whether to enable user to logon to a terminal server
    //

    uc.fLogonDisabled = SendMessage( GetDlgItem( hDlg , IDC_CHECK_ALLOWLOGON ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? FALSE : TRUE;
    
    //
    // Profile path is under the admin discretion
    //

    SetWTSProfilePath( hDlg , uc );

    //
    // Parse and flag corrupt data
    //

    if( m_bTSHomeFolderChanged )
    {
        ODS( L"Persisting home folder settings\n" );

        if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_LOCAL ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
        {
            bRet = SetWTSLocalPath( hDlg , uc );
            // Set WFHomeDirDrive to NULL because Home folder is a Local folder
            wcscpy(uc.WFHomeDirDrive, L"\0");
        }
        else
        {
            bRet = SetWTSRemotePath( hDlg , uc );
        }

        m_bTSHomeFolderChanged = FALSE;
    }

    if( bRet )
    {
        if( !m_pUSht->SetUserConfig( uc , &dwStatus ) )
        {
            ErrorMessage2( hDlg , dwStatus );

            return TRUE;
        }
        
        PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

        SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

    }

    return bRet;
}

//-------------------------------------------------------------------------------
// IsValidSettings doesnot persist the information
//-------------------------------------------------------------------------------
BOOL CProfileDlg::IsValidSettings( HWND hDlg )
{
    BOOL bRet = TRUE;

    //
    // Parse and flag corrupt data
    //

    if( m_bTSHomeFolderChanged )
    {
        ODS( L"Checking validity of home folders\n" );

        if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_LOCAL ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
        {
            bRet = IsLocalPathValid( hDlg );
        }
        else
        {
            bRet = IsRemotePathValid( hDlg );
        }
    }

    return bRet;
}


//-------------------------------------------------------------------------------
// SetWTSProfilePath
//-------------------------------------------------------------------------------
BOOL CProfileDlg::SetWTSProfilePath( HWND hDlg , USERCONFIG& uc )
{
    //
    // It looks like we don't care what the user enters
    // I'm borrowing the behavior from the current usrmgr profile page
    //

    GetWindowText( GetDlgItem( hDlg , IDC_EDIT_USRPROFILE ) , uc.WFProfilePath , sizeof( uc.WFProfilePath ) / sizeof( TCHAR ) );

    ExpandUserName( uc.WFProfilePath );

    SetWindowText( GetDlgItem( hDlg , IDC_EDIT_USRPROFILE ) , uc.WFProfilePath );

    return TRUE;
}

//-------------------------------------------------------------------------------
// IsLocalPathValid
//-------------------------------------------------------------------------------
BOOL CProfileDlg::IsLocalPathValid( HWND hDlg )
{
    TCHAR tchBuf[ MAX_PATH ] = { 0 };

    TCHAR tchErr[ MAX_PATH ] = { 0 };

    TCHAR tchErrTitle[ 80 ]= { 0 };

    TCHAR tchPath[ MAX_PATH ]= { 0 };

    INT_PTR dw = ( INT_PTR )&tchPath[0];

    if( SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOCALPATH ) , WM_GETTEXT , sizeof( tchPath ) / sizeof( TCHAR ) , ( LPARAM )&tchPath[ 0 ] ) > 0 )
    {
        ExpandUserName( tchPath );

        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOCALPATH ) , tchPath );

        if( !IsPathValid( tchPath , FALSE ) )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_PATH , tchErr , sizeof( tchErr ) / sizeof( TCHAR ) );

            LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , sizeof( tchErrTitle ) / sizeof( TCHAR ) );

            FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchErr , 0 , 0 , tchBuf , sizeof( tchBuf ) / sizeof( TCHAR ) , ( va_list * )&dw );

            MessageBox( hDlg , tchBuf , tchErrTitle , MB_OK | MB_ICONERROR );

            return FALSE;
        }

        // test if path exists or not

        if( GetFileAttributes( tchPath ) != FILE_ATTRIBUTE_DIRECTORY )
        {
			DWORD dwErr;

            if( !m_pUSht->GetDSAType( ) && !createdir( tchPath , FALSE , &dwErr ) )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_WARN_PATH , tchErr , sizeof( tchErr ) / sizeof( TCHAR ) );

                FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchErr , 0 , 0 , tchBuf , sizeof( tchBuf ) / sizeof( TCHAR ) , ( va_list * )&dw );

                LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchErrTitle , sizeof( tchErrTitle ) / sizeof( TCHAR ) );

                MessageBox( hDlg , tchBuf , tchErrTitle , MB_OK | MB_ICONWARNING );
            }
        }
    }

    return TRUE;
}


//-------------------------------------------------------------------------------
// SetWTSLocalPath - copies the contents over - IsPathValid would have return
// true inorder for us to get here!
//-------------------------------------------------------------------------------
BOOL CProfileDlg::SetWTSLocalPath( HWND hDlg , USERCONFIG& uc )
{
    SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOCALPATH ) , WM_GETTEXT , sizeof( uc.WFHomeDir ) / sizeof( TCHAR ) , ( LPARAM )&uc.WFHomeDir[ 0 ] );

    // uc.fHomeDirectoryMapRoot = FALSE;

    return TRUE;
}

//-------------------------------------------------------------------------------
// IsRemotePathValid - verifies UNC is correct
//-------------------------------------------------------------------------------
BOOL CProfileDlg::IsRemotePathValid( HWND hDlg )
{
    TCHAR tchErr1[ 768 ] = { 0 };

    TCHAR tchError[ 768 ] = { 0 };

    TCHAR tchHomeDir[ MAX_PATH ] = { 0 };

    if( GetWindowText( GetDlgItem( hDlg , IDC_EDIT_REMOTEPATH ) , tchHomeDir , sizeof( tchHomeDir ) / sizeof( TCHAR ) ) > 0 )
    {
        ExpandUserName( tchHomeDir );

        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_REMOTEPATH ) , tchHomeDir );

        if( !IsPathValid( tchHomeDir , TRUE ) )
        {
            if( LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_REMOTEPATH , tchErr1 , sizeof( tchErr1 ) / sizeof( TCHAR ) ) > 0 )
            {
                INT_PTR dw = ( INT_PTR )&tchHomeDir[ 0 ];

                FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchErr1 , 0 , 0 , tchError , sizeof( tchError ) / sizeof( TCHAR ) , ( va_list * )&dw );

                LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErr1 , sizeof( tchErr1 ) / sizeof( TCHAR ) );

                MessageBox( hDlg , tchError , tchErr1 , MB_OK | MB_ICONERROR );
            }

            return FALSE;
        }
        /*

		DWORD dwErr = 0;

        if( !createdir( tchHomeDir , TRUE , &dwErr ) )
		{
			if( dwErr != 0 )
			{

				UINT rId;

				switch( dwErr )
				{
				case ERROR_ALREADY_EXISTS:
				case ERROR_LOGON_FAILURE:
				case ERROR_PATH_NOT_FOUND:
					{
						rId = ( ERROR_ALREADY_EXISTS == dwErr) ?
								IDS_HOME_DIR_EXISTS :
								( ERROR_PATH_NOT_FOUND == dwErr ) ?
								IDS_HOME_DIR_CREATE_FAILED :
								IDS_HOME_DIR_CREATE_NO_ACCESS;

						LoadString( _Module.GetResourceInstance( ) , rId , tchErr1 , sizeof( tchErr1 ) / sizeof( TCHAR ) );
						
						wsprintf( tchError , tchErr1 , tchHomeDir );

						LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErr1 , sizeof( tchErr1 ) / sizeof( TCHAR ) );

						MessageBox( hDlg , tchError , tchErr1 , MB_OK | MB_ICONERROR );
					}
					break;

				default:
					xxErrorMessage( hDlg , dwErr , IDS_ERR_CREATE_DIR );				
				}

			}
		}
        */


    }
    else
    {
        LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_NETPATH , tchError , sizeof( tchError ) / sizeof( TCHAR ) );

        LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErr1 , sizeof( tchErr1 ) / sizeof( TCHAR ) );

        MessageBox( hDlg , tchError , tchErr1 , MB_OK | MB_ICONERROR );

        return FALSE;
    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// SetWTSRemotePath - IsRemotePathValid must return TRUE in order to get here
//-------------------------------------------------------------------------------
BOOL CProfileDlg::SetWTSRemotePath( HWND hDlg , USERCONFIG& uc )
{
    TCHAR tchErr1[ 768 ] = { 0 };

    TCHAR tchError[ 768 ] = { 0 };

    GetWindowText( GetDlgItem( hDlg , IDC_EDIT_REMOTEPATH ) , uc.WFHomeDir , sizeof( uc.WFHomeDir ) / sizeof( TCHAR ) );

    if( GetWindowText( GetDlgItem( hDlg , IDC_COMBO_DRIVES ) ,  uc.WFHomeDirDrive , sizeof( uc.WFHomeDirDrive ) / sizeof( TCHAR ) ) == 0 )
    {
        SendMessage( GetDlgItem( hDlg , IDC_COMBO_DRIVES ) , CB_GETLBTEXT , 0 , ( LPARAM )&uc.WFHomeDirDrive );
    }

    DWORD dwErr = 0;

    if( !createdir( uc.WFHomeDir , TRUE , &dwErr ) )
	{
		if( dwErr != 0 )
		{

			UINT rId;

			switch( dwErr )
			{
			case ERROR_ALREADY_EXISTS:
			case ERROR_LOGON_FAILURE:
			case ERROR_PATH_NOT_FOUND:
				{
					rId = ( ERROR_ALREADY_EXISTS == dwErr) ?
							IDS_HOME_DIR_EXISTS :
							( ERROR_PATH_NOT_FOUND == dwErr ) ?
							IDS_HOME_DIR_CREATE_FAILED :
							IDS_HOME_DIR_CREATE_NO_ACCESS;

					LoadString( _Module.GetResourceInstance( ) , rId , tchErr1 , sizeof( tchErr1 ) / sizeof( TCHAR ) );
					
					wsprintf( tchError , tchErr1 , uc.WFHomeDir );

					LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErr1 , sizeof( tchErr1 ) / sizeof( TCHAR ) );

					MessageBox( hDlg , tchError , tchErr1 , MB_OK | MB_ICONERROR );
				}
				break;

			default:
				xxErrorMessage( hDlg , dwErr , IDS_ERR_CREATE_DIR );				
			}

		}
	}

    // uc.fHomeDirectoryMapRoot = TRUE;

    return TRUE;
}


//-------------------------------------------------------------------------------
// This is cool - I_NetPathType really does a lot of work for us
//-------------------------------------------------------------------------------
BOOL CProfileDlg::IsPathValid( LPTSTR pszPath , BOOL bUnc )
{
    DWORD dwRetflags;

    if( I_NetPathType( NULL, pszPath, &dwRetflags, 0) != NERR_Success )
    {
        return FALSE;
    }

    if( !bUnc )
    {
        return ( dwRetflags & ITYPE_PATH_ABSD ? TRUE : FALSE );
    }

    return ( dwRetflags & ITYPE_UNC ? TRUE : FALSE );

}

//-------------------------------------------------------------------------------
// If the string contains %username% expand it to the current user.
//-------------------------------------------------------------------------------
void CProfileDlg::ExpandUserName( LPTSTR szPath )
{
    TCHAR tchSubPath[ MAX_PATH];
    TCHAR szUserName[ 40 ];

    if( szPath == NULL )
    {
        return;
    }

    // remove any leading or trailing spaces

    TCHAR tchTrim[] = TEXT( " " );

    StrTrim( szPath , tchTrim );

    int nSz = LoadString( _Module.GetResourceInstance( ) , IDS_USERNAME , szUserName , sizeof( szUserName ) / sizeof( TCHAR ) );

    //CharLowerBuff( szPath , lstrlen( szPath ) );

    // Find %username%

    LPTSTR pFound = StrStrI( szPath , szUserName ); //_tcsstr( szPath , szUserName );

    if( pFound != NULL )
    {
        INT_PTR nPos = ( INT_PTR )( pFound - szPath );

        lstrcpy( tchSubPath , ( szPath + nPos + nSz ) );

        szPath[ nPos ] = 0;

        lstrcat( szPath , m_pUSht->GetUserName() );

        lstrcat( szPath , tchSubPath );
    }

}

//-------------------------------------------------------------------------------
// Removing decimal entries
//-------------------------------------------------------------------------------
LRESULT CTimeOutDlg::ParseDurationEntry( LPTSTR pszTime , PULONG pTime )
{
    TCHAR tchNoTimeout[ 80 ];

    LPTSTR pszTemp = pszTime;

    UINT uDec = 0;

    BOOL bSetDay  = FALSE;
    BOOL bSetHour = FALSE;
    BOOL bSetMin  = FALSE;
    BOOL bEOL     = FALSE;
    BOOL bHasDigit= FALSE;

    *pTime = 0;

    LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchNoTimeout , sizeof( tchNoTimeout ) / sizeof( TCHAR ) );

    if( lstrcmpi( pszTime , tchNoTimeout ) == 0 )
    {
        // *pTime = 0;

        return E_SUCCESS;
    }

    while( !bEOL )
    {
        // remove leading white spaces

        while( *pszTemp == L' ' )
        {
            pszTemp++;
        }

        while( *pszTemp )
        {
            if( !iswdigit( *pszTemp ) )
            {
                if( !bHasDigit )
                {
                    return E_PARSE_MISSING_DIGITS;
                }

                break;
            }

            // check for overflow

            if( uDec >= 1000000000 )
            {
                return E_PARSE_VALUEOVERFLOW ;
            }

            uDec *= 10;

            uDec += ( *pszTemp - '0' );

            if( !bHasDigit )
            {
                bHasDigit = TRUE;
            }

            pszTemp++;
        }

        // remove intermediate white spaces

        while( *pszTemp == L' ' )
        {
            pszTemp++;
        }

        if( *pszTemp != NULL )
        {
            // Get next token

            TCHAR tchToken[ 80 ];

            pszTemp = GetNextToken( pszTemp , tchToken );


            if( IsToken( tchToken , TOKEN_DAY ) )
            {
                if( !bSetDay )
                {
                    *pTime += uDec * 1440;

                    bSetDay = TRUE;
                }

            }
            else if( IsToken( tchToken , TOKEN_HOUR ) )
            {
                if( !bSetHour )
                {
                    *pTime += uDec * 60;

                    bSetHour = TRUE;
                }

            }
            else if( IsToken( tchToken , TOKEN_MINUTE ) )
            {
                if( !bSetMin )
                {
                    *pTime += uDec;

                    bSetMin = TRUE;
                }

            }
            else
            {
                return E_PARSE_INVALID;
            }

        }
        else
        {
            if( !bSetHour )
            {
                *pTime += uDec * 60;
            }

            bEOL = TRUE;
        }

        uDec = 0;

        bHasDigit = FALSE;

    }

    return E_SUCCESS;
}

//-------------------------------------------------------------------------------
// replacing older api
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ConvertToDuration( ULONG ulTime , LPTSTR pszDuration )
{
//    TCHAR dw[] = L"dhm";

    TCHAR tchTimeUnit[ 40 ];

    TCHAR tchTimeFormat[ 40 ];

    TCHAR tchOutput[ 80 ];

    ASSERT_( ulTime != 0 );

    int iHour = ( ulTime / 60 );

    int iDays = iHour / 24;

    int iMinute = ulTime % 60;

    // Resolve format

    tchOutput[0] = 0;


    if( iDays > 0 )
    {
        if( iDays == 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_DAY , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_DAYS , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }

        iHour = iHour % 24;

        wsprintf( tchTimeFormat , L"%d %s", iDays , tchTimeUnit );

        lstrcat( tchOutput , tchTimeFormat );

        lstrcat( tchOutput , L" " );
    }

    if( iHour > 0 )
    {
        if( iHour == 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_HOUR , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_HOURS , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }

        wsprintf( tchTimeFormat , L"%d %s", iHour , tchTimeUnit );

        lstrcat( tchOutput , tchTimeFormat );

        lstrcat( tchOutput , L" " );
    }

    if( iMinute > 0 )
    {
        if( iMinute == 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTE , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , sizeof( tchTimeUnit ) / sizeof( TCHAR ) );
        }

        wsprintf( tchTimeFormat , L"%d %s", iMinute , tchTimeUnit );

        lstrcat( tchOutput , tchTimeFormat );

        lstrcat( tchOutput , L" " );
    }

    lstrcpy( pszDuration , tchOutput );

    return TRUE;

}

//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::DoesContainDigits( LPTSTR pszString )
{
    while( *pszString )
    {
        if( *pszString != L' ')
        {
            if( iswdigit( *pszString ) )
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }

            pszString++;
        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
TCHAR * GetNextToken( TCHAR *pszString , TCHAR *tchToken )
{
    while( *pszString )
    {
        if( IsCharAlpha( *pszString ) )
        {
            *tchToken = *pszString;
        }
        else
        {
            break;
        }

        tchToken++;

        pszString++;
    }

    *tchToken = '\0';

    return pszString;
}

//-------------------------------------------------------------------------------
void ErrorMessage1( HWND hParent , DWORD dwStatus )
{
    xxErrorMessage( hParent , dwStatus , IDS_TSGETPROPSFAILED );
}

//-------------------------------------------------------------------------------
void ErrorMessage2( HWND hParent , DWORD dwStatus )
{
    xxErrorMessage( hParent , dwStatus , IDS_TSOPSFAILED );
}

//-------------------------------------------------------------------------------
void xxErrorMessage( HWND hParent , DWORD dwStatus , UINT nResID )
{
    LPTSTR pBuffer = NULL;

    TCHAR tchBuffer[ 256 ];

    TCHAR tchErr[ 128 ];

    TCHAR tchTitle[ 80 ];

    LoadString( _Module.GetModuleInstance( ) , nResID , tchErr , sizeof( tchErr ) / sizeof( TCHAR ) );

    LoadString( _Module.GetModuleInstance( ) , IDS_TSGETPROPTITLE , tchTitle , sizeof( tchTitle ) / sizeof( TCHAR ) );

    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                 FORMAT_MESSAGE_FROM_SYSTEM,
                 NULL,                                          //ignored
                 dwStatus    ,                                //message ID
                 MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ), //message language
                 (LPTSTR)&pBuffer,                              //address of buffer pointer
                 0,                                             //minimum buffer size
                 NULL);                                         //no other arguments

    wsprintf( tchBuffer , tchErr , pBuffer );

    ::MessageBox( hParent , tchBuffer , tchTitle , MB_OK | MB_ICONERROR );

    if( pBuffer != NULL )
    {
        LocalFree( pBuffer );
    }

}




#if 0
//-------------------------------------------------------------------------------
NTSTATUS GetDomainName( PWCHAR ServerNamePtr, // name of server to get domain of
                        LPTSTR DomainNamePtr // alloc and set ptr (free with NetApiBufferFree)
                       )

/*++

Routine Description:

    Returns the name of the domain or workgroup this machine belongs to.

Arguments:

    DomainNamePtr - The name of the domain or workgroup

    IsWorkgroupName - Returns TRUE if the name is a workgroup name.
        Returns FALSE if the name is a domain name.

Return Value:

   NERR_Success - Success.
   NERR_CfgCompNotFound - There was an error determining the domain name

--*/
{
    NTSTATUS status;
    LSA_HANDLE PolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo;
    OBJECT_ATTRIBUTES ObjAttributes;
    UNICODE_STRING UniServerName;


    //
    // Check for caller's errors.
    //
    if ( DomainNamePtr == NULL ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    RtlInitUnicodeString( &UniServerName, ServerNamePtr );
    status = LsaOpenPolicy(
                   &UniServerName,
                   &ObjAttributes,
                   POLICY_VIEW_LOCAL_INFORMATION,
                   &PolicyHandle
                   );


    KdPrint( ( "TSUSEREX - GetDomainName: LsaOpenPolicy returned NTSTATUS = 0x%x\n", status ) );



    if (! NT_SUCCESS(status)) {
        return( status );
    }

    //
    // Get the name of the primary domain from LSA
    //
    status = LsaQueryInformationPolicy(
                   PolicyHandle,
                   PolicyAccountDomainInformation,
                   (PVOID *)&DomainInfo
                   );


    KdPrint( ( "TSUSEREX - GetDomainName: LsaQueryInformationPolicy returned NTSTATUS = 0x%x\n", status ) );



    if (! NT_SUCCESS(status)) {
        (void) LsaClose(PolicyHandle);
        return( status );
    }

    (void) LsaClose(PolicyHandle);

    lstrcpy( DomainNamePtr , DomainInfo->DomainName.Buffer );

    (void) LsaFreeMemory((PVOID) DomainInfo);

    return( STATUS_SUCCESS );
}
#endif


BOOL CProfileDlg::createdir( LPTSTR szPath , BOOL bIsRemote , PDWORD pdwErr )
{
    int npos = 0;

	*pdwErr = ERROR_INVALID_NAME;

    if( bIsRemote )
    {
        // skip over three four whacks		

        npos = 2;

        if( szPath[0] != TEXT( '\\' ) && szPath[1] != TEXT( '\\' ) )
        {
            return FALSE;
        }

        for( int n = 0; n < 2 ; n++ )
        {
            while( szPath[ npos ] != TEXT( '\\' ) && szPath[ npos ] != TEXT( '\0' ) )
            {
                npos++;
            }

            if( szPath[ npos ] == TEXT( '\0' ) )
            {
                return FALSE;
            }

            npos++;
        }

    }
    else
    {

        if( szPath[1] != TEXT( ':' ) && szPath[2] != TEXT( '\\' ) )
        {
            return FALSE;
        }

        npos = 3;
    }

	SECURITY_ATTRIBUTES securityAttributes;

	ZeroMemory( &securityAttributes , sizeof( SECURITY_ATTRIBUTES ) );

	// its redundant to check the bIsRemote flag since for dsadmin createdir is only called for
	// UNC paths

	if( m_pUSht->GetDSAType() && bIsRemote )
	{
		//
		// From EricB's DSPROP_CreateHomeDirectory
		PSID psidAdmins = NULL;

		SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;

		if (!AllocateAndInitializeSid(&NtAuth,
							  2,
							  SECURITY_BUILTIN_DOMAIN_RID,
							  DOMAIN_ALIAS_RID_ADMINS,
							  0, 0, 0, 0, 0, 0,
							  &psidAdmins  ) )
		{		
		 ODS( L"AllocateAndInitializeSid failed\n");

		 *pdwErr = GetLastError( );

		 return FALSE;

		}


		// build a DACL

		PACL pDacl;

		static const int nAceCount = 2;
		PSID pAceSid[nAceCount];

		pAceSid[0] = m_pUSht->GetUserSid( );
		pAceSid[1] = psidAdmins;

		EXPLICIT_ACCESS rgAccessEntry[nAceCount] = {0};
		
		for (int i = 0 ; i < nAceCount; i++)
		{
			rgAccessEntry[i].grfAccessPermissions = GENERIC_ALL;
			rgAccessEntry[i].grfAccessMode = GRANT_ACCESS;
			rgAccessEntry[i].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

			// build the trustee structs
			//
			BuildTrusteeWithSid(&(rgAccessEntry[i].Trustee),
							              pAceSid[i]);
		}

		// add the entries to the ACL
		//
		*pdwErr = SetEntriesInAcl( nAceCount, rgAccessEntry, NULL, &pDacl );

		if( *pdwErr != 0 )
		{
			ODS( L"SetEntriesInAcl() failed\n" );

			return FALSE;
		}

		// build a security descriptor and initialize it
		// in absolute format

		SECURITY_DESCRIPTOR securityDescriptor;

		PSECURITY_DESCRIPTOR pSecurityDescriptor = &securityDescriptor;
		
		if( !InitializeSecurityDescriptor( pSecurityDescriptor , SECURITY_DESCRIPTOR_REVISION ) )
		{
			ODS( L"InitializeSecurityDescriptor() failed\n" );

			*pdwErr = GetLastError( );

			return FALSE;
		}

		// add DACL to security descriptor (must be in absolute format)
		
		if( !SetSecurityDescriptorDacl( pSecurityDescriptor,
			                            TRUE, // bDaclPresent
				                        pDacl,
					                    FALSE // bDaclDefaulted
						               ) )
		{
			
			ODS( L"SetSecurityDescriptorDacl() failed\n" );

			*pdwErr = GetLastError( );

			return FALSE;
		}


		// set the owner of the directory
		if( !SetSecurityDescriptorOwner( pSecurityDescriptor ,
			                             m_pUSht->GetUserSid( ) ,
				                         FALSE // bOwnerDefaulted
					                   ) )
		{
			
			ODS( L"SetSecurityDescriptorOwner() failed\n" );

			*pdwErr = GetLastError( );

			return FALSE;
		}

		ASSERT_( IsValidSecurityDescriptor( pSecurityDescriptor ) );

		// build a SECURITY_ATTRIBUTES struct as argument for
		// CreateDirectory()
		
		securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);

		securityAttributes.lpSecurityDescriptor = pSecurityDescriptor;

		securityAttributes.bInheritHandle = FALSE;

		if( !CreateDirectory( szPath , &securityAttributes ) )
		{
            *pdwErr = GetLastError( );

            if( psidAdmins != NULL )
            {
                FreeSid( psidAdmins );
            }

			return FALSE;
		}	

		FreeSid( psidAdmins );

	}
	else
	{	
		// for local accounts we don't need to set security

		while( szPath[ npos ] != TEXT( '\0' ) )
		{
			while( szPath[ npos ] != TEXT( '\\' ) && szPath[ npos ] != TEXT( '\0' ) )
			{
				npos++;
			}

			if( szPath[ npos ] == TEXT( '\0' ) )
			{
				CreateDirectory( szPath , 0 );
			}
			else
			{
				szPath[ npos ] = 0;

				CreateDirectory( szPath , 0 );

				szPath[ npos ] = TEXT( '\\' );

				npos++;
			}
		}
	}

	*pdwErr = 0;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\tsusrsht.h ===
#ifndef _TSUSERSHEET_H
#define _TSUSERSHEET_H

#include <winsta.h>

#define NUM_OF_PAGES 4

class CDialogBase;

#ifdef UNICODE

#define COPYWCHAR2TCHAR( SRC , DEST ) \
            wcscpy( SRC , DEST );
#else

#define COPYWCHAR2TCHAR( SRC , DEST ) \
        { \
           DWORD dwLen; \
           dwLen = wcslen( DEST ); \
           WideCharToMultiByte( CP_ACP , 0 , DEST , dwLen , SRC , dwLen / sizeof( WCHAR ) , 0 , 0 ); \
        }
#endif

#define ALN_APPLY ( WM_USER + 900 )

const ULONG kMilliMinute = 60000;
const ULONG kMaxTimeoutMinute = 71580;

#define E_PARSE_VALUEOVERFLOW   0x80000000
#define E_PARSE_INVALID         0xffffffff
#define E_SUCCESS               0
#define E_PARSE_MISSING_DIGITS  0X7fffffff

enum TOKEN { TOKEN_DAY , TOKEN_HOUR , TOKEN_MINUTE };

//---------------------------------------------------------------------
// Class for managing user manager for Terminal server extensions
//---------------------------------------------------------------------
class CTSUserSheet
{
private:
    LPTSTR m_pstrMachinename;

    LPTSTR m_pstrUsername;

    CDialogBase *m_pDlg[ NUM_OF_PAGES ];

    UINT m_cref;

    BOOL m_bDC;             // domain controller

    BOOL m_bIsConfigLoaded;

    BOOL GetUserConfig( PDWORD );

    TCHAR m_szRemoteServerName[ MAX_PATH ];

    BOOL m_bDSAType;	

	PSID m_pUserSid;

public:
    CTSUserSheet();

    ~CTSUserSheet();

	

    BOOL SetServerAndUser( LPWSTR , LPWSTR );

    HRESULT AddPagesToPropSheet( LPPROPERTYSHEETCALLBACK pProvider );

	HRESULT AddPagesToDSAPropSheet( LPFNADDPROPSHEETPAGE , LPARAM );


    BOOL SetUserConfig( USERCONFIG& , PDWORD );

    USERCONFIG& GetCurrentUserConfig( PDWORD );

    LPTSTR GetUserName( ) { return m_pstrUsername; }

    void SetDSAType( BOOL bT ) { m_bDSAType = bT; }

    BOOL GetDSAType( void ) { return m_bDSAType; }

	void CopyUserSid( PSID );

	PSID GetUserSid( ) { return m_pUserSid; }

    UINT AddRef( );

    UINT Release( );

    //
    // public data
    //

    USERCONFIG m_userconfig;
};

//---------------------------------------------------------------------
// CDialogBase - as the name implies base class for all the dialogs
//---------------------------------------------------------------------
class CDialogBase
{
protected:
    BOOL m_bPersisted;

    HWND m_hWnd;

public:
    virtual BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    virtual BOOL OnDestroy( ){ return TRUE; }

    virtual BOOL GetPropertySheetPage( PROPSHEETPAGE& ){ return FALSE;}

    virtual BOOL PersistSettings( HWND ){ return FALSE;}

    virtual BOOL IsValidSettings( HWND ){ return TRUE;}

    virtual BOOL OnNotify( int , LPNMHDR , HWND );

    virtual BOOL OnContextMenu( HWND , POINT& );

    virtual BOOL OnHelp( HWND , LPHELPINFO );

    CDialogBase( );

    //virtual ~CDialogBase( );
};

//---------------------------------------------------------------------
// Dialog for profile page
//---------------------------------------------------------------------
class CEnviroDlg : public CDialogBase
{
    CTSUserSheet *m_pUSht;

public:

    CEnviroDlg( CTSUserSheet *);

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL PersistSettings( HWND );

    void OnCommand( WORD , WORD , HWND );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

};

//---------------------------------------------------------------------
// retains object state for the timeout dlg combx
//---------------------------------------------------------------------
typedef struct _cbxstate
{
    int icbxSel;

    BOOL bEdit;

} CBXSTATE;

//---------------------------------------------------------------------
// keeps a list of the time unit abbreviations and full names
// ie: h hr hrs hour hours
//---------------------------------------------------------------------
typedef struct _toktable
{
    LPTSTR pszAbbrv;

    DWORD dwresourceid;

} TOKTABLE, *PTOKTABLE;

//---------------------------------------------------------------------
// Dialog for Timeout settings page
//---------------------------------------------------------------------
class CTimeOutDlg : public CDialogBase
{
    CTSUserSheet *m_pUSht;

    static WNDPROC m_pfWndproc;

    CBXSTATE m_cbxst[ 3 ];

    WORD m_wAction;

    WORD m_wCon;

    TOKTABLE m_tokday[ 4 ];

    TOKTABLE m_tokhour[ 6 ];

    TOKTABLE m_tokmin[ 5 ];

public:

    CTimeOutDlg( CTSUserSheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL PersistSettings( HWND );

    BOOL IsValidSettings( HWND );

    void OnCommand( WORD , WORD , HWND );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL ConvertToMinutes( HWND , PULONG );

    BOOL InsertSortedAndSetCurSel( HWND , DWORD );

    BOOL RestorePreviousValue( HWND );

    BOOL SaveChangedSelection( HWND );

    void OnCBNSELCHANGE( HWND );

    BOOL ConvertToDuration ( ULONG , LPTSTR );

    LRESULT ParseDurationEntry( LPTSTR , PULONG );

    int GetCBXSTATEindex( HWND );

    void OnCBEditChange( HWND );

    BOOL DoesContainDigits( LPTSTR );

    BOOL OnCBDropDown( HWND );

    BOOL IsToken( LPTSTR , TOKEN );

    BOOL LoadAbbreviates( );

    BOOL xxxLoadAbbreviate( PTOKTABLE );

    BOOL xxxUnLoadAbbreviate( PTOKTABLE );

    void InitTokTables( );

};


//---------------------------------------------------------------------
// Dialog for Shadowing settings page
//---------------------------------------------------------------------
class CShadowDlg : public CDialogBase
{
    CTSUserSheet *m_pUSht;

    WORD m_wOldRad;

public:

    CShadowDlg( CTSUserSheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    void OnCommand( WORD , WORD , HWND );

    // BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL PersistSettings( HWND );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

};


//---------------------------------------------------------------------
// Dialog for profile page
//---------------------------------------------------------------------
class CProfileDlg : public CDialogBase
{
    CTSUserSheet *m_pUSht;

    int m_ncbxOld;

    WORD m_wOldRadio;

    BOOL m_bTSHomeFolderChanged;    

public:

    CProfileDlg( CTSUserSheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    void OnCommand( WORD , WORD , HWND );

    BOOL EnableRemoteHomeDirectory( HWND , BOOL );

    BOOL SetWTSProfilePath( HWND , USERCONFIG& );

    BOOL SetWTSLocalPath( HWND , USERCONFIG& );

    BOOL SetWTSRemotePath( HWND , USERCONFIG& );

    BOOL IsPathValid( LPTSTR , BOOL );

    BOOL PersistSettings( HWND );

    BOOL IsValidSettings( HWND );

    BOOL IsLocalPathValid( HWND );

    BOOL IsRemotePathValid( HWND hDlg );

    void ExpandUserName( LPTSTR );

    BOOL createdir( LPTSTR  , BOOL , PDWORD );


    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

};


#endif //_TSUSERSHEET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsuserex\registry.cpp ===
/*--------------------------------------------------------------------------------------------------------
*  Copyright (c) 1998  Microsoft Corporation
*
*  Module Name:
*
*      Registry.cpp
*
*  Abstract:
*
*      Registry.cpp: implementation of the CRegistry class.
*      This class helps with registry by allocating memory by itself
*      As a result caller must copy the pointer returned by Get functions
*      immediately.
*
*
*
*  Author:
*
*      Makarand Patwardhan  - April 9, 1997
*
* -------------------------------------------------------------------------------------------------------*/

#include "stdafx.h"
#include "Registry.h"


/*--------------------------------------------------------------------------------------------------------
* Constructor
* -------------------------------------------------------------------------------------------------------*/
CRegistry::CRegistry()
{
    m_pMemBlock = NULL;
    m_hKey = NULL;
    m_iEnumIndex = -1;
    m_iEnumValueIndex = -1;

#ifdef DBG
    m_dwSizeDebugOnly = 0;
#endif
}

/*--------------------------------------------------------------------------------------------------------
* Destructor
* -------------------------------------------------------------------------------------------------------*/
CRegistry::~CRegistry()
{
    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
    Release();
}

/*--------------------------------------------------------------------------------------------------------
* void Allocate (DWORD dwSize)
* This private function is used for allocating the memory for 
* reading registry
* returns the pointer to memory allocated.
* -------------------------------------------------------------------------------------------------------*/
void *CRegistry::Allocate (DWORD dwSize)
{
    ASSERT(dwSize != 0);
    if (m_pMemBlock)
        Release();
    
    m_pMemBlock = new BYTE[dwSize];

#ifdef DBG
    // remember the size of the block to be allocated.
    m_dwSizeDebugOnly = dwSize;
#endif

    return m_pMemBlock;
}

/*--------------------------------------------------------------------------------------------------------
* void Release ()
* This private function is used for releasing internal memory block
* -------------------------------------------------------------------------------------------------------*/
void CRegistry::Release ()
{
    if (m_pMemBlock)
    {

#ifdef DBG
        // fistly fill up the block we allocated previously with garbage.
        // so that if anybody is using this block, it is more lilely to 
        // catch the bug.
        ASSERT(m_dwSizeDebugOnly != 0);
        FillMemory(m_pMemBlock, m_dwSizeDebugOnly, 'c');
        m_dwSizeDebugOnly = 0;

#endif

        delete [] m_pMemBlock;
    }
    
    m_pMemBlock = 0;
}


/*--------------------------------------------------------------------------------------------------------
* DWORD CRegistry::CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS, DWORD *pDisposition = NULL)
* opens/creates the key specified. before attempting any operation on any key/value. this function
* must be called.
* hKey - hive
* lpSubKey - Path of the key in the format _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server")
* access - access desired. like REG_READ, REG_WRITE..
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, DWORD *pDisposition /*= NULL*/)
{
    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    DWORD dwDisposition;
    LONG lResult = RegCreateKeyEx( 
                    hKey,               // handle of an open key 
                    lpSubKey,           // address of subkey name 
                    0,                  // reserved 
                    NULL,               // address of class string 
                    REG_OPTION_NON_VOLATILE ,  // special options flag 
                    access,             // desired security access 
                    NULL,               // address of key security structure 
                    &m_hKey,            // address of buffer for opened handle 
                    &dwDisposition      // address of disposition value buffer 
                    ); 

    if (lResult != ERROR_SUCCESS)
    {
        m_hKey = NULL;
    }

    if (pDisposition)
        *pDisposition = dwDisposition;

    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access) ()
* opens the key specified. before attempting any operation on any key/value. this function
* must be called.
* hKey - hive
* lpSubKey - Path of the key in the format _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server")
* access - access desired. like REG_READ, REG_WRITE..
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/ )
{
    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
    
    LONG lResult = RegOpenKeyEx( 
        hKey,                       // handle of open key 
        lpSubKey,                   // address of name of subkey to open 
        0 ,                         // reserved 
        access,                     // security access mask 
        &m_hKey                     // address of handle of open key 
        );
    
    if (lResult != ERROR_SUCCESS)
    {
        m_hKey = NULL;
    }
    
    return lResult;
}


DWORD CRegistry::RecurseDeleteKey (LPCTSTR lpSubKey)
{
    ASSERT(lpSubKey);
    ASSERT(m_hKey);

    CRegistry reg;
    DWORD dwError = reg.OpenKey(m_hKey, lpSubKey);
    if (dwError != ERROR_SUCCESS)
        return dwError;

    
    LPTSTR lpChildKey;
    DWORD  dwSize;
    
    // we needn't/shouldn't use GetNextSubKey in here
    // as we are deleting the keys in the loop.
    while (ERROR_SUCCESS == reg.GetFirstSubKey(&lpChildKey, &dwSize))
    {
        reg.RecurseDeleteKey(lpChildKey);
    }

    return RegDeleteKey(m_hKey, lpSubKey);
    
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadReg(LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype)
* Reads the registry used internally.
* LPCTSTR lpValue - value to be read.
* LPBYTE *lppbyte - address of the lpbyte at which to place the output buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* dword datatype - datatype you are expecting.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadReg(LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype)
{
    ASSERT(lpValue);
    ASSERT(lppbyte);
    ASSERT(pdw);
    ASSERT(m_hKey != NULL);
    *pdw = 0;
    
    DWORD dwType;
    DWORD lResult = RegQueryValueEx( 
        m_hKey,             // handle of key to query 
        lpValue,            // address of name of value to query 
        0,                  // reserved 
        &dwType,            // address of buffer for value type 
        0,                  // address of data buffer 
        pdw                 // address of data buffer size 
        ); 
    
    if (lResult == ERROR_SUCCESS)
    {
        ASSERT(dwType == dwDatatype || dwType == REG_EXPAND_SZ);
    
        if (0 == Allocate(*pdw))
            return ERROR_OUTOFMEMORY;

        lResult = RegQueryValueEx( 
            m_hKey,                 // handle of key to query 
            lpValue,                // address of name of value to query 
            0,                      // reserved 
            &dwType,                // address of buffer for value type 
            m_pMemBlock,            // address of data buffer 
            pdw                     // address of data buffer size 
            ); 
    
        ASSERT (ERROR_MORE_DATA != lResult);
    
        if (lResult == ERROR_SUCCESS)
            *lppbyte = m_pMemBlock;
    }
    
    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
* Reads A string (REG_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
{
    return ReadReg(lpValue, (LPBYTE *)lppStr, pdw, REG_SZ);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegDWord(LPCTSTR lpValue, DWORD *pdw)
* Reads A string (REG_SZ) from the registry
* LPCTSTR lpValue value to be read.
* DWORD  *pdw  - address of dword in which the read dword returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegDWord(LPCTSTR lpValue, DWORD *pdw)
{
    ASSERT(pdw);
    
    DWORD dwSize;
    LPBYTE pByte;
    DWORD dwReturn = ReadReg(lpValue, &pByte, &dwSize, REG_DWORD);
    ASSERT(dwSize == sizeof(DWORD));
    *pdw = * LPDWORD(pByte);
    return dwReturn;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegMultiString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
* Reads A string (REG_MULTI_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegMultiString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
{
    return ReadReg(lpValue, (LPBYTE *)lppStr, pdw, REG_MULTI_SZ);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegBinary(LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw)
* Reads A string (REG_MULTI_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPBYTE *lppByte - address of LPBYTE in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegBinary(LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw)
{
    return ReadReg(lpValue, lppByte, pdw, REG_BINARY);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetFirstSubKey(LPTSTR *lppStr, DWORD *pdw)
* Reads a first subkey for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetFirstSubKey(LPTSTR *lppStr, DWORD *pdw)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    m_iEnumIndex = 0;
    
    return GetNextSubKey(lppStr, pdw);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetNextSubKey(LPTSTR *lppStr, DWORD *pdw
* Reads the next subkey for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetNextSubKey(LPTSTR *lppStr, DWORD *pdw)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(m_hKey != NULL);
    ASSERT(m_iEnumIndex >= 0); // must call GetFirstSubKey first.
    
    //FILETIME unused;
    
    *pdw = 256;
    if (0 == Allocate(*pdw))
        return ERROR_NOT_ENOUGH_MEMORY;

    LONG lResult = RegEnumKeyEx( 
        m_hKey,                     // handle of key to enumerate 
        m_iEnumIndex,               // index of subkey to enumerate 
        (LPTSTR)m_pMemBlock,        // address of buffer for subkey name 
        pdw,                        // address for size of subkey buffer 
        0,                          // reserved 
        NULL,                       // address of buffer for class string 
        NULL,                       // address for size of class buffer 
        NULL                        // address for time key last written to 
        ); 
    
    (*pdw)++;    // since null is not included in the size.
    if (ERROR_NO_MORE_ITEMS == lResult)
        return lResult;
    
    m_iEnumIndex++;
    
    if (lResult == ERROR_SUCCESS)
        *lppStr = (LPTSTR)m_pMemBlock;
    
    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetFirstValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
* Reads a first value for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* DWORD *pDataType - datatype of the value is returned in this one.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetFirstValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(pDataType);
    
    m_iEnumValueIndex = 0;
    return GetNextValue(lppStr, pdw, pDataType);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetNextValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
* Reads a next value for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* DWORD *pDataType - datatype of the value is returned in this one.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetNextValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(pDataType);
    ASSERT(m_hKey != NULL);
    ASSERT(m_iEnumValueIndex >= 0); // must call GetFirstSubKey first.
    
    *pdw = 256;
    if (0 == Allocate(*pdw))
        return ERROR_NOT_ENOUGH_MEMORY;
    
    LONG lResult = RegEnumValue( 
        m_hKey,                     // handle of key to query 
        m_iEnumValueIndex,          // index of value to query 
        (LPTSTR)m_pMemBlock,        // address of buffer for value string 
        pdw,                        // address for size of value buffer 
        0,                          // reserved 
        pDataType,                  // address of buffer for type code 
        NULL,                       // address of buffer for value data    maks_todo : use this
        NULL                        // address for size of data buffer 
        ); 
    
    (*pdw)++;    // since null is not included in the size.
    
    if (ERROR_NO_MORE_ITEMS == lResult)
        return lResult;
    
    
    m_iEnumValueIndex++;
    if (lResult == ERROR_SUCCESS)
        *lppStr = (LPTSTR)m_pMemBlock;
    
    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegString(LPCTSTR lpValueName, LPCTSTR lpStr)
* writes REG_SZ value into the registry 
* LPCTSTR lpValueName - value name to be written to 
* LPCTSTR lpStr - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegString(LPCTSTR lpValueName, LPCTSTR lpStr)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

    DWORD dwSize = (_tcslen(lpStr) + 1) * sizeof(TCHAR) / sizeof(BYTE);
    return RegSetValueEx( 
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_SZ,                 // flag for value type 
        (LPBYTE)lpStr,          // address of value data 
        dwSize                  // size of value data 
        ); 
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegMultiString(LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize)
* writes REG_MULTI_SZ value into the registry 
* LPCTSTR lpValueName - value name to be written to 
* LPCTSTR lpStr - data to be written 
* DWORD   dwSize - size of data.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegMultiString(LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

#ifdef DBG
    
    // lets make sure that the given size is right.
    LPCTSTR lpTemp = lpStr;
    DWORD rightsize = 0;
    while (_tcslen(lpTemp) > 0)
    {
        rightsize  += _tcslen(lpTemp) + 1;
        lpTemp += _tcslen(lpTemp) + 1;
    }

    ASSERT(*lpTemp == 0);           // final NULL.
    rightsize++;                    // account for final terminating null

    rightsize *= sizeof(TCHAR) / sizeof(BYTE); // size must be in bytes.

    ASSERT(dwSize == rightsize);
    
#endif

    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_MULTI_SZ,           // flag for value type 
        (LPBYTE)lpStr,          // address of value data 
        dwSize                  // size of value data 
        ); 
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsutil\acl.c ===
/*
 *  Acl.c
 *
 *  Author: BreenH
 *
 *  Acl utilities.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutil.h"
#include "tsutilnt.h"

/*
 *  Function Implementations
 */

BOOL WINAPI
AddSidToObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    PSID pSid,
    DWORD dwNewAccess,
    ACCESS_MODE AccessMode,
    DWORD dwInheritance
    )
{
    BOOL fRet;
    DWORD dwRet;
    EXPLICIT_ACCESS ExpAccess;
    PACL pNewDacl;
    PACL pOldDacl;
    PSECURITY_DESCRIPTOR pSd;

    //
    //  Get the objects security descriptor and current Dacl.
    //

    pSd = NULL;
    pOldDacl = NULL;

    dwRet = GetSecurityInfo(
            hObject,
            ObjectType,
            DACL_SECURITY_INFORMATION,
            NULL,
            NULL,
            &pOldDacl,
            NULL,
            &pSd
            );

    if (dwRet != ERROR_SUCCESS)
    {
        return(FALSE);
    }

    //
    //  Initialize an EXPLICIT_ACCESS structure for the new ace.
    //

    ZeroMemory(&ExpAccess, sizeof(EXPLICIT_ACCESS));
    ExpAccess.grfAccessPermissions = dwNewAccess;
    ExpAccess.grfAccessMode = AccessMode;
    ExpAccess.grfInheritance = dwInheritance;
    BuildTrusteeWithSid(&(ExpAccess.Trustee), pSid);

    //
    //  Merge the new ace into the existing Dacl.
    //

    fRet = FALSE;

    dwRet = SetEntriesInAcl(
            1,
            &ExpAccess,
            pOldDacl,
            &pNewDacl
            );

    if (dwRet == ERROR_SUCCESS)
    {

        //
        //  Set the new security for the object.
        //

        dwRet = SetSecurityInfo(
                hObject,
                ObjectType,
                DACL_SECURITY_INFORMATION,
                NULL,
                NULL,
                pNewDacl,
                NULL
                );

        if (dwRet == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
    }

    if (pNewDacl != NULL)
    {
        LocalFree(pNewDacl);
    }

    if (pSd != NULL)
    {
        LocalFree(pSd);
    }

    return(fRet);
}


BOOL WINAPI
AddSidToSecurityDescriptor(
    PSECURITY_DESCRIPTOR *ppSd,
    PSID pSid,
    DWORD dwNewAccess,
    ACCESS_MODE AccessMode,
    DWORD dwInheritance
    )
{
    BOOL fAbsoluteSd;
    BOOL fDaclDefaulted;
    BOOL fDaclPresent;
    BOOL fRet;
    PACL pDacl;
    PSECURITY_DESCRIPTOR pAbsoluteSd;
    PSECURITY_DESCRIPTOR pOriginalSd;

    ASSERT(ppSd != NULL);
    ASSERT(*ppSd != NULL);

    //
    //  The security descriptors should be absolute to allow the addition of
    //  the new ace.
    //

    pOriginalSd = *ppSd;

    fAbsoluteSd = IsSecurityDescriptorAbsolute(pOriginalSd);

    if (!fAbsoluteSd)
    {
        fRet = ConvertSelfRelativeToAbsolute(&pAbsoluteSd, pOriginalSd);

        if (!fRet)
        {
            return(FALSE);
        }
    }
    else
    {
        pAbsoluteSd = pOriginalSd;
    }

    //
    //  Now that the type of security descriptor is absolute, get the Dacl.
    //

    pDacl = NULL;

    fRet = GetSecurityDescriptorDacl(
            pAbsoluteSd,
            &fDaclPresent,
            &pDacl,
            &fDaclDefaulted
            );

    if (fRet)
    {
        DWORD dwRet;
        EXPLICIT_ACCESS ExplicitAccess;
        PACL pNewDacl;

        //
        //  Initialize an EXPLICIT_ACCESS structure for the new ace.
        //

        RtlZeroMemory(&ExplicitAccess, sizeof(EXPLICIT_ACCESS));
        ExplicitAccess.grfAccessPermissions = dwNewAccess;
        ExplicitAccess.grfAccessMode = AccessMode;
        ExplicitAccess.grfInheritance = dwInheritance;
        BuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid);

        //
        //  Merge the ace into the existing Dacl. This will allocate a new
        //  Dacl. Unfortunately this API is only available as a WINAPI.
        //

        pNewDacl = NULL;

        dwRet = SetEntriesInAcl(
                1,
                &ExplicitAccess,
                pDacl,
                &pNewDacl
                );

        if (dwRet == ERROR_SUCCESS)
        {
            ASSERT(pNewDacl != NULL);

            //
            //  Point the security descriptor's Dacl to the new Dacl.
            //

            fRet = SetSecurityDescriptorDacl(
                    pAbsoluteSd,
                    TRUE,
                    pNewDacl,
                    FALSE
                    );

            if (fRet)
            {
                PULONG_PTR pBeginning;
                PULONG_PTR pEnd;
                PULONG_PTR pPtr;

                //
                //  The new Dacl has been set, free the old. Be careful here;
                //  the RTL folks like to put absolute security descriptors in
                //  one big allocation, just like a self-relative security
                //  descriptor. If the old Dacl is inside the security
                //  descriptor allocation, it cannot be freed. Essentially,
                //  that memory becomes unused, and the security descriptor
                //  takes up more space than necessary.
                //

                pBeginning = (PULONG_PTR)pAbsoluteSd;
                pEnd = (PULONG_PTR)((PBYTE)pAbsoluteSd +
                        LocalSize(pAbsoluteSd));
                pPtr = (PULONG_PTR)pDacl;

                if ((pPtr < pBeginning) || (pPtr > pEnd))
                {
                    LocalFree(pDacl);
                }
            }
            else
            {

                //
                //  A failure occurred setting the new Dacl. This should never
                //  occur, but if it does, free the newly created Dacl.
                //

                LocalFree(pNewDacl);
            }
        }
        else
        {
            fRet = FALSE;
        }
    }

    //
    //  The new security descriptor should be returned in the same format as
    //  the original security descriptor. The returned security descriptor is
    //  also dependent on the success of the function.
    //

    if (!fAbsoluteSd)
    {
        if (fRet)
        {
            PSECURITY_DESCRIPTOR pNewSd;

            //
            //  The original security descriptor was self-relative, and until
            //  now everything has succeeded. Convert the temporary absolute
            //  security descriptor back to self-relative form. This creates a
            //  third security descriptor (the other two being the original
            //  and the absolute).
            //

            pNewSd = NULL;

            fRet = ConvertAbsoluteToSelfRelative(
                    &pNewSd,
                    pAbsoluteSd,
                    NULL
                    );

            if (fRet)
            {

                //
                //  The final conversion was successful. Free the original
                //  security descriptor. The absolute security descriptor is
                //  freed later. The only possible error from destroying the
                //  security descriptor is a version mismatch, but that would
                //  have happened long ago.
                //

                *ppSd = pNewSd;

                (VOID)DestroySecurityDescriptor(&pOriginalSd);
            }
            else
            {

                //
                //  The final conversion failed. At this point, the original
                //  security descriptor is still intact. Free the absolute
                //  security descriptor that was created earlier, and leave
                //  the passed in security descriptor pointer alone. Note that
                //  with the absolute security descriptor being freed later,
                //  there is nothing to do here.
                //

            }
        }

        //
        //  Regardless of success or failure, the absolute security descriptor
        //  was created, so it must be freed. The only possible error from destroying the
        //  security descriptor is a version mismatch, but that would
        //  have happened long ago.
        //

        (VOID)DestroySecurityDescriptor(&pAbsoluteSd);

    }
    else
    {

        //
        //  Regardless of what happened, there is nothing to do here. The
        //  original security descriptor was absolute; therefore no copies
        //  were made. The only data that changed was the Dacl, and whether
        //  or not that succeeded is irrelevant, as that was handled above.
        //

    }

    return(fRet);
}

BOOL WINAPI
ConvertAbsoluteToSelfRelative(
    PSECURITY_DESCRIPTOR *ppSelfRelativeSd,
    PSECURITY_DESCRIPTOR pAbsoluteSd,
    PDWORD pcbSelfRelativeSd
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtConvertAbsoluteToSelfRelative(
        ppSelfRelativeSd,
        pAbsoluteSd,
        pcbSelfRelativeSd
        );

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}

BOOL WINAPI
ConvertSelfRelativeToAbsolute(
    PSECURITY_DESCRIPTOR *ppAbsoluteSd,
    PSECURITY_DESCRIPTOR pSelfRelativeSd
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtConvertSelfRelativeToAbsolute(ppAbsoluteSd, pSelfRelativeSd);

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}

BOOL WINAPI
DestroySecurityDescriptor(
    PSECURITY_DESCRIPTOR *ppSd
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtDestroySecurityDescriptor(ppSd);

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}

BOOL WINAPI
IsSecurityDescriptorAbsolute(
    PSECURITY_DESCRIPTOR pSd
    )
{
    BOOLEAN fAbsolute;
    BOOL fRet;
    NTSTATUS Status;

    fAbsolute = FALSE;

    Status = NtIsSecurityDescriptorAbsolute(pSd, &fAbsolute);

    fRet = ((NT_SUCCESS(Status)) && fAbsolute);

    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsutil\misc.c ===
/*
 *  Misc.c
 *
 *  Author: BreenH
 *
 *  Miscellaneous utilities.
 */

/*
 *  Includes
 */

#include "precomp.h"

/*
 *  Function Implementations
 */

BOOL WINAPI
LoadStringResourceW(
    HMODULE hModule,
    UINT uiResourceId,
    PWSTR *ppString,
    PDWORD pcchString
    )
{
    BOOL fRet;
    INT iRet;
    PWSTR pROString;
    PWSTR pString;

    ASSERT(ppString != NULL);

    //
    //  Get a pointer to the string in memory. This string is the actual read-
    //  only memory into which the module is loaded. This string is not NULL
    //  terminated, so allocate a buffer and copy the exact number of bytes,
    //  then set the NULL terminator.
    //

    fRet = FALSE;
    pROString = NULL;

    iRet = LoadStringW(
            hModule,
            uiResourceId,
            (PWSTR)(&pROString),
            0
            );

    if (iRet > 0)
    {

        //
        //  For better performance, don't zero out the entire allocation just
        //  to copy the string. Zero out the last WCHAR to terminate the
        //  string.
        //

        pString = (PWSTR)LocalAlloc(LMEM_FIXED, (iRet + 1) * sizeof(WCHAR));

        if (pString != NULL)
        {
            RtlCopyMemory(pString, pROString, iRet * sizeof(WCHAR));

            pString[iRet] = (WCHAR)0;

            *ppString = pString;

            if (pcchString != NULL)
            {
                *pcchString = (DWORD)iRet;
            }

            fRet = TRUE;
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }
    }

    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsutil\string.c ===
/*
 *  String.c
 *
 *  Author: BreenH
 *
 *  String utilities.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutil.h"
#include "tsutilnt.h"

/*
 *  Function Implementations
 */

PSTR WINAPI
AllocateAndCopyStringA(
    PCSTR pString
    )
{
    NTSTATUS Status;
    PSTR pCopy;

    ASSERT(pString != NULL);

    pCopy = NULL;

    Status = NtAllocateAndCopyStringA(&pCopy, pString);

    if (NT_SUCCESS(Status))
    {
        return(pCopy);
    }
    else
    {
        SetLastError(RtlNtStatusToDosError(Status));
        return(NULL);
    }
}

PWSTR WINAPI
AllocateAndCopyStringW(
    PCWSTR pString
    )
{
    NTSTATUS Status;
    PWSTR pCopy;

    ASSERT(pString != NULL);

    pCopy = NULL;

    Status = NtAllocateAndCopyStringW(&pCopy, pString);

    if (NT_SUCCESS(Status))
    {
        return(pCopy);
    }
    else
    {
        SetLastError(RtlNtStatusToDosError(Status));
        return(NULL);
    }
}

BOOL WINAPI
ConvertAnsiToUnicode(
    PWSTR *ppUnicodeString,
    PCSTR pAnsiString
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtConvertAnsiToUnicode(ppUnicodeString, pAnsiString);

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}

BOOL WINAPI
ConvertUnicodeToAnsi(
    PSTR *ppAnsiString,
    PCWSTR pUnicodeString
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtConvertUnicodeToAnsi(ppAnsiString, pUnicodeString);

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsutil\precomp.h ===
/*
 *  Precomp.h
 *
 *  Author: BreenH
 *
 *  Precompiled header for TS Util.
 */

//
//  Remove warning 4514: unreferenced inline function has been removed.
//  This comes up due to the code being compiled at /W4, even though the
//  precompiled header is at /W3.
//

#pragma warning(disable: 4514)

//
//  Most SDK headers can't survive /W4.
//

#pragma warning(push, 3)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#include <aclapi.h>
#include <ntlsapi.h>

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsutil\lsa.c ===
/*
 *  Lsa.c
 *
 *  Author: BreenH
 *
 *  LSA utilities.
 */

/*
 *  Includes
 */

#include "precomp.h"

/*
 *  Function Implementations
 */

VOID NTAPI
InitLsaString(
    PLSA_UNICODE_STRING pLsaString,
    PCWSTR pString
    )
{
    ULONG cchString;

    //
    //  Unicode strings do not require NULL terminators. Length should relay
    //  the number of bytes in the string, with MaximumLength set to the
    //  number of bytes in the entire buffer.
    //

    if (pString != NULL)
    {
        cchString = lstrlenW(pString);
        pLsaString->Buffer = (PWSTR)pString;
        pLsaString->Length = (USHORT)(cchString * sizeof(WCHAR));
        pLsaString->MaximumLength = (USHORT)((cchString + 1) * sizeof(WCHAR));
    }
    else
    {
        pLsaString->Buffer = (PWSTR)NULL;
        pLsaString->Length = 0;
        pLsaString->MaximumLength = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsutil\aclnt.c ===
/*
 *  AclNt.c
 *
 *  Author: BreenH
 *
 *  Acl utilities in the NT flavor.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutilnt.h"

/*
 *  Function Implementations
 */

NTSTATUS NTAPI
NtConvertAbsoluteToSelfRelative(
    PSECURITY_DESCRIPTOR *ppSelfRelativeSd,
    PSECURITY_DESCRIPTOR pAbsoluteSd,
    PULONG pcbSelfRelativeSd
    )
{
#if DBG
    BOOLEAN fAbsoluteSd;
#endif
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR pSd;
    ULONG cbSd;

    ASSERT(ppSelfRelativeSd != NULL);
    ASSERT(pAbsoluteSd != NULL);
    ASSERT(NT_SUCCESS(NtIsSecurityDescriptorAbsolute(pAbsoluteSd,
            &fAbsoluteSd)));
    ASSERT(fAbsoluteSd);

    //
    //  Determine the buffer size needed to convert the security descriptor.
    //  Catch any exceptions due to an invalid descriptor.
    //

    cbSd = 0;

    __try
    {
        Status = RtlAbsoluteToSelfRelativeSD(
                pAbsoluteSd,
                NULL,
                &cbSd
                );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(STATUS_INVALID_SECURITY_DESCR);
    }

    //
    //  Allocate memory for the self-relative security descriptor.
    //

    pSd = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSd);

    if (pSd != NULL)
    {

        //
        //  Now convert the security descriptor using the allocated buffer.
        //  Catch any exceptions due to an invalid descriptor.
        //

        __try
        {
            Status = RtlAbsoluteToSelfRelativeSD(
                    pAbsoluteSd,
                    pSd,
                    &cbSd
                    );
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = STATUS_INVALID_SECURITY_DESCR;
        }

    }
    else
    {
        return(STATUS_NO_MEMORY);
    }

    if (NT_SUCCESS(Status))
    {

        //
        //  If the conversion succeeded, save the pointer to the security
        //  descriptor and return the size.
        //

        *ppSelfRelativeSd = pSd;

        if (pcbSelfRelativeSd != NULL)
        {
            *pcbSelfRelativeSd = cbSd;
        }
    }
    else
    {

        //
        //  If the conversion failed, free the memory and leave the input
        //  parameters alone.
        //

        LocalFree(pSd);
    }

    return(Status);
}

NTSTATUS NTAPI
NtConvertSelfRelativeToAbsolute(
    PSECURITY_DESCRIPTOR *ppAbsoluteSd,
    PSECURITY_DESCRIPTOR pSelfRelativeSd
    )
{
#if DBG
    BOOLEAN fAbsoluteSd;
#endif
    NTSTATUS Status;
    PACL pDacl;
    PACL pSacl;
    PSID pGroup;
    PSID pOwner;
    PSECURITY_DESCRIPTOR pSd;
    ULONG cbDacl;
    ULONG cbGroup;
    ULONG cbOwner;
    ULONG cbSacl;
    ULONG cbSd;

    ASSERT(ppAbsoluteSd != NULL);
    ASSERT(pSelfRelativeSd != NULL);
    ASSERT(NT_SUCCESS(NtIsSecurityDescriptorAbsolute(pSelfRelativeSd,
            &fAbsoluteSd)));
    ASSERT(!fAbsoluteSd);

    //
    //  Determine the size of each buffer needed to convert the security
    //  descriptor. Catch any exceptions due to an invalid descriptor.
    //

    cbDacl = 0;
    cbGroup = 0;
    cbOwner = 0;
    cbSacl = 0;
    cbSd = 0;

    __try
    {
        Status = RtlSelfRelativeToAbsoluteSD(
                pSelfRelativeSd,
                NULL, &cbSd,
                NULL, &cbDacl,
                NULL, &cbSacl,
                NULL, &cbOwner,
                NULL, &cbGroup
                );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(STATUS_INVALID_SECURITY_DESCR);
    }

    //
    //  Allocate memory for the security descriptor and its components.
    //

    pDacl = NULL;
    pGroup = NULL;
    pOwner = NULL;
    pSacl = NULL;

    if (cbDacl > 0)
    {
        pDacl = (PACL)LocalAlloc(LMEM_FIXED, cbDacl);

        if (pDacl == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto allocerror;
        }
    }

    if (cbGroup > 0)
    {
        pGroup = (PSID)LocalAlloc(LMEM_FIXED, cbGroup);

        if (pGroup == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto allocerror;
        }
    }

    if (cbOwner > 0)
    {
        pOwner = (PSID)LocalAlloc(LMEM_FIXED, cbOwner);

        if (pOwner == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto allocerror;
        }
    }

    if (cbSacl > 0)
    {
        pSacl = (PACL)LocalAlloc(LMEM_FIXED, cbSacl);

        if (pSacl == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto allocerror;
        }
    }

    ASSERT(cbSd > 0);

    pSd = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSd);

    if (pSd == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto allocerror;
    }

    //
    //  Now convert the security descriptor using the allocated buffer.
    //  Catch any exceptions due to an invalid descriptor.
    //

    __try
    {
        Status = RtlSelfRelativeToAbsoluteSD(
                pSelfRelativeSd,
                pSd, &cbSd,
                pDacl, &cbDacl,
                pSacl, &cbSacl,
                pOwner, &cbOwner,
                pGroup, &cbGroup
                );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INVALID_SECURITY_DESCR;
    }

    if (NT_SUCCESS(Status))
    {
        *ppAbsoluteSd = pSd;
        return(Status);
    }

    LocalFree(pSd);

allocerror:
    if (pSacl != NULL)
    {
        LocalFree(pSacl);
    }

    if (pOwner != NULL)
    {
        LocalFree(pOwner);
    }

    if (pGroup != NULL)
    {
        LocalFree(pGroup);
    }

    if (pDacl != NULL)
    {
        LocalFree(pDacl);
    }

    return(Status);
}

NTSTATUS NTAPI
NtDestroySecurityDescriptor(
    PSECURITY_DESCRIPTOR *ppSd
    )
{
    BOOLEAN fAbsolute;
    NTSTATUS Status;

    ASSERT(ppSd != NULL);
    ASSERT(*ppSd != NULL);

    Status = NtIsSecurityDescriptorAbsolute(*ppSd, &fAbsolute);

    if (NT_SUCCESS(Status))
    {
        if (fAbsolute)
        {
            PISECURITY_DESCRIPTOR pSd;
            PULONG_PTR pBeginning;
            PULONG_PTR pDacl;
            PULONG_PTR pEnd;
            PULONG_PTR pGroup;
            PULONG_PTR pOwner;
            PULONG_PTR pSacl;

            //
            //  An absolute security descriptor is much more complicated. The
            //  descriptor contains pointers to the other items (instead of
            //  offsets). This does not mean, however, that it is made up of
            //  more than one allocation. In fact, almost all absolute
            //  descriptors from the NT RTL are made of one allocation, with
            //  the internal pointers set to areas of memory inside the one
            //  allocation. This makes completely freeing a security
            //  descriptor a heinous effort. (As an aside, whats the point of
            //  creating an absolute security descriptor out of one chunk of
            //  memory? Just make it relative!)
            //
            //  Each component of the security descriptor may be NULL. For the
            //  Dacl and the Sacl, the f[D,S]aclPresent variable may be TRUE
            //  with a NULL [D,S]acl. Therefore, compare all pointers to NULL
            //  and against the security descriptor allocation before freeing.
            //
            //  The check to NtIsSecurityDescriptorAbsolute verifies that this
            //  is a valid security descriptor. Therefore it is safe to type
            //  cast here instead of making several RtlGetXSecurityDescriptor
            //  calls.
            //

            pSd = (PISECURITY_DESCRIPTOR)(*ppSd);

            pBeginning = (PULONG_PTR)(pSd);
            pEnd = (PULONG_PTR)((PBYTE)pBeginning + LocalSize(pSd));

            pDacl = (PULONG_PTR)(pSd->Dacl);
            pGroup = (PULONG_PTR)(pSd->Group);
            pOwner = (PULONG_PTR)(pSd->Owner);
            pSacl = (PULONG_PTR)(pSd->Sacl);

            //
            //  Handle the Dacl.
            //

            if (pDacl != NULL)
            {
                if ((pDacl > pEnd) || (pDacl < pBeginning))
                {
                    LocalFree(pDacl);
                }
            }

            //
            //  Handle the Group.
            //

            if (pGroup != NULL)
            {
                if ((pGroup > pEnd) || (pGroup < pBeginning))
                {
                    LocalFree(pGroup);
                }
            }

            //
            //  Handle the Owner.
            //

            if (pOwner != NULL)
            {
                if ((pOwner > pEnd) || (pOwner < pBeginning))
                {
                    LocalFree(pOwner);
                }
            }

            //
            //  Handle the Sacl.
            //

            if (pSacl != NULL)
            {
                if ((pSacl > pEnd) || (pSacl < pBeginning))
                {
                    LocalFree(pSacl);
                }
            }

        }
    }
    else
    {
        return(Status);
    }

    //
    //  If the security descriptor was absolute, the individual components
    //  have been freed, and now the security descriptor itself can be freed.
    //  If the security descriptor was self-relative, all the components are
    //  stored in the same block of memory, so free it all at once.
    //

    LocalFree(*ppSd);
    *ppSd = NULL;

    return(STATUS_SUCCESS);
}

NTSTATUS NTAPI
NtIsSecurityDescriptorAbsolute(
    PSECURITY_DESCRIPTOR pSd,
    PBOOLEAN pfAbsolute
    )
{
    NTSTATUS Status;
    ULONG ulRevision;
    SECURITY_DESCRIPTOR_CONTROL wSdControl;

    ASSERT(pSd != NULL);
    ASSERT(pfAbsolute != NULL);

    Status = RtlGetControlSecurityDescriptor(pSd, &wSdControl, &ulRevision);

    if (NT_SUCCESS(Status))
    {

        //
        //  Don't cast away the TRUE into a FALSE when dropping from a DWORD
        //  to a UCHAR.
        //

        *pfAbsolute = (BOOLEAN)((wSdControl & SE_SELF_RELATIVE) ? TRUE : FALSE);
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsutil\tsutil.c ===
/*
 *  TSUtil.c
 *
 *  Author: BreenH
 *
 *  Terminal Services utilities.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutil.h"

/*
 *  Function Implementations
 */

BOOL WINAPI
IsFullTerminalServicesEnabled(
    VOID
    )
{
    BOOL fRet;
    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wProductType = VER_NT_SERVER;
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    fRet = VerifyVersionInfo(
            &osVersionInfo,
            VER_PRODUCT_TYPE | VER_SUITENAME,
            dwlConditionMask
            );

    return(fRet);
}

BOOL WINAPI
IsPersonalTerminalServicesEnabled(
    VOID
    )
{
    BOOL fRet;
    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wProductType = VER_NT_WORKSTATION;
    osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    fRet = VerifyVersionInfo(
            &osVersionInfo,
            VER_PRODUCT_TYPE | VER_SUITENAME,
            dwlConditionMask
            );

    return(fRet);
}

BOOL WINAPI
IsTerminalServicesEnabled(
    VOID
    )
{
    BOOL fRet;
    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    fRet = VerifyVersionInfo(&osVersionInfo, VER_SUITENAME, dwlConditionMask);

    return(fRet);
}

BOOL WINAPI
IsPersonalWorkstation(
    VOID
    )
{
    BOOL fRet;
    DWORDLONG dwlConditionMask;
    OSVERSIONINFOEX osVersionInfo;

    RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wProductType = VER_NT_WORKSTATION;
    osVersionInfo.wSuiteMask = VER_SUITE_PERSONAL;

    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

    fRet = VerifyVersionInfo(
            &osVersionInfo,
            VER_PRODUCT_TYPE | VER_SUITENAME,
            dwlConditionMask
            );

    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsutil\stringnt.c ===
/*
 *  String.c
 *
 *  Author: BreenH
 *
 *  String utilities in the NT flavor.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutilnt.h"

/*
 *  Function Implementations
 */

NTSTATUS NTAPI
NtAllocateAndCopyStringA(
    PSTR *ppDestination,
    PCSTR pString
    )
{
    NTSTATUS Status;
    PSTR pCopy;
    ULONG cbString;

    ASSERT(ppDestination != NULL);

    cbString = (lstrlenA(pString) + 1) * sizeof(CHAR);

    pCopy = LocalAlloc(LMEM_FIXED, cbString);

    if (pCopy != NULL)
    {
        RtlCopyMemory(pCopy, pString, cbString);
        *ppDestination = pCopy;
        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = STATUS_NO_MEMORY;
    }

    return(Status);
}

NTSTATUS NTAPI
NtAllocateAndCopyStringW(
    PWSTR *ppDestination,
    PCWSTR pString
    )
{
    NTSTATUS Status;
    PWSTR pCopy;
    ULONG cbString;

    ASSERT(ppDestination != NULL);
    ASSERT(pString != NULL);

    cbString = (lstrlenW(pString) + 1) * sizeof(WCHAR);

    pCopy = LocalAlloc(LMEM_FIXED, cbString);

    if (pCopy != NULL)
    {
        RtlCopyMemory(pCopy, pString, cbString);
        *ppDestination = pCopy;
        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = STATUS_NO_MEMORY;
    }

    return(Status);
}

NTSTATUS NTAPI
NtConvertAnsiToUnicode(
    PWSTR *ppUnicodeString,
    PCSTR pAnsiString
    )
{
    NTSTATUS Status;
    PWSTR pUnicodeString;
    ULONG cbAnsiString;
    ULONG cbBytesWritten;
    ULONG cbUnicodeString;

    ASSERT(ppUnicodeString != NULL);
    ASSERT(pAnsiString != NULL);

    //
    //  Get the number of bytes in the ANSI string, then get the number of
    //  bytes needed for the Unicode version. None of the Rtl... APIs include
    //  the NULL terminator in their calculations.
    //

    cbAnsiString = lstrlenA(pAnsiString);

    Status = RtlMultiByteToUnicodeSize(
            &cbUnicodeString,
            (PCHAR)pAnsiString,
            cbAnsiString
            );

    if (Status == STATUS_SUCCESS)
    {

        //
        //  Allocate a buffer for the Unicode string and its NULL terminator,
        //  then convert the string.
        //

        cbUnicodeString += sizeof(WCHAR);

        pUnicodeString = (PWSTR)LocalAlloc(LPTR, cbUnicodeString);

        if (pUnicodeString != NULL)
        {
            Status = RtlMultiByteToUnicodeN(
                    pUnicodeString,
                    cbUnicodeString,
                    &cbBytesWritten,
                    (PCHAR)pAnsiString,
                    cbAnsiString
                    );

            if (Status == STATUS_SUCCESS)
            {
                *ppUnicodeString = pUnicodeString;
            }
            else
            {
                LocalFree(pUnicodeString);
            }
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }

    return(Status);
}

NTSTATUS NTAPI
NtConvertUnicodeToAnsi(
    PSTR *ppAnsiString,
    PCWSTR pUnicodeString
    )
{
    NTSTATUS Status;
    PSTR pAnsiString;
    ULONG cbAnsiString;
    ULONG cbBytesWritten;
    ULONG cbUnicodeString;

    ASSERT(ppAnsiString != NULL);
    ASSERT(pUnicodeString != NULL);

    //
    //  Get the number of bytes in the ANSI string, then get the number of
    //  bytes needed for the Unicode version. None of the Rtl... APIs include
    //  the NULL terminator in their calculations.
    //

    cbUnicodeString = lstrlenW(pUnicodeString) * sizeof(WCHAR);

    Status = RtlUnicodeToMultiByteSize(
            &cbAnsiString,
            (PWSTR)pUnicodeString,
            cbUnicodeString
            );

    if (Status == STATUS_SUCCESS)
    {

        //
        //  Allocate a buffer for the Unicode string and its NULL terminator,
        //  then convert the string.
        //

        cbAnsiString += sizeof(CHAR);

        pAnsiString = (PSTR)LocalAlloc(LPTR, cbAnsiString);

        if (pAnsiString != NULL)
        {
            Status = RtlUnicodeToMultiByteN(
                    pAnsiString,
                    cbAnsiString,
                    &cbBytesWritten,
                    (PWSTR)pUnicodeString,
                    cbUnicodeString
                    );

            if (Status == STATUS_SUCCESS)
            {
                *ppAnsiString = pAnsiString;
            }
            else
            {
                LocalFree(pAnsiString);
            }
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsutil\user.c ===
/*
 *  User.c
 *
 *  Author: BreenH
 *
 *  User account utilities.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutil.h"
#include "tsutilnt.h"

/*
 *  Function Implementations
 */

BOOL WINAPI
CreateAdminSid(
    PSID *ppAdminSid
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtCreateAdminSid(ppAdminSid);

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}

BOOL WINAPI
CreateSystemSid(
    PSID *ppSystemSid
    )
{
    BOOL fRet;
    NTSTATUS Status;

    Status = NtCreateSystemSid(ppSystemSid);

    if (NT_SUCCESS(Status))
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
        SetLastError(RtlNtStatusToDosError(Status));
    }

    return(fRet);
}

BOOL WINAPI
IsUserMember(
    PSID pSid
    )
{
    BOOL fMember;
    BOOL fRet;

    ASSERT(pSid != NULL);

    fMember = FALSE;

    fRet = CheckTokenMembership(NULL, pSid, &fMember);

    return(fRet && fMember);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\tsutil\usernt.c ===
/*
 *  UserNt.c
 *
 *  Author: BreenH
 *
 *  User account utilities in the NT flavor.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "tsutilnt.h"

/*
 *  Function Implementations
 */

NTSTATUS NTAPI
NtCreateAdminSid(
    PSID *ppAdminSid
    )
{
    NTSTATUS Status;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    ASSERT(ppAdminSid != NULL);

    Status = RtlAllocateAndInitializeSid(
            &SidAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &pSid
            );

    if (NT_SUCCESS(Status))
    {
        *ppAdminSid = pSid;
    }

    return(Status);
}

NTSTATUS NTAPI
NtCreateSystemSid(
    PSID *ppSystemSid
    )
{
    NTSTATUS Status;
    PSID pSid;
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;

    ASSERT(ppSystemSid != NULL);

    Status = RtlAllocateAndInitializeSid(
            &SidAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pSid
            );

    if (NT_SUCCESS(Status))
    {
        *ppSystemSid = pSid;
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\cecommon\cecommon.c ===
#include <windows.h>
#include <ceconfig.h>

PFN_CREATECURSOR g_pCreateCursor;
CE_CONFIG g_CEConfig;
BOOL g_CEUseScanCodes;     
BOOL UTREG_UI_DEDICATED_TERMINAL_DFLT;

void CEInitialize(void)
{
    // no need to free coredll.dll, it's used by bascially everything already.
    HINSTANCE hLib = LoadLibrary(L"coredll.dll");

    if (!hLib)
    {
        g_pCreateCursor = NULL;
        return;
    }

    g_pCreateCursor = (PFN_CREATECURSOR) GetProcAddress(hLib,L"CreateCursor");
}

CE_CONFIG CEGetConfigType(BOOL *CEUseScanCodes)
{
    HKEY hkey = 0;
    TCHAR szConfig[256];
    DWORD dwType;
    DWORD dwValue;
    DWORD dwSize = sizeof(szConfig);
    CE_CONFIG CEConfig;

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,UTREG_CE_CONFIG_KEY,
    								 0, KEY_ALL_ACCESS, &hkey))
    {
        if (CEUseScanCodes)
        {
            *CEUseScanCodes = UTREG_CE_USE_SCAN_CODES_DFLT;
        }
        return UTREG_CE_CONFIG_TYPE_DFLT;
    }  

    if (ERROR_SUCCESS != RegQueryValueEx(hkey,UTREG_CE_CONFIG_NAME, 0, &dwType, (LPBYTE)&szConfig,&dwSize))
    {
        CEConfig = UTREG_CE_CONFIG_TYPE_DFLT;
    }
    else if (0 == lstrcmpi(szConfig,TEXT("Maxall")))
    {
        CEConfig = CE_CONFIG_MAXALL;
    }
    else if (0 == lstrcmpi(szConfig,TEXT("Minshell")))
    {
        CEConfig = CE_CONFIG_MINSHELL;
    }
    else if (0 == lstrcmpi(szConfig,TEXT("Rapier")) || 0 == lstrcmpi(szConfig,TEXT("PalmSized")))
    {            
        CEConfig = CE_CONFIG_PALMSIZED;
    }
    else
    {
        CEConfig = UTREG_CE_CONFIG_TYPE_DFLT;
    }

    // CEUseScanCodes is optional and may be NULL
    if (CEUseScanCodes)
    {
        if (ERROR_SUCCESS != RegQueryValueEx(hkey,UTREG_CE_USE_SCAN_CODES, 0, &dwType, (LPBYTE)&dwValue, &dwSize))
        {                        
            // This keeps things the way they were by default in WBT and Cerburus project
            // if there is no overriding registry key.
            if (CEConfig == CE_CONFIG_WBT)
            {
                *CEUseScanCodes = 1;
            }
            else
            {
                *CEUseScanCodes = 0;
            }
        }
        else
        {
            *CEUseScanCodes = (dwValue ? 1 : 0);
        }            
    }

    if (hkey)
    	RegCloseKey(hkey);

    return CEConfig;        	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\cecommon\genguid.cpp ===
#ifdef OS_WINCE

#include "windows.h"
#include <winsock.h>
#include "ceconfig.h"

// extern "C" {
// The following four files are from the OS, but are needed here
// by the GUID-generation code, so they were copied over.
// Ick...
#include "tdiinfo.h"
#include "tdistat.h"
#include "llinfo.h"
#include "wscntl.h"

#define REGISTRY_ROOT                   TEXT("Software\\Microsoft\\Terminal Server Client")
#define REGISTRY_VALUE_UUID             TEXT("UUID")
#define ETHER_ADDRESS_LENGTH            6
#define DEFAULT_MINIMUM_ENTITIES        32
#define MAX_ADAPTER_DESCRIPTION_LENGTH  128
#define RPC_UUID_TIME_HIGH_MASK         0x0FFF
#define RPC_UUID_VERSION                0x1000
#define RPC_UUID_RESERVED               0x80
#define RPC_UUID_CLOCK_SEQ_HI_MASK      0x3F

typedef struct {
    unsigned long  ulTimeLow;
    unsigned short usTimeMid;
    unsigned short usTimeHiAndVersion;
    unsigned char  ucClockSeqHiAndReserved;
    unsigned char  ucClockSeqLow;
    unsigned char  ucNodeId[6];
} _UUID;

static unsigned int gs_seq = 0;
static LARGE_INTEGER gs_tm = {0};
static unsigned char gs_ucEtherAddr[ETHER_ADDRESS_LENGTH];
static int  gs_fIsAddressInitialized = FALSE;

static void GetAdapterAddress()
{
    if(!gs_fIsAddressInitialized) {
        memset (gs_ucEtherAddr, 0, sizeof(gs_ucEtherAddr));
        // Load WinSock.DLL so we can call into WsControl(...)
        HINSTANCE hInstWinSock = LoadLibrary(TEXT("winsock.dll"));
        if(0 != hInstWinSock) {
            DWORD(*fpfWsControl)(DWORD Protocol, DWORD Action, LPVOID InputBuffer, LPDWORD InputBufferLength, LPVOID OutputBuffer, LPDWORD OutputBufferLength);
            fpfWsControl = (DWORD(*)(DWORD Protocol, DWORD Action, LPVOID InputBuffer, LPDWORD InputBufferLength, LPVOID OutputBuffer, LPDWORD OutputBufferLength))GetProcAddress(hInstWinSock, TEXT("WsControl"));
            if(0 != fpfWsControl) {
                //  First, obtain list of TCP entities...
                TCP_REQUEST_QUERY_INFORMATION_EX req;
                memset(&req, 0, sizeof(req));
                req.ID.toi_entity.tei_entity = GENERIC_ENTITY;
                req.ID.toi_entity.tei_instance = 0;
                req.ID.toi_class = INFO_CLASS_GENERIC;
                req.ID.toi_type = INFO_TYPE_PROVIDER;
                req.ID.toi_id = ENTITY_LIST_ID;
                int iInputLen  = sizeof(req);
                int iOutputLen = sizeof(TDIEntityID) * DEFAULT_MINIMUM_ENTITIES;
                TDIEntityID *pEntity = NULL;
                for ( ; ; ) {
                    int iPrevOutputLen = iOutputLen;
                    pEntity = (TDIEntityID*)LocalAlloc(LPTR, (size_t)iOutputLen);
                    if (!pEntity)
                        break;
                    DWORD status = fpfWsControl(IPPROTO_TCP,
                                       WSCNTL_TCPIP_QUERY_INFO,
                                       (LPVOID)&req,
                                       (ULONG *)&iInputLen,
                                       (LPVOID)pEntity,
                                       (ULONG *)&iOutputLen
                                       );
                    if (status != TDI_SUCCESS) {
                        LocalFree(pEntity);
                        pEntity = NULL;
                        break;
                    }
                    if (iOutputLen <= iPrevOutputLen)
                        break;
                    LocalFree(pEntity);
                }
                if (0 != pEntity) {
                    int iCount = (UINT)(iOutputLen / sizeof(TDIEntityID));
                    //  Second, walk through these in search of adapters
                    TDIEntityID *pRunner = pEntity;
                    for (int i = 0; i < iCount; ++i, ++pRunner) {
                        // IF_ENTITY: this entity/instance describes an adapter
                        if (pRunner->tei_entity == IF_ENTITY) {
                            // find out if this entity supports MIB requests
                            memset(&req, 0, sizeof(req));
                            TDIObjectID id;
                            memset (&id, 0, sizeof(id));
                            id.toi_entity = *pRunner;
                            id.toi_class  = INFO_CLASS_GENERIC;
                            id.toi_type   = INFO_TYPE_PROVIDER;
                            id.toi_id     = ENTITY_TYPE_ID;
                            req.ID = id;
                            DWORD fIsMib = FALSE;
                            iInputLen  = sizeof(req);
                            iOutputLen = sizeof(fIsMib);
                            DWORD status = fpfWsControl(IPPROTO_TCP,
                                               WSCNTL_TCPIP_QUERY_INFO,
                                               (LPVOID)&req,
                                               (ULONG *)&iInputLen,
                                               (LPVOID)&fIsMib,
                                               (ULONG *)&iOutputLen
                                               );
                            if (status != TDI_SUCCESS)
                                break;
                            if (fIsMib != IF_MIB)
                                continue;
                            // MIB requests supported - query the adapter info
                            id.toi_class = INFO_CLASS_PROTOCOL;
                            id.toi_id = IF_MIB_STATS_ID;
                            memset(&req, 0, sizeof(req));
                            req.ID = id;
                            BYTE info[sizeof(IFEntry) + MAX_ADAPTER_DESCRIPTION_LENGTH + 1];
                            iInputLen  = sizeof(req);
                            iOutputLen = sizeof(info);
                            status = fpfWsControl(IPPROTO_TCP,
                                               WSCNTL_TCPIP_QUERY_INFO,
                                               (LPVOID)&req,
                                               (ULONG *)&iInputLen,
                                               (LPVOID)&info,
                                               (ULONG *)&iOutputLen
                                               );
                            if (status != TDI_SUCCESS)
                                break;
                            if (iOutputLen > sizeof(info))
                                continue;
                            IFEntry* pIfEntry = (IFEntry*)info;
                            memcpy (gs_ucEtherAddr, pIfEntry->if_physaddr, sizeof (gs_ucEtherAddr));
                            gs_fIsAddressInitialized = TRUE;
                            break;
                        }
                    }
                    LocalFree (pEntity);
                }
            }
            FreeLibrary(hInstWinSock);
        }
    }
}


BOOL generate_guid (GUID *guid) {
    GetAdapterAddress();  // It may fail, but gs_ucEtherAddr will still be all 0
    _UUID *p_uuid = (_UUID *)guid;
    SYSTEMTIME st;
    GetLocalTime(&st);
    LARGE_INTEGER tm2;
    SystemTimeToFileTime (&st, (FILETIME *)&tm2);
    if (gs_tm.QuadPart < tm2.QuadPart)
        gs_tm = tm2;
    else
        ++gs_tm.QuadPart;
    if (gs_tm.QuadPart > tm2.QuadPart + 1000)   { // Clock reset or super heavy usage
        gs_tm = tm2;
        ++gs_seq;
    }
    unsigned int uiLowPart  = gs_tm.LowPart;
    unsigned int uiHighPart = gs_tm.HighPart;
    unsigned int uiSeq      = gs_seq;
    p_uuid->ulTimeLow = (unsigned long)uiLowPart;
    p_uuid->usTimeMid = (unsigned short)(uiHighPart & 0x0000FFFF);
    p_uuid->usTimeHiAndVersion = (unsigned short)(( (unsigned short)(uiHighPart >> 16) & RPC_UUID_TIME_HIGH_MASK) | RPC_UUID_VERSION);
    p_uuid->ucClockSeqHiAndReserved = RPC_UUID_RESERVED | (((unsigned char) (uiSeq >> 8)) & (unsigned char) RPC_UUID_CLOCK_SEQ_HI_MASK);
    p_uuid->ucClockSeqLow = (unsigned char) (uiSeq & 0x00FF);
    p_uuid->ucNodeId[0] = gs_ucEtherAddr[0];
    p_uuid->ucNodeId[1] = gs_ucEtherAddr[1];
    p_uuid->ucNodeId[2] = gs_ucEtherAddr[2];
    p_uuid->ucNodeId[3] = gs_ucEtherAddr[3];
    p_uuid->ucNodeId[4] = gs_ucEtherAddr[4];
    p_uuid->ucNodeId[5] = gs_ucEtherAddr[5];
    return TRUE;
}

BOOL OEMGetUUID(GUID* pGuid)
{
    DWORD len;
    HKEY hKey;
    BOOL fRetVal = FALSE;

    len = sizeof(UUID);

    // Try to read the UUID from the registry - if we find one, use it
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_ROOT, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType;

        if ( ( RegQueryValueEx(hKey, REGISTRY_VALUE_UUID, 0, &dwType, 
                (BYTE*)pGuid, &len) == ERROR_SUCCESS) && (sizeof(UUID) == len) )
        {
            fRetVal = TRUE;
        }

        RegCloseKey(hKey);
    }

    if (!fRetVal)
    {
        // We didn't find a UUID in the registry, so we need to generate one now

        // First, try asking the hardware for a UUID...
        fRetVal = KernelIoControl(IOCTL_HAL_GET_UUID, NULL, 0, pGuid, len, &len);

        // If the hardware was unable to provide a UUID, generate one now.
        if (!fRetVal)
        {
            fRetVal = generate_guid(pGuid);
        }

        // Save the UUID (however we got it) in the registry so that we will always use this UUID
        if(fRetVal) {
            DWORD dwDisposition;
            BOOL fSavedKey = FALSE;
            if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_ROOT, 0, 0, 0, KEY_ALL_ACCESS, 0, &hKey, &dwDisposition) == ERROR_SUCCESS)
            {
                if (RegSetValueEx(hKey, REGISTRY_VALUE_UUID, 0, REG_BINARY, (BYTE*)pGuid, len) == ERROR_SUCCESS)
                {
                    fSavedKey = TRUE;
                }
                RegCloseKey(hKey);
            }
            // If we can't save the registry key, we have to return failure because we don't want to leak licenses
            fRetVal = fSavedKey;
        }
    }

    if (!fRetVal)
    {
        // We failed to generate a UUID.
        MessageBox(NULL, 
                   TEXT("Can't read or generate licensing information.  (Unable to generate a UUID or read one from the registry.)"), 
                   TEXT("Error"), MB_OK);

    }

    return fRetVal;
}

// }; // extern "C"

#endif // OS_WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\cecommon\autohide.cpp ===
#include <windows.h>
#include <ceconfig.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


// On non-WBT, we want to be able to hide and show the shell's taskbar.
// The two functions below were taken directly from the shell and are
// used to perform that task by WM_ACTIVATE in UIMainWndProc below.
// Only applies to non-WBT builds.

const TCHAR c_szShellAutoHide[] = TEXT("Software\\Microsoft\\Shell\\AutoHide");
void HHTaskBar_SetAutoHide(BOOL bAutoHide)
{
    LONG lRet;
    HKEY hkey;
    DWORD dw;
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szShellAutoHide, 0, KEY_ALL_ACCESS, &hkey);
    if(lRet != ERROR_SUCCESS) {
        lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szShellAutoHide, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hkey, &dw);
    }
    if (lRet == ERROR_SUCCESS) {
        RegSetValueEx(hkey, TEXT(""), 0, REG_DWORD, (LPBYTE)&bAutoHide, sizeof(DWORD));
        RegCloseKey(hkey);
    }
}

BOOL HHTaskBar_GetAutoHide(BOOL *pbAutoHide)
{
    HKEY hkey;
    DWORD dw = sizeof(*pbAutoHide);
    DWORD dwType;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szShellAutoHide, 0, KEY_ALL_ACCESS, &hkey)) {
        RegQueryValueEx(hkey, TEXT(""), 0, &dwType, (LPBYTE) pbAutoHide, &dw);
        RegCloseKey(hkey);
        return TRUE;
    }
    return FALSE;
}

// We want to hide the taskbar if it's not in AutoHide mode and we're
// being activated.  Because we may have two separate TSC connections
// active, we want to guard against problems that could result from            
// differing order of operations (like the taskbar being taken out of
// AutoHide mode when a TSC window is still in use).  In order to do
// that, we'll create a system-wide named Mutex that we'll use to
// indicate when we need to restore the taskbar's state.

const TCHAR psWinCEHPCTaskBarMutexName[] = TEXT("WinCEHPCTaskBarMutex");


// This function is called when the main window proc receives an WM_ACTIVATE 
// message.  wParam indicates if we're being minimized or maximized, hwnd
// is variable received from main window proc.

// BUGBUG - to make ActiveX control work we may need to expose/doc this function.
void AutoHideCE(HWND hwnd, WPARAM wParam)
{
    static HANDLE hWinCEHPCTaskBarMutex = 0;
    HWND hwndTaskBar;

    hwndTaskBar = FindWindow(TEXT("HHTaskBar"), NULL);
    if(0 != hwndTaskBar)
    {
        BOOL bActivating = LOWORD(wParam) != WA_INACTIVE;
        if(bActivating)
        {
            // Window is being displayed
            // Assume that the taskbar is not in AutoHide mode, then find
            // out what mode it IS in
#define WM_USER                     0x0400
#define WM_TASKBAR_FULLSCREEN       (WM_USER + 7)

#define SHFS_SHOWTASKBAR            0x0001					
#define SHFS_HIDETASKBAR            0x0002			

            // BUGBUG -- this has not been well tested/integrated on Palmsized.
            // Use at your own risk.
            if (g_CEConfig == CE_CONFIG_PALMSIZED)
            {

            	PostMessage(hwndTaskBar, 
            		WM_TASKBAR_FULLSCREEN, (WPARAM)hwnd, SHFS_HIDETASKBAR);
            }
            else
            {                    
                BOOL bAutoHide = FALSE;
                HHTaskBar_GetAutoHide(&bAutoHide);
                if(bAutoHide)
                {
                    // Auto-Hide is already active - see if that's because
                    // some other TSC window is responsible
                    hWinCEHPCTaskBarMutex = CreateMutex(0, FALSE, psWinCEHPCTaskBarMutexName);
                    if((0 != hWinCEHPCTaskBarMutex) && (ERROR_ALREADY_EXISTS != GetLastError()))
                    {
                        // We just created this Mutex, so Auto-Hide was
                        // enabled by the user.  Throw-away the Mutex we
                        // just created so we know that this TSC window
                        // didn't enable Auto-Hide.
                        CloseHandle(hWinCEHPCTaskBarMutex);
                        hWinCEHPCTaskBarMutex = 0;
                    }
                    else
                    {
                        // The Mutex was already present, so keep a handle on
                        // it as a reference-count
                    }
                }
                else
                {
                    // We're about to set Auto-Hide, so create the Mutex to
                    // tell other TSC windows that we've done so
                    hWinCEHPCTaskBarMutex = CreateMutex(0, FALSE, psWinCEHPCTaskBarMutexName);
                    if(0 != hWinCEHPCTaskBarMutex)
                        {
                        // Only hide the taskbar if we were able to indicate
                        // that we have done so
                        HHTaskBar_SetAutoHide(TRUE);
                        PostMessage(hwndTaskBar, WM_WININICHANGE, 0, 5000);
                        }
                }
                // If this or any other TSC window set Auto-Hide, then
                // (hWinCEHPCTaskBarMutex != 0) now
            }
        }
        else
        {
            // BUGBUG -- this has not been well tested/integrated on Palmsized devices.
            // Use at your own risk.
            if (g_CEConfig == CE_CONFIG_PALMSIZED)
            {
            	PostMessage(hwndTaskBar, 
            		WM_TASKBAR_FULLSCREEN, (WPARAM)hwnd, SHFS_SHOWTASKBAR);
            }	                
            // Window is being hiden
            if(0 != hWinCEHPCTaskBarMutex)
            {
                // Some TSC window set the taskbar into Auto-Hide mode
                // Discard our Mutex handle to drop the reference-count
                // and see if the Mutex stays around
                CloseHandle(hWinCEHPCTaskBarMutex);
                hWinCEHPCTaskBarMutex = CreateMutex(0, FALSE, psWinCEHPCTaskBarMutexName);
                if(0 != hWinCEHPCTaskBarMutex)
                {
                    if(ERROR_ALREADY_EXISTS == GetLastError())
                    {
                        // The Mutex was still present, so there is at
                        // least one other TSC window that's active.
                        // So we do nothing here.
                    }
                    else
                    {
                        // The Mutex went away after we closed our Mutex handle, so we are the last TSC window
                        // We need to restore the Auto-Hide setting (and we know it used to be FALSE because
                        // the Mutex was present)
                        HHTaskBar_SetAutoHide(FALSE);
                        PostMessage(hwndTaskBar, WM_WININICHANGE, 0, 5000);
                    }
                    // We didn't really want a handle to the Mutex, so
                    // discard it now.
                    CloseHandle(hWinCEHPCTaskBarMutex);
                }
            }
        else
            {
            // The Mutex was not present, so no TSC window set the
            // taskbar into Auto-Hide mode.  That means we don't need
            // to restore anything here.
            }
        }
    }
}

#ifdef __cplusplus
}
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\cecommon\genguid2.cpp ===
#ifdef OS_WINCE
// BUGBUG -- cleanup sources file in this dir a little (include wincecom.inc)

#include "windows.h"
#include <winsock.h>
// extern "C" {
// The following four files are from the OS, but are needed here
// by the GUID-generation code, so they were copied over.
// Ick...
#include "tdiinfo.h"
#include "tdistat.h"
#include "llinfo.h"
#include "wscntl.h"

#define REGISTRY_ROOT                   TEXT("Software\\Microsoft\\Terminal Server Client")
#define REGISTRY_VALUE_UUID             TEXT("UUID")
#define ETHER_ADDRESS_LENGTH            6
#define DEFAULT_MINIMUM_ENTITIES        32
#define MAX_ADAPTER_DESCRIPTION_LENGTH  128
#define RPC_UUID_TIME_HIGH_MASK         0x0FFF
#define RPC_UUID_VERSION                0x1000
#define RPC_UUID_RESERVED               0x80
#define RPC_UUID_CLOCK_SEQ_HI_MASK      0x3F

typedef struct {
    unsigned long  ulTimeLow;
    unsigned short usTimeMid;
    unsigned short usTimeHiAndVersion;
    unsigned char  ucClockSeqHiAndReserved;
    unsigned char  ucClockSeqLow;
    unsigned char  ucNodeId[6];
} _UUID;

static unsigned int gs_seq = 0;
static LARGE_INTEGER gs_tm = {0};
static unsigned char gs_ucEtherAddr[ETHER_ADDRESS_LENGTH];
static int  gs_fIsAddressInitialized = FALSE;

static void GetAdapterAddress()
{
    if(!gs_fIsAddressInitialized) {
        memset (gs_ucEtherAddr, 0, sizeof(gs_ucEtherAddr));
        // Load WinSock.DLL so we can call into WsControl(...)
        HINSTANCE hInstWinSock = LoadLibrary(TEXT("winsock.dll"));
        if(0 != hInstWinSock) {
            DWORD(*fpfWsControl)(DWORD Protocol, DWORD Action, LPVOID InputBuffer, LPDWORD InputBufferLength, LPVOID OutputBuffer, LPDWORD OutputBufferLength);
            fpfWsControl = (DWORD(*)(DWORD Protocol, DWORD Action, LPVOID InputBuffer, LPDWORD InputBufferLength, LPVOID OutputBuffer, LPDWORD OutputBufferLength))GetProcAddress(hInstWinSock, TEXT("WsControl"));
            if(0 != fpfWsControl) {
                //  First, obtain list of TCP entities...
                TCP_REQUEST_QUERY_INFORMATION_EX req;
                memset(&req, 0, sizeof(req));
                req.ID.toi_entity.tei_entity = GENERIC_ENTITY;
                req.ID.toi_entity.tei_instance = 0;
                req.ID.toi_class = INFO_CLASS_GENERIC;
                req.ID.toi_type = INFO_TYPE_PROVIDER;
                req.ID.toi_id = ENTITY_LIST_ID;
                int iInputLen  = sizeof(req);
                int iOutputLen = sizeof(TDIEntityID) * DEFAULT_MINIMUM_ENTITIES;
                TDIEntityID *pEntity = NULL;
                for ( ; ; ) {
                    int iPrevOutputLen = iOutputLen;
                    pEntity = (TDIEntityID*)LocalAlloc(LPTR, (size_t)iOutputLen);
                    if (!pEntity)
                        break;
                    DWORD status = fpfWsControl(IPPROTO_TCP,
                                       WSCNTL_TCPIP_QUERY_INFO,
                                       (LPVOID)&req,
                                       (ULONG *)&iInputLen,
                                       (LPVOID)pEntity,
                                       (ULONG *)&iOutputLen
                                       );
                    if (status != TDI_SUCCESS) {
                        LocalFree(pEntity);
                        pEntity = NULL;
                        break;
                    }
                    if (iOutputLen <= iPrevOutputLen)
                        break;
                    LocalFree(pEntity);
                }
                if (0 != pEntity) {
                    int iCount = (UINT)(iOutputLen / sizeof(TDIEntityID));
                    //  Second, walk through these in search of adapters
                    TDIEntityID *pRunner = pEntity;
                    for (int i = 0; i < iCount; ++i, ++pRunner) {
                        // IF_ENTITY: this entity/instance describes an adapter
                        if (pRunner->tei_entity == IF_ENTITY) {
                            // find out if this entity supports MIB requests
                            memset(&req, 0, sizeof(req));
                            TDIObjectID id;
                            memset (&id, 0, sizeof(id));
                            id.toi_entity = *pRunner;
                            id.toi_class  = INFO_CLASS_GENERIC;
                            id.toi_type   = INFO_TYPE_PROVIDER;
                            id.toi_id     = ENTITY_TYPE_ID;
                            req.ID = id;
                            DWORD fIsMib = FALSE;
                            iInputLen  = sizeof(req);
                            iOutputLen = sizeof(fIsMib);
                            DWORD status = fpfWsControl(IPPROTO_TCP,
                                               WSCNTL_TCPIP_QUERY_INFO,
                                               (LPVOID)&req,
                                               (ULONG *)&iInputLen,
                                               (LPVOID)&fIsMib,
                                               (ULONG *)&iOutputLen
                                               );
                            if (status != TDI_SUCCESS)
                                break;
                            if (fIsMib != IF_MIB)
                                continue;
                            // MIB requests supported - query the adapter info
                            id.toi_class = INFO_CLASS_PROTOCOL;
                            id.toi_id = IF_MIB_STATS_ID;
                            memset(&req, 0, sizeof(req));
                            req.ID = id;
                            BYTE info[sizeof(IFEntry) + MAX_ADAPTER_DESCRIPTION_LENGTH + 1];
                            iInputLen  = sizeof(req);
                            iOutputLen = sizeof(info);
                            status = fpfWsControl(IPPROTO_TCP,
                                               WSCNTL_TCPIP_QUERY_INFO,
                                               (LPVOID)&req,
                                               (ULONG *)&iInputLen,
                                               (LPVOID)&info,
                                               (ULONG *)&iOutputLen
                                               );
                            if (status != TDI_SUCCESS)
                                break;
                            if (iOutputLen > sizeof(info))
                                continue;
                            IFEntry* pIfEntry = (IFEntry*)info;
                            memcpy (gs_ucEtherAddr, pIfEntry->if_physaddr, sizeof (gs_ucEtherAddr));
                            gs_fIsAddressInitialized = TRUE;
                            break;
                        }
                    }
                    LocalFree (pEntity);
                }
            }
            FreeLibrary(hInstWinSock);
        }
    }
}


BOOL generate_guid (GUID *guid) {
    GetAdapterAddress();  // It may fail, but gs_ucEtherAddr will still be all 0
    _UUID *p_uuid = (_UUID *)guid;
    SYSTEMTIME st;
    GetLocalTime(&st);
    LARGE_INTEGER tm2;
    SystemTimeToFileTime (&st, (FILETIME *)&tm2);
    if (gs_tm.QuadPart < tm2.QuadPart)
        gs_tm = tm2;
    else
        ++gs_tm.QuadPart;
    if (gs_tm.QuadPart > tm2.QuadPart + 1000)   { // Clock reset or super heavy usage
        gs_tm = tm2;
        ++gs_seq;
    }
    unsigned int uiLowPart  = gs_tm.LowPart;
    unsigned int uiHighPart = gs_tm.HighPart;
    unsigned int uiSeq      = gs_seq;
    p_uuid->ulTimeLow = (unsigned long)uiLowPart;
    p_uuid->usTimeMid = (unsigned short)(uiHighPart & 0x0000FFFF);
    p_uuid->usTimeHiAndVersion = (unsigned short)(( (unsigned short)(uiHighPart >> 16) & RPC_UUID_TIME_HIGH_MASK) | RPC_UUID_VERSION);
    p_uuid->ucClockSeqHiAndReserved = RPC_UUID_RESERVED | (((unsigned char) (uiSeq >> 8)) & (unsigned char) RPC_UUID_CLOCK_SEQ_HI_MASK);
    p_uuid->ucClockSeqLow = (unsigned char) (uiSeq & 0x00FF);
    p_uuid->ucNodeId[0] = gs_ucEtherAddr[0];
    p_uuid->ucNodeId[1] = gs_ucEtherAddr[1];
    p_uuid->ucNodeId[2] = gs_ucEtherAddr[2];
    p_uuid->ucNodeId[3] = gs_ucEtherAddr[3];
    p_uuid->ucNodeId[4] = gs_ucEtherAddr[4];
    p_uuid->ucNodeId[5] = gs_ucEtherAddr[5];
    return TRUE;
}

BOOL OEMGetUUID(GUID* pGuid)
{
    DWORD len;
    HKEY hKey;
    BOOL fRetVal = FALSE;

    len = sizeof(UUID);

    // Try to read the UUID from the registry - if we find one, use it
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_ROOT, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwType;

        if ( ( RegQueryValueEx(hKey, REGISTRY_VALUE_UUID, 0, &dwType, 
                (BYTE*)pGuid, &len) == ERROR_SUCCESS) && (sizeof(UUID) == len) )
        {
            fRetVal = TRUE;
        }

        RegCloseKey(hKey);
    }

    if (!fRetVal)
    {
        // We didn't find a UUID in the registry, so we need to generate one now

        // First, try asking the hardware for a UUID...
        fRetVal = KernelIoControl(IOCTL_HAL_GET_UUID, NULL, 0, pGuid, len, &len);

        // If the hardware was unable to provide a UUID, generate one now.
        if (!fRetVal)
        {
            fRetVal = generate_guid(pGuid);
        }

        // Save the UUID (however we got it) in the registry so that we will always use this UUID
        if(fRetVal) {
            DWORD dwDisposition;
            BOOL fSavedKey = FALSE;
            if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_ROOT, 0, 0, 0, KEY_ALL_ACCESS, 0, &hKey, &dwDisposition) == ERROR_SUCCESS)
            {
                if (RegSetValueEx(hKey, REGISTRY_VALUE_UUID, 0, REG_BINARY, (BYTE*)pGuid, len) == ERROR_SUCCESS)
                {
                    fSavedKey = TRUE;
                }
                RegCloseKey(hKey);
            }
            // If we can't save the registry key, we have to return failure because we don't want to leak licenses
            fRetVal = fSavedKey;
        }
    }

    if (!fRetVal)
    {
        // We failed to generate a UUID.
        MessageBox(NULL, 
                   TEXT("Can't read or generate licensing information.  (Unable to generate a UUID or read one from the registry.)"), 
                   TEXT("Error"), MB_OK);

    }

    return fRetVal;
}

// }; // extern "C"

#endif // OS_WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\cecommon\llinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** LLINFO.H - Lower layer SNMP information definitions.
//
// This file contains all of the definitions for SNMP information collected
// by layers below IP.

#ifndef	LLINFO_INCLUDED
#define	LLINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


#define	IF_MIB_STATS_ID		1

#define	MAX_PHYSADDR_SIZE	8

typedef struct IPNetToMediaEntry {
	ulong			inme_index;
	ulong			inme_physaddrlen;
	uchar			inme_physaddr[MAX_PHYSADDR_SIZE];
	ulong			inme_addr;
	ulong			inme_type;
} IPNetToMediaEntry;

#define	INME_TYPE_OTHER			1
#define	INME_TYPE_INVALID		2
#define	INME_TYPE_DYNAMIC		3
#define	INME_TYPE_STATIC		4

#define	MAX_IFDESCR_LEN			256

#define	IFE_FIXED_SIZE	offsetof(struct IFEntry, if_descr)

typedef struct IFEntry {
	ulong			if_index;
	ulong			if_type;
	ulong			if_mtu;
	ulong			if_speed;
	ulong			if_physaddrlen;
	uchar			if_physaddr[MAX_PHYSADDR_SIZE];
	ulong			if_adminstatus;
	ulong			if_operstatus;
	ulong			if_lastchange;
	ulong			if_inoctets;
	ulong			if_inucastpkts;
	ulong			if_innucastpkts;
	ulong			if_indiscards;
	ulong			if_inerrors;
	ulong			if_inunknownprotos;
	ulong			if_outoctets;
	ulong			if_outucastpkts;
	ulong			if_outnucastpkts;
	ulong			if_outdiscards;
	ulong			if_outerrors;
	ulong			if_outqlen;
	ulong			if_descrlen;
	uchar			if_descr[1];
} IFEntry;

#define	IF_TYPE_OTHER	  	1
#define	IF_TYPE_ETHERNET	6
#define	IF_TYPE_TOKENRING	9
#define	IF_TYPE_FDDI		15
#define	IF_TYPE_PPP			23
#define	IF_TYPE_LOOPBACK	24
#define	IF_TYPE_SLIP		28

#define	IF_STATUS_UP		1
#define	IF_STATUS_DOWN		2
#define	IF_STATUS_TESTING	3


#endif // LLINFO_INCLUDED




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\cecommon\tdistat.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDISTAT.H - TDI status code definitions.
//
// This file contains the TDI status code definitions.

#ifndef NT

#define TDI_SUCCESS             0           // Success
#define TDI_NO_RESOURCES        1           // No resources.
#define TDI_ADDR_IN_USE         2           // Address already in use.
#define TDI_BAD_ADDR            3           // Address given is bad.
#define TDI_NO_FREE_ADDR        4           // No addresses available.
#define TDI_ADDR_INVALID        6           // Address object is invalid.
#define TDI_ADDR_DELETED        7           // Address object was deleted.
#define TDI_BUFFER_OVERFLOW     9           // Buffer overflowed.
#define TDI_BAD_EVENT_TYPE      10          // Bad event type.
#define TDI_BAD_OPTION          11          // Bad option or length.
#define TDI_CONN_REFUSED        14          // Connection was refused.
#define TDI_INVALID_CONNECTION  15          // Invalid connection.
#define TDI_ALREADY_ASSOCIATED  16          // Connection already associated.
#define TDI_NOT_ASSOCIATED      17          // Connection not associated.
#define TDI_CONNECTION_ACTIVE   18          // Connection is still active.
#define TDI_CONNECTION_ABORTED  19          // Connection was aborted.
#define TDI_CONNECTION_RESET    20          // Connection was reset.
#define TDI_TIMED_OUT           21          // Connection timed out.
#define TDI_GRACEFUL_DISC       22          // Received a graceful disconnect.
#define TDI_NOT_ACCEPTED        23          // Data not accepted.
#define TDI_MORE_PROCESSING     24          // More processing required.
#define TDI_INVALID_STATE       25          // TCB in an invalid state.
#define TDI_INVALID_PARAMETER   26          // An invalid parameter.
#define TDI_DEST_NET_UNREACH    27          // Destination net is unreachable.
#define TDI_DEST_HOST_UNREACH   28          // Dest. host is unreachable.
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   29          // Destination protocol is
                                            // unreachable.
#define TDI_DEST_PORT_UNREACH   30          // Dest. port is unreachable.
#define TDI_INVALID_QUERY       31          // Invalid query type specified.
#define TDI_REQ_ABORTED         32          // Request was aborted for some
                                            // reason.
#define TDI_BUFFER_TOO_SMALL    33          // Buffer was too small.
#define TDI_CANCELLED           34          // The request was cancelled.
#define	TDI_BUFFER_TOO_BIG		35			// Send buffer was too big.
#define TDI_INVALID_REQUEST     0xfe        // Invalid request.
#define TDI_PENDING             0xff        // Pending

#define TDI_LINK_BUSY           37          // IrLMP exclusive mode support
#define TDI_NET_DOWN            38
#define TDI_IN_PROGRESS         39
#else

//
// Map to NT STATUS codes.
//
#define TDI_SUCCESS             STATUS_SUCCESS
#define TDI_NO_RESOURCES        STATUS_INSUFFICIENT_RESOURCES
#define TDI_ADDR_IN_USE         STATUS_ADDRESS_ALREADY_EXISTS
#define TDI_BAD_ADDR            STATUS_INVALID_ADDRESS_COMPONENT
#define TDI_NO_FREE_ADDR        STATUS_TOO_MANY_ADDRESSES
#define TDI_ADDR_INVALID        STATUS_INVALID_ADDRESS
#define TDI_ADDR_DELETED        STATUS_ADDRESS_CLOSED
#define TDI_BUFFER_OVERFLOW     STATUS_BUFFER_OVERFLOW
#define TDI_BAD_EVENT_TYPE      STATUS_INVALID_PARAMETER
#define TDI_BAD_OPTION          STATUS_INVALID_PARAMETER
#define TDI_CONN_REFUSED        STATUS_CONNECTION_REFUSED
#define TDI_INVALID_CONNECTION  STATUS_CONNECTION_INVALID
#define TDI_ALREADY_ASSOCIATED  STATUS_ADDRESS_ALREADY_ASSOCIATED
#define TDI_NOT_ASSOCIATED      STATUS_ADDRESS_NOT_ASSOCIATED
#define TDI_CONNECTION_ACTIVE   STATUS_CONNECTION_ACTIVE
#define TDI_CONNECTION_ABORTED  STATUS_CONNECTION_ABORTED
#define TDI_CONNECTION_RESET    STATUS_CONNECTION_RESET
#define TDI_TIMED_OUT           STATUS_IO_TIMEOUT
#define TDI_GRACEFUL_DISC       STATUS_GRACEFUL_DISCONNECT
#define TDI_NOT_ACCEPTED        STATUS_DATA_NOT_ACCEPTED
#define TDI_MORE_PROCESSING     STATUS_MORE_PROCESSING_REQUIRED
#define TDI_INVALID_STATE       STATUS_INVALID_DEVICE_STATE
#define TDI_INVALID_PARAMETER   STATUS_INVALID_PARAMETER
#define TDI_DEST_NET_UNREACH    STATUS_NETWORK_UNREACHABLE
#define TDI_DEST_HOST_UNREACH   STATUS_HOST_UNREACHABLE
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   STATUS_PROTOCOL_UNREACHABLE
#define TDI_DEST_PORT_UNREACH   STATUS_PORT_UNREACHABLE
#define TDI_INVALID_QUERY       STATUS_INVALID_DEVICE_REQUEST
#define TDI_REQ_ABORTED         STATUS_REQUEST_ABORTED
#define TDI_BUFFER_TOO_SMALL    STATUS_BUFFER_TOO_SMALL
#define TDI_CANCELLED           STATUS_CANCELLED
#define	TDI_BUFFER_TOO_BIG		STATUS_INVALID_BUFFER_SIZE
#define TDI_INVALID_REQUEST     STATUS_INVALID_DEVICE_REQUEST
#define TDI_PENDING             STATUS_PENDING


#endif  // NT

#define	TDI_OPTION_EOL				0

#define	TDI_ADDRESS_OPTION_REUSE	1
#define	TDI_ADDRESS_OPTION_DHCP		2


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\inc\tdistat.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDISTAT.H - TDI status code definitions.
//
// This file contains the TDI status code definitions.

#ifndef NT

#define TDI_SUCCESS             0           // Success
#define TDI_NO_RESOURCES        1           // No resources.
#define TDI_ADDR_IN_USE         2           // Address already in use.
#define TDI_BAD_ADDR            3           // Address given is bad.
#define TDI_NO_FREE_ADDR        4           // No addresses available.
#define TDI_ADDR_INVALID        6           // Address object is invalid.
#define TDI_ADDR_DELETED        7           // Address object was deleted.
#define TDI_BUFFER_OVERFLOW     9           // Buffer overflowed.
#define TDI_BAD_EVENT_TYPE      10          // Bad event type.
#define TDI_BAD_OPTION          11          // Bad option or length.
#define TDI_CONN_REFUSED        14          // Connection was refused.
#define TDI_INVALID_CONNECTION  15          // Invalid connection.
#define TDI_ALREADY_ASSOCIATED  16          // Connection already associated.
#define TDI_NOT_ASSOCIATED      17          // Connection not associated.
#define TDI_CONNECTION_ACTIVE   18          // Connection is still active.
#define TDI_CONNECTION_ABORTED  19          // Connection was aborted.
#define TDI_CONNECTION_RESET    20          // Connection was reset.
#define TDI_TIMED_OUT           21          // Connection timed out.
#define TDI_GRACEFUL_DISC       22          // Received a graceful disconnect.
#define TDI_NOT_ACCEPTED        23          // Data not accepted.
#define TDI_MORE_PROCESSING     24          // More processing required.
#define TDI_INVALID_STATE       25          // TCB in an invalid state.
#define TDI_INVALID_PARAMETER   26          // An invalid parameter.
#define TDI_DEST_NET_UNREACH    27          // Destination net is unreachable.
#define TDI_DEST_HOST_UNREACH   28          // Dest. host is unreachable.
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   29          // Destination protocol is
                                            // unreachable.
#define TDI_DEST_PORT_UNREACH   30          // Dest. port is unreachable.
#define TDI_INVALID_QUERY       31          // Invalid query type specified.
#define TDI_REQ_ABORTED         32          // Request was aborted for some
                                            // reason.
#define TDI_BUFFER_TOO_SMALL    33          // Buffer was too small.
#define TDI_CANCELLED           34          // The request was cancelled.
#define	TDI_BUFFER_TOO_BIG		35			// Send buffer was too big.
#define TDI_INVALID_REQUEST     0xfe        // Invalid request.
#define TDI_PENDING             0xff        // Pending

#define TDI_LINK_BUSY           37          // IrLMP exclusive mode support
#define TDI_NET_DOWN            38
#define TDI_IN_PROGRESS         39
#else

//
// Map to NT STATUS codes.
//
#define TDI_SUCCESS             STATUS_SUCCESS
#define TDI_NO_RESOURCES        STATUS_INSUFFICIENT_RESOURCES
#define TDI_ADDR_IN_USE         STATUS_ADDRESS_ALREADY_EXISTS
#define TDI_BAD_ADDR            STATUS_INVALID_ADDRESS_COMPONENT
#define TDI_NO_FREE_ADDR        STATUS_TOO_MANY_ADDRESSES
#define TDI_ADDR_INVALID        STATUS_INVALID_ADDRESS
#define TDI_ADDR_DELETED        STATUS_ADDRESS_CLOSED
#define TDI_BUFFER_OVERFLOW     STATUS_BUFFER_OVERFLOW
#define TDI_BAD_EVENT_TYPE      STATUS_INVALID_PARAMETER
#define TDI_BAD_OPTION          STATUS_INVALID_PARAMETER
#define TDI_CONN_REFUSED        STATUS_CONNECTION_REFUSED
#define TDI_INVALID_CONNECTION  STATUS_CONNECTION_INVALID
#define TDI_ALREADY_ASSOCIATED  STATUS_ADDRESS_ALREADY_ASSOCIATED
#define TDI_NOT_ASSOCIATED      STATUS_ADDRESS_NOT_ASSOCIATED
#define TDI_CONNECTION_ACTIVE   STATUS_CONNECTION_ACTIVE
#define TDI_CONNECTION_ABORTED  STATUS_CONNECTION_ABORTED
#define TDI_CONNECTION_RESET    STATUS_CONNECTION_RESET
#define TDI_TIMED_OUT           STATUS_IO_TIMEOUT
#define TDI_GRACEFUL_DISC       STATUS_GRACEFUL_DISCONNECT
#define TDI_NOT_ACCEPTED        STATUS_DATA_NOT_ACCEPTED
#define TDI_MORE_PROCESSING     STATUS_MORE_PROCESSING_REQUIRED
#define TDI_INVALID_STATE       STATUS_INVALID_DEVICE_STATE
#define TDI_INVALID_PARAMETER   STATUS_INVALID_PARAMETER
#define TDI_DEST_NET_UNREACH    STATUS_NETWORK_UNREACHABLE
#define TDI_DEST_HOST_UNREACH   STATUS_HOST_UNREACHABLE
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   STATUS_PROTOCOL_UNREACHABLE
#define TDI_DEST_PORT_UNREACH   STATUS_PORT_UNREACHABLE
#define TDI_INVALID_QUERY       STATUS_INVALID_DEVICE_REQUEST
#define TDI_REQ_ABORTED         STATUS_REQUEST_ABORTED
#define TDI_BUFFER_TOO_SMALL    STATUS_BUFFER_TOO_SMALL
#define TDI_CANCELLED           STATUS_CANCELLED
#define	TDI_BUFFER_TOO_BIG		STATUS_INVALID_BUFFER_SIZE
#define TDI_INVALID_REQUEST     STATUS_INVALID_DEVICE_REQUEST
#define TDI_PENDING             STATUS_PENDING


#endif  // NT

#define	TDI_OPTION_EOL				0

#define	TDI_ADDRESS_OPTION_REUSE	1
#define	TDI_ADDRESS_OPTION_DHCP		2


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\cecommon\wscntl.h ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    wscntl.h

    Semi-public include file for the WsControl API in the Chicago/
    Snowball Windows Sockets implementation.


    FILE HISTORY:
        KeithMo     04-Feb-1994 Created.

*/


#ifndef _WSCNTL_H_
#define _WSCNTL_H_


//
//  Function prototypes.
//

DWORD
FAR PASCAL
WsControl(
    DWORD   Protocol,
    DWORD   Action,
    LPVOID  InputBuffer,
    LPDWORD InputBufferLength,
    LPVOID  OutputBuffer,
    LPDWORD OutputBufferLength
    );

typedef DWORD (FAR PASCAL * LPWSCONTROL)( DWORD   Protocol,
                                          DWORD   Action,
                                          LPVOID  InputBuffer,
                                          LPDWORD InputBufferLength,
                                          LPVOID  OutputBuffer,
                                          LPDWORD OutputBufferLength );


//
//  Ws Control action codes.
//

#define WSCNTL_TCPIP_QUERY_INFO             0x00000000
#define WSCNTL_TCPIP_SET_INFO               0x00000001
#define WSCNTL_TCPIP_ICMP_ECHO              0x00000002
#define WSCNTL_TCPIP_TEST                   0x00000003
#define WSCNTL_AFD_INFO						0x00000004
#define WSCNTL_AFD_GATHER_RAND              0x00000005


// For WSCNTL_AFD_INFO
// All selections must fit in the mask.
#define WSCNTL_AFD_INFO_MASK				0x0000ffff
#define	WSCNTL_AFD_INFO_LOCK				0x00000001
#define WSCNTL_AFD_INFO_SOCK				0x00000002
#define WSCNTL_AFD_INFO_CONN				0x00000004
#define WSCNTL_AFD_INFO_ENDP				0x00000008
#define WSCNTL_AFD_INFO_BUFFER				0x00000010
#define WSCNTL_AFD_IRDA_INFO				0x00000020
#define WSCNTL_AFD_CXPORT_INFO				0x00000040

// Option bits.
#define WSCNTL_AFD_INFO_VERBOSE				0x80000000


#endif  // _WSCNTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\cecommon\winhelp.cpp ===
#include <windows.h>
#include "ceconfig.h"

BOOL WinHelp(HWND hWndMain, LPCTSTR lpszHelp, UINT uCommand, DWORD dwData)
{
    PROCESS_INFORMATION pi;
    
    if (g_CEConfig != CE_CONFIG_WBT)
    {
    	// 1st try to load "html based" help file on non-WBT, if this fails
    	// load string into dialog box.	
        if(CreateProcess(TEXT("\\Windows\\PegHelp.exe"),
            TEXT("file:TermServClient.htm#Main_Contents"),
            0, 0, FALSE, 0, 0, 0, 0, &pi))
        {
        	return TRUE;
        }
    }

	// BUGBUG -- see other WinHelp comments for details here. (newclient\core\euint.cpp)
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\cecommon\tdiinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDIINFO.H - TDI Query/SetInfoEx definitons.
//
//	This file contains definitions for the extended TDI query and set info.
//	calls.
//

#ifndef TDI_INFO_INCLUDED
#define TDI_INFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


//* Structure of an entity ID.
typedef struct TDIEntityID {
	ulong		tei_entity;
	ulong		tei_instance;
} TDIEntityID;

//* Structure of an object ID.
typedef struct TDIObjectID {
	TDIEntityID	toi_entity;
	ulong		toi_class;
	ulong		toi_type;
	ulong		toi_id;
} TDIObjectID;

#define	MAX_TDI_ENTITIES			32

#define	INFO_CLASS_GENERIC			0x100
#define	INFO_CLASS_PROTOCOL			0x200
#define	INFO_CLASS_IMPLEMENTATION	0x300

#define	INFO_TYPE_PROVIDER			0x100
#define	INFO_TYPE_ADDRESS_OBJECT	0x200
#define	INFO_TYPE_CONNECTION		0x300

#define	ENTITY_LIST_ID				0

#define	GENERIC_ENTITY				0

#define	CO_TL_ENTITY				0x400
#define	CL_TL_ENTITY				0x401

#define	ER_ENTITY					0x380

#define	CO_NL_ENTITY				0x300
#define	CL_NL_ENTITY				0x301

#define	AT_ENTITY					0x280

#define	IF_ENTITY					0x200

#define	CONTEXT_SIZE				16


//* The following are IDs supported by all entities. They are of class
//	GENERIC and type PROVIDER.

#define	ENTITY_TYPE_ID				1			// The ID to get the entity
												// type. The return from this
												// type is an unsigned integer
												// (see below).


// Valid values to get back from entity type ID query.
#define	CO_TL_NBF					0x400		// Entity implements NBF prot.
#define	CO_TL_SPX					0x402		// Entity implements SPX prot.
#define	CO_TL_TCP					0x404		// Entity implements TCP prot.
#define	CO_TL_SPP					0x406		// Entity implements SPP prot.

#define	CL_TL_NBF					0x401		// CL NBF protocol.
#define	CL_TL_UDP					0x403		// Entity implements UDP.

#define	ER_ICMP						0x380		// The ICMP protocol.

#define	CL_NL_IPX					0x301		// Entity implements IPX.
#define	CL_NL_IP					0x303		// Entity implements IP.

#define	AT_ARP						0x280		// Entity implements ARP.
#define	AT_NULL						0x282		// Entity does no address
												// translation.

#define	IF_GENERIC					0x200		// Generic interface.
#define	IF_MIB						0x202		// Supports MIB-2 interface.


/*NOINC*/
//
// NT DeviceIoControl definitions for TdiExtendedInformationEx functions.
//

//
// QueryInformationEx IOCTL. The return buffer is passed as the OutputBuffer
// in the DeviceIoControl request. This structure is passed as the
// InputBuffer.
//
struct tcp_request_query_information_ex {
	TDIObjectID   ID;                     // object ID to query.
	uchar         Context[CONTEXT_SIZE];  // multi-request context. Zeroed
	                                      // for the first request.
};

typedef struct tcp_request_query_information_ex
        TCP_REQUEST_QUERY_INFORMATION_EX,
        *PTCP_REQUEST_QUERY_INFORMATION_EX;

//
// SetInformationEx IOCTL request structure. This structure is passed as the
// InputBuffer. The space allocated for the structure must be large enough
// to contain the structure and the set data buffer, which begins at the
// Buffer field. The OutputBuffer parameter in the DeviceIoControl is not used.
//
struct tcp_request_set_information_ex {
	TDIObjectID   ID;                // object ID to set.
	unsigned int  BufferSize;        // size of the set data buffer in bytes
	unsigned char Buffer[1];         // beginning of the set data buffer
};

typedef struct tcp_request_set_information_ex
               TCP_REQUEST_SET_INFORMATION_EX,
			   *PTCP_REQUEST_SET_INFORMATION_EX;


#endif // TDI_INFO_INCLUDED


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\inc\euiint.h ===
/**MOD+**********************************************************************/
/* Module:    euiint.h                                                      */
/*                                                                          */
/* Purpose:   WinCE specific ui functionality                               */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/

#define UI_HELP_TEXT_RESOURCE_MAX_LENGTH    1024 * 10

#define HELP_CONTEXT      0x0001L  /* Display topic in ulTopic */
#define HELP_CONTENTS     0x0003L
#define HELP_HELPONHELP   0x0004L  /* Display help on using help */
#define HELP_PARTIALKEY   0x0105L

DCVOID UIRegisterHelpClass(HINSTANCE hInstance);
BOOL WinHelp(HWND hWndMain, LPCTSTR lpszHelp, UINT uCommand, DWORD dwData);
BOOL    CALLBACK UIHelpDlgProc(HWND hwndDlg, UINT uMsg,
                                             WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\inc\wscntl.h ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    wscntl.h

    Semi-public include file for the WsControl API in the Chicago/
    Snowball Windows Sockets implementation.


    FILE HISTORY:
        KeithMo     04-Feb-1994 Created.

*/


#ifndef _WSCNTL_H_
#define _WSCNTL_H_


//
//  Function prototypes.
//

DWORD
FAR PASCAL
WsControl(
    DWORD   Protocol,
    DWORD   Action,
    LPVOID  InputBuffer,
    LPDWORD InputBufferLength,
    LPVOID  OutputBuffer,
    LPDWORD OutputBufferLength
    );

typedef DWORD (FAR PASCAL * LPWSCONTROL)( DWORD   Protocol,
                                          DWORD   Action,
                                          LPVOID  InputBuffer,
                                          LPDWORD InputBufferLength,
                                          LPVOID  OutputBuffer,
                                          LPDWORD OutputBufferLength );


//
//  Ws Control action codes.
//

#define WSCNTL_TCPIP_QUERY_INFO             0x00000000
#define WSCNTL_TCPIP_SET_INFO               0x00000001
#define WSCNTL_TCPIP_ICMP_ECHO              0x00000002
#define WSCNTL_TCPIP_TEST                   0x00000003
#define WSCNTL_AFD_INFO						0x00000004
#define WSCNTL_AFD_GATHER_RAND              0x00000005


// For WSCNTL_AFD_INFO
// All selections must fit in the mask.
#define WSCNTL_AFD_INFO_MASK				0x0000ffff
#define	WSCNTL_AFD_INFO_LOCK				0x00000001
#define WSCNTL_AFD_INFO_SOCK				0x00000002
#define WSCNTL_AFD_INFO_CONN				0x00000004
#define WSCNTL_AFD_INFO_ENDP				0x00000008
#define WSCNTL_AFD_INFO_BUFFER				0x00000010
#define WSCNTL_AFD_IRDA_INFO				0x00000020
#define WSCNTL_AFD_CXPORT_INFO				0x00000040

// Option bits.
#define WSCNTL_AFD_INFO_VERBOSE				0x80000000


#endif  // _WSCNTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\inc\rc4.h ===
#ifndef __RC4_H__
#define __RC4_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Key structure */
#if defined(_WIN64) && !defined(MIDL_PASS)
__declspec(align(8))
#endif
typedef struct RC4_KEYSTRUCT
{
  unsigned char S[256];     /* State table */
  unsigned char i,j;        /* Indices */
} RC4_KEYSTRUCT;

/* rc4_key()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *   Key        A KEYSTRUCT structure that will be initialized.
 *   dwLen      Size of the key, in bytes.
 *   pbKey      Pointer to the key.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4_key(struct RC4_KEYSTRUCT *pKS, unsigned int dwLen, unsigned char *pbKey);

/* rc4()
 *
 * Performs the actual encryption
 *
 * Parameters:
 *
 *   pKS        Pointer to the KEYSTRUCT created using rc4_key().
 *   dwLen      Size of buffer, in bytes.
 *   pbuf       Buffer to be encrypted.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4(struct RC4_KEYSTRUCT *pKS, unsigned int dwLen, unsigned char *pbuf);

#ifdef __cplusplus
}
#endif

#endif // __RC4_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\inc\llinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** LLINFO.H - Lower layer SNMP information definitions.
//
// This file contains all of the definitions for SNMP information collected
// by layers below IP.

#ifndef	LLINFO_INCLUDED
#define	LLINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


#define	IF_MIB_STATS_ID		1

#define	MAX_PHYSADDR_SIZE	8

typedef struct IPNetToMediaEntry {
	ulong			inme_index;
	ulong			inme_physaddrlen;
	uchar			inme_physaddr[MAX_PHYSADDR_SIZE];
	ulong			inme_addr;
	ulong			inme_type;
} IPNetToMediaEntry;

#define	INME_TYPE_OTHER			1
#define	INME_TYPE_INVALID		2
#define	INME_TYPE_DYNAMIC		3
#define	INME_TYPE_STATIC		4

#define	MAX_IFDESCR_LEN			256

#define	IFE_FIXED_SIZE	offsetof(struct IFEntry, if_descr)

typedef struct IFEntry {
	ulong			if_index;
	ulong			if_type;
	ulong			if_mtu;
	ulong			if_speed;
	ulong			if_physaddrlen;
	uchar			if_physaddr[MAX_PHYSADDR_SIZE];
	ulong			if_adminstatus;
	ulong			if_operstatus;
	ulong			if_lastchange;
	ulong			if_inoctets;
	ulong			if_inucastpkts;
	ulong			if_innucastpkts;
	ulong			if_indiscards;
	ulong			if_inerrors;
	ulong			if_inunknownprotos;
	ulong			if_outoctets;
	ulong			if_outucastpkts;
	ulong			if_outnucastpkts;
	ulong			if_outdiscards;
	ulong			if_outerrors;
	ulong			if_outqlen;
	ulong			if_descrlen;
	uchar			if_descr[1];
} IFEntry;

#define	IF_TYPE_OTHER	  	1
#define	IF_TYPE_ETHERNET	6
#define	IF_TYPE_TOKENRING	9
#define	IF_TYPE_FDDI		15
#define	IF_TYPE_PPP			23
#define	IF_TYPE_LOOPBACK	24
#define	IF_TYPE_SLIP		28

#define	IF_STATUS_UP		1
#define	IF_STATUS_DOWN		2
#define	IF_STATUS_TESTING	3


#endif // LLINFO_INCLUDED




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\inc\wsasync.h ===
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.
Copyright (c) 1995, 1996, 1997  Microsoft Corporation

Module Name:

winsock.h

Abstract:

Windows CE version of winsock.h.

Notes:


--*/

#ifndef _WSASYNC_H_
#define _WSASYNC_H_

#define WSAAPI __cdecl

#ifdef __cplusplus
extern "C" {
#endif

	

HANDLE WSAAPI WSAAsyncGetHostByName (HWND hWnd, unsigned int wMsg, const char FAR * name,	
							  char FAR * buf, int buflen);
int WSAAPI WSAAsyncSelect (SOCKET s, HWND hWnd, unsigned int wMsg, long lEvent);
int WSAAPI WSACancelAsyncRequest (HANDLE hAsyncTaskHandle);


#define MAXGETHOSTSTRUCT 1024
/*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
/*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTEVENT(lParam)           LOWORD(lParam)
/*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTERROR(lParam)           HIWORD(lParam)


#ifdef __cplusplus
}
#endif

#endif // _WSASYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\import.h ===
/*++

Copyright Microsoft Corporation. 1998

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/

#ifdef MIDL_PASS
#define WIN32_LEAN_AND_MEAN
#endif

//#ifndef _NTDEF_
//typedef LONG NTSTATUS, *PNTSTATUS;
//#endif

//typedef unsigned long   DWORD;
//typedef unsigned char   BYTE;

//#include <windows.h>
//#include <winnt.h>
//#include <ntdef.h>
//#include <ntseapi.h>
//#include <ntpsapi.h>
//#include <ntkeapi.h>

#ifdef MIDL_PASS
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
//#include <windef.h>
//#include <wtypes.h>
typedef unsigned long   DWORD;
typedef unsigned char   BYTE, *PBYTE;
#endif

#include <allproc.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define PSECURITY_DESCRIPTOR DWORD
#define BOOL        DWORD
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\inc\tdiinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDIINFO.H - TDI Query/SetInfoEx definitons.
//
//	This file contains definitions for the extended TDI query and set info.
//	calls.
//

#ifndef TDI_INFO_INCLUDED
#define TDI_INFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


//* Structure of an entity ID.
typedef struct TDIEntityID {
	ulong		tei_entity;
	ulong		tei_instance;
} TDIEntityID;

//* Structure of an object ID.
typedef struct TDIObjectID {
	TDIEntityID	toi_entity;
	ulong		toi_class;
	ulong		toi_type;
	ulong		toi_id;
} TDIObjectID;

#define	MAX_TDI_ENTITIES			32

#define	INFO_CLASS_GENERIC			0x100
#define	INFO_CLASS_PROTOCOL			0x200
#define	INFO_CLASS_IMPLEMENTATION	0x300

#define	INFO_TYPE_PROVIDER			0x100
#define	INFO_TYPE_ADDRESS_OBJECT	0x200
#define	INFO_TYPE_CONNECTION		0x300

#define	ENTITY_LIST_ID				0

#define	GENERIC_ENTITY				0

#define	CO_TL_ENTITY				0x400
#define	CL_TL_ENTITY				0x401

#define	ER_ENTITY					0x380

#define	CO_NL_ENTITY				0x300
#define	CL_NL_ENTITY				0x301

#define	AT_ENTITY					0x280

#define	IF_ENTITY					0x200

#define	CONTEXT_SIZE				16


//* The following are IDs supported by all entities. They are of class
//	GENERIC and type PROVIDER.

#define	ENTITY_TYPE_ID				1			// The ID to get the entity
												// type. The return from this
												// type is an unsigned integer
												// (see below).


// Valid values to get back from entity type ID query.
#define	CO_TL_NBF					0x400		// Entity implements NBF prot.
#define	CO_TL_SPX					0x402		// Entity implements SPX prot.
#define	CO_TL_TCP					0x404		// Entity implements TCP prot.
#define	CO_TL_SPP					0x406		// Entity implements SPP prot.

#define	CL_TL_NBF					0x401		// CL NBF protocol.
#define	CL_TL_UDP					0x403		// Entity implements UDP.

#define	ER_ICMP						0x380		// The ICMP protocol.

#define	CL_NL_IPX					0x301		// Entity implements IPX.
#define	CL_NL_IP					0x303		// Entity implements IP.

#define	AT_ARP						0x280		// Entity implements ARP.
#define	AT_NULL						0x282		// Entity does no address
												// translation.

#define	IF_GENERIC					0x200		// Generic interface.
#define	IF_MIB						0x202		// Supports MIB-2 interface.


/*NOINC*/
//
// NT DeviceIoControl definitions for TdiExtendedInformationEx functions.
//

//
// QueryInformationEx IOCTL. The return buffer is passed as the OutputBuffer
// in the DeviceIoControl request. This structure is passed as the
// InputBuffer.
//
struct tcp_request_query_information_ex {
	TDIObjectID   ID;                     // object ID to query.
	uchar         Context[CONTEXT_SIZE];  // multi-request context. Zeroed
	                                      // for the first request.
};

typedef struct tcp_request_query_information_ex
        TCP_REQUEST_QUERY_INFORMATION_EX,
        *PTCP_REQUEST_QUERY_INFORMATION_EX;

//
// SetInformationEx IOCTL request structure. This structure is passed as the
// InputBuffer. The space allocated for the structure must be large enough
// to contain the structure and the set data buffer, which begins at the
// Buffer field. The OutputBuffer parameter in the DeviceIoControl is not used.
//
struct tcp_request_set_information_ex {
	TDIObjectID   ID;                // object ID to set.
	unsigned int  BufferSize;        // size of the set data buffer in bytes
	unsigned char Buffer[1];         // beginning of the set data buffer
};

typedef struct tcp_request_set_information_ex
               TCP_REQUEST_SET_INFORMATION_EX,
			   *PTCP_REQUEST_SET_INFORMATION_EX;


#endif // TDI_INFO_INCLUDED


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\rpcwire.h ===
/***************************************************************************
*
*  RPCWIRE.H
*
*  This module contains structures passed over the wire between winsta.dll 
*  and icasrv.
*
*  Copyright Microsoft Corporation. 1998
*
****************************************************************************/

#ifndef __RPCWIRE_H__
#define __RPCWIRE_H__

#ifdef __cplusplus
extern "C" {
#endif

// Common structure for variable length data
typedef struct _VARDATA_WIRE {
    USHORT Size;
    USHORT Offset;
} VARDATA_WIRE, *PVARDATA_WIRE;

// Wire structure for WINSTATIONCONFIGW
// WinStationQuery/SetInfo ( WinStationConfiguration )
typedef struct _WINSTACONFIGWIREW {
    WCHAR Comment[WINSTATIONCOMMENT_LENGTH + 1];
    char OEMId[4];
    VARDATA_WIRE UserConfig;  // Embedded structure
    VARDATA_WIRE NewFields;   // For any new fields added after UserConfig
    // Variable length data follows - UserConfig and new fields added
} WINSTACONFIGWIREW, *PWINSTACONFIGWIREW;

// Wire structure for PDPARAMSW
// WinStationQueryInformation( WinStationPdParams )
typedef struct _PDPARAMSWIREW {
    SDCLASS SdClass;
    VARDATA_WIRE SdClassSpecific;  // Embedded union
    // Variable length PdClass specific data follows
} PDPARAMSWIREW, *PPDPARAMSWIREW;

// Wire structure for PDCONFIGW
// WinStationQueryInformation( WinStationPd)
typedef struct _PDCONFIGWIREW {
    VARDATA_WIRE PdConfig2W;  // Embedded structure
    PDPARAMSWIREW PdParams;   // Enbedded structure
    // Variable length data follows
} PDCONFIGWIREW, *PPDCONFIGWIREW;

// Wire structure for WLX_CLIENT_CREDENTIALS_V2_0
typedef struct _WLXCLIENTCREDWIREW {
    DWORD dwType;
    BOOL fDisconnectOnLogonFailure;
    BOOL fPromptForPassword;
    VARDATA_WIRE UserNameData;
    VARDATA_WIRE DomainData;
    VARDATA_WIRE PasswordData;
    // Variable data starts here
} WLXCLIENTCREDWIREW, *PWLXCLIENTCREDWIREW;

// common routines
VOID InitVarData(PVARDATA_WIRE pVarData, ULONG Size, ULONG Offset);
ULONG NextOffset(PVARDATA_WIRE PrevData);
ULONG CopySourceToDest(PCHAR SourceBuf, ULONG SourceSize,
                       PCHAR DestBuf, ULONG DestSize);
VOID CopyPdParamsToWire(PPDPARAMSWIREW PdParamsWire, PPDPARAMSW PdParams);
VOID CopyPdParamsFromWire(PPDPARAMSWIREW PdParamsWire, PPDPARAMSW PdParams);
VOID CopyPdConfigToWire(PPDCONFIGWIREW PdConfigWire, PPDCONFIGW PdConfig);
VOID CopyPdConfigFromWire(PPDCONFIGWIREW PdConfigWire, PPDCONFIGW PdConfig);
VOID CopyWinStaConfigToWire(PWINSTACONFIGWIREW WinStaConfigWire,
                            PWINSTATIONCONFIGW WinStaConfig);
VOID CopyWinStaConfigFromWire(PWINSTACONFIGWIREW WinStaConfigWire,
                              PWINSTATIONCONFIGW WinStaConfig);
BOOLEAN CopyInWireBuf(WINSTATIONINFOCLASS InfoClass,
                      PVOID UserBuf, PVOID WireBuf);
BOOLEAN CopyOutWireBuf(WINSTATIONINFOCLASS InfoClass,
                       PVOID UserBuf,PVOID WireBuf);
ULONG AllocateAndCopyCredToWire(PWLXCLIENTCREDWIREW *ppWire,
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCredentials);
BOOLEAN CopyCredFromWire(PWLXCLIENTCREDWIREW pWire,
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCredentials);

/*
 *  Licensing Core wire typedefs and function prototypes
 */

typedef struct {
    ULONG ulVersion;
    VARDATA_WIRE PolicyNameData;
    VARDATA_WIRE PolicyDescriptionData;
    //  Variable data begins here.
} LCPOLICYINFOWIRE_V1, *LPLCPOLICYINFOWIRE_V1;

ULONG
CopyPolicyInformationToWire(
    LPLCPOLICYINFOGENERIC *ppWire,
    LPLCPOLICYINFOGENERIC pPolicyInfo
    );

BOOLEAN
CopyPolicyInformationFromWire(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo,
    LPLCPOLICYINFOGENERIC pWire
    );

#ifdef __cplusplus
}
#endif

#endif  // __RPCWIRE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\client\lcrpc-c.c ===
#include <lcrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\client\icarpc.c ===
/****************************************************************************/
// icarpc.c
//
// winsta.dll RPC client code for interaction with termsrv.exe.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <winsta.h>
#include <icadd.h>

#include "rpcwire.h"


/****************************************************************************
 * ValidUserBuffer
 *
 *   This function verifies that the caller if WinStationQueryInformation/
 *   WinStationSetInformation has the correct structure size (i.e. client
 *   application built with the same header files as winsta.dll).
 *
 * ENTRY:
 *   BufferSize
 *     The size of the bufferr.
 *
 *   InfoClass
 *     The WinStationQuery/Set information class.
 *
 * EXIT:
 *     Retures TRUE if the buffer is valid, otherwise FALSE.
 ****************************************************************************/
BOOLEAN ValidUserBuffer(ULONG BufferSize, WINSTATIONINFOCLASS InfoClass)
{
    switch (InfoClass) {
        case WinStationLoadIndicator:
            return(BufferSize >= sizeof(WINSTATIONLOADINDICATORDATA));

        case WinStationCreateData:
            return(BufferSize == sizeof(WINSTATIONCREATEW));

        case WinStationConfiguration:
            return(BufferSize == sizeof(WINSTATIONCONFIGW));

        case WinStationPdParams:
            return(BufferSize == sizeof(PDPARAMSW));

        case WinStationWd:
            return(BufferSize == sizeof(WDCONFIGW));

        case WinStationPd:
            return(BufferSize == sizeof(PDCONFIGW));

        case WinStationPrinter:
            return(BufferSize == sizeof(WINSTATIONPRINTERW));

        case WinStationClient:
            return(BufferSize == sizeof(WINSTATIONCLIENTW));

        case WinStationModules:
            return(TRUE);

        case WinStationInformation:
            return(BufferSize == sizeof(WINSTATIONINFORMATIONW));

        case WinStationTrace:
            return(BufferSize == sizeof(ICA_TRACE));

        case WinStationBeep:
            return(BufferSize == sizeof(BEEPINPUT));

        case WinStationEncryptionOff:
        case WinStationEncryptionPerm:
        case WinStationNtSecurity:
            return(TRUE);

        case WinStationUserToken:
            return(BufferSize == sizeof(WINSTATIONUSERTOKEN));

        case WinStationVideoData:
        case WinStationInitialProgram:
        case WinStationCd:
        case WinStationSystemTrace:
        case WinStationVirtualData:
            return(TRUE); // Not Implemented - let server handle it

        case WinStationClientData:
            return(BufferSize >= sizeof(WINSTATIONCLIENTDATA));

        case WinStationLoadBalanceSessionTarget:
            return (BufferSize >= sizeof(ULONG));

        case WinStationShadowInfo:
            return(BufferSize == sizeof(WINSTATIONSHADOW));

        case WinStationDigProductId:
                        return(BufferSize >= sizeof(WINSTATIONPRODID));

        case WinStationLockedState:
             return(BufferSize >= sizeof(BOOL));

        case WinStationRemoteAddress:
            return(BufferSize >= sizeof(WINSTATIONREMOTEADDRESS));

        case WinStationLastReconnectType: 
            return(BufferSize >= sizeof(ULONG));       

        case WinStationDisallowAutoReconnect: 
            return(BufferSize >= sizeof(BOOLEAN));       

        case WinStationMprNotifyInfo: 
            return(BufferSize >= sizeof(ExtendedClientCredentials));

        default:
            return(FALSE);
    }
}


/****************************************************************************
 * CreateGenericWireBuf
 *
 *   This function creates a generic wire buffer for structures which may
 *   have new fields added to the end.
 *
 * ENTRY:
 *
 *   DataSize (input)
 *     The size of the structure.
 *   pBuffer (output)
 *     Pointer to the allocated buffer.
 *   pBufSize (output)
 *     Pointer to the wire buffer size.
 *
 * EXIT:
 *     Returns ERROR_SUCCESS if successful. If successful, pBuffer
 *     contains the generic wire buffer.
 ****************************************************************************/
ULONG CreateGenericWireBuf(ULONG DataSize, PVOID *ppBuffer, PULONG pBufSize)
{
    ULONG BufSize;
    PVARDATA_WIRE pVarData;

    BufSize = sizeof(VARDATA_WIRE) + DataSize;
    if ((pVarData = (PVARDATA_WIRE)LocalAlloc(0,BufSize)) == NULL)
        return(ERROR_NOT_ENOUGH_MEMORY);

    InitVarData(pVarData, DataSize, sizeof(VARDATA_WIRE));
    *ppBuffer = (PVOID) pVarData;
    *pBufSize = BufSize;
    return ERROR_SUCCESS;
}


/****************************************************************************
 * CheckUserBuffer
 *
 *   This function determines if the buffer type should be converted to a
 *   wire format. If so, a wire buffer is allocated.
 *
 * ENTRY:
 *   InfoClass (input)
 *     WinStationQuery/Set information class.
 *
 *   UserBuf(input)
 *     The client bufferr.
 *
 *   UserBufLen (input)
 *     The client buffer length.
 *
 *   ppWireBuf(output)
 *     Pointer to wirebuf pointer, updated with allocated wire buffer if
 *     BufAllocated is TRUE.
 *  pWireBufLen (output)
 *     Pointer to the length of the wire buffer allocated, updated if
 *     BufAllocated is TRUE.
 *  pBufAllocated (output)
 *     Pointer to flag indicating if a wire buffer was allocated.
 * EXIT:
 *     Returns ERROR_SUCCESS if successful. If successful, BufAllocated
 *     indicated whether a wire buffer was allocated.
 *     on failure, an error code is returned.
 ****************************************************************************/
ULONG CheckUserBuffer(
        WINSTATIONINFOCLASS InfoClass,
        PVOID UserBuf,
        ULONG UserBufLen,
        PVOID *ppWireBuf,
        PULONG pWireBufLen,
        BOOLEAN *pBufAllocated)
{
    ULONG BufSize;
    ULONG Error;
    PPDCONFIGWIREW PdConfigWire;
    PPDCONFIGW PdConfig;
    PPDPARAMSWIREW PdParamsWire;
    PPDPARAMSW PdParam;
    PWINSTACONFIGWIREW WinStaConfigWire;
    PWINSTATIONCONFIGW WinStaConfig;
    PVOID WireBuf;

    if (!ValidUserBuffer(UserBufLen, InfoClass)) {
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    switch (InfoClass) {
        case WinStationPd:
            BufSize = sizeof(PDCONFIGWIREW) + sizeof(PDCONFIG2W) + sizeof(PDPARAMSW);
            if ((WireBuf = (PCHAR)LocalAlloc(0,BufSize)) == NULL)
                return(ERROR_NOT_ENOUGH_MEMORY);

            PdConfigWire = (PPDCONFIGWIREW)WireBuf;
            InitVarData(&PdConfigWire->PdConfig2W,
                        sizeof(PDCONFIG2W),
                        sizeof(PDCONFIGWIREW));
            InitVarData(&PdConfigWire->PdParams.SdClassSpecific,
                        sizeof(PDPARAMSW) - sizeof(SDCLASS),
                        NextOffset(&PdConfigWire->PdConfig2W));
            break;
        case WinStationPdParams:
            BufSize = sizeof(PDPARAMSWIREW) + sizeof(PDPARAMSW);
            if ((WireBuf = (PCHAR)LocalAlloc(0,BufSize)) == NULL)
                return(ERROR_NOT_ENOUGH_MEMORY);

            PdParamsWire = (PPDPARAMSWIREW)WireBuf;
            InitVarData(&PdParamsWire->SdClassSpecific,
                        sizeof(PDPARAMSW),
                        sizeof(PDPARAMSWIREW));
            break;

        case WinStationConfiguration:
            BufSize = sizeof(WINSTACONFIGWIREW) + sizeof(USERCONFIGW);
            if ((WireBuf = (PCHAR)LocalAlloc(0,BufSize)) == NULL)
                return(ERROR_NOT_ENOUGH_MEMORY);

            WinStaConfigWire = (PWINSTACONFIGWIREW)WireBuf;
            InitVarData(&WinStaConfigWire->UserConfig,
                        sizeof(USERCONFIGW),
                        sizeof(WINSTACONFIGWIREW));
            InitVarData(&WinStaConfigWire->NewFields,
                        0,
                        NextOffset(&WinStaConfigWire->UserConfig));
            break;

        case WinStationInformation:
            if ((Error = CreateGenericWireBuf(sizeof(WINSTATIONINFORMATIONW),
                                              &WireBuf,
                                              &BufSize)) != ERROR_SUCCESS)
                return(Error);
            break;

        case WinStationWd:
            if ((Error = CreateGenericWireBuf(sizeof(WDCONFIGW),
                                              &WireBuf,
                                              &BufSize)) != ERROR_SUCCESS)
                return(Error);
            break;

         case WinStationClient:
            if ((Error = CreateGenericWireBuf(sizeof(WINSTATIONCLIENTW),
                                              &WireBuf,
                                              &BufSize)) != ERROR_SUCCESS)
                return(Error);
            break;
 
        default:
            *ppWireBuf = NULL;
            *pBufAllocated = FALSE;
            return ERROR_SUCCESS;
    }

    *pWireBufLen = BufSize;
    *ppWireBuf = WireBuf;
    *pBufAllocated = TRUE;
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\wince\wsasync\wsasync.c ===
#include "windows.h"
#include "types.h"
#include "winsock.h"
#include "wsasync.h"

#ifdef UNDER_CE
#include <ceconfig.h>
#endif

DWORD CopyHostEnt(PHOSTENT lpWinsockHostEnt, PHOSTENT lpHostEnt,
        LPDWORD lpdwHostEntBufferSize);

#define ProxyDbgAssert(x) ASSERT(x)
// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
// DWORD
// ROUND_UP_COUNT(
//     IN DWORD Count,
//     IN DWORD Pow2
//     );
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~((Pow2)-1)) )
#define ALIGN_DWORD             4

#ifdef DEBUG

DBGPARAM dpCurSettings = {
    TEXT("WSASYNC"), {
    TEXT("Init"),     TEXT("HostName"),TEXT("Undefined"),TEXT("Undefined"),
    TEXT("Recv"),TEXT("Send"),TEXT("Undefined"),TEXT("Undefined"),
    TEXT("Undefined"),TEXT("Undefined"),TEXT("Interface"),TEXT("Misc"),
    TEXT("Alloc"),    TEXT("Function"), TEXT("Warning"),  TEXT("Error") },
    0x0000c000
};

#define ZONE_INIT		DEBUGZONE(0)		// 0x0001
#define ZONE_HNAME		DEBUGZONE(1)		// 0x0002
//#define ZONE_???		DEBUGZONE(2)		// 0x0004
//#define ZONE_???		DEBUGZONE(3)		// 0x0008
#define ZONE_RECV		DEBUGZONE(4)		// 0x0010
#define ZONE_SEND		DEBUGZONE(5)		// 0x0020
#define ZONE_SELECT		DEBUGZONE(6)		// 0x0040
#define ZONE_CLOSE		DEBUGZONE(7)		// 0x0080
//#define ZONE_???		DEBUGZONE(8)		// 0x0100
#define ZONE_MSG		DEBUGZONE(9)		// 0x0200
#define ZONE_INTERFACE	DEBUGZONE(10)		// 0x0400
#define ZONE_MISC		DEBUGZONE(11)		// 0x0800
#define ZONE_ALLOC		DEBUGZONE(12)		// 0x1000
#define ZONE_FUNCTION	DEBUGZONE(13)		// 0x2000
#define ZONE_WARN		DEBUGZONE(14)		// 0x4000
#define ZONE_ERROR		DEBUGZONE(15)		// 0x8000

#endif


typedef struct GetNames {
	struct GetNames	*pNext;
	HANDLE			hThread;
	HWND			hWnd;
	uint			wMsg;
	char			*pBuf;
    DWORD           dwBufLen;
	char			*pName;
	DWORD			Status;
} GetNames;

GetNames			*v_pNameList;
CRITICAL_SECTION	v_NameListCS;
BOOL                v_fNameListInit = FALSE;

#define MAXALIASES		15		// We only support 5 aliases
#define AVG_HOST_LEN	40		// To calculate buff space
#define MAXADDRS		15		// Max of 5 IP addrs

typedef struct FULL_HOSTENT {
	HOSTENT	hostent;
	PSTR	host_aliases[MAXALIASES+1];
	char	hostbuf[(MAXALIASES+1)*AVG_HOST_LEN];
	PSTR	h_addr_ptrs[MAXADDRS + 1];
	uchar	hostaddr[MAXADDRS*4];
} FULL_HOSTENT;


GetNames **_FindName(HANDLE hThread) {
	GetNames	**ppName;

	ppName = &v_pNameList;
	while (*ppName && hThread != (*ppName)->hThread)
		ppName = &(*ppName)->pNext;

	return ppName;

}	// _FindName()

// HANDLE CreateThread(NULL, 0, Addr, pParam, NULL, ThreadId);
// BOOL PostMessage(hWnd, wMsg, wParam, lParam);


void CallGetHostByName(DWORD Name) {
	GetNames		**ppName, *pName = (GetNames *)Name;
	HOSTENT			*pHostent;
#if 0
	FULL_HOSTENT	*pFull;
	int				cLen, i;
	char			*p;
#endif
	DWORD			lParam;

	EnterCriticalSection(&v_NameListCS);
	// put it in list of pending items
	pName->pNext = v_pNameList;
	v_pNameList = pName;
	LeaveCriticalSection(&v_NameListCS);

	pHostent = gethostbyname(pName->pName);

	DEBUGMSG(ZONE_HNAME, (TEXT("gethostbyname returned %x\r\n"), pHostent));
	// take this task out of the pending items list
	EnterCriticalSection(&v_NameListCS);
	ppName = _FindName(pName->hThread);
	ASSERT(*ppName);
	ASSERT(*ppName == pName);
	*ppName = pName->pNext;
	pName->pNext = NULL;
	LeaveCriticalSection(&v_NameListCS);

	if (pName->Status != 0xffffffff) {
		if (pHostent) {
#if 0
			lParam = 0;
			pFull = (FULL_HOSTENT *)pName->pBuf;
			memcpy(pFull, pHostent, sizeof(FULL_HOSTENT));
			// now change the pointers to point to the correct places
			pFull->hostent.h_name = pFull->hostbuf;
			cLen = strlen(pFull->hostbuf) + 1;

			p = pFull->hostbuf + cLen;

			// do the aliases
			pFull->hostent.h_aliases = pFull->host_aliases;
			i = 0;
			while (pHostent->h_aliases[i]) {
				p += strlen(pHostent->h_aliases[i]) + 1;
				pFull->hostent.h_aliases[i++] = p;
			}
			// h_addrtype & h_length should have been copied with memcpy


			// do the h_addr_list
			pFull->hostent.h_addr_list = pFull->h_addr_ptrs;
            while(pHostent->h_addr_list[i]) {
                pFull->h_adddr_ptrs[i] =
            }

            p = pFull->hostaddr;
			i = 0;
			while (pHostent->h_addr_list[i]) {
				pFull->h_addr_ptrs[i] = p;
				(int *)p = *(int *)pHostent->h_addr_list[i++];
				p += 4;
			}
#endif
            lParam = CopyHostEnt(pHostent, (PHOSTENT)pName->pBuf,
                    &pName->dwBufLen);
			lParam <<= 16;
            lParam += pName->dwBufLen;
        } else {	// if (pHostent)
			// we must have some error condition
			lParam = GetLastError();
			lParam <<= 16;
    		lParam += sizeof(FULL_HOSTENT);
		}
		// BUGBUG: we don't retry on failure
		PostMessage(pName->hWnd, pName->wMsg, (WPARAM)pName->hThread, lParam);
	}	// if (pName->Status)

	LocalFree(pName->pName);
	LocalFree(pName);

}	// CallGetHostByName()


HANDLE WSAAsyncGetHostByName(HWND hWnd, unsigned wMsg, const char FAR *name,
							 char FAR * buf, int buflen) {
	HANDLE		hThread;
	DWORD		ThreadId;
	GetNames	*pName;
	DWORD		Status = 0;
    int         cc;

	if (buflen < sizeof(HOSTENT)) {
		Status = WSAENOBUFS;
	} else if (pName = LocalAlloc(LPTR, sizeof(*pName))) {
		pName->hWnd = hWnd;
		pName->wMsg = wMsg;
		pName->pBuf = buf;
        pName->dwBufLen = (DWORD)buflen;
        cc = strlen(name) + 1;
        if (pName->pName = LocalAlloc(LPTR, cc)) {
            memcpy(pName->pName, name, cc);
		    pName->Status = 0;
            if (!v_fNameListInit) {
		        InitializeCriticalSection(&v_NameListCS);
                v_fNameListInit = TRUE;
            }
		    EnterCriticalSection(&v_NameListCS);
		    pName->hThread = hThread = CreateThread(NULL, 0,
			    (LPTHREAD_START_ROUTINE)CallGetHostByName, pName, 0, &ThreadId);

		    LeaveCriticalSection(&v_NameListCS);
		    CloseHandle(hThread);
        } else {
            LocalFree(pName);
		    Status = WSAENOBUFS;
        }
	} else {
		Status = WSAENOBUFS;
	}

	if (Status) {
		SetLastError(Status);
		return (HANDLE)0;
	} else
		return (HANDLE)hThread;
}	// WSAASyncGetHostByName()


int WSACancelAsyncRequest (HANDLE hAsyncTaskHandle) {
	GetNames	**ppName;
	int			Status;

	EnterCriticalSection(&v_NameListCS);
	ppName = _FindName(hAsyncTaskHandle);
	if (*ppName) {
		(*ppName)->Status = 0xffffffff;
		LeaveCriticalSection(&v_NameListCS);
		Status = 0;
	} else {
		LeaveCriticalSection(&v_NameListCS);
		Status = SOCKET_ERROR;
		SetLastError(WSAEINVAL);
	}

	return Status;
}	// WSACancelAsyncRequest()


typedef int (*WSRecvFn)(SOCKET, char *, int, int);
typedef int (*WSSendFn)(SOCKET, const char *, int, int);
typedef int (*WSCloseFn)(SOCKET);

WSRecvFn v_pRecv;
WSSendFn v_pSend;
WSCloseFn v_pClose;
SOCKADDR_IN	SockAddr;

#ifndef IP_LOOPBACK
#define IP_LOOPBACK	0x100007f
#endif

static fd_set	ReadSet, WriteSet, ExcSet;
static int		v_fDone;
static SOCKET	v_Sock= INVALID_SOCKET;
static SOCKET	v_WakeSock;
static SOCKET	v_SendSock;
static int		v_SelEvents;
static int		v_Disabled;
static HWND		v_hWnd;
static int		v_wMsg;
static int		v_fAlready;	// implicitly set to FALSE

CRITICAL_SECTION	v_EventCS;

void SelectWorker(DWORD Sock);

int WSAAsyncSelect (SOCKET s, HWND hWnd, unsigned int wMsg, long lEvent) {
	static int		fInit = FALSE;
	HINSTANCE		hinst;
	HANDLE			hThread;
	DWORD			ThreadId;
	int				True = 1;
    int             len;

	if (! fInit) {
		fInit = TRUE;
		InitializeCriticalSection(&v_EventCS);
		if (hinst = LoadLibrary(TEXT("winsock.dll"))) {
			v_pRecv = (WSRecvFn)GetProcAddressW(hinst, TEXT("recv"));
			v_pSend = (WSSendFn)GetProcAddressW(hinst, TEXT("send"));
			v_pClose = (WSCloseFn)GetProcAddressW(hinst, TEXT("closesocket"));
			if (! (v_pRecv && v_pSend && v_pClose)) {
				DEBUGMSG(ZONE_WARN | ZONE_ERROR,
					(TEXT("Couldn't get ProcAddr of winsock recv/send\r\n")));
				SetLastError(WSAENOBUFS);
				return SOCKET_ERROR;
			}
		} else {
			DEBUGMSG(ZONE_WARN | ZONE_ERROR,
					(TEXT("Couldn't LoadLibrary winsock.dll\r\n")));
			SetLastError(WSAENOBUFS);
			return SOCKET_ERROR;
		}
		// now WakeSock and SendSock initialized at init time only
		v_WakeSock = socket(AF_INET, SOCK_DGRAM, 0);
		if (INVALID_SOCKET == v_WakeSock) {
			DEBUGMSG(ZONE_WARN|ZONE_ERROR,
				(TEXT("Can't create dgram socket\r\n")));
			SetLastError(WSAENOBUFS);
			return SOCKET_ERROR;
		}
		memset ((char *)&SockAddr, 0, sizeof(SockAddr));
		SockAddr.sin_family = AF_INET;
		SockAddr.sin_port = 0;
		SockAddr.sin_addr.S_un.S_addr = IP_LOOPBACK;
		if (SOCKET_ERROR == bind(v_WakeSock, (SOCKADDR *)&SockAddr,
			sizeof(SockAddr))) {
			DEBUGMSG(ZONE_WARN|ZONE_ERROR, (TEXT("Can't bind WakeSock\r\n")));
			return SOCKET_ERROR;
		}

		v_SendSock = socket(AF_INET, SOCK_DGRAM, 0);
		if (INVALID_SOCKET == v_SendSock) {
			DEBUGMSG(ZONE_WARN|ZONE_ERROR,
				(TEXT("Can't create send socket\r\n")));
			v_pClose(v_WakeSock);
			SetLastError(WSAENOBUFS);
			return SOCKET_ERROR;
		}
        len = sizeof(SockAddr);
	    getsockname (v_WakeSock, (SOCKADDR *)&SockAddr, &len);
		connect(v_SendSock, (SOCKADDR *)&SockAddr, sizeof(SockAddr));
	}	// if (! fInit)

	EnterCriticalSection(&v_EventCS);
	if (! lEvent) {
		v_fDone = TRUE;
		LeaveCriticalSection(&v_EventCS);
		return 0;
	}

	if (v_fAlready) {
		LeaveCriticalSection(&v_EventCS);
		return 0;
	} else {
		v_fAlready = TRUE;
		v_fDone = FALSE;
		v_hWnd = hWnd;
		v_wMsg = wMsg;
		v_SelEvents = lEvent;
		ASSERT(INVALID_SOCKET == v_Sock);
		v_Sock = s;
		v_Disabled = 0;
		LeaveCriticalSection(&v_EventCS);

		// set socket to non-blocking
		if (SOCKET_ERROR == ioctlsocket(s, FIONBIO, &True)) {
			DEBUGMSG(ZONE_WARN, (TEXT("ioctlsocket FIONBIO failed w/ %d\r\n"),
				GetLastError()));
		}

		hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)SelectWorker,
			(void *)s, 0, &ThreadId);
		CloseHandle(hThread);
	}
	return 0;
}

void SelectWorker(DWORD Sock) {
	SOCKET	s = (SOCKET) Sock;
	char	c;
	DWORD	lParam = 0;
	int		Status;
#ifdef OS_WINCE
	TIMEVAL tv = {0, 25000};
#endif // OS_WINCE
	

	while (2) {
		FD_ZERO(&ReadSet);
		FD_ZERO(&WriteSet);
		FD_ZERO(&ExcSet);
		if (INVALID_SOCKET != v_WakeSock) {
			FD_SET(v_WakeSock, &ReadSet);
		}
		EnterCriticalSection(&v_EventCS);
		if (v_fDone) {	// do this here b/c of CS
			v_fAlready = FALSE;
			// LeaveCriticalSection(&v_EventCS);
			break;
		}

		if (v_SelEvents & ~v_Disabled & (FD_WRITE | FD_CONNECT)) {
			FD_SET(s, &WriteSet);
			DEBUGMSG(ZONE_MSG, (TEXT("W\r\n")));
		}
		if (v_SelEvents & ~v_Disabled & FD_READ) {
			FD_SET(s, &ReadSet);
			DEBUGMSG(ZONE_MSG, (TEXT("R\r\n")));
		}
		//FD_SET(s, &ExcSet);

		LeaveCriticalSection(&v_EventCS);
		DEBUGMSG(ZONE_SELECT, (TEXT("calling select\r\n")));

#ifdef OS_WINCE
		/* When select(...) is called with a NULL timeval parameter,
		   it does not return after closesocket(...) is called on
		   that socket.  To work around that behavior, use a time-
		   out on the call to select(...) (and take advantage of
		   the while(2) wrapping this code-block. */

        // This was only made for HPCs, WBT was always fine using the old way,
        // so we're going to keep it the same.        
        if (g_CEConfig != CE_CONFIG_WBT)
        {
    		Status = select(0, &ReadSet, &WriteSet, NULL, &tv);
        }
        else
        {
    		Status = select(0, &ReadSet, &WriteSet, NULL, NULL);
        }
#else // OS_WINCE
		Status = select(0, &ReadSet, &WriteSet, NULL, NULL);
#endif // OS_WINCE

		

		if (SOCKET_ERROR == Status) {
			//v_fDone = TRUE;
			Status = GetLastError();
			DEBUGMSG(ZONE_WARN|ZONE_SELECT,
				(TEXT("Select returned error: %d \r\n"), Status));
		} else {
			if (FD_ISSET(v_WakeSock, &ReadSet)) {
				v_pRecv(v_WakeSock, &c, 1, 0);
			}
			EnterCriticalSection(&v_EventCS);

			if (FD_ISSET(s, &WriteSet)) {
				// we need to report connect events only once
				if (v_SelEvents & ~v_Disabled & FD_CONNECT) {
					v_Disabled |= FD_CONNECT;
					lParam = FD_CONNECT;
					DEBUGMSG(ZONE_MSG, (TEXT("p-C\r\n")));
					PostMessage(v_hWnd, v_wMsg, (WPARAM)s, lParam);
				}
				if (v_SelEvents & ~v_Disabled & FD_WRITE) {
					v_Disabled |= FD_WRITE;
					lParam = FD_WRITE;
					DEBUGMSG(ZONE_MSG, (TEXT("p-W\r\n")));
					PostMessage(v_hWnd, v_wMsg, (WPARAM)s, lParam);
				}
			}
			if (FD_ISSET(s, &ReadSet)) {
				v_Disabled |= FD_READ;
				lParam = FD_READ;
				DEBUGMSG(ZONE_MSG, (TEXT("p-R\r\n")));
				PostMessage(v_hWnd, v_wMsg, (WPARAM)s, lParam);
			}
			if (FD_ISSET(s, &ExcSet)) {
				DEBUGMSG(ZONE_WARN, (TEXT("Selects ExcSet is set!!\r\n")));
			}
			LeaveCriticalSection(&v_EventCS);
		}	// else SOCKET_ERROR == Status
	}
	// note we have the CS here!!!
	v_Sock = INVALID_SOCKET;
	v_hWnd = NULL;
	LeaveCriticalSection(&v_EventCS);

	return;

}	// SelectWorker()


int recv(SOCKET s, char *buf, int len, int flags) {
	char	c = (char)7;
	int		Status;

	DEBUGMSG(ZONE_RECV, (TEXT("+recv\r\n")));
	Status = v_pRecv(s, buf, len, flags);

	EnterCriticalSection(&v_EventCS);
	if (v_Sock != INVALID_SOCKET && v_Sock == s) {
		// BUGBUG: should we check for errors as well?
		if (! Status) {	// recv'd 0 bytes
			DEBUGMSG(ZONE_MSG, (TEXT("p-Close\r\n")));
			PostMessage(v_hWnd, v_wMsg, (WPARAM)s, FD_CLOSE);
			// after this we don't want to re-enable FD_READ's
		} else if (v_Disabled & FD_READ) {
			v_Disabled &= ~FD_READ;
			v_pSend(v_SendSock, &c, 1, 0);
		}
	}
	LeaveCriticalSection(&v_EventCS);

	DEBUGMSG(ZONE_RECV, (TEXT("-recv\r\n")));
	return Status;

}	// recv

int send(SOCKET s, const char *buf, int len, int flags) {
	char	c = (char)8;
	int		Status;

	DEBUGMSG(ZONE_SEND, (TEXT("+send\r\n")));
	Status = v_pSend(s, buf, len, flags);

	EnterCriticalSection(&v_EventCS);
	if (v_Sock != INVALID_SOCKET && v_Sock == s) {
		// BUGBUG: should we check for errors??
		if (v_Disabled & FD_WRITE) {
			v_Disabled &= ~FD_WRITE;
			v_pSend(v_SendSock, &c, 1, 0);
		}
	}
	LeaveCriticalSection(&v_EventCS);

	DEBUGMSG(ZONE_SEND, (TEXT("-send\r\n")));
	return Status;

}	// send()

int closesocket(SOCKET s) {
	int	Status;

	DEBUGMSG(ZONE_CLOSE, (TEXT("+close\r\n")));
	Status = v_pClose(s);

	EnterCriticalSection(&v_EventCS);
	if (v_Sock != INVALID_SOCKET && v_Sock == s) {
		v_fDone = TRUE;
	}
	LeaveCriticalSection(&v_EventCS);

	DEBUGMSG(ZONE_CLOSE, (TEXT("-close\r\n")));
	return Status;
}	// closesocket()


BOOL __stdcall
dllentry (
    HANDLE  hinstDLL,
    DWORD   Op,
    LPVOID  lpvReserved
    )
{
	switch (Op) {
	case DLL_PROCESS_ATTACH :
		DEBUGREGISTER(hinstDLL);
		DEBUGMSG (ZONE_INIT, (TEXT(" CXPORT:dllentry ProcessAttach\r\n")));
		break;
	case DLL_PROCESS_DETACH :
		break;
	default :
		break;
	}
	return TRUE;
}

DWORD
CopyHostEnt(
    PHOSTENT lpWinsockHostEnt,
    PHOSTENT lpHostEnt,
    LPDWORD lpdwHostEntBufferSize
    )
/*++

Arguments:

Return Value:

    Windows Error Code.

--*/
{
    DWORD dwSize;
    LPSTR *lpAliasNames;
    LPSTR *lpDestAliasNames;
    LPSTR *lpAddrList;
    LPSTR *lpDestAddrList;
    LPBYTE lpNextVariable;
    LPBYTE lpEndBuffer;
    DWORD dwNumAliasNames = 0;
    DWORD dwNumAddresses = 0;
    DWORD dwDnsNameLen;

    //
    // compute the size required.
    //

    dwSize = sizeof(HOSTENT);

    dwDnsNameLen =
        ROUND_UP_COUNT(
            (strlen(lpWinsockHostEnt->h_name) + sizeof(CHAR)),
            ALIGN_DWORD );

    dwSize += dwDnsNameLen;

    lpAliasNames = lpWinsockHostEnt->h_aliases;
    while( *lpAliasNames != NULL ) {

        dwSize += ROUND_UP_COUNT(
            (strlen(*lpAliasNames) + sizeof(CHAR)),
            ALIGN_DWORD );

        dwSize += sizeof(LPSTR);
        dwNumAliasNames++;
        lpAliasNames++;
    }

    dwSize += sizeof(LPSTR);

    lpAddrList = lpWinsockHostEnt->h_addr_list;

    while( *lpAddrList != NULL ) {
        dwSize += sizeof(DWORD);
        dwSize += sizeof(LPSTR);
        dwNumAddresses++;
        lpAddrList++;
    }

    dwSize += sizeof(LPSTR);

    if( dwSize > *lpdwHostEntBufferSize ) {
        *lpdwHostEntBufferSize = dwSize;
        return( WSAENOBUFS );
    }

    //
    // copy data.
    //

    lpNextVariable =  (LPBYTE)lpHostEnt + sizeof(HOSTENT);
    lpEndBuffer = (LPBYTE)lpHostEnt + dwSize;

    //
    // copy fixed part.
    //

    lpHostEnt->h_addrtype = lpWinsockHostEnt->h_addrtype;
    lpHostEnt->h_length = lpWinsockHostEnt->h_length;

    //
    // copy variable parts.
    //

    lpHostEnt->h_name = (LPSTR)lpNextVariable;

    strcpy( lpHostEnt->h_name, lpWinsockHostEnt->h_name );

    lpNextVariable += dwDnsNameLen;
    ProxyDbgAssert( lpNextVariable < lpEndBuffer);


    lpHostEnt->h_aliases = (LPSTR *)lpNextVariable;
    lpNextVariable += (dwNumAliasNames + 1) * sizeof(LPSTR);
    ProxyDbgAssert( lpNextVariable < lpEndBuffer);

    lpAliasNames = lpWinsockHostEnt->h_aliases;
    lpDestAliasNames = lpHostEnt->h_aliases;

    while( *lpAliasNames != NULL ) {

        *lpDestAliasNames = (LPSTR)lpNextVariable;
        strcpy( *lpDestAliasNames, *lpAliasNames );

        lpNextVariable += ROUND_UP_COUNT(
            (strlen(*lpAliasNames) + sizeof(CHAR)),
            ALIGN_DWORD );

        ProxyDbgAssert( lpNextVariable < lpEndBuffer);

        lpDestAliasNames++;
        lpAliasNames++;
    }

    *lpDestAliasNames = NULL;

    lpHostEnt->h_addr_list = (LPSTR *)lpNextVariable;
    lpNextVariable += (dwNumAddresses + 1) * sizeof(LPSTR);
    ProxyDbgAssert( lpNextVariable < lpEndBuffer);

    lpAddrList = lpWinsockHostEnt->h_addr_list;
    lpDestAddrList = lpHostEnt->h_addr_list;

    while( *lpAddrList != NULL ) {

        *lpDestAddrList = (LPSTR)lpNextVariable;
        *(LPDWORD)(*lpDestAddrList) = *(LPDWORD)(*lpAddrList);

        lpNextVariable += sizeof(DWORD);
        ProxyDbgAssert( lpNextVariable <= lpEndBuffer);

        lpDestAddrList++;
        lpAddrList++;
    }

    *lpDestAddrList = NULL;

    return( ERROR_SUCCESS );
}


// ----------------------------------------------------------------
//
// 	The Windows Sockets WSAAsyncGetHostByName function gets host
// 	information corresponding to a host name asynchronously.
//
// 	HANDLE WSAAsyncGetHostByName ( HWND hWnd, unsigned int wMsg, const
// 	char FAR * name, char FAR * buf, int buflen );
//
//	Parameters
//
//	hWnd
//
// 	[in] The handle of the window that will receive a message when the
// 	asynchronous request completes.
//
// 	wMsg
//
// 	[in] The message to be received when the asynchronous request
// 	completes.
//
// 	name
//
// 	[in] A pointer to the null-terminated name of the host.
//
// 	buf
//
// 	[out] A pointer to the data area to receive the HOSTENT data. It must
// 	be larger than the size of a HOSTENT structure because the supplied
// 	data area is used by Windows Sockets to contain not only a HOSTENT
// 	structure but any and all of the data referenced by members of the
// 	HOSTENT structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
//
// 	buflen
//
// 	[in] The size of data area the buf parameter.
//
// Remarks
//
// 	This function is an asynchronous version of gethostbyname, and is
// 	used to retrieve host name and address information corresponding to a
// 	host name. Windows Sockets initiates the operation and returns to the
// 	caller immediately, passing back an opaque "asynchronous task handle"
// 	that whichthe application can use to identify the operation. When the
// 	operation is completed, the results (if any) are copied into the
// 	buffer provided by the caller and a message is sent to the
// 	application's window.
//
// 	When the asynchronous operation is complete the application's window
// 	hWnd receives message wMsg. The wParam parameter contains the
// 	asynchronous task handle as returned by the original function call.
// 	The high 16 bits of lParam contain any error code. The error code can
// 	be any error as defined in WINSOCK2.H. An error code of zero
// 	indicates successful completion of the asynchronous operation. On
// 	successful completion, the buffer supplied to the original function
// 	call contains a HOSTENT structure. To access the elements of this
// 	structure, the original buffer address should be cast to a HOSTENT
// 	structure pointer and accessed as appropriate.
//
// 	If the error code is WSAENOBUFS, the size of the buffer specified by
// 	buflen in the original call was too small to contain all the
// 	resulting information. In this case, the low 16 bits of lParam
// 	contain the size of buffer required to supply all the requisite
// 	information. If the application decides that the partial data is
// 	inadequate, it can reissue the WSAAsyncGetHostByAddr function call
// 	with a buffer large enough to receive all the desired information
// 	(that is, no smaller than the low 16 bits of lParam).
//
// 	The buffer supplied to this function is used by Windows Sockets to
// 	construct a HOSTENT structure together with the contents of data
// 	areas referenced by members of the same HOSTENT structure. To avoid
// 	the WSAENOBUFS error, the application should provide a buffer of at
// 	least MAXGETHOSTSTRUCT bytes (as defined in WINSOCK2.H).
//
// 	The error code and buffer length should be extracted from the lParam
// 	using the macros WSAGETASYNCERROR and WSAGETASYNCBUFLEN, defined in
// 	WINSOCK2.H as:
//
// 	#define WSAGETASYNCERROR(lParam) HIWORD(lParam) #define
// 	WSAGETASYNCBUFLEN(lParam) LOWORD(lParam) The use of these macros will
// 	maximize the portability of the source code for the application.
//
// 	WSAAsyncGetHostByName is guaranteed to resolve the string returned by
// 	a successful call to gethostname.
//
// Return Values
//
// 	The return value specifies whether or not the asynchronous operation
// 	was successfully initiated. Note that it does not imply success or
// 	failure of the operation itself.
//
// 	If the operation was successfully initiated, WSAAsyncGetHostByName
// 	returns a nonzero value of type HANDLE that is the asynchronous task
// 	handle (not to be confused with a Windows HTASK) for the request.
// 	This value can be used in two ways. It can be used to cancel the
// 	operation using WSACancelAsyncRequest. It can also be used to match
// 	up asynchronous operations and completion messages by examining the
// 	wParam message parameter.
//
// 	If the asynchronous operation could not be initiated,
// 	WSAAsyncGetHostByName returns a zero value, and a specific error
// 	number can be retrieved by calling WSAGetLastError.
//
// Error Codes
//
// 	The following error codes can be set when an application window
// 	receives a message. As described above, they can be extracted from
// 	the lParam in the reply message using the WSAGETASYNCERROR macro.
//
// 	WSAENETDOWN The network subsystem has failed.
//
// 	WSAENOBUFS Insufficient buffer space is available.
//
// 	WSAEFAULT name or buf is not in a valid part of the process address
// 	space.
//
// 	WSAHOST_NOT_FOUND Authoritative Answer Host not found.
//
// 	WSATRY_AGAIN Non-Authoritative Host not found, or SERVERFAIL.
//
// 	WSANO_RECOVERY Nonrecoverable errors, FORMERR, REFUSED, NOTIMP.
//
// 	WSANO_DATA Valid name, no data record of requested type.
//
// 	The following errors can occur at the time of the function call, and
// 	indicate that the asynchronous operation could not be initiated.
//
// 	WSANOTINITIALISED A successful WSAStartup must occur before using
// 	this function.
//
// 	WSAENETDOWN The network subsystem has failed.
//
// 	WSAEINPROGRESS A blocking Windows Sockets 1.1 call is in progress, or
// 	the service provider is still processing a callback function.
//
// 	WSAEWOULDBLOCK The asynchronous operation cannot be scheduled at this
// 	time due to resource or other constraints within the Windows Sockets
// 	implementation.
//
// ----------------------------------------------------------------


// 
// ----------------------------------------------------------------
//
// The Windows Sockets WSACancelAsyncRequest function cancels an
// incomplete asynchronous operation.
//
//    int WSACancelAsyncRequest (
//     HANDLE hAsyncTaskHandle
//    );
//
// Parameters
// 	hAsyncTaskHandle
// 	[in] Specifies the asynchronous operation to be canceled.
//
// Remarks
//    The WSACancelAsyncRequest function is used to cancel an asynchronous
//    operation that was initiated by one of the WSAAsyncGetXByY functions
//    such as WSAAsyncGetHostByName. The operation to be canceled is
//    identified by the hAsyncTaskHandle parameter, which should be set to
//    the asynchronous task handle as returned by the initiating
//    WSAAsyncGetXByY function.
//
// Return Values
// 	The value returned by WSACancelAsyncRequest is zero if the operation
// 	was successfully canceled. Otherwise, the value SOCKET_ERROR is
// 	returned, and a specific error number may be retrieved by calling
// 	WSAGetLastError.
//
// Comments
// 	An attempt to cancel an existing asynchronous WSAAsyncGetXByY
// 	operation can fail with an error code of WSAEALREADY for two reasons.
// 	First, the original operation has already completed and the
// 	application has dealt with the resultant message. Second, the
// 	original operation has already completed but the resultant message is
// 	still waiting in the application window queue.
//
// Note
// 	It is unclear whether the application can usefully distinguish
// 	between WSAEINVAL and WSAEALREADY, since in both cases the error
// 	indicates that there is no asynchronous operation in progress with
// 	the indicated handle. [Trivial exception: zero is always an invalid
// 	asynchronous task handle.] The Windows Sockets specification does not
// 	prescribe how a conformant Windows Sockets provider should
// 	distinguish between the two cases. For maximum portability, a Windows
// 	Sockets application should treat the two errors as equivalent.
//
//
// Error Codes
// 	WSANOTINITIALISED A successful WSAStartup must occur before using
// 	this function.
//
// 	WSAENETDOWN	The network subsystem has failed.
//
// 	WSAEINVAL Indicates that the specified asynchronous task handle was
// 	invalid
//
// 	WSAEINPROGRESS A blocking Windows Sockets 1.1 call is in progress, or
// 	the service provider is still processing a callback function.
//
// 	WSAEALREADY The asynchronous routine being canceled has already
// 	completed.
//
// ----------------------------------------------------------------


// ----------------------------------------------------------------
//
//
// The Windows Sockets WSAAsyncSelect function requests Windows message-based notification of network events for a socket.
//
// int WSAAsyncSelect (
//     SOCKET s,
//     HWND hWnd,
//     unsigned int wMsg,
//     long lEvent
//    );
//
// Parameters
// 	s
// 	[in] A descriptor identifying the socket for which event notification
// 	is required.
//
// 	hWnd
// 	[in] A handle identifying the window that should receive a message
// 	when a network event occurs.
//
// 	wMsg
// 	[in] The message to be received when a network event occurs.
//
// 	lEvent
// 	[in] A bitmask that specifies a combination of network events in
// 	which the application is interested.
//
// Remarks
// 	This function is used to request that the Windows Sockets DLL should
// 	send a message to the window hWnd whenever it detects any of the
// 	network events specified by the lEvent parameter. The message that
// 	should be sent is specified by the wMsg parameter. The socket for
// 	which notification is required is identified by s.
//
// 	This function automatically sets socket s to nonblocking mode,
// 	regardless of the value of lEvent. See ioctlsocket about how to set
// 	the nonoverlapped socket back to blocking mode.
//
// 	The lEvent parameter is constructed by or'ing any of the values
// 	specified in the following list.
//
// 	Value		Meaning
// 	FD_READ		Want to receive notification of readiness for reading
//
// 	FD_WRITE	Want to receive notification of readiness for writing
//
// 	FD_OOB		Want to receive notification of the arrival of
// 				out-of-band data
//
// 	FD_ACCEPT	Want to receive notification of incoming connections
//
// 	FD_CONNECT	Want to receive notification of completed connection
//
// 	FD_CLOSE	Want to receive notification of socket closure
//
// 	FD_QOS		Want to receive notification of socket Quality of Service
// 				(QOS) changes
//
// 	FD_GROUP_QOS Want to receive notification of socket group Quality of
// 				Service (QOS) changes
//
// 	Issuing a WSAAsyncSelect for a socket cancels any previous
// 	WSAAsyncSelect or WSAEventSelect for the same socket. For example, to
// 	receive notification for both reading and writing, the application
// 	must call WSAAsyncSelect with both FD_READ and FD_WRITE, as follows:
//
// 	rc = WSAAsyncSelect(s, hWnd, wMsg, FD_READ|FD_WRITE);
//
// 	It is not possible to specify different messages for different
// 	events. The following code will not work; the second call will cancel
// 	the effects of the first, and only FD_WRITE events will be reported
// 	with message wMsg2:
//
// 	rc = WSAAsyncSelect(s, hWnd, wMsg1, FD_READ);
// 	rc = WSAAsyncSelect(s, hWnd, wMsg2, FD_WRITE);
//
// 	To cancel all notification (that is, to indicate that Windows Sockets
// 	should send no further messages related to network events on the
// 	socket) lEvent should be set to zero.
//
// 	rc = WSAAsyncSelect(s, hWnd, 0, 0);
//
// 	Although in this instance WSAAsyncSelect immediately disables event
// 	message posting for the socket, it is possible that messages can be
// 	waiting in the application's message queue. The application must
// 	therefore be prepared to receive network event messages even after
// 	cancellation. Closing a socket with closesocket also cancels
// 	WSAAsyncSelect message sending, but the same caveat about messages in
// 	the queue prior to the closesocket still applies.
//
// 	Since an accept'ed socket has the same properties as the listening
// 	socket used to accept it, any WSAAsyncSelect events set for the
// 	listening socket apply to the accepted socket. For example, if a
// 	listening socket has WSAAsyncSelect events FD_ACCEPT, FD_READ, and
// 	FD_WRITE, then any socket accepted on that listening socket will also
// 	have FD_ACCEPT, FD_READ, and FD_WRITE events with the same wMsg value
// 	used for messages. If a different wMsg or events are desired, the
// 	application should call WSAAsyncSelect, passing the accepted socket
// 	and the desired new information.
//
// 	When one of the nominated network events occurs on the specified
// 	socket s, the application's window hWnd receives message wMsg. The
// 	wParam parameter identifies the socket on which a network event has
// 	occurred. The low word of lParam specifies the network event that has
// 	occurred. The high word of lParam contains any error code. The error
// 	code be any error as defined in WINSOCK2.H.  Note Upon receipt of an
// 	event notification message the WSAGetLastError function cannot be
// 	used to check the error value, because the error value returned can
// 	differ from the value in the high word of lParam.
//
// 	The error and event codes can be extracted from the lParam using the
// 	macros WSAGETSELECTERROR and WSAGETSELECTEVENT, defined in WINSOCK2.H
// 	as:
//
// 	#define WSAGETSELECTERROR(lParam)       HIWORD(lParam)
// 	#define WSAGETSELECTEVENT(lParam)       LOWORD(lParam)
//
// 	The use of these macros will maximize the portability of the source
// 	code for the application.
//
// 	The possible network event codes that can be returned are as follows:
//
// 	Value	Meaning
// 	 FD_READ Socket s ready for reading
//
// 	FD_WRITE Socket s ready for writing
//
// 	FD_OOB Out-of-band data ready for reading on socket s
//
// 	FD_ACCEPT Socket s ready for accepting a new incoming connection
//
// 	FD_CONNECT Connection initiated on socket s completed
//
// 	FD_CLOSE Connection identified by socket s has been closed
//
// 	FD_QOS Quality of Service associated with socket s has changed
//
// 	FD_GROUP_QOS Quality of Service associated with the socket group to
// 	which s belongs has changed
//
// Return Values
//
// 	The return value is zero if the application's declaration of interest
// 	in the network event set was successful. Otherwise, the value
// 	SOCKET_ERROR is returned, and a specific error number can be
// 	retrieved by calling WSAGetLastError.
//
// Comments
//
// 	Although WSAAsyncSelect can be called with interest in multiple
// 	events, the application window will receive a single message for each
// 	network event.
//
// 	As in the case of the select function, WSAAsyncSelect will frequently
// 	be used to determine when a data transfer operation (send or recv)
// 	can be issued with the expectation of immediate success.
// 	Nevertheless, a robust application must be prepared for the
// 	possibility that it can receive a message and issue a Windows Sockets
// 	2 call that returns WSAEWOULDBLOCK immediately. For example, the
// 	following sequence of events is possible:
//
// 	1. data arrives on socket s; Windows Sockets 2 posts WSAAsyncSelect
// 	message
//
// 	2. application processes some other message
//
// 	3. while processing, application issues an ioctlsocket(s,
// 	FIONREAD...) and notices that there is data ready to be read
//
// 	4. application issues a recv(s,...) to read the data
//
// 	5. application loops to process next message, eventually reaching the
// 	WSAAsyncSelect message indicating that data is ready to read
//
// 	6. application issues recv(s,...), which fails with the error
// 	WSAEWOULDBLOCK.
//
// 	Other sequences are possible.
//
// 	The Windows Sockets DLL will not continually flood an application
// 	with messages for a particular network event. Having successfully
// 	posted notification of a particular event to an application window,
// 	no further message(s) for that network event will be posted to the
// 	application window until the application makes the function call that
// 	implicitly re-enables notification of that network event.
//
// 	Event	Re-enabling function
//
// 	FD_READ recv, recvfrom, WSARecv, or WSARecvFrom
//
// 	FD_WRITE send, sendto, WSASend, or WSASendTo
//
// 	FD_OOB recv, recvfrom, WSARecv, or WSARecvFrom
//
// 	FD_ACCEPT accept or WSAAccept unless the error code is WSATRY_AGAIN
// 	indicating that the condition function returned CF_DEFER
//
// 	FD_CONNECT NONE
//
// 	FD_CLOSE NONE
//
// 	FD_QOS WSAIoctl with command SIO_GET_QOS
//
// 	FD_GROUP_QOS WSAIoctl with command SIO_GET_GROUP_QOS
//
// 	Any call to the re-enabling routine, even one that fails, results in
// 	re-enabling of message posting for the relevant event.
//
// 	For FD_READ, FD_OOB, and FD_ACCEPT events, message posting is
// 	"level-triggered." This means that if the re-enabling routine is
// 	called and the relevant condition is still met after the call, a
// 	WSAAsyncSelect message is posted to the application. This allows an
// 	application to be event-driven and not be concerned with the amount
// 	of data that arrives at any one time. Consider the following sequence:
//
// 	1. Network transport stack receives 100 bytes of data on socket s and
// 	causes Windows Sockets 2 to post an FD_READ message.
//
// 	2. The application issues recv( s, buffptr, 50, 0) to read 50 bytes.
//
// 	3. Another FD_READ message is posted since there is still data to be
// 	read.
//
// 	With these semantics, an application need not read all available data
// 	in response to an FD_READ messagea single recv in response to each
// 	FD_READ message is appropriate. If an application issues multiple
// 	recv calls in response to a single FD_READ, it can receive multiple
// 	FD_READ messages. Such an application may need to disable FD_READ
// 	messages before starting the recv calls by calling WSAAsyncSelect
// 	with the FD_READ event not set.
//
// 	The FD_QOS and FD_GROUP_QOS events are considered edge triggered. A
// 	message will be posted exactly once when a QOS change occurs. Further
// 	messages will not be forthcoming until either the provider detects a
// 	further change in QOS or the application renegotiates the QOS for the
// 	socket.
//
// 	If any event has already happened when the application calls
// 	WSAAsyncSelect or when the re-enabling function is called, then a
// 	message is posted as appropriate. For example, consider the following
// 	sequence:
//
// 	1. an application calls listen,
//
// 	2. a connect request is received but not yet accepted,
//
// 	3. the application calls WSAAsyncSelect specifying that it wants to
// 	receive FD_ACCEPT messages for the socket. Due to the persistence of
// 	events, Windows Sockets 2 posts an FD_ACCEPT message immediately.
//
// 	The FD_WRITE event is handled slightly differently. An FD_WRITE
// 	message is posted when a socket is first connected with
// 	connect/WSAConnect (after FD_CONNECT, if also registered) or accepted
// 	with accept/WSAAccept, and then after a send operation fails with
// 	WSAEWOULDBLOCK and buffer space becomes available. Therefore, an
// 	application can assume that sends are possible starting from the
// 	first FD_WRITE message and lasting until a send returns
// 	WSAEWOULDBLOCK. After such a failure the application will be notified
// 	that sends are again possible with an FD_WRITE message.
//
// 	The FD_OOB event is used only when a socket is configured to receive
// 	out-of-band data separately. (See section Out-Of-Band data for a
// 	discussion of this topic.) If the socket is configured to receive
// 	out-of-band data in-line, the out-of-band (expedited) data is treated
// 	as normal data and the application should register an interest in,
// 	and will receive, FD_READ events, not FD_OOB events. An application
// 	may set or inspect the way in which out-of-band data is to be handled
// 	by using setsockopt or getsockopt for the SO_OOBINLINE option.
//
// 	The error code in an FD_CLOSE message indicates whether the socket
// 	close was graceful or abortive. If the error code is zero, then the
// 	close was graceful; if the error code is WSAECONNRESET, then the
// 	socket's virtual circuit was reset. This only applies to
// 	connection-oriented sockets such as SOCK_STREAM.
//
// 	The FD_CLOSE message is posted when a close indication is received
// 	for the virtual circuit corresponding to the socket. In TCP terms,
// 	this means that the FD_CLOSE is posted when the connection goes into
// 	the TIME WAIT or CLOSE WAIT states. This results from the remote end
// 	performing a shutdown on the send side or a closesocket. FD_CLOSE
// 	should only be posted after all data is read from a socket, but an
// 	application should check for remaining data upon receipt of FD_CLOSE
// 	to avoid any possibility of losing data.
//
// 	Please note your application will receive ONLY an FD_CLOSE message to
// 	indicate closure of a virtual circuit, and only when all the received
// 	data has been read if this is a graceful close. It will not receive
// 	an FD_READ message to indicate this condition.
//
// 	The FD_QOS or FD_GROUP_QOS message is posted when any field in the
// 	flow specification associated with socket s or the socket group that
// 	s belongs to has changed, respectively. Applications should use
// 	WSAIoctl with command SIO_GET_QOS or SIO_GET_GROUP_QOS to get the
// 	current QOS for socket s or for the socket group s belongs to,
// 	respectively.
//
// 	Here is a summary of events and conditions for each asynchronous
// 	notification message:
//
// 	FD_READ:
//
// 	1. when WSAAsyncSelect called, if there is data currently available
// 	to receive,
//
// 	2. when data arrives, if FD_READ not already posted,
//
// 	3. after recv or recvfrom called (with or without MSG_PEEK), if data
// 	is still available to receive.  Note when setsockopt SO_OOBINLINE is
// 	enabled "data" includes both normal data and out-of-band (OOB) data
// 	in the instances noted above.  FD_WRITE:
//
// 	1. when WSAAsyncSelect called, if a send or sendto is possible
//
// 	2. after connect or accept called, when connection established
//
// 	3. after send or sendto fail with WSAEWOULDBLOCK, when send or sendto
// 	are likely to succeed,
//
// 	4. after bind on a datagram socket.
//
// 	FD_OOB: Only valid when setsockopt SO_OOBINLINE is disabled (default).
//
// 	1. when WSAAsyncSelect called, if there is OOB data currently
// 	available to receive with the MSG_OOB flag,
//
// 	2. when OOB data arrives, if FD_OOB not already posted,
//
// 	3. after recv or recvfrom called with or without MSG_OOB flag, if OOB
// 	data is still available to receive.
//
// 	FD_ACCEPT:
//
// 	1. when WSAAsyncSelect called, if there is currently a connection
// 	request available to accept,
//
// 	2. when a connection request arrives, if FD_ACCEPT not already
// 	posted,
//
// 	3. after accept called, if there is another connection request
// 	available to accept.
//
// 	FD_CONNECT:
//
// 	1. when WSAAsyncSelect called, if there is currently a connection
// 	established,
//
// 	2. after connect called, when connection is established (even when
// 	connect succeeds immediately, as is typical with a datagram socket)
//
// 	FD_CLOSE: Only valid on connection-oriented sockets (for example,
// 	SOCK_STREAM) 1. when WSAAsyncSelect called, if socket connection has
// 	been closed,
//
// 	2. after remote system initiated graceful close, when no data
// 	currently available to receive (note: if data has been received and
// 	is waiting to be read when the remote system initiates a graceful
// 	close, the FD_CLOSE is not delivered until all pending data has been
// 	read),
//
// 	3. after local system initiates graceful close with shutdown and
// 	remote system has responded with "End of Data" notification (for
// 	example, TCP FIN), when no data currently available to receive,
//
// 	4. when remote system terminates connection (for example, sent TCP
// 	RST), and lParam will contain WSAECONNRESET error value.
//
//
// 	Note FD_CLOSE is not posted after closesocket is called.  FD_QOS:
//
// 	1. when WSAAsyncSelect called, if the QOS associated with the socket
// 	has been changed,
//
// 	2. after WSAIoctl with SIO_GET_QOS called, when the QOS is changed.
//
// 	FD_GROUP_QOS:
//
// 	1. when WSAAsyncSelect called, if the group QOS associated with the
// 	socket has been changed,
//
// 	2. after WSAIoctl with SIO_GET_GROUP_QOS called, when the group QOS
// 	is changed.  Error Codes
//
// 	WSANOTINITIALISED A successful WSAStartup must occur before using
// 	this function.
//
// 	WSAENETDOWN The network subsystem has failed.
//
// 	WSAEINVAL Indicates that one of the specified parameters was invalid
// 	such as the window handle not referring to an existing window, or the
// 	specified socket is in an invalid state.
//
// 	WSAEINPROGRESS A blocking Windows Sockets 1.1 call is in progress, or
// 	the service provider is still processing a callback function.
//
// 	WSAENOTSOCK The descriptor is not a socket.  Additional error codes
// 	may be set when an application window receives a message. This error
// 	code is extracted from the lParam in the reply message using the
// 	WSAGETSELECTERROR macro. Possible error codes for each network event
// 	are:
//
// 	Event: FD_CONNECT
//
// 	Error Code Meaning
//
// 	WSAEADDRINUSE The specified address is already in use.
//
// 	WSAEADDRNOTAVAIL The specified address is not available from the
// 	local machine.
//
// 	WSAEAFNOSUPPORT Addresses in the specified family cannot be used with
// 	this socket.
//
// 	WSAECONNREFUSED The attempt to connect was forcefully rejected.
//
// 	WSAENETUNREACH The network cannot be reached from this host at this
// 	time.
//
// 	WSAEFAULT The namelen parameter is incorrect.
//
// 	WSAEINVAL The socket is already bound to an address.
//
// 	WSAEISCONN The socket is already connected.
//
// 	WSAEMFILE No more file descriptors are available.
//
// 	WSAENOBUFS No buffer space is available. The socket cannot be
// 	connected.
//
// 	WSAENOTCONN The socket is not connected.
//
// 	WSAETIMEDOUT Attempt to connect timed out without establishing a
// 	connection.
//
//
//
// 	Event: FD_CLOSE
//
// 	Error Code Meaning
//
// 	WSAENETDOWN The network subsystem has failed.
//
// 	WSAECONNRESET The connection was reset by the remote side.
//
// 	WSAECONNABORTED The connection was terminated due to a time-out or
// 	other failure.
//
//
// 	Event: FD_READ
//
// 	Event: FD_WRITE
//
// 	Event: FD_OOB
//
// 	Event: FD_ACCEPT
//
// 	Event: FD_QOS
//
// 	Event: FD_GROUP_QOS
//
// 	Error Code Meaning
//
// 	WSAENETDOWN The network subsystem has failed.
//
// ----------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\rpcwire.c ===
/*************************************************************************
*
* rpcwire.c
*
* Common functions for converting internal WinStation API structures 
* to/from a wire format which enables interoperability between various
* releases of icasrv and winsta.dll.
*
* Copyright Microsoft Corporation. 1998
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <winsta.h>

#include "rpcwire.h"

//
//  Allocation routines as defined by the client/server.
//
extern void * MIDL_user_allocate(size_t);
extern void MIDL_user_free( void * ); 


/*****************************************************************************
 *
 *  InitVarData
 *
 *   Initialize a generic structure which describes variable length data
 *   within a wire buffer.
 *
 * ENTRY:
 *   pVarData (input)
 *     The structure to initialize.
 *   Size (input)
 *     The size of the variable length data.
 *   Offset (input)
 *     The offset to the start of the data in the wire buffer.
 *
 ****************************************************************************/

VOID InitVarData(PVARDATA_WIRE pVarData,
                 ULONG Size,
                 ULONG Offset)
{
    pVarData->Size = (USHORT) Size;
    pVarData->Offset = (USHORT) Offset;
}

/*****************************************************************************
 *
 *  NextOffset
 *
 *   Returns the offset to the next variable length data area.
 *
 * ENTRY:
 *   PrevData (input)
 *     The current last variable length data area.
 *
 *****************************************************************************/

ULONG NextOffset(PVARDATA_WIRE PrevData)
{
    return(PrevData->Offset + PrevData->Size);
}

/*****************************************************************************
 *
 *  SdClassSize
 *
 *   Returns the actual size of the data associated with a given SdClass.
 *
 * ENTRY:
 *   SdClass (input)
 *     The type of Sd.
 *
 * EXIT
 *   Returns the data size if known otherwise 0.
 *****************************************************************************/

ULONG SdClassSize(SDCLASS SdClass)
{
    switch (SdClass) {
    case SdNetwork:   return(sizeof(NETWORKCONFIGW));
    case SdAsync:     return(sizeof(ASYNCCONFIGW));
    case SdNasi:      return(sizeof(NASICONFIGW));
    case SdOemFilter: return(sizeof(OEMTDCONFIGW));
#ifdef notdef
    // These cases are valid in 1.7
    case SdConsole:   return(sizeof(CONSOLECONFIGW));
    case SdFrame:     return(sizeof(FRAMECONFIG));
    case SdReliable:  return(sizeof(RELIABLECONFIG));
    case SdCompress:  return(sizeof(COMPRESSCONFIG));
    case SdModem:     return(sizeof(MODEMCONFIGW));
#endif
    default:
        return(0);
    }
}

/*****************************************************************************
 *
 *  CopySourceToDest
 *
 *   Copies variable length data to/from local/wire buffers. If the source
 *   buffer is smaller than the destination buffer, the destination buffer
 *   is zero filled after SourceSize, upto DestSize. (e.g. client queries
 *   down-level icasrv).  If the source buffer is larger than the
 *   destination buffer, the data is truncated at DestSize (e.g. down-level
 *   client queries newer icasrv). 
 *
 * ENTRY:
 *   SourceBuf (input)
 *     Source buffer 
 *   SourceSize (input)
 *     Source buffer size
 *   DestBuf (input)
 *     Destination buffer
 *   DestSize (input)
 *     Destiantion buffer size
 *
 * EXIT
 *   Returns the amount of data copied.
 *****************************************************************************/

ULONG CopySourceToDest(PCHAR SourceBuf, ULONG SourceSize,
                       PCHAR DestBuf, ULONG DestSize)
{
    ULONG DataSize;

    if (SourceSize >= DestSize ) {
        memcpy(DestBuf, SourceBuf, DestSize);
        DataSize = DestSize;
    } 
    else {
        // Down-level server/client (zero fill)
        memcpy(DestBuf, SourceBuf, SourceSize);
        memset(DestBuf+SourceSize, 0, DestSize - SourceSize);
        DataSize = SourceSize;
    }
    return(DataSize);
}

/*****************************************************************************
 *
 *  CopyPdParamsToWire
 *
 *   Copies a PDPARAMSW structure to a wire buffer.
 *
 * ENTRY:
 *   PdParamsWire (input)
 *     Destination wire buffer 
 *   PdParams (input)
 *     Source PDPARAMSW structure
 *
 *****************************************************************************/

VOID
CopyPdParamsToWire(PPDPARAMSWIREW PdParamsWire, PPDPARAMSW PdParams)
{
    ULONG Size;
    ULONG DataSize;

    PdParamsWire->SdClass = PdParams->SdClass; 
    Size = SdClassSize(PdParams->SdClass);
    DataSize = CopySourceToDest((PCHAR)&PdParams->Network,
                                Size,
                                (PCHAR)PdParamsWire +
                                PdParamsWire->SdClassSpecific.Offset,
                                PdParamsWire->SdClassSpecific.Size);

    PdParamsWire->SdClassSpecific.Size = (USHORT)DataSize;
}

/*****************************************************************************
 *
 *  CopyPdParamsFromWire
 *
 *   Copies a wire buffer to a PDPARAMSW structure.
 *
 * ENTRY:
 *   PdParamsWire (input)
 *     Source wire buffer 
 *   PdParams (input)
 *     Destination PDPARAMSW structure.
 *
 *****************************************************************************/

VOID
CopyPdParamsFromWire(PPDPARAMSWIREW PdParamsWire, PPDPARAMSW PdParams)
{
    ULONG Size;

    PdParams->SdClass = PdParamsWire->SdClass; 
    Size = SdClassSize(PdParams->SdClass);
    CopySourceToDest((PCHAR)PdParamsWire + PdParamsWire->SdClassSpecific.Offset,
                     PdParamsWire->SdClassSpecific.Size,
                     (PCHAR)&PdParams->Network,
                     Size);
}

/*****************************************************************************
 *
 *  CopyPdConfigToWire
 *
 *   Copies a PDCONFIGW structure to a wire buffer.
 *
 * ENTRY:
 *   PdConfigWire (input)
 *     Destination wire buffer 
 *   PdConfig (input)
 *     Source PDCONFIGW structure
 *
 *****************************************************************************/

VOID CopyPdConfigToWire(PPDCONFIGWIREW PdConfigWire, PPDCONFIGW PdConfig)
{
    CopySourceToDest((PCHAR) &PdConfig->Create, sizeof(PDCONFIG2W),
                     (PCHAR)PdConfigWire + PdConfigWire->PdConfig2W.Offset,
                     PdConfigWire->PdConfig2W.Size);
    CopyPdParamsToWire(&PdConfigWire->PdParams,&PdConfig->Params);

}

/*****************************************************************************
 *
 *  CopyPdConfigFromWire
 *
 *   Copies a wire buffer to a PDCONFIGW structure.
 *
 * ENTRY:
 *   PdConfigWire (input)
 *     Destination wire buffer 
 *   PdConfig (input)
 *     Source PDCONFIGW structure
 *
 *****************************************************************************/

VOID CopyPdConfigFromWire(PPDCONFIGWIREW PdConfigWire, PPDCONFIGW PdConfig)
{
    CopySourceToDest((PCHAR)PdConfigWire + PdConfigWire->PdConfig2W.Offset,
                     PdConfigWire->PdConfig2W.Size,
                     (PCHAR) &PdConfig->Create, sizeof(PDCONFIG2W));
    CopyPdParamsFromWire(&PdConfigWire->PdParams,&PdConfig->Params);
}

/*****************************************************************************
 *
 *  CopyWinStaConfigToWire
 *
 *   Copies a WINSTATIONCONFIGW structure to a wire buffer.
 *
 * ENTRY:
 *   WinStaConfigWire (input)
 *     Destination wire buffer 
 *   WinStaConfig (input)
 *     Source WINSTATIONCONFIGW structure
 *
 *****************************************************************************/

VOID CopyWinStaConfigToWire(PWINSTACONFIGWIREW WinStaConfigWire,
                            PWINSTATIONCONFIGW WinStaConfig)
{
    CopySourceToDest((PCHAR) &WinStaConfig->User, sizeof(USERCONFIGW),
                     (PCHAR)WinStaConfigWire+WinStaConfigWire->UserConfig.Offset,
                     WinStaConfigWire->UserConfig.Size);
    CopySourceToDest((PCHAR)&WinStaConfig->Comment,
                     sizeof(WinStaConfig->Comment),
                     (PCHAR)&WinStaConfigWire->Comment,
                     sizeof(WinStaConfigWire->Comment));
    CopySourceToDest((PCHAR)&WinStaConfig->OEMId,
                     sizeof(WinStaConfig->OEMId),
                     (PCHAR)&WinStaConfigWire->OEMId,
                     sizeof(WinStaConfigWire->OEMId));
    CopySourceToDest((PCHAR)&WinStaConfig + sizeof(WINSTATIONCONFIGW),
                     0, // Change this when new fields are added
                     (PCHAR)WinStaConfigWire+WinStaConfigWire->NewFields.Offset,
                     WinStaConfigWire->NewFields.Size);

}

/*****************************************************************************
 *
 *  CopyWinStaConfigFromWire
 *
 *   Copies a wire buffer to a WINSTATIONCONFIGW structure.
 *
 * ENTRY:
 *   WinStaConfigWire (input)
 *     Source wire buffer 
 *   WinStaConfig (input)
 *     Destiantion WINSTATIONCONFIGW structure
 *
 *****************************************************************************/

VOID CopyWinStaConfigFromWire(PWINSTACONFIGWIREW WinStaConfigWire,
                              PWINSTATIONCONFIGW WinStaConfig)
{
    CopySourceToDest((PCHAR)WinStaConfigWire+WinStaConfigWire->UserConfig.Offset,
                     WinStaConfigWire->UserConfig.Size,
                     (PCHAR) &WinStaConfig->User, sizeof(USERCONFIGW));

    CopySourceToDest((PCHAR)&WinStaConfigWire->Comment,
                     sizeof(WinStaConfigWire->Comment),
                     (PCHAR)&WinStaConfig->Comment,
                     sizeof(WinStaConfig->Comment));

    CopySourceToDest((PCHAR)&WinStaConfigWire->OEMId,
                     sizeof(WinStaConfigWire->OEMId),
                     (PCHAR)&WinStaConfig->OEMId,
                     sizeof(WinStaConfig->OEMId));

    CopySourceToDest((PCHAR)WinStaConfigWire+WinStaConfigWire->NewFields.Offset,
                     WinStaConfigWire->NewFields.Size,
                     (PCHAR) &WinStaConfig + sizeof(WINSTATIONCONFIGW),
                     0); // Change this when new fields are added
    
}

/*****************************************************************************
 *
 *  CopyGenericToWire
 *
 *   Copies a single variable length structure to a wire buffer.
 *
 * ENTRY:
 *   WireBuf (input)
 *     Destination wire buffer 
 *   LocalBuf (input)
 *     Source structure
 *   LocalBufLength (input)
 *     Source structure length
 *****************************************************************************/

VOID CopyGenericToWire(PVARDATA_WIRE WireBuf, PVOID LocalBuf, ULONG LocalBufLen)
{
    CopySourceToDest((PCHAR)LocalBuf,
                     LocalBufLen,
                     (PCHAR) WireBuf + WireBuf->Offset,
                     WireBuf->Size);
}

/*****************************************************************************
 *
 *  CopyGenericFromWire
 *
 *   Copies a wire buffer to a single variable length structure.
 *
 * ENTRY:
 *   WireBuf (input)
 *     Source wire buffer 
 *   LocalBuf (input)
 *     Destination structure
 *   LocalBufLength (input)
 *     Destination structure length
 *****************************************************************************/

VOID CopyGenericFromWire(PVARDATA_WIRE WireBuf, PVOID LocalBuf, ULONG LocalBufLen)
{
    CopySourceToDest((PCHAR) WireBuf + WireBuf->Offset,
                     WireBuf->Size,
                     (PCHAR)LocalBuf,
                     LocalBufLen);
}

/*****************************************************************************
 *
 *  CopyOutWireBuf
 *
 *   Copies a wire buffer to a local structure.
 *
 * ENTRY:
 *   InfoClass (input)
 *     WinStationQuery/Set information class
 *   UserBuf (input)
 *     Destination local structure
 *   WireBuf
 *     Source wire buffer 
 *****************************************************************************/

BOOLEAN
CopyOutWireBuf(WINSTATIONINFOCLASS InfoClass,
               PVOID UserBuf,
               PVOID WireBuf)
{
    ULONG BufSize;
    PPDCONFIGWIREW PdConfigWire;
    PPDCONFIGW PdConfig;
    PPDPARAMSWIREW PdParamsWire;
    PPDPARAMSW PdParam;
    PWINSTACONFIGWIREW WinStaConfigWire;
    PWINSTATIONCONFIGW WinStaConfig;

    switch (InfoClass) {
    case WinStationPd:
        PdConfigWire = (PPDCONFIGWIREW)WireBuf;
        PdConfig = (PPDCONFIGW)UserBuf;
        CopyPdConfigFromWire(PdConfigWire, PdConfig);
        break;
    case WinStationPdParams:
        PdParamsWire = (PPDPARAMSWIREW)WireBuf;

        CopyPdParamsFromWire(PdParamsWire,
                             (PPDPARAMS)UserBuf);
        break;

    case WinStationConfiguration:
        WinStaConfigWire = (PWINSTACONFIGWIREW)WireBuf;
        WinStaConfig = (PWINSTATIONCONFIGW)UserBuf;

        CopyWinStaConfigFromWire(WinStaConfigWire, WinStaConfig);
        break;

    case WinStationInformation:
        CopyGenericFromWire((PVARDATA_WIRE)WireBuf,
                            UserBuf,
                            sizeof(WINSTATIONINFORMATIONW));
        break;

    case WinStationWd:
        CopyGenericFromWire((PVARDATA_WIRE)WireBuf,
                            UserBuf,
                            sizeof(WDCONFIGW));
        break;

    case WinStationClient:
        CopyGenericFromWire((PVARDATA_WIRE)WireBuf,
                            UserBuf,
                            sizeof(WINSTATIONCLIENTW));
        break;

    default:
        return(FALSE);

    }

    return(TRUE);
}

/*****************************************************************************
 *
 *  CopyInWireBuf
 *
 *   Copies a local structure to a wire buffer.
 *
 * ENTRY:
 *   InfoClass (input)
 *     WinStationQuery/Set information class
 *   WireBuf (input)
 *     Destination wire buffer
 *   UserBuf (input)
 *     Destination local structure
 *****************************************************************************/

BOOLEAN
CopyInWireBuf(WINSTATIONINFOCLASS InfoClass,
              PVOID UserBuf,
              PVOID WireBuf)
{
    ULONG BufSize;
    PPDCONFIGWIREW PdConfigWire;
    PPDCONFIGW PdConfig;
    PPDPARAMSWIREW PdParamsWire;
    PPDPARAMSW PdParam;
    PWINSTACONFIGWIREW WinStaConfigWire;
    PWINSTATIONCONFIGW WinStaConfig;

    switch (InfoClass) {
    case WinStationPd:
        PdConfigWire = (PPDCONFIGWIREW)WireBuf;
        PdConfig = (PPDCONFIGW)UserBuf;
        CopyPdConfigToWire(PdConfigWire, PdConfig);
        break;
    case WinStationPdParams:
        PdParamsWire = (PPDPARAMSWIREW)WireBuf;

        CopyPdParamsToWire(PdParamsWire,
                           (PPDPARAMS)UserBuf);
        break;

    case WinStationConfiguration:
        WinStaConfigWire = (PWINSTACONFIGWIREW)WireBuf;
        WinStaConfig = (PWINSTATIONCONFIGW)UserBuf;

        CopyWinStaConfigToWire(WinStaConfigWire, WinStaConfig);
        break;

    case WinStationInformation:
        CopyGenericToWire((PVARDATA_WIRE)WireBuf,
                          UserBuf,
                          sizeof(WINSTATIONINFORMATIONW));
        break;

    case WinStationWd:
        CopyGenericToWire((PVARDATA_WIRE)WireBuf,
                          UserBuf,
                          sizeof(WDCONFIGW));
        break;

    case WinStationClient:
        CopyGenericToWire((PVARDATA_WIRE)WireBuf,
                          UserBuf,
                          sizeof(WINSTATIONCLIENTW));
        break;

    default:
        return(FALSE);

    }

    return(TRUE);
}

/*****************************************************************************
 *
 *  AllocateAndCopyCredToWire
 *
 *   Allocates a buffer big enough for the credentials and then copies them in.
 *
 *****************************************************************************/

ULONG
AllocateAndCopyCredToWire(
    PWLXCLIENTCREDWIREW *ppWire,
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCredentials
    )
{
    ULONG cchUserName;
    ULONG cchDomain;
    ULONG cchPassword;
    ULONG cbWireBuf;

    cchUserName = lstrlenW(pCredentials->pszUserName) + 1;
    cchDomain = lstrlenW(pCredentials->pszDomain) + 1;
    cchPassword = lstrlenW(pCredentials->pszPassword) + 1;

    cbWireBuf = sizeof(WLXCLIENTCREDWIREW) +
        (cchUserName + cchDomain + cchPassword) * sizeof(WCHAR);

    *ppWire = MIDL_user_allocate(cbWireBuf);

    if (*ppWire != NULL)
    {
        ZeroMemory(*ppWire, cbWireBuf);
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(0);
    }

    (*ppWire)->dwType = pCredentials->dwType;
    (*ppWire)->fDisconnectOnLogonFailure = pCredentials->fDisconnectOnLogonFailure;
    (*ppWire)->fPromptForPassword = pCredentials->fPromptForPassword;

    InitVarData(
        &((*ppWire)->UserNameData),
        cchUserName * sizeof(WCHAR),
        sizeof(WLXCLIENTCREDWIREW)
        );
    CopyMemory(
        (LPBYTE)(*ppWire) + (*ppWire)->UserNameData.Offset,
        pCredentials->pszUserName,
        (*ppWire)->UserNameData.Size
        );

    InitVarData(
        &((*ppWire)->DomainData),
        cchDomain * sizeof(WCHAR),
        NextOffset(&((*ppWire)->UserNameData))
        );
    CopyMemory(
        (LPBYTE)(*ppWire) + (*ppWire)->DomainData.Offset,
        pCredentials->pszDomain,
        (*ppWire)->DomainData.Size
        );

    InitVarData(
        &((*ppWire)->PasswordData),
        cchPassword * sizeof(WCHAR),
        NextOffset(&((*ppWire)->DomainData))
        );
    CopyMemory(
        (LPBYTE)(*ppWire) + (*ppWire)->PasswordData.Offset,
        pCredentials->pszPassword,
        (*ppWire)->PasswordData.Size
        );

    return(cbWireBuf);
}

/*****************************************************************************
 *
 *  CopyCredFromWire
 *
 *   Copies credentials from the wire buffer.
 *
 *****************************************************************************/

BOOLEAN
CopyCredFromWire(
    PWLXCLIENTCREDWIREW pWire,
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCredentials
    )
{
    BOOLEAN fRet;

    pCredentials->pszUserName = LocalAlloc(
        LMEM_FIXED,
        pWire->UserNameData.Size
        );

    if (pCredentials->pszUserName != NULL)
    {
        CopyMemory(
            (LPBYTE)(pCredentials->pszUserName),
            (LPBYTE)pWire + pWire->UserNameData.Offset,
            pWire->UserNameData.Size
            );
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fRet = FALSE;
        goto exit;
    }

    pCredentials->pszDomain = LocalAlloc(
        LMEM_FIXED,
        pWire->DomainData.Size
        );

    if (pCredentials->pszDomain != NULL)
    {
        CopyMemory(
            (LPBYTE)(pCredentials->pszDomain),
            (LPBYTE)pWire + pWire->DomainData.Offset,
            pWire->DomainData.Size
            );
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fRet = FALSE;
        goto exit;
    }

    pCredentials->pszPassword = LocalAlloc(
        LMEM_FIXED,
        pWire->PasswordData.Size
        );

    if (pCredentials->pszPassword != NULL)
    {
        CopyMemory(
            (LPBYTE)(pCredentials->pszPassword),
            (LPBYTE)pWire + pWire->PasswordData.Offset,
            pWire->PasswordData.Size
            );
    }
    else
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fRet = FALSE;
        goto exit;
    }

    pCredentials->dwType = pWire->dwType;
    pCredentials->fDisconnectOnLogonFailure = pWire->fDisconnectOnLogonFailure;
    pCredentials->fPromptForPassword = pWire->fPromptForPassword;

    fRet = TRUE;

exit:
    if (!fRet)
    {
        if (pCredentials->pszUserName != NULL)
        {
            LocalFree(pCredentials->pszUserName);
            pCredentials->pszUserName = NULL;
        }

        if (pCredentials->pszDomain != NULL)
        {
            LocalFree(pCredentials->pszDomain);
            pCredentials->pszDomain = NULL;
        }

        if (pCredentials->pszPassword != NULL)
        {
            LocalFree(pCredentials->pszPassword);
            pCredentials->pszPassword = NULL;
        }
    }

    return(fRet);
}

/*
 *  Licensing Core functions
 */

ULONG
CopyPolicyInformationToWire(
    LPLCPOLICYINFOGENERIC *ppWire,
    LPLCPOLICYINFOGENERIC pPolicyInfo
    )
{
    ULONG ulReturn;

    ASSERT(ppWire != NULL);
    ASSERT(pPolicyInfo != NULL);

    if (pPolicyInfo->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        LPLCPOLICYINFOWIRE_V1 *ppWireV1;
        LPLCPOLICYINFO_V1W pPolicyInfoV1;
        ULONG cbPolicyName;
        ULONG cbPolicyDescription;

        ppWireV1 = (LPLCPOLICYINFOWIRE_V1*)ppWire;
        pPolicyInfoV1 = (LPLCPOLICYINFO_V1W)pPolicyInfo;
        cbPolicyName = (lstrlenW(pPolicyInfoV1->lpPolicyName) + 1) * sizeof(WCHAR);
        cbPolicyDescription = (lstrlenW(pPolicyInfoV1->lpPolicyDescription) + 1) * sizeof(WCHAR);

        ulReturn = sizeof(LCPOLICYINFOWIRE_V1);
        ulReturn += cbPolicyName;
        ulReturn += cbPolicyDescription;

        *ppWireV1 = MIDL_user_allocate(ulReturn);

        if (*ppWireV1 != NULL)
        {
            (*ppWireV1)->ulVersion = LCPOLICYINFOTYPE_V1;

            InitVarData(
                &((*ppWireV1)->PolicyNameData),
                cbPolicyName,
                sizeof(LCPOLICYINFOWIRE_V1)
                );
            CopyMemory(
                (LPBYTE)(*ppWireV1) + (*ppWireV1)->PolicyNameData.Offset,
                pPolicyInfoV1->lpPolicyName,
                (*ppWireV1)->PolicyNameData.Size
                );

            InitVarData(
                &((*ppWireV1)->PolicyDescriptionData),
                cbPolicyDescription,
                NextOffset(&((*ppWireV1)->PolicyNameData))
                );
            CopyMemory(
                (LPBYTE)(*ppWireV1) + (*ppWireV1)->PolicyDescriptionData.Offset,
                pPolicyInfoV1->lpPolicyDescription,
                (*ppWireV1)->PolicyDescriptionData.Size
                );
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            ulReturn = 0;
        }
    }
    else
    {
        SetLastError(ERROR_UNKNOWN_REVISION);
        ulReturn = 0;
    }

    return(ulReturn);
}

BOOLEAN
CopyPolicyInformationFromWire(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo,
    LPLCPOLICYINFOGENERIC pWire
    )
{
    BOOLEAN fRet;

    ASSERT(ppPolicyInfo != NULL);
    ASSERT(pWire != NULL);

    if (pWire->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        LPLCPOLICYINFO_V1W *ppPolicyInfoV1;
        LPLCPOLICYINFOWIRE_V1 pWireV1;

        ppPolicyInfoV1 = (LPLCPOLICYINFO_V1W*)ppPolicyInfo;
        pWireV1 = (LPLCPOLICYINFOWIRE_V1)pWire;

        *ppPolicyInfoV1 = LocalAlloc(LPTR, sizeof(LCPOLICYINFO_V1W));

        if (*ppPolicyInfoV1 != NULL)
        {
            (*ppPolicyInfoV1)->ulVersion = LCPOLICYINFOTYPE_V1;

            (*ppPolicyInfoV1)->lpPolicyName = LocalAlloc(LPTR, pWireV1->PolicyNameData.Size);

            if ((*ppPolicyInfoV1)->lpPolicyName != NULL)
            {
                CopyMemory(
                    (LPBYTE)((*ppPolicyInfoV1)->lpPolicyName),
                    (LPBYTE)pWireV1 + pWireV1->PolicyNameData.Offset,
                    pWireV1->PolicyNameData.Size
                    );
            }
            else
            {
                SetLastError(ERROR_OUTOFMEMORY);
                fRet = FALSE;
                goto V1error;
            }

            (*ppPolicyInfoV1)->lpPolicyDescription = LocalAlloc(LPTR, pWireV1->PolicyDescriptionData.Size);

            if ((*ppPolicyInfoV1)->lpPolicyDescription != NULL)
            {
                CopyMemory(
                    (LPBYTE)((*ppPolicyInfoV1)->lpPolicyDescription),
                    (LPBYTE)pWireV1 + pWireV1->PolicyDescriptionData.Offset,
                    pWireV1->PolicyDescriptionData.Size
                    );
            }
            else
            {
                SetLastError(ERROR_OUTOFMEMORY);
                fRet = FALSE;
                goto V1error;
            }

            fRet = TRUE;
            goto exit;

V1error:
            if ((*ppPolicyInfoV1)->lpPolicyName != NULL)
            {
                LocalFree((*ppPolicyInfoV1)->lpPolicyName);
                (*ppPolicyInfoV1)->lpPolicyName = NULL;
            }

            if ((*ppPolicyInfoV1)->lpPolicyDescription != NULL)
            {
                LocalFree((*ppPolicyInfoV1)->lpPolicyDescription);
                (*ppPolicyInfoV1)->lpPolicyDescription = NULL;
            }

            LocalFree(*ppPolicyInfoV1);
            *ppPolicyInfoV1 = NULL;
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            fRet = FALSE;
        }
    }
    else
    {
        SetLastError(ERROR_UNKNOWN_REVISION);
        fRet = FALSE;
    }

exit:
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\client\tsrpc-c.c ===
#include <tsrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\client\server.c ===
/*************************************************************************
*
* server.c
*
* Client side APIs for server-level administration
*
* Copyright Microsoft Corporation, 1999
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <allproc.h>

#include <winsta.h>

/*
 * Include the RPC generated common header
 */

#include "tsrpc.h"

#include "rpcwire.h"

#ifdef NTSDDEBUG
#define NTSDDBGPRINT(x) DbgPrint x
#else
#define NTSDDBGPRINT(x)
#endif

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*
 * This handle is returned when there is no terminal
 * server present on the system. (Non-Hydra)
 */
#define RPC_HANDLE_NO_SERVER (HANDLE)IntToPtr( 0xFFFFFFFD )


/*
 *  Private Procedures defined here
 */

/*
 *  Global data
 */

/*
 *  other internal Procedures used (not defined here)
 */

VOID WinStationConfigU2A( PWINSTATIONCONFIGA, PWINSTATIONCONFIGW );
ULONG CheckUserBuffer(WINSTATIONINFOCLASS,
                      PVOID,
                      ULONG,
                      PVOID *,
                      PULONG,
                      BOOLEAN *);

BOOLEAN
RpcLocalAutoBind(
    VOID
    );

/*
 * Check to see that caller does not hold the loader critsec.
 * WinStation APIs must NOT be called while holding the loader critsec
 * since deadlock may occur.
 */
#define CheckLoaderLock() \
        ASSERT( NtCurrentTeb()->ClientId.UniqueThread != \
            ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread );

/*
 * Handle the SERVERNAME_CURRENT for auto local binding.
 */
#define HANDLE_CURRENT_BINDING( hServer )                       \
    CheckLoaderLock();                                          \
    if( hServer == SERVERNAME_CURRENT ) {                       \
        if( IcaApi_IfHandle == NULL ) {                         \
            if( !RpcLocalAutoBind() ) {                         \
                return FALSE;                                   \
            }                                                   \
        }                                                       \
        hServer = IcaApi_IfHandle;                              \
    }                                                           \
    if( hServer == RPC_HANDLE_NO_SERVER ) {                     \
        *pResult = ERROR_APP_WRONG_OS;                          \
        return FALSE;                                           \
    }

/******************************************************************************
 *
 *  ServerGetInternetConnectorStatus
 *
 *    Returns whether Internet Connector licensing is being used
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and pfEnabled contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is in pResult
 *
 ******************************************************************************/

BOOLEAN
ServerGetInternetConnectorStatus(
    HANDLE   hServer,
    DWORD    *pResult,
    PBOOLEAN pfEnabled
    )
{
    BOOLEAN rc = FALSE;

    if (pResult == NULL)
    {
        goto Done;
    }

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcServerGetInternetConnectorStatus(hServer,
                                                 pResult,
                                                 pfEnabled
                                                 );

        *pResult = RtlNtStatusToDosError( *pResult );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        *pResult = RpcExceptionCode();
    }
    RpcEndExcept

Done:
    return rc;
}

/******************************************************************************
 *
 *  ServerSetInternetConnectorStatus
 *
 *    This function will (if fEnabled has changed from its previous setting):
 *       Check that the caller has administrative privileges,
 *       Modify the corresponding value in the registry,
 *       Change licensing mode (between normal per-seat and Internet Connector.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is in pResult
 *
 ******************************************************************************/

BOOLEAN
ServerSetInternetConnectorStatus(
    HANDLE   hServer,
    DWORD    *pResult,
    BOOLEAN  fEnabled
    )
{
    BOOLEAN rc = FALSE;

    if (pResult == NULL)
    {
        goto Done;
    }

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcServerSetInternetConnectorStatus(hServer,
                                                 pResult,
                                                 fEnabled
                                                 );

        // STATUS_LICENSE_VIOLATION has no DOS error to map to
        if (*pResult != STATUS_LICENSE_VIOLATION)
            *pResult = RtlNtStatusToDosError( *pResult );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        *pResult = RpcExceptionCode();
    }
    RpcEndExcept

Done:
    return rc;
}

/*******************************************************************************
 *
 *  ServerQueryInetConnectorInformationA (ANSI stub)
 *
 *    Queries the server for internet connector configuration information.
 *
 * ENTRY:
 *
 *    see ServerQueryInetConnectorInformationW
 *
 * EXIT:
 *
 *    see ServerQueryInetConnectorInformationW
 *
 ******************************************************************************/

BOOLEAN
ServerQueryInetConnectorInformationA(
        HANDLE hServer,
        PVOID  pWinStationInformation,
        ULONG WinStationInformationLength,
        PULONG  pReturnLength
        )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

/*******************************************************************************
 *
 *  ServerQueryInetConnectorInformationW (UNICODE)
 *
 *    Queries the server for internet connector configuration information.
 *
 * ENTRY:
 *
 *    WinStationHandle (input)
 *       Identifies the window station object. The handle must have
 *       WINSTATION_QUERY access.
 *
 *    pWinStationInformation (output)
 *       A pointer to a buffer that will receive information about the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being queried.
 *
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 *    pReturnLength (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes placed in the window station information buffer.
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
ServerQueryInetConnectorInformationW(
        HANDLE hServer,
        PVOID  pWinStationInformation,
        ULONG WinStationInformationLength,
        PULONG  pReturnLength
        )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\client\lscore.c ===
/*
 *  LsCore.c
 *
 *  Author: BreenH
 *
 *  Client side functions to call the licensing core RPC interface.
 */

/*
 *  Includes
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsta.h>
#include <license.h>
#include "lcrpc.h"
#include "rpcwire.h"

/*
 *  External Globals and Function Prototypes
 */

extern RTL_CRITICAL_SECTION WstHandleLock;
extern LPWSTR pszOptions;
extern LPWSTR pszProtocolSequence;
extern LPWSTR pszRemoteProtocolSequence;

RPC_STATUS
RpcWinStationBind(
    LPWSTR pszUuid,
    LPWSTR pszProtocolSequence,
    LPWSTR pszNetworkAddress,
    LPWSTR pszEndPoint,
    LPWSTR pszOptions,
    RPC_BINDING_HANDLE *pHandle
    );

/*
 *  Internal Function Prototypes
 */

BOOLEAN
ConvertAnsiToUnicode(
    LPWSTR *ppUnicodeString,
    LPSTR pAnsiString
    );

BOOLEAN
ConvertUnicodeToAnsi(
    LPSTR *ppAnsiString,
    LPWSTR pUnicodeString
    );

BOOLEAN
ConvertPolicyInformationA2U(
    LPLCPOLICYINFOGENERIC *ppPolicyInfoW,
    LPLCPOLICYINFOGENERIC pPolicyInfoA
    );

BOOLEAN
ConvertPolicyInformationU2A(
    LPLCPOLICYINFOGENERIC *ppPolicyInfoA,
    LPLCPOLICYINFOGENERIC pPolicyInfoW
    );

BOOLEAN
LcRpcBindLocal(
    VOID
    );

/*
 *  Macros borrowed from winsta.c. RPC_HANDLE_NO_SERVER is not supported
 *  for the license core RPC calls. This means that no license core RPC call
 *  to the local machine will differentiate between "not a TS box" and "server
 *  not available".
 */

#define CheckLoaderLock() \
    ASSERT(NtCurrentTeb()->ClientId.UniqueThread != \
        ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread);

#define HANDLE_CURRENT_BINDING(hServer) \
    CheckLoaderLock(); \
    if (hServer == SERVERNAME_CURRENT) \
    { \
        if (LCRPC_IfHandle == NULL) \
        { \
            if (!LcRpcBindLocal()) \
            { \
                return(FALSE); \
            } \
        } \
        hServer = LCRPC_IfHandle; \
    }

/*
 *  Function Implementations
 */

BOOLEAN
ConvertAnsiToUnicode(
    LPWSTR *ppUnicodeString,
    LPSTR pAnsiString
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;
    ULONG cbAnsiString;
    ULONG cbBytesWritten;
    ULONG cbUnicodeString;

    ASSERT(ppUnicodeString != NULL);
    ASSERT(pAnsiString != NULL);

    cbAnsiString = lstrlenA(pAnsiString);

    Status = RtlMultiByteToUnicodeSize(
        &cbUnicodeString,
        pAnsiString,
        cbAnsiString
        );

    if (Status == STATUS_SUCCESS)
    {
        cbUnicodeString += sizeof(WCHAR);

        *ppUnicodeString = (LPWSTR)LocalAlloc(LPTR, cbUnicodeString);

        if (*ppUnicodeString != NULL)
        {
            Status = RtlMultiByteToUnicodeN(
                *ppUnicodeString,
                cbUnicodeString,
                &cbBytesWritten,
                pAnsiString,
                cbAnsiString
                );

            if (Status == STATUS_SUCCESS)
            {
                fRet = TRUE;
            }
            else
            {
                LocalFree(*ppUnicodeString);
                *ppUnicodeString = NULL;
                SetLastError(RtlNtStatusToDosError(Status));
                fRet = FALSE;
            }
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            fRet = FALSE;
        }
    }
    else
    {
        SetLastError(RtlNtStatusToDosError(Status));
        fRet = FALSE;
    }

    return(fRet);
}

BOOLEAN
ConvertUnicodeToAnsi(
    LPSTR *ppAnsiString,
    LPWSTR pUnicodeString
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;
    ULONG cbAnsiString;
    ULONG cbBytesWritten;
    ULONG cbUnicodeString;

    ASSERT(ppAnsiString != NULL);
    ASSERT(pUnicodeString != NULL);

    cbUnicodeString = lstrlenW(pUnicodeString) * sizeof(WCHAR);

    Status = RtlUnicodeToMultiByteSize(
        &cbAnsiString,
        pUnicodeString,
        cbUnicodeString
        );

    if (Status == STATUS_SUCCESS)
    {
        cbAnsiString += sizeof(CHAR);

        *ppAnsiString = (LPSTR)LocalAlloc(LPTR, cbAnsiString);

        if (*ppAnsiString != NULL)
        {
            Status = RtlUnicodeToMultiByteN(
                *ppAnsiString,
                cbAnsiString,
                &cbBytesWritten,
                pUnicodeString,
                cbUnicodeString
                );

            if (Status == STATUS_SUCCESS)
            {
                fRet = TRUE;
            }
            else
            {
                LocalFree(*ppAnsiString);
                *ppAnsiString = NULL;
                SetLastError(RtlNtStatusToDosError(Status));
                fRet = FALSE;
            }
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            fRet = FALSE;
        }
    }
    else
    {
        SetLastError(RtlNtStatusToDosError(Status));
        fRet = FALSE;
    }

    return(fRet);
}

BOOLEAN
ConvertPolicyInformationA2U(
    LPLCPOLICYINFOGENERIC *ppPolicyInfoW,
    LPLCPOLICYINFOGENERIC pPolicyInfoA
    )
{
    BOOLEAN fRet;

    ASSERT(ppPolicyInfoW != NULL);
    ASSERT(pPolicyInfoA != NULL);

    if (pPolicyInfoA->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        LPLCPOLICYINFO_V1W *ppPolicyInfoV1W;
        LPLCPOLICYINFO_V1A pPolicyInfoV1A;

        ppPolicyInfoV1W = (LPLCPOLICYINFO_V1W*)ppPolicyInfoW;
        pPolicyInfoV1A = (LPLCPOLICYINFO_V1A)pPolicyInfoA;

        *ppPolicyInfoV1W = LocalAlloc(LPTR, sizeof(LPLCPOLICYINFO_V1W));

        if (*ppPolicyInfoV1W != NULL)
        {
            (*ppPolicyInfoV1W)->ulVersion = LCPOLICYINFOTYPE_V1;

            fRet = ConvertAnsiToUnicode(
                &((*ppPolicyInfoV1W)->lpPolicyName),
                pPolicyInfoV1A->lpPolicyName
                );

            if (fRet)
            {
                fRet = ConvertAnsiToUnicode(
                    &((*ppPolicyInfoV1W)->lpPolicyDescription),
                    pPolicyInfoV1A->lpPolicyDescription
                    );
            }

            if (fRet)
            {
                goto exit;
            }

            if ((*ppPolicyInfoV1W)->lpPolicyName != NULL)
            {
                LocalFree((*ppPolicyInfoV1W)->lpPolicyName);
            }

            if ((*ppPolicyInfoV1W)->lpPolicyDescription != NULL)
            {
                LocalFree((*ppPolicyInfoV1W)->lpPolicyDescription);
            }

            LocalFree(*ppPolicyInfoV1W);
            *ppPolicyInfoV1W = NULL;
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            fRet = FALSE;
        }
    }
    else
    {
        SetLastError(ERROR_UNKNOWN_REVISION);
        fRet = FALSE;
    }

exit:
    return(fRet);
}

BOOLEAN
ConvertPolicyInformationU2A(
    LPLCPOLICYINFOGENERIC *ppPolicyInfoA,
    LPLCPOLICYINFOGENERIC pPolicyInfoW
    )
{
    BOOLEAN fRet;

    ASSERT(ppPolicyInfoA != NULL);
    ASSERT(pPolicyInfoW != NULL);

    if (pPolicyInfoW->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        LPLCPOLICYINFO_V1A *ppPolicyInfoV1A;
        LPLCPOLICYINFO_V1W pPolicyInfoV1W;

        ppPolicyInfoV1A = (LPLCPOLICYINFO_V1A*)ppPolicyInfoA;
        pPolicyInfoV1W = (LPLCPOLICYINFO_V1W)pPolicyInfoW;

        *ppPolicyInfoV1A = LocalAlloc(LPTR, sizeof(LPLCPOLICYINFO_V1W));

        if (*ppPolicyInfoV1A != NULL)
        {
            (*ppPolicyInfoV1A)->ulVersion = LCPOLICYINFOTYPE_V1;

            fRet = ConvertUnicodeToAnsi(
                &((*ppPolicyInfoV1A)->lpPolicyName),
                pPolicyInfoV1W->lpPolicyName
                );

            if (fRet)
            {
                fRet = ConvertUnicodeToAnsi(
                    &((*ppPolicyInfoV1A)->lpPolicyDescription),
                    pPolicyInfoV1W->lpPolicyDescription
                    );
            }

            if (fRet)
            {
                goto exit;
            }

            if ((*ppPolicyInfoV1A)->lpPolicyName != NULL)
            {
                LocalFree((*ppPolicyInfoV1A)->lpPolicyName);
            }

            if ((*ppPolicyInfoV1A)->lpPolicyDescription != NULL)
            {
                LocalFree((*ppPolicyInfoV1A)->lpPolicyDescription);
            }

            LocalFree(*ppPolicyInfoV1A);
            *ppPolicyInfoV1A = NULL;
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
            fRet = FALSE;
        }
    }
    else
    {
        SetLastError(ERROR_UNKNOWN_REVISION);
        fRet = FALSE;
    }

exit:
    return(fRet);
}

BOOLEAN
LcRpcBindLocal(
    VOID
    )
{
    //
    //  Borrow the TSRPC handle critical section.
    //

    RtlEnterCriticalSection(&WstHandleLock);

    if (LCRPC_IfHandle == NULL)
    {
        LCRPC_IfHandle = ServerLicensingOpenW(NULL);

        if (LCRPC_IfHandle == NULL)
        {
            SetLastError(RPC_S_INVALID_BINDING);
            RtlLeaveCriticalSection(&WstHandleLock);
            return(FALSE);
        }
    }

    RtlLeaveCriticalSection(&WstHandleLock);

    return(TRUE);
}

HANDLE WINAPI
ServerLicensingOpenW(
    LPWSTR pServerName
    )
{
    BOOLEAN fRet;
    HANDLE hServer;
    NTSTATUS Status;
    RPC_STATUS RpcStatus;
    RPC_BINDING_HANDLE RpcHandle;

    if (pServerName == NULL)
    {
        if (!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer)))
        {
            return(NULL);
        }

        RpcStatus = RpcWinStationBind(
            LC_RPC_UUID,
            pszProtocolSequence,
            NULL,
            LC_RPC_LRPC_EP,
            pszOptions,
            &RpcHandle
            );
    }
    else
    {
        RpcStatus = RpcWinStationBind(
            LC_RPC_UUID,
            pszRemoteProtocolSequence,
            pServerName,
            LC_RPC_NP_EP,
            pszOptions,
            &RpcHandle
            );
    }

    if (RpcStatus != RPC_S_OK)
    {
        SetLastError(RPC_S_SERVER_UNAVAILABLE);
        RpcBindingFree(&RpcHandle);
        return(NULL);
    }

    __try
    {
        hServer = NULL;

        fRet = RpcLicensingOpenServer(RpcHandle, &hServer, &Status);

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    RpcBindingFree(&RpcHandle);

    return(fRet ? hServer : NULL);
}

HANDLE WINAPI
ServerLicensingOpenA(
    LPSTR pServerName
    )
{
    BOOLEAN fRet;
    HANDLE hServer;
    LPWSTR pServerNameW;
    ULONG cchServerName;

    if (pServerName == NULL)
    {
        return(ServerLicensingOpenW(NULL));
    }

    fRet = ConvertAnsiToUnicode(&pServerNameW, pServerName);

    if (fRet)
    {
        hServer = ServerLicensingOpenW(pServerNameW);
        LocalFree(pServerNameW);
    }
    else
    {
        hServer = NULL;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(hServer);
}

VOID WINAPI
ServerLicensingClose(
    HANDLE hServer
    )
{
    //
    //  Don't try to close the define for the local server, and don't allow
    //  the auto-binding handle to be closed.
    //

    if ((hServer == SERVERNAME_CURRENT) || (hServer == LCRPC_IfHandle))
    {
        return;
    }

    __try
    {
        RpcLicensingCloseServer(&hServer);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
}

BOOLEAN WINAPI
ServerLicensingLoadPolicy(
    HANDLE hServer,
    ULONG ulPolicyId
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;

    HANDLE_CURRENT_BINDING(hServer);

    __try
    {
        fRet = RpcLicensingLoadPolicy(hServer, ulPolicyId, &Status);

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    return(fRet);
}

BOOLEAN WINAPI
ServerLicensingUnloadPolicy(
    HANDLE hServer,
    ULONG ulPolicyId
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;

    HANDLE_CURRENT_BINDING(hServer);

    __try
    {
        fRet = RpcLicensingUnloadPolicy(hServer, ulPolicyId, &Status);

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    return(fRet);
}

DWORD WINAPI
ServerLicensingSetPolicy(
    HANDLE hServer,
    ULONG ulPolicyId,
    LPDWORD lpNewPolicyStatus
    )
{
    BOOLEAN fRet;
    DWORD dwRet;
    NTSTATUS Status;
    NTSTATUS NewPolicyStatus;

    HANDLE_CURRENT_BINDING(hServer);

    if (lpNewPolicyStatus == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    __try
    {
        Status = RpcLicensingSetPolicy(hServer, ulPolicyId, &NewPolicyStatus);

        dwRet = RtlNtStatusToDosError(Status);
        *lpNewPolicyStatus = RtlNtStatusToDosError(NewPolicyStatus);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        dwRet = GetExceptionCode();
        *lpNewPolicyStatus = ERROR_SUCCESS;
    }

    return(dwRet);
}

BOOLEAN WINAPI
ServerLicensingGetAvailablePolicyIds(
    HANDLE hServer,
    PULONG *ppulPolicyIds,
    PULONG pcPolicies
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;

    HANDLE_CURRENT_BINDING(hServer);

    if ((ppulPolicyIds == NULL) || (pcPolicies == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    *pcPolicies = 0;

    __try
    {
        fRet = RpcLicensingGetAvailablePolicyIds(hServer, ppulPolicyIds, pcPolicies, &Status);

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    return(fRet);
}

BOOLEAN WINAPI
ServerLicensingGetPolicy(
    HANDLE hServer,
    PULONG pulPolicyId
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;

    HANDLE_CURRENT_BINDING(hServer);

    if (pulPolicyId == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    __try
    {
        fRet = RpcLicensingGetPolicy(hServer, pulPolicyId, &Status);

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    return(fRet);
}

BOOLEAN WINAPI
ServerLicensingGetPolicyInformationW(
    HANDLE hServer,
    ULONG ulPolicyId,
    PULONG pulVersion,
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    )
{
    BOOLEAN fRet;
    LPLCPOLICYINFOGENERIC pWire;
    NTSTATUS Status;
    ULONG cbPolicyInfo;

    HANDLE_CURRENT_BINDING(hServer);

    if ((ppPolicyInfo == NULL) || (pulVersion == NULL))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    *pulVersion = min(*pulVersion, LCPOLICYINFOTYPE_CURRENT);

    pWire = NULL;
    cbPolicyInfo = 0;

    __try
    {
        fRet = RpcLicensingGetPolicyInformation(
            hServer,
            ulPolicyId,
            pulVersion,
            (PCHAR*)&pWire,
            &cbPolicyInfo,
            &Status
            );

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    if (fRet)
    {
        fRet = CopyPolicyInformationFromWire(ppPolicyInfo, pWire);

        MIDL_user_free(pWire);
    }

    return(fRet);
}

BOOLEAN WINAPI
ServerLicensingGetPolicyInformationA(
    HANDLE hServer,
    ULONG ulPolicyId,
    PULONG pulVersion,
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    )
{
    BOOLEAN fRet;
    LPLCPOLICYINFOGENERIC pPolicyInfoW;
    NTSTATUS Status;

    if (ppPolicyInfo == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    pPolicyInfoW = NULL;

    fRet = ServerLicensingGetPolicyInformationW(
        hServer,
        ulPolicyId,
        pulVersion,
        &pPolicyInfoW
        );

    if (fRet)
    {
        fRet = ConvertPolicyInformationU2A(ppPolicyInfo, pPolicyInfoW);

        ServerLicensingFreePolicyInformation(&pPolicyInfoW);
    }

    return(fRet);
}

VOID
ServerLicensingFreePolicyInformation(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    )
{
    if ((ppPolicyInfo != NULL) && (*ppPolicyInfo != NULL))
    {
        if ((*ppPolicyInfo)->ulVersion == LCPOLICYINFOTYPE_V1)
        {
            LPLCPOLICYINFO_V1 pPolicyInfoV1 = (LPLCPOLICYINFO_V1)(*ppPolicyInfo);

            if (pPolicyInfoV1->lpPolicyName != NULL)
            {
                LocalFree(pPolicyInfoV1->lpPolicyName);
            }

            if (pPolicyInfoV1->lpPolicyDescription != NULL)
            {
                LocalFree(pPolicyInfoV1->lpPolicyDescription);
            }

            LocalFree(pPolicyInfoV1);
            pPolicyInfoV1 = NULL;
        }
    }
}

BOOLEAN WINAPI
ServerLicensingDeactivateCurrentPolicy(
    HANDLE hServer
    )
{
    BOOLEAN fRet;
    NTSTATUS Status;

    HANDLE_CURRENT_BINDING(hServer);

    __try
    {
        fRet = RpcLicensingDeactivateCurrentPolicy(hServer, &Status);

        if (!fRet)
        {
            SetLastError(RtlNtStatusToDosError(Status));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
        SetLastError(GetExceptionCode());
    }

    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\client\winbreak.c ===
/****************************************************************************/
// winbreak.c
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winsta.h>

int _cdecl
main (int argc, char *argv[])
{
    int i;
    ULONG LogonId = 0;
    HANDLE hServer = NULL;
    BOOLEAN KernelFlag = FALSE;

    if ( argc == 1 || argc == 2 && !strcmp( argv[1], "-?" ) ) {
	printf( "winbreak: WinStation breakpoint utility\n" );
	printf( "USAGE: winbreak [-k] [-s server] <logonid>\n" );
	printf( "  -k: for kernel breakpoint\n" );
        printf( "  -s: to specify server name\n" );
	return( 1 );
    }

    for ( i = 1; i < argc; i++ ) {
        if ( !strcmp( argv[i], "-s" ) ) {
            if ( i+1 >= argc ) {
                printf( "Server name expected after -s\n" );
                return( 1 );
            }
            hServer = WinStationOpenServerA( argv[++i] );
            if ( hServer == NULL ) {
                printf( "Unable to open server %s\n", argv[i] );
                return( 1 );
            }
        } else if ( !strcmp( argv[1], "-k" ) ) {
            KernelFlag = TRUE;
        } else if ( !strcmp( argv[1], "-2" ) ) {
            LogonId = (ULONG)-2;
        } else if ( isdigit( argv[i][0] ) ) {
            LogonId = atoi( argv[i] );
        } else {
            printf( "winbreak: WinStation breakpoint utility\n" );
            printf( "USAGE: winbreak [-k] [-s server] <logonid>\n" );
            printf( "  -k: for kernel breakpoint\n" );
            printf( "  -s: to specify server name\n" );
            return( 1 );
        }
    }

    _WinStationBreakPoint( hServer, LogonId, KernelFlag );

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\idl\sessdir\tssduuid.cpp ===
/****************************************************************************/
// tssduuid.c
//
// Terminal Server Session Directory (ITSSessionDirectory) UUID
// instantiations.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>

#define INITGUID
#include <ole2.h>
#include <objbase.h>
#include <comdef.h>

#include "itssd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\client\winsta.c ===
/*************************************************************************
*
* winsta.c
*
* Client side APIs for window stations objects
*
* Copyright Microsoft Corporation, 1998
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <allproc.h>

#include <winsta.h>
#include <winwlx.h>
#include <malloc.h>
#include <stdio.h>
#include <dbt.h>


/*
 * Include the RPC generated common header
 */

#include "tsrpc.h"

#include "rpcwire.h"

#ifdef NTSDDEBUG
#define NTSDDBGPRINT(x) DbgPrint x
#else
#define NTSDDBGPRINT(x)
#endif

#if DBG
#define VERIFY(x) ASSERT(x)     // we already have ASSERT;
#else
#define VERIFY(x) (x)
#endif


#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*
 * This handle is returned when there is no terminal
 * server present on the system. (Non-Hydra)
 */
#define RPC_HANDLE_NO_SERVER (HANDLE)IntToPtr( 0xFFFFFFFD )


/*
 *  Private Procedures defined here
 */

BOOLEAN DllInitialize(IN PVOID, IN ULONG, IN PCONTEXT OPTIONAL);

RPC_STATUS
RpcWinStationBind(
    LPWSTR pszUuid,
    LPWSTR pszProtocolSequence,
    LPWSTR pszNetworkAddress,
    LPWSTR pszEndPoint,
    LPWSTR pszOptions,
    RPC_BINDING_HANDLE *pHandle
    );

BOOLEAN
RpcLocalAutoBind(
    VOID
    );

/*
 *  Global data
 */

// Critical section to protect the handlelist from multiple threads
RTL_CRITICAL_SECTION   WstHandleLock;

/*
 * RPC program identifier and security options
 */
LPWSTR pszUuid = L"5ca4a760-ebb1-11cf-8611-00a0245420ed"; // From ICAAPI.IDL
LPWSTR pszOptions          = L"Security=Impersonation Dynamic False";

/*
 * RPC over LPC binding information
 */
LPWSTR pszProtocolSequence = L"ncalrpc";   // RPC over LPC
LPWSTR pszEndPoint         = L"IcaApi";

/*
 * RPC over named pipes binding information
 */
LPWSTR pszRemoteProtocolSequence = L"ncacn_np";   // RPC over Named pipes
LPWSTR pszRemoteEndPoint         = L"\\pipe\\Ctx_WinStation_API_service";


/*
 *  other internal Procedures used (not defined here)
 */
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );
VOID PdConfig2U2A( PPDCONFIG2A, PPDCONFIG2W );
VOID PdConfig2A2U( PPDCONFIG2W, PPDCONFIG2A );
VOID PdParamsU2A( PPDPARAMSA, PPDPARAMSW );
VOID PdParamsA2U( PPDPARAMSW, PPDPARAMSA );
VOID WdConfigU2A( PWDCONFIGA, PWDCONFIGW );
VOID WdConfigA2U( PWDCONFIGW, PWDCONFIGA );
VOID WinStationCreateU2A( PWINSTATIONCREATEA, PWINSTATIONCREATEW );
VOID WinStationCreateA2U( PWINSTATIONCREATEW, PWINSTATIONCREATEA );
VOID WinStationConfigU2A( PWINSTATIONCONFIGA, PWINSTATIONCONFIGW );
VOID WinStationConfigA2U( PWINSTATIONCONFIGW, PWINSTATIONCONFIGA );
VOID WinStationPrinterU2A( PWINSTATIONPRINTERA, PWINSTATIONPRINTERW );
VOID WinStationPrinterA2U( PWINSTATIONPRINTERW, PWINSTATIONPRINTERA );
VOID WinStationInformationU2A( PWINSTATIONINFORMATIONA,
                               PWINSTATIONINFORMATIONW );
VOID WinStationInformationA2U( PWINSTATIONINFORMATIONW,
                               PWINSTATIONINFORMATIONA );
VOID WinStationClientU2A( PWINSTATIONCLIENTA, PWINSTATIONCLIENTW );
VOID WinStationProductIdU2A( PWINSTATIONPRODIDA, PWINSTATIONPRODIDW );

ULONG CheckUserBuffer(WINSTATIONINFOCLASS,
                      PVOID,
                      ULONG,
                      PVOID *,
                      PULONG,
                      BOOLEAN *);
BOOLEAN CloseContextHandle(HANDLE *pHandle, DWORD *pdwResult);

/*
 * Check to see that caller does not hold the loader critsec.
 * WinStation APIs must NOT be called while holding the loader critsec
 * since deadlock may occur.
 */
#define CheckLoaderLock() \
        ASSERT( NtCurrentTeb()->ClientId.UniqueThread != \
            ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread );


/*
 * Handle the SERVERNAME_CURRENT for auto local binding.
 */
#define HANDLE_CURRENT_BINDING( hServer )                       \
    CheckLoaderLock();                                          \
    if( hServer == SERVERNAME_CURRENT ) {                       \
        if( IcaApi_IfHandle == NULL ) {                         \
            if( !RpcLocalAutoBind() ) {                         \
                return FALSE;                                   \
            }                                                   \
        }                                                       \
        hServer = IcaApi_IfHandle;                              \
    }                                                           \
    if( hServer == RPC_HANDLE_NO_SERVER ) {                     \
        SetLastError( ERROR_APP_WRONG_OS );                     \
        return FALSE;                                           \
    }


#define HANDLE_CURRENT_BINDING_BUFFER( hServer, pBuffer )       \
    CheckLoaderLock();                                          \
    if( hServer == SERVERNAME_CURRENT ) {                       \
        if( IcaApi_IfHandle == NULL ) {                         \
            if( !RpcLocalAutoBind() ) {                         \
                if (pBuffer != NULL) {                          \
                    LocalFree(pBuffer);                         \
                }                                               \
                return FALSE;                                   \
            }                                                   \
        }                                                       \
        hServer = IcaApi_IfHandle;                              \
    }                                                           \
    if( hServer == RPC_HANDLE_NO_SERVER ) {                     \
        if (pBuffer != NULL) {                                  \
            LocalFree(pBuffer);                                 \
        }                                                       \
        SetLastError( ERROR_APP_WRONG_OS );                     \
        return FALSE;                                           \
    }


/*
 * Handle the SERVERNAME_CURRENT for auto local binding that
 * allows the RPC_HANDLE_NO_SERVER handle.
 */
#define HANDLE_CURRENT_BINDING_NO_SERVER( hServer )             \
    CheckLoaderLock();                                          \
    if( hServer == SERVERNAME_CURRENT ) {                       \
        if( IcaApi_IfHandle == NULL ) {                         \
            if( !RpcLocalAutoBind() ) {                         \
                return FALSE;                                   \
            }                                                   \
        }                                                       \
        hServer = IcaApi_IfHandle;                              \
    }




/****************************************************************************
 *
 * DllInitialize
 *
 *   Function is called when the DLL is loaded. The only work we do here
 *   is initialize our CriticalSection.
 *
 * ENTRY:
 *
 *   DllHandle
 *     Loaded handle to our DLL image
 *
 *   Reason
 *     Reason for notifying us
 *
 *   Context
 *     Reason specific parameter from NT
 *
 ****************************************************************************/

BOOLEAN
DllInitialize(
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )
{

    BOOLEAN rc;
    DWORD Result;
    RPC_STATUS Status;
    BOOLEAN Success;
    NTSTATUS ntStatus;
    static BOOLEAN sbIniOK = FALSE;

    (VOID)Context;

    Success = TRUE;

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:


/*       
        // some instrumentation for catching the bug #
        // 145378   TRACKING: Winsta.dll getting loaded into csrss

        DBGPRINT(("Checking if winsta is being loaded into csrss.exe\n"));
        if(NULL != wcsstr(GetCommandLine(), TEXT("csrss.exe")))
        {
            DBGPRINT(("**** will break because csrss.exe loaded winsta.dll ***** \n"));
            DebugBreak();
        }
*/
        ntStatus = RtlInitializeCriticalSection( &WstHandleLock );
        IcaApi_IfHandle = NULL;
        if (!NT_SUCCESS(ntStatus)) {
           Success = FALSE;
        }else {
           sbIniOK = TRUE;
        }
        break;

    case DLL_PROCESS_DETACH:
        
        if (sbIniOK) {
            
            if( (IcaApi_IfHandle != NULL) && (IcaApi_IfHandle != RPC_HANDLE_NO_SERVER) ) 
            {
                HANDLE hTmp = InterlockedExchangePointer(&IcaApi_IfHandle,NULL);
                if( hTmp && !IcaApi_IfHandle ) 
                {
                    CloseContextHandle(&hTmp, &Result); 
                }
            }

           RtlDeleteCriticalSection( &WstHandleLock );        
        }

        break;

    default:
        break;
    }

    return Success;

}

/*****************************************************************************
 *
 *  RpcWinStationBind
 *
 *   Perform the RPC binding sequence.
 *
 *   This is an internal function.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

RPC_STATUS
RpcWinStationBind(
    LPWSTR pszUuid,
    LPWSTR pszProtocolSequence,
    LPWSTR pszNetworkAddress,
    LPWSTR pszEndPoint,
    LPWSTR pszOptions,
    RPC_BINDING_HANDLE *pHandle
    )
{
    RPC_STATUS Status;
    LPWSTR pszString = NULL;

    /*
     * Compose the binding string using the helper routine
     * and our protocol sequence, security options, UUID, etc.
     */
    Status = RpcStringBindingCompose(
                 pszUuid,
                 pszProtocolSequence,
                 pszNetworkAddress,
                 pszEndPoint,
                 pszOptions,
                 &pszString
                 );

    if( Status != RPC_S_OK ) {
        DBGPRINT(("Error %d in RpcStringBindingCompose\n",Status));
        return( Status );
    }

    /*
     * Now generate the RPC binding from the cononical RPC
     * binding string.
     */
    Status = RpcBindingFromStringBinding(
                 pszString,
                 pHandle
                 );

    if( Status != RPC_S_OK ) {
        DBGPRINT(("Error %d in RpcBindingFromStringBinding\n",Status));
        RpcStringFree( &pszString );
        return( Status );
    }

    /*
     * Free the memory returned from RpcStringBindingCompose()
     */
    RpcStringFree( &pszString );

    return( Status );
}

/*****************************************************************************
 *
 *  WinStationOpenLocalServer (Private)
 *
 *   Connect to the local RPC over LPC server for WINSTATION API's.
 *
 *   On non-terminal server machines, it returns a handle that allows
 *   a subset of the DLL's functions to operate locally.
 *
 * ENTRY:
 *
 * EXIT:
 *
 ****************************************************************************/

HANDLE WINAPI
WinStationOpenLocalServer(
    )
{
    RPC_STATUS Status;
    DWORD      Result;
    BOOLEAN    rc;
    RPC_BINDING_HANDLE RpcHandle;
    HANDLE             ContextHandle;

    if( !(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer)) ) {
        return( RPC_HANDLE_NO_SERVER );
    }

    /*
     * Do the RPC bind to the local server.
     *
     * We use explict binding handles since we want
     * to allow a single application to talk to multiple
     * WinFrame servers at a time.
     *
     * NOTE: We use the auto handle from the .ACF file
     *       for our local connections.
     */
    Status = RpcWinStationBind(
                 pszUuid,
                 pszProtocolSequence,
                 NULL,     // ServerName
                 pszEndPoint,
                 pszOptions,
                 &RpcHandle
                 );

    if( Status != RPC_S_OK ) {
        SetLastError( RtlNtStatusToDosError(RPC_NT_SERVER_UNAVAILABLE) );
        return( NULL );
    }

    //
    // Get a context handle from the server so it can
    // manage the connections state
    //
    // NOTE: This can fail due to authentication failure.
    //
    RpcTryExcept {
        rc = RpcWinStationOpenServer( RpcHandle, &Result, &ContextHandle );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        rc = FALSE;
#if DBG
        if ( Result != RPC_S_SERVER_UNAVAILABLE ) {
            DBGPRINT(("RPC Exception %d\n",Result));
        }
#endif
    }
    RpcEndExcept

    if( rc ) {
        //
        // Close the server binding handle now that we
        // have a client specific context handle
        //
        RpcBindingFree( &RpcHandle );

        return( (HANDLE)ContextHandle );
    }
    else {
#if DBG
        if ( Result != RPC_S_SERVER_UNAVAILABLE ) {
            DBGPRINT(("WinStationOpenLocalServer: Error %d getting context handle\n",Result));
        }
#endif
        
        RpcBindingFree( &RpcHandle );

        SetLastError( Result );
        return( NULL );
    }
}

/*****************************************************************************
 *
 *  RpcLocalAutoBind
 *
 *   Handle auto binding to the local server.
 *
 * ENTRY:
 *
 * EXIT:
 *   TRUE - Success
 *   FALSE - Error, Use GetLastError() to retrieve reason.
 *
 ****************************************************************************/

BOOLEAN
RpcLocalAutoBind(void)
{
    if( IcaApi_IfHandle == NULL ) {
        
        DWORD Result;
        HANDLE hTmp = WinStationOpenLocalServer();

        if( hTmp == NULL ) {
            SetLastError( RPC_S_INVALID_BINDING );
            return( FALSE );
        }

        InterlockedCompareExchangePointer(&IcaApi_IfHandle,hTmp,NULL);

        if(IcaApi_IfHandle != hTmp) {
            CloseContextHandle(&hTmp, &Result); 
        }
    }
    
    return( TRUE );
}

/*****************************************************************************
 *
 *  WinStationOpenServerA
 *
 *   Connect to a WinFrame computer in order to issue
 *   ICA API's
 *
 *   NULL for machine name means local system.
 *
 * ENTRY:
 *   Machine (input)
 *     Name of WinFrame computer to connect to
 *
 * EXIT:
 *   handle to server (or NULL on error)
 *
 ****************************************************************************/

HANDLE WINAPI
WinStationOpenServerA(
    LPSTR pServerName
    )
{
    HANDLE hServer;
    ULONG NameLength;
    PWCHAR pServerNameW = NULL;

    if( pServerName == NULL ) {
        return( WinStationOpenServerW( NULL ) );
    }

    NameLength = strlen( pServerName ) + 1;

    pServerNameW = LocalAlloc( 0, NameLength * sizeof(WCHAR) );
    if( pServerNameW == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( NULL );
    }

    AnsiToUnicode( pServerNameW, NameLength*sizeof(WCHAR), pServerName );

    hServer = WinStationOpenServerW( pServerNameW );

    LocalFree( pServerNameW );

    return( hServer );
}

/*****************************************************************************
 *
 *  WinStationOpenServerW
 *
 *   Connect to a WinFrame computer in order to issue
 *   ICA API's
 *
 *   NULL for machine name means local system.
 *
 * ENTRY:
 *   Machine (input)
 *     Name of WinFrame computer to connect to
 *
 * EXIT:
 *   handle to server (or NULL on error)
 *
 ****************************************************************************/

HANDLE WINAPI
WinStationOpenServerW(
    LPWSTR pServerName
    )
{
    DWORD      Result;
    BOOLEAN    rc;
    RPC_STATUS Status;
    RPC_BINDING_HANDLE RpcHandle;
    HANDLE             ContextHandle;

    /*
     * If the server name is NULL, attempt to open
     * the local machines ICA server over LPC.
     */
    if( pServerName == NULL ) {
        return( WinStationOpenLocalServer() );
    }

    /*
     * Do the RPC bind to the server.
     *
     * We use explict binding handles since we want
     * to allow a single application to talk to multiple
     * WinFrame servers at a time.
     */
    Status = RpcWinStationBind(
                 pszUuid,
                 pszRemoteProtocolSequence,
                 pServerName,
                 pszRemoteEndPoint,
                 pszOptions,
                 &RpcHandle
                 );

    if( Status != RPC_S_OK ) {
        SetLastError( RtlNtStatusToDosError(RPC_NT_SERVER_UNAVAILABLE) );
        return( NULL );
    }

    //
    // Get a context handle from the server so it can
    // manage the connections state
    //
    // NOTE: This can fail due to authentication failure.
    //
    RpcTryExcept {
        rc = RpcWinStationOpenServer( RpcHandle, &Result, &ContextHandle );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        rc = FALSE;
        DBGPRINT(("RPC Exception %d\n",Result));
    }
    RpcEndExcept

    if( rc ) {
        //
        // Close the server binding handle now that we
        // have a client specific context handle
        //
        RpcBindingFree( &RpcHandle );
            
        return( (HANDLE)ContextHandle );
    }
    else {
        DBGPRINT(("WinStationOpenServerW: Error %d getting context handle\n",Result));
        SetLastError( Result );
        return( NULL );
    }
}

/*****************************************************************************
 *
 *  WinStationCloseServer
 *
 *   Close a connection to a WinFrame computer.
 *
 * ENTRY:
 *   hServer (input)
 *     Handle to close
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
WinStationCloseServer(
    HANDLE hServer
    )
{
    BOOLEAN    rc;
    DWORD      Result;
    //
    // Do not close the implicit handles
    //
    if( (hServer == IcaApi_IfHandle) ||
        (hServer == RPC_HANDLE_NO_SERVER) ) {
        return( TRUE );
    }

    //
    // Send the close to the remote side so it clean
    // cleanup its context
    //
    rc = CloseContextHandle(&hServer, &Result);

    if( rc ) {
        return( TRUE );
    }
    else {
        DBGPRINT(("WinStationCloseServer: Error %d closing context handle\n",Result));
        SetLastError( Result );
        return( FALSE );
    }
}

/*****************************************************************************
 *
 *  MIDL_user_allocate
 *
 *    Handles RPC's allocation of argument data structures
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

void __RPC_FAR * __RPC_USER
MIDL_user_allocate(
    size_t Size
    )
{
    return( LocalAlloc(LMEM_FIXED,Size) );
}

/*****************************************************************************
 *
 *  MIDL_user_allocate
 *
 *    Handles RPC's de-allocation of argument data structures
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

void __RPC_USER
MIDL_user_free(
    void __RPC_FAR *p
    )
{
    LocalFree( p );
}

/*****************************************************************************
 *
 *  WinStationServerPing
 *
 *   Ping the given WinFrame server handle to see if it is still up.
 *
 * ENTRY:
 *   hServer (input)
 *    Open RPC server handle
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
WinStationServerPing(
    HANDLE hServer
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    /*
     * Do the RPC
     *
     * NOTE: This must be done under an RPC exception handler,
     *       since the RPC runtime code throws exceptions if
     *       network errors occur, or the server can not be
     *       reached.
     */
    RpcTryExcept {

        rc = RpcIcaServerPing(
                     hServer,
                     &Result
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);

        TRACE0(("RpcIcaServerPing rc 0x%x, Result 0x%x\n",rc, Result));
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationEnumerateA (ANSI stub)
 *
 *     Returns a list of window station objects.
 *
 * ENTRY:
 *
 *    see WinStationEnumerateW
 *
 * EXIT:
 *
 *    see WinStationEnumerateW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationEnumerateA(
        HANDLE  hServer,
        PLOGONIDA  *ppLogonId,
        PULONG  pEntries
        )
{
    PLOGONIDW pLogonIdW, pLogonIdBaseW;
    PLOGONIDA pLogonIdA;
    BOOLEAN Status;
    ULONG Count;

    /*
     * Call UNICODE WinStationEnumerateW first.
     */
    *pEntries = 0;
    *ppLogonId = NULL;
    Status = WinStationEnumerateW( hServer, &pLogonIdBaseW, &Count );
    if ( !Status )
        goto badenumerate;

    /*
     * Allocate buffer and perform conversion from UNICODE to ANSI.
     */
    if ( !(pLogonIdA = (PLOGONIDA)LocalAlloc( 0, Count * sizeof(LOGONIDA) )) ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        Status = FALSE;
        goto nomemory;
    }

    *pEntries = Count;
    *ppLogonId = pLogonIdA;

    for ( pLogonIdW = pLogonIdBaseW; Count; Count-- ) {

        pLogonIdA->LogonId = pLogonIdW->LogonId;

        UnicodeToAnsi( pLogonIdA->WinStationName,
                       sizeof(WINSTATIONNAMEA),
                       pLogonIdW->WinStationName );

        pLogonIdA->State = pLogonIdW->State;

        pLogonIdA++;
        pLogonIdW++;
    }

nomemory:
    /*
     * Free the UNICODE enumerate buffer.
     */
    WinStationFreeMemory( pLogonIdBaseW );

badenumerate:
    return(Status);
}

/*******************************************************************************
 *
 *  WinStationEnumerateW (UNICODE)
 *
 *     Returns a list of window station objects.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    ppLogonId (output)
 *       Points to a pointer to a buffer to receive the enumeration results,
 *       which are returned as an array of LOGONID structures.  The buffer is
 *       allocated within this API and is disposed of using
 *       WinStationFreeMemory.
 *    pEntries (output)
 *       Points to a variable specifying the number of entries read.
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationEnumerateW(
        HANDLE  hServer,
        PLOGONIDW  *ppLogonId,
        PULONG  pEntries
        )
{
    DWORD Result;
    BOOLEAN rc;
    ULONG LogonIdCount = 50;
    PLOGONIDW pLogonId, pLogonIdTemp;
    ULONG Length;
    ULONG Index = 0;
    ULONG ByteCount = 0;

    HANDLE_CURRENT_BINDING( hServer );

    *pEntries = 0;
    *ppLogonId = NULL;
    Length = LogonIdCount * sizeof(LOGONIDW);
    if ( !(pLogonId = (PLOGONIDW)LocalAlloc( 0, Length)) ) {
        Result = ERROR_NOT_ENOUGH_MEMORY;
        goto nomemexit;
    }

    /*
     *  get list of all WinStations
     */
    for (;;) {

        if ( Index ) {

           ByteCount = *pEntries * sizeof(LOGONIDW);
           *pEntries += LogonIdCount;
           if ( !(pLogonIdTemp = (PSESSIONIDW)LocalAlloc( 0,
                                            (*pEntries * sizeof(LOGONIDW)))) ) {

               Result = ERROR_NOT_ENOUGH_MEMORY;
               goto errexit;
           }

           if ( *ppLogonId ) {

               MoveMemory( pLogonIdTemp, *ppLogonId, ByteCount );
               LocalFree(*ppLogonId);
           }

           MoveMemory( ((PBYTE)pLogonIdTemp + ByteCount), pLogonId,
                       (LogonIdCount * sizeof(LOGONIDW)) );
           *ppLogonId = pLogonIdTemp;
        }

        RpcTryExcept {

            rc = RpcWinStationEnumerate(
                         hServer,
                         &Result,
                         &LogonIdCount,
                         (PCHAR)pLogonId,
                         &Length,
                         &Index
                         );

            Result = RtlNtStatusToDosError( Result );
            if ( Result == ERROR_NO_MORE_ITEMS) {
                Result = ERROR_SUCCESS;
                break;
            }
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            Result = RpcExceptionCode();
            DBGPRINT(("RPC Exception %d\n",Result));
            goto nomemexit;
        }
        RpcEndExcept
    }

errexit:
    LocalFree( pLogonId );

nomemexit:
    if ( Result ) {

        if ( *ppLogonId ) {

            LocalFree( *ppLogonId );
            *ppLogonId = NULL;
        }

        SetLastError(Result);
        return(FALSE);

    } else {

        return(TRUE);
    }
}


/*******************************************************************************
 *
 *  WinStationEnumerate_IndexedA (ANSI stub)
 *
 *     Returns a list of window station objects (multi-call indexed).
 *
 *     NOTE: this API used to be WinStationEnumerateA in WinFrame 1.6 and
 *           earlier.  It is provided now for backward compatibility with
 *           Citrix code built around the indexed enumeration procedure.
 *           New code should use the WinStationEnumerateA call.
 *
 * ENTRY:
 *
 *    see WinStationEnumerate_IndexedW
 *
 * EXIT:
 *
 *    see WinStationEnumerate_IndexedW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationEnumerate_IndexedA(
        HANDLE  hServer,
        PULONG  pEntries,
        PLOGONIDA  pLogonId,
        PULONG  pByteCount,
        PULONG  pIndex
        )
{
    PLOGONIDW pBuffer = NULL, pLogonIdW;
    BOOLEAN Status;
    ULONG Count, ByteCountW = (*pByteCount << 1);

    /*
     * If the caller supplied a buffer and the length is not 0,
     * allocate a corresponding (*2) buffer for UNICODE strings.
     */
    if ( pLogonId && ByteCountW ) {
        if ( !(pBuffer = LocalAlloc(0, ByteCountW)) ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(FALSE);
        }
    }

    /*
     * Enumerate WinStations
     */
    pLogonIdW = pBuffer;
    Status = WinStationEnumerate_IndexedW( hServer, pEntries, pLogonIdW,
                                           &ByteCountW, pIndex );

    /*
     * Always /2 the resultant ByteCount (whether sucessful or not).
     */
    *pByteCount = (ByteCountW >> 1);

    /*
     * If the function completed sucessfully and caller
     * (and stub) defined a buffer to copy into, perform conversion
     * from UNICODE to ANSI.
     */
    if ( Status && pLogonIdW && pLogonId ) {

        for ( Count = *pEntries; Count; Count-- ) {

            pLogonId->LogonId = pLogonIdW->LogonId;

            UnicodeToAnsi( pLogonId->WinStationName,
                           sizeof(WINSTATIONNAMEA),
                           pLogonIdW->WinStationName );

            pLogonId->State = pLogonIdW->State;

            (char*)pLogonId += sizeof(LOGONIDA);
            (char*)pLogonIdW += sizeof(LOGONIDW);
        }
    }

    /*
     * If we defined a buffer, free it now, then return the status of
     * the WinStationEnumerateW call.
     */
    if ( pBuffer )
        LocalFree(pBuffer);

    return(Status);
}


/*******************************************************************************
 *
 *  WinStationEnumerate_IndexedW (UNICODE)
 *
 *     Returns a list of window station objects (multi-call indexed).
 *
 *     NOTE: this API used to be WinStationEnumerateW in WinFrame 1.6 and
 *           earlier.  It is provided now for backward compatibility with
 *           Citrix code built around the indexed enumeration procedure.
 *           New code should use the WinStationEnumerateW call.
 *
 * ENTRY:
 *
 *    pEntries (input/output)
 *       Points to a variable specifying the number of entries requested.
 *       If the number requested is 0xFFFFFFFF, the function returns as
 *       many entries as possible. When the function finishes successfully,
 *       the variable pointed to by the pEntries parameter contains the
 *       number of entries actually read.
 *
 *    pLogonId (output)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of LOGONID structures.  If the window
 *       station is disconnected the name is null.
 *
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pLogonId parameter. If the buffer is too small to receive even
 *       one entry, this variable receives the required size of the buffer.
 *
 *    pIndex (input/output)
 *       Points to a ULONG that specifies where to start the enumeration.
 *       The only user visible value is 0, for starting at the begining.
 *       Each call will update this so that the next call will return the
 *       next WinStation in the list, till end of list.
 *       The user should not interpret, or use the internal values, other
 *       than the special case 0.
 *
 * EXIT:
 *
 *    TRUE  - The enumeration succeeded, and the buffer contains the
 *            requested data. The calling application can continue to call
 *            the WinStationEnumerate function to complete the enumeration.
 *
 *    FALSE - The operation failed.  Extended error status is available using
 *            GetLastError. Possible return values from GetLastError include
 *            the following:
 *
 *            ERROR_NO_MORE_ITEMS - There are no more entries. The buffer
 *                                  contents are undefined.
 *            ERROR_MORE_DATA     - The buffer is too small for even one entry.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationEnumerate_IndexedW(
        HANDLE  hServer,
        PULONG  pEntries,
        PLOGONIDW  pLogonId,
        PULONG  pByteCount,
        PULONG  pIndex
        )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationEnumerate(
                     hServer,
                     &Result,
                     pEntries,
                     (PCHAR)pLogonId,
                     pByteCount,
                     pIndex
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationGetAllProcesses (UNICODE)
 *
 *     Returns a structure containing TS_SYS_PROCESS_INFORMATION structures
 *     for each process on the specified server.
 *
 * ENTRY:
 *
 * EXIT:
 *    TRUE  - The enumeration succeeded, and the buffer contains the
 *            requested data.
 *    FALSE - The operation failed.  Extended error status is available using
 *            GetLastError.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationGetAllProcesses(
                          HANDLE    hServer,
                          ULONG     Level,
                          ULONG    *pNumberOfProcesses,
                          PVOID    *ppProcessArray
                          )
{
    BOOLEAN       bGetAllProcessesOk = FALSE;
    DWORD         dwResult;

    if (Level != GAP_LEVEL_BASIC)
    {
            dwResult = RtlNtStatusToDosError( STATUS_NOT_IMPLEMENTED );
            SetLastError(dwResult);
            return FALSE;
    }

    HANDLE_CURRENT_BINDING( hServer );

    // The Win2K server uses PTS_ALL_PROCESSES_INFO structure for the process information. 
    // And the whistler server uses PTS_SYS_PROCESS_INFORMATION_NT6 structure for the same.
    // So, we have to try two different RPC APIs. Assume initially that the server is a 
    // Whistler server and use RpcWinStationGetAllProcesses_NT6. If it is Win2K server, this
    // call will fail, because this API does not exist on Win2K server. In that case we will 
    // use RpcWinStationGetAllProcesses.

    // Try out Whistler interface first.

    RpcTryExcept {
        bGetAllProcessesOk = RpcWinStationGetAllProcesses_NT6(hServer,
                                                         (ULONG *)&dwResult,
                                                         Level,
                                                         pNumberOfProcesses,
                                                         (PTS_ALL_PROCESSES_INFO_NT6 *)ppProcessArray);
        if( !bGetAllProcessesOk )
        {
            dwResult = RtlNtStatusToDosError( dwResult );
            SetLastError(dwResult);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        dwResult = RpcExceptionCode();
        if (dwResult == RPC_S_PROCNUM_OUT_OF_RANGE) {
			// Whistler interface failed.
			goto TryW2KInterface;
        }
        SetLastError( dwResult );
        DBGPRINT(("RPC Exception %d\n",dwResult));
        bGetAllProcessesOk = FALSE;
    }
    RpcEndExcept

    return( bGetAllProcessesOk );

TryW2KInterface:
    // Try out Win2K interface now.
    RpcTryExcept {
        bGetAllProcessesOk = RpcWinStationGetAllProcesses(hServer,
                                                         (ULONG *)&dwResult,
                                                         Level,
                                                         pNumberOfProcesses,
                                                         (PTS_ALL_PROCESSES_INFO *)ppProcessArray);
        if( !bGetAllProcessesOk )
        {
            dwResult = RtlNtStatusToDosError( dwResult );
            SetLastError(dwResult);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        dwResult = RpcExceptionCode();
        SetLastError( dwResult );
        DBGPRINT(("RPC Exception %d\n",dwResult));
        bGetAllProcessesOk = FALSE;
    }
    RpcEndExcept

    return( bGetAllProcessesOk );
}


/*******************************************************************************
 *  WinStationGetProcessSid()
 *  username for the requested process
 *  For identifying correct process processid and start
 *  time are required
 *
 *  hServer         - input, Handle of the server to find info about,
 *                    if NULL use local.
 *  ProcessId       - input, ProcessID
 *  ProcessStartTime- input, Process start time, (identifies unique process
 *                    together with ProcessID)
 *  pProcessUserSid - output, process user sid
 *  dwSidSize       - input, memory allocated for pProcessUserSid
 *
 *  returns TURE if succeeded, FALSE if failed. in case of failure
 *  GetLastError() will gives more infromation about failure.
 *
 ******************************************************************************/
BOOLEAN WINAPI
WinStationGetProcessSid(
        HANDLE   hServer,
        DWORD    ProcessId,
        FILETIME ProcessStartTime,
        PBYTE    pProcessUserSid,
        DWORD    *pdwSidSize
        )
{
    BOOLEAN         rc;
    LARGE_INTEGER   CreateTime;
    DWORD           Result;
    NTSTATUS        Status;


    HANDLE_CURRENT_BINDING( hServer );

    CreateTime.LowPart  = ProcessStartTime.dwLowDateTime;
    CreateTime.HighPart = ProcessStartTime.dwHighDateTime;

    RpcTryExcept
    {
        rc = RpcWinStationGetProcessSid(
            hServer,
            ProcessId,
            CreateTime,
            &Status,
            pProcessUserSid,
            *pdwSidSize,
            pdwSidSize
            );

        if( !rc )
        {
            Result = RtlNtStatusToDosError( Status );
            SetLastError(Result);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        Result = RpcExceptionCode();
        SetLastError(Result);
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept


    return( rc );
}

/*******************************************************************************
 *
 *  WinStationGetLanAdapterNameW (UNICODE)
 *
 *     Returns a Network Adapter name
 *
 * ENTRY:
 *
 * EXIT:
 *    TRUE  - The Query succeeded, and the buffer contains the
 *            requested data.
 *    FALSE - The operation failed.  Extended error status is available using
 *            GetLastError.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationGetLanAdapterNameW(
                          HANDLE    hServer,
                          ULONG     LanAdapter,
                                                  ULONG     pdNameLength,
                          PWCHAR  pPdName,
                          ULONG   *pLength,
                          PWCHAR  *ppLanAdapter
                         )
{
    BOOLEAN       bGetLanAdapter = FALSE;
    DWORD         dwResult;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept
    {
        bGetLanAdapter =  RpcWinStationGetLanAdapterName(hServer,
                                                         &dwResult,
                                                         pdNameLength,
                                                         pPdName,
                                                         LanAdapter,
                                                         pLength,
                                                         ppLanAdapter
                                                         );

        if( !bGetLanAdapter )
        {
            dwResult = RtlNtStatusToDosError( dwResult );
            SetLastError(dwResult);
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwResult = RpcExceptionCode();
        SetLastError( dwResult );
        DBGPRINT(("RPC Exception %d\n",dwResult));
        bGetLanAdapter = FALSE;
    }
    RpcEndExcept

    return( bGetLanAdapter );
}

/*******************************************************************************
 *
 *  WinStationGetLanAdapterNameA
 *
 *     Returns a Network Adapter name - Ansi equivalent for WinStationGetLanAdapterNameW
 *
 * ENTRY:
 *
 * EXIT:
 *    TRUE  - The Query succeeded, and the buffer contains the
 *            requested data.
 *    FALSE - The operation failed.  Extended error status is available using
 *            GetLastError.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationGetLanAdapterNameA(
                          HANDLE    hServer,
                          ULONG     LanAdapter,
                                                  ULONG     pdNameLength,
                          PCHAR  pPdName,
                          ULONG   *pLength,
                          PCHAR  *ppLanAdapter
                         )
{
    BOOLEAN  bGetLanAdapter = FALSE;
    PWCHAR pPdNameW = NULL;
    PWCHAR pLanAdapterW = NULL;
    ULONG Size = 0;


    *ppLanAdapter = NULL;
    *pLength = 0;

        pPdNameW = LocalAlloc(0,pdNameLength * sizeof(WCHAR));
    if (NULL == pPdNameW)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    AnsiToUnicode(pPdNameW, pdNameLength * sizeof(WCHAR), pPdName );

    bGetLanAdapter =  WinStationGetLanAdapterNameW(hServer,LanAdapter,pdNameLength * sizeof(WCHAR),pPdNameW,&Size,&pLanAdapterW);
    if(bGetLanAdapter )
    {
        *ppLanAdapter = LocalAlloc(0,lstrlen(pLanAdapterW) + 1);
        if(NULL == *ppLanAdapter)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            bGetLanAdapter = FALSE;

        }
        else
        {
            UnicodeToAnsi(*ppLanAdapter,lstrlen(pLanAdapterW) + 1,pLanAdapterW);
            *pLength = lstrlen(pLanAdapterW) + 1;
        }
        WinStationFreeMemory(pLanAdapterW);


    }

    LocalFree(pPdNameW);

    return( bGetLanAdapter );
}


/*******************************************************************************
 *
 *  WinStationEnumerateProcesses (UNICODE)
 *
 *     Returns a buffer containing SYSTEM_PROCESS_INFORMATION structures
 *     for each process on the specified server.
 *
 *  IMPORTANT:  This API can ONLY be used to access TS 4.0 servers.
 *              The process structure has changed in Windows 2000 !
 *
 * ENTRY:
 *    ppProcessBuffer (output)
 *       Points to a variable that will be set to the beginning of the
 *       process buffer on success.  The buffer is allocated within this
 *       API and is disposed of using WinStationFreeMemory.
 *
 * EXIT:
 *    TRUE  - The enumeration succeeded, and the buffer contains the
 *            requested data.
 *    FALSE - The operation failed.  Extended error status is available using
 *            GetLastError.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationEnumerateProcesses(
        HANDLE  hServer,
        PVOID *ppProcessBuffer
        )
{
    DWORD Result;
    BOOLEAN rc;
    PBYTE pBuffer;
    ULONG ByteCount;

// From pstat.c
#define BUFFER_SIZE 32*1024

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        ByteCount = BUFFER_SIZE;
        *ppProcessBuffer = NULL;

        for(;;) {

            if ( (pBuffer = LocalAlloc( 0, ByteCount )) == NULL ) {
                Result = (DWORD)STATUS_NO_MEMORY;
                rc = FALSE;
                break;
            }

//#ifdef notdef
            /*
             *  get process info from server
             */
            rc = RpcWinStationEnumerateProcesses(
                        hServer,
                        &Result,
                        pBuffer,
                        ByteCount
                     );
//#else
#ifdef notdef
            Result = NtQuerySystemInformation( SystemProcessInformation,
                                               (PVOID)pBuffer,
                                               ByteCount,
                                               NULL );

            rc = (Result == STATUS_SUCCESS) ? TRUE : FALSE;
#endif

            if ( rc || (Result != STATUS_INFO_LENGTH_MISMATCH) )
                break;

            LocalFree( pBuffer );
            ByteCount *= 2;
        }

        if( !rc ) {

            Result = RtlNtStatusToDosError( Result );
            SetLastError(Result);
            LocalFree( pBuffer );
            *ppProcessBuffer = NULL;

        } else {

//#ifdef notdef
            PSYSTEM_PROCESS_INFORMATION ProcessInfo;
            PCITRIX_PROCESS_INFORMATION CitrixInfo;

            ULONG TotalOffset;

            /*
             * Walk the returned buffer (it's in SYSTEM_PROCESS_INFORMATION
             * format) and fixup the addresses (now containing
             * offsets) to pointers in our address space within pBuffer.
             */
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pBuffer;
            TotalOffset = 0;
            for(;;) {

                /*
                 * Fixup image name buffer address
                 */
                if ( ProcessInfo->ImageName.Buffer )
                    ProcessInfo->ImageName.Buffer =
                        (PWSTR)&pBuffer[(ULONG_PTR)(ProcessInfo->ImageName.Buffer)];

                /*
                 * Fixup ProcessSid address
                 */
                //
                //  Note: this is necessary because we may access to a Hydra 4 server
                //  the MagicNumber should prevent us from doing wrong.
                //
                CitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                             (((PUCHAR)ProcessInfo) +
                              SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION +
                              (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * (int)ProcessInfo->NumberOfThreads));



                if( (CitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC) &&
                        (CitrixInfo->ProcessSid) ) {

                    CitrixInfo->ProcessSid =
                        (PVOID)&pBuffer[(ULONG_PTR)(CitrixInfo->ProcessSid)];
                }

                if( ProcessInfo->NextEntryOffset == 0 )
                    break;
                else
                    TotalOffset += ProcessInfo->NextEntryOffset;

                ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pBuffer[TotalOffset];
            }
//#endif
            *ppProcessBuffer = (PVOID)pBuffer;
        }

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}


/*******************************************************************************
 *
 *  WinStationRenameA (ANSI stub)
 *
 *    Renames a window station object in the session manager.
 *    (see WinStationRenameW)
 *
 * ENTRY:
 *
 *    see WinStationRenameW
 *
 * EXIT:
 *
 *    see WinStationRenameW
 *
 ******************************************************************************/

BOOLEAN
WinStationRenameA(
        HANDLE hServer,
        PWINSTATIONNAMEA pWinStationNameOld,
        PWINSTATIONNAMEA pWinStationNameNew
        )
{
    WINSTATIONNAMEW WinStationNameOldW;
    WINSTATIONNAMEW WinStationNameNewW;

    /*
     * Convert ANSI WinStationNames to UNICODE.
     */
    AnsiToUnicode( WinStationNameOldW, sizeof(WINSTATIONNAMEW), pWinStationNameOld );
    AnsiToUnicode( WinStationNameNewW, sizeof(WINSTATIONNAMEW), pWinStationNameNew );

    /*
     * Call WinStationRenameW & return it's status.
     */
    return ( WinStationRenameW( hServer, WinStationNameOldW, WinStationNameNewW ) );
}

/*******************************************************************************
 *
 *  WinStationRenameW (UNICODE)
 *
 *    Renames a window station object in the session manager.
 *
 * ENTRY:
 *
 *    pWinStationNameOld (input)
 *       Old name of window station.
 *
 *    pWinStationNameNew (input)
 *       New name of window station.
 *
 *
 * EXIT:
 *
 *    TRUE  -- The rename operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationRenameW(
        HANDLE hServer,
        PWINSTATIONNAMEW pWinStationNameOld,
        PWINSTATIONNAMEW pWinStationNameNew
        )
{
    DWORD Result;
    BOOLEAN rc;
    WCHAR*  rpcBufferOld;
    WCHAR*  rpcBufferNew;

    HANDLE_CURRENT_BINDING( hServer );


//  Since, due to legacy clients, we cannot change the interface,
//  as a workarround to bug#265954, we double the size of RPC Buffers.

    rpcBufferOld = LocalAlloc(LPTR, sizeof(PWINSTATIONNAMEW) * sizeof(WCHAR));
    if (rpcBufferOld != NULL) {
        CopyMemory(rpcBufferOld, pWinStationNameOld, sizeof(PWINSTATIONNAMEW));
    } else {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    rpcBufferNew = LocalAlloc(LPTR, sizeof(PWINSTATIONNAMEW) * sizeof(WCHAR));
    if (rpcBufferNew != NULL) {
        CopyMemory(rpcBufferNew, pWinStationNameNew, sizeof(PWINSTATIONNAMEW));
    } else {
        LocalFree(rpcBufferOld);
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }



    RpcTryExcept {

        rc = RpcWinStationRename(
                     hServer,
                     &Result,
                     (PWCHAR)rpcBufferOld,
                     sizeof(WINSTATIONNAMEW),
                     (PWCHAR)rpcBufferNew,
                     sizeof(WINSTATIONNAMEW)
                     );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    LocalFree(rpcBufferOld);
    LocalFree(rpcBufferNew);
    if( !rc ) SetLastError(Result);
    return( rc );
}


/*******************************************************************************
 *
 *  WinStationQueryInformationA (ANSI stub)
 *
 *    Queries configuration information about a window station object.
 *
 * ENTRY:
 *
 *    see WinStationQueryInformationW
 *
 * EXIT:
 *
 *    see WinStationQueryInformationW
 *
 ******************************************************************************/

BOOLEAN
WinStationQueryInformationA(
        HANDLE hServer,
        ULONG  LogonId,
        WINSTATIONINFOCLASS WinStationInformationClass,
        PVOID  pWinStationInformation,
        ULONG WinStationInformationLength,
        PULONG  pReturnLength
        )
{
    PVOID pInfo;
    ULONG InfoLength, ValidInputLength;
    struct {
        union {
            WINSTATIONCREATEW      CreateData;
            WINSTATIONCONFIGW      Configuration;
            PDPARAMSW              PdParams;
            WDCONFIGW              Wd;
            PDCONFIGW              Pd;
            WINSTATIONPRINTERW     Printer;
            WINSTATIONINFORMATIONW Information;
            WINSTATIONCLIENTW      Client;
            WINSTATIONPRODIDW            DigProdId;
        };
    } Info;

    /*
     * Validate the caller supplied buffer length and set up for
     * call to WinStationQueryInformationW.
     */
    switch ( WinStationInformationClass ) {

        case WinStationCreateData:
            pInfo = &Info.CreateData;
            InfoLength = sizeof(Info.CreateData);
            ValidInputLength = sizeof(WINSTATIONCREATEA);
            break;

        case WinStationConfiguration:
            pInfo = &Info.Configuration;
            InfoLength = sizeof(Info.Configuration);
            ValidInputLength = sizeof(WINSTATIONCONFIGA);
            break;

        case WinStationPdParams:
            pInfo = &Info.PdParams;
            ((PPDPARAMSW)pInfo)->SdClass = ((PPDPARAMSA)pWinStationInformation)->SdClass;
            InfoLength = sizeof(Info.PdParams);
            ValidInputLength = sizeof(PDPARAMSA);
            break;

        case WinStationWd:
            pInfo = &Info.Wd;
            InfoLength = sizeof(Info.Wd);
            ValidInputLength = sizeof(WDCONFIGA);
            break;

        case WinStationPd:
            pInfo = &Info.Pd;
            InfoLength = sizeof(Info.Pd);
            ValidInputLength = sizeof(PDCONFIGA);
            break;

        case WinStationPrinter:
            pInfo = &Info.Printer;
            InfoLength = sizeof(Info.Printer);
            ValidInputLength = sizeof(WINSTATIONPRINTERA);
            break;

        case WinStationInformation:
            pInfo = &Info.Information;
            InfoLength = sizeof(Info.Information);
            ValidInputLength = sizeof(WINSTATIONINFORMATIONA);
            break;

        case WinStationClient:
            pInfo = &Info.Client;
            InfoLength = sizeof(Info.Client);
            ValidInputLength = sizeof(WINSTATIONCLIENTA);
            break;
        case WinStationDigProductId:
                pInfo = &Info.DigProdId;
                InfoLength = sizeof(Info.DigProdId);
                ValidInputLength = sizeof(WINSTATIONPRODIDA);
                break;

        /*
         * The other WINSTATIONINFOCLASSes don't need converting.
         */
        default:
            pInfo = pWinStationInformation;
            ValidInputLength = InfoLength = WinStationInformationLength;
            break;
    }

    /*
     * If the caller-supplied buffer is not the proper size, set error
     * and return FALSE.
     */
    if ( WinStationInformationLength != ValidInputLength )
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    }

    /*
     * Call the WinStationQueryInformationW function, returning if
     * failure.
     */
    if ( !WinStationQueryInformationW( hServer, LogonId,
                                       WinStationInformationClass,
                                       pInfo, InfoLength, pReturnLength ) )
        return(FALSE);


    /*
     * Convert the returned UNICODE information to ANSI, if needed.
     */
    switch ( WinStationInformationClass ) {

        case WinStationCreateData:
            WinStationCreateU2A( (PWINSTATIONCREATEA)pWinStationInformation,
                                 (PWINSTATIONCREATEW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationConfiguration:
            WinStationConfigU2A( (PWINSTATIONCONFIGA)pWinStationInformation,
                                 (PWINSTATIONCONFIGW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationPdParams:
            PdParamsU2A( (PPDPARAMSA)pWinStationInformation,
                          (PPDPARAMSW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationWd:
            WdConfigU2A( (PWDCONFIGA)pWinStationInformation,
                               (PWDCONFIGW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationPd:
            PdConfig2U2A( &((PPDCONFIGA)pWinStationInformation)->Create,
                           &((PPDCONFIGW)pInfo)->Create );
            PdParamsU2A( &((PPDCONFIGA)pWinStationInformation)->Params,
                          &((PPDCONFIGW)pInfo)->Params );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationPrinter:
            WinStationPrinterU2A( (PWINSTATIONPRINTERA)pWinStationInformation,
                                  (PWINSTATIONPRINTERW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationInformation:
            WinStationInformationU2A( (PWINSTATIONINFORMATIONA)pWinStationInformation,
                                      (PWINSTATIONINFORMATIONW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationClient:
            WinStationClientU2A( (PWINSTATIONCLIENTA)pWinStationInformation,
                                 (PWINSTATIONCLIENTW)pInfo );
            *pReturnLength = ValidInputLength;
            break;

        case WinStationDigProductId:
                WinStationProductIdU2A( (PWINSTATIONPRODIDA)pWinStationInformation, 
                                                                (PWINSTATIONPRODIDW)pInfo );
                        *pReturnLength = ValidInputLength;
                        break;

        default:
            break;
    }
    return(TRUE);
}

/*******************************************************************************
 *
 *  WinStationQueryInformationW (UNICODE)
 *
 *    Queries configuration information about a window station object.
 *
 * ENTRY:
 *
 *    WinStationHandle (input)
 *       Identifies the window station object. The handle must have
 *       WINSTATION_QUERY access.
 *
 *    WinStationInformationClass (input)
 *       Specifies the type of information to retrieve from the specified
 *       window station object.
 *
 *    pWinStationInformation (output)
 *       A pointer to a buffer that will receive information about the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being queried.
 *
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 *    pReturnLength (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes placed in the window station information buffer.
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationQueryInformationW(
        HANDLE hServer,
        ULONG  LogonId,
        WINSTATIONINFOCLASS WinStationInformationClass,
        PVOID  pWinStationInformation,
        ULONG WinStationInformationLength,
        PULONG  pReturnLength
        )
{
    DWORD Result;
    BOOLEAN rc;
    PCHAR RpcBuf;
    ULONG RpcBufLen;
    PVOID WireBuf;
    PVOID AllocatedBuff = NULL;
    ULONG WireBufLen;
    BOOLEAN WireBufAllocated;
    ULONG Status;
    static UINT AlreadyWaitedForTermsrv = 0; // a flag which helps to determine if we already waited for TermSrv to be up

    if ((Status = CheckUserBuffer(WinStationInformationClass,
                                  pWinStationInformation,
                                  WinStationInformationLength,
                                  &WireBuf,
                                  &WireBufLen,
                                  &WireBufAllocated)) != ERROR_SUCCESS) {
        SetLastError(Status);
        return(FALSE);
    }

    if (WireBufAllocated) {
        AllocatedBuff = WireBuf;
        RpcBuf = (PCHAR) WireBuf;
        RpcBufLen = WireBufLen;
        CopyInWireBuf(WinStationInformationClass,
                      pWinStationInformation,
                      WireBuf);
    } else {
        RpcBuf = (PCHAR) pWinStationInformation;
        RpcBufLen = WinStationInformationLength;
    }


    HANDLE_CURRENT_BINDING_BUFFER( hServer, AllocatedBuff );

    // First wait for termsrv to get started if User Token is queried
    // This is for Session 0 only where termsrv is started after 60 seconds on Per and Pro
    // Need to do this only for the first time - AlreadyWaitedForTermsrv flag helps to determine this

    if ( (LogonId == 0) && (WinStationInformationClass == WinStationUserToken) && (AlreadyWaitedForTermsrv == 0) ) {

        HANDLE ReadyEventHandle ;

        ReadyEventHandle = CreateEvent(NULL, TRUE, FALSE, TEXT("Global\\TermSrvReadyEvent"));
        if (ReadyEventHandle != NULL) {
            DWORD dwTimeOut = 1000*60*3;   // 3 minutes
            AlreadyWaitedForTermsrv++;
            // wait until termsrv is actually ready.
            WaitForSingleObject(ReadyEventHandle, dwTimeOut);
            CloseHandle(ReadyEventHandle);
        } 
    }
     

    RpcTryExcept {

        rc = RpcWinStationQueryInformation(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     (DWORD)WinStationInformationClass,
                     RpcBuf,
                     RpcBufLen,
                     pReturnLength
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (WireBufAllocated) {
        if (rc) {
            CopyOutWireBuf(WinStationInformationClass,
                           pWinStationInformation,
                           WireBuf);
            *pReturnLength = WinStationInformationLength;
        }
        LocalFree(WireBuf);
    }

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationSetInformationA (ANSI stub)
 *
 *    Sets configuration information for a window station object.
 *
 * ENTRY:
 *
 *    see WinStationSetInformationW
 *
 * EXIT:
 *
 *    see WinStationSetInformationW
 *
 ******************************************************************************/

BOOLEAN
WinStationSetInformationA(
        HANDLE hServer,
        ULONG  LogonId,
        WINSTATIONINFOCLASS WinStationInformationClass,
        PVOID pWinStationInformation,
        ULONG WinStationInformationLength
        )
{
    PVOID pInfo;
    ULONG InfoLength;
    struct {
        union {
            WINSTATIONCREATEW      CreateData;
            WINSTATIONCONFIGW      Configuration;
            PDPARAMSW              PdParams;
            WDCONFIGW              Wd;
            PDCONFIGW              Pd;
            WINSTATIONPRINTERW     Printer;
            WINSTATIONINFORMATIONW Information;
        };
    } Info;

    /*
     * Validate the caller supplied buffer length and convert to the
     * appropriate UNICODE buffer for call to WinStationSetInformationW.
     */
    switch ( WinStationInformationClass ) {

        case WinStationCreateData:
            pInfo = &Info.CreateData;
            InfoLength = sizeof(Info.CreateData);
            if ( WinStationInformationLength != sizeof(WINSTATIONCREATEA) )
                goto BadBufferLength;
            WinStationCreateA2U( (PWINSTATIONCREATEW)pInfo,
                                 (PWINSTATIONCREATEA)pWinStationInformation );
            break;

        case WinStationConfiguration:
            pInfo = &Info.Configuration;
            InfoLength = sizeof(Info.Configuration);
            if ( WinStationInformationLength != sizeof(WINSTATIONCONFIGA) )
                goto BadBufferLength;
            WinStationConfigA2U( (PWINSTATIONCONFIGW)pInfo,
                                 (PWINSTATIONCONFIGA)pWinStationInformation );
            break;

        case WinStationPdParams:
            pInfo = &Info.PdParams;
            InfoLength = sizeof(Info.PdParams);
            if ( WinStationInformationLength != sizeof(PDPARAMSA) )
                goto BadBufferLength;
            PdParamsA2U( (PPDPARAMSW)pInfo,
                          (PPDPARAMSA)pWinStationInformation );
            break;

        case WinStationWd:
            pInfo = &Info.Wd;
            InfoLength = sizeof(Info.Wd);
            if ( WinStationInformationLength != sizeof(WDCONFIGA) )
                goto BadBufferLength;
            WdConfigA2U( (PWDCONFIGW)pInfo,
                               (PWDCONFIGA)pWinStationInformation );
            break;

        case WinStationPd:
            pInfo = &Info.Pd;
            InfoLength = sizeof(Info.Pd);
            if ( WinStationInformationLength != sizeof(PDCONFIGA) )
                goto BadBufferLength;
            PdConfig2A2U( &((PPDCONFIGW)pInfo)->Create,
                           &((PPDCONFIGA)pWinStationInformation)->Create );
            PdParamsA2U( &((PPDCONFIGW)pInfo)->Params,
                          &((PPDCONFIGA)pWinStationInformation)->Params );
            break;

        case WinStationPrinter:
            pInfo = &Info.Printer;
            InfoLength = sizeof(Info.Printer);
            if ( WinStationInformationLength != sizeof(WINSTATIONPRINTERA) )
                goto BadBufferLength;
            WinStationPrinterA2U( (PWINSTATIONPRINTERW)pInfo,
                                  (PWINSTATIONPRINTERA)pWinStationInformation );
            break;

        case WinStationInformation:
            pInfo = &Info.Information;
            InfoLength = sizeof(Info.Information);
            if ( WinStationInformationLength != sizeof(WINSTATIONINFORMATIONA) )
                goto BadBufferLength;
            WinStationInformationA2U( (PWINSTATIONINFORMATIONW)pInfo,
                                      (PWINSTATIONINFORMATIONA)pWinStationInformation );
            break;

        /*
         * The other WINSTATIONINFOCLASSes don't need converting.
         */
        default:
            pInfo = pWinStationInformation;
            InfoLength = WinStationInformationLength;
            break;
    }

    /*
     * Call the WinStationSetInformationW function and return it's
     * status.
     */
    return ( WinStationSetInformationW( hServer, LogonId,
                                          WinStationInformationClass,
                                          pInfo, InfoLength ) );

/*--------------------------------------
 * Error clean-up and return...
 */
BadBufferLength:
    SetLastError(ERROR_INSUFFICIENT_BUFFER);
    return(FALSE);
}

/*******************************************************************************
 *
 *  WinStationSetInformationW (UNICODE)
 *
 *    Sets configuration information for a window station object.
 *
 * ENTRY:
 *
 *    WinStationHandle (input)
 *       Identifies the window station object. The handle must have
 *       WINSTATION_SET access.
 *
 *    WinStationInformationClass (input)
 *       Specifies the type of information to retrieve from the specified
 *       window station object.
 *
 *    pWinStationInformation (input)
 *       A pointer to a buffer that contains information to set for the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being set.
 *
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 * EXIT:
 *
 *    TRUE  -- The set operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationSetInformationW(
        HANDLE hServer,
        ULONG  LogonId,
        WINSTATIONINFOCLASS WinStationInformationClass,
        PVOID pWinStationInformation,
        ULONG WinStationInformationLength
        )
{
    DWORD Result;
    BOOLEAN rc;
    PCHAR RpcBuf;
    ULONG RpcBufLen;
    PVOID WireBuf;
    PVOID AllocatedBuff = NULL;
    ULONG WireBufLen;
    BOOLEAN WireBufAllocated;
    ULONG Status;

    if ((Status = CheckUserBuffer(WinStationInformationClass,
                                  pWinStationInformation,
                                  WinStationInformationLength,
                                  &WireBuf,
                                  &WireBufLen,
                                  &WireBufAllocated)) != ERROR_SUCCESS) {
        SetLastError(Status);
        return(FALSE);
    }

    if (WireBufAllocated) {
        AllocatedBuff = WireBuf;
        RpcBuf = (PCHAR) WireBuf;
        RpcBufLen = WireBufLen;
        CopyInWireBuf(WinStationInformationClass,
                      pWinStationInformation,
                      WireBuf);
    } else {
        RpcBuf = (PCHAR) pWinStationInformation;
        RpcBufLen = WinStationInformationLength;
    }

    HANDLE_CURRENT_BINDING_BUFFER( hServer, AllocatedBuff );

    RpcTryExcept {

        rc = RpcWinStationSetInformation(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     (DWORD)WinStationInformationClass,
                     RpcBuf,
                     RpcBufLen
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (WireBufAllocated) {
        LocalFree(WireBuf);
    }

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationSendMessageA (ANSI stub)
 *
 *    Sends a message to the specified window station object and optionally
 *    waits for a reply.  The reply is returned to the caller of
 *    WinStationSendMessage.
 *
 * ENTRY:
 *
 *    see WinStationSendMessageW
 *
 * EXIT:
 *
 *    see WinStationSendMessageW, plus
 *
 *  ERROR_NOT_ENOUGH_MEMORY - the LocalAlloc failed
 *
 ******************************************************************************/

BOOLEAN
WinStationSendMessageA(
        HANDLE hServer,
        ULONG  LogonId,
        LPSTR  pTitle,
        ULONG TitleLength,
        LPSTR  pMessage,
        ULONG MessageLength,
        ULONG Style,
        ULONG Timeout,
        PULONG pResponse,
        BOOLEAN DoNotWait
        )
{
    BOOLEAN status;
    LPWSTR pTitleW, pMessageW;
    ULONG TitleLengthW, MessageLengthW;

    /*
     * Allocate a buffer for UNICODE version of Title and convert.
     */
    if ( !(pTitleW = LocalAlloc( 0,
                                 TitleLengthW =
                                    (TitleLength*sizeof(WCHAR)) )) ) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    AnsiToUnicode( pTitleW, TitleLengthW, pTitle );

    /*
     * Allocate a buffer for UNICODE version of Message and convert.
     */
    if ( !(pMessageW = LocalAlloc( 0,
                                 MessageLengthW =
                                    (MessageLength*sizeof(WCHAR)) )) ) {
        LocalFree(pTitleW);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    AnsiToUnicode( pMessageW, MessageLengthW, pMessage );

    /*
     * Call WinStationSendMessageW
     */
    status = WinStationSendMessageW( hServer,
                                     LogonId,
                                     pTitleW,
                                     TitleLengthW,
                                     pMessageW,
                                     MessageLengthW,
                                     Style,
                                     Timeout,
                                     pResponse,
                                     DoNotWait );

    /*
     * Free allocated buffers and return status.
     */
    LocalFree(pTitleW);
    LocalFree(pMessageW);
    return(status);
}

/*******************************************************************************
 *
 *  WinStationSendMessageW (UNICODE)
 *
 *    Sends a message to the specified window station object and optionally
 *    waits for a reply.  The reply is returned to the caller of
 *    WinStationSendMessage.
 *
 * ENTRY:
 *
 *    WinStationHandle (input)
 *       Specifies the window station object to send a message to.
 *
 *    pTitle (input)
 *       Pointer to title for message box to display.
 *
 *    TitleLength (input)
 *       Length of title to display in bytes.
 *
 *    pMessage (input)
 *       Pointer to message to display.
 *
 *    MessageLength (input)
 *       Length of message in bytes to display at the specified window station.
 *
 *    Style (input)
 *       Standard Windows MessageBox() style parameter.
 *
 *    Timeout (input)
 *       Response timeout in seconds.  If message is not responded to in
 *       Timeout seconds then a response code of IDTIMEOUT (cwin.h) is
 *       returned to signify the message timed out.
 *
 *    pResponse (output)
 *       Address to return selected response.
 *
 *    DoNotWait (input)
 *       Do not wait for the response. Causes pResponse to be set to
 *       IDASYNC (cwin.h) if no errors queueing the message.
 *
 * EXIT:
 *
 *    TRUE  -- The send message operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationSendMessageW(
        HANDLE hServer,
        ULONG  LogonId,
        LPWSTR  pTitle,
        ULONG TitleLength,
        LPWSTR  pMessage,
        ULONG MessageLength,
        ULONG Style,
        ULONG Timeout,
        PULONG pResponse,
        BOOLEAN DoNotWait
        )
{
    DWORD Result;
    BOOLEAN rc;
    WCHAR*  rpcBuffer1;
    WCHAR*  rpcBuffer2;


    HANDLE_CURRENT_BINDING( hServer );

//  Since, due to legacy clients, we cannot change the interface,
//  as a workarround to bug#265954, we double the size of RPC Buffers.

    rpcBuffer1 = LocalAlloc(LPTR, MessageLength * sizeof(WCHAR));
    if (rpcBuffer1 != NULL) {
        CopyMemory(rpcBuffer1, pMessage, MessageLength);
    } else {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    rpcBuffer2 = LocalAlloc(LPTR, TitleLength * sizeof(WCHAR));
    if (rpcBuffer2 != NULL) {
        CopyMemory(rpcBuffer2, pTitle, TitleLength);
    } else {
        LocalFree(rpcBuffer1);
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }


    RpcTryExcept {

        rc = RpcWinStationSendMessage(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     rpcBuffer2,
                     TitleLength,
                     rpcBuffer1,
                     MessageLength,
                     Style,
                     Timeout,
                     pResponse,
                     DoNotWait
                     );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    LocalFree(rpcBuffer1);
    LocalFree(rpcBuffer2);
    if (!rc) {
        SetLastError( Result );
    }

    return( rc );
}

/*******************************************************************************
 *
 *  LogonIdFromWinStationNameA (ANSI stub)
 *
 *    Returns the LogonId for the specified window station name.
 *
 * ENTRY:
 *
 *    see LogonIdFromWinStationNameW
 *
 * EXIT:
 *
 *    see LogonIdFromWinStationNameW
 *
 ******************************************************************************/

BOOLEAN
LogonIdFromWinStationNameA(
        HANDLE hServer,
        PWINSTATIONNAMEA pWinStationName,
        PULONG pLogonId
        )
{
    WINSTATIONNAMEW WinStationNameW;

    /*
     * Convert ANSI WinStationName to UNICODE.
     */
    AnsiToUnicode( WinStationNameW, sizeof(WINSTATIONNAMEW), pWinStationName );

    /*
     * Call LogonIdFromWinStationNameW & return it's status.
     */
    return ( LogonIdFromWinStationNameW( hServer, WinStationNameW, pLogonId ) );
}

/*******************************************************************************
 *
 *  LogonIdFromWinStationNameW (UNICODE)
 *
 *    Returns the LogonId for the specified window station name.
 *
 * ENTRY:
 *
 *    pWinStationName (input)
 *       Window station name.
 *
 *    pLogonId (output)
 *       Pointer to where to place the LogonId if found
 *
 * EXIT:
 *
 *    If the function succeeds, the return value is TRUE, otherwise, it is
 *    FALSE.
 *    To get extended error information, use the GetLastError function.
 *
 ******************************************************************************/

BOOLEAN
LogonIdFromWinStationNameW(
        HANDLE hServer,
        PWINSTATIONNAMEW pWinStationName,
        PULONG pLogonId
        )
{
    DWORD   Result;
    BOOLEAN rc;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    /*
     *  rpcBuffer is a workaround for bug 229753. The bug can't be fixed
     *  completely without breaking TS4 clients.
     */

    rpcBuffer = LocalAlloc(LPTR, sizeof(WINSTATIONNAMEW) * sizeof(WCHAR));
    if (rpcBuffer != NULL) {
        CopyMemory(rpcBuffer, pWinStationName, sizeof(WINSTATIONNAMEW));
    } else {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    RpcTryExcept {

        rc = RpcLogonIdFromWinStationName(
                    hServer,
                    &Result,
                    rpcBuffer,
                    sizeof(WINSTATIONNAMEW),
                    pLogonId
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*******************************************************************************
 *
 *  WinStationNameFromLogonIdA (ANSI stub)
 *
 *    Returns the WinStation name for the specified LogonId.
 *
 * ENTRY:
 *
 *    see WinStationNameFromLogonIdW
 *
 * EXIT:
 *
 *    see WinStationNameFromLogonIdW
 *
 ******************************************************************************/

BOOLEAN
WinStationNameFromLogonIdA(
        HANDLE hServer,
        ULONG LogonId,
        PWINSTATIONNAMEA pWinStationName
        )
{
    BOOLEAN Result;
    WINSTATIONNAMEW WinStationNameW;

    /*
     * Call WinStationNameFromLogonIdW
     */
    Result = WinStationNameFromLogonIdW( hServer, LogonId, WinStationNameW );

    /*
     * if successful, convert UNICODE WinStationName to ANSI.
     */
    if ( Result ) {
        UnicodeToAnsi( pWinStationName, sizeof(WINSTATIONNAMEA), WinStationNameW );
    }

    return( Result );
}

/*******************************************************************************
 *
 *  WinStationNameFromLogonIdW (UNICODE)
 *
 *    Returns the WinStation name for the specified LogonId.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       LogonId to query
 *
 *    pWinStationName (output)
 *       Location to return WinStation name
 *
 * EXIT:
 *
 *    If the function succeeds, the return value is TRUE, otherwise, it is
 *    FALSE.
 *    To get extended error information, use the GetLastError function.
 *
 ******************************************************************************/

BOOLEAN
WinStationNameFromLogonIdW(
        HANDLE hServer,
        ULONG LogonId,
        PWINSTATIONNAMEW pWinStationName
        )
{
    DWORD   Result;
    BOOLEAN rc;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    /*
     *  rpcBuffer is a workaround for bug 229753. The bug can't be fixed
     *  completely without breaking TS4 clients.
     */

    rpcBuffer = LocalAlloc(LPTR, sizeof(WINSTATIONNAMEW) * sizeof(WCHAR));
    if (rpcBuffer == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    RpcTryExcept {

        rc = RpcWinStationNameFromLogonId(
                    hServer,
                    &Result,
                    (LogonId == LOGONID_CURRENT) ?
                        NtCurrentPeb()->SessionId : LogonId,
                    rpcBuffer,
                    sizeof(WINSTATIONNAMEW)
                    );

        Result = RtlNtStatusToDosError( Result );
        if (rc) {
            CopyMemory(pWinStationName, rpcBuffer, sizeof(WINSTATIONNAMEW));
        }

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*******************************************************************************
 *
 *  WinStationConnectA (ANSI stub)
 *
 *    Connects a window station object to the configured terminal and Pd.
 *
 * ENTRY:
 *
 *    see WinStationConnectW
 *
 * EXIT:
 *
 *    see WinStationConnectW
 *
 ******************************************************************************/

BOOLEAN
WinStationConnectA( HANDLE hServer,
                    ULONG LogonId,
                    ULONG TargetLogonId,
                    PCHAR pPassword,
                    BOOLEAN bWait )
{
    WCHAR PasswordW[ PASSWORD_LENGTH + 1 ];

    /*
     * Convert ANSI Password to UNICODE.
     */
    AnsiToUnicode( PasswordW, sizeof(PasswordW), pPassword );

    /*
     * Call WinStationConnectW & return it's status.
     */
    return ( WinStationConnectW( hServer, LogonId, TargetLogonId, PasswordW, bWait ) );
}

/*******************************************************************************
 *
 *  WinStationConnectW (UNICODE)
 *
 *    Connects a window station object to the configured terminal and Pd.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       ID of window station object to connect.
 *
 *    TargetLogonId (input)
 *       ID of target window station.
 *
 *    pPassword (input)
 *       password of LogonId window station (not needed if same domain/username)
 *
 *    bWait (input)
 *       Specifies whether or not to wait for connect to complete
 *
 * EXIT:
 *
 *    TRUE  -- The connect operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationConnectW(
    HANDLE hServer,
    ULONG LogonId,
    ULONG TargetLogonId,
    PWCHAR pPassword,
    BOOLEAN bWait
    )
{
    DWORD   Result;
    BOOLEAN rc;
    DWORD   PasswordLength;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        if( pPassword ) {
            PasswordLength = (lstrlenW( pPassword ) + 1) * sizeof(WCHAR);

            /*
             *  rpcBuffer is a workaround for bug 229753. The bug can't be
             *  fixed completely without breaking TS4 clients.
             */

            rpcBuffer = LocalAlloc(LPTR, PasswordLength * sizeof(WCHAR));
            if (rpcBuffer != NULL) {
                CopyMemory(rpcBuffer, pPassword, PasswordLength);
            } else {
                SetLastError(ERROR_OUTOFMEMORY);
                return(FALSE);
            }

        } else {
            PasswordLength = 0;
            rpcBuffer = NULL;
        }

        rc = RpcWinStationConnect(
                    hServer,
                    &Result,
                    NtCurrentPeb()->SessionId,
                    (LogonId == LOGONID_CURRENT) ?
                        NtCurrentPeb()->SessionId : LogonId,
                    (TargetLogonId == LOGONID_CURRENT) ?
                        NtCurrentPeb()->SessionId : TargetLogonId,
                    rpcBuffer,
                    PasswordLength,
                    bWait
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************
 *
 *  WinStationVirtualOpen
 *
 *   Open a virtual channel
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

HANDLE WINAPI
WinStationVirtualOpen(
    HANDLE hServer,
    ULONG LogonId,
    PVIRTUALCHANNELNAME pVirtualName   /* ascii name */
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   NameLength;
    DWORD   VirtualHandle = (DWORD)0;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        if( pVirtualName )
            NameLength = strlen( pVirtualName ) + 1;
        else
            NameLength = 0;

        rc = RpcWinStationVirtualOpen(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     GetCurrentProcessId(),
                     (PCHAR)pVirtualName,
                     NameLength,
                     &VirtualHandle
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) {
            SetLastError(Result);
            VirtualHandle = (DWORD)0;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( (HANDLE)LongToHandle( VirtualHandle ) );
}

/*****************************************************************************
 *
 *  _WinStationBeepOpen
 *
 *   Open a beep channel
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

HANDLE WINAPI
_WinStationBeepOpen(
    ULONG LogonId
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   VirtualHandle = (DWORD)0;
    HANDLE hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationBeepOpen(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     GetCurrentProcessId(),
                     &VirtualHandle
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) {
            SetLastError(Result);
            VirtualHandle = (DWORD)0;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( (HANDLE)LongToHandle( VirtualHandle ) );
}

/*******************************************************************************
 *
 *  WinStationDisconnect
 *
 *    Disconects a window station object from the configured terminal and Pd.
 *    While disconnected all window station i/o is bit bucketed.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       ID of window station object to disconnect.
 *    bWait (input)
 *       Specifies whether or not to wait for disconnect to complete
 *
 * EXIT:
 *
 *    TRUE  -- The disconnect operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationDisconnect(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN bWait
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationDisconnect(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     bWait
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationReset
 *
 *    Reset the specified window station.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       Identifies the window station object to reset.
 *    bWait (input)
 *       Specifies whether or not to wait for reset to complete
 *
 * EXIT:
 *
 *    TRUE  -- The reset operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationReset(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN bWait
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationReset(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     bWait
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationShadowStop
 *
 *    Stop the shadow on the specified window station.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       Identifies the window station object to stop the shadow on.
 *    bWait (input)
 *       Specifies whether or not to wait for reset to complete
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationShadowStop(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN bWait
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationShadowStop(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     bWait
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationShutdownSystem
 *
 *    Shutdown the system and optionally logoff all WinStations
 *    and/or reboot the system.
 *
 * ENTRY:
 *
 *    ShutdownFlags (input)
 *       Flags which specify shutdown options.
 *
 * EXIT:
 *
 *    TRUE  -- The shutdown operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationShutdownSystem(
    HANDLE hServer,
    ULONG ShutdownFlags
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationShutdownSystem(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     ShutdownFlags
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationTerminateProcess
 *
 *    Terminate the specified process
 *
 * ENTRY:
 *
 *    hServer (input)
 *       handle to winframe server
 *    ProcessId (input)
 *       process id of the process to terminate
 *    ExitCode (input)
 *       Termination status for each thread in the process
 *
 *
 * EXIT:
 *
 *    TRUE  -- The terminate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationTerminateProcess(
    HANDLE hServer,
    ULONG ProcessId,
    ULONG ExitCode
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationTerminateProcess(
                     hServer,
                     &Result,
                     ProcessId,
                     ExitCode
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}


/*******************************************************************************
 *
 *  WinStationWaitSystemEvent
 *
 *    Waits for an event (WinStation create, delete, connect, etc) before
 *    returning to the caller.
 *
 * ENTRY:
 *
 *    EventFlags (input)
 *       Bit mask that specifies which event(s) to wait for.
 *    pEventFlags (output)
 *       Bit mask of event(s) that occurred.
 *
 * EXIT:
 *
 *    TRUE  -- The wait event operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationWaitSystemEvent(
    HANDLE hServer,
    ULONG EventMask,
    PULONG pEventFlags
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationWaitSystemEvent(
                     hServer,
                     &Result,
                     EventMask,
                     pEventFlags
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  WinStationShadow
 *
 *   Start a Winstation shadow operation
 *
 * ENTRY:
 *   hServer (input)
 *     open RPC server handle
 *   pTargetServerName (input)
 *     name of target WinFrame server
 *   TargetLogonId (input)
 *     shadow target login id (where the app is running)
 *   HotkeyVk (input)
 *     virtual key to press to stop shadow
 *   HotkeyModifiers (input)
 *     virtual modifer to press to stop shadow (i.e. shift, control)
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
WinStationShadow(
    HANDLE hServer,
    LPWSTR pTargetServerName,
    ULONG TargetLogonId,
    BYTE HotkeyVk,
    USHORT HotkeyModifiers
    )
{
    DWORD   NameSize;
    DWORD   Result;
    BOOLEAN rc;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        if ( pTargetServerName && *pTargetServerName ) {
            NameSize = (lstrlenW( pTargetServerName ) + 1) * sizeof(WCHAR);

            /*
             *  rpcBuffer is a workaround for bug 229753. The bug can't be
             *  fixed completely without breaking TS4 clients.
             */

            rpcBuffer = LocalAlloc(LPTR, NameSize * sizeof(WCHAR));
            if (rpcBuffer != NULL) {
                CopyMemory(rpcBuffer, pTargetServerName, NameSize);
            } else {
                SetLastError(ERROR_OUTOFMEMORY);
                return(FALSE);
            }

        } else {
            NameSize = 0;
            rpcBuffer = NULL;
        }

        rc = RpcWinStationShadow(
                    hServer,
                    &Result,
                    NtCurrentPeb()->SessionId,
                    rpcBuffer,
                    NameSize,
                    TargetLogonId,
                    HotkeyVk,
                    HotkeyModifiers
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}


/*****************************************************************************
 *
 *  _WinStationShadowTargetSetup
 *
 *   private api used to initialize the target size of a shadow
 *
 * ENTRY:
 *   hServer (input)
 *      target server
 *   LogonId (input)
 *      target logon id
 *   pClientName (input)
 *      pointer to client name string (domain/username)
 *   ClientNameLength (input)
 *      length of client name string
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationShadowTargetSetup(
    HANDLE hServer,
    ULONG LogonId
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationShadowTargetSetup(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId
                     );

        //Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(RtlNtStatusToDosError(Result));
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}


/*****************************************************************************
 *
 *  _WinStationShadowTarget
 *
 *   private api used to initialize the target size of a shadow
 *
 * ENTRY:
 *   hServer (input)
 *      target server
 *   LogonId (input)
 *      target logon id
 *   pConfig (input)
 *      pointer to WinStation config data (to configure shadow stack)
 *   pAddress (input)
 *      address of shadow client
 *   pModuleData (input)
 *      pointer to client module data
 *   ModuleDataLength (input)
 *      length of client module data
 *   pThinwireData (input)
 *      pointer to thinwire module data
 *   ThinwireDataLength (input)
 *      length of thinwire module data
 *   pClientName (input)
 *      pointer to client name string (domain/username)
 *   ClientNameLength (input)
 *      length of client name string
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS WINAPI
_WinStationShadowTarget(
    HANDLE hServer,
    ULONG LogonId,
    PWINSTATIONCONFIG2 pConfig,
    PICA_STACK_ADDRESS pAddress,
    PVOID pModuleData,
    ULONG ModuleDataLength,
    PVOID pThinwireData,
    ULONG ThinwireDataLength,
    PVOID pClientName,
    ULONG ClientNameLength
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationShadowTarget(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     (PBYTE) pConfig,
                     sizeof(*pConfig),
                     (PBYTE) pAddress,
                     sizeof(*pAddress),
                     pModuleData,
                     ModuleDataLength,
                     pThinwireData,
                     ThinwireDataLength,
                     pClientName,
                     ClientNameLength
                     );

        // Since a program has called us, we need to set the last error code such
        // that extended error information is available
        if (!rc)
            SetLastError(RtlNtStatusToDosError(Result));
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return Result;
}


/*******************************************************************************
 *
 *  WinStationFreeMemory
 *
 *  Called to free memory which was allocated by a WinStation API.
 *
 * ENTRY:
 *       pBuffer (input)
 *
 * EXIT:
 *    TRUE  -- The install operation succeeded.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationFreeMemory(
    PVOID pBuffer
    )
{
    if ( pBuffer )
        LocalFree( pBuffer );
    return( TRUE );
}

/*******************************************************************************
 *
 *  WinStationFreeGAPMemory
 *
 *  Called to free memory which was allocated by the WinStationGetAllProcesses API.
 *
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationFreeGAPMemory(ULONG   Level,
                        PVOID   pProcArray,
                        ULONG   NumberOfProcesses)
{
    ULONG   i;
    PTS_ALL_PROCESSES_INFO  pProcessArray = (PTS_ALL_PROCESSES_INFO)pProcArray;

    if (Level == GAP_LEVEL_BASIC)   // only level supported right now
    {
        if ( pProcessArray != NULL)
        {
            for (i=0; i < NumberOfProcesses ; i++)
            {
                if (pProcessArray[i].pTsProcessInfo != NULL)
                {
                    if (((pProcessArray[i].pTsProcessInfo)->ImageName).Buffer  != NULL)
                    {
                        //
                        //  free the ImageName string
                        //
                        LocalFree(((pProcessArray[i].pTsProcessInfo)->ImageName).Buffer);
                    }
                    //
                    //  free the Process Info buffer
                    //
                    LocalFree(pProcessArray[i].pTsProcessInfo);
                }

                if (pProcessArray[i].pSid != NULL)
                {
                    //
                    //  free the SID
                    //
                    LocalFree(pProcessArray[i].pSid);
                }
            }

        LocalFree(pProcessArray);
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/*******************************************************************************
 *
 *  WinStationGenerateLicense
 *
 *  Called to generate a license from a given serial number string.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pSerialNumberString (input)
 *       Pointer to a null-terminated, wide-character Serial Number string
 *    pLicense (output)
 *       Pointer to a License structure that will be filled in with
 *       information based on pSerialNumberString
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *
 *    TRUE  -- The install operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN WINAPI
WinStationGenerateLicense(
    HANDLE hServer,
    PWCHAR pSerialNumberString,
    PVOID  pLicense,
    DWORD  LicenseSize
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   Length;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        if ( pSerialNumberString ) {
            Length = (lstrlenW( pSerialNumberString ) + 1) * sizeof(WCHAR);

            /*
             *  rpcBuffer is a workaround for 229753.
             */

            rpcBuffer = LocalAlloc(LPTR, Length * sizeof(WCHAR));
            if (rpcBuffer != NULL) {
                CopyMemory(rpcBuffer, pSerialNumberString, Length);
            } else {
                SetLastError(ERROR_OUTOFMEMORY);
                return(FALSE);
            }

        } else {
            Length = 0;
            rpcBuffer = NULL;
        }

        rc = RpcWinStationGenerateLicense(
                    hServer,
                    &Result,
                    rpcBuffer,
                    Length,
                    (PCHAR)pLicense,
                    LicenseSize
                    );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*******************************************************************************
 *
 *  WinStationInstallLicense
 *
 *  Called to install a license.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input)
 *       Pointer to a License structure containing the license to
 *       be installed
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *
 *    TRUE  -- The install operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationInstallLicense(
    HANDLE hServer,
    PVOID  pLicense,
    DWORD  LicenseSize
    )
{
    BOOLEAN rc;
    DWORD   Result;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationInstallLicense(
                     hServer,
                     &Result,
                     (PCHAR) pLicense,
                     LicenseSize
                     );

        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationEnumerateLicenses
 *
 *  Called to return the list of valid licenses.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    ppLicense (output)
 *       Points to a pointer to a buffer to receive the enumeration results,
 *       which are returned as an array of LICENSE structures.  The buffer is
 *       allocated within this API and is disposed of using
 *       WinStationFreeMemory.
 *    pEntries (output)
 *       Points to a variable specifying the number of entries read.
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

#define _LICENSE_REQUEST_SIZE 10
#define _LICENSE_SIZE         1024  // This is arbitrary
BOOLEAN
WinStationEnumerateLicenses(
    HANDLE hServer,
    PVOID  *ppLicense,
    DWORD  *pEntries
    )
{
    ULONG ByteCount;
    ULONG BumpSize;
    ULONG TotalSize;
    LONG Index;
    int i;
    BOOLEAN rc;
    DWORD   Result;

    HANDLE_CURRENT_BINDING( hServer );

    BumpSize =  _LICENSE_SIZE * _LICENSE_REQUEST_SIZE;
    TotalSize = 0;
    *ppLicense = NULL;
    *pEntries = 0;
    Index = 0;
    for ( ;; ) {
        PVOID pNewLicense;
        LONG BumpEntries;

        /*
         *  Allocate a enough memory for _LICENSE_REQUEST_SIZE more
         *  entries.
         */
        pNewLicense = LocalAlloc( 0, TotalSize + BumpSize );
        if ( !pNewLicense ) {
            if ( *ppLicense )
                WinStationFreeMemory( *ppLicense );
            SetLastError( ERROR_OUTOFMEMORY );
            return( FALSE );
        }

        /*
         * If this is not the first pass through, then copy
         * the previous buffer's contents to the new buffer.
         */
        if ( TotalSize ) {
            RtlCopyMemory( pNewLicense, *ppLicense, TotalSize );
            WinStationFreeMemory( *ppLicense );
        }
        *ppLicense = pNewLicense;

        /*
         *  Get up to _LICENSE_REQUEST_SIZE Licenses
         */
        ByteCount = BumpSize;
        BumpEntries = _LICENSE_REQUEST_SIZE;

        RpcTryExcept {

            rc = RpcWinStationEnumerateLicenses(
                         hServer,
                         &Result,
                         &Index,
                         &BumpEntries,
                         (PCHAR) (((PCHAR) *ppLicense) + TotalSize),
                         ByteCount,
                         &ByteCount
                         );

            Result = rc ? ERROR_SUCCESS : Result;
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
            Result = RpcExceptionCode();
            DBGPRINT(("RPC Exception %d\n",Result));
        }
        RpcEndExcept

        if ( Result != ERROR_SUCCESS && Result != ERROR_NO_MORE_ITEMS ) {

            SetLastError( Result );
            return( FALSE );

        }
        else {
            /*
             *  Bump the Total Size of the License buffer by the size of
             *  the request
             */
            TotalSize += BumpSize;

            /*
             *  Include the new Licenses in the entry count
             */
            *pEntries += BumpEntries;

            if ( Result == ERROR_NO_MORE_ITEMS ) {
                return( TRUE );
            }
        }
    } // for ( ;; )
}

/*******************************************************************************
 *
 *  WinStationActivateLicense
 *
 *  Called to Activate a license for a given License
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input/output)
 *       Pointer to a License structure that will be activated
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *    pActivationCode (input)
 *       Pointer to a null-terminated, wide-character Activation Code string
 *
 * EXIT:
 *
 *    TRUE  -- The install operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationActivateLicense(
    HANDLE hServer,
    PVOID  pLicense,
    DWORD  LicenseSize,
    PWCHAR pActivationCode
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   Length;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        if ( pActivationCode ) {
            Length = (lstrlenW( pActivationCode ) + 1) * sizeof(WCHAR);

            /*
             *  rpcBuffer is a workaround for 229753.
             */

            rpcBuffer = LocalAlloc(LPTR, Length * sizeof(WCHAR));
            if (rpcBuffer != NULL) {
                CopyMemory(rpcBuffer, pActivationCode, Length);
            } else {
                SetLastError(ERROR_OUTOFMEMORY);
                return(FALSE);
            }

        } else {
            Length = 0;
            rpcBuffer = NULL;
        }

        rc = RpcWinStationActivateLicense(
                    hServer,
                    &Result,
                    (PCHAR)pLicense,
                    LicenseSize,
                    rpcBuffer,
                    Length
                    );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}


/*****************************************************************************
 *
 *  WinStationQueryLicense
 *
 *   Query the license(s) on the WinFrame server and the network
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicenseCounts (output)
 *       pointer to buffer to return license count structure
 *    ByteCount (input)
 *       length of buffer in bytes
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
WinStationQueryLicense(
    HANDLE hServer,
    PVOID pLicenseCounts,
    ULONG ByteCount
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        memset( pLicenseCounts, 0, ByteCount );

        rc = RpcWinStationQueryLicense(
                     hServer,
                     &Result,
                     (PCHAR) pLicenseCounts,
                     ByteCount
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  WinStationQueryUpdateRequired
 *
 *   Query the license(s) on the WinFrame server and determine if an
 *   update is required. (worker)
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pUpdateFlag (output)
 *       Update flag, set if an update is required
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
WinStationQueryUpdateRequired(
    HANDLE hServer,
    PULONG pUpdateFlag
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationQueryUpdateRequired(
                     hServer,
                     &Result,
                     pUpdateFlag
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationRemoveLicense
 *
 *  Called to remove a license diskette.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input)
 *       Pointer to a License structure containing the license to
 *       be removed
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *
 *    TRUE  -- The install operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationRemoveLicense(
    HANDLE hServer,
    PVOID  pLicense,
    DWORD  LicenseSize
    )
{
    BOOLEAN rc;
    DWORD   Result;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationRemoveLicense(
                     hServer,
                     &Result,
                     (PCHAR) pLicense,
                     LicenseSize
                     );

        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationSetPoolCount
 *
 *  Called to change the PoolCount for a given License
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input/output)
 *       Pointer to a License structure that will be changed
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *
 *    TRUE  -- The change operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationSetPoolCount(
    HANDLE hServer,
    PVOID  pLicense,
    DWORD  LicenseSize
    )
{
    BOOLEAN rc;
    DWORD   Result;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationSetPoolCount(
                     hServer,
                     &Result,
                     (PCHAR) pLicense,
                     LicenseSize
                     );

        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}


/*****************************************************************************
 *
 *  _WinStationAnnoyancePopup
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationAnnoyancePopup(
    HANDLE hServer,
    ULONG LogonId
    )
{
    BOOLEAN rc;
    DWORD   Result;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationAnnoyancePopup(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationCallback
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationCallback(
    HANDLE hServer,
    ULONG LogonId,
    LPWSTR pPhoneNumber
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   Length;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        if( pPhoneNumber ) {
            Length = (lstrlenW( pPhoneNumber ) + 1) * sizeof(WCHAR);

            /*
             *  rpcBuffer is a workaround for 229753.
             */

            rpcBuffer = LocalAlloc(LPTR, Length * sizeof(WCHAR));
            if (rpcBuffer != NULL) {
                CopyMemory(rpcBuffer, pPhoneNumber, Length);
            } else {
                SetLastError(ERROR_OUTOFMEMORY);
                return(FALSE);
            }

        } else {
            Length = 0;
            rpcBuffer = NULL;
        }

        rc = RpcWinStationCallback(
                    hServer,
                    &Result,
                    (LogonId == LOGONID_CURRENT) ?
                        NtCurrentPeb()->SessionId : LogonId,
                    rpcBuffer,
                    Length
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationBreakPoint
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationBreakPoint(
    HANDLE hServer,
    ULONG LogonId,
    BOOLEAN KernelFlag
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationBreakPoint(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId,
                     KernelFlag
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationReadRegistry
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationReadRegistry(
    HANDLE  hServer
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        rc = RpcWinStationReadRegistry(
                     hServer,
                     &Result
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationUpdateSettings
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationUpdateSettings(
    HANDLE  hServer,
    WINSTATIONUPDATECFGCLASS SettingsClass,
    DWORD SettingsParameters
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        rc = RpcWinStationUpdateSettings(
                     hServer,
                     &Result,
                     (DWORD)SettingsClass,
                     SettingsParameters
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}


/*****************************************************************************
 *
 *  _WinStationReInitializeSecurity
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationReInitializeSecurity(
    HANDLE  hServer
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        rc = RpcWinStationReInitializeSecurity(
                     hServer,
                     &Result
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationWaitForConnect
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationWaitForConnect(
    VOID
    )
{
    DWORD Result;
    BOOLEAN rc;
    HANDLE hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        if (NtCurrentPeb()->SessionId != 0) {
            DbgPrint("hServer == RPC_HANDLE_NO_SERVER for SessionId %d\n",NtCurrentPeb()->SessionId);
            ASSERT(FALSE);
            return FALSE;
        } else {
            return TRUE;
        }
    }

    RpcTryExcept {

        rc = RpcWinStationWaitForConnect(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId()
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationNotifyLogon
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationNotifyLogon(
    BOOLEAN fUserIsAdmin,
    HANDLE UserToken,
    PWCHAR pDomain,
    PWCHAR pUserName,
    PWCHAR pPassword,
    UCHAR Seed,
    PUSERCONFIGW pUserConfig
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   DomainLength;
    DWORD   UserNameLength;
    DWORD   PasswordLength;
    HANDLE hServer = SERVERNAME_CURRENT;
    HANDLE ReadyEventHandle;
    DWORD TermSrvWaitTime = 180 * 1000;  // 3 Minutes
    WCHAR*  rpcBuffer1 = NULL;
    WCHAR*  rpcBuffer2 = NULL;
    WCHAR*  rpcBuffer3 = NULL;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    //
    // Wait for the TermSrvReadyEvent to be set by TERMSRV.EXE.  This
    // event indicates that TermSrv is initialized to the point that
    // the data used by _WinStationNotifyLogon() is available.
    //
    ReadyEventHandle = CreateEvent(NULL, TRUE, FALSE,
                                   TEXT("Global\\TermSrvReadyEvent"));
    if (ReadyEventHandle != NULL)
       {
       if (WaitForSingleObject(ReadyEventHandle, TermSrvWaitTime) != 0)
          {
          DBGPRINT(("WinLogon:  Wait for ReadyEventHandle failed\n"));
          }
       CloseHandle(ReadyEventHandle);
       }
    else
       {
       DBGPRINT(("WinLogon:  Create failed for ReadyEventHandle\n"));
       }


    RpcTryExcept {

        if( pDomain ) {
            DomainLength = (lstrlenW( pDomain ) + 1) * sizeof(WCHAR);

            /*
             *  rpcBuffer[1,2,3] is a workaround for 229753.
             */

            rpcBuffer1 = LocalAlloc(LPTR, DomainLength * sizeof(WCHAR));
            if (rpcBuffer1 != NULL) {
                CopyMemory(rpcBuffer1, pDomain, DomainLength);
            } else {
                Result = ERROR_OUTOFMEMORY;
                rc = FALSE;
                goto Error;
            }

        } else {
            DomainLength = 0;
            rpcBuffer1 = NULL;
        }

        if( pUserName ) {
            UserNameLength = (lstrlenW( pUserName ) + 1) * sizeof(WCHAR);

            rpcBuffer2 = LocalAlloc(LPTR, UserNameLength * sizeof(WCHAR));
            if (rpcBuffer2 != NULL) {
                CopyMemory(rpcBuffer2, pUserName, UserNameLength);
            } else {
                Result = ERROR_OUTOFMEMORY;
                rc = FALSE;
                goto Error;
            }

        } else {
            UserNameLength = 0;
            rpcBuffer2 = NULL;
        }

        if( pPassword ) {
            PasswordLength = (lstrlenW( pPassword ) + 1) * sizeof(WCHAR);

            rpcBuffer3 = LocalAlloc(LPTR, PasswordLength * sizeof(WCHAR));
            if (rpcBuffer3 != NULL) {
                CopyMemory(rpcBuffer3, pPassword, PasswordLength);
            } else {
                Result = ERROR_OUTOFMEMORY;
                rc = FALSE;
                goto Error;
            }

        } else {
            PasswordLength = 0;
            rpcBuffer3 = NULL;
        }

        rc = RpcWinStationNotifyLogon(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId(),
                     fUserIsAdmin,
                     (DWORD)(INT_PTR)UserToken,
                     rpcBuffer1,
                     DomainLength,
                     rpcBuffer2,
                     UserNameLength,
                     rpcBuffer3,
                     PasswordLength,
                     Seed,
                     (PCHAR)pUserConfig,
                     sizeof(*pUserConfig)
                     );

        if( !rc ) {
            Result = RtlNtStatusToDosError( Result );

        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

Error:
    if (rpcBuffer1 != NULL) {
        LocalFree(rpcBuffer1);
    }

    if (rpcBuffer2 != NULL) {
        LocalFree(rpcBuffer2);
    }

    if (rpcBuffer3 != NULL) {
        LocalFree(rpcBuffer3);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************
 *
 *  _WinStationNotifyLogoff
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationNotifyLogoff(
    VOID
    )
{
    DWORD Result;
    BOOLEAN rc;
    HANDLE hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        rc = RpcWinStationNotifyLogoff(
                     hServer,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId(),
                     &Result
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}


/*****************************************************************************
 *
 *  _WinStationNotifyNewSession
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_WinStationNotifyNewSession(
    HANDLE hServer,
    ULONG  LogonId
    )
{
    DWORD Result;
    BOOLEAN rc;

    //
    //  If the local machine has no TSRPC interface running, this is most
    //  likely the console winlogon attempting to logon before termsrv.exe
    //  is running.
    //

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER )
    {
        return(TRUE);
    }
    
    RpcTryExcept {

        rc = RpcWinStationNotifyNewSession(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId
                     );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}



/*****************************************************************************
 *
 *  _RpcServerNWLogonSetAdmin
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_NWLogonSetAdmin(
    HANDLE hServer,
    PWCHAR pServerName,
    PNWLOGONADMIN pNWLogon
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   ServerNameLength;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    if (pServerName) {
        ServerNameLength = (lstrlenW(pServerName) + 1) * sizeof(WCHAR);

        /*
         *  rpcBuffer is a workaround for bug 229753. The bug can't be fixed
         *  completely without breaking TS4 clients.
         */

        rpcBuffer = LocalAlloc(LPTR, ServerNameLength * sizeof(WCHAR));
        if (rpcBuffer != NULL) {
            CopyMemory(rpcBuffer, pServerName, ServerNameLength);
        } else {
            SetLastError(ERROR_OUTOFMEMORY);
            return(FALSE);
        }

    } else {
        ServerNameLength = 0;
        rpcBuffer = NULL;
    }

    RpcTryExcept {

        rc = RpcServerNWLogonSetAdmin(
                    hServer,
                    &Result,
                    rpcBuffer,
                    ServerNameLength,
                    (PCHAR)pNWLogon,
                    sizeof(NWLOGONADMIN)
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************
 *
 *  _RpcServerNWLogonQueryAdmin
 *
 *   Comment
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ****************************************************************************/

BOOLEAN WINAPI
_NWLogonQueryAdmin(
    HANDLE hServer,
    PWCHAR pServerName,
    PNWLOGONADMIN pNWLogon
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   ServerNameLength;
    WCHAR*  rpcBuffer;

    HANDLE_CURRENT_BINDING( hServer );

    if (pServerName) {
        ServerNameLength = (lstrlenW(pServerName) + 1) * sizeof(WCHAR);

        /*
         *  rpcBuffer is a workaround for bug 229753. The bug can't be fixed
         *  completely without breaking TS4 clients.
         */

        rpcBuffer = LocalAlloc(LPTR, ServerNameLength * sizeof(WCHAR));
        if (rpcBuffer != NULL) {
            CopyMemory(rpcBuffer, pServerName, ServerNameLength);
        } else {
            SetLastError(ERROR_OUTOFMEMORY);
            return(FALSE);
        }

    } else {
        ServerNameLength = 0;
        rpcBuffer = NULL;
    }

    RpcTryExcept {

        rc = RpcServerNWLogonQueryAdmin(
                    hServer,
                    &Result,
                    rpcBuffer,
                    ServerNameLength,
                    (PCHAR)pNWLogon,
                    sizeof(NWLOGONADMIN)
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if (rpcBuffer != NULL) {
        LocalFree(rpcBuffer);
    }
    if( !rc ) SetLastError(Result);
    return( rc );
}

/*******************************************************************************
 *
 *  _WinStationCheckForApplicationName
 *
 *    Handles published applications.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
_WinStationCheckForApplicationName(
    HANDLE hServer,
    ULONG  LogonId,
    PWCHAR pUserName,
    DWORD  UserNameSize,
    PWCHAR pDomain,
    DWORD  DomainSize,
    PWCHAR pPassword,
    DWORD  *pPasswordSize,
    DWORD  MaxPasswordSize,
    PCHAR  pSeed,
    PBOOLEAN pfPublished,
    PBOOLEAN pfAnonymous
    )
{
    DWORD Result;
    BOOLEAN rc;
    WCHAR*  rpcBufferName;
    WCHAR*  rpcBufferDomain;
    WCHAR*  rpcBufferPassword;


    HANDLE_CURRENT_BINDING( hServer );

//  Since, due to legacy clients, we cannot change the interface,
//  as a workarround to bug#265954, we double the size of RPC Buffers.

    rpcBufferName = LocalAlloc(LPTR, UserNameSize * sizeof(WCHAR));
    if (rpcBufferName != NULL) {
        CopyMemory(rpcBufferName, pUserName, UserNameSize);
    } else {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    rpcBufferDomain = LocalAlloc(LPTR, DomainSize * sizeof(WCHAR));
    if (rpcBufferDomain != NULL) {
        CopyMemory(rpcBufferDomain, pDomain, DomainSize);
    } else {
        LocalFree(rpcBufferName);
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    rpcBufferPassword = LocalAlloc(LPTR,MaxPasswordSize * sizeof(WCHAR));
    if (rpcBufferPassword != NULL) {
        CopyMemory(rpcBufferPassword, pPassword, MaxPasswordSize);
    } else {
        LocalFree(rpcBufferName);
        LocalFree(rpcBufferDomain);
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }




    RpcTryExcept {

        rc = RpcWinStationCheckForApplicationName(
                 hServer,
                 &Result,
                 LogonId,
                 rpcBufferName,
                 UserNameSize,
                 rpcBufferDomain,
                 DomainSize,
                 rpcBufferPassword,
                 pPasswordSize,
                 MaxPasswordSize,
                 pSeed,
                 pfPublished,
                 pfAnonymous
                 );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    LocalFree(rpcBufferName);
    LocalFree(rpcBufferDomain);
    LocalFree(rpcBufferPassword);

    if( !rc ) SetLastError(Result);
    return( rc );


}

/*******************************************************************************
 *
 *  _WinStationGetApplicationInfo
 *
 *    Gets info about published applications.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
_WinStationGetApplicationInfo(
    HANDLE hServer,
    ULONG  LogonId,
    PBOOLEAN pfPublished,
    PBOOLEAN pfAnonymous
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationGetApplicationInfo(
                 hServer,
                 &Result,
                 LogonId,
                 pfPublished,
                 pfAnonymous
                 );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*******************************************************************************
 *
 *  WinStationNtsdDebug
 *
 *    Set up a debug connection for ntsd
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The function succeeds
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationNtsdDebug(
    ULONG  LogonId,
    LONG   ProcessId,
    ULONG  DbgProcessId,
    ULONG  DbgThreadId,
    PVOID  AttachCompletionRoutine
    )
{
    DWORD Result;
    BOOLEAN rc;
    HANDLE hServer = SERVERNAME_CURRENT;

    NTSDDBGPRINT(("In WinStationNtsdDebug command\n"));
    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationNtsdDebug(
                 hServer,
                 &Result,
                 LogonId,
                 ProcessId,
                 DbgProcessId,
                 DbgThreadId,
                 (DWORD_PTR) AttachCompletionRoutine
                 );

        DbgPrint("RpcWinStationNtsdDebug: returned 0x%x\n", rc);
        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    NTSDDBGPRINT(("WinStationNtsdDebug returning %d\n", rc));
    return( rc );
}

/*******************************************************************************
 *
 *  WinStationGetTermSrvCountersValue
 *
 *    Gets TermSrv Counters value
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
WinStationGetTermSrvCountersValue(
    HANDLE hServer,
    ULONG  dwEntries,
    PVOID  pCounter
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {
        rc = RpcWinStationGetTermSrvCountersValue(
                hServer,
                &Result,
                dwEntries,
                (PTS_COUNTER)pCounter
                );

        Result = RtlNtStatusToDosError( Result );
        if( !rc ) SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}
/*****************************************************************************
 *
 *  WinStationBroadcastSystemMessageWorker
 *
 *   Perform the the equivalent to Window's standard API BroadcastSystemMessage to
 *        all Hydra sessions.  This is an exported function, at least used by the PNP manager to
 *         send a device  change message to all sessions.
 *
 * LIMITATIONS:
 *          some messages, such as WM_COPYDATA send an address pointer to some user data as lParam.
 *          In this API. the only such case that is currently supported is for WM_DEVICECHANGE
 *          No error code will be returned if you try to use such an unsupported message, simply the
 *          lParam will be ignored.
 *
 * ENTRY:
 *        hServer
 *            this is a handle which identifies a Hydra server. For the local server, hServer
 *            should be set to SERVERNAME_CURRENT
 *
 *        sendToAllWinstations
 *          This should be set to TRUE if you want to broadcast message to all winstations
 *
 *        sessionID,
 *          if sendToAllWinstations = FALSE, then message is only sent to only the
 *          winstation with the specified sessionID
 *
 *        timeOut
 *          set this to the amount of time you are willing to wait to get a response
 *          from the specified winstation. Even though Window's SendMessage API
 *          is blocking, the call from this side MUST choose how long it is willing to
 *          wait for a response.
 *
 *        dwFlags
 *          see MSDN on BroadcastSystemMessage(). Be aware that POST is not allowed on any
 *          where the wparam is a pointer to some user mode data structure.
 *          For more info, see ntos\...\client\ntstubs.c
 *
 *        lpdwRecipients
 *          Pointer to a variable that contains and receives information about the recipients of the message.
 *          see MSDN for more info
 *
 *        uiMessage
 *          the window's message to send, limited to WM_DEVICECHANGE and WM_SETTINGSCHANGE
 *          at this time.
 *
 *        wParam
 *            first message param
 *
 *        lParam
 *            second message parameter
 *
 *        pResponse
 *          this is the response to the message sent, see MSDN
 *
 *        idOfSessionBeingIgnored
 *          if -1, then no sessions are ignored. Else, the id of the session passed in is ignored
 *
 * EXIT:
 *        TRUE    if all went well or
 *        FALSE   if something went wrong.
 *
 * WARNINGs:
 *        since the RPC call never blocks, you need to specify a reasonable timeOut if you want to wait for
 *         a response. Please remember that since this message is being sent to all winstations, the timeOut value
 *        will be on per-winstation.
 *
 *        Also, Do not use flag  BSF_POSTMESSAGE, since an app/window on a
 *        winstation is not setup to send back a response to the
 *        query in an asynchronous fashion.
 *        You must wait for the response (until the time out period).
 *
 * Comments:
 *      For more info, please see MSDN for BroadcastSystemMessage()
 *
 ****************************************************************************/

LONG WinStationBroadcastSystemMessageWorker(
        HANDLE hServer,
        BOOL    sendToAllWinstations,
        ULONG   sessionID,
        ULONG   timeOut,
        DWORD   dwFlags,
        DWORD   *lpdwRecipients,
        ULONG   uiMessage,
        WPARAM  wParam,
        LPARAM  lParam,
        LONG    *pResponse,             // this is the response to the message sent
        DWORD   idOfSessionBeingIgnored
    )
{

    DWORD   Result = ERROR_SUCCESS;
    LONG rc;
    LONG    status;
    ULONG   i;
    LONG    response=0;

    PLOGONID    pWd;
    ULONG       ByteCount, Index;
    UINT        WdCount;

    // these are used for PNP messages
    PBYTE   rpcBuffer=NULL;
    ULONG   bufferSize=0;
    ULONG   maxSize;

    BOOLEAN fBufferHasValidData = FALSE;

    // Since the PNP message uses the lparam to pass the address of a user memory location, we
    // need to handle this by creating our own copy of that data, and then pass it to
    // termServ

    // we may want to make this general for the future... hence use switch
    switch( uiMessage )
    {
            // if this is a PNP message
    case    WM_DEVICECHANGE:

            if ( lParam )   // see if the PNP message has a pointer to some user data
            {
                bufferSize = ( (DEV_BROADCAST_HDR *)(lParam))->dbch_size;
                rpcBuffer = LocalAlloc( LPTR, bufferSize );
                if ( rpcBuffer )
                {
                    // copy from user-space into our local rpc buffer
                    CopyMemory(rpcBuffer, (PBYTE)lParam, bufferSize );
                    fBufferHasValidData = TRUE;
                }
                else
                {
                    SetLastError( ERROR_OUTOFMEMORY );
                    return ( FALSE );
                }
            }
    break;


    // if this is a settings change message the system-CPL sends out
    // when an Admin changes the system env vars...
    case WM_SETTINGCHANGE:
            if ( lParam )   // see if message has a string data
            {
                // put some artificial limit on how large a buffer we are willing to use
                // in order to protect against malicious use of this api
                maxSize = 4096;

                bufferSize = lstrlenW( (PWCHAR) lParam ) * sizeof( WCHAR );
                if ( bufferSize < maxSize )
                {
                    rpcBuffer = LocalAlloc( LPTR, bufferSize );
                    if ( rpcBuffer )
                    {
                        // copy from user-space into our local rpc buffer
                        CopyMemory(rpcBuffer, (PBYTE) lParam, bufferSize );
                        fBufferHasValidData = TRUE;

                    }
                    else
                    {
                        SetLastError( ERROR_OUTOFMEMORY );
                        return ( FALSE );
                    }
                }
                else
                {
                    // we have too many
                    // vars in the user's profile.
                    KdPrint(("lParam length too big = %d \n", bufferSize));
                    break;
                    SetLastError( ERROR_MESSAGE_EXCEEDS_MAX_SIZE );
                    return ( FALSE );
                }
            }

    break;

    }

    //
    // if the rpcBuffer is still empty (meaning, this was not a PNP message), we must fill it up
    // with some bogus data, otherwise, we will get an RPC error of RPC_X_NULL_REF_POINTER
    // (error code of 1780). It looks like Rpc does not check the
    // bufferSize value, and it just throws an exception if the buffer is NULL.
    //
    if ( !rpcBuffer )
    {
        rpcBuffer = LocalAlloc( LPTR, sizeof(UINT) );
        if (!rpcBuffer)
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return ( FALSE );
        }
        bufferSize = sizeof(UINT);
        fBufferHasValidData = FALSE;    // note that this is set to FALSE, which means, the recepient will
                                        // not use the buffer. We do free the alloc below in either case.
    }

    HANDLE_CURRENT_BINDING_BUFFER( hServer, rpcBuffer );

    WdCount = 1000;
    pWd = NULL; // it will be allocated  by Winstation Enumerate()
    rc = WinStationEnumerate( hServer, &pWd, &WdCount );

    /*
     * Do not use this flag, since no process on the session side can respond back to a console process
     * thru the post message mechanism, since there is no session ID abstraction in that call.
     */
    dwFlags &= ~BSF_POSTMESSAGE;

    if ( rc != TRUE )
    {
        status = GetLastError();
        DBGPRINT(( "WinstationEnumerate = %d, failed at %s %d\n", status,__FILE__,__LINE__));
        if ( pWd )
        {
            WinStationFreeMemory(pWd);
        }
        return(FALSE);
    }


    //
    // the loop for sending data to each winstation
    //
    for ( i=0; i < WdCount; i++ )
    {
            // id of the session being ignored
            if ( pWd[i].SessionId == idOfSessionBeingIgnored)
                continue;

            // either send to all winstations, or to a specific winstation
            if ( sendToAllWinstations ||  pWd[i].SessionId == sessionID )
            {
                // don't send message to any winstation unless it is either Active or in the disconnect state
                if ( pWd[i].State == State_Active ||
                        pWd[i].State == State_Disconnected)
                {
                    RpcTryExcept
                    {
                        rc = RpcWinStationBroadcastSystemMessage(
                                        hServer,
                                        pWd[i].SessionId,
                                        timeOut,
                                        dwFlags,
                                        lpdwRecipients,
                                        uiMessage,
                                        wParam,
                                        lParam,
                                        rpcBuffer,
                                        bufferSize,
                                        fBufferHasValidData,
                                        &response   );

                        DBGPRINT(("done with call RpcWinStationBroadcastSystemMessage() for sessionID= %d\n",  pWd[i].SessionId ));
                        *pResponse |= response;        // keep an OR of all return values

                        // @@@
                        // if response is -1 from any winstation, maybe we should give up and return ?
                    }
                    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
                    {
                        Result = RpcExceptionCode();
                        DBGPRINT(("RPC Exception %d in RpcWinStationBroadcastSystemMessage() for sessionID = %d \n",Result, sessionID));
                        rc = FALSE;        // change rc to FALSE
                        break;    // get out of the for-loop, we have a problem with at least one of the winstations
                    }
                    RpcEndExcept

            }    // end if winstation state check

        }   // if ( sendToAllWinstations ||  pWd[i].SessionId == sessionID )

    }    // end of the for loop

    WinStationFreeMemory(pWd);

    LocalFree( rpcBuffer );

    SetLastError( Result );

    return( rc );
}

/*************************************************************************
*                                                                        *
* This struct is used to pack data passed into a workder thread which is *
* altimetly passed to WinStationBroadcastSystemMessageWorker()           *
*                                                                        *
*************************************************************************/
typedef struct {
        HANDLE hServer;
        BOOL    sendToAllWinstations;
        ULONG   sessionID;
        ULONG   timeOut;
        DWORD   dwFlags;
        DWORD   *lpdwRecipients;
        ULONG   uiMessage;
        WPARAM  wParam;
        LPARAM  lParam;
        LONG    *pResponse;
        DWORD   idOfSessionBeingIgnored ;
} BSM_DATA_PACKAGE;

/***********************************************************************************************
*                                                                                              *
* This is a workder thread used to make a call into WinStationBroadcastSystemMessageWorker()   *
* The reason for this is in certain cases, we don't want to block the caller of this func from *
* processing window messages                                                                   *
* DWORD WINAPI WinStationBSMWorkerThread( LPVOID p )                                           *
*
***********************************************************************************************/
DWORD WINAPI WinStationBSMWorkerThread( LPVOID p )
{
    DWORD rc;
    BSM_DATA_PACKAGE *pd = (BSM_DATA_PACKAGE *)p;

    rc  = WinStationBroadcastSystemMessageWorker(
             pd->hServer              ,
             pd->sendToAllWinstations ,
             pd->sessionID            ,
             pd->timeOut              ,
             pd->dwFlags              ,
             pd->lpdwRecipients       ,
             pd->uiMessage            ,
             pd->wParam               ,
             pd->lParam               ,
             pd->pResponse            ,
             pd->idOfSessionBeingIgnored);

    return rc;
}

/**************************************************************************************************
*                                                                                                 *
* This func is used to wait on a thread, and still allow the user of this thread (aka the creator *
* of this thread) to process window messages                                                      *
*                                                                                                 *
**************************************************************************************************/
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent, DWORD dwTimeout)
{
    while (1)
    {
        MSG msg;

        DWORD dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE, dwTimeout, QS_ALLEVENTS);

        // Are we done waiting?
        switch (dwObject)
        {
            case WAIT_OBJECT_0:
            case WAIT_FAILED:
                return dwObject;

            case WAIT_TIMEOUT:
                return WAIT_TIMEOUT;

            case WAIT_OBJECT_0 + 1:
                // This PeekMessage has the side effect of processing any broadcast messages.
                // It doesn't matter what message we actually peek for but if we don't peek
                // then other threads that have sent broadcast sendmessages will hang until
                // hEvent is signaled.  Since the process we're waiting on could be the one
                // that sent the broadcast message that could cause a deadlock otherwise.
                PeekMessage(&msg, NULL, WM_NULL, WM_USER, PM_NOREMOVE);
            break;
        }
    }
    // never gets here
    // return dwObject;
}

/*****************************************************************************
 *
 *  WinStationBroadcastSystemMessage
 *
 *   Perform the the equivalent to Window's standard API BroadcastSystemMessage to
 *        all Hydra sessions.  This is an exported function, at least used by the PNP manager to
 *         send a device  change message to all sessions.
 *
 * LIMITATIONS:
 *          some messages, such as WM_COPYDATA send an address pointer to some user data as lParam.
 *          In this API. the only such case that is currently supported is for WM_DEVICECHANGE
 *          No error code will be returned if you try to use such an unsupported message, simply the
 *          lParam will be ignored.
 *
 *          This func will only allow WM_DEVICECHNAGE and WM_SETTINGSCHANGE to go thru.
 *
 * ENTRY:
 *        hServer
 *            this is a handle which identifies a Hydra server. For the local server, hServer
 *            should be set to SERVERNAME_CURRENT
 *
 *        sendToAllWinstations
 *          This should be set to TRUE if you want to broadcast message to all winstations
 *
 *        sessionID,
 *          if sendToAllWinstations = FALSE, then message is only sent to only the
 *          winstation with the specified sessionID
 *
 *        timeOut [ IN SECONDS ]
 *          set this to the amount of time you are willing to wait to get a response
 *          from the specified winstation. Even though Window's SendMessage API
 *          is blocking, the call from this side MUST choose how long it is willing to
 *          wait for a response.
 *
 *        dwFlags
 *          see MSDN on BroadcastSystemMessage(). Be aware that POST is not allowed on any
 *          where the wparam is a pointer to some user mode data structure.
 *          For more info, see ntos\...\client\ntstubs.c
 *
 *        lpdwRecipients
 *          Pointer to a variable that contains and receives information about the recipients of the message.
 *          see MSDN for more info
 *
 *        uiMessage
 *          the window's message to send, limited to WM_DEVICECHANGE and WM_SETTINGSCHANGE
 *          at this time.
 *
 *        wParam
 *            first message param
 *
 *        lParam
 *            second message parameter
 *
 *        pResponse
 *          this is the response to the message sent, see MSDN
 *
 * EXIT:
 *        TRUE    if all went well or
 *        FALSE   if something went wrong.
 *
 * WARNINGs:
 *        since the RPC call never blocks, you need to specify a reasonable timeOut if you want to wait for
 *         a response. Please remember that since this message is being sent to all winstations, the timeOut value
 *        will be on per-winstation.
 *
 *        Also, Do not use flag  BSF_POSTMESSAGE, since an app/window on a
 *        winstation is not setup to send back a response to the
 *        query in an asynchronous fashion.
 *        You must wait for the response (until the time out period).
 *
 *       For WM_SETTINGGSCHNAGE, a second therad is used to allow the caller to still process windows
 *       messages.
 *       For WM_DEVICECHANGE, no such thread is used.
 *
 * Comments:
 *      For more info, please see MSDN for BroadcastSystemMessage()
 *
 ****************************************************************************/
LONG WinStationBroadcastSystemMessage(
        HANDLE hServer,
        BOOL    sendToAllWinstations,
        ULONG   sessionID,
        ULONG   timeOut,
        DWORD   dwFlags,
        DWORD   *lpdwRecipients,
        ULONG   uiMessage,
        WPARAM  wParam,
        LPARAM  lParam,
        LONG    *pResponse        // this is the response to the message sent
    )
{

    LONG    rc;
    DWORD   dwRecipients=0;        // caller may be passing null, so use a local var 1st, and then set
                                   // value passed in by caller if an only if the caller's address is not null.

    BOOLEAN fBufferHasValidData = FALSE;

    BOOL bIsTerminalServer = !!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer));
    if (!bIsTerminalServer)
    {
        return TRUE;    // all is well, but we are not on a Hydra server
    }

    if (lpdwRecipients) // if caller passed in a non-NULL pointer for lpdwRec, use it's value
    {
       dwRecipients = *lpdwRecipients ;
    }


    // we may want to make this general for the future, but for now...
    // we only let WM_DEVICECHANGE or WM_SETTINGCHANGE messages to go thru
    switch ( uiMessage)
    {
        case    WM_DEVICECHANGE:
            rc = WinStationBroadcastSystemMessageWorker(
                hServer,
                sendToAllWinstations,
                sessionID,
                timeOut,
                dwFlags,
                &dwRecipients,
                uiMessage,
                wParam,
                lParam,
                pResponse,
                NtCurrentPeb()->SessionId   // ID of the session to be ignored.
                );

                if (lpdwRecipients) // if caller passed in a non-NULL pointer for lpdwRec, then set value
                {
                    *lpdwRecipients = dwRecipients;
                }

        break;
    
        case    WM_SETTINGCHANGE:
    
                {
                    BSM_DATA_PACKAGE    d;
                    ULONG               threadID;
                    HANDLE              hThread;
    
                    //pack the data passed to the thread proc
                    d.hServer              = hServer ;
                    d.sendToAllWinstations = sendToAllWinstations;
                    d.sessionID            = sessionID;
                    d.timeOut              = timeOut;
                    d.dwFlags              = dwFlags;
                    d.lpdwRecipients       = &dwRecipients;
                    d.uiMessage            = uiMessage;
                    d.wParam               = wParam;
                    d.lParam               = lParam;
                    d.pResponse            = pResponse;
                    d.idOfSessionBeingIgnored = NtCurrentPeb()->SessionId ;    
                                                    // a remote admin may change env-settings
                                                    // and expect all sessions includin the
                                                    // console session to be updated
                                                    // A -1 means no sessions are ignored
                                                    // Call from shell\cpls\system\envvar.c already sent the message to the current session
    
    
                    hThread = CreateThread( NULL, 0, WinStationBSMWorkerThread,
                        (void *) &d, 0 , &threadID );
    
                    if ( hThread )
                    {
                        MsgWaitForMultipleObjectsLoop( hThread, INFINITE );
                        if (lpdwRecipients) // if caller passed in a non-NULL pointer for lpdwRec, then set value
                        {
                            *lpdwRecipients = *d.lpdwRecipients ;
                        }
                        GetExitCodeThread( hThread, &rc );
                        CloseHandle( hThread );
                    }
                    else
                    {
                        rc = FALSE;
                    }
                }
        break;
    
    
        default:
            DBGPRINT(("Request is rejected \n"));
            rc = FALSE;
        break;
    }

    return rc;

}


/*****************************************************************************
 *
 *  WinStationSendWindowMessage
 *
 *   Perform the the equivalent to SendMessage to a specific winstation as
 *        identified by the session ID.  This is an exported function, at least used
 *        by the PNP manager to send a device change message (or any other window's message)
 *
 * LIMITATIONS:
 *          some messages, such as WM_COPYDATA send an address pointer to some user data as lParam.
 *          In this API, the only such case that is currently supported is for WM_DEVICECHANGE
 *          No error code will be returned if you try to use such an unsupported message, simply the
 *          lParam will be ignored.
 *
 * ENTRY:
 *        hServer
 *            this is a handle which identifies a Hydra server. For the local server, hServer
 *            should be set to SERVERNAME_CURRENT
 *        sessionID
 *            this idefntifies the hydra session to which message is being sent
 *
 *        timeOut [ IN SECONDS ]
 *            set this to the amount of time you are willing to wait to get a response
 *            from the specified winstation. Even though Window's SendMessage API
 *            is blocking, the call from this side MUST choose how long it is willing to
 *            wait for a response.
 *
 *        hWnd
 *            This is the HWND of the target window in the specified session that
 *            a message will be sent to.
 *        Msg
 *            the window's message to send
 *        wParam
 *            first message param
 *        lParam
 *            second message parameter
 *        pResponse
 *          this is the response to the message sent, it depends on the type of message sent, see MSDN
 *
 *
 * EXIT:
 *        TRUE if all went well , check presponse for the actual response to the send message
 *        FALSE if something went wrong, the value of pResponse is not altered.
 *
 * WARNINGs:
 *        since the RPC call never blocks, you need to specify a reasonable timeOut if you want to wait for
 *         a response. Please remember that since this message is being sent to all winstations, the timeOut value
 *        will be on per-winstation.
 *
 *
 * Comments:
 *      For more info, please see MSDN for SendMessage()
 *
 ****************************************************************************/
LONG    WinStationSendWindowMessage(
        HANDLE  hServer,
        ULONG   sessionID,
        ULONG   timeOut,
        ULONG   hWnd,        // handle of destination window
        ULONG   Msg,         // message to send
        WPARAM  wParam,      // first message parameter
        LPARAM  lParam,      // second message parameter
        LONG    *pResponse
  )
{

    DWORD   Result = ERROR_SUCCESS;
    LONG    rc = TRUE ;

    // these are used for PNP messages
    PBYTE   rpcBuffer=NULL;
    ULONG   bufferSize=0;
    PWCHAR  lpStr;
    ULONG   maxSize;


    BOOLEAN fBufferHasValidData=FALSE;

    BOOL bIsTerminalServer = !!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer));
    if (!bIsTerminalServer)
    {
        return TRUE;    // all is well, but we are not on a Hydra server
    }

    // we may want to make this general for the future, but for now...
    // since we only alloc/copy the lparam in case of an WM_DEVICECHANGE msg, then, only
    // let message with either lparam=0 to go thru, or any WM_DEVICECHANGE msg.
    if (lParam)
    {
        switch ( Msg)
        {
        case        WM_DEVICECHANGE:
        case        WM_SETTINGCHANGE:
        case        WM_APPCOMMAND:
        case        WM_KEYDOWN:
        case        WM_KEYUP:
            // these are ok
        break;

        default:
            DBGPRINT(("Request is rejected \n"));
            return FALSE;
        break;
        }
    }

    HANDLE_CURRENT_BINDING( hServer );

    // Since the PNP message uses the lparam to pass the address of a user memory location, we
    // need to handle this by creating our own copy of that data, and then pass it to
    // termServ

    switch( Msg )
    {
            // if this is a PNP message
    case    WM_DEVICECHANGE:

            if ( lParam )   // see if the PNP message has a pointer to some user data
            {
                bufferSize = ( (DEV_BROADCAST_HDR *)(lParam))->dbch_size;
                rpcBuffer = LocalAlloc( LPTR, bufferSize );
                if ( rpcBuffer )
                {
                    // copy from user-space into our local rpc buffer
                    CopyMemory(rpcBuffer, (PBYTE) lParam, bufferSize );
                    fBufferHasValidData = TRUE;

                }
                else
                {
                    SetLastError( ERROR_OUTOFMEMORY );
                    return ( FALSE );
                }
            }
    break;

            // if this is a settings change message the system-CPL sends out
            // when an Admin changes the system env vars...
    case WM_SETTINGCHANGE:
            if ( lParam )   // see if message has a string data
            {
                // put some artificial limit on how large a buffer we are willing to use
                // in order to protect against malicious use of this api
                maxSize = 4096;

                bufferSize = lstrlenW( (PWCHAR) lParam ) * sizeof( WCHAR );
                if ( bufferSize < maxSize )
                {
                    rpcBuffer = LocalAlloc( LPTR, bufferSize );
                    if ( rpcBuffer )
                    {
                        // copy from user-space into our local rpc buffer
                        CopyMemory(rpcBuffer, (PBYTE) lParam, bufferSize );
                        fBufferHasValidData = TRUE;

                    }
                    else
                    {
                        SetLastError( ERROR_OUTOFMEMORY );
                        return ( FALSE );
                    }
                }
                else
                {
                    // we have too many
                    // vars in the user's profile.
                    KdPrint(("lParam length too big = %d \n", bufferSize));
                    break;
                    SetLastError( ERROR_MESSAGE_EXCEEDS_MAX_SIZE );
                    return ( FALSE );
                }
            }

    break;


    }

    // if the rpcBuffer is still empty, we must fill it up with some bogus data, otherwise, we will get
    // an RPC error of RPC_X_NULL_REF_POINTER (error code of 1780). It looks like Rpc does not check the
    // bufferSize value, and it just throws an exception if the buffer is NULL.
    if ( !rpcBuffer )
    {
        rpcBuffer = LocalAlloc( LPTR, sizeof(UINT) );
        if ( !rpcBuffer )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return ( FALSE );
        }

        bufferSize = sizeof(UINT);
        fBufferHasValidData = FALSE;    // note that this is set to FALSE, which means, the recepient will
                                        // not use the buffer. We do free the alloc below in either case.
    }


    RpcTryExcept {

        // rc is set to TRUE for a successful call, else, FALSE
        rc = RpcWinStationSendWindowMessage(
            hServer,
            sessionID ,
            timeOut,
            hWnd,
            Msg,
            wParam,
            lParam  ,
            rpcBuffer ,
            bufferSize,
            fBufferHasValidData,
            pResponse );

        //DBGPRINT(("done with call RpcWinStationSendWindowMessage() for sessionID= %d\n", sessionID ));
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d in RpcWinStationSendWindowMessage()  for sessionID = %d \n",Result, sessionID ));
        rc = FALSE;
    }
    RpcEndExcept

    LocalFree( rpcBuffer );

    SetLastError( Result );

    return( rc );

}

/****************************************************************************
*
*  _WinStationUpdateUserConfig()
*     Used by notify when shell is about to start
*     This will cause an update to the userconfig of the session by loading the user profile
*     and reading policy data from their HKCU
*
*  Params:
*     [in] UserToken,
*     [in] pDomain,
*     [in] pUserName
*
*  Return:
*     TRUE if no errors, FALSE in case of error, use GetLastError() for more info
*
****************************************************************************/
BOOLEAN WINAPI
_WinStationUpdateUserConfig(
    HANDLE UserToken
    )
{
    DWORD Result;
    BOOLEAN rc = TRUE;
    HANDLE hServer = SERVERNAME_CURRENT;

    DWORD   result;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return FALSE;
    }

    RpcTryExcept {

        rc = RpcWinStationUpdateUserConfig(
                     hServer, 
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId(),
                     (DWORD)(INT_PTR) UserToken,
                     &result
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*
 *  WinStationQueryLogonCredentialsW
 *
 *  Used by Winlogon to get auto-logon credentials from termsrv. This replaces
 *  the dual calls to WinStationQueryInformation and
 *  ServerQueryInetConnectorInformation.
 */

BOOLEAN WINAPI
WinStationQueryLogonCredentialsW(
    PWLX_CLIENT_CREDENTIALS_INFO_V2_0 pCredentials
    )
{
    BOOLEAN fRet;
    HANDLE hServer;
    NTSTATUS Status;
    PCHAR pWire;
    ULONG cbWire;

    if (pCredentials == NULL)
    {
        return(FALSE);
    }

    if (pCredentials->dwType != WLX_CREDENTIAL_TYPE_V2_0)
    {
        return(FALSE);
    }

    hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING(hServer);

    pWire = NULL;
    cbWire = 0;

    __try
    {
        fRet = RpcWinStationQueryLogonCredentials(
            hServer,
            NtCurrentPeb()->SessionId,
            &pWire,
            &cbWire
            );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
    }

    if (fRet)
    {
        fRet = CopyCredFromWire((PWLXCLIENTCREDWIREW)pWire, pCredentials);
    }

    if (pWire != NULL)
    {
        MIDL_user_free(pWire);
    }

    return(fRet);
}

BOOL WINAPI WinStationRegisterConsoleNotification (
                        HANDLE  hServer,
                        HWND    hWnd,
                        DWORD   dwFlags
                        )
{
        NTSTATUS Status = STATUS_UNSUCCESSFUL;
        BOOL bResult = FALSE;

        HANDLE_CURRENT_BINDING( hServer );

        RpcTryExcept {

                bResult =  RpcWinStationRegisterConsoleNotification (
                                hServer,
                                &Status,
                                NtCurrentPeb()->SessionId,
                                HandleToUlong(hWnd),
                                dwFlags
                                );
                if (!bResult) {

                        //
                        // Convert NTSTATUS to winerror, and set last error here.
                        //
                        SetLastError(RtlNtStatusToDosError(Status));
                }
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                SetLastError(RpcExceptionCode());
        }
        RpcEndExcept

        return (bResult);
}

BOOL WINAPI WinStationUnRegisterConsoleNotification (
                        HANDLE  hServer,
                        HWND    hWnd
                        )
{

        NTSTATUS Status = STATUS_UNSUCCESSFUL;
        BOOL     bResult = FALSE;

        HANDLE_CURRENT_BINDING( hServer );

        RpcTryExcept {

                bResult =  RpcWinStationUnRegisterConsoleNotification (
                                hServer,
                                &Status,
                                NtCurrentPeb()->SessionId,
                                HandleToUlong(hWnd)
                                );
                if (!bResult) {
                        SetLastError(RtlNtStatusToDosError(Status));
                }


        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                SetLastError(RpcExceptionCode());
        }
        RpcEndExcept

        return (bResult);
}


BOOLEAN CloseContextHandle(HANDLE *pHandle, DWORD *pdwResult)
{
    BOOLEAN bSuccess;
    ASSERT(pHandle);
    ASSERT(pdwResult);

    RpcTryExcept {

       bSuccess = RpcWinStationCloseServerEx( pHandle, pdwResult );
       if( !bSuccess ) *pdwResult = RtlNtStatusToDosError( *pdwResult );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        *pdwResult = RpcExceptionCode();
        bSuccess = FALSE;
    }
    RpcEndExcept

    if (!bSuccess && (*pdwResult == RPC_S_PROCNUM_OUT_OF_RANGE))        {
        //
        // most probabaly we are calling an older server which does not have
        // RpcWinStationCloseServerEx, so lets give a try to RpcWinStationCloseServer
        //
        RpcTryExcept {

           bSuccess = RpcWinStationCloseServer( *pHandle, pdwResult );
           if( !bSuccess ) *pdwResult = RtlNtStatusToDosError( *pdwResult );

        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            *pdwResult = RpcExceptionCode();
            bSuccess = FALSE;
            DBGPRINT(("RPC Exception %d\n", *pdwResult));
        }
        RpcEndExcept

        //
        // RpcWinStationCloseServer does not take care of destroying the context handle.
        // we we have to do it here at client end.
        //
        RpcTryExcept {

            RpcSsDestroyClientContext(pHandle);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            ASSERT(FALSE);
        }
        RpcEndExcept

    }

    return (bSuccess);
}

BOOLEAN WINAPI
RemoteAssistancePrepareSystemRestore(
	HANDLE hServer
    )
/*++

--*/
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcRemoteAssistancePrepareSystemRestore(
                     hServer,
                     &Result
                     );

        // TermSrv RpcRemoteAssistancePrepareSystemRestore() return
        // win32 ERROR code or actual HRESULT code.
        SetLastError(Result);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return rc;
}

BOOLEAN WinStationIsHelpAssistantSession(
    SERVER_HANDLE   hServer,
    ULONG           LogonId    
    )
/*++

--*/
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationIsHelpAssistantSession(
                     hServer,
                     &Result,
                     (LogonId == LOGONID_CURRENT) ? NtCurrentPeb()->SessionId : LogonId
                     );

        // Since a program has called us, we need to set the last error code such
        // that extended error information is available
        if (!rc)
            SetLastError(RtlNtStatusToDosError(Result));
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return rc;
}

/*
*   
*   WinStationGetMachinePolicy
*       Pass it a pointer to the callers ALREADY allocated policy struct, and this func
*       will fill it up from the current machine policy known to TermSrv 
*
*   Params:
*        hServer
*            this is a handle which identifies a Hydra server. For the local server, hServer
*            should be set to SERVERNAME_CURRENT
*
*         pPolicy
*            pointer to POLICY_TS_MACHINE already allocated by the caller.
*
*/
BOOLEAN    WinStationGetMachinePolicy (
        HANDLE              hServer,
        POLICY_TS_MACHINE   *pPolicy
  )
{

    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    BOOLEAN     bResult = FALSE;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

            bResult =  RpcWinStationGetMachinePolicy  (
                            hServer,
                            (PBYTE)pPolicy,
                            sizeof( POLICY_TS_MACHINE )
                            );

            if (!bResult) {
                    SetLastError(RtlNtStatusToDosError(Status));
            }


    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            SetLastError(RpcExceptionCode());
    }
    RpcEndExcept

    return (bResult);

}

/*****************************************************************************************************************
 *
 *  _WinStationUpdateClientCachedCreadentials
 *
 *   Comment
 *      Msgina calls this routine to notify TermSrv about the exact credentials specified by the User during logon
 *      TermSrv uses this information to send back notification information to the client
 *      This call was introduced because the notification used before did not support UPN Names
 *
 * ENTRY:
 *   [in] pDomain 
 *   [in] pUserName  
 *
 * EXIT:
 *   ERROR_SUCCESS - no error
 *
 ******************************************************************************************************************/

BOOLEAN WINAPI
_WinStationUpdateClientCachedCredentials(
    PWCHAR pDomain,
    PWCHAR pUserName
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   DomainLength;
    DWORD   UserNameLength;
    HANDLE hServer = SERVERNAME_CURRENT;
    HANDLE ReadyEventHandle;
    DWORD TermSrvWaitTime = 0;  

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    //
    // Wait for the TermSrvReadyEvent to be set by TERMSRV.EXE.  This
    // event indicates that TermSrv is initialized to the point that
    // the data used by _WinStationUpdateClientCachedCredentials() is available.
    //
    ReadyEventHandle = CreateEvent(NULL, TRUE, FALSE,
                                   TEXT("Global\\TermSrvReadyEvent"));
    if (ReadyEventHandle != NULL) {
       if (WaitForSingleObject(ReadyEventHandle, TermSrvWaitTime) != 0) {
          DBGPRINT(("WinLogon:  Wait for ReadyEventHandle failed\n"));
          return TRUE;
       }
       CloseHandle(ReadyEventHandle);
    } else {
       DBGPRINT(("WinLogon:  Create failed for ReadyEventHandle\n"));
       return TRUE;
    }

    RpcTryExcept {

        if( pDomain ) {
            DomainLength = lstrlenW(pDomain) + 1; 
        } else {
            DomainLength = 0;
        }

        if( pUserName ) {
            UserNameLength = lstrlenW(pUserName) + 1;
        } else {
            UserNameLength = 0;
        }

        rc = RpcWinStationUpdateClientCachedCredentials(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId(),
                     pDomain,
                     DomainLength,
                     pUserName,
                     UserNameLength
                     );

        if( !rc ) {
            Result = RtlNtStatusToDosError( Result );

        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************************************************
 *
 *  _WinStationFUSCanRemoteUserDisconnect
 *
 *   Comment
 *      FUS specific call when a remote user wants to connect and hence disconnect the present User
 *      Winlogon calls this routine so that we can ask the present user if it is ok to disconnect him
 *      The Target LogonId, Username and Domain of the remote user are passed on from Winlogon (useful to display the MessageBox)
 *
 * ENTRY:
 *   [in] LogonId - Session Id of the new session
 *   [in] pDomain - Domain name of the remote user trying to connect
 *   [in] pUserName  - Username of the remote user trying to connect
 *
 * EXIT:
 *   TRUE when local user allows the remote user to connect. FALSE otherwise.
 *
 ******************************************************************************************************************/


BOOLEAN WINAPI
_WinStationFUSCanRemoteUserDisconnect(
    ULONG  LogonId,
    PWCHAR pDomain,
    PWCHAR pUserName
    )
{
    BOOLEAN rc;
    DWORD   Result;
    DWORD   DomainLength;
    DWORD   UserNameLength;
    HANDLE hServer = SERVERNAME_CURRENT;
    HANDLE ReadyEventHandle;
    DWORD TermSrvWaitTime = 0;  

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        if( pDomain ) {
            DomainLength = lstrlenW(pDomain) + 1; 
        } else {
            DomainLength = 0;
        }

        if( pUserName ) {
            UserNameLength = lstrlenW(pUserName) + 1;
        } else {
            UserNameLength = 0;
        }

        rc = RpcWinStationFUSCanRemoteUserDisconnect(
                     hServer,
                     &Result,
                     LogonId,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId(),
                     pDomain,
                     DomainLength,
                     pUserName,
                     UserNameLength
                     );

        if( !rc ) {
            Result = RtlNtStatusToDosError( Result );

        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if( !rc ) SetLastError(Result);
    return( rc );
}

/*****************************************************************************
 *
 *  WinStationCheckLoopBack
 *
 *   Check if there is a loopback when a client tries to connect 
 *
 * ENTRY:
 *   IN hServer : open RPC server handle
 *   IN ClientSessionId : ID of the Session from which the Client was started
 *   IN TargetLogonId : Session ID to which the client is trying to connect to 
 *   IN pTargetServerName : name of target server
 *
 * EXIT:
 *   TRUE if there is a Loopback. FALSE otherwise.
 *
 ****************************************************************************/

BOOLEAN WINAPI
WinStationCheckLoopBack(
    HANDLE hServer,
    ULONG ClientSessionId,
    ULONG TargetLogonId,
    LPWSTR pTargetServerName
    )
{
    DWORD   NameSize;
    DWORD   Result;
    BOOLEAN rc;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    } 

    RpcTryExcept {

        if (pTargetServerName) {
            NameSize = lstrlenW(pTargetServerName) + 1;
        } else {
            NameSize = 0;
        }

        rc = RpcWinStationCheckLoopBack(
                    hServer,
                    &Result,
                    ClientSessionId,
                    TargetLogonId,
                    pTargetServerName,
                    NameSize
                    );

        Result = RtlNtStatusToDosError( Result );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if( !rc ) SetLastError(Result);
    return( rc );
}

//
// generic routine that can support all kind of protocol but this will
// require including tdi.h
//
BOOLEAN
WinStationConnectCallback(
    HANDLE hServer,
    DWORD  Timeout,
    ULONG  AddressType,
	PBYTE  pAddress,
	ULONG  AddressSize
    )
{
    BOOLEAN rc;
    DWORD   Result;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcConnectCallback(
                     hServer,
                     &Result,
                     Timeout,
                     AddressType,
                     pAddress,
                     AddressSize
                     );

        if( !rc ) SetLastError( RtlNtStatusToDosError(Result) );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( rc );
}

/*****************************************************************************************************************
 *
 *  _WinStationNotifyDisconnectPipe
 *
 *   Comment
 *     This routine is called by the temperory winlogon created during console reconnect, when it wants to inform
 *     the session 0 winlogon to disconnect the autologon Named Pipe. This can happen in some error handling paths
 *     during console reconnect.
 *
 * ENTRY: None
 *
 * EXIT:
 *   TRUE when notification succeeded. FALSE otherwise.
 *
 ******************************************************************************************************************/


BOOLEAN WINAPI
_WinStationNotifyDisconnectPipe(
    VOID
    )
{
    BOOLEAN rc;
    DWORD   Result;
    HANDLE hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING_NO_SERVER( hServer );

    if( hServer == RPC_HANDLE_NO_SERVER ) {
        return TRUE;
    }

    RpcTryExcept {

        rc = RpcWinStationNotifyDisconnectPipe(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     GetCurrentProcessId()
                     );

        if( !rc ) {
            Result = RtlNtStatusToDosError( Result );

        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    if( !rc ) SetLastError(Result);
    return( rc );
}

/*******************************************************************************
 *
 *  WinStationAutoReconnect
 *
 *    Atomically:
 *    1) Queries a winstation to see if it should be autoreconnected
 *       and which session ID to autoreconnect to
 *    2) Performs security checks to ensure session is authorized to ARC
 *    3) Auto reconnect is done
 *
 * ENTRY:
 *
 *    flags (input)
 *       Extra settings, currently unused
 *
 * EXIT:
 *    The return value is an NTSTATUS code which could have the infromational
 *    class set to specify the call succeeded but autoreconnect did not happen
 *
 ******************************************************************************/
ULONG WINAPI
WinStationAutoReconnect(
    ULONG         flags
    )
{
    DWORD Result;
    BOOLEAN rc;

    HANDLE hServer = SERVERNAME_CURRENT;

    HANDLE_CURRENT_BINDING( hServer );

    RpcTryExcept {

        rc = RpcWinStationAutoReconnect(
                     hServer,
                     &Result,
                     NtCurrentPeb()->SessionId,
                     flags
                     );
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
        Result = RpcExceptionCode();
        SetLastError( Result );
        DBGPRINT(("RPC Exception %d\n",Result));
        rc = FALSE;
    }
    RpcEndExcept

    return( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\client\winping.c ===
/****************************************************************************/
// winping.c
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <windows.h>
#include <winsta.h>

/*
 * Include the RPC generated common header
 */

#include "tsrpc.h"

int _cdecl
main (int argc, char *argv[])
{
    HANDLE   hLocal;
    NTSTATUS Status;
    DWORD    Result;    
    int      i;
    WCHAR *CmdLine;
    WCHAR **argvW;

    if ( argc != 2 ) {
	printf( "winping: WinStation Ping utility\n" );
	printf( "USAGE: winping <Machine>\n" );
	return( 1 );
    }

    CmdLine = GetCommandLineW();
    argvW = (WCHAR **)malloc( sizeof(WCHAR *) * (argc+1) );
    if(argvW == NULL) {
        exit(1);
    }

    argvW[0] = wcstok(CmdLine, L" ");
    for(i=1; i < argc; i++){
        argvW[i] = wcstok(0, L" ");
    }
    argvW[argc] = NULL;

    printf(" Pinging Local SERVERNAME_CURRENT\n");

    Result = WinStationServerPing( SERVERNAME_CURRENT );

    printf(" Result from 0x%x\n",Result,GetLastError());

    if( _wcsicmp(L"LOCAL", argvW[1]) == 0 ) {

        printf("Opening machine name NULL (per context local)\n");

	hLocal = WinStationOpenServerW(
                     NULL      // Machine name
	   	     );

        if( hLocal == NULL ) {
            printf("Error %d Opening Local Server over LPC\n",GetLastError());
            exit(1);
        }
    }
    else {
        printf("Opening machine name %ws\n",argvW[1]);

	hLocal = WinStationOpenServerW(
                     argvW[1]      // Machine name
		     );

        if( hLocal == NULL ) {
            printf("Error %d Opening Remote Server %ws over NP\n",GetLastError(),argvW[1]);
            exit(1);
        }
    }

    Result = WinStationServerPing( hLocal );

    printf("Result from WinStationServerPing 0x%x\n",Result);

    Result = WinStationCloseServer( hLocal );

    printf("Result from WinStationCloseServer is 0x%x\n",Result);

    printf("Sleeping.....\n");

    SleepEx(1000*30, TRUE);

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\concurrent.h ===
/*
 *  Concurrent.h
 *
 *  Author: RobLeit
 *
 *  The Concurrent licensing policy.
 */

#ifndef __LC_Concurrent_H__
#define __LC_Concurrent_H__

/*
 *  Includes
 */

#include "policy.h"

/*
 *  Constants
 */

#define LC_POLICY_CONCURRENT_EXPIRATION_LEEWAY (1000*60*60*24*7)

/*
 *  Class Definition
 */

class CConcurrentPolicy : public CPolicy
{
public:

/*
 *  Creation Functions
 */

    CConcurrentPolicy(
    );

    ~CConcurrentPolicy(
    );

/*
 *  Administrative Functions
 */

    ULONG
    GetFlags(
    );

    ULONG
    GetId(
    );

    NTSTATUS
    GetInformation(
                   LPLCPOLICYINFOGENERIC lpPolicyInfo
                   );

/*
 *  Loading and Activation Functions
 */

    NTSTATUS
    Load(
    );

    NTSTATUS
    Unload(
    );

    NTSTATUS
    Activate(
             BOOL fStartup,
             ULONG *pulAlternatePolicy
             );

    NTSTATUS
    Deactivate(
               BOOL fShutdown
               );

/*
 *  Licensing Functions
 */

    NTSTATUS
    Logon(
          CSession& Session
          );


    NTSTATUS
    Reconnect(
          CSession& Session,
          CSession& TemporarySession
          );

    NTSTATUS
    Logoff(
          CSession& Session
          );


/*
 *  Private License Functions
 */

private:

    NTSTATUS
    LicenseClient(
          CSession& Session
          );

    NTSTATUS
    CheckExpiration(
          );

    LONG
    CheckInstalledLicenses(
                           DWORD dwWanted
                           );

    VOID
    ReadLicensingParameters(
    );


/*
 *  Global Static Functions for checking license expiration.
 */

    static DWORD
    TimeToSoftExpiration(
    );
    
    static DWORD
    TimeToHardExpiration(
    );
    
    static NTSTATUS
    GetLicenseFromLS(
                     LONG nNum,
                     BOOL fIgnoreCurrentCount,
                     BOOL *pfRetrievedAll
                     );

    static DWORD
    GenerateHwidFromComputerName(
                                 HWID *hwid
                                 );

    static VOID
    TryToAddLicenses(
                     DWORD dwTotalWanted
                     );


    static VOID
    TryToReturnLicenses(
                        DWORD dwWanted
                        );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\lcreg.cpp ===
/*
 *  LCReg.cpp
 *
 *  Author: BreenH
 *
 *  Registry constants and functions for the licensing core.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lcreg.h"

/*
 *  Constants
 */

#define LCREG_BASEKEY L"System\\CurrentControlSet\\Control\\Terminal Server\\Licensing Core"

/*
 *  Globals
 */

HKEY g_hBaseKey;

/*
 *  Function Implementations
 */

HKEY
GetBaseKey(
    )
{
    return(g_hBaseKey);
}

NTSTATUS
RegistryInitialize(
    )
{
    DWORD dwStatus;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    dwStatus = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        LCREG_BASEKEY,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &g_hBaseKey,
        NULL
        );

    if (dwStatus == ERROR_SUCCESS)
    {
        Status = STATUS_SUCCESS;
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\lcreg.h ===
/*
 *  LCReg.h
 *
 *  Author: BreenH
 *
 *  Registry constants and functions for the licensing core.
 */

#ifndef __LC_LCREG_H__
#define __LC_LCREG_H__

/*
 *  Base Licensing Core Key Constants
 */

#define LCREG_TRACEVALUE L"TraceLevel"
#define LCREG_ACONMODE L"PolicyAcOn"
#define LCREG_ACOFFMODE L"PolicyAcOff"

/*
 *  Policy Key Constants
 */

#define LCREG_POLICYDLLVALUE L"DllName"
#define LCREG_POLICYCREATEFN L"CreationFunction"

/*
 *  Function Prototypes
 */

HKEY
GetBaseKey(
    );

NTSTATUS
RegistryInitialize(
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\concurrent.cpp ===
/*
 *  Concurrent.cpp
 *
 *  Author: RobLeit
 *
 *  The Concurrent (renamed to Per Session) licensing policy.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "concurrent.h"
#include "util.h"
#include "lctrace.h"
#include <icaevent.h>

/*
 *  Typedefs
 */

#define CONCURRENTLICENSEINFO_TYPE_V1 (1)

typedef struct {
    DWORD dwStructVer;
    DWORD dwLicenseVer;
    LONG lLicenseCount;
    HWID hwid;
} CONCURRENTLICENSEINFO_V1, *PCONCURRENTLICENSEINFO_V1;

typedef struct {
    ULARGE_INTEGER ulSerialNumber;
    FILETIME ftNotAfter;
    DWORD cchServerName;
    WCHAR szServerName[MAX_COMPUTERNAME_LENGTH + 2];
} LSERVERINFO, *PLSERVERINFO;

/*
 * Function declarations
 */

NTSTATUS
ReturnLicenseToLS(
    LONG nNum
    );

LICENSE_STATUS
GetLicenseFromStore(
                    PLONG LicenseCount,
                    PHWID phwid,
                    DWORD dwLicenseVer
                    );

LICENSE_STATUS
SetLicenseInStore(
                  LONG LicenseCount,
                  HWID hwid,
                  DWORD dwLicenseVer
                  );


/*
 *  extern globals
 */
extern "C"
extern HANDLE hModuleWin;

/*
 *  globals
 */
FILETIME g_ftNotAfter = {0,0};

FILETIME g_ftOkayToAdd;

DWORD g_dwWaitTimeAdd;
DWORD g_dwWaitTimeRemove;
DWORD g_dwIncrement;

HANDLE g_rgWaitEvents[4] = {NULL,NULL,NULL,NULL};

CRITICAL_SECTION g_csAddLicenses;
RTL_RESOURCE g_rwLockLicense;
BOOL g_fLockLicenseInitialized = FALSE;

LONG g_lSessionCount = 0;
LONG g_lSessionMax;

/*
 *  Constants
 */

//
// Dynamic licensing parameters
//
#define LC_POLICY_CONCURRENT_LICENSE_COUNT_INCREMENT    25
#define LC_POLICY_CONCURRENT_WAIT_TIME_ADD              (60)
#define LC_POLICY_CONCURRENT_WAIT_TIME_REMOVE           (60*30)

//
// The LSA secret store for the Concurrent licenses
//

// L$ means only readable from the local machine

#define CONCURRENT_LICENSE_STORE_5_1 L"L$CONCURRENT_LICENSE_STORE_AFF8D0DE-BF56-49e2-89F8-1F188C0ACEDD"

#define CONCURRENT_LICENSE_STORE_LATEST_VERSION CONCURRENT_LICENSE_STORE_5_1

//
// The LSA secret store for the license server info
//

#define CONCURRENT_LSERVER_STORE L"L$CONCURRENT_LSERVER_STORE_AFF8D0DE-BF56-49e2-89F8-1F188C0ACEDD"

// 
// Registry keys
//

#define LCREG_CONCURRENTKEY         L"System\\CurrentControlSet\\Control\\Terminal Server\\Licensing Core\\Policies\\Concurrent"

#define LCREG_INCREMENT         L"Increment"
#define LCREG_WAIT_TIME_ADD     L"WaitTimeAdd"
#define LCREG_WAIT_TIME_REMOVE  L"WaitTimeRemove"

//
// Events used to trigger license returns
//
#define RETURN_LICENSE_START_WAITING    0
#define RETURN_LICENSE_IMMEDIATELY      1
#define RETURN_LICENSE_EXIT             2
#define RETURN_LICENSE_WAITING_DONE     3

/*
 *  Class Implementation
 */

/*
 *  Creation Functions
 */

CConcurrentPolicy::CConcurrentPolicy(
    ) : CPolicy()
{
}

CConcurrentPolicy::~CConcurrentPolicy(
    )
{
}

/*
 *  Administrative Functions
 */

ULONG
CConcurrentPolicy::GetFlags(
    )
{
    return(LC_FLAG_INTERNAL_POLICY | LC_FLAG_REQUIRE_APP_COMPAT);
}

ULONG
CConcurrentPolicy::GetId(
    )
{
    return(4);
}

NTSTATUS
CConcurrentPolicy::GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    )
{
    NTSTATUS Status;

    ASSERT(lpPolicyInfo != NULL);

    if (lpPolicyInfo->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        int retVal;
        LPLCPOLICYINFO_V1 lpPolicyInfoV1 = (LPLCPOLICYINFO_V1)lpPolicyInfo;
        LPWSTR pName;
        LPWSTR pDescription;

        ASSERT(lpPolicyInfoV1->lpPolicyName == NULL);
        ASSERT(lpPolicyInfoV1->lpPolicyDescription == NULL);

        //
        //  The strings loaded in this fashion are READ-ONLY. They are also
        //  NOT NULL terminated. Allocate and zero out a buffer, then copy the
        //  string over.
        //

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_CONCURRENT_NAME,
            (LPWSTR)(&pName),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyName = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyName != NULL)
            {
                lstrcpynW(lpPolicyInfoV1->lpPolicyName, pName, retVal + 1);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_CONCURRENT_DESC,
            (LPWSTR)(&pDescription),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyDescription = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyDescription != NULL)
            {
                lstrcpynW(lpPolicyInfoV1->lpPolicyDescription, pDescription, retVal + 1);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        Status = STATUS_SUCCESS;
        goto exit;

V1error:

        //
        //  An error occurred loading/copying the strings.
        //

        if (lpPolicyInfoV1->lpPolicyName != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyName);
            lpPolicyInfoV1->lpPolicyName = NULL;
        }

        if (lpPolicyInfoV1->lpPolicyDescription != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyDescription);
            lpPolicyInfoV1->lpPolicyDescription = NULL;
        }
    }
    else
    {
        Status = STATUS_REVISION_MISMATCH;
    }

exit:
    return(Status);
}

DWORD WINAPI ReturnLicenseWorker(
                                 LPVOID lpParameter
                                 )
{
    DWORD dwWait;
    HANDLE * rgWaitEvents = (HANDLE *) lpParameter;
    LONG lLicensesToReturn, lLastBlock;

    for (;;)
    {
        //
        // wait for events signalling when to return licenses
        // or start waiting to return licenses
        //

        dwWait = WaitForMultipleObjects(4,            // nCount
                                        rgWaitEvents,
                                        FALSE,        // fWaitAll
                                        INFINITE
                                        );

        switch (dwWait)
        {
            case WAIT_OBJECT_0+RETURN_LICENSE_START_WAITING:
                LARGE_INTEGER liWait;

                // relative wait, in 100 nanosecond intervals
                liWait.QuadPart = (__int64) g_dwWaitTimeRemove * (-10 * 1000 * 1000);

                SetWaitableTimer(rgWaitEvents[RETURN_LICENSE_WAITING_DONE],
                                 &liWait,
                                 0,             // lPeriod
                                 NULL,          // pfnCompletionRoutine
                                 NULL,          // lpArgToCompletionRoutine
                                 FALSE          // fResume (from suspended)
                                 );
                                 
                break;

            case WAIT_OBJECT_0+RETURN_LICENSE_WAITING_DONE:

                RtlAcquireResourceShared(&g_rwLockLicense,TRUE);

                lLastBlock = g_lSessionMax - ((g_lSessionMax / g_dwIncrement) * g_dwIncrement);
                if (lLastBlock == 0) 
                    lLastBlock = g_dwIncrement;

                if (g_lSessionCount + lLastBlock <= g_lSessionMax )
                {
                    lLicensesToReturn = lLastBlock + (((g_lSessionMax - g_lSessionCount - lLastBlock) / g_dwIncrement) * g_dwIncrement);

                    (VOID)ReturnLicenseToLS(lLicensesToReturn);
                }

                RtlReleaseResource(&g_rwLockLicense);
                break;

            case WAIT_OBJECT_0+RETURN_LICENSE_IMMEDIATELY:

                RtlAcquireResourceShared(&g_rwLockLicense,TRUE);

                lLastBlock = g_lSessionMax - ((g_lSessionMax / g_dwIncrement) * g_dwIncrement);
                if (lLastBlock == 0) 
                    lLastBlock = g_dwIncrement;

                if (g_lSessionCount + lLastBlock + g_dwIncrement <= (DWORD)g_lSessionMax )
                {
                    lLicensesToReturn = ((g_lSessionMax - g_lSessionCount - lLastBlock) / g_dwIncrement) * g_dwIncrement;

                    (VOID)ReturnLicenseToLS(lLicensesToReturn);
                }

                RtlReleaseResource(&g_rwLockLicense);
                break;

            case WAIT_OBJECT_0+RETURN_LICENSE_EXIT:

                if (NULL != rgWaitEvents[RETURN_LICENSE_START_WAITING])
                {
                    CloseHandle(rgWaitEvents[RETURN_LICENSE_START_WAITING]);
                    rgWaitEvents[RETURN_LICENSE_START_WAITING] = NULL;
                }

                if (NULL != rgWaitEvents[RETURN_LICENSE_IMMEDIATELY])
                {
                    CloseHandle(rgWaitEvents[RETURN_LICENSE_IMMEDIATELY]);
                    rgWaitEvents[RETURN_LICENSE_IMMEDIATELY] = NULL;
                }

                if (NULL != rgWaitEvents[RETURN_LICENSE_EXIT])
                {
                    CloseHandle(rgWaitEvents[RETURN_LICENSE_EXIT]);
                    rgWaitEvents[RETURN_LICENSE_EXIT] = NULL;
                }

                if (NULL != rgWaitEvents[RETURN_LICENSE_WAITING_DONE])
                {
                    CloseHandle(rgWaitEvents[RETURN_LICENSE_WAITING_DONE]);
                    rgWaitEvents[RETURN_LICENSE_WAITING_DONE] = NULL;
                }

                if (g_fLockLicenseInitialized)
                {
                    // make sure no one else is using it

                    RtlAcquireResourceExclusive(&g_rwLockLicense,TRUE);

                    RtlDeleteResource(&g_rwLockLicense);
                    g_fLockLicenseInitialized = FALSE;
                }

                return STATUS_SUCCESS;
                break;

            default:
            {                
                DWORD dwRet = 0;
                DWORD dwErr = GetLastError();
                LPTSTR lpszError;
                BOOL fFree = TRUE;

                dwRet=FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    NULL,
                                    dwErr,
                                    LANG_NEUTRAL,
                                    (LPTSTR)&lpszError,
                                    0,
                                    NULL);

                if (dwRet == 0)
                {
                    lpszError = (LPTSTR) LocalAlloc(LPTR,12 * sizeof(WCHAR));

                    if (NULL != lpszError)
                    {
                        wsprintf(lpszError,L"%#lX",dwErr);
                    }
                    else
                    {
                        lpszError = L"";
                        fFree = FALSE;
                    }
                }

                LicenseLogEvent(EVENTLOG_ERROR_TYPE,
                                EVENT_LICENSING_CONCURRENT_NOT_DYNAMIC,
                                1,
                                &lpszError );

                if (fFree)
                {
                    LocalFree(lpszError);
                }

                return dwErr;
                break;
            }
        }
    }
}


/*
 *  Loading and Activation Functions
 */

NTSTATUS
CConcurrentPolicy::Load(
    )
{
    NTSTATUS Status;

    g_rgWaitEvents[RETURN_LICENSE_START_WAITING] = NULL;
    g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY] = NULL;
    g_rgWaitEvents[RETURN_LICENSE_EXIT] = NULL;
    g_rgWaitEvents[RETURN_LICENSE_WAITING_DONE] = NULL;

    Status = RtlInitializeCriticalSection(&g_csAddLicenses);
    if (STATUS_SUCCESS != Status)
    {
        return Status;
    }

    __try
    {
        RtlInitializeResource(&g_rwLockLicense);
        g_fLockLicenseInitialized = TRUE;
        Status = STATUS_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }


    return(Status);
}

NTSTATUS
CConcurrentPolicy::Unload(
    )
{
    // signal worker thread to cleanup and exit
    if (NULL != g_rgWaitEvents[RETURN_LICENSE_EXIT])
    {
        SetEvent(g_rgWaitEvents[RETURN_LICENSE_EXIT]);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
CConcurrentPolicy::Activate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hThread;
    HWID hwidEncrypted;
    LICENSE_STATUS LsStatus;

    if (NULL != pulAlternatePolicy)
    {
        // don't set an explicit alternate policy
        
        *pulAlternatePolicy = ULONG_MAX;
    }

    ReadLicensingParameters();

    g_ftOkayToAdd.dwLowDateTime = 0;
    g_ftOkayToAdd.dwHighDateTime = 0;

    //
    // Read number of licenses from LSA secret
    //
    LsStatus = GetLicenseFromStore(&g_lSessionMax,
                                   &hwidEncrypted,
                                   CURRENT_TERMINAL_SERVER_VERSION
                                   );

    if (LsStatus != LICENSE_STATUS_OK)
    {
        g_lSessionMax = 0;
    }

    Status = StartCheckingGracePeriod();

    if (Status == STATUS_SUCCESS)
    {
        g_rgWaitEvents[RETURN_LICENSE_START_WAITING]
            = CreateEvent(NULL,         // SecurityAttributes,
                          FALSE,        // bManualReset
                          FALSE,        // bInitialState
                          NULL          // lpName
                          );

        if (NULL == g_rgWaitEvents[RETURN_LICENSE_START_WAITING])
        {
            Status = GetLastError();
            
            goto check_status;
        }

        g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY]
            = CreateEvent(NULL,         // SecurityAttributes,
                          FALSE,        // bManualReset
                          FALSE,        // bInitialState
                          NULL          // lpName
                          );

        if (NULL == g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY])
        {
            Status = GetLastError();
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_START_WAITING]);
            g_rgWaitEvents[RETURN_LICENSE_START_WAITING] = NULL;
            
            goto check_status;
        }

        g_rgWaitEvents[RETURN_LICENSE_EXIT]
            = CreateEvent(NULL,         // SecurityAttributes,
                          FALSE,        // bManualReset
                          FALSE,        // bInitialState
                          NULL          // lpName
                          );

        if (NULL == g_rgWaitEvents[RETURN_LICENSE_EXIT])
        {
            Status = GetLastError();
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_START_WAITING]);
            g_rgWaitEvents[RETURN_LICENSE_START_WAITING] = NULL;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY]);
            g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY] = NULL;
            
            goto check_status;
        }

        g_rgWaitEvents[RETURN_LICENSE_WAITING_DONE]
            = CreateWaitableTimer(NULL,         // SecurityAttributes,
                                  FALSE,        // bManualReset
                                  NULL          // lpName
                                  );
        
        if (NULL == g_rgWaitEvents[RETURN_LICENSE_WAITING_DONE])
        {
            Status = GetLastError();
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_START_WAITING]);
            g_rgWaitEvents[RETURN_LICENSE_START_WAITING] = NULL;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY]);
            g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY] = NULL;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_EXIT]);
            g_rgWaitEvents[RETURN_LICENSE_EXIT] = NULL;
            
            goto check_status;
        }

        hThread = CreateThread( NULL,               // SecurityAttributes
                                0,                  // StackSize
                                ReturnLicenseWorker,
                                (LPVOID)g_rgWaitEvents,
                                0,                  // CreationFlags
                                NULL                // ThreadId
                                );

        if (NULL != hThread)
        {
            CloseHandle(hThread);
        }
        else
        {
            Status = STATUS_BAD_INITIAL_PC;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_START_WAITING]);
            g_rgWaitEvents[RETURN_LICENSE_START_WAITING] = NULL;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY]);
            g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY] = NULL;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_EXIT]);
            g_rgWaitEvents[RETURN_LICENSE_EXIT] = NULL;
            
            CloseHandle(g_rgWaitEvents[RETURN_LICENSE_WAITING_DONE]);
            g_rgWaitEvents[RETURN_LICENSE_WAITING_DONE] = NULL;

            goto check_status;
        }
    }

check_status:

    if (Status != STATUS_SUCCESS)
    {
        StopCheckingGracePeriod();

        if (!fStartup)
        {
            DWORD dwRet = 0;
            LPTSTR lpszError;
            BOOL fFree = TRUE;

            dwRet=FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                NULL,
                                RtlNtStatusToDosError(Status),
                                LANG_NEUTRAL,
                                (LPTSTR)&lpszError,
                                0,
                                NULL);

            if (dwRet == 0)
            {
                lpszError = (LPTSTR) LocalAlloc(LPTR,12 * sizeof(WCHAR));

                if (NULL != lpszError)
                {
                    wsprintf(lpszError,L"%#lX",RtlNtStatusToDosError(Status));
                }
                else
                {
                    lpszError = L"";
                    fFree = FALSE;
                }
            }

            LicenseLogEvent(EVENTLOG_ERROR_TYPE,
                            EVENT_LICENSING_CONCURRENT_CANT_START,
                            1,
                            &lpszError
                            );

            if (fFree)
            {
                LocalFree(lpszError);
            }
        }
    }

    return Status;
}

NTSTATUS
CConcurrentPolicy::Deactivate(
    BOOL fShutdown
    )
{
    NTSTATUS Status;

    if (fShutdown)
    {
        Status = STATUS_SUCCESS;
    }
    else
    {
        RtlAcquireResourceShared(&g_rwLockLicense,TRUE);
        Status = ReturnLicenseToLS(0);
        RtlReleaseResource(&g_rwLockLicense);

        if (Status != STATUS_SUCCESS)
        {
            LPTSTR lpszError;
            DWORD dwRet = 0;
            BOOL fFree = TRUE;

            dwRet=FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                NULL,
                                RtlNtStatusToDosError(Status),
                                LANG_NEUTRAL,
                                (LPTSTR)&lpszError,
                                0,
                                NULL);

            if (dwRet == 0)
            {
                lpszError = (LPTSTR) LocalAlloc(LPTR,12 * sizeof(WCHAR));

                if (NULL != lpszError)
                {
                    wsprintf(lpszError,L"%#lX",RtlNtStatusToDosError(Status));
                }
                else
                {
                    lpszError = L"";
                    fFree = FALSE;
                }
            }

            LicenseLogEvent(EVENTLOG_ERROR_TYPE,
                            EVENT_LICENSING_CONCURRENT_NOT_RETURNED,
                            1,
                            &lpszError
                            );

            if (fFree)
            {
                LocalFree(lpszError);
            }
        }

        StopCheckingGracePeriod();
    }

    return(Status);
}

/*
 *  Licensing Functions
 */

NTSTATUS
CConcurrentPolicy::Logon(
    CSession& Session
    )
{
    if (!Session.IsSessionZero())
    {
        return LicenseClient(Session);
    }
    else
    {
        return STATUS_SUCCESS;
    }
}

NTSTATUS
CConcurrentPolicy::Reconnect(
    CSession& Session,
    CSession& TemporarySession
    )
{
    UNREFERENCED_PARAMETER(Session);

    if (!Session.IsSessionZero()
        && !Session.GetLicenseContext()->fTsLicense)
    {
        return LicenseClient(TemporarySession);
    }
    else
    {
        return STATUS_SUCCESS;
    }
}

NTSTATUS
CConcurrentPolicy::Logoff(
    CSession& Session
    )
{
    if (!Session.IsSessionZero())
    {
        LONG lSessions, lLastBlock;

        lSessions = InterlockedDecrement(&g_lSessionCount);

        ASSERT(lSessions >= 0);

        RtlAcquireResourceShared(&g_rwLockLicense,TRUE);
        lLastBlock = g_lSessionMax - ((g_lSessionMax / g_dwIncrement) * g_dwIncrement);
        if (lLastBlock == 0) 
            lLastBlock = g_dwIncrement;

        if (lSessions + lLastBlock <= g_lSessionMax)
        {
            TryToReturnLicenses(g_lSessionMax-lSessions);
        }
        RtlReleaseResource(&g_rwLockLicense);
    }

    return(STATUS_SUCCESS);
}

/*
 *  Private License Functions
 */

NTSTATUS
CConcurrentPolicy::LicenseClient(
    CSession& Session
    )
{
    NTSTATUS Status;
    LONG lSessions;

    lSessions = InterlockedIncrement(&g_lSessionCount);

    RtlAcquireResourceShared(&g_rwLockLicense,TRUE);

    if (lSessions > g_lSessionMax)
    {
        DWORD cBlocks = ((lSessions - g_lSessionMax) / g_dwIncrement) + 1;

        TryToAddLicenses(cBlocks * g_dwIncrement + g_lSessionMax);

        if (lSessions > g_lSessionMax)
        {
            if (!AllowLicensingGracePeriodConnection())
            {
                InterlockedDecrement(&g_lSessionCount);
                RtlReleaseResource(&g_rwLockLicense);
                return STATUS_CTX_LICENSE_NOT_AVAILABLE;
            }
        }
    }

    Status = CheckExpiration();

    RtlReleaseResource(&g_rwLockLicense);

    if (Status == STATUS_SUCCESS)
    {
        Status = GetLlsLicense(Session);

        if (Status == STATUS_SUCCESS)
        {
            Session.GetLicenseContext()->fTsLicense = TRUE;
        }
    }

    return(Status);
}

LONG
CConcurrentPolicy::CheckInstalledLicenses(
                                          DWORD dwWanted
    )
{
    CONCURRENTLICENSEINFO_V1 LicenseInfo;
    LICENSE_STATUS LsStatus;
    ULONG cbSecretLen;

    cbSecretLen = sizeof(LicenseInfo);
    ZeroMemory(&LicenseInfo, cbSecretLen);

    //
    // Get the concurrent license count from the LSA secret
    //

    LsStatus = LsCsp_RetrieveSecret( 
        CONCURRENT_LICENSE_STORE_LATEST_VERSION,
        (LPBYTE)&LicenseInfo,
        &cbSecretLen
        );

    if ((LsStatus != LICENSE_STATUS_OK) ||
        (cbSecretLen < sizeof(CONCURRENTLICENSEINFO_V1)) ||
        (LicenseInfo.dwLicenseVer != CURRENT_TERMINAL_SERVER_VERSION))
    {
        //
        // We determine that the license pack for this version is
        // not installed if:
        //
        // (1) we cannot retrieve the license info from the LSA secret
        // (2) we cannot read at least the size of version 1 of the license
        // info structure, or
        // (3) the license pack version is different from that requested.
        //

        return dwWanted;
    }
    else
    {
        LSERVERINFO LServerInfo;
        ULONG cbLServerInfo;

        cbLServerInfo = sizeof(LSERVERINFO);

        LsStatus = LsCsp_RetrieveSecret(
                                        CONCURRENT_LSERVER_STORE,
                                        (LPBYTE)&LServerInfo,
                                        &cbLServerInfo
                                        );

        if (LsStatus == LICENSE_STATUS_OK)
        {
            g_ftNotAfter = LServerInfo.ftNotAfter;

            if (0 == TimeToHardExpiration())
            {
                return dwWanted;
            }
        }

        return (dwWanted - LicenseInfo.lLicenseCount);
    }
}

VOID
CConcurrentPolicy::TryToReturnLicenses(
    DWORD dwReturnCount
    )
{
    ASSERT(dwReturnCount != 0);

    if (dwReturnCount <= g_dwIncrement)
    {
        // Wait before returning one block
        if (NULL != g_rgWaitEvents[RETURN_LICENSE_START_WAITING])
            SetEvent(g_rgWaitEvents[RETURN_LICENSE_START_WAITING]);
    }
    else
    {
        // Immediately return all but one block
        if (NULL != g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY])
            SetEvent(g_rgWaitEvents[RETURN_LICENSE_IMMEDIATELY]);
    }
}

//
// Must have shared lock to call this
//

NTSTATUS
ReturnLicenseToLS(
    LONG nNum
    )
{
    HANDLE hProtocol = NULL;
    HWID hwid;
    LICENSEREQUEST LicenseRequest;
    LICENSE_STATUS LsStatus;
    LONG CurrentCount;
    LSERVERINFO LServerInfo;
    ULONG cbLServerInfo;
    Product_Info ProductInfo;

    LsStatus = InitProductInfo(
        &ProductInfo,
        PRODUCT_INFO_CONCURRENT_SKU_PRODUCT_ID
        );

    if (LsStatus != LICENSE_STATUS_OK)
    {
        return(LsStatusToNtStatus(LsStatus));
    }

    //
    //  Get the current license count and HWID from the store.
    //

    LsStatus = GetLicenseFromStore(
        &CurrentCount,
        &hwid,
        CURRENT_TERMINAL_SERVER_VERSION
        );

    if (LsStatus == LICENSE_STATUS_OK)
    {
        if ((0 == nNum) || (nNum > CurrentCount))
        {
            nNum = CurrentCount;
        }

        if (CurrentCount == 0)
        {
            return(STATUS_SUCCESS);
        }
    }
    else
    {
        return(LsStatusToNtStatus(LsStatus));
    }

    //
    //  Initialize the license request structure.
    //

    ZeroMemory(&LicenseRequest, sizeof(LICENSEREQUEST));

    LicenseRequest.pProductInfo = &ProductInfo;
    LicenseRequest.dwLanguageID = GetSystemDefaultLCID();
    LicenseRequest.dwPlatformID = CURRENT_TERMINAL_SERVER_VERSION;    
    LicenseRequest.cbEncryptedHwid = sizeof(HWID);
    LicenseRequest.pbEncryptedHwid = (PBYTE)&hwid;

    cbLServerInfo = sizeof(LSERVERINFO);

    LsStatus = LsCsp_RetrieveSecret(
        CONCURRENT_LSERVER_STORE,
        (LPBYTE)&LServerInfo,
        &cbLServerInfo
        );

    if (LsStatus == LICENSE_STATUS_OK)
    {
        LsStatus = CreateProtocolContext(NULL, &hProtocol);
    }
    else
    {
        goto done;
    }

    if (LsStatus == LICENSE_STATUS_OK)
    {
        LsStatus = ReturnInternetLicense(
            hProtocol,
            LServerInfo.szServerName,
            &LicenseRequest,
            LServerInfo.ulSerialNumber,
            nNum
            );
    }
    else
    {
        goto done;
    }

    if (LsStatus == LICENSE_STATUS_OK)
    {
        LsStatus = SetLicenseInStore(
            CurrentCount-nNum,
            hwid,
            CURRENT_TERMINAL_SERVER_VERSION
            );

        RtlConvertSharedToExclusive(&g_rwLockLicense);
        g_lSessionMax = CurrentCount - nNum;
        RtlConvertExclusiveToShared(&g_rwLockLicense);
    }

done:
    if (hProtocol != NULL)
    {
        DeleteProtocolContext(hProtocol);
    }

    if (ProductInfo.pbCompanyName)
    {
        LocalFree(ProductInfo.pbCompanyName);
    }

    if (ProductInfo.pbProductID)
    {
        LocalFree(ProductInfo.pbProductID);
    }

    return(LsStatusToNtStatus(LsStatus));
}

DWORD
CConcurrentPolicy::GenerateHwidFromComputerName(
    HWID *hwid
    )
{
    MD5_CTX HashState;
    WCHAR wszName[MAX_COMPUTERNAME_LENGTH * 9]; // buffer we hope is big enough
    DWORD cbName = sizeof(wszName) / sizeof(TCHAR);
    BOOL fRet;

    //
    // get computer name
    //

    fRet = GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified,
                 wszName,
                 &cbName);

    if (!fRet)
    {
        return GetLastError();
    }

    //
    // generate the hash on the data.
    //
    MD5Init( &HashState );
    MD5Update( &HashState, (LPBYTE)wszName, cbName );
    MD5Final( &HashState );

    memcpy((LPBYTE)hwid,HashState.digest,sizeof(HashState.digest));

    // fill in the rest with characters from computer name

    lstrcpyn((LPWSTR)(((LPBYTE)hwid)+sizeof(HashState.digest)),
             wszName,
             (sizeof(HWID)-sizeof(HashState.digest))/sizeof(WCHAR));

    return ERROR_SUCCESS;
}

//
// Must have shared lock to call this
//
VOID
CConcurrentPolicy::TryToAddLicenses(
                                    DWORD dwTotalWanted
    )
{
    NTSTATUS Status;
    SYSTEMTIME stNow;
    FILETIME ftNow;
    ULARGE_INTEGER ull;
    BOOL fRetrievedAll;
    
    RtlEnterCriticalSection(&g_csAddLicenses);

    GetSystemTime(&stNow);

    SystemTimeToFileTime(&stNow,&ftNow);

    if (((0 != g_ftOkayToAdd.dwLowDateTime)
         || (0 != g_ftOkayToAdd.dwHighDateTime))
        && (CompareFileTime(&ftNow,&g_ftOkayToAdd) < 0))
    {
        // We're in waiting period
        RtlLeaveCriticalSection(&g_csAddLicenses);
        return;
    }

    if (g_lSessionMax >= (LONG) dwTotalWanted)
    {
        // we already have enough
        RtlLeaveCriticalSection(&g_csAddLicenses);
        return;
    }


    Status = GetLicenseFromLS(dwTotalWanted - g_lSessionMax,
                              FALSE,    // fIgnoreCurrentCount
                              &fRetrievedAll);

    if ((Status != STATUS_SUCCESS) || (!fRetrievedAll))
    {
        // wait before adding more

        ull.LowPart = ftNow.dwLowDateTime;
        ull.HighPart = ftNow.dwHighDateTime;
    
        ull.QuadPart += (__int64) g_dwWaitTimeAdd * 1000 * 1000 * 10;

        g_ftOkayToAdd.dwLowDateTime = ull.LowPart;
        g_ftOkayToAdd.dwHighDateTime = ull.HighPart;
    }

    RtlLeaveCriticalSection(&g_csAddLicenses);
}

//
// Must have shared lock to call this
//
NTSTATUS
CConcurrentPolicy::GetLicenseFromLS(
                                    LONG nNumToAdd,
                                    BOOL fIgnoreCurrentCount,
                                    BOOL *pfRetrievedAll
    )
{
    BOOL fHwidSet;
    BOOL fRet;
    DWORD cbLicense;
    DWORD cbSecretKey;
    DWORD cchComputerName = MAX_COMPUTERNAME_LENGTH + 1;
    DWORD dwNumLicensedProduct = 0;
    DWORD dwStatus;
    HANDLE hProtocol;
    HWID hwid;
    HWID hwidEncrypted;
    LICENSE_STATUS LsStatus;
    LICENSEREQUEST LicenseRequest;
    LONG CurrentCount;
    LSERVERINFO LServerInfo;
    ULONG cbLServerInfo;
    NTSTATUS Status;
    PBYTE pbLicense;
    PBYTE pbSecretKey;
    PLICENSEDPRODUCT pLicensedProduct;
    Product_Info ProductInfo;
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    TCHAR *pszLicenseServerName = LServerInfo.szServerName;
    DWORD dwNumLicensesRetrieved = 0;

    if (nNumToAdd < 0)
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (nNumToAdd == 0)
    {
        if (NULL != pfRetrievedAll)
            *pfRetrievedAll = TRUE;

        return STATUS_SUCCESS;
    }

    if (NULL != pfRetrievedAll)
        *pfRetrievedAll = FALSE;

    //
    //  These variables must be initialized here, or else any of the gotos
    //  below may cause them to be used without initialization.
    //

    hProtocol = NULL;
    pbLicense = NULL;
    pbSecretKey = NULL;
    pLicensedProduct = NULL;
    Status = STATUS_SUCCESS;
    ZeroMemory(&ProductInfo, sizeof(Product_Info));

    //
    //  Get the current license count and HWID from the store. Failure is not
    //  fatal.
    //

    LsStatus = GetLicenseFromStore(
        &CurrentCount,
        &hwidEncrypted,
        CURRENT_TERMINAL_SERVER_VERSION
        );

    if (LsStatus == LICENSE_STATUS_OK)
    {
        fHwidSet = TRUE;

        if (fIgnoreCurrentCount)
        {
            CurrentCount = 0;
        }
    }
    else
    {
        CurrentCount = 0;
        fHwidSet = FALSE;
    }

    //
    //  Initialize the product info.
    //

    LsStatus = InitProductInfo(
        &ProductInfo,
        PRODUCT_INFO_CONCURRENT_SKU_PRODUCT_ID
        );

    if (LsStatus == LICENSE_STATUS_OK)
    {
        //
        //  Initialize the license request structure.
        //

        ZeroMemory(&LicenseRequest, sizeof(LicenseRequest));

        LicenseRequest.pProductInfo = &ProductInfo;
        LicenseRequest.dwLanguageID = GetSystemDefaultLCID();
        LicenseRequest.dwPlatformID = CURRENT_TERMINAL_SERVER_VERSION;    
        LicenseRequest.cbEncryptedHwid = sizeof(HWID);
    }
    else
    {
        goto done;
    }


    if (!fHwidSet)
    {
        //
        // No hardware ID yet - create one
        //

        dwStatus = GenerateHwidFromComputerName(&hwid);

        if (dwStatus == ERROR_SUCCESS)
        {
            LsStatus = LsCsp_EncryptHwid(
                &hwid,
                (PBYTE)&hwidEncrypted,
                &(LicenseRequest.cbEncryptedHwid)
                );

            if (LsStatus == LICENSE_STATUS_OK)
            {
                fHwidSet = TRUE;
            }
            else
            {
                goto done;
            }
        }
        else
        {
            Status = STATUS_BUFFER_TOO_SMALL;
            goto done;
        }
    }

    LicenseRequest.pbEncryptedHwid = (PBYTE)&hwidEncrypted;

    //
    // get our computer name
    //

    fRet = GetComputerName(szComputerName, &cchComputerName);

    if (fRet)
    {
        LsStatus = CreateProtocolContext(NULL, &hProtocol);
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    if (0 == CurrentCount)
    {
        // any license server will do

        pszLicenseServerName = NULL;
    }
    else
    {
        cbLServerInfo = sizeof(LSERVERINFO);

        LsStatus = LsCsp_RetrieveSecret(
                                        CONCURRENT_LSERVER_STORE,
                                        (LPBYTE)&LServerInfo,
                                        &cbLServerInfo
                                        );

        if (LsStatus != LICENSE_STATUS_OK)
        {
            // no license server known; any will do

            pszLicenseServerName = NULL;
        }
    }

    cbLicense = 0;

    if (LsStatus == LICENSE_STATUS_OK)
    {
        //
        // NB: even if CurrentCount>0, license server will know about
        // existing licenses, and do a proper upgrade
        //

        dwNumLicensesRetrieved = nNumToAdd+CurrentCount;

        LsStatus = RequestNewLicense(
                           hProtocol,
                           pszLicenseServerName,
                           &LicenseRequest,
                           szComputerName,
                           szComputerName,
                           FALSE,       // bAcceptTemporaryLicense
                           TRUE,        // bAcceptFewerLicenses
                           &dwNumLicensesRetrieved,
                           &cbLicense,
                           &pbLicense
                           );

        if ((NULL != pfRetrievedAll)
            && (LsStatus == LICENSE_STATUS_OK)
            && ((LONG)dwNumLicensesRetrieved == nNumToAdd+CurrentCount))
        {
            *pfRetrievedAll = TRUE;
        }

    }
    else
    {
        goto done;
    }

    if (LsStatus == LICENSE_STATUS_OK)
    {
        //
        // Get the secret key that is used to decode the license
        //

        cbSecretKey = 0;

        LicenseGetSecretKey(&cbSecretKey, NULL);

        pbSecretKey = (PBYTE)LocalAlloc(LPTR, cbSecretKey);

        if (pbSecretKey != NULL)
        {
            LsStatus = LicenseGetSecretKey(&cbSecretKey, pbSecretKey);
        }
        else
        {
            Status = STATUS_NO_MEMORY;
            goto done;
        }

    }
    else
    {
        goto done;
    }

    //
    //  Decode license issued by hydra license server certificate engine.
    //

    __try
    {
        //
        //  Check size of decoded licenses.
        //

        LsStatus = LSVerifyDecodeClientLicense(
            pbLicense, 
            cbLicense, 
            pbSecretKey, 
            cbSecretKey,
            &dwNumLicensedProduct,
            NULL
            );

        if (LsStatus == LICENSE_STATUS_OK)
        {
            pLicensedProduct = (PLICENSEDPRODUCT)LocalAlloc(
                    LPTR,
                    sizeof(LICENSEDPRODUCT) * dwNumLicensedProduct
                    );
        }
        else
        {
            goto done;
        }
        
        if (pLicensedProduct != NULL)
        {
            //
            //  Decode the license.
            //

            LsStatus = LSVerifyDecodeClientLicense(
                pbLicense, 
                cbLicense, 
                pbSecretKey, 
                cbSecretKey,
                &dwNumLicensedProduct,
                pLicensedProduct
                );
        }
        else
        {
            Status = STATUS_NO_MEMORY;
            goto done;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        LsStatus = LICENSE_STATUS_CANNOT_DECODE_LICENSE;
    }

    if (LsStatus == LICENSE_STATUS_OK)
    {
        ReceivedPermanentLicense();

        LServerInfo.cchServerName = lstrlen(pLicensedProduct->szIssuer);

        lstrcpynW(
            LServerInfo.szServerName,
            pLicensedProduct->szIssuer,
            sizeof(LServerInfo.szServerName) / sizeof(WCHAR)
            );

        LServerInfo.ulSerialNumber = pLicensedProduct->ulSerialNumber;

        LServerInfo.ftNotAfter = pLicensedProduct->NotAfter;

        g_ftNotAfter = LServerInfo.ftNotAfter;

        LsStatus = LsCsp_StoreSecret(
            CONCURRENT_LSERVER_STORE,
            (LPBYTE)&LServerInfo,
            sizeof(LServerInfo)
            );

    }
    else
    {
        goto done;
    }

    if (LsStatus == LICENSE_STATUS_OK)
    {
        //
        //  Adjust the license count in the local LSA store.
        //

        LsStatus = SetLicenseInStore(
            dwNumLicensesRetrieved,
            hwidEncrypted,
            CURRENT_TERMINAL_SERVER_VERSION
            );

        RtlConvertSharedToExclusive(&g_rwLockLicense);
        g_lSessionMax = dwNumLicensesRetrieved;
        RtlConvertExclusiveToShared(&g_rwLockLicense);
    }

done:
    if (hProtocol != NULL)
    {
        DeleteProtocolContext(hProtocol);
    }

    if (pbLicense != NULL)
    {
        LocalFree(pbLicense);
    }

    if (pbSecretKey != NULL)
    {
        LocalFree(pbSecretKey);
    }

    if (pLicensedProduct != NULL)
    {
        for (DWORD dwCount = 0; dwCount < dwNumLicensedProduct; dwCount++)
        {
            LSFreeLicensedProduct(pLicensedProduct+dwCount);
        }
    }

    if (ProductInfo.pbCompanyName != NULL)
    {
        LocalFree(ProductInfo.pbCompanyName);
    }

    if (ProductInfo.pbProductID != NULL)
    {
        LocalFree(ProductInfo.pbProductID);
    }

    if (Status == STATUS_SUCCESS)
    {
        return(LsStatusToNtStatus(LsStatus));
    }
    else
    {
        return(Status);
    }
}

LICENSE_STATUS
GetLicenseFromStore(
    PLONG pLicenseCount,
    PHWID phwid,
    DWORD dwLicenseVer
    )
{
    CONCURRENTLICENSEINFO_V1 LicenseInfo;
    LICENSE_STATUS LsStatus;
    ULONG cbSecretLen;

    ASSERT(pLicenseCount != NULL);
    ASSERT(phwid != NULL);

    cbSecretLen = sizeof(CONCURRENTLICENSEINFO_V1);    
    ZeroMemory(&LicenseInfo, cbSecretLen);

    //
    // Get the license count from the LSA secret
    //

    LsStatus = LsCsp_RetrieveSecret( 
        CONCURRENT_LICENSE_STORE_LATEST_VERSION,
        (LPBYTE)&LicenseInfo,
        &cbSecretLen
        );

    if ((LsStatus != LICENSE_STATUS_OK) ||
        (cbSecretLen < sizeof(CONCURRENTLICENSEINFO_V1)) ||
        (LicenseInfo.dwLicenseVer != dwLicenseVer))
    {
        //
        // We determine that the license pack for this version is
        // not installed if we:
        //
        // (1) cannot retrieve the license info from the LSA secret
        // (2) cannot read at least the size of version 1 of the license info
        // structure.
        // (3) the license pack version is different from that requested.
        //

        LsStatus = LICENSE_STATUS_NO_LICENSE_ERROR;
    }
    else
    {
        *pLicenseCount = LicenseInfo.lLicenseCount;
        *phwid = LicenseInfo.hwid;
    }
        
    return(LsStatus);
}

LICENSE_STATUS
SetLicenseInStore(
    LONG LicenseCount,
    HWID hwid,
    DWORD dwLicenseVer
    )
{
    CONCURRENTLICENSEINFO_V1 LicenseInfo;
    LICENSE_STATUS LsStatus;

    //
    // verify that the license count to set is not negative.
    //

    ASSERT(LicenseCount >= 0);

    //
    // initialize the license information to store
    //

    LicenseInfo.dwStructVer = CONCURRENTLICENSEINFO_TYPE_V1;
    LicenseInfo.dwLicenseVer = dwLicenseVer;
    LicenseInfo.hwid = hwid;
    LicenseInfo.lLicenseCount = LicenseCount;

    //
    // store the new license count
    //

    LsStatus = LsCsp_StoreSecret(
        CONCURRENT_LICENSE_STORE_LATEST_VERSION,
        (LPBYTE)&LicenseInfo,
        sizeof(CONCURRENTLICENSEINFO_V1)
        );

    return(LsStatus);
}

/*
 *  Private Functions
 */

//
// Must have shared lock to call this
//

NTSTATUS
CConcurrentPolicy::CheckExpiration(
    )
{
    DWORD dwWait = TimeToSoftExpiration();
    NTSTATUS Status = STATUS_SUCCESS;

    if (0 == dwWait)
    {
        // Soft expiration reached, time to renew
        Status = GetLicenseFromLS(g_lSessionMax,
                                  TRUE,         // fIgnoreCurrentCount
                                  NULL);

        if ((STATUS_SUCCESS != Status) && (0 == TimeToHardExpiration()))
        {
            // Couldn't renew and we're past hard expiration

            LicenseLogEvent(EVENTLOG_ERROR_TYPE,
                            EVENT_LICENSING_CONCURRENT_EXPIRED,
                            0,
                            NULL
                            );

            RtlConvertSharedToExclusive(&g_rwLockLicense);
            g_lSessionMax = 0;
            RtlConvertExclusiveToShared(&g_rwLockLicense);
        }
        else
        {
            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}

/*
 *  Global Static Functions
 */

DWORD
CConcurrentPolicy::TimeToSoftExpiration(
    )
{
    SYSTEMTIME stNow;
    FILETIME ftNow;
    ULARGE_INTEGER ullNotAfterLeeway;
    ULARGE_INTEGER ullNow;
    ULARGE_INTEGER ullDiff;
    DWORD dwDiff = 0;

    GetSystemTime(&stNow);
    SystemTimeToFileTime(&stNow,&ftNow);

    ullNow.LowPart = ftNow.dwLowDateTime;
    ullNow.HighPart = ftNow.dwHighDateTime;

    ullNotAfterLeeway.LowPart = g_ftNotAfter.dwLowDateTime;
    ullNotAfterLeeway.HighPart = g_ftNotAfter.dwHighDateTime;

    ullNotAfterLeeway.QuadPart -= (__int64) LC_POLICY_CONCURRENT_EXPIRATION_LEEWAY * 10 * 1000;

    if (ullNotAfterLeeway.QuadPart > ullNow.QuadPart)
    {
        ullDiff.QuadPart = ullNotAfterLeeway.QuadPart - ullNow.QuadPart;

        ullDiff.QuadPart /= (10 * 1000);

        if (ullDiff.HighPart == 0)
        {
            dwDiff = ullDiff.LowPart;
        }
        else
        {
            // too big, return max

            dwDiff = ULONG_MAX;
        }
    }

    return dwDiff;
}

DWORD
CConcurrentPolicy::TimeToHardExpiration(
    )
{
    SYSTEMTIME stNow;
    FILETIME ftNow;
    ULARGE_INTEGER ullNotAfterLeeway;
    ULARGE_INTEGER ullNow;
    ULARGE_INTEGER ullDiff;
    DWORD dwDiff = 0;

    GetSystemTime(&stNow);
    SystemTimeToFileTime(&stNow,&ftNow);

    ullNow.LowPart = ftNow.dwLowDateTime;
    ullNow.HighPart = ftNow.dwHighDateTime;

    ullNotAfterLeeway.LowPart = g_ftNotAfter.dwLowDateTime;
    ullNotAfterLeeway.HighPart = g_ftNotAfter.dwHighDateTime;

    if (ullNotAfterLeeway.QuadPart > ullNow.QuadPart)
    {
        ullDiff.QuadPart = ullNotAfterLeeway.QuadPart - ullNow.QuadPart;

        ullDiff.QuadPart /= (10 * 1000);

        if (ullDiff.HighPart == 0)
        {
            dwDiff = ullDiff.LowPart;
        }
        else
        {
            // too big, return max

            dwDiff = ULONG_MAX;
        }
    }

    return dwDiff;
}

VOID
CConcurrentPolicy::ReadLicensingParameters(
    )
{
    HKEY hKey = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwBuffer;
    DWORD cbBuffer;

    g_dwIncrement = LC_POLICY_CONCURRENT_LICENSE_COUNT_INCREMENT;
    g_dwWaitTimeAdd = LC_POLICY_CONCURRENT_WAIT_TIME_ADD;
    g_dwWaitTimeRemove = LC_POLICY_CONCURRENT_WAIT_TIME_REMOVE;
        
    dwStatus =RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    LCREG_CONCURRENTKEY,
                    0,
                    KEY_READ,
                    &hKey
                    );

    if(dwStatus == ERROR_SUCCESS)
    {
        cbBuffer = sizeof(dwBuffer);
        dwStatus = RegQueryValueEx(
                    hKey,
                    LCREG_INCREMENT,
                    NULL,
                    NULL,
                    (LPBYTE)&dwBuffer,
                    &cbBuffer
                    );

        if (dwStatus == ERROR_SUCCESS)
        {
            g_dwIncrement = max(dwBuffer, 1);
        }

        cbBuffer = sizeof(dwBuffer);
        dwStatus = RegQueryValueEx(
                    hKey,
                    LCREG_WAIT_TIME_ADD,
                    NULL,
                    NULL,
                    (LPBYTE)&dwBuffer,
                    &cbBuffer
                    );

        if (dwStatus == ERROR_SUCCESS)
        {
            g_dwWaitTimeAdd = max(dwBuffer, 1);
        }

        cbBuffer = sizeof(dwBuffer);
        dwStatus = RegQueryValueEx(
                    hKey,
                    LCREG_WAIT_TIME_REMOVE,
                    NULL,
                    NULL,
                    (LPBYTE)&dwBuffer,
                    &cbBuffer
                    );

        if (dwStatus == ERROR_SUCCESS)
        {
            g_dwWaitTimeRemove = max(dwBuffer, 1);
        }

        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\lcrpcint.h ===
/*
 *  LCRpcInt.h
 *
 *  Author: BreenH
 *
 *  Internal functions to support the RPC interface.
 */

#ifndef __LC_LCRPCINT_H__
#define __LC_LCRPCINT_H__

/*
 *  Function Prototypes
 */

NTSTATUS
InitializeRpcInterface(
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\inc\wsxmgr.h ===
/*************************************************************************
*
* wsxmgr.h
*
* Data to manage Window Station extensions.
*
* Copyright Microsoft Corporation, 1998
*
*  
*************************************************************************/


/*=============================================================================
==   ICA Server supplied procs
=============================================================================*/

/*
 *  Callback workers
 */

typedef VOID (WINAPI * PCALLBACK_PRIMARY)(PVOID, PVOID, PVOID);
typedef VOID (WINAPI * PCALLBACK_COMPLETION)(PVOID);


/*
 *  ICASRV Exported Functions
 */

typedef VOID (WINAPI * PICASRV_NOTIFYSYSTEMEVENT)(ULONG);
typedef VOID (WINAPI * PICASRV_SENDWINSTATIONMESSAGE)(ULONG, PWCHAR, PWCHAR, ULONG);
typedef VOID (WINAPI * PICASRV_GETCONTEXTFORLOGONID)(ULONG, PVOID *);
typedef VOID (WINAPI * PICASRV_WINSTATIONENUMCALLBACK)(PCALLBACK_PRIMARY,
                                                       PCALLBACK_COMPLETION,
                                                       PVOID);

/*
 * Typedefs and structures
 */
typedef struct _ICASRVPROCADDR {

    ULONG                           cbProcAddr;

    PICASRV_NOTIFYSYSTEMEVENT       pNotifySystemEvent;
    PICASRV_SENDWINSTATIONMESSAGE   pSendWinStationMessage;
    PICASRV_GETCONTEXTFORLOGONID    pGetContextForLogonId;
    PICASRV_WINSTATIONENUMCALLBACK  pWinStationEnumCallBack;

} ICASRVPROCADDR, * PICASRVPROCADDR;



/*
 * Exported function prototypes
 */

//  Initialization

typedef BOOL (WINAPI * PWSX_INITIALIZE)(PICASRVPROCADDR);
typedef NTSTATUS (WINAPI * PWSX_WINSTATIONINITIALIZE)(PVOID *);
typedef NTSTATUS (WINAPI * PWSX_WINSTATIONREINITIALIZE)(PVOID, PVOID);
typedef NTSTATUS (WINAPI * PWSX_WINSTATIONRUNDOWN)(PVOID);



//  Client Drive Mapping Extensions

typedef NTSTATUS (WINAPI * PWSX_CDMCONNECT)(PVOID, ULONG, HANDLE);
typedef NTSTATUS (WINAPI * PWSX_CDMDISCONNECT)(PVOID, ULONG, HANDLE);



//  License Extensions

typedef NTSTATUS (WINAPI * PWSX_VERIFYCLIENTLICENSE)(PVOID, SDCLASS);
typedef NTSTATUS (WINAPI * PWSX_GETLICENSE)(PVOID, HANDLE, ULONG, BOOL);
typedef NTSTATUS (WINAPI * PWSX_QUERYLICENSE)(PVOID, ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONGENERATELICENSE)(PWCHAR, ULONG, PCHAR, ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONINSTALLLICENSE)(PCHAR, ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONENUMERATELICENSES)(PULONG, PULONG, PCHAR, PULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONACTIVATELICENSE)(PCHAR, ULONG, PWCHAR, ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONREMOVELICENSE)(PCHAR, ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONSETPOOLCOUNT)(PCHAR, ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONQUERYUPDATEREQUIRED)(PULONG);
typedef NTSTATUS (WINAPI * PWSX_WINSTATIONLOGONANNOYANCE)(ULONG);
typedef DWORD (WINAPI * PWSX_WINSTATIONANNOYANCETHREAD)(PVOID);


//  Context 


typedef NTSTATUS (WINAPI * PWSX_DUPLICATECONTEXT)(PVOID, PVOID *);
typedef NTSTATUS (WINAPI * PWSX_COPYCONTEXT)(PVOID, PVOID);
typedef NTSTATUS (WINAPI * PWSX_CLEARCONTEXT)(PVOID);


//  Other


typedef NTSTATUS (WINAPI * PWSX_VIRTUALCHANNELSECURITY)(PVOID, HANDLE, PUSERCONFIG);
typedef NTSTATUS (WINAPI * PWSX_ICASTACKIOCONTROL)(PVOID, HANDLE, HANDLE, ULONG, PVOID, ULONG, PVOID, ULONG, PULONG);
typedef NTSTATUS (WINAPI * PWSX_INITIALIZECLIENTDATA)(PVOID, HANDLE, HANDLE, HANDLE,
                                                      BYTE *, ULONG, PUSERCONFIG, 
                                                      PUSHORT, PUSHORT, PUSHORT,
                                                      WINSTATIONDOCONNECTMSG *);
typedef NTSTATUS (WINAPI * PWSX_INITIALIZEUSERCONFIG)(PVOID, HANDLE, HANDLE, PUSERCONFIG,
                                                      PUSHORT, PUSHORT, PUSHORT);
typedef NTSTATUS (WINAPI * PWSX_CONVERTPUBLISHEDAPP)(PVOID, PUSERCONFIG);
typedef NTSTATUS (WINAPI * PWSX_CHECKFORAPPLICATIONNAME)(PVOID, PWCHAR, ULONG, PWCHAR, ULONG,  
                                                         PWCHAR, PULONG, ULONG, PCHAR, PBOOLEAN, PBOOLEAN ); 
typedef NTSTATUS (WINAPI * PWSX_GETAPPLICATIONINFO)(PVOID, PBOOLEAN, PBOOLEAN); 
typedef NTSTATUS (WINAPI * PWSX_BROKENCONNECTION)(PVOID, HANDLE, PICA_BROKEN_CONNECTION); 
typedef NTSTATUS (WINAPI * PWSX_LOGONNOTIFY)(PVOID, ULONG, HANDLE, PWCHAR, PWCHAR); 
typedef NTSTATUS (WINAPI * PWSX_SETERRORINFO)(PVOID, UINT32, BOOL); 
typedef NTSTATUS (WINAPI * PWSX_SENDAUTORECONNECTSTATUS)(PVOID, UINT32, BOOL); 
// added for long UserName, Password support
typedef NTSTATUS (WINAPI * PWSX_ESCAPE) (PVOID, INFO_TYPE, PVOID, ULONG, PVOID, ULONG, PULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\lctrace.h ===
/*
 *  LCTrace.h
 *
 *  Author: BreenH
 *
 *  Tracing code for the licensing core.
 */

#ifndef __LC_LCTRACE_H__
#define __LC_LCTRACE_H__

#ifdef DBG

/*
 *  Constants
 */

#define LCTRACETYPE_NONE ((ULONG)(0x0))
#define LCTRACETYPE_API ((ULONG)(0x1))
#define LCTRACETYPE_INFO ((ULONG)(0x2))
#define LCTRACETYPE_WARNING ((ULONG)(0x4))
#define LCTRACETYPE_ERROR ((ULONG)(0x8))
#define LCTRACETYPE_ALL ((ULONG)(0xFFFF))

/*
 *  Function Prototypes
 */

VOID
TraceInitialize(
    VOID
    );

VOID __cdecl
TracePrint(
    ULONG ulTraceLevel,
    LPCSTR pFormat,
    ...
    );

#define TRACEPRINT(x) TracePrint x;

#else

#define TRACEPRINT(x)

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\lctrace.cpp ===
/*
 *  LCTrace.cpp
 *
 *  Author: BreenH
 *
 *  Tracing code for the licensing core.
 */

#ifdef DBG

/*
 *  Includes
 */

#include "precomp.h"
#include "lctrace.h"
#include "lcreg.h"

/*
 *  Constants
 */

#define LCTRACE_FMT_MSG_SIZE 256

/*
 *  Globals
 */

ULONG g_ulTraceLevel;

/*
 *  Function Prototypes
 */

LPCSTR
TraceLevelString(
    ULONG ulTraceLevel
    );

/*
 *  Function Implementations
 */

VOID
TraceInitialize(
    VOID
    )
{
    DWORD cbSize;
    DWORD dwStatus;
    DWORD dwType;

    g_ulTraceLevel = LCTRACETYPE_NONE;
    cbSize = sizeof(DWORD);

    dwStatus = RegQueryValueEx(
        GetBaseKey(),
        LCREG_TRACEVALUE,
        NULL,
        &dwType,
        (LPBYTE)&g_ulTraceLevel,
        &cbSize
        );

    if (dwStatus == ERROR_SUCCESS)
    {
        ASSERT(cbSize == sizeof(DWORD));
        ASSERT(dwType == REG_DWORD);

        if (g_ulTraceLevel != LCTRACETYPE_NONE)
        {
            DbgPrint("LSCORE: Trace Message: Trace initialized to 0x%x\n", g_ulTraceLevel);
        }
    }
}

VOID __cdecl
TracePrint(
    ULONG ulTraceLevel,
    LPCSTR pFormat,
    ...
    )
{
    int cbPrinted;
    va_list vaList;
    CHAR szFormattedMessage[LCTRACE_FMT_MSG_SIZE];

    if ((ulTraceLevel & g_ulTraceLevel) == 0)
    {
        return;
    }

    va_start(vaList, pFormat);
    cbPrinted = _vsnprintf(szFormattedMessage, LCTRACE_FMT_MSG_SIZE, pFormat, vaList);
    va_end(vaList);

    if (cbPrinted == -1)
    {
        DbgPrint("LSCORE: Trace Message: Next trace message too long.\n");
        szFormattedMessage[LCTRACE_FMT_MSG_SIZE - 1] = (CHAR)NULL;
    }

    DbgPrint("LSCORE: %s: %s\n", TraceLevelString(ulTraceLevel), szFormattedMessage);
}

LPCSTR
TraceLevelString(
    ULONG ulTraceLevel
    )
{
#define TLS_CASE(x) case x: return(#x)

    switch(ulTraceLevel)
    {
        TLS_CASE(LCTRACETYPE_API);
        TLS_CASE(LCTRACETYPE_INFO);
        TLS_CASE(LCTRACETYPE_WARNING);
        TLS_CASE(LCTRACETYPE_ERROR);
        TLS_CASE(LCTRACETYPE_ALL);
        default: return("Trace Level Unknown");
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\lcrpcint.cpp ===
/*
 *  LCRpcInt.cpp
 *
 *  Author: BreenH
 *
 *  Internal functions to support the RPC interface.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "lscorep.h"
#include "lcrpcint.h"
#include "lcrpc.h"
#include "rpcwire.h"

/*
 *  Globals
 */

ULONG g_ulRpcContext = 0;

/*
 *  TERMSRV.EXE Function Prototypes
 */

extern "C" BOOL
IsCallerAdmin(
    VOID
    );

/*
 *  Function Implementations
 */

RPC_STATUS
InitializeRpcInterface(
    )
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcServerUseProtseqEp(
        L"ncalrpc",
        LC_RPC_MAX_THREADS,
        LC_RPC_LRPC_EP,
        NULL
        );

    if (RpcStatus == RPC_S_OK)
    {
        RpcStatus = RpcServerUseProtseqEp(
            L"ncacn_np",
            LC_RPC_MAX_THREADS,
            LC_RPC_NP_EP,
            NULL
            );
    }
    else
    {
        goto exit;
    }

    if (RpcStatus == RPC_S_OK)
    {
        RpcStatus = RpcServerRegisterIf(
            LCRPC_v1_0_s_ifspec,
            NULL,
            NULL
            );
    }
    else
    {
        goto exit;
    }

exit:
    return(RpcStatus);
}

/*
 *  RPC Interface Functions
 */

extern "C" void
LCRPC_HANDLE_rundown(
    LCRPC_HANDLE hServer
    )
{
    RpcLicensingCloseServer(&hServer);
}

BOOLEAN
RpcLicensingOpenServer(
    handle_t hBinding,
    HANDLE *phServer,
    PLONG pStatus
    )
{
    BOOLEAN fReturn;
    PULONG pulContext;

    UNREFERENCED_PARAMETER(hBinding);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pStatus != NULL);
    ASSERT(phServer != NULL);

    pulContext = (PULONG)MIDL_user_allocate(sizeof(ULONG));

    //
    //  Currently, RPC contexts are not necessary, but in case they are
    //  needed in the future, the RPC calls today must pass them. For
    //  now, just increment a ULONG for a context value.
    //

    if (pulContext != NULL)
    {
        *pulContext = g_ulRpcContext++;
        *phServer = pulContext;
        *pStatus = STATUS_SUCCESS;
        fReturn = TRUE;
    }
    else
    {
        *pStatus = STATUS_INSUFF_SERVER_RESOURCES;
        fReturn = FALSE;
    }

    return(fReturn);
}

VOID
RpcLicensingCloseServer(
    HANDLE *phServer
    )
{
    ASSERT(phServer != NULL);
    ASSERT(*phServer != NULL);

    MIDL_user_free(*phServer);
    *phServer = NULL;
}

BOOLEAN
RpcLicensingLoadPolicy(
    HANDLE hServer,
    ULONG ulPolicyId,
    PLONG pStatus
    )
{
    UNREFERENCED_PARAMETER(hServer);
    UNREFERENCED_PARAMETER(ulPolicyId);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pStatus != NULL);

    *pStatus = STATUS_NOT_IMPLEMENTED;
    return(FALSE);
}

BOOLEAN
RpcLicensingUnloadPolicy(
    HANDLE hServer,
    ULONG ulPolicyId,
    PLONG pStatus
    )
{
    UNREFERENCED_PARAMETER(hServer);
    UNREFERENCED_PARAMETER(ulPolicyId);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pStatus != NULL);

    *pStatus = STATUS_NOT_IMPLEMENTED;
    return(FALSE);
}

LONG
RpcLicensingSetPolicy(
    HANDLE hServer,
    ULONG ulPolicyId,
    PLONG pNewPolicyStatus
    )
{
    NTSTATUS Status;
    RPC_STATUS RpcStatus;

    UNREFERENCED_PARAMETER(hServer);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pNewPolicyStatus != NULL);

    //
    //  Impersonate client.
    //

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        Status = STATUS_CANNOT_IMPERSONATE;
        *pNewPolicyStatus = STATUS_SUCCESS;
        return(Status);
    }

    //
    //  Check for administration privileges.
    //

    if (!IsCallerAdmin())
    {
        RpcRevertToSelf();
        Status = STATUS_ACCESS_DENIED;
        *pNewPolicyStatus = STATUS_SUCCESS;
        return(Status);
    }

    RpcRevertToSelf();

    Status = LCSetPolicy(ulPolicyId, pNewPolicyStatus);

    return(Status);
}

BOOLEAN
RpcLicensingGetAvailablePolicyIds( 
    HANDLE hServer,
    PULONG *ppulPolicyIds,
    PULONG pcPolicies,
    PLONG pStatus
    )
{
    UNREFERENCED_PARAMETER(hServer);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(ppulPolicyIds != NULL);
    ASSERT(pcPolicies != NULL);
    ASSERT(pStatus != NULL);

    *pStatus = LCGetAvailablePolicyIds(ppulPolicyIds, pcPolicies);

    return(*pStatus == STATUS_SUCCESS);
}

BOOLEAN
RpcLicensingGetPolicy( 
    HANDLE hServer,
    PULONG pulPolicyId,
    PLONG pStatus
    )
{
    UNREFERENCED_PARAMETER(hServer);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pulPolicyId != NULL);
    ASSERT(pStatus != NULL);

    *pulPolicyId = LCGetPolicy();
    *pStatus = STATUS_SUCCESS;

    return(TRUE);
}

BOOLEAN
RpcLicensingGetPolicyInformation( 
    HANDLE hServer,
    ULONG ulPolicyId,
    PULONG pulVersion,
    PCHAR *ppWire,
    PULONG pcbWire,
    PLONG pStatus
    )
{
    BOOLEAN fRet;
    LPLCPOLICYINFOGENERIC lpPolicyInfo;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(hServer);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pulVersion != NULL);
    ASSERT(ppWire != NULL);
    ASSERT(pcbWire != NULL);
    ASSERT(pStatus != NULL);

    fRet = FALSE;
    *pulVersion = min(*pulVersion, LCPOLICYINFOTYPE_CURRENT);
    *ppWire = NULL;

    Status = AllocatePolicyInformation(&lpPolicyInfo, *pulVersion);

    if (Status == STATUS_SUCCESS)
    {
        Status = LCGetPolicyInformation(ulPolicyId, lpPolicyInfo);

        if (Status == STATUS_SUCCESS)
        {
            *pcbWire = CopyPolicyInformationToWire(
                (LPLCPOLICYINFOGENERIC*)ppWire,
                lpPolicyInfo
                );

            if (*pcbWire != 0)
            {
                fRet = TRUE;
                Status = STATUS_SUCCESS;
            }
            else
            {
                Status = STATUS_INSUFF_SERVER_RESOURCES;
            }

            FreePolicyInformation(&lpPolicyInfo);
        }
        else if (Status == STATUS_NO_MEMORY)
        {
            Status = STATUS_INSUFF_SERVER_RESOURCES;
        }
    }

    *pStatus = Status;

    return(fRet);
}

BOOLEAN
RpcLicensingDeactivateCurrentPolicy(
    HANDLE hServer,
    PLONG pStatus
    )
{
    RPC_STATUS RpcStatus;

    UNREFERENCED_PARAMETER(hServer);

    //
    //  These pointers are REF pointers; they cannot be NULL.
    //

    ASSERT(pStatus != NULL);

    //
    //  Impersonate client.
    //

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        *pStatus = STATUS_CANNOT_IMPERSONATE;
        return(FALSE);
    }

    //
    //  Check for administration privileges.
    //

    if (!IsCallerAdmin())
    {
        RpcRevertToSelf();
        *pStatus = STATUS_ACCESS_DENIED;
        return(FALSE);
    }

    RpcRevertToSelf();

    *pStatus = LCDeactivateCurrentPolicy();

    return(*pStatus == STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\lscore.cpp ===
/*
 *  LSCore.cpp
 *
 *  Author: BreenH
 *
 *  The licensing core.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "lscorep.h"
#include "lcreg.h"
#include "lcrpcint.h"
#include "session.h"
#include "policy.h"
#include "pollist.h"
#include "lctrace.h"
#include "util.h"

/*
 *  Globals
 */

extern "C" BOOL g_fAppCompat;
CRITICAL_SECTION g_PolicyCritSec;
LCINITMODE g_lcInitMode;
CPolicy *g_pCurrentPolicy = NULL;
BOOL g_fInitialized = FALSE;

/*
 *  Initialization Function Implementations
 */

extern "C"
NTSTATUS
LCInitialize(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    )
{
    CPolicy *pPolicy;
    DWORD dwStatus;
    LICENSE_STATUS LsStatus;
    NTSTATUS Status;
    ULONG ulPolicyId;
    ULONG ulAlternatePolicyId = ULONG_MAX;

    Status = RegistryInitialize();

    if (Status == STATUS_SUCCESS)
    {
#if DBG
        TraceInitialize();
#endif

        TRACEPRINT((LCTRACETYPE_API, "LCInitialize: Entered with lcInitMode: %d", lcInitMode));

        Status = RtlInitializeCriticalSection(&g_PolicyCritSec);
    }
    else
    {
        goto errorreginit;
    }

    if (Status == STATUS_SUCCESS)
    {
        dwStatus = TLSInit();
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to RtlInitializeCriticalSection: 0x%x", Status));

        goto errorcritsecalloc;
    }

    if (dwStatus == ERROR_SUCCESS)
    {
        LsStatus = InitializeProtocolLib();
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to TLSInit: %d", dwStatus));

        Status = STATUS_UNSUCCESSFUL;
        goto errortlsinit;
    }

    if (lcInitMode == LC_INIT_ALL)
    {
        dwStatus = TLSStartDiscovery();

        if (dwStatus != ERROR_SUCCESS)
        {
            //
            //  This error is not fatal.
            //

            TRACEPRINT((LCTRACETYPE_WARNING, "LCInitialize: Failed to TLSStartDiscovery: %d", dwStatus));
        }
    }

    if (LsStatus == LICENSE_STATUS_OK)
    {
        Status = PolicyListInitialize();
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to InitializeProtocolLib: 0x%x", LsStatus));

        Status = STATUS_UNSUCCESSFUL;
        goto errorprotlib;
    }

    if (Status == STATUS_SUCCESS)
    {
        Status = InitializePolicies(lcInitMode, fAppCompat);
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to PolicyListInitialize: 0x%x", Status));

        goto errorinitpollist;
    }

    if (Status == STATUS_SUCCESS)
    {
        ulPolicyId = GetInitialPolicy(lcInitMode, fAppCompat);
        pPolicy = PolicyListFindById(ulPolicyId);
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to InitializePolicies: 0x%x", Status));

        goto errorinitpol;
    }

    ASSERT(pPolicy != NULL);

    Status = pPolicy->CoreActivate(TRUE,&ulAlternatePolicyId);

    if (Status != STATUS_SUCCESS)
    {
        if ((ulAlternatePolicyId != ULONG_MAX)
            && (ulAlternatePolicyId != ulPolicyId))
        {
            TRACEPRINT((LCTRACETYPE_WARNING, "LCInitialize: Trying to activate the alternate policy, ID: %d, Status: 0x%x", ulAlternatePolicyId, Status));

            pPolicy = PolicyListFindById(ulAlternatePolicyId);

            if (NULL != pPolicy)
            {

                Status = pPolicy->CoreActivate(TRUE,NULL);
                
                if (Status == STATUS_SUCCESS)
                {
                    goto foundpolicy;
                }
            }
            else
            {
                TRACEPRINT((LCTRACETYPE_WARNING, "LCInitialize: Alternate policy could not be loaded, ID: %d", ulAlternatePolicyId));
            }

        }

        {
            ULONG ulNewPolicyId;

            TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to activate the initial policy, ID: %d, Status: 0x%x", ulPolicyId, Status));

            ulNewPolicyId = GetHardcodedPolicyId(lcInitMode, fAppCompat);

            if ((ulNewPolicyId != ulPolicyId)
                && (ulNewPolicyId != ulAlternatePolicyId))
            {
                TRACEPRINT((LCTRACETYPE_WARNING, "LCInitialize: Trying to activate the default policy, ID: %d, Status: 0x%x", ulNewPolicyId, Status));

                pPolicy = PolicyListFindById(ulNewPolicyId);

                ASSERT(pPolicy != NULL);

                Status = pPolicy->CoreActivate(TRUE,NULL);
            }
            else
            {
                TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed policy is default policy!"));
            }
        }
    }

    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to activate any policy!"));

        goto erroractpol;
    }

foundpolicy:
    g_pCurrentPolicy = pPolicy;

    if (lcInitMode == LC_INIT_ALL)
    {
        Status = InitializeRpcInterface();

        if (Status != STATUS_SUCCESS)
        {
            TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Failed to InitializeRpcInterface: 0x%x", Status));

            goto errorrpcinit;
        }
    }

    g_lcInitMode = lcInitMode;

    TRACEPRINT((LCTRACETYPE_API, "LCInitialize: Returning success"));

    g_fInitialized = TRUE;

    return(STATUS_SUCCESS);

errorrpcinit:
erroractpol:
    ShutdownPolicies();
errorinitpol:
    ShutdownProtocolLib();
errorinitpollist:
errorprotlib:
    TLSShutdown();
errortlsinit:
    RtlDeleteCriticalSection(&g_PolicyCritSec);
errorcritsecalloc:
errorreginit:
    TRACEPRINT((LCTRACETYPE_ERROR, "LCInitialize: Returning: 0x%x", Status));

    return(Status);
}

// This function should invoke only the most important and required
// destruction code, since we're on a strict time limit on system shutdown.
extern "C"
VOID
LCShutdown(
    )
{
    // Note: this can be called without LCInitialize having been called

    if (g_fInitialized)
    {
        g_fInitialized = FALSE;

        RtlEnterCriticalSection(&g_PolicyCritSec);
    
        if (NULL != g_pCurrentPolicy)
        {
            g_pCurrentPolicy->CoreDeactivate(TRUE);
            g_pCurrentPolicy = NULL;
        }

        ShutdownPolicies();

        RtlLeaveCriticalSection(&g_PolicyCritSec);
    }
}

/*
 *  Policy Loading and Activation Function Implementations
 */

extern "C"
NTSTATUS
LCLoadPolicy(
    ULONG ulPolicyId
    )
{
    UNREFERENCED_PARAMETER(ulPolicyId);

    return(STATUS_NOT_IMPLEMENTED);
}

extern "C"
NTSTATUS
LCUnloadPolicy(
    ULONG ulPolicyId
    )
{
    UNREFERENCED_PARAMETER(ulPolicyId);

    return(STATUS_NOT_IMPLEMENTED);
}

extern "C"
NTSTATUS
LCDeactivateCurrentPolicy(
    )
{
    NTSTATUS Status;

    TRACEPRINT((LCTRACETYPE_API, "LCDeactivateCurrentPolicy:"));

    RtlEnterCriticalSection(&g_PolicyCritSec);

    Status = g_pCurrentPolicy->CoreDeactivate(FALSE);

    RtlLeaveCriticalSection(&g_PolicyCritSec);

    return(Status);
}

extern "C"
NTSTATUS
LCSetPolicy(
    ULONG ulPolicyId,
    PNTSTATUS pNewPolicyStatus
    )
{
    CPolicy *pNewPolicy;
    NTSTATUS Status;

    TRACEPRINT((LCTRACETYPE_API, "LCSetPolicy: Entered with ulPolicyId: %d, pNewPolicyStatus: 0x%p", ulPolicyId, pNewPolicyStatus));
    ASSERT(pNewPolicyStatus != NULL);

    *pNewPolicyStatus = STATUS_SUCCESS;

    RtlEnterCriticalSection(&g_PolicyCritSec);

    if (ulPolicyId == g_pCurrentPolicy->GetId())
    {
        Status = STATUS_SUCCESS;
        goto exit;
    }

    pNewPolicy = PolicyListFindById(ulPolicyId);

    if (pNewPolicy == NULL)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto exit;
    }

    *pNewPolicyStatus = pNewPolicy->CoreActivate(FALSE,NULL);

    if (*pNewPolicyStatus == STATUS_SUCCESS)
    {
        Status = SetInitialPolicy(ulPolicyId, g_fAppCompat);

        if (Status == STATUS_SUCCESS)
        {
            g_pCurrentPolicy->CoreDeactivate(FALSE);
            g_pCurrentPolicy = pNewPolicy;
        }
        else
        {
            pNewPolicy->CoreDeactivate(FALSE);
        }
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCSetPolicy: Failed to pNewPolicy->CoreActivate: 0x%x", *pNewPolicyStatus));

        Status = STATUS_UNSUCCESSFUL;
    }

exit:
    RtlLeaveCriticalSection(&g_PolicyCritSec);

    TRACEPRINT((LCTRACETYPE_API, "LCSetPolicy: Returning 0x%x", Status));

    return(Status);
}

/*
 *  Administrative Function Implementations
 */

extern "C"
VOID
LCAssignPolicy(
    PWINSTATION pWinStation
    )
{
    LPLCCONTEXT lpContext;

    ASSERT(pWinStation != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCAssignPolicy: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    ASSERT(lpContext != NULL);
    ASSERT(lpContext->pPolicy == NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCAssignPolicy: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    //
    //  Always enter the context critical section first.
    //

    RtlEnterCriticalSection(&(lpContext->CritSec));

    RtlEnterCriticalSection(&g_PolicyCritSec);

    ASSERT(g_pCurrentPolicy != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCAssignPolicy: Session: %d, Assigning policy: %d", pWinStation->LogonId, g_pCurrentPolicy->GetId()));

    lpContext->pPolicy = g_pCurrentPolicy;
    lpContext->pPolicy->IncrementReference();

    RtlLeaveCriticalSection(&g_PolicyCritSec);

    RtlLeaveCriticalSection(&(lpContext->CritSec));

    TRACEPRINT((LCTRACETYPE_API, "LCAssignPolicy: Session: %d, Returning", pWinStation->LogonId));
}

extern "C"
NTSTATUS
LCCreateContext(
    PWINSTATION pWinStation
    )
{
    LPLCCONTEXT lpContext;
    NTSTATUS Status;

    ASSERT(pWinStation != NULL);
    ASSERT(pWinStation->lpLicenseContext == NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCCreateContext: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)LocalAlloc(LPTR, sizeof(LCCONTEXT));

    if (lpContext != NULL)
    {
        Status = RtlInitializeCriticalSection(&(lpContext->CritSec));

        if (Status == STATUS_SUCCESS)
        {
            TRACEPRINT((LCTRACETYPE_INFO, "LCCreateContext: Session: %d, Context initialized", pWinStation->LogonId));

            pWinStation->lpLicenseContext = (LPARAM)lpContext;
        }
        else
        {
            TRACEPRINT((LCTRACETYPE_ERROR, "LCCreateContext: Session: %d, Failed RtlInitializeCriticalSection: 0x%x", pWinStation->LogonId, Status));

            LocalFree(lpContext);
        }
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCCreateContext: Session: %d, Failed lpContext allocation", pWinStation->LogonId));

        Status = STATUS_NO_MEMORY;
    }

    TRACEPRINT((LCTRACETYPE_API, "LCCreateContext: Session: %d, Returning 0x%x", pWinStation->LogonId, Status));

    return(Status);
}

extern "C"
VOID
LCDestroyContext(
    PWINSTATION pWinStation
    )
{
    LPLCCONTEXT lpContext;

    ASSERT(pWinStation != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCDestroyContext: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    if (lpContext != NULL)
    {
        TRACEPRINT((LCTRACETYPE_INFO, "LCDestroyContext: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

        //
        //  Idle winstations may not have a policy assigned.
        //

        if (lpContext->pPolicy != NULL)
        {
            TRACEPRINT((LCTRACETYPE_INFO, "LCDestroyContext: Session: %d, Policy: %d", pWinStation->LogonId, lpContext->pPolicy->GetId()));

            if (lpContext->lPrivate != NULL)
            {
                lpContext->pPolicy->DestroyPrivateContext(lpContext);
            }

            RtlEnterCriticalSection(&g_PolicyCritSec);

            lpContext->pPolicy->DecrementReference();

            RtlLeaveCriticalSection(&g_PolicyCritSec);

            lpContext->pPolicy = NULL;
        }
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_INFO, "LCDestroyContext: Session: %d, lpContext is NULL", pWinStation->LogonId));

        goto exit;
    }

    //
    //  The lPrivate member should have been freed and set to NULL by the
    //  policy during the DestroyPrivateContext call.
    //

    ASSERT(lpContext->lPrivate == NULL);

    if (lpContext->hProtocolLibContext != NULL)
    {
        DeleteProtocolContext(lpContext->hProtocolLibContext);
    }


    if (lpContext->fLlsLicense)
    {
        NtLSFreeHandle(lpContext->hLlsLicense);
    }

    RtlDeleteCriticalSection(&(lpContext->CritSec));

#if DBG
    RtlFillMemory(lpContext, sizeof(LCCONTEXT), (BYTE)0xFE);
#endif

    LocalFree(lpContext);

    pWinStation->lpLicenseContext = (LPARAM)NULL;

exit:
    TRACEPRINT((LCTRACETYPE_API, "LCDestroyContext: Session: %d, Returning", pWinStation->LogonId));
}

extern "C"
NTSTATUS
LCGetAvailablePolicyIds(
    PULONG *ppulPolicyIds,
    PULONG pcPolicies
    )
{
    NTSTATUS Status;

    TRACEPRINT((LCTRACETYPE_API, "LCGetAvailablePolicyIds: Entered with ppulPolicyIds: 0x%p, pcPolicies: 0x%p", ppulPolicyIds, pcPolicies));
    ASSERT(ppulPolicyIds != NULL);
    ASSERT(pcPolicies != NULL);

    RtlEnterCriticalSection(&g_PolicyCritSec);

    Status = PolicyListEnumerateIds(ppulPolicyIds, pcPolicies);

    RtlLeaveCriticalSection(&g_PolicyCritSec);

    TRACEPRINT((LCTRACETYPE_API, "LCGetAvailablePolicyIds: Returning 0x%x", Status));

    return(Status);
}

extern "C"
ULONG
LCGetPolicy(
    VOID
    )
{
    ULONG ulPolicyId;

    TRACEPRINT((LCTRACETYPE_API, "LCGetPolicy: Entered"));
    ASSERT(g_pCurrentPolicy != NULL);

    RtlEnterCriticalSection(&g_PolicyCritSec);

    ulPolicyId = g_pCurrentPolicy->GetId();

    RtlLeaveCriticalSection(&g_PolicyCritSec);

    TRACEPRINT((LCTRACETYPE_API, "LCGetPolicy: Returning %d", ulPolicyId));

    return(ulPolicyId);
}

extern "C"
NTSTATUS
LCGetPolicyInformation(
    ULONG ulPolicyId,
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    )
{
    CPolicy *pPolicy;
    NTSTATUS Status;

    TRACEPRINT((LCTRACETYPE_API, "LCGetPolicyInformation: Entered with ulPolicyId: %d, lpPolicyInfo: 0x%p", ulPolicyId, lpPolicyInfo));
    ASSERT(lpPolicyInfo != NULL);

    RtlEnterCriticalSection(&g_PolicyCritSec);

    pPolicy = PolicyListFindById(ulPolicyId);

    if (pPolicy != NULL)
    {
        Status = pPolicy->GetInformation(lpPolicyInfo);
    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
    }

    RtlLeaveCriticalSection(&g_PolicyCritSec);

    TRACEPRINT((LCTRACETYPE_API, "LCGetPolicyInformation: Returning 0x%x", Status));

    return(Status);
}

/*
 *  Licensing Event Function Implementations
 */

extern "C"
NTSTATUS
LCProcessConnectionProtocol(
    PWINSTATION pWinStation
    )
{
    CSession Session(pWinStation);
    LICENSE_CAPABILITIES lcCap;
    LICENSE_STATUS LsStatus;
    LPLCCONTEXT lpContext;
    NTSTATUS Status;
    ULONG cbReturned;
    WCHAR szClientName[CLIENTNAME_LENGTH + 1];
    UINT32 dwClientError;

    ASSERT(pWinStation != NULL);

    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionProtocol: Entered with Session: %d", pWinStation->LogonId));
    TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionProtocol: Session: %d, Current Policy ID: 0x%x", pWinStation->LogonId, g_pCurrentPolicy->GetId()));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    ASSERT(lpContext != NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionProtocol: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    RtlEnterCriticalSection(&(lpContext->CritSec));

    //
    //  Get the client capabilities.
    //

    ZeroMemory(&lcCap, sizeof(LICENSE_CAPABILITIES));
    lcCap.pbClientName = (LPBYTE)szClientName;
    lcCap.cbClientName = sizeof(szClientName);

    Status = _IcaStackIoControl(
        pWinStation->hStack,
        IOCTL_ICA_STACK_QUERY_LICENSE_CAPABILITIES,
        NULL,
        0,
        &lcCap,
        sizeof(LICENSE_CAPABILITIES),
        &cbReturned
        );

    if (Status == STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionProtocol: Session: %d, Queried license capabilities", pWinStation->LogonId));

        //
        //  Save the protocol version for later use.
        //

        lpContext->ulClientProtocolVersion = lcCap.ProtocolVer;
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionProtocol: Session: %d, Failed to query license capabilities: 0x%x", pWinStation->LogonId, Status));

        dwClientError = NtStatusToClientError(Status);

        goto error;
    }

    //
    //  Create the protocol library context.
    //

    LsStatus = CreateProtocolContext(&lcCap, &(lpContext->hProtocolLibContext));

    if (LsStatus == LICENSE_STATUS_OK)
    {
        TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionProtocol: Session: %d, Created protocol context", pWinStation->LogonId));

        //
        //  Pass the call to the policy assigned to the connection.
        //

        Status = lpContext->pPolicy->Connect(Session, dwClientError);
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionProtocol: Session: %d, Failed to CreateProtocolContext: 0x%x", pWinStation->LogonId, LsStatus));

        dwClientError = LsStatusToClientError(LsStatus);

        Status = LsStatusToNtStatus(LsStatus);
    }

#if DBG
    if (Status == STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionProtocol: Session: %d, Succeeded pPolicy->Protocol", pWinStation->LogonId));
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionProtocol: Session: %d, Failed pPolicy->Protocol: 0x%x", pWinStation->LogonId, Status));
    }
#endif

error:
    RtlLeaveCriticalSection(&(lpContext->CritSec));

    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionProtocol: Session: %d, Reporting: 0x%x", pWinStation->LogonId, dwClientError));

        Session.SetErrorInfo(dwClientError);

    }

    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionProtocol: Session: %d, Returning: 0x%x", pWinStation->LogonId, Status));

    return(Status);
}

extern "C"
NTSTATUS
LCProcessConnectionPostLogon(
    PWINSTATION pWinStation
    )
{
    CSession Session(pWinStation);
    LPLCCONTEXT lpContext;
    NTSTATUS Status;

    ASSERT(pWinStation != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionPostLogon: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    ASSERT(lpContext != NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionPostLogon: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    RtlEnterCriticalSection(&(lpContext->CritSec));

    //
    //  Pass the call to the policy assigned to the connection.
    //

    Status = lpContext->pPolicy->Logon(Session);

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionPostLogon: Session: %d, Failed to pPolicy->Logon: 0x%x", pWinStation->LogonId, Status));
    }

#endif

    RtlLeaveCriticalSection(&(lpContext->CritSec));

    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionPostLogon: Session: %d, Returning: 0x%x", pWinStation->LogonId, Status));

    return(Status);
}

extern "C"
NTSTATUS
LCProcessConnectionDisconnect(
    PWINSTATION pWinStation
    )
{
    CSession Session(pWinStation);
    LPLCCONTEXT lpContext;
    NTSTATUS Status;

    ASSERT(pWinStation != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionDisconnect: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    //
    //  Console licensing is not yet supported.
    //

    ASSERT(lpContext != NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionDisconnect: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    RtlEnterCriticalSection(&(lpContext->CritSec));

    //
    //  Pass the call to the policy assigned to the connection.
    //

    Status = lpContext->pPolicy->Disconnect(Session);

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionDisconnect: Session: %d, Failed to pPolicy->Disconnect: 0x%x", pWinStation->LogonId, Status));
    }

#endif

    RtlLeaveCriticalSection(&(lpContext->CritSec));

    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionDisconnect: Session: %d, Returning: 0x%x", pWinStation->LogonId, Status));

    return(Status);
}

extern "C"
NTSTATUS
LCProcessConnectionReconnect(
    PWINSTATION pWinStation,
    PWINSTATION pTemporaryWinStation
    )
{
    CSession Session(pWinStation);
    CSession TemporarySession(pTemporaryWinStation);
    LPLCCONTEXT lpContext;
    NTSTATUS Status;

    ASSERT(pWinStation != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionReconnect: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    ASSERT(lpContext != NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionReconnect: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    RtlEnterCriticalSection(&(lpContext->CritSec));

    //
    //  Pass the call to the policy assigned to the connection.
    //

    Status = lpContext->pPolicy->Reconnect(Session, TemporarySession);

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionReconnect: Session: %d, Failed to pPolicy->Reconnect: 0x%x", pWinStation->LogonId, Status));
    }

#endif

    RtlLeaveCriticalSection(&(lpContext->CritSec));

    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionReconnect: Session: %d, Returning: 0x%x", pWinStation->LogonId, Status));

    return(Status);
}

extern "C"
NTSTATUS
LCProcessConnectionLogoff(
    PWINSTATION pWinStation
    )
{
    CSession Session(pWinStation);
    LPLCCONTEXT lpContext;
    NTSTATUS Status;

    ASSERT(pWinStation != NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionLogoff: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    ASSERT(lpContext != NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCProcessConnectionLogoff: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    RtlEnterCriticalSection(&(lpContext->CritSec));

    //
    //  Pass the call to the policy assigned to the connection.
    //

    Status = lpContext->pPolicy->Logoff(Session);

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProcessConnectionLogoff: Session: %d, Failed to pPolicy->Reconnect: 0x%x", pWinStation->LogonId, Status));
    }

#endif

    RtlLeaveCriticalSection(&(lpContext->CritSec));

    TRACEPRINT((LCTRACETYPE_API, "LCProcessConnectionLogoff: Session: %d, Returning: 0x%x", pWinStation->LogonId, Status));

    return(Status);
}

extern "C"
NTSTATUS
LCProvideAutoLogonCredentials(
    PWINSTATION pWinStation,
    LPBOOL lpfUseCredentials,
    LPLCCREDENTIALS lpCredentials
    )
{
    CSession Session(pWinStation);
    LPLCCONTEXT lpContext;
    NTSTATUS Status;

    ASSERT(pWinStation != NULL);
    ASSERT(lpfUseCredentials != NULL);
    ASSERT(lpCredentials != NULL);
    ASSERT(lpCredentials->pUserName == NULL);
    ASSERT(lpCredentials->pDomain == NULL);
    ASSERT(lpCredentials->pPassword == NULL);
    TRACEPRINT((LCTRACETYPE_API, "LCProvideAutoLogonCredentials: Entered with Session: %d", pWinStation->LogonId));

    lpContext = (LPLCCONTEXT)(pWinStation->lpLicenseContext);

    ASSERT(lpContext != NULL);
    TRACEPRINT((LCTRACETYPE_INFO, "LCProvideAutoLogonCredentials: Session: %d, lpContext: 0x%p", pWinStation->LogonId, lpContext));

    RtlEnterCriticalSection(&(lpContext->CritSec));

    //
    //  Pass the call to the policy assigned to the connection.
    //

    Status = lpContext->pPolicy->AutoLogon(Session, lpfUseCredentials, lpCredentials);

#if DBG
    if (Status != STATUS_SUCCESS)
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "LCProvideAutoLogonCredentials: Session: %d, Failed to pPolicy->AutoLogon: 0x%x", pWinStation->LogonId, Status));
    }
#endif

    RtlLeaveCriticalSection(&(lpContext->CritSec));

    TRACEPRINT((LCTRACETYPE_API, "LCProvideAutoLogonCredentials: Session: %d, Returning: 0x%x", pWinStation->LogonId, Status));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\lscorep.cpp ===
/*
 *  LSCoreP.cpp
 *
 *  Author: BreenH
 *
 *  Internal functions for the core.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "lscorep.h"
#include "lcreg.h"
#include "lctrace.h"
#include "session.h"
#include "policy.h"
#include "pollist.h"
#include "concurrent.h"
#include "perseat.h"
#include "pts.h"
#include "ra.h"
#include <icaevent.h>

/*
 *  Internal Function Prototypes
 */

ULONG
InitializeBuiltinPolicies(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    );

ULONG
InitializeExternalPolicies(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    );

/*
 *  Function Implementations
 */

NTSTATUS
AllocatePolicyInformation(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo,
    ULONG ulVersion
    )
{
    NTSTATUS Status;

    ASSERT(ppPolicyInfo != NULL);

    if (ulVersion == LCPOLICYINFOTYPE_V1)
    {
        *ppPolicyInfo = (LPLCPOLICYINFOGENERIC)LocalAlloc(LPTR, sizeof(LCPOLICYINFO_V1));

        if (*ppPolicyInfo != NULL)
        {
            (*ppPolicyInfo)->ulVersion = LCPOLICYINFOTYPE_V1;
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }
    else
    {
        Status = STATUS_REVISION_MISMATCH;
    }

    return(Status);
}

VOID
FreePolicyInformation(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    )
{
    ASSERT(ppPolicyInfo != NULL);
    ASSERT(*ppPolicyInfo != NULL);
    ASSERT((*ppPolicyInfo)->ulVersion <= LCPOLICYINFOTYPE_CURRENT);

    if ((*ppPolicyInfo)->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        LPLCPOLICYINFO_V1 pPolicyInfoV1 = (LPLCPOLICYINFO_V1)(*ppPolicyInfo);

        ASSERT(pPolicyInfoV1->lpPolicyName != NULL);
        ASSERT(pPolicyInfoV1->lpPolicyDescription != NULL);

        LocalFree(pPolicyInfoV1->lpPolicyName);
        LocalFree(pPolicyInfoV1->lpPolicyDescription);
        LocalFree(pPolicyInfoV1);
        *ppPolicyInfo = NULL;
    }
}

ULONG
GetHardcodedPolicyId(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    )
{
    //
    //  WARNING: HARDCODED VALUES:
    //
    //  This function will return the ID of the default policy to activate upon
    //  system boot. It will return the ID for Remote Admin or Per Seat based
    //  on fAppCompat, or PTS, based on lcInitMode. Theoretically, the core
    //  should not know these ID values, but it is necessary in this case.
    //

    return(lcInitMode == LC_INIT_LIMITED ? 0 : (fAppCompat ? 2 : 1));
}

ULONG
GetInitialPolicy(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    )
{
    ULONG ulPolicyId;

    if (lcInitMode == LC_INIT_ALL)
    {
        DWORD cbSize;
        DWORD dwStatus;
        DWORD dwType;

        cbSize = sizeof(ULONG);

        //
        //  Query the value for the current App Compat mode.
        //

        dwStatus = RegQueryValueEx(
            GetBaseKey(),
            fAppCompat ? LCREG_ACONMODE : LCREG_ACOFFMODE,
            NULL,
            &dwType,
            (LPBYTE)&ulPolicyId,
            &cbSize
            );

        //
        //  Make sure that the data type is good.
        //

        if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD))
        {
            BOOL fLimitedInit;
            BOOL fRequireAC;
            CPolicy *pPolicy;

            //
            // Internet Connector is no longer supported; switch to Concurrent
            //
            if (3 == ulPolicyId)
            {
                ulPolicyId = 4;

                SetInitialPolicy(ulPolicyId,fAppCompat);

                LicenseLogEvent(EVENTLOG_ERROR_TYPE,
                                EVENT_LICENSING_IC_TO_CONCURRENT,
                                0,
                                NULL );
            }

            //
            //  Make sure that the policy specified actually exists, and
            //  that it matches the settings.
            //

            pPolicy = PolicyListFindById(ulPolicyId);

            if (NULL != pPolicy)
            {
                fLimitedInit = pPolicy->GetFlags() & LC_FLAG_LIMITED_INIT_ONLY;
                fRequireAC = pPolicy->GetFlags() & LC_FLAG_REQUIRE_APP_COMPAT;

                if (!fLimitedInit)
                {
                    if ((fRequireAC && fAppCompat) || (!fRequireAC && !fAppCompat))
                    {
                        goto exit;
                    }
                }
            }
        }
    }

    //
    //  For LC_INIT_LIMITED or for failure from above, get the hardcoded
    //  value.
    //

    ulPolicyId = GetHardcodedPolicyId(lcInitMode, fAppCompat);

exit:
    return(ulPolicyId);
}

NTSTATUS
InitializePolicies(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    )
{
    ULONG cLoadedPolicies;

    cLoadedPolicies = InitializeBuiltinPolicies(lcInitMode, fAppCompat);
    cLoadedPolicies += InitializeExternalPolicies(lcInitMode, fAppCompat);

    return(cLoadedPolicies > 0 ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}

NTSTATUS
SetInitialPolicy(
    ULONG ulPolicyId,
    BOOL fAppCompat
    )
{
    DWORD cbSize;
    DWORD dwStatus;

    //
    //  Set the value based on the app compat mode.
    //

    cbSize = sizeof(ULONG);

    dwStatus = RegSetValueEx(
        GetBaseKey(),
        fAppCompat ? LCREG_ACONMODE : LCREG_ACOFFMODE,
        NULL,
        REG_DWORD,
        (LPBYTE)&ulPolicyId,
        cbSize
        );

    return(dwStatus == ERROR_SUCCESS ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}

VOID
ShutdownPolicies(
    )
{
    CPolicy *pPolicy;

    while ((pPolicy = PolicyListPop()) != NULL)
    {
        pPolicy->CoreUnload();

        delete pPolicy;
    }
}

/*
 *  Internal Function Implementations
 */

ULONG
InitializeBuiltinPolicies(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    )
{
    CPolicy *ppPolicy[3];
    NTSTATUS Status;
    ULONG cLoadedPolicies = 0;
    ULONG cPolicyArray;
    ULONG i;

    cPolicyArray = (lcInitMode == LC_INIT_LIMITED ? 1 : (fAppCompat ? 2 : 1));

    //
    //  WARNING: HARDCODED POLICY NAMES (and flags, as this will
    //  only load policies that will work in the current environment, even
    //  though the core shouldn't know this)
    //

    if (lcInitMode == LC_INIT_ALL)
    {
        if (fAppCompat)
        {
            ppPolicy[0] = new CPerSeatPolicy();
            ppPolicy[1] = new CConcurrentPolicy();
        }
        else
        {
            ppPolicy[0] = new CRAPolicy();
        }
    }
    else
    {
        ppPolicy[0] = new CPtsPolicy();
    }

    for (i = 0; i < cPolicyArray; i++)
    {
        if (ppPolicy[i] != NULL)
        {
            Status = ppPolicy[i]->CoreLoad(LC_VERSION_CURRENT);

            if (Status == STATUS_SUCCESS)
            {
                Status = PolicyListAdd(ppPolicy[i]);

                if (Status == STATUS_SUCCESS)
                {
                    cLoadedPolicies++;
                    continue;
                }
            }

            delete ppPolicy[i];
            ppPolicy[i] = NULL;
        }
    }

    return(cLoadedPolicies);
}

ULONG
InitializeExternalPolicies(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    )
{
    DBG_UNREFERENCED_PARAMETER(lcInitMode);
    DBG_UNREFERENCED_PARAMETER(fAppCompat);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\lscore.h ===
/*
 *  LSCore.h
 *
 *  Author: BreenH
 *
 *  API for the licensing core.
 */

#ifndef __LC_LSCORE_H__
#define __LC_LSCORE_H__

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  Typedefs
 */

typedef enum {
    LC_INIT_LIMITED = 0,
    LC_INIT_ALL
} LCINITMODE, *LPLCINITMODE;

typedef struct {
    LPWSTR pUserName;
    LPWSTR pDomain;
    LPWSTR pPassword;
} LCCREDENTIALS, *LPLCCREDENTIALS;

/*
 *  Initialization Function Prototypes
 */

NTSTATUS
LCInitialize(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    );

VOID
LCShutdown(
    );

/*
 *  Policy Loading and Activation Function Prototypes
 */

NTSTATUS
LCLoadPolicy(
    ULONG ulPolicyId
    );

NTSTATUS
LCUnloadPolicy(
    ULONG ulPolicyId
    );

NTSTATUS
LCSetPolicy(
    ULONG ulPolicyId,
    PNTSTATUS pNewPolicyStatus
    );

/*
 *  Administrative Function Prototypes
 */

VOID
LCAssignPolicy(
    PWINSTATION pWinStation
    );

NTSTATUS
LCCreateContext(
    PWINSTATION pWinStation
    );

VOID
LCDestroyContext(
    PWINSTATION pWinStation
    );

NTSTATUS
LCGetAvailablePolicyIds(
    PULONG *ppulPolicyIds,
    PULONG pcPolicies
    );

ULONG
LCGetPolicy(
    VOID
    );

NTSTATUS
LCGetPolicyInformation(
    ULONG ulPolicyId,
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    );

/*
 *  Licensing Event Function Prototypes
 */

NTSTATUS
LCProcessConnectionProtocol(
    PWINSTATION pWinStation
    );

NTSTATUS
LCProcessConnectionPostLogon(
    PWINSTATION pWinStation
    );

NTSTATUS
LCProcessConnectionDisconnect(
    PWINSTATION pWinStation
    );

NTSTATUS
LCProcessConnectionReconnect(
    PWINSTATION pWinStation,
    PWINSTATION pTemporaryWinStation
    );

NTSTATUS
LCProcessConnectionLogoff(
    PWINSTATION pWinStation
    );

NTSTATUS
LCProvideAutoLogonCredentials(
    PWINSTATION pWinStation,
    LPBOOL lpfUseCredentials,
    LPLCCREDENTIALS lpCredentials
    );

NTSTATUS
LCDeactivateCurrentPolicy(
    );

#ifdef __cplusplus
}   // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\lscorep.h ===
/*
 *  LSCoreP.h
 *
 *  Author: BreenH
 *
 *  Internal functions for the core.
 */

#ifndef __LC_LSCOREP_H__
#define __LC_LSCOREP_H__

/*
 *  Function Prototypes
 */

NTSTATUS
AllocatePolicyInformation(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo,
    ULONG ulVersion
    );

VOID
FreePolicyInformation(
    LPLCPOLICYINFOGENERIC *ppPolicyInfo
    );

ULONG
GetHardcodedPolicyId(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    );

ULONG
GetInitialPolicy(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    );

NTSTATUS
InitializePolicies(
    LCINITMODE lcInitMode,
    BOOL fAppCompat
    );

NTSTATUS
SetInitialPolicy(
    ULONG ulPolicyId,
    BOOL fAppCompat
    );

VOID
ShutdownPolicies(
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\perseat.cpp ===
/*
 *  PerSeat.cpp
 *
 *  Author: BreenH
 *
 *  The Per-Seat licensing policy.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "perseat.h"
#include "lctrace.h"
#include "util.h"

#define ISSUE_LICENSE_WARNING_PERIOD    15      // days to expiration when warning should be issued

// Size of strings to be displayed to user
#define MAX_MESSAGE_SIZE    512
#define MAX_TITLE_SIZE      256

/*
 *  extern globals
 */
extern "C"
extern HANDLE hModuleWin;

/*
 *  Class Implementation
 */

/*
 *  Creation Functions
 */

CPerSeatPolicy::CPerSeatPolicy(
    ) : CPolicy()
{
}

CPerSeatPolicy::~CPerSeatPolicy(
    )
{
}

/*
 *  Administrative Functions
 */

ULONG
CPerSeatPolicy::GetFlags(
    )
{
    return(LC_FLAG_INTERNAL_POLICY | LC_FLAG_REQUIRE_APP_COMPAT);
}

ULONG
CPerSeatPolicy::GetId(
    )
{
    return(2);
}

NTSTATUS
CPerSeatPolicy::GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    )
{
    NTSTATUS Status;

    ASSERT(lpPolicyInfo != NULL);

    if (lpPolicyInfo->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        int retVal;
        LPLCPOLICYINFO_V1 lpPolicyInfoV1 = (LPLCPOLICYINFO_V1)lpPolicyInfo;
        LPWSTR pName;
        LPWSTR pDescription;

        ASSERT(lpPolicyInfoV1->lpPolicyName == NULL);
        ASSERT(lpPolicyInfoV1->lpPolicyDescription == NULL);

        //
        //  The strings loaded in this fashion are READ-ONLY. They are also
        //  NOT NULL terminated. Allocate and zero out a buffer, then copy the
        //  string over.
        //

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_PERSEAT_NAME,
            (LPWSTR)(&pName),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyName = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyName != NULL)
            {
                lstrcpynW(lpPolicyInfoV1->lpPolicyName, pName, retVal + 1);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_PERSEAT_DESC,
            (LPWSTR)(&pDescription),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyDescription = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyDescription != NULL)
            {
                lstrcpynW(lpPolicyInfoV1->lpPolicyDescription, pDescription, retVal + 1);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        Status = STATUS_SUCCESS;
        goto exit;

V1error:

        //
        //  An error occurred loading/copying the strings.
        //

        if (lpPolicyInfoV1->lpPolicyName != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyName);
            lpPolicyInfoV1->lpPolicyName = NULL;
        }

        if (lpPolicyInfoV1->lpPolicyDescription != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyDescription);
            lpPolicyInfoV1->lpPolicyDescription = NULL;
        }
    }
    else
    {
        Status = STATUS_REVISION_MISMATCH;
    }

exit:
    return(Status);
}

/*
 *  Loading and Activation Functions
 */

NTSTATUS
CPerSeatPolicy::Activate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    )
{
    UNREFERENCED_PARAMETER(fStartup);

    if (NULL != pulAlternatePolicy)
    {
        // don't set an explicit alternate policy

        *pulAlternatePolicy = ULONG_MAX;
    }

    return(StartCheckingGracePeriod());
}

NTSTATUS
CPerSeatPolicy::Deactivate(
    BOOL fShutdown
    )
{
    if (!fShutdown)
    {
        return(StopCheckingGracePeriod());
    }
    else
    {
        return STATUS_SUCCESS;
    }
}

/*
 *  Licensing Functions
 */

NTSTATUS
CPerSeatPolicy::Connect(
    CSession& Session,
    UINT32 &dwClientError
    )
{
    LICENSE_STATUS LsStatus = LICENSE_STATUS_OK;
    LPBYTE lpReplyBuffer;
    LPBYTE lpRequestBuffer;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG cbReplyBuffer;
    ULONG cbRequestBuffer;
    ULONG cbReturned;

    //
    // Check for client redirected to session 0
    //

    if (Session.IsSessionZero())
    {
        // Allow client to connect unlicensed

        return CPolicy::Connect(Session,dwClientError);
    }

    lpRequestBuffer = NULL;
    lpReplyBuffer = (LPBYTE)LocalAlloc(LPTR, LC_POLICY_PS_DEFAULT_LICENSE_SIZE);

    if (lpReplyBuffer != NULL)
    {
        cbReplyBuffer = LC_POLICY_PS_DEFAULT_LICENSE_SIZE;
    }
    else
    {
        Status = STATUS_NO_MEMORY;
        goto errorexit;
    }

    LsStatus = AcceptProtocolContext(
        Session.GetLicenseContext()->hProtocolLibContext,
        0,
        NULL,
        &cbRequestBuffer,
        &lpRequestBuffer
        );

    while(LsStatus == LICENSE_STATUS_CONTINUE)
    {
        cbReturned = 0;

        ASSERT(cbRequestBuffer > 0);

        Status = _IcaStackIoControl(
            Session.GetIcaStack(),
            IOCTL_ICA_STACK_REQUEST_CLIENT_LICENSE,
            lpRequestBuffer,
            cbRequestBuffer,
            lpReplyBuffer,
            cbReplyBuffer,
            &cbReturned
            );

        if (Status != STATUS_SUCCESS)
        {
            if (Status == STATUS_BUFFER_TOO_SMALL)
            {
                TRACEPRINT((LCTRACETYPE_WARNING, "CPerSeatPolicy::Connect: Reallocating license buffer: %lu, %lu", cbReplyBuffer, cbReturned));

                LocalFree(lpReplyBuffer);
                lpReplyBuffer = (LPBYTE)LocalAlloc(LPTR, cbReturned);

                if (lpReplyBuffer != NULL)
                {
                    cbReplyBuffer = cbReturned;
                }
                else
                {
                    Status = STATUS_NO_MEMORY;
                    goto errorexit;
                }

                Status = _IcaStackIoControl(
                    Session.GetIcaStack(),
                    IOCTL_ICA_STACK_GET_LICENSE_DATA,
                    NULL,
                    0,
                    lpReplyBuffer,
                    cbReplyBuffer,
                    &cbReturned
                    );

                if (Status != STATUS_SUCCESS)
                {
                    goto errorexit;
                }
            }
            else
            {
                goto errorexit;
            }
        }

        if (cbReturned != 0)
        {
            if (lpRequestBuffer != NULL)
            {
                LocalFree(lpRequestBuffer);
                lpRequestBuffer = NULL;
                cbRequestBuffer = 0;
            }

            LsStatus = AcceptProtocolContext(
                Session.GetLicenseContext()->hProtocolLibContext,
                cbReturned,
                lpReplyBuffer,
                &cbRequestBuffer,
                &lpRequestBuffer
                );
        }
    }

    cbReturned = 0;

    if ((LsStatus == LICENSE_STATUS_ISSUED_LICENSE) || (LsStatus == LICENSE_STATUS_OK))
    {
        Status = _IcaStackIoControl(
            Session.GetIcaStack(),
            IOCTL_ICA_STACK_SEND_CLIENT_LICENSE,
            lpRequestBuffer,
            cbRequestBuffer,
            NULL,
            0,
            &cbReturned
            );

        if (Status == STATUS_SUCCESS)
        {
            ULONG ulLicenseResult;

            ulLicenseResult = LICENSE_PROTOCOL_SUCCESS;

            Status = _IcaStackIoControl(
                Session.GetIcaStack(),
                IOCTL_ICA_STACK_LICENSE_PROTOCOL_COMPLETE,
                &ulLicenseResult,
                sizeof(ULONG),
                NULL,
                0,
                &cbReturned
                );
        }
    }
    else if (LsStatus != LICENSE_STATUS_SERVER_ABORT)
    {
        DWORD dwClientResponse;
        LICENSE_STATUS LsStatusT;

        if (AllowLicensingGracePeriodConnection())
        {
            dwClientResponse = LICENSE_RESPONSE_VALID_CLIENT;
        }
        else
        {
            dwClientResponse = LICENSE_RESPONSE_INVALID_CLIENT;
        }

        if (lpRequestBuffer != NULL)
        {
            LocalFree(lpRequestBuffer);
            lpRequestBuffer = NULL;
            cbRequestBuffer = 0;
        }

        LsStatusT = ConstructProtocolResponse(
            Session.GetLicenseContext()->hProtocolLibContext,
            dwClientResponse,
            &cbRequestBuffer,
            &lpRequestBuffer
            );

        if (LsStatusT == LICENSE_STATUS_OK)
        {
            Status = _IcaStackIoControl(
                Session.GetIcaStack(),
                IOCTL_ICA_STACK_SEND_CLIENT_LICENSE,
                lpRequestBuffer,
                cbRequestBuffer,
                NULL,
                0,
                &cbReturned
                );
        }
        else
        {
            Status = STATUS_CTX_LICENSE_CLIENT_INVALID;
            goto errorexit;
        }

        if (Status == STATUS_SUCCESS)
        {
            if (dwClientResponse == LICENSE_RESPONSE_VALID_CLIENT)
            {
                ULONG ulLicenseResult;

                //
                //  Grace period allowed client to connect
                //  Tell the stack that the licensing protocol has completed
                //

                ulLicenseResult = LICENSE_PROTOCOL_SUCCESS;

                Status = _IcaStackIoControl(
                     Session.GetIcaStack(),
                     IOCTL_ICA_STACK_LICENSE_PROTOCOL_COMPLETE,
                     &ulLicenseResult,
                     sizeof(ULONG),
                     NULL,
                     0,
                     &cbReturned
                     );            
            }
            else
            {
                //
                //  If all IO works correctly, adjust the status to reflect
                //  that the connection attempt is failing.
                //

                Status = STATUS_CTX_LICENSE_CLIENT_INVALID;
            }
        }
    }
    else
    {
        TRACEPRINT((LCTRACETYPE_ERROR, "Connect: LsStatus: %d", LsStatus));
        Status = STATUS_CTX_LICENSE_CLIENT_INVALID;
    }

errorexit:
    if (Status != STATUS_SUCCESS)
    {
        if (LsStatus != LICENSE_STATUS_OK)
        {
            dwClientError = LsStatusToClientError(LsStatus);
        }
        else
        {
            dwClientError = NtStatusToClientError(Status);
        }
    }

    if (lpRequestBuffer != NULL)
    {
        LocalFree(lpRequestBuffer);
    }

    if (lpReplyBuffer != NULL)
    {
        LocalFree(lpReplyBuffer);
    }

    return(Status);
}

NTSTATUS
CPerSeatPolicy::MarkLicense(
    CSession& Session
    )
{
    LICENSE_STATUS Status;

    Status = MarkLicenseFlags(
                   Session.GetLicenseContext()->hProtocolLibContext,
                   MARK_FLAG_USER_AUTHENTICATED);

    return (Status == LICENSE_STATUS_OK
            ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}

NTSTATUS
CPerSeatPolicy::Logon(
    CSession& Session
    )
{
    NTSTATUS Status;
    PTCHAR
        ptszMsgText = NULL, 
        ptszMsgTitle = NULL; 


    if (Session.GetLogonId() != 0)
    {
        Status = GetLlsLicense(Session);
    }
    else
    {
        Status = STATUS_SUCCESS;
        goto done;
    }

    if (Status != STATUS_SUCCESS)
    {
        // TODO: put up new error message - can't logon
        // also useful when we do post-logon licensing
        //
        // NB: eventually this should be done through client-side
        // error reporting
    }
    else
    {
        ULONG_PTR
            dwDaysLeftPtr;
        DWORD
            dwDaysLeft,
            cchMsgText;
        BOOL
            fTemporary;
        LICENSE_STATUS
            LsStatus;
        int
            ret,
            cchMsgTitle;
        WINSTATION_APIMSG
            WMsg;

        //
        // Allocate memory
        //
        ptszMsgText = (PTCHAR) LocalAlloc(LPTR, MAX_MESSAGE_SIZE * sizeof(TCHAR));
        if (NULL == ptszMsgText) {
            Status = STATUS_NO_MEMORY;
            goto done;
        }

        ptszMsgTitle = (PTCHAR) LocalAlloc(LPTR, MAX_TITLE_SIZE * sizeof(TCHAR));
        if (NULL == ptszMsgTitle) {
            Status = STATUS_NO_MEMORY;
            goto done;
        }

        ptszMsgText[0] = L'\0'; 
        ptszMsgTitle[0] = L'\0';
        
        //
        // check whether to give an expiration warning
        //

        LsStatus = DaysToExpiration(
                Session.GetLicenseContext()->hProtocolLibContext,
                &dwDaysLeft, &fTemporary);

        if ((LICENSE_STATUS_OK != LsStatus) || (!fTemporary))
        {
            goto done;
        }

        if ((dwDaysLeft == 0xFFFFFFFF) ||
            (dwDaysLeft > ISSUE_LICENSE_WARNING_PERIOD))
        {
            goto done;
        }

        //
        // Display an expiration warning
        //

        cchMsgTitle = LoadString((HINSTANCE)hModuleWin,
                                 STR_TEMP_LICENSE_MSG_TITLE,
                                 ptszMsgTitle, MAX_TITLE_SIZE );

        if (0 == cchMsgTitle)
        {
            goto done;
        }

        ret = LoadString((HINSTANCE)hModuleWin,
                         STR_TEMP_LICENSE_EXPIRATION_MSG,
                         ptszMsgText, MAX_MESSAGE_SIZE );


        if (0 == ret)
        {
            goto done;
        }

        dwDaysLeftPtr = dwDaysLeft;
        cchMsgText = FormatMessage(FORMAT_MESSAGE_FROM_STRING
                                   | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   ptszMsgText,
                                   0,
                                   0,
                                   ptszMsgText,
                                   MAX_MESSAGE_SIZE,
                                   (va_list * )&dwDaysLeftPtr );

        if (0 == cchMsgText)
        {
            goto done;
        }

        WMsg.u.SendMessage.pTitle = ptszMsgTitle;
        WMsg.u.SendMessage.TitleLength = (cchMsgTitle + 1) * sizeof(TCHAR);
        WMsg.u.SendMessage.pMessage = ptszMsgText;
        WMsg.u.SendMessage.MessageLength = (cchMsgText + 1) * sizeof(TCHAR);

        WMsg.u.SendMessage.Style = MB_OK;
        WMsg.u.SendMessage.Timeout = 60;
        WMsg.u.SendMessage.DoNotWait = TRUE;
        WMsg.u.SendMessage.pResponse = NULL;

        WMsg.ApiNumber = SMWinStationDoMessage;

        Session.SendWinStationCommand( &WMsg );

    }

done:
    if (Session.GetLicenseContext()->hProtocolLibContext != NULL)
    {
        //
        // Mark the license to show user has logged on
        //

        MarkLicense(Session);
    }

    if (ptszMsgText != NULL) {
        LocalFree(ptszMsgText);
        ptszMsgText = NULL;
    }

    if (ptszMsgTitle != NULL) {
        LocalFree(ptszMsgTitle);
        ptszMsgTitle = NULL;
    }

    return(Status);
}

NTSTATUS
CPerSeatPolicy::Reconnect(
    CSession& Session,
    CSession& TemporarySession
    )
{
    UNREFERENCED_PARAMETER(Session);

    if (TemporarySession.GetLicenseContext()->hProtocolLibContext != NULL)
    {
        //
        // Mark the license to show user has logged on
        //

        MarkLicense(TemporarySession);
    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\perseat.h ===
/*
 *  PerSeat.h
 *
 *  Author: BreenH
 *
 *  The Per-Seat licensing policy.
 */

#ifndef __LC_PERSEAT_H__
#define __LC_PERSEAT_H__

/*
 *  Includes
 */

#include "policy.h"

/*
 *  Constants
 */

#define LC_POLICY_PS_DEFAULT_LICENSE_SIZE 8192

/*
 *  Class Definition
 */

class CPerSeatPolicy : public CPolicy
{
private:

/*
 *  Licensing Functions
 */
NTSTATUS
MarkLicense(
    CSession& Session
    );

public:

/*
 *  Creation Functions
 */

CPerSeatPolicy(
    );

~CPerSeatPolicy(
    );

/*
 *  Administrative Functions
 */

ULONG
GetFlags(
    );

ULONG
GetId(
    );

NTSTATUS
GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    );

/*
 *  Loading and Activation Functions
 */

NTSTATUS
Activate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    );

NTSTATUS
Deactivate(
    BOOL fShutdown
    );

/*
 *  Licensing Functions
 */

NTSTATUS
Connect(
    CSession& pSession,
    UINT32 &dwClientError
    );

NTSTATUS
Logon(
    CSession& Session
    );


NTSTATUS
Reconnect(
    CSession& Session,
    CSession& TemporarySession
    );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\pollist.h ===
/*
 *  PolRef.h
 *
 *  Author: BreenH
 *
 *  Private header for the policy reference list.
 */

#ifndef __POLLIST_H__
#define __POLLIST_H__

/*
 *  Typedefs
 */

typedef struct {
    LIST_ENTRY ListEntry;
    CPolicy *pPolicy;
} LCPOLICYREF, *LPLCPOLICYREF;

/*
 *  Function Prototypes
 */

NTSTATUS
PolicyListAdd(
    CPolicy *pPolicy
    );

VOID
PolicyListDelete(
    ULONG ulPolicyId
    );

NTSTATUS
PolicyListEnumerateIds(
    PULONG *ppulPolicyIds,
    PULONG pcPolicies
    );

CPolicy *
PolicyListFindById(
    ULONG ulPolicyId
    );

CPolicy *
PolicyListPop(
    VOID
    );

NTSTATUS
PolicyListInitialize(
    VOID
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\pollist.cpp ===
/*
 *  PolRef.cpp
 *
 *  Author: BreenH
 *
 *  Policy reference list code.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "policy.h"
#include "pollist.h"

/*
 *  Globals
 */

LIST_ENTRY g_PolicyList;
ULONG g_cPolicies;

/*
 *  Internal Function Prototypes
 */

LPLCPOLICYREF
FindPolicyListEntry(
    ULONG ulPolicyId
    );

/*
 *  Function Implementations
 */

NTSTATUS
PolicyListAdd(
    CPolicy *pPolicy
    )
{
    LPLCPOLICYREF lpPolicyRef;

    ASSERT(pPolicy != NULL);

    lpPolicyRef = (LPLCPOLICYREF)LocalAlloc(LPTR, sizeof(LCPOLICYREF));

    if (lpPolicyRef != NULL)
    {
        lpPolicyRef->pPolicy = pPolicy;

        g_cPolicies++;
        InsertTailList(&g_PolicyList, &(lpPolicyRef->ListEntry));
        return(STATUS_SUCCESS);
    }
    else
    {
        return(STATUS_NO_MEMORY);
    }
}

VOID
PolicyListDelete(
    ULONG ulPolicyId
    )
{
    LPLCPOLICYREF lpPolicyRef;

    lpPolicyRef = FindPolicyListEntry(ulPolicyId);

    if (lpPolicyRef != NULL)
    {
        g_cPolicies--;
        RemoveEntryList(&(lpPolicyRef->ListEntry));
        LocalFree(lpPolicyRef);
    }
}

NTSTATUS
PolicyListEnumerateIds(
    PULONG *ppulPolicyIds,
    PULONG pcPolicies
    )
{
    NTSTATUS Status;

    *ppulPolicyIds = (PULONG)MIDL_user_allocate(g_cPolicies * sizeof(ULONG));

    if (*ppulPolicyIds != NULL)
    {
        LPLCPOLICYREF pTemp;
        ULONG i;

        pTemp = CONTAINING_RECORD(g_PolicyList.Flink, LCPOLICYREF, ListEntry);

        for (i = 0; i < g_cPolicies; i++)
        {
            (*ppulPolicyIds)[i] = pTemp->pPolicy->GetId();

            pTemp = CONTAINING_RECORD(pTemp->ListEntry.Flink, LCPOLICYREF, ListEntry);
        }

        *pcPolicies = g_cPolicies;
        Status = STATUS_SUCCESS;
    }
    else
    {
        *pcPolicies = 0;
        Status = STATUS_NO_MEMORY;
    }

    return(Status);
}

CPolicy *
PolicyListFindById(
    ULONG ulPolicyId
    )
{
    LPLCPOLICYREF lpPolicyRef;

    lpPolicyRef = FindPolicyListEntry(ulPolicyId);

    return(lpPolicyRef != NULL ? lpPolicyRef->pPolicy : NULL);
}

NTSTATUS
PolicyListInitialize(
    VOID
    )
{
    g_cPolicies = 0;
    InitializeListHead(&g_PolicyList);

    return(STATUS_SUCCESS);
}

CPolicy *
PolicyListPop(
    VOID
    )
{
    CPolicy *pPolicy;
    PLIST_ENTRY pTemp;
    LPLCPOLICYREF lpCurrentRef;

    if (!IsListEmpty(&g_PolicyList))
    {
        pTemp = RemoveHeadList(&g_PolicyList);

        lpCurrentRef = CONTAINING_RECORD(pTemp, LCPOLICYREF, ListEntry);
        pPolicy = lpCurrentRef->pPolicy;
        LocalFree(lpCurrentRef);
    }
    else
    {
        pPolicy = NULL;
    }

    return(pPolicy);
}

/*
 *  Internal Function Implementations
 */

LPLCPOLICYREF
FindPolicyListEntry(
    ULONG ulPolicyId
    )
{
    PLIST_ENTRY pNext;
    LPLCPOLICYREF lpPolicyRef, lpCurrentRef;

    lpPolicyRef = NULL;

    for (pNext = g_PolicyList.Flink; pNext != &g_PolicyList; pNext = pNext->Flink)
    {
        lpCurrentRef = CONTAINING_RECORD(pNext, LCPOLICYREF, ListEntry);

        if (lpCurrentRef->pPolicy->GetId() == ulPolicyId)
        {
            lpPolicyRef = lpCurrentRef;
            break;
        }
    }

    return(lpPolicyRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\pts.cpp ===
/*
 *  Pts.cpp
 *
 *  Author: BreenH
 *
 *  A dummy licensing policy for Personal TS.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "pts.h"

/*
 *  Class Implementation
 */

/*
 *  Creation Functions
 */

CPtsPolicy::CPtsPolicy(
    ) : CPolicy()
{
}

CPtsPolicy::~CPtsPolicy(
    )
{
}

/*
 *  Administrative Functions
 */

ULONG
CPtsPolicy::GetFlags(
    )
{
    return(LC_FLAG_INTERNAL_POLICY | LC_FLAG_LIMITED_INIT_ONLY);
}

ULONG
CPtsPolicy::GetId(
    )
{
    return(0);
}

NTSTATUS
CPtsPolicy::GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    )
{
    UNREFERENCED_PARAMETER(lpPolicyInfo);

    return(STATUS_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\precomp.h ===
/*
 *  precomp.h
 *
 *  Author: BreenH
 *
 *  Precompiled header for the licensing core.
 */

//
//  Remove warning 4514: unreferenced inline function has been removed.
//  This comes up due to the code being compiled at /W4, even though the
//  precompiled header is at /W3.
//

#pragma warning(disable: 4514)

//
//  Most SDK headers can't survive /W4.
//

#pragma warning(push, 3)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#include <stdio.h>
#include <ntlsapi.h>
#include <limits.h>
#include <time.h>
#include <winsta.h>
#include <wstmsg.h>
#include <icadd.h>
#include <icaapi.h>
#include <license.h>
#include <tlsapi.h>
#include <licprot.h>
#include <hslice.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <dsrole.h>
#include <cryptkey.h>
#include <certutil.h>
#include <lscsp.h>
#include <tsutilnt.h>
#include <md5.h>

#include "..\inc\wsxmgr.h"
#define LSCORE_NO_ICASRV_GLOBALS
#include "..\server\icasrv.h"
#include "..\server\helpasst.h"

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\policy.h ===
/*
 *  Policy.h
 *
 *  Author: BreenH
 *
 *  The policy base class definition.
 */

#ifndef __LC_POLICY_H__
#define __LC_POLICY_H__

/*
 *  Defines
 */

#define LC_VERSION_V1 0x1
#define LC_VERSION_CURRENT LC_VERSION_V1

#define LC_FLAG_INTERNAL_POLICY 0x1
#define LC_FLAG_LIMITED_INIT_ONLY 0x2
#define LC_FLAG_REQUIRE_APP_COMPAT 0x4

#define LC_LLS_PRODUCT_NAME L"TermService"

/*
 *  Typedefs
 */

class CPolicy;

/*
 *  Class Definition
 */

class CPolicy
{
public:

/*
 *  Creation Functions
 */

CPolicy(
    );

virtual
~CPolicy(
    );

/*
 *  Core Loading and Activation Functions
 */

NTSTATUS
CoreActivate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    );

NTSTATUS
CoreDeactivate(
    BOOL fShutdown
    );

NTSTATUS
CoreLoad(
    ULONG ulCoreVersion
    );

NTSTATUS
CoreUnload(
    );

/*
 *  Subclass Loading and Activation Functions
 */

protected:

virtual NTSTATUS
Activate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    );

virtual NTSTATUS
Deactivate(
    BOOL fShutdown
    );

virtual NTSTATUS
Load(
    );

virtual NTSTATUS
Unload(
    );

/*
 *  Reference Functions
 */

public:

LONG
IncrementReference(
    );

LONG
DecrementReference(
    );

/*
 *  Administrative Functions
 */

virtual NTSTATUS
DestroyPrivateContext(
    LPLCCONTEXT lpContext
    );

virtual ULONG
GetFlags(
    ) = 0;

virtual ULONG
GetId(
    ) = 0;

virtual NTSTATUS
GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    ) = 0;

/*
 *  Licensing Functions
 */

virtual NTSTATUS
Connect(
    CSession& Session,
    UINT &dwClientError
    );

virtual NTSTATUS
AutoLogon(
    CSession& Session,
    LPBOOL lpfUseCredentials,
    LPLCCREDENTIALS lpCredentials
    );

virtual NTSTATUS
Logon(
    CSession& Session
    );

virtual NTSTATUS
Disconnect(
    CSession& Session
    );

virtual NTSTATUS
Reconnect(
    CSession& Session,
    CSession& TemporarySession
    );

virtual NTSTATUS
Logoff(
    CSession& Session
    );

/*
 *  Common Helper Functions
 */

protected:

NTSTATUS
CPolicy::GetLlsLicense(
    CSession& Session
    );

/*
 *  Private Variables
 */

private:

BOOL m_fActivated;
LONG m_RefCount;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\policy.cpp ===
/*
 *  Policy.cpp
 *
 *  Author: BreenH
 *
 *  The policy base class definition.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "policy.h"
#include "util.h"

/*
 *  Globals
 */

extern "C" WCHAR g_wszProductVersion[];

/*
 *  Class Implementation
 */

/*
 *  Creation Functions
 */

CPolicy::CPolicy(
    )
{
    m_fActivated = FALSE;
    m_RefCount = 0;
}

CPolicy::~CPolicy(
    )
{
    ASSERT(!m_fActivated);
    ASSERT(m_RefCount == 0);
}

/*
 *  Core Loading and Activation Functions
 */

NTSTATUS
CPolicy::CoreActivate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    )
{
    NTSTATUS Status;

    //
    //  CoreActivate is protected by the g_PolicyCritSec.
    //

    ASSERT(!m_fActivated);

    Status = Activate(fStartup,pulAlternatePolicy);

    if (Status == STATUS_SUCCESS)
    {
        m_fActivated = TRUE;
    }

    return(Status);
}

NTSTATUS
CPolicy::CoreDeactivate(
    BOOL fShutdown
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    //  CoreDeactivate is protected by the g_PolicyCritSec.
    //

    if (m_fActivated)
    {
        Status = Deactivate(fShutdown);

        m_fActivated = FALSE;
    }

    return(Status);
}

NTSTATUS
CPolicy::CoreLoad(
    ULONG ulCoreVersion
    )
{
    NTSTATUS Status;

    //
    //  CoreLoad is protected by the g_PolicyCritSec.
    //

    if (ulCoreVersion == LC_VERSION_CURRENT)
    {
        Status = Load();
    }
    else
    {
        Status = STATUS_NOT_SUPPORTED;
    }

    return(Status);
}

NTSTATUS
CPolicy::CoreUnload(
    )
{
    NTSTATUS Status;

    //
    //  CoreUnload is protected by the g_PolicyCritSec.
    //

    ASSERT(!m_fActivated);

    if (m_RefCount > 0)
    {
        Status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        Status = Unload();
    }

    return(Status);
}

/*
 *  Subclass Loading and Activation Functions
 */

NTSTATUS
CPolicy::Activate(
    BOOL fStartup,
    ULONG *pulAlternatePolicy
    )
{
    UNREFERENCED_PARAMETER(fStartup);
    UNREFERENCED_PARAMETER(pulAlternatePolicy);

    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Deactivate(
    BOOL fShutdown
    )
{
    UNREFERENCED_PARAMETER(fShutdown);

    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Load(
    )
{
    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Unload(
    )
{
    return(STATUS_SUCCESS);
}

/*
 *  Reference Functions
 */

LONG
CPolicy::IncrementReference(
    )
{
    //
    //  IncrementReference is protected by the g_PolicyCritSec. No need to
    //  protect it again here, or do an InterlockedIncrement.
    //

    return(++m_RefCount);
}

LONG
CPolicy::DecrementReference(
    )
{
    //
    //  DecrementReference is protected by the g_PolicyCritSec. No need to
    //  protect it again here, or do an InterlockedDecrement. 
    //

    return(--m_RefCount);
}

/*
 *  Administrative Functions
 */

NTSTATUS
CPolicy::DestroyPrivateContext(
    LPLCCONTEXT lpContext
    )
{
    UNREFERENCED_PARAMETER(lpContext);

    ASSERT(lpContext->lPrivate == NULL);

    return(STATUS_SUCCESS);
}

/*
 *  Licensing Functions
 */

NTSTATUS
CPolicy::Connect(
    CSession& Session,
    UINT32 &dwClientError
    )
{
    LICENSE_STATUS LsStatus;
    NTSTATUS Status;
    PBYTE pBuffer;
    ULONG cbBuffer;
    ULONG cbReturned;

    pBuffer = NULL;
    cbBuffer = 0;

    LsStatus = ConstructProtocolResponse(
        Session.GetLicenseContext()->hProtocolLibContext,
        LICENSE_RESPONSE_VALID_CLIENT,
        &cbBuffer,
        &pBuffer
        );

    if (LsStatus == LICENSE_STATUS_OK)
    {
        ASSERT(pBuffer != NULL);
        ASSERT(cbBuffer > 0);

        Status = _IcaStackIoControl(
            Session.GetIcaStack(),
            IOCTL_ICA_STACK_SEND_CLIENT_LICENSE,
            pBuffer,
            cbBuffer,
            NULL,
            0,
            &cbReturned
            );
    }
    else
    {
        dwClientError = LsStatusToClientError(LsStatus);
        
        Status = LsStatusToNtStatus(LsStatus);
        goto errorexit;
    }

    if (Status == STATUS_SUCCESS)
    {
        ULONG ulLicenseStatus;

        ulLicenseStatus = LICENSE_PROTOCOL_SUCCESS;
        
        Status = _IcaStackIoControl(
            Session.GetIcaStack(),
            IOCTL_ICA_STACK_LICENSE_PROTOCOL_COMPLETE,
            &ulLicenseStatus,
            sizeof(ULONG),
            NULL,
            0,
            &cbReturned
            );
    }

    if (Status != STATUS_SUCCESS)
    {
        dwClientError = NtStatusToClientError(Status);
    }

errorexit:
    if (pBuffer != NULL)
    {
        LocalFree(pBuffer);
    }

    return(Status);
}

NTSTATUS
CPolicy::AutoLogon(
    CSession& Session,
    LPBOOL lpfUseCredentials,
    LPLCCREDENTIALS lpCredentials
    )
{
    UNREFERENCED_PARAMETER(Session);
    UNREFERENCED_PARAMETER(lpCredentials);

    ASSERT(lpfUseCredentials != NULL);
    ASSERT(lpCredentials != NULL);

    *lpfUseCredentials = FALSE;

    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Logon(
    CSession& Session
    )
{
    UNREFERENCED_PARAMETER(Session);

    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Disconnect(
    CSession& Session
    )
{
    UNREFERENCED_PARAMETER(Session);

    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Reconnect(
    CSession& Session,
    CSession& TemporarySession
    )
{
    UNREFERENCED_PARAMETER(Session);
    UNREFERENCED_PARAMETER(TemporarySession);

    return(STATUS_SUCCESS);
}

NTSTATUS
CPolicy::Logoff(
    CSession& Session
    )
{
    UNREFERENCED_PARAMETER(Session);

    return(STATUS_SUCCESS);
}

/*
 *  Common Helper Functions
 */

NTSTATUS
CPolicy::GetLlsLicense(
    CSession& Session
    )
{
    LS_STATUS_CODE LlsStatus;
    NTSTATUS Status;
    NT_LS_DATA LsData;

    ASSERT(!(Session.GetLicenseContext()->fLlsLicense));

    LsData.DataType = NT_LS_USER_NAME;
    LsData.Data = (PVOID)(Session.GetUserName());
    LsData.IsAdmin = Session.IsUserAdmin();

    LlsStatus = NtLicenseRequest(
        LC_LLS_PRODUCT_NAME,
        g_wszProductVersion,
        &(Session.GetLicenseContext()->hLlsLicense),
        &LsData
        );

    if (LlsStatus == LS_SUCCESS)
    {
        Session.GetLicenseContext()->fLlsLicense = TRUE;
        Status = STATUS_SUCCESS;
    }
    else
    {
        if (LlsStatus == LS_INSUFFICIENT_UNITS)
        {
            Status = STATUS_CTX_LICENSE_NOT_AVAILABLE;
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\pts.h ===
/*
 *  Pts.h
 *
 *  Author: BreenH
 *
 *  A dummy policy for Personal TS.
 */

#ifndef __LC_PTS_H__
#define __LC_PTS_H__

/*
 *  Includes
 */

#include "policy.h"

/*
 *  Class Definition
 */

class CPtsPolicy : public CPolicy
{
public:

/*
 *  Creation Functions
 */

CPtsPolicy(
    );

~CPtsPolicy(
    );

/*
 *  Administrative Functions
 */

ULONG
GetFlags(
    );

ULONG
GetId(
    );

NTSTATUS
GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\ra.h ===
/*
 *  RA.h
 *
 *  Author: BreenH
 *
 *  The Remote Administration policy.
 */

#ifndef __LC_RA_H__
#define __LC_RA_H__

/*
 *  Includes
 */

#include "policy.h"

/*
 *  Constants
 */

#define LC_POLICY_RA_MAX_SESSIONS 2

/*
 *  Class Definition
 */

class CRAPolicy : public CPolicy
{
public:

/*
 *  Creation Functions
 */

CRAPolicy(
    );

~CRAPolicy(
    );

/*
 *  Administrative Functions
 */

ULONG
GetFlags(
    );

ULONG
GetId(
    );

NTSTATUS
GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    );

/*
 *  Licensing Functions
 */

NTSTATUS
Logon(
    CSession& Session
    );

NTSTATUS
Logoff(
    CSession& Session
    );

/*
 *  Private Functions
 */

private:

NTSTATUS
ReleaseLicense(
    CSession& Session
    );

NTSTATUS
UseLicense(
    CSession& Session
    );

LONG m_SessionCount;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\ra.cpp ===
/*
 *  RA.cpp
 *
 *  Author: BreenH
 *
 *  The Remote Administration policy.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include "lscore.h"
#include "session.h"
#include "ra.h"

/*
 *  extern globals
 */
extern "C"
extern HANDLE hModuleWin;

/*
 *  Class Implementation
 */

/*
 *  Creation Functions
 */

CRAPolicy::CRAPolicy(
    ) : CPolicy()
{
    m_SessionCount = 0;
}

CRAPolicy::~CRAPolicy(
    )
{
    ASSERT(m_SessionCount == 0);
}

/*
 *  Administrative Functions
 */

ULONG
CRAPolicy::GetFlags(
    )
{
    return(LC_FLAG_INTERNAL_POLICY);
}

ULONG
CRAPolicy::GetId(
    )
{
    return(1);
}

NTSTATUS
CRAPolicy::GetInformation(
    LPLCPOLICYINFOGENERIC lpPolicyInfo
    )
{
    NTSTATUS Status;

    ASSERT(lpPolicyInfo != NULL);

    if (lpPolicyInfo->ulVersion == LCPOLICYINFOTYPE_V1)
    {
        int retVal;
        LPLCPOLICYINFO_V1 lpPolicyInfoV1 = (LPLCPOLICYINFO_V1)lpPolicyInfo;
        LPWSTR pName;
        LPWSTR pDescription;

        ASSERT(lpPolicyInfoV1->lpPolicyName == NULL);
        ASSERT(lpPolicyInfoV1->lpPolicyDescription == NULL);

        //
        //  The strings loaded in this fashion are READ-ONLY. They are also
        //  NOT NULL terminated. Allocate and zero out a buffer, then copy the
        //  string over.
        //

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_RA_NAME,
            (LPWSTR)(&pName),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyName = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyName != NULL)
            {
                lstrcpynW(lpPolicyInfoV1->lpPolicyName, pName, retVal + 1);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        retVal = LoadString(
            (HINSTANCE)hModuleWin,
            IDS_LSCORE_RA_DESC,
            (LPWSTR)(&pDescription),
            0
            );

        if (retVal != 0)
        {
            lpPolicyInfoV1->lpPolicyDescription = (LPWSTR)LocalAlloc(LPTR, (retVal + 1) * sizeof(WCHAR));

            if (lpPolicyInfoV1->lpPolicyDescription != NULL)
            {
                lstrcpynW(lpPolicyInfoV1->lpPolicyDescription, pDescription, retVal + 1);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
                goto V1error;
            }
        }
        else
        {
            Status = STATUS_INTERNAL_ERROR;
            goto V1error;
        }

        Status = STATUS_SUCCESS;
        goto exit;

V1error:

        //
        //  An error occurred loading/copying the strings.
        //

        if (lpPolicyInfoV1->lpPolicyName != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyName);
            lpPolicyInfoV1->lpPolicyName = NULL;
        }

        if (lpPolicyInfoV1->lpPolicyDescription != NULL)
        {
            LocalFree(lpPolicyInfoV1->lpPolicyDescription);
            lpPolicyInfoV1->lpPolicyDescription = NULL;
        }
    }
    else
    {
        Status = STATUS_REVISION_MISMATCH;
    }

exit:
    return(Status);
}

/*
 *  Licensing Functions
 */

NTSTATUS
CRAPolicy::Logon(
    CSession& Session
    )
{
    NTSTATUS Status;

    if ((Session.GetLogonId() != 0) && (!(Session.IsUserHelpAssistant())))
    {
        Status = UseLicense(Session);
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

    return(Status);
}

NTSTATUS
CRAPolicy::Logoff(
    CSession& Session
    )
{
    NTSTATUS Status;

    if (Session.GetLicenseContext()->fTsLicense)
    {
        Status = ReleaseLicense(Session);
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

    return(Status);
}

/*
 *  Private Functions
 */

NTSTATUS
CRAPolicy::ReleaseLicense(
    CSession& Session
    )
{
    LONG lSessions;

    ASSERT(Session.GetLicenseContext()->fTsLicense);

    lSessions = InterlockedDecrement(&m_SessionCount);
    Session.GetLicenseContext()->fTsLicense = FALSE;

    ASSERT(lSessions >= 0);

    return(STATUS_SUCCESS);
}

NTSTATUS
CRAPolicy::UseLicense(
    CSession& Session
    )
{
    NTSTATUS Status;
    LONG lSessions;

    ASSERT(!(Session.GetLicenseContext()->fTsLicense));

    lSessions = InterlockedIncrement(&m_SessionCount);

    if (lSessions <= LC_POLICY_RA_MAX_SESSIONS)
    {
        Session.GetLicenseContext()->fTsLicense = TRUE;
        Status = STATUS_SUCCESS;
    }
    else
    {
        InterlockedDecrement(&m_SessionCount);
        Status = STATUS_CTX_LICENSE_NOT_AVAILABLE;
    }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\session.h ===
/*
 *  Session.h
 *
 *  Author: BreenH
 *
 *  The Session class provides a level of separation between the winstation
 *  structure and the policy modules. It is just a wrapper class; it does not
 *  create or destroy winstation stuctures.
 */

#ifndef __LC_SESSION_H__
#define __LC_SESSION_H__


/*
 *  Typedefs
 */

typedef struct {
    CRITICAL_SECTION CritSec;
    class CPolicy *pPolicy;
    ULONG ulClientProtocolVersion;
    HANDLE hProtocolLibContext;
    BOOL fTsLicense;
    BOOL fLlsLicense;
    LS_HANDLE hLlsLicense;
    LPARAM lPrivate;
} LCCONTEXT, *LPLCCONTEXT;

/*
 *  Class Definition
 */

class CSession
{
public:

/*
 *  Creation Functions
 */

CSession(
    PWINSTATION pWinStation
    )
{
    m_pWinStation = pWinStation;
}

~CSession(
    )
{
    m_pWinStation = NULL;
}

/*
 *  Get Functions
 */

inline HANDLE
GetIcaStack(
    ) const
{
    return(m_pWinStation->hStack);
}

inline LPLCCONTEXT
GetLicenseContext(
    ) const
{
    return((LPLCCONTEXT)(m_pWinStation->lpLicenseContext));
}

inline ULONG
GetLogonId(
    ) const
{
    return(m_pWinStation->LogonId);
}

inline LPCWSTR
GetUserDomain(
    ) const
{
    return((LPCWSTR)(m_pWinStation->Domain));
}

inline LPCWSTR
GetUserName(
    ) const
{
    return((LPCWSTR)(m_pWinStation->UserName));
}

/*
 *  Is Functions
 */

inline BOOLEAN
IsConsoleSession(
    ) const
{
    return((BOOLEAN)(GetCurrentConsoleId() == m_pWinStation->LogonId));
}

inline BOOLEAN
IsSessionZero(
    ) const
{
    return((BOOLEAN)((0 == m_pWinStation->LogonId)
                     || (m_pWinStation->bClientSupportsRedirection
                         && m_pWinStation->bRequestedSessionIDFieldValid
                         && (0 == m_pWinStation->RequestedSessionID))));
}

inline BOOLEAN
IsUserAdmin(
    ) const
{
    return(m_pWinStation->fUserIsAdmin);
}

inline BOOL
IsUserHelpAssistant(
    ) const
{
    return TSIsSessionHelpSession( m_pWinStation, NULL );
}


/*
 *  Do Functions
 */

inline NTSTATUS
SendWinStationCommand(
    PWINSTATION_APIMSG pMsg
    )
{
    //
    //  Wait time must be zero, or termsrv will release the winstation,
    //  causing who knows what to happen to our state.
    //

    return(::SendWinStationCommand(m_pWinStation, pMsg, 0));
}

//
// ASSUMPTION: This function will be
//             called with the stack lock already held
//
inline NTSTATUS
SetErrorInfo(
    UINT32 dwErr
    )
{
        if(m_pWinStation->pWsx &&
           m_pWinStation->pWsx->pWsxSetErrorInfo &&
           m_pWinStation->pWsxContext)
        {
            return m_pWinStation->pWsx->pWsxSetErrorInfo(
                               m_pWinStation->pWsxContext,
                               dwErr,
                               TRUE); //lock already held
        }
        else
        {
            return STATUS_INVALID_PARAMETER;
        }
}


/*
 *  Set Functions
 */


private:

PWINSTATION m_pWinStation;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\rpc\lcimport.h ===
//
//  Win32 Headers
//  Note: MIDL includes windows.h in a separate fashion, define _INC_WINDOWS
//  to prevent other header files from re-including.
//

#define _INC_WINDOWS
#include <windef.h>
#include <winbase.h>
#include <license.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\util.h ===
/*
 *  Util.h
 *
 *  Author: BreenH
 *
 *  Utility functions for the licensing core and its policies.
 */

#ifndef __LC_UTIL_H__
#define __LC_UTIL_H__

/*
 *  Typedefs
 */

typedef VOID (*PSSL_GEN_RAND_BITS)(PUCHAR, LONG);

/*
 *  Function Prototypes
 */

NTSTATUS
LsStatusToNtStatus(
    LICENSE_STATUS LsStatus
    );

UINT32
LsStatusToClientError(
    LICENSE_STATUS LsStatus
    );

UINT32
NtStatusToClientError(
    NTSTATUS Status
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\lscore\util.cpp ===
/*
 *  Util.h
 *
 *  Author: BreenH
 *
 *  Utility functions for the licensing core and its policies.
 */

/*
 *  Includes
 */

#include "precomp.h"
#include <stdlib.h>
#include <time.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmapibuf.h>
#define SECURITY_WIN32
#include <security.h>
#include <rpc.h>
#include <tserrs.h>
#include "util.h"
#include "lctrace.h"

/*
 *  Function Definitions
 */

NTSTATUS
LsStatusToNtStatus(
    LICENSE_STATUS LsStatus
    )
{
    NTSTATUS Status;

    switch (LsStatus)
    {
    case LICENSE_STATUS_OK:
        Status = STATUS_SUCCESS;
        break;

    case LICENSE_STATUS_OUT_OF_MEMORY:
        Status = STATUS_NO_MEMORY;
        break;
        
    case LICENSE_STATUS_INSUFFICIENT_BUFFER:
        Status = STATUS_BUFFER_TOO_SMALL;
        break;

    case LICENSE_STATUS_INVALID_INPUT:
        Status = STATUS_INVALID_PARAMETER;
        break;

    case LICENSE_STATUS_NO_LICENSE_SERVER:
        Status = RPC_NT_SERVER_UNAVAILABLE;
        break;

    case LICENSE_STATUS_CANNOT_UPGRADE_LICENSE:
    case LICENSE_STATUS_NO_LICENSE_ERROR:
        Status = STATUS_LICENSE_VIOLATION;
        break;

    default:
        Status = STATUS_INTERNAL_ERROR;
        break;
    }

    return Status;
}


UINT32
LsStatusToClientError(
    LICENSE_STATUS LsStatus
    )
{
    UINT32 dwClientError;

    switch (LsStatus)
    {
    case LICENSE_STATUS_OK:
        dwClientError = TS_ERRINFO_NOERROR;
        break;

    case LICENSE_STATUS_OUT_OF_MEMORY:
        dwClientError = TS_ERRINFO_OUT_OF_MEMORY;
        break;
        
    case LICENSE_STATUS_NO_LICENSE_SERVER:
        dwClientError = TS_ERRINFO_LICENSE_NO_LICENSE_SERVER;
        break;

    case LICENSE_STATUS_NO_LICENSE_ERROR:
        dwClientError = TS_ERRINFO_LICENSE_NO_LICENSE;
        break;

    case LICENSE_STATUS_INVALID_RESPONSE:
        dwClientError = TS_ERRINFO_LICENSE_BAD_CLIENT_MSG;
        break;

    case LICENSE_STATUS_INVALID_MAC_DATA:
        dwClientError = TS_ERRINFO_LICENSE_BAD_CLIENT_MSG;
        break;

    case LICENSE_STATUS_CANNOT_DECODE_LICENSE:
        dwClientError = TS_ERRINFO_LICENSE_BAD_CLIENT_LICENSE;
        break;

    case LICENSE_STATUS_CANNOT_VERIFY_HWID:
        dwClientError = TS_ERRINFO_LICENSE_HWID_DOESNT_MATCH_LICENSE;
        break;

    case LICENSE_STATUS_SERVER_ABORT:
        dwClientError = TS_ERRINFO_LICENSE_CANT_FINISH_PROTOCOL;
        break;

    case LICENSE_STATUS_CLIENT_ABORT:
        dwClientError = TS_ERRINFO_LICENSE_CLIENT_ENDED_PROTOCOL;
        break;

    case LICENSE_STATUS_CANNOT_UPGRADE_LICENSE:
        dwClientError = TS_ERRINFO_LICENSE_CANT_UPGRADE_LICENSE;
        break;

    case LICENSE_STATUS_INSUFFICIENT_BUFFER:
    case LICENSE_STATUS_INVALID_INPUT:
    case LICENSE_STATUS_INVALID_SERVER_CONTEXT:
    case LICENSE_STATUS_NO_CERTIFICATE:
    case LICENSE_STATUS_NO_PRIVATE_KEY:
    case LICENSE_STATUS_INVALID_CRYPT_STATE:
    case LICENSE_STATUS_AUTHENTICATION_ERROR:
    default:
        dwClientError = TS_ERRINFO_LICENSE_INTERNAL;
        break;
    }

    return dwClientError;
}

UINT32
NtStatusToClientError(
    NTSTATUS Status
    )
{
    UINT32 dwClientError;

    switch (Status)
    {
    case STATUS_SUCCESS:
        dwClientError = TS_ERRINFO_NOERROR;
        break;

    case STATUS_NO_MEMORY:
        dwClientError = TS_ERRINFO_OUT_OF_MEMORY;
        break;
        
    case RPC_NT_SERVER_UNAVAILABLE:
        dwClientError = TS_ERRINFO_LICENSE_NO_LICENSE_SERVER;
        break;

    case STATUS_LICENSE_VIOLATION:
        dwClientError = TS_ERRINFO_LICENSE_NO_LICENSE;
        break;

    case STATUS_NET_WRITE_FAULT:
        dwClientError = TS_ERRINFO_LICENSE_CANT_FINISH_PROTOCOL;
        break;


    case STATUS_CTX_CLOSE_PENDING:
    case STATUS_INVALID_PARAMETER:
    case STATUS_BUFFER_TOO_SMALL:
    case STATUS_NO_DATA_DETECTED:
    default:
        dwClientError = TS_ERRINFO_LICENSE_INTERNAL;
        break;
    }

    return dwClientError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\acl.c ===
/*************************************************************************
*
* acl.c
*
* Routines to manage Window Station Security.
*
*
* Copyright Microsoft Corporation, 1998
*
*************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <winsta.h>

#include <rpc.h>
#include <seopaque.h>

/*
 * NOTE: Please keep all security code for ICASRV and CITRIX WINSTATIONS
 *       in this file. This helps to compartmentilize the security routines
 *       to make it easier to update/debug our policies.
 *
 */

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif



/*
 * Forward references
 */

VOID
CleanUpSD(
   PSECURITY_DESCRIPTOR pSD
   );

NTSTATUS IcaRegWinStationEnumerate( PULONG, PWINSTATIONNAME, PULONG );

NTSTATUS
ConfigureSecurity(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
ConfigureConsoleSecurity(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

PSECURITY_DESCRIPTOR
CreateWinStationDefaultSecurityDescriptor();

NTSTATUS
RpcGetClientLogonId(
    PULONG pLogonId
    );

NTSTATUS
RpcCheckSystemClientEx(
    PWINSTATION pWinStation
    );

BOOL
IsCallerSystem( VOID );

BOOL
IsCallerAdmin( VOID );

BOOL
IsServiceLoggedAsSystem( VOID );


BOOL
IsSystemToken( HANDLE TokenHandle );


NTSTATUS
RpcCheckSystemClientNoLogonId(
    PWINSTATION pWinStation
    );

NTSTATUS
RpcCheckClientAccessLocal(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    );

BOOL
AddAccessToDirectory(
    PWCHAR pPath,
    DWORD  NewAccess,
    PSID   pSid
    );

NTSTATUS
AddAccessToDirectoryObjects(
    HANDLE DirectoryHandle,
    DWORD  NewAccess,
    PSID   pSid
    );

BOOL
AddAceToSecurityDescriptor(
    PSECURITY_DESCRIPTOR *ppSd,
    PACL                 *ppDacl,
    DWORD                Access,
    PSID                 pSid,
    BOOLEAN              InheritOnly
    );

BOOL
SelfRelativeToAbsoluteSD(
    PSECURITY_DESCRIPTOR SecurityDescriptorIn,
    PSECURITY_DESCRIPTOR *SecurityDescriptorOut,
    PULONG ReturnedLength
    );

BOOL
AbsoluteToSelfRelativeSD(
    PSECURITY_DESCRIPTOR SecurityDescriptorIn,
    PSECURITY_DESCRIPTOR *SecurityDescriptorOut,
    PULONG ReturnedLength
    );

NTSTATUS ApplyWinStaMappingToSD( 
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );



/*
 * Global data
 */
PSECURITY_DESCRIPTOR DefaultWinStationSecurityDescriptor = NULL;
PSECURITY_DESCRIPTOR DefaultConsoleSecurityDescriptor = NULL;

/*
 * Structure to lookup the default security descriptor
 * for WINSTATIONS.
 */
RTL_QUERY_REGISTRY_TABLE DefaultSecurityTable[] = {

    {NULL, RTL_QUERY_REGISTRY_SUBKEY,
     REG_WINSTATIONS, NULL,
     REG_NONE, NULL, 0},

    {ConfigureSecurity,      RTL_QUERY_REGISTRY_REQUIRED,
     REG_DEFAULTSECURITY, NULL,
     REG_NONE, NULL, 0},

    {NULL, 0,
     NULL, NULL,
     REG_NONE, NULL, 0}

};

/*
 * Structure to lookup the default console security descriptor
 */
RTL_QUERY_REGISTRY_TABLE ConsoleSecurityTable[] = {

    {NULL, RTL_QUERY_REGISTRY_SUBKEY,
     REG_WINSTATIONS, NULL,
     REG_NONE, NULL, 0},

    {ConfigureConsoleSecurity,      RTL_QUERY_REGISTRY_REQUIRED,
     REG_CONSOLESECURITY, NULL,
     REG_NONE, NULL, 0},

    {NULL, 0,
     NULL, NULL,
     REG_NONE, NULL, 0}

};

extern PSID gSystemSid;
extern PSID gAdminSid;
extern RTL_RESOURCE WinStationSecurityLock;

/*
 * Structure to lookup the security on a specific WINSTATION
 * type name in the registry.
 *
 * This is control\Terminal Server\WinStations\<name>\Security
 *
 * <name> is the transport type. IE: TCP, IPX, etc.
 */
RTL_QUERY_REGISTRY_TABLE WinStationSecurityTable[] = {

    {ConfigureSecurity,         RTL_QUERY_REGISTRY_REQUIRED,
     REG_SECURITY,               NULL,
     REG_NONE, NULL, 0},

    {NULL, 0,
     NULL, NULL,
     REG_NONE, NULL, 0}

};

LPCWSTR szTermsrv = L"Termsrv";
LPCWSTR szTermsrvSession = L"Termsrv Session";

//
// Structure that describes the mapping of generic access rights to object
// specific access rights for Window Station objects.
//

GENERIC_MAPPING WinStaMapping = {
    STANDARD_RIGHTS_READ |
        WINSTATION_QUERY,
    STANDARD_RIGHTS_WRITE |
        WINSTATION_SET,
    STANDARD_RIGHTS_EXECUTE,
        WINSTATION_ALL_ACCESS
};


/*******************************************************************************
 *
 *  WinStationSecurityInit
 *
 *  Initialize the WinStation security.
 *
 * ENTRY:
 *   nothing
 *
 * EXIT:
 *   STATUS_SUCCESS
 *
 ******************************************************************************/

NTSTATUS
WinStationSecurityInit( VOID )
{
    NTSTATUS Status;

    /*
     * Get the default security descriptor from the registry
     *
     * This is placed on WinStations that do not have specific
     * security placed on them by WinAdmin.
     *
     * This key is in CurrentControlSet\Control\Terminal Server\WinStations\DefaultSecurity
     */
    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     REG_TSERVER,
                                     DefaultSecurityTable,
                                     NULL,
                                     DefaultEnvironment
                                   );

    /*
     * If the key does not exist, create a default security descriptor.
     *
     * NOTE: This is now created by default always by SM manager. The
     *       SM default must match the default here.
     *       This is so that the console is created with the right SD.
     */
    if (   ( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        || ( DefaultWinStationSecurityDescriptor == NULL ) ) {
        PSECURITY_DESCRIPTOR Default;
        ULONG Length;

        Default = CreateWinStationDefaultSecurityDescriptor();
        ASSERT( Default != NULL );
        if (Default == NULL) {
            return STATUS_NO_MEMORY;
        }

        Length = RtlLengthSecurityDescriptor(Default);

        // Ensure the complete path exists
        RtlCreateRegistryKey( RTL_REGISTRY_CONTROL, REG_TSERVER );
        RtlCreateRegistryKey( RTL_REGISTRY_CONTROL, REG_TSERVER_WINSTATIONS );

        Status = RtlWriteRegistryValue( RTL_REGISTRY_CONTROL,
                                        REG_TSERVER_WINSTATIONS,
                                        REG_DEFAULTSECURITY, REG_BINARY,
                                        Default, Length );

        DefaultWinStationSecurityDescriptor = Default;
    }

    if (!NT_SUCCESS( Status )) {
        DBGPRINT(( "TERMSRV: RtlQueryRegistryValues(Terminal Server) failed - Status == %lx\n", Status ));
    }

    ASSERT( DefaultWinStationSecurityDescriptor != NULL );
    
    //Just do the same for default console security descriptor
    //--------------------------------------------------------------------------------------
    /*
     * Get the default console security descriptor from the registry
     *
     * This is placed on WinStations that do not have specific
     * security placed on them by WinAdmin.
     *
     * This key is in CurrentControlSet\Control\Terminal Server\WinStations\ConsoleSecurity
     */
    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     REG_TSERVER,
                                     ConsoleSecurityTable,
                                     NULL,
                                     DefaultEnvironment
                                   );

    /*
     * If the key does not exist, set default console SD to be equal to 
     * default SD
     */
    if (   ( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        || ( DefaultConsoleSecurityDescriptor == NULL ) ) {
        DefaultConsoleSecurityDescriptor = DefaultWinStationSecurityDescriptor;        
    }

    ASSERT( DefaultConsoleSecurityDescriptor != NULL );
    //--------------------------------------------------------------------------------------

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  ReadWinStationSecurityDescriptor
 *
 *   Read the security descriptor from the registry for the
 *   WINSTATION name.
 *
 *   The WINSTATION name is the base protocol name, or the one shot name.
 *   IE: "TCP", or "COM3". It is not an instance name such as "TCP#4".
 *
 *   This is called by the WSF_LISTEN thread to get any specific ACL's
 *   for the WINSTATION protocol type.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
ReadWinStationSecurityDescriptor(
    PWINSTATION pWinStation
    )
{
    LONG cb;
    LPWSTR PathBuf;
    NTSTATUS Status;
    ULONG Length;
    PACL Dacl, NewDacl = NULL;
    BOOLEAN DaclPresent, DaclDefaulted;
    ACL_SIZE_INFORMATION AclInfo;
    PACE_HEADER CurrentAce;
    ULONG i;


    /*
     * If no name, we can not lookup the security descriptor.
     */
    if( pWinStation->WinStationName[0] == UNICODE_NULL ) {
        TRACE0(("TERMSRV: ReadWinStationSecurityDescriptor: No name on WinStation LogonId %d\n",pWinStation->LogonId));
        return( STATUS_NO_SECURITY_ON_OBJECT );
    }

    TRACE0(("TERMSRV: ReadWinStationSecurityDescriptor: Name %ws\n",&pWinStation->WinStationName));

    cb = sizeof( REG_TSERVER_WINSTATIONS ) +
         sizeof( L"\\" ) +
         sizeof(WINSTATIONNAME)             +
         sizeof(UNICODE_NULL);

    PathBuf = MemAlloc( cb );
    if ( PathBuf == NULL )
        return( STATUS_NO_MEMORY );

    wcscpy( PathBuf, REG_TSERVER_WINSTATIONS );
    wcscat( PathBuf, L"\\" );
    wcscat( PathBuf, pWinStation->WinStationName );

    Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                     PathBuf,
                                     WinStationSecurityTable,
                                     pWinStation,
                                     DefaultEnvironment
                                   );
   /*
    * Do not let a Winstation with no security descriptor
    */
    if ( (   ( Status == STATUS_OBJECT_NAME_NOT_FOUND )
          || ( pWinStation->pSecurityDescriptor == NULL) )
        && (DefaultWinStationSecurityDescriptor != NULL) )
    {
        //
        //  Free the old one if allocated
        //
        if ( pWinStation->pSecurityDescriptor ) {
            //  must break up into absolute format and self-relative
            CleanUpSD(pWinStation->pSecurityDescriptor);
            pWinStation->pSecurityDescriptor = NULL;
        }

        if(_wcsicmp( pWinStation->WinStationName, L"Console" ))
        {
            // RtlCopySecurityDescriptor only works with self-relative format
            Status = RtlCopySecurityDescriptor(DefaultWinStationSecurityDescriptor,
                                               &(pWinStation->pSecurityDescriptor));
        }
        else
        {
            //It is a console winstation
            Status = RtlCopySecurityDescriptor(DefaultConsoleSecurityDescriptor,
                                               &(pWinStation->pSecurityDescriptor));
        }

    }

    TRACE0(("TERMSRV: ReadWinStationSecurityDescriptor: Status 0x%x\n",Status));

    MemFree( PathBuf );

    return( Status );
}

/*****************************************************************************
 *
 *  ConfigureSecurity
 *
 *   Processing function called by RtlQueryRegistryValues() to process the
 *   WINSTATION security descriptor read from the registry.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
ConfigureSecurity(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR * ppSD;
    PWINSTATION pWinStation = (PWINSTATION)Context;
    PSID pOwnerSid = NULL;
    BOOLEAN bOD;
    PSID pGroupSid = NULL;
    BOOLEAN bGD;
    PSID SystemSid;
    SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;

    /*
     * Ensure value type is REG_BINARY and length of value data
     * is at least the length of a minimum security descriptor
     * and not unreasonably large.
     */
    if ( ValueType != REG_BINARY ||
         ValueLength < SECURITY_DESCRIPTOR_MIN_LENGTH ||
         ValueLength > MAXUSHORT ) {
        DBGPRINT(( "TERMSRV: ConfigureSecurity, ValueType=0x%x\n", ValueType ));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    if( !IsValidSecurityDescriptor( ValueData )) {
        DBGPRINT(( "TERMSRV: ConfigureSecurity, Invalid Security Descriptor in registry\n"));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    //
    // HACK needed for TS 4.0 security descriptors conversion
    //
    if (!NT_SUCCESS(RtlGetOwnerSecurityDescriptor( ValueData, &pOwnerSid, &bOD))
        || (pOwnerSid == NULL))
    {
        DBGPRINT(( "TERMSRV: ConfigureSecurity, Invalid Security Descriptor in registry: Can't get owner\n"));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    if (!NT_SUCCESS(RtlGetGroupSecurityDescriptor( ValueData, &pGroupSid, &bGD)))
    {
        DBGPRINT(( "TERMSRV: ConfigureSecurity, Invalid Security Descriptor in registry: Can't get group\n"));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    if( pWinStation ) {
        /*
         * WinStation specific security descriptor
         */
        ppSD = &(pWinStation->pSecurityDescriptor);
    }
    else {
        /*
         * Update the global default security descriptor
         */
        ppSD = &DefaultWinStationSecurityDescriptor;
    }

    //
    // Free old one if allocated
    //
    if (*ppSD != NULL) {
        CleanUpSD(*ppSD);
        //RtlDeleteSecurityObject( ppSD );
        *ppSD = NULL;
    }

    if (pGroupSid != NULL)
    {
        //
        // Regular case:
        // Copy the value read in registry
        //
        // RtlCopySecurityDescriptor only works with self-relative format
        RtlCopySecurityDescriptor((PSECURITY_DESCRIPTOR)ValueData, ppSD);
    }
    else
    {
        //
        //  Conversion for TS 4 descriptors
        //

        PSECURITY_DESCRIPTOR AbsoluteSD = NULL;

        if (SelfRelativeToAbsoluteSD ( (PSECURITY_DESCRIPTOR)ValueData, &AbsoluteSD, NULL))
        {
            // set the owner as group (both should be system sid)
            Status = RtlSetGroupSecurityDescriptor(AbsoluteSD, pOwnerSid, FALSE);
            if (NT_SUCCESS(Status))
            {
                // need also to force the mapping. Sigh !
                Status = ApplyWinStaMappingToSD(AbsoluteSD);

                if ((!NT_SUCCESS(Status)) || ( !AbsoluteToSelfRelativeSD (AbsoluteSD, ppSD, NULL)))
                {
                    Status = STATUS_INVALID_SECURITY_DESCR;
                }
            }

            // Absolute SD was only needed temporarily
            CleanUpSD( AbsoluteSD );
        }
        else
        {
            Status = STATUS_INVALID_SECURITY_DESCR;
        }
        if (!NT_SUCCESS(Status))
        {
            DBGPRINT(( "TERMSRV: ConfigureSecurity, Invalid Security Descriptor in registry\n"));
            return( STATUS_INVALID_SECURITY_DESCR );
        }

    }

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  ConfigureConsoleSecurity
 *
 *   Processing function called by RtlQueryRegistryValues() to process the
 *   default console security descriptor read from the registry.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
ConfigureConsoleSecurity(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR * ppSD;
    PSID pOwnerSid = NULL;
    BOOLEAN bOD;
    PSID pGroupSid = NULL;
    BOOLEAN bGD;
    /*
     * Ensure value type is REG_BINARY and length of value data
     * is at least the length of a minimum security descriptor
     * and not unreasonably large.
     */
    if ( ValueType != REG_BINARY ||
         ValueLength < SECURITY_DESCRIPTOR_MIN_LENGTH ||
         ValueLength > MAXUSHORT ) {
        DBGPRINT(( "TERMSRV: ConfigureConsoleSecurity, ValueType=0x%x\n", ValueType ));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    if( !IsValidSecurityDescriptor( ValueData )) {
        DBGPRINT(( "TERMSRV: ConfigureConsoleSecurity, Invalid Security Descriptor in registry\n"));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    //
    // HACK needed for TS 4.0 security descriptors conversion
    //
    if (!NT_SUCCESS(RtlGetOwnerSecurityDescriptor( ValueData, &pOwnerSid, &bOD))
        || (pOwnerSid == NULL))
    {
        DBGPRINT(( "TERMSRV: ConfigureConsoleSecurity, Invalid Security Descriptor in registry: Can't get owner\n"));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    if (!NT_SUCCESS(RtlGetGroupSecurityDescriptor( ValueData, &pGroupSid, &bGD))
        ||(pGroupSid == NULL))
    {
        DBGPRINT(( "TERMSRV: ConfigureConsoleSecurity, Invalid Security Descriptor in registry: Can't get group\n"));
        return( STATUS_INVALID_SECURITY_DESCR );
    }

    
    /*
     * Update the global default security descriptor
     */
    ppSD = &DefaultConsoleSecurityDescriptor;


    //
    // Free old one if allocated
    //
    if (*ppSD != NULL) {
        CleanUpSD(*ppSD);
        //RtlDeleteSecurityObject( ppSD );
        *ppSD = NULL;
    }


    //
    // Regular case:
    // Copy the value read in registry
    //
    // RtlCopySecurityDescriptor only works with self-relative format
    RtlCopySecurityDescriptor((PSECURITY_DESCRIPTOR)ValueData, ppSD);

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  WinStationGetSecurityDescriptor
 *
 *   Return a pointer to the security descriptor that should be enforced
 *   on this winstation. This could be a specific, or a global
 *   default security descriptor.
 *
 * ENTRY:   pWinStation     the aimed winstation
 *
 * EXIT:    the SD of this winstation,
 *          or the default SD if this winstation hs no SD (it should not happen !)
 *
 ****************************************************************************/

PSECURITY_DESCRIPTOR
WinStationGetSecurityDescriptor(
    PWINSTATION pWinStation
    )
{
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    SecurityDescriptor = pWinStation->pSecurityDescriptor ?
                         pWinStation->pSecurityDescriptor :
                         DefaultWinStationSecurityDescriptor;

    return( SecurityDescriptor );
}


/*****************************************************************************
 *
 *  WinStationFreeSecurityDescriptor
 *
 *   Release the winstation security descriptor.
 *
 *   If its the global default, it is not free'd.
 *
 * ENTRY:   the winstation
 *
 * EXIT:    nothing
 *
 ****************************************************************************/

VOID
WinStationFreeSecurityDescriptor(
    PWINSTATION pWinStation
    )
{

    // console disconnect
    if ( pWinStation->pSecurityDescriptor == DefaultWinStationSecurityDescriptor && pWinStation->LogonId != 0) {
        pWinStation->pSecurityDescriptor = NULL;
    }
    // Catch callers mis-managing the security descriptor
    ASSERT( pWinStation->pSecurityDescriptor != DefaultWinStationSecurityDescriptor );

    if (pWinStation->pSecurityDescriptor) {
        //RtlDeleteSecurityObject( &(pWinStation->pSecurityDescriptor) );
        CleanUpSD(pWinStation->pSecurityDescriptor);
        pWinStation->pSecurityDescriptor = NULL;
    }

    return;
}

/*****************************************************************************
 *
 *  WinStationInheritSecurityDescriptor
 *
 *  Copy the security descriptor to the target WinStation and set it
 *  on the kernel object.
 *
 * ENTRY:
 *   pSecurityDescriptor (input)
 *     pointer to SD to be inherited
 *   pTargetWinStation (input)
 *     pointer to WinStation to inherit the SD
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationInheritSecurityDescriptor(
    PVOID pSecurityDescriptor,
    PWINSTATION pTargetWinStation
    )
{
    NTSTATUS Status;

    //
    // If the listen WinStation has a security descriptor, this means
    // that all WinStations of this protocol (TD) type will inherit
    // the security descriptor set by WinCfg.
    //
    if ( pSecurityDescriptor ) {

        ASSERT( IsValidSecurityDescriptor( pSecurityDescriptor ) );

        if ( pTargetWinStation->pSecurityDescriptor ) {
           //RtlDeleteSecurityObject( &(pTargetWinStation->pSecurityDescriptor) );
           CleanUpSD(pTargetWinStation->pSecurityDescriptor);
           pTargetWinStation->pSecurityDescriptor = NULL;
        }
        // RtlCopySecurityDescriptor only works with self-relative format
        Status = RtlCopySecurityDescriptor(pSecurityDescriptor,
                                           &(pTargetWinStation->pSecurityDescriptor) );
        return (Status);
    }

    //
    // If no specific security descriptor on the listen WinStation,
    // the default was set on the object when it was created for the pool.
    //

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  RpcCheckClientAccess
 *
 *   Verify whether client has the desired access to a WinStation.
 *
 *   NOTE: This is called under an RPC context.
 *
 * ENTRY:
 *    pWinStation (input)
 *      Pointer to WinStation to query access to
 *
 *    DesiredAccess (input)
 *      Access mask of desired client access
 *
 *    AlreadyImpersonating (input)
 *      BOOLEAN that specifies caller is already impersonating client
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
RpcCheckClientAccess(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    )
{
    NTSTATUS    Status;
    RPC_STATUS  RpcStatus;
    BOOL        bAccessCheckOk = FALSE;
    DWORD       GrantedAccess;
    BOOL        AccessStatus;
    BOOL        fGenerateOnClose;

    /*
     * Impersonate the client
     */
    if ( !AlreadyImpersonating ) {
        RpcStatus = RpcImpersonateClient( NULL );
        if ( RpcStatus != RPC_S_OK ) {
            DBGPRINT(("TERMSRV: CheckClientAccess: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
            return( STATUS_CANNOT_IMPERSONATE );
        }
    }
    bAccessCheckOk = AccessCheckAndAuditAlarm(szTermsrv,
                         NULL,
                         (LPWSTR)szTermsrvSession,
                         (LPWSTR)szTermsrvSession,
                         WinStationGetSecurityDescriptor(pWinStation),
                         DesiredAccess,
                         &WinStaMapping,
                         FALSE,
                         &GrantedAccess,
                         &AccessStatus,
                         &fGenerateOnClose);

    if ( !AlreadyImpersonating ) {
        RpcRevertToSelf();
    }

    if (bAccessCheckOk)
    {
        if (AccessStatus == FALSE)
        {
            Status = NtCurrentTeb()->LastStatusValue;
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: RpcCheckClientAccess, AccessCheckAndAuditAlarm(%u) returned error 0x%x\n",
                      pWinStation->LogonId, Status ));
        }
        else
        {
            TRACE((hTrace,TC_ICASRV,TT_API3, "TERMSRV: RpcCheckClientAccess, AccessCheckAndAuditAlarm(%u) returned no error \n",
                      pWinStation->LogonId));
            Status = STATUS_SUCCESS;
        }
    }
    else
    {
        Status = NtCurrentTeb()->LastStatusValue;
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: RpcCheckClientAccess, AccessCheckAndAuditAlarm(%u) failed 0x%x\n",
                  pWinStation->LogonId, Status ));
    }

    return (Status);
}

/*****************************************************************************
 *
 *  _CheckConnectAccess
 *
 *   Check for connect access to the WINSTATION.
 *
 *   This is called under RPC context.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

_CheckConnectAccess(
    PWINSTATION pSourceWinStation,
    PSID   pClientSid,
    ULONG  ClientLogonId,
    PWCHAR pPassword,
    DWORD  PasswordSize
    )
{
    NTSTATUS Status;
    BOOLEAN fWrongPassword;
    UNICODE_STRING PasswordString;

    /*
     * First check that the current RPC caller has WINSTATION_CONNECT access
     * to the target WINSTATIONS object. This is controlled by either the
     * default, or per WINSTATION ACL setup from the registry.
     */
    Status = RpcCheckClientAccess( pSourceWinStation, WINSTATION_CONNECT, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        /*
         *  clear the password parameter to prevent it being paged cleartext
         */
        RtlZeroMemory( pPassword, wcslen(pPassword) * sizeof(WCHAR) );
        return( Status );
    }

   //
   // C2 WARNING - WARNING - WARNING
   //
   // Comments by JohnR 01/21/97 - The design of this feature was redone.
   //
   // There was legacy code which has WinLogon store the users password
   // scrambled in the PWINSTATION structure for all users to support
   // the feature in which a user logged on as account User1 may type the
   // "connect <winstation>" command, in which the disconnected winstation
   // logged in as account User2 may be connected to, if the proper account
   // password is supplied from the command line. The password verification
   // was a simple string compare between the winstations stored password,
   // and the password supplied by the caller.
   //
   // The problems with this are many:
   //
   // - LSA should do all authentication. The password may have
   //   been changed, or the account disabled. Also all authentication
   //   code must be in a centralized location.
   //
   // - The Logon Hours may have expired on the account. Another violation
   //   of policy.
   //
   // - No auditing is performed on failure, in violation of
   //   security policy.
   //
   // - The users password, though scrambled, is passed around the
   //   system in code not explicitly designed to handle user authentication.
   //   This code is not known, or registered with LSA as an authentication
   //   provider. Network redirectors, WinLogon, etc. do this registration.
   //
   //
   // FIX that was be done:
   //
   // The users password is no longer set in the PWINSTATION
   // by WinLogon. When a user wants to do a "connect <winstation>",
   // the account name and password of the winstation to connect to
   // is passed to LSA as a normal authentication. This means that
   // ICASRV.EXE is properly registered as a logon provider. If the
   // account and password is valid, a token is returned. This token
   // can then be closed, and the user connected to the winstation.
   // If failure, return the access denied error. The benefits are:
   //
   // - LSA authentication
   // - ICASRV registration as a logon provider
   // - Auditing
   // - Password change, account disable handling
   // - Logon hours enforcement
   // - Password no longer passed around the system
   //
   //
   // C2 WARNING
   //
   // Even with this routine using LSA, the WinFrame connect.exe command
   // could be trojan horsed. It is not in the trusted path. At least it is
   // a system utility that users should not allow writing to. Though a user
   // has to watch their %PATH%. A better design would be for the connect
   // commands function to be part of the WinLogon's GINA screen like our
   // current Disconnect... option. This will keep the password gathering
   // in the trusted path. But this is no worse than "net.exe", WinFile, etc.,
   // or anything else that asks for a network resource password.
   //
   // C2 WARNING - WARNING - WARNING
   //

    /*
     *  If different username/domain check the password by calling LogonUser()
     */
     // SALIMC CHANGE
    if ( pSourceWinStation->pUserSid && !RtlEqualSid( pClientSid, pSourceWinStation->pUserSid ) &&  
         !RtlEqualSid( pClientSid, gSystemSid ) ) {

        HANDLE hToken;
        BOOL   Result;

        Result = LogonUser(
                     pSourceWinStation->UserName,
                     pSourceWinStation->Domain,
                     pPassword,
                     LOGON32_LOGON_INTERACTIVE, // Logon Type
                     LOGON32_PROVIDER_DEFAULT,  // Logon Provider
                     &hToken                    // Token that represents the account
                     );

        /*
         *  clear the password parameter to prevent it being paged cleartext
         */
        RtlZeroMemory( pPassword, wcslen(pPassword) * sizeof(WCHAR) );

        /*
         *  check for account restriction which indicates a blank password
         *  on the account that is correct though - allow this thru on console
         */
        if( !Result && (PasswordSize == sizeof(WCHAR)) && (GetLastError() == ERROR_ACCOUNT_RESTRICTION) && (USER_SHARED_DATA->ActiveConsoleId == ClientLogonId)) {
            return( STATUS_SUCCESS );
        }
        if( !Result) {
            DBGPRINT(("TERMSRV: _CheckConnectAccess: User Account %ws\\%ws not valid %d\n",pSourceWinStation->Domain,pSourceWinStation->UserName,GetLastError()));
            return( STATUS_LOGON_FAILURE );
        }

        /*
         * Close the token handle since we only needed to determine
         * if the account and password is still valid.
         */
        CloseHandle( hToken );

        return( STATUS_SUCCESS );
    }
    else {
        return( STATUS_SUCCESS );
    }

    // NOTREACHED
}

/*****************************************************************************
 *
 *  RpcCheckSystemClient
 *
 *   Inquire in the current RPC call context whether we were
 *   called by a local SYSTEM mode caller.
 *
 *   WinStation API's that are only to be called by the WinLogon
 *   process call this function.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
RpcCheckSystemClient(
    ULONG TargetLogonId
    )
{
    NTSTATUS    Status;
    PWINSTATION pWinStation;

    pWinStation = FindWinStationById( TargetLogonId, FALSE );
    if ( pWinStation == NULL ) {
        return( STATUS_CTX_WINSTATION_NOT_FOUND );
    }

    Status = RpcCheckSystemClientEx( pWinStation );

    ReleaseWinStation( pWinStation );

    return( Status );
}

/*****************************************************************************
 *
 *  RpcCheckSystemClientEx
 *
 *   Inquire in the current RPC call context whether we were
 *   called by a local SYSTEM mode caller.
 *
 *   WinStation API's that are only to be called by the WinLogon
 *   process call this function.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
RpcCheckSystemClientEx(
    PWINSTATION pWinStation
    )
{
    ULONG ClientLogonId;
    RPC_STATUS RpcStatus;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = RpcCheckSystemClientNoLogonId( pWinStation );
    if( !NT_SUCCESS(Status) ) {
        return( Status);
    }

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        return( STATUS_CANNOT_IMPERSONATE );
    }

    /*
     * Check that the LogonId of the client is the same
     * as the LogonId of the WINSTATION being targeted.
     */
    Status = RpcGetClientLogonId( &ClientLogonId );
    if( !NT_SUCCESS(Status) ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Could not get clients LogonId 0x%x\n",Status));
        RpcRevertToSelf();
        return( STATUS_ACCESS_DENIED );
    }

    if( ClientLogonId != pWinStation->LogonId ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Caller LogonId %d does not match target %d\n",ClientLogonId,pWinStation->LogonId));
        RpcRevertToSelf();
        return( STATUS_ACCESS_DENIED );
    }

    RpcRevertToSelf();

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  RpcCheckSystemClientNoLogonId
 *
 *   Inquire in the current RPC call context whether we were
 *   called by a local SYSTEM mode caller.
 *
 *   WinStation API's that are only to be called by the WinLogon
 *   process call this function.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
RpcCheckSystemClientNoLogonId(
    PWINSTATION pWinStation
    )
{
    UINT  LocalFlag;
    RPC_STATUS RpcStatus;
    RPC_AUTHZ_HANDLE Privs;
    PWCHAR pServerPrincName;
    ULONG AuthnLevel, AuthnSvc, AuthzSvc;
    NTSTATUS Status = STATUS_SUCCESS;


    /*
     * The following checking  is to keep from screwing up
     * the state due to attempts to invoke this local
     * only API remotely, across LogonId's, or from an application.
     */

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        return( STATUS_CANNOT_IMPERSONATE );
    }

    /*
     * Inquire if local RPC call
     */
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Could not query local client RpcStatus 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        return( STATUS_ACCESS_DENIED );
    }

    if( !LocalFlag ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Not a local client call\n"));
        RpcRevertToSelf();
        return( STATUS_ACCESS_DENIED );
    }

#ifdef notdef
    // This is not working in 4.0. Its not returning
    // the principle name on the LPC transport.
    // So we resort to looking into the thread token.

    /*
     * Get the principle name, and see if its the built in LSA
     * local account "SYSTEM".
     */
    RpcStatus = RpcBindingInqAuthClientW(
                    0,    // Active RPC call we are servicing
                    &Privs,
                    &pServerPrincName,
                    &AuthnLevel,
                    &AuthnSvc,
                    &AuthzSvc
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT(("TERMSRV: RpcCheckSystemClient RpcAuthorizaton query failed! RpcStatus 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        return( STATUS_ACCESS_DENIED );
    }

    TRACE0(("TERMSRV: AuthnLevel %d, AuthnSvc %d, AuthzSvc %d pServerPrincName 0x%x, Privs 0x%x\n",AuthnLevel,AuthnSvc,AuthzSvc,pServerPrincName,Privs));

    if( AuthnSvc != RPC_C_AUTHN_WINNT ) {
        DBGPRINT(("TERMSRV: RpcCheckSystemClient RpcAuthorizaton Type not NT! 0x%x\n",AuthnSvc));
        RpcRevertToSelf();
        Status = STATUS_ACCESS_DENIED;
    }

    if( pServerPrincName ) {
        TRACE0(("TERMSRV: RpcCheckSystemClient: Principle Name :%ws:\n",pServerPrincName));

        // Compare with "SYSTEM"
        if( wcsicmp( L"SYSTEM", pServerPrincName ) ) {
            DBGPRINT(("TERMSRV: RpcCheckSystemClient: Principle Name :%ws: not SYSTEM\n",pServerPrincName));
            Status = STATUS_ACCESS_DENIED;
        }

        RpcStringFreeW( &pServerPrincName );
    }
#else
    /*
     * Validate that the thread token is SYSTEM
     */

    if( !IsCallerSystem() ) {
        Status = STATUS_ACCESS_DENIED;
    }
#endif

    RpcRevertToSelf();

    return( Status );
}



/*****************************************************************************
 *
 *  RpcCheckClientAccessLocal
 *
 *   Inquire in the current RPC call context whether we were
 *   called by a local caller.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
RpcCheckClientAccessLocal(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    )
{
    UINT  LocalFlag;
    RPC_STATUS RpcStatus;
    RPC_AUTHZ_HANDLE Privs;
    PWCHAR pServerPrincName;
    ULONG AuthnLevel, AuthnSvc, AuthzSvc;
    NTSTATUS Status;

    /*
     * Impersonate the client, if not already
     */
    if ( !AlreadyImpersonating ) {
        RpcStatus = RpcImpersonateClient( NULL );
        if ( RpcStatus != RPC_S_OK ) {
            DBGPRINT(("TERMSRV: RpcCheckClientAccessLocal: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
            return( STATUS_CANNOT_IMPERSONATE );
        }
    }

    /*
     * Check for desired access. This will generate an access audit if on.
     */
    Status = RpcCheckClientAccess( pWinStation, DesiredAccess, TRUE );
    if ( !NT_SUCCESS( Status ) ) {
        if ( !AlreadyImpersonating ) {
            RpcRevertToSelf();
        }
        return( Status );
    }

    /*
     * We have now checked security on the WINSTATION, the
     * rest of the checking is to keep from screwing up
     * the state due to attempts to invoke this local
     * only API remotely.
     */

    /*
     * Inquire if local RPC call
     */
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if ( !AlreadyImpersonating ) {
        RpcRevertToSelf();
    }

    if ( RpcStatus != RPC_S_OK ) {
        DBGPRINT(("TERMSRV: RpcCheckClientAccessLocal: Could not query local client RpcStatus 0x%x\n",RpcStatus));
        return( STATUS_ACCESS_DENIED );
    }

    if ( !LocalFlag ) {
        DBGPRINT(("TERMSRV: RpcCheckClientAccessLocal: Not a local client call\n"));
        return( STATUS_ACCESS_DENIED );
    }

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  AddUserAce
 *
 *   Add an ACE for the currently logged on user to the WinStation object.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to update
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
AddUserAce( PWINSTATION pWinStation )
{
    PACL Dacl = NULL;
    BOOLEAN DaclPresent, DaclDefaulted;
    ACL_SIZE_INFORMATION AclInfo;
    ULONG Length;
    NTSTATUS Status;

    /*
     * Get a pointer to the DACL from the security descriptor.
     */
    Status = RtlGetDaclSecurityDescriptor( pWinStation->pSecurityDescriptor, &DaclPresent,
                                           &Dacl, &DaclDefaulted );
    if ( !NT_SUCCESS( Status ) || !DaclPresent || !Dacl ) {

        return( Status );
    }

    Status = RtlAddAccessAllowedAce( Dacl, ACL_REVISION,
                                     (WINSTATION_ALL_ACCESS) & ~(STANDARD_RIGHTS_ALL),
                                     pWinStation->pUserSid );

    if ( (Status == STATUS_ALLOTTED_SPACE_EXCEEDED) || (Status == STATUS_REVISION_MISMATCH) )
    {
        //
        // We need to copy the security data into a new descriptor
        //
        Status = RtlQueryInformationAcl( Dacl, &AclInfo, sizeof(AclInfo),
                                         AclSizeInformation );
        if ( NT_SUCCESS( Status ) )
        {
            ULONG AceCount;
            PRTL_ACE_DATA pAceData;
            PACE_HEADER pAce;
            ULONG i;
            PSECURITY_DESCRIPTOR pSD;
            PSID Owner, Group;
            PSID * pSidList;

            BOOLEAN OwnerDefaulted, GroupDefaulted;

            AceCount = AclInfo.AceCount;
            AceCount++;
            //
            // allocate a RTL_ACE_DATA structure and a list of pPSIDs
            //
            Length = AceCount * sizeof(RTL_ACE_DATA);
            pAceData = MemAlloc(Length);
            if (!pAceData)
            {
                return (STATUS_NO_MEMORY);
            }

            Length = AceCount * sizeof(PSID *);
            pSidList = MemAlloc(Length);
            if (!pSidList)
            {
                MemFree(pAceData);
                return (STATUS_NO_MEMORY);
            }

            for ( i = 0; i < AclInfo.AceCount; i++ )
            {
                Status = RtlGetAce( Dacl, i, &pAce );
                ASSERT( NT_SUCCESS( Status ) );
                if (!NT_SUCCESS( Status ))
                {
                    MemFree(pAceData);
                    MemFree(pSidList);
                    return STATUS_INVALID_SECURITY_DESCR;
                }

                pAceData[i].AceType = pAce->AceType;
                pAceData[i].InheritFlags = 0;
                pAceData[i].AceFlags = 0;

                switch (pAce->AceType)
                {
                case ACCESS_ALLOWED_ACE_TYPE:

                    pAceData[i].Mask = ((PACCESS_ALLOWED_ACE)pAce)->Mask;

                    pSidList[i] = (PSID)(&(((PACCESS_ALLOWED_ACE)pAce)->SidStart));
                    break;

                case ACCESS_DENIED_ACE_TYPE:

                    pAceData[i].Mask = ((PACCESS_DENIED_ACE)pAce)->Mask;

                    pSidList[i] = (PSID)(&(((PACCESS_DENIED_ACE)pAce)->SidStart));
                    pAceData[i].Sid = (PSID *)(&(pSidList[i]));
                    break;

                default:        // we do not expect anything else

                    MemFree(pAceData);
                    MemFree(pSidList);
                    return STATUS_INVALID_SECURITY_DESCR;
                }
                pAceData[i].Sid = (PSID *)(&(pSidList[i]));
            }
            //
            // add the new ACE
            //
            pAceData[i].AceType = ACCESS_ALLOWED_ACE_TYPE;
            pAceData[i].InheritFlags = 0;
            pAceData[i].AceFlags = 0;
            pAceData[i].Mask = (WINSTATION_ALL_ACCESS) & ~(STANDARD_RIGHTS_ALL);
            pAceData[i].Sid = &(pWinStation->pUserSid);

            //
            // get the owner and the group
            //
            Status = RtlGetOwnerSecurityDescriptor(pWinStation->pSecurityDescriptor,
                                                   &Owner,
                                                   &OwnerDefaulted);
            Status = RtlGetOwnerSecurityDescriptor(pWinStation->pSecurityDescriptor,
                                                   &Group,
                                                   &GroupDefaulted);
            //
            // save the old security descriptor
            //
            pSD = pWinStation->pSecurityDescriptor;

            //
            // create the new security descriptor
            //
            Status = RtlCreateUserSecurityObject(pAceData,
                                                 AceCount,
                                                 Owner,
                                                 Group,
                                                 FALSE,
                                                 &WinStaMapping,
                                                 &(pWinStation->pSecurityDescriptor) );
            //
            // delete the old security descriptor
            //
            //RtlDeleteSecurityObject( &pSD );
            // must break up into absolute format and self-relative
            if (pSD) {
               CleanUpSD(pSD);
            }
            //
            // free the RTL_ACE_DATA
            //
            MemFree(pAceData);
            MemFree(pSidList);
        }
    }
    return( Status );

}


/*******************************************************************************
 *
 *  RemoveUserAce
 *
 *   Remove the ACE for the currently logged on user from the WinStation object.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to update
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
RemoveUserAce( PWINSTATION pWinStation )
{
    SECURITY_INFORMATION SecInfo = DACL_SECURITY_INFORMATION;
    PACL Dacl;
    BOOLEAN DaclPresent, DaclDefaulted;
    ACL_SIZE_INFORMATION AclInfo;
    PACE_HEADER Ace;
    ULONG i, Length;
    NTSTATUS Status;

    /*
     * This is probably the console if ICASRV wasn't started soon enough
     * 
     */
    if ( !pWinStation->pUserSid ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
    }
    else
    {
        Status = RtlGetDaclSecurityDescriptor( pWinStation->pSecurityDescriptor, &DaclPresent,
                                               &Dacl, &DaclDefaulted );
        if ( !NT_SUCCESS( Status ) || !DaclPresent || !Dacl ) {
            return( Status );
        }

        Status = RtlQueryInformationAcl( Dacl, &AclInfo, sizeof(AclInfo),
                                        AclSizeInformation );
        if ( !NT_SUCCESS( Status ) ) {
            return( Status );
        }

        /*
         * Scan the DACL looking for the ACE that contains the UserSid (it should
         * be first), delete the ACE, and set the new security for the WinStation.
         */
        for ( i = 0; i < AclInfo.AceCount; i++ ) {
            RtlGetAce( Dacl, i, &Ace );
            if ( RtlEqualSid( pWinStation->pUserSid,
                              &((PACCESS_ALLOWED_ACE)Ace)->SidStart ) ) {
                RtlDeleteAce( Dacl, i );
                break;
            }
        }
    }
    return( Status );
}

/*******************************************************************************
 *
 *  ApplyWinStaMappingToSD
 *
 *   Apply the generic mapping on the security descriptor.
 *
 * ENTRY:
 *    pSecurityDescriptor
 *       Pointer to security descriptor to update
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
ApplyWinStaMappingToSD( PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
    PACL Dacl;
    BOOLEAN DaclPresent, DaclDefaulted;
    ACL_SIZE_INFORMATION AclInfo;
    PACE_HEADER Ace;
    ULONG i;
    NTSTATUS Status;

    Status = RtlGetDaclSecurityDescriptor( pSecurityDescriptor, &DaclPresent,
                                           &Dacl, &DaclDefaulted );
    if ( !NT_SUCCESS( Status ) || !DaclPresent || !Dacl ) {
        return( Status );
    }

    Status = RtlQueryInformationAcl( Dacl, &AclInfo, sizeof(AclInfo),
                                    AclSizeInformation );
    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
    }

    /*
     * Scan the DACL applying the generic mapping to each ACE
     */
    for ( i = 0; i < AclInfo.AceCount; i++ ) {
        RtlGetAce( Dacl, i, &Ace );
        RtlApplyAceToObject( Ace, &WinStaMapping );
    }

    return( Status );
}

/*******************************************************************************
 *
 *  ApplyWinStaMapping
 *
 *   Apply the generic mapping on the security descriptor of the WinStation object.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to update
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
ApplyWinStaMapping( PWINSTATION pWinStation )
{
    return (ApplyWinStaMappingToSD(pWinStation->pSecurityDescriptor));
}



/*****************************************************************************
 *
 *  BuildEveryOneAllowSD
 *
 *   Build and return an EveryOne (WORLD) allow Security descriptor.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PSECURITY_DESCRIPTOR
BuildEveryOneAllowSD()
{
    BOOL  rc;
    DWORD Error;
    DWORD AclSize;
    PACL  pAcl = NULL;
    PACCESS_ALLOWED_ACE pAce = NULL;
    PSECURITY_DESCRIPTOR pSd = NULL;

    PSID  SeWorldSid = NULL;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;

    pSd = LocalAlloc(LMEM_FIXED, sizeof(SECURITY_DESCRIPTOR) );
    if( pSd == NULL ) {
        return( NULL );
    }

    rc = InitializeSecurityDescriptor( pSd, SECURITY_DESCRIPTOR_REVISION );
    if( !rc ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"Error initing security descriptor %d\n",GetLastError()));
        LocalFree( pSd );
        return( NULL );
    }

    SeWorldSid = (PSID)LocalAlloc(LMEM_FIXED, RtlLengthRequiredSid(1) );
    if( SeWorldSid == NULL ) {
        LocalFree( pSd );
        return( NULL );
    }

    RtlInitializeSid( SeWorldSid, &WorldSidAuthority, 1 );
    *(RtlSubAuthoritySid( SeWorldSid, 0 ))        = SECURITY_WORLD_RID;

    /*
     * Calculate the ACL size
     */
    AclSize = sizeof(ACL);
    AclSize += sizeof(ACCESS_ALLOWED_ACE);
    AclSize += (GetLengthSid( SeWorldSid ) - sizeof(DWORD));

    pAcl = LocalAlloc( LMEM_FIXED, AclSize );
    if( pAcl == NULL ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"Could not allocate memory\n"));
        LocalFree( SeWorldSid );
        LocalFree( pSd );
        return( NULL );
    }

    rc = InitializeAcl(
             pAcl,
             AclSize,
             ACL_REVISION
             );

    if( !rc ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"Error %d InitializeAcl\n",GetLastError()));
        LocalFree( pAcl );
        LocalFree( SeWorldSid );
        LocalFree( pSd );
        return( NULL );
    }

    /*
     * Add the access allowed ACE
     */
    rc = AddAccessAllowedAce(
                 pAcl,
                 ACL_REVISION,
                 FILE_ALL_ACCESS,
                 SeWorldSid
                 );

    if( !rc ) {
        Error = GetLastError();
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"***ERROR*** adding allow ACE %d for SeWorldSid\n",Error));
        LocalFree( pAcl );
        LocalFree( SeWorldSid );
        LocalFree( pSd );
        return( NULL );
    }

    rc = SetSecurityDescriptorDacl(
             pSd,
             TRUE,
             pAcl,
             FALSE
             );

    if( !rc ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"Error %d SetSecurityDescriptorDacl\n",GetLastError()));
        LocalFree( pAcl );
        LocalFree( SeWorldSid );
        LocalFree( pSd );
        return( NULL );
    }

// These are contained in the SD
//   LocalFree( pAcl );
//   LocalFree( SeWorldSid );

   // Caller can free SD
   return( pSd );
}


/*****************************************************************************
 *
 *  CreateWinStationDefaultSecurityDescriptor
 *
 *   Create the default security descriptor for WinStation for
 *   when we do not find one in the registry.
 *
 * ENTRY:   nothing
 *
 * EXIT:    a self-relative SD, or NULL
 *
 ****************************************************************************/

PSECURITY_DESCRIPTOR
CreateWinStationDefaultSecurityDescriptor()
{
    PSECURITY_DESCRIPTOR SecurityDescriptor;

#define DEFAULT_ACE_COUNT 2
    RTL_ACE_DATA AceData[DEFAULT_ACE_COUNT] =
    {
        { ACCESS_ALLOWED_ACE_TYPE, 0, 0, WINSTATION_ALL_ACCESS, &gSystemSid },

        { ACCESS_ALLOWED_ACE_TYPE, 0, 0, WINSTATION_ALL_ACCESS, &gAdminSid }

    };

    SecurityDescriptor = NULL;

    RtlCreateUserSecurityObject(AceData, DEFAULT_ACE_COUNT, gSystemSid,
            gSystemSid, FALSE, &WinStaMapping, &SecurityDescriptor);

    return( SecurityDescriptor );
}

/*****************************************************************************
 *
 *  BuildSystemOnlySecurityDescriptor
 *
 *   Create a security descriptor for system access only.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

PSECURITY_DESCRIPTOR
BuildSystemOnlySecurityDescriptor()
{
    PACL  Dacl;
    ULONG Length;
    NTSTATUS Status;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;

    Length = SECURITY_DESCRIPTOR_MIN_LENGTH +
             (ULONG)sizeof(ACL) +
             (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
             RtlLengthSid( gSystemSid );
    SecurityDescriptor = MemAlloc(Length);
    if (SecurityDescriptor == NULL) {
        goto bsosderror;
    }

    Dacl = (PACL)((PCHAR)SecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);

    Status = RtlCreateSecurityDescriptor(SecurityDescriptor,
                                         SECURITY_DESCRIPTOR_REVISION);
    if (Status != STATUS_SUCCESS) {
        goto bsosderror;
    }

    Status = RtlCreateAcl( Dacl, Length - SECURITY_DESCRIPTOR_MIN_LENGTH,
                           ACL_REVISION2);
    if (Status != STATUS_SUCCESS) {
        goto bsosderror;
    }

    Status = RtlAddAccessAllowedAce (
                 Dacl,
                 ACL_REVISION2,
                 PORT_ALL_ACCESS,
                 gSystemSid
                 );
    if (Status != STATUS_SUCCESS) {
        goto bsosderror;
    }

    Status = RtlSetDaclSecurityDescriptor (
                 SecurityDescriptor,
                 TRUE,
                 Dacl,
                 FALSE
                 );

    if (Status != STATUS_SUCCESS) {
        goto bsosderror;
    }

    return( SecurityDescriptor );

bsosderror:
    if (SecurityDescriptor) {
        MemFree(SecurityDescriptor);
    }

    return(NULL);
}

/*****************************************************************************
 *
 *  RpcGetClientLogonId
 *
 *   Get the logonid from the client who we should be impersonating.
 *
 * ENTRY:
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
RpcGetClientLogonId(
    PULONG pLogonId
    )
{
    BOOL          Result;
    HANDLE        TokenHandle;
    ULONG         LogonId, ReturnLength;
    NTSTATUS      Status = STATUS_SUCCESS;

    //
    // We should be impersonating the client, so we will get the
    // LogonId from out token.
    //

    Result = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_QUERY,
                 FALSE,              // Use impersonation
                 &TokenHandle
                 );

    if( Result ) {

        //
        // Use the CITRIX extension to GetTokenInformation to
        // return the LogonId from the token.
        //
        // This identifies which WinStation is making this request.
        //

        Result = GetTokenInformation(
                     TokenHandle,
                     (TOKEN_INFORMATION_CLASS)TokenSessionId,
                     &LogonId,
                     sizeof(LogonId),
                     &ReturnLength
                     );

        if( Result ) {
#if DBG
            if( ReturnLength != sizeof(LogonId) ) {
                DbgPrint("TERMSRV: RpcGetClientLogonId GetTokenInformation: ReturnLength %d != sizeof(LogonId)\n", ReturnLength );
            }
#endif
            *pLogonId = LogonId;
        }
        else {
            DBGPRINT(("TERMSRV: Error getting token LogonId information %d\n", GetLastError()));
            Status = STATUS_NO_IMPERSONATION_TOKEN;
        }
        CloseHandle( TokenHandle );
    }
    else {
        TRACE0(("SYSLIB: Error opening token %d\n", GetLastError()));
        Status = STATUS_NO_IMPERSONATION_TOKEN;
    }

    return( Status );
}




/*****************************************************************************
 *
 *  IsServiceLoggedAsSystem
 *
 *   Returns whether the termsrv process is running under SYSTEM
 *   security.
 *
 * ENTRY:
 *   None
 *     Comments
 *
 * EXIT:
 *   TRUE if running under system account. FALSE otherwise
 *
 ****************************************************************************/


BOOL
IsServiceLoggedAsSystem( VOID )
{
    BOOL   Result;
    HANDLE TokenHandle;

    //
    // Open the process token and check if System token. 
    //


    Result = OpenProcessToken(
                 GetCurrentProcess(),
                 TOKEN_QUERY,
                 &TokenHandle
                 );
    if (!Result) {
        DBGPRINT(("TERMSRV: IsServiceLoggedAsSystem : Could not open process token %d\n",GetLastError()));
        return( FALSE );
    }

    Result = IsSystemToken(TokenHandle);
    return Result;

}




/*****************************************************************************
 *
 *  IsCallerSystem
 *
 *   Returns whether the current thread is running under SYSTEM
 *   security.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
IsCallerSystem( VOID )
{
    BOOL   Result;
    HANDLE TokenHandle;

    //
    // Open the thread token and check if System token. 
    //


    Result = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_QUERY,
                 FALSE,              // Use impersonation
                 &TokenHandle
                 );

    if( !Result ) {
        TRACE0(("TERMSRV: IsCallerSystem: Could not open thread token %d\n",GetLastError()));
        return( FALSE );
    }
    
    Result = IsSystemToken(TokenHandle);
    return Result;

}

/*****************************************************************************
 *
 *  IsSystemToken
 *
 *   Returns whether the current token is running under SYSTEM
 *   security.
 *
 * ENTRY:
 *   Param1 Thread or process token
 *     Comments
 *
 * EXIT:
 *   TRUE if System token. FALSE otherwise.
 *
 ****************************************************************************/

BOOL
IsSystemToken( HANDLE TokenHandle )
{
    BOOL   Result;
    ULONG  ReturnLength, BufferLength;
    NTSTATUS Status;
    PTOKEN_USER pTokenUser = NULL;



    //Get primary account SID from token and test if local system SID.

    if (gSystemSid == NULL) {
        return FALSE;
    }

    ReturnLength = 0;

    Result = GetTokenInformation(
                 TokenHandle,
                 TokenUser,
                 NULL,
                 0,
                 &ReturnLength
                 );

    if( ReturnLength == 0 ) {
        TRACE0(("TERMSRV: IsCallerSystem: Error %d Getting TokenInformation\n",GetLastError()));
        CloseHandle( TokenHandle );
        return( FALSE );
    }

    BufferLength = ReturnLength;

    pTokenUser = MemAlloc( BufferLength );
    if( pTokenUser == NULL ) {
        TRACE0(("TERMSRV: IsCallerSystem: Error allocating %d bytes memory\n",BufferLength));
        CloseHandle( TokenHandle );
        return( FALSE );
    }

    Result = GetTokenInformation(
                 TokenHandle,
                 TokenUser,
                 pTokenUser,
                 BufferLength,
                 &ReturnLength
                 );

    CloseHandle( TokenHandle );

    if( !Result ) {
        TRACE0(("TERMSRV: IsCallerSystem: Error %d Getting TokenInformation on buffer\n",GetLastError()));
        MemFree( pTokenUser );
        return( FALSE );
    }

    if( RtlEqualSid( pTokenUser->User.Sid, gSystemSid) ) {
        MemFree( pTokenUser );
        return( TRUE );
    }
    else {
#if DBGTRACE
        BOOL  OK;
        DWORD cDomain;
        DWORD cUserName;
        WCHAR Domain[256];
        WCHAR UserName[256];
        SID_NAME_USE UserSidType;

        cUserName = sizeof(UserName)/sizeof(WCHAR);
        cDomain = sizeof(Domain)/sizeof(WCHAR);

        // Now print its account
        OK = LookupAccountSidW(
                 NULL, // Computer Name
                 pTokenUser->User.Sid,
                 UserName,
                 &cUserName,
                 Domain,
                 &cDomain,
                 &UserSidType
                 );

        DBGPRINT(("TERMSRV: IsCallerSystem: Caller SID is not SYSTEM\n"));

        if( OK ) {
            DBGPRINT(("TERMSRV: IsCallerSystem: CallerAccount Name %ws, Domain %ws, Type %d, SidSize %d\n",UserName,Domain,UserSidType));
        }
        else {
            extern void CtxDumpSid( PSID, PCHAR, PULONG ); // syslib:dumpsd.c

            DBGPRINT(("TERMSRV: Could not lookup callers account Error %d\n",GetLastError()));
            CtxDumpSid( pTokenUser->User.Sid, NULL, NULL );
        }
#else
        TRACE0(("TERMSRV: IsCallerSystem: Caller SID is not SYSTEM\n"));
#endif
        MemFree( pTokenUser );
        return( FALSE );
    }

    // NOTREACHED
}


/*****************************************************************************
 *
 *  IsCallerAdmin
 *
 *   Returns whether the current thread is running under SYSTEM
 *   security.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
IsCallerAdmin( VOID )
{
    BOOL   FoundAdmin;
    NTSTATUS Status;

    //
    //  If the admin sid didn't initialize, the service would not have started.
    //

    ASSERT(gAdminSid != NULL);

    if (!CheckTokenMembership(NULL, gAdminSid, &FoundAdmin)) {
        FoundAdmin = FALSE;
    }

#if DBG
    if (!FoundAdmin)
    {
        DBGPRINT(("TERMSRV: IsCallerAdmin: Caller SID is not ADMINISTRATOR\n"));
    }
#endif

    return(FoundAdmin);
}

/*******************************************************************************
 *
 *  IsCallerAllowedPasswordAccess
 *
 *  Is the calling process allowed to view the password field?
 *
 *     The caller must be SYSTEM context, IE: WinLogon.
 *
 * ENTRY:
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

BOOLEAN
IsCallerAllowedPasswordAccess()
{
    UINT  LocalFlag;
    RPC_STATUS RpcStatus;

    //
    // Only a SYSTEM mode caller (IE: Winlogon) is allowed
    // to query this value.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        RpcRevertToSelf();
        return( FALSE );
    }

    if( !LocalFlag ) {
        RpcRevertToSelf();
        return( FALSE );
    }

    if( !IsCallerSystem() ) {
        RpcRevertToSelf();
        return( FALSE );
    }

    RpcRevertToSelf();
    return( TRUE );
}

BOOL
ConfigurePerSessionSecurity(
    PWINSTATION pWinStation
    )

/*++

Routine Description:

    Configure security for the new session. This sets the
    per session \Sessions\<x>\BasedNamedObjects and
    \Sessions\<x>\DosDevices with an ACE that allows the
    currently logged on user to be able to create objects
    in their sessions directories.

    This is called by WinStationNotifyLogon() after the user
    has been authenticated. This must be called before the
    newly logged on user can create any WIN32 objects
    (events, semaphores, etc.), or DosDevices.

Arguments:

   Arg - desc

Return Value:

   NTSTATUS - STATUS_SUCCESS no error

   !STATUS_SUCCESS NT Status code

--*/

{
    BOOL Result;
    BOOL bRet = TRUE;
    DWORD Len;
    PWCHAR pBuf;
    WCHAR IdBuf[MAX_PATH];
    static ProtectionMode = 0;
    static GotProtectionMode = FALSE;
    PSID CreatorOwnerSid;
    PSID LocalSystemSid;
    SID_IDENTIFIER_AUTHORITY CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    


#define SESSIONS_ROOT L"\\Sessions\\"
#define BNO_PATH      L"\\BaseNamedObjects"
#define DD_PATH       L"\\DosDevices"

    //
    // We leave the consoles default NT permissions
    // alone.
    //
    if( pWinStation->LogonId == 0 ) {
        return TRUE;
    }

    // Get the Protection mode from Session Manager\ProtectionMode
    if( !GotProtectionMode ) {

        HANDLE KeyHandle;
        NTSTATUS Status;
        ULONG ResultLength;
        WCHAR ValueBuffer[ 32 ];
        UNICODE_STRING NameString;
        OBJECT_ATTRIBUTES ObjectAttributes;
        PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;


        GotProtectionMode = TRUE;

        RtlInitUnicodeString( &NameString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager" );

        InitializeObjectAttributes(
            &ObjectAttributes,
            &NameString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = NtOpenKey(
                     &KeyHandle,
                     KEY_READ,
                     &ObjectAttributes
                     );

        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString( &NameString, L"ProtectionMode" );
            KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
            Status = NtQueryValueKey(
                         KeyHandle,
                         &NameString,
                         KeyValuePartialInformation,
                         KeyValueInformation,
                         sizeof( ValueBuffer ),
                         &ResultLength
                         );

            if (NT_SUCCESS(Status)) {
                if (KeyValueInformation->Type == REG_DWORD &&
                    *(PULONG)KeyValueInformation->Data) {
                    ProtectionMode = *(PULONG)KeyValueInformation->Data;
                }
            }

            NtClose( KeyHandle );
        }
    }

    // Nothing locked down
    if( (ProtectionMode & 0x00000003) == 0 ) {
        return TRUE;
    }

    wsprintf( IdBuf, L"%d", pWinStation->LogonId );

    Len = wcslen( IdBuf ) + wcslen( SESSIONS_ROOT ) + wcslen( BNO_PATH ) + 2;

    pBuf = LocalAlloc( LMEM_FIXED, Len*sizeof(WCHAR) );
    if( pBuf == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    wsprintf( pBuf, L"%s%s%s", SESSIONS_ROOT, IdBuf, BNO_PATH );

    Result = AddAccessToDirectory(
                 pBuf,
                 GENERIC_ALL,
                 pWinStation->pUserSid
                 );

    if( !Result ) bRet = FALSE;



    if (NT_SUCCESS(RtlAllocateAndInitializeSid(
                 &CreatorAuthority,
                 1,
                 SECURITY_CREATOR_OWNER_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &CreatorOwnerSid
                 ))) {

       Result = AddAccessToDirectory(
                    pBuf,
                    GENERIC_ALL,
                    CreatorOwnerSid
                    );

       if( !Result ) {
          bRet = FALSE;
       }

       RtlFreeSid( CreatorOwnerSid );

    }



    if (NT_SUCCESS(RtlAllocateAndInitializeSid(
                 &NtAuthority,
                 1,
                 SECURITY_LOCAL_SYSTEM_RID,
                 0, 0, 0, 0, 0, 0, 0,
                 &LocalSystemSid
                 ))) {

       Result = AddAccessToDirectory(
                    pBuf,
                    GENERIC_ALL,
                    LocalSystemSid
                    );

       if( !Result ) {
          bRet = FALSE;
       }

       RtlFreeSid( LocalSystemSid );

    }

    LocalFree( pBuf );

    Len = wcslen( IdBuf ) + wcslen( SESSIONS_ROOT ) + wcslen( DD_PATH ) + 2;

    pBuf = LocalAlloc( LMEM_FIXED, Len*sizeof(WCHAR) );
    if( pBuf == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    wsprintf( pBuf, L"%s%s%s", SESSIONS_ROOT, IdBuf, DD_PATH );

    Result = AddAccessToDirectory(
                 pBuf,
                 GENERIC_READ | GENERIC_EXECUTE,
                 pWinStation->pUserSid
                 );

    if( !Result ) bRet = FALSE;

    LocalFree( pBuf );

    return bRet;
}

BOOL
AddAccessToDirectory(
    PWCHAR pPath,
    DWORD  NewAccess,
    PSID   pSid
    )

/*++

Routine Description:

    Add Access to the given NT object directory path for
    the supplied SID.

    This is done by adding a new AccessAllowedAce to
    the DACL on the object directory.

Arguments:

   Arg - desc

Return Value:

   TRUE - Success

   FALSE - Error in GetLastError()

--*/

{
    BOOL Result;
    HANDLE hDir;
    NTSTATUS Status;
    ULONG LengthNeeded;
    OBJECT_ATTRIBUTES Obja;
    PSECURITY_DESCRIPTOR pSd,pSelfSD;
    PACL pDacl;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, pPath );

    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
        NULL,
        NULL // Sd
        );

    Status = NtCreateDirectoryObject(
                 &hDir,
                 DIRECTORY_ALL_ACCESS,
                 &Obja
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("AddAccessToDirectory: NtCreateDirectoryObject 0x%x :%ws:\n",Status,pPath));
        SetLastError(RtlNtStatusToDosError(Status));
        return FALSE;
    }


    // Get SD from sessions directory
    Status = NtQuerySecurityObject(
                 hDir,
                 OWNER_SECURITY_INFORMATION | 
                 GROUP_SECURITY_INFORMATION |
                 DACL_SECURITY_INFORMATION,
                 NULL,         // pSd
                 0,            // Length
                 &LengthNeeded
                 );

    // ? bad handle
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        DBGPRINT(("AddAccessToDirectory: NtQuerySecurityObject 0x%x :%ws:\n",Status,pPath));
        SetLastError(RtlNtStatusToDosError(Status));
        NtClose( hDir );
        return FALSE;
    }

    pSd = LocalAlloc(LMEM_FIXED, LengthNeeded );
    if( pSd == NULL ) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        NtClose( hDir );
        return FALSE;
    }

    Status = NtQuerySecurityObject(
                 hDir,
                 OWNER_SECURITY_INFORMATION | 
                 GROUP_SECURITY_INFORMATION |
                 DACL_SECURITY_INFORMATION,
                 pSd,
                 LengthNeeded,
                 &LengthNeeded
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("AddAccessToDirectory: NtQuerySecurityObject 0x%x :%ws:\n",Status,pPath));
        SetLastError(RtlNtStatusToDosError(Status));
        LocalFree( pSd );
        NtClose( hDir );
        return FALSE;
    }


    Result = AddAceToSecurityDescriptor(
                 &pSd,
                 &pDacl,
                 NewAccess,
                 pSid,
                 TRUE
                 );

    if( !Result ) {
        DBGPRINT(("AddAccessToDirectory: AddAceToSecurityDescriptor failure :%ws:\n",pPath));
        CleanUpSD(pSd);
        NtClose( hDir );
        return FALSE;
    }

    Result = AddAceToSecurityDescriptor(
                 &pSd,
                 &pDacl,
                 NewAccess,
                 pSid,
                 FALSE
                 );

    if( !Result ) {
        DBGPRINT(("AddAccessToDirectory: AddAceToSecurityDescriptor failure :%ws:\n",pPath));
        CleanUpSD(pSd);
        NtClose( hDir );
        return FALSE;
    }
    
    Result = FALSE;
    // make sure that pSd is not self-relative already
    if (!(((PISECURITY_DESCRIPTOR)pSd)->Control & SE_SELF_RELATIVE)) {
       Result = AbsoluteToSelfRelativeSD (pSd, &pSelfSD, NULL);
       CleanUpSD(pSd);
       if ( !Result ) {
          NtClose( hDir);
          return FALSE;
       }
    }

    // Put a self-relative SD on session directory (note only self-relative sd are allowed)
    Status = NtSetSecurityObject(
                 hDir,
                 DACL_SECURITY_INFORMATION,
                 pSelfSD
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("AddAccessToDirectory: NtSetSecurityObject 0x%x :%ws:\n",Status,pPath));
        SetLastError(RtlNtStatusToDosError(Status));
        CleanUpSD(pSelfSD);
        NtClose( hDir );
        return FALSE;
    }

    // Result could only be false if the sd is already self-relative
    if (Result) {
       CleanUpSD(pSelfSD);
    }
    

    // Now update any objects in the directory already
    Status = AddAccessToDirectoryObjects(
        hDir,
        NewAccess,
        pSid
        
        );

    NtClose( hDir );

    // AddAccessToDirectoryObjects() may return out of memory.
    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
AddAceToSecurityDescriptor(
    PSECURITY_DESCRIPTOR *ppSd,
    PACL                 *ppDacl,
    DWORD                Access,
    PSID                 pSid,
    BOOLEAN              InheritOnly
    )

/*++

Routine Description:

   Adds the given ACE/SID to the security descriptor. It will
   re-allocate the security descriptor if more room is needed.

Arguments:

   ppSD - Pointer to PSECURITY_DESCRIPTOR

   ppDacl - Pointer to PACL, returns the newly created DACL for freeing
            after the security has been set.

   Access - Access mask for ACE

   pSid - Pointer to Sid this ACE is representing

Return Value:

   TRUE  - Success
   FALSE - Error

--*/

{
    ULONG i;
    BOOL Result;
    BOOL DaclPresent;
    BOOL DaclDefaulted;
    DWORD Length;
    DWORD NewAceLength, NewAclLength;
    PACE_HEADER OldAce;
    PACE_HEADER NewAce;
    ACL_SIZE_INFORMATION AclInfo;
    PACL Dacl = NULL;
    PACL NewDacl = NULL;
    PACL NewAceDacl = NULL;
    PSECURITY_DESCRIPTOR NewSD = NULL;
    PSECURITY_DESCRIPTOR OldSD = NULL;
    BOOL SDAllocated = FALSE;

    OldSD = *ppSd;
    *ppDacl = NULL;

    /*
     * Convert SecurityDescriptor to absolute format. It generates
     * a new SecurityDescriptor for its output which we must free.
     */

    if (((PISECURITY_DESCRIPTOR)OldSD)->Control & SE_SELF_RELATIVE) {

        Result = SelfRelativeToAbsoluteSD( OldSD, &NewSD, NULL );
        if ( !Result ) {
            DBGPRINT(("Could not convert to AbsoluteSD %d\n",GetLastError()));
            return( FALSE );
        }
        SDAllocated = TRUE;

    } else {
    
        NewSD = OldSD;
    }
    // Must get DACL pointer again from new (absolute) SD
    Result = GetSecurityDescriptorDacl(
                 NewSD,
                 &DaclPresent,
                 &Dacl,
                 &DaclDefaulted
                 );
    if( !Result ) {
        DBGPRINT(("Could not get Dacl %d\n",GetLastError()));
        goto ErrorCleanup;
    }

    //
    // If no DACL, no need to add the user since no DACL
    // means all accesss
    //
    if( !DaclPresent ) {
        DBGPRINT(("SD has no DACL, Present %d, Defaulted %d\n",DaclPresent,DaclDefaulted));
        if (SDAllocated && NewSD) {
           CleanUpSD(NewSD);
        }
        return( TRUE );
    }

    //
    // Code can return DaclPresent, but a NULL which means
    // a NULL Dacl is present. This allows no access to the object.
    //
    if( Dacl == NULL ) {
        DBGPRINT(("SD has NULL DACL, Present %d, Defaulted %d\n",DaclPresent,DaclDefaulted));
        goto ErrorCleanup;
    }

    // Get the current ACL's size
    Result = GetAclInformation(
                 Dacl,
                 &AclInfo,
                 sizeof(AclInfo),
                 AclSizeInformation
                 );
    if( !Result ) {
        DBGPRINT(("Error GetAclInformation %d\n",GetLastError()));
        goto ErrorCleanup;
    }

    //
    // Create a new ACL to put the new access allowed ACE on
    // to get the right structures and sizes.
    //
    NewAclLength = sizeof(ACL) +
                   sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) +
                   GetLengthSid( pSid );

    NewAceDacl = LocalAlloc( LMEM_FIXED, NewAclLength );
    if ( NewAceDacl == NULL ) {
        DBGPRINT(("Error LocalAlloc %d bytes\n",NewAclLength));
        goto ErrorCleanup;
    }

    Result = InitializeAcl( NewAceDacl, NewAclLength, ACL_REVISION );
    if( !Result ) {
        DBGPRINT(("Error Initializing Acl %d\n",GetLastError()));
        goto ErrorCleanup;
    }

    Result = AddAccessAllowedAce(
                 NewAceDacl,
                 ACL_REVISION,
                 Access,
                 pSid
                 );
    if( !Result ) {
        DBGPRINT(("Error adding Ace %d\n",GetLastError()));
        goto ErrorCleanup;
    }

    TRACE0(("Added 0x%x Access to ACL\n",Access));

    Result = GetAce( NewAceDacl, 0, &NewAce );
    if( !Result ) {
        DBGPRINT(("Error getting Ace %d\n",GetLastError()));
        goto ErrorCleanup;
    }

    /*
     * Allocate new DACL and copy existing ACE list
     */
    Length = AclInfo.AclBytesInUse + NewAce->AceSize;
    NewDacl = LocalAlloc( LMEM_FIXED, Length );
    if( NewDacl == NULL ) {
        DBGPRINT(("Error LocalAlloc %d bytes\n",Length));
        goto ErrorCleanup;
    }

    Result = InitializeAcl( NewDacl, Length, ACL_REVISION );
    if( !Result ) {
        DBGPRINT(("Error Initializing Acl %d\n",GetLastError()));
        goto ErrorCleanup;
    }


    if (InheritOnly) {
        /*
         * Make this an inherit ACE
         */
        NewAce->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
 
    } 

    /*
     * Insert new ACE at the front of the DACL
     */
    Result = AddAce( NewDacl, ACL_REVISION, 0, NewAce, NewAce->AceSize );
    if( !Result ) {
        DBGPRINT(("Error Adding New Ace to Acl %d\n",GetLastError()));
        goto ErrorCleanup;
    }

    /*
     * Now put the ACE's on the old Dacl to the new Dacl
     */
    for ( i = 0; i < AclInfo.AceCount; i++ ) {

        Result = GetAce( Dacl, i, &OldAce );
        if( !Result ) {
            DBGPRINT(("Error getting old Ace from Acl %d\n",GetLastError()));
            goto ErrorCleanup;
        }

        Result = AddAce( NewDacl, ACL_REVISION, i+1, OldAce, OldAce->AceSize );
        if( !Result ) {
            DBGPRINT(("Error setting old Ace to Acl %d\n",GetLastError()));
            goto ErrorCleanup;
        }
    }

    /*
     * Set new DACL for Security Descriptor
     */
    Result = SetSecurityDescriptorDacl(
                 NewSD,
                 TRUE,
                 NewDacl,
                 FALSE
                 );
    if( !Result ) {
        DBGPRINT(("Error setting New Dacl to SD %d\n",GetLastError()));
        goto ErrorCleanup;
    } 

    // NewSD is in absolute format and it's dacl is being replaced by NewDacl
    // thus it makes perfect sense to delete the old dacl
    if (Dacl) {
       LocalFree( Dacl );
    }

    // If we allocated the SD, release the callers old security descriptor,
    // otherwise, release the old SDs DACL.
    if (SDAllocated) {
       CleanUpSD(OldSD);
    }

    // Release the template Ace Dacl
    LocalFree( NewAceDacl );

    *ppSd = NewSD;
    *ppDacl = NewDacl;

    return( TRUE );


ErrorCleanup:

        if (NewDacl) {
           LocalFree( NewDacl );
        }
        if (NewAceDacl) {
           LocalFree( NewAceDacl );
        }
        if (SDAllocated && NewSD) {
           CleanUpSD( NewSD );
        }
        // If the SD wasn't allocated, and we got far enough to get a valid
        // DACL, free the DACL.
        if (Dacl) {
           LocalFree( Dacl );
        }
        return( FALSE );
}

BOOL
AbsoluteToSelfRelativeSD(
    PSECURITY_DESCRIPTOR SecurityDescriptorIn,
    PSECURITY_DESCRIPTOR *SecurityDescriptorOut,
    PULONG ReturnedLength
    )
/*++

Routine Description:

    Make a security descriptor self-relative

Return Value:

   TRUE - Success
   FALSE - Failure

--*/

{
    BOOL Result;
    PSECURITY_DESCRIPTOR pSD;
    DWORD dwLength = 0;

    /*
     * Determine buffer size needed to convert absolute to self-relative SD .
     * We use try-except here since if the input security descriptor value
     * is sufficiently messed up, it is possible for this call to trap.
     */
    try {
        Result = MakeSelfRelativeSD(
                     SecurityDescriptorIn,
                     NULL,
                     &dwLength);

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        Result = FALSE;
    }

    if ( Result || (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ) {
        DBGPRINT(("SUSERVER: AbsoluteToSelfRelativeSD, Error %d\n",GetLastError()));
        return( FALSE );
    }

    /*
     * Allocate memory for the self-relative SD
     */
    pSD = LocalAlloc( LMEM_FIXED, dwLength );
    if ( pSD == NULL )
        return( FALSE );

    /*
     * Now convert absolute SD to self-relative format.
     * We use try-except here since if the input security descriptor value
     * is sufficiently messed up, it is possible for this call to trap.
     */
    try {
        Result = MakeSelfRelativeSD(SecurityDescriptorIn,
                                    pSD, 
                                    &dwLength);

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        Result = FALSE;
    }

    if ( !Result ) {
        DBGPRINT(("SUSERVER: SelfRelativeToAbsoluteSD, Error %d\n",GetLastError()));
        LocalFree( pSD );
        return( FALSE );
    }

    *SecurityDescriptorOut = pSD;

    if ( ReturnedLength )
        *ReturnedLength = dwLength;

    return( TRUE );
}



BOOL
SelfRelativeToAbsoluteSD(
    PSECURITY_DESCRIPTOR SecurityDescriptorIn,
    PSECURITY_DESCRIPTOR *SecurityDescriptorOut,
    PULONG ReturnedLength
    )

/*++

Routine Description:

    Make a security descriptor absolute

Arguments:

   Arg - desc

Return Value:

   TRUE - Success
   FALSE - Failure

--*/

{
    BOOL Result;
    PACL pDacl, pSacl;
    PSID pOwner, pGroup;
    PSECURITY_DESCRIPTOR pSD;
    ULONG SdSize, DaclSize, SaclSize, OwnerSize, GroupSize;

    /*
     * Determine buffer size needed to convert self-relative SD to absolute.
     * We use try-except here since if the input security descriptor value
     * is sufficiently messed up, it is possible for this call to trap.
     */
    try {
        SdSize = DaclSize = SaclSize = OwnerSize = GroupSize = 0;
        Result = MakeAbsoluteSD(
                     SecurityDescriptorIn,
                     NULL, &SdSize,
                     NULL, &DaclSize,
                     NULL, &SaclSize,
                     NULL, &OwnerSize,
                     NULL, &GroupSize
                     );

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        Result = FALSE;
    }

    if ( Result || (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ) {
        DBGPRINT(("SUSERVER: SelfRelativeToAbsoluteSD, Error %d\n",GetLastError()));
        return( FALSE );
    }

    /*
     * Allocate memory for the absolute SD and setup various pointers
     */
    pSD = NULL;
    pDacl = NULL;
    pSacl = NULL;
    pOwner = NULL;
    pGroup = NULL;
    if (SdSize>0) {
       pSD = LocalAlloc( LMEM_FIXED, SdSize);
       if ( pSD == NULL )
          goto error;
    }

    if (DaclSize>0) {
       pDacl = LocalAlloc( LMEM_FIXED, DaclSize);
       if ( pDacl == NULL ){
          goto error;
       }
    }

    if (SaclSize>0) {
       pSacl = LocalAlloc( LMEM_FIXED, SaclSize);
       if ( pSacl == NULL ){
          goto error;
       }
    }

    if (OwnerSize>0) {
       pOwner = LocalAlloc( LMEM_FIXED, OwnerSize);
       if ( pOwner == NULL ){
          goto error;
       }
    }

    if (GroupSize>0) {
       pGroup = LocalAlloc( LMEM_FIXED, GroupSize);
       if ( pGroup == NULL ){
          goto error;
       }
    }

    //pDacl = (PACL)((PCHAR)pSD + SdSize);
    ///pSacl = (PACL)((PCHAR)pDacl + DaclSize);
    //pOwner = (PSID)((PCHAR)pSacl + SaclSize);
    //pGroup = (PSID)((PCHAR)pOwner + OwnerSize);

    /*
     * Now convert self-relative SD to absolute format.
     * We use try-except here since if the input security descriptor value
     * is sufficiently messed up, it is possible for this call to trap.
     */
    try {
        Result = MakeAbsoluteSD(
                     SecurityDescriptorIn,
                     pSD, &SdSize,
                     pDacl, &DaclSize,
                     pSacl, &SaclSize,
                     pOwner, &OwnerSize,
                     pGroup, &GroupSize
                     );

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        Result = FALSE;
    }

    if ( !Result ) {
        DBGPRINT(("SUSERVER: SelfRelativeToAbsoluteSD, Error %d\n",GetLastError()));
        goto error;
    }

    *SecurityDescriptorOut = pSD;

    if ( ReturnedLength )
        *ReturnedLength = SdSize + DaclSize + SaclSize + OwnerSize + GroupSize;

    return( TRUE );


error:
    if (pSD) {
       LocalFree(pSD);
    }
    if (pDacl) {
       LocalFree(pDacl);
    }
    if (pSacl) {
       LocalFree(pSacl);
    }
    if (pOwner) {
       LocalFree(pOwner);
    }
    if (pGroup) {
       LocalFree(pGroup);
    }
    return( FALSE );
}

VOID
CleanUpSD(
   PSECURITY_DESCRIPTOR pSD
   )
/*++

Routine Description:
   
   delete the security descriptor

Arguments:

   Arg - desc

Return Value:

   TRUE - Success

   FALSE - Error in GetLastError()

--*/
{

   if (pSD) {
      if (((PISECURITY_DESCRIPTOR)pSD)->Control & SE_SELF_RELATIVE){
         LocalFree( pSD );
      }else{
         ULONG_PTR Dacl,Owner,Group,Sacl;
         ULONG_PTR SDTop = (ULONG_PTR)pSD;
         ULONG_PTR SDBottom = LocalSize(pSD)+SDTop;

         Dacl  = (ULONG_PTR)((PISECURITY_DESCRIPTOR)pSD)->Dacl;
         Owner = (ULONG_PTR)((PISECURITY_DESCRIPTOR)pSD)->Owner;
         Group = (ULONG_PTR)((PISECURITY_DESCRIPTOR)pSD)->Group;
         Sacl  = (ULONG_PTR)((PISECURITY_DESCRIPTOR)pSD)->Sacl;

         // make sure that the dacl, owner, group, sacl are not within the SD boundary

         if (Dacl) {
            if (Dacl>=SDBottom|| Dacl<SDTop) {
               LocalFree(((PISECURITY_DESCRIPTOR)pSD)->Dacl);
            }
         }

         if (Owner) {
            if (Owner>=SDBottom || Owner<SDTop) {
               LocalFree(((PISECURITY_DESCRIPTOR)pSD)->Owner);
            }
         }
         
         if (Group) {
            if (Group>=SDBottom || Group<SDTop) {
               LocalFree(((PISECURITY_DESCRIPTOR)pSD)->Group);
            }
         }

         if (Sacl) {
            if (Sacl>=SDBottom || Sacl<SDTop) {
               LocalFree(((PISECURITY_DESCRIPTOR)pSD)->Sacl);
            }
         }

         LocalFree(pSD);
      }
   }

}


NTSTATUS
AddAccessToDirectoryObjects(
    HANDLE DirectoryHandle,
    DWORD  NewAccess,
    PSID   pSid
    )

/*++

Routine Description:

    Add Access to the objects in the given NT object directory
    for the supplied SID.

    This is done by adding a new AccessAllowedAce to the DACL's
    on the objects in the directory.

Arguments:

   Arg - desc

Return Value:

   TRUE - Success

   FALSE - Error in GetLastError()

--*/

{
    BOOL  Result;
    ULONG Context;
    HANDLE LinkHandle;
    NTSTATUS Status;
    BOOLEAN RestartScan;
    ULONG ReturnedLength;
    ULONG LengthNeeded;
    OBJECT_ATTRIBUTES Attributes;
    PSECURITY_DESCRIPTOR pSd,pSelfSD;
    PACL pDacl;
    POBJECT_DIRECTORY_INFORMATION pDirInfo;
    RestartScan = TRUE;
    Context = 0;
    
    pDirInfo = (POBJECT_DIRECTORY_INFORMATION) LocalAlloc(LMEM_FIXED, 4096  );

    if ( !pDirInfo)
    {
        return STATUS_NO_MEMORY;
    }

    while (TRUE) {
        Status = NtQueryDirectoryObject( DirectoryHandle,
                                         pDirInfo,
                                         4096 ,
                                         TRUE,
                                         RestartScan,
                                         &Context,
                                         &ReturnedLength
                                       );
        
        RestartScan = FALSE;

        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status )) {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            break;
        }

        // SymbolicLink
        if (!wcscmp( pDirInfo->TypeName.Buffer, L"SymbolicLink" )) {

            InitializeObjectAttributes(
                &Attributes,
                &pDirInfo->Name,
                OBJ_CASE_INSENSITIVE,
                DirectoryHandle,
                NULL
                );

            Status = NtOpenSymbolicLinkObject(
                         &LinkHandle,
                         SYMBOLIC_LINK_ALL_ACCESS,
                         &Attributes
                         );
        }
        else {
            continue;
        }

        if (!NT_SUCCESS( Status )) {
           continue;
        }

        // GetSecurity
        Status = NtQuerySecurityObject(
                     LinkHandle,
                     OWNER_SECURITY_INFORMATION | 
                     GROUP_SECURITY_INFORMATION |
                     DACL_SECURITY_INFORMATION,
                     NULL,         // pSd
                     0,            // Length
                     &LengthNeeded
                     );

        if( Status != STATUS_BUFFER_TOO_SMALL ) {
            DBGPRINT(("NtQuerySecurityObject 0x%x\n",Status));
            NtClose( LinkHandle );
            continue;
        }

        pSd = LocalAlloc(LMEM_FIXED, LengthNeeded );
        if( pSd == NULL ) {
            NtClose( LinkHandle );
            continue;
        }

        Status = NtQuerySecurityObject(
                     LinkHandle,
                     OWNER_SECURITY_INFORMATION | 
                     GROUP_SECURITY_INFORMATION |
                     DACL_SECURITY_INFORMATION,
                     pSd,          // pSd
                     LengthNeeded, // Length
                     &LengthNeeded
                     );

        if( !NT_SUCCESS(Status) ) {
            DBGPRINT(("NtQuerySecurityObject 0x%x\n",Status));
            NtClose( LinkHandle );
            LocalFree( pSd );
            continue;
        }

        // Mung ACL
        Result = AddAceToSecurityDescriptor(
                     &pSd,
                     &pDacl,
                     NewAccess,
                     pSid,
                     FALSE
                     );

        if( !Result ) {
            NtClose( LinkHandle );
            CleanUpSD(pSd);
            continue;
        }

        // make sure that pSd is not self-relative already.
        if (!(((PISECURITY_DESCRIPTOR)pSd)->Control & SE_SELF_RELATIVE)) {
           if (!AbsoluteToSelfRelativeSD (pSd, &pSelfSD, NULL)){
              NtClose( LinkHandle );
              CleanUpSD(pSd);
              continue;
           }
        }

        // SetSecurity only accepts self-relative formats
        Status = NtSetSecurityObject(
                     LinkHandle,
                     DACL_SECURITY_INFORMATION,
                     pSelfSD
                     );
 
        NtClose( LinkHandle );

        //
        //  These must be freed regardless of the success of
        //  NtSetSecurityObject
        //
        // pDacl lives inside of pSd
        CleanUpSD(pSd);
        CleanUpSD(pSelfSD);

    } // end while


    LocalFree( pDirInfo );

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *
 *  ReInitializeSecurityWorker
 *
 *  ReInitialize the default WinStation security descriptor and force all active
 * sessions to update their security descirptors
 *
 * ENTRY:
 *   nothing
 *
 * EXIT:
 *   STATUS_SUCCESS
 *
 ******************************************************************************/

NTSTATUS
ReInitializeSecurityWorker( VOID )
{
    NTSTATUS Status;
    ULONG WinStationCount;
    ULONG ByteCount;
    WINSTATIONNAME * pWinStationName;
    ULONG i;
    PWINSTATION pWinStation;



    /*
     * Update Default Security Descriptor
     */

    RtlAcquireResourceExclusive(&WinStationSecurityLock, TRUE);
    WinStationSecurityInit();
    RtlReleaseResource(&WinStationSecurityLock);




    /*
     *  Get the number of WinStations in the registry 
     */
    WinStationCount = 0;
    Status = IcaRegWinStationEnumerate( &WinStationCount, NULL, &ByteCount );
    if ( !NT_SUCCESS(Status) ) 
        return Status;

    /*
     *  Allocate a buffer for the WinStation names
     */
    pWinStationName = MemAlloc( ByteCount );
    if ( pWinStationName == NULL ) {
        return STATUS_NO_MEMORY;
    }

    /*
     * Get list of WinStation names from registry
     */
    WinStationCount = (ULONG) -1;
    Status = IcaRegWinStationEnumerate( &WinStationCount, 
                                        (PWINSTATIONNAME)pWinStationName, 
                                        &ByteCount );
    if ( !NT_SUCCESS(Status) ) {
        MemFree( pWinStationName );
        return Status;
    }


    /*
     *  Check if any WinStations need to be created or reset
     */
    for ( i = 0; i < WinStationCount; i++ ) {

        /*
         * Ignore console WinStation 
         */
        if ( _wcsicmp( pWinStationName[i], L"Console" ) ) {

            /*
             * If this WinStation exists, then see if the Registry data
             * has changed.  If so, then reset the WinStation.
             */
            if ( pWinStation = FindWinStationByName( pWinStationName[i], FALSE ) ) {


                    /*
                     * Winstations should update their security 
                     * descriptors.
                     */

                RtlAcquireResourceExclusive(&WinStationSecurityLock, TRUE);
                ReadWinStationSecurityDescriptor( pWinStation );
                RtlReleaseResource(&WinStationSecurityLock);
                    
                ReleaseWinStation( pWinStation );

            }
        }
    }

    /*
     *  Free buffers
     */
    MemFree( pWinStationName );

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\channel.c ===
/*************************************************************************
*
* channel.c
*
* WinStation channel routines
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

NTSTATUS
WinStationOpenChannel (
    HANDLE IcaDevice,
    HANDLE ProcessHandle,
    CHANNELCLASS ChannelClass,
    PVIRTUALCHANNELNAME pVirtualName,
    PHANDLE pDupChannel
   )

{
    NTSTATUS Status;
    HANDLE ChannelHandle;

    Status = IcaChannelOpen( IcaDevice,
                             ChannelClass,
                             pVirtualName,
                             &ChannelHandle );

    if ( !NT_SUCCESS( Status ) ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationOpenChannel, IcaChannelOpen 0x%x\n",
                  Status  ));
        return Status;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                ChannelHandle,
                                ProcessHandle,
                                pDupChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );

    if ( !NT_SUCCESS( Status ) ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationOpenChannel, NtDuplicateObject 0x%x\n",
                  Status  ));
        (void) IcaChannelClose( ChannelHandle );
        return Status;
    }

    Status = IcaChannelClose( ChannelHandle );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationOpenChannel status 0x%x\n", Status ));

    return Status;
}

/*
 * Disable virtual channel depending on the WinStation configuration.
 * This was supposed to be for security purposes (Web client).  
 *
 * Notes: 
 *    This doesn't protect the client since it's a host configuration option.
 *      The client doesn't have to support any virtual channels.
 *    It doesn't protect the host since it's the client devices you are denying
 *       access to.
 *    You may be adding some (fake) data security by denying the user access to
 *      a client printer and disk so he can't download data.
 */
VOID
VirtualChannelSecurity( PWINSTATION pWinStation )
{

    //  Check for availability
    if ( pWinStation->pWsx && 
         pWinStation->pWsx->pWsxVirtualChannelSecurity ) {

        (void) pWinStation->pWsx->pWsxVirtualChannelSecurity(
                    pWinStation->pWsxContext,
                    pWinStation->hIca,
                    &pWinStation->Config.Config.User);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\audit.c ===
/*******************************************************************************
* AUDIT.C
*
*     This module contains the routines for logging audit events
*
* Copyright (C) 1997-1999 Microsoft Corp.
*******************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <rpc.h>
#include <msaudite.h>
#include <ntlsa.h>
#include <authz.h>
#include <authzi.h>

HANDLE AuditLogHandle = NULL;
HANDLE SystemLogHandle = NULL;

#define MAX_INSTANCE_MEMORYERR 20

/*
 * Global data
 */
//Authz Changes
AUTHZ_RESOURCE_MANAGER_HANDLE hRM         = NULL;
extern RTL_CRITICAL_SECTION g_AuthzCritSection;
//END Authz Changes

/*
 * External procedures defined
 */
VOID
AuditEvent( PWINSTATION pWinstation, ULONG EventId );

NTSTATUS
AuthzReportEventW( IN PAUTHZ_AUDIT_EVENT_TYPE_HANDLE pHAET, 
                   IN DWORD Flags, 
                   IN ULONG EventId, 
                   IN PSID pUserID, 
                   IN USHORT NumStrings,
                   IN ULONG DataSize OPTIONAL, //Future - DO NOT USE
                   IN PWSTR* Strings,
                   IN PVOID  Data OPTIONAL         //Future - DO NOT USE
                   );


BOOL AuthzInit( IN DWORD Flags,
                IN USHORT CategoryID,
                IN USHORT AuditID,
                IN USHORT ParameterCount,
                OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
                );

BOOLEAN
AuditingEnabled ();

VOID
AuditEnd();


/*
 * Internal procedures defined
 */
NTSTATUS
AdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString
    );



BOOLEAN
IsAuditLogFull(
    HANDLE LogHandle
    )
{
    BOOLEAN retval = TRUE;
    EVENTLOG_FULL_INFORMATION EventLogFullInformation;
    DWORD dwBytesNeeded;

    if (GetEventLogInformation(LogHandle, 
                               EVENTLOG_FULL_INFO, 
                               &EventLogFullInformation, 
                               sizeof(EventLogFullInformation), 
                               &dwBytesNeeded )   ) {
        if (EventLogFullInformation.dwFull == FALSE) {
            retval = FALSE;
        }
    }

    return retval;
}



NTSTATUS
AdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed LUID.

    The resultant string will be formatted as follows:

        (0x00005678,0x12340000)

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;
    UNICODE_STRING          IntegerString;

    ULONG                   Buffer[(16*sizeof(WCHAR))/sizeof(ULONG)];


    IntegerString.Buffer = (PWCHAR)&Buffer[0];
    IntegerString.MaximumLength = 16*sizeof(WCHAR);


    //
    // Length (in WCHARS) is  3 for   (0x
    //                       10 for   1st hex number
    //                        3 for   ,0x
    //                       10 for   2nd hex number
    //                        1 for   )
    //                        1 for   null termination
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 28 * sizeof(WCHAR);

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }

    Status = RtlAppendUnicodeToString( ResultantString, L"(0x" );
    Status = RtlIntegerToUnicodeString( Value->HighPart, 16, &IntegerString );
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );

    Status = RtlAppendUnicodeToString( ResultantString, L",0x" );
    Status = RtlIntegerToUnicodeString( Value->LowPart, 16, &IntegerString );
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );

    Status = RtlAppendUnicodeToString( ResultantString, L")" );

    return(STATUS_SUCCESS);
}


VOID
AuditEvent( PWINSTATION pWinstation, ULONG EventId )
{
    NTSTATUS Status, Status2;
    UNICODE_STRING LuidString;
    PWSTR StringPointerArray[6];
    USHORT StringIndex = 0;
    TOKEN_STATISTICS TokenInformation;
    ULONG ReturnLength;
    BOOLEAN WasEnabled;
    LUID LogonId = {0,0};
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET = NULL;

    if (!AuditingEnabled() )
        return;

    Status = RtlAdjustPrivilege(
                 SE_SECURITY_PRIVILEGE,
                 TRUE,    // Enable the PRIVILEGE
                 FALSE,    // Don't Use Thread token (under impersonation)
                 &WasEnabled
                 );

    if ( Status == STATUS_NO_TOKEN ) {
        DBGPRINT(("TERMSRV: AuditEvent: RtlAdjustPrivilege failure 0x%x\n",Status));
        return;
    }

    //
    //AUTHZ Changes 
    //

    if( !AuthzInit( 0, SE_CATEGID_LOGON, (USHORT)EventId, 6, &hAET ))
        goto badAuthzInit;
            
    if (pWinstation->UserName && (wcslen(pWinstation->UserName) > 0)) {
        StringPointerArray[StringIndex] = pWinstation->UserName;
    } else {
        StringPointerArray[StringIndex] = L"Unknown";
    }
    StringIndex++;

    if (pWinstation->Domain  && (wcslen(pWinstation->Domain) > 0)) {
        StringPointerArray[StringIndex] = pWinstation->Domain;
    } else {
        StringPointerArray [StringIndex] =  L"Unknown";
    }
    StringIndex++;

    if (pWinstation->UserToken != NULL) {
        Status = NtQueryInformationToken (
            pWinstation->UserToken,
            TokenStatistics,
            &TokenInformation,
            sizeof(TokenInformation),
            &ReturnLength
            );
    
        if (NT_SUCCESS(Status)) {
    
            Status = AdtBuildLuidString( &(TokenInformation.AuthenticationId), &LuidString );
        } else {
            Status = AdtBuildLuidString( &LogonId, &LuidString );
        }
    } else {
        Status = AdtBuildLuidString( &LogonId, &LuidString );
    }
    StringPointerArray[StringIndex] = LuidString.Buffer;
    StringIndex++;

    if (pWinstation->WinStationName && (wcslen(pWinstation->WinStationName) > 0)) {
        StringPointerArray[StringIndex] = pWinstation->WinStationName;
    } else {
        StringPointerArray[StringIndex] = L"Unknown" ;
    }
    StringIndex++;

    if (pWinstation->Client.ClientName && (wcslen(pWinstation->Client.ClientName) > 0)) {
        StringPointerArray[StringIndex] = pWinstation->Client.ClientName;
    } else {
        StringPointerArray[StringIndex] = L"Unknown";
    }

    StringIndex++;

    if (pWinstation->Client.ClientAddress && (wcslen(pWinstation->Client.ClientAddress) > 0)) {
        StringPointerArray[StringIndex] = pWinstation->Client.ClientAddress;
    } else {
        StringPointerArray[StringIndex] = L"Unknown";
    }

    StringIndex++;

    //Authz Changes
    
    Status = AuthzReportEventW( &hAET, 
                                APF_AuditSuccess, 
                                EventId, 
                                pWinstation->pUserSid, 
                                StringIndex,
                                0,
                                StringPointerArray,
                                NULL
                                );

    //end authz changes


     if ( !NT_SUCCESS(Status))
        DBGPRINT(("Termsrv - failed to report event \n" ));

    if( !WasEnabled ) {

        /*
         * Principle of least rights says to not go around with privileges
         * held you do not need. So we must disable the shutdown privilege
         * if it was just a logoff force.
         */
        Status2 = RtlAdjustPrivilege(
                      SE_SECURITY_PRIVILEGE,
                      FALSE,    // Disable the PRIVILEGE
                      FALSE,     // Don't Use Thread token
                      &WasEnabled
                      );

    }
badAuthzInit:
    if( hAET != NULL )
        AuthziFreeAuditEventType( hAET  );
}




/***************************************************************************\
* AuditingEnabled
*
* Purpose : Check auditing via LSA.
*
* Returns:  TRUE on success, FALSE on failure
*
* History:
* 5-6-92   DaveHart     Created.
\***************************************************************************/

BOOLEAN
AuditingEnabled()
{
    NTSTATUS                    Status, IgnoreStatus;
    PPOLICY_AUDIT_EVENTS_INFO   AuditInfo;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE                  PolicyHandle;

    //
    // Set up the Security Quality Of Service for connecting to the
    // LSA policy object.
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy(
                 NULL,
                 &ObjectAttributes,
                 POLICY_VIEW_AUDIT_INFORMATION | POLICY_SET_AUDIT_REQUIREMENTS,
                 &PolicyHandle
                 );
    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("Termsrv: Failed to open LsaPolicyObject Status = 0x%lx", Status));
        return FALSE;
    }

    Status = LsaQueryInformationPolicy(
                 PolicyHandle,
                 PolicyAuditEventsInformation,
                 (PVOID *)&AuditInfo
                 );
    IgnoreStatus = LsaClose(PolicyHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(("Termsrv: Failed to query audit event info Status = 0x%lx", Status));
        return FALSE;
    }

    return (AuditInfo->AuditingMode &&
            ((AuditInfo->EventAuditingOptions)[AuditCategoryLogon] &
                                          POLICY_AUDIT_EVENT_SUCCESS));
}


VOID     WriteErrorLogEntry(
            IN  NTSTATUS NtStatusCode,
            IN  PVOID    pRawData,
            IN  ULONG    RawDataLength
            )
{
    NTSTATUS Status;
    ULONG Length;


    if ( !SystemLogHandle ) {
        UNICODE_STRING ModuleName;

        RtlInitUnicodeString( &ModuleName, L"TermService");

        Status = ElfRegisterEventSourceW( NULL, &ModuleName, &SystemLogHandle );

        if (!NT_SUCCESS(Status)) {
            DBGPRINT(("Termsrv - failed to open System log file\n"));
            return;
        }
    }

    if (IsAuditLogFull(SystemLogHandle))
        return;

    Status = ElfReportEventW( SystemLogHandle,
                              EVENTLOG_ERROR_TYPE,
                              0,
                              NtStatusCode,
                              NULL,
                              0,
                              RawDataLength,
                              NULL,
                              pRawData,
                              0,
                              NULL,
                              NULL );
    if ( !NT_SUCCESS(Status))
        DBGPRINT(("Termsrv - failed to report event \n" ));
}


// This function is duplicated in \nt\termsrv\sessdir\dis\tssdis.cpp.
/****************************************************************************/
// PostErrorValueEvent
//
// Utility function used to create a system log error event containing one
// hex DWORD error code value.
/****************************************************************************/
void PostErrorValueEvent(unsigned EventCode, DWORD ErrVal)
{
    HANDLE hLog;
    WCHAR hrString[128];
    PWSTR String = NULL;
	extern WCHAR gpszServiceName[];
    static DWORD numInstances = 0;
    //
    //count the numinstances of out of memory error, if this is more than
    //a specified number, we just won't log them
    //
    if( STATUS_COMMITMENT_LIMIT == ErrVal )
    {
        if( numInstances > MAX_INSTANCE_MEMORYERR )
            return;
         //
        //if applicable, tell the user that we won't log any more of the out of memory errors
        //
        if( numInstances >= MAX_INSTANCE_MEMORYERR - 1 ) {
            wsprintfW(hrString, L"0x%X. This type of error will not be logged again to avoid clutter.", ErrVal);
            String = hrString;
        }
        numInstances++;
    }

    hLog = RegisterEventSource(NULL, gpszServiceName);
    if (hLog != NULL) {
        if( NULL == String ) {
            wsprintfW(hrString, L"0x%X", ErrVal);
            String = hrString;
        }
        ReportEvent(hLog, EVENTLOG_ERROR_TYPE, 0, EventCode, NULL, 1, 0,
                (const WCHAR **)&String, NULL);
        DeregisterEventSource(hLog);
    }
}

/*************************************************************
* AuthzInit Purpose : Initialize authz for logging an event to the security log
*Flags - unused
*Category Id - Security Category to which this event belongs
*Audit Id - An id for the event
*PArameter count - Number of parameters that will be passed to the logging function later
****************************************************************/

BOOL AuthzInit( IN DWORD Flags,
                IN USHORT CategoryID,
                IN USHORT AuditID,
                IN USHORT ParameterCount,
                OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
                )                     
{
     BOOL fAuthzInit   = TRUE;

     if( NULL == phAuditEventType )
        goto badAuthzInit;
    
    *phAuditEventType = NULL;
    
    //
    //only one thread can create hRM
    //
    RtlEnterCriticalSection( &g_AuthzCritSection );
    if( NULL == hRM )
    {
            fAuthzInit = AuthzInitializeResourceManager( 0,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         L"Terminal Server",
                                                         &hRM
                                                         );

            if ( !fAuthzInit )
            {
                DBGPRINT(("TERMSRV: AuditEvent: AuthzInitializeResourceManager failed with %d\n", GetLastError()));
                goto badAuthzInit;
            }
    }
    RtlLeaveCriticalSection( &g_AuthzCritSection );

    fAuthzInit = AuthziInitializeAuditEventType( Flags,
                                                 CategoryID,
                                                 AuditID,
                                                 ParameterCount,
                                                 phAuditEventType
                                                 );

    if ( !fAuthzInit )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthziInitializeAuditEventType failed with %d\n", GetLastError()));
        goto badAuthzInit;
    }

badAuthzInit:
    if( !fAuthzInit )
    {
        if( NULL != *phAuditEventType )
        {
            if( !AuthziFreeAuditEventType( *phAuditEventType ))
                DBGPRINT(("TERMSRV: AuditEvent: AuthziFreeAuditEventType failed with %d\n", GetLastError()));
            *phAuditEventType = NULL;
        }
    }

  // if( fAuthzInit )
   //  DBGPRINT(("TERMSRV: Successfully initialized authz = %d\n", AuditID));
 return fAuthzInit;
}


/*********************************************************
* Purpose : Log an Event to the security log
* In pHAET
*  Audit Event type obtained from a call to AuthzInit() above
* In Flags
*   APF_AuditSuccess or others as listed in the header file
* pUserSID - Unused
* NumStrings - Number of strings contained within "Strings"
* DataSize - unused
* Strings- Pointer to a sequence of unicode strings
* Data - unused
*
**********************************************************/
NTSTATUS
AuthzReportEventW( IN PAUTHZ_AUDIT_EVENT_TYPE_HANDLE pHAET, 
                   IN DWORD Flags, 
                   IN ULONG EventId, 
                   IN PSID pUserSID, 
                   IN USHORT NumStrings,
                   IN ULONG DataSize OPTIONAL, //Future - DO NOT USE
                   IN PWSTR* Strings,
                   IN PVOID  Data OPTIONAL         //Future - DO NOT USE
                  )
{
    NTSTATUS status = STATUS_ACCESS_DENIED;
    AUTHZ_AUDIT_EVENT_HANDLE      hAE         = NULL;
    BOOL                          fSuccess   = FALSE;
    PAUDIT_PARAMS                 pParams     = NULL;

    if( NULL == hRM || NULL == pHAET || *pHAET == NULL )
        return status;

    fSuccess = AuthziAllocateAuditParams( &pParams,  NumStrings  );

    if ( !fSuccess )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthzAllocateAuditParams failed with %d\n", GetLastError()));
        goto BadAuditEvent;
    }


    if( 6 == NumStrings )
    {
        fSuccess = AuthziInitializeAuditParamsWithRM( Flags,
                                                     hRM,
                                                     NumStrings,
                                                     pParams,
                                                     APT_String, Strings[0],
                                                     APT_String,  Strings[1],
                                                     APT_String,  Strings[2],
                                                     APT_String,  Strings[3],
                                                     APT_String, Strings[4],
                                                     APT_String, Strings[5]
                                                     );
    }
    else if( 0 == NumStrings )
    {
        fSuccess = AuthziInitializeAuditParamsWithRM( Flags,
                                                     hRM,
                                                     NumStrings,
                                                     pParams
                                                     );
    }
    else
    {
        //we don't support anything else
        fSuccess = FALSE;
        DBGPRINT(("TERMSRV: AuditEvent: unsupported audit type \n"));
        goto BadAuditEvent;
    }
    
    if ( !fSuccess )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthziInitializeAuditParamsWithRM failed with %d\n", GetLastError()));
        goto BadAuditEvent;
    }

    fSuccess = AuthziInitializeAuditEvent( 0,
                                           hRM,
                                           *pHAET,
                                           pParams,
                                           NULL,
                                           INFINITE,
                                           L"",
                                           L"",
                                           L"",
                                           L"",
                                           &hAE
                                           );

    if ( !fSuccess )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthziInitializeAuditEvent failed with %d\n", GetLastError()));
        goto BadAuditEvent;
    }    

    fSuccess = AuthziLogAuditEvent( 0,
                                    hAE,
                                    NULL
                                    );

    if ( !fSuccess )
    {
        DBGPRINT(("TERMSRV: AuditEvent: AuthziLogAuditEvent failed with %d\n", GetLastError()));
        goto BadAuditEvent;
    }    

BadAuditEvent:

    if( hAE )
        AuthzFreeAuditEvent( hAE );

    if( pParams )
        AuthziFreeAuditParams( pParams );
    
    if( fSuccess )
        status = STATUS_SUCCESS;

    //if( fSuccess )
    // DBGPRINT(("TERMSRV: Successfully audited event with authz= %d\n", EventId));
    return status;
}


//
//should only be called once per our process
//
VOID AuditEnd()
{
    if( NULL != hRM )
    {
        if( !AuthzFreeResourceManager( hRM ))
            DBGPRINT(("TERMSRV: AuditEvent: AuthzFreeResourceManager failed with %d\n", GetLastError()));
        hRM = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\conntfy.c ===
#include "precomp.h"
#pragma hdrstop

#define SECURITY_WIN32

#ifdef NTSDDEBUG
#define NTSDDBGPRINT(x) DbgPrint x
#else
#define NTSDDBGPRINT(x)
#endif

#include "winsvcp.h"        // defines I_ScSendTSMessage
#include "conntfy.h"



//#ifdef MAKARANDS_HIGHER_WARNING_LEVEL
#pragma warning(push, 4)
#pragma warning(disable:4201) // nameless structure.
//#endif

#define INVALID_SESSIONID       0xffffffff
#define INVALID_SESSIONSERIAL   0xffffffff


// 0x1  fConnected
// 0x2  fLoggedOn
// 0x3  fRemote
// 0x4  fWelcome
typedef struct _WTSSESSION_STATE
{
    unsigned int bConnected: 1;
    unsigned int bLoggedOn: 1;
    unsigned int bConsole:  1;
    unsigned int bRemote: 1;
    unsigned int bLocked: 1;

} WTSSESSION_STATE, *PWTSSESSION_STATE;

/*
WTS_CONSOLE_CONNECT         bConnected, bConsole, !bRemote,
WTS_CONSOLE_DISCONNECT      !bConnected, !bConsole, !bRemote
WTS_REMOTE_CONNECT          bConnected, !bConsole, bremote
WTS_REMOTE_DISCONNECT       !bConnected, !bConsole, !bRemote
WTS_SESSION_LOGON           bLoggedOn
WTS_SESSION_LOGOFF          !bLoggedOn
WTS_SESSION_LOCK            bLocked
WTS_SESSION_UNLOCK          !bLocked
*/

//
// this is head for hwnds list.
// this links NOTIFY_ENTRY or NOTIFY_ENTRY_GLOBAL together.
//
typedef struct _NOTIFY_LIST
{
    LIST_ENTRY              Links;              // links to other NOTIFY_LISTs. not used in case of global notification list.
    LIST_ENTRY              ListHead;           // head of notification entries. links NOTIFY_ENTRYs (or NOTIFY_ENTRY_GLOBAL) together
    RTL_CRITICAL_SECTION    ListLock;           // lock to travel the entries.
    ULONG                   SessionId;          // session id ( not used in case of global list)
    ULONG                   SessonSerialNumber; // serial number ( not used in case of global list)
    WTSSESSION_STATE        SessionState;        // state of the session.

} NOTIFY_LIST, *PNOTIFY_LIST;

//
// entry in notification list per winstation.
//
typedef struct _NOTIFY_ENTRY
{
    LIST_ENTRY               Links;             // links to other entries
    ULONG                    hWnd;              // hwnd to be notified
    ULONG                    RefCount;          // how many times was this hwnd registered ?

} NOTIFY_ENTRY, *PNOTIFY_ENTRY;

//
// Entry in Notification list for all sessions Notifications.
//
typedef struct _NOTIFY_ENTRY_GLOBAL
{
    struct                  _NOTIFY_ENTRY;       // above structure +
    ULONG                   SessionId;           // since this is global entry, it needs to keep session id per hwnd.

} NOTIFY_ENTRY_GLOBAL, *PNOTIFY_ENTRY_GLOBAL;

//
// The notification Queue.
//
typedef struct _NOTIFICATION_QUEUE
{
    LIST_ENTRY ListHead;                        // head of queue reuests. links NOTIFICATION_REQUESTs together
    RTL_CRITICAL_SECTION ListLock;              // lock to travel the queue
    HANDLE hNotificationEvent;                  // syncronization between woker and caller of queue.

} NOTIFICATION_QUEUE, *PNOTIFICATION_QUEUE;

//
// Entry in Notification Queue.
//
typedef struct _NOTIFICATION_REQUEST
{
    LIST_ENTRY              Links;                       // links to other entries.
    ULONG                   SessionId;                   // session id for the session this notificaiton is to be sent.
    ULONG                   SessonSerialNumber;          // serial number for the session this notificaiton is to be sent.
    WPARAM                  NotificationCode;            // notificaiton code

} NOTIFICATION_REQUEST, *PNOTIFICATION_REQUEST;

//
// our main data structure.
//
typedef struct _NOTIFY_LLIST
{
    LIST_ENTRY              ListHead;                   // head of notification lists. links NOTIFY_LISTs together.
    RTL_CRITICAL_SECTION    ListLock;                   // lock to travel the head list.
    NOTIFY_LIST             GlobalList;                 // global notification list.
    NOTIFICATION_QUEUE      RequestQueue;               // notification queue.
    NOTIFY_LIST             InvlidHwndList;             // invalid window list

} NOTIFY_LLIST, PNOTIFY_LLIST;

//
// File Globals.
//
NOTIFY_LLIST gNotifyLList;


//
// private functions
//
BOOL DoesHWndExists (
                     PNOTIFY_LIST pNotifyList,
                     ULONG hWnd
                     );

PNOTIFY_ENTRY GetHWndEntryFromSessionList (
                                           PNOTIFY_LIST pNotifyList,
                                           ULONG hWnd
                                           );

PNOTIFY_ENTRY_GLOBAL GetHWndEntryFromGlobalList (
                                                 PNOTIFY_LIST pNotifyList,
                                                 ULONG hWnd,
                                                 ULONG SessionId
                                                 );

NTSTATUS GetNoficationListFromSessionId (
                                         ULONG SessionId,
                                         PNOTIFY_LIST *ppNofificationList,
                                         BOOL bKeepLListLocked
                                         );

NTSTATUS GetGlobalNotificationList (
                                    PNOTIFY_LIST *ppConChgNtfy
                                    );


NTSTATUS GetInvlidHwndList(PNOTIFY_LIST *ppConChgNtfy);
NTSTATUS NotifyConsole (
                        ULONG SessionId,
                        ULONG SessionSerialNumber,
                        WPARAM wParam
                        );

NTSTATUS SendConsoleNotification (
                                  ULONG SessionId,
                                  ULONG hWnd,
                                  ULONG Msg,
                                  WPARAM wParam,
                                  WTSSESSION_NOTIFICATION wtsConsoleNotification
                                  );

BOOL IsGlobalList(PNOTIFY_LIST pNtfyList);

int GetListCount (
                  LIST_ENTRY *pListHead
                  );


NTSTATUS DestroyLock ( PNOTIFY_LIST pNtfyList);
NTSTATUS CreateLock ( PNOTIFY_LIST pNtfyList);



NTSTATUS
InitializeNotificationQueue ();

NTSTATUS
QueueNotificationRequest (
                          ULONG SessionSerialNumber,
                          ULONG SessionId,
                          WPARAM notification
                          );

PNOTIFICATION_REQUEST
UnQueueNotificationRequest ();

DWORD NotificationQueueWorker (
                               LPVOID
                               );

NTSTATUS RemoveGlobalNotification (ULONG SessionId);
NTSTATUS RemoveInvalidWindowsFromLists ();
NTSTATUS UnRegisterConsoleNotificationInternal (ULONG hWnd, ULONG SessionId, BOOL bDcrRef);

void ReleaseNotificationList  (PNOTIFY_LIST pNotifyList);

void UpdateSessionState(PNOTIFY_LIST pNotifyList, WPARAM wNotification)
{
/*
WTS_CONSOLE_CONNECT         bConnected, bConsole, !bRemote,
WTS_CONSOLE_DISCONNECT      !bConnected, !bConsole, !bRemote
WTS_REMOTE_CONNECT          bConnected, !bConsole, bremote
WTS_REMOTE_DISCONNECT       !bConnected, !bConsole, !bRemote
WTS_SESSION_LOGON           bLoggedOn
WTS_SESSION_LOGOFF          !bLoggedOn
WTS_SESSION_LOCK            bLocked
WTS_SESSION_UNLOCK          !bLocked
*/

    ASSERT(!IsGlobalList(pNotifyList));
    

    ASSERT(!pNotifyList->SessionState.bConsole || !pNotifyList->SessionState.bRemote);
    ASSERT(!pNotifyList->SessionState.bConnected || pNotifyList->SessionState.bConsole || pNotifyList->SessionState.bRemote);

    switch  (wNotification)
    {
        case WTS_CONSOLE_CONNECT:

            ASSERT(!pNotifyList->SessionState.bConsole);
            ASSERT(!pNotifyList->SessionState.bRemote);

            pNotifyList->SessionState.bConnected = 1;
            pNotifyList->SessionState.bConsole = 1;
            break;

        case WTS_CONSOLE_DISCONNECT:

            ASSERT(pNotifyList->SessionState.bConsole);
            ASSERT(pNotifyList->SessionState.bConnected);
            ASSERT(!pNotifyList->SessionState.bRemote);

            pNotifyList->SessionState.bConnected = 0;
            pNotifyList->SessionState.bConsole = 0;
            break;

        case WTS_REMOTE_DISCONNECT:

            ASSERT(pNotifyList->SessionState.bRemote);
            ASSERT(pNotifyList->SessionState.bConnected);
            ASSERT(!pNotifyList->SessionState.bConsole);

            pNotifyList->SessionState.bConnected = 0;
            pNotifyList->SessionState.bRemote = 0;
            break;

        case WTS_REMOTE_CONNECT:
            
            ASSERT(!pNotifyList->SessionState.bRemote);
            ASSERT(!pNotifyList->SessionState.bConnected);
            ASSERT(!pNotifyList->SessionState.bConsole);
            
            pNotifyList->SessionState.bConnected = 1;
            pNotifyList->SessionState.bRemote = 1;
            break;

        case WTS_SESSION_LOGON:
            
            ASSERT(pNotifyList->SessionState.bLoggedOn == 0);
            
            pNotifyList->SessionState.bLoggedOn = 1;
            break;

        case WTS_SESSION_LOGOFF:
            
            ASSERT(pNotifyList->SessionState.bLoggedOn == 1);

            pNotifyList->SessionState.bLoggedOn = 0;
            break;

        case WTS_SESSION_LOCK:
            
            ASSERT(pNotifyList->SessionState.bLocked == 0);

            pNotifyList->SessionState.bLocked = 1;
            break;

        case WTS_SESSION_UNLOCK:
            
            ASSERT(pNotifyList->SessionState.bLocked == 1);

            pNotifyList->SessionState.bLocked = 0;
            break;

        default:
            ASSERT(FALSE);
    }
    
    ASSERT(!pNotifyList->SessionState.bConsole || !pNotifyList->SessionState.bRemote);
    ASSERT(!pNotifyList->SessionState.bConnected || pNotifyList->SessionState.bConsole || pNotifyList->SessionState.bRemote);
}

//
// Global initialization.
//
NTSTATUS InitializeConsoleNotification ()
{
    NTSTATUS Status;

    InitializeListHead( &gNotifyLList.ListHead );
    Status = RtlInitializeCriticalSection( &gNotifyLList.ListLock );
    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }

    //
    // following members are unused in for global list.
    //
    gNotifyLList.GlobalList.Links.Blink = NULL;
    gNotifyLList.GlobalList.Links.Flink = NULL;
    gNotifyLList.GlobalList.SessionId = INVALID_SESSIONID;
    gNotifyLList.GlobalList.SessonSerialNumber = INVALID_SESSIONSERIAL;


    InitializeListHead( &gNotifyLList.GlobalList.ListHead);
    Status = RtlInitializeCriticalSection( &gNotifyLList.GlobalList.ListLock );
    if ( !NT_SUCCESS( Status ) )
    {
        RtlDeleteCriticalSection( &gNotifyLList.ListLock );
        return (Status);
    }


    gNotifyLList.InvlidHwndList.Links.Blink = NULL;
    gNotifyLList.InvlidHwndList.Links.Flink = NULL;
    gNotifyLList.InvlidHwndList.SessionId = INVALID_SESSIONID;
    gNotifyLList.InvlidHwndList.SessonSerialNumber = INVALID_SESSIONSERIAL;

    InitializeListHead(&gNotifyLList.InvlidHwndList.ListHead) ;
    Status = RtlInitializeCriticalSection( &gNotifyLList.InvlidHwndList.ListLock );
    if ( !NT_SUCCESS( Status ) )
    {
        RtlDeleteCriticalSection( &gNotifyLList.ListLock );
        RtlDeleteCriticalSection( &gNotifyLList.GlobalList.ListLock );
        return (Status);
    }


    Status =  InitializeNotificationQueue ();
    if ( !NT_SUCCESS( Status ) )
    {
        RtlDeleteCriticalSection( &gNotifyLList.ListLock );
        RtlDeleteCriticalSection( &gNotifyLList.GlobalList.ListLock );
        RtlDeleteCriticalSection( &gNotifyLList.InvlidHwndList.ListLock );
    }

    return (Status);
}


//
// per winstation initialization.
//
NTSTATUS InitializeSessionNotification (PWINSTATION  pWinStation)
{
    NTSTATUS        Status;
    PNOTIFY_LIST    pNewNotifyList;

    ASSERT(pWinStation);

    if (pWinStation->Terminating)
    {
        // dont create notification list if this winstation is already terminating.
        // its possible that a winstation is being terminated before getting completely created,
        // in such case we might end up calling RemoveSessionNotification before InitializeSessionNotification.
        // so essentially leaving this session never to deleted. (Bug #414330)
        return STATUS_SUCCESS;
    }

#ifdef DBG

    // BUGBUG - is it possible that a old session with the same session id is still there?
    Status = GetNoficationListFromSessionId(pWinStation->LogonId, &pNewNotifyList, FALSE);

    //
    // we are just being asked to initialize notification
    // we must not find list for this session in our LList.
    //
    ASSERT( STATUS_NO_SUCH_LOGON_SESSION == Status );

#endif


    //
    // create a new hwnd list for this session
    //
    pNewNotifyList = MemAlloc(sizeof(NOTIFY_LIST));
    if (!pNewNotifyList)
    {
        return STATUS_NO_MEMORY;
    }

    pNewNotifyList->SessionId = pWinStation->LogonId;
    pNewNotifyList->SessonSerialNumber = pWinStation->SessionSerialNumber;

    //
    // initialize session state.
    //
    {
        pNewNotifyList->SessionState.bConnected = 0;
        pNewNotifyList->SessionState.bConsole = 0;
        pNewNotifyList->SessionState.bLoggedOn = 0;
        pNewNotifyList->SessionState.bRemote = 0;
        pNewNotifyList->SessionState.bLocked = 0; // bugbug we dont know the real welcome state ;(
    }

    InitializeListHead( &pNewNotifyList->ListHead);

    Status = RtlInitializeCriticalSection( &pNewNotifyList->ListLock );
    if ( !NT_SUCCESS( Status ) )
    {
        MemFree(pNewNotifyList);
        pNewNotifyList = NULL;
        return Status;
    }

    // now link this new list into our main list of lists.
    ENTERCRIT(&gNotifyLList.ListLock);
    InsertTailList( &gNotifyLList.ListHead, &pNewNotifyList->Links);
    LEAVECRIT(&gNotifyLList.ListLock);

    return STATUS_SUCCESS;
}
//
// must be called when a session ends.
//
NTSTATUS RemoveSessionNotification(ULONG SessionId, ULONG SessionSerialNumber)
{
    NTSTATUS Status;
    PNOTIFY_LIST pListTobeRemoved;
    UNREFERENCED_PARAMETER(SessionSerialNumber);    // it's referenced only for Chk builds.


    // BUGBUG - is it possible that a new session with the same session id was created while we are here ?
    Status = GetNoficationListFromSessionId( SessionId, &pListTobeRemoved, TRUE);

    if (!NT_SUCCESS( Status ))
    {
        //
        // we are being asked to remove session notification
        // but its possible that we dont have session notification list created for this session. 
        // This can happen if the session is being terminate during session creation process.
        //
        ASSERT( !pListTobeRemoved );
        return Status;

    }

    ASSERT( pListTobeRemoved );
    ASSERT( SessionSerialNumber == pListTobeRemoved->SessonSerialNumber );

    RemoveEntryList( &pListTobeRemoved->Links );
    LEAVECRIT(&gNotifyLList.ListLock);

    //
    // walk throught this list and free all the nodes.
    //
    while (!IsListEmpty(&pListTobeRemoved->ListHead))
    {
        PNOTIFY_ENTRY pEntry;
        PLIST_ENTRY Next;

        Next = pListTobeRemoved->ListHead.Flink;

        ASSERT(Next);

        pEntry = CONTAINING_RECORD( Next, NOTIFY_ENTRY, Links );
        ASSERT(pEntry);

        RemoveEntryList( &pEntry->Links );
        MemFree(pEntry);
        pEntry = NULL;
    }

    // we are no more going to use this list lock.
    RtlDeleteCriticalSection( &pListTobeRemoved->ListLock );
    MemFree(pListTobeRemoved);
    pListTobeRemoved = NULL;


    return RemoveGlobalNotification (SessionId);
    // return QueueNotificationRequest(pWinStation->SessionSerialNumber, pWinStation->LogonId, 0);

}

NTSTATUS RemoveGlobalNotification (ULONG SessionId)
{
    PLIST_ENTRY Head, Next;
    PNOTIFY_LIST pListTobeRemoved = NULL;
    NTSTATUS Status = GetGlobalNotificationList(&pListTobeRemoved);


    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }

    ASSERT(pListTobeRemoved);


    Head = &pListTobeRemoved->ListHead;
    Next = Head->Flink;
    while (Head != Next)
    {
        PNOTIFY_ENTRY_GLOBAL pEntryGlobal = CONTAINING_RECORD( Next, NOTIFY_ENTRY_GLOBAL, Links );
        Next = Next->Flink;
        ASSERT(pEntryGlobal);
        if (pEntryGlobal->SessionId == SessionId)
        {
            RemoveEntryList( &pEntryGlobal->Links );
            MemFree(pEntryGlobal);
            pEntryGlobal = NULL;
        }
    }

    ReleaseNotificationList( pListTobeRemoved );
    pListTobeRemoved = NULL;

    // now lets remove the invalid Windows associated with this session.
    // from the list if there is any.

    pListTobeRemoved = NULL;
    Status = GetInvlidHwndList(&pListTobeRemoved);
    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }
    
    ASSERT(pListTobeRemoved);

    Head = &pListTobeRemoved->ListHead;
    Next = Head->Flink;
    while (Head != Next)
    {
        PNOTIFY_ENTRY_GLOBAL pEntryGlobal = CONTAINING_RECORD( Next, NOTIFY_ENTRY_GLOBAL, Links );
        Next = Next->Flink;
        ASSERT(pEntryGlobal);
        if (pEntryGlobal->SessionId == SessionId)
        {
            RemoveEntryList( &pEntryGlobal->Links );
            MemFree(pEntryGlobal);
            pEntryGlobal = NULL;
        }
    }

    ReleaseNotificationList(pListTobeRemoved);

    return STATUS_SUCCESS;
}

NTSTATUS RegisterConsoleNotification ( ULONG hWnd, ULONG SessionId, DWORD dwFlags )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PNOTIFY_LIST pNotifyList = NULL;
    PNOTIFY_LIST pNotifyListGlobal = NULL;
    PNOTIFY_ENTRY pEntry = NULL;
    PNOTIFY_ENTRY_GLOBAL pEntryGlobal = NULL;


    if (dwFlags != NOTIFY_FOR_THIS_SESSION && dwFlags != NOTIFY_FOR_ALL_SESSIONS)
    {
        //
        // invalid flag value
        //
        return STATUS_INVALID_PARAMETER_3;
    }

    //
    // get the global session notificaiton list
    //
    Status = GetGlobalNotificationList(&pNotifyListGlobal);
    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // get the session specific list for this window
    //
    Status = GetNoficationListFromSessionId( SessionId, &pNotifyList, FALSE);
    if (!NT_SUCCESS(Status))
    {
        ReleaseNotificationList (pNotifyListGlobal);
        return Status;
    }


    ASSERT( pNotifyList );
    ASSERT( pNotifyListGlobal );

    pEntry = GetHWndEntryFromSessionList(pNotifyList, hWnd);
    pEntryGlobal = GetHWndEntryFromGlobalList(pNotifyListGlobal, hWnd, SessionId);

    //
    // entry must not exist in both the lists.
    //
    ASSERT(!(pEntry && pEntryGlobal));

    if (pEntry)
    {
        //
        // Let other list go
        //
        ReleaseNotificationList( pNotifyListGlobal );

        ASSERT( pEntry );
        ASSERT( pEntry->RefCount > 0 );

        //
        // entry already exists, just increment its reference count.
        //
        pEntry->RefCount++;

        ReleaseNotificationList( pNotifyList );

    }
    else if (pEntryGlobal)
    {
        ReleaseNotificationList (pNotifyList);

        ASSERT( pEntryGlobal );
        ASSERT( pEntryGlobal->RefCount > 0 );

        //
        // entry already exists, just increment its reference count.
        //
        pEntryGlobal->RefCount++;

        ReleaseNotificationList( pNotifyListGlobal );
    }
    else
    {
        //
        // the entry does not exists in either of the lists.
        // so we need to create a new entry
        //
        if (dwFlags & NOTIFY_FOR_ALL_SESSIONS)
        {
            ReleaseNotificationList (pNotifyList);

            pEntryGlobal = MemAlloc( sizeof(NOTIFY_ENTRY_GLOBAL) );
            if (pEntryGlobal == NULL )
            {
                Status = STATUS_NO_MEMORY;
            }
            else
            {
                pEntryGlobal->hWnd = hWnd;
                pEntryGlobal->SessionId = SessionId;
                pEntryGlobal->RefCount = 1;

                InsertTailList( &(pNotifyListGlobal->ListHead), &(pEntryGlobal->Links) );
            }

            ReleaseNotificationList( pNotifyListGlobal );
        }
        else
        {
            ReleaseNotificationList( pNotifyListGlobal );

            pEntry = MemAlloc( sizeof(NOTIFY_ENTRY) );
            if (pEntry == NULL )
            {
                Status = STATUS_NO_MEMORY;
            }
            else
            {
                pEntry->hWnd = hWnd;
                pEntry->RefCount = 1;

                InsertTailList( &(pNotifyList->ListHead), &(pEntry->Links) );
            }

            ReleaseNotificationList (pNotifyList);
        }
    }

    return (Status);
}

NTSTATUS UnRegisterConsoleNotification (ULONG hWnd, ULONG SessionId)
{
    return UnRegisterConsoleNotificationInternal (hWnd, SessionId, TRUE);
}


NTSTATUS UnRegisterConsoleNotificationInternal (ULONG hWnd, ULONG SessionId, BOOL bDcrRef)
{
    NTSTATUS Status;
    PNOTIFY_LIST pNotifyList;
    PNOTIFY_ENTRY pEntry;

    //
    // get the notification list for the Session
    //
    Status = GetNoficationListFromSessionId( SessionId, &pNotifyList, FALSE);

    if (NT_SUCCESS(Status))
    {
        ASSERT(pNotifyList);

        pEntry = GetHWndEntryFromSessionList(pNotifyList,hWnd);

        if (pEntry)
        {
            ASSERT( pEntry->RefCount > 0 );

            // decrement ref count
            pEntry->RefCount--;

            if (pEntry->RefCount == 0 || !bDcrRef)
            {
                RemoveEntryList( &pEntry->Links );
                MemFree(pEntry);
                pEntry = NULL;
            }

            ReleaseNotificationList (pNotifyList);
        }
        else
        {
            PNOTIFY_LIST pNotifyListGlobal = NULL;
            PNOTIFY_ENTRY_GLOBAL pEntryGlobal = NULL;

            ReleaseNotificationList (pNotifyList);

            //
            // now check the global session notificaiton entry
            //
            Status = GetGlobalNotificationList(&pNotifyListGlobal);

            if (NT_SUCCESS(Status))
            {
                pEntryGlobal = GetHWndEntryFromGlobalList(pNotifyListGlobal, hWnd, SessionId);
                if (pEntryGlobal)
                {
                    ASSERT(pEntryGlobal->RefCount > 0);
                    pEntryGlobal->RefCount--;
                    if (pEntryGlobal->RefCount == 0 || !bDcrRef)
                    {
                        RemoveEntryList( &pEntryGlobal->Links );
                        MemFree(pEntryGlobal);
                        pEntryGlobal = NULL;
                    }
                }
                else
                {
                    Status = STATUS_NOT_FOUND;
                }

                ReleaseNotificationList( pNotifyListGlobal );
            }

        }

    }

    return (Status);
}

NTSTATUS NotifySessionChange (PWINSTATION pWinStation, WPARAM wNotification)
{
    return QueueNotificationRequest(pWinStation->SessionSerialNumber, pWinStation->LogonId, wNotification);
}

NTSTATUS NotifyLogon(PWINSTATION pWinStation)
{
    return NotifySessionChange(pWinStation, WTS_SESSION_LOGON);
}

NTSTATUS NotifyLogoff(PWINSTATION pWinStation)
{
    return NotifySessionChange(pWinStation, WTS_SESSION_LOGOFF);
}

NTSTATUS NotifyConnect (PWINSTATION pWinStation, BOOL bConsole)
{
    return NotifySessionChange(pWinStation, bConsole ? WTS_CONSOLE_CONNECT : WTS_REMOTE_CONNECT);
}

NTSTATUS NotifyDisconnect (PWINSTATION pWinStation, BOOL bConsole)
{
    return NotifySessionChange(pWinStation, bConsole ? WTS_CONSOLE_DISCONNECT : WTS_REMOTE_DISCONNECT);
}

NTSTATUS NofifyWelcomeOn  (PWINSTATION  pWinStation)
{
    return NotifySessionChange(pWinStation, WTS_SESSION_LOCK);
}

NTSTATUS NotifyWelcomeOff (PWINSTATION  pWinStation)
{
    return NotifySessionChange(pWinStation, WTS_SESSION_UNLOCK);
}


NTSTATUS SendNotificationToHwnd(PWINSTATION pWinstation, ULONG hWnd, ULONG SessionId, WPARAM wParam)
{
    WINSTATION_APIMSG WMsg;

    //
    // now pupulate the WMSG for delievery.
    //
    WMsg.u.sMsg.Msg        = WM_WTSSESSION_CHANGE;
    WMsg.u.sMsg.wParam     = wParam;
    WMsg.ApiNumber         = SMWinStationSendWindowMessage ;
    WMsg.WaitForReply      = FALSE;
    WMsg.u.sMsg.dataBuffer = NULL;
    WMsg.u.sMsg.bufferSize = 0;
    WMsg.u.sMsg.lParam     = SessionId;
    WMsg.u.sMsg.hWnd       = (HWND)ULongToHandle( hWnd );

    return SendWinStationCommand( pWinstation, &WMsg, 0);

}


NTSTATUS NotifyConsole (ULONG SessionId, ULONG SessionSerialNumber, WPARAM wParam)
{
    NTSTATUS Status = STATUS_SUCCESS;


    DWORD dwError;
    PWINSTATION pWinStation=NULL;


    Status = RemoveInvalidWindowsFromLists();
    ASSERT(NT_SUCCESS(Status));

    pWinStation = FindWinStationById(SessionId, FALSE);

    //
    // if we find the session we were looking for
    // note: we must check for the serialnumber, as the session id is not unique.
    //
    if (pWinStation)
    {
        if (SessionSerialNumber == pWinStation->SessionSerialNumber)
        {
            PNOTIFY_LIST pConsoleList;

            Status = GetNoficationListFromSessionId(pWinStation->LogonId, &pConsoleList, FALSE);
            if (NT_SUCCESS(Status) && pConsoleList)
            {
                PLIST_ENTRY Head, Next;
                Head = &pConsoleList->ListHead;
                for ( Next = Head->Flink; Next != Head; Next = Next->Flink )
                {
                    PNOTIFY_ENTRY pEntry;
                    pEntry = CONTAINING_RECORD( Next, NOTIFY_ENTRY, Links );
                    ASSERT(pEntry);

                    Status = SendNotificationToHwnd(pWinStation, pEntry->hWnd, SessionId, wParam);

                    if (!NT_SUCCESS(Status))
                    {
                        NTSDDBGPRINT(("conntfy.c - SendWinStationCommand failed, Status = %d.\n", Status));
                    }
                }

                UpdateSessionState(pConsoleList, wParam);

                ReleaseNotificationList( pConsoleList );
            }
        }

        ReleaseWinStation( pWinStation );
    }

    //
    // now send notifications to windows registered for all session notificaitons.
    //
    {
        PNOTIFY_LIST pNotifyListGlobal = NULL;

        Status = GetGlobalNotificationList(&pNotifyListGlobal);
        if (NT_SUCCESS(Status))
        {
            PLIST_ENTRY Head, Next;
            Head = &pNotifyListGlobal->ListHead;

            for ( Next = Head->Flink; Next != Head; Next = Next->Flink )
            {
                PNOTIFY_ENTRY_GLOBAL pEntryGlobal = NULL;
                pEntryGlobal = CONTAINING_RECORD( Next, NOTIFY_ENTRY_GLOBAL, Links );
                ASSERT(pEntryGlobal);

                pWinStation = FindWinStationById(pEntryGlobal->SessionId, FALSE);
                if (pWinStation)
                {
                    if  (!pWinStation->Terminating)
                    {
                        Status = SendNotificationToHwnd(pWinStation, pEntryGlobal->hWnd, SessionId, wParam);
                        
                        if (!NT_SUCCESS(Status))
                        {
                            NTSDDBGPRINT(("conntfy.c - SendWinStationCommand failed, Status = %d.\n", Status));
                        }
                    }
                    
                    ReleaseWinStation( pWinStation );
                }
            }

            ReleaseNotificationList(pNotifyListGlobal);
        }
        else
        {
            NTSDDBGPRINT(("conntfy.c - Failed to get all session notification list - status = 0x%x.\n", Status));
        }
    }


    //
    // now lets notify SCM which will notify all the services registered for SERVICE_ACCEPT_SESSIONCHANGE
    //

    //
	// logon logoff notifications for session 0 are sent by winlogon. rest are handled here.
    //
	if (SessionId != 0 || ( wParam != WTS_SESSION_LOGON && wParam != WTS_SESSION_LOGOFF))
    {

        WTSSESSION_NOTIFICATION wtsConsoleNotification;
        wtsConsoleNotification.cbSize = sizeof(WTSSESSION_NOTIFICATION);
        wtsConsoleNotification.dwSessionId = SessionId;

		dwError = I_ScSendTSMessage(
				SERVICE_CONTROL_SESSIONCHANGE,        // op code
				(DWORD)wParam,                        // event code,
				wtsConsoleNotification.cbSize,        // data size
				(LPBYTE)&wtsConsoleNotification       // data.
				);

    }

    return Status;
}



NTSTATUS DestroyLock( PNOTIFY_LIST pNtfyList)
{
    return RtlDeleteCriticalSection( &pNtfyList->ListLock );
}

NTSTATUS CreateLock (PNOTIFY_LIST pNtfyList)
{
    return RtlInitializeCriticalSection( &pNtfyList->ListLock );
}


BOOL IsInvalidHWndList (PNOTIFY_LIST pNtfyList)
{
    return (pNtfyList == &gNotifyLList.InvlidHwndList);
}
BOOL IsGlobalList(PNOTIFY_LIST pNtfyList)
{
    return (pNtfyList == &gNotifyLList.GlobalList);
}

int GetListCount (LIST_ENTRY *pListHead)
{
    PLIST_ENTRY Head, Next;
    int iCount = 0;

    ASSERT(pListHead);

    Head = pListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink )
    {
        iCount++;
    }

    return iCount;
}

PNOTIFY_ENTRY GetHWndEntryFromSessionList(PNOTIFY_LIST pNotifyList, ULONG hWnd)
{
    PLIST_ENTRY Head = NULL;
    PLIST_ENTRY Next = NULL;
    PNOTIFY_ENTRY pEntry = NULL;

    Head = &pNotifyList->ListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink )
    {
        pEntry = CONTAINING_RECORD( Next, NOTIFY_ENTRY, Links );

        ASSERT(pEntry);
        if (pEntry->hWnd == hWnd)
        {
            return pEntry;
        }
    }

    return NULL;
}

PNOTIFY_ENTRY_GLOBAL GetHWndEntryFromGlobalList(PNOTIFY_LIST pNotifyList, ULONG hWnd, ULONG SessionId)
{
    PLIST_ENTRY Head = NULL;
    PLIST_ENTRY Next = NULL;
    PNOTIFY_ENTRY_GLOBAL pEntry = NULL;

    Head = &pNotifyList->ListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink )
    {
        pEntry = CONTAINING_RECORD( Next, NOTIFY_ENTRY_GLOBAL, Links );

        ASSERT(pEntry);
        if (pEntry->hWnd == hWnd && SessionId == pEntry->SessionId)
        {
            return pEntry;
        }
    }

    return NULL;
}

//
// returns PNOTIFY_LIST list for the given session.
//
NTSTATUS GetNoficationListFromSessionId (ULONG SessionId, PNOTIFY_LIST *ppNotifyList, BOOL bKeepLListLocked)
{
    PLIST_ENTRY Next, Head;

    ASSERT(ppNotifyList);

    *ppNotifyList = NULL;

    // lock our list of lists.
    ENTERCRIT(&gNotifyLList.ListLock);



    Head = &gNotifyLList.ListHead;
    Next = Head->Flink;
    while (Head != Next)
    {
        PNOTIFY_LIST pNotifyList = CONTAINING_RECORD( Next, NOTIFY_LIST, Links );

        ASSERT( pNotifyList );

        //
        // we always take gNotifyLList.ListLock first and then the Listlock
        // therefore we must never have PNOTIFY_LIST.ListLock at this time.
        //
        ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != pNotifyList->ListLock.OwningThread );


        if (pNotifyList->SessionId == SessionId)
        {
            //
            // did we find more that 1 matching notify list ???, should never happen!
            //
            ASSERT(*ppNotifyList == NULL);

            //
            // ok we found the session list we were looking for
            //
            *ppNotifyList = pNotifyList;

#ifndef DBG
            break;
#endif
        }

        Next = Next->Flink;
    }

    //
    // if we have found the list we were looking for
    //
    if (*ppNotifyList)
    {
        //
        // lock the list before returning.
        //
        ENTERCRIT(&(*ppNotifyList)->ListLock);
    }

    if (!(*ppNotifyList) || !bKeepLListLocked)
    {
        //
        // unlock llist lock.
        //
        LEAVECRIT(&gNotifyLList.ListLock);
    }

    if (*ppNotifyList)
    {
        return STATUS_SUCCESS;
    }
    else
    {
        return STATUS_NO_SUCH_LOGON_SESSION;
    }
}

void ReleaseNotificationList  (PNOTIFY_LIST pNotifyList)
{
    ASSERT(pNotifyList);
    if (IsInvalidHWndList(pNotifyList))
    {
        // we must take invalid hwnd list before taking global list.
        ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (gNotifyLList.GlobalList.ListLock).OwningThread );
        // we must take invalid hwnd list before taking LList.
        ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (gNotifyLList.ListLock).OwningThread );
    }
    else if (IsGlobalList(pNotifyList))
    {
        // we must take invalid hwnd list before taking LList.
        ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (gNotifyLList.ListLock).OwningThread );
    }

    LEAVECRIT(&pNotifyList->ListLock);
}

NTSTATUS GetInvlidHwndList(PNOTIFY_LIST *ppConChgNtfy)
{
    ASSERT(ppConChgNtfy);
    
    // we must take invalid hwnd list before taking global list.
    ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (gNotifyLList.GlobalList.ListLock).OwningThread );
    
    // we must take invalid hwnd list before taking LList.
    ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (gNotifyLList.ListLock).OwningThread );

    *ppConChgNtfy = &gNotifyLList.InvlidHwndList;
    ENTERCRIT(&(*ppConChgNtfy)->ListLock);

    ASSERT(gNotifyLList.InvlidHwndList.Links.Blink == NULL);
    ASSERT(gNotifyLList.InvlidHwndList.Links.Flink == NULL);
    ASSERT(gNotifyLList.InvlidHwndList.SessionId == INVALID_SESSIONID);
    ASSERT(gNotifyLList.InvlidHwndList.SessonSerialNumber == INVALID_SESSIONSERIAL);
    
    return STATUS_SUCCESS;
}

NTSTATUS GetGlobalNotificationList(PNOTIFY_LIST *ppConChgNtfy)
{
    ASSERT(ppConChgNtfy);
    
    // we must LLIst after global list.
    ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (gNotifyLList.ListLock).OwningThread );
    
    *ppConChgNtfy = &gNotifyLList.GlobalList;

    ENTERCRIT(&(*ppConChgNtfy)->ListLock);

    ASSERT(gNotifyLList.GlobalList.Links.Blink == NULL);
    ASSERT(gNotifyLList.GlobalList.Links.Flink == NULL);
    ASSERT(gNotifyLList.GlobalList.SessionId == INVALID_SESSIONID);
    ASSERT(gNotifyLList.GlobalList.SessonSerialNumber == INVALID_SESSIONSERIAL);

    return (STATUS_SUCCESS);
}


NTSTATUS InitializeNotificationQueue ()
{
    DWORD ThreadId;
    NTSTATUS Status;
    HANDLE hSessionNotifyThread;

    InitializeListHead( &gNotifyLList.RequestQueue.ListHead);

    gNotifyLList.RequestQueue.hNotificationEvent = CreateEvent(
        NULL,    // SD
        FALSE, // reset type
        FALSE, // initial state
        NULL    // object name
        );

    if (gNotifyLList.RequestQueue.hNotificationEvent == NULL)
    {
        // we failed to create event.
        // return GetLastError()
        return STATUS_UNSUCCESSFUL;

    }

    Status = RtlInitializeCriticalSection( &gNotifyLList.RequestQueue.ListLock );
    if (!NT_SUCCESS(Status))
    {
        CloseHandle(gNotifyLList.RequestQueue.hNotificationEvent);
        gNotifyLList.RequestQueue.hNotificationEvent = NULL;
        return Status;
    }

    //
    // now create thread for notifications.
    //
    hSessionNotifyThread = CreateThread(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE)NotificationQueueWorker,
        NULL,
        0,
        &ThreadId);

    //
    // Just close it, we can do without this handle.
    //
    if( hSessionNotifyThread )
    {
        NtClose( hSessionNotifyThread );
    }
    else
    {
        
        RtlDeleteCriticalSection( &gNotifyLList.RequestQueue.ListLock );

        CloseHandle(gNotifyLList.RequestQueue.hNotificationEvent);
        gNotifyLList.RequestQueue.hNotificationEvent = NULL;

        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

void LockNotificationQueue()
{
    ENTERCRIT(&gNotifyLList.RequestQueue.ListLock);
}

void UnLockNotificationQueue()
{
    LEAVECRIT(&gNotifyLList.RequestQueue.ListLock);
}


//
// Queues a notification entry
//
NTSTATUS QueueNotificationRequest(ULONG SessionSerialNumber, ULONG SessionId, WPARAM notification)
{
    PNOTIFICATION_REQUEST pRequest = NULL;
    pRequest = MemAlloc( sizeof(NOTIFICATION_REQUEST) );

    if (!pRequest)
    {
        return STATUS_NO_MEMORY;
    }

    pRequest->SessonSerialNumber = SessionSerialNumber;
    pRequest->SessionId = SessionId;
    pRequest->NotificationCode = notification;

    // now lock the queue
    LockNotificationQueue();
    InsertHeadList(&gNotifyLList.RequestQueue.ListHead, &pRequest->Links);
    UnLockNotificationQueue();

    // let the waiting thread process this notification.
    PulseEvent(gNotifyLList.RequestQueue.hNotificationEvent);
    return STATUS_SUCCESS;
}

//
// takes out a notification entry from queue.
//
PNOTIFICATION_REQUEST UnQueueNotificationRequest()
{
    PLIST_ENTRY pEntry;
    PNOTIFICATION_REQUEST pRequest = NULL;

    //
    //  Remove a request from the list.
    //
    LockNotificationQueue();
    if (!IsListEmpty(&gNotifyLList.RequestQueue.ListHead))
    {
        pEntry = RemoveTailList(&gNotifyLList.RequestQueue.ListHead);
        pRequest = CONTAINING_RECORD(pEntry, NOTIFICATION_REQUEST, Links);
    }
    
    UnLockNotificationQueue();

    return pRequest;
}


// This thread is a helper for the next function.  We do this because the
// compiler defies reason by insisting not all control paths return a value.
VOID NotificationQueueWorkerEx()
{
    PNOTIFICATION_REQUEST pRequest = NULL;

    for(;;)
    {
        WaitForSingleObject(gNotifyLList.RequestQueue.hNotificationEvent, INFINITE); // wait for the event to be signaled.
        
        while ((pRequest = UnQueueNotificationRequest()) != NULL)
        {
            if (!pRequest->NotificationCode)
            {
                ASSERT(FALSE);
                // this is not a real notificaiton request.
                // this request is for session removal.
                // RemoveGlobalNotification(pRequest->SessionId, pRequest->SessonSerialNumber);
            }
            else
            {
                NotifyConsole (pRequest->SessionId, pRequest->SessonSerialNumber, pRequest->NotificationCode);
            }

            MemFree(pRequest);
            pRequest = NULL;
        }
    }
}

//
// this thread takes a notification request from queue and executes it.
// this thread gets signaled when a new item is added to the queue.
//
DWORD NotificationQueueWorker(LPVOID ThreadParameter)
{
    UNREFERENCED_PARAMETER(ThreadParameter);

    NotificationQueueWorkerEx();

    return 0;
}

NTSTATUS SetLockedState (PWINSTATION  pWinStation, BOOL bLocked)
{
    ASSERT(pWinStation);

    if (bLocked)
    {
        return NofifyWelcomeOn (pWinStation);
    }
    else
    {
        return NotifyWelcomeOff (pWinStation);
    }
}

NTSTATUS GetLockedState (PWINSTATION  pWinStation, BOOL *pbLocked)
{
    NTSTATUS Status;
    PNOTIFY_LIST pNotifyList;

    ASSERT(pbLocked);
    ASSERT(pWinStation);

    Status = GetNoficationListFromSessionId(pWinStation->LogonId, &pNotifyList, FALSE);
    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }

    *pbLocked = pNotifyList->SessionState.bLocked;
    ReleaseNotificationList(pNotifyList);
    return STATUS_SUCCESS;
}
/*
NTSTATUS GetSessionState (PWINSTATION  pWinStation, WTSSESSION_STATE *pSessionState)
{
    NTSTATUS Status;
    PNOTIFY_LIST pNotifyList;

    ASSERT(pSessionState);
    ASSERT(pWinStation);

    Status = GetNoficationListFromSessionId(pWinStation->LogonId, &pNotifyList, FALSE);
    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }

    *pSessionState = pNotifyList->SessionState;
    ReleaseNotificationList(pNotifyList);

    return STATUS_SUCCESS;
}
*/

NTSTATUS RemoveBadHwnd(ULONG hWnd, ULONG SessionId)
{
    PNOTIFY_ENTRY_GLOBAL pInvalidHwndEntry;
    PNOTIFY_LIST pInvalidHwndList;
    NTSTATUS Status;

    Status = GetInvlidHwndList(&pInvalidHwndList);
    
    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }

    pInvalidHwndEntry = GetHWndEntryFromGlobalList(pInvalidHwndList, hWnd, SessionId);
    //
    // this entry must not already exist in invalid list.
    //
    if(!pInvalidHwndEntry)
    {
        // it alreay exists in our list. 
        pInvalidHwndEntry = MemAlloc(sizeof(NOTIFY_ENTRY_GLOBAL));
        if (pInvalidHwndEntry)
        {
            pInvalidHwndEntry->hWnd = hWnd;
            pInvalidHwndEntry->SessionId = SessionId;
            InsertHeadList(&pInvalidHwndList->ListHead, &pInvalidHwndEntry->Links);
        }
    }
    
    ReleaseNotificationList( pInvalidHwndList );

    if (pInvalidHwndEntry)
        return STATUS_SUCCESS;
    else 
        return STATUS_NO_MEMORY;
}

NTSTATUS RemoveInvalidWindowsFromLists()
{
    PNOTIFY_LIST pInvalidHwndList;
    PLIST_ENTRY Next, Head;
    NTSTATUS Status;

    Status = GetInvlidHwndList(&pInvalidHwndList);
   
    if ( !NT_SUCCESS( Status ) )
    {
        return (Status);
    }

    Head = &pInvalidHwndList->ListHead;
    Next = Head->Flink;
    while (Head != Next)
    {
        PNOTIFY_ENTRY_GLOBAL pInvalidHwndEntry = CONTAINING_RECORD( Next, NOTIFY_ENTRY_GLOBAL, Links );
        Next = Next->Flink;
        ASSERT(pInvalidHwndEntry);
        Status = UnRegisterConsoleNotificationInternal (pInvalidHwndEntry->hWnd, pInvalidHwndEntry->SessionId, FALSE);

        // we are done removing this invalid hwnd entry from our lists.
        RemoveEntryList( &pInvalidHwndEntry->Links );
        MemFree(pInvalidHwndEntry);
        pInvalidHwndEntry = NULL;
    }

    ReleaseNotificationList(pInvalidHwndList);

    return STATUS_SUCCESS;
}


/*
    our order of locks is

    0. Invalid Hwnd List.
    1. Global Notification List
    2. Winstation
    3. List of Lists lock.
    4. Session Notification List
*/

//#ifdef MAKARANDS_HIGHER_WARNING_LEVEL
#pragma warning(pop)
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\conntfy.h ===
#ifndef __CONNTFY_H__
#define __CONNTFY_H__


#include <wtsapi32.h>

/*
 * interface
 */

NTSTATUS InitializeConsoleNotification      ();
NTSTATUS InitializeSessionNotification		(PWINSTATION  pWinStation);
NTSTATUS RemoveSessionNotification          (ULONG SessionId, ULONG SessionSerialNumber);

NTSTATUS RegisterConsoleNotification        (ULONG hWnd, ULONG SessionId, DWORD dwFlags);
NTSTATUS UnRegisterConsoleNotification      (ULONG hWnd, ULONG SessionId);

NTSTATUS NotifyDisconnect					(PWINSTATION  pWinStation, BOOL bConsole);
NTSTATUS NotifyConnect						(PWINSTATION  pWinStation, BOOL bConsole);
NTSTATUS NotifyLogon						(PWINSTATION  pWinStation);
NTSTATUS NotifyLogoff						(PWINSTATION  pWinStation);

NTSTATUS GetLockedState (PWINSTATION  pWinStation, BOOL *pbLocked);
NTSTATUS SetLockedState (PWINSTATION  pWinStation, BOOL bLocked);



#endif /* __CONNTFY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\helpasst.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    helpasst.h

Abstract:

    Prototype for Help Assistant account related function

Author:

    HueiWang    4/26/2000

--*/

#ifndef __HELPASST_H__
#define __HELPASST_H__

#include "tsremdsk.h"

#ifdef __cplusplus
extern "C"{
#endif

BOOL
TSIsSessionHelpSession(
    PWINSTATION pWinStation,
    BOOL* pValid
);

NTSTATUS
TSHelpAssistantQueryLogonCredentials(
    ExtendedClientCredentials* pCredential
);

BOOL
TSVerifyHelpSessionAndLogSalemEvent(
    PWINSTATION pWinStation
);

VOID
TSStartupSalem();

VOID
TSLogSalemReverseConnection(
    PWINSTATION pWinStation,
    PICA_STACK_ADDRESS pStackAddress
);

HRESULT
TSRemoteAssistancePrepareSystemRestore();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\lcrpc-s.c ===
#include <lcrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\helpasst.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    helpass.c

Abstract:

    Salem related function.

Author:

    HueiWang    4/26/2000

--*/

#define LSCORE_NO_ICASRV_GLOBALS
#include "precomp.h"
#include <tdi.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include "tsremdsk.h"
#include "sessmgr.h"
#include "sessmgr_i.c"

extern "C" 
NTSTATUS
xxxQueryRemoteAddress(
    PWINSTATION pWinStation,
    PWINSTATIONREMOTEADDRESS pRemoteAddress
);

HRESULT
__LogSalemEvent(
    IN IRemoteDesktopHelpSessionMgr* iSessMgr,
    IN ULONG eventType,
    IN ULONG eventCode,
    IN int numStrings,
    IN BSTR EventStrings[]
);

//
// Function copied from atlconv.h, we don't include
// any ATL header in termsrv.
//
BSTR A2WBSTR(LPCSTR lp)
{
    if (lp == NULL)
        return NULL;

    BSTR str = NULL;
    int nConvertedLen = MultiByteToWideChar(
                                    GetACP(), 0, lp,
                                    -1, NULL, NULL)-1;

    str = ::SysAllocStringLen(NULL, nConvertedLen);
    if (str != NULL)
    {
        MultiByteToWideChar(GetACP(), 0, lp, -1,
            str, nConvertedLen);
    }

    return str;
}

NTSTATUS
TSHelpAssistantQueryLogonCredentials(
    ExtendedClientCredentials* pCredential
    ) 
/*++

Description:

    Retrieve HelpAssistant logon credential, routine first retrieve
    infor passed from client and then decrypt password

Parameters:

    pWinStation : Pointer to WINSTATION
    pCredential : Pointer to ExtendedClientCredentials to receive HelpAssistant
                  credential.

Returns:

    STATUS_SUCCESS or STATUS_INVALID_PARAMETER

--*/
{
    LPWSTR pszHelpAssistantPassword = NULL;
    NTSTATUS Status;
    LPWSTR pszHelpAssistantAccountName = NULL;
    LPWSTR pszHelpAssistantAccountDomain = NULL;

    if( pCredential )
    {
        ZeroMemory( pCredential, sizeof(ExtendedClientCredentials) );

        Status = TSGetHelpAssistantAccountName(&pszHelpAssistantAccountDomain, &pszHelpAssistantAccountName);
        if( ERROR_SUCCESS == Status )
        {
            // make sure we don't overwrite buffer, length can't be
            // more than 255 characters.
            lstrcpyn( 
                    pCredential->UserName, 
                    pszHelpAssistantAccountName, 
                    EXTENDED_USERNAME_LEN 
                );

            lstrcpyn(
                    pCredential->Domain,
                    pszHelpAssistantAccountDomain,
                    EXTENDED_DOMAIN_LEN
                );

            Status = TSGetHelpAssistantAccountPassword( &pszHelpAssistantPassword );
            if( ERROR_SUCCESS == Status )
            {
                ASSERT( lstrlen(pszHelpAssistantPassword) < EXTENDED_PASSWORD_LEN );

                if( lstrlen(pszHelpAssistantPassword) < EXTENDED_PASSWORD_LEN )
                {
                    // Password contains encrypted version, overwrite with
                    // clear text.
                    lstrcpy( pCredential->Password, pszHelpAssistantPassword );
                }
                else
                {
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
        }
    }
    else
    {
        ASSERT( FALSE );
        Status = STATUS_INVALID_PARAMETER;
    }

    if( NULL != pszHelpAssistantAccountDomain )
    {
        LocalFree( pszHelpAssistantAccountDomain );
    }

    if( NULL != pszHelpAssistantAccountName )
    {
        LocalFree(pszHelpAssistantAccountName);
    }

    if( NULL != pszHelpAssistantPassword )
    {
        LocalFree( pszHelpAssistantPassword );
    }

    return Status;
}


BOOL
TSIsSessionHelpSession(
    PWINSTATION pWinStation,
    BOOL* pValid
    )
/*++

Routine Description:

    Determine if a session is HelpAssistant session.

Parameters:

    pWinStation : Pointer to WINSTATION structure.
    pValid : Optional Pointer to BOOL to receive status of ticket, 
             TRUE of ticket is valid, FALSE if ticket is invalid or
             help is disabled.

Returns:

    TRUE/FALSE Funtion return TRUE even if ticket is invalid, caller
    should check pValid to determine if ticket is valid or not.

--*/
{
    BOOL bReturn;
    BOOL bValidHelpSession = FALSE;

    if( NULL == pWinStation )
    {
        ASSERT( NULL != pWinStation );
        SetLastError( ERROR_INVALID_PARAMETER );
        bReturn = FALSE;
        goto CLEANUPANDEXIT;
    }

    if( pWinStation->Client.ProtocolType != PROTOCOL_RDP )
    {
        //
        // HelpAssistant is RDP specific and not on console        
        DBGPRINT( ("TermSrv : HelpAssistant protocol type not RDP \n") );
        bValidHelpSession = FALSE;
        bReturn = FALSE;
    }
    else if( WSF_ST_HELPSESSION_NOTHELPSESSION & pWinStation->StateFlags )
    {
        // We are sure that this session is not HelpAssistant Session.
        bReturn = FALSE;
        bValidHelpSession = FALSE;
    }
    else if( WSF_ST_HELPSESSION_HELPSESSIONINVALID & pWinStation->StateFlags )
    {
        // Help assistant logon but password or ticket ID is invalid
        bReturn = TRUE;
        bValidHelpSession = FALSE;
    }
    else if( WSF_ST_HELPSESSION_HELPSESSION & pWinStation->StateFlags )
    {
        // We are sure this is help assistant logon
        bReturn = TRUE;
        bValidHelpSession = TRUE;
    }
    else
    {
        //
        // Clear RA state flags.
        //
        pWinStation->StateFlags &= ~WSF_ST_HELPSESSION_FLAGS;

        if( !pWinStation->Client.UserName[0] || !pWinStation->Client.Password[0] || 
            !pWinStation->Client.WorkDirectory[0] )
        {
            bReturn = FALSE;
            bValidHelpSession = FALSE;
            pWinStation->StateFlags |= WSF_ST_HELPSESSION_NOTHELPSESSION;
        }
        else
        {
            //
            // TermSrv might call this routine with data send from client,
            // client always send hardcoded SALEMHELPASSISTANTACCOUNT_NAME
            //
            if( lstrcmpi( pWinStation->Client.UserName, SALEMHELPASSISTANTACCOUNT_NAME ) )
            {
                bReturn = FALSE;
                bValidHelpSession = FALSE;
                pWinStation->StateFlags |= WSF_ST_HELPSESSION_NOTHELPSESSION;
                goto CLEANUPANDEXIT;
            }

            //
            // this is helpassistant login.
            //
            bReturn = TRUE;

            //
            // Check if machine policy restrict help or
            // in Help mode, deny access if not.
            //
            if( FALSE == TSIsMachinePolicyAllowHelp() || FALSE == TSIsMachineInHelpMode() )
            {
                bValidHelpSession = FALSE;
                pWinStation->StateFlags |= WSF_ST_HELPSESSION_HELPSESSIONINVALID;
                goto CLEANUPANDEXIT;
            }

            if( TSVerifyHelpSessionAndLogSalemEvent(pWinStation) )
            {
                bValidHelpSession = TRUE;
                pWinStation->StateFlags |= WSF_ST_HELPSESSION_HELPSESSION;
            }
            else
            {
                //
                // Either ticket is invalid or expired.
                //
                bValidHelpSession = FALSE;
                pWinStation->StateFlags |= WSF_ST_HELPSESSION_HELPSESSIONINVALID;
            }
        }
    }

CLEANUPANDEXIT:

    if( pValid )
    {
        *pValid = bValidHelpSession;
    }

    return bReturn;
}


DWORD WINAPI
SalemStartupThreadProc( LPVOID ptr )
/*++

Temporary code to start up Salem sessmgr, post B2 need to move sessmgr into svchost

--*/
{
    HRESULT hRes = S_OK;
    IRemoteDesktopHelpSessionMgr* pISessMgr = NULL;

    if( TSIsMachineInSystemRestore() ) {
        // Ignore value if we can restore cached LSA key.
        // user can always resend ticket again as in XP.
        TSSystemRestoreResetValues();
    }

    //
    // Startup sessmgr if there is outstanding ticket and 
    // we just rebooted from system restore.
    //
    if( !TSIsMachineInHelpMode() )
    {
        ExitThread(hRes);
        return hRes;
    }

    hRes = CoInitialize( NULL );
    if( FAILED(hRes) )
    {
        DBGPRINT( ("TermSrv : TSStartupSalem() CoInitialize() failed with 0x%08x\n", hRes) );

        // Failed in COM, return FALSE.
        goto CLEANUPANDEXIT;
    }

    hRes = CoCreateInstance(
                        CLSID_RemoteDesktopHelpSessionMgr,
                        NULL,
                        CLSCTX_ALL,
                        IID_IRemoteDesktopHelpSessionMgr,
                        (LPVOID *) &pISessMgr
                    );                    
    if( FAILED(hRes) || NULL == pISessMgr )
    {
        DBGPRINT( ("TermSrv : TSStartupSalem() CoCreateInstance() failed with 0x%08x\n", hRes) );

        // Can't initialize sessmgr
        goto CLEANUPANDEXIT;
    }

CLEANUPANDEXIT:

    if( NULL != pISessMgr )
    {
        pISessMgr->Release();
    }

    CoUninitialize();

    ExitThread(hRes);
    return hRes;
}

void
TSStartupSalem()
{
    HANDLE hThread;

    hThread = CreateThread( NULL, 0, SalemStartupThreadProc, NULL, 0, NULL );
    if( NULL != hThread )
    {
        CloseHandle( hThread );
    }

    return;
}

BOOL
TSVerifyHelpSessionAndLogSalemEvent(
    PWINSTATION pWinStation
    )
/*++

Description:

    Verify help session is a valid, non-expired pending help session,
    log an event if help session is invalid.

Parameters:

    pWinStation : Point to WINSTATION

Returns:

    TRUE/FALSE

Note :

    WorkDirectory is HelpSessionID and InitialProgram contains
    password to pending help session

--*/
{
    HRESULT hRes;
    IRemoteDesktopHelpSessionMgr* pISessMgr = NULL;
    BOOL bSuccess = FALSE;
    BSTR bstrHelpSessId = NULL;
    BSTR bstrHelpSessPwd = NULL;
    WINSTATIONREMOTEADDRESS winstationRemoteAddress;
    DWORD dwReturnLength;
    NTSTATUS Status;

    BSTR bstrExpertIpAddressFromClient = NULL;
    BSTR bstrExpertIpAddressFromServer = NULL;

    // only have three strings in this event
    BSTR bstrEventStrings[3];


    hRes = CoInitialize( NULL );
    if( FAILED(hRes) )
    {
        DBGPRINT( ("TermSrv : TSIsHelpSessionValid() CoInitialize() failed with 0x%08x\n", hRes) );

        // Failed in COM, return FALSE.
        return FALSE;
    }

    hRes = CoCreateInstance(
                        CLSID_RemoteDesktopHelpSessionMgr,
                        NULL,
                        CLSCTX_ALL,
                        IID_IRemoteDesktopHelpSessionMgr,
                        (LPVOID *) &pISessMgr
                    );                    
    if( FAILED(hRes) || NULL == pISessMgr )
    {
        DBGPRINT( ("TermSrv : TSIsHelpSessionValid() CoCreateInstance() failed with 0x%08x\n", hRes) );

        // Can't initialize sessmgr
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the security level to impersonate.  This is required by
    //  the session manager.
    //
    hRes = CoSetProxyBlanket(
                    (IUnknown *)pISessMgr,
                    RPC_C_AUTHN_DEFAULT,
                    RPC_C_AUTHZ_DEFAULT,
                    NULL,
                    RPC_C_AUTHN_LEVEL_DEFAULT,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE
                );

    if( FAILED(hRes) )
    {
        DBGPRINT( ("TermSrv : TSIsHelpSessionValid() CoSetProxyBlanket() failed with 0x%08x\n", hRes) );

        // can't impersonate, return FALSE
        goto CLEANUPANDEXIT;
    }

    bstrHelpSessId = ::SysAllocString(pWinStation->Client.WorkDirectory);
    bstrHelpSessPwd = ::SysAllocString(pWinStation->Client.InitialProgram);

    if( NULL == bstrHelpSessId || NULL == bstrHelpSessPwd )
    {
        // We are so out of memory, treat as error
        goto CLEANUPANDEXIT;
    }

    // Verify help session
    hRes = pISessMgr->IsValidHelpSession(
                                    bstrHelpSessId,
                                    bstrHelpSessPwd
                                );

    bSuccess = SUCCEEDED(hRes);

    if( FALSE == bSuccess )
    {
        // Log invalid help ticket event here.
        Status = xxxQueryRemoteAddress( pWinStation, &winstationRemoteAddress );
        bstrExpertIpAddressFromClient = ::SysAllocString( pWinStation->Client.ClientAddress );

        if( !NT_SUCCESS(Status) || AF_INET != winstationRemoteAddress.sin_family )
        {
            //
            // we don't support other than IPV4 now or we failed to retrieve address
            // from driver, use what's send in from client.
            bstrExpertIpAddressFromServer = ::SysAllocString( pWinStation->Client.ClientAddress );
        }
        else
        {
            // refer to in_addr structure.
            struct in_addr S;
            S.S_un.S_addr = winstationRemoteAddress.ipv4.in_addr;

            bstrExpertIpAddressFromServer = A2WBSTR( inet_ntoa(S) );
        }

        if( !bstrExpertIpAddressFromClient || !bstrExpertIpAddressFromServer )
        {
            // we are out of memory, can't log event.
            goto CLEANUPANDEXIT;
        }

        bstrEventStrings[0] = bstrExpertIpAddressFromClient;
        bstrEventStrings[1] = bstrExpertIpAddressFromServer;
        bstrEventStrings[2] = bstrHelpSessId;

        __LogSalemEvent( 
                    pISessMgr, 
                    EVENTLOG_INFORMATION_TYPE,
                    REMOTEASSISTANCE_EVENTLOG_TERMSRV_INVALID_TICKET,
                    3,
                    bstrEventStrings
                );
    }

CLEANUPANDEXIT:

    if( NULL != pISessMgr )
    {
        pISessMgr->Release();
    }

    if( NULL != bstrHelpSessId )
    {
        ::SysFreeString( bstrHelpSessId );
    }

    if( NULL != bstrHelpSessPwd )
    {
        ::SysFreeString( bstrHelpSessPwd );
    }

    if( NULL != bstrExpertIpAddressFromClient )
    {
        ::SysFreeString( bstrExpertIpAddressFromClient );
    }

    if( NULL != bstrExpertIpAddressFromServer )
    {
        ::SysFreeString( bstrExpertIpAddressFromServer );
    }

    DBGPRINT( ("TermSrv : TSIsHelpSessionValid() returns 0x%08x\n", hRes) );
    CoUninitialize();
    return bSuccess;
}


VOID
TSLogSalemReverseConnection(
    PWINSTATION pWinStation,
    PICA_STACK_ADDRESS pStackAddress
    )
/*++

--*/
{
    HRESULT hRes;
    IRemoteDesktopHelpSessionMgr* pISessMgr = NULL;
    BOOL bSuccess = FALSE;

    int index;

    // Fours string for this event
    BSTR bstrEventStrings[3];

    ZeroMemory( bstrEventStrings, sizeof(bstrEventStrings) );

    hRes = CoInitialize( NULL );
    if( FAILED(hRes) )
    {
        DBGPRINT( ("TermSrv : TSLogSalemReverseConnection() CoInitialize() failed with 0x%08x\n", hRes) );

        goto CLEANUPANDEXIT;
    }

    hRes = CoCreateInstance(
                        CLSID_RemoteDesktopHelpSessionMgr,
                        NULL,
                        CLSCTX_ALL,
                        IID_IRemoteDesktopHelpSessionMgr,
                        (LPVOID *) &pISessMgr
                    );                    
    if( FAILED(hRes) || NULL == pISessMgr )
    {
        DBGPRINT( ("TermSrv : TSLogSalemReverseConnection() CoCreateInstance() failed with 0x%08x\n", hRes) );

        // Can't initialize sessmgr
        goto CLEANUPANDEXIT;
    }

    //
    //  Set the security level to impersonate.  This is required by
    //  the session manager.
    //
    hRes = CoSetProxyBlanket(
                    (IUnknown *)pISessMgr,
                    RPC_C_AUTHN_DEFAULT,
                    RPC_C_AUTHZ_DEFAULT,
                    NULL,
                    RPC_C_AUTHN_LEVEL_DEFAULT,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE
                );

    if( FAILED(hRes) )
    {
        DBGPRINT( ("TermSrv : TSLogSalemReverseConnection() CoSetProxyBlanket() failed with 0x%08x\n", hRes) );

        // can't impersonate, return FALSE
        goto CLEANUPANDEXIT;
    }

    //
    // sessmgr expect event string in following order
    //
    //  IP address send from client.
    //  IP address that termsrv connect to, this is part of the expert connect parm.
    //  Help Session Ticket ID
    //  

    bstrEventStrings[0] = ::SysAllocString( pWinStation->Client.ClientAddress );

    {
        struct in_addr S;
        PTDI_ADDRESS_IP pIpAddress = (PTDI_ADDRESS_IP)&((PCHAR)pStackAddress)[2];

        // refer to in_addr structure.
        S.S_un.S_addr = pIpAddress->in_addr;
        bstrEventStrings[1] = A2WBSTR( inet_ntoa(S) );
    }

    bstrEventStrings[2] = ::SysAllocString(pWinStation->Client.WorkDirectory);

    if( NULL != bstrEventStrings[0] &&
        NULL != bstrEventStrings[1] &&
        NULL != bstrEventStrings[2] ) 
    {
        hRes = __LogSalemEvent(
                            pISessMgr,
                            EVENTLOG_INFORMATION_TYPE,
                            REMOTEASSISTANCE_EVENTLOG_TERMSRV_REVERSE_CONNECT,
                            3,
                            bstrEventStrings
                        );
    }
    

CLEANUPANDEXIT:

    if( NULL != pISessMgr )
    {
        pISessMgr->Release();
    }

    for(index=0; index < sizeof(bstrEventStrings)/sizeof(bstrEventStrings[0]); index++)
    {
        if( !bstrEventStrings[index] )
        {
            ::SysFreeString( bstrEventStrings[index] );
        }
    }

    DBGPRINT( ("TermSrv : TSLogSalemReverseConnection() returns 0x%08x\n", hRes) );
    CoUninitialize();
    return;
}

HRESULT
__LogSalemEvent(
    IN IRemoteDesktopHelpSessionMgr* pISessMgr,
    IN ULONG eventType,
    IN ULONG eventCode,
    IN int numStrings,
    IN BSTR bstrEventStrings[]
    )
/*++

Description:

    Create a safearray and pass parameters to sessmgr.

Parameters:


Returns:

    S_OK or error code.

--*/
{
    HRESULT hRes = S_OK;
    VARIANT EventStrings;
    int index;

    // we only have three string to be included in the event log.
    SAFEARRAY* psa = NULL;
    SAFEARRAYBOUND bounds;
    BSTR* bstrArray = NULL;

    bounds.cElements = numStrings;
    bounds.lLbound = 0;

    VariantInit(&EventStrings);

    //
    // Create a safearray to pass all event string
    // 
    psa = SafeArrayCreate(VT_BSTR, 1, &bounds);
    if( NULL == psa )
    {
        goto CLEANUPANDEXIT;
    }

    // Required, lock the safe array
    hRes = SafeArrayAccessData(psa, (void **)&bstrArray);

    if( SUCCEEDED(hRes) )
    {
        for(index=0; index < numStrings; index++)
        {
            bstrArray[index] = bstrEventStrings[index];
        }

        EventStrings.vt = VT_ARRAY | VT_BSTR;
        EventStrings.parray = psa;
        hRes = pISessMgr->LogSalemEvent(
                                eventType,
                                eventCode,
                                &EventStrings
                            );

        //
        // make sure we clear BSTR array or VariantClear() will invoke
        // SafeArrayDestroy() which in term will invoke ::SysFreeString()
        // on each BSTR.
        //        
        for(index=0; index < numStrings; index++)
        {
            bstrArray[index] = NULL;
        }

        hRes = SafeArrayUnaccessData( psa );
        ASSERT( SUCCEEDED(hRes) );


        // make sure we don't destroy safe array twice, VariantClear()
        // will destroy it.
        psa = NULL;
    }
               

CLEANUPANDEXIT:

    hRes = VariantClear(&EventStrings);
    ASSERT( SUCCEEDED(hRes) );

    if( psa != NULL )
    {
        SafeArrayDestroy(psa);
    }

    return hRes;
}

HRESULT
TSRemoteAssistancePrepareSystemRestore()
/*++

Routine Description:

    Prepare system for RA specific system restore, this includes RA specific encryption key, 
    registry settings that we need preserve.

Parameters:

    None.

Returns:

    S_OK or error code.

--*/
{
    // Here we have different implementation for XPSP1 and .NET, on .NET, all Salem related
    // stuff goes into sessmgr, that is this function will invoke sessmgr's necessay method to 
    // deal with system restore; however, SP1 installer does not kick off same OCMANAGER setup
    // and we will also have to worry about SP1 uinstall issue.  When merging two tree on longhorn
    // we need to take .NET approach.
    return TSSystemRestoreCacheValues();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\icasrv.h ===
/****************************************************************************/
// icasrv.h
//
// TermSrv types, data, prototypes.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include <tssd.h>
#include <tssec.h>



#ifdef __cplusplus
extern "C" {
#endif

#define STR_CITRIX_IDLE_TITLE   249
#define STR_CITRIX_IDLE_MSG_LOGOFF 250
#define STR_CITRIX_LOGON_TITLE  251
#define STR_CITRIX_LOGON_MSG_LOGOFF 252
#define STR_CITRIX_SHADOW_TITLE 253
#define STR_CITRIX_SHADOW_MSG_1 254
#define STR_CITRIX_SHADOW_MSG_2 255
#define STR_TEMP_LICENSE_EXPIRED_MSG        257
#define STR_TEMP_LICENSE_EXPIRATION_MSG     258
#define STR_TEMP_LICENSE_MSG_TITLE          259
#define STR_ALL_LAN_ADAPTERS                260
#define STR_CANNOT_ALLOW_CONCURRENT_MSG     261
#define STR_CITRIX_IDLE_MSG_DISCON 262
#define STR_CITRIX_LOGON_MSG_DISCON 263
#define STR_FUS_REMOTE_DISCONNECT_TITLE     264
#define STR_FUS_REMOTE_DISCONNECT_MSG       265

/*
 *  Resource definitions for the Licensing Core.
 */

#define IDS_LSCORE_RA_NAME 1100
#define IDS_LSCORE_RA_DESC 1101
#define IDS_LSCORE_PERSEAT_NAME 1200
#define IDS_LSCORE_PERSEAT_DESC 1201
#define IDS_LSCORE_CONCURRENT_NAME 1300
#define IDS_LSCORE_CONCURRENT_DESC 1301

/*
 * defines for memory allocation
 */
#define MemAlloc( _x )  RtlAllocateHeap( IcaHeap, 0, _x )
#define MemFree( _p )   RtlFreeHeap( IcaHeap, 0, _p )

/*
 * Prototype for reference lock delete procedure
 */
typedef VOID (*PREFLOCKDELETEPROCEDURE)( struct _REFLOCK * );

typedef struct _WINSTATION *PWINSTATION;


/*
 * Reference counted lock structure
 */
typedef struct _REFLOCK {
    HANDLE Mutex;                       // mutex handle
    LONG RefCount;                      // reference count
    BOOLEAN Invalid;                    // containing struct no longer valid
    PREFLOCKDELETEPROCEDURE pDeleteProcedure; // pointer to delete procedure
} REFLOCK, *PREFLOCK;

/*
 * Structure used to get the exact credentials used for logon by the client
 * We use this to send back the notification to the client
 */
typedef struct _CLIENTNOTIFICATIONCREDENTIALS {
    WCHAR UserName[EXTENDED_USERNAME_LEN + 1];
    WCHAR Domain[EXTENDED_DOMAIN_LEN + 1] ; 
} CLIENTNOTIFICATIONCREDENTIALS, *PCLIENTNOTIFICATIONCREDENTIALS; 


//
// Private contents of the autoreconnect cookie
//

typedef struct _AUTORECONNECTIONINFO {
    BOOLEAN Valid;    
    BYTE  ArcRandomBits[ARC_SC_SECURITY_TOKEN_LEN];
} AUTORECONNECTIONINFO, *PAUTORECONNECTIONINFO; 


/*
 * Remembered Client address structure
 */


typedef struct _REMEMBERED_CLIENT_ADDRESS{
    ULONG length;
    BYTE  addr[1];
} REMEMBERED_CLIENT_ADDRESS, *PREMEMBERED_CLIENT_ADDRESS;

typedef enum _RECONNECT_TYPE {
    NeverReconnected = 0,
    ManualReconnect,
    AutoReconnect
} RECONNECT_TYPE, *PRECONNECT_TYPE; 


/*
 * Session Manager WinStation struct
 */
typedef struct _WINSTATION {
    LIST_ENTRY Links;
    BOOLEAN Starting;                   // WinStation is starting
    BOOLEAN Terminating;                // WinStation is terminating
    BOOLEAN NeverConnected;             // WinStation not connected yet
    REFLOCK Lock;
    ULONG LogonId;                      // Logon Id
    WINSTATIONNAME WinStationName;      // WinStation Name
    WINSTATIONNAME ListenName;          // Listen Name (for limits checking)
    WINSTATIONCONFIG2 Config;           // WinStation Config
    WINSTATIONCLIENT Client;            // WinStation client data

    ULONG State;                        // current state
    ULONG Flags;                        // WinStation Flags (see WSF_??? below)
    PVOID pSecurityDescriptor;
    HANDLE CreateEvent;
    NTSTATUS CreateStatus;
    HANDLE ConnectEvent;

    HANDLE hIca;                        // WinStation's primary Device
    HANDLE hStack;                      // WinStation's primary stack

    ULONG ShadowId;
    HANDLE hPassthruStack;              // passthru (shadow client) stack
    HANDLE ShadowBrokenEvent;
    HANDLE ShadowDoneEvent;
    HANDLE ShadowDisplayChangeEvent;
    NTSTATUS ShadowTargetStatus;
    BOOLEAN ShadowConnectionWait;

    LIST_ENTRY ShadowHead;              // head of shadow list

    HANDLE WindowsSubSysProcess;        // process handle for Win32 SS (csrss)
    HANDLE WindowsSubSysProcessId;      // process id for Win32 SS
    HANDLE InitialCommandProcess;       // process handle for initial command
    HANDLE InitialCommandProcessId;     // process id for initial command
    BOOLEAN InitialProcessSet;          // Flag for console communication

    HANDLE CsrStartEventHandle;         // Handle for CsrStartEvent

    HANDLE Win32CommandPort;
    PORT_MESSAGE Win32CommandPortMsg;
    LIST_ENTRY Win32CommandHead;        // head of COMMAND_ENTRY list
    struct _LPC_CLIENT_CONTEXT *pWin32Context;

    PSID pUserSid;                      // SID for currently logged on user
    WCHAR Password[PASSWORD_LENGTH+1];  // password for currently logged on user
    UCHAR Seed;                         // seed for above password

    HANDLE UserToken;                   // User Token

    HANDLE hIdleTimer;
    HANDLE hLogonTimer;
    HANDLE hDisconnectTimer;

    ULONG fIdleTimer : 1;
    ULONG fLogonTimer : 1;
    ULONG fDisconnectTimer : 1;

    LARGE_INTEGER ConnectTime;
    LARGE_INTEGER DisconnectTime;
    LARGE_INTEGER LogonTime;
    WCHAR Domain[ DOMAIN_LENGTH + 1 ];   // Domain
    WCHAR UserName[USERNAME_LENGTH + 1]; // UserName

    BYTE VideoModuleName[9];            // For reconnect checking

    HANDLE hConnectThread;              // Connect thread for this WinStation

    HANDLE hIcaBeepChannel;
    HANDLE hIcaThinwireChannel;

    PVOID pEndpoint;
    ULONG EndpointLength;

    struct _WSEXTENSION *pWsx;
    PVOID  pWsxContext;

    BROKENCLASS BrokenReason;           // reason/source why this WinStation..
    BROKENSOURCECLASS BrokenSource;     // ..is being reset/disconnected

    ULONG StateFlags;                   // WinStation State (see WSF_ST_??? below)
    ULONG SessionSerialNumber;          // Session Id is reused when session is deleted. Serial number not

    PSID pProfileSid;                   // SID for previously logged on user kept for profile cleanup
    BOOLEAN fOwnsConsoleTerminal;       // session currently connected to the console

    WCHAR DisplayDriverName[9];
    WCHAR ProtocolName[9];

    LPARAM lpLicenseContext;                        // Licensing context for the winstation
    BOOLEAN fUserIsAdmin;               // Needed for LLS licensing

    // Server pool (cluster) support - disconnected session query results
    // and client capabilities for this client.
    ULONG bClientSupportsRedirection : 1;
    ULONG bRequestedSessionIDFieldValid : 1;
    ULONG bClientRequireServerAddr : 1;
    UINT32 RequestedSessionID;
    unsigned NumClusterDiscSessions;
    TSSD_DisconnectedSessionInfo ClusterDiscSessions[TSSD_MaxDisconnectedSessions];

    HANDLE hWinmmConsoleAudioEvent;     // Event that set if console audio is enabled remotely
    // Support for longer UserName and Password during client autologon to a Terminal Server
    pExtendedClientCredentials pNewClientCredentials ; 

    HANDLE hReconnectReadyEvent;
    // The following structure is used to send back the logon notification to the client
    PCLIENTNOTIFICATIONCREDENTIALS pNewNotificationCredentials;

    // Cache original shadow setting when session is created.
    // this is to fix a security hole created by Salem/pcHealth in that
    // pcHealth dynamically switch shadow to full control without
    // user permission and does not reset it, a normal
    // termination of Help will trigger Salem sessmgr to reset shadow 
    // back to original setting, but a bad expert can stop sessmgr service
    // and our session's shadow setting will still be FULL CONTROL
    // WITHOUT USER PERMISSION, anyone with enough priviledge can then
    // start shadow and take control of this session .
    SHADOWCLASS OriginalShadowClass;
    //termsrv's cached cache statistics
    CACHE_STATISTICS Cache;
    PREMEMBERED_CLIENT_ADDRESS pRememberedAddress;
    AUTORECONNECTIONINFO AutoReconnectInfo;
    RECONNECT_TYPE LastReconnectType;
    BOOLEAN fDisallowAutoReconnect;
} WINSTATION, *PWINSTATION;

/*
 * WinStation Flags
 */
#define WSF_CONNECT     0x00000001      // being connected
#define WSF_DISCONNECT  0x00000002      // being disconnected
#define WSF_RESET       0x00000004      // being reset
#define WSF_DELETE      0x00000008      // being deleted
#define WSF_DOWNPENDING 0x00000010      // down pending
#define WSF_LOGOFF      0x00000020      // being logged off
#define WSF_LISTEN      0x00000040      // this is a "listening" WinStation
#define WSF_IDLE        0x00000080      // part of the idle pool
#define WSF_IDLEBUSY    0x00000100      // idle but in process of connecting
#define WSF_AUTORECONNECTING 0x00000200 // autoreconnecting


/*
 *  WinStation State Flags
 */

#define WSF_ST_WINSTATIONTERMINATE  0x00000001  //Called WinstationTerminate for this session
#define WSF_ST_DELAYED_STACK_TERMINATE  0x00000002 //Need to delay stack termination till WinstationDeleProc()
#define WSF_ST_BROKEN_CONNECTION    0x00000004 // received a broken connection indication
#define WSF_ST_CONNECTED_TO_CSRSS   0x00000008 // Connected or reconnected to CSRSS
#define WSF_ST_IN_DISCONNECT       0x00000010 // Disconnect processing is pending
#define WSF_ST_LOGON_NOTIFIED       0x00000020 // Logon notification is received
#define WSF_ST_SHADOW      0x00000200      // In shadow or waiting for user

/*
 * Help Assistant Session flag.
 *  3 bits, winlogon, msgina, licensing query termsrv in different
 *  phrase of logon, we don't want to make repeated call, and since
 *  we can't be sure if a session is a help session until winlogon
 *  actually logon a user, we need more than TRUE/FALSE bit.
 */
#define WSF_ST_HELPSESSION_FLAGS                        0xF0000000      // reserved flags.
#define WSF_ST_HELPSESSION_NOTSURE                      0x00000000      // No sure it is helpassistant session
#define WSF_ST_HELPSESSION_NOTHELPSESSION               0x20000000      // Detemined not a helpassistant session
#define WSF_ST_HELPSESSION_HELPSESSION                  0x40000000      // Session is a helpassistant session
#define WSF_ST_HELPSESSION_HELPSESSIONINVALID           0x80000000      // HelpAssistant logon but ticket is invalid
/*
 * Reconnect struct
 *
 * This structure is used to store WinStation connection information.
 * This structure is transferred from one WinStation to another when
 * processing a reconnect.
 */
typedef struct _RECONNECT_INFO {
    WINSTATIONNAME WinStationName;      // WinStation Name
    WINSTATIONNAME ListenName;          // WinStation Name
    WINSTATIONCONFIG2 Config;           // Registry config data
    WINSTATIONCLIENT Client;            // WinStation client data
    struct _WSEXTENSION *pWsx;
    PVOID pWsxContext;
    HANDLE hIca;                        // temp ICA device handle to connect
                                        // stack to while in disconnect state
    HANDLE hStack;                      // handle of stack being reconnected
    PVOID pEndpoint;                    // endpoint data for connection..
    ULONG EndpointLength;               // ..being reconnected
    BOOLEAN fOwnsConsoleTerminal;       // session currently connected to the console
    WCHAR   DisplayDriverName[9];
    WCHAR   ProtocolName[9];
    // The following structure is used to send back the logon notification to the client
    PCLIENTNOTIFICATIONCREDENTIALS pNotificationCredentials;
} RECONNECT_INFO, *PRECONNECT_INFO;


/*
 * Shadow entry
 * There is one of these for each shadow client,
 * linked from the target WinStation (ShadowHead).
 */
typedef struct _SHADOW_INFO {
    LIST_ENTRY Links;
    HANDLE hStack;
    HANDLE hBrokenEvent;
    PVOID pEndpoint;
    ULONG EndpointLength;
} SHADOW_INFO, *PSHADOW_INFO;


/*
 * Command entry struct
 */
typedef struct _COMMAND_ENTRY {
    LIST_ENTRY Links;
    HANDLE Event;
    struct _WINSTATION_APIMSG * pMsg;
} COMMAND_ENTRY, *PCOMMAND_ENTRY;


/*
 * Event wait structure
 */
typedef struct _EVENT {
    LIST_ENTRY EventListEntry;
    HANDLE   Event;
    BOOLEAN  fWaiter;
    BOOLEAN  fClosing;
    NTSTATUS WaitResult;
    ULONG    EventMask;
    ULONG    EventFlags;
} EVENT, *PEVENT;

/*
 * RPC client context structure
 */
typedef struct _RPC_CLIENT_CONTEXT{
    PEVENT pWaitEvent;
} RPC_CLIENT_CONTEXT, *PRPC_CLIENT_CONTEXT;




/*
 * This structure is used to keep track of the client accessing the
 * LPC interfaces. This structure is pointed to by the CONTEXT value
 * that the NT LPC system maintains for us on a per communication port
 * basis.
 */
typedef struct _LPC_CLIENT_CONTEXT {
    ULONG     ClientLogonId;
    HANDLE    CommunicationPort;
    ULONG     AccessRights;
    PVOID     ClientViewBase;
    PVOID     ClientViewBounds;
    PVOID     ViewBase;
    SIZE_T     ViewSize;
    PVOID     ViewRemoteBase;
} LPC_CLIENT_CONTEXT, *PLPC_CLIENT_CONTEXT;


typedef struct _LOAD_BALANCING_METRICS {

    BOOLEAN fInitialized;

    // Basic system information
    ULONG NumProcessors;
    ULONG PageSize;
    ULONG PhysicalPages;

    // Idle system values to remove base system usage
    ULONG BaselineFreePtes ;
    ULONG BaselinePagedPool;
    ULONG BaselineCommit;

    // Minimum usage values to prevent absurdly large estimates
    ULONG MinPtesPerUser;
    ULONG MinPagedPoolPerUser;
    ULONG MinCommitPerUser;

    // Live usage values derived from runtime data: totals
    ULONG PtesUsed;
    ULONG PagedPoolUsed;
    ULONG CommitUsed;

    // Live usage values derived from runtime data: per user
    ULONG AvgPtesPerUser;
    ULONG AvgPagedPoolPerUser;
    ULONG AvgCommitPerUser;

    // Raw and Estimated values for session capacity
    ULONG RemainingSessions;
    ULONG EstimatedSessions;

    // CPU utilization metrics
    ULONG AvgIdleCPU;
    LARGE_INTEGER TotalCPU;
    LARGE_INTEGER IdleCPU;

} LOAD_BALANCING_METRICS, *PLOAD_BALANCING_METRICS;


// TODO: Is there a better place to get this value from?
//
#define MAX_PROCESSORS      32


// Minimum assumed resource usage per user
//
// TODO: Use these as registry defaults, but attempt to read from registry
//

// Floating point optimization: (Avg >> 1) == 0.50 (growth reservation)
#define SimGrowthBias             1
#define SimUserMinimum            5

// DEW (34 threads) = 1434KB (PTE) + 649KB (PP) + 172KB (NPP)
#define DEWAvgPtesPerUser         1434
#define DEWAvgPagedPoolPerUser    649 
#define DEWAvgNonPagedPoolPerUser 172
#define DEWCommitPerUser          3481

// KW  (65 threads) = 2812KB (PTE) + 987KB (PP) + 460KB (NPP)
#define KWAvgPtesPerUser          2812
#define KWAvgPagedPoolPerUser     987
#define KWAvgNonPagedPoolPerUser  460
#define KWCommitPerUser           7530

#define SimAvgPtesPerUser         DEWAvgPtesPerUser
#define SimAvgPagedPoolPerUser    DEWAvgPagedPoolPerUser
#define SimAvgNonPagedPoolPerUser DEWAvgNonPagedPoolPerUser
#define SimCommitPerUser          DEWCommitPerUser

/*
 * Global variables
 */
extern BOOLEAN ShutdownInProgress;
//extern BOOLEAN ShutdownTerminateNoWait;
extern ULONG ShutDownFromSessionID;
extern RTL_CRITICAL_SECTION WinStationListLock;
extern RTL_CRITICAL_SECTION WinStationListenersLock;
extern RTL_CRITICAL_SECTION TimerCritSec;
extern LIST_ENTRY SystemEventHead;
extern HANDLE hTrace;
extern BOOL g_bPersonalTS;
extern BOOL g_bPersonalWks;
extern BOOL gbServer;
extern BOOLEAN g_fDenyTSConnectionsPolicy;

/*
 * Globals to support load balancing.  Since this is queried frequently we can't
 * afford to lock the winstation list and count them up.
 */
extern ULONG IdleWinStationPoolCount;
extern ULONG WinStationTotalCount;
extern ULONG WinStationDiscCount;
extern LOAD_BALANCING_METRICS gLB;

extern ExtendedClientCredentials g_MprNotifyInfo;


/*
 * Function prototypes
 */
NTSTATUS InitTermSrv(HKEY);

void StartAllWinStations(HKEY);

NTSTATUS CheckWinStationEnable(LPWSTR);

NTSTATUS SetWinStationEnable(LPWSTR, ULONG);

NTSTATUS
LoadSubSystemsForWinStation(
    IN PWINSTATION pWinStation );

VOID
FreeWinStationLists(
    PWINSTATION pWinStation );

NTSTATUS
GetProcessLogonId(
    IN HANDLE Process,
    OUT PULONG pLogonId );

NTSTATUS
SetProcessLogonId(
    IN HANDLE Process,
    IN ULONG LogonId );

PWINSTATION FindWinStationById( ULONG, BOOLEAN );
PWINSTATION FindWinStationByName( LPWSTR, BOOLEAN );
BOOLEAN LockWinStationByPointer( PWINSTATION );
BOOLEAN IsWinStationLockedByCaller( PWINSTATION );

NTSTATUS QueueWinStationReset( IN ULONG LogonId );
NTSTATUS QueueWinStationDisconnect( IN ULONG LogonId );
VOID ResetGroupByListener( PWINSTATIONNAME );

VOID NotifySystemEvent(ULONG);

NTSTATUS WinStationOpenChannel(
        HANDLE IcaDevice,
        HANDLE ProcessHandle,
        CHANNELCLASS ChannelClass,
        PVIRTUALCHANNELNAME pVirtualName,
        PHANDLE pDupChannel);

VOID InvalidateTerminateWaitList(VOID);

#define UnlockWinStation( _p )   UnlockRefLock( &_p->Lock )
#define RelockWinStation( _p )   RelockRefLock( &_p->Lock )
#define ReleaseWinStation( _p )  ReleaseRefLock( &_p->Lock )

NTSTATUS InitRefLock( PREFLOCK, PREFLOCKDELETEPROCEDURE );
BOOLEAN  LockRefLock( PREFLOCK );
VOID     UnlockRefLock( PREFLOCK );
BOOLEAN  RelockRefLock( PREFLOCK );
VOID     ReleaseRefLock( PREFLOCK );
VOID     DeleteRefLock( PREFLOCK );

#if DBG
#define ENTERCRIT(_x) \
        { \
            ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) != (_x)->OwningThread ); \
            RtlEnterCriticalSection(_x); \
        }
#define LEAVECRIT(_x) \
        { \
            ASSERT( (HANDLE)LongToHandle( GetCurrentThreadId() ) == (_x)->OwningThread ); \
            RtlLeaveCriticalSection(_x); \
        }
#else
#define ENTERCRIT(_x)   RtlEnterCriticalSection(_x)
#define LEAVECRIT(_x)   RtlLeaveCriticalSection(_x)
#endif

NTSTATUS
MakeUserGlobalPath(
    IN OUT PUNICODE_STRING Unicode,
    IN ULONG LogonId );

NTSTATUS SendWinStationCommand( PWINSTATION, PWINSTATION_APIMSG, ULONG );

NTSTATUS
WsxStackIoControl(
    PVOID pContext,
    IN HANDLE pStack,
    IN ULONG IoControlCode,
    IN PVOID pInBuffer,
    IN ULONG InBufferSize,
    OUT PVOID pOutBuffer,
    IN ULONG OutBufferSize,
    OUT PULONG pBytesReturned );


VOID MergeUserConfigData( PWINSTATION pWinStation, 
                    PPOLICY_TS_USER         pPolicy,
                    PUSERCONFIGW            pPolicyData,
                    PUSERCONFIG             pUserConfig ) ;
                

VOID StartLogonTimers( PWINSTATION );
VOID ResetUserConfigData( PWINSTATION );

LONG    IcaTimerCreate( ULONG, HANDLE * );
NTSTATUS IcaTimerStart( HANDLE, PVOID, PVOID, ULONG );
BOOLEAN IcaTimerCancel( HANDLE );
BOOLEAN IcaTimerClose( HANDLE );

VOID InitializeTrace(IN PWINSTATION, IN BOOLEAN, OUT PICA_TRACE);
void InitializeSystemTrace(HKEY);
void GetSetSystemParameters(HKEY);

NTSTATUS CdmConnect( ULONG, HANDLE );
NTSTATUS CdmDisconnect( ULONG, HANDLE );

VOID VirtualChannelSecurity( PWINSTATION );

VOID
WinstationUnloadProfile( PWINSTATION pWinStation);

NTSTATUS
WinStationResetWorker(
    ULONG   LogonId,
    BOOLEAN bWait,
    BOOLEAN CallerIsRpc,
    BOOLEAN bRecreate
    );

BOOL     StartStopListeners( LPWSTR WinStationName, BOOLEAN bStart );
NTSTATUS WinStationCreateWorker( PWINSTATIONNAME, PULONG );

NTSTATUS ConsoleShadowStart( IN PWINSTATION pWinStation,
                             IN PWINSTATIONCONFIG2 pClientConfig,
                             IN PVOID pModuleData,
                             IN ULONG ModuleDataLength);

NTSTATUS ConsoleShadowStop(PWINSTATION pWinStation);

NTSTATUS TransferConnectionToIdleWinStation(
    PWINSTATION pListenWinStation,
    PVOID pEndpoint,
    ULONG EndpointLength,
    PICA_STACK_ADDRESS pStackAddress );

PWINSTATION
GetWinStationFromArcInfo(
    PBYTE pClientRandom,
    LONG  cbClientRandomLen,
    PTS_AUTORECONNECTINFO pArc
    );

// Why doesn't the compiler complain that each source file is redefining
// a global variable? This file _is_ included by all source files in this
// directory. But these definitions will cause warnings if they show up
// in the licensing core, so give the core the ability to ifdef them out.

#ifndef LSCORE_NO_ICASRV_GLOBALS
PVOID IcaHeap;

PVOID DefaultEnvironment;

HANDLE IcaSmApiPort;
HANDLE hModuleWin;
#endif

#if DBG
#define DBGPRINT(_arg) DbgPrint _arg
#else
#define DBGPRINT(_arg)
#endif

#if DBG
#undef TRACE
#define TRACE(_arg)     { if (hTrace) IcaSystemTrace _arg; }
#else
#define TRACE(_arg)
#endif


/*=============================================================================
== TermSrv Server Extension supplied procs
=============================================================================*/

/*
 * Macros
 */

#define WSX_INITIALIZE                        "WsxInitialize"
#define WSX_WINSTATIONINITIALIZE              "WsxWinStationInitialize"
#define WSX_WINSTATIONREINITIALIZE            "WsxWinStationReInitialize"
#define WSX_WINSTATIONRUNDOWN                 "WsxWinStationRundown"

#define WSX_CDMCONNECT                        "WsxConnect"
#define WSX_CDMDISCONNECT                     "WsxDisconnect"

#define WSX_VERIFYCLIENTLICENSE               "WsxVerifyClientLicense"
#define WSX_QUERYLICENSE                      "WsxQueryLicense"
#define WSX_GETLICENSE                        "WsxGetLicense"

#define WSX_WINSTATIONLOGONANNOYANCE          "WsxWinStationLogonAnnoyance"
#define WSX_WINSTATIONGENERATELICENSE         "WsxWinStationGenerateLicense"
#define WSX_WINSTATIONINSTALLLICENSE          "WsxWinStationInstallLicense"
#define WSX_WINSTATIONENUMERATELICENSES       "WsxWinStationEnumerateLicenses"
#define WSX_WINSTATIONACTIVATELICENSE         "WsxWinStationActivateLicense"
#define WSX_WINSTATIONREMOVELICENSE           "WsxWinStationRemoveLicense"
#define WSX_WINSTATIONSETPOOLCOUNT            "WsxWinStationSetPoolCount"
#define WSX_WINSTATIONQUERYUPDATEREQUIRED     "WsxWinStationQueryUpdateRequired"
#define WSX_WINSTATIONANNOYANCETHREAD         "WsxWinStationAnnoyanceThread"

#define WSX_DUPLICATECONTEXT                  "WsxDuplicateContext"
#define WSX_COPYCONTEXT                       "WsxCopyContext"
#define WSX_CLEARCONTEXT                      "WsxClearContext"

#define WSX_INITIALIZECLIENTDATA              "WsxInitializeClientData"
#define WSX_INITIALIZEUSERCONFIG              "WsxInitializeUserConfig"
#define WSX_CONVERTPUBLISHEDAPP               "WsxConvertPublishedApp"
#define WSX_VIRTUALCHANNELSECURITY            "WsxVirtualChannelSecurity"
#define WSX_ICASTACKIOCONTROL                 "WsxIcaStackIoControl"

#define WSX_BROKENCONNECTION                  "WsxBrokenConnection"

#define WSX_LOGONNOTIFY                       "WsxLogonNotify"
#define WSX_SETERRORINFO                      "WsxSetErrorInfo"
#define WSX_ESCAPE                            "WsxEscape"
#define WSX_SENDAUTORECONNECTSTATUS           "WsxSendAutoReconnectStatus"


/*
 * Typedefs and structures
 */

typedef struct _WSEXTENSION {

    LIST_ENTRY Links;                   // Links
    DLLNAME WsxDLL;                     // DLL name

    HANDLE hInstance;                   // Handle of the DLL

    PVOID Context;                      // Extension context data

    PWSX_INITIALIZE                     pWsxInitialize;
    PWSX_WINSTATIONINITIALIZE           pWsxWinStationInitialize;
    PWSX_WINSTATIONREINITIALIZE         pWsxWinStationReInitialize;
    PWSX_WINSTATIONRUNDOWN              pWsxWinStationRundown;

    PWSX_CDMCONNECT                     pWsxCdmConnect;
    PWSX_CDMDISCONNECT                  pWsxCdmDisconnect;

    PWSX_VERIFYCLIENTLICENSE            pWsxVerifyClientLicense;
    PWSX_QUERYLICENSE                   pWsxQueryLicense;
    PWSX_GETLICENSE                     pWsxGetLicense;

    PWSX_WINSTATIONLOGONANNOYANCE       pWsxWinStationLogonAnnoyance;
    PWSX_WINSTATIONGENERATELICENSE      pWsxWinStationGenerateLicense;
    PWSX_WINSTATIONINSTALLLICENSE       pWsxWinStationInstallLicense;
    PWSX_WINSTATIONENUMERATELICENSES    pWsxWinStationEnumerateLicenses;
    PWSX_WINSTATIONACTIVATELICENSE      pWsxWinStationActivateLicense;
    PWSX_WINSTATIONREMOVELICENSE        pWsxWinStationRemoveLicense;
    PWSX_WINSTATIONSETPOOLCOUNT         pWsxWinStationSetPoolCount;
    PWSX_WINSTATIONQUERYUPDATEREQUIRED  pWsxWinStationQueryUpdateRequired;
    PWSX_WINSTATIONANNOYANCETHREAD      pWsxWinStationAnnoyanceThread;

    PWSX_DUPLICATECONTEXT               pWsxDuplicateContext;
    PWSX_COPYCONTEXT                    pWsxCopyContext;
    PWSX_CLEARCONTEXT                   pWsxClearContext;

    PWSX_INITIALIZECLIENTDATA           pWsxInitializeClientData;
    PWSX_INITIALIZEUSERCONFIG           pWsxInitializeUserConfig;
    PWSX_CONVERTPUBLISHEDAPP            pWsxConvertPublishedApp;

    PWSX_VIRTUALCHANNELSECURITY         pWsxVirtualChannelSecurity;
    PWSX_ICASTACKIOCONTROL              pWsxIcaStackIoControl;

    PWSX_BROKENCONNECTION               pWsxBrokenConnection;

    PWSX_LOGONNOTIFY                    pWsxLogonNotify;
    PWSX_SETERRORINFO                   pWsxSetErrorInfo;
    PWSX_SENDAUTORECONNECTSTATUS        pWsxSendAutoReconnectStatus;
    PWSX_ESCAPE                         pWsxEscape; 
} WSEXTENSION, * PWSEXTENSION;

//
// For disconnect / reconnect completion constants
// Currently we wait 5000 milisecs (12*15) times,
// which make a maximum total wait of 3 minutes.

#define WINSTATION_WAIT_COMPLETE_DURATION 5000
#define WINSTATION_WAIT_COMPLETE_RETRIES  (12*15)

// For disconnect completion constant when we do a reconnect
// Currently we wait 2000 milisecs, (5*3) times,
// which make a maximum total wait of 30 seconds

#define WINSTATION_WAIT_DURATION 2000
#define WINSTATION_WAIT_RETRIES  (5*3)


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\icarpc.c ===
/*************************************************************************
*
* icarpc.c
*
* Server specific routines for handling of RPC wire structures.
*
* Copyright Microsoft Corporation, 1998
*
*************************************************************************/

/*
 *  Includes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <winsta.h>

#include "rpcwire.h"

#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*****************************************************************************
 *
 *  ValidWireBuffer
 *
 *   Tests whether the buffer is a valid Winsta API Wire Buffer
 *
 * ENTRY:
 *    InfoClass (input)
 *       WinStationQuery/Set Information class.
 *    WireBuf (input)
 *       Data buffer
 *    WireBufLen
 *      Length of the wire buffer
 *
 * EXIT:
 *    Returns true if the buffer is a valid wire format buffer, FALSE otherwise.
 *
 ****************************************************************************/
BOOLEAN
ValidWireBuffer(WINSTATIONINFOCLASS InfoClass,
                PVOID WireBuf,
                ULONG WireBufLen)
{
    PVARDATA_WIRE GenericWire;
    PPDCONFIGWIREW PdConfigWire;
    PPDPARAMSWIREW PdParamsWire;
    PWINSTACONFIGWIREW WinStaConfigWire;

    switch(InfoClass) {
    case WinStationInformation:
    case WinStationWd:
    case WinStationClient:
        GenericWire = (PVARDATA_WIRE)WireBuf;
        if ((WireBufLen < sizeof(VARDATA_WIRE)) ||
            (GenericWire->Offset != sizeof(VARDATA_WIRE)) ||
            (WireBufLen < sizeof(VARDATA_WIRE) + GenericWire->Size)) {
            DBGPRINT(("ICASRV Bad Wire Buffer Type: %d\n",InfoClass));
            return(FALSE);
        }
        break;

    case WinStationPd:
        PdConfigWire = (PPDCONFIGWIREW)WireBuf;
        if ((WireBufLen < sizeof(PDCONFIGWIREW)) ||
            (PdConfigWire->PdConfig2W.Offset != sizeof(PDCONFIGWIREW)) ||
            (WireBufLen < sizeof(PDCONFIGWIREW) +
                          PdConfigWire->PdConfig2W.Size +
                          PdConfigWire->PdParams.SdClassSpecific.Size) ||
            (NextOffset(&PdConfigWire->PdConfig2W) !=
             PdConfigWire->PdParams.SdClassSpecific.Offset)) {
            DBGPRINT(("ICASRV Bad Wire Buffer Type: %d\n",InfoClass));
            return(FALSE);
        }
        break;

    case WinStationPdParams:
        PdParamsWire = (PPDPARAMSWIREW)WireBuf;
        if ((WireBufLen < sizeof(PDPARAMSWIREW)) ||
            (PdParamsWire->SdClassSpecific.Offset != sizeof(PDPARAMSWIREW)) ||
            (WireBufLen < sizeof(PDPARAMSWIREW) +
                          PdParamsWire->SdClassSpecific.Size)) {
            DBGPRINT(("ICASRV Bad Wire Buffer Type: %d\n",InfoClass));
            return(FALSE);
        }
        break;

    case WinStationConfiguration:
        WinStaConfigWire = (PWINSTACONFIGWIREW)WireBuf;
        if ((WireBufLen < sizeof(WINSTACONFIGWIREW)) ||
            WinStaConfigWire->UserConfig.Offset != sizeof(WINSTACONFIGWIREW) ||
            (WireBufLen < sizeof(WINSTACONFIGWIREW) +
                          WinStaConfigWire->UserConfig.Size +
                          WinStaConfigWire->NewFields.Size) ||
            (NextOffset(&WinStaConfigWire->UserConfig) !=
             WinStaConfigWire->NewFields.Offset) ||
            (WireBufLen < NextOffset(&WinStaConfigWire->UserConfig)) ||
            (WireBufLen < NextOffset(&WinStaConfigWire->NewFields))) {
            DBGPRINT(("ICASRV Bad Wire Buffer Type: %d\n",InfoClass));
            return(FALSE);
        }
        break;

    default:
        return(FALSE);
    }
    return(TRUE);
}

/*****************************************************************************
 *
 *  CheckWireBuffer
 *
 *   Tests whether the buffer is a Winsta API Wire Buffer. If it is a valid
 *   wire buffer, a local buffer is allocated and initialized from the data
 *   in the wire buffer.
 *
 * ENTRY:
 *    InfoClass (input)
 *       WinStationQuery/Set Information class.
 *    WireBuf (input)
 *       Data buffer
 *    WireBufLen
 *      Length of the wire buffer
 *    ppLocalBuf (output)
 *      Local format buffer allocated for conversion from wire format to
 *      native format.
 *    pLocalBufLen
 *      Length of the native buffer allocated.
  *
 * EXIT:
 *    STATUS_SUCCESS if successful. If successful, a native local buffer
 *    is allocated based on InfoClass and the wire buffer data is copied
 *    into it.
 *
 ****************************************************************************/
NTSTATUS
CheckWireBuffer(WINSTATIONINFOCLASS InfoClass,
                PVOID WireBuf,
                ULONG WireBufLen,
                PVOID *ppLocalBuf,
                PULONG pLocalBufLen)
{
    ULONG BufSize;
    PPDCONFIGWIREW PdConfigWire;
    PPDCONFIGW PdConfig;
    PPDPARAMSWIREW PdParamsWire;
    PPDPARAMSW PdParam;
    PWINSTACONFIGWIREW WinStaConfigWire;
    PWINSTATIONCONFIGW WinStaConfig;
    PVOID LocalBuf;

    switch (InfoClass) {
    case WinStationPd:
        BufSize = sizeof(PDCONFIGW);
        break;

    case WinStationPdParams:
        BufSize = sizeof(PDPARAMSW);
        break;

    case WinStationConfiguration:
        BufSize = sizeof(WINSTATIONCONFIGW);
        break;

    case WinStationInformation:
        BufSize = sizeof(WINSTATIONINFORMATIONW);
        break;

    case WinStationWd:
        BufSize = sizeof(WDCONFIGW);
        break;

    case WinStationClient:
        BufSize = sizeof(WINSTATIONCLIENTW);
        break;

    default:
        *ppLocalBuf = NULL;
        return(STATUS_INVALID_USER_BUFFER);

    }
    if (!ValidWireBuffer(InfoClass, WireBuf, WireBufLen)) {
        return(STATUS_INVALID_USER_BUFFER);
    }

    if ((LocalBuf = (PCHAR)LocalAlloc(0,BufSize)) == NULL)
        return(STATUS_NO_MEMORY);


    *pLocalBufLen = BufSize;
    *ppLocalBuf = LocalBuf;
    CopyOutWireBuf(InfoClass, LocalBuf, WireBuf);

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\precomp.h ===
/****************************************************************************/
// precomp.h
//
// Copyright (C) 1997-1999 Microsoft Corp.
/****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntcsrsrv.h>
#include <windows.h>
#include <lmcons.h>
#include <lmserver.h>
#include <ntsm.h>
#include <stdio.h>
#include <string.h>
#include <winerror.h>
#include <ntverp.h>
#include <ntddbeep.h>
#include <regstr.h>
#include <ntlsapi.h>

#include <winstaw.h>

#include <ntexapi.h>

#include <regapi.h>

#include <wstmsg.h>

#include <icadd.h>
#include <icaapi.h>

#include <syslib.h>
#include <ntddvdeo.h>

#include <license.h>
#include <tsutilnt.h>
#include <tsutil.h>

#include "..\inc\wsxmgr.h"
#include "icasrv.h"
#include "lscore.h"
#include "helpasst.h"
#include "tserrs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\icasrv.c ===
/****************************************************************************/
// icasrv.c
//
// TermSrv service process entry points.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <objbase.h>

#include "icaevent.h"
#include "sessdir.h"
#include <safeboot.h>

extern BOOL UpdateOemAndProductInfo(HKEY);

extern BOOL IsServiceLoggedAsSystem( VOID );

extern VOID     WriteErrorLogEntry(
            IN  NTSTATUS NtStatusCode,
            IN  PVOID    pRawData,
            IN  ULONG    RawDataLength
            );

extern NTSTATUS WinStationInitRPC();
extern NTSTATUS InitializeWinStationSecurityLock(VOID);
extern VOID AuditEnd();

/*
 * Definitions
 */
#define STACKSIZE_LPCTHREAD (4 * 0x1000)

/*
 * Internal Procedures defined
 */
VOID ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv);
VOID Handler(DWORD fdwControl);
BOOL UpdateServiceStatus(DWORD, DWORD, DWORD, DWORD);
void ShutdownService();

/*
 * Global variables
 */
WCHAR gpszServiceName[] = L"TermService";
SERVICE_TABLE_ENTRY gpServiceTable[] = {
    gpszServiceName, (LPSERVICE_MAIN_FUNCTION)ServiceMain,
    NULL,            NULL,
};

SERVICE_STATUS_HANDLE gStatusHandle;
SERVICE_STATUS gStatus;
DWORD gExitStatus = STATUS_SUCCESS;

WCHAR g_wszProductVersion[22];
TCHAR g_tszServiceAccount[UNLEN + 1];

BOOL g_fAppCompat = TRUE;
BOOL g_bPersonalTS = FALSE;
BOOL g_bPersonalWks = FALSE;
BOOL g_SafeBootWithNetwork = FALSE;
BOOL gbServer = FALSE;
BOOL gBreakOnProcessExit = FALSE;
OSVERSIONINFOEX gOsVersion;

HANDLE gReadyEventHandle = NULL;

//
// The following is used to inform Session 0 winlogon of the credentials needed to notify 3rd party n/w logon providers
// This happens only during force logoff console reconnect scenario in PTS and /console in Server
//
ExtendedClientCredentials g_MprNotifyInfo; 

extern PSID gAdminSid;
extern PSID gSystemSid;

// Local prototypes.
void LicenseModeInit(HKEY);
NTSTATUS WsxInit(VOID);
NTSTATUS VfyInit(VOID);
BOOL WINAPI 
IsSafeBootWithNetwork();


void CreateTermsrvHeap ()
{
    IcaHeap = GetProcessHeap();
    return;
}

#ifdef TERMSRV_PROC
/****************************************************************************/
// main
//
// Standard console-app-style entry point. Returns an NTSTATUS code.
/****************************************************************************/
int _cdecl main(int argc, char *argv[])
{
    NTSTATUS Status = STATUS_SUCCESS;
    KPRIORITY BasePriority;
    HRESULT hr;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Loading...\n"));

    /*
     * Run TermSrv at just above foreground priority.
     */
    BasePriority = FOREGROUND_BASE_PRIORITY + 1;
    Status = NtSetInformationProcess(NtCurrentProcess(),
            ProcessBasePriority,
            &BasePriority,
            sizeof(BasePriority) );
    ASSERT((Status == STATUS_PRIVILEGE_NOT_HELD) || NT_SUCCESS(Status));

    // Initialize COM once with multithreaded capability. This must be done
    // on the main service thread to allow other threads in the service to
    // inherit this initialization, if not specifically initialized for
    // apartment threading.
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (!SUCCEEDED(hr)) {
        HANDLE h;
        WCHAR hrString[16];
        PWSTR String;

        h = RegisterEventSource(NULL, gpszServiceName);
        if (h != NULL) {
            wsprintfW(hrString, L"0x%X", hr);
            String = hrString;
            ReportEvent(h, EVENTLOG_ERROR_TYPE, 0, EVENT_TERMSRV_FAIL_COM_INIT,
                    NULL, 1, 0, &String, NULL);
            DeregisterEventSource(h);
        }

        DbgPrint("TERMSRV: Failed init COM, hr=0x%X\n", hr);
        goto done;
    }

    /*
     * Call service dispatcher
     */
    if (!StartServiceCtrlDispatcher(gpServiceTable)) {
        Status = GetLastError();
        DbgPrint("TERMSRV: Error %d in StartServiceCtrlDispatcher\n", Status);
        goto done;
    }

done:
    if (SUCCEEDED(hr))
        CoUninitialize();

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Unloading...\n"));
    return Status;
}
#else // TERMSRV_PROC

BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,  // handle to the DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved   // reserved
)
{

    BOOL fResult = TRUE;

    switch(fdwReason) {
        case DLL_PROCESS_ATTACH:

            hModuleWin = hinstDLL;

            DisableThreadLibraryCalls(hinstDLL);

            break;

        default:;
    }

    return fResult;

}

#endif // TERMSRV_PROC


/*****************************************************************************
 *
 *  InitializeLoadMetrics
 *
 *    Grabs baseline system resource values for use in load balancing.  These
 *    values are used to factor out the system resources required for basic OS
 *    operation so they don't get into the calculations for how much resource on
 *    average a user is consuming.
 *
 *
 * ENTRY:
 *    no arguments.
 *
 * EXIT:
 *   void
 *
 ****************************************************************************/
VOID InitializeLoadMetrics()
{
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION ProcessorInfo[MAX_PROCESSORS];
    SYSTEM_PERFORMANCE_INFORMATION           SysPerfInfo;
    SYSTEM_BASIC_INFORMATION                 SysBasicInfo;

    ULONG i;
    NTSTATUS Status;

    memset(&gLB, 0, sizeof(LOAD_BALANCING_METRICS));

    // Get basic system information
    Status = NtQuerySystemInformation(SystemBasicInformation, &SysBasicInfo,
                                      sizeof(SysBasicInfo), NULL);

    if (!NT_SUCCESS(Status)) {
        TRACE((hTrace, TC_LOAD, TT_ERROR,
               "InitializeLoadMetrics failed! SystemBasicInformation: %lx\n",
               Status));
        return;
    }

    gLB.NumProcessors = SysBasicInfo.NumberOfProcessors;
    gLB.PageSize = SysBasicInfo.PageSize;
    gLB.PhysicalPages = SysBasicInfo.NumberOfPhysicalPages;

    // Establish minimum usage levels to prevent absurd estimation
    gLB.MinPtesPerUser = SimAvgPtesPerUser;
    gLB.MinPagedPoolPerUser = (SimAvgPagedPoolPerUser * 1024) / gLB.PageSize;
    gLB.MinCommitPerUser = (SimCommitPerUser * 1024) / gLB.PageSize;

    // Grab base boot values.  This isn't perfect, but it allows us to factor
    // out base OS resource requirements from the per user averages.  The runtime
    // algorithm will reset the baselines if we go below these.
    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      &SysPerfInfo, sizeof(SysPerfInfo),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        TRACE((hTrace, TC_LOAD, TT_ERROR, 
               "InitializeLoadMetrics failed! SystemPerformanceInformation: %lx\n",
               Status));
        return;
    }

    // Note: we have an unsolvable problem in that there is no way to get
    // perfect values for how much memory the baseline system consumes.  We
    // default baseline commit to 64M since that is the minimum recommended
    // system requirement.
    gLB.BaselineCommit    = (64 * 1024*1024) / gLB.PageSize;
//  gLB.BaselineCommit    = SysPerfInfo.CommittedPages;
    gLB.BaselineFreePtes  = SysPerfInfo.FreeSystemPtes;
    gLB.BaselinePagedPool = SysPerfInfo.PagedPoolPages;

    // Initialize CPU Loading
    Status = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                                      ProcessorInfo, 
                                      sizeof(ProcessorInfo),
                                      NULL);
    if (!NT_SUCCESS(Status)) {
        TRACE((hTrace, TC_LOAD, TT_ERROR, 
               "InitializeLoadMetrics failed! SystemProcessorPerformanceInformation: %lx\n",
               Status));
        return;
    }

    for (i = 0; i < gLB.NumProcessors; i++) {
        gLB.IdleCPU.QuadPart  += ProcessorInfo[i].IdleTime.QuadPart;
        gLB.TotalCPU.QuadPart += ProcessorInfo[i].KernelTime.QuadPart +
                                     ProcessorInfo[i].UserTime.QuadPart;
    }
    
    // Start out saying we're 80 percent idle (0-255 based)
    gLB.AvgIdleCPU = 204 ;

    // Indicate we got all the intial values!
    gLB.fInitialized = TRUE;

    TRACE((hTrace, TC_LOAD, TT_API1, "InitializeLoadMetrics():\n"));
    TRACE((hTrace, TC_LOAD, TT_API1, 
           "   Processors [%6ld], PageSize  [%6ld], Physical [%6ld]\n",
           gLB.NumProcessors, gLB.PageSize, gLB.PhysicalPages));
    TRACE((hTrace, TC_LOAD, TT_API1,
           "   PtesAvail  [%6ld], PagedUsed [%6ld], Commit   [%6ld]\n",
           gLB.BaselineFreePtes, gLB.BaselinePagedPool, gLB.BaselineCommit));
}


BOOL IsKernelDebuggerAttached ()
{
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInfo;
    NTSTATUS Status;

    Status = NtQuerySystemInformation( SystemKernelDebuggerInformation,
                    &KernelDebuggerInfo,
                    sizeof(KernelDebuggerInfo),
                    NULL
                    );

    return ( NT_SUCCESS(Status) && KernelDebuggerInfo.KernelDebuggerEnabled );
}

void DebugBreakIfAsked()
{

    TCHAR REG_TERMSRV_DEBUGBREAK[] = TEXT("DebugTS");
    TCHAR REG_TERMSRV_DEBUGGER[]   = TEXT("Debugger");
    TCHAR szDebugger[256];
    TCHAR szCommand[256];
    HKEY  hTermSrv = NULL;
    DWORD dwBreakIn;
    DWORD dwValueType;
    DWORD dwSize;
    DWORD dwError;

    enum
    {
        TermSrvDoNotBreak = 0,
        TermSrvBreakIfBeingDebugged = 1,
        TermSrvAttachDebugger = 2,
        TermSrvBreakAlways = 3
    };

    dwError = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    REG_CONTROL_TSERVER,
                    0,
                    KEY_READ,
                    &hTermSrv
                    );

    if (ERROR_SUCCESS == dwError)
    {
        dwSize = sizeof(dwBreakIn);
        dwError = RegQueryValueEx(
                        hTermSrv,
                        REG_TERMSRV_DEBUGBREAK,
                        NULL,
                        &dwValueType,
                        (LPBYTE)&dwBreakIn,
                        &dwSize
                        );

        if (ERROR_SUCCESS == dwError && dwValueType == REG_DWORD)
        {
            switch (dwBreakIn)
            {
                case TermSrvAttachDebugger:

                    //
                    // if its already being debugged Break into it.
                    //

                    if (IsDebuggerPresent())
                    {
                        DebugBreak();
                        break;
                    }

                    //
                    // Get the debugger to be launched.
                    // must contain %d which will be replaced by processid
                    //
                    dwSize = sizeof(szDebugger) / sizeof(TCHAR);
                    dwError = RegQueryValueEx(
                                hTermSrv,
                                REG_TERMSRV_DEBUGGER,
                                NULL,
                                &dwValueType,
                                (LPBYTE)szDebugger,
                                &dwSize
                                );

                    if (ERROR_SUCCESS == dwError && dwValueType == REG_SZ)
                    {
                        PROCESS_INFORMATION ProcessInfo;
                        STARTUPINFO StartupInfo;
                        wsprintf(szCommand, szDebugger, GetCurrentProcessId());
                        DbgPrint("TERMSRV:*-----------------* Executing:<%ws> *-----------------*\n", szCommand);

                        ZeroMemory(&StartupInfo, sizeof(StartupInfo));
                        StartupInfo.cb = sizeof(StartupInfo);
                        if (!CreateProcess(NULL, szCommand, NULL, NULL, FALSE, 0, NULL, NULL, &StartupInfo, &ProcessInfo))
                        {
                            DbgPrint("TERMSRV:*-----------------* TERMSRV:CreateProcess failed *-----------------*\n");
                        }
                        else
                        {
                            CloseHandle(ProcessInfo.hProcess);
                            CloseHandle(ProcessInfo.hThread);

                            while (!IsDebuggerPresent())
                            {
                                Sleep(500);
                            }
                        }

                    }
                    else
                    {
                        DbgPrint("TERMSRV:*-----------------* Did not find the debugger entry. *-----------------*\n");
                    }
                    break;

                case TermSrvBreakIfBeingDebugged:

                    // check if any debugger is attached, if not dont breakin.
                    if (!IsDebuggerPresent() && !IsKernelDebuggerAttached ())
                        break;

                case TermSrvBreakAlways:
                    DebugBreak();
                    break;

                case TermSrvDoNotBreak:
                default:
                    break;

            }

        }

        RegCloseKey(hTermSrv);
    }
    else
    {
        DbgPrint("TERMSRV:*-----------------* Could not open termsrv registry *-----------------*\n");
    }
}

/****************************************************************************/
// ServiceMain
//
// TermSrv service entry point.
/****************************************************************************/
VOID ServiceMain(DWORD dwArgc, LPTSTR *lpszArgv)
{
    HANDLE hIcaLPCThread;
    HANDLE hIcaLPCPort = NULL;
    DWORD  dwValueType;
    LONG   lReturn;
    DWORD  cbValue;
    BOOL   bAdvertiseTS;
    DWORD  dwTSAdvertise;
    NTSTATUS Status;
    HKEY hKeyTermSrv = NULL;

    DWORDLONG  dwlConditionMask;

    DebugBreakIfAsked();

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: ServiceMain entered...\n"));

    gStatus.dwServiceType = SERVICE_WIN32;
    gStatus.dwWaitHint = 30000;
    gStatus.dwCurrentState = SERVICE_STOPPED;



     /*
     * Register the control handler
     */
    if (!(gStatusHandle = RegisterServiceCtrlHandler(gpszServiceName,
            Handler))) {
        DbgPrint("TERMSRV: Error %d in RegisterServiceCtrlHandler\n",
        GetLastError());
        goto done;
    }


    // If Terminal Services are not enabled then don't allow starting termsrv
    // service.
    if (!IsTerminalServicesEnabled()) {
        HANDLE h;
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Not a TSBox."));
        h = RegisterEventSource(NULL, gpszServiceName);
        if (h != NULL) {
            if (!ReportEvent(
                    h,                     // event log handle
                    EVENTLOG_ERROR_TYPE,   // event type
                    0,                     // category zero
                    EVENT_NOT_A_TSBOX,     // event identifier
                    NULL,                  // no user security identifier
                    0,                     // one substitution string
                    0,                     // no data
                    NULL,                  // pointer to string array
                    NULL                   // pointer to data
                    )) {

                DBGPRINT(("ReportEvent Failed %ld. Event ID=%lx\n",GetLastError(), EVENT_NOT_A_TSBOX));
            }
        }

        goto done;
    }

    CreateTermsrvHeap ();


    /*
     * Create and set an event which indicates that TermSrv is ready.
     * WinLogon checks this event. Do not signal now.
     *
     */
    gReadyEventHandle = CreateEvent(NULL, TRUE, FALSE,
            TEXT("Global\\TermSrvReadyEvent"));

    // Initialize Global System and Admin SID
    Status = NtCreateAdminSid(&gAdminSid);

    if (!NT_SUCCESS(Status))
    {
        goto done;
    }

    Status = InitializeWinStationSecurityLock();
    if (!NT_SUCCESS(Status))
    {
        goto done;
    }

    Status = NtCreateSystemSid(&gSystemSid);

    if (!NT_SUCCESS(Status))
    {
        goto done;
    }

    if (!IsServiceLoggedAsSystem()) {
        WriteErrorLogEntry(EVENT_NOT_SYSTEM_ACCOUNT, NULL, 0);
        gExitStatus = ERROR_PRIVILEGE_NOT_HELD;
        goto done;
    }

    // Set global flag for Personal WorkStation
    g_bPersonalWks = IsPersonalWorkstation();

    #if DBG
    if( TRUE == g_bPersonalWks )
    {
        DbgPrint("TERMSRV : TS running on Personal Workstation\n");
    }
    else
    {
        DbgPrint("TERMSRV : Not Personal Workstation\n");
    }
    #endif

    //
    // Initialize HelpAssistant password encryption.
    //
    lReturn = TSHelpAssistantInitializeEncryptionLib();

    //
    // Not a critical error, No help will be available
    //
    #if DBG
    if( lReturn != ERROR_SUCCESS ) {
        DbgPrint( "TERMSRV : EncryptionLib failed with %d, no help is available\n", lReturn );
    }
    #endif

    //
    // We are booting in safeboot with network support
    //
    g_SafeBootWithNetwork = IsSafeBootWithNetwork();


    // Set the global flag for Personal TS support. We use this to reduce
    // the feature set based on product (e.g. no load balancing session
    // directory if not on Server).
    g_bPersonalTS = IsPersonalTerminalServicesEnabled();

    ZeroMemory(&gOsVersion, sizeof(OSVERSIONINFOEX));
    gOsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    gOsVersion.wProductType = VER_NT_WORKSTATION;
    dwlConditionMask = 0;
    VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    gbServer = !VerifyVersionInfo(&gOsVersion, VER_PRODUCT_TYPE, dwlConditionMask);

    // Open a single, global HKLM\System\CCS\Control\TS reg handle, from which
    // other init code can query.
    lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
            KEY_READ, &hKeyTermSrv);
    if (lReturn != ERROR_SUCCESS) {
        DbgPrint("TERMSRV: Unable to open TS key in HKLM, lasterr=0x%X",
               GetLastError());
        goto done;
    }

    /*
     * Indicate service is starting.
     */
    Status = UpdateServiceStatus(SERVICE_START_PENDING, 0, 1, 0);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("TERMSRV: Unable update service status %X\n", Status );
    }

    Status = RtlCreateEnvironment(TRUE, &DefaultEnvironment);
    if (!NT_SUCCESS(Status)) {
        DbgPrint("TERMSRV: Unable to alloc default environment, Status=0x%X\n",
                Status);
        goto done;
    }

#ifdef TERMSRV_PROC
    /*
     * Get the module handle for messages.
     */
    hModuleWin = GetModuleHandleW(NULL);
#endif // TERMSRV_PROC

    /*
     * Indicate service has started successfully.
     * Maybe this should be moved below? No way!!!
     */
    Status = UpdateServiceStatus(SERVICE_RUNNING, 0, 2, 0);
    if (!Status)
        DbgPrint("TERMSRV: Unable to update service status %X\n", Status);

    /*
     *  Connect to the session manager
     */




    Status = SmConnectToSm((PUNICODE_STRING)NULL, (HANDLE)NULL, 0,
            &IcaSmApiPort);
    if (!NT_SUCCESS(Status))
        goto done;

    // Initialize the licensing mode - this only gets information, it doesn't
    // initialize the licensing core.




    LicenseModeInit(hKeyTermSrv);

    // Perform the bulk of the TermSrv init.



    Status = InitTermSrv(hKeyTermSrv);
    if (!NT_SUCCESS(Status))
        goto ShutdownService;

    /*
     * Indicate that we are a Terminal Server unless were asked not to
     * advertise ourselves as a Terminal Server.
     */
    bAdvertiseTS = TRUE;
    cbValue = sizeof(dwTSAdvertise);
    lReturn = RegQueryValueEx(hKeyTermSrv, REG_TERMSRV_ADVERTISE, NULL,
            &dwValueType, (LPBYTE)&dwTSAdvertise, &cbValue);
    if (ERROR_SUCCESS == lReturn && dwValueType == REG_DWORD)
        bAdvertiseTS = dwTSAdvertise;
    if (bAdvertiseTS)
        SetServiceBits(gStatusHandle, SV_TYPE_TERMINALSERVER, TRUE, TRUE);

    /*
     * Need to do this at least once
     */
    UpdateOemAndProductInfo(hKeyTermSrv);

    // Initialize TermSrv and TermDD trace.


    InitializeSystemTrace(hKeyTermSrv);

    /*
     * Set TermDD parameters.
     */
    GetSetSystemParameters(hKeyTermSrv);

    /*
     * Initialize WinStation extension DLL support
     */
    Status = WsxInit();
    if (!NT_SUCCESS(Status))
        goto ShutdownService;

    /*
     *  Initialize DLL Verification mechanism.
     */
    Status = VfyInit();
    if (!NT_SUCCESS(Status))
        goto ShutdownService;

    /*
     * Start WinStations
     */


    StartAllWinStations(hKeyTermSrv);

    // Initialize the TS Session Directory for load balancing.
    // Not available on Personal TS or remote admin.
    if (!g_bPersonalTS && g_fAppCompat)
        InitSessionDirectory();


    InitializeLoadMetrics();

    // Done with init, close the TermSrv regkey.
    RegCloseKey(hKeyTermSrv);
    hKeyTermSrv = NULL;


    /*
     * Initialize WinStationAPI's
     */


    Status = WinStationInitRPC();
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto done;
    }


    /*
     * Set break on termination flag for our process.
     */
    {
        NTSTATUS stp;
        if ( IsKernelDebuggerAttached ()) {
            stp = RtlSetProcessIsCritical(TRUE, NULL, FALSE);
            if (stp == STATUS_SUCCESS) {
                gBreakOnProcessExit = TRUE;
            }
            else {
                DbgPrint("TERMSRV: RtlSetProcessIsCritical returned: %x ", stp);
            }
        }
    }

    /*
     * Set the  event which indicates that TermSrv is ready.
     * WinLogon checks this event. 
     */



    if (gReadyEventHandle != NULL)
        SetEvent(gReadyEventHandle);

    TSStartupSalem();

    return;

ShutdownService:
    ShutdownService();

done:
    // Kill the session directory.
    if (!g_bPersonalTS && g_fAppCompat)
        DestroySessionDirectory();

    // In case of error, check the TermSrv regkey again.
    if (hKeyTermSrv != NULL)
        RegCloseKey(hKeyTermSrv);

    UpdateServiceStatus(SERVICE_STOPPED, gExitStatus, 5, 0);
}


/****************************************************************************/
// Handler
//
// TermSrv service control event handler.
/****************************************************************************/
VOID Handler(DWORD fdwControl)
{
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Handler %d\n", fdwControl));
    switch (fdwControl) {
        case SERVICE_CONTROL_STOP:
            // We absolutely do not want to be stopping TermSrv -- it is
            // the only location for a lot of system-wide TS related state.
            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: control code %d, stopping service...\n",
                    fdwControl));
            if (gStatus.dwCurrentState == SERVICE_RUNNING) {
                UpdateServiceStatus(SERVICE_STOP_PENDING, 0, 3, 0);
#ifdef notdef
                // For now don't stop TermSRV
                // The CDM service does a KeAttachProcess() to this process
 
                if (gReadyEventHandle != NULL) {
                    ResetEvent(gReadyEventHandle);
                    CloseHandle(gReadyEventHandle);
                    gReadyEventHandle = NULL;
                }
                ShutdownService();
                UpdateServiceStatus(SERVICE_STOPPED, gExitStatus, 5, 0);
#endif
            }
            break;

        case SERVICE_CONTROL_SHUTDOWN:
            DBGPRINT(("TERMSRV: control code %d, shutdown service...\n",
                    fdwControl));
            if (gStatus.dwCurrentState == SERVICE_RUNNING) {
                // 2 seconds at most to shut down.
                UpdateServiceStatus(SERVICE_STOP_PENDING, 0, 4, 2000);
#ifdef notdef
                // We don't trigger this event that invokes destructors for
                // all of TermSrv, since on shutdown we don't want to be
                // destroying machine state. We want to invoke only those
                // destructors that are required for proper functioning of
                // the system.
#endif

                // Invoke required destruction code.
                if (gReadyEventHandle != NULL) {
                    ResetEvent(gReadyEventHandle);
                    CloseHandle(gReadyEventHandle);
                    gReadyEventHandle = NULL;
                }
                ShutdownService();
                UpdateServiceStatus(SERVICE_STOPPED, 0, 4, 0);
            }
            break;

        case SERVICE_CONTROL_INTERROGATE :
            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Interrogating service...\n"));
            SetServiceStatus(gStatusHandle, &gStatus);
            break;

        default:
            DBGPRINT(("TERMSRV: Unhandled control code %d\n", fdwControl));
            break;
    }
}


/****************************************************************************/
// ShutdownService
//
// Called by service manager to shut down the service at system shutdown
// time. This function should invoke only the most important and required
// destruction code, since we're on a strict time limit on system shutdown.
/****************************************************************************/
void ShutdownService()
{
    //free authz resource manager
    AuditEnd();

    // Destroy the session directory so the directory can be informed to
    // remove server- and session-specific information.
    if (!g_bPersonalTS && g_fAppCompat)
        DestroySessionDirectory();
}


/****************************************************************************/
// UpdateServiceStatus
//
// Updates the service's status to the Service Control Manager. Returns
// FALSE on error.
/****************************************************************************/
BOOL UpdateServiceStatus(
        DWORD CurrentState,
        DWORD ExitCode,
        DWORD CheckPoint,
        DWORD WaitHint)
{
    // If service is starting, then disable all control requests, otherwise
    // accept shutdown notifications if we are an app server, to properly
    // clean up the session directory. We do not accept stop requests
    // during the lifetime of the server up state, the CDM service does a
    // KeAttachProcess() to this process so it must always be around.
    if (gStatusHandle == NULL) {
        return FALSE;
    }

    gStatus.dwControlsAccepted = 0;

    gStatus.dwCurrentState = CurrentState;
    gStatus.dwWin32ExitCode = ExitCode;
    gStatus.dwCheckPoint = CheckPoint;
    gStatus.dwServiceSpecificExitCode = 0;
    gStatus.dwWaitHint = WaitHint;

    return SetServiceStatus(gStatusHandle, &gStatus);
}


/*****************************************************************************
 *  LicenseModeInit
 *
 *    Initialize the licensing mode
 ****************************************************************************/

void LicenseModeInit(HKEY hKeyTermSrv)
{
    DWORD dwValueType;
    LONG lReturn;
    DWORD cbValue = sizeof( DWORD ), dwAccount = UNLEN + 1;
    DWORD dwRegValue;
    OSVERSIONINFO VersionInfo;

    ASSERT(hKeyTermSrv != NULL);

    //
    // Get the user name for which the service is started under
    //
    GetUserName(g_tszServiceAccount, &dwAccount);

    // 
    // Check whether Remote Admin is enabled
    //
    lReturn = RegQueryValueEx(hKeyTermSrv,
            REG_TERMSRV_APPCOMPAT,
            NULL,
            &dwValueType,
            (LPBYTE) &dwRegValue,
            &cbValue);
    if (lReturn == ERROR_SUCCESS) {
        g_fAppCompat = (BOOL)dwRegValue;
    }

    //
    // Get the product version
    //
    memset( &VersionInfo, 0, sizeof( OSVERSIONINFO ) );
    VersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    if (GetVersionEx(&VersionInfo)) {
        wsprintf( g_wszProductVersion, L"%d.%d",
                  VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion );
    }
    else {
        TRACE((hTrace, TC_ICASRV, TT_ERROR, "LicenseModeInit: GetVersionEx "
                "failed: 0x%x\n", GetLastError()));
    }
}

//
// Get Safeboot option, code modified from ds\security\gina\winlogon\aenrlhlp.c
//
BOOL WINAPI 
IsSafeBootWithNetwork()
{
    DWORD   dwSafeBoot = 0;
    DWORD   cbSafeBoot = sizeof(dwSafeBoot);
    DWORD   dwType = 0;

    HKEY    hKeySafeBoot = NULL;

    if(ERROR_SUCCESS == RegOpenKeyW(
                              HKEY_LOCAL_MACHINE,
                              L"system\\currentcontrolset\\control\\safeboot\\option",
                              &hKeySafeBoot))
    {
        // we did in fact boot under safeboot control
        if(ERROR_SUCCESS != RegQueryValueExW(
                                    hKeySafeBoot,
                                    L"OptionValue",
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwSafeBoot,
                                    &cbSafeBoot))
        {
            dwSafeBoot = 0;
        }

        if(hKeySafeBoot)
            RegCloseKey(hKeySafeBoot);
    }

    

    return ( SAFEBOOT_NETWORK == dwSafeBoot );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\registry.c ===
/*************************************************************************
*
* registry.c
*
*  WinStation Registry Routines
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   Public functions
=============================================================================*/

NTSTATUS WinStationReadRegistryWorker( VOID );


/*=============================================================================
==   Functions Used
=============================================================================*/

NTSTATUS IcaRegWinStationEnumerate( PULONG, PWINSTATIONNAME, PULONG );
NTSTATUS QueueWinStationCreate( PWINSTATIONNAME );
PWINSTATION FindWinStationByName( LPWSTR WinStationName, BOOLEAN LockList );
NTSTATUS QueueWinStationReset( ULONG LogonId );
NTSTATUS ReadWinStationSecurityDescriptor( PWINSTATION pWinStation );
NTSTATUS WinStationRenameWorker(PWINSTATIONNAME, ULONG, PWINSTATIONNAME, ULONG);

/*=============================================================================
==   Global data
=============================================================================*/

extern LIST_ENTRY WinStationListHead;    // protected by WinStationListLock

extern RTL_RESOURCE WinStationSecurityLock;
extern POLICY_TS_MACHINE    g_MachinePolicy;    //defined in winsta.c
extern RTL_RESOURCE WinStationSecurityLock;


/*******************************************************************************
 *
 *  WinStationReadRegistryWorker
 *
 *    Update the listening winstations to match the registry
 *
 *    This function assumes that g_MachinePolicy is up to date. This object is a global object
 *      which is updated on TS startup, and any time there is a TS related policy change.
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

typedef struct _RENAMEINFO {
    WINSTATIONNAME OldName;
    BOOLEAN Renamed;
} RENAMEINFO, *PRENAMEINFO;

#define KEEP_ALIVE_INTERVAL_DFLT     4     // in minutes

NTSTATUS
WinStationKeepAlive()
{
    NTSTATUS                    Status;
    ICA_KEEP_ALIVE              k;
    HANDLE                      hKeepAlive;
    static      ICA_KEEP_ALIVE  kPrev;
    static      BOOLEAN         firstTime = TRUE;

    k.start     = FALSE;
    k.interval  = 0;

    if ( g_MachinePolicy.fPolicyKeepAlive )
    {
        k.start = (BOOLEAN) g_MachinePolicy.fKeepAliveEnable;
        k.interval = g_MachinePolicy.KeepAliveInterval;
    }
    else
    {
        // read to see what the registry policy is set to...
        // Code below was cut/paste from termdd ( where Zw was replaced with Nt )
        UNICODE_STRING    RegistryPath;
        UNICODE_STRING    KeyName;
        HANDLE            hKey;
        OBJECT_ATTRIBUTES ObjAttribs;
        ULONG             KeyInfoBuffer[16];
        ULONG             KeyInfoLength;
        PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;
        ULONG             KeepAliveEnable;
        ULONG             KeepAliveInterval;
    
        // Open the Terminal Server subkey under \\HKEY_LOCAL_MACHINE\SYSTEM\CurrentConttrolSet\
        // Control\Terminal Server
        RtlInitUnicodeString(&RegistryPath, REG_NTAPI_CONTROL_TSERVER);
        InitializeObjectAttributes(&ObjAttribs, &RegistryPath, OBJ_CASE_INSENSITIVE, NULL, NULL);
        Status = NtOpenKey(&hKey, KEY_READ, &ObjAttribs);
    
        if (Status == STATUS_SUCCESS) {
            pKeyInfo =  (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfoBuffer;
    
            // Get the value for KeepAliveEnable Key
            RtlInitUnicodeString(&KeyName, KEEP_ALIVE_ENABLE_KEY);
            Status = NtQueryValueKey(hKey, &KeyName, KeyValuePartialInformation,
                    pKeyInfo, sizeof(KeyInfoBuffer), &KeyInfoLength);
    
            if ((Status == STATUS_SUCCESS) && (pKeyInfo->Type == REG_DWORD) &&
                    (pKeyInfo->DataLength == sizeof(ULONG))) {
                KeepAliveEnable = *((PULONG) pKeyInfo->Data);
            }
            else {
                // By default, we don't enable keepalive
                KeepAliveEnable = 0;
            }
    
            if (KeepAliveEnable) {
                // Get the value for KeepAliveInterval
                RtlInitUnicodeString(&KeyName, KEEP_ALIVE_INTERVAL_KEY);
                Status = NtQueryValueKey(hKey, &KeyName, KeyValuePartialInformation,
                        pKeyInfo, sizeof(KeyInfoBuffer), &KeyInfoLength);
    
                if (Status == STATUS_SUCCESS && (pKeyInfo->Type == REG_DWORD) &&
                        (pKeyInfo->DataLength == sizeof(ULONG))) {
                    KeepAliveInterval = *((PULONG) pKeyInfo->Data);
                }
                else {
                    // The default KeepAliveInterval is 2 min
                    KeepAliveInterval = KEEP_ALIVE_INTERVAL_DFLT;
                }
            }
            else {
                // The default KeepAliveInterval
                KeepAliveInterval = KEEP_ALIVE_INTERVAL_DFLT;
            }
    
            // Close the Key
            NtClose(hKey);
        }
        else {
            // Set the default values for KeepAlive parameters
            KeepAliveEnable = 0;
            KeepAliveInterval = KEEP_ALIVE_INTERVAL_DFLT;
        }

        k.start = (BOOLEAN )KeepAliveEnable;
        k.interval =  KeepAliveInterval;

    }

    if ( firstTime )
    {
        kPrev = k;
    }
    else
    {

        #ifdef  DBG
            #ifdef ARABERN_TEST
                #include <time.h>
                ULONG   x;
                srand( (unsigned)time( NULL ) );
                x = rand();
                k.start =    (BOOLEAN ) (0x00000001 & x) ;
                k.interval = 0x00000008 & x ;
            #endif
        #endif
        
        if ( ( kPrev.start == k.start  )  && ( kPrev.interval == k.interval ) )
        {
            // no change, nothing to do, so return;
            return STATUS_SUCCESS;
        }
    }

    /*
     *  Open TermDD.
     */
    Status = IcaOpen(&hKeepAlive);

    if (NT_SUCCESS(Status)) 
    {
        Status = IcaIoControl(hKeepAlive, IOCTL_ICA_SYSTEM_KEEP_ALIVE , &k,
                sizeof(k), NULL, 0, NULL);

        IcaClose(hKeepAlive);
        hKeepAlive = NULL;
    }

    firstTime = FALSE;

    return Status;

}

NTSTATUS 
WinStationReadRegistryWorker()
{
    ULONG WinStationCount;
    ULONG ByteCount;
    WINSTATIONNAME * pWinStationName;
    PWINSTATIONCONFIG2 pWinConfig;
    PWINSTATION pWinStation;
    PRENAMEINFO pRenameInfo;
    PLIST_ENTRY Head, Next;
    NTSTATUS Status;
    ULONG i;

    if ( !gbServer )
        ENTERCRIT( &WinStationListenersLock );

    // see if keep alive is required, then IOCTL it to TermDD
    WinStationKeepAlive();

    /*
     *  Get the number of WinStations in the registry
     */
    WinStationCount = 0;
    Status = IcaRegWinStationEnumerate( &WinStationCount, NULL, &ByteCount );
    if ( !NT_SUCCESS(Status) ) 
        goto badenum1;

    /*
     *  Allocate a buffer for the WinStation names
     */
    pWinStationName = MemAlloc( ByteCount );
    if ( pWinStationName == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto badalloc1;
    }

    /*
     * Get list of WinStation names from registry
     */
    WinStationCount = (ULONG) -1;
    Status = IcaRegWinStationEnumerate( &WinStationCount, 
                                        (PWINSTATIONNAME)pWinStationName, 
                                        &ByteCount );
    if ( !NT_SUCCESS(Status) ) 
        goto badenum2;

    /*
     *  Allocate a buffer for WinStation configuration data
     */
    pWinConfig = MemAlloc( sizeof(WINSTATIONCONFIG2) * WinStationCount );
    if ( pWinConfig == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto badalloc2;
    }

    /*
     *  Allocate a buffer for tracking listener WinStation renames
     */
    pRenameInfo = MemAlloc( sizeof(RENAMEINFO) * WinStationCount );
    if ( pRenameInfo == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto badalloc3;
    }


    /*
     * Now query the configuration data for each of the WinStation names
     */
    for ( i = 0; i < WinStationCount; i++ ) {
        pRenameInfo[i].Renamed = FALSE;
            {
            TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationReadRegistryWorker: %S\n",pWinStationName[i]));
            Status = RegWinStationQueryEx( 
                                         SERVERNAME_CURRENT, 
                                         &g_MachinePolicy, 
                                         pWinStationName[i],
                                         &pWinConfig[i],
                                         sizeof(WINSTATIONCONFIG2),
                                         &ByteCount, TRUE );
            if ( !NT_SUCCESS(Status) ) {
                goto badregdata;
            }
        }
    }

    /*
     *  Check if any existing WinStations need to be deleted
     */
    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {

        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

        /*
         * only check listening and single-instance winstations
         */
        if ( !(pWinStation->Flags & WSF_LISTEN) &&
             !(pWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST) )
            continue;

        /* check if name still exists in the registry */
        for ( i = 0; i < WinStationCount; i++ ) {
            if ( !_wcsicmp( pWinStationName[i], pWinStation->WinStationName ) ) {
                break;
            }
        }

        if ( i == WinStationCount ) {
            /* The WinStation is not in the registry. If the listener was
               renamed, we don't want to reset it. We look for a registry
               entry which has the same configuration info.
             */

            for ( i = 0; i < WinStationCount; i++ ) {
                if ( !memcmp( &pWinStation->Config, &pWinConfig[i], sizeof(WINSTATIONCONFIG2) ) ) {
                    pRenameInfo[i].Renamed = TRUE;
                    wcscpy(pRenameInfo[i].OldName, pWinStation->WinStationName);
                    DBGPRINT(("TERMSRV: Renaming %ws to %ws\n",
                             pWinStation->WinStationName, pWinStationName[i]));
                    break;
                }
            }
    
        }

        /* If no match was found in the registry, or if the matching
           listener is diabled, reset the listener.
         */
        if ((i == WinStationCount) ||
            (CheckWinStationEnable(!pRenameInfo[i].Renamed ? 
                                   pWinStation->WinStationName :
                                   pWinStationName[i]) != STATUS_SUCCESS)) {
            TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationReadRegistryWorker: DELETE %u\n",
                   pWinStation->LogonId ));
            QueueWinStationReset( pWinStation->LogonId );
        }

    }
    LEAVECRIT( &WinStationListLock );

    /*
     *  Check if any WinStations need to be created or reset
     */
    for ( i = 0; i < WinStationCount; i++ ) {

        if ( _wcsicmp( pWinStationName[i], L"Console" ) ){
        /*
         * Ignore console WinStation
         */
            /*
             * If this WinStation exists, then see if the Registry data
             * has changed.  If so, then reset the WinStation.
             */
            if ( pWinStation = FindWinStationByName( pWinStationName[i], FALSE ) ) {

                if ( memcmp( &pWinStation->Config, &pWinConfig[i], sizeof(WINSTATIONCONFIG2) ) ) {

                    /*
                     * NOTE: For network WinStations, we test to see if the Lan
                     *       Adapter setting has changed.  If not, we simply
                     *       refresh the configuration data since resetting the
                     *       WinStation would reset ALL connections on the same
                     *       Transport/Lan adapter combination.
                     */
                    if ( pWinConfig[i].Pd[0].Create.SdClass == SdNetwork &&
                         pWinConfig[i].Pd[0].Params.Network.LanAdapter ==
                         pWinStation->Config.Pd[0].Params.Network.LanAdapter ) {
                        memcpy( &pWinStation->Config, &pWinConfig[i], sizeof(WINSTATIONCONFIG2) );

                        /*
                         * Listening network winstations should update their security 
                         * descriptors.
                         */
                        RtlAcquireResourceExclusive(&WinStationSecurityLock, TRUE);
                        ReadWinStationSecurityDescriptor( pWinStation );
                        RtlReleaseResource(&WinStationSecurityLock);
                        
                    /*
                     * NOTE: For async WinStations, if the WinStation is NOT in
                     *       in the listen state and the Device name and Modem
                     *       name have not changed, then we do nothing.  The
                     *       new config data will be read when the WinStation
                     *       is next re-created.
                     */
                    } else if ( pWinConfig[i].Pd[0].Create.SdClass == SdAsync &&
                                pWinStation->State != State_Listen &&
                                !memcmp ( pWinConfig[i].Pd[0].Params.Async.DeviceName,
                                          pWinStation->Config.Pd[0].Params.Async.DeviceName,
                                          sizeof( pWinConfig[i].Pd[0].Params.Async.DeviceName ) ) &&
                                !memcmp ( pWinConfig[i].Pd[0].Params.Async.ModemName,
                                          pWinStation->Config.Pd[0].Params.Async.ModemName,
                                          sizeof( pWinConfig[i].Pd[0].Params.Async.ModemName ) ) ) {

                        // Nothing to do

                    /*
                     * NOTE: For OEM WinStations, if the WinStation is NOT in
                     *       in the listen state and the Pd[0] params have not
                     *       changed, then we do nothing.  The new config data
                     *       will be read when the WinStation is next re-created.
                     */
                    } else if ( pWinConfig[i].Pd[0].Create.SdClass == SdOemTransport &&
                                pWinStation->State != State_Listen &&
                                !memcmp ( &pWinConfig[i].Pd[0].Params,
                                          &pWinStation->Config.Pd[0].Params,
                                          sizeof( pWinConfig[i].Pd[0].Params ) ) ) {

                        // Nothing to do

                    } else {

                        BOOLEAN bRecreate = TRUE;

                        if ( !gbServer ) {
                            if ( g_fDenyTSConnectionsPolicy  &&
                                 // Performance, we only want to check if policy enable help when connection is denied
                                 (!TSIsMachineInHelpMode() || !TSIsMachinePolicyAllowHelp()) ) {

                                bRecreate = FALSE;
                            } 

                            WinStationResetWorker( pWinStation->LogonId, TRUE, FALSE, bRecreate ); 

                        } else {

                            QueueWinStationReset( pWinStation->LogonId );
                        }
                    }
                }
                else if ( !(pWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST) ||
                          ( pWinStation->State == State_Listen ) ) {

                    RtlAcquireResourceExclusive(&WinStationSecurityLock, TRUE);
                    ReadWinStationSecurityDescriptor( pWinStation );
                    RtlReleaseResource(&WinStationSecurityLock);
                }
                ReleaseWinStation( pWinStation );

            } else
            if (pRenameInfo[i].Renamed &&
                NT_SUCCESS(WinStationRenameWorker(pRenameInfo[i].OldName,
                                                  sizeof(WINSTATIONNAMEW)/sizeof(WCHAR),
                                                  pWinStationName[i],
                                                  sizeof(WINSTATIONNAMEW)/sizeof(WCHAR)))) {
                // Rename succeeded - don't recreate listener
            /*
             * An active WinStation was not found so we will create one.
             */
            } else {

                 if ( !gbServer &&
                       g_fDenyTSConnectionsPolicy  &&
                      // Performance, we only want to check if policy enable help when connection is denied
                      (!TSIsMachineInHelpMode() || !TSIsMachinePolicyAllowHelp()) ) {

                     continue;
                 }

                /*
                 * NOTE: NEVER create TAPI modem winstations in this routine.
                 *       We only allow creation of these winstations at
                 *       system startup time due to issues with the TAPI
                 *       database potentially being locked by this and other
                 *       processes, resulting in incorrect TAPI device
                 *       enumeration.
                 */
                 if ( pWinConfig[i].Cd.CdClass != CdModem ) {
                     if (!gbServer ) {
                        WinStationCreateWorker( pWinStationName[i], NULL );
                     } else {
                        QueueWinStationCreate( pWinStationName[i] );
                     }
                 }
            }
        }
        else
        {
            // we are dealing with the console session, update userconfig's shadow bit, that is 
            // the only item I know of that needs updating.
            if ( pWinStation = FindWinStationByName( pWinStationName[i], FALSE ) ) {
                pWinStation->Config.Config.User.Shadow = pWinConfig[i].Config.User.Shadow;
                pWinStation->Config.Config.User.fInheritShadow  = pWinConfig[i].Config.User.fInheritShadow;
                TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationReadRegistryWorker: %S, Shadow value of %d copied to console session's USERCONFIG\n",pWinStationName[i], 
                       pWinConfig[i].Config.User.Shadow));
                ReleaseWinStation( pWinStation );
            }
        }
    }

    /*
     *  Free buffers
     */
    MemFree( pRenameInfo );
    MemFree( pWinConfig );
    MemFree( pWinStationName );

    if ( !gbServer )
        LEAVECRIT( &WinStationListenersLock );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

badregdata:
    MemFree( pRenameInfo );
badalloc3:
    MemFree( pWinConfig );
badalloc2:
badenum2:
    MemFree( pWinStationName );
badalloc1:
badenum1:
    
    if ( !gbServer )
        LEAVECRIT( &WinStationListenersLock );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\misc.c ===
/****************************************************************************/
// misc.c
//
// TermSrv general code.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <rpc.h>
#include <msaudite.h>
#include <ntlsa.h>
#include <authz.h>
#include <authzi.h>
//external procedures used
extern NTSTATUS
AuthzReportEventW( IN PAUTHZ_AUDIT_EVENT_TYPE_HANDLE pHAET, 
                   IN DWORD Flags, 
                   IN ULONG EventId, 
                   IN PSID pUserID, 
                   IN USHORT NumStrings,
                   IN ULONG DataSize OPTIONAL, //Future - DO NOT USE
                   IN PUNICODE_STRING* Strings,
                   IN PVOID  Data OPTIONAL         //Future - DO NOT USE
                   );


extern BOOL 
AuthzInit( IN DWORD Flags,
           IN USHORT CategoryID,
           IN USHORT AuditID,
           IN USHORT ParameterCount,
           OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
           );




NTSTATUS ConfigureEnable(
        IN PWSTR ValueName,
        IN ULONG ValueType,
        IN PVOID ValueData,
        IN ULONG ValueLength,
        IN PVOID Context,
        IN PVOID EntryContext)
{
    if (ValueType == REG_DWORD && *(PULONG)ValueData != 0)
        return STATUS_SUCCESS;
    return STATUS_UNSUCCESSFUL;
}


RTL_QUERY_REGISTRY_TABLE WinStationEnableTable[] = {
    { ConfigureEnable, RTL_QUERY_REGISTRY_REQUIRED, WIN_ENABLEWINSTATION,
        NULL, REG_NONE, NULL, 0},
    { NULL, 0, NULL, NULL, REG_NONE, NULL, 0}
};


NTSTATUS CheckWinStationEnable(LPWSTR WinStationName)
{
    NTSTATUS Status;

    PWCHAR PathBuf = MemAlloc((wcslen(REG_TSERVER_WINSTATIONS L"\\") + wcslen(WinStationName) + 1) * sizeof(WCHAR));
    if (!PathBuf)
    {
        return STATUS_NO_MEMORY;
    }

    wcscpy(PathBuf, REG_TSERVER_WINSTATIONS L"\\");
    wcscat(PathBuf, WinStationName);

    /*
     * Check if WinStation is enabled, and return error if not.
     */
    Status = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL, PathBuf,
            WinStationEnableTable, NULL, NULL);

    MemFree(PathBuf);
    return Status;
}


void InitializeSystemTrace(HKEY hKeyTermSrv)
{
    ICA_TRACE Trace;
    NTSTATUS Status;
    WCHAR SystemDir[256];
    DWORD ValueType;
    DWORD ValueSize;
    ULONG fDebugger;
    UINT uiWinDirSize;

    ASSERT(hKeyTermSrv != NULL);


    RtlZeroMemory( &Trace , sizeof( ICA_TRACE ) );
    /*
     *  Query trace enable flag
     */
    ValueSize = sizeof(Trace.TraceEnable);
    Status = RegQueryValueEx(hKeyTermSrv, WIN_TRACEENABLE, NULL, &ValueType,
            (LPBYTE) &Trace.TraceEnable, &ValueSize);
    if (Status == ERROR_SUCCESS && Trace.TraceEnable != 0) {
        /*
         *  Query trace class flag
         */
        ValueSize = sizeof(Trace.TraceClass);
        Status = RegQueryValueEx(hKeyTermSrv, WIN_TRACECLASS, NULL,
                &ValueType, (LPBYTE)&Trace.TraceClass, &ValueSize);
        if (Status != ERROR_SUCCESS) {
            Trace.TraceClass = 0xffffffff;
        }

        /*
         *  Query trace to debugger flag
         */
        ValueSize = sizeof(fDebugger);
        Status = RegQueryValueEx(hKeyTermSrv, WIN_TRACEDEBUGGER, NULL, 
                &ValueType, (LPBYTE)&fDebugger, &ValueSize);
        if (Status != ERROR_SUCCESS) {
            fDebugger = FALSE; 
        }

        Trace.fDebugger  = (BOOLEAN)fDebugger;
        Trace.fTimestamp = TRUE;

        uiWinDirSize = GetWindowsDirectory(SystemDir, sizeof(SystemDir)/sizeof(WCHAR));
        if ((uiWinDirSize == 0) || 
            ((uiWinDirSize + wcslen(L"\\ICADD.log") + 1) > sizeof(Trace.TraceFile)/sizeof(WCHAR)))
        {
            // we failed to get the windows directory or we dont have enough buffer for the logfile.
            Trace.TraceEnable = 0;
            
        }
        else
        {

            wsprintf(Trace.TraceFile, L"%s\\ICADD.log", SystemDir);

            /*
             *  Open TermDD.
             */
            Status = IcaOpen(&hTrace);
            if (NT_SUCCESS(Status)) {
                Status = IcaIoControl(hTrace, IOCTL_ICA_SET_SYSTEM_TRACE, &Trace,
                        sizeof(Trace), NULL, 0, NULL);
                if (!NT_SUCCESS(Status)) {
                    IcaClose(hTrace);
                    hTrace = NULL;
                }
            }

            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_TRACE_LEVEL, "TRACE: %S, c:%x, e:%x d:%d, Status=0x%x\n", Trace.TraceFile,
                      Trace.TraceClass, Trace.TraceEnable, Trace.fDebugger, Status ));
        }
    }
}


void InitializeTrace(
        PWINSTATION pWinStation,
        BOOLEAN fListen,
        PICA_TRACE pTrace)
{
    PWINSTATIONNAME pWinStationName;
    NTSTATUS Status;
    WCHAR SystemDir[256];
    ULONG fDebugger;
    ULONG ulSize;

    /*
     * Use WinStation name if set, else try ListenName,
     * otherwise nothing to be done.
     */
    if (pWinStation->WinStationName[0])
        pWinStationName = pWinStation->WinStationName;
    else if (pWinStation->ListenName[0])
        pWinStationName = pWinStation->ListenName;
    else
        return;

    /*
     *  Check if trace should be enabled for this WinStation
     */
    Status = RegWinStationQueryNumValue(SERVERNAME_CURRENT, pWinStationName,
            WIN_TRACEENABLE, &pTrace->TraceEnable);

    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_TRACE_LEVEL, "TERMSRV: InitializeTrace: LogonId %d, fListen %u, Status=0x%x\n",
              pWinStation->LogonId, fListen, Status ));

    if (Status == ERROR_SUCCESS && pTrace->TraceEnable != 0) {
        /*
         *  Enable trace for this WinStation
         */
        if (RegWinStationQueryNumValue(SERVERNAME_CURRENT, pWinStationName,
                WIN_TRACECLASS, &pTrace->TraceClass))
            pTrace->TraceClass = 0xffffffff;

        if (RegWinStationQueryNumValue(SERVERNAME_CURRENT, pWinStationName,
                WIN_TRACEDEBUGGER, &fDebugger))
            fDebugger = FALSE; 

        pTrace->fDebugger  = (BOOLEAN)fDebugger;
        pTrace->fTimestamp = TRUE;

        if (RegWinStationQueryValue(SERVERNAME_CURRENT, pWinStationName,
                WIN_TRACEOPTION, pTrace->TraceOption,
                sizeof(pTrace->TraceOption), &ulSize))
            memset(pTrace->TraceOption, 0, sizeof(pTrace->TraceOption));

        if (GetWindowsDirectory(SystemDir, sizeof(SystemDir)/sizeof(WCHAR)) == 0) {
            return;
        }

        if (fListen)
            wsprintf(pTrace->TraceFile, L"%s\\%s.log", SystemDir,
                    pWinStationName);
        else
            wsprintf(pTrace->TraceFile, L"%s\\%u.log", SystemDir,
                    pWinStation->LogonId);

        Status = IcaIoControl(pWinStation->hIca, IOCTL_ICA_SET_TRACE, pTrace,
                sizeof(ICA_TRACE), NULL, 0, NULL);

        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_TRACE_LEVEL, "TRACE: %S, c:%x, e:%x d:%d, Status=0x%x\n", pTrace->TraceFile,
                  pTrace->TraceClass, pTrace->TraceEnable, pTrace->fDebugger, Status ));
    }
}


/*
 * Retrieves non-trace systemwide registry entries and conveys them to TermDD.
 * Single location for configuration params.
 */
void GetSetSystemParameters(HKEY hKeyTermSrv)
{
    TERMSRV_SYSTEM_PARAMS SysParams;
    NTSTATUS Status;
    DWORD ValueType;
    DWORD ValueSize;
    HANDLE hTermDD;

    ASSERT(hKeyTermSrv != NULL);

    // Read the mouse throttle size.
    ValueSize = sizeof(SysParams.MouseThrottleSize);
    if (RegQueryValueEx(hKeyTermSrv, REG_MOUSE_THROTTLE_SIZE, NULL,
            &ValueType, (PCHAR)&SysParams.MouseThrottleSize, &ValueSize) ==
            ERROR_SUCCESS) {
        // Round the retrieved value up to the next multiple of the
        // input size.
        SysParams.MouseThrottleSize = (SysParams.MouseThrottleSize +
                sizeof(MOUSE_INPUT_DATA) - 1) &
                ~(sizeof(MOUSE_INPUT_DATA) - 1);
    }
    else {
        // Set default value.
        SysParams.MouseThrottleSize = DEFAULT_MOUSE_THROTTLE_SIZE;
    }

    // Read the keyboard throttle size.
    ValueSize = sizeof(SysParams.KeyboardThrottleSize);
    if (RegQueryValueEx(hKeyTermSrv, REG_KEYBOARD_THROTTLE_SIZE, NULL,
            &ValueType, (PCHAR)&SysParams.KeyboardThrottleSize, &ValueSize) ==
            ERROR_SUCCESS) {
        // Round the retrieved value up to the next multiple of the
        // input size.
        SysParams.KeyboardThrottleSize = (SysParams.KeyboardThrottleSize +
                sizeof(KEYBOARD_INPUT_DATA) - 1) &
                ~(sizeof(KEYBOARD_INPUT_DATA) - 1);
    }
    else {
        // Set default value.
        SysParams.KeyboardThrottleSize = DEFAULT_KEYBOARD_THROTTLE_SIZE;
    }

    // Open TermDD and send IOCTL.
    Status = IcaOpen(&hTermDD);
    if (NT_SUCCESS(Status)) {
        Status = IcaIoControl(hTermDD, IOCTL_ICA_SET_SYSTEM_PARAMETERS,
                &SysParams, sizeof(SysParams), NULL, 0, NULL);
        IcaClose(hTermDD);
    }

    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_TRACE_LEVEL, "SysParams: MouseThrottle=%u, KbdThrottle=%u, Status=0x%x\n",
             SysParams.MouseThrottleSize, SysParams.KeyboardThrottleSize,
             Status));
}


VOID AuditShutdownEvent(void)
{
    RPC_STATUS  RPCStatus;
    NTSTATUS    NtStatus;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET = NULL;

    RPCStatus = RpcImpersonateClient(NULL);
    
    if (RPCStatus != RPC_S_OK)
    {
        DBGPRINT(("TERMSRV: AuditShutdownEvent: Not impersonating! RpcStatus 0x%x\n",RPCStatus));
        return;
    }

    //
    //authz Changes
    //
    if( !AuthzInit( 0, SE_CATEGID_SYSTEM, SE_AUDITID_SYSTEM_SHUTDOWN, 0, &hAET ))
            goto ExitFunc;
     
     NtStatus = AuthzReportEventW( &hAET, 
                                   APF_AuditSuccess, 
                                   0, 
                                   NULL, 
                                   0,
                                   0,
                                   NULL,
                                   NULL
                                   );
            

     //end authz changes

     if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: Failed to report shutdown event.\n"));
    }

ExitFunc:
    if( hAET != NULL )
        AuthziFreeAuditEventType( hAET  );
    if (RPCStatus == RPC_S_OK)
        RpcRevertToSelf();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\sessdir.h ===
/****************************************************************************/
// sessdir.h
//
// TS Session Directory header.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/
#ifndef __SESSDIR_H
#define __SESSDIR_H

#include "tssd.h"
#include <winsock2.h>
#include <ws2tcpip.h>


#ifdef __cplusplus
extern "C" {
#endif

// This one shoud be consistent with the one in at120ex.h
#define TS_CLUSTER_REDIRECTION_VERSION3             0x2

extern WCHAR g_LocalServerAddress[64];

extern POLICY_TS_MACHINE g_MachinePolicy;

void InitSessionDirectory();
DWORD UpdateSessionDirectory();
DWORD RepopulateSessionDirectory();
void DestroySessionDirectory();

void SessDirNotifyLogon(TSSD_CreateSessionInfo *);
void SessDirNotifyDisconnection(DWORD, FILETIME);
void SessDirNotifyReconnection(TSSD_ReconnectSessionInfo *);
void SessDirNotifyLogoff(DWORD);
void SessDirNotifyReconnectPending(WCHAR *ServerName);
unsigned SessDirGetDisconnectedSessions(WCHAR *, WCHAR *,
        TSSD_DisconnectedSessionInfo[TSSD_MaxDisconnectedSessions]);
BOOL SessDirCheckRedirectClient(PWINSTATION, TS_LOAD_BALANCE_INFO *);
BOOL SessDirGetLBInfo(WCHAR *ServerAddress, DWORD* pLBInfoSize, PBYTE* pLBInfo);

int SetTSSD(ITSSessionDirectory *pTSSD);
ITSSessionDirectory *GetTSSD();
void ReleaseTSSD();

int SetTSSDEx(ITSSessionDirectoryEx *pTSSD);
ITSSessionDirectoryEx *GetTSSDEx();
void ReleaseTSSDEx();


#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // __SESSDIR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\regnw.c ===
/*************************************************************************
*
* nw.c
*
*  Netware security support
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop
#include <ntlsa.h>

#include <rpc.h>


#if DBG
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#define DBGPRINT(x) DbgPrint x
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif


/*
 * This is the prefix for the secret object name.
 */
#define CITRIX_NW_SECRET_NAME L"CTX_NW_INFO_"


/*=============================================================================
==   Public functions
=============================================================================*/



/*=============================================================================
==   Functions Used
=============================================================================*/
NTSTATUS CreateSecretInLsa(
    PWCHAR pSecretName,
    PWCHAR pSecretData
    );

NTSTATUS
QuerySecretInLsa(
    PWCHAR pSecretName,
    PWCHAR pSecretData,
    DWORD  ByteCount
    );

BOOL
IsCallerSystem( VOID );

BOOL
IsCallerAdmin( VOID );

BOOL
TestUserForAdmin( VOID );



NTSTATUS
IsZeroterminateStringA(
    PBYTE pString,
    DWORD  dwLength
    );



NTSTATUS
IsZeroterminateStringW(
    PWCHAR pwString,
    DWORD  dwLength
    ) ;
/*=============================================================================
==   Global data
=============================================================================*/


/*******************************************************************************
 *
 *  RpcServerNWLogonSetAdmin (UNICODE)
 *
 *    Creates or updates the specified server's NWLogon Domain Administrator
 *    UserID and Password in the SAM secret objects of the specified server.
 *
 *    The caller must be ADMIN.
 *
 * ENTRY:
 *    pServerName (input)
 *       Server to store info for. This server is typically a domain controller.
 *
 *    pNWLogon (input)
 *       Pointer to a NWLOGONADMIN structure containing specified server's
 *       domain admin and password.
 *
 * EXIT:
 *    ERROR_SUCCESS - no error
 *    ERROR_INSUFFICIENT_BUFFER - pUserConfig buffer too small
 *      otherwise: the error code
 *
 ******************************************************************************/

BOOLEAN
RpcServerNWLogonSetAdmin(
    HANDLE        hServer,
    DWORD         *pResult,
    PWCHAR        pServerName,
    DWORD         ServerNameSize,
    PNWLOGONADMIN pNWLogon,
    DWORD         ByteCount
    )
{
    DWORD Size;
    DWORD Result;
    PWCHAR pDomain;
    UINT  LocalFlag;
    PWCHAR pSecretName;
    RPC_STATUS RpcStatus;
    WCHAR UserPass[ USERNAME_LENGTH + PASSWORD_LENGTH + DOMAIN_LENGTH + 3 ];

    // Do minimal buffer validation

    if (pNWLogon == NULL ) {
        *pResult = STATUS_INVALID_USER_BUFFER;
        return FALSE;
    }

    if( pServerName == NULL ) {
        DBGPRINT(("NWLogonSetAdmin: No ServerName\n"));
        *pResult = (ULONG)STATUS_INVALID_PARAMETER;
        return( FALSE );
    }

    *pResult = IsZeroterminateStringW(pServerName, ServerNameSize  );

    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }


    pNWLogon->Username[USERNAME_LENGTH] = (WCHAR) 0;
    pNWLogon->Password[PASSWORD_LENGTH] = (WCHAR) 0;
    pNWLogon->Domain[DOMAIN_LENGTH] = (WCHAR) 0;

    //
    // Only a SYSTEM mode caller (IE: Winlogon) is allowed
    // to query this value.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT(("RpcServerNWLogonSetAdmin: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = (ULONG)STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT(("NWLogonSetAdmin Could not query local client RpcStatus 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        *pResult = (ULONG)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    if( !LocalFlag ) {
        DBGPRINT(("NWLogonSetAdmin Not a local client call\n"));
        RpcRevertToSelf();
        *pResult = (ULONG)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    if( !IsCallerAdmin() ) {
        RpcRevertToSelf();
        DBGPRINT(("RpcServerNWLogonSetAdmin: Caller Not SYSTEM\n"));
        *pResult = (ULONG)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    RpcRevertToSelf();


    if( ByteCount < sizeof(NWLOGONADMIN) ) {
        DBGPRINT(("NWLogonSetAdmin: Bad size %d\n",ByteCount));
        *pResult = (ULONG)STATUS_INFO_LENGTH_MISMATCH;
        return( FALSE );
    }

    //  check for username, and if there is one then encrypt username and pw

        TRACE0(("NWLogonSetAdmin: UserName %ws\n",pNWLogon->Username));

        // concatenate the username, password, and domain together
        wcscpy(UserPass, pNWLogon->Username);
        wcscat(UserPass, L"/");
        wcscat(UserPass, pNWLogon->Password);
        wcscat(UserPass, L"/");

        // Skip over any \\ backslashes (if a machine name was passed in)
        pDomain = pNWLogon->Domain;
        while (*pDomain == L'\\') {
            pDomain++;
        }
        wcscat(UserPass, pDomain);

        //
        // Build the secret name from the server name.
        //
        // This is because each domain will have a different entry.
        //

        // Skip over any \\ backslashes (if a machine name was passed in)
        while (*pServerName == L'\\') {
            pServerName++;
        }
        Size = wcslen(pServerName) + 1;
        Size *= sizeof(WCHAR);
        Size += sizeof(CITRIX_NW_SECRET_NAME);

        pSecretName = MemAlloc( Size );
        if( pSecretName == NULL ) {
            DBGPRINT(("NWLogonSetAdmin: No memory\n"));
            *pResult = (ULONG)STATUS_NO_MEMORY;
            return( FALSE );
        }

        wcscpy(pSecretName, CITRIX_NW_SECRET_NAME );
        wcscat(pSecretName, pServerName );

    //  check for username, and if there is one then encrypt username and pw
    if ( wcslen( pNWLogon->Username ) ) {
        //  store encrypted username
        Result = CreateSecretInLsa( pSecretName, UserPass );
    } else {
        // If there wasn't a username, clear this secret object. 
        Result = CreateSecretInLsa( pSecretName, L"");
        DBGPRINT(("TERMSRV: RpcServerNWLogonSetAdmin: UserName not supplied\n"));
    }
    MemFree( pSecretName );

    *pResult = Result;
    return( Result == STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  RpcServerQueryNWLogonAdmin
 *
 *     Query NWLOGONADMIN structure from the SAM Secret object on the given
 *     WinFrame server.
 *
 *     The caller must be SYSTEM context, IE: WinLogon.
 *
 * ENTRY:
 *    hServer (input)
 *       Rpc handle
 *
 *    pServerName (input)
 *       Server to store info for. This server is typically a domain controller.
 *
 *    pNWLogon (output)
 *       pointer to NWLOGONADMIN structure
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

BOOLEAN
RpcServerNWLogonQueryAdmin(
    HANDLE        hServer,
    DWORD         *pResult,
    PWCHAR        pServerName,
    DWORD         ServerNameSize,
    PNWLOGONADMIN pNWLogon,
    DWORD         ByteCount
    )
{
    PWCHAR pwch;
    DWORD  Size;
    ULONG  ulcsep;
    UINT  LocalFlag;
    NTSTATUS Status;
    PWCHAR pSecretName;
    RPC_STATUS RpcStatus;
    WCHAR encString[ USERNAME_LENGTH + PASSWORD_LENGTH + DOMAIN_LENGTH + 3 ];
    BOOLEAN  SystemCaller = FALSE;

    // Do minimal buffer validation

   if (pNWLogon == NULL) {
       *pResult = STATUS_INVALID_USER_BUFFER;
       return FALSE;
   }

   if( pServerName == NULL ) {
       DBGPRINT(("NWLogonQueryAdmin: No ServerName\n"));
       *pResult = (ULONG)STATUS_INVALID_PARAMETER;
       return( FALSE );
   }

    *pResult = IsZeroterminateStringW(pServerName, ServerNameSize  );

   if (*pResult != STATUS_SUCCESS) {
      return FALSE;
   }


   pNWLogon->Username[USERNAME_LENGTH] = (WCHAR) 0;
   pNWLogon->Password[PASSWORD_LENGTH] = (WCHAR) 0;
   pNWLogon->Domain[DOMAIN_LENGTH] = (WCHAR) 0;

   //



    //
    // Only a SYSTEM mode caller (IE: Winlogon) is allowed
    // to query this value.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT(("RpcServerNWLogonQueryAdmin: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = (ULONG)STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT(("NWLogonQueryAdmin Could not query local client RpcStatus 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        *pResult = (ULONG)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    if( !LocalFlag ) {
        DBGPRINT(("NWLogonQueryAdmin Not a local client call\n"));
        RpcRevertToSelf();
        *pResult = (ULONG)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

/* find out who is calling us system has complete access, admin can't get password, user is kicked out */
    if( IsCallerSystem() ) {
        SystemCaller = TRUE;
    }
    if( !TestUserForAdmin() && (SystemCaller != TRUE) ) {
        RpcRevertToSelf();
        DBGPRINT(("RpcServerNWLogonQueryAdmin: Caller Not SYSTEM or Admin\n"));
        *pResult = (ULONG)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    RpcRevertToSelf();


    if( ByteCount < sizeof(NWLOGONADMIN) ) {
        DBGPRINT(("NWLogonQueryAdmin: Bad size %d\n",ByteCount));
        *pResult = (ULONG)STATUS_INFO_LENGTH_MISMATCH;
        return( FALSE );
    }

    //
    // Build the secret name from the server name.
    //
    // This is because each domain will have a different entry.
    //

    // Skip over any \\ backslashes (if a machine name was passed in)
    while (*pServerName == L'\\') {
        pServerName++;
    }
    Size = wcslen(pServerName) + 1;
    Size *= sizeof(WCHAR);
    Size += sizeof(CITRIX_NW_SECRET_NAME);

    pSecretName = MemAlloc( Size );
    if( pSecretName == NULL ) {
        DBGPRINT(("NWLogonSetAdmin: No memory\n"));
        *pResult = (ULONG)STATUS_NO_MEMORY;
        return( FALSE );
    }

    wcscpy(pSecretName, CITRIX_NW_SECRET_NAME );
    wcscat(pSecretName, pServerName );

    Status = QuerySecretInLsa(
                 pSecretName,
                 encString,
                 sizeof(encString)
                 );

    MemFree( pSecretName );

    if( !NT_SUCCESS(Status) ) {
        *pResult = Status;
        DBGPRINT(("NWLogonQueryAdmin: Error 0x%x querying secret object\n",Status));
        return( FALSE );
    }

    //  check for username/password if there is one then decrypt it
    if ( wcslen( encString ) ) {

        // Change the '/' seperator to null
        pwch = &encString[0];
        ulcsep = 0;
        while (pwch && *pwch) {
            pwch = wcschr(pwch, L'/');
            if (pwch) {
                *pwch = L'\0';
                pwch++;
                ulcsep++;
            }
        }

        //  get clear text username
        wcscpy( pNWLogon->Username, &encString[0] );

        if (ulcsep >= 1) {
            // Skip to the password
            pwch = &encString[0] + wcslen(&encString[0]) + 1;

            if( SystemCaller == TRUE ){ 
                //  get clear text password
                wcscpy( pNWLogon->Password, pwch);
            } else {
                *pNWLogon->Password = L'\0';
            }

        } else {
            *pNWLogon->Password = L'\0';
        }
        if (ulcsep >= 2) {
            // Skip to the domain string
            pwch = pwch + wcslen(pwch) + 1;

            //  get clear text domain
            wcscpy( pNWLogon->Domain, pwch);
        } else {
            *pNWLogon->Domain = L'\0';
        }

        TRACE0(("NwLogonQueryAdmin :%ws:%ws:%ws:\n",pNWLogon->Username,pNWLogon->Domain,pNWLogon->Password));

        *pResult = STATUS_SUCCESS;
        return( TRUE );
    }
    else {
        DBGPRINT(("RpcServerNWLogonQueryAdmin: zero length data\n"));

        //  set to username and password to NULL strings
        pNWLogon->Password[0] = L'\0';
        pNWLogon->Username[0] = L'\0';
        pNWLogon->Domain[0]   = L'\0';

        *pResult = STATUS_SUCCESS;
        return( TRUE );
    }
}

/*******************************************************************************
 *
 *  CreateSecretInLsa
 *
 *     Create the secret object in the LSA to keep it from prying eyes.
 *
 *     NOTE: There is no need to encode the data since it is RSA encrypted
 *           by the LSA secret routines.
 *
 * ENTRY:
 *    pSecretName (input)
 *       Secret name to create.
 *
 *    pSecretData (input)
 *       Data to store in secret
 *
 * EXIT:
 *    NTSTATUS
 *
 ******************************************************************************/

NTSTATUS
CreateSecretInLsa(
    PWCHAR pSecretName,
    PWCHAR pSecretData
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretName;
    UNICODE_STRING SecretValue;
    LSA_HANDLE SecretHandle;
    ACCESS_MASK DesiredAccess;

    if( pSecretName == NULL ) {
        DBGPRINT(("CreateSecretInLsa: NULL SecretName\n"));
        return( STATUS_INVALID_PARAMETER );
    }

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
    );

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    Status = LsaOpenPolicy(
                 NULL,    // SystemName (Local)
                 &ObjectAttributes,
                 GENERIC_ALL,
                 &PolicyHandle
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("Error 0x%x Opening Policy\n",Status));
        return( Status );
    }

    RtlInitUnicodeString( &SecretName, pSecretName );

    DesiredAccess = GENERIC_ALL;

    TRACE0(("Creating Secret name :%ws:\n",pSecretName));

    Status = LsaCreateSecret(
                 PolicyHandle,
                 &SecretName,
                 DesiredAccess,
                 &SecretHandle
                 );

    // Its OK if the name already exits, we will set a new value or delete
    if( Status == STATUS_OBJECT_NAME_COLLISION ) {
        TRACE0(("CreateSecretInLsa: Existing Entry, Opening\n"));
        Status = LsaOpenSecret(
                     PolicyHandle,
                     &SecretName,
                     DesiredAccess,
                     &SecretHandle
                     );
    }

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("Error 0x%x Creating Secret\n",Status));

        /* makarp; Close Policy Handle in case of LsaCreateSecrete, LsaopenSecret failures. #182787 */
        LsaClose( PolicyHandle );
        return( Status );
    }

    TRACE0(("CreateSecretInLsa: Status 0x%x\n",Status));

    if ( wcslen(pSecretData) != 0 ){
    RtlInitUnicodeString( &SecretValue, pSecretData );

    Status = LsaSetSecret( SecretHandle, &SecretValue, NULL );

    TRACE0(("CreateSecretInLsa: LsaSetSecret Status 0x%x\n",Status));

    LsaClose(SecretHandle);
    }
    else{
        Status = LsaDelete(SecretHandle);
    }

    LsaClose( PolicyHandle );

    return( Status );
}

/*******************************************************************************
 *
 *  QuerySecretInLsa
 *
 *     Query the secret object in the LSA.
 *
 * ENTRY:
 *    pSecretName (input)
 *       Secret name to create.
 *
 *    pSecretData (output)
 *       Buffer to store secret data.
 *
 *    ByteCount (input)
 *       Maximum size of buffer to store result.
 *
 * EXIT:
 *    NTSTATUS
 *
 ******************************************************************************/

NTSTATUS
QuerySecretInLsa(
    PWCHAR pSecretName,
    PWCHAR pSecretData,
    DWORD  ByteCount
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretName;
    LSA_HANDLE SecretHandle;
    ACCESS_MASK DesiredAccess;
    LARGE_INTEGER CurrentTime;
    PUNICODE_STRING pCurrentValue = NULL;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
    );

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    Status = LsaOpenPolicy(
                 NULL,    // SystemName (Local)
                 &ObjectAttributes,
                 GENERIC_ALL,
                 &PolicyHandle
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("Error 0x%x Opening Policy\n",Status));
        return( Status );
    }

    RtlInitUnicodeString( &SecretName, pSecretName );

    DesiredAccess = GENERIC_ALL;

    Status = LsaOpenSecret(
                 PolicyHandle,
                 &SecretName,
                 DesiredAccess,
                 &SecretHandle
                 );

    if( !NT_SUCCESS(Status) ) {
        DBGPRINT(("Error 0x%x Opening Secret :%ws:\n",Status,pSecretName));

        /* makarp; Close Policy Handle in case of LsaopenSecret failures. #182787 */
        LsaClose( PolicyHandle );

        return( Status );
    }

    Status = LsaQuerySecret(
                 SecretHandle,
                 &pCurrentValue,
                 &CurrentTime,
                 NULL,
                 NULL
                 );

    TRACE0(("QuerySecretInLsa: Status 0x%x\n",Status));

    if( NT_SUCCESS(Status) ) {
        if (pCurrentValue != NULL) {
            if( (pCurrentValue->Length+sizeof(WCHAR)) > ByteCount ) {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            else {
                RtlMoveMemory( pSecretData, pCurrentValue->Buffer, pCurrentValue->Length );
                pSecretData[pCurrentValue->Length/sizeof(WCHAR)] = 0;
            }
            LsaFreeMemory( pCurrentValue );
        } else {
            pSecretData[0] = (WCHAR) 0;
        }

    }

    LsaClose(SecretHandle);

    LsaClose( PolicyHandle );

    TRACE0(("QuerySecretInLsa: Final Status 0x%x\n",Status));

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\sessdir.cpp ===
/****************************************************************************/
// sessdir.cpp
//
// TS Session Directory code used by TermSrv.exe.
//
// Copyright (C) 2000 Microsot Corporation
/****************************************************************************/

// precomp.h includes COM base headers.
#define INITGUID
#include "precomp.h"
#pragma hdrstop

#include "icaevent.h"

#include "sessdir.h"
#include <tssd.h>

#pragma warning (push, 4)

#define CLSIDLENGTH 39
#define STORESERVERNAMELENGTH 64
#define CLUSTERNAMELENGTH 64
#define OPAQUESETTINGSLENGTH 256

#define TOTAL_STRINGS_LENGTH 640
#define USERNAME_OFFSET 0
#define DOMAIN_OFFSET 256
#define APPLICATIONTYPE_OFFSET 384

#define SINGLE_SESSION_FLAG 0x1

// Extern defined in icasrv.c.
extern "C" WCHAR gpszServiceName[];

// Extern defined in winsta.c
extern "C" LIST_ENTRY WinStationListHead;    // protected by WinStationListLock

extern "C" void PostErrorValueEvent(unsigned EventCode, DWORD ErrVal);

WCHAR g_LocalServerAddress[64];

BOOL g_SessDirUseServerAddr = TRUE;

// Do not access directly.  Use *TSSD functions.
//
// These variables are used to manage synchronization with retrieving the 
// pointer to the COM object.  See *TSSD, below, for details on how they are
// used.
ITSSessionDirectory *g_pTSSDPriv = NULL;
CRITICAL_SECTION g_CritSecComObj;
CRITICAL_SECTION g_CritSecInitialize;
int g_nComObjRefCount = 0;
BOOL g_bCritSecsInitialized = FALSE;

// Do not access directly.  Use *TSSDEx functions.
//
// These variables are used to manage synchronization with retrieving the 
// pointer to the COM object.  See *TSSDEx, below, for details on how they are
// used.
ITSSessionDirectoryEx *g_pTSSDExPriv = NULL;
int g_nTSSDExObjRefCount = 0;


/****************************************************************************/
// SessDirGetLocalIPAddr
//
// Gets the local IP address of this machine.  On success, returns 0.  On
// failure, returns a failure code from the function that failed.
/****************************************************************************/
DWORD SessDirGetLocalIPAddr(WCHAR *LocalIP)
{
    DWORD NameSize;
    unsigned char *tempaddr;
    WCHAR psServerName[64];
    char psServerNameA[64];
    
    NameSize = sizeof(psServerName) / sizeof(WCHAR);
    if (GetComputerNameEx(ComputerNamePhysicalDnsHostname,
            psServerName, &NameSize)) {
        // Temporary code to get an IP address.  This should be replaced in the
        // fix to bug #323867.
        struct hostent *hptr;

        // change the wide character string to non-wide
        sprintf(psServerNameA, "%S", psServerName);

        if ((hptr = gethostbyname(psServerNameA)) == 0) {
            DWORD Err = WSAGetLastError();

            return Err;
        }

        tempaddr = (unsigned char *)*(hptr->h_addr_list);
        wsprintf(LocalIP, L"%d.%d.%d.%d", tempaddr[0], tempaddr[1],
        tempaddr[2], tempaddr[3]);

    }
    else {
        DWORD Err = GetLastError();

        return Err;
    }

    return 0;
}


/****************************************************************************/
// InitSessionDirectoryEx
//
// Reads values from the registry, and either initializes the session 
// directory or updates it, depending on the value of the Update parameter.
/****************************************************************************/
DWORD InitSessionDirectoryEx(bool Update)
{
    DWORD Len;
    DWORD Type;
    DWORD DataSize;
    BOOL hKeyTermSrvSucceeded = FALSE;
    HRESULT hr;
    DWORD NameSize;
    DWORD ErrVal;
    CLSID TSSDCLSID;
    CLSID TSSDEXCLSID;
    LONG RegRetVal;
    HKEY hKey = NULL;
    HKEY hKeyTermSrv = NULL;
    ITSSessionDirectory *pTSSD = NULL;
    ITSSessionDirectoryEx *pTSSDEx = NULL;
    BOOL bClusteringActive = FALSE;
    BOOL bThisServerIsInSingleSessionMode;
    WCHAR CLSIDStr[CLSIDLENGTH];
    WCHAR CLSIDEXStr[CLSIDLENGTH];
    WCHAR StoreServerName[STORESERVERNAMELENGTH];
    WCHAR ClusterName[CLUSTERNAMELENGTH];
    WCHAR OpaqueSettings[OPAQUESETTINGSLENGTH];

    if (g_bCritSecsInitialized == FALSE) {
        ASSERT(FALSE);
        PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_INIT_TSSD, 
                (DWORD) E_OUTOFMEMORY);
        return (DWORD) E_OUTOFMEMORY;
    }

// trevorfo: Load only if any 1 loaded protocol needs it? Requires running
// off of StartAllWinStations.

    // No more than one thread should be doing initialization.
    EnterCriticalSection(&g_CritSecInitialize);

    // Load registry keys.
    RegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0, 
            KEY_READ, &hKeyTermSrv);
    if (RegRetVal != ERROR_SUCCESS) {
        PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_INIT_TSSD,
                RegRetVal);
        goto RegFailExit;
    }
    else {
        hKeyTermSrvSucceeded = TRUE;
    }
    
    RegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_TS_CLUSTERSETTINGS, 0,
            KEY_READ, &hKey);
    if (RegRetVal != ERROR_SUCCESS) {
        DBGPRINT(("TERMSRV: RegOpenKeyEx for ClusterSettings err %u\n",
                RegRetVal));
        goto RegFailExit;
    }

    //
    // First, we get the serious settings--active, SD location, and cluster 
    // name.
    //
    // If group policy exists for all three, use that.  Otherwise, use what
    // is in the registry.
    //

    StoreServerName[0] = L'\0';
    ClusterName[0] = L'\0';
    OpaqueSettings[0] = L'\0';

    if (g_MachinePolicy.fPolicySessionDirectoryActive && 
            g_MachinePolicy.fPolicySessionDirectoryLocation &&
            g_MachinePolicy.fPolicySessionDirectoryClusterName) {

        // Copy over parameters

        bClusteringActive = g_MachinePolicy.SessionDirectoryActive;

        wcsncpy(StoreServerName, g_MachinePolicy.SessionDirectoryLocation, 
                STORESERVERNAMELENGTH);
        StoreServerName[STORESERVERNAMELENGTH - 1] = '\0';

        wcsncpy(ClusterName, g_MachinePolicy.SessionDirectoryClusterName, 
                CLUSTERNAMELENGTH);
        ClusterName[CLUSTERNAMELENGTH - 1] = '\0';

        if (g_MachinePolicy.fPolicySessionDirectoryAdditionalParams) {
            wcsncpy(OpaqueSettings, 
                    g_MachinePolicy.SessionDirectoryAdditionalParams, 
                    OPAQUESETTINGSLENGTH);
            OpaqueSettings[OPAQUESETTINGSLENGTH - 1] = '\0';
        }

    }
    else {

        Len = sizeof(bClusteringActive);
        RegQueryValueEx(hKeyTermSrv, REG_TS_SESSDIRACTIVE, NULL, &Type,
                (BYTE *)&bClusteringActive, &Len);

        // Not an error for the name to be absent or empty.
        DataSize = sizeof(StoreServerName);
        RegRetVal = RegQueryValueExW(hKey, REG_TS_CLUSTER_STORESERVERNAME,
                NULL, &Type, (BYTE *)StoreServerName, &DataSize);
        if (RegRetVal != ERROR_SUCCESS) {
            DBGPRINT(("TERMSRV: Failed RegQuery for StoreSvrName - "
                    "err=%u, DataSize=%u, type=%u\n",
                    RegRetVal, DataSize, Type));
        }

        // Not an error for the name to be absent or empty.
        DataSize = sizeof(ClusterName);
        RegRetVal = RegQueryValueExW(hKey, REG_TS_CLUSTER_CLUSTERNAME,
                NULL, &Type, (BYTE *)ClusterName, &DataSize);
        if (RegRetVal != ERROR_SUCCESS) {
            DBGPRINT(("TERMSRV: Failed RegQuery for ClusterName - "
                    "err=%u, DataSize=%u, type=%u\n",
                    RegRetVal, DataSize, Type));
        }

        // Not an error for the string to be absent or empty.
        DataSize = sizeof(OpaqueSettings);
        RegRetVal = RegQueryValueExW(hKey, REG_TS_CLUSTER_OPAQUESETTINGS,
                NULL, &Type, (BYTE *)OpaqueSettings, &DataSize);
        if (RegRetVal != ERROR_SUCCESS) {
            DBGPRINT(("TERMSRV: Failed RegQuery for OpaqueSettings - "
                    "err=%u, DataSize=%u, type=%u\n",
                    RegRetVal, DataSize, Type));
        }
    }

    //
    // Now for the less crucial settings.
    //
    // Get the setting that determines whether the server's local address is 
    // visible to the client.  Group Policy takes precedence over registry.
    //

    if (g_MachinePolicy.fPolicySessionDirectoryExposeServerIP) {
        g_SessDirUseServerAddr = g_MachinePolicy.SessionDirectoryExposeServerIP;
    }
    else {
        Len = sizeof(g_SessDirUseServerAddr);
        RegRetVal = RegQueryValueEx(hKeyTermSrv, REG_TS_SESSDIR_EXPOSE_SERVER_ADDR, 
                NULL, &Type, (BYTE *)&g_SessDirUseServerAddr, &Len);

        if (RegRetVal == ERROR_SUCCESS) {
            //DBGPRINT(("TERMSRV: RegOpenKeyEx for allow server addr to client %d"
            //      "\n", g_SessDirUseServerAddr));
        }
        else {
            DBGPRINT(("TERMSRV: RegQueryValueEx for allow server addr to client"
                    " %d, err %u\n", g_SessDirUseServerAddr, RegRetVal));
        }
    }

    // Get the single session per user setting from GP if it's active, otherwise
    // from the registry.
    if (g_MachinePolicy.fPolicySingleSessionPerUser) {
        bThisServerIsInSingleSessionMode = 
                g_MachinePolicy.fSingleSessionPerUser;
    }
    else {
        Len = sizeof(bThisServerIsInSingleSessionMode);
        RegRetVal = RegQueryValueEx(hKeyTermSrv, 
                POLICY_TS_SINGLE_SESSION_PER_USER, NULL, &Type, 
                (BYTE *)&bThisServerIsInSingleSessionMode, &Len);

        if (RegRetVal != ERROR_SUCCESS) {
            DBGPRINT(("TERMSRV: RegQueryValueEx for single session mode"
                    ", Error %u\n", RegRetVal));
        }
    }
    
    // Get the CLSID of the session directory object to instantiate.
    CLSIDStr[0] = L'\0';
    Len = sizeof(CLSIDStr);
    RegQueryValueEx(hKeyTermSrv, REG_TS_SESSDIRCLSID, NULL, &Type,
            (BYTE *)CLSIDStr, &Len);

    // Get the CLSID of the session directory object to instantiate.
    CLSIDEXStr[0] = L'\0';
    Len = sizeof(CLSIDEXStr);
    RegQueryValueEx(hKeyTermSrv, REG_TS_SESSDIR_EX_CLSID, NULL, &Type,
            (BYTE *)CLSIDEXStr, &Len);

    RegCloseKey(hKey);
    RegCloseKey(hKeyTermSrv);

    //
    // Configuration loading complete.
    //
    // See what to do about activation/deactivation.
    //

    pTSSD = GetTSSD();
    
    if (pTSSD == NULL) {
        // This is the normal initialization path.  If Update is true here, it 
        // should be treated as a normal initialize because the COM object was 
        // unloaded.
        Update = false;
    }
    else {
        // Clustering is already active.  See whether we should deactivate it.
        if (bClusteringActive == FALSE) {
            ReleaseTSSD();  // Once here, once again at the end of the function.
            ReleaseTSSDEx();
        }
    }
    if (bClusteringActive) {
        // We need to get the local machine's address to pass in to
        // the directory.
        NameSize = 64;
        if ((ErrVal = SessDirGetLocalIPAddr(g_LocalServerAddress)) == 0) {

            if (wcslen(CLSIDStr) > 0 &&
                    SUCCEEDED(CLSIDFromString(CLSIDStr, &TSSDCLSID))) {

                // If it's not an update, create the TSSD object.
                if (Update == false) {
                    hr = CoCreateInstance(TSSDCLSID, NULL, 
                            CLSCTX_INPROC_SERVER, IID_ITSSessionDirectory, 
                            (void **)&pTSSD);
                    if (SUCCEEDED(hr)) {
                        if (SetTSSD(pTSSD) != 0) {
                            DBGPRINT(("TERMSRV: InitSessDirEx: Could not set "
                                    "TSSD", E_FAIL));
                            pTSSD->Release();
                            pTSSD = NULL;
                            hr = E_FAIL;
                        }
                        else {
                            // Add 1 to the ref count because we're gonna use 
                            // it.
                            pTSSD = GetTSSD();
                        }
                    }
                }
                else {
                    hr = S_OK;
                }
                
                if (SUCCEEDED (hr)) {
                    // Right now the only flag we pass in to session directory
                    // says whether we are in single-session mode.
                    DWORD Flags = 0;

                    Flags |= (bThisServerIsInSingleSessionMode ? 
                            SINGLE_SESSION_FLAG : 0x0);

                    if (Update == false) 
                        hr = pTSSD->Initialize(g_LocalServerAddress,
                                StoreServerName, ClusterName, OpaqueSettings,
                                Flags, RepopulateSessionDirectory);
                    else
                        hr = pTSSD->Update(g_LocalServerAddress,
                                StoreServerName, ClusterName, OpaqueSettings,
                                Flags);
                    if (FAILED(hr)) {
                        DBGPRINT(("TERMSRV: InitSessDirEx: Failed %s TSSD, "
                                "hr=0x%X\n", Update ? "update" : "init", hr));
                        ReleaseTSSD();
                        PostErrorValueEvent(
                                EVENT_TS_SESSDIR_FAIL_INIT_TSSD, hr);
                    }

                }
                else {
                    DBGPRINT(("TERMSRV: InitSessDirEx: Failed create TSSD, "
                            "hr=0x%X\n", hr));
                    PostErrorValueEvent(
                            EVENT_TS_SESSDIR_FAIL_CREATE_TSSD, hr);
                }
            }
            else {
                DBGPRINT(("TERMSRV: InitSessDirEx: Failed get or parse "
                        "CLSID\n"));
                PostErrorValueEvent(
                        EVENT_TS_SESSDIR_FAIL_GET_TSSD_CLSID, 0);

                hr = E_INVALIDARG;
            }
        }
        else {
            DBGPRINT(("TERMSRV: InitSessDirEx: Failed to get local DNS name, "
                    "lasterr=0x%X\n", ErrVal));
            PostErrorValueEvent(EVENT_TS_SESSDIR_NO_COMPUTER_DNS_NAME,
                    ErrVal);

            hr = E_FAIL;
        }

        // Initialize the other COM object, but only if the above succeeded.
        if (SUCCEEDED(hr)) {
            if (wcslen(CLSIDEXStr) > 0 &&
                    SUCCEEDED(CLSIDFromString(CLSIDEXStr, &TSSDEXCLSID))) {
                // If it's not an update, create the TSSDEX object.
                if (Update == false) {
                    hr = CoCreateInstance(TSSDEXCLSID, NULL, 
                            CLSCTX_INPROC_SERVER, IID_ITSSessionDirectoryEx, 
                            (void **)&pTSSDEx);
                    if (SUCCEEDED(hr)) {
                        if (SetTSSDEx(pTSSDEx) != 0) {
                            DBGPRINT(("TERMSRV: InitSessDirEx: Could not set "
                                    "TSSDEx\n", E_FAIL));
                            pTSSDEx->Release();
                            pTSSDEx = NULL;
                            hr = E_FAIL;
                        }
                    }
                }
                else
                    hr = S_OK;
                
                if (FAILED(hr)) {
                    DBGPRINT(("TERMSRV: InitSessDirEx: Failed create TSSDEx, "
                            "hr=0x%X\n", hr));
                    PostErrorValueEvent(
                            EVENT_TS_SESSDIR_FAIL_CREATE_TSSDEX, hr);
                }
            }
            else {
                DBGPRINT(("TERMSRV: InitSessDirEx: Failed get or parse "
                        "CLSIDSDEx\n"));
                PostErrorValueEvent(
                        EVENT_TS_SESSDIR_FAIL_GET_TSSDEX_CLSID, 0);
            }
        }
    }
    else {
        DBGPRINT(("TERMSRV: InitSessDirEx: SessDir not activated\n"));
    }

    if (pTSSD != NULL)
        ReleaseTSSD();

    // Initialization complete--someone else is allowed to enter now.
    LeaveCriticalSection(&g_CritSecInitialize);
    
    return S_OK;

RegFailExit:
    // Initialization complete--someone else is allowed to enter now.
    LeaveCriticalSection(&g_CritSecInitialize);

    if (hKeyTermSrvSucceeded)
        RegCloseKey(hKeyTermSrv);

    return (DWORD) E_FAIL;
}

/****************************************************************************/
// InitSessionDirectory
//
// Initializes the directory by loading and initializing the session directory
// object, if load balancing is enabled. We assume COM has been initialized
// on the service main thread as COINIT_MULTITHREADED.
//
// This function should only be called once ever.  It is the location of the
// initialization of the critical sections used by this module.
/****************************************************************************/
void InitSessionDirectory()
{
    BOOL br1 = FALSE;
    BOOL br2 = FALSE;

    ASSERT(g_bCritSecsInitialized == FALSE);

    // Initialize critical sections.
    __try {

        // Initialize the provider critical section to preallocate the event
        // and spin 4096 times on each try (since we don't spend very
        // long in our critical section).
        br1 = InitializeCriticalSectionAndSpinCount(&g_CritSecComObj, 
                0x80001000);
        br2 = InitializeCriticalSectionAndSpinCount(&g_CritSecInitialize,
                0x80001000);

        // Since this happens at startup time, we should not fail.
        ASSERT(br1 && br2);

        if (br1 && br2) {
            g_bCritSecsInitialized = TRUE;
        }
        else {
            DBGPRINT(("TERMSRV: InitSessDir: critsec init failed\n"));

            if (br1)
                DeleteCriticalSection(&g_CritSecComObj);
            if (br2)
                DeleteCriticalSection(&g_CritSecInitialize);
            
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_INIT_TSSD, 
                    GetLastError());
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        // Since this happens at startup time, we should not fail.
        ASSERT(FALSE);

        DBGPRINT(("TERMSRV: InitSessDir: critsec init failed\n"));

        if (br1)
            DeleteCriticalSection(&g_CritSecComObj);
        if (br2)
            DeleteCriticalSection(&g_CritSecInitialize);

        PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_INIT_TSSD, 
                GetExceptionCode());
    }

    // Now do the common initialization.
    if (g_bCritSecsInitialized)
        InitSessionDirectoryEx(false);
}

/****************************************************************************/
// UpdateSessionDirectory
//
// Updates the session directory with new settings. Assumes COM has been 
// initialized.
/****************************************************************************/
DWORD UpdateSessionDirectory()
{
    return InitSessionDirectoryEx(true);
}


#define REPOP_FAIL 1
#define REPOP_SUCCESS 0
/****************************************************************************/
// RepopulateSessionDirectory
//
// Repopulates the session directory.  Returns REPOP_FAIL (1) on failure,
// REPOP_SUCCESS(0) otherwise.
/****************************************************************************/
DWORD RepopulateSessionDirectory()
{
    DWORD WinStationCount = 0;
    PLIST_ENTRY Head, Next;
    DWORD i = 0;
    HRESULT hr;
    PWINSTATION pWinStation = NULL;
    ITSSessionDirectory *pTSSD;
    WCHAR *wBuffer = NULL;


    // If we got here, it should be because of the session directory.
    pTSSD = GetTSSD();

    if (pTSSD != NULL) {

        // Grab WinStationListLock
        ENTERCRIT( &WinStationListLock );

        Head = &WinStationListHead;

        // Count the WinStations I care about.
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {

            pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

            switch (pWinStation->State) {
            case State_Active:
            case State_Disconnected:
            case State_Shadow:
                WinStationCount += 1;
                break;
            }
        }

        // Allocate the memory for the structure to pass to the session 
        // directory.
        TSSD_RepopulateSessionInfo *rsi = new TSSD_RepopulateSessionInfo[
                WinStationCount];

        if (rsi == NULL) {
            DBGPRINT(("TERMSRV: RepopulateSessDir: mem alloc failed\n"));

            // Release WinStationListLock
            LEAVECRIT( &WinStationListLock );

            goto CleanUp;
        }

        // Allocate string arrays (for now)
        wBuffer = new WCHAR[WinStationCount * TOTAL_STRINGS_LENGTH];
        if (wBuffer == NULL) {
            DBGPRINT(("TERMSRV: RepopulateSessDir: mem alloc failed\n"));

            // Release WinStationListLock
            LEAVECRIT( &WinStationListLock );

            delete [] rsi;

            goto CleanUp;
        }

        // Set the pointers in the rsi
        for ( i = 0; i < WinStationCount; i += 1) {
            rsi[i].UserName = &(wBuffer[i * TOTAL_STRINGS_LENGTH + 
                    USERNAME_OFFSET]);
            rsi[i].Domain = &(wBuffer[i * TOTAL_STRINGS_LENGTH + 
                    DOMAIN_OFFSET]);
            rsi[i].ApplicationType = &(wBuffer[i * TOTAL_STRINGS_LENGTH + 
                    APPLICATIONTYPE_OFFSET]);
        }

        // Now populate the structure to pass in.

        // Reset index to 0
        i = 0;
        
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {

            pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

            ASSERT(i <= WinStationCount);

            // There are two sets of information here: First, if the session
            // is Active, we can do stuff, then we have an intentional 
            // fallthrough to the common code used by Disconnected and Active
            // sessions for the common stuff.  For now, if it's disconnected
            // we then call the update function in our COM object.
            switch (pWinStation->State) {
            case State_Active:
            case State_Shadow:
                rsi[i].State = 0;
                // NOTE INTENTIONAL FALLTHROUGH
            case State_Disconnected:
                rsi[i].TSProtocol = pWinStation->Client.ProtocolType;
                rsi[i].ResolutionWidth = pWinStation->Client.HRes;
                rsi[i].ResolutionHeight = pWinStation->Client.VRes;
                rsi[i].ColorDepth = pWinStation->Client.ColorDepth;

                // TODO: I don't get it--USERNAME_LENGTH is 20, yet in the csi,
                // TODO: it's 256.  Likewise, DOMAIN_LENGTH is 17.
                wcsncpy(rsi[i].UserName, pWinStation->UserName, 
                        USERNAME_LENGTH);
                rsi[i].UserName[USERNAME_LENGTH] = '\0';
                wcsncpy(rsi[i].Domain, pWinStation->Domain, DOMAIN_LENGTH);
                rsi[i].Domain[DOMAIN_LENGTH] = '\0';

                // TODO: Here there is a problem in that the INITIALPROGRAM
                // TODO: length is 256 + 1, but the buffer we copy into is
                // TODO: 256, hence we lose a character.
                wcsncpy(rsi[i].ApplicationType, pWinStation->
                        Client.InitialProgram, INITIALPROGRAM_LENGTH - 1);
                rsi[i].ApplicationType[INITIALPROGRAM_LENGTH - 2] = '\0';
                rsi[i].SessionID = pWinStation->LogonId;
                rsi[i].CreateTimeLow = pWinStation->LogonTime.LowPart;
                rsi[i].CreateTimeHigh = pWinStation->LogonTime.HighPart;
                if (pWinStation->State == State_Disconnected) {
                    rsi[i].DisconnectionTimeLow = pWinStation->DisconnectTime.
                            LowPart;
                    rsi[i].DisconnectionTimeHigh = pWinStation->DisconnectTime.
                            HighPart;
                    rsi[i].State = 1;
                }
                i += 1;
                break;
            }
        }

        // Release WinStationListLock
        LEAVECRIT( &WinStationListLock );

        // Call the session directory provider with our big struct.
        hr = pTSSD->Repopulate(WinStationCount, rsi);
        delete [] rsi;
        delete [] wBuffer;

        if (hr == S_OK) {
            ReleaseTSSD();
            return REPOP_SUCCESS;
        }
        else {
            goto CleanUp;
        }

CleanUp:
        ReleaseTSSD();
    }

    return REPOP_FAIL;
}


/****************************************************************************/
// DestroySessionDirectory
//
// Destroys the directory, releasing any COM objects held and other memory
// used. Assumes COM has been initialized.
/****************************************************************************/
void DestroySessionDirectory()
{
    ITSSessionDirectory *pTSSD = NULL;
    ITSSessionDirectoryEx *pTSSDEx = NULL;

    pTSSD = GetTSSD();
    pTSSDEx = GetTSSDEx();

    if (pTSSD != NULL) {
        ReleaseTSSD();
        ReleaseTSSD();
    }

    if (pTSSDEx != NULL) {     
        ReleaseTSSDEx();
        ReleaseTSSDEx();
    }
}

/****************************************************************************/
// SessDirNotifyLogon
//
// Called to inform the session directory of session creation.
/****************************************************************************/
void SessDirNotifyLogon(TSSD_CreateSessionInfo *pCreateInfo)
{
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();

    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {
        hr = pTSSD->NotifyCreateLocalSession(pCreateInfo);
        if (FAILED(hr)) {
            DBGPRINT(("TERMSRV: SessDirNotifyLogon: Call failed, "
                    "hr=0x%X\n", hr));
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_UPDATE, hr);
        }

        ReleaseTSSD();
    }

}


/****************************************************************************/
// SessDirNotifyDisconnection
//
// Called on session disconnection to inform the session directory.
/****************************************************************************/
void SessDirNotifyDisconnection(DWORD SessionID, FILETIME DiscTime)
{
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();
    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {
        hr = pTSSD->NotifyDisconnectLocalSession(SessionID, DiscTime);
        if (FAILED(hr)) {
            DBGPRINT(("TERMSRV: SessDirNotifyDisc: Call failed, "
                    "hr=0x%X\n", hr));
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_UPDATE, hr);
        }

        ReleaseTSSD();
    }
}


/****************************************************************************/
// SessDirNotifyReconnection
//
// Called on session reconnection to inform the session directory.
/****************************************************************************/
void SessDirNotifyReconnection(TSSD_ReconnectSessionInfo *pReconnInfo)
{
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();

    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {
        hr = pTSSD->NotifyReconnectLocalSession(pReconnInfo);
        if (FAILED(hr)) {
            DBGPRINT(("TERMSRV: SessDirNotifyReconn: Call failed, "
                    "hr=0x%X\n", hr));
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_UPDATE, hr);
        }

        ReleaseTSSD();
    }
}


/****************************************************************************/
// SessDirNotifyLogoff
//
// Called on logoff to inform the session directory.
/****************************************************************************/
void SessDirNotifyLogoff(DWORD SessionID)
{
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();

    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {
        hr = pTSSD->NotifyDestroyLocalSession(SessionID);
        if (FAILED(hr)) {
            DBGPRINT(("TERMSRV: SessDirNotifyLogoff: Call failed, "
                    "hr=0x%X\n", hr));
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_UPDATE, hr);
        }

        ReleaseTSSD();
    }
}


/****************************************************************************/
// SessDirNotifyReconnectPending
//
// Called to inform the session directory a session should start soon on
// another machine in the cluster (for Directory Integrity Service).
/****************************************************************************/
void SessDirNotifyReconnectPending(WCHAR *ServerName)
{
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();

    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {
        hr = pTSSD->NotifyReconnectPending(ServerName);
        if (FAILED(hr)) {
            DBGPRINT(("TERMSRV: SessDirNotifyReconnectPending: Call failed, "
                    "hr=0x%X\n", hr));
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_UPDATE, hr);
        }

        ReleaseTSSD();
    }
}


/****************************************************************************/
// SessDirGetDisconnectedSessions
//
// Returns in the provided TSSD_DisconnectedSessionInfo buffer space
// up to TSSD_MaxDisconnectedSessions' worth of disconnected sessions
// from the session directory. Returns the number of sessions returned, which
// can be zero.
/****************************************************************************/
unsigned SessDirGetDisconnectedSessions(
        WCHAR *UserName,
        WCHAR *Domain,
        TSSD_DisconnectedSessionInfo Info[TSSD_MaxDisconnectedSessions])
{
    DWORD NumSessions = 0;
    HRESULT hr;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();

    // We can get called even when the directory is inactive.
    if (pTSSD != NULL) {
        hr = pTSSD->GetUserDisconnectedSessions(UserName, Domain,
                &NumSessions, Info);
        if (FAILED(hr)) {
            DBGPRINT(("TERMSRV: SessDirGetDiscSessns: Call failed, "
                    "hr=0x%X\n", hr));
            PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_QUERY, hr);
        }
        ReleaseTSSD();
    }

    return NumSessions;
}

/****************************************************************************/
// SessDirGetLBInfo
//
// Call the SessDirEx COM object interface, using the server address, get
// the opaque load balance info back, will send the info to the client.
/****************************************************************************/
BOOL SessDirGetLBInfo(
        WCHAR *ServerAddress, 
        DWORD* pLBInfoSize,
        PBYTE* pLBInfo)        
{
    ITSSessionDirectoryEx *pTSSDEx;
    HRESULT hr;
    static BOOL EventLogged = FALSE;

    *pLBInfoSize = 0;
    *pLBInfo = NULL;

    pTSSDEx = GetTSSDEx();

    if (pTSSDEx != NULL) {
        hr = pTSSDEx->GetLoadBalanceInfo(ServerAddress, (BSTR *)pLBInfo);

        if(SUCCEEDED(hr))
        {
             *pLBInfoSize = SysStringByteLen((BSTR)(*pLBInfo));
        }
        else 
        {
            DBGPRINT(("TERMSRV: SessDirGetLBInfo: Call failed, "
                    "hr=0x%X\n", hr));
            if (EventLogged == FALSE) {
                PostErrorValueEvent(EVENT_TS_SESSDIR_FAIL_LBQUERY, hr);
                EventLogged = TRUE;
            }
        }

        ReleaseTSSDEx();
    }
    else {
        DBGPRINT(("TERMSRV: SessDirGetLBInfo: Call failed, pTSSDEx is NULL "));
        hr = E_FAIL;
    }

    return SUCCEEDED(hr);
}


#define SERVER_ADDRESS_LENGTH 64
/****************************************************************************/
// IsSameAsCurrentIP
//
// Determines whether the IP address given is the same as the current machine.
// Returning FALSE in case of error is not a problem--the client will
// just get redirected right back here.
/****************************************************************************/
BOOL IsSameAsCurrentIP(WCHAR *SessionIPAddress)
{
    // Get the server adresses.
    int RetVal;
    unsigned long NumericalSessionIPAddr = 0;
    char  achComputerName[256];
    DWORD dwComputerNameSize;
    PBYTE pServerAddrByte;
    PBYTE pSessionAddrByte;
    ADDRINFO *AddrInfo, *AI;
    struct sockaddr_in *pIPV4addr;
    char AnsiSessionIPAddress[SERVER_ADDRESS_LENGTH];

    // Compute integer for the server address.
    // First, get ServerAddress as an ANSI string.
    RetVal = WideCharToMultiByte(CP_ACP, 0, SessionIPAddress, -1, 
            AnsiSessionIPAddress, SERVER_ADDRESS_LENGTH, NULL, NULL);
    if (RetVal == 0) {
        DBGPRINT(("IsSameServerIP: WideCharToMB failed %d\n", GetLastError()));
        return FALSE;
    }

    // Now, get the numerical server address.
    // Now, use inet_addr to turn into an unsigned long.
    NumericalSessionIPAddr = inet_addr(AnsiSessionIPAddress);
    if (NumericalSessionIPAddr == INADDR_NONE) {
        DBGPRINT(("IsSameServerIP: inet_addr failed\n"));
        return FALSE;
    }

    pSessionAddrByte = (PBYTE) &NumericalSessionIPAddr;

    dwComputerNameSize = sizeof(achComputerName);
    if (!GetComputerNameA(achComputerName,&dwComputerNameSize)) {
        return FALSE;
    }

    RetVal = getaddrinfo(achComputerName, NULL, NULL, &AddrInfo);
    if (RetVal != 0) {
        DBGPRINT (("Cannot resolve address, error: %d\n", RetVal));
        return FALSE;
    } 
    else {
        // Compare all server adresses with client till a match is found.
        // Currently only works for IPv4.
        for (AI = AddrInfo; AI != NULL; AI = AI->ai_next) {

            if (AI->ai_family == AF_INET) {

                if (AI->ai_addrlen >= sizeof(struct sockaddr_in)) {
                    pIPV4addr = (struct sockaddr_in *) AI->ai_addr;
                    pServerAddrByte = (PBYTE)&pIPV4addr->sin_addr;
                    if (RtlEqualMemory(pSessionAddrByte, pServerAddrByte, 4)) {
                        return TRUE;
                    }
                }
                
            }
        }
        
    }

    return FALSE;
}

/****************************************************************************/
// SessDirCheckRedirectClient
//
// Performs the set of steps needed to get the client's clustering
// capabilities, get the disconnected session list, and apply client
// redirection policy. Returns TRUE if the client was redirected, FALSE if
// the current WinStation transfer should be continued.
/****************************************************************************/
BOOL SessDirCheckRedirectClient(
        PWINSTATION pTargetWinStation,
        TS_LOAD_BALANCE_INFO *pLBInfo)
{
    BOOL rc = FALSE;
    ULONG ReturnLength;
    unsigned i, NumSessions;
    NTSTATUS Status;
    ITSSessionDirectory *pTSSD;

    pTSSD = GetTSSD();

    pTargetWinStation->NumClusterDiscSessions = 0;

    if (pTSSD != NULL) {
        if (pLBInfo->bClientSupportsRedirection &&
                !pLBInfo->bRequestedSessionIDFieldValid) {
            // The client has not been redirected to this machine. See if we
            // have disconnected sessions in the database for redirecting.
            NumSessions = pTargetWinStation->NumClusterDiscSessions =
                    SessDirGetDisconnectedSessions(
                    pLBInfo->UserName,
                    pLBInfo->Domain,
                    pTargetWinStation->ClusterDiscSessions);
            if (pTargetWinStation->NumClusterDiscSessions > 0) {
                
// trevorfo: Applying policy here for reconnection to only one session
// (whichever is first).  More general policy requires a selection UI at the 
// client or in WinLogon.

                // Find the first session in the list that matches the
                // client's session requirements. Namely, we filter based
                // on the client's TS protocol, wire protocol, and application
                // type.
                for (i = 0; i < NumSessions; i++) {
                    if ((pLBInfo->ProtocolType ==
                            pTargetWinStation->ClusterDiscSessions[i].
                            TSProtocol) &&
                            (!_wcsicmp(pLBInfo->InitialProgram,
                            pTargetWinStation->ClusterDiscSessions[i].
                            ApplicationType))) {
                        break;
                    }
                }
                if (i == NumSessions) {
                    TRACE((hTrace,TC_ICASRV,TT_API1,
                            "TERMSRV: SessDirCheckRedir: No matching sessions "
                            "found\n"));
                }
                else {
                    // If the session is not on this server, redirect the
                    // client. See notes above about use of
                    // _IcaStackIoControl().
                    
                    if (!IsSameAsCurrentIP(pTargetWinStation->
                            ClusterDiscSessions[i].ServerAddress)) {
                        BYTE *pRedirInfo, *pRedirInfoStart;
                        BYTE *LBInfo = NULL; 
                        DWORD LBInfoSize = 0;
                        DWORD RedirInfoSize = 0;
                        DWORD ServerAddrLen = 0;
                        DWORD DomainSize = 0;
                        DWORD UserNameSize = 0;
                        DWORD PasswordSize = 0;
                        
                        RedirInfoSize = sizeof(TS_CLIENT_REDIRECTION_INFO);

                        // Setup the server addr
                        if (g_SessDirUseServerAddr || 
                                pLBInfo->bClientRequireServerAddr) {
                            ServerAddrLen =  (DWORD)((wcslen(pTargetWinStation->
                                    ClusterDiscSessions[i].ServerAddress) + 1) *
                                    sizeof(WCHAR));
                            RedirInfoSize += (ServerAddrLen + sizeof(ULONG));

                            DBGPRINT(("TERMSRV: SessDirCheckRedir: size=%d, "
                                    "addr=%S\n", ServerAddrLen, 
                                    (WCHAR *)pTargetWinStation->
                                    ClusterDiscSessions[i].ServerAddress));
                        }
                        else {
                            DBGPRINT(("TERMSRV: SessDirCheckRedir no server "
                                    "address: g_SessDirUseServerAddr = %d, "
                                    "bClientRequireServerAddr = %d\n",
                                    g_SessDirUseServerAddr, 
                                    pLBInfo->bClientRequireServerAddr));
                        }

                        // Setup the load balance info
                        if ((pLBInfo->bClientRequireServerAddr == 0) &&
                                SessDirGetLBInfo(
                                pTargetWinStation->ClusterDiscSessions[i].
                                ServerAddress, &LBInfoSize, &LBInfo)) {
                        
                            if (LBInfo) {
                                DBGPRINT(("TERMSRV: SessDirCheckRedir: size=%d, "
                                        "info=%S\n", LBInfoSize, 
                                        (WCHAR *)LBInfo));
    
                                RedirInfoSize += (LBInfoSize + sizeof(ULONG));
                            }
                        }
                        else {
                            DBGPRINT(("TERMSRV: SessDirCheckRedir failed: "
                                    "size=%d, info=%S\n", LBInfoSize, 
                                    (WCHAR *)LBInfo));
                        
                        }

                        // Only send domain, username and password info if client
                        // redirection version is 3 and above
                        if (pLBInfo->ClientRedirectionVersion >= TS_CLUSTER_REDIRECTION_VERSION3) {
                            //domain
                            if (pLBInfo->Domain) {
                                DomainSize = (DWORD)(wcslen(pLBInfo->Domain) + 1) * sizeof(WCHAR);
                                RedirInfoSize += DomainSize + sizeof(ULONG);
                            }
                            //username
                            if (pLBInfo->UserName) {
                                UserNameSize = (DWORD)(wcslen(pLBInfo->UserName) + 1) * sizeof(WCHAR);
                                RedirInfoSize += UserNameSize + sizeof(ULONG);
                            }
                            //password
                            if (pLBInfo->Password) {
                                PasswordSize = (DWORD)(wcslen(pLBInfo->Password) + 1) * sizeof(WCHAR);
                                RedirInfoSize += PasswordSize + sizeof(ULONG);
                            }
                        }

                        // Setup the load balance IOCTL
                        pRedirInfoStart = pRedirInfo = new BYTE[RedirInfoSize];

                        TS_CLIENT_REDIRECTION_INFO *pClientRedirInfo =
                                (TS_CLIENT_REDIRECTION_INFO *)pRedirInfo;

                        if (pRedirInfo != NULL) {
                            
                            pClientRedirInfo->SessionID = 
                                    pTargetWinStation->ClusterDiscSessions[i].
                                    SessionID;

                            pClientRedirInfo->Flags = 0;

                            pRedirInfo += sizeof(TS_CLIENT_REDIRECTION_INFO);

                            if (ServerAddrLen) {
                                *((ULONG UNALIGNED*)(pRedirInfo)) = 
                                        ServerAddrLen;
                                
                                wcscpy((WCHAR*)(pRedirInfo + sizeof(ULONG)),
                                    pTargetWinStation->ClusterDiscSessions[i].
                                    ServerAddress);

                                pRedirInfo += ServerAddrLen + sizeof(ULONG);
                                
                                pClientRedirInfo->Flags |= TARGET_NET_ADDRESS;
                            }

                            if (LBInfoSize) {
                                *((ULONG UNALIGNED*)(pRedirInfo)) = LBInfoSize;
                                memcpy((BYTE*)(pRedirInfo + sizeof(ULONG)), 
                                       LBInfo, LBInfoSize);

                                pRedirInfo += LBInfoSize + sizeof(ULONG);

                                pClientRedirInfo->Flags |= LOAD_BALANCE_INFO;
                            }

                            if (UserNameSize) {
                                *((ULONG UNALIGNED*)(pRedirInfo)) = UserNameSize;
                                wcscpy((WCHAR*)(pRedirInfo + sizeof(ULONG)), 
                                       pLBInfo->UserName);

                                pRedirInfo += UserNameSize + sizeof(ULONG);

                                pClientRedirInfo->Flags |= LB_USERNAME;
                            }

                            if (DomainSize) {
                                *((ULONG UNALIGNED*)(pRedirInfo)) = DomainSize;
                                wcscpy((WCHAR*)(pRedirInfo + sizeof(ULONG)), 
                                       pLBInfo->Domain);

                                pRedirInfo += DomainSize + sizeof(ULONG);

                                pClientRedirInfo->Flags |= LB_DOMAIN;
                            }

                            if (PasswordSize) {
                                *((ULONG UNALIGNED*)(pRedirInfo)) = PasswordSize;
                                wcscpy((WCHAR*)(pRedirInfo + sizeof(ULONG)), 
                                       pLBInfo->Password);

                                pRedirInfo += PasswordSize + sizeof(ULONG);

                                pClientRedirInfo->Flags |= LB_PASSWORD;
                            }
                        }
                        else {
                            Status = STATUS_NO_MEMORY;

                            // The stack returned failure. Continue
                            // the current connection.
                            TRACE((hTrace,TC_ICASRV,TT_API1,
                                    "TERMSRV: Failed STACK_CLIENT_REDIR, "
                                    "SessionID=%u, Status=0x%X\n",
                                    pTargetWinStation->LogonId, Status));
                            PostErrorValueEvent(
                                    EVENT_TS_SESSDIR_FAIL_CLIENT_REDIRECT,
                                    Status);

                            goto Cleanup;
                        }

                        Status = IcaStackIoControl(pTargetWinStation->hStack,
                                IOCTL_TS_STACK_SEND_CLIENT_REDIRECTION,
                                pClientRedirInfo, RedirInfoSize,
                                NULL, 0,
                                &ReturnLength);

                        if (NT_SUCCESS(Status)) {
                            // Notify session directory
                            // 
                            // There is a relatively benign race condition here.
                            // If the second server logs in the user completely,
                            // it may end up hitting the session directory
                            // before this statement executes.  In that case, 
                            // the directory integrity service may end up 
                            // pinging the machine once.
                            SessDirNotifyReconnectPending(pTargetWinStation->
                                    ClusterDiscSessions[i].ServerAddress);

                            // Drop the current connection.
                            rc = TRUE;
                        }
                        else {
                            // The stack returned failure. Continue
                            // the current connection.
                            TRACE((hTrace,TC_ICASRV,TT_API1,
                                    "TERMSRV: Failed STACK_CLIENT_REDIR, "
                                    "SessionID=%u, Status=0x%X\n",
                                    pTargetWinStation->LogonId, Status));
                            PostErrorValueEvent(
                                    EVENT_TS_SESSDIR_FAIL_CLIENT_REDIRECT,
                                    Status);
                        }
                        
Cleanup:
                        // Cleanup the buffers
                        if (LBInfo != NULL) {
                            SysFreeString((BSTR)LBInfo);
                            LBInfo = NULL;
                        }

                        if (pRedirInfo != NULL) {
                            delete [] pRedirInfoStart;
                            pRedirInfoStart = NULL;
                        }
                    }
                }
            }
        }
        ReleaseTSSD();
    }

    return rc;
}

/****************************************************************************/
// SetTSSD
//
// These three functions ensure protected access to the session directory 
// provider at all times.  SetTSSD sets the pointer and increments the
// reference count to 1.
//
// SetTSSD returns:
//  0 on success
//  -1 if failed because there was still a reference count on the COM object.
//   This could happen if set was called too quickly after the final release
//   to attempt to delete the object, as there still may be pending calls using
//   the COM object.
//  -2 if failed because the critical section is not initialized.  This 
//   shouldn't be reached in normal operation, because Init is the only 
//   function that can call Set, and it bails if it fails the creation of the
//   critical section.
/****************************************************************************/
int SetTSSD(ITSSessionDirectory *pTSSD)
{
    int retval = 0;

    if (g_bCritSecsInitialized != FALSE) {
        EnterCriticalSection(&g_CritSecComObj);

        if (g_nComObjRefCount == 0) {
            ASSERT(g_pTSSDPriv == NULL);
            
            g_pTSSDPriv = pTSSD;
            g_nComObjRefCount = 1;
        }
        else {
            DBGPRINT(("TERMSRV: SetTSSD: obj ref count not 0!\n"));
            retval = -1;
        }

        LeaveCriticalSection(&g_CritSecComObj);
    }
    else {
        ASSERT(g_bCritSecsInitialized == TRUE);
        retval = -2;
    }

    return retval;
}


/****************************************************************************/
// GetTSSD
//
// GetTSSD returns a pointer to the session directory provider, if any, and
// increments the reference count if there is one.
/****************************************************************************/
ITSSessionDirectory *GetTSSD()
{
    ITSSessionDirectory *pTSSD = NULL;

    if (g_bCritSecsInitialized != FALSE) {
        EnterCriticalSection(&g_CritSecComObj);

        if (g_pTSSDPriv != NULL) {
            g_nComObjRefCount += 1;
        }
        else {
            ASSERT(g_nComObjRefCount == 0);
        }

        pTSSD = g_pTSSDPriv;
        LeaveCriticalSection(&g_CritSecComObj);
    }

    return pTSSD;
}


/****************************************************************************/
// ReleaseTSSD
//
// ReleaseTSSD decrements the reference count of the session directory provider
// after a thread has finished using it, or when it is going to be deleted.
//
// If the reference count goes to zero, the pointer to the session directory
// provider is set to NULL.
/****************************************************************************/
void ReleaseTSSD()
{
    ITSSessionDirectory *killthispTSSD = NULL;

    if (g_bCritSecsInitialized != FALSE) {
        EnterCriticalSection(&g_CritSecComObj);

        ASSERT(g_nComObjRefCount != 0);

        if (g_nComObjRefCount != 0) {
            g_nComObjRefCount -= 1;

            if (g_nComObjRefCount == 0) {
                killthispTSSD = g_pTSSDPriv;
                g_pTSSDPriv = NULL;
            }
        }
        
        LeaveCriticalSection(&g_CritSecComObj);
    }
    // Now, release the session directory provider if our temppTSSD is NULL.
    // We didn't want to release it while holding the critical section because
    // that might create a deadlock in the recovery thread.  Well, it did once.
    if (killthispTSSD != NULL)
        killthispTSSD->Release();

}

/****************************************************************************/
// SetTSSDEx
//
// These three functions ensure protected access to the session directory 
// provider at all times.  SetTSSDEx sets the pointer and increments the
// reference count to 1.
//
// SetTSSDEx returns:
//  0 on success
//  -1 if failed because there was still a reference count on the COM object.
//   This could happen if set was called too quickly after the final release
//   to attempt to delete the object, as there still may be pending calls using
//   the COM object.
/****************************************************************************/
int SetTSSDEx(ITSSessionDirectoryEx *pTSSDEx)
{
    int retval = 0;
    
    EnterCriticalSection(&g_CritSecComObj);

    if (g_nTSSDExObjRefCount == 0) {
        ASSERT(g_pTSSDExPriv == NULL);
        
        g_pTSSDExPriv = pTSSDEx;
        g_nTSSDExObjRefCount = 1;
    }
    else {
        DBGPRINT(("TERMSRV: SetTSSDEx: obj ref count not 0!\n"));
        retval = -1;
    }

    LeaveCriticalSection(&g_CritSecComObj);

    return retval;
}

/****************************************************************************/
// GetTSSDEx
//
// GetTSSDEx returns a pointer to the session directory provider, if any, and
// increments the reference count if there is one.
/****************************************************************************/
ITSSessionDirectoryEx *GetTSSDEx()
{
    ITSSessionDirectoryEx *pTSSDEx = NULL;

    if (g_bCritSecsInitialized != FALSE) {
        EnterCriticalSection(&g_CritSecComObj);

        if (g_pTSSDExPriv != NULL) {
            g_nTSSDExObjRefCount += 1;
        }
        else {
            ASSERT(g_nTSSDExObjRefCount == 0);
        }

        pTSSDEx = g_pTSSDExPriv;
        LeaveCriticalSection(&g_CritSecComObj);
    }

    return pTSSDEx;
}

/****************************************************************************/
// ReleaseTSSDEx
//
// ReleaseTSSDEx decrements the reference count of the session directory
// provider after a thread has finished using it, or when it is going to be 
// deleted.
//
// If the reference count goes to zero, the pointer to the session directory 
// provider is set to NULL.
/****************************************************************************/
void ReleaseTSSDEx()
{
    ITSSessionDirectoryEx *killthispTSSDEx = NULL;
    
    EnterCriticalSection(&g_CritSecComObj);

    ASSERT(g_nTSSDExObjRefCount != 0);

    if (g_nTSSDExObjRefCount != 0) {
        g_nTSSDExObjRefCount -= 1;

        if (g_nTSSDExObjRefCount == 0) {
            killthispTSSDEx = g_pTSSDExPriv;
            g_pTSSDExPriv = NULL;
        }
    }
    
    LeaveCriticalSection(&g_CritSecComObj);

    // Now, release the session directory provider if our temppTSSD is NULL.
    // We didn't want to release it while holding the critical section because
    // that might create a deadlock in the recovery thread.  Well, it did once.
    if (killthispTSSDEx != NULL)
        killthispTSSDEx->Release();
}


#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\termsrv\winsta\server\shadow.c ===
/*************************************************************************
*
* shadow.c
*
* Citrix routines for supporting shadowing
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

#include <rpc.h>
#include <winsock.h>

// the highest required size for RDP is 431
#define MODULE_SIZE 512 

typedef struct _SHADOW_PARMS {
    BOOLEAN ShadowerIsHelpSession;  //  True if the shadow target is being
                                    //   shadowed in a Remote Assistance
                                    //   scenario.
    ULONG ClientLogonId;
    ULONG ClientShadowId;
    PWSTR pTargetServerName;
    ULONG TargetLogonId;
    WINSTATIONCONFIG2 Config;
    ICA_STACK_ADDRESS Address;
    PVOID pModuleData;
    ULONG ModuleDataLength;
    PVOID pThinwireData;
    ULONG ThinwireDataLength;
    HANDLE ImpersonationToken;
    WCHAR ClientName[DOMAIN_LENGTH+USERNAME_LENGTH+4];
    BOOL fResetShadowMode;
} SHADOW_PARMS, *PSHADOW_PARMS;

/*
 * External procedures defined
 */
NTSTATUS WinStationShadowWorker( ULONG, PWSTR, ULONG, BYTE, USHORT );
NTSTATUS WinStationShadowTargetSetupWorker( ULONG );
NTSTATUS WinStationShadowTargetWorker( BOOLEAN, BOOL, ULONG, PWINSTATIONCONFIG2, PICA_STACK_ADDRESS,
                                       PVOID, ULONG, PVOID, ULONG, PVOID);
NTSTATUS WinStationStopAllShadows( PWINSTATION );

BOOLEAN WINAPI
_WinStationShadowTargetSetup(
    HANDLE hServer,
    ULONG LogonId
    );

NTSTATUS WINAPI
_WinStationShadowTarget(
    HANDLE hServer,
    ULONG LogonId,
    PWINSTATIONCONFIG2 pConfig,
    PICA_STACK_ADDRESS pAddress,
    PVOID pModuleData,
    ULONG ModuleDataLength,
    PVOID pThinwireData,
    ULONG ThinwireDataLength,
    PVOID pClientName,
    ULONG ClientNameLength
    );

NTSTATUS
WinStationWinerrorToNtStatus(ULONG ulWinError);

/*
 * Internal procedures defined
 */
NTSTATUS _CreateShadowAddress( ULONG, PWINSTATIONCONFIG2, PWSTR,
                               PICA_STACK_ADDRESS, PICA_STACK_ADDRESS );
NTSTATUS _WinStationShadowTargetThread( PVOID );

NTSTATUS
_CheckShadowLoop(
    IN ULONG ClientLogonId,
    IN PWSTR pTargetServerName,
    IN ULONG TargetLogonId
    );

/*
 * External procedures used.
 */
NTSTATUS RpcCheckClientAccess( PWINSTATION, ACCESS_MASK, BOOLEAN );

NTSTATUS WinStationDoDisconnect( PWINSTATION, PRECONNECT_INFO, BOOLEAN bSyncNotify );

NTSTATUS xxxWinStationQueryInformation(ULONG, WINSTATIONINFOCLASS,
        PVOID, ULONG, PULONG);

BOOL GetSalemOutbufCount(PDWORD pdwValue);

ULONG UniqueShadowId = 0;

extern WCHAR g_DigProductId[CLIENT_PRODUCT_ID_LENGTH];

/*****************************************************************************
 *
 *  WinStationShadowWorker
 *
 *   Start a Winstation shadow operation
 *
 * ENTRY:
 *   ClientLogonId (input)
 *     client of the shadow
 *   pTargetServerName (input)
 *     target server name
 *   TargetLogonId (input)
 *     target login id (where the app is running)
 *   HotkeyVk (input)
 *     virtual key to press to stop shadow
 *   HotkeyModifiers (input)
 *     virtual modifer to press to stop shadow (i.e. shift, control)
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationShadowWorker(
    IN ULONG ClientLogonId,
    IN PWSTR pTargetServerName,
    IN ULONG TargetLogonId,
    IN BYTE HotkeyVk,
    IN USHORT HotkeyModifiers
    )
{
    PWINSTATION pWinStation;
    ULONG Length;
    LONG rc;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE ClientToken;
    HANDLE ImpersonationToken;
    PVOID pModuleData;
    ULONG ModuleDataLength;
    PVOID pThinwireData;
    ULONG ThinwireDataLength;
    PWINSTATIONCONFIG2 pShadowConfig = NULL;
    ICA_STACK_ADDRESS ShadowAddress;
    ICA_STACK_ADDRESS RemoteShadowAddress;
    ICA_STACK_BROKEN Broken;
    ICA_STACK_HOTKEY Hotkey;
    WINSTATION_APIMSG msg;
    HANDLE hShadowThread;
    PSHADOW_PARMS pShadowParms;
    HANDLE hTargetThread;
    DWORD ThreadId;
    PVOID pEndpoint;
    ULONG EndpointLength;
    LARGE_INTEGER Timeout;
    LONG retry;
    NTSTATUS WaitStatus;
    NTSTATUS TargetStatus;
    NTSTATUS Status;
    int nFormattedlength;
    BOOL bShadowerHelpSession = FALSE;

    /* 
     * Allocate memory
     */
    pShadowConfig = MemAlloc(sizeof(WINSTATIONCONFIG2));
    if (pShadowConfig == NULL) {
        Status = STATUS_NO_MEMORY;
        return Status;
    }

    /*
     * If target server name is ourself, then clear the target name
     */

    if ( pTargetServerName ) {
        if ( *pTargetServerName ) {
            WCHAR ServerName[MAX_COMPUTERNAME_LENGTH+1];

            Length = MAX_COMPUTERNAME_LENGTH+1;
            GetComputerName( ServerName, &Length );
            if ( !_wcsicmp( ServerName, pTargetServerName ) )
                pTargetServerName = NULL;
        } else {
            pTargetServerName = NULL;
        }
    }

    /*
     * Verify the target logonid is valid, is currently shadowable,
     * and that the caller (client) has shadow access.
     */
    if ( pTargetServerName == NULL ) {

        Status = WinStationShadowTargetSetupWorker( TargetLogonId );


    /*
     * Otherwise, open the remote targer server and call the shadow target API.
     */
    } else {
        HANDLE hServer;

        hServer = WinStationOpenServer( pTargetServerName );
        if ( hServer == NULL ) {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        } else {
            if (_WinStationShadowTargetSetup( hServer, TargetLogonId ) == FALSE) {
                Status = WinStationWinerrorToNtStatus(GetLastError());
            } else {
                Status = STATUS_SUCCESS;
            }
            WinStationCloseServer( hServer );
        }
    }

    /*
     * Check the status of the setup call.
     */
    if ( !NT_SUCCESS( Status ) )
        goto badsetup;

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_ACCESS_DENIED;
        goto badsetup;
    }

    /*
     * If WinStation is not in the active state (connected and
     * a user is logged on), or there is no stack handle,
     * then deny the shadow request.
     */
    if ( pWinStation->State != State_Active ||
         pWinStation->hStack == NULL ) {
        Status = STATUS_CTX_SHADOW_INVALID;
        goto badstate;
    }

    /*
     * If shadower is help session, we already disable screen saver on logon notify
     */
    
    bShadowerHelpSession = TSIsSessionHelpSession(pWinStation, NULL);
    /*
     * Allocate a unique shadow id for this request.
     * (This is used by the shadow target thread in order
     *  to synchronize the return status.)
     */
    pWinStation->ShadowId = InterlockedIncrement( &UniqueShadowId );

    /*
     * Set up shadow config structure to use Named Pipe transport driver
     */
    RtlZeroMemory( pShadowConfig, sizeof(WINSTATIONCONFIG2) );
    wcscpy( pShadowConfig->Pd[0].Create.PdName, L"namedpipe" );
    pShadowConfig->Pd[0].Create.SdClass = SdNetwork;
    wcscpy( pShadowConfig->Pd[0].Create.PdDLL, L"tdpipe" );
    pShadowConfig->Pd[0].Create.PdFlag =
        PD_TRANSPORT | PD_CONNECTION | PD_FRAME | PD_RELIABLE;

    pShadowConfig->Pd[0].Create.OutBufLength = 530;
    pShadowConfig->Pd[0].Create.OutBufCount = 6;
    //
    //344175	Mouse buffer size needs to be increased
    //check if this is a help session, if it is read OutBufCount from registry
    //
    if (bShadowerHelpSession) {
        if (!GetSalemOutbufCount((PDWORD)&pShadowConfig->Pd[0].Create.OutBufCount)) {
            //
            //set the default outbuf count to 25
            //we don't want any low water mark for help sessions
            //
            pShadowConfig->Pd[0].Create.OutBufCount = 25;
        }
        
        pShadowConfig->Pd[0].Create.PdFlag |= PD_NOLOW_WATERMARK; //no low water mark
    }

    pShadowConfig->Pd[0].Create.OutBufDelay = 0;
    pShadowConfig->Pd[0].Params.SdClass = SdNetwork;
    pShadowConfig->Pd[1].Create.SdClass = SdNone;

    /*
     * Use same WD as shadowing WinStation
     */
    pShadowConfig->Wd = pWinStation->Config.Wd;

    /*
     * Create a shadow address based on the config Pd[0] type.
     */
    Status = _CreateShadowAddress( pWinStation->ShadowId, pShadowConfig,
                                   pTargetServerName,
                                   &ShadowAddress, &RemoteShadowAddress );

    if (!NT_SUCCESS(Status)) {
        goto badAddress;
    }

    /*
     * Now impersonate the client and duplicate the impersonation token
     * so we can hand it off to the thread doing the target side work.
     */

    /*
     * Duplicate our impersonation token to allow the shadow
     * target thread to use it.
     */
    Status = NtOpenThreadToken( NtCurrentThread(),
                                TOKEN_ALL_ACCESS,
                                FALSE,
                                &ClientToken );

    if (!NT_SUCCESS(Status)) {
        goto badtoken;
    }


    InitializeObjectAttributes( &ObjA, NULL, 0L, NULL, NULL );

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjA.SecurityQualityOfService = &SecurityQualityOfService;
    Status = NtDuplicateToken( ClientToken,
                               TOKEN_IMPERSONATE,
                               &ObjA,
                               FALSE,
                               TokenImpersonation,
                               &ImpersonationToken );

    NtClose( ClientToken );

    if (!NT_SUCCESS(Status)) {
        goto badtoken;
    }

    /*
     * Query client module data
     */

    pModuleData = MemAlloc( MODULE_SIZE );
    if ( !pModuleData ) {
        Status = STATUS_NO_MEMORY;
        goto badwddata;
    }

    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hStack,
                                IOCTL_ICA_STACK_QUERY_MODULE_DATA,
                                NULL,
                                0,
                                pModuleData,
                                MODULE_SIZE,
                                &ModuleDataLength );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( Status == STATUS_BUFFER_TOO_SMALL ) {

        MemFree( pModuleData );
        pModuleData = MemAlloc( ModuleDataLength );
        if ( !pModuleData ) {
            Status = STATUS_NO_MEMORY;
            goto badwddata;
        }

        //  Check for availability
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxIcaStackIoControl ) {

            Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                    pWinStation->pWsxContext,
                                    pWinStation->hIca,
                                    pWinStation->hStack,
                                    IOCTL_ICA_STACK_QUERY_MODULE_DATA,
                                    NULL,
                                    0,
                                    pModuleData,
                                    ModuleDataLength,
                                    &ModuleDataLength );
        }
        else {
            Status = STATUS_CTX_SHADOW_INVALID;
        }
    }

    if ( !NT_SUCCESS( Status ) ) {
        goto badwddata;
    }

    /*
     * Query thinwire module data
     */
    pThinwireData = MemAlloc( MODULE_SIZE );
    if ( !pThinwireData ) {
        Status = STATUS_NO_MEMORY;
        goto badthinwiredata;
    }

    Status = IcaChannelIoControl( pWinStation->hIcaThinwireChannel,
                                  IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA,
                                  NULL,
                                  0,
                                  pThinwireData,
                                  MODULE_SIZE,
                                  &ThinwireDataLength );
    if ( Status == STATUS_BUFFER_TOO_SMALL ) {

        MemFree( pThinwireData );
        pThinwireData = MemAlloc( ThinwireDataLength );
        if ( !pThinwireData ) {
            Status = STATUS_NO_MEMORY;
            goto badthinwiredata;
        }

        Status = IcaChannelIoControl( pWinStation->hIcaThinwireChannel,
                                      IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA,
                                      NULL,
                                      0,
                                      pThinwireData,
                                      ThinwireDataLength,
                                      &ThinwireDataLength );
    }

    if ( !NT_SUCCESS( Status ) ) {
        goto badthinwiredata;
    }

    /*
     * Create the local passthru stack
     */
    Status = IcaStackOpen( pWinStation->hIca, Stack_Passthru,
                           (PROC)WsxStackIoControl, pWinStation,
                           &pWinStation->hPassthruStack );
    if ( !NT_SUCCESS( Status ) )
        goto badstackopen;

#ifdef notdef
    /*
     * Create the client endpoint.
     * This call will return the ICA_STACK_ADDRESS we bound to,
     * so we can pass it on to the shadow target routine.
     */
    Status = IcaStackCreateShadowEndpoint( pWinStation->hPassthruStack,
                                           pWinStation->ListenName,
                                           pShadowConfig,
                                           &ShadowAddress,
                                           NULL );
    if ( !NT_SUCCESS( Status ) )
        goto badshadowendpoint;
#endif

    /*
     * Create stack broken event and register it
     */
    Status = NtCreateEvent( &pWinStation->ShadowBrokenEvent, EVENT_ALL_ACCESS,
                            NULL, NotificationEvent, FALSE );
    if ( !NT_SUCCESS( Status ) )
        goto badevent;
    Broken.BrokenEvent = pWinStation->ShadowBrokenEvent;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: BrokenEvent(%ld) = %p\n",
          pWinStation->LogonId, pWinStation->ShadowBrokenEvent));


    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hPassthruStack,
                                IOCTL_ICA_STACK_REGISTER_BROKEN,
                                &Broken,
                                sizeof(Broken),
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS(Status) )
        goto badbroken;

    /*
     * Register hotkey
     */
    Hotkey.HotkeyVk        = HotkeyVk;
    Hotkey.HotkeyModifiers = HotkeyModifiers;

    //  Check for availability
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hStack,
                                IOCTL_ICA_STACK_REGISTER_HOTKEY,
                                &Hotkey,
                                sizeof(Hotkey),
                                NULL,
                                0,
                                NULL );
    }
    else {
        Status = STATUS_CTX_SHADOW_INVALID;
    }

    if ( !NT_SUCCESS(Status) )
        goto badhotkey;

    /*
     * Before we enable passthru mode, change the WinStation state
     */
    pWinStation->State = State_Shadow;
    NotifySystemEvent( WEVENT_STATECHANGE );

    /*
     * Tell win32k about passthru mode being enabled
     */
    msg.ApiNumber = SMWinStationPassthruEnable;
    Status = SendWinStationCommand( pWinStation, &msg, 60 );
    if ( !NT_SUCCESS( Status ) )
        goto badpassthru;

    /*
     * Allocate a SHADOW_PARMS struct to pass to the target thread
     */
    pShadowParms = MemAlloc( sizeof(SHADOW_PARMS) );
    if ( !pShadowParms ) {
        Status = STATUS_NO_MEMORY;
        goto badshadowparms;
    }

    /*
     * Create a thread to load the target shadow stack
     */
    pShadowParms->fResetShadowMode   = bShadowerHelpSession;    // Only reset if client is HelpAssistant session
    pShadowParms->ShadowerIsHelpSession = bShadowerHelpSession ? TRUE : FALSE;   
    pShadowParms->ClientLogonId         = ClientLogonId;
    pShadowParms->ClientShadowId        = pWinStation->ShadowId;
    pShadowParms->pTargetServerName     = pTargetServerName;
    pShadowParms->TargetLogonId         = TargetLogonId;
    pShadowParms->Config                = *pShadowConfig;
    pShadowParms->Address               = ShadowAddress;
    pShadowParms->pModuleData           = pModuleData;
    pShadowParms->ModuleDataLength      = ModuleDataLength;
    pShadowParms->pThinwireData         = pThinwireData;
    pShadowParms->ThinwireDataLength    = ThinwireDataLength;
    pShadowParms->ImpersonationToken    = ImpersonationToken;

    nFormattedlength = _snwprintf(pShadowParms->ClientName,
            sizeof(pShadowParms->ClientName) / sizeof(WCHAR),
            L"%s\\%s", pWinStation->Domain, pWinStation->UserName);
    if (nFormattedlength < 0 || nFormattedlength ==
            sizeof(pShadowParms->ClientName) / sizeof(WCHAR)) {
        Status = STATUS_INVALID_PARAMETER;
        goto badClientName;
    }

    pWinStation->ShadowTargetStatus = 0;
    hTargetThread = CreateThread( NULL,
            0,
            (LPTHREAD_START_ROUTINE)_WinStationShadowTargetThread,
            pShadowParms,
            THREAD_SET_INFORMATION,
            &ThreadId );
    if ( hTargetThread == NULL ){
        Status = STATUS_NO_MEMORY;
        goto badthread;
    }
    pModuleData = NULL;                 // Target thread will free
    pThinwireData = NULL;               // Target thread will free
    ImpersonationToken = NULL;          // Target thread will close
    pShadowParms = NULL;                // Target thread will free

    /*
     * Allocate an endpoint buffer
     */
    EndpointLength = MODULE_SIZE;
    pEndpoint = MemAlloc( MODULE_SIZE );
    if ( !pEndpoint ) {
        Status = STATUS_NO_MEMORY;
        goto badmalloc;
    }

    /*
     * Unlock WinStation while we try to connect to the shadow target
     */
    UnlockWinStation( pWinStation );

    /*
     *  Wait for connection from the shadow target
     *
     *  We must do this in a loop since we don't know how long it
     *  will take the target side thread to get to the corresponding
     *  IcaStackConnectionWait() call.  In between calls, we delay for
     *  1 second, but break out if the ShadowBrokenEvent gets triggered.
     */
    for ( retry = 0; retry < 35; retry++ ) {
        ULONG ReturnedLength;


        Status = IcaStackConnectionRequest( pWinStation->hPassthruStack,
                                         pWinStation->ListenName,
                                         pShadowConfig,
                                         &RemoteShadowAddress,
                                         pEndpoint,
                                         EndpointLength,
                                         &ReturnedLength );
        if ( Status == STATUS_BUFFER_TOO_SMALL ) {
            MemFree( pEndpoint );
            pEndpoint = MemAlloc( ReturnedLength );
            if ( !pEndpoint ) {
                Status = STATUS_NO_MEMORY;
                break;
            }
            EndpointLength = ReturnedLength;
            Status = IcaStackConnectionRequest( pWinStation->hPassthruStack,
                                                pWinStation->ListenName,
                                                pShadowConfig,
                                                &RemoteShadowAddress,
                                                pEndpoint,
                                                EndpointLength,
                                                &ReturnedLength );
        }
        if ( Status != STATUS_OBJECT_NAME_NOT_FOUND )
            break;
        Timeout = RtlEnlargedIntegerMultiply( 1000, -10000 );
        WaitStatus = NtWaitForSingleObject( pWinStation->ShadowBrokenEvent, FALSE, &Timeout );
        if ( WaitStatus != STATUS_TIMEOUT )
            break;
        
        /*
         * If the shadow has already completed, we don't need to continue 
         * trying to initiate it
         */
        if (pWinStation->ShadowTargetStatus)
        {
           break;
        }
    }

    /*
     * Now relock the WinStation
     */
    RelockWinStation( pWinStation );

    /*
     * Check the status from the wait for connection
     */
    if ( !NT_SUCCESS( Status ) ) {
        // The pipe disconnected before the worker thread can set an error
        // code.  Wait for worker thread to set error code.
        if ( Status == ST