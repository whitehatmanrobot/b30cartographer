DirCount * sizeof(ULONG))) {

#if MSSIPOTF_ERROR
                DbgPrintf ("Not a TTC: First block is not immediately after the v1.0 header.\n");
#endif
                *phrError = MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT;
                goto done;
            }

        } else if ((pTTCInfo->pHeader->ulVersion >= TTC_VERSION_1_0) &&
            (pTTCInfo->pHeader->ulDsigTag == DSIG_LONG_TAG)) {

            if (pTTCInfo->ppBlockSorted[0]->ulOffset !=
                (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG +
                pTTCInfo->pHeader->ulDirCount * sizeof(ULONG))) {

#if MSSIPOTF_ERROR
                DbgPrintf ("Not a TTC: First block is not immediately after the v2.0 header.\n");
#endif
                *phrError = MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT;
                goto done;
            }

        } else {
            // this case should already have been caught in GetTTCInfo
#if MSSIPOTF_DBG
            DbgPrintf ("Bad TTC version number.\n");
#endif
            *phrError = MSSIPOTF_E_BADVERSION;
            goto done;
        }
    }


    // Check #2
	//// Check that blocks begin on a long-word boundary.
	for (i = 0; i < pTTCInfo->ulNumBlocks; i++) {
// printf ("block %d offset = 0x%x.\n", i, pTTCInfo->ppBlockSorted[i]->ulOffset);
		if ( (pTTCInfo->ppBlockSorted[i]->ulOffset % sizeof(LONG)) != 0) {

#if MSSIPOTF_ERROR
			DbgPrintf ("Not a TTC: Table offset not long word-aligned (offset = %d).\n",
                pTTCInfo->ppBlockSorted[i]->ulOffset);
#endif
            *phrError = MSSIPOTF_E_TABLE_LONGWORD;
            goto done;
		}
	}

	//// If the tables are sorted by offset, then for table i,
	//// Offset[i] + Length[i] <= Offset[i+1] and
	//// Offset[i] + Length[i] >= Offset[i+1] - sizeof(LONG) + 1.
    //// Also, check that the pad bytes are 0x00.
	for (i = 0; i < pTTCInfo->ulNumBlocks - 1; i++) {
		if ( (pTTCInfo->ppBlockSorted[i]->ulOffset + pTTCInfo->ppBlockSorted[i]->ulLength) >
			pTTCInfo->ppBlockSorted[i+1]->ulOffset) {

#if MSSIPOTF_ERROR
            DbgPrintf ("Not a TTC: TTC blocks overlap.\n");
#endif

/*
printf ("Block %d:\n", i);
printf ("  ulTag      = 0x%x\n", pTTCInfo->ppBlockSorted[i]->ulTag);
printf ("  ulChecksum = 0x%x\n", pTTCInfo->ppBlockSorted[i]->ulChecksum);
printf ("  ulOffset   = %d\n", pTTCInfo->ppBlockSorted[i]->ulOffset);
printf ("  ulLength   = %d\n", pTTCInfo->ppBlockSorted[i]->ulLength);
printf ("Buffer size  = %d\n", pTTCInfo->pFileBufferInfo->ulBufferSize);
printf ("Block %d:\n", i+1);
printf ("  ulTag      = 0x%x\n", pTTCInfo->ppBlockSorted[i+1]->ulTag);
printf ("  ulChecksum = 0x%x\n", pTTCInfo->ppBlockSorted[i+1]->ulChecksum);
printf ("  ulOffset   = %d\n", pTTCInfo->ppBlockSorted[i+1]->ulOffset);
printf ("  ulLength   = %d\n", pTTCInfo->ppBlockSorted[i+1]->ulLength);
printf ("Buffer size  = %d\n", pTTCInfo->pFileBufferInfo->ulBufferSize);
*/
            *phrError = MSSIPOTF_E_TABLES_OVERLAP;
			goto done;
		}
		if ( (pTTCInfo->ppBlockSorted[i]->ulOffset + pTTCInfo->ppBlockSorted[i]->ulLength) <
			(pTTCInfo->ppBlockSorted[i+1]->ulOffset - sizeof(LONG) + 1) ) {

#if MSSIPOTF_ERROR
            DbgPrintf ("Not a TTC: Too much padding.\n");
#endif
            *phrError = MSSIPOTF_E_TABLE_PADBYTES;
			goto done;
		}

        pad_start = pTTCInfo->ppBlockSorted[i]->ulOffset +
            pTTCInfo->ppBlockSorted[i]->ulLength;
        j = pad_start;
        // make sure we don't try to read beyond the end of the buffer
        if (RoundToLongWord(pad_start) > pTTCInfo->pFileBufferInfo->ulBufferSize) {
#if MSSIPOTF_ERROR
            DbgPrintf ("Not an OTF: File not large enough to contain all tables.\n", i);
#endif
            *phrError = MSSIPOTF_E_FILETOOSMALL;
            goto done;
        }
        for ( ; j < RoundToLongWord (pad_start); j++) {
            if (memcmp (pTTCInfo->pFileBufferInfo->puchBuffer + j, &zero, 1)) {
// printf ("offset = 0x%x\n", j);

#if MSSIPOTF_ERROR
                DbgPrintf ("Not a TTC: Bad gap bytes.\n");
#endif
                *phrError = MSSIPOTF_E_TABLE_PADBYTES;
                goto done;
            }
        }
	}

    // Check #3

    if (fTableChecksum) {
        //// Check the table checksums.
	    for (i = 0; i < pTTCInfo->ulNumBlocks; i++) {
            if ((pTTCInfo->ppBlockSorted[i]->ulTag != HEAD_LONG_TAG) &&
                (pTTCInfo->ppBlockSorted[i]->ulTag != DSIG_LONG_TAG) &&
                (pTTCInfo->ppBlockSorted[i]->ulTag != 0)) {
                // the block is not a head table and it's not the DSIG table
                // and it's not a Table Directory
                CalcChecksum (pTTCInfo->pFileBufferInfo,
                            pTTCInfo->ppBlockSorted[i]->ulOffset,
                            pTTCInfo->ppBlockSorted[i]->ulLength,
                            &ulChecksum);
                if (ulChecksum != pTTCInfo->ppBlockSorted[i]->ulChecksum) {
#if MSSIPOTF_ERROR
    			    DbgPrintf ("Not a TTC: Table checksum does not match.\n");
#endif
#if MSSIPOTF_DBG
                    DbgPrintf ("Block no. %d, calc cs = %x, file cs = %x.\n",
                        i, ulChecksum, pTTCInfo->ppBlockSorted[i]->ulChecksum);
#endif
                    *phrError = MSSIPOTF_E_TABLE_CHECKSUM;
			        goto done;
                }
            } else if (pTTCInfo->ppBlockSorted[i]->ulTag == HEAD_LONG_TAG) {
 
                // The block is a head table.
                ULONG ulHeadOffset = 0;
                USHORT usBytesMoved = 0;
                ULONG ulHeadChecksum = 0;
                ULONG ulHeadChecksumFile = 0;


                memset (pFileBufferInfoHead->puchBuffer, 0x00, RoundToLongWord(SIZEOF_HEAD));
                pFileBufferInfoHead->ulBufferSize = RoundToLongWord(SIZEOF_HEAD);
                pFileBufferInfoHead->ulOffsetTableOffset = 0;   // not used in this function
                pFileBufferInfoHead->lpfnReAllocate = NULL;

	            ulHeadOffset =  pTTCInfo->ppBlockSorted[i]->ulOffset;
	            if (ReadGeneric (pTTCInfo->pFileBufferInfo, (uint8 *) &Head,
                        SIZEOF_HEAD, HEAD_CONTROL, ulHeadOffset, &usBytesMoved) != NO_ERROR) {
#if MSSIPOTF_ERROR
                    DbgPrintf ("Error reading head table.\n");
#endif
                    *phrError = MSSIPOTF_E_NOHEADTABLE;
		            goto done;
                }

	            Head.checkSumAdjustment = 0L;
                if (WriteGeneric(pFileBufferInfoHead, (uint8 *) &Head,
                        SIZEOF_HEAD, HEAD_CONTROL, 0, &usBytesMoved) != NO_ERROR) {
#if MSSIPOTF_ERROR
                    DbgPrintf ("Error writing head table.\n");
#endif
                    *phrError = MSSIPOTF_E_NOHEADTABLE;
                    goto done;
                }
                assert (usBytesMoved == SIZEOF_HEAD);

                // ASSERT: pFileBufferInfoHead now contains the head table with
                // the file checksum (checkSumAdjustment) field zeroed out.

                // Calculate the checksum of the head table (from the new buffer).
                CalcChecksum (pFileBufferInfoHead, 0,
                    RoundToLongWord (SIZEOF_HEAD), &ulHeadChecksum);

                // Get the checksum that is in the head table's directory entry
                ulHeadChecksumFile = pTTCInfo->ppBlockSorted[i]->ulChecksum;

                // Compare the head table's calculated checksum with the checksum in the file
                if (ulHeadChecksum != ulHeadChecksumFile) {
#if MSSIPOTF_ERROR
                    DbgPrintf ("Not an TTC: head table checksum does not match.\n");
#endif
//		DbgPrintf ("calc = 0x%x ; file = 0x%x.\n", ulHeadChecksum, ulHeadChecksumFile);
                    *phrError = MSSIPOTF_E_TABLE_CHECKSUM;
                    goto done;
                }

            }
	    }
    }

    // Check #4

    i = pTTCInfo->ulNumBlocks - 1;
	// ASSERT: i now equals ulNumBlocks - 1
	//// Check that the file is large enough to contain the last block.
	if ( (pTTCInfo->ppBlockSorted[i]->ulOffset + pTTCInfo->ppBlockSorted[i]->ulLength) >
		    pTTCInfo->pFileBufferInfo->ulBufferSize) {

#if MSSIPOTF_ERROR
		DbgPrintf ("Not a TTC: File not large enough to contain all blocks.\n");
#endif
/*
printf ("Block %d:\n", i);
printf ("  ulTag      = 0x%x\n", pTTCInfo->ppBlockSorted[i]->ulTag);
printf ("  ulChecksum = 0x%x\n", pTTCInfo->ppBlockSorted[i]->ulChecksum);
printf ("  ulOffset   = %d\n", pTTCInfo->ppBlockSorted[i]->ulOffset);
printf ("  ulLength   = %d\n", pTTCInfo->ppBlockSorted[i]->ulLength);
printf ("Buffer size  = %d\n", pTTCInfo->pFileBufferInfo->ulBufferSize);
*/
        *phrError = MSSIPOTF_E_FILETOOSMALL;
		goto done;
	}

	if ( RoundToLongWord(pTTCInfo->ppBlockSorted[i]->ulOffset +
                         pTTCInfo->ppBlockSorted[i]->ulLength) <
            pTTCInfo->pFileBufferInfo->ulBufferSize) {

#if MSSIPOTF_ERROR
		DbgPrintf ("Not a TTC: Too much padding.\n");
#endif
        *phrError = MSSIPOTF_E_TABLE_PADBYTES;
		goto done;
	}

    // Check #5
    // Check the pad bytes of the last block.
    // Note that the pad bytes after the last block might not
    // end on a long word boundary (whereas in all previous
    // blocks, the pad bytes pad to a long word boundary).
    pad_start = pTTCInfo->ppBlockSorted[i]->ulOffset +
        pTTCInfo->ppBlockSorted[i]->ulLength;
    j = pad_start;
    for ( ; (j < RoundToLongWord (pad_start)) &&
            (j < pTTCInfo->pFileBufferInfo->ulBufferSize); j++) {
        if (memcmp (pTTCInfo->pFileBufferInfo->puchBuffer + j, &zero, 1)) {

#if MSSIPOTF_ERROR
            DbgPrintf ("Not a TTC: Bad gap bytes.\n");
#endif
            *phrError = MSSIPOTF_E_TABLE_PADBYTES;
            goto done;
        }
    }

    rv = TRUE;
done:

    // Free the temporary buffer that contained the modified head table.
    if (pFileBufferInfoHead) {
        delete [] pFileBufferInfoHead->puchBuffer;
    }
    delete pFileBufferInfoHead;

    FreeTTCInfo(pTTCInfo);

    return rv;
}


//
// Create a TTCInfo structure for the TTC file and
// set all of its fields.
//
// Note: a TABLE_BLOCK defines a block of memory that
// is either an Table Directory (Offset Table plus directory entries)
// or a table or the DSIG table.
//
// GetTTCInfo allocates memory for subfields, but not for
// the TTCInfo structure itself.
//
HRESULT GetTTCInfo (BYTE *pbFile, ULONG cbFile, TTCInfo *pTTCInfo)
{
    HRESULT rv = E_FAIL;

    ULONG i, j;
    TABLE_BLOCK *pBlock = NULL;
    ULONG numBlocks = 0;
    ULONG blockIndex;
	USHORT numTables = 0;
	DIRECTORY DirectoryEntry;
    OFFSET_TABLE OffTable;
    OFFSET_TABLE offsetTableCheck;
	ULONG ulOffset = 0;
    ULONG ulPrevTableTag = 0;


	// Allocate space for the file buffer info
	if ((pTTCInfo->pFileBufferInfo =
		(TTFACC_FILEBUFFERINFO *) malloc (sizeof (TTFACC_FILEBUFFERINFO))) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in malloc.", NULL, FALSE);
#endif
		rv = E_OUTOFMEMORY;
		goto done;
	}

	//// Set the fields of the TTFACC_FILEBUFFERINFO structure
	pTTCInfo->pFileBufferInfo->puchBuffer = pbFile;
	pTTCInfo->pFileBufferInfo->ulBufferSize = cbFile;
	pTTCInfo->pFileBufferInfo->ulOffsetTableOffset = 0;
	pTTCInfo->pFileBufferInfo->lpfnReAllocate = &NullRealloc;

	if ((pTTCInfo->pHeader = new TTC_HEADER_TABLE) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new TTC_HEADER_TABLE.", NULL, FALSE);
#endif
		rv = E_OUTOFMEMORY;
		goto done;
	}
    pTTCInfo->pHeader->pulDirOffsets = NULL;

	//// Read the header table from the TTC file
	if ((rv = ReadTTCHeaderTable (pTTCInfo->pFileBufferInfo,
                                  pTTCInfo->pHeader)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in ReadTTCHeaderTable.\n");
#endif
		goto done;
	}

    // Compute the number of blocks in the TTC file, which is the number
    // of TTF Table Directories plus the number of tables in each TTF plus
    // one (for the DSIG table).
    // This number is likely to be an overestimate of the actual number
    // of distinct blocks, because there might be identical directory
    // entries in different TTFs.
    // However, this will be compensated for when the array of blocks
    // is compressed (see below).
    //
    // Note that in reading the offset tables, the ReadGeneric code checks
    // to make sure the offset is within the range of the file.
    if ((pTTCInfo->pulOffsetTables =
            new (ULONG [pTTCInfo->pHeader->ulDirCount])) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new ULONG [].", NULL, FALSE);
#endif
        rv = E_OUTOFMEMORY;
        goto done;
    }

    // set offset table pointers of the TTCInfo structure and
    // compute number of blocks.
    numBlocks = 0;
    for (i = 0; i < pTTCInfo->pHeader->ulDirCount; i++) {
        ulOffset = pTTCInfo->pHeader->pulDirOffsets[i];
        pTTCInfo->pulOffsetTables [i] = ulOffset;
        ReadOffsetTableOffset (pTTCInfo->pFileBufferInfo, ulOffset, &OffTable);
        numBlocks += OffTable.numTables + 1;

        // make sure numBlocks doesn't wrap at 2^32.
        if (numBlocks <= OffTable.numTables) {
#if MSSIPOTF_ERROR
            SignError ("Cannot continue: Too many blocks in TTC file.", NULL, FALSE);
#endif
            rv = MSSIPOTF_E_STRUCTURE;
            goto done;
        }
    }

    // Add one for the DSIG table (it may not even exist)
    numBlocks++;
    // Again, check that numBlocks didn't wrap at 2^32.
    if (numBlocks == 0) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Too many blocks in TTC.", NULL, FALSE);
#endif
        rv = MSSIPOTF_E_STRUCTURE;
        goto done;
    }

	// Allocate space for the array of TABLE_BLOCKs
    if ((pTTCInfo->pBlocks =
        new (TABLE_BLOCK [numBlocks])) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new TABLE_BLOCK.", NULL, FALSE);
#endif
		rv = E_OUTOFMEMORY;
		goto done;
	}

    // Allocate space for the pointers to the TABLE_BLOCK entries in pBlocks
    if ((pTTCInfo->ppBlockSorted =
        new (TABLE_BLOCK * [numBlocks])) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new TABLE_BLOCK *.", NULL, FALSE);
#endif
		rv = E_OUTOFMEMORY;
		goto done;
	}

	// For each TTF, set a block for the table directory and for its tables.
    // Set the pointers in pBlockSorted to be in the (incorrect) order the
    // table directories and tables are read in.
    blockIndex = 0;
    pBlock = pTTCInfo->pBlocks;
    for (i = 0; i < pTTCInfo->pHeader->ulDirCount; i++) {

        // table directory (offset table and directory entries) block
		pTTCInfo->pBlocks[blockIndex].ulTag = 0;
        pTTCInfo->pBlocks[blockIndex].ulChecksum= 0;
		pTTCInfo->pBlocks[blockIndex].ulOffset = pTTCInfo->pHeader->pulDirOffsets[i];
        ReadOffsetTableOffset (pTTCInfo->pFileBufferInfo,
            pTTCInfo->pulOffsetTables[i],
            &OffTable);

        //// Check that the entries in the offset table
        //// (that is, the sfnt table) are correct, given the
        //// assumption that numTables is correct.
        offsetTableCheck.numTables = OffTable.numTables;
        CalcOffsetTable (&offsetTableCheck);
// DbgPrintf ("search range: %d %d\n", offsetTableCheck.searchRange, pttfInfo->pOffset->searchRange);
// DbgPrintf ("entry selector: %d %d\n", offsetTableCheck.entrySelector, pttfInfo->pOffset->entrySelector);
// DbgPrintf ("rangeShift: %d %d\n", offsetTableCheck.rangeShift, pttfInfo->pOffset->rangeShift);
        if ((offsetTableCheck.searchRange != OffTable.searchRange) ||
            (offsetTableCheck.entrySelector != OffTable.entrySelector) ||
            (offsetTableCheck.rangeShift != OffTable.rangeShift) ) {

#if MSSIPOTF_ERROR
            DbgPrintf ("Not a TTC: Offset table values incorrect in TTF #%d.\n", i);
#endif
            rv = MSSIPOTF_E_BAD_OFFSET_TABLE;
            goto done;
        }

		pTTCInfo->pBlocks[blockIndex].ulLength =
            SIZEOF_OFFSET_TABLE +
            (OffTable.numTables * SIZEOF_DIRECTORY);
        pTTCInfo->ppBlockSorted[blockIndex] = pBlock;
        blockIndex++;
        pBlock++;

        // the actual tables
	    numTables = OffTable.numTables;
	    ulOffset = pTTCInfo->pHeader->pulDirOffsets[i] + SIZEOF_OFFSET_TABLE;

	    for (j = 0; j < numTables; j++, ulOffset += SIZEOF_DIRECTORY) {
		    ReadDirectoryEntry (pTTCInfo->pFileBufferInfo,
							    ulOffset,
							    &DirectoryEntry);
		    pTTCInfo->pBlocks[blockIndex].ulTag = DirectoryEntry.tag;
            pTTCInfo->pBlocks[blockIndex].ulChecksum = DirectoryEntry.checkSum;
		    pTTCInfo->pBlocks[blockIndex].ulOffset = DirectoryEntry.offset;
		    pTTCInfo->pBlocks[blockIndex].ulLength = DirectoryEntry.length;
            pTTCInfo->ppBlockSorted[blockIndex] = pBlock;
            // Check for table tags out of alphabetical order or duplicate tags
            // The check for j>0 is there because we don't need to check the first tag.
            if ((DirectoryEntry.tag <= ulPrevTableTag) && (j > 0)) {
#if MSSIPOTF_ERROR
                DbgPrintf ("Not a TTC: Tag of table %d in TTF %d out of alphabetical order or duplicate tag.\n", j, i);
#endif
                rv = MSSIPOTF_E_TABLE_TAGORDER;
                goto done;
            } else {
                ulPrevTableTag = DirectoryEntry.tag;
            }
            blockIndex++;
            pBlock++;
	    }
    }

    // Handle the DSIG table.  If the DsigOffset is 0, then we do not
    // add a block to the list of blocks.
    if (pTTCInfo->pHeader->ulDsigOffset != 0) {
        pTTCInfo->pBlocks[blockIndex].ulTag = DSIG_LONG_TAG;
        pTTCInfo->pBlocks[blockIndex].ulChecksum = 0;  // not used for DSIG table
		pTTCInfo->pBlocks[blockIndex].ulOffset = pTTCInfo->pHeader->ulDsigOffset;
		pTTCInfo->pBlocks[blockIndex].ulLength = pTTCInfo->pHeader->ulDsigLength;
        pTTCInfo->ppBlockSorted[blockIndex] = pBlock;
        blockIndex++;
        pBlock++;
    }
    
    pTTCInfo->ulNumBlocks = blockIndex;

	//// Sort the ppDirSorted field of pTTCInfo
	SortTTCBlocksByOffset (pTTCInfo);

    //// Compress away any duplicate entries.
    if ((rv = CompressTTCBlocks (pTTCInfo)) != S_OK) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in CompressTTCBlocks.\n");
#endif
        goto done;
    }

	rv = S_OK;

done:

    return rv;
}


void PrintTTCHeader (TTC_HEADER_TABLE *pTTCHeader)
{
    ULONG i;

    DbgPrintf ("TTC Header:\n");
    DbgPrintf ("  tag      : 0x%x\n", pTTCHeader->TTCtag);
    DbgPrintf ("  version  : 0x%x\n", pTTCHeader->ulVersion);
    DbgPrintf ("  dir count: %d\n", pTTCHeader->ulDirCount);
    for (i = 0; i < pTTCHeader->ulDirCount; i++) {
        DbgPrintf ("    %d off : %d\n", i, pTTCHeader->pulDirOffsets[i]);
    }
    DbgPrintf ("  DSIG tag : 0x%x\n", pTTCHeader->ulDsigTag);
    DbgPrintf ("  DSIG len : %d\n", pTTCHeader->ulDsigLength);
    DbgPrintf ("  DSIG off : %d\n", pTTCHeader->ulDsigOffset);
}


void PrintTTCBlocks (TTCInfo *pTTCInfo)
{
    ULONG i;

    for (i = 0; i < pTTCInfo->ulNumBlocks; i++) {
        DbgPrintf ("Block number %d:\n", i);
        DbgPrintf ("  tag     : 0x%x\n", pTTCInfo->ppBlockSorted[i]->ulTag);
        DbgPrintf ("  checksum: 0x%x\n", pTTCInfo->ppBlockSorted[i]->ulChecksum);
        DbgPrintf ("  offset  : 0x%x\n", pTTCInfo->ppBlockSorted[i]->ulOffset);
        DbgPrintf ("  length  : 0x%x\n", pTTCInfo->ppBlockSorted[i]->ulLength);
   }

}


//
// Free the allocated resources in a TTCInfo structure
//
void FreeTTCInfo (TTCInfo *pTTCInfo)
{
	if (pTTCInfo) {
		if (pTTCInfo->pFileBufferInfo) {
			FreeFileBufferInfo (pTTCInfo->pFileBufferInfo);
			pTTCInfo->pFileBufferInfo = NULL;
		}

        if (pTTCInfo->pHeader) {
            delete [] pTTCInfo->pHeader->pulDirOffsets;
            pTTCInfo->pHeader->pulDirOffsets = NULL;
        }
        delete pTTCInfo->pHeader;
		pTTCInfo->pHeader = NULL;

        delete [] pTTCInfo->pulOffsetTables;
		pTTCInfo->pulOffsetTables = NULL;

        delete [] pTTCInfo->ppBlockSorted;
		pTTCInfo->ppBlockSorted = NULL;

        delete [] pTTCInfo->pBlocks;
        pTTCInfo->pBlocks = NULL;

		delete pTTCInfo;
	}
}

//
// InitTTCStructures
//
// Given a TTC file, return a TTCInfo structure and DsigTable
//   structure for that file.  This function allocates the memory
//   for these structures.
// This functions assumes that the file has passed the IsTTCFile test.
// BUGBUG: Is this last assumption really necessary?  If not, then
// the GetSignedDataMsg does not need to do the full structural checks.
//
HRESULT InitTTCStructures (BYTE *pbFile,
                           ULONG cbFile,
                           TTCInfo **ppTTCInfo,
                           CDsigTable **ppDsigTable)
{
	HRESULT fReturn = E_FAIL;

	ULONG ulOffset = 0;  // needed for the call to CDsigTable::Read
	ULONG ulLength = 0;  // needed for the call to CDsigTable::Read

	// Allocate memory for the TTFInfo structure
	if ((*ppTTCInfo = new TTCInfo) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new TTCInfo.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

    // Initialize TTCInfo pointers to NULL
    (*ppTTCInfo)->pFileBufferInfo = NULL;
    (*ppTTCInfo)->pHeader = NULL;
    (*ppTTCInfo)->pulOffsetTables = NULL;
    (*ppTTCInfo)->ppBlockSorted = NULL;
    (*ppTTCInfo)->pBlocks = NULL;

    // Set the TTCInfo structure of the old file
	if ((fReturn = GetTTCInfo (pbFile, cbFile, *ppTTCInfo)) != S_OK) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in GetTTCInfo.", NULL, FALSE);
#endif
		goto done;
	}

    ulOffset = (*ppTTCInfo)->pHeader->ulDsigOffset;
    ulLength = (*ppTTCInfo)->pHeader->ulDsigLength;

	// allocate memory for a dsigTable
	if ((*ppDsigTable = new CDsigTable) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CDsigTable.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

    if ((*ppTTCInfo)->pHeader->ulDsigTag != DSIG_LONG_TAG) {
#if MSSIPOTF_DBG
		DbgPrintf ("No DSIG table to read.  Creating default DsigTable.\n");
#endif
        fReturn = S_OK;
        goto done;
    }

	// Extract the DSIG table from the old file
    if ((fReturn = (*ppDsigTable)->Read ((*ppTTCInfo)->pFileBufferInfo,
										 &ulOffset, ulLength)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in DsigTable::Read.\n");
#endif
		goto done;
    }

	fReturn = S_OK;

done:
	return fReturn;
}


//
// Compare the offsets of two blocks.
//
int __cdecl BlockOffsetCmp (const void *elem1, const void *elem2)
{
	if ((* (TABLE_BLOCK * *) elem1)->ulOffset < (* (TABLE_BLOCK * *) elem2)->ulOffset) {
		return -1;
	} else if ((* (TABLE_BLOCK * *) elem1)->ulOffset > (* (TABLE_BLOCK * *) elem2)->ulOffset) {
		return 1;
	} else {
        // the offsets are equal; the length now determines which is greater
        if ((* (TABLE_BLOCK * *) elem1)->ulLength <
            (* (TABLE_BLOCK * *) elem2)->ulLength) {
            return -1;
        } else if ((* (TABLE_BLOCK * *) elem1)->ulLength >
            (* (TABLE_BLOCK * *) elem2)->ulLength) {
            return 1;
        } else {
		    return 0;
        }
	}
}


//
// Given a TTCInfo struct, set the ppDirSorted field to
// be an array of pointers to the blocks,
// sorted by ascending offset.
//
void SortTTCBlocksByOffset (TTCInfo *pTTCInfo)
{
	qsort ((void *) pTTCInfo->ppBlockSorted,
		(size_t) pTTCInfo->ulNumBlocks,
		sizeof(TABLE_BLOCK *),
		BlockOffsetCmp);
}


// Compare two pointers to TABLE_BLOCKs.
// Return 1 if all fields are identical.
// Return 0 otherwise.
BOOL BlockEqual (const TABLE_BLOCK *pBlock1, const TABLE_BLOCK *pBlock2)
{
    BOOL rv;

    rv = (pBlock1->ulTag == pBlock2->ulTag) &&
        (pBlock1->ulOffset == pBlock2->ulOffset) &&
        (pBlock1->ulLength == pBlock2->ulLength);

    return rv;

}


//
// Delete duplicate entries in the set of TTC blocks.
// This function assumes that the pointers to blocks are
// sorted by offset.
// Distinct entries with the same offset is an error.
//
HRESULT CompressTTCBlocks (TTCInfo *pTTCInfo)
{
    HRESULT rv = E_FAIL;
    ULONG i, j;


    if (pTTCInfo->ulNumBlocks == 0) {
        rv = S_OK;
        goto done;
    }

    for (i = 0; i < pTTCInfo->ulNumBlocks - 1; ) {
        if (BlockEqual (pTTCInfo->ppBlockSorted[i],
                        pTTCInfo->ppBlockSorted[i+1])) {
            // compress out the i+1 entry
            for (j = i+1; j < pTTCInfo->ulNumBlocks - 1; j++) {
                pTTCInfo->ppBlockSorted[j] = pTTCInfo->ppBlockSorted[j+1];
            }
            pTTCInfo->ulNumBlocks--;

        } else if (pTTCInfo->ppBlockSorted[i]->ulOffset ==
            pTTCInfo->ppBlockSorted[i+1]->ulOffset) {

#if MSSIPOTF_ERROR
            SignError ("Cannot continue: Distinct blocks with same offset.", NULL, FALSE);
#endif
            rv = MSSIPOTF_E_STRUCTURE;
            goto done;
        } else {
            i++;
        }
    }

    rv = S_OK;

done:
    return rv;
}


//
// Read the header table of a TTC file
//
HRESULT ReadTTCHeaderTable (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                            TTC_HEADER_TABLE *pTTCHeader)
{
    int rv = E_FAIL;

    ULONG ulOffset = 0;
    ULONG sizeof_long = sizeof(ULONG);
    ULONG i;

    ULONG ulDsigTag;

	//// Check that the file is at least SIZEOF_TTC_HEADER_TABLE_1_0 long.
	//// (If the file is too small, then we might try to read beyond
	//// the end of the file when we try to read the offset table to
	//// retrieve the number of tables.)
	if (pFileBufferInfo->ulBufferSize < SIZEOF_TTC_HEADER_TABLE_1_0) {
#if MSSIPOTF_ERROR
        SignError ("File too small (not big enough for TTC header v1.0).", NULL, FALSE);
#endif
		rv = MSSIPOTF_E_FILETOOSMALL;
		goto done;
	}

    ReadLong (pFileBufferInfo, &(pTTCHeader->TTCtag), ulOffset);
    ulOffset += sizeof_long;
    ReadLong (pFileBufferInfo, &(pTTCHeader->ulVersion), ulOffset);
    ulOffset += sizeof_long;
    ReadLong (pFileBufferInfo, &(pTTCHeader->ulDirCount), ulOffset);
    ulOffset += sizeof_long;

    // Check the tag field
    // ASSERT: This already should have been checked by IsFontFile.
    if (pTTCHeader->TTCtag != TTC_HEADER_LONG_TAG) {
#if MSSIPOTF_ERROR
        SignError ("TTC header tag is incorrect.", NULL, FALSE);
#endif
        rv = MSSIPOTF_E_STRUCTURE;
		goto done;
	}

    // Check the header version number
    if (pTTCHeader->ulVersion < TTC_VERSION_1_0) {
#if MSSIPOTF_ERROR
        SignError ("Bad TTC header version number.", NULL, FALSE);
#endif
        rv = MSSIPOTF_E_BADVERSION;
		goto done;
	}

	//// Check that the file is at least
	//// SIZEOF_TTC_HEADER_TABLE_1_0 + (numTables * sizeof(ULONG)) long
	//// (If the file is too small, then we might try to read beyond
	//// the end of the file when we try to access the offsets to the 
	//// TTFs.)
    if (pFileBufferInfo->ulBufferSize <
        (SIZEOF_TTC_HEADER_TABLE_1_0 + pTTCHeader->ulDirCount * sizeof(ULONG))) {
#if MSSIPOTF_ERROR
        SignError ("File not large enough to hold all table directory offsets.", NULL, FALSE);
#endif
        rv = MSSIPOTF_E_FILETOOSMALL;
        goto done;
    }

    // set the directory offsets in the TTCHeader struct
    if ((pTTCHeader->pulDirOffsets = new ULONG [pTTCHeader->ulDirCount]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new ULONG [].", NULL, FALSE);
#endif
        rv = E_OUTOFMEMORY;
        goto done;
    }

    for (i = 0; i < pTTCHeader->ulDirCount; i++) {
        ReadLong (pFileBufferInfo, &(pTTCHeader->pulDirOffsets[i]), ulOffset);
        ulOffset += sizeof_long;
    }

    // make sure we can read the next ULONG
    if (pFileBufferInfo->ulBufferSize <
        (SIZEOF_TTC_HEADER_TABLE_1_0 +
            pTTCHeader->ulDirCount * sizeof(ULONG) +
            sizeof(ULONG))) {
#if MSSIPOTF_ERROR
        SignError ("File not large enough to hold more than the TTC header.", NULL, FALSE);
#endif
        rv = MSSIPOTF_E_FILETOOSMALL;
        goto done;
    }

    // Read the DSIG_LONG_TAG
    ReadLong (pFileBufferInfo, &ulDsigTag, ulOffset);
    ulOffset += sizeof_long;

    // If we have a version 1.0 or greater header with DSIG fields,
    // read in the Dsig fields
    if ((pTTCHeader->ulVersion >= TTC_VERSION_1_0) &&
        (ulDsigTag == DSIG_LONG_TAG)) {

        pTTCHeader->ulDsigTag = ulDsigTag;

        if (pFileBufferInfo->ulBufferSize <
            (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG + pTTCHeader->ulDirCount * sizeof(ULONG))) {
#if MSSIPOTF_ERROR
            SignError ("File not large enough to hold the entire v1.0 header with DSIG fields.", NULL, FALSE);
#endif
            rv = MSSIPOTF_E_FILETOOSMALL;
            goto done;
        }
        ReadLong (pFileBufferInfo, &(pTTCHeader->ulDsigLength), ulOffset);
        ulOffset += sizeof_long;
        ReadLong (pFileBufferInfo, &(pTTCHeader->ulDsigOffset), ulOffset);
        ulOffset += sizeof_long;
    } else {
        pTTCHeader->ulDsigTag = 0;
        pTTCHeader->ulDsigLength = 0;
        pTTCHeader->ulDsigOffset = 0;
    }

    rv = S_OK;

done:
    return rv;
}


//
// Write the header table of a TTC file.
// The TTC file is assumed to have SIZEOF_TTC_HEADER_TABLE_1_0_DSIG
// bytes earmarked for the header.
//
HRESULT WriteTTCHeaderTable (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                             TTC_HEADER_TABLE *pTTCHeader)
{
    HRESULT rv = E_FAIL;

    ULONG ulOffset = 0;
    ULONG sizeof_long = sizeof(ULONG);
    ULONG i;

	//// Check that the file is at least SIZEOF_TTC_HEADER_TABLE_1_0_DSIG long.
	//// (If the file is too small, then we might try to read beyond
	//// the end of the file when we try to read the offset table to
	//// retrieve the number of tables.)
	if (pFileBufferInfo->ulBufferSize < SIZEOF_TTC_HEADER_TABLE_1_0_DSIG) {
#if MSSIPOTF_ERROR
		SignError ("File too small (not big enough for TTC header).", NULL, FALSE);
#endif
		rv = MSSIPOTF_E_FILETOOSMALL;
		goto done;
	}

    WriteLong (pFileBufferInfo, pTTCHeader->TTCtag, ulOffset);
    ulOffset += sizeof_long;
    WriteLong (pFileBufferInfo, pTTCHeader->ulVersion, ulOffset);
    ulOffset += sizeof_long;
    WriteLong (pFileBufferInfo, pTTCHeader->ulDirCount, ulOffset);
    ulOffset += sizeof_long;

    for (i = 0; i < pTTCHeader->ulDirCount; i++) {
        WriteLong (pFileBufferInfo, pTTCHeader->pulDirOffsets[i], ulOffset);
        ulOffset += sizeof_long;
    }

    if (pFileBufferInfo->ulBufferSize <
        (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG + pTTCHeader->ulDirCount * sizeof(ULONG))) {
#if MSSIPOTF_ERROR
        SignError ("File not large enough to hold the entire v2.0 header.", NULL, FALSE);
#endif
        rv = MSSIPOTF_E_FILETOOSMALL;
        goto done;
    }

    WriteLong (pFileBufferInfo, pTTCHeader->ulDsigTag, ulOffset);
    ulOffset += sizeof_long;
    WriteLong (pFileBufferInfo, pTTCHeader->ulDsigLength, ulOffset);
    ulOffset += sizeof_long;
    WriteLong (pFileBufferInfo, pTTCHeader->ulDsigOffset, ulOffset);
    ulOffset += sizeof_long;

    rv = S_OK;

done:
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\ttcinfo.h ===
//
// ttcinfo.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Data structures and #defines associates
// with TTC files.
//
// Functions exported:
//
//   IsTTCFile_handle
//   IsTTCFile_memptr
//   GetTTCInfo
//   PrintTTCHeader
//   PrintTTCBlocks
//   FreeTTCInfo
//

#ifndef _TTCINFO_H
#define _TTCINFO_H


#include <windows.h>

#include "signglobal.h"

#include "fileobj.h"
#include "dsigTable.h"
#include "subset.h"

// Tag for the TTC header
#define TTC_HEADER_LONG_TAG 0x74746366
// Version number for TTCs
#define TTC_VERSION_1_0     0x00010000
// #define TTC_VERSION_2_0     0x00020000

typedef struct
{
    ULONG                   TTCtag;             // should be 'ttcf'
    ULONG                   ulVersion;          // TTC_VERSION_1_0
    ULONG                   ulDirCount;         // number of table directories
    ULONG                   *pulDirOffsets;     // array of offsets to table directories
    ULONG                   ulDsigTag;          // if there is a DSIG table, this value should equal DSIG_LONG_TAG
    ULONG                   ulDsigLength;       // length of the DSIG table in the TTC
    ULONG                   ulDsigOffset;       // offset from beginning of file to the DSIG table
} TTC_HEADER_TABLE;

// SIZEOF_TTC_HEADER_TABLE_xxxx does NOT include pulDirOffsets
#define SIZEOF_TTC_HEADER_TABLE_1_0 12
#define SIZEOF_TTC_HEADER_TABLE_1_0_DSIG 24


// TABLE_BLOCK has the same layout as a DIRECTORY.
// A TABLE_BLOCK can represent an Offset Table (tag = 0).
typedef struct
{
    ULONG                   ulTag;              // tag of the table. 0 means it's an Offset Table
    ULONG                   ulChecksum;
    ULONG                   ulOffset;
    ULONG                   ulLength;
} TABLE_BLOCK;


typedef struct
{
    TTFACC_FILEBUFFERINFO   *pFileBufferInfo;   // TrueType Collection file
	TTC_HEADER_TABLE        *pHeader;           // TrueType Collection header table
    ULONG                   *pulOffsetTables;    // array of offsets to offset tables in the TTC file
    ULONG                   ulNumBlocks;        // Number of table blocks in ppBlockSorted
    TABLE_BLOCK             **ppBlockSorted;    // array of pointers to blocks, sorted by offset
    TABLE_BLOCK             *pBlocks;           // array of blocks
} TTCInfo;


BOOL IsTTCFile_handle (HANDLE hFile,
                       BOOL fTableChecksum,
                       HRESULT *phrError);

BOOL IsTTCFile_memptr (BYTE *pbMemPtr,
                       ULONG cbMemPtr,
                       BOOL fTableChecksum,
                       HRESULT *phrError);

BOOL IsTTCFile (CFileObj *pFileObj,
                BOOL fTableChecksum,
                HRESULT *phrError);

HRESULT GetTTCInfo (BYTE *pbFile, ULONG cbFile, TTCInfo *pTTCInfo);

void PrintTTCHeader (TTC_HEADER_TABLE *pTTCHeader);

void PrintTTCBlocks (TTCInfo *pTTCInfo);

void FreeTTCInfo (TTCInfo *pTTCInfo);

HRESULT InitTTCStructures (BYTE *pbFile,
					   ULONG cbFile,
					   TTCInfo **ppTTCInfo,
					   CDsigTable **ppDsigTable);

HRESULT CompressTTCBlocks (TTCInfo *pTTCInfo);

void SortTTCBlocksByOffset (TTCInfo *pTTCInfo);

HRESULT ReadTTCHeaderTable (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                            TTC_HEADER_TABLE *pTTCHeader);

HRESULT WriteTTCHeaderTable (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                             TTC_HEADER_TABLE *pTTCHeader);

#endif // _TTCINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\ttfinfo.h ===
//
// ttfinfo.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Data structures and #defines associates
// with TTF files.
//
// Functions exported:
//   IsTTFFile_handle
//   IsTTFFile_memptr
//   IsTTFFile
//   NullRealloc
//   FreeFileBufferInfo
//   FreeTTFInfo
//   GetTTFInfo
//   OffsetCmp
//   InitTTFStructures
//   WriteNewFile
//

#ifndef _TTFINFO_H
#define _TTFINFO_H


#include <windows.h>

#include "signglobal.h"

#include "fileobj.h"
#include "dsigTable.h"
#include "subset.h"


// Values for the fAddDsig parameter in WriteNonDsigTables
#define ADD_DSIG_TABLE 1
#define KEEP_DSIG_TABLE 0
#define DELETE_DSIG_TABLE -1


// A TTFInfo structure holds pointers to the file buffer associated
// with a TTF file, along with pointers to commonly-needed structures
// within the file, such as the offset table and the directory.
typedef struct
{
    TTFACC_FILEBUFFERINFO	*pFileBufferInfo;	// TrueType file
	OFFSET_TABLE			*pOffset;			// TrueType offset table
    DIRECTORY				*pDirectory;		// TrueType directory table
    DIRECTORY				**ppDirSorted;		// array of pointers to directory entries,
												//   sorted by offset
} TTFInfo;

// for the magic number comparison in IsTTFFile
#define MAGIC_NUMBER 0x5F0F3CF5

BOOL IsTTFFile_handle (HANDLE hFile,
                       BOOL fTableChecksum,
                       HRESULT *phrError);

BOOL IsTTFFile_memptr (BYTE *pbMemPtr,
                       ULONG cbMemPtr,
                       BOOL fTableChecksum,
                       HRESULT *phrError);

BOOL IsTTFFile (CFileObj *pFileObj,
                BOOL fTableChecksum,
                HRESULT *phrError);

void * NullRealloc (void * pb, size_t n);

void FreeFileBufferInfo (TTFACC_FILEBUFFERINFO *pFileBufferInfo);

void FreeTTFInfo (TTFInfo *pTTFInfo);

HRESULT GetTTFInfo (UCHAR *pFile, ULONG cbFile, TTFInfo *pttfInfo);

int __cdecl OffsetCmp (const void *elem1, const void *elem2);

HRESULT CheckTTF (TTFInfo *pttfInfo,
                  BOOL fTableChecksum);

HRESULT InitTTFStructures (BYTE *pbFile,
                           ULONG cbFile,
                           TTFInfo **ppTTFInfo,
                           CDsigTable **ppDsigTable);


HRESULT WriteNewFile (TTFInfo *pttfInfoOld,
                      CDsigTable *pDsigTable,
                      HANDLE hNewFile);

HRESULT WriteNonDsigTables (TTFInfo *pttfInfoOld,
                            USHORT numTablesNew,
                            SHORT fAddDsig,
                            TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
                            ULONG *pulOffset);

HRESULT GetNewTTFFileSize (TTFInfo *pttfInfoOld,
                           USHORT numTablesNew,
                           CDsigTable *pDsigTable,
                           ULONG *pulFileSize);

#endif // _TTFINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\utilsign.h ===
//
// utilsign.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//

#ifndef _UTIL_H
#define _UTIL_H



#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>

#include "signglobal.h"

#include "subset.h"


HRESULT MapFile (HANDLE hFile,
                 HANDLE *phMapFile,
                 BYTE **ppFile,
                 ULONG *pcbFile,
                 DWORD dwProtect,
                 DWORD dwAccess);

HRESULT UnmapFile (HANDLE hMapFile, BYTE *pFile);

HRESULT ReadOffsetTable (TTFACC_FILEBUFFERINFO *pInputFileBufferInfo,
                         OFFSET_TABLE *pOffTab);

HRESULT ReadOffsetTableOffset (TTFACC_FILEBUFFERINFO *pInputFileBufferInfo,
                               ULONG ulOffset,
                               OFFSET_TABLE *pOffTab);

HRESULT WriteOffsetTable (OFFSET_TABLE *pOffTab,
                          TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo);

void CalcOffsetTable (OFFSET_TABLE *pOffsetTable);

HRESULT ReadDirectoryEntry (TTFACC_FILEBUFFERINFO *pInputFileBufferInfo,
                            ULONG ulOffset,
                            DIRECTORY *pDir);

HRESULT WriteDirectoryEntry (DIRECTORY *pDir,
                             TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
                             ULONG ulOffset);

HRESULT ShiftDirectory (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                        USHORT numTables,
                        ULONG ulNewTag);

void PrintOffsetTable (OFFSET_TABLE *pOffTab);

void PrintDirectoryHeading ();

void PrintDirectoryEntry (DIRECTORY *pDirectory);

void PrintSortedDirectory (DIRECTORY **ppDirSorted, USHORT numTables);

void PrintBytes (BYTE *pb, DWORD cb);

void PrintAbbrevBytes (BYTE *pb, DWORD cb);

HRESULT WszToMbsz (LPSTR psz, int *pcbsz, LPCWSTR pwsz);

LONG ByteCmp (BYTE *pbLeft, BYTE *pbRight, DWORD cbToCompare);

void ByteCopy (BYTE *dest, BYTE *source, ULONG n);

ULONG CheckSumBlock(
	UCHAR *pbyData, 
	LONG lBytesRead );

USHORT near_2 (USHORT n);

USHORT log_2 (USHORT n);


#endif  // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sip\authattr.cpp ===
//
// authattr.cpp
//
// (c) 1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions that return authenticated attributes
// to be inserted into a PKCS #7 packet.
//
// These functions are intended to be exported so that
// the -j and -jp options to signcode.exe work.
//
// When signcode.exe runs, just before it calls the Create
// function, it calls InitAttr, GetAttrEx, and ExitAttr (in that
// order).  After the Put function, signcode.exe calls
// InitAttr, ReleaseAttr, and ExitAttr (in that order).
//
// NOTE: All allocations and deallocations of memory involving the
//   the authenticated and unauthenticated attributes (the return
//   values for GetAttrEx) use LocalAlloc and LocalFree, respectively.
//   The reason is that since signcode unloads this DLL, any memory
//   allocated by this DLL is lost.  By using LocalAlloc, the allocated
//   memory persists across loads and unloads of this DLL.
//
//   Memory that is not needed across loads and unloads of this DLL
//   can just use malloc and free as usual.
//
//
// Functions defined in this file:
//   PrintAttributes
//   bHintsChecked
//   GetFontAuthAttrValueFromAuthAttrs
//   GetAuthAttrsFromPkcs
//   GetFontAuthAttrValueFromDsig
//   mssipotf_ValidHintsPolicy
//   mssipotf_VerifyPolicyAttr
//   mssipotf_VerifyPolicyPkcs
//   SetStructuralChecksBit
//   SetHintsCheckBit
//   FormatFontAuthAttr
//   InitAttr
//   GetAttrEx
//   ReleaseAttr
//   ExitAttr
//

#include "authattr.h"
#include "sipobotf.h"
#include "sipobttc.h"
#include "isfont.h"
#include "ttcinfo.h"
#include "ttfinfo.h"
#include "utilsign.h"
#ifdef __cplusplus
extern "C" {
#endif
#include "fsverify.h"
#ifdef __cplusplus
}
#endif

#include "signglobal.h"
#include "signerr.h"


// Given an array of bits, return TRUE if and only if the
// bit corresponding to structure checking is set.
BOOL WINAPI bStructureChecked (BYTE *pbBits, DWORD cbBits)
{
    BOOL rv = FALSE;

    // make sure there are at least 8 bits in the array
    if (cbBits >= 1) {
        rv = pbBits[0] & MSSIPOTF_STRUCT_CHECK_BIT;
    }

    return rv;
}


//
// Given a pointer a block of memory that is structured as
// a CRYPT_ATTRIBUTES structure, print out the structure.
//
HRESULT PrintAttributes (BYTE *pbAuth, ULONG cbAuth)
{
    HRESULT rv = S_OK;

    PCRYPT_ATTRIBUTES pAttributes = NULL;
    DWORD i, j;

    pAttributes = (PCRYPT_ATTRIBUTES) pbAuth;
    for (i = 0; i < pAttributes->cAttr; i++) {

        //// print out each attribute
        printf ("Attribute #%d:\n", i);
        // oid
        printf ("  pszObjId  = %s\n", pAttributes->rgAttr[i].pszObjId);
        // num values
        printf ("  cValue    = %d\n", pAttributes->rgAttr[i].cValue);
        // values
        for (j = 0; j < pAttributes->rgAttr[i].cValue; j++) {
            printf ("  value %d   =\n", j);
            PrintBytes (pAttributes->rgAttr[i].rgValue[j].pbData,
                        pAttributes->rgAttr[i].rgValue[j].cbData);
        }

        printf ("\n");
    }

    return rv;
}


// Given an array of authenticated attributes, return the
// value of the font authenticated attribute.  This value is
// an array of bits.  We assume that the number of bits in
// the array is a multiple of 8.
HRESULT GetFontAuthAttrValueFromAuthAttrs (PCRYPT_ATTRIBUTES pAttrs,
                                           BYTE **ppbBits,
                                           DWORD *pcbBits)
{
    HRESULT rv = E_FAIL;

    DWORD i;
    DWORD cbEncodedData = 0;
    BYTE *pbEncodedData = NULL;

    DWORD cbBits = 0;
    BYTE *pbBits = NULL;

    CRYPT_BIT_BLOB *pBitBlob = NULL;

    //// find the font integrity attribute (szOID_FontIntegrity)
    for (i = 0; i < pAttrs->cAttr; i++) {
        if (!strcmp (pAttrs->rgAttr[i].pszObjId,
                     szOID_FontIntegrity )) {
            // we found the right attribute
            break;
        }
    }

    if (i == pAttrs->cAttr) {
        // attribute not found
        rv = MSSIPOTF_E_FAILED_POLICY;
        goto done;
    }

    //// ASSERT: At this point, i is the smallest index into the array
    //// of attributes such that the ith attribute is the FontIntegrity
    //// attribute.

    //// Extract the blob that is the encoded data.
    if (pAttrs->rgAttr[i].cValue >= 1) {
        cbEncodedData = pAttrs->rgAttr[i].rgValue[0].cbData;
        pbEncodedData = pAttrs->rgAttr[i].rgValue[0].pbData;
    } else {
        // error: no values for the attribute
        rv = MSSIPOTF_E_FAILED_POLICY;
        goto done;
    }

	if (!CryptDecodeObject(CRYPT_ASN_ENCODING,
                        X509_BITS,
		                pbEncodedData,
                        cbEncodedData,
                        0,
		                NULL,
		                &cbBits )) {

        rv = MSSIPOTF_E_FAILED_POLICY;
        goto done;
	}

    if ((pbBits = (BYTE *) malloc (cbBits)) == NULL) {
        rv = E_OUTOFMEMORY;
        goto done;
    }
    
    if (!CryptDecodeObject(CRYPT_ASN_ENCODING,
                        X509_BITS,
		                pbEncodedData,
                        cbEncodedData,
                        0,
		                pbBits,
		                &cbBits )) {

        rv = MSSIPOTF_E_FAILED_POLICY;
        goto done;
    }

    //// ASSERT: pbBits and cbBits now contain the (unencoded) bits
    //// that were originally encoded using CryptEncodeObject.

    pBitBlob = (CRYPT_BIT_BLOB *) pbBits;

    *pcbBits = pBitBlob->cbData;
    if ((*ppbBits = (BYTE *) LocalAlloc (LPTR, *pcbBits)) == NULL) {
        rv = E_OUTOFMEMORY;
        goto done;
    }
    memset (*ppbBits, 0, *pcbBits);
    memcpy (*ppbBits, pBitBlob->pbData, *pcbBits);
    
    rv = S_OK;

done:

    if (pbBits) {
        free (pbBits);
    }

    return rv;
}


// Given a cryptographic provider, the encoding type,
// the index of the signer, and a PKCS #7 packet (specified
// by dwLength and pbData), return an array of authenticated
// atributes.
HRESULT GetAuthAttrsFromPkcs (HCRYPTPROV hProv,
                              DWORD dwEncodingType,
                              DWORD dwIndex,
                              DWORD dwDataLen,
                              BYTE *pbData,
                              BYTE **ppbAuth)
{

    HRESULT rv = E_FAIL;

    HCRYPTMSG hMsg = NULL;
    DWORD cbAuth = 0;

    // prepare the message to be decoded
    if (!(hMsg = CryptMsgOpenToDecode (dwEncodingType,
                                       0,
                                       0,   // dwMsgType
                                       hProv,
                                       NULL,
                                       NULL))) {
        goto done;
    }

    // associate the pkcs #7 packet with hMsg
    if (!CryptMsgUpdate (hMsg,
                         pbData,
                         dwDataLen,
                         TRUE)) {
#if MSSIPOTF_DBG
        printf ("error: 0x%x\n", GetLastError());
#endif
        goto done;
    }

    // get the size of the auth attributes
    if (!CryptMsgGetParam (hMsg,
                           CMSG_SIGNER_AUTH_ATTR_PARAM,
                           dwIndex,
                           NULL,
                           &cbAuth)) {
        goto done;
    }

    if ((*ppbAuth = (BYTE *) malloc (cbAuth)) == NULL) {
        goto done;
    }

    // get the authenticate attributes
    if (!CryptMsgGetParam (hMsg,
                           CMSG_SIGNER_AUTH_ATTR_PARAM,
                           dwIndex,
                           *ppbAuth,
                           &cbAuth)) {
        goto done;
    }

#if MSSIPOTF_DBG 
    if (PrintAttributes (*ppbAuth, cbAuth) != S_OK) {
        goto done;
    }
#endif

    rv = S_OK;

done:
    if (hMsg) {
        CryptMsgClose (hMsg);
    }

    return rv;
}   
    
// Given a pointer and length of a DSIG table, return the value of
// the font authenticated attribute.  This is expressed as an array
// of bytes, which is interpreted as a bit array.  We assume that
// the number of bits is a multiple of 8.
HRESULT WINAPI GetFontAuthAttrValueFromDsig (BYTE *pbDsig,
                                             DWORD cbDsig,
                                             BYTE **ppbBits,
                                             DWORD *pcbBits)
{
    HRESULT rv = E_FAIL;

    TTFACC_FILEBUFFERINFO fileBufferInfo;
    CDsigTable dsigTable;
    ULONG ulDsigOffset = 0;
    CDsigSignature *pDsigSignature = NULL;
    CDsigSig *pDsigSig = NULL;

    HCRYPTPROV hProv = NULL;
    OTSIPObjectOTF dummySIPObj;

    BYTE *pbAuth = NULL;

    // initialize return values
    *ppbBits = NULL;
    *pcbBits = 0;

    // initialize file buffer
    fileBufferInfo.puchBuffer = pbDsig;
    fileBufferInfo.ulBufferSize = cbDsig;
    fileBufferInfo.ulOffsetTableOffset = 0;  // not used
    fileBufferInfo.lpfnReAllocate = NULL;

    // read in the DSIG table into the dsigTable object
    if ((rv = dsigTable.Read (&fileBufferInfo, &ulDsigOffset, cbDsig)) != S_OK) {
       goto done; 
    }

    // extract the first signature
    if ((pDsigSignature = dsigTable.GetDsigSignature (0)) == NULL) {
        rv = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    // extract the PKCS #7 packet
    if ((pDsigSig = pDsigSignature->GetDsigSig()) == NULL) {
        rv = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    // extract the authenticated attributes
    if ((rv = dummySIPObj.GetDefaultProvider (&hProv)) != S_OK) {
        goto done;
    }

    if ((rv = GetAuthAttrsFromPkcs (hProv,
                                    CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    0,      // first signer
                                    pDsigSig->GetSignatureSize(),
                                    pDsigSig->GetSignature(),
                                    &pbAuth) ) != S_OK) {
        goto done;
    }

    if ((rv = GetFontAuthAttrValueFromAuthAttrs ((PCRYPT_ATTRIBUTES) pbAuth,
                                                 ppbBits,
                                                 pcbBits)) != S_OK) {
        goto done;
    }

    rv = S_OK;

done:

    if (pbAuth) {
        free (pbAuth);
    }

    if (hProv) {
        CryptReleaseContext (hProv, 0);
    }

    return rv;
}


// Given a pointer to an array of attributes, return S_OK
// if and only if the attributes satisfy the ValidHints policy.
// The ValidHints policy is:
//   There is a font integrity attribute (szOID_FontIntegrity)
//   and both bit 0 and bit 1 of the first value of the attribute
//   are set to 1.  This means that the signer claims that the
//   font passes the structural checks and the hints checks.
HRESULT mssipotf_ValidHintsPolicy (PCRYPT_ATTRIBUTES pAttrs)
{
    HRESULT rv = S_OK;

    BYTE *pbBits = NULL;
    DWORD cbBits = 0;

    if ((rv = GetFontAuthAttrValueFromAuthAttrs (pAttrs,
                                                 &pbBits,
                                                 &cbBits)) != S_OK) {
        goto done;
    }

    // Now we test to see if the policy is satisfied
    if ( (cbBits == 0) ||
         !((pbBits[0] & MSSIPOTF_STRUCT_CHECK_BIT) &&
           (pbBits[0] & MSSIPOTF_HINTS_CHECK_BIT)) ) {

        rv = MSSIPOTF_E_FAILED_POLICY;
        goto done;
    }


done:
    if (pbBits) {
        free (pbBits);
    }

    return rv;
}


// Given a pointer to an array of attributes and a policy,
// return S_OK if and only if the values in the authenticated
// attributes satisfy the policy.
HRESULT mssipotf_VerifyPolicyAttr (PCRYPT_ATTRIBUTES pbAuth, ULONG ulPolicy)
{
    HRESULT rv = S_OK;

    switch (ulPolicy) {

        case VALID_HINTS_POLICY:
            rv = mssipotf_ValidHintsPolicy (pbAuth);
            break;

        default: // unknown policy
            rv = MSSIPOTF_E_FAILED_POLICY;
            break;
    }

    return rv;
}


// Return TRUE if and only if the authenticated attributes
// in the given PKCS #7 packet (specified by dwDataLen and pbData)
// satisfy the policy specified by ulPolicy.
BOOL mssipotf_VerifyPolicyPkcs (IN      SIP_SUBJECTINFO *pSubjectInfo,
                                IN      DWORD           dwEncodingType,
                                IN      DWORD           dwIndex,
                                IN      DWORD           dwDataLen,
                                IN      BYTE            *pbData,
                                IN      ULONG           ulPolicy)
{
    BOOL rv = FALSE;
    HCRYPTPROV hProvT = NULL;
    BYTE *pbAuth = NULL;    // the auth attr array

    BOOL fDefaultProvider = FALSE;
    OTSIPObjectOTF dummySIPObj;  // dummy SIP object, used to generate the default CSP


	// Find the cryptographic provider
    hProvT = pSubjectInfo->hProv;
    // get the default cryptographic provider if one isn't provided
    if (!(hProvT)) {
        if (dummySIPObj.GetDefaultProvider(&hProvT) != S_OK) {
            goto done;
        }
        fDefaultProvider = TRUE;
    }

    // get the authenticated attributes
    if (GetAuthAttrsFromPkcs (hProvT,
                              dwEncodingType,
                              dwIndex,
                              dwDataLen,
                              pbData,
                              &pbAuth) != S_OK) {
        goto done;
    }

    //// See if the policy is satisfied
    if (mssipotf_VerifyPolicyAttr ((PCRYPT_ATTRIBUTES) pbAuth, ulPolicy)
            != S_OK) {
        goto done;
    }

    rv = TRUE;

done:

    if (pbAuth) {
        free (pbAuth);
    }

    if (hProvT && fDefaultProvider) {
        CryptReleaseContext (hProvT, 0);
    }

    return rv;
}


// Set the structural check bit in the bit blob
void SetStructuralChecksBit (CRYPT_BIT_BLOB *pBitBlob)
{
    pBitBlob->pbData [0] |= MSSIPOTF_STRUCT_CHECK_BIT;
}


// Set the hints check bit in the bit blob
void SetHintsCheckBit (CRYPT_BIT_BLOB *pBitBlob)
{
    pBitBlob->pbData [0] |= MSSIPOTF_HINTS_CHECK_BIT;
}



// Given the ASN bits corresponding to the value of the font attribute,
// format it so that it looks readable.
// The attribute value is an ASN BIT_STRING.  We will format it
// as a byte string of the form xx xx xx xx, where xx is the value
// of the byte in hexadecimal.
//
// Only the pbEncoded, cbEncoded, pbFormat, and pcbFormat parameters
// are needed and used.
BOOL
WINAPI
FormatFontAuthAttr (DWORD dwCertEncodingType,
                    DWORD dwFormatType,
                    DWORD dwFormatStrType,
                    void *pFormatStruct,
                    LPCSTR lpszStructType,
                    const BYTE *pbEncoded,
                    DWORD cbEncoded,
                    void *pbFormat,
                    DWORD *pcbFormat)
{
    LPWSTR pwszBuffer = NULL;

    DWORD cbHeaderBitString = 3;

    DWORD dwBufferSize = 0;
    DWORD dwBufferIndex = 0;
    ULONG i = 0;
    BYTE currentNibble = 0;

    // Determine the size of the formatted string.
    // We lop off the first three bytes of the BIT_STRING.
    // (Those three bytes are the type ID (BIT_STRING), the
    // length of the string, and the number of unused bits.)
    // For each byte remaining byte, we need three wchar's,
    // two to print out the byte and one space.  Plus, we need
    // one more wchar for the null character terminator.
    if (cbEncoded >= cbHeaderBitString) {
        dwBufferSize = ((cbEncoded - cbHeaderBitString) * 3 + 1)* sizeof(WCHAR);
    } else {
        dwBufferSize = sizeof(WCHAR);
    }

    // if the caller asks only for the size, return dwBufferSize.
    if ((pcbFormat != NULL) && (pbFormat == NULL)) {
        *pcbFormat = dwBufferSize;
        return TRUE;
    }

    // allocate and initialize formatted string
    if ((pwszBuffer = (LPWSTR) malloc (dwBufferSize)) == NULL) {
        SetLastError (E_OUTOFMEMORY);
        return FALSE;
    }
    memset (pwszBuffer, 0, dwBufferSize);


    // starting with the third byte of pbEncoded, convert each byte
    // to its hexidecimal character and add it to the buffer
    for (i = cbHeaderBitString; i < cbEncoded; i++) {

        // upper 4 bits of the byte
        currentNibble = (pbEncoded[i] & 0xf0) >> 4;
        if (currentNibble <= 9) {
            pwszBuffer [dwBufferIndex] = currentNibble + wcZero;
        } else {
            pwszBuffer [dwBufferIndex] = (currentNibble - 10) + wcA;
        }
        dwBufferIndex++;

        // lower 4 bits of the byte
        currentNibble = (pbEncoded[i] & 0x0f);
        if (currentNibble <= 9) {
            pwszBuffer [dwBufferIndex] = currentNibble + wcZero;
        } else {
            pwszBuffer [dwBufferIndex] = (currentNibble - 10) + wcA;
        }
        dwBufferIndex++;

        // add a space after every byte
        pwszBuffer [dwBufferIndex] = wcSpace;
        dwBufferIndex++;
    }

    // null character terminator
    pwszBuffer[dwBufferIndex] = wcNull;

    memcpy (pbFormat, pwszBuffer,
        (*pcbFormat >= dwBufferSize) ? dwBufferSize : *pcbFormat);

    free (pwszBuffer);

    if (*pcbFormat < dwBufferSize) {
        *pcbFormat = dwBufferSize;
        SetLastError (ERROR_MORE_DATA);
        return FALSE;
    }

    return TRUE;
}


HRESULT WINAPI InitAttr(LPWSTR pInitString) 
{

#if MSSIPOTF_DBG
    DbgPrintf ("Entering InitAttr.\n");
    if (pInitString)
        DbgPrintf ("This is InitAttr's parameter: '%S'\n", pInitString);
#endif

    return S_OK;
}


//
// Given a file name, return the FontIntegrity authenticated attribute
// with the correct bits set if and only if the font file passes
// the hints test.  dwFlags and pInitString are ignored.
//
HRESULT WINAPI GetAttrEx (DWORD dwFlags,
                          LPWSTR pwszFileName,
                          LPWSTR pInitString,                           
                          PCRYPT_ATTRIBUTES  *ppsAuthenticated,
                          PCRYPT_ATTRIBUTES  *ppsUnauthenticated)
{
    HRESULT     hr = E_FAIL;

    // these variables are used in case we are on a Win95 system
    // and so the file name needs to be multibyte (not wide char)
    LPSTR pszFileName = NULL;
    int cbszFileName = 0;

    // pSubjectObject is like that in the SIP functions, except
    // that the SIP_SUBJECTINFO structure is never used to
    // figure out how to initialize it.
    OTSIPObject *pSubjectObj = NULL;
    int FileTag = FAIL_TAG;

    LPOSVERSIONINFO lpVersionInfo = NULL;
    HANDLE      hFile = NULL;
    CFileHandle *pFileHandleObj = NULL;
    TTCInfo     *pTTCInfo = NULL;

    BYTE        *pbIntegrityAuth = NULL;
    DWORD       cbIntegrityAuth = 0;
//    BYTE        *pbIntegrityUnauth = NULL;
//    DWORD       cbIntegrityUnauth = 0;
    CRYPT_BIT_BLOB  bitBlob;
    DWORD       cbOID = 0;      // never used
    LPSTR       pbOID = NULL;

    DWORD       i;


#if MSSIPOTF_DBG
    DbgPrintf ("Entering GetAttrEx.\n");
#endif

    bitBlob.cbData = 0;
    bitBlob.pbData = NULL;
    bitBlob.cUnusedBits = 0;

    if (!ppsAuthenticated || !ppsUnauthenticated) {
        return E_INVALIDARG;
    }

    *ppsAuthenticated =
        (PCRYPT_ATTRIBUTES) LocalAlloc (LPTR, sizeof(CRYPT_ATTRIBUTES));

    *ppsUnauthenticated =
        (PCRYPT_ATTRIBUTES) LocalAlloc (LPTR, sizeof(CRYPT_ATTRIBUTES));

    // check for a malloc error
    if (!(*ppsAuthenticated) || !(*ppsUnauthenticated)) {
        hr = E_OUTOFMEMORY;
        goto done;
    } else {
        // initialize pointers to NULL
        (*ppsAuthenticated)->cAttr = 0;
        (*ppsAuthenticated)->rgAttr = NULL;
        (*ppsUnauthenticated)->cAttr = 0;
        (*ppsUnauthenticated)->rgAttr = NULL;
    }


    //// Create a handle for the file.
    // set up the version info data structure
    if ((lpVersionInfo =
        (OSVERSIONINFO *) malloc (sizeof (OSVERSIONINFO))) == NULL) {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    memset (lpVersionInfo, 0, sizeof (OSVERSIONINFO));
    lpVersionInfo->dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

    // get the version
    if (GetVersionEx (lpVersionInfo) == 0) {
        hr = E_FAIL;
        goto done;
    }

    // If Windows 95, then call CreateFile.
    // If NT, then call CreateFileW.
    switch (lpVersionInfo->dwPlatformId) {

        case VER_PLATFORM_WIN32_NT:

            // Create a file object for the file.
            if ((hFile = CreateFileW (pwszFileName,
                                      GENERIC_READ,
                                      FILE_SHARE_READ,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL)) == INVALID_HANDLE_VALUE) {
                hr = MSSIPOTF_E_FILE;
                goto done;
            }
            break;

        case VER_PLATFORM_WIN32_WINDOWS:
        default:

            // convert the wide character string to an ANSI string
            if ((hr = WszToMbsz (NULL, &cbszFileName, pwszFileName)) != S_OK) {
                goto done;
            }

            if (cbszFileName <= 0) {
                hr = MSSIPOTF_E_FILE;
                goto done;
            }
            if ((pszFileName = (CHAR *) malloc (cbszFileName)) == NULL) {
                hr = E_OUTOFMEMORY;
                goto done;
            }
            if ((hr = WszToMbsz (pszFileName, &cbszFileName, pwszFileName)) != S_OK) {
                goto done;
            }

            if (cbszFileName <= 0) {
                hr = MSSIPOTF_E_FILE;
                goto done;
            }
            
            // Create a file object for the file.
            if ((hFile = CreateFile (pszFileName,
                                     GENERIC_READ,
                                     FILE_SHARE_READ,
                                     NULL,
                                     OPEN_EXISTING,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL)) == INVALID_HANDLE_VALUE) {
                hr = MSSIPOTF_E_FILE;
                goto done;
            }

            break;
    }
#if MSSIPOTF_DBG
//            DbgPrintf ("Opening file in authattr.cpp.  hFile = %d.\n", hFile);
#endif


    if ((pFileHandleObj =
            (CFileHandle *) new CFileHandle (hFile, TRUE)) == NULL) {
#if MSSIPOTF_DBG
	    DbgPrintf ("Error in new CFileHandle.\n");
#endif
        hr = E_OUTOFMEMORY;
        goto done;
    }
	if (pFileHandleObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ) != S_OK) {
#if MSSIPOTF_DBG
	DbgPrintf ("Error in MapFile.\n");
#endif
        hr = MSSIPOTF_E_FILE;
		goto done;
	}


    //// Call IsFontFile to determine what kind of file it is
    if ((FileTag = IsFontFile (pFileHandleObj)) == FAIL_TAG) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in IsFontFile.\n");
#endif
        hr = MSSIPOTF_E_NOT_OPENTYPE;
        goto done;
    }
    
    switch (FileTag) {
        case OTF_TAG:
            if ((pSubjectObj = (OTSIPObject *) new OTSIPObjectOTF) == NULL) {
                hr = E_OUTOFMEMORY;
                goto done;
            }
            if (!IsTTFFile (pFileHandleObj, TRUE, &hr)) {
                goto done;
            }

            if (ExistsGlyfTable (pFileHandleObj,
                                 OTF_TAG,
                                 0)) {
#if !NO_FSTRACE
                if (fsv_VerifyImage((unsigned char *) pFileHandleObj->GetFileObjPtr(),
                        pFileHandleObj->GetFileObjSize(),
                        0,
                        NULL) != FSV_E_NONE) {
#if MSSIPOTF_ERROR
                    SignError ("Did not pass hints check.", NULL, FALSE);
#endif
                    hr = MSSIPOTF_E_FAILED_HINTS_CHECK;
                    goto done;
                }
#endif  // !NO_FSTRACE
            }
            break;

        case TTC_TAG:
            if ((pSubjectObj = (OTSIPObject *) new OTSIPObjectTTC) == NULL) {
                hr = E_OUTOFMEMORY;
                goto done;
            }
            if (!IsTTCFile (pFileHandleObj, TRUE, &hr)) {
                goto done;
            }
		    // Extract the DSIG table (create default DsigTable if it didn't exist)
            if ((pTTCInfo = (TTCInfo *) new TTCInfo) == NULL) {
                hr = E_OUTOFMEMORY;
                goto done;
            }
		    if ((hr = GetTTCInfo (pFileHandleObj->GetFileObjPtr(),
                            pFileHandleObj->GetFileObjSize(),
                            pTTCInfo) != S_OK)) {
#if MSSIPOTF_DBG
			    DbgPrintf ("Error in GetTTCInfo.\n");
#endif
			    goto done;
		    }
            //// For each OTF file with TrueType information in it (this is
            //// determined by examining the first four bytes of the Offset Table
            //// of the TTF), call the hints check.
            for (i = 0; i < pTTCInfo->pHeader->ulDirCount; i++) {

                // Run the OTF file through the hints check if it has TrueType
                // information in it
                if (ExistsGlyfTable (pFileHandleObj,
                                     TTC_TAG,
                                     i)) {

#if !NO_FSTRACE

                    // the file has TrueType info in it
#if MSSIPOTF_DBG
                    DbgPrintf ("Calling hints check on file #%d\n", i);
#endif

                    if (fsv_VerifyImage ((unsigned char *) pFileHandleObj->GetFileObjPtr(),
                            pFileHandleObj->GetFileObjSize(),
                            i,
                            NULL) != FSV_E_NONE) {
#if MSSIPOTF_ERROR
                        SignError ("Did not pass hints check.", NULL, FALSE);
#endif
                        hr = MSSIPOTF_E_FAILED_HINTS_CHECK;
                        goto done;
                    }

#endif  // !NO_FSTRACE
                }

            }
            break;

        default:
            // bad value for FileTag
            goto done;
            break;
    }

    // ASSERT: If it's neither a OTF nor a TTC (or if the new operation
    // fails), then pSubjectObj is still NULL.


    //// Initialize the bitBlob data structure
    bitBlob.cbData = SIZEOF_INTEGRITY_FLAGS;
    if ((bitBlob.pbData = (BYTE *) malloc (bitBlob.cbData)) == NULL) {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    bitBlob.cUnusedBits = 0;
    // Initialize the bits
    for (i = 0; i < bitBlob.cbData; i++) {
        bitBlob.pbData [i] = 0;
    }

    // Set the flags for structural checks and hints check
    SetStructuralChecksBit (&bitBlob);
    SetHintsCheckBit (&bitBlob);
    

    //// Encode the data
    //// (See wincrypt.h to see the definition of X509_BITS
    //// and the corresponding data structure (CRYPT_BIT_BLOB).)
    if (!CryptEncodeObject(CRYPT_ASN_ENCODING,
                        X509_BITS,
                        &bitBlob,
                        NULL,
                        &cbIntegrityAuth )) {

		hr = HRESULT_FROM_WIN32(GetLastError());
		goto done;
	}


	if ((pbIntegrityAuth = (BYTE *) LocalAlloc (LPTR, cbIntegrityAuth)) == NULL) {
		hr = E_OUTOFMEMORY;
		goto done;
	}
	   
	if (!CryptEncodeObject(CRYPT_ASN_ENCODING,
                        X509_BITS,
		                &bitBlob,
		                pbIntegrityAuth,
		                &cbIntegrityAuth )) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
	}

    if ((pbOID = (LPSTR) LocalAlloc (LPTR, strlen(szOID_FontIntegrity)+1)) == NULL) {
		hr = E_OUTOFMEMORY;
		goto done;
	}

    memcpy (pbOID, szOID_FontIntegrity, strlen(szOID_FontIntegrity)+1); 

    (*ppsAuthenticated)->cAttr = 1;
    (*ppsAuthenticated)->rgAttr =
        (PCRYPT_ATTRIBUTE) LocalAlloc (LPTR, sizeof(CRYPT_ATTRIBUTE));

    (*ppsUnauthenticated)->cAttr = 0;
    (*ppsUnauthenticated)->rgAttr = NULL;

    // check for a malloc error
    if (!((*ppsAuthenticated)->rgAttr)) {

        hr = E_OUTOFMEMORY;
        goto done;
    } else {

        // initialize pointers to NULL
        for (i = 0; i < (*ppsAuthenticated)->cAttr; i++) {
            (*ppsAuthenticated)->rgAttr[i].pszObjId = NULL;
            (*ppsAuthenticated)->rgAttr[i].cValue = 0;
            (*ppsAuthenticated)->rgAttr[i].rgValue = NULL;
        }

        for (i = 0; i < (*ppsUnauthenticated)->cAttr; i++) {
            (*ppsUnauthenticated)->rgAttr[i].pszObjId = NULL;
            (*ppsUnauthenticated)->rgAttr[i].cValue = 0;
            (*ppsUnauthenticated)->rgAttr[i].rgValue = NULL;
        }
    }

    // set the first authenticated attribute 
    (*ppsAuthenticated)->rgAttr[0].pszObjId = pbOID;
    (*ppsAuthenticated)->rgAttr[0].cValue = 1;  
    (*ppsAuthenticated)->rgAttr[0].rgValue =
        (PCRYPT_ATTR_BLOB) LocalAlloc (LPTR, sizeof(CRYPT_ATTR_BLOB));

    // check for a malloc error
    if(!((*ppsAuthenticated)->rgAttr[0].rgValue)) {
        hr = E_OUTOFMEMORY;
        goto done;
    } 

    (*ppsAuthenticated)->rgAttr[0].rgValue[0].cbData = cbIntegrityAuth;
    (*ppsAuthenticated)->rgAttr[0].rgValue[0].pbData = pbIntegrityAuth;

#if MSSIPOTF_DBG 
    if (PrintAttributes ((BYTE *) *ppsAuthenticated, 0) != S_OK) {
        goto done;
    }
#endif

/*
	// set the first unauthenticated attribute 
	(*ppsUnauthenticated)->rgAttr[0].pszObjId = pbOID;
	(*ppsUnauthenticated)->rgAttr[0].cValue = 1;  
	(*ppsUnauthenticated)->rgAttr[0].rgValue = 
        (PCRYPT_ATTR_BLOB) LocalAlloc (LPTR, sizeof(CRYPT_ATTR_BLOB));

    // check for a malloc error
	if(!((*ppsUnauthenticated)->rgAttr[0].rgValue)) {
 		hr = E_OUTOFMEMORY;
		goto done;
	}

    if ((pbIntegrityUnauth = (BYTE *) LocalAlloc (LPTR, cbIntegrityAuth)) == NULL) {
 		hr = E_OUTOFMEMORY;
		goto done;
	}

    memcpy (pbIntegrityUnauth, pbIntegrityAuth, cbIntegrityAuth);
    cbIntegrityUnauth = cbIntegrityAuth;

	(*ppsUnauthenticated)->rgAttr[0].rgValue[0].cbData = cbIntegrityUnauth;
	(*ppsUnauthenticated)->rgAttr[0].rgValue[0].pbData = pbIntegrityUnauth;
*/

    hr = S_OK;

done:
    if (lpVersionInfo) {
        free (lpVersionInfo);
    }

    if (pszFileName) {
        free (pszFileName);
    }

    delete pSubjectObj;

    FreeTTCInfo (pTTCInfo);

    if (bitBlob.pbData) {
        free ((HLOCAL) bitBlob.pbData);
    }

    if (pFileHandleObj) {
        pFileHandleObj->UnmapFile();
        pFileHandleObj->CloseFileHandle();
    }
    delete pFileHandleObj;

    if (hr != S_OK) {
        ReleaseAttr (*ppsAuthenticated, *ppsUnauthenticated);
        *ppsAuthenticated = NULL;
        *ppsUnauthenticated = NULL;
    }

#if MSSIPOTF_DBG
    DbgPrintf ("Exiting GetAttrEx.\n");
#endif

    return hr;
}


HRESULT WINAPI ReleaseAttr (PCRYPT_ATTRIBUTES psAuthenticated,
                            PCRYPT_ATTRIBUTES psUnauthenticated)
{
    DWORD dwIndex = 0;

#if MSSIPOTF_DBG
    printf ("Entering ReleaseAttr.\n");
#endif

    if (psAuthenticated) {
        for (dwIndex = 0; dwIndex < psAuthenticated->cAttr; dwIndex++) {
            // free each attribute's dynamic memory
            if (psAuthenticated->rgAttr[dwIndex].rgValue->pbData) {
                LocalFree ((HLOCAL) psAuthenticated->rgAttr[dwIndex].rgValue->pbData);
                psAuthenticated->rgAttr[dwIndex].rgValue->pbData = NULL;
            }

            if (psAuthenticated->rgAttr[dwIndex].pszObjId) {
                LocalFree ((HLOCAL) psAuthenticated->rgAttr[dwIndex].pszObjId);
                psAuthenticated->rgAttr[dwIndex].pszObjId = NULL;
            }


            if (psAuthenticated->rgAttr[dwIndex].rgValue) {
                LocalFree ((HLOCAL) psAuthenticated->rgAttr[dwIndex].rgValue);
                psAuthenticated->rgAttr[dwIndex].rgValue = NULL;
            }
		}

        if (psAuthenticated->cAttr) {
            LocalFree ((HLOCAL) psAuthenticated->rgAttr);
            psAuthenticated->rgAttr = NULL;
        }

        LocalFree ((HLOCAL) psAuthenticated);
        psAuthenticated = NULL;
    }

    if (psUnauthenticated) {
        for (dwIndex = 0; dwIndex < psUnauthenticated->cAttr; dwIndex++) {
            //free the attributes
            if (psUnauthenticated->rgAttr[dwIndex].rgValue->pbData) {
                LocalFree ((HLOCAL) psUnauthenticated->rgAttr[dwIndex].rgValue->pbData);
                psUnauthenticated->rgAttr[dwIndex].rgValue->pbData = NULL;
            }

            if (psUnauthenticated->rgAttr[dwIndex].pszObjId) {
                LocalFree ((HLOCAL) psUnauthenticated->rgAttr[dwIndex].pszObjId);
                psUnauthenticated->rgAttr[dwIndex].pszObjId = NULL;
            }

            if (psUnauthenticated->rgAttr[dwIndex].rgValue) {
                LocalFree ((HLOCAL) psUnauthenticated->rgAttr[dwIndex].rgValue);
                psUnauthenticated->rgAttr[dwIndex].rgValue = NULL;
            }
        }

        if (psUnauthenticated->cAttr) {
            LocalFree ((HLOCAL) psUnauthenticated->rgAttr);
            psUnauthenticated->rgAttr = NULL;
        }

        LocalFree ((HLOCAL) psUnauthenticated);
        psUnauthenticated = NULL;
    }

#if MSSIPOTF_DBG
    printf ("Exiting ReleaseAttr.\n");
#endif

    return S_OK;
}



HRESULT	WINAPI ExitAttr() {
#if MSSIPOTF_DBG
    DbgPrintf ("Entering and exiting ExitAttr.\n");
#endif
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\utilsign.cpp ===
//
// utilsign.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Useful utility functions for printing out
// objects, or reading and writing objects
// from/to a file.
//
// Various assumptions made throughout the code:
// 1. Files are never more than 4 GB in size.
//
// Functions in this file:
//   MapFile
//   UnmapFile
//   ReadOffsetTable
//   ReadOffsetTableOffset
//   WriteOffsetTable
//   CalcOffsetTable
//   ReadDirectoryEntry
//   WriteDirectoryEntry
//   ShiftDirectory
//   PrintOffsetTable
//   PrintDirectoryHeading
//   PrintDirectoryEntry
//   PrintSortedDirectory
//   PrintBytes
//   PrintAbbrevBytes
//   WszToMbsz
//   ByteCmp
//   ByteCopy
//   near_2
//   log_2
//


#include "utilsign.h"
#include "cryptutil.h"
#include "signerr.h"




// Map a file.  If *pcbFile == 0, then the size of the
// file is used in the calls to map the file and its file
// size is returned in *pcbFile.
// Return as parameters the map handle and the view.
HRESULT MapFile (HANDLE hFile,
                 HANDLE *phMapFile,
                 BYTE **ppFile,
                 ULONG *pcbFile,
                 DWORD dwProtect,
                 DWORD dwAccess)
{
	HRESULT fReturn = E_FAIL;

	HANDLE hMapFile;
	BYTE *pFile;
	ULONG cbFile;

	if ((hMapFile =
			CreateFileMapping (hFile,
							NULL,
							dwProtect,
							0,
							*pcbFile,
							NULL)) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Error in CreateFileMapping.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_FILE;
		goto done;
	}
	if ((pFile = (BYTE *) MapViewOfFile (hMapFile,
										dwAccess,
										0,
										0,
										*pcbFile)) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Error in MapViewOfFile.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_FILE;
        goto done;
	}
	if (*pcbFile == 0) {
		if ((cbFile = GetFileSize (hFile, NULL)) == 0xFFFFFFFF) {
#if MSSIPOTF_ERROR
			SignError ("Error in GetFileSize.", NULL, TRUE);
#endif
			fReturn = MSSIPOTF_E_FILE;
            goto done;
		}
	    *pcbFile = cbFile;
	}

	// Set the return values
	*phMapFile = hMapFile;
	*ppFile = pFile;

	fReturn = S_OK;
done:
	return fReturn;
}


// Unmap a file.  This function should be called with the
// same objects as when MapFile was called.
HRESULT UnmapFile (HANDLE hMapFile, BYTE *pbFile)
{
    if (hMapFile)
		CloseHandle (hMapFile);

	if (pbFile)
		UnmapViewOfFile (pbFile);

	return S_OK;
}
	

//
// Read an offset table from a file buffer.
//
HRESULT ReadOffsetTable (TTFACC_FILEBUFFERINFO *pInputFileBufferInfo,
                         OFFSET_TABLE *pOffTab)
{
	HRESULT fReturn = E_FAIL;
	USHORT usBytesRead;

	ReadGeneric (pInputFileBufferInfo,
				 (BYTE *) pOffTab,
				 SIZEOF_OFFSET_TABLE,
				 OFFSET_TABLE_CONTROL,
				 0,		// offset table begins at offset 0
				 &usBytesRead);
	assert (usBytesRead == SIZEOF_OFFSET_TABLE);
    if (usBytesRead != SIZEOF_OFFSET_TABLE) {
		fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    fReturn = S_OK;

done:
	return fReturn;
}


//
// Read an offset table from a file buffer at a given offset.
//
HRESULT ReadOffsetTableOffset (TTFACC_FILEBUFFERINFO *pInputFileBufferInfo,
                               ULONG ulOffset,
                               OFFSET_TABLE *pOffTab)
{
	HRESULT fReturn = E_FAIL;
	USHORT usBytesRead;

	ReadGeneric (pInputFileBufferInfo,
				 (BYTE *) pOffTab,
				 SIZEOF_OFFSET_TABLE,
				 OFFSET_TABLE_CONTROL,
				 ulOffset,      // offset table begins at offset 0
				 &usBytesRead);
	assert (usBytesRead == SIZEOF_OFFSET_TABLE);
    if (usBytesRead != SIZEOF_OFFSET_TABLE) {
		fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    fReturn = S_OK;

done:
	return fReturn;
}


//
// Write an offset table to a file buffer.
//
HRESULT WriteOffsetTable (OFFSET_TABLE *pOffTab,
                          TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo)
{
	HRESULT fReturn = E_FAIL;
	USHORT usBytesWritten;

	WriteGeneric (pOutputFileBufferInfo,
				  (BYTE *) pOffTab,
				  SIZEOF_OFFSET_TABLE,
				  OFFSET_TABLE_CONTROL,
				  0,		// offset table begins at offset 0
				  &usBytesWritten);
	assert (usBytesWritten == SIZEOF_OFFSET_TABLE);
    if (usBytesWritten != SIZEOF_OFFSET_TABLE) {
		fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    fReturn = S_OK;

done:
	return fReturn;
}


//
// Given an offset table, assume that the number of tables in
// the numTables field is correct and compute the other
// offset table values (searchRange, entrySelector, and rangeShift).
void CalcOffsetTable (OFFSET_TABLE *pOffsetTable)
{
    USHORT usNumTables = pOffsetTable->numTables;

    // searchRange
    pOffsetTable->searchRange = 16 * near_2 (usNumTables);

    // entrySelector
	pOffsetTable->entrySelector = log_2 (usNumTables);

    // rangeShift
	pOffsetTable->rangeShift = (USHORT) 
		((16 * usNumTables) - pOffsetTable->searchRange);
}


//
// Read a directory entry from an input file buffer at the given offset.
//
HRESULT ReadDirectoryEntry (TTFACC_FILEBUFFERINFO *pInputFileBufferInfo,
                            ULONG ulOffset,
                            DIRECTORY *pDir)
{
	HRESULT fReturn = E_FAIL;
	USHORT usBytesRead;

	ReadGeneric (pInputFileBufferInfo,
				 (BYTE *) pDir,
				 SIZEOF_DIRECTORY,
				 DIRECTORY_CONTROL,
				 ulOffset,
				 &usBytesRead);
	assert (usBytesRead == SIZEOF_DIRECTORY);
    if (usBytesRead != SIZEOF_DIRECTORY) {
		fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    fReturn = S_OK;

done:
	return fReturn;
}


//
// Write a directory entry to an output file buffer at the given offset.
//
HRESULT WriteDirectoryEntry (DIRECTORY *pDir,
                             TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
                             ULONG ulOffset)
{
	HRESULT fReturn = E_FAIL;
	USHORT usBytesWritten;

	WriteGeneric (pOutputFileBufferInfo,
				 (BYTE *) pDir,
				 SIZEOF_DIRECTORY,
				 DIRECTORY_CONTROL,
				 ulOffset,
				 &usBytesWritten);
	assert (usBytesWritten == SIZEOF_DIRECTORY);
    if (usBytesWritten != SIZEOF_DIRECTORY) {
		fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    fReturn = S_OK;

done:
	return fReturn;
}


//
// The input is a directory whose last directory entry is garbage, and
// the tag for a new table.
//
// The result is a directory with the new table's entry in its alphabetically
// correct position.  The new table's tag is correct, but its other data is
// garbage.
//
// The TTF file must have (at least) numTables directory entries.
// numTables must be at least 2.
//
HRESULT ShiftDirectory (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                        USHORT numTables,
                        ULONG ulNewTag)
{
	HRESULT fReturn = E_FAIL;
	
	ULONG ulDirStartOffset;	// offset where the table of directory entries begins
	DIRECTORY dir;
	ULONG ulOffset;

	BOOL fDone;

	if (numTables <= 1) {
		fReturn = S_OK;
        goto done;
	}

	ulDirStartOffset = SIZEOF_OFFSET_TABLE;

	//// Starting with the last valid entry, slide them down one position
	//// until we find the right place for the new entry.
	ulOffset = SIZEOF_OFFSET_TABLE + (numTables - 2) * SIZEOF_DIRECTORY;

	fDone = (ulOffset < ulDirStartOffset);  // flag to break out of the while loop
	while (!fDone) {
		ReadDirectoryEntry (pFileBufferInfo, ulOffset, &dir);
		if (ulNewTag < dir.tag) {
			WriteDirectoryEntry (&dir, pFileBufferInfo, ulOffset + SIZEOF_DIRECTORY);
			// reminder: ulOffset is unsigned, so we need the condition
			// ulOffset < ulOffset - SIZEOF_DIRECTORY
			fDone = (ulOffset < ulDirStartOffset) ||
				(ulOffset < (ulOffset - SIZEOF_DIRECTORY));
			ulOffset -= SIZEOF_DIRECTORY;
		} else {
			break;
		}
	}
	ulOffset += SIZEOF_DIRECTORY;

	// ulOffset now points to the right place for the new entry
	dir.tag = ulNewTag;
	dir.checkSum = 0;
	dir.offset = 0;
	dir.length = 0;
	WriteDirectoryEntry (&dir, pFileBufferInfo, ulOffset);

    fReturn = S_OK;

done:
	return fReturn;
}


//
// Print the offset table.
//
void PrintOffsetTable (OFFSET_TABLE *pOffTab)
{
#if MSSIPOTF_DBG
	DbgPrintf ("Offset table:\n");
	DbgPrintf ("Version       : 0x%x\n", pOffTab->version);
	DbgPrintf ("Num Tables    : %d\n", pOffTab->numTables);
	DbgPrintf ("Search Range  : %d\n", pOffTab->searchRange);
	DbgPrintf ("Entry Selector: %d\n", pOffTab->entrySelector);
	DbgPrintf ("Range shift   : %d\n", pOffTab->rangeShift);
	DbgPrintf ("\n");
#endif
}


//
// Print a heading for a sirectory listing.
//
void PrintDirectoryHeading ()
{
#if MSSIPOTF_DBG
	DbgPrintf ("Directory:\n");
	DbgPrintf ("\t  Tag                CkSum      Offset      Length\n");
#endif
}


//
// Print out a directory entry.
//
void PrintDirectoryEntry (DIRECTORY *pDirectory)
{
#if MSSIPOTF_DBG
	CHAR pszTag[5];

	ConvertLongTagToString (pDirectory->tag, pszTag);
	DbgPrintf ("%.4s = %#8x  %10u  %9u  %9u\n",
		pszTag,
		pDirectory->tag,
		pDirectory->checkSum,
		pDirectory->offset,
		pDirectory->length);
#endif
}


//
// Print out the directory, given an array of pointers
// to directory entries.
//
void PrintSortedDirectory (DIRECTORY **ppDirSorted, USHORT numTables)
{
#if MSSIPOTF_DBG
	USHORT i;

	for (i = 0; i < numTables; i++) {
		DbgPrintf ("Sorted directory entry %d:\n", i);
		DbgPrintf ("  Address : 0x%x\n", &ppDirSorted[i]);
		DbgPrintf ("  Tag     : 0x%x\n", ppDirSorted[i]->tag);
		DbgPrintf ("  CheckSum: %d\n", ppDirSorted[i]->checkSum);
		DbgPrintf ("  Offset  : %d\n", ppDirSorted[i]->offset);
		DbgPrintf ("  Length  : %d\n", ppDirSorted[i]->length);
		DbgPrintf ("\n");
	}
#endif
}


//
// Print out a stream of bytes, given by the
// specified number of bytes.  Each byte is printed
// in hexadecimal form.
//
void PrintBytes (BYTE *pb, DWORD cb)
{
	for (UINT i = 0; i < cb; i++) {

		if ((i % 8) == 0) {
			DbgPrintf ("%3d: ", i);
		}
		if ((UINT) pb[i] < 16) {
			DbgPrintf ("0");
		}
		DbgPrintf ("%x ", (UINT) pb[i]);

		// print out a newline every 8 bytes
		if ((i % 8) == 7) {
			DbgPrintf ("\n");
		}
	}
	DbgPrintf ("\n");
}


// Print out first 16 bytes and last 16 bytes of a stream
// of bytes.  If the number of bytes is less than or equal
// to 32, then the entire block is printed out.
void PrintAbbrevBytes (BYTE *pb, DWORD cb)
{
#if MSSIPOTF_DBG
    if (cb <= 32) {
        PrintBytes (pb, cb);
    } else {
        DbgPrintf ("    First 16 bytes:\n");
        PrintBytes (pb, 16);
        DbgPrintf ("    Last 16 bytes:\n");
        PrintBytes (pb + RoundToLongWord (cb - 16),
            16 - (RoundToLongWord (cb) - cb));
    }
#endif
}


//
// Convert a wide character string to a multibyte character string.
// If psz is NULL, then the function returns *pcbsz, the size of the
// multibyte string.
//
HRESULT WszToMbsz (LPSTR psz, int *pcbsz, LPCWSTR pwsz)
{
    HRESULT hr = S_OK;

    *pcbsz = WideCharToMultiByte (CP_ACP, // current code page
                                  0,      // dwFlags
                                  pwsz,
                                  -1,     // let it determine length of wide string
                                  NULL,
                                  0,
                                  NULL,
                                  NULL);
    if (*pcbsz <= 0) {
        hr = MSSIPOTF_E_FILE;
        goto done;
    }

    if (psz != NULL) {
        *pcbsz = WideCharToMultiByte (CP_ACP, // current code page
                                      0,      // dwFlags
                                      pwsz,
                                      -1,     // let it determine length of wide string
                                      psz,
                                      *pcbsz,
                                      NULL,
                                      NULL);

        if (*pcbsz <= 0) {
            hr = MSSIPOTF_E_FILE;
            goto done;
        }
    }

done:
    return hr;            
}


//
// Compare the two byte streams for the specified number of bytes.
// If the left stream is lexicographically earlier than the right stream,
//   then return -1.
// If the right stream is earlier, return 1.
// If they are equal, return 0.
//
LONG ByteCmp (BYTE *pbLeft, BYTE *pbRight, DWORD cbToCompare)
{
	DWORD i;

	for (i = 0; i < cbToCompare; i++) {
		if (pbLeft[i] < pbRight[i]) {
			return -1;
		} else if (pbLeft[i] > pbRight[i]) {
			return 1;
		}
	}
	// All the bytes are equal
	return 0;
}


//
// Copy n bytes from the source to the destination
//
void ByteCopy (BYTE *dest, BYTE *source, ULONG n)
{
	ULONG i;

	for (i = 0; i < n; i++, source++, dest++) {
		*dest = *source;
	}
}


// Calculate the check sum of a block of data

ULONG CheckSumBlock(
	UCHAR *pbyData, 
	LONG lBytesRead )
{
	ULONG checkSum;
	ULONG ulTemp;
	UCHAR *pbyStop; 

	pbyStop = pbyData + lBytesRead;
	checkSum = 0;

	while (pbyData < pbyStop)
	{
		ulTemp = *pbyData++;
		ulTemp <<=8;
		ulTemp += *pbyData++;
		ulTemp <<=8;
		ulTemp += *pbyData++;
		ulTemp <<=8;
		ulTemp += *pbyData++;
		checkSum += ulTemp;
	}
	return checkSum;
}


// Compute the nearest power of 2 of a USHORT (that does
// not exceed the given integer).
// If the input is 0, then this function returns 0.
USHORT near_2 (USHORT n)
{
	USHORT rv = 1;

    if (n == 0)
        return 0;

    n >>= 1;
	for (; n > 0; n >>= 1, rv <<= 1) {
		;
	}
	return rv;
}


//
// Given a USHORT, compute and return the floor of its
// logarithm base 2.
// If the input is 0, this function returns 0.
//
USHORT log_2 (USHORT n)
{
	USHORT rv = 1;
    USHORT usPowerOf2 = 4;

    if (n <= 1)
        return 0;
    if (n >= 0x8000)
        return 0x8000;

    while (n >= usPowerOf2) {
		usPowerOf2 *= 2;
		rv++;
	}
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sip\mssipotf.h ===
//
// mssipotf.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//

#ifndef _MSSIPOTF_H
#define _MSSIPOTF_H


#define     MY_NAME     L"MSSIPOTF.DLL"

// Arrays of bytes that correspond to the first four bytes
// of an OTF file and a TTC file.
// OTFTagV1: 
extern BYTE OTFTagV1[4];
extern BYTE OTFTagOTTO[4];
extern BYTE OTFTagV2[4];
extern BYTE OTFTagTRUE[4];
extern BYTE TTCTag[4];

// SubjectIDs for mssipotf_CreateSubjectObject
#define     MSSIPOTF_ID_NONE                   0       // file only types
#define     MSSIPOTF_ID_FONT                   1
// #define     MSSIPOTF_ID_TTC                    2


// New GUID for FONT files -- dchinn
// SIP v2.0 Font Image == {6D875CC1-EF35-11d0-9438-00C04FD42C3B}
#define CRYPT_SUBJTYPE_FONT_IMAGE                                    \
            { 0x6d875cc1,                                           \
              0xef35,                                               \
              0x11d0,                                               \
              { 0x94, 0x38, 0x0, 0xc0, 0x4f, 0xd4, 0x2c, 0x3b }     \
            }

/*
// New GUID for TTC files -- dchinn
// SIP v2.0 TTC Image = {69986620-5BB5-11d1-A3E3-00C04FD42C3B}
#define CRYPT_SUBJTYPE_TTC_IMAGE                                    \
            { 0x69986620,                                           \
              0x5bb5,                                               \
              0x11d1,                                               \
              { 0xa3, 0xe3, 0x0, 0xc0, 0x4f, 0xd4, 0x2c, 0x3b }     \
            }
*/

#ifdef __cplusplus
extern "C"
{
#endif

BOOL WINAPI SIPIsOTFFile (IN HANDLE hFile, OUT GUID *pgSubject);

BOOL WINAPI OTSIPGetSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                                   OUT     DWORD           *pdwEncodingType,
                                   IN      DWORD           dwIndex,
                                   IN OUT  DWORD           *pdwDataLen,
                                   OUT     BYTE            *pbData);

BOOL WINAPI OTSIPPutSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                                   IN      DWORD           dwEncodingType,
                                   OUT  DWORD           *pdwIndex,
                                   IN      DWORD           dwDataLen,
                                   IN      BYTE            *pbData);

BOOL WINAPI OTSIPRemoveSignedDataMsg (IN SIP_SUBJECTINFO  *pSubjectInfo,
                                      IN DWORD            dwIndex);

BOOL WINAPI OTSIPCreateIndirectData (IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                     IN OUT  DWORD               *pdwDataLen,
                                     OUT     SIP_INDIRECT_DATA   *psData);

BOOL WINAPI OTSIPVerifyIndirectData (IN SIP_SUBJECTINFO      *pSubjectInfo,
                                     IN SIP_INDIRECT_DATA    *psData);


#ifdef __cplusplus
}
#endif

#endif  // _MSSIPOTF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sip\authattr.h ===
//
// authattr.h
//
// (c) 1998. Microsoft Corporation.
// Author: Donald Chinn
//
// This file contains the function definitions for
// InitAttr, GetAttrEx, ReleaseAttr, and ExitAttr.
// These functions are used to generate an array
// of authenticated attributes and an array of
// unauthenticated attributes that are to be inserted
// into a font file's digital signature.
//
// This file also contains the OIDs for font-related
// attributes.
//
// Functions exported:
//   bStructureChecked
//   GetFontAuthAttrValueFromDsig
//   mssipotf_VerifyPolicyPkcs
//   InitAttr
//   GetAttrEx
//   ReleaseAttr
//   ExitAttr
//
// The function prototypes for
//   bStructureChecked
//   GetFontAuthAttrValueFromDsig
// can be found in \nt\private\inc\mssipotx.h
//


#ifndef _AUTHATTR_H
#define _AUTHATTR_H

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <assert.h>
#include <wincrypt.h>
// #include <base64.h>
// #include "resource.h"

#include <mssip.h>

#include "mssipotx.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
// Given an array of bits, return TRUE if and only if the
// bit corresponding to structure checking is set.
BOOL WINAPI bStructureChecked (BYTE *pbBits, DWORD cbBits);


// Given a pointer and length of a DSIG table, return the value of
// the font authenticated attribute.  This is expressed as an array
// of bytes, which is interpreted as a bit array.  We assume that
// the number of bits is a multiple of 8.
HRESULT WINAPI GetFontAuthAttrValueFromDsig (BYTE *pbDsig,
                                             DWORD cbDsig,
                                             BYTE **ppbBits,
                                             DWORD *pcbBits);
*/
                                      

// Given the ASN bits corresponding to the value of the font attribute,
// format it so that it looks readable.
// The attribute value is an ASN BIT_STRING.  We will format it
// as a byte string of the form xx xx xx xx, where xx is the value
// of the byte in hexadecimal.
BOOL
WINAPI
FormatFontAuthAttr (DWORD dwCertEncodingType,
                    DWORD dwFormatType,
                    DWORD dwFormatStrType,
                    void *pFormatStruct,
                    LPCSTR lpszStructType,
                    const BYTE *pbEncoded,
                    DWORD cbEncoded,
                    void *pbFormat,
                    DWORD *pcbFormat);

                    
// mssipotf_VerifyPolicyPkcs
//
// This function returns TRUE if and only if there is the
// font integrity authenticated attribute (szOID_FontIntegrity,
// defined below) in the given PKCS #7 packet.
//
BOOL mssipotf_VerifyPolicyPkcs (IN      SIP_SUBJECTINFO *pSubjectInfo,
                                IN      DWORD           dwEncodingType,
                                IN      DWORD           dwIndex,
                                IN      DWORD           dwDataLen,
                                IN      BYTE            *pbData,
                                IN      ULONG           ulPolicy);



//+-----------------------------------------------------------------------
//  
//  InitAttr:
//
//	    This function should be called as the first call to the dll.
//
//	    The dll has to use the input memory allocation and free routine
//      to allocate and free all memories, including internal use.
//      It has to handle when pInitString==NULL.
//
//------------------------------------------------------------------------

HRESULT WINAPI  
InitAttr(LPWSTR			pInitString); //IN: the init string
	
typedef HRESULT (*pInitAttr)(LPWSTR	pInitString);

//+-----------------------------------------------------------------------
//  
//  GetAttr:
//
//
//      Return authenticated and unauthenticated attributes.  
//
//      *ppsAuthenticated and *ppsUnauthenticated should never be NULL.
//      If there is no attribute, *ppsAuthenticated->cAttr==0.
// 
//------------------------------------------------------------------------

/*
HRESULT  WINAPI
GetAttr(PCRYPT_ATTRIBUTES  *ppsAuthenticated,		// OUT: Authenticated attributes added to signature
        PCRYPT_ATTRIBUTES  *ppsUnauthenticated);	// OUT: Uunauthenticated attributes added to signature
	
typedef HRESULT (*pGetAttr)(PCRYPT_ATTRIBUTES  *ppsAuthenticated,
                            PCRYPT_ATTRIBUTES  *ppsUnauthenticated);	
*/

//+-----------------------------------------------------------------------
//  
//  GetAttrEx:
//
//
//		Return authenticated and unauthenticated attributes.  
//
//      *ppsAuthenticated and *ppsUnauthenticated should never be NULL.
//      If there is no attribute, *ppsAuthenticated->cAttr==0.
// 
//------------------------------------------------------------------------

HRESULT  WINAPI
GetAttrEx(  DWORD               dwFlags,                //In:   Reserved.  Set to 0.
            LPWSTR              pwszFileName,           //In:   The file name to sign
            LPWSTR			    pInitString,            //In:   The init string, same as the input parameter to InitAttr
            PCRYPT_ATTRIBUTES  *ppsAuthenticated,		// OUT: Authenticated attributes added to signature
            PCRYPT_ATTRIBUTES  *ppsUnauthenticated);	// OUT: Uunauthenticated attributes added to signature
	
typedef HRESULT (*pGetAttrEx)(DWORD                 dwFlags,
                              LPWSTR                pwszFileName,
                              LPWSTR			    pInitString,
                              PCRYPT_ATTRIBUTES     *ppsAuthenticated,		
							  PCRYPT_ATTRIBUTES     *ppsUnauthenticated);	



//+-----------------------------------------------------------------------
//  
//  ReleaseAttrs:
//
//
//	    Release authenticated and unauthenticated attributes
//	    returned from GetAttr(). 
//
//      psAuthenticated and psUnauthenticated should never be NULL.
// 
//------------------------------------------------------------------------

HRESULT  WINAPI
ReleaseAttr(PCRYPT_ATTRIBUTES  psAuthenticated,		// OUT: Authenticated attributes to be released
            PCRYPT_ATTRIBUTES  psUnauthenticated);	// OUT: Uunauthenticated attributes to be released
	
typedef HRESULT (*pReleaseAttr)(PCRYPT_ATTRIBUTES  psAuthenticated,
                                PCRYPT_ATTRIBUTES  psUnauthenticated);	


//+-----------------------------------------------------------------------
//  
//  ExitAttr:
//
//	    This function should be called as the last call to the dll
//------------------------------------------------------------------------
HRESULT	WINAPI
ExitAttr( );	

typedef HRESULT (*pExitAttr)();

#ifdef __cplusplus
}
#endif



////  Font OID subtree
#define szOID_Font          "1.3.6.1.4.1.311.40"

// Font OID for font integrity (structural checks and hints check)
//
// The corresponding data structure for the OID is CRYPT_BIT_BLOB.
// The number of bytes in the bit blob is defined by SIZEOF_INTEGRITY_FLAGS.
// The meaning of the bits is as follows:
// First byte:
//   bit 0 (lowest order bit): passed structural checks
//   bit 1 : passed hints checks (or hints check is not applicable (such
//             is the case for OpenType fonts with no glyf table)
//
// All other bits should be set to zero.
//
#define szOID_FontIntegrity "1.3.6.1.4.1.311.40.1"

// size (in bytes) of the data structure that holds
// all of the integrity flags
#define SIZEOF_INTEGRITY_FLAGS  4

// Flags for Byte 0 of the four-byte bit blob
#define MSSIPOTF_STRUCT_CHECK_BIT  0x01
#define MSSIPOTF_HINTS_CHECK_BIT 0x02


// #defines for formatting:
// wszFormatDll: name of the DLL where the formatting function is
// szFormatFontAttrFunc: name of the formatting function
#define wszFormatDll L"mssipotf.dll"
#define szFormatFontAttrFunc "FormatFontAuthAttr"

// Unicode char values for space, zero, and A for bytes to
// hexidecimal conversion
#define wcSpace L' '
#define wcZero L'0'
#define wcA L'A'
#define wcNull L'\0'

//// policy numbers

// The ValidHints policy is:
//   There is a font integrity attribute (szOID_FontIntegrity)
//   and both bit 0 and bit 1 of the first value of the attribute
//   are set to 1.  This means that the signer claims that the
//   font passes the structural checks and the hints checks.
#define VALID_HINTS_POLICY      0


// If NO_POLICY_CHECK is 1, then
// Put will insert the signature regardless
// of any policy decisions about what tests
// a font must pass in order to be signed
#define NO_POLICY_CHECK 0


#endif // _AUTHATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sip\mssipotx.h ===
//
// mssipotx.h
//
// (c) 1998. Microsoft Corporation.
// Author: Donald Chinn
//
// This file contains function prototypes
// for components external to mssipotf.
//
// These functions are:
//   bStructureChecked
//   GetFontAuthAttrValueFromDsig
//


#ifndef _MSSIPOTX_H
#define _MSSIPOTX_H

#include <windows.h>


#ifdef __cplusplus
extern "C" {
#endif


// Given an array of bits, return TRUE if and only if the
// bit corresponding to structure checking is set.
BOOL WINAPI bStructureChecked (BYTE *pbBits, DWORD cbBits);


// Given a pointer and length of a DSIG table, return the value of
// the font authenticated attribute.  This is expressed as an array
// of bytes, which is interpreted as a bit array.  We assume that
// the number of bits is a multiple of 8.
HRESULT WINAPI GetFontAuthAttrValueFromDsig (BYTE *pbDsig,
                                             DWORD cbDsig,
                                             BYTE **ppbBits,
                                             DWORD *pcbBits);

#ifdef __cplusplus
}
#endif

#endif // _MSSIPOTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sip\mssipotf.cpp ===
//
// mssipotf.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include    <windows.h>
#include    <wintrust.h>
#include    <assert.h>
#include    <softpub.h>
#include    <sipbase.h>
#include    <mssip.h>

// objbase.h defines the operator ==
// for GUIDs
#include    <objbase.h>

#include "signglobal.h"

#include "mssipotf.h"
#include "fileobj.h"
#include "sipob.h"
#include "sipobotf.h"
#include "sipobttc.h"
#include "isfont.h"
#include "ttfinfo.h"
#include "ttcinfo.h"
#include "utilsign.h"
#include "authattr.h"

#include "signerr.h"


OTSIPObject *mssipotf_CreateSubjectObject_Full (SIP_SUBJECTINFO *pSubjectInfo, BOOL fTableChecksum, HRESULT *phr);
OTSIPObject *mssipotf_CreateSubjectObject_Quick (SIP_SUBJECTINFO *pSubjectInfo);

#if MSSIPOTF_DBG
void TestMapping (HANDLE hFile);
#endif

//
//  the entries in SubjectsGuid MUST be in the same
//  relative position and correlate with those in the
//  SubjectsID.
//
static const GUID SubjectsGuid[] =
                    {
                        CRYPT_SUBJTYPE_FONT_IMAGE
//                        CRYPT_SUBJTYPE_TTC_IMAGE
                    };

static const UINT SubjectsID[] = 
                    {
                        MSSIPOTF_ID_FONT,
//                        MSSIPOTF_ID_TTC,
                        MSSIPOTF_ID_NONE     // MUST be at the end!
                    };
                

// Extract the dwIndex-th signature from the file
BOOL WINAPI OTSIPGetSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                                   OUT     DWORD           *pdwEncodingType,
                                   IN      DWORD           dwIndex,
                                   IN OUT  DWORD           *pdwDataLen,
                                   OUT     BYTE            *pbData)
{
	BOOL rv = FALSE; // return value
    HRESULT hr = S_OK;

    OTSIPObject *pSubjectObj = NULL;

#if PERF
    _int64 liStart;
    _int64 liNow;
    _int64 liFreq;
    _int64 liDelta;

    QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
#endif


#if MSSIPOTF_DBG


    DbgPrintf ("Called OTSIPGetSignedDataMsg.\n");
    DbgPrintf ("dwIndex = %d, *pdwDataLen = %d, pbData = %d.\n",
        dwIndex, *pdwDataLen, pbData);

#endif

    // Check for bad parameters
    // (The WVT_IS_CBSTRUCT_GT_MEMBEROFFSET macro is defined in wintrust.h)
    if (!(pSubjectInfo) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO,
            pSubjectInfo->cbSize,
            dwEncodingType)) ||
        !(pdwDataLen) || 
        !(pdwEncodingType) ) {

#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Bad parameters to Get.", NULL, FALSE);
#endif
        hr = ERROR_INVALID_PARAMETER;
        goto done;
    }

    // create an OTSIPObject based on the subject type
    // Do the full file check to generate the right subject object.
    pSubjectObj = mssipotf_CreateSubjectObject_Quick (pSubjectInfo);
    if (!pSubjectObj) {
        hr = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    // call the Get code for the object
    hr = pSubjectObj->GetSignedDataMsg(pSubjectInfo,
                            pdwEncodingType,
                            dwIndex,
                            pdwDataLen,
                            pbData);

done:

    delete pSubjectObj;

#if PERF
    QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
    QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
    liNow = liNow - liStart;
    liDelta = (liNow * 1000) / liFreq;
    printf( "  Time in Get is %d milliseconds\n", liDelta );
#endif

#if MSSIPOTF_ERROR
    if (hr != S_OK) {
        DbgPrintf ("Failed to retrieve a signature from the DSIG table (Get).\n");
    }
#endif

    // Set the last error if we failed.
    if (hr != S_OK) {
        SetLastError (hr);
        rv = FALSE;
    } else {
        rv = TRUE;
    }

#if MSSIPOTF_DBG
    DbgPrintf ("Exiting OTSIPGetSignedDataMsg. rv = %d.\n", rv);
#endif

    return rv;
}


// Replace the *pdwIndex-th signature with the given one in the file.
// If *pdwIndex is greater than or equal to the number of signatures
// already present in the file, then append the new signature.
BOOL WINAPI OTSIPPutSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                                   IN      DWORD           dwEncodingType,
                                   OUT     DWORD           *pdwIndex,
                                   IN      DWORD           dwDataLen,
                                   IN      BYTE            *pbData)
{
	BOOL rv = FALSE;  // return value
    HRESULT hr = S_OK;

    OTSIPObject *pSubjectObj = NULL;

#if PERF
    _int64 liStart;
    _int64 liNow;
    _int64 liFreq;
    _int64 liDelta;

    QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
#endif

#if MSSIPOTF_DBG
    DbgPrintf ("Called OTSIPPutSignedDataMsg.\n");
    DbgPrintf ("*pdwIndex = %d, dwDataLen = %d, pbData = %d.\n",
        *pdwIndex, dwDataLen, pbData);
#endif

    // Check for bad parameters
    if (!(pSubjectInfo) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO,
            pSubjectInfo->cbSize,
            dwEncodingType)) ||
        !(pbData) ||
        !(pdwIndex) ||
        (dwDataLen < 1)
        ) {

#if MSSIPOTF_ERROR
      SignError ("Cannot continue: Bad parameters to Put.", NULL, FALSE);
#endif
        hr = ERROR_INVALID_PARAMETER;
        goto done;
    }


#if !NO_POLICY_CHECK
    //// Make sure that the incoming PKCS #7 packet has
    //// the FontIntegrity authenticated attribute "1.3.6.1.4.1.311.40.1"
    if (!mssipotf_VerifyPolicyPkcs (pSubjectInfo,
                                    dwEncodingType,
                                    *pdwIndex,
                                    dwDataLen,
                                    pbData,
                                    VALID_HINTS_POLICY)) {
        hr = MSSIPOTF_E_FAILED_POLICY;
        goto done;
    }
#endif


    // create an OTSIPObject based on the subject type
    // Do the full file check to generate the right subject object.
    pSubjectObj = mssipotf_CreateSubjectObject_Full (pSubjectInfo, TRUE, &hr);
    if (!pSubjectObj) {
        goto done;
    }

    // call the Put code for the object
    hr = pSubjectObj->PutSignedDataMsg(pSubjectInfo,
                            dwEncodingType,
                            pdwIndex,
                            dwDataLen,
                            pbData);

done:

    delete pSubjectObj;


#if PERF
    QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
    QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
    liNow = liNow - liStart;
    liDelta = (liNow * 1000) / liFreq;
    printf( "  Time in Put is %d milliseconds\n", liDelta );
#endif

    // Set the last error if we failed.
    if (hr != S_OK) {
        SetLastError (hr);
        rv = FALSE;
    } else {
        rv = TRUE;
    }

#if MSSIPOTF_DBG
    DbgPrintf ("Exiting OTSIPPutSignedDataMsg. rv = %d\n", rv);
#endif

    return rv;
}


//
// Remove a signature from a TTF file.  If the requested signature does
// not exist, then the file is unchanged and FALSE is returned.
//
// Authenticode currently assumes there is at most one signature in the file.
// This function does not make that assumption.
//
BOOL WINAPI OTSIPRemoveSignedDataMsg(IN SIP_SUBJECTINFO  *pSubjectInfo,
                                     IN DWORD            dwIndex)
{
    BOOL rv = FALSE;
    HRESULT hr = S_OK;

    OTSIPObject *pSubjectObj = NULL;

#if PERF
    _int64 liStart;
    _int64 liNow;
    _int64 liFreq;
    _int64 liDelta;

    QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
#endif

#if MSSIPOTF_DBG
    DbgPrintf ("Called OTSIPRemoveSignedDataMsg.\n");
#endif

    if (!(pSubjectInfo) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO,
            pSubjectInfo->cbSize,
            dwEncodingType))
        ) {
        hr = ERROR_INVALID_PARAMETER;
        goto done;
    }

    // create an OTSIPObject based on the subject type
    // ASSERT: We assume Create already did the full check.
    // Do the (quick) 4-byte check.
    pSubjectObj = mssipotf_CreateSubjectObject_Quick (pSubjectInfo);
    if (!pSubjectObj) {
        hr = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    // call the Remove code for the object
    rv = pSubjectObj->RemoveSignedDataMsg(pSubjectInfo,
                            dwIndex);

done:

    delete pSubjectObj;

#if PERF
    QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
    QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
    liNow = liNow - liStart;
    liDelta = (liNow * 1000) / liFreq;
    printf( "  Time in Remove is %d milliseconds\n", liDelta );
#endif

    // Set the last error if we failed.
    if (!rv) {
        if (hr == S_OK) {
            SetLastError ((DWORD)E_FAIL);
        } else {
            SetLastError (hr);
        }
    } else {
        assert (hr == S_OK);
    }

#if MSSIPOTF_DBG
    DbgPrintf ("Exiting OTSIPRemoveSignedDataMsg.\n");
#endif

    // always return false when finished!!!
    // we're being called in a "TRUE" loop.
    return FALSE;
}


//
// Calculate the hash of the TTF file and generate a SIP_INDIRECT_DATA structure.
//
BOOL WINAPI OTSIPCreateIndirectData (IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                     IN OUT  DWORD               *pdwDataLen,
                                     OUT     SIP_INDIRECT_DATA   *psData)
{
    BOOL rv = FALSE;  // return value
    HRESULT hr = S_OK;

    OTSIPObject *pSubjectObj = NULL;


#if MSSIPOTF_DBG
    /*
    DbgPrintf ("Test mapping in CreateIndirectData.  hFile = 0x%x.\n",
        pSubjectInfo->hFile);
    TestMapping (pSubjectInfo->hFile);
    */
#endif


#if MSSIPOTF_DBG
    DbgPrintf ("Called OTSIPCreateIndirectData.\n");
    DbgPrintf ("*pdwDataLen = %d\n", *pdwDataLen);
    DbgPrintf ("psData = %d\n", psData);

    DbgPrintf ("hash alg: %s %d\n", pSubjectInfo->DigestAlgorithm.pszObjId,
        CertOIDToAlgId(pSubjectInfo->DigestAlgorithm.pszObjId));
#endif

#if PERF
    _int64 liStart;
    _int64 liNow;
    _int64 liFreq;
    _int64 liDelta;

    QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
#endif



    // Check for bad parameters
    if (!(pSubjectInfo) || 
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO,
            pSubjectInfo->cbSize,
            dwEncodingType)) ||
        !(pdwDataLen)) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Bad parameters to Create.", NULL, FALSE);
#endif
        hr = ERROR_INVALID_PARAMETER;
        goto done;
    }

    // create an OTSIPObject based on the subject type
    // If the caller of this function is just requesting the size of
    // psData that will be returned, then just do the Quick file check
    // to generate the right subject object.
    // Otherwise, call the Full version.
    if (psData) {
        pSubjectObj = mssipotf_CreateSubjectObject_Full (pSubjectInfo, FALSE, &hr);
        if (!pSubjectObj) {
            goto done;
        }
    } else {
        pSubjectObj = mssipotf_CreateSubjectObject_Quick (pSubjectInfo);
        if (!pSubjectObj) {
            hr = MSSIPOTF_E_CANTGETOBJECT;
            goto done;
        }
    }

    // call the Create code for the object
    hr = pSubjectObj->CreateIndirectData(pSubjectInfo,
                            pdwDataLen,
                            psData);

done:

    delete pSubjectObj;

#if PERF
    QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
    QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
    liNow = liNow - liStart;
    liDelta = (liNow * 1000) / liFreq;
    printf( "  Time in Create is %d milliseconds\n", liDelta );
#endif

    // Set the last error if we failed.
    if (hr != S_OK) {
        SetLastError (hr);
        rv = FALSE;
    } else {
        rv = TRUE;
    }

#if MSSIPOTF_DBG
    DbgPrintf ("End of Create. rv = %d\n", rv);
    DbgPrintf ("*pdwDataLen = %d\n", *pdwDataLen);
    DbgPrintf ("psData = %d\n", psData);
#endif

    return rv;
}


// Given a signature, verify that its associated hash value
// matches that of the given file.
BOOL WINAPI OTSIPVerifyIndirectData( IN SIP_SUBJECTINFO      *pSubjectInfo,
                                     IN SIP_INDIRECT_DATA    *psData)
{
    BOOL rv = FALSE;  // return value
    HRESULT hr = S_OK;

    OTSIPObject *pSubjectObj = NULL;

#if PERF
    _int64 liStart;
    _int64 liNow;
    _int64 liFreq;
    _int64 liDelta;

    QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
#endif


#if MSSIPOTF_DBG
    DbgPrintf ("Called OTSIPVerifyIndirectData.\n");

    DbgPrintf ("hash oid: %s %d\n",
        pSubjectInfo->DigestAlgorithm.pszObjId,
        CertOIDToAlgId(pSubjectInfo->DigestAlgorithm.pszObjId));
#endif

    if (!(pSubjectInfo) ||
        !(WVT_IS_CBSTRUCT_GT_MEMBEROFFSET(SIP_SUBJECTINFO,
            pSubjectInfo->cbSize,
            dwEncodingType)) ) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Bad parameters to Verify.", NULL, FALSE);
#endif
        hr = ERROR_INVALID_PARAMETER;
        goto done;
    }

    // create an OTSIPObject based on the subject type
    // Do the full structural check.
    pSubjectObj = mssipotf_CreateSubjectObject_Full (pSubjectInfo, TRUE, &hr);
    if (!pSubjectObj) {
        goto done;
    }

    // call the Verify code for the object
    hr = pSubjectObj->VerifyIndirectData(pSubjectInfo,
                            psData);

done:

    delete pSubjectObj;

#if PERF
    QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
    QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
    liNow = liNow - liStart;
    liDelta = (liNow * 1000) / liFreq;
    printf( "  Time in Verify is %d milliseconds\n", liDelta );
#endif

    // Set the last error if we failed.
    if (hr != S_OK) {
        SetLastError (hr);
        rv = FALSE;
    } else {
        rv = TRUE;
    }

#if MSSIPOTF_DBG
    DbgPrintf ("Exiting OTSIPVerifyIndirectData. rv = %d.\n", rv);
#endif

    return rv;
}


// Assuming that the file represented by pFileObj is a TTF
// file, check to see that the Offset Table values in the
// file are consistent.
// BUGBUG: Currently not called by anyone.
BOOL OffsetTableCheck (CFileObj *pFileObj)
{
    BOOL rv = FALSE;

    TTFACC_FILEBUFFERINFO fileBufferInfo;
    OFFSET_TABLE offsetTable;
    OFFSET_TABLE offsetTableCheck;

    fileBufferInfo.puchBuffer = pFileObj->GetFileObjPtr();
    fileBufferInfo.ulBufferSize = pFileObj->GetFileObjSize();
    fileBufferInfo.ulOffsetTableOffset = 0;
    fileBufferInfo.lpfnReAllocate = NULL;

    //// Check that the file is at least SIZEOF_OFFSET_TABLE long.
    if (fileBufferInfo.ulBufferSize < SIZEOF_OFFSET_TABLE) {
	    goto done;
    }
    //// Check that the values in the offset table are consistent
    // Read the offset table from the file
    if (ReadOffsetTable (&fileBufferInfo,
                         &offsetTable) != NO_ERROR) {
        goto done;
    }
    //// Check that the entries in the offset table
    //// (that is, the sfnt table) are correct, given the
    //// assumption that numTables is correct.
    offsetTableCheck.numTables = offsetTable.numTables;
    CalcOffsetTable (&offsetTableCheck);
// DbgPrintf ("search range: %d %d\n", offsetTableCheck.searchRange, pttfInfo->pOffset->searchRange);
// DbgPrintf ("entry selector: %d %d\n", offsetTableCheck.entrySelector, pttfInfo->pOffset->entrySelector);
// DbgPrintf ("rangeShift: %d %d\n", offsetTableCheck.rangeShift, pttfInfo->pOffset->rangeShift);
    if ((offsetTableCheck.searchRange != offsetTable.searchRange) ||
        (offsetTableCheck.entrySelector != offsetTable.entrySelector) ||
        (offsetTableCheck.rangeShift != offsetTable.rangeShift) ) {

        goto done;
    }

    // Offset table values are consistent.
    rv = TRUE;
done:
    return rv;
}

        
// Return TRUE if and only if the given file is a font file.
// This function checks the first four bytes of the file to
// see if it "looks" like an OTF or TTC file.
BOOL WINAPI SIPIsFontFile (IN HANDLE hFile, OUT GUID *pgSubject)
{
    GUID gFont    = CRYPT_SUBJTYPE_FONT_IMAGE;
	BOOL rv = FALSE;  // return value


#if MSSIPOTF_DBG
    DbgPrintf ("Called SIPIsFontFile.\n");
#endif

    // check the first four bytes.
    rv = IsFontFile_handle (hFile) ? TRUE : FALSE;


#if MSSIPOTF_DBG
    DbgPrintf ("Exiting SIPIsFontFile.  rv = %d\n", rv);
#endif

// done:
    if ((rv) && (pgSubject))
    {
        memcpy(pgSubject, &gFont, sizeof(GUID));
    }

#if MSSIPOTF_DBG
    /*
    DbgPrintf ("Test mapping in SIPIsFontFile 1.  hFile = 0x%x.\n", hFile);
    TestMapping (hFile);
    DbgPrintf ("Test mapping in SIPIsFontFile 2.  hFile = 0x%x.\n", hFile);
    TestMapping (hFile);
    */
#endif

	return rv;
}


// Given a pointer to a SIP_SUBJECTINFO structure, return a pointer to
// a font object (either sipobotf or sipobttc) associated with that type
// of subject.  Return NULL if the subject is not an OTF or TTC file.
// Perform full structural checks on the file.
OTSIPObject *mssipotf_CreateSubjectObject_Full (SIP_SUBJECTINFO *pSubjectInfo,
                                                BOOL fTableChecksum,
                                                HRESULT *phr)
{
    OTSIPObject *pDummy = NULL;
    CFileObj *pFileObj = NULL;
    OTSIPObject *pSO = NULL;
    int FileTag;


#if MSSIPOTF_DBG
    DbgPrintf ("Called mssipotf_CreateSubjectObject_Full.  ");
#endif

    // Need to create a OTSIPObject before calling GetFileObjectFromSubject
    if ((pDummy = (OTSIPObject *) new OTSIPObjectOTF) == NULL) {
        goto done;
    }

    // create a file object based on the pSubjectInfo.
    if (pDummy->GetFileObjectFromSubject
            (pSubjectInfo, GENERIC_READ, &pFileObj) != S_OK) {
        goto done;
    }

    // ASSERT: if we reach here, then pFileObj is a valid CFileObj

    // map the file object
    if (pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ) != S_OK) {
        goto done;
    }

    if ((FileTag = IsFontFile (pFileObj)) == FAIL_TAG) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in IsFontFile.\n");
#endif
        goto done;
    }

    // Call the IsTTFFile and/or IsTTCFile
    if ((FileTag == OTF_TAG) && IsTTFFile (pFileObj, fTableChecksum, phr)) {
        pSO = (OTSIPObject *) new OTSIPObjectOTF;
#if MSSIPOTF_DBG
        DbgPrintf ("Creating OTF object.\n");
#endif
    } else if ((FileTag == TTC_TAG) && IsTTCFile (pFileObj, fTableChecksum, phr)) {
        pSO = (OTSIPObject *) new OTSIPObjectTTC;
#if MSSIPOTF_DBG
        DbgPrintf ("Creating TTC object.\n");
#endif
    }

    // ASSERT: If it's neither a OTF nor a TTC (or if the new operator
    // failed), then pSO is still NULL.

done:
    if (pFileObj) {
        pFileObj->UnmapFile();
        pFileObj->CloseFileHandle();
    }

    delete pDummy;

    delete pFileObj;

    return pSO;
}


// Given a pointer to a SIP_SUBJECTINFO structure, return a pointer to
// a font object (either sipobotf or sipobttc) associated with that type
// of subject.  Return NULL if the subject is not an OTF or TTC file.
// Perform the quick check on the file.
OTSIPObject *mssipotf_CreateSubjectObject_Quick (SIP_SUBJECTINFO *pSubjectInfo)
{
    OTSIPObject *pDummy = NULL;
    CFileObj *pFileObj = NULL;
    int FileTag;
    OTSIPObject *pSO = NULL;


#if MSSIPOTF_DBG
    DbgPrintf ("Called mssipotf_CreateSubjectObject_Quick.\n");
#endif

    // Need to create a OTSIPObject before calling GetFileObjectFromSubject
    if ((pDummy = (OTSIPObject *) new OTSIPObjectOTF) == NULL) {
        goto done;
    }

    // create a file object based on the pSubjectInfo.
    if (pDummy->GetFileObjectFromSubject
            (pSubjectInfo, GENERIC_READ, &pFileObj) != S_OK) {
        goto done;
    }

    // ASSERT: if we have reached here, then pFileObj is a valid CFileObj

    // map the file object
    if (pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ) != S_OK) {
        goto done;
    }

    // Call IsFontFile to determine what kind of file it is
    if ((FileTag = IsFontFile (pFileObj)) == FAIL_TAG) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in IsFontFile.\n");
#endif
        goto done;
    }
    
    switch (FileTag) {
        case OTF_TAG:
            pSO = (OTSIPObject *) new OTSIPObjectOTF;
            break;

        case TTC_TAG:
            pSO = (OTSIPObject *) new OTSIPObjectTTC;
            break;

        default:
            // bad value for FileTag
            goto done;
            break;

    }
    // ASSERT: If it's neither a OTF nor a TTC (or if the new operation
    // fails), then pSO is still NULL.

done:
    if (pFileObj) {
        pFileObj->UnmapFile();
        pFileObj->CloseFileHandle();
    }

    delete pDummy;

    delete pFileObj;

#if MSSIPOTF_DBG
    DbgPrintf ("Exiting mssipotf_CreateSubjectObject_Quick.\n");
#endif

    return (pSO);
}



//////////////////////////////////////////////////////////////////////////////////////
//
// standard DLL exports ...
//------------------------------------------------------------------------------------
//

BOOL WINAPI DllMain(HANDLE hInstDLL,DWORD fdwReason,LPVOID lpvReserved)
{
    return(TRUE);
}


STDAPI DllRegisterServer(void)
{
    BOOL                fRet = TRUE;
    GUID                gFont = CRYPT_SUBJTYPE_FONT_IMAGE;
    SIP_ADD_NEWPROVIDER sProv;

    CRYPT_OID_INFO OIDInfo;


    memset(&sProv, 0x00, sizeof(SIP_ADD_NEWPROVIDER));
    
    sProv.cbStruct              = sizeof(SIP_ADD_NEWPROVIDER);
    sProv.pwszDLLFileName       = MY_NAME;
    sProv.pwszGetFuncName       = L"OTSIPGetSignedDataMsg";
    sProv.pwszPutFuncName       = L"OTSIPPutSignedDataMsg";
    sProv.pwszRemoveFuncName    = L"OTSIPRemoveSignedDataMsg";
    sProv.pwszCreateFuncName    = L"OTSIPCreateIndirectData";
    sProv.pwszVerifyFuncName    = L"OTSIPVerifyIndirectData";

    sProv.pwszIsFunctionName    = L"SIPIsFontFile";
    sProv.pgSubject             = &gFont;

    fRet &= CryptSIPAddProvider(&sProv);


    // Register the OID info so that name of the OID appears
    // in UI rather than the OID itself.
    memset (&OIDInfo, 0, sizeof (CRYPT_OID_INFO));
    OIDInfo.cbSize = sizeof (CRYPT_OID_INFO);
    OIDInfo.pszOID = szOID_FontIntegrity;
    OIDInfo.pwszName = L"Font Attribute";
    OIDInfo.dwGroupId = CRYPT_RDN_ATTR_OID_GROUP_ID;

    fRet &= CryptRegisterOIDInfo (&OIDInfo, 0);

    // Register the formatting function for the font attribute value
    // so that in UI, the attribute value is more friendly.
    fRet &= CryptRegisterOIDFunction (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                      CRYPT_OID_FORMAT_OBJECT_FUNC,
                                      szOID_FontIntegrity,
                                      wszFormatDll,
                                      szFormatFontAttrFunc);

    return (fRet ? S_OK : S_FALSE);
}


STDAPI DllUnregisterServer(void)
{
    BOOL                fRet = TRUE;
    GUID                gFont = CRYPT_SUBJTYPE_FONT_IMAGE;

    CRYPT_OID_INFO OIDInfo;


    // Unregister the OID info.
    memset (&OIDInfo, 0, sizeof (CRYPT_OID_INFO));
    OIDInfo.cbSize = sizeof (CRYPT_OID_INFO);
    OIDInfo.pszOID = szOID_FontIntegrity;
    OIDInfo.dwGroupId = CRYPT_RDN_ATTR_OID_GROUP_ID;

    fRet &= CryptUnregisterOIDInfo (&OIDInfo);

    // Unregister the formatting function for the font attribute value.
    fRet &= CryptUnregisterOIDFunction (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                      CRYPT_OID_FORMAT_OBJECT_FUNC,
                                      szOID_FontIntegrity);
    
    fRet &= CryptSIPRemoveProvider(&gFont);

    return (fRet ? S_OK : S_FALSE);
}


#if MSSIPOTF_DBG
void TestMapping (HANDLE hFile)
{
    HANDLE hFileMapping = NULL;

    if ((hFileMapping =
            CreateFileMapping (hFile,
                               NULL,
                               PAGE_READWRITE,
                               0,
                               0,
                               NULL)) == NULL) {
        SignError ("*** Error in CreateFileMapping.", NULL, TRUE);
    } else {
        DbgPrintf ("Closing file mapping handle.\n");
        CloseHandle (hFileMapping);
        hFileMapping = NULL;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sip\sipob.h ===
//
// sipob.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//

#ifndef _SIPOB_H
#define _SIPOB_H

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <softpub.h>
#include <sipbase.h>
#include <mssip.h>

#include <assert.h>

#include "signglobal.h"
#include "fileobj.h"


#define     OBSOLETE_TEXT_W                 L"<<<Obsolete>>>"   // valid since 2/14/1997


class OTSIPObject {
public:
    virtual HRESULT GetSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                                      OUT     DWORD           *pdwEncodingType,
                                      IN      DWORD           dwIndex,
                                      IN OUT  DWORD           *pdwDataLen,
                                      OUT     BYTE            *pbData) = 0;

    virtual HRESULT PutSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                                      IN      DWORD           dwEncodingType,
                                      OUT     DWORD           *pdwIndex,
                                      IN      DWORD           dwDataLen,
                                      IN      BYTE            *pbData) = 0;

    virtual HRESULT RemoveSignedDataMsg (IN SIP_SUBJECTINFO  *pSubjectInfo,
                                         IN DWORD            dwIndex) = 0;

    virtual HRESULT CreateIndirectData (IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                        IN OUT  DWORD               *pdwDataLen,
                                        OUT     SIP_INDIRECT_DATA   *psData) = 0;

    virtual HRESULT VerifyIndirectData (IN SIP_SUBJECTINFO      *pSubjectInfo,
                                        IN SIP_INDIRECT_DATA    *psData) = 0;

    HRESULT GetDefaultProvider(HCRYPTPROV *phProv);

    HRESULT SIPOpenFile(LPCWSTR FileName, DWORD dwAccess, HANDLE *phFile);

    HRESULT GetFileHandleFromSubject(SIP_SUBJECTINFO *pSubjectInfo,
                                     DWORD dwAccess,
                                     HANDLE *phFile);

    HRESULT GetFileObjectFromSubject(SIP_SUBJECTINFO *pSubjectInfo,
                                     DWORD dwAccess,
                                     CFileObj **ppFileObj);

};

#endif // _SIPOB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sip\sipobotf.h ===
//
// sipobotf.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//

#ifndef _SIPOBOTF_H
#define _SIPOBOTF_H


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>

#include "sipob.h"
#include "dsigTable.h"


class OTSIPObjectOTF : public OTSIPObject {
public:
    HRESULT GetSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                              OUT     DWORD           *pdwEncodingType,
                              IN      DWORD           dwIndex,
                              IN OUT  DWORD           *pdwDataLen,
                              OUT     BYTE            *pbData);

    HRESULT PutSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                              IN      DWORD           dwEncodingType,
                              OUT     DWORD           *pdwIndex,
                              IN      DWORD           dwDataLen,
                              IN      BYTE            *pbData);

    HRESULT RemoveSignedDataMsg (IN SIP_SUBJECTINFO  *pSubjectInfo,
                                 IN DWORD            dwIndex);

    HRESULT CreateIndirectData (IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                IN OUT  DWORD               *pdwDataLen,
                                OUT     SIP_INDIRECT_DATA   *psData);

    HRESULT VerifyIndirectData (IN SIP_SUBJECTINFO      *pSubjectInfo,
                                IN SIP_INDIRECT_DATA    *psData);


//    ULONG GetFormat (CFileObj *pFileObj, DWORD dwIndex);

//    USHORT GetFlag (CFileObj *pFileObj);

    HRESULT DigestFileData (CFileObj *pFileObj,
                            HCRYPTPROV hProv,
                            ALG_ID alg_id,
                            BYTE **ppbDigest,
                            DWORD *pcbDigest,
                            USHORT usIndex,
                            ULONG ulFormat,
                            ULONG cbDsig,
                            BYTE *pbDsig);

    HRESULT ReplaceDsigTable (CFileObj *pFileObj,
                              CDsigTable *pDsigTableNew);

    char *GetTTFObjectID ();
};

#endif // _SIPOTOTF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sip\sipobttc.h ===
//
// sipobttc.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//

#ifndef _SIPOBTTC_H
#define _SIPOBTTC_H

#include "sipob.h"
#include "dsigTable.h"

class OTSIPObjectTTC : public OTSIPObject {
public:
    HRESULT GetSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                              OUT     DWORD           *pdwEncodingType,
                              IN      DWORD           dwIndex,
                              IN OUT  DWORD           *pdwDataLen,
                              OUT     BYTE            *pbData);

    HRESULT PutSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                              IN      DWORD           dwEncodingType,
                              OUT     DWORD           *pdwIndex,
                              IN      DWORD           dwDataLen,
                              IN      BYTE            *pbData);

    HRESULT RemoveSignedDataMsg (IN SIP_SUBJECTINFO  *pSubjectInfo,
                                 IN DWORD            dwIndex);

    HRESULT CreateIndirectData (IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                IN OUT  DWORD               *pdwDataLen,
                                OUT     SIP_INDIRECT_DATA   *psData);

    HRESULT VerifyIndirectData (IN SIP_SUBJECTINFO      *pSubjectInfo,
                                IN SIP_INDIRECT_DATA    *psData);

    HRESULT DigestFileData (CFileObj *pFileObj,
                            HCRYPTPROV hProv,
                            ALG_ID alg_id,
                            BYTE **ppbDigest,
                            DWORD *pcbDigest,
                            USHORT usIndex,
                            ULONG ulFormat,
                            ULONG cbDsig,
                            BYTE *pbDsig);

    HRESULT ReplaceDsigTable (CFileObj *pFileObj,
                              CDsigTable *pDsigTable);


    char *GetTTCObjectID ();
};

#endif // _SIPOBTTC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sip\sipob.cpp ===
//
// sipob.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//

#include "sipob.h"
#include "utilsign.h"
#include "signerr.h"


// Return in *phProv the default cryptographic provider
HRESULT OTSIPObject::GetDefaultProvider(HCRYPTPROV *phProv)
{
    HRESULT rv = E_FAIL;

    if (!(CryptAcquireContext(phProv, NULL, MS_DEF_PROV, PROV_RSA_FULL,
                              CRYPT_VERIFYCONTEXT))) {
        *phProv = NULL;
        rv = MSSIPOTF_E_CRYPT;
        goto done;
    }
    
    rv = S_OK;

done:
    return rv;
}


// Open a file given a string and desired access.
HRESULT OTSIPObject::SIPOpenFile(LPCWSTR FileName,
                                 DWORD dwAccess,
                                 HANDLE *phFile)
{
    HRESULT hr = S_OK;

    LPOSVERSIONINFO lpVersionInfo = NULL;
    LPSTR pszFileName = NULL;
    int cbszFileName = 0;

#if MSSIPOTF_DBG
    DbgPrintf ("Entering OTSIPObject::SIPOpenFile.\n");
#endif

    //// Create a handle for the file.
    // set up the version info data structure
    if ((lpVersionInfo =
        (OSVERSIONINFO *) malloc (sizeof (OSVERSIONINFO))) == NULL) {
        hr = E_OUTOFMEMORY;
        goto done;
    }
    memset (lpVersionInfo, 0, sizeof (OSVERSIONINFO));
    lpVersionInfo->dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

    // get the version
    if (GetVersionEx (lpVersionInfo) == 0) {
        hr = E_FAIL;
        goto done;
    }

    // If Windows 95, then call CreateFile.
    // If NT, then call CreateFileW.
    switch (lpVersionInfo->dwPlatformId) {

        case VER_PLATFORM_WIN32_NT:

            if ((*phFile = CreateFileW( FileName,
                                        dwAccess,
                                        FILE_SHARE_READ,
                                        NULL,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL)) == INVALID_HANDLE_VALUE) {
                return MSSIPOTF_E_FILE;
            }
            break;

        case VER_PLATFORM_WIN32_WINDOWS:
        default:
            // convert the wide character string to an ANSI string
            if ((hr = WszToMbsz (NULL, &cbszFileName, FileName)) != S_OK) {
                goto done;
            }
            if (cbszFileName <= 0) {
                hr = MSSIPOTF_E_FILE;
                goto done;
            }
            if ((pszFileName = (CHAR *) malloc (cbszFileName)) == NULL) {
                hr = E_OUTOFMEMORY;
                goto done;
            }
            if ((hr = WszToMbsz (pszFileName, &cbszFileName, FileName)) != S_OK) {
                goto done;
            }
            if (cbszFileName <= 0) {
                hr = MSSIPOTF_E_FILE;
                goto done;
            }
            
           // Create a file object for the file.
            if ((*phFile = CreateFile (pszFileName,
                                       GENERIC_READ,
                                       FILE_SHARE_READ,
                                       NULL,
                                       OPEN_EXISTING,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL)) == INVALID_HANDLE_VALUE) {
                hr = MSSIPOTF_E_FILE;
                goto done;
            }
            break;
    }
#if MSSIPOTF_DBG
        DbgPrintf ("Opening file in sipob.cpp.  hFile = 0x%x.\n", *phFile);
#endif
    

// DbgPrintf ("SIPOpenFile: Opening file.\n");  // DBGEXTRA

done:
    if (lpVersionInfo) {
        free (lpVersionInfo);
    }

    if (pszFileName) {
        free (pszFileName);
    }

#if MSSIPOTF_DBG
    DbgPrintf ("Entering OTSIPObject::SIPOpenFile.\n");
#endif

    return hr;
}


// Return in phFile the handle to the file of the subject.
HRESULT OTSIPObject::GetFileHandleFromSubject(SIP_SUBJECTINFO *pSubjectInfo,
                                              DWORD dwAccess,
                                              HANDLE *phFile)
{
    HRESULT hr = E_FAIL;

    if ((pSubjectInfo->hFile == NULL) ||
        (pSubjectInfo->hFile == INVALID_HANDLE_VALUE)) {

        if ((hr = SIPOpenFile(pSubjectInfo->pwsFileName,
                        dwAccess,
                        phFile)) != S_OK) {
            goto done;
        }

    } else {
        *phFile = pSubjectInfo->hFile;
    }

    hr = S_OK;
done:
    return hr;
}


// Return in pFileObj the file object of the file of the subject.
// If the hFile field or the pwsFilename is non-null, then we
// create a CFileHandle object.  If hFile and pwsFileName is null
// and the dwUnionChoice is MSSIP_ADDINFO_BLOB, then we create a
// CFileMemPtr object.  Otherwise, we return FALSE.
// dwAccess is passed to CreateFile.
HRESULT OTSIPObject::GetFileObjectFromSubject(SIP_SUBJECTINFO *pSubjectInfo,
                                              DWORD dwAccess,
                                              CFileObj **ppFileObj)
{
    HRESULT hr = E_FAIL;

    HANDLE hFile = NULL;

#if MSSIPOTF_DBG
    DbgPrintf ("Called GetFileObjectFromSubject.\n");
#endif

    if ((pSubjectInfo->hFile != NULL) &&
        (pSubjectInfo->hFile != INVALID_HANDLE_VALUE)) {
        // file handle specified by hFile
        if ((*ppFileObj = (CFileObj *) new CFileHandle (pSubjectInfo->hFile, FALSE)) == NULL) {
            hr = E_OUTOFMEMORY;
            goto done;
        } else {
#if MSSIPOTF_DBG
            DbgPrintf ("Passed a file handle.  pSubjectInfo->hFile = 0x%x\n", pSubjectInfo->hFile);
#endif
            hr = S_OK;
            goto done;
        }

    } else if (pSubjectInfo->pwsFileName) {
        // file handle specified by file name

        if ((hr = SIPOpenFile(pSubjectInfo->pwsFileName,
                              dwAccess,
                              &hFile)) != S_OK) {
            goto done;
        } 
        
        if ((*ppFileObj =
                    (CFileObj *) new CFileHandle (hFile, TRUE)) == NULL) {
            hr = E_OUTOFMEMORY;
            goto done;
        } else {
#if MSSIPOTF_DBG
            DbgPrintf ("Opened file handle.\n");
#endif
            hr = S_OK;
            goto done;
        }

    } else if (pSubjectInfo->dwUnionChoice == MSSIP_ADDINFO_BLOB) {
        // memory pointer

        if (!(pSubjectInfo->psBlob)) {
            hr = MSSIPOTF_E_CANTGETOBJECT;
            goto done;
        }
        
        if ((*ppFileObj = (CFileObj *) new
                    CFileMemPtr (pSubjectInfo->psBlob->pbMemObject,
                                 pSubjectInfo->psBlob->cbMemObject)) == NULL) {
            hr = E_OUTOFMEMORY;
            goto done;
        } else {
#if MSSIPOTF_DBG
            DbgPrintf ("Passed a mem pointer.\n");
#endif
            hr = S_OK;
            goto done;
        }

    } else {
        // unrecognized way to specify the file
        hr = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

done:
#if MSSIPOTF_DBG
    DbgPrintf ("Exiting GetFileObjectFromSubject.\n");
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sip\sipobttc.cpp ===
//
// sipobttc.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//

#include "sipobttc.h"

#include "signglobal.h"

#include "mssipotf.h"
#include "fileobj.h"
#include "sign.h"
#include "glyphExist.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "ttcinfo.h"
#include "hTTCfile.h"

#include "subset.h"
#ifdef __cplusplus
extern "C" {
#endif
#include "fsverify.h"
#ifdef __cplusplus
}
#endif

#include "signerr.h"

    // SIZEOF_ZERO should be the difference between
    // SIZEOF_TTC_HEADER_TABLE_1_0_DSIG and SIZEOF_TTC_HEADER_TABLE_1_0
#define SIZEOF_ZERO 12
    BYTE pbZero[SIZEOF_ZERO] = {0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00};

    
// If there is no DSIG table, add one with no signatures,
// but with the proper flags field.
// If there is a DSIG table, change its flags field.
HRESULT OTSIPObjectTTC::ReplaceDsigTable (CFileObj *pFileObj,
                                          CDsigTable *pDsigTableNew)
{
    HRESULT rv = E_FAIL;

    //// Here's the algorithm.
    //// 1. Map the file and extract the DSIG table.
    //// 2. Get the sizes of the old and new DSIG tables.
    ////      (We only need the size of the old DSIG table if
    ////      the TTC file has the special Version 1 header.)
	//// 3. If the TTC file has a version 1 header with no DSIG fields:
	////      a. Create a default DsigTable structure.
	////      b. Determine the size of the new DSIG table.  Call
	////           this size N.
	////      c. Unmap the file and remap it to be
    ////           (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0) + N
	////           bytes larger.
	////      d. Move all bytes after the TTC header down
    ////           (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0)
    ////           bytes.
	////      e. Adjust the table directory offsets in the TTC header.
    ////           Also, add ulDsigTag, ulDsigLength, and ulDsigOffset fields of the
    ////           TTC header in the hole created.
	////      f. Update the offsets in all of the directories entries of the TTFs.
    ////      g. Write the DSIG table at the correct offset.
	//// 4. If the TTC file has a version 1 header with DSIG fields:
	////      a. Calculate the size of the new DSIG table minus the size of
	////         the old DSIG table.  Call this value D.
    ////         Update the ulDsigLength in the TTC Header.
	////      b. If D is positive (i.e., the new file will be larger):
	////           i.  Unmap the file and map it again at the new size
	////                 (which is the old size + D).
	////           ii. Write the new DSIG table at the end of the file.
	////      c. If D is negative (i.e., the new file will be smaller):
	////           i.   Write the new DSIG table at the end of the file.
	////           ii.  Unmap the file.
	////           iii. Set the end of the file pointer to be the new size
	////                  (which is the old size + D).


	ULONG cbFile = 0;		// current file size
	ULONG cbFileOld = 0;	// original file size

	TTCInfo *pTTCInfo = NULL;
	CDsigTable *pDsigTable = NULL;
	CDsigSignature *pDsigSignature = NULL;

    TTFACC_FILEBUFFERINFO *pFileBufferInfoNew = NULL;

    ULONG ulOldDsigTableSize = 0;
	ULONG ulDsigTableSize = 0;

	DIRECTORY dir;
    OFFSET_TABLE offTab;
	ULONG ulOffset;
	USHORT i,j;

    //// Step 1
	// Map the file
	if ((rv = pFileObj->MapFile (0, PAGE_READWRITE, FILE_MAP_WRITE))
            != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in MapFile.\n");
#endif
		goto done;
	}

	// Extract the DSIG table (create default DsigTable if it didn't exist)
	if ((rv = InitTTCStructures (pFileObj->GetFileObjPtr(),
                        pFileObj->GetFileObjSize(),
                        &pTTCInfo,
                        &pDsigTable)) != S_OK) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in InitTTCStructures.\n");
#endif
		goto done;
	}

    //// Step 2
    pDsigTable->GetSize(&ulOldDsigTableSize);
	pDsigTableNew->GetSize(&ulDsigTableSize);


    if ((pTTCInfo->pHeader->ulVersion == TTC_VERSION_1_0) &&
        (pTTCInfo->pHeader->ulDsigTag != DSIG_LONG_TAG)) {
		// step 3.  We have a version 1 TTC header with no DSIG fields
		// step 3a. the call to InitTTCStructures handled this
		// step 3b. this was done in step 2

		// step 3c.
        cbFileOld = pFileObj->GetFileObjSize();
		pFileObj->UnmapFile();

		cbFile = RoundToLongWord (cbFileOld) +
            (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0) +
            ulDsigTableSize;

#if MSSIPOTF_DBG
DbgPrintf ("cbFileOld = %d\n", cbFileOld);
DbgPrintf ("cbFile    = %d\n", cbFile);
DbgPrintf ("ulDsigTableSize = %d\n", ulDsigTableSize);
#endif

        if ((rv = pFileObj->MapFile (cbFile,
                        PAGE_READWRITE,
                        FILE_MAP_WRITE)) != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in MapFile.\n");
#endif
			goto done;
		}

        // initialize a new fileBufferInfo
		if ((pFileBufferInfoNew =
			(TTFACC_FILEBUFFERINFO *) malloc (sizeof (TTFACC_FILEBUFFERINFO))) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in malloc.", NULL, FALSE);
#endif
            rv = E_OUTOFMEMORY;
            goto done;
		}

		pFileBufferInfoNew->puchBuffer = pFileObj->GetFileObjPtr();
		pFileBufferInfoNew->ulBufferSize = cbFile;
        pFileBufferInfoNew->ulOffsetTableOffset = 0;
        pFileBufferInfoNew->lpfnReAllocate = NULL;

		// step 3d.
        ulOffset = SIZEOF_TTC_HEADER_TABLE_1_0;

		// move the bytes after the DSIG fields of the TTC header
		// down (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0)
        // bytes.  Also, pad out the file.

        // move part after TTC header down
        memmove (pFileBufferInfoNew->puchBuffer + SIZEOF_TTC_HEADER_TABLE_1_0_DSIG,
                 pFileBufferInfoNew->puchBuffer +
                     SIZEOF_TTC_HEADER_TABLE_1_0,
                 cbFileOld - SIZEOF_TTC_HEADER_TABLE_1_0);

        // DsigLength and DsigOffset fields
        memcpy (pFileBufferInfoNew->puchBuffer + SIZEOF_TTC_HEADER_TABLE_1_0,
                pbZero,
                SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0);

        ZeroLongWordAlign (pFileBufferInfoNew,
            cbFileOld +
            (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0));

        // step 3e.
        // fill in the ulDsigLength and ulDsigOffset fields of the
        // TTC header.  Add the DSIG fields to the TTC header.

        for (i = 0; i < pTTCInfo->pHeader->ulDirCount; i++) {
            pTTCInfo->pHeader->pulDirOffsets[i] +=
                (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0);
        }

        pTTCInfo->pHeader->ulVersion = TTC_VERSION_1_0;
        pTTCInfo->pHeader->ulDsigTag = DSIG_LONG_TAG;
        pTTCInfo->pHeader->ulDsigLength = ulDsigTableSize;
        pTTCInfo->pHeader->ulDsigOffset =
            RoundToLongWord (cbFileOld) +
            (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0);

        // update the TTC header of the new file buffer
        if ((rv = WriteTTCHeaderTable (pFileBufferInfoNew,
                                       pTTCInfo->pHeader)) != S_OK) {
#if MSSIPOTF_DBG
		    DbgPrintf ("Error in WriteTTCHeaderTable.\n");
#endif
		    goto done;
	    }

#if MSSIPOTF_DBG
PrintTTCHeader (pTTCInfo->pHeader);
#endif

		// step 3f.
        
        // Now recompute the table offsets in the table directories
        // of all TTFs in the TTC.  We just need to add
        // (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0)
        // to each offset.
        for (i = 0; i < pTTCInfo->pHeader->ulDirCount; i++) {

            ulOffset = pTTCInfo->pHeader->pulDirOffsets[i];
            // ASSERT: ulOffset points to the Offset Table of the i-th
            // TTF file in the TTC
            ReadOffsetTableOffset (pFileBufferInfoNew, ulOffset, &offTab);
            ulOffset += sizeof(OFFSET_TABLE);
            // ASSERT: ulOffset now points to the first directory
            // entry of the i-th TTF file in the TTC

            // check to make sure there is enough memory in the buffer
            // to read all of the tables in the TTF
            if ((ulOffset + offTab.numTables * sizeof(DIRECTORY)) >
                 pFileBufferInfoNew->ulBufferSize) {
#if MSSIPOTF_ERROR
                SignError ("Cannot continue: Too many TTF directory entries.", NULL, FALSE);
#endif
                rv = MSSIPOTF_E_FILETOOSMALL;
                goto done;
            }
            // update the directory entries for the i-th TTF file
            for (j = 0; j < offTab.numTables; j++) {
                ReadDirectoryEntry (pFileBufferInfoNew, ulOffset, &dir);
                dir.offset +=
                    (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0);
                WriteDirectoryEntry (&dir, pFileBufferInfoNew, ulOffset);
                ulOffset += sizeof(DIRECTORY);
            }
        }


        // step 3g.
        // Write the DSIG table out.

        ulOffset = pTTCInfo->pHeader->ulDsigOffset;
        if ((rv = pDsigTableNew->Write (pFileBufferInfoNew,
                       &ulOffset)) != S_OK) {
            goto done;
        }


	} else if ((pTTCInfo->pHeader->ulVersion >= TTC_VERSION_1_0) &&
               (pTTCInfo->pHeader->ulDsigTag == DSIG_LONG_TAG)) {
		// step 4.  We have a version 1 (or greater) TTC header with DSIG fields
		// step 4a.  ulDsigTableSize and ulOldDsigTableSize are the
		//           sizes of the new and old DSIG table, respectively.
		//           These variables were set in steps 1 and 2.
        //   Update the ulDsigLength field in the TTC header
        pTTCInfo->pHeader->ulDsigLength = ulDsigTableSize;
        WriteTTCHeaderTable (pTTCInfo->pFileBufferInfo, pTTCInfo->pHeader);

		if (ulDsigTableSize > ulOldDsigTableSize) {
			// step 4b. new table is larger
			// step 4b i.
            cbFile = pFileObj->GetFileObjSize();
			pFileObj->UnmapFile();
			cbFile += ulDsigTableSize - ulOldDsigTableSize;


#if MSSIPOTF_DBG
            DbgPrintf ("ulDsigTableSize = %d\n", ulDsigTableSize);
            DbgPrintf ("ulOldDsigTableSize = %d\n", ulOldDsigTableSize);
            DbgPrintf ("cbFile = %d\n", cbFile);
#endif

            if ((rv = pFileObj->MapFile (cbFile,
                            PAGE_READWRITE,
                            FILE_MAP_WRITE)) != S_OK) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in MapFile.\n");
#endif
                goto done;
			}

            pTTCInfo->pFileBufferInfo->puchBuffer = pFileObj->GetFileObjPtr();
		    pTTCInfo->pFileBufferInfo->ulBufferSize  = cbFile;

			// step 4b ii.
            ulOffset = pTTCInfo->pHeader->ulDsigOffset;
            if ((rv = pDsigTableNew->Write(pTTCInfo->pFileBufferInfo,
                               &ulOffset)) != S_OK) {
                goto done;
            }

            assert (cbFile == (pTTCInfo->pHeader->ulDsigOffset + ulDsigTableSize));

		} else if (ulDsigTableSize < ulOldDsigTableSize) {
			// step 4c. new table is smaller
			// step 4c i.
            ulOffset = pTTCInfo->pHeader->ulDsigOffset;
            if ((rv = pDsigTableNew->Write (pTTCInfo->pFileBufferInfo,
                            &ulOffset)) != S_OK) {
                goto done;
            }

			// step 4c ii.
			pFileObj->UnmapFile();

			// step 4c iii.
			cbFile -= (ulOldDsigTableSize - ulDsigTableSize);
            pFileObj->SetEndOfFileObj (cbFile);

            // verify that the DSIG table was padded
            assert (cbFile == RoundToLongWord (cbFile));

		} else {
			// old and new tables have the same size
            ulOffset = pTTCInfo->pHeader->ulDsigOffset;
            if ((rv = pDsigTableNew->Write (pTTCInfo->pFileBufferInfo,
                           &ulOffset)) != S_OK) {
                goto done;
            }

            assert (ulOffset == (pTTCInfo->pHeader->ulDsigOffset +
                pTTCInfo->pHeader->ulDsigLength));
		}

    } else {
        // bad TTC version number
#if MSSIPOTF_ERROR
        SignError ("Bad TTC version number.", NULL, FALSE);
#endif
        rv = MSSIPOTF_E_BADVERSION;
        goto done;
    }

    // We are successful if and only if we've made it this far.
    rv = S_OK;

done:

#if MSSIPOTF_DBG
    if (rv == S_OK) {
        pDsigTable->Print();
    }
#endif

    FreeTTCInfo (pTTCInfo);

    delete pDsigTable;

    if (pFileObj) {
        pFileObj->UnmapFile();
    }

    if (pFileBufferInfoNew) {
        FreeFileBufferInfo (pFileBufferInfoNew);
    }

    return rv;
}


//
// Return the digest of the TTC file.  This function acts
// as a bridge between the SIP interface and the HashTTCfile
// function.
//
// The argument usIndex tells which DsigSignature in the DSIG
// table is used to help create the hash value.  (For example,
// the DsigSignature might be a Format 2 signature, which would
// have a DsigInfo structure that is needed to determine the
// hash value of the file.)  If no such signature exists in
// the file, then a default DsigSignature is used.  To ensure
// that a default DsigSignature is used, the caller should pass
// NO_SIGNATURE as the argument to usIndex.
//
// Memory allocation: The memory allocated for *ppbDigest is
// allocated by HashTTCfile using new BYTE [] and must be
// deleted by the caller of this function.
//
HRESULT OTSIPObjectTTC::DigestFileData (CFileObj *pFileObj,
                                        HCRYPTPROV hProv,
                                        ALG_ID alg_id,
                                        BYTE **ppbDigest,
                                        DWORD *pcbDigest,
                                        USHORT usIndex,
                                        ULONG ulFormat,
                                        ULONG cbDsig,
                                        BYTE *pbDsig)
{
    BOOL rv = E_FAIL;

    ULONG ulOffset = 0;
    ULONG ulLength = 0;
    CDsigTable *pDsigTable = NULL;
	CDsigSignature *pDsigSignature = NULL;
    BOOL fDeleteDsigSignature = FALSE;
	TTFACC_FILEBUFFERINFO fileBufferInfo;
    TTC_HEADER_TABLE TTCHeader;


    TTCHeader.pulDirOffsets = NULL;

    // Check here for unsupported DSIG signature formats.
    // Currently, we only support Format 1 and Format 2.
    switch (ulFormat) {
        case DSIGSIG_FORMAT1:
            break;

        // no such thing as Format 2 signature for TTC files
        case DSIGSIG_FORMAT2:
#if MSSIPOTF_ERROR
            SignError ("Cannot continue: Signature has bad format number.",
                NULL, FALSE);
#endif
            rv = MSSIPOTF_E_DSIG_STRUCTURE;
            goto done;
            break;

        default:
#if MSSIPOTF_ERROR
            SignError ("Cannot continue: Signature has bad format number.",
                NULL, FALSE);
#endif
            rv = MSSIPOTF_E_DSIG_STRUCTURE;
            goto done;
            break;
    }

    //// Map the file to memory and pass the appropriate
	//// parameters to HashTTCfile.

	// Map the file into memory
	if ((rv = pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ))
                != S_OK) {
		*pcbDigest = 0;
		goto done;
	}

	//// Mapping was successful.
	
	// Create a TTFACC_FILEBUFFERINFO for the file.
	fileBufferInfo.puchBuffer = pFileObj->GetFileObjPtr();
	fileBufferInfo.ulBufferSize = pFileObj->GetFileObjSize();
	fileBufferInfo.ulOffsetTableOffset = 0;
	fileBufferInfo.lpfnReAllocate = &NullRealloc;

    //// Find the usIndex-th DsigSignature
    // Read in the DSIG table (if one exists)
    if ((pDsigTable = new CDsigTable) == NULL) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in new CDsigSignature.\n");
#endif
        rv = E_OUTOFMEMORY;
		goto done;
	}

    // Read in the TTC header to get the offset of the DSIG table
	if ((rv = ReadTTCHeaderTable (&fileBufferInfo,
                                  &TTCHeader)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in ReadTTCHeaderTable.\n");
#endif
		goto done;
	}

    ulOffset = TTCHeader.ulDsigOffset;
    ulLength = TTCHeader.ulDsigLength;

    // ASSERT: if there is no DSIG table, then ulOffset is 0
    // (see ReadTTCHeaderTable to confirm this.)

    if ((ulOffset == 0) ||
        (pDsigTable->Read(&fileBufferInfo, &ulOffset, ulLength) != S_OK) ||
        ((pDsigSignature = pDsigTable->GetDsigSignature (usIndex)) == NULL)) {
        // Create a default DsigSignature with a DsigSig with the
        //   appropriate format.
	    // We do this so that we can call the function HashTTCfile for the
	    //   correct format.  (We don't use the data in the object.)
	    if ((pDsigSignature = new CDsigSignature (ulFormat)) == NULL) {
#if MSSIPOTF_DBG
		    DbgPrintf ("Error in new CDsigSignature.\n");
#endif
		    *pcbDigest = 0;
            rv = E_OUTOFMEMORY;
		    goto done;
        }
        fDeleteDsigSignature = TRUE;
    }

	
#if MSSIPOTF_DBG
    DbgPrintf ("DigestFileData alg_id = %d\n", alg_id);
#endif
/*
    if (ulFormat == DSIGSIG_FORMAT2) {
        assert (alg_id == ((CDsigSigF2 *) pDsigSignature->GetDsigSig())->GetHashAlgorithm());
    }
*/

	// Generate the hash value of the TTC file.
	if ((rv = pDsigSignature->GetDsigSig()->HashTTCfile(&fileBufferInfo,
			    								ppbDigest,
				    							pcbDigest,
					    						hProv,
						    					alg_id,
                                                cbDsig,
                                                pbDsig)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in HashTTCfile.\n");
#endif
		*pcbDigest = 0;
        goto done;
	}

    rv = S_OK;

done:
    if (fDeleteDsigSignature) {
	    delete pDsigSignature;
    }
    delete pDsigTable;

    if (pFileObj) {
        pFileObj->UnmapFile();
    }

    delete [] TTCHeader.pulDirOffsets;

	return rv;
}


// Extract the dwIndex-th signature from the TTC file.
HRESULT OTSIPObjectTTC::GetSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                                          OUT     DWORD           *pdwEncodingType,
                                          IN      DWORD           dwIndex,
                                          IN OUT  DWORD           *pdwDataLen,
                                          OUT     BYTE            *pbData)
{
    HRESULT rv = E_FAIL;

    CFileObj *pFileObj = NULL;

	CDsigTable *pDsigTable = NULL;
	CDsigSignature *pDsigSignature = NULL;
	TTCInfo *pTTCInfo = NULL;

    USHORT usIndex;
    usIndex = (USHORT) dwIndex;  // will check to see if dwIndex is at most MAX_USHORT

    if (dwIndex != usIndex) {
        rv = ERROR_INVALID_PARAMETER;
        goto done;
    }

	if ((rv = GetFileObjectFromSubject(pSubjectInfo,
                        GENERIC_READ,
                        &pFileObj)) == S_OK) {

		// Map the file into memory
		if ((rv = pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ))
                != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in MapFile.\n");
#endif
			goto done;
		}

		// Get the DsigTable
		if ((rv = InitTTCStructures (pFileObj->GetFileObjPtr(),
                                     pFileObj->GetFileObjSize(),
                                     &pTTCInfo,
                                     &pDsigTable)) != S_OK) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in InitTTCStructures.\n");
#endif
			goto done;
		}

        if (pTTCInfo->pHeader->ulVersion < TTC_VERSION_1_0) {
#if MSSIPOTF_ERROR
            SignError ("Bad TTC version number (not 1.0 or greater).", NULL, FALSE);
#endif
            rv = MSSIPOTF_E_BADVERSION;
            goto done;
        }

        //// Note: we never use the TTCInfo structure in this function
        //// (except for the header version number).
		//// However, it is used in InitTTCStructures to get the DsigTable.

		//// Set the return values (length and signature and encoding type)

		if ((pDsigSignature = pDsigTable->GetDsigSignature(usIndex)) == NULL) {
#if MSSIPOTF_DBG
			DbgPrintf ("Not enough signatures.\n");
#endif
            rv = MSSIPOTF_E_DSIG_STRUCTURE;
			goto done;
		}
		pDsigSignature->GetSignatureSize(pdwDataLen);
		// If pbData == NULL, then just return the length of the signature.
		if (pbData) {
			memcpy (pbData,
				pDsigSignature->GetDsigSig()->GetSignature(),
				*pdwDataLen);
		}

		// This is the only encoding type we will return
		*pdwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;

        rv = S_OK;
	}

done:

#if MSSIPOTF_DBG
    if (rv == S_OK) {
        pDsigTable->Print();
    }
#endif

	FreeTTCInfo (pTTCInfo);

	delete pDsigTable;

    if (pFileObj) {
        pFileObj->UnmapFile();
        pFileObj->CloseFileHandle();
    }

    delete pFileObj;

    return rv;
}


// Replace the *pdwIndex-th signature with the given one in the TTC file.
// If *pdwIndex is greater than or equal to the number of signatures
// already present in the file, then append the new signature.
HRESULT OTSIPObjectTTC::PutSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                                          IN      DWORD           dwEncodingType,
                                          OUT     DWORD           *pdwIndex,
                                          IN      DWORD           dwDataLen,
                                          IN      BYTE            *pbData)
{
    HRESULT rv = E_FAIL;

    //// Here's the algorithm.
	//// 1. Map the file so that we can extract the DSIG table.
	//// 2. Create or replace the new signature in the DsigTable structure.
    //// 3. Replace the old DSIG table with the new one.

    CFileObj *pFileObj = NULL;

	ULONG cbFile = 0;		// current file size
	ULONG cbFileOld = 0;	// original file size

	TTCInfo *pTTCInfo = NULL;
	CDsigTable *pDsigTable = NULL;
	CDsigSignature *pDsigSignature = NULL;

    USHORT usIndex;
    usIndex = (USHORT) *pdwIndex;   // will late check to see if
                                    // dwIndex is at most MAX_USHORT

    if (*pdwIndex != usIndex) {
        rv = ERROR_INVALID_PARAMETER;
        goto done;
    }

    //  BUGBUG:
    //  Authenticode only supports one message!!!
    //  If the next 2 lines were deleted, then this function would
    //    allow for any number of signatures.
    *pdwIndex = 0;
    usIndex = (USHORT) *pdwIndex;

	if (dwEncodingType != (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING)) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Bad encoding type.", NULL, FALSE);
#endif
		rv = MSSIPOTF_E_CRYPT;
        goto done;
	}

	if ((rv = GetFileObjectFromSubject(pSubjectInfo,
                    GENERIC_READ | GENERIC_WRITE,
                    &pFileObj)) == S_OK) {
		//// step 1.
		// Map the file
		if ((rv = pFileObj->MapFile (0, PAGE_READWRITE, FILE_MAP_WRITE))
                    != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in MapFile.\n");
#endif
			goto done;
		}

		// Extract the DSIG table (create default DsigTable if it didn't exist)
		if ((rv = InitTTCStructures (pFileObj->GetFileObjPtr(),
                                     pFileObj->GetFileObjSize(),
                                     &pTTCInfo,
                                     &pDsigTable)) != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in InitTTCStructures.\n");
#endif
			goto done;
		}

        // pDsigTable->GetSize(&ulOldDsigTableSize);

		//// step 2.  Add the new signature to the DsigTable.

		if ((pDsigSignature = 
                new CDsigSignature (DSIGSIG_DEF_FORMAT)) == NULL) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in new CDsigSignature.\n");
#endif
            rv = E_OUTOFMEMORY;
			goto done;
		}

#if MSSIPOTF_DBG
        DbgPrintf ("hash alg OID: %s.\n", pSubjectInfo->DigestAlgorithm.pszObjId);
#endif

#if MSSIPOTF_DBG
        DbgPrintf ("pDsigSignature:\n");
        pDsigSignature->Print();
#endif

        // Add the DsigSignature to the DsigTable
        if ((rv = pDsigTable->InsertDsigSignature(pDsigSignature,
                            &usIndex)) != S_OK) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in InsertDsigSignature.\n");
#endif
            goto done;
        }

        // Make a copy of the signature, since the caller will
        // deallocate the original signature's memory, whereas
        // this function deallocates pDsigTable.
        BYTE    *pbDataLocal;

        if (!(pbDataLocal = new BYTE [dwDataLen])) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
            rv = E_OUTOFMEMORY;
			goto done;
        }
        memcpy(pbDataLocal, pbData, dwDataLen);

        if ((rv = pDsigTable->ReplaceSignature (usIndex, pbDataLocal, dwDataLen))
                != S_OK) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in ReplaceSignature.\n");
#endif
            goto done;
        }

        // ASSERT: pDsigTable now has the new signature inserted into
        //   the usIndex-th spot.
		
        //// Step 3
        if ((rv = ReplaceDsigTable (pFileObj, pDsigTable)) != S_OK) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in ReplaceDsigTable.", NULL, FALSE);
#endif
            goto done;
        }

	} else {
        // couldn't get the file object from the pSubjectInfo
#if MSSIPOTF_DBG
        DbgPrintf ("Error in GetFileObjectFromSubject.\n");
#endif
		goto done;
	}

    // We are successful if and only if we've made it this far.
	rv = S_OK;

done:

#if MSSIPOTF_DBG
    if (rv == S_OK) {
        pDsigTable->Print();
    }
#endif

	FreeTTCInfo (pTTCInfo);

	delete pDsigTable;

    if (pFileObj) {
        pFileObj->UnmapFile();
    }

    delete pFileObj;

    // if (pFileBufferInfoNew) {
    //     FreeFileBufferInfo (pFileBufferInfoNew);
    // }

    return rv;
}


//
// Remove a signature from a TTC file.  If the requested signature does
// not exist, then the file is unchanged and FALSE is returned.
//
// Authenticode currently assumes there is at most one signature in the file.
// This function does not make that assumption.
//
HRESULT OTSIPObjectTTC::RemoveSignedDataMsg (IN SIP_SUBJECTINFO  *pSubjectInfo,
                                             IN DWORD            dwIndex)
{
	//// Here's the algorithm:
	//// 1. Map the file so that we can extract the DSIG table.
	//// 2. Compute length of original DSIG table.
	//// 3. Remove the dwIndex-th DsigSignature from the DsigTable.
	//// 4. Compute length of new DSIG table.
    //// 5. Adjust the TTC header.
	//// 6. Write the new DSIG table to the file.
	//// 7. Unmap the file.
	//// 8. Set the end of file pointer to be the new size (which is
	////      old file size - (old DSIG table size - new DSIG table size) ).

    HRESULT rv = E_FAIL;

    CFileObj *pFileObj = NULL;

	ULONG cbFile = 0;
	ULONG cbFileOld = 0;

	TTCInfo *pTTCInfo = NULL;
	CDsigTable *pDsigTable = NULL;

	ULONG ulOldDsigTableSize = 0;
	ULONG ulDsigTableSize = 0;

	ULONG ulOffset;

    USHORT usIndex = 0;

    usIndex = (USHORT) dwIndex;


    if (dwIndex != usIndex) {
        rv = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if ((rv = GetFileObjectFromSubject(pSubjectInfo,
                    GENERIC_READ | GENERIC_WRITE,
                    &pFileObj)) == S_OK) {
		// step 1
		// Map the file
		if ((rv = pFileObj->MapFile (0, PAGE_READWRITE, FILE_MAP_WRITE))
                != S_OK) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in MapFile.\n");
#endif
			goto done;
		}

		// Extract the DSIG table (create default DsigTable if it didn't exist)
		if ((rv = InitTTCStructures (pFileObj->GetFileObjPtr(),
                                     pFileObj->GetFileObjSize(),
                                     &pTTCInfo,
                                     &pDsigTable)) != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in InitTTCStructures.\n");
#endif
			goto done;
		}

        // check for bad version number
        if (pTTCInfo->pHeader->ulVersion < TTC_VERSION_1_0) {
#if MSSIPOTF_ERROR
            SignError ("Bad TTC version number (not 1.0 or greater).", NULL, FALSE);
#endif
            rv = MSSIPOTF_E_BADVERSION;
            goto done;
        }

        // ASSERT: the TTC header is version 1 or greater

		// step 2
		pDsigTable->GetSize (&ulOldDsigTableSize);

		// step 3
		if ((rv = pDsigTable->RemoveDsigSignature (usIndex))
                != S_OK) {
			goto done;
		}

		// step 4
		pDsigTable->GetSize (&ulDsigTableSize);

		assert (ulDsigTableSize < ulOldDsigTableSize);

        // step 5
        pTTCInfo->pHeader->ulDsigLength = ulDsigTableSize;
        if ((rv = WriteTTCHeaderTable (pTTCInfo->pFileBufferInfo,
                       pTTCInfo->pHeader)) != S_OK) {
            goto done;
        }

        // step 6
		ulOffset = pTTCInfo->pHeader->ulDsigOffset;
		if ((rv = pDsigTable->Write (pTTCInfo->pFileBufferInfo,
                       &ulOffset)) != S_OK) {
            goto done;
        }


		assert (ulOffset ==
            (pTTCInfo->pHeader->ulDsigOffset + ulDsigTableSize));

		// step 7
        cbFile = pFileObj->GetFileObjSize();
		pFileObj->UnmapFile();

		// step 8
		cbFile -= ulOldDsigTableSize - ulDsigTableSize;
        pFileObj->SetEndOfFileObj (cbFile);

    } else {
        rv = E_FAIL;
		goto done;
	}

    rv = S_OK;

done:

#if MSSIPOTF_DBG
    if (rv == S_OK) {
        pDsigTable->Print();
    }
#endif

    FreeTTCInfo (pTTCInfo);

    delete pDsigTable;

    if (pFileObj) {
        pFileObj->UnmapFile();
    }

    delete pFileObj;

    return rv;
}


//
// Calculate the hash of the TTC file and generate a SIP_INDIRECT_DATA structure.
//
HRESULT OTSIPObjectTTC::CreateIndirectData (IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                            IN OUT  DWORD               *pdwDataLen,
                                            OUT     SIP_INDIRECT_DATA   *psData)
{
    HRESULT rv = E_FAIL;

    ULONG cbDsig = 0;
    BYTE *pbDsig = NULL;

    CFileObj *pFileObj = NULL;
    TTCInfo *pTTCInfo = NULL;
    CDsigTable *pDsigTable = NULL;

    BYTE *pbDigest = NULL;
    DWORD cbDigest;
    HCRYPTPROV hProvT;
    BOOL fDefaultProvider = FALSE;  // is TRUE iff no provider is
                                    // given in SIP_SUBJECTINFO
    SPC_LINK SpcLink;

	// Find the cryptographic provider
    hProvT = pSubjectInfo->hProv;

    if (!(hProvT)) {
        if ((rv = GetDefaultProvider(&hProvT)) != S_OK) {
            goto done;
        }
        fDefaultProvider = TRUE;
    }

    memset (&SpcLink, 0x00, sizeof(SPC_LINK));

    // Make sure the SpcLink fields have known values;
    // these values are not actually used anywhere
    SpcLink.dwLinkChoice = SPC_FILE_LINK_CHOICE;
    SpcLink.pwszFile = OBSOLETE_TEXT_W;


    // needed by signer.dll -- not needed by the OT SIP
    pSubjectInfo->dwIntVersion = WIN_CERT_REVISION_2_0;


    if (!(psData)) {
		//// The caller is requesting only the size of the
		//// SIP_INDIRECT_DATA object to allocate the right
		//// amount of space.
        HCRYPTHASH  hHash;
        DWORD       dwRetLen;
        DWORD       dwEncLen;
        DWORD       dwAlgId;

		// non-pointer fields of the SIP_INDIRECT_DATA structure
        dwRetLen = sizeof(SIP_INDIRECT_DATA);

        // crypt_algorithm_identifier size
            // obj id
        dwRetLen += strlen(pSubjectInfo->DigestAlgorithm.pszObjId);
        dwRetLen += 1;  // null term
            // parameters (none)

        // crypt_attribute_type_value size
		  // size of the obj id
        dwRetLen += strlen(GetTTCObjectID());
        dwRetLen += 1; // null term

        // size of the attribute value
        dwEncLen = 0;

        // Encode the SpcLink
        CryptEncodeObject (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                           GetTTCObjectID (),
                           &SpcLink,
                           NULL,
                           &dwEncLen);

        if (dwEncLen == 0) {
#if MSSIPOTF_ERROR
            SignError ("Bad encoding length from CryptEncodeObject.", NULL, FALSE);
#endif
            rv = MSSIPOTF_E_CRYPT;
            goto done;
        }

        dwRetLen += dwEncLen;

        // get the length of the hash value of the subject
        if ((dwAlgId = CertOIDToAlgId(pSubjectInfo->DigestAlgorithm.pszObjId)) == 0) {
            rv = NTE_BAD_ALGID;
            goto done;
        }

        if (!(CryptCreateHash(hProvT, dwAlgId, NULL, 0, &hHash))) {
            rv = MSSIPOTF_E_CRYPT;
            goto done;
        }

        if (CryptHashData(hHash,(const BYTE *)" ", 1, 0)) {
            cbDigest = 0;

            CryptGetHashParam(hHash, HP_HASHVAL, NULL, &cbDigest,0);

            if (cbDigest > 0) {
                CryptDestroyHash(hHash);

                dwRetLen += cbDigest;
                *pdwDataLen = dwRetLen;

                rv = S_OK;
                goto done;
            }
        } else {
            rv = MSSIPOTF_E_CRYPT;
        }

        CryptDestroyHash(hHash);
        goto done;

    } else if ((rv = GetFileObjectFromSubject (pSubjectInfo,
                        GENERIC_READ,
                        &pFileObj)) == S_OK) {

        USHORT usFlagNew;
        ALG_ID alg_id;
        BOOL fKeepDefFlags = FALSE;


        usFlagNew = DSIG_DEFAULT_FLAG_HIGH * FLAG_RADIX +
            DSIG_DEFAULT_FLAG_LOW;

	    if ((rv = pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ))
                    != S_OK) {
#if MSSIPOTF_DBG
		    DbgPrintf ("Error in MapFile.\n");
#endif
		    goto done;
	    }

		// Extract the DSIG table (create default DsigTable if it didn't exist)
		if ((rv = InitTTCStructures (pFileObj->GetFileObjPtr(),
                                     pFileObj->GetFileObjSize(),
                                     &pTTCInfo,
                                     &pDsigTable)) != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in InitTTCStructures.\n");
#endif
			goto done;
		}

		//// The caller is requesting the SIP_INDIRECT_DATA
		//// structure for the given file.

		// First, create the hash value for the file (using the hash algorithm
        // in the subject info structure).

        cbDsig = sizeof(USHORT);
        if ((pbDsig = new BYTE [cbDsig]) == NULL) {
#if MSSIPOTF_ERROR
           SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
            rv = E_OUTOFMEMORY;
            goto done;
        }

        pbDsig [0] = (BYTE) usFlagNew / FLAG_RADIX;  // high byte
        pbDsig [1] = (BYTE) usFlagNew % FLAG_RADIX;  // low byte
#if MSSIPOTF_DBG
        DbgPrintf ("pbDsig bytes:\n");
        PrintBytes (pbDsig, 2);
#endif

        alg_id = CertOIDToAlgId (pSubjectInfo->DigestAlgorithm.pszObjId);

        if ((rv = DigestFileData (pFileObj,
                                  hProvT,
                                  alg_id,
                                  &pbDigest,
                                  &cbDigest,
                                  NO_SIGNATURE,
                                  DSIGSIG_TTC_DEF_FORMAT,
                                  cbDsig,
                                  pbDsig)) == S_OK) {
            ULONG_PTR  dwOffset;
            DWORD     dwRetLen;

            BYTE *pbAttrData = NULL;  // pointer to encoded blob

            dwRetLen = 0;
 
            // get the length of the encoding
            if (!CryptEncodeObject (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                    GetTTCObjectID (),
                                    &SpcLink,
                                    NULL,
                                    &dwRetLen)) {
		        rv = HRESULT_FROM_WIN32(GetLastError());
		        goto done;
	        }


            if ((pbAttrData = new BYTE [dwRetLen]) == NULL) {
#if MSSIPOTF_ERROR
                SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
                rv = E_OUTOFMEMORY;
                goto done;
            }

            // Get the actual encoding
            if (!CryptEncodeObject (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                    GetTTCObjectID (),
                                    &SpcLink,
                                    pbAttrData,
                                    &dwRetLen)) {
		        rv = HRESULT_FROM_WIN32(GetLastError());
		        goto done;
	        }


            dwOffset = (ULONG_PTR) psData + sizeof(SIP_INDIRECT_DATA);

			// obj id of the attribute type value
            strcpy((char *) dwOffset, GetTTCObjectID());
            psData->Data.pszObjId   = (LPSTR)dwOffset;
            dwOffset += (strlen(GetTTCObjectID()) + 1);

			// the encoded blob
            memcpy((void *)dwOffset, pbAttrData, dwRetLen);
            psData->Data.Value.pbData   = (BYTE *)dwOffset;
            psData->Data.Value.cbData   = dwRetLen;
            dwOffset += (ULONG_PTR) dwRetLen;

			// the algorithm identifier
            strcpy((char *)dwOffset, (char *)pSubjectInfo->DigestAlgorithm.pszObjId);
            psData->DigestAlgorithm.pszObjId            = (char *) dwOffset;
            psData->DigestAlgorithm.Parameters.cbData   = 0;
            psData->DigestAlgorithm.Parameters.pbData   = NULL;
            dwOffset += (strlen(pSubjectInfo->DigestAlgorithm.pszObjId) + 1);

			// the actual digest (the hash value of the file)
            memcpy((void *)dwOffset, pbDigest, cbDigest);
            psData->Digest.pbData   = (BYTE *) dwOffset;
            psData->Digest.cbData   = cbDigest;

#if MSSIPOTF_DBG
            DbgPrintf ("dwOffset = %d\n", dwOffset + cbDigest);
#endif
        
            rv = S_OK;

            delete [] pbAttrData;

            goto done;
        }
    }

done:
    if (pFileObj) {
        pFileObj->UnmapFile();
    }
    FreeTTCInfo (pTTCInfo);
    delete pDsigTable;

    delete [] pbDsig;
    delete [] pbDigest;

    if (hProvT && fDefaultProvider) {
        CryptReleaseContext (hProvT, 0);
    }

    delete pFileObj;

    return rv;
}


// Given a signature, verify that its associated hash value
// matches that of the given file.
HRESULT OTSIPObjectTTC::VerifyIndirectData (IN SIP_SUBJECTINFO      *pSubjectInfo,
                                            IN SIP_INDIRECT_DATA    *psData)
{
    HRESULT rv = E_FAIL;

    HCRYPTPROV hProvT = NULL;
    BOOL fDefaultProvider = FALSE;  // is TRUE iff no provider is
                                    // given in SIP_SUBJECTINFO
    HANDLE hFile = NULL;
    CFileObj *pFileObj = NULL;

    TTCInfo *pTTCInfo = NULL;
    CDsigTable *pDsigTable = NULL;

    ULONG cbDsig = 0;
    BYTE *pbDsig = NULL;

    DWORD cbDigest = 0;
    BYTE *pbDigest = NULL;

    ALG_ID alg_id;


/*
    if (!(psData)) {
        if (GetFileHandleFromSubject(pSubjectInfo, GENERIC_READ, &hFile)) {
			// if the file exists, set bad parameter!
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        }
        goto done;
    }
*/

    // Find the cryptographic provider
    hProvT = pSubjectInfo->hProv;

    if (!(hProvT)) {
        if ((rv = GetDefaultProvider(&hProvT)) != S_OK) {
            goto done;
        }
        fDefaultProvider = TRUE;
    }

    if ((rv = GetFileObjectFromSubject(pSubjectInfo,
                    GENERIC_READ,
                    &pFileObj)) == S_OK) {

        USHORT usIndex = 0;
        DWORD dwRetLen;
    	ULONG ulFormat;
        USHORT usFlag;

        dwRetLen = 0;

        if ((rv = pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ))
                    != S_OK) {
#if MSSIPOTF_DBG
		    DbgPrintf ("Error in MapFile.\n");
#endif
		    goto done;
	    }

	    if ((rv = InitTTCStructures (pFileObj->GetFileObjPtr(),
                                     pFileObj->GetFileObjSize(),
                                     &pTTCInfo,
                                     &pDsigTable)) != S_OK) {
#if MSSIPOTF_DBG
		    DbgPrintf ("Error in InitTTCStructures.\n");
#endif
		    goto done;
	    }

        // make sure the TTC file has a version 1 or greater header
        if (pTTCInfo->pHeader->ulVersion < TTC_VERSION_1_0) {
#if MSSIPOTF_ERROR
            SignError ("Bad TTC version number (less than 1.0).", NULL, FALSE);
#endif
            rv = MSSIPOTF_E_BADVERSION;
            goto done;
        }

        // ASSERT: the TTC header is version 1 or greater

        usIndex = (USHORT) pSubjectInfo->dwIndex;
        // Check to see if dwIndex is at most MAX_USHORT
        if (pSubjectInfo->dwIndex != usIndex) {
#if MSSIPOTF_ERROR
            SignError ("Cannot continue: Bad index to Verify.", NULL, FALSE);
#endif
            rv = ERROR_INVALID_PARAMETER;
            goto done;
        }

		// Find out what the format is for the signature in the
		// DSIG table with the given index.
		ulFormat = pDsigTable->GetDsigSignature(usIndex)->GetFormat();

        // Retrieve the flag field from the DSIG table.
        // These bytes will be used as part of the hash.
        usFlag = pDsigTable->GetFlag ();

        // Compute the hash value for the file and compare it to the hash
        // value in the SIP_INDIRECT_DATA structure.

        alg_id = CertOIDToAlgId (psData->DigestAlgorithm.pszObjId);
#if MSSIPOTF_DBG
        DbgPrintf ("alg_id = %d\n", alg_id);
#endif

        cbDsig = sizeof(USHORT);
        if ((pbDsig = new BYTE [cbDsig]) == NULL) {
#if MSSIPOTF_ERROR
            SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
            rv = E_OUTOFMEMORY;
            goto done;
        }

        pbDsig [0] = (BYTE) (usFlag / FLAG_RADIX);  // high byte
        pbDsig [1] = (BYTE) (usFlag % FLAG_RADIX);  // low byte
#if MSSIPOTF_DBG
        DbgPrintf ("pbDsig bytes:\n");
        PrintBytes (pbDsig, 2);
#endif

        if ((rv = DigestFileData (pFileObj,
                                  hProvT,
                                  alg_id,
                                  &pbDigest,
                                  &cbDigest,
                                  (USHORT) pSubjectInfo->dwIndex,
                                  ulFormat,
                                  cbDsig,
                                  pbDsig)) == S_OK) {

            if ((cbDigest != psData->Digest.cbData) ||
                    (memcmp(pbDigest,psData->Digest.pbData,cbDigest) != 0)) {
                rv = TRUST_E_BAD_DIGEST;
                goto done;
            }

            rv = S_OK;
            goto done;
        }
    }

done:

    delete [] pbDsig;
    delete [] pbDigest;

    if (hProvT && fDefaultProvider) {
        CryptReleaseContext (hProvT, 0);
    }

    FreeTTCInfo (pTTCInfo);
    delete pDsigTable;

    if (pFileObj) {
        pFileObj->UnmapFile();
        pFileObj->CloseFileHandle();
    }
    delete pFileObj;

    return rv;
}


// Return the OID of the structure in the attribute_type_value field of
// the SIP_INDIRECT_DATA structure.
char *OTSIPObjectTTC::GetTTCObjectID ()
{
    return (SPC_LINK_OBJID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sip\sipobotf.cpp ===
//
// sipobotf.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//


#include "sipobotf.h"

#include "signglobal.h"

#include "mssipotf.h"
#include "fileobj.h"
#include "sign.h"
#include "glyphExist.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "ttfinfo.h"
#include "hTTFfile.h"

#include "subset.h"
#ifdef __cplusplus
extern "C" {
#endif
#include "fsverify.h"
#ifdef __cplusplus
}
#endif

#include "signerr.h"


// If there is no DSIG table, add one with no signatures.
// If there is a DSIG table, change its flags field.
// This function assumes that pFileObj has not been mapped
// before invocation.
// The parameters pTTFinfo and pDsigTableOld should be the
// arguments passed back from a call to InitTTFStructures.
// (The caller of this function should call InitTTFStructures
// before calling this function.)
HRESULT OTSIPObjectOTF::ReplaceDsigTable (CFileObj *pFileObj,
                                          CDsigTable *pDsigTableNew)
{
    HRESULT rv = E_FAIL;

    TTFInfo *pTTFInfo;
    CDsigTable *pDsigTableOld = NULL;
    BOOL fDsig;
    TTFACC_FILEBUFFERINFO dsigBufferInfo;

    ULONG cbFileOld;
    ULONG cbFile;
    ULONG ulOffset;
    DIRECTORY dir;
    BOOL fDone;
    USHORT i;

    ULONG ulOldDsigTableSize;
    ULONG ulDsigTableSize;

    ////
    //// The algorithm is:
    //// 1. Map the file and extract the DSIG table.
    //// 2. Write the new DSIG table to a buffer.
    //// 3. If there was no DSIG table in the file, then
    ////      insert the new DSIG table in the file.
    //// 4. If there was a DSIG table in the file, then
    ////      replace it with the new one.
    //// 5. Update the directory entry for the DSIG table.
    //// 6. Recompute the file checksum in the head table.
    ////

	dsigBufferInfo.puchBuffer = NULL;
	dsigBufferInfo.lpfnReAllocate = NULL;	// this value isn't used

    //// Step 1
	// Map the file
	if ((rv = pFileObj->MapFile (0, PAGE_READWRITE, FILE_MAP_WRITE))
            != S_OK) {
#if MSSIPOTF_DBG
	    DbgPrintf ("Error in MapFile.\n");
#endif
		goto done;
	}

    // Extract the DSIG table (create a default DsigTable if it didn't exist)
    if ((rv = InitTTFStructures (pFileObj->GetFileObjPtr(),
                                 pFileObj->GetFileObjSize(),
                                 &pTTFInfo, &pDsigTableOld))
                             != S_OK) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in InitTTFStructure.\n");
#endif
        goto done;
    }

    //// Step 2
	//// Determine whether there was a DSIG table or not
	fDsig =
		// This call assumes we won't get a read error, since it passed
        // InitTTFStructures (which does checks on the directory entries).
		(TTDirectoryEntryOffset (pTTFInfo->pFileBufferInfo, DSIG_TAG) ==
		DIRECTORY_ERROR) ? FALSE : TRUE;

	// If there was a DSIG table, we need to remember how big it is
	// before modifying it.
	if (fDsig) {
		pDsigTableOld->GetSize(&ulOldDsigTableSize);
    }

	// write the DSIG table to a buffer
	pDsigTableNew->GetSize(&ulDsigTableSize);

	if ((dsigBufferInfo.puchBuffer = new BYTE [ulDsigTableSize]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
        rv = E_OUTOFMEMORY;
		goto done;
	}
	dsigBufferInfo.ulBufferSize = ulDsigTableSize;
	dsigBufferInfo.ulOffsetTableOffset = 0;			// this value isn't used
	dsigBufferInfo.lpfnReAllocate = &NullRealloc;	// this value isn't used

	ulOffset = 0;
    if ((rv = pDsigTableNew->Write (&dsigBufferInfo, &ulOffset))
            != S_OK) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in CDsigTable::Write.\n");
#endif
        goto done;
    }

    //// ASSERT: At this point, the dsigBufferInfo contains the bytes
    //// that need to be written to the new file.

#if MSSIPOTF_DBG
        DbgPrintf ("ulOffset = %d, ulDsigTableSize = %d.\n", ulOffset, ulDsigTableSize);
#endif
    assert (RoundToLongWord(ulOffset) == ulDsigTableSize);
		
	if (!fDsig) {
		//// step 3.  There was no DSIG table
		// step 3a. the call to InitTTFStructures handled this
		// step 3b. this was done in step 2

		// step 3c.
        cbFileOld = pFileObj->GetFileObjSize();
		pFileObj->UnmapFile();

		cbFile = cbFileOld + SIZEOF_DIRECTORY + ulDsigTableSize;

		if ((rv = pFileObj->MapFile (cbFile, PAGE_READWRITE, FILE_MAP_WRITE))
                != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in MapFile.\n");
#endif
			goto done;
		}
		pTTFInfo->pFileBufferInfo->puchBuffer = pFileObj->GetFileObjPtr();
		pTTFInfo->pFileBufferInfo->ulBufferSize = pFileObj->GetFileObjSize();

		// step 3d.
		fDone = FALSE;
		for (ulOffset = SIZEOF_OFFSET_TABLE, i = 0;
				(i < pTTFInfo->pOffset->numTables) && !fDone;
				i++) {

			ReadDirectoryEntry (pTTFInfo->pFileBufferInfo, ulOffset, &dir);
			if (DSIG_LONG_TAG < dir.tag) {
				fDone = TRUE;
			}
            else
            {
                ulOffset += SIZEOF_DIRECTORY;
            }
		}

		//// ASSERT: ulOffset is where the DSIG entry should be.
		//// ASSERT: i is index of the entry just after the DSIG entry in
		////           the modified directory.

		// move the bytes after the DSIG directory entry
		// down SIZEOF_DIRECTORY bytes

		memmove (
			pFileObj->GetFileObjPtr() + ulOffset + SIZEOF_DIRECTORY,
            pFileObj->GetFileObjPtr() + ulOffset,
			cbFileOld - ulOffset);

		// step 3e.
		dir.tag = DSIG_LONG_TAG;
		dir.checkSum = 0;  // this will be updated later
		dir.offset = cbFileOld;
		dir.length = ulDsigTableSize;
		WriteDirectoryEntry (&dir, pTTFInfo->pFileBufferInfo, ulOffset);

        // ASSERT: At this point, all directory entry offsets are off by
        // SIZEOF_DIRECTORY.

		// step 3f.
		ulOffset = SIZEOF_OFFSET_TABLE;
		// ulOffset now points to the first directory entry
		for (i = 0; i < (pTTFInfo->pOffset->numTables + 1);
				ulOffset += SIZEOF_DIRECTORY, i++) {
			ReadDirectoryEntry (pTTFInfo->pFileBufferInfo, ulOffset, &dir);
			dir.offset += SIZEOF_DIRECTORY;
			WriteDirectoryEntry (&dir,pTTFInfo->pFileBufferInfo, ulOffset);
		}

		// step 3g.
		if (InsertTable (pTTFInfo->pFileBufferInfo, (BYTE *)DSIG_TAG,
				dsigBufferInfo.puchBuffer, ulDsigTableSize) != NO_ERROR) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in InsertTable.\n");
#endif
            rv = MSSIPOTF_E_FILE;
			goto done;
        }

		// step 3h.
		OFFSET_TABLE offTable;

		offTable.version = pTTFInfo->pOffset->version;
		offTable.numTables = pTTFInfo->pOffset->numTables + 1;

        CalcOffsetTable (&offTable);
		WriteOffsetTable (&offTable, pTTFInfo->pFileBufferInfo);

	} else {
		//// step 4.  There was a DSIG table
		// step 4a.  ulDsigTableSize and ulOldDsigTableSize are the
		//           sizes of the new and old DSIG table, respectively.
		//           These variables were set in steps 1 and 2.
        cbFile = pFileObj->GetFileObjSize();
		if (ulDsigTableSize > ulOldDsigTableSize) {
			// step 4b. new table is larger
			// step 4b i.
			pFileObj->UnmapFile();
			cbFile += ulDsigTableSize - ulOldDsigTableSize;


#if MSSIPOTF_DBG
            DbgPrintf ("ulDsigTableSize = %d\n", ulDsigTableSize);
            DbgPrintf ("ulOldDsigTableSize = %d\n", ulOldDsigTableSize);
            DbgPrintf ("cbFile = %d\n", cbFile);
#endif

            if ((rv = pFileObj->MapFile (cbFile, PAGE_READWRITE, FILE_MAP_WRITE))
                    != S_OK) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in MapFile.\n");
#endif
				goto done;
			}
            pTTFInfo->pFileBufferInfo->puchBuffer = pFileObj->GetFileObjPtr();
            // We don't need to update the buffer size field of
            // of the TTFInfo structure because InsertTable will
            // do that for us.
		    //   pTTFInfo->pFileBufferInfo->ulBufferSize  = cbFile;

			// step 4b ii.
			if (InsertTable (pTTFInfo->pFileBufferInfo,
                             (BYTE *)DSIG_TAG,
                             dsigBufferInfo.puchBuffer,
                             ulDsigTableSize) != NO_ERROR) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in InsertTable.\n");
#endif
                rv = MSSIPOTF_E_FILE;
				goto done;
			}

		} else if (ulDsigTableSize < ulOldDsigTableSize) {
			// step 4c. new table is smaller
			// step 4c i.
			if (InsertTable (pTTFInfo->pFileBufferInfo,
                             (BYTE *)DSIG_TAG,
                             dsigBufferInfo.puchBuffer,
                             ulDsigTableSize) != NO_ERROR) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in InsertTable.\n");
#endif
                rv = MSSIPOTF_E_FILE;
				goto done;
			}

			// step 4c ii.
			pFileObj->UnmapFile();

			// step 4c iii.
			cbFile -= (ulOldDsigTableSize - ulDsigTableSize);
            pFileObj->SetEndOfFileObj (cbFile);

			// step 4d iv.
			if ((rv = pFileObj->MapFile (cbFile, PAGE_READWRITE, FILE_MAP_WRITE))
                    != S_OK) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in MapFile.\n");
#endif
				goto done;
			}
			pTTFInfo->pFileBufferInfo->puchBuffer = pFileObj->GetFileObjPtr();
			pTTFInfo->pFileBufferInfo->ulBufferSize = pFileObj->GetFileObjSize();

            assert (cbFile == pFileObj->GetFileObjSize());

		} else {
			// old and new tables have the same size
			if (InsertTable (pTTFInfo->pFileBufferInfo, (BYTE *)DSIG_TAG,
					dsigBufferInfo.puchBuffer, ulDsigTableSize) != NO_ERROR) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in InsertTable.\n");
#endif
                rv = MSSIPOTF_E_FILE;
				goto done;
			}
		}
	}

	//// ASSERT: cbFile is the length of the new file.

	//// step 5
	// ASSERT: the offset field of the DSIG table directory entry
	//   should be correct.  Hence, we can safely call UpdateDirEntry.

	if (UpdateDirEntry (pTTFInfo->pFileBufferInfo, DSIG_TAG, ulDsigTableSize)
			!= NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in UpdateDirEntry.\n");
#endif
        rv = MSSIPOTF_E_FILE;
		goto done;
	}

	//// step 6
	// Recompute the head table checksum for the entire file
	SetFileChecksum (pTTFInfo->pFileBufferInfo, cbFile);

    rv = S_OK;

done:
#if MSSIPOTF_DBG
    if (rv == S_OK) {
        pDsigTableNew->Print();
    }
#endif

	delete [] dsigBufferInfo.puchBuffer;

    FreeTTFInfo (pTTFInfo);

    delete pDsigTableOld;

    if (pFileObj) {
        pFileObj->UnmapFile();
    }

    return rv;
}


//
// Return the digest of the TTF file.  This function acts
// as a bridge between the SIP interface and the HashTTFfile
// function.
//
// The argument usIndex tells which DsigSignature in the DSIG
// table is used to help create the hash value.  (For example,
// the DsigSignature might be a Format 2 signature, which would
// have a DsigInfo structure that is needed to determine the
// hash value of the file.)  If no such signature exists in
// the file, then a default DsigSignature is used.  To ensure
// that a default DsigSignature is used, the caller should pass
// NO_SIGNATURE as the argument to usIndex.
//
// Memory allocation: The memory allocated for *ppbDigest is
// allocated by HashTTFfile using new BYTE [] and must be
// deleted by the caller of this function.
//
HRESULT OTSIPObjectOTF::DigestFileData (CFileObj *pFileObj,
                                        HCRYPTPROV hProv,
                                        ALG_ID alg_id,
                                        BYTE **ppbDigest,
                                        DWORD *pcbDigest,
                                        USHORT usIndex,
                                        ULONG ulFormat,
                                        ULONG cbDsig,
                                        BYTE *pbDsig)
{
    BOOL rv = E_FAIL;

    int32 fError;
    DIRECTORY dir;
    ULONG ulOffset = 0;
    ULONG ulLength = 0;
    CDsigTable *pDsigTable = NULL;
	CDsigSignature *pDsigSignature = NULL;
    BOOL fDeleteDsigSignature = FALSE;
	TTFACC_FILEBUFFERINFO fileBufferInfo;

    // Check here for unsupported DSIG signature formats.
    // Currently, we only support Format 1 and Format 2.
    switch (ulFormat) {
        case DSIGSIG_FORMAT1:
#if ENABLE_FORMAT2
        case DSIGSIG_FORMAT2:
#endif
            break;

        default:
#if MSSIPOTF_ERROR
            SignError ("Cannot continue: Signature has a bad format number.",
                NULL, FALSE);
#endif
            rv = MSSIPOTF_E_DSIG_STRUCTURE;
            goto done;
            break;
    }

    //// Map the file to memory and pass the appropriate
	//// parameters to HashTTFfile.

	// Map the file into memory
	if ((rv = pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ))
            != S_OK) {
		*pcbDigest = 0;
		goto done;
	}

	//// Mapping was successful.
	
	// Create a TTFACC_FILEBUFFERINFO for the file.
	fileBufferInfo.puchBuffer = pFileObj->GetFileObjPtr();
	fileBufferInfo.ulBufferSize = pFileObj->GetFileObjSize();
	fileBufferInfo.ulOffsetTableOffset = 0;
	fileBufferInfo.lpfnReAllocate = &NullRealloc;

    //// Find the usIndex-th DsigSignature
    // Read in the DSIG table (if one exists)
    if ((pDsigTable = new CDsigTable) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CDsigSignature.", NULL, FALSE);
#endif
        rv = E_OUTOFMEMORY;
		goto done;
	}

    fError = GetTTDirectory (&fileBufferInfo, DSIG_TAG, &dir);
    ulOffset = dir.offset;
    ulLength = dir.length;

    if ((fError == DIRECTORY_ERROR) ||
        (pDsigTable->Read (&fileBufferInfo, &ulOffset, ulLength) != S_OK) ||
        ((pDsigSignature = pDsigTable->GetDsigSignature (usIndex)) == NULL)) {
        // Create a default DsigSignature with a DsigSig with the
        //   appropriate format.
	    // We do this so that we can call the function HashTTFfile for the
	    //   correct format.  (We don't use the data in the object.)
	    if ((pDsigSignature = new CDsigSignature (ulFormat)) == NULL) {
#if MSSIPOTF_ERROR
		    SignError ("Cannot continue: Error in new CDsigSignature.", NULL, FALSE);
#endif
		    *pcbDigest = 0;
            rv = E_OUTOFMEMORY;
		    goto done;
        }
        fDeleteDsigSignature = TRUE;
    }

	
#if MSSIPOTF_DBG
    DbgPrintf ("DigestFileData alg_id = %d\n", alg_id);
#endif
#if ENABLE_FORMAT2
    if (ulFormat == DSIGSIG_FORMAT2) {
        assert (alg_id == ((CDsigSigF2 *) pDsigSignature->GetDsigSig())->GetHashAlgorithm());
    }
#endif

	// Generate the hash value of the TTF file.
	if ((rv = pDsigSignature->GetDsigSig()->HashTTFfile(&fileBufferInfo,
                                            ppbDigest,
                                            pcbDigest,
                                            hProv,
                                            alg_id,
                                            cbDsig,
                                            pbDsig)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in HashTTFfile.\n");
#endif
		*pcbDigest = 0;
        goto done;
	}

    rv = S_OK;

done:
    if (fDeleteDsigSignature) {
	    delete pDsigSignature;
    }
    delete pDsigTable;

    if (pFileObj) {
        pFileObj->UnmapFile();
    }

	return rv;
}


// Extract the dwIndex-th signature from the OTF file.
HRESULT OTSIPObjectOTF::GetSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                                          OUT     DWORD           *pdwEncodingType,
                                          IN      DWORD           dwIndex,
                                          IN OUT  DWORD           *pdwDataLen,
                                          OUT     BYTE            *pbData)
{
    HRESULT rv = E_FAIL;

    CFileObj *pFileObj = NULL;

	CDsigTable *pDsigTable = NULL;
	CDsigSignature *pDsigSignature = NULL;
	TTFInfo *pTTFInfo = NULL;

    USHORT usIndex;
    usIndex = (USHORT) dwIndex;  // will check to see if dwIndex is at most MAX_USHORT

    if (dwIndex != usIndex) {
        rv = ERROR_INVALID_PARAMETER;
        goto done;
    }

	if ((rv = GetFileObjectFromSubject(pSubjectInfo,
                                GENERIC_READ,
                                &pFileObj)) == S_OK) {

		// Map the file into memory
		if ((rv = pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ))
                != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in MapFile.\n");
#endif
			goto done;
		}

		// Get the DsigTable
		if ((rv = InitTTFStructures (pFileObj->GetFileObjPtr(),
                                     pFileObj->GetFileObjSize(),
                                     &pTTFInfo, &pDsigTable))
                                != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in InitTTFStructures.\n");
#endif
			goto done;
		}

		//// Note: we never use the TTFInfo structure in this function.
		//// However, it is used in InitTTFStructures to get the DsigTable.

		//// Set the return values (length and signature and encoding type)

		if ((pDsigSignature = pDsigTable->GetDsigSignature(usIndex)) == NULL) {
#if MSSIPOTF_DBG
			DbgPrintf ("Not enough signatures.\n");
#endif
            rv = MSSIPOTF_E_DSIG_STRUCTURE;
			goto done;
		}
		pDsigSignature->GetSignatureSize(pdwDataLen);
		// If pbData == NULL, then just return the length of the signature.
		if (pbData) {
			memcpy (pbData,
				pDsigSignature->GetDsigSig()->GetSignature(),
				*pdwDataLen);
		}

		// This is the only encoding type we will return
		*pdwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;

        rv = S_OK;
    } else {
        // couldn't get file object from subject
        rv = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

done:

#if MSSIPOTF_DBG
    if (rv == S_OK) {
        pDsigTable->Print();
    }
#endif

	FreeTTFInfo (pTTFInfo);

	delete pDsigTable;

    if (pFileObj) {
        pFileObj->UnmapFile();
        pFileObj->CloseFileHandle();
    }

    delete pFileObj;

    return rv;
}


// Replace the *pdwIndex-th signature with the given one in the OTF file.
// If *pdwIndex is greater than or equal to the number of signatures
// already present in the file, then append the new signature.
HRESULT OTSIPObjectOTF::PutSignedDataMsg (IN      SIP_SUBJECTINFO *pSubjectInfo,
                                          IN      DWORD           dwEncodingType,
                                          OUT     DWORD           *pdwIndex,
                                          IN      DWORD           dwDataLen,
                                          IN      BYTE            *pbData)
{
	BOOL rv = E_FAIL;

    //// Here's the algorithm.
	//// 1. Map the file so that we can extract the DSIG table.
	//// 2. Create or replace the new signature in the DsigTable structure.
    //// 3. Replace the old DSIG table with the new one.


    CFileObj *pFileObj = NULL;

	ULONG cbFile = 0;		// current file size
	ULONG cbFileOld = 0;	// original file size

	TTFInfo *pTTFInfo = NULL;
	CDsigTable *pDsigTable = NULL;
	CDsigSignature *pDsigSignature = NULL;
    CDsigInfo *pDsigInfoNew = NULL;

    USHORT usIndex;
    usIndex = (USHORT) *pdwIndex;   // will late check to see if
                                    // dwIndex is at most MAX_USHORT

    if (*pdwIndex != usIndex) {
        rv = ERROR_INVALID_PARAMETER;
        goto done;
    }

    //  BUGBUG:
    //  Authenticode only supports one message!!!
    //  If the next 2 lines were deleted, then this function would
    //    allow for any number of signatures.
    *pdwIndex = 0;
    usIndex = (USHORT) *pdwIndex;

	// Initialize to NULL in case an error occurs in the middle
	// of the routine.
	//dsigBufferInfo.puchBuffer = NULL;

	if (dwEncodingType != (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING)) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Bad encoding type.", NULL, FALSE);
#endif
		rv = MSSIPOTF_E_CRYPT;
	}

	if ((rv = GetFileObjectFromSubject(pSubjectInfo,
                    GENERIC_READ | GENERIC_WRITE,
                    &pFileObj)) == S_OK) {
		//// step 1.
		// Map the file
		if ((rv = pFileObj->MapFile (0, PAGE_READWRITE, FILE_MAP_WRITE))
                != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in MapFile.\n");
#endif
			goto done;
		}

		// Extract the DSIG table (create default DsigTable if it didn't exist)
		if ((rv = InitTTFStructures (pFileObj->GetFileObjPtr(),
                                     pFileObj->GetFileObjSize(),
                                     &pTTFInfo, &pDsigTable))
                                 != S_OK) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in InitTTFStructures.\n");
#endif
			goto done;
		}

		//// step 2.  Add the new signature to the DsigTable.  Write the
		//// new DsigTable in a buffer.

		if ((pDsigSignature = 
                new CDsigSignature (DSIGSIG_DEF_FORMAT)) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new CDsigSignature.", NULL, FALSE);
#endif
            rv = E_OUTOFMEMORY;
			goto done;
		}

        // For format 2 DsigSig's, we need to set the hash algorithm
        // field to whatever was passed into this function.
#if MSSIPOTF_DBG
        DbgPrintf ("hash alg OID: %s.\n", pSubjectInfo->DigestAlgorithm.pszObjId);
#endif

#if ENABLE_FORMAT2
        if (pDsigSignature->GetFormat() == DSIGSIG_FORMAT2) {
            ((CDsigSigF2 *) pDsigSignature->GetDsigSig())->GetDsigInfo()->
                SetHashAlgorithm(CertOIDToAlgId(pSubjectInfo->DigestAlgorithm.pszObjId));

                //// BUGBUG: This is a total HACK!!  This line should be deleted
                //// when the code can handle any hash algorithm.
            ((CDsigSigF2 *) pDsigSignature->GetDsigSig())->GetDsigInfo()->
                SetHashAlgorithm(CALG_MD5);
            //// BUGBUG: The above code will have to be replaced by code
            //// that actually cracks the PKCS #7 packet to determine
            //// what hash algorithm was used.  Why?  Because the signer
            //// code has no idea what hash algorithm was used to sign
            //// after it calls the timestamping code.
            ////
            //// However, we will eventually not need this code at all, since
            //// the ulHashAlgorithm and ulHashValueLength will not actually
            //// be written to the file.
            ////

            //// We need to copy the old DsigInfo structure into the
            //// DsigSignature if that signature existed in the old
            //// DSIG table.  (Up until now, the default DsigInfo structure
            //// has worked, but only because we used font files where there
            //// was no need for hash values for missing glyphs.)
            ////
            //// If there was no usIndex-th signature, then we need to generate
            //// the DsigInfo from scratch, which will require us to crack the
            //// PKCS #7 packet.  (Again, until now the default DsigInfo has
            //// worked.)
            if ((pDsigTable->GetNumSigs() > usIndex) &&
                (pDsigTable->GetDsigSignature(usIndex)->GetFormat() ==
                    DSIGSIG_FORMAT2)) {

                CDsigInfo *pDsigInfoOld = NULL;

                //// Copy the old DsigInfo into the DsigSignature
#if MSSIPOTF_DBG
                DbgPrintf ("Copying old DsigInfo into new DsigSignature ...\n");
#endif

                if ((pDsigInfoNew = new CDsigInfo) == NULL) {
#if MSSIPOTF_ERROR
                    SignError ("Cannot continue: Error in new CDsigInfo.", NULL, FALSE);
#endif
                    rv = E_OUTOFMEMORY;
                    goto done;
                }

                pDsigInfoOld = ((CDsigSigF2 *)
                    pDsigTable->GetDsigSignature(usIndex)->GetDsigSig())->
                    GetDsigInfo();
                // use the assignment operator to copy the object
                *pDsigInfoNew = *pDsigInfoOld;

                ((CDsigSigF2 *) pDsigTable->GetDsigSignature(usIndex)->GetDsigSig())->
                    SetDsigInfo (pDsigInfoNew);
                delete pDsigInfoOld;

            } else {

                UCHAR *pPresentGlyphList = NULL;
                USHORT usNumGlyphs;
                HCRYPTPROV hProvT = NULL;
                BOOL fDefaultProvider = FALSE;
                CDsigInfo *pDsigInfoOld = NULL;
                CDsigInfo *pDsigInfoNew = NULL;
                ULONG cbDsigInfoNew;

                //// Generate a new DsigInfo and put it into the DsigSignature
#if MSSIPOTF_DBG
                DbgPrintf ("Generating a new DsigInfo ...\n");
#endif

                if ((pDsigInfoNew = new CDsigInfo) == NULL) {
#if MSSIPOTF_ERROR
                    SignError ("Cannot continue: Error in new CDsigInfo.", NULL, FALSE);
#endif
                    rv = E_OUTOFMEMORY;
                    goto done;
                }
                // Set up the parameters to be passed to GetPresentGlyphList
                // and GetSubsetDsigInfo
                if ((usNumGlyphs = GetNumGlyphs (pTTFInfo->pFileBufferInfo)) == 0) {
#if MSSIPOTF_ERROR
                    SignError ("Cannot continue: No glyphs!", NULL, FALSE);
#endif
                    rv = MSSIPOTF_E_CANTGETOBJECT;
                    goto done;
                }
                if ((pPresentGlyphList = new UCHAR [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
                    SignError ("Cannot continue: Error in new UCHAR.", NULL, FALSE);
#endif
                    rv = E_OUTOFMEMORY;
                    goto done;
                }

                pDsigInfoOld = ((CDsigSigF2 *) pDsigSignature->GetDsigSig())->
                    GetDsigInfo();

	            // Find the cryptographic provider
                hProvT = pSubjectInfo->hProv;

                if (!(hProvT)) {
                    if (!(GetDefaultProvider(&hProvT))) {
                        rv = MSSIPOTF_E_CRYPT;
                        goto done;
                    }
                    fDefaultProvider = TRUE;
                }

                if ((rv = GetPresentGlyphList (pTTFInfo->pFileBufferInfo,
                                        pPresentGlyphList,
                                        usNumGlyphs)) != S_OK) {
                    goto done;
                }

                if ((rv = GetSubsetDsigInfo (pTTFInfo->pFileBufferInfo,
                                             pPresentGlyphList,
                                             usNumGlyphs,
                                             pDsigInfoOld,
                                             &cbDsigInfoNew,
                                             &pDsigInfoNew,
                                             hProvT)) != S_OK) {
                    goto done;
                }

                delete pDsigInfoOld;
                ((CDsigSigF2 *) pDsigSignature->GetDsigSig())->
                    SetDsigInfo(pDsigInfoNew);

                if (hProvT && fDefaultProvider) {
                    CryptReleaseContext (hProvT, 0);
                }
            }
        }
#endif

#if MSSIPOTF_DBG
        DbgPrintf ("pDsigSignature:\n");
        pDsigSignature->Print();
#endif

        // Add the DsigSignature to the DsigTable
        if ((rv = pDsigTable->InsertDsigSignature(pDsigSignature,
                                            &usIndex)) != S_OK) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in InsertDsigSignature.\n");
#endif
            goto done;
        }

        // Make a copy of the signature, since the caller will
        // deallocate the original signature's memory, whereas
        // this function deallocates pDsigTable.
        BYTE    *pbDataLocal;

        if (!(pbDataLocal = new BYTE [dwDataLen])) {
#if MSSIPOTF_ERROR
			SignError ("Error in new BYTE.", NULL, FALSE);
#endif
            rv = E_OUTOFMEMORY;
			goto done;
        }
        memcpy(pbDataLocal, pbData, dwDataLen);


        if ((rv = pDsigTable->ReplaceSignature (usIndex,
                                        pbDataLocal,
                                        dwDataLen))
                                    != S_OK) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in ReplaceSignature.\n");
#endif
            goto done;
        }

        // ASSERT: pDsigTable now has the new signature inserted into
        //   the usIndex-th spot.

        //// Step 3
        if ((rv = ReplaceDsigTable (pFileObj, pDsigTable)) != S_OK) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in ReplaceDsigTable.\n");
#endif
            goto done;
        }

	} else {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in GetFileObjectFromSubject.\n");
#endif
		goto done;
	}

    // We are successful if and only if we've made it this far.
	rv = S_OK;

done:

#if MSSIPOTF_DBG
    if (rv == S_OK) {
        pDsigTable->Print();
    }
#endif

	// delete [] dsigBufferInfo.puchBuffer;

	FreeTTFInfo (pTTFInfo);

	delete pDsigTable;

    if (pFileObj) {
        pFileObj->UnmapFile();
        pFileObj->CloseFileHandle();
    }

    delete pFileObj;

    return rv;
}


//
// Remove a signature from a TTF file.  If the requested signature does
// not exist, then the file is unchanged and FALSE is returned.
//
// Authenticode currently assumes there is at most one signature in the file.
// This function does not make that assumption.
//
HRESULT OTSIPObjectOTF::RemoveSignedDataMsg(IN SIP_SUBJECTINFO  *pSubjectInfo,
                                            IN DWORD            dwIndex)
{
	//// Here's the algorithm:
	//// 1. Map the file so that we can extract the DSIG table.
	//// 2. Compute length of original DSIG table.
	//// 3. Remove the dwIndex-th DsigSignature from the DsigTable.
	//// 4. Compute length of new DSIG table.
	//// 5. Write the new DSIG table to a buffer.
	//// 6. Call InsertTable.
	//// 7. Unmap the file.
	//// 8. Set the end of file pointer to be the new size (which is
	////      old file size - (old DSIG table size - new DSIG table size) ).
	//// 9. Remap the file.
	//// 10. Update the checksum of the DSIG table.
	//// 11. Update the checksum of the file.

    HRESULT rv = E_FAIL;

    CFileObj *pFileObj = NULL;

	ULONG cbFile = 0;
	ULONG cbFileOld = 0;

	TTFInfo *pTTFInfo = NULL;
	CDsigTable *pDsigTable = NULL;

	TTFACC_FILEBUFFERINFO dsigBufferInfo;
	ULONG ulOldDsigTableSize = 0;
	ULONG ulDsigTableSize = 0;

	ULONG ulOffset;

    USHORT usIndex = 0;

    usIndex = (USHORT) dwIndex;


    if (dwIndex != usIndex) {
        rv = ERROR_INVALID_PARAMETER;
        goto done;
    }

	// Initialize to NULL in case an error occurs in the middle
	// of the routine.
	dsigBufferInfo.puchBuffer = NULL;

    if ((rv = GetFileObjectFromSubject(pSubjectInfo,
                    GENERIC_READ | GENERIC_WRITE,
                    &pFileObj)) == S_OK) {
		// step 1
		// Map the file
		if ((rv = pFileObj->MapFile (0, PAGE_READWRITE, FILE_MAP_WRITE)) != S_OK) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in MapFile.\n");
#endif
			goto done;
		}

		// Extract the DSIG table (create default DsigTable if it didn't exist)
		if ((rv = InitTTFStructures (pFileObj->GetFileObjPtr(),
                                     pFileObj->GetFileObjSize(),
                                     &pTTFInfo,
                                     &pDsigTable)) != S_OK) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in InitTTFStructures.\n");
#endif
			goto done;
		}

		// step 2
		pDsigTable->GetSize (&ulOldDsigTableSize);

		// step 3
		if ((rv = pDsigTable->RemoveDsigSignature (usIndex)) != S_OK) {
			goto done;
		}

		// step 4
		pDsigTable->GetSize (&ulDsigTableSize);

		assert (ulDsigTableSize < ulOldDsigTableSize);

		// step 5
		if ((dsigBufferInfo.puchBuffer = new BYTE [ulDsigTableSize]) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
            rv = E_OUTOFMEMORY;
			goto done;
		}
		dsigBufferInfo.ulBufferSize = ulDsigTableSize;
		dsigBufferInfo.ulOffsetTableOffset = 0;			// this value isn't used
		dsigBufferInfo.lpfnReAllocate = &NullRealloc;	// this value isn't used

		ulOffset = 0;
		pDsigTable->Write (&dsigBufferInfo, &ulOffset);


		assert (ulOffset == ulDsigTableSize);

		// step 6
		if (InsertTable (pTTFInfo->pFileBufferInfo, (BYTE *)DSIG_TAG,
				dsigBufferInfo.puchBuffer, ulDsigTableSize) != NO_ERROR) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in InsertTable.\n");
#endif
            rv = MSSIPOTF_E_FILE;
			goto done;
		}

		// step 7
        cbFile = pFileObj->GetFileObjSize();
		pFileObj->UnmapFile();

		// step 8
		cbFile -= ulOldDsigTableSize - ulDsigTableSize;
        pFileObj->SetEndOfFileObj (cbFile);

		// step 9
		if ((rv = pFileObj->MapFile (cbFile, PAGE_READWRITE, FILE_MAP_WRITE)) != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in MapFile.\n");
#endif
			goto done;
		}
		pTTFInfo->pFileBufferInfo->puchBuffer = pFileObj->GetFileObjPtr();
		pTTFInfo->pFileBufferInfo->ulBufferSize = pFileObj->GetFileObjSize();

		// step 10
		// ASSERT: the offset field of the DSIG table directory entry
		//   should be correct.  Hence, we can safely call UpdateDirEntry.

		if (UpdateDirEntry (pTTFInfo->pFileBufferInfo, DSIG_TAG, ulDsigTableSize)
				!= NO_ERROR) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in UpdateDirEntry.\n");
#endif
            rv = MSSIPOTF_E_FILE;
            goto done;
		}

		// step 11
		//// Recompute the head table checksum for the entire file
		SetFileChecksum (pTTFInfo->pFileBufferInfo, cbFile);

        // we are successful if we have made it this far
        rv = S_OK;

    } else {
        // couldn't get the file object from subject
		goto done;
	}

done:

#if MSSIPOTF_DBG
    if (rv == S_OK) {
        pDsigTable->Print();
    }
#endif

    delete [] dsigBufferInfo.puchBuffer;

    FreeTTFInfo (pTTFInfo);

    delete pDsigTable;

    if (pFileObj) {
        pFileObj->UnmapFile();
        pFileObj->CloseFileHandle();
    }

    delete pFileObj;

    return rv;
}


//
// Calculate the hash of the TTF file and generate a SIP_INDIRECT_DATA structure.
//
HRESULT OTSIPObjectOTF::CreateIndirectData (IN      SIP_SUBJECTINFO     *pSubjectInfo,
                                            IN OUT  DWORD               *pdwDataLen,
                                            OUT     SIP_INDIRECT_DATA   *psData)
{
    BOOL rv = E_FAIL;

    ULONG cbDsig = 0;
    BYTE *pbDsig = NULL;

    CFileObj *pFileObj = NULL;
    TTFInfo *pTTFInfo = NULL;
    CDsigTable *pDsigTable = NULL;

    BYTE *pbDigest = NULL;
    DWORD cbDigest;
    HCRYPTPROV hProvT;
    BOOL fDefaultProvider = FALSE;  // is TRUE iff no provider is
                                    // given in SIP_SUBJECTINFO
    SPC_LINK SpcLink;

	// Find the cryptographic provider
    hProvT = pSubjectInfo->hProv;

    if (!(hProvT)) {
        if ((rv = GetDefaultProvider(&hProvT)) != S_OK) {
            goto done;
        }
        fDefaultProvider = TRUE;
    }

    memset (&SpcLink, 0x00, sizeof(SPC_LINK));

    // Make sure the SpcLink fields have known values;
    // these values are not actually used anywhere
    SpcLink.dwLinkChoice = SPC_FILE_LINK_CHOICE;
    SpcLink.pwszFile = OBSOLETE_TEXT_W;


    // needed by signer.dll -- not needed by the OT SIP
    pSubjectInfo->dwIntVersion = WIN_CERT_REVISION_2_0;


    if (!(psData)) {
		//// The caller is requesting only the size of the
		//// SIP_INDIRECT_DATA object to allocate the right
		//// amount of space.
        HCRYPTHASH  hHash;
        DWORD       dwRetLen;
        DWORD       dwEncLen;
        DWORD       dwAlgId;

		// non-pointer fields of the SIP_INDIRECT_DATA structure
        dwRetLen = sizeof(SIP_INDIRECT_DATA);

        // crypt_algorithm_identifier size
            // obj id
        dwRetLen += strlen(pSubjectInfo->DigestAlgorithm.pszObjId);
        dwRetLen += 1;  // null term
            // parameters (none)

        // crypt_attribute_type_value size
		  // size of the obj id
        dwRetLen += strlen(GetTTFObjectID());
        dwRetLen += 1; // null term

        // size of the attribute value
        dwEncLen = 0;

        // Encode the SpcLink
        if (!CryptEncodeObject (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                GetTTFObjectID (),
                                &SpcLink,
                                NULL,
                                &dwEncLen)) {
		    rv = HRESULT_FROM_WIN32(GetLastError());
		    goto done;
	    }

        if (dwEncLen == 0) {
#if MSSIPOTF_ERROR
            SignError ("Cannot continue: Bad encoding length from CryptEncodeObject.",
                NULL, FALSE);
#endif
            rv = MSSIPOTF_E_CRYPT;
            goto done;
        }

        dwRetLen += dwEncLen;

        // get the length of the hash value of the subject
        if ((dwAlgId = CertOIDToAlgId(pSubjectInfo->DigestAlgorithm.pszObjId)) == 0) {
            rv = NTE_BAD_ALGID;
            goto done;
        }

        if (!(CryptCreateHash(hProvT, dwAlgId, NULL, 0, &hHash))) {
            rv = MSSIPOTF_E_CRYPT;
            goto done;
        }

        if (CryptHashData(hHash,(const BYTE *)" ", 1, 0)) {
            cbDigest = 0;

            CryptGetHashParam(hHash, HP_HASHVAL, NULL, &cbDigest,0);

            if (cbDigest > 0) {
                CryptDestroyHash(hHash);

                dwRetLen += cbDigest;
                *pdwDataLen = dwRetLen;

                rv = S_OK;
                goto done;
            }
        } else {
            rv = MSSIPOTF_E_CRYPT;
        }

        CryptDestroyHash(hHash);
        goto done;

    } else if ((rv = GetFileObjectFromSubject (pSubjectInfo,
                        GENERIC_READ,
                        &pFileObj)) == S_OK) {

        USHORT usFlagNew;
        ALG_ID alg_id;


        usFlagNew = DSIG_DEFAULT_FLAG_HIGH * FLAG_RADIX +
            DSIG_DEFAULT_FLAG_LOW;

	    if ((rv = pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ))
                != S_OK) {
#if MSSIPOTF_DBG
		    DbgPrintf ("Error in MapFile.\n");
#endif
		    goto done;
	    }

		//// The caller is requesting the SIP_INDIRECT_DATA
		//// structure for the given file.

		// First, create the hash value for the file (using the hash algorithm
        // in the subject info structure).

        cbDsig = sizeof(USHORT);
        if ((pbDsig = new BYTE [cbDsig]) == NULL) {
#if MSSIPOTF_ERROR
            SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
            rv = E_OUTOFMEMORY;
            goto done;
        }

        pbDsig [0] = (BYTE) usFlagNew / FLAG_RADIX;  // high byte
        pbDsig [1] = (BYTE) usFlagNew % FLAG_RADIX;  // low byte
#if MSSIPOTF_DBG
        DbgPrintf ("pbDsig bytes:\n");
        PrintBytes (pbDsig, 2);
#endif

        alg_id = CertOIDToAlgId (pSubjectInfo->DigestAlgorithm.pszObjId);

        if ((rv = DigestFileData (pFileObj,
                                hProvT,
                                alg_id,
                                &pbDigest,
                                &cbDigest,
                                NO_SIGNATURE,
                                DSIGSIG_DEF_FORMAT,
                                cbDsig,
                                pbDsig)) == S_OK) {
            ULONG_PTR dwOffset;
            DWORD    dwRetLen;

            BYTE *pbAttrData = NULL;  // pointer to encoded blob

            dwRetLen = 0;
 
            // get the length of the encoding
            if (!CryptEncodeObject (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                    GetTTFObjectID (),
                                    &SpcLink,
                                    NULL,
                                    &dwRetLen)) {
		        rv = HRESULT_FROM_WIN32(GetLastError());
		        goto done;
	        }

            if ((pbAttrData = new BYTE [dwRetLen]) == NULL) {
#if MSSIPOTF_ERROR
                SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
                rv = E_OUTOFMEMORY;
                goto done;
            }

            // Get the actual encoding
            if (!CryptEncodeObject (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                    GetTTFObjectID (),
                                    &SpcLink,
                                    pbAttrData,
                                    &dwRetLen)) {
		        rv = HRESULT_FROM_WIN32(GetLastError());
		        goto done;
	        }

            dwOffset = (ULONG_PTR) psData + sizeof(SIP_INDIRECT_DATA);

			// obj id of the attribute type value
            strcpy((char *) dwOffset, GetTTFObjectID());
            psData->Data.pszObjId   = (LPSTR)dwOffset;
            dwOffset += (strlen(GetTTFObjectID()) + 1);

			// the encoded blob
            memcpy((void *)dwOffset, pbAttrData, dwRetLen);
            psData->Data.Value.pbData   = (BYTE *)dwOffset;
            psData->Data.Value.cbData   = dwRetLen;
            dwOffset += (ULONG_PTR) dwRetLen;

			// the algorithm identifier
            strcpy((char *)dwOffset, (char *)pSubjectInfo->DigestAlgorithm.pszObjId);
            psData->DigestAlgorithm.pszObjId            = (char *) dwOffset;
            psData->DigestAlgorithm.Parameters.cbData   = 0;
            psData->DigestAlgorithm.Parameters.pbData   = NULL;
            dwOffset += (strlen(pSubjectInfo->DigestAlgorithm.pszObjId) + 1);

			// the actual digest (the hash value of the file)
            memcpy((void *)dwOffset, pbDigest, cbDigest);
            psData->Digest.pbData   = (BYTE *) dwOffset;
            psData->Digest.cbData   = cbDigest;

#if MSSIPOTF_DBG
            DbgPrintf ("dwOffset = %d\n", dwOffset + cbDigest);
#endif
        
            rv = S_OK;

            delete [] pbAttrData;

            goto done;
        }
    } else {
        // couldn't get the file object from subject
        goto done;
    }

done:

    if (pFileObj) {
        pFileObj->UnmapFile();
        pFileObj->CloseFileHandle();
    }
    FreeTTFInfo (pTTFInfo);
    delete pDsigTable;

    delete [] pbDsig;
    delete [] pbDigest;

    if (hProvT && fDefaultProvider) {
        CryptReleaseContext (hProvT, 0);
    }

    delete pFileObj;

    return rv;
}


// Given a signature, verify that its associated hash value
// matches that of the given file.
HRESULT OTSIPObjectOTF::VerifyIndirectData(IN SIP_SUBJECTINFO      *pSubjectInfo,
                                           IN SIP_INDIRECT_DATA    *psData)
{
    HRESULT rv = FALSE;

    HCRYPTPROV hProvT = NULL;
    BOOL fDefaultProvider = FALSE;  // is TRUE iff no provider is
                                    // given in SIP_SUBJECTINFO
// HANDLE hFile = NULL;
    CFileObj *pFileObj = NULL;

    TTFInfo *pTTFInfo = NULL;
    CDsigTable *pDsigTable = NULL;

    ULONG cbDsig = 0;
    BYTE *pbDsig = NULL;

    DWORD cbDigest = 0;
    BYTE *pbDigest = NULL;

    ALG_ID alg_id;

/*
    if (!(psData)) {
        if (GetFileHandleFromSubject(pSubjectInfo, GENERIC_READ, &hFile)) {
			// if the file exists, set bad parameter!
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        }
        goto done;
    }
*/

    // Find the cryptographic provider
    hProvT = pSubjectInfo->hProv;

    if (!(hProvT)) {
        if ((rv = GetDefaultProvider(&hProvT)) != S_OK) {
            goto done;
        }
        fDefaultProvider = TRUE;
    }

    if ((rv = GetFileObjectFromSubject(pSubjectInfo,
                    GENERIC_READ,
                    &pFileObj)) == S_OK) {

        USHORT usIndex = 0;
        DWORD dwRetLen;
    	ULONG ulFormat;
        USHORT usFlag;

        dwRetLen = 0;

        if ((rv = pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ))
                != S_OK) {
#if MSSIPOTF_DBG
		    DbgPrintf ("Error in MapFile.\n");
#endif
		    goto done;
	    }

	    if ((rv = InitTTFStructures (pFileObj->GetFileObjPtr(),
                                     pFileObj->GetFileObjSize(),
                                     &pTTFInfo, &pDsigTable)) != S_OK) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in InitTTFStructures.\n");
#endif
		    goto done;
	    }

        usIndex = (USHORT) pSubjectInfo->dwIndex;
        // Check to see if dwIndex is at most MAX_USHORT
        if (pSubjectInfo->dwIndex != usIndex) {
#if MSSIPOTF_ERROR
            SignError ("Bad index to Verify.", NULL, FALSE);
#endif
            goto done;
        }

		// Find out what the format is for the signature in the
		// DSIG table with the given index.
		ulFormat = pDsigTable->GetDsigSignature(usIndex)->GetFormat();

        // Retrieve the flag field from the DSIG table.
        // These bytes will be used as part of the hash.
        usFlag = pDsigTable->GetFlag ();

        // Compute the hash value for the file and compare it to the hash
        // value in the SIP_INDIRECT_DATA structure.

        alg_id = CertOIDToAlgId (psData->DigestAlgorithm.pszObjId);
#if MSSIPOTF_DBG
        DbgPrintf ("alg_id = %d\n", alg_id);
#endif

        cbDsig = sizeof(USHORT);
        if ((pbDsig = new BYTE [cbDsig]) == NULL) {
#if MSSIPOTF_ERROR
            SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
            rv = E_OUTOFMEMORY;
            goto done;
        }

        pbDsig [0] = (BYTE) (usFlag / FLAG_RADIX);  // high byte
        pbDsig [1] = (BYTE) (usFlag % FLAG_RADIX);  // low byte
#if MSSIPOTF_DBG
        DbgPrintf ("pbDsig bytes:\n");
        PrintBytes (pbDsig, 2);
#endif

        if ((rv = DigestFileData (pFileObj,
                                  hProvT,
                                  alg_id,
                                  &pbDigest,
                                  &cbDigest,
                                  (USHORT) pSubjectInfo->dwIndex,
                                  ulFormat,
                                  cbDsig,
                                  pbDsig)) == S_OK) {

            if ((cbDigest != psData->Digest.cbData) ||
                    (memcmp(pbDigest,psData->Digest.pbData,cbDigest) != 0)) {
                rv = TRUST_E_BAD_DIGEST;
                goto done;
            }

            goto done;
        }
    } else {
        // couldn't get file object from subject
        goto done;
    }

done:

    delete [] pbDsig;
    delete [] pbDigest;

    if (hProvT && fDefaultProvider) {
        CryptReleaseContext (hProvT, 0);
    }

    FreeTTFInfo (pTTFInfo);
    delete pDsigTable;

    if (pFileObj) {
        pFileObj->UnmapFile();
        pFileObj->CloseFileHandle();
    }
    delete pFileObj;

    return rv;
}


// Return the OID of the structure in the attribute_type_value field of
// the SIP_INDIRECT_DATA structure.
char *OTSIPObjectOTF::GetTTFObjectID ()
{
    return (SPC_LINK_OBJID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfacc1\ttfacc.h ===
/*
  * TTFAcc.h: Interface file for TTFAcc.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */

/* NOTE: must include TYPEDEFS.H and TTFF.H before this file */
/* must include ttfcntrl.h after this file in order to use the *Generic functions */
  
#ifndef TTFACC_DOT_H_DEFINED
#define TTFACC_DOT_H_DEFINED        

#ifndef NO_ERROR
#define NO_ERROR 0
#endif
#ifndef ERR_GENERIC
#define ERR_GENERIC 1000  
#define ERR_READOUTOFBOUNDS 1001	/* trying to read from memory not allowed - data error? */
#define ERR_WRITEOUTOFBOUNDS 1002	/* trying to write to memory not allowed - data error? */
#define ERR_READCONTROL 1003	/* read control structure does not match data */
#define ERR_WRITECONTROL 1004	/* write control structure does not match data */
#define ERR_MEM 1005   /* error allocating memory */
#define ERR_FORMAT 1006 /* input data format error */
#endif

#define TTFACC_BYTE 0x01   /* read/write/pad 1 byte */
#define TTFACC_WORD 0x02   /* read/write/pad 1 word */
#define TTFACC_LONG 0x04   /* read/write/pad 1 long word */
#define TTFACC_DATA 0x07  /* bits that define data size */
#define TTFACC_PAD  0x10   /* pad by whatever is specified */
#define TTFACC_NO_XLATE  0x20   /* don't translate the data */

#ifndef CFP_ALLOCPROC_DEFINED
#define CFP_ALLOCPROC_DEFINED
typedef void *(*CFP_ALLOCPROC)(size_t);
typedef void *(*CFP_REALLOCPROC)(void *, size_t);
typedef void (*CFP_FREEPROC)(void *);
#endif

typedef struct TTFACC_FILEBUFFERINFO {
	uint8 * puchBuffer;
	uint32 ulBufferSize;
	uint32 ulOffsetTableOffset;	/* offset into puchBuffer where OffsetTable begins */
	CFP_REALLOCPROC lpfnReAllocate;
} TTFACC_FILEBUFFERINFO;

typedef struct CONST_TTFACC_FILEBUFFERINFO {
	CONST uint8 * puchBuffer;
	uint32 ulBufferSize;
	uint32 ulOffsetTableOffset;	/* offset into puchBuffer where OffsetTable begins */
	CFP_REALLOCPROC lpfnReAllocate;
} CONST_TTFACC_FILEBUFFERINFO;

int16 ReadByte(TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint8 * puchBuffer, uint32 ulOffset);
int16 ReadWord(TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint16 * pusBuffer, uint32 ulOffset);
int16 ReadLong(TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint32 * pulBuffer, uint32 ulOffset);
int16 ReadBytes(TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint8 * puchBuffer, uint32 ulOffset, size_t Count);
int16 WriteByte(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint8 uchValue, uint32 ulOffset);
int16 WriteWord(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint16 usValue, uint32 ulOffset);
int16 WriteLong(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint32 ulValue, uint32 ulOffset);
int16 WriteBytes(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint8 * puchBuffer, uint32 ulOffset, size_t Count);

/* ReadGeneric - Generic read of data - Translation buffer provided for Word and Long swapping and RISC alignment handling */
/* 
Output:
puchDestBuffer updated with new data
Return:
0 or ErrorCode.
*/
int16 ReadGeneric(
TTFACC_FILEBUFFERINFO * pInputBufferInfo, /* buffer info of file buffer to read from */
uint8 * puchBuffer, 	/* buffer to read into - pad according to pControl data	*/
uint16 usBufferSize, 	/* size of buffer */
uint8 * puchControl, 	/* pControl - describes the size of each element in the structure, if a pad byte should be inserted in the output buffer */
uint32 ulOffset, 		/* offset into input TTF Buffer of where to read */
uint16 * pusBytesRead			/* number of bytes read from the file */
);

int16 ReadGenericRepeat(
TTFACC_FILEBUFFERINFO * pInputBufferInfo, /* buffer info of file buffer to read from */
uint8 * puchBuffer, 	/* buffer to read into - pad according to pControl data	*/
uint8 * puchControl, 	/* pControl - describes the size of each element in the structure, if a pad byte should be inserted in the output buffer */
uint32 ulOffset, 		/* offset into input TTF Buffer of where to read */
uint32 * pulBytesRead,	/* number of bytes read from the file */
uint16 usItemCount, 	/* number of times to read into the buffer */
uint16 usItemSize  		/* size of item in buffer */
);

/* WriteGeneric - Generic write of data - Translation buffer provided for Word and Long swapping and RISC alignment handling
Output:
puchDestBuffer updated with new data
Return:
Number of bytes written.
*/

int16 WriteGeneric(
TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
uint8 * puchBuffer, 
uint16 usBufferSize,
uint8 * puchControl, 
uint32 ulOffset, /* offset into output TTF Buffer of where to write */
uint16 *pusBytesWritten
);

int16 WriteGenericRepeat(
TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
uint8 * puchBuffer, 	/* buffer to read from - pad according to pControl data	*/
uint8 * puchControl, 	/* pControl - describes the size of each element in the structure, if a pad byte should be inserted in the output buffer */
uint32 ulOffset, 		/* offset into output TTF Buffer of where to write */
uint32 * pulBytesWritten,/* number of bytes written to the file */
uint16 usItemCount, 	/* number of times to read into the buffer */
uint16 usItemSize 		/* size of item in buffer */
);

uint16 GetGenericSize(uint8 * puchControl); 
int16 CalcChecksum( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
				  uint32 ulOffset,
				  uint32 ulLength,
                  uint32 * pulChecksum );
uint32 CalcFileChecksum( TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint32 ulLength ) ;

#endif /* TTFACC_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfacc1\ttfacc.c ===
/***************************************************************************
 * module: TTFACC.C
 *
 * author: Louise Pathe
 * date:   Nov 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * Routines to read data in a platform independent way from 
 * a file buffer
 *
 **************************************************************************/


/* Inclusions ----------------------------------------------------------- */

#include <string.h> /* for memcpy */
#include <stdlib.h> /* for max */

#include "TypeDefs.h"	 /* for uint8 etc definition */
#include "TTFAcc.h"
#include "TTFCntrl.h"
#ifdef _DEBUG
#include <stdio.h>
#endif

/* turn back into a macro, because it gets called so much */
#define CheckInOffset(a, b, c) \
	if ((a->puchBuffer == NULL) || (b > a->ulBufferSize) || (b + c > a->ulBufferSize) || (b + c < b)) 	\
		return ERR_READOUTOFBOUNDS	\

/* ---------------------------------------------------------------------- */
#if 0
static int16 CheckInOffset(TTFACC_FILEBUFFERINFO *a,  uint32 b,  size_t c)
{
	if (a->puchBuffer == NULL) /* a prior realloc may have failed */
		return ERR_READOUTOFBOUNDS;
	if ((b > a->ulBufferSize) || (b + c > a->ulBufferSize) || (b + c < b)) 
		return ERR_READOUTOFBOUNDS;
	return NO_ERROR;
}
#endif
/* ---------------------------------------------------------------------- */
PRIVATE CallCheckInOffset(TTFACC_FILEBUFFERINFO *a,  uint32 b,  size_t c)
{
	CheckInOffset(a,b,c);
	return NO_ERROR;
}

/* ---------------------------------------------------------------------- */
PRIVATE int16 CheckOutOffset(TTFACC_FILEBUFFERINFO *a, register uint32 b, register size_t c) 
{
		if (a->puchBuffer == NULL) /* a prior realloc may have failed */
			return ERR_WRITEOUTOFBOUNDS;
		if (b + c < b) return ERR_WRITEOUTOFBOUNDS; 
		else if (b + c > a->ulBufferSize)  
		{ 
			if (a->lpfnReAllocate == NULL) 
				return ERR_WRITEOUTOFBOUNDS; 
			if ((uint32) (a->ulBufferSize * 11/10) > b + c) 
			{  
#ifdef _DEBUG
				printf("we're reallocating 10 percent (%lu) more bytes\n",(uint32) (a->ulBufferSize * .1));	
#endif
				a->ulBufferSize = (uint32) (a->ulBufferSize * 11/10);
			} 
			else 
			{  
#ifdef _DEBUG
				printf("we're reallocating (%lu) more bytes\n",(uint32) (b + c - a->ulBufferSize));	
#endif
				a->ulBufferSize = b + c; 
			} 
			if ((a->puchBuffer = a->lpfnReAllocate(a->puchBuffer, a->ulBufferSize)) == NULL) 
			{
				a->ulBufferSize = 0L;
				return ERR_MEM;
			}
		} 
		return NO_ERROR;
}
/* ---------------------------------------------------------------------- */
int16 ReadByte(TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint8 * puchBuffer, uint32 ulOffset)
{

	CheckInOffset(pInputBufferInfo, ulOffset,sizeof(uint8));
	*puchBuffer = *(pInputBufferInfo->puchBuffer + ulOffset);
	return NO_ERROR;	
}
/* ---------------------------------------------------------------------- */
int16 ReadWord(TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint16 * pusBuffer, uint32 ulOffset)
{

	CheckInOffset(pInputBufferInfo, ulOffset,sizeof(uint16));
	*pusBuffer = SWAPW(*(pInputBufferInfo->puchBuffer + ulOffset));
	return NO_ERROR;
}	
/* ---------------------------------------------------------------------- */
int16 ReadLong(TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint32 * pulBuffer, uint32 ulOffset)
{
	CheckInOffset(pInputBufferInfo, ulOffset,sizeof(uint32));
	*pulBuffer = SWAPL(*(pInputBufferInfo->puchBuffer + ulOffset));
	return NO_ERROR;
}
/* ---------------------------------------------------------------------- */
int16 ReadBytes(TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint8 * puchBuffer, uint32 ulOffset, size_t Count)
{

	CheckInOffset(pInputBufferInfo, ulOffset,sizeof(uint8)*Count);

	memcpy(puchBuffer, pInputBufferInfo->puchBuffer + ulOffset, Count); 
	return NO_ERROR;	
}
/* ---------------------------------------------------------------------- */
int16 WriteByte(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint8 uchValue, uint32 ulOffset)
{
int16 errCode;

	if ((errCode = CheckOutOffset(pOutputBufferInfo, ulOffset,sizeof(uint8))) != NO_ERROR)
		return errCode;

	*(pOutputBufferInfo->puchBuffer + ulOffset) = uchValue;
	return NO_ERROR;	
}
/* ---------------------------------------------------------------------- */
int16 WriteWord(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint16 usValue, uint32 ulOffset)
{
int16 errCode;

	if ((errCode = CheckOutOffset(pOutputBufferInfo, ulOffset,sizeof(uint16))) != NO_ERROR)
		return errCode;

	* (UNALIGNED uint16 *) (pOutputBufferInfo->puchBuffer + ulOffset) = SWAPW(usValue);
	return NO_ERROR;
}
/* ---------------------------------------------------------------------- */
int16 WriteLong(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint32 ulValue, uint32 ulOffset)
{
int16 errCode;

	if ((errCode = CheckOutOffset(pOutputBufferInfo, ulOffset,sizeof(uint32))) != NO_ERROR)
		return errCode;

	* (UNALIGNED uint32 *) (pOutputBufferInfo->puchBuffer + ulOffset) = SWAPL(ulValue);
	return NO_ERROR;
}
/* ---------------------------------------------------------------------- */
int16 WriteBytes(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint8 * puchBuffer, uint32 ulOffset, size_t Count)
{
int16 errCode;

	if ((errCode = CheckOutOffset(pOutputBufferInfo, ulOffset,sizeof(uint8)*Count)) != NO_ERROR)
		return errCode;

	memcpy(pOutputBufferInfo->puchBuffer + ulOffset, puchBuffer, Count); 
	return NO_ERROR;	
}
/* ---------------------------------------------------------------------- */
/* ReadGeneric - Generic read of data - Translation buffer provided for Word and Long swapping and RISC alignment handling */
/* 
Output:
puchDestBuffer updated with new data
pusByteRead - number of bytes read 
Return:
0 if OK
error code if not. */
/* ---------------------------------------------------------------------- */
int16 ReadGeneric(
TTFACC_FILEBUFFERINFO * pInputBufferInfo, /* buffer info of file buffer to read from */
uint8 * puchBuffer, 	/* buffer to read into - pad according to pControl data	*/
uint16 usBufferSize, 	/* size of buffer */
uint8 * puchControl, 	/* pControl - describes the size of each element in the structure, if a pad byte should be inserted in the output buffer */
uint32 ulOffset, 			/* offset into input TTF Buffer of where to read */
uint16 * pusBytesRead			/* number of bytes read from the file */
)
{
uint32 ulCurrOffset = ulOffset;	  /* offset into TTF data buffer */
uint16 usBufferOffset = 0;		  /* offset into local read buffer */
uint16 usControlCount;		/* number of elements in the Control array */
UNALIGNED uint16 *pusBuffer;				  /* coerced puchBuffer */
UNALIGNED uint32 *pulBuffer;
uint16 i;

	usControlCount = puchControl[0]; 
	for (i = 1; i <= usControlCount; ++i)
	{
		switch (puchControl[i] & TTFACC_DATA)
		{
		case TTFACC_BYTE:
			if (usBufferOffset + sizeof(uint8) > usBufferSize)
				return ERR_READCONTROL;  /* trying to stuff too many bytes into target buffer */ 
			if (puchControl[i] & TTFACC_PAD) /* don't read, just pad */
				*(puchBuffer + usBufferOffset) = 0;
			else
			{
				CheckInOffset(pInputBufferInfo, ulCurrOffset,sizeof(uint8));

 				*(puchBuffer + usBufferOffset) = *(pInputBufferInfo->puchBuffer + ulCurrOffset);

				ulCurrOffset += sizeof(uint8);
			}
			usBufferOffset += sizeof(uint8);
		break;
		case TTFACC_WORD:
			if (usBufferOffset + sizeof(uint16) > usBufferSize)
				return ERR_READCONTROL;  /* trying to stuff too many bytes into target buffer */ 
			pusBuffer = (uint16 *) (puchBuffer + usBufferOffset);
			if (puchControl[i] & TTFACC_PAD) /* don't read, just pad */
				*pusBuffer = 0;
			else
			{
				CheckInOffset(pInputBufferInfo, ulCurrOffset,sizeof(uint16));

				if (puchControl[i] & TTFACC_NO_XLATE)
					memcpy(pusBuffer, (pInputBufferInfo->puchBuffer + ulCurrOffset), sizeof(uint16));
 				/* 	*pusBuffer = * (uint16 *) (pInputBufferInfo->puchBuffer + ulCurrOffset); */
				else
					*pusBuffer = SWAPW(*(pInputBufferInfo->puchBuffer + ulCurrOffset));
				ulCurrOffset += sizeof(uint16);
			}
			usBufferOffset += sizeof(uint16);
		break;
		case TTFACC_LONG:
			if (usBufferOffset + sizeof(uint32) > usBufferSize)
				return ERR_READCONTROL;  /* trying to stuff too many bytes into target buffer */ 
			pulBuffer = (uint32 *) (puchBuffer + usBufferOffset);
			if (puchControl[i] & TTFACC_PAD) /* don't read, just pad */
				*pulBuffer = 0;
			else
			{
				CheckInOffset(pInputBufferInfo, ulCurrOffset,sizeof(uint32));

  				if (puchControl[i] & TTFACC_NO_XLATE)
					memcpy(pulBuffer, pInputBufferInfo->puchBuffer + ulCurrOffset, sizeof(uint32));
					/* *pulBuffer = * (uint32 *) (pInputBufferInfo->puchBuffer + ulCurrOffset);	 */
				else
					*pulBuffer = SWAPL(*(pInputBufferInfo->puchBuffer + ulCurrOffset));

				ulCurrOffset += sizeof(uint32);
			}
			usBufferOffset += sizeof(uint32);
		break;
		default:
			return ERR_READCONTROL; /* don't read any, bad control */
		}  /* end switch */
	} /* end for i */
	if (usBufferOffset < usBufferSize)  /* didn't fill up the buffer */
		return ERR_READCONTROL;  /* control thing doesn't fit the buffer */
	* pusBytesRead = (uint16) (ulCurrOffset - ulOffset); 
	return NO_ERROR;
}
/* ---------------------------------------------------------------------- */
/* read an array of items repeatedly
Output
puchDestBuffer updated with new data
pusByteRead - number of bytes read total 
Return:
0 if OK	or
ErrorCode  */
/* ---------------------------------------------------------------------- */
int16 ReadGenericRepeat(
TTFACC_FILEBUFFERINFO * pInputBufferInfo, /* buffer info of file buffer to read from */
uint8 * puchBuffer, 	/* buffer to read into - pad according to pControl data	*/
uint8 * puchControl, 	/* pControl - describes the size of each element in the structure, if a pad byte should be inserted in the output buffer */
uint32 ulOffset, 		/* offset into input TTF Buffer of where to read */
uint32 * pulBytesRead,	/* number of bytes read from the file */
uint16 usItemCount, 	/* number of times to read into the buffer */
uint16 usItemSize 		/* size of item in buffer */
)
{
uint16 i;
int16 errCode;
uint16 usBytesRead;

	for (i = 0; i < usItemCount; ++i)
	{
		errCode = ReadGeneric( pInputBufferInfo, puchBuffer, usItemSize, puchControl, ulOffset, &usBytesRead);
		if (errCode != NO_ERROR)
			return errCode;
		ulOffset += usBytesRead;
		puchBuffer += usItemSize;
	}

	*pulBytesRead = usBytesRead * usItemCount;
	return NO_ERROR;
}	
/* ---------------------------------------------------------------------- */
/* WriteGeneric - Generic write of data - Translation buffer provided for Word and Long swapping and RISC alignment handling
Output:
puchDestBuffer updated with new data
pusBytesWritten - Number of bytes written.
Return:
0 or Error Code
*/
/* ---------------------------------------------------------------------- */
int16 WriteGeneric(
TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
uint8 * puchBuffer, 
uint16 usBufferSize,
uint8 * puchControl, 
uint32 ulOffset, /* offset into output TTF Buffer of where to write */
uint16 * pusBytesWritten)
{
uint32 ulCurrOffset = ulOffset;	  /* offset into TTF data buffer */
uint16 usControlCount;
uint16 usBufferOffset = 0;		  /* offset into local read buffer */
UNALIGNED uint16 *pusBuffer;				  /* coerced puchBuffer */
UNALIGNED uint32 *pulBuffer;
uint16 i;
uint32 ulBytesWritten;
int16 errCode;
 
	usControlCount = puchControl[0]; 
	for (i = 1; i <= usControlCount; ++i)
	{
		switch (puchControl[i] & TTFACC_DATA)
		{
		case TTFACC_BYTE:
			if (!(puchControl[i] & TTFACC_PAD))
			{
				if (usBufferOffset + sizeof(uint8) > usBufferSize)
					return ERR_WRITECONTROL;  /* trying to read too many bytes from source buffer */ 
				if ((errCode = CheckOutOffset(pOutputBufferInfo, ulCurrOffset,sizeof(uint8))) != NO_ERROR)
					return errCode;

 				*(pOutputBufferInfo->puchBuffer + ulCurrOffset) = *(puchBuffer + usBufferOffset);
				ulCurrOffset += sizeof(uint8);
			}
			usBufferOffset += sizeof(uint8);
			break;
		case TTFACC_WORD:
			if (!(puchControl[i] & TTFACC_PAD))
			{
				if (usBufferOffset + sizeof(uint16) > usBufferSize)
					return ERR_WRITECONTROL;  /* trying to read too many bytes from source buffer */ 
				if ((errCode = CheckOutOffset(pOutputBufferInfo, ulCurrOffset,sizeof(uint16))) != NO_ERROR)
					return errCode;

	 			pusBuffer = (uint16 *) (puchBuffer + usBufferOffset);
				if (puchControl[i] & TTFACC_NO_XLATE)
					* (UNALIGNED uint16 *) (pOutputBufferInfo->puchBuffer + ulCurrOffset) = *pusBuffer;
				else
					* (UNALIGNED uint16 *) (pOutputBufferInfo->puchBuffer + ulCurrOffset) = SWAPW(*pusBuffer);
				ulCurrOffset += sizeof(uint16);
			}
			usBufferOffset += sizeof(uint16);
			break;
		case TTFACC_LONG:
			if (!(puchControl[i] & TTFACC_PAD)) 
			{
				if (usBufferOffset + sizeof(uint32) > usBufferSize)
					return ERR_WRITECONTROL;  /* trying to read too many bytes from source buffer */ 
				if ((errCode = CheckOutOffset(pOutputBufferInfo, ulCurrOffset,sizeof(uint32))) != NO_ERROR)
					return errCode;
	 			pulBuffer = (uint32 *) (puchBuffer + usBufferOffset);
				if (puchControl[i] & TTFACC_NO_XLATE)
					* (UNALIGNED uint32 *) (pOutputBufferInfo->puchBuffer + ulCurrOffset) = *pulBuffer;
				else
					* (UNALIGNED uint32 *) (pOutputBufferInfo->puchBuffer + ulCurrOffset) = SWAPL(*pulBuffer);
				ulCurrOffset += sizeof(uint32);
			}
			usBufferOffset += sizeof(uint32);
			break;
		default:
			return ERR_WRITECONTROL; /* don't write any, bad control */
		}  /* end switch */
	} /* end for i */
	if (usBufferOffset < usBufferSize)  /* didn't read all the bytes in buffer */
		return ERR_WRITECONTROL;  /* control thing doesn't fit the buffer */
	ulBytesWritten = ulCurrOffset - ulOffset;
	*pusBytesWritten = (uint16)(ulCurrOffset - ulOffset);
	if (ulBytesWritten != *pusBytesWritten)	   /* check to see if it fits */
		return ERR_FORMAT;
	return NO_ERROR; 
}
/* ---------------------------------------------------------------------- */
/* write an array of items repeatedly
Output
puchDestBuffer updated with new data
pusByteWritten - number of bytes written total 
Return:
0 if OK	or
ErrorCode  */
/* ---------------------------------------------------------------------- */
int16 WriteGenericRepeat(
TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
uint8 * puchBuffer, 	/* buffer to read from - pad according to pControl data	*/
uint8 * puchControl, 	/* pControl - describes the size of each element in the structure, if a pad byte should be inserted in the output buffer */
uint32 ulOffset, 		/* offset into output TTF Buffer of where to write */
uint32 * pulBytesWritten,/* number of bytes written to the file */
uint16 usItemCount, 	/* number of times to read into the buffer */
uint16 usItemSize 		/* size of item in buffer */
)
{
uint16 i;
int16 errCode;
uint16 usBytesWritten;

	for (i = 0; i < usItemCount; ++i)
	{
		errCode = WriteGeneric( pOutputBufferInfo, puchBuffer, usItemSize, puchControl, ulOffset, &usBytesWritten);
		if (errCode != NO_ERROR)
			return errCode;
		ulOffset += usBytesWritten;
		puchBuffer += usItemSize;
	}

	*pulBytesWritten = usBytesWritten * usItemCount;
	return NO_ERROR;
}	

/* ---------------------------------------------------------------------- */

uint16 GetGenericSize(uint8 * puchControl) 
{
uint16 usCurrOffset = 0;	 
uint16 usControlCount;
uint16 i;

	usControlCount = puchControl[0]; 
	for (i = 1; i <= usControlCount; ++i)
	{
		switch (puchControl[i] & TTFACC_DATA)
		{
		case TTFACC_BYTE:
			if (!(puchControl[i] & TTFACC_PAD))
				usCurrOffset += sizeof(uint8);
			break;
		case TTFACC_WORD:
			if (!(puchControl[i] & TTFACC_PAD))
				usCurrOffset += sizeof(uint16);
			break;
		case TTFACC_LONG:
			if (!(puchControl[i] & TTFACC_PAD)) 
				usCurrOffset += sizeof(uint32);
			break;
		default:
			return 0; 
		}  /* end switch */
	} /* end for i */
	return usCurrOffset; 
}
/* ---------------------------------------------------------------------- */
/* next 2 functions moved from ttftabl1.c to allow inline ReadLong access */
/* calc checksum of an as-yet unwritten Directory. */
int16 CalcChecksum( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
				  uint32 ulOffset,
				  uint32 ulLength,
                  uint32 * pulChecksum )
{
uint32 ulWord;
uint32 ulEndOffset;

	*pulChecksum = 0;

	ulEndOffset = ulOffset + (((ulLength+3) / 4) * sizeof(uint32));
 
	CheckInOffset(pInputBufferInfo, ulOffset, sizeof(uint32));
	CheckInOffset(pInputBufferInfo, ulEndOffset-sizeof(uint32), sizeof(uint32));

	for ( ;ulOffset < ulEndOffset; ulOffset+=sizeof(uint32) )
	{
		ulWord = SWAPL(*(pInputBufferInfo->puchBuffer + ulOffset));	/* inline to save pushing */
	/*	if ( ReadLong( pInputBufferInfo, &ulWord, ulOffset + ul * sizeof(uint32)) != 0 )
		 	break;	*/
		*pulChecksum = *pulChecksum + ulWord;
	}
	return NO_ERROR;
}
/* ---------------------------------------------------------------------- */
uint32 CalcFileChecksum( TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint32 ulLength )
{
int16 sExtraBytes;
int16 i;
uint32 ulWord;
uint32 ulCS = 0L;
uint32 ulOffset = 0L;
uint32 ulLastOffset;
uint32 ulLastLong = 0L;

	ulLastOffset = ((ulLength/sizeof(uint32))-1) * sizeof(uint32); /* truncate and subtract one */

	if (CallCheckInOffset(pInputBufferInfo, ulOffset, sizeof(uint32)) != NO_ERROR)
		return 0L;
	if (CallCheckInOffset(pInputBufferInfo, ulLastOffset, sizeof(uint32)) != NO_ERROR)
		return 0L;
	while (ulOffset <= ulLastOffset)
	{
		ulWord = SWAPL(*(pInputBufferInfo->puchBuffer + ulOffset));	/* inline to save pushing */
		ulCS += ulWord;
		ulOffset += sizeof(uint32);
	}
	sExtraBytes = (int16) (ulLength - ulOffset); /* there are more bytes */
	if (sExtraBytes > 0)  /* LCP 3/97 add support for last few bytes */
	{
		for (i = 0; i < sExtraBytes; ++i)
		{
			ulWord = *(pInputBufferInfo->puchBuffer + ulOffset);
			ulLastLong = ulLastLong | (ulWord<<4);  /* read a bytes and shift it */
		}
		for (;i < 4; ++i)
			ulLastLong <<= 1; /* shift it into position for a virtual long padded with zeros */
		ulWord = SWAPL(ulLastLong);
		ulCS += ulWord;
	}

	return( ulCS );
}
/* ---------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfacc1\ttfcntrl.h ===
/*
  * TTFCntrl.h: Interface file for TTFCntrl.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */
  /* NOTE: must include TYPEDEFS.H before this file */
  
#ifndef TTFCNTRL_DOT_H_DEFINED
#define TTFCNTRL_DOT_H_DEFINED        

extern uint8 BYTE_CONTROL[]; 
extern uint8 WORD_CONTROL[]; 
extern uint8 LONG_CONTROL[]; 

extern uint8 TTC_HEADER_CONTROL [];

extern uint8 OFFSET_TABLE_CONTROL [];

extern uint8 DIRECTORY_CONTROL[];

extern uint8 DIRECTORY_NO_XLATE_CONTROL[];

extern uint8 CMAP_HEADER_CONTROL[];

extern uint8 CMAP_TABLELOC_CONTROL[];

extern uint8 CMAP_SUBHEADER_CONTROL[];

extern uint8 CMAP_FORMAT0_CONTROL[];

extern uint8 CMAP_FORMAT6_CONTROL[];

extern uint8 CMAP_FORMAT4_CONTROL[];

extern uint8 FORMAT4_SEGMENTS_CONTROL[];
    
/* 'post' postscript table */

extern uint8 POST_CONTROL[];

/* 'glyf' glyph data table */

extern uint8 GLYF_HEADER_CONTROL[];

extern uint8 SIMPLE_GLYPH_CONTROL[];

extern uint8 COMPOSITE_GLYPH_CONTROL[];

extern uint8 HEAD_CONTROL[];

/* 'hhea' horizontal header table */

extern uint8 HHEA_CONTROL[];

/* 'hmtx' horizontal metrics table */

extern uint8 LONGHORMETRIC_CONTROL[];

extern uint8 LSB_CONTROL[];

/* 'vhea' vertical header table */

extern uint8 VHEA_CONTROL[];

/* 'vmtx' vertical metrics table */

extern uint8 LONGVERMETRIC_CONTROL[];

extern uint8 TSB_CONTROL[];

/* generic 'hmtx', 'vmtx' tables */

extern uint8 XHEA_CONTROL[];

extern uint8 LONGXMETRIC_CONTROL[];

extern uint8 XSB_CONTROL[];

/* 'LTSH' linear threshold table */

extern uint8 LTSH_CONTROL[];

/* 'maxp' maximum profile table */

extern uint8 MAXP_CONTROL[];

extern uint8 NAME_RECORD_CONTROL[];

extern uint8 	NAME_HEADER_CONTROL[];

/* 'hdmx' horizontal device metrix table */
          
extern uint8 	HDMX_DEVICE_REC_CONTROL[];

extern uint8  HDMX_CONTROL[];

/* 'VDMX' Vertical Device Metrics Table */
extern uint8 VDMXVTABLE_CONTROL[];

extern uint8 VDMXGROUP_CONTROL[]; 

extern uint8 VDMXRATIO_CONTROL[]; 

extern uint8 VDMX_CONTROL[]; 

/* 'dttf' private table */

extern uint8 DTTF_HEADER_CONTROL[]; 

/* 'kern' kerning table */

extern uint8 KERN_HEADER_CONTROL[];

extern uint8 KERN_SUB_HEADER_CONTROL[];

extern uint8 KERN_FORMAT_0_CONTROL[];

extern uint8 KERN_PAIR_CONTROL[];

extern uint8 SEARCH_PAIRS_CONTROL[];

/* 'OS/2' OS/2 and Windows metrics table */

extern uint8 OS2_PANOSE_CONTROL[];

extern uint8 OS2_CONTROL[];

extern uint8 NEWOS2_CONTROL[];

extern uint8 VERSION2OS2_CONTROL[];

/*  EBLC, EBDT and EBSC file constants    */

/*	This first EBLC is common to both EBLC and EBSC tables */

extern uint8 	EBLCHEADER_CONTROL[];

extern uint8 	SBITLINEMETRICS_CONTROL[];

extern uint8 BITMAPSIZETABLE_CONTROL[];

extern uint8 BIGGLYPHMETRICS_CONTROL[];

extern uint8 SMALLGLYPHMETRICS_CONTROL[];

extern uint8 INDEXSUBTABLEARRAY_CONTROL[];

extern uint8 INDEXSUBHEADER_CONTROL[];

extern uint8 INDEXSUBTABLE1_CONTROL[];

extern uint8 INDEXSUBTABLE2_CONTROL[];

extern uint8 INDEXSUBTABLE3_CONTROL[];

extern uint8 CODEOFFSETPAIR_CONTROL[];

extern uint8 INDEXSUBTABLE4_CONTROL[];

extern uint8 INDEXSUBTABLE5_CONTROL[];

extern uint8 EBDTHEADER_CONTROL[];

extern uint8 EBDTHEADERNOXLATENOPAD_CONTROL[];

extern uint8 EBDTCOMPONENT_CONTROL[];

extern uint8 EBDTFORMAT8SIZE_CONTROL[];

extern uint8 EBDTFORMAT9_CONTROL[];

/* TrueType Open GSUB Tables, needed for Auto Mapping of unmapped Glyphs. */
extern uint8 GSUBFEATURE_CONTROL[];

extern uint8 GSUBFEATURERECORD_CONTROL[];

extern uint8 GSUBFEATURELIST_CONTROL[];

extern uint8 GSUBLOOKUP_CONTROL[];

extern uint8 GSUBLOOKUPLIST_CONTROL[];

extern uint8 GSUBCOVERAGEFORMAT1_CONTROL[];

extern uint8 GSUBRANGERECORD_CONTROL[];

extern uint8 GSUBCOVERAGEFORMAT2_CONTROL[];

extern uint8 GSUBHEADER_CONTROL[];

extern uint8 GSUBSINGLESUBSTFORMAT1_CONTROL[];

extern uint8 GSUBSINGLESUBSTFORMAT2_CONTROL[];

extern uint8 GSUBSEQUENCE_CONTROL[];

extern uint8 GSUBMULTIPLESUBSTFORMAT1_CONTROL[];

extern uint8 GSUBALTERNATESET_CONTROL[];

extern uint8 GSUBALTERNATESUBSTFORMAT1_CONTROL[];

extern uint8 GSUBLIGATURE_CONTROL[];

extern uint8 GSUBLIGATURESET_CONTROL[];

extern uint8 GSUBLIGATURESUBSTFORMAT1_CONTROL[];

extern uint8 GSUBSUBSTLOOKUPRECORD_CONTROL[];

extern uint8 GSUBSUBRULE_CONTROL[];

extern uint8 GSUBSUBRULESET_CONTROL[];

extern uint8 GSUBCONTEXTSUBSTFORMAT1_CONTROL[];

extern uint8 GSUBSUBCLASSRULE_CONTROL[];

extern uint8 GSUBSUBCLASSSET_CONTROL[];

extern uint8 GSUBCONTEXTSUBSTFORMAT2_CONTROL[];

extern uint8 GSUBCONTEXTSUBSTFORMAT3_CONTROL[];

/* just enough jstf info to get the Automap working for jstf */
extern uint8 JSTFSCRIPTRECORD_CONTROL[];

extern uint8 JSTFHEADER_CONTROL[];

extern uint8 JSTFLANGSYSRECORD_CONTROL[];

extern uint8 JSTFSCRIPT_CONTROL[];

extern uint8 JSTFEXTENDERGLYPH_CONTROL[];

/* BASE TTO Table, enough to do TTOAutoMap */

extern uint8 BASEHEADER_CONTROL[];

extern uint8 BASEAXIS_CONTROL[];

extern uint8 BASESCRIPTRECORD_CONTROL[];

extern uint8 BASESCRIPTLIST_CONTROL[];

extern uint8 BASELANGSYSRECORD_CONTROL[];

extern uint8 BASESCRIPT_CONTROL[];

extern uint8 BASEVALUES_CONTROL[];

extern uint8 BASEFEATMINMAXRECORD_CONTROL[];

extern uint8 BASEMINMAX_CONTROL[];

extern uint8 BASECOORDFORMAT2_CONTROL[];

extern uint8 MORTBINSRCHHEADER_CONTROL[];

extern uint8 MORTLOOKUPSINGLE_CONTROL[];

extern uint8 MORTHEADER_CONTROL[];

#endif /* TTFCNTRL_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfacc1\ttfdcnfg.h ===
/***************************************************************************
 * module: ttfdcnfg.h
 *
 * author: Paul Linnerud
 * date:   Jan 1998
 * Copyright 1990-1998. Microsoft Corporation.
 *
 * Provides some platform configuration for ttfdelta.
 *
 **************************************************************************/
#ifndef TTFDCNFG_DOT_H_DEFINED
#define TTFDCNFG_DOT_H_DEFINED  

// Using Microsoft C, callback functions for qsort and bsearch must be __cdecl
#define CRTCB __cdecl 

#endif  TTFDCNFG_DOT_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfacc1\ttftabl1.c ===
/***************************************************************************
 * module: TTFTABL1.C
 *
 * author: Louise Pathe
 * date:   Nov 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * aRoutines to read TrueType tables and table information from 
 * a TrueType file buffer
 *
 **************************************************************************/


/* Inclusions ----------------------------------------------------------- */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _MAC
#include <Memory.h>
#endif // _MAC

#include "typedefs.h"
#include "ttff.h"                       /* TrueType font file def's */
#include "ttfacc.h"
#include "ttftabl1.h"
#include "ttfcntrl.h"

/* if the _INDEX defines are changed, the Control_Table array below must be updated to match */

#define HEAD_INDEX  0
#define HHEA_INDEX  1
#define VHEA_INDEX  2
#define MAXP_INDEX  3
#define POST_INDEX  4
#define OS2_INDEX   5
#define NEWOS2_INDEX 6
#define VERSION2OS2_INDEX 7
#define HDMX_INDEX  8
#define LTSH_INDEX  9

#define TAG_INDEX_COUNT 10  /* this is tied to the list of _INDEX #defines above */

typedef	struct CONTROL_TABLE {
	char * Tag;
	uint16 StructSize;
	uint8  *Control;
} CONTROL_TABLE;

/* Definitions local to this file ---------------------------------------- */

/* if the Control_Table array is changed, the _INDEX defines above must be updated to match */

static CONTROL_TABLE Control_Table[TAG_INDEX_COUNT] = {

{ HEAD_TAG, SIZEOF_HEAD, HEAD_CONTROL},  
{ HHEA_TAG, SIZEOF_HHEA, HHEA_CONTROL},  
{ VHEA_TAG, SIZEOF_VHEA, VHEA_CONTROL},  
{ MAXP_TAG, SIZEOF_MAXP, MAXP_CONTROL},  
{ POST_TAG, SIZEOF_POST, POST_CONTROL},  
{  OS2_TAG, SIZEOF_OS2,  OS2_CONTROL},   
{  OS2_TAG, SIZEOF_NEWOS2,  NEWOS2_CONTROL},  
{  OS2_TAG, SIZEOF_VERSION2OS2, VERSION2OS2_CONTROL}, 
{ HDMX_TAG, SIZEOF_HDMX, HDMX_CONTROL},  
{ LTSH_TAG, SIZEOF_LTSH, LTSH_CONTROL}  
};  

/* ---------------------------------------------------------------------- */
void ConvertLongTagToString(uint32 ulTag, char *szTag)	  /* convert a tag, as it has been read from the font, to a string */
{
uint32 ulSwappedTag;

	ulSwappedTag = SWAPL(ulTag); /* on intel, this will swap back to motorola. On motorola, this will leave alone */
	memcpy(szTag, (char *) &ulSwappedTag, 4);
	szTag[4] = '\0';
}
/* ---------------------------------------------------------------------- */
void ConvertStringTagToLong(char *szTag, uint32 *pulTag)
{
		memcpy((char *)pulTag, szTag, 4); 
		*pulTag = SWAPL(*pulTag); /* on intel, this will swap back to intel format. On motorola, this will leave alone */
}
/* functions to read font file data ------------------------------------- */
/* ---------------------------------------------------------------------- */
uint32 TTDirectoryEntryOffset( TTFACC_FILEBUFFERINFO * pInputBufferInfo, char * szTagName )
{
uint16 usBytesRead;
OFFSET_TABLE Offset_Table;
DIRECTORY Directory;
uint32 ulCurrOffset = pInputBufferInfo->ulOffsetTableOffset;
uint16 i;
BOOL bFound = FALSE;
uint32 *pulTag = (uint32 *) szTagName;

   /* read offset table to determine number of tables in file. */

	if (ReadGeneric(pInputBufferInfo, (uint8 *) &Offset_Table, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulCurrOffset, &usBytesRead) != 0)
		return(DIRECTORY_ENTRY_OFFSET_ERR);
	ulCurrOffset += usBytesRead; 

   /* read table directory until proper tag is found, or until
      all tags have been read */
	for (i = 0; i < Offset_Table.numTables; ++i)  /* don't want any translation done - read raw data */
	{ 
		if (ReadGeneric(pInputBufferInfo, (uint8 *) &Directory, SIZEOF_DIRECTORY, DIRECTORY_NO_XLATE_CONTROL, ulCurrOffset, &usBytesRead) != 0)
			return(DIRECTORY_ENTRY_OFFSET_ERR);
      	bFound = ( *pulTag == Directory.tag );
		if (bFound)
			break;
		ulCurrOffset += usBytesRead; 
	}

   if ( ! bFound )
      return( DIRECTORY_ERROR );
   return( ulCurrOffset );

}


/* ---------------------------------------------------------------------- */
uint32 GetTTDirectory( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
					  char * szTagName,
                      DIRECTORY * pDirectory )
{
uint16 usBytesRead;
uint32 ulOffset;

	ulOffset = TTDirectoryEntryOffset( pInputBufferInfo, szTagName );
	if ( ulOffset == DIRECTORY_ERROR || ulOffset == DIRECTORY_ENTRY_OFFSET_ERR)
		return( DIRECTORY_ERROR );

	if (ReadGeneric(pInputBufferInfo, (uint8 *) pDirectory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesRead) != NO_ERROR)
		return ( DIRECTORY_ERROR );
	return( ulOffset );

} /* ReadTTDirectory() */


/* ---------------------------------------------------------------------- */
uint32 TTTableLength( TTFACC_FILEBUFFERINFO * pInputBufferInfo, char *  szTagName )
{
DIRECTORY Directory;

	if ( GetTTDirectory( pInputBufferInfo, szTagName, &Directory ) != DIRECTORY_ERROR)
		return( Directory.length );
	return( DIRECTORY_ERROR );
}


/* ---------------------------------------------------------------------- */
uint32 TTTableOffset( TTFACC_FILEBUFFERINFO * pInputBufferInfo, char * szTagName )
{
DIRECTORY Directory;

	if ( GetTTDirectory( pInputBufferInfo, szTagName, &Directory ) != DIRECTORY_ERROR)
		return( Directory.offset );
	return( DIRECTORY_ERROR );
}
/* this function calculates the checksum of a table already written to the buffer */
/* ---------------------------------------------------------------------- */
uint32 TTTableChecksum( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
				  char * szTagName,
                  uint32 * pulChecksum )
{
uint32 ul;
uint32 ulWord;
uint32 ulOffset;
uint32 ulLength;

	*pulChecksum = 0;
	if ((ulOffset = TTTableOffset( pInputBufferInfo, szTagName ))== DIRECTORY_ERROR)
		return DIRECTORY_ERROR;
	if ((ulLength = TTTableLength( pInputBufferInfo, szTagName ))== DIRECTORY_ERROR)
		return DIRECTORY_ERROR;

	for ( ul = 0; ul < (ulLength+3) / 4; ul++ )
	{
		if ( ReadLong( pInputBufferInfo, &ulWord, ulOffset + ul * sizeof(uint32)) != 0 )
		 	break;
		*pulChecksum = *pulChecksum + ulWord;
	}
	return ulOffset; /* any non zero number will do */
}


/* ---------------------------------------------------------------------- */
/* calcs the new checksum */
/* ---------------------------------------------------------------------- */
int16 UpdateChecksum( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
					 char *  szDirTag)
{
DIRECTORY Directory;
uint32 ulOffset;
uint16 usBytesMoved;
int16 errCode;

	/* read existing directory entry */

	ulOffset = GetTTDirectory( pInputBufferInfo, szDirTag, &Directory );
	if ( ulOffset == DIRECTORY_ERROR)
		return NO_ERROR;

	if ((errCode = CalcChecksum( pInputBufferInfo, Directory.offset, Directory.length, &Directory.checkSum )) != NO_ERROR)
		return errCode;

	/* write new directory entry with new checksum */

	if ((errCode = WriteGeneric( pInputBufferInfo, (uint8 *) &Directory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesMoved )) != NO_ERROR)
		return errCode;
	return NO_ERROR;
}

/* ---------------------------------------------------------------------- */
/* sets the new length, calcs the new checksum, makes sure offset on long word boundary */
/* ---------------------------------------------------------------------- */
int16 UpdateDirEntry( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
					 char *  szDirTag,
                     uint32   ulNewLength )
{
DIRECTORY Directory;
uint32 ulOffset;
uint16 usBytesMoved;
int16 errCode;

	/* read existing directory entry */

	ulOffset = GetTTDirectory( pInputBufferInfo, szDirTag, &Directory );
	if ( ulOffset == DIRECTORY_ERROR)
		return NO_ERROR;
	/* set new length and recalc checksum */

	Directory.length = ulNewLength;
	ZeroLongWordGap( pInputBufferInfo, Directory.offset, Directory.length );

	if ((errCode = CalcChecksum( pInputBufferInfo, Directory.offset, Directory.length, &Directory.checkSum )) != NO_ERROR)
		return errCode;

	/* write new directory entry with new checksum */

	if ((errCode = WriteGeneric( pInputBufferInfo, (uint8 *) &Directory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesMoved )) != NO_ERROR)
		return errCode;
	return NO_ERROR;
}

/* ---------------------------------------------------------------------- */
/* sets the new length, calcs the new checksum, makes sure offset on long word boundary */
/* ---------------------------------------------------------------------- */
int16 UpdateDirEntryAll( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
					 char *  szDirTag,
                     uint32   ulNewLength,
					 uint32   ulNewOffset)
{
DIRECTORY Directory;
uint32 ulOffset;
uint16 usBytesMoved;
int16 errCode;

	/* read existing directory entry */

	ulOffset = GetTTDirectory( pInputBufferInfo, szDirTag, &Directory );
	/* set new length and recalc checksum */

	Directory.length = ulNewLength;
	Directory.offset = ulNewOffset + ZeroLongWordAlign( pInputBufferInfo, ulNewOffset);
	if ((errCode = CalcChecksum( pInputBufferInfo, Directory.offset, Directory.length, &Directory.checkSum )) != NO_ERROR)
		return errCode;

	/* write new directory entry with new values */
	if ((errCode = WriteGeneric( pInputBufferInfo, (uint8 *) &Directory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesMoved )) != NO_ERROR)
		return errCode;
	return NO_ERROR;
}


/* ---------------------------------------------------------------------- */

PRIVATE uint32 GetGeneric( TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint8 * puchBuffer, uint16 usTagIndex)
{
uint32 ulOffset;
uint16 usBytesRead;

	if (usTagIndex >= TAG_INDEX_COUNT)
		return 0L;
	if ((ulOffset = TTTableOffset( pInputBufferInfo, Control_Table[usTagIndex].Tag ))== DIRECTORY_ERROR)
		return 0L;
	if (ReadGeneric(pInputBufferInfo, (uint8 *) puchBuffer, Control_Table[usTagIndex].StructSize, Control_Table[usTagIndex].Control, ulOffset, &usBytesRead) != NO_ERROR)
		return 0L;

	return ulOffset;
}

/* ---------------------------------------------------------------------- */
uint32 GetHHea( TTFACC_FILEBUFFERINFO * pInputBufferInfo, HHEA *  pHorizHead )
{
   	return(GetGeneric(pInputBufferInfo, (uint8 *) pHorizHead, HHEA_INDEX));
}

/* ---------------------------------------------------------------------- */
uint32 GetVHea( TTFACC_FILEBUFFERINFO * pInputBufferInfo, VHEA * pVertHead )
{
   	return(GetGeneric(pInputBufferInfo, (uint8 *) pVertHead, VHEA_INDEX));
}

/* ---------------------------------------------------------------------- */
uint32 GetHead( TTFACC_FILEBUFFERINFO * pInputBufferInfo, HEAD *  pHead )
{
   	return(GetGeneric(pInputBufferInfo, (uint8 *) pHead, HEAD_INDEX));
}

/* ---------------------------------------------------------------------- */
uint32 GetOS2( TTFACC_FILEBUFFERINFO * pInputBufferInfo, OS2 *pOs2 )	  
{
   	return(GetGeneric(pInputBufferInfo, (uint8 *) pOs2, OS2_INDEX));
}

/* ---------------------------------------------------------------------- */
uint32 GetNEWOS2( TTFACC_FILEBUFFERINFO * pInputBufferInfo, NEWOS2 *pNewOs2 )	 
{
   	return(GetGeneric(pInputBufferInfo, (uint8 *) pNewOs2, NEWOS2_INDEX));
}

/* ---------------------------------------------------------------------- */
uint32 GetVERSION2OS2( TTFACC_FILEBUFFERINFO * pInputBufferInfo, VERSION2OS2 *pVersion2Os2 )	 
{
   	return(GetGeneric(pInputBufferInfo, (uint8 *) pVersion2Os2, VERSION2OS2_INDEX));
}

/* ---------------------------------------------------------------------- */
uint32 GetSmartOS2(TTFACC_FILEBUFFERINFO * pInputBufferInfo, NEWOS2 *pOs2, BOOL *pbNewOS2)
{
uint32 ulOffset = 0L;
uint32 ulLength = 0L;

	ulLength = TTTableLength( pInputBufferInfo, OS2_TAG);
	if (ulLength > 0L)
	{
		if(ulLength == GetGenericSize(OS2_CONTROL))	/* we read all the bytes available */
		{
			*pbNewOS2 = FALSE;
			ulOffset = GetOS2(pInputBufferInfo,(OS2 *)pOs2);
		}
		else if (ulLength >= GetGenericSize(NEWOS2_CONTROL)) /* make sure there's enough to read */
		{
			*pbNewOS2 = TRUE;
			ulOffset = GetNEWOS2(pInputBufferInfo,pOs2);
		}
	}
	return ulOffset;	
}

/* ---------------------------------------------------------------------- */
uint32 GetSmarterOS2(TTFACC_FILEBUFFERINFO * pInputBufferInfo, MAINOS2 *pOs2)
{
uint32 ulOffset = 0L;
uint32 ulLength = 0L;

	ulLength = TTTableLength( pInputBufferInfo, OS2_TAG);
	if (ulLength > 0L)
	{
		if(ulLength == GetGenericSize(OS2_CONTROL))	/* we read all the bytes available */
			ulOffset = GetOS2(pInputBufferInfo,(OS2 *)pOs2);
		else if (ulLength == GetGenericSize(NEWOS2_CONTROL)) /* make sure there's enough to read */
			ulOffset = GetNEWOS2(pInputBufferInfo,(NEWOS2 *)pOs2);
		else if (ulLength >= GetGenericSize(VERSION2OS2_CONTROL))
			ulOffset = GetVERSION2OS2(pInputBufferInfo,pOs2);		
	}
	return ulOffset;
}

/* ---------------------------------------------------------------------- */
uint32 GetMaxp( TTFACC_FILEBUFFERINFO * pInputBufferInfo, MAXP *  pMaxp )
{
   	return(GetGeneric(pInputBufferInfo, (uint8 *) pMaxp, MAXP_INDEX));
}

/* ---------------------------------------------------------------------- */

uint32 GetPost( TTFACC_FILEBUFFERINFO * pInputBufferInfo, POST *  Post )
{
	return(GetGeneric(pInputBufferInfo, (uint8 *) Post, POST_INDEX));
}
		
/* ---------------------------------------------------------------------- */
uint32 GetHdmx( TTFACC_FILEBUFFERINFO * pInputBufferInfo, HDMX *  Hdmx )
{
	return(GetGeneric(pInputBufferInfo, (uint8 *) Hdmx, HDMX_INDEX));
}
		
/* ---------------------------------------------------------------------- */
uint32 GetLTSH( TTFACC_FILEBUFFERINFO * pInputBufferInfo, LTSH *  Ltsh )
{
	return(GetGeneric(pInputBufferInfo, (uint8 *) Ltsh, LTSH_INDEX));
}
/* ---------------------------------------------------------------------- */
/* ---------------------------------------------------------------------- */
uint16 GetUnitsPerEm( TTFACC_FILEBUFFERINFO * pInputBufferInfo )
{
/* get true type scaling factor */

HEAD Head = {0};

   if (! GetHead(pInputBufferInfo,  &Head ) )
      return( 0 );
   return(Head.unitsPerEm);
}

/* ---------------------------------------------------------------------- */
uint16 GetNumGlyphs( TTFACC_FILEBUFFERINFO * pInputBufferInfo )
{
MAXP MaxP = {0};

   	if (!GetMaxp(pInputBufferInfo, &MaxP))
		return (0);
	return(MaxP.numGlyphs);

} /* GetNumGlyphs() */

/* ---------------------------------------------------------------------- */
/* determine checksum, then calc checkSumAdjustment and write 
the whole thing out again.  This routine assumes that 
the checkSumAdjustment field was set to 0 and the 'head' 
table checksum was computed while that was so.  */
/* ---------------------------------------------------------------------- */
void SetFileChecksum( TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint32 ulLength )
{
uint32        ulCheckSum;
HEAD         Head;
uint32        ulHeadOffset;
uint16 usBytesMoved;


	ulHeadOffset =  TTTableOffset( pOutputBufferInfo, HEAD_TAG );
	if ( ulHeadOffset == 0L )
		return;
	if (ReadGeneric(pOutputBufferInfo, (uint8 *) &Head, SIZEOF_HEAD, HEAD_CONTROL, ulHeadOffset, &usBytesMoved) != NO_ERROR)
		return;

	Head.checkSumAdjustment = 0L;
	if (WriteGeneric(pOutputBufferInfo, (uint8 *) &Head, SIZEOF_HEAD, HEAD_CONTROL, ulHeadOffset, &usBytesMoved) != NO_ERROR)
		return;
	ulCheckSum = CalcFileChecksum(pOutputBufferInfo, ulLength);

	Head.checkSumAdjustment = (0xb1b0afbaL - ulCheckSum );

	WriteGeneric(pOutputBufferInfo, (uint8 *) &Head, SIZEOF_HEAD, HEAD_CONTROL, ulHeadOffset, &usBytesMoved);
}

/* ---------------------------------------------------------------------- */
int16 CopyBlock( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
				uint32 ulTarget,
                uint32 ulSource,
                uint32 ulSize )
{
/* this routine copies a block of TrueType file data, taking into
account possible overlap between source and target */

/* ignore request for "null" copy */

	if ( ulTarget == ulSource || ulSize == 0L )
		return (NO_ERROR);

	/* now check ranges so that we can use memmove to do the copying.*/

	if (ulSource + ulSize > pInputBufferInfo->ulBufferSize) /* if outside of buffer */
		return ERR_READOUTOFBOUNDS;
	if (ulTarget + ulSize > pInputBufferInfo->ulBufferSize) /* if outside of buffer */
		return ERR_WRITEOUTOFBOUNDS;
   /* copy correctly regardless of whether the regions overlap */
#ifdef _MAC
	BlockMove((char *)(pInputBufferInfo->puchBuffer + ulSource),(char *)(pInputBufferInfo->puchBuffer + ulTarget), ulSize); 
#else
	memmove((char *)(pInputBufferInfo->puchBuffer + ulTarget),(char *)(pInputBufferInfo->puchBuffer + ulSource), ulSize); 
#endif // _MAC
	return(NO_ERROR);
}

/* ---------------------------------------------------------------------- */
int16 CopyBlockOver( TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
					 CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo,
					 uint32 ulTarget,
					 uint32 ulSource,
					 uint32 ulSize )
{
int16 errCode;
/* this routine copies a block of data, taking into
account possible overlap between source and target */

/* ignore request for "null" copy */

	if ( (pOutputBufferInfo->puchBuffer + ulTarget == pInputBufferInfo->puchBuffer + ulSource) 
		 || ulSize == 0L )
		return (NO_ERROR);

	/* now check ranges so that we can use memmove to do the copying.*/

	if (ulSource + ulSize > pInputBufferInfo->ulBufferSize) /* if outside of buffer */
		return ERR_READOUTOFBOUNDS;
	/* try to write that last byte to see if we can */
	if ((errCode = WriteByte(pOutputBufferInfo, 0, ulTarget + ulSize - 1)) != NO_ERROR)
		return errCode;
   /* copy correctly regardless of whether the regions overlap */
#ifdef _MAC
	BlockMove((char *)(pInputBufferInfo->puchBuffer + ulSource), (char *)(pOutputBufferInfo->puchBuffer + ulTarget), ulSize); 
#else
	memmove((char *)(pOutputBufferInfo->puchBuffer + ulTarget),(char *)(pInputBufferInfo->puchBuffer + ulSource), ulSize); 
#endif // _MAC
	return(NO_ERROR);
}
/* ---------------------------------------------------------------------- */
/* copy a table from the input buffer to the output buffer to location *pulNewOutOffset */
/* table should not already exist in the output buffer, it will get written elsewhere */ 
/* ---------------------------------------------------------------------- */
int16 CopyTableOver(TTFACC_FILEBUFFERINFO *pOutputBufferInfo,
					CONST_TTFACC_FILEBUFFERINFO *pInputBufferInfo,
					char * Tag,
					uint32 *pulNewOutOffset)
{
uint32 ulOffset;
uint32 ulLength;
uint32 ulDestOffset;
int16 errCode=NO_ERROR;
uint32 ulOutDirectoryOffset;
DIRECTORY Directory;
uint16 usBytesWritten;
	
	ulOutDirectoryOffset = GetTTDirectory( pOutputBufferInfo, Tag, &Directory); 
	/* make sure there is a directory entry */
	if (ulOutDirectoryOffset == DIRECTORY_ERROR) /* this should have been setup */
		return ERR_FORMAT;
	
	ulOffset = TTTableOffset((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, Tag );
	ulLength = TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, Tag);

	if (ulOffset == DIRECTORY_ERROR)
		return ERR_FORMAT; /* couldn't find it in input! */

	ulDestOffset = *pulNewOutOffset + ZeroLongWordAlign(pOutputBufferInfo, *pulNewOutOffset); /* where to put the stuff in the dest buffer */
	Directory.offset = ulDestOffset;
	Directory.length = ulLength;

	if (ulLength > 0)
	{
		if (ulDestOffset + ulLength > pOutputBufferInfo->ulBufferSize) /* uh oh, need to grow */
		{
			if ((errCode = WriteByte((TTFACC_FILEBUFFERINFO *)pOutputBufferInfo, 0, ulDestOffset + ulLength - 1)) != NO_ERROR)
				return errCode;  /* couldn't grow the buffer */
		}
		errCode = ReadBytes((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, pOutputBufferInfo->puchBuffer + ulDestOffset, ulOffset, ulLength);  /* read those bytes */
	}
	if (errCode == NO_ERROR)
	{
		if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &Directory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOutDirectoryOffset, &usBytesWritten )) == NO_ERROR)
			*pulNewOutOffset = ulDestOffset + ulLength;
	}

	return errCode;
}
/* ---------------------------------------------------------------------- */
uint32 RoundToLongWord( uint32  ulLength )
{
	ulLength = (ulLength + 3) & ~3;
	return( ulLength );
}


/* ---------------------------------------------------------------------- */
uint16 ZeroLongWordGap( TTFACC_FILEBUFFERINFO * pInputBufferInfo,
					  uint32  ulOffset,
                      uint32  ulUnalignedLength )
{
uint16 i;
uint32 ulRoundLength;
uint32 ulLongWordRounding;

   /* zero out any pad bytes */

   ulRoundLength      = RoundToLongWord( ulUnalignedLength );
   ulLongWordRounding = ulRoundLength - ulUnalignedLength;
   for ( i = 0; i < (uint16) ulLongWordRounding; i++ )
      WriteByte( pInputBufferInfo, (uint8) 0, ulOffset + ulUnalignedLength + i);
	return ((uint16) ulLongWordRounding);
}

/* ---------------------------------------------------------------------- */
uint16 ZeroLongWordAlign( TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint32  ulOffset)
{
uint16 i;
uint32 ulNewOffset;
uint16 usLongWordRounding;

   /* zero out any pad bytes */

	ulNewOffset = RoundToLongWord(ulOffset);

	usLongWordRounding = (uint16) (ulNewOffset - ulOffset);
	for ( i = 0; i < usLongWordRounding; i++ )
		WriteByte( pInputBufferInfo, (uint8) 0, ulOffset + i);
	return ( usLongWordRounding);
}
/* ---------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfacc1\ttff.h ===
/**************************************************************************
 * module: TTFF.H (True Type Font File)
 *
 * author: Steve McConnell [a-stevem]
 * date:   20 July 1990
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * Typedefs corresponding to tables and table entries in the
 * true type font files. 
 * Use with TTFCntrl.h for platform independent file access
 * Also, update TTFCntrl.h if this file is updated.	  
 * PadForRISC in the OS2 table is the one example of where the 
 * internal data structure does not line up with the image in the file.
 *
 **************************************************************************/

#ifndef TTFF_DOT_H_DEFINED
#define TTFF_DOT_H_DEFINED

#define NEW_OS2

/* This is the amount by which a TTFF structure in memory exceeds the size of that structure in the file */
/* a value of 2 means "At most it will be 2x as large" */
/* Set this to a large value if needed */
/* currently only used by modsbit.c */
#define PORTABILITY_FACTOR 2

/* To ensure that these structures are left as is, and not aligned for */
/* processor access efficiency, use pragma pack(1) */
#pragma pack()

/* True Type Font File defines ------------------------------------------ */

#define UNICODE_PLATFORMID 0
#define APPLE_PLATFORMID   1
#define ISO_PLATFORMID     2
#define MS_PLATFORMID      3
#define NUM_PLATFORMS      4

#define ADOBE_GRID         1000.0

#define HEAD_TAG  "head"
#define CMAP_TAG  "cmap"
#define GLYF_TAG  "glyf"
#define HHEA_TAG  "hhea"
#define VHEA_TAG  "vhea"
#define HMTX_TAG  "hmtx"
#define VMTX_TAG  "vmtx"
#define LOCA_TAG  "loca"
#define MAXP_TAG  "maxp"
#define NAME_TAG  "name"
#define POST_TAG  "post"
#define OS2_TAG   "OS/2"
#define CVT_TAG   "cvt "
#define FPGM_TAG  "fpgm"
#define HDMX_TAG  "hdmx"
#define KERN_TAG  "kern"
#define LTSH_TAG  "LTSH"
#define PREP_TAG  "prep"
#define PCLT_TAG  "PCLT"
#define VDMX_TAG  "VDMX"
#define GASP_TAG  "gasp"
#define EBLC_TAG  "EBLC"
#define EBDT_TAG  "EBDT"
#define EBSC_TAG  "EBSC"
#define BLOC_TAG  "bloc"
#define BDAT_TAG  "bdat"
#define BSCA_TAG  "bsca"
#define GPOS_TAG  "GPOS"
#define GDEF_TAG  "GDEF"
#define GSUB_TAG  "GSUB"
#define JSTF_TAG  "JSTF"
#define BASE_TAG  "BASE"
#define MORT_TAG  "mort"
#define DTTF_TAG  "dttf"  /* private Delta TTF table */
#define DTTF_LONG_TAG 0x64747466 /* 'dttf' need it in this form to SET the value */
#define HHEA_LONG_TAG 0x68686561 /* 'hhea' */
#define VHEA_LONG_TAG 0x76686561 /* "vhea" */
#define HMTX_LONG_TAG 0x686d7478 /* "hmtx" */
#define VMTX_LONG_TAG 0x766d7478 /* "vmtx" */
#define LTSH_LONG_TAG 0x4c545348 /* "LTSH" */
#define HDMX_LONG_TAG 0x68646d78 /* "hdmx" */
#define LOCA_LONG_TAG 0x6c6f6361 /* "loca" */
#define MAXP_LONG_TAG 0x6d617870 /* "maxp" */
#define GLYF_LONG_TAG 0x676c7966 /* 'glyf' */
#define CMAP_LONG_TAG 0x636d6170 /* 'cmap' */
#define EBLC_LONG_TAG 0x45424c43 /* 'EBLC' */
#define EBDT_LONG_TAG 0x45424454 /* 'EBDT' */
#define EBSC_LONG_TAG 0x45425343 /* 'EBSC' */
#define BLOC_LONG_TAG 0x626c6f63 /* 'bloc' */
#define BDAT_LONG_TAG 0x62646174 /* 'bdat' */
#define BSCA_LONG_TAG 0x62736361 /* 'bsca' */
#define HEAD_LONG_TAG 0x68656164 /* 'head' */
#define OS2_LONG_TAG  0x4f532f32 /* 'OS/2' */
#define VDMX_LONG_TAG 0x56444d58 /* "VDMX" */
#define FPGM_LONG_TAG 0x6670676d /* 'fpgm' */
#define PREP_LONG_TAG 0x70726570 /* 'prep' */
#define CVT_LONG_TAG  0x63767420 /* 'cvt ' */
#define KERN_LONG_TAG 0x6b65726e /* 'kern' */
#define NAME_LONG_TAG 0x6e616d65 /* "name" */
#define POST_LONG_TAG 0x706f7374 /* "post" */
#define GASP_LONG_TAG 0x67617370 /* 'gasp' */
#define PCLT_LONG_TAG 0x50434c54 /* 'PCLT' */
#define GPOS_LONG_TAG 0x47504f53 /* 'GPOS' */
#define GSUB_LONG_TAG 0x47535542 /* 'GSUB' */
#define GDEF_LONG_TAG 0x47444546 /* 'GDEF' */
#define JSTF_LONG_TAG 0x4a535446 /* 'JSTF' */
#define BASE_LONG_TAG 0x42415345 /* 'BASE' */
#define TTC_LONG_TAG  0x74746366 /* 'ttcf'

#define WIN_TAG   "win "
#define FOCA_TAG  "foca"
#define BLANK_TAG "    "
#define INFO_TAG  "*   "
#define NULL_TAG ""


/* type definitions --------------------------------------------------- */

/* TTC header */
typedef struct TTC_HEADER
   {
   ULONG  TTCTag;	 /* must be ttcf */
   Fixed   version;
   ULONG  DirectoryCount;
   /* ULONG TableDirectoryOffset */
   } TTC_HEADER;
#define SIZEOF_TTC_HEADER 12


/* Table directory */

typedef struct OFFSET_TABLE
   {
   Fixed   version;
   USHORT  numTables;
   USHORT  searchRange;
   USHORT  entrySelector;
   USHORT  rangeShift;

   } OFFSET_TABLE;
#define SIZEOF_OFFSET_TABLE 12


typedef struct DIRECTORY
   {
   ULONG  tag;
   ULONG  checkSum;
   ULONG  offset;
   ULONG  length;

   } DIRECTORY;
#define SIZEOF_DIRECTORY      16


/* 'cmap' table */
     
#define FORMAT0_CMAP_FORMAT  0
#define FORMAT4_CMAP_FORMAT  4
#define FORMAT6_CMAP_FORMAT  6

typedef struct CMAP_HEADER
   {
   USHORT  versionNumber;
   USHORT  numTables;

   } CMAP_HEADER;
#define SIZEOF_CMAP_HEADER 4

typedef struct CMAP_TABLELOC
   {
   USHORT  platformID;
   USHORT  encodingID;
   ULONG   offset;

   } CMAP_TABLELOC;
#define SIZEOF_CMAP_TABLELOC 8

typedef struct CMAP_SUBHEADER
   {
   USHORT  format;
   USHORT  OldLength;
   ULONG   NewLength;
   } CMAP_SUBHEADER;

#define SIZEOF_CMAP_SUBHEADER 8

#define CMAP_FORMAT0_ARRAYCOUNT 256
typedef struct CMAP_FORMAT0
   {
   USHORT  format;
   USHORT  length;
   USHORT  revision;
   BYTE    glyphIndexArray[CMAP_FORMAT0_ARRAYCOUNT];

   } CMAP_FORMAT0;

#define SIZEOF_CMAP_FORMAT0 6	 /* don't include the array */

typedef struct CMAP_FORMAT6
   {
   USHORT  format;
   USHORT  length;
   USHORT  revision;
   USHORT  firstCode;
   USHORT  entryCount;

   } CMAP_FORMAT6;

#define SIZEOF_CMAP_FORMAT6 10


typedef struct CMAP_FORMAT4
   {
   USHORT  format;
   USHORT  length;
   USHORT  revision;
   USHORT  segCountX2;
   USHORT  searchRange;
   USHORT  entrySelector;
   USHORT  rangeShift;
   } CMAP_FORMAT4;

#define SIZEOF_CMAP_FORMAT4 14

typedef struct FORMAT4_SEGMENTS
   {
   USHORT  endCount;
   USHORT  startCount;
   short   idDelta;
   USHORT  idRangeOffset;
   } FORMAT4_SEGMENTS;

#define SIZEOF_FORMAT4_SEGMENTS 8
    
typedef unsigned short GLYPH_ID;

#define SIZEOF_GLYPH_ID 2


/* 'post' postscript table */

typedef struct POST
   {
   Fixed  formatType;
   Fixed  italicAngle;
   FWord  underlinePos;
   FWord  underlineThickness;
   ULONG  isFixedPitch;
   ULONG  minMemType42;
   ULONG  maxMemType42;
   ULONG  minMemType1;
   ULONG  maxMemType1;
   } POST;
#define SIZEOF_POST 32


/* 'glyf' glyph data table */

typedef struct GLYF_HEADER
   {
   short  numberOfContours;
   FWord  xMin;
   FWord  yMin;
   FWord  xMax;
   FWord  yMax;
   } GLYF_HEADER;
#define SIZEOF_GLYF_HEADER 10

#define ON_CURVE           0x01
#define X_SHORT            0x02
#define Y_SHORT            0x04
#define REPEAT_FLAG        0x08
#define X_SAME             0x10
#define X_SIGN             0x10
#define Y_SAME             0x20
#define Y_SIGN             0x20
#define GLYF_UNDEF_FLAGS   0xC0


typedef struct SIMPLE_GLYPH
   {
   USHORT *endPtsOfContours;
   USHORT instructionLength;
   BYTE   *instructions;
   BYTE   *flags;
   BYTE   *Coordinates;       /* length of x,y coord's depends on flags */
   } SIMPLE_GLYPH;

#define ARG_1_AND_2_ARE_WORDS     0x0001
#define ARGS_ARE_XY_VALUES        0x0002
#define ROUND_XY_TO_GRID          0x0004
#define WE_HAVE_A_SCALE           0x0008
#define NON_OVERLAPPING           0x0010
#define MORE_COMPONENTS           0x0020
#define WE_HAVE_AN_X_AND_Y_SCALE  0x0040
#define WE_HAVE_A_TWO_BY_TWO      0x0080
#define WE_HAVE_INSTRUCTIONS      0x0100
#define USE_MY_METRICS            0x0200
#define COMPOSITE_RESERVED_BITS   (~( ARG_1_AND_2_ARE_WORDS | \
           ARGS_ARE_XY_VALUES | ROUND_XY_TO_GRID | WE_HAVE_A_SCALE | \
           NON_OVERLAPPING | MORE_COMPONENTS | WE_HAVE_AN_X_AND_Y_SCALE | \
           WE_HAVE_A_TWO_BY_TWO | WE_HAVE_INSTRUCTIONS | USE_MY_METRICS ))

typedef struct COMPOSITE_GLYPH
   {
   BYTE TBD;
   } COMPOSITE_GLYPH;

#define SIZEOF_COMPOSITE_GLYPH 1

/* 'head' font header table */

#define SHORT_OFFSETS 0
#define LONG_OFFSETS  1

#define MACSTYLE_BOLD    0x0001
#define MACSTYLE_ITALIC  0x0002

#define HEADFLAG_OPTICALSCALING   0x0004
#define HEADFLAG_NONLINEARSCALING 0x0010

typedef long longDateTime[2];

typedef struct HEAD
   {
   Fixed        version;
   Fixed        fontRevision;
   ULONG        checkSumAdjustment;
   ULONG        magicNumber;
   USHORT       flags;
   USHORT       unitsPerEm;
   longDateTime created;
   longDateTime modified;
   FWord        xMin;
   FWord        yMin;
   FWord        xMax;
   FWord        yMax;
   USHORT       macStyle;
   USHORT       lowestRecPPEM;
   short        fontDirectionHint;
   short        indexToLocFormat;
   short        glyphDataFormat;

   } HEAD;

#define SIZEOF_HEAD 54

/* 'hhea' horizontal header table */

typedef struct HHEA
   {
   Fixed  version;
   FWord  Ascender;
   FWord  Descender;
   FWord  LineGap;
   uFWord advanceWidthMax;
   FWord  minLeftSideBearing;
   FWord  minRightSideBearing;
   FWord  xMaxExtent;
   short  caretSlopeRise;
   short  caretSlopeRun;
   short  reserved1;
   short  reserved2;
   short  reserved3;
   short  reserved4;
   short  reserved5;
   short  metricDataFormat;
   USHORT numLongMetrics;

   } HHEA;

#define SIZEOF_HHEA 36

/* 'hmtx' horizontal metrics table */

typedef struct LONGHORMETRIC
   {
   uFWord  advanceWidth;
   FWord   lsb;

   } LONGHORMETRIC;

#define SIZEOF_LONGHORMETRIC 4

typedef struct
   {
   LONGHORMETRIC *  hMetrics;
   FWord *          leftSideBearing;
   } HMTX;

/* 'vhea' horizontal header table */

typedef struct VHEA
   {
   Fixed  version;
   FWord  Ascender;
   FWord  Descender;
   FWord  LineGap;
   uFWord advanceHeightMax;
   FWord  minTopSideBearing;
   FWord  minBottomSideBearing;
   FWord  yMaxExtent;
   short  caretSlopeRise;
   short  caretSlopeRun;
   short  caretOffset;
   short  reserved2;
   short  reserved3;
   short  reserved4;
   short  reserved5;
   short  metricDataFormat;
   USHORT numLongMetrics;

   } VHEA;
#define SIZEOF_VHEA 36

/* 'vmtx' horizontal metrics table */

typedef struct LONGVERMETRIC
   {
   uFWord  advanceHeight;
   FWord   tsb;
   } LONGVERMETRIC;

#define SIZEOF_LONGVERMETRIC 4

typedef struct
   {
   LONGVERMETRIC *  vMetrics;
   FWord *          topSideBearing;
   } VMTX;

/* for use when dealing with hmtx or vmtx generically */
typedef struct XHEA
   {
   Fixed  version;
   FWord  Ascender;
   FWord  Descender;
   FWord  LineGap;
   uFWord advanceXMax;
   FWord  minLeftTopSideBearing;
   FWord  minRightBottomSideBearing;
   FWord  xyMaxExtent;
   short  caretSlopeRise;
   short  caretSlopeRun;
   short  caretOffset;
   short  reserved2;
   short  reserved3;
   short  reserved4;
   short  reserved5;
   short  metricDataFormat;
   USHORT numLongMetrics;

   } XHEA;
#define SIZEOF_XHEA 36

typedef struct LONGXMETRIC
   {
   uFWord  advanceX;
   FWord   xsb;
   } LONGXMETRIC;

#define SIZEOF_LONGXMETRIC 4

typedef struct
   {
   LONGXMETRIC *  xMetrics;
   FWord * xSideBearing;
   } XMTX;

/* 'loca' index to location table */

typedef union
   {
   USHORT *usOffsets;
   ULONG  *ulOffsets;
   } LOCA;

/* 'LTSH' linear threshold table */

typedef struct
   {
   USHORT      version;
   USHORT      numGlyphs;
   } LTSH;

#define SIZEOF_LTSH 4

typedef BYTE   LTSH_YPELS;
#define SIZEOF_LTSH_YPELS 1

/* 'maxp' maximum profile table */

typedef struct
   {
   Fixed   version;
   USHORT  numGlyphs;
   USHORT  maxPoints;
   USHORT  maxContours;
   USHORT  maxCompositePoints;
   USHORT  maxCompositeContours;
   USHORT  maxElements;
   USHORT  maxTwilightPoints;
   USHORT  maxStorage;
   USHORT  maxFunctionDefs;
   USHORT  maxInstructionDefs;
   USHORT  maxStackElements;
   USHORT  maxSizeOfInstructions;
   USHORT  maxComponentElements;
   USHORT  maxComponentDepth;
   } MAXP;
#define SIZEOF_MAXP 32

/* 'name' naming table */

#define UNDEF_CHAR_SET    0
#define STD_MAC_CHAR_SET  0
#define UGL_CHAR_SET      1
#define DONT_CARE         0xFFFF
#define NAMES_REQ         7
#define MAC_ENGLISH       0
#define MS_USENGLISH      0x0409

#define COPYRIGHT        0
#define FONT_FAMILY      1
#define FONT_SUBFAMILY   2
#define SUBFAMILY_ID     3
#define FULL_FONT_NAME   4
#define VERSION          5
#define POSTSCRIPT_NAME  6

typedef struct
   {
   USHORT  platformID;
   USHORT  encodingID;
   USHORT  languageID;
   USHORT  nameID;
   USHORT  stringLength;
   USHORT  stringOffset;
   } NAME_RECORD;
#define SIZEOF_NAME_RECORD 12

typedef struct
   {
   USHORT       formatSelector;
   USHORT       numNameRecords;
   USHORT       offsetToStringStorage;   /* from start of table */
   } NAME_HEADER;
#define SIZEOF_NAME_HEADER 6

/* 'cvt ' control value table */

typedef FWord  CVT[];


/* 'fpgm' font program table */

typedef BYTE  FPGM[];


/* 'hdmx' horizontal device metrix table */
          
typedef BYTE HDMX_WIDTHS;

typedef struct
   {
   BYTE  pixelSize;
   BYTE  maxWidth;
   } HDMX_DEVICE_REC;
#define SIZEOF_HDMX_DEVICE_REC 2

typedef struct
   {
   USHORT         formatVersion;
   SHORT		  numDeviceRecords;
   LONG           sizeDeviceRecord;
   } HDMX;
#define SIZEOF_HDMX 8

/* 'VDMX' Vertical Device Metrics Table */

typedef struct {
	USHORT yPelHeight;
	SHORT yMax;
	SHORT yMin;
    SHORT PadForRISC;  /* lcp for platform independence */
} VDMXvTable;
#define SIZEOF_VDMXVTABLE 8

typedef struct {
	USHORT recs;
	BYTE startSize;
	BYTE endSize;
/*	VDMXvTable entry[recs];*/
} VDMXGroup;
#define SIZEOF_VDMXGROUP 4

typedef struct {
	BYTE bCharSet;
	BYTE xRatio;
	BYTE yStartRatio;
	BYTE yEndRatio;
} VDMXRatio;
#define SIZEOF_VDMXRATIO 4

typedef struct {
	USHORT version;
	USHORT numRecs;
	USHORT numRatios;
/*	VDMXRatio ratRange[numRatios] */
/* 	uint16 offset[numRatios]; */
/*	VDMXGroup groups[numRecs]; */
}VDMX;
#define SIZEOF_VDMX 6


/*** End VDMX ***/
/* 'dttf' delta ttf table */
#define CURRENT_DTTF_VERSION 0x00010000

typedef struct DTTF_HEADER
{
	Fixed version;	 /* set to 0x00010000 */
	ULONG checkSum;	 /* of original font. Used as unique identifier when merging a font */
	USHORT originalNumGlyphs; /* numGlyphs from Maxp from the original font, used to expand tables */
	USHORT maxGlyphIndexUsed; /* maximum glyph index used in font. same as GlyphIndexArray[glyphCount-1] */
	USHORT format;	/* of font. 0 = regular subset font - no subsequent deltas will be sent. 1 = subset font w/ full tto and kern data - format 2 may merge with this, 2 = delta font, 3 = merged  font (Working TrueType font created by MergeDeltaTTF) */
	USHORT fflags;	/* reserved. Set to 0 */
	USHORT glyphCount;	 /* number of glyphs in GlyphIndexArray. If this is set, then the hmtx, hdmx, vmtx, LTSH and loca tables are in Compact form. If this is 0, they are in full subsetted form. This will be 0 for format 3 fonts. */
/*  USHORT GlyphIndexArray[glyphCount];	 array of glyphCount glyph indices in ascending order corresponding to the glyph indices in this font. This will be empty for format 3 fonts */
} DTTF_HEADER;

#define SIZEOF_DTTF_HEADER 18
/* end 'dttf' delta ttf table */

/* 'kern' kerning table */

#define MS_KERN_FORMAT  0

typedef struct KERN_HEADER
   {
   USHORT format;
   USHORT nTables;
   } KERN_HEADER;
#define SIZEOF_KERN_HEADER 4

typedef struct KERN_SUB_HEADER
   {
   USHORT format;
   USHORT length;
   struct coverage
      {
      USHORT horizontal  :1;
      USHORT minimum     :1;
      USHORT crossStream :1;
      USHORT override    :1;
      USHORT reserved1   :4;
      USHORT format      :8;
      } coverage;
   SHORT  PadForRISC;  /* lcp for platform independence */
   } KERN_SUB_HEADER;
#define SIZEOF_KERN_SUB_HEADER 8

typedef struct KERN_FORMAT_0
   {
   USHORT  nPairs;
   USHORT  searchRange;
   USHORT  entrySelector;
   USHORT  rangeShift;
   } KERN_FORMAT_0;
#define SIZEOF_KERN_FORMAT_0 8

typedef struct KERN_PAIR
   {
   USHORT  left;
   USHORT  right;
   FWord   value;
   SHORT  PadForRISC;  /* lcp for platform independence */
   } KERN_PAIR;
#define SIZEOF_KERN_PAIR 8

typedef struct SEARCH_PAIRS
   {
   ULONG leftAndRight;
   FWord value;
   SHORT PadForRISC;  /* lcp for platform independence */
   } SEARCH_PAIRS;
#define SIZEOF_SEARCH_PAIRS 8

/* 'prep' anachronistic control value table */

typedef BYTE *PREP;


/* 'OS/2' OS/2 and Windows metrics table */

#define UNICODE_a      0x61
#define UNICODE_SPACE  0x20

typedef union
   {
   BYTE array[10];
   struct fields
      {
      BYTE  bFamilyType;
      BYTE  bSerifStyle;
      BYTE  bWeight;
      BYTE  bProportion;
      BYTE  bContrast;
      BYTE  bStrokeVariation;
      BYTE  bArmStyle;
      BYTE  bLetterform;
      BYTE  bMidline;
      BYTE  bXHeight;
      } fields;
   } OS2_PANOSE;
#define SIZEOF_OS2_PANOSE 10


#define OS2_ITALIC     0x0001
#define OS2_UNDERSCORE 0x0002
#define OS2_NEGATIVE   0x0004
#define OS2_OUTLINED   0x0008
#define OS2_STRIKEOUT  0x0010
#define OS2_BOLD       0x0020
#define OS2_REGULAR    0X0040

#define OS2_PANOSE_BOLD       7
#define OS2_PANOSE_ITALIC     9
#define OS2_PANOSE_UNDEFINED  1

#define OS2_WEIGHTCLASS_SEMIBOLD  6

typedef struct
   { 
   USHORT      usVersion;
   SHORT       xAvgCharWidth;
   USHORT      usWeightClass;
   USHORT      usWidthClass;
   SHORT       fsTypeFlags;
   SHORT       ySubscriptXSize;
   SHORT       ySubscriptYSize;
   SHORT       ySubscriptXOffset;
   SHORT       ySubscriptYOffset;
   SHORT       ySuperscriptXSize;
   SHORT       ySuperscriptYSize;
   SHORT       ySuperscriptXOffset;
   SHORT       ySuperscriptYOffset;
   SHORT       yStrikeoutSize;
   SHORT       yStrikeoutPosition;
   SHORT       sFamilyClass;
   union
   {
	  BYTE array[10];
	  struct
      {
		  BYTE  bFamilyType;
		  BYTE  bSerifStyle;
		  BYTE  bWeight;
		  BYTE  bProportion;
		  BYTE  bContrast;
		  BYTE  bStrokeVariation;
		  BYTE  bArmStyle;
		  BYTE  bLetterform;
		  BYTE  bMidline;
		  BYTE  bXHeight;
      } fields;
   } panose;
   SHORT	   PadForRISC;  /* lcp for platform independence */
   ULONG       ulCharRange[4];
   CHAR        achVendID[4];
   USHORT      fsSelection;
   USHORT      usFirstCharIndex;
   USHORT      usLastCharIndex;
   SHORT       sTypoAscender;
   SHORT       sTypoDescender;
   SHORT       sTypoLineGap;
   USHORT      usWinAscent;
   USHORT      usWinDescent;
   } OS2;
#define SIZEOF_OS2 (70+SIZEOF_OS2_PANOSE)

typedef struct
   { 
   USHORT      usVersion;
   SHORT       xAvgCharWidth;
   USHORT      usWeightClass;
   USHORT      usWidthClass;
   SHORT       fsTypeFlags;
   SHORT       ySubscriptXSize;
   SHORT       ySubscriptYSize;
   SHORT       ySubscriptXOffset;
   SHORT       ySubscriptYOffset;
   SHORT       ySuperscriptXSize;
   SHORT       ySuperscriptYSize;
   SHORT       ySuperscriptXOffset;
   SHORT       ySuperscriptYOffset;
   SHORT       yStrikeoutSize;
   SHORT       yStrikeoutPosition;
   SHORT       sFamilyClass;
   union
   {
	   BYTE array[10];
	   struct
      {
		  BYTE  bFamilyType;
		  BYTE  bSerifStyle;
		  BYTE  bWeight;
		  BYTE  bProportion;
		  BYTE  bContrast;
		  BYTE  bStrokeVariation;
		  BYTE  bArmStyle;
		  BYTE  bLetterform;
		  BYTE  bMidline;
		  BYTE  bXHeight;
      } fields;
   } panose;
   SHORT	   PadForRISC;  /* lcp for platform independence */
   ULONG	   ulUnicodeRange1;
   ULONG	   ulUnicodeRange2;
   ULONG	   ulUnicodeRange3;
   ULONG	   ulUnicodeRange4;
   CHAR        achVendID[4];
   USHORT      fsSelection;
   USHORT      usFirstCharIndex;
   USHORT      usLastCharIndex;
   SHORT       sTypoAscender;
   SHORT       sTypoDescender;
   SHORT       sTypoLineGap;
   USHORT      usWinAscent;
   USHORT	   usWinDescent;
   ULONG	   ulCodePageRange1;
   ULONG	   ulCodePageRange2;
   } NEWOS2;
#define SIZEOF_NEWOS2 (78+SIZEOF_OS2_PANOSE)

typedef struct
   { 
   USHORT      usVersion;
   SHORT       xAvgCharWidth;
   USHORT      usWeightClass;
   USHORT      usWidthClass;
   SHORT       fsTypeFlags;
   SHORT       ySubscriptXSize;
   SHORT       ySubscriptYSize;
   SHORT       ySubscriptXOffset;
   SHORT       ySubscriptYOffset;
   SHORT       ySuperscriptXSize;
   SHORT       ySuperscriptYSize;
   SHORT       ySuperscriptXOffset;
   SHORT       ySuperscriptYOffset;
   SHORT       yStrikeoutSize;
   SHORT       yStrikeoutPosition;
   SHORT       sFamilyClass;
   union
   {
	   BYTE array[10];
	   struct
      {
		  BYTE  bFamilyType;
		  BYTE  bSerifStyle;
		  BYTE  bWeight;
		  BYTE  bProportion;
		  BYTE  bContrast;
		  BYTE  bStrokeVariation;
		  BYTE  bArmStyle;
		  BYTE  bLetterform;
		  BYTE  bMidline;
		  BYTE  bXHeight;
      } fields;
   } panose;
   SHORT	   PadForRISC;  /* lcp for platform independence */
   ULONG	   ulUnicodeRange1;
   ULONG	   ulUnicodeRange2;
   ULONG	   ulUnicodeRange3;
   ULONG	   ulUnicodeRange4;
   CHAR        achVendID[4];
   USHORT      fsSelection;
   USHORT      usFirstCharIndex;
   USHORT      usLastCharIndex;
   SHORT       sTypoAscender;
   SHORT       sTypoDescender;
   SHORT       sTypoLineGap;
   USHORT      usWinAscent;
   USHORT	   usWinDescent;
   ULONG	   ulCodePageRange1;
   ULONG	   ulCodePageRange2;
   SHORT	   sxHeight;
   SHORT	   sCapHeight;
   USHORT	   usDefaultChar;
   USHORT	   usBreakChar;
   USHORT	   usMaxLookups;   
   } VERSION2OS2;
#define SIZEOF_VERSION2OS2 (88+SIZEOF_OS2_PANOSE)

/// MAINOS2 will always be most current OS2 we support.
typedef VERSION2OS2 MAINOS2;
#define SIZEOF_MAINOS2 SIZEOF_VERSION2OS2


/*  EBLC, EBDT and EBSC file constants    */

/*	This first EBLC is common to both EBLC and EBSC tables */

typedef struct
   {
   Fixed		fxVersion;
   ULONG		ulNumSizes;
   } EBLCHEADER;
#define SIZEOF_EBLCHEADER 8

typedef struct
{
	CHAR		cAscender;
	CHAR		cDescender;
	BYTE		byWidthMax;
	CHAR		cCaretSlopeNumerator;
	CHAR		cCaretSlopeDenominator;
	CHAR		cCaretOffset;
	CHAR		cMinOriginSB;
	CHAR		cMinAdvanceSB;
	CHAR		cMaxBeforeBL;
	CHAR		cMinAfterBL;
	CHAR		cPad1;
	CHAR		cPad2;
} SBITLINEMETRICS;
#define SIZEOF_SBITLINEMETRICS 12


typedef struct
{
	ULONG		ulIndexSubTableArrayOffset;
	ULONG		ulIndexTablesSize;
#ifdef TESTPORT
	USHORT		pad1;	   /* to test portability */
	USHORT		pad2;
#endif
	ULONG		ulNumberOfIndexSubTables;
	ULONG		ulColorRef;
	SBITLINEMETRICS hori;
	SBITLINEMETRICS vert;
	USHORT		usStartGlyphIndex;
	USHORT		usEndGlyphIndex;
	BYTE		byPpemX;
	BYTE		byPpemY;
	BYTE		byBitDepth;
	CHAR		fFlags;
} BITMAPSIZETABLE;
#ifdef TESTPORT
#define SIZEOF_BITMAPSIZETABLE (28 + SIZEOF_SBITLINEMETRICS + SIZEOF_SBITLINEMETRICS)
#else
#define SIZEOF_BITMAPSIZETABLE (24 + SIZEOF_SBITLINEMETRICS + SIZEOF_SBITLINEMETRICS)
#endif

#define BITMAP_FLAGS_HORIZONTAL 0x01
#define BITMAP_FLAGS_VERTICAL	0x02

typedef struct
{
	BYTE		byHeight;
	BYTE		byWidth;
	CHAR		cHoriBearingX;
	CHAR		cHoriBearingY;
	BYTE		byHoriAdvance;
	CHAR		cVertBearingX;
	CHAR		cVertBearingY;
	BYTE		byVertAdvance;
} BIGGLYPHMETRICS;
#define SIZEOF_BIGGLYPHMETRICS 8

typedef struct
{
	BYTE		byHeight;
	BYTE		byWidth;
	CHAR		cBearingX;
	CHAR		cBearingY;
	BYTE		byAdvance;
} SMALLGLYPHMETRICS;
#define SIZEOF_SMALLGLYPHMETRICS 5

typedef struct
{
	USHORT		usFirstGlyphIndex;
	USHORT		usLastGlyphIndex;
#ifdef TESTPORT
	USHORT		pad1;	   /* to test portability */
	USHORT		pad2;
#endif
	ULONG		ulAdditionalOffsetToIndexSubtable;
} INDEXSUBTABLEARRAY;
#ifdef TESTPORT
#define SIZEOF_INDEXSUBTABLEARRAY 12
#else
#define SIZEOF_INDEXSUBTABLEARRAY 8
#endif

typedef struct
{
	USHORT		usIndexFormat;
	USHORT		usImageFormat;
#ifdef TESTPORT
	USHORT		pad1;	   /* to test portability */
	USHORT		pad2;
#endif
	ULONG		ulImageDataOffset;
} INDEXSUBHEADER;
#ifdef TESTPORT
#define SIZEOF_INDEXSUBHEADER 12
#else
#define SIZEOF_INDEXSUBHEADER 8
#endif

typedef struct
{
	INDEXSUBHEADER	header;
#ifdef TESTPORT
	USHORT		pad1;	   /* to test portability */
	USHORT		pad2;
#endif
	ULONG			aulOffsetArray[1];
} INDEXSUBTABLE1;
#ifdef TESTPORT
#define SIZEOF_INDEXSUBTABLE1 (SIZEOF_INDEXSUBHEADER)+4 /* don't include array entry */
#else
#define SIZEOF_INDEXSUBTABLE1 (SIZEOF_INDEXSUBHEADER) /* don't include array entry */
#endif

/* any padding to format 2 must be the same as format 5 */
typedef struct
{
	INDEXSUBHEADER	header;
#ifdef TESTPORT
	USHORT		pad1;	   /* to test portability */
	USHORT		pad2;
#endif
	ULONG			ulImageSize;
	BIGGLYPHMETRICS bigMetrics;
} INDEXSUBTABLE2;
#ifdef TESTPORT
#define SIZEOF_INDEXSUBTABLE2 (4 + SIZEOF_INDEXSUBHEADER + SIZEOF_BIGGLYPHMETRICS) + 4
#else
#define SIZEOF_INDEXSUBTABLE2 (4 + SIZEOF_INDEXSUBHEADER + SIZEOF_BIGGLYPHMETRICS)
#endif

typedef struct
{
	INDEXSUBHEADER	header;
#ifdef TESTPORT
	USHORT		pad1;	   /* to test portability */
	USHORT		pad2;
#endif
	USHORT			ausOffsetArray[1];
} INDEXSUBTABLE3;
#ifdef TESTPORT
#define SIZEOF_INDEXSUBTABLE3 (SIZEOF_INDEXSUBHEADER)+4 /* don't include array entry */
#else
#define SIZEOF_INDEXSUBTABLE3 (SIZEOF_INDEXSUBHEADER) /* don't include array entry */
#endif

typedef struct
{
#ifdef TESTPORT
	USHORT		pad1;	   /* to test portability */
	USHORT		pad2;
#endif
	USHORT			usGlyphCode;
	USHORT			usOffset;
} CODEOFFSETPAIR;
#ifdef TESTPORT
#define SIZEOF_CODEOFFSETPAIR 4	+4
#else
#define SIZEOF_CODEOFFSETPAIR 4
#endif

typedef struct
{
	INDEXSUBHEADER	header;
	ULONG			ulNumGlyphs;
#ifdef TESTPORT
	USHORT		pad1;	   /* to test portability */
	USHORT		pad2;
#endif
	CODEOFFSETPAIR	glyphArray[1];
} INDEXSUBTABLE4;
#ifdef TESTPORT
#define SIZEOF_INDEXSUBTABLE4 (SIZEOF_INDEXSUBHEADER + 4 + 4) /* don't include array entry */
#else
#define SIZEOF_INDEXSUBTABLE4 (SIZEOF_INDEXSUBHEADER + 4) /* don't include array entry */
#endif

/* any padding to format 5 must be the same as format 2 */

typedef struct
{
	INDEXSUBHEADER	header;
#ifdef TESTPORT
	USHORT		pad1;	   /* to test portability */
	USHORT		pad2;
#endif
	ULONG			ulImageSize;
	BIGGLYPHMETRICS bigMetrics;
	ULONG			ulNumGlyphs;
	USHORT			ausGlyphCodeArray[1];
} INDEXSUBTABLE5;
#ifdef TESTPORT
#define SIZEOF_INDEXSUBTABLE5 (SIZEOF_INDEXSUBHEADER + 8 + SIZEOF_BIGGLYPHMETRICS) + 4 /* don't include array entry */
#else
#define SIZEOF_INDEXSUBTABLE5 (SIZEOF_INDEXSUBHEADER + 8 + SIZEOF_BIGGLYPHMETRICS) /* don't include array entry */
#endif


typedef struct
{
	Fixed		fxVersion;
} EBDTHEADER;
#define SIZEOF_EBDTHEADER 4

typedef struct 
{
	USHORT glyphCode;
	CHAR xOffset;
	CHAR yOffset;
} EBDTCOMPONENT;
#define SIZEOF_EBDTCOMPONENT 4

typedef struct
{
	/* SMALLGLYPHMETRICS */
	BYTE		byHeight;
	BYTE		byWidth;
	CHAR		cBearingX;
	CHAR		cBearingY;
	BYTE		byAdvance;
	/* SMALLGLYPHMETRICS */
	BYTE pad;
	USHORT 	numComponents;
	EBDTCOMPONENT componentArray[1];
} EBDTFORMAT8;
#define SIZEOF_EBDTFORMAT8 8 

typedef struct
{
	BIGGLYPHMETRICS bigMetrics;
	USHORT 	numComponents;
    SHORT PadForRISC;  /* lcp for platform independence */
	EBDTCOMPONENT componentArray[1];
} EBDTFORMAT9;
#define SIZEOF_EBDTFORMAT9 (SIZEOF_BIGGLYPHMETRICS + 4) 

/* TrueType Open GSUB Tables, needed for Auto Mapping of unmapped Glyphs. */
typedef struct {
	USHORT FeatureParamsOffset;  /* dummy, NULL */
	USHORT FeatureLookupCount;
	USHORT LookupListIndexArray[1];
} GSUBFEATURE;
#define SIZEOF_GSUBFEATURE 4


typedef struct {
	ULONG Tag;
	USHORT FeatureOffset;  
    SHORT PadForRISC;  /* lcp for platform independence */
} GSUBFEATURERECORD;

#define SIZEOF_GSUBFEATURERECORD 8

typedef struct 
{
   USHORT FeatureCount; 
   SHORT PadForRISC;  /* lcp for platform independence */
   GSUBFEATURERECORD FeatureRecordArray[1]; 
} GSUBFEATURELIST;

#define SIZEOF_GSUBFEATURELIST 4

#define GSUBSingleLookupType 1
#define GSUBMultipleLookupType 2
#define GSUBAlternateLookupType 3
#define GSUBLigatureLookupType 4
#define GSUBContextLookupType 5	 

typedef struct {
	USHORT	LookupType;
	USHORT 	LookupFlag;
	USHORT 	SubTableCount;
	USHORT	SubstTableOffsetArray[1];
} GSUBLOOKUP;

#define SIZEOF_GSUBLOOKUP 6

typedef struct {
	USHORT	LookupCount;
	USHORT 	LookupTableOffsetArray[1];
} GSUBLOOKUPLIST;
#define SIZEOF_GSUBLOOKUPLIST 2

typedef struct {
	USHORT Format;
	USHORT GlyphCount;
	USHORT GlyphIDArray[1];
} GSUBCOVERAGEFORMAT1;

#define SIZEOF_GSUBCOVERAGEFORMAT1 4

typedef struct {
	USHORT RangeStart;
	USHORT RangeEnd;
	USHORT StartCoverageIndex;
    SHORT PadForRISC;  /* lcp for platform independence */
} GSUBRANGERECORD;

#define SIZEOF_GSUBRANGERECORD 8

typedef struct {
	USHORT Format;
	USHORT CoverageRangeCount;
	GSUBRANGERECORD RangeRecordArray[1];
} GSUBCOVERAGEFORMAT2;

#define SIZEOF_GSUBCOVERAGEFORMAT2 4

typedef struct {
	ULONG Version;
	USHORT ScriptListOffset;
	USHORT FeatureListOffset;
	USHORT LookupListOffset;
} GSUBHEADER;

#define SIZEOF_GSUBHEADER 10

typedef struct {
	USHORT Format;
	USHORT CoverageOffset;
	SHORT DeltaGlyphID;
} GSUBSINGLESUBSTFORMAT1;

#define SIZEOF_GSUBSINGLESUBSTFORMAT1 6

typedef struct {
	USHORT Format;
	USHORT CoverageOffset;
	USHORT GlyphCount; 
	USHORT GlyphIDArray[1];
} GSUBSINGLESUBSTFORMAT2;

#define SIZEOF_GSUBSINGLESUBSTFORMAT2 6

typedef struct { 
	USHORT SequenceGlyphCount;
	USHORT GlyphIDArray[1];
} GSUBSEQUENCE;

#define SIZEOF_GSUBSEQUENCE 2

typedef struct {
	USHORT Format;
	USHORT CoverageOffset;
	USHORT SequenceCount; 
	USHORT SequenceOffsetArray[1];
} GSUBMULTIPLESUBSTFORMAT1;	

#define SIZEOF_GSUBMULTIPLESUBSTFORMAT1	6

typedef struct { 
	USHORT GlyphCount;
	USHORT GlyphIDArray[1];
} GSUBALTERNATESET;

#define SIZEOF_GSUBALTERNATESET 2

typedef struct {
	USHORT Format;
	USHORT CoverageOffset;
	USHORT AlternateSetCount; 
	USHORT AlternateSetOffsetArray[1];
} GSUBALTERNATESUBSTFORMAT1;

#define SIZEOF_GSUBALTERNATESUBSTFORMAT1 6

typedef struct {
	USHORT GlyphID;
	USHORT LigatureCompCount;
	USHORT GlyphIDArray[1];
} GSUBLIGATURE;

#define SIZEOF_GSUBLIGATURE 4

typedef struct {
	USHORT LigatureCount;
	USHORT LigatureOffsetArray[1];
} GSUBLIGATURESET;

#define SIZEOF_GSUBLIGATURESET 2

typedef struct {
	USHORT Format;
	USHORT CoverageOffset;
	USHORT LigatureSetCount;
	USHORT LigatureSetOffsetArray[1];
} GSUBLIGATURESUBSTFORMAT1;

#define SIZEOF_GSUBLIGATURESUBSTFORMAT1 6

typedef struct {
	USHORT SequenceIndex;
	USHORT LookupListIndex;
} GSUBSUBSTLOOKUPRECORD;

#define SIZEOF_GSUBSUBSTLOOKUPRECORD 4

typedef struct {
	USHORT SubRuleGlyphCount;
	USHORT SubRuleSubstCount;
	USHORT GlyphIDArray[1];
/* USHORT SubstLookupRecordArray[1] */  /* can't put this here - in code */
} GSUBSUBRULE;

#define SIZEOF_GSUBSUBRULE 4

typedef struct {
	USHORT SubRuleCount;
	USHORT SubRuleOffsetArray[1];
} GSUBSUBRULESET;

#define SIZEOF_GSUBSUBRULESET 2

typedef struct {
	USHORT Format;
	USHORT CoverageOffset;
	USHORT SubRuleSetCount;
	USHORT SubRuleSetOffsetArray[1];
} GSUBCONTEXTSUBSTFORMAT1;

#define SIZEOF_GSUBCONTEXTSUBSTFORMAT1 6

typedef struct {
	USHORT SubClassRuleGlyphCount;
	USHORT SubClassRuleSubstCount;
	USHORT ClassArray[1];
/* USHORT SubstLookupRecordArray[1] */  /* can't put this here - in code */
} GSUBSUBCLASSRULE;

#define SIZEOF_GSUBSUBCLASSRULE 4

typedef struct {
	USHORT SubClassRuleCount;
	USHORT SubClassRuleOffsetArray[1];
} GSUBSUBCLASSSET;

#define SIZEOF_GSUBSUBCLASSSET 2

typedef struct {
	USHORT Format;
	USHORT CoverageOffset;
	USHORT ClassDefOffset;
	USHORT SubClassSetCount;
	USHORT SubClassSetOffsetArray[1];
} GSUBCONTEXTSUBSTFORMAT2;

#define SIZEOF_GSUBCONTEXTSUBSTFORMAT2 8

typedef struct {
	USHORT Format;
	USHORT GlyphCount;
	USHORT SubstCount;
	USHORT CoverageOffsetArray[1];
/* USHORT SubstLookupRecordArray[1] */
} GSUBCONTEXTSUBSTFORMAT3;

#define SIZEOF_GSUBCONTEXTSUBSTFORMAT3 6

/* just enough jstf info to get the Automap working for jstf */
typedef struct {
	ULONG Tag;
	USHORT JstfScriptOffset; 
    SHORT PadForRISC;  /* lcp for platform independence */
} JSTFSCRIPTRECORD;

#define SIZEOF_JSTFSCRIPTRECORD 8

typedef struct {
	ULONG Version;
	USHORT ScriptCount; /* do we need a pad-for-risc here ? */
    SHORT PadForRISC;  /* lcp for platform independence */
	JSTFSCRIPTRECORD ScriptRecordArray[1];
} JSTFHEADER;

#define SIZEOF_JSTFHEADER 8

typedef struct {
	ULONG Tag;		
	USHORT LangSysOffset;
	SHORT PadForRISC;  /* lcp for platform independence */
} JSTFLANGSYSRECORD;

#define SIZEOF_JSTFLANGSYSRECORD 8

typedef struct {
	USHORT ExtenderGlyphOffset;
	USHORT LangSysOffset;
	USHORT LangSysCount;	
	SHORT PadForRISC;  /* lcp for platform independence */
	JSTFLANGSYSRECORD LangSysRecordArray[1];
} JSTFSCRIPT;

#define SIZEOF_JSTFSCRIPT 8

typedef struct {
USHORT ExtenderGlyphCount;
USHORT GlyphIDArray[1];
} JSTFEXTENDERGLYPH;

#define SIZEOF_JSTFEXTENDERGLYPH 2

/* BASE TTO Table, enough to do TTOAutoMap */

typedef struct {
ULONG version;              
USHORT HorizAxisOffset;                          
USHORT VertAxisOffset;             
} BASEHEADER;

#define SIZEOF_BASEHEADER 8

typedef struct {
USHORT BaseTagListOffset;
USHORT BaseScriptListOffset;
} BASEAXIS;
#define SIZEOF_BASEAXIS 4

typedef struct {
ULONG Tag;               
USHORT BaseScriptOffset;
SHORT PadForRISC;  /* lcp for platform independence */
} BASESCRIPTRECORD;
#define SIZEOF_BASESCRIPTRECORD 8

typedef struct {
USHORT BaseScriptCount; 
SHORT PadForRISC;  /* lcp for platform independence */
BASESCRIPTRECORD BaseScriptRecordArray[1];
} BASESCRIPTLIST;
#define SIZEOF_BASESCRIPTLIST 4

typedef struct {
	ULONG Tag;                                 
	USHORT MinMaxOffset; 
	SHORT PadForRISC;  /* lcp for platform independence */
} BASELANGSYSRECORD;
#define SIZEOF_BASELANGSYSRECORD 8

typedef struct {
	USHORT BaseValuesOffset;
	USHORT MinMaxOffset;
	USHORT BaseLangSysCount;  
	SHORT PadForRISC;  /* lcp for platform independence */
	BASELANGSYSRECORD BaseLangSysRecordArray[1];
} BASESCRIPT;
#define SIZEOF_BASESCRIPT 8

typedef struct {
	USHORT DefaultIndex;
	USHORT BaseCoordCount;
	USHORT BaseCoordOffsetArray[1];
} BASEVALUES;
#define SIZEOF_BASEVALUES 4

typedef struct {
	ULONG Tag;
	USHORT MinCoordOffset;
	USHORT MaxCoordOffset;
} BASEFEATMINMAXRECORD;
#define SIZEOF_BASEFEATMINMAXRECORD 8

typedef struct {
	USHORT MinCoordOffset; 
	USHORT MaxCoordOffset;		               
	USHORT FeatMinMaxCount;
	SHORT PadForRISC;  /* lcp for platform independence */
	BASEFEATMINMAXRECORD FeatMinMaxRecordArray[1];
} BASEMINMAX;
#define SIZEOF_BASEMINMAX 8

typedef struct {
USHORT Format; 
USHORT Coord;
USHORT GlyphID;
USHORT BaseCoordPoint;                                
} BASECOORDFORMAT2;
#define SIZEOF_BASECOORDFORMAT2 8


/* Glyph Metamorphosis table (mort) structures */

typedef struct {
    USHORT  entrySize;      // size in bytes of a lookup entry ( should be 4 )
    USHORT  nEntries;       // number of lookup entries to be searched
    USHORT  searchRange;
    USHORT  entrySelector;
    USHORT  rangeShift;
} MORTBINSRCHHEADER;
#define SIZEOF_MORTBINSRCHHEADER 10

typedef struct {
    USHORT  glyphid1;       // the glyph index for the horizontal shape
    USHORT  glyphid2;       // the glyph index for the vertical shape
} MORTLOOKUPSINGLE;
#define SIZEOF_MORTLOOKUPSINGLE 4

typedef struct {
    BYTE           constants1[12];
    ULONG          length1;
    BYTE           constants2[16];
    BYTE           constants3[16];
    BYTE           constants4[8];
    USHORT         length2;
    BYTE           constants5[8];
/*    MORTBINSRCHHEADER  SearchHeader; */
/*    MORTLOOKUPSINGLE   entries[1];  */
} MORTHEADER;
#define SIZEOF_MORTHEADER 66


/* other defines for font file processing ------------------------------- */

#ifndef TRUE
#define TRUE             1
#define FALSE            0
#endif

#define ROMAN          ((BYTE) 0x00)
#define BOLD           ((BYTE) 0x01)
#define ITALIC         ((BYTE) 0x02)
#define BOLDITALIC     ((BYTE) 0x03)
#define BLDIT_MASK     ((BYTE) 0x03)
#define UNDERSCORE     ((BYTE) 0x04)
#define STRIKEOUT      ((BYTE) 0x08)

#pragma pack()

#endif /* TTFF_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfacc1\ttftabl1.h ===
/***************************************************************************
 * module: TTFTABL1.H
 *
 * author: Louise Pathe
 * date:   November 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * Function prototypes for TTFTABL1.C for TTFacc.lib
 *		Lower level functions extracted from ttftable.c
 *
 **************************************************************************/
 /* NOTE: must include TYPEDEFS.H, TTFF.H and TTFACC.H before this file */

#ifndef TTFTABL1_DOT_H_DEFINED
#define TTFTABL1_DOT_H_DEFINED        
/* preprocessor macros -------------------------------------------------- */
#define DIRECTORY_ENTRY_OFFSET_ERR 0xFFFFFFFF
#define DIRECTORY_ERROR 0L

/* structure definitions -------------------------------------------------- */

/* exported functions --------------------------------------------------- */
void ConvertLongTagToString(uint32 ulTag, char *szTag);	  /* convert a tag, as it has been read from the font, to a string */
void ConvertStringTagToLong(char *szTag, uint32 *pulTag);

uint32 TTDirectoryEntryOffset( TTFACC_FILEBUFFERINFO * pInputBufferInfo, char * szTagName );
uint32 GetTTDirectory( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
					  char * szTagName,
                      DIRECTORY * pDirectory );
uint32 TTTableLength( TTFACC_FILEBUFFERINFO * pInputBufferInfo, char * szTagName );

uint32 TTTableOffset( TTFACC_FILEBUFFERINFO * pInputBufferInfo, char * szTagName );
uint32 TTTableChecksum( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
				  char * szTagName,
                  uint32 * pulChecksum );

int16 UpdateChecksum( TTFACC_FILEBUFFERINFO * pInputBufferInfo,
					 char *  szDirTag );

int16 UpdateDirEntry( TTFACC_FILEBUFFERINFO * pInputBufferInfo,
					 char *  szDirTag,
                     uint32   ulNewLength );

int16 UpdateDirEntryAll( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
					 char *  szDirTag,
                     uint32   ulNewLength,
					 uint32   ulNewOffset);

					 uint32 GetHHea( TTFACC_FILEBUFFERINFO * pInputBufferInfo, HHEA * HorizHead );
uint32 GetVHea( TTFACC_FILEBUFFERINFO * pInputBufferInfo, VHEA * VertHead );
uint32 GetHead( TTFACC_FILEBUFFERINFO * pInputBufferInfo, HEAD * Head );
uint32 GetOS2( TTFACC_FILEBUFFERINFO * pInputBufferInfo, OS2 *Os2 );	  
uint32 GetNEWOS2( TTFACC_FILEBUFFERINFO * pInputBufferInfo, NEWOS2 *NEWOs2 );	
uint32 GetVERSION2OS2( TTFACC_FILEBUFFERINFO * pInputBufferInfo, VERSION2OS2 *pVersion2Os2 );
uint32 GetSmartOS2(TTFACC_FILEBUFFERINFO * pInputBufferInfo, NEWOS2 *pOs2, BOOL *pbNewOS2);
uint32 GetSmarterOS2(TTFACC_FILEBUFFERINFO * pInputBufferInfo, MAINOS2 *pOs2);
uint32 GetMaxp( TTFACC_FILEBUFFERINFO * pInputBufferInfo, MAXP *  pMaxp );
uint32 GetPost( TTFACC_FILEBUFFERINFO * pInputBufferInfo, POST *  Post );
uint32 GetHdmx( TTFACC_FILEBUFFERINFO * pInputBufferInfo, HDMX *  Hdmx );
uint32 GetLTSH( TTFACC_FILEBUFFERINFO * pInputBufferInfo, LTSH *  Ltsh );
uint16 GetUnitsPerEm( TTFACC_FILEBUFFERINFO * pInputBufferInfo );
uint16 GetNumGlyphs( TTFACC_FILEBUFFERINFO * pInputBufferInfo );

void SetFileChecksum( TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint32 ulLength );
int16 CopyBlock( TTFACC_FILEBUFFERINFO * pInputBufferInfo,
				uint32 ulTarget,
                uint32 ulSource,
                uint32 ulSize )	;
int16 CopyBlockOver( TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
					 CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo,
					 uint32 ulTarget,
					 uint32 ulSource,
					 uint32 ulSize );
int16 CopyTableOver(TTFACC_FILEBUFFERINFO *pOutputBufferInfo,
					CONST_TTFACC_FILEBUFFERINFO *pInputBufferInfo,
					char * Tag,
					uint32 *pulNewOutOffset);
uint32 RoundToLongWord( uint32  ulLength ) ;
uint16 ZeroLongWordGap( TTFACC_FILEBUFFERINFO * pInputBufferInfo,
					  uint32  ulOffset,
                      uint32  ulUnalignedLength );
uint16 ZeroLongWordAlign( TTFACC_FILEBUFFERINFO * pInputBufferInfo,
						  uint32  ulOffset);

#endif TTFTABL1_DOT_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfacc1\typedefs.h ===
/*
  * TypeDefs.h: stolen from FSCDEFS.H in FScaler project
  *
  * Copyright 1990-1997. Microsoft Corporation.
  *
  */

#ifndef TYPEDEFS_DOT_H_DEFINED
#define TYPEDEFS_DOT_H_DEFINED

#include <stddef.h>
#include <limits.h>

#define true 1
#define false 0
#ifndef TRUE
#define TRUE    true
#endif

#ifndef FALSE
#define FALSE   false
#endif

#define ONEFIX      ( 1L << 16 )
#define ONEFRAC     ( 1L << 30 )
#define ONEHALFFIX  0x8000L
#define ONEVECSHIFT 16
#define HALFVECDIV  (1L << (ONEVECSHIFT-1))

#define NULL_GLYPH  0

typedef signed char int8;
typedef unsigned char uint8;
typedef short int16;
typedef unsigned short uint16;
typedef long int32;
typedef unsigned long uint32;

typedef short FUnit;
typedef unsigned short uFUnit;

typedef short ShortFract;                       /* 2.14 */

#ifndef F26Dot6
#define F26Dot6 long
#endif

#ifndef boolean
#define boolean int
#endif

#ifndef CONST
#define CONST const
#endif

#ifndef FAR
#define FAR
#endif

#ifndef NEAR
#define NEAR
#endif

/* Private Data Types */
typedef struct {
	int16 xMin;
	int16 yMin;
	int16 xMax;
	int16 yMax;
} BBOX;

typedef struct {
	F26Dot6 x;
	F26Dot6 y;
} point;

typedef int32 ErrorCode;

#define ALIGN(object, p) p =    (p + ((uint32)sizeof(object) - 1)) & ~((uint32)sizeof(object) - 1);

#define ROWBYTESLONG(x)     (((x + 31) >> 5) << 2)

#ifndef SHORTMUL
#define SHORTMUL(a,b)   (int32)((int32)(a) * (b))
#endif

#ifndef SHORTDIV
#define SHORTDIV(a,b)   (int32)((int32)(a) / (b))
#endif

/* Portable code to extract a short or a long from a 2- or 4-byte buffer */
/* which was encoded using Motorola 68000 (TrueType "native") byte order. */
#define FS_2BYTE(p)  ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
#define FS_4BYTE(p)  ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )

#define SWAPW(a)        ((int16) FS_2BYTE( (unsigned char *)(&a) ))
#define SWAPL(a)        ((int32) FS_4BYTE( (unsigned char *)(&a) ))
#define SWAPWINC(a)     SWAPW(*(a)); a++    /* Do NOT parenthesize! */

#define ASSERT(expression, message)

#ifndef Assert
#define Assert(a)
#endif

#ifndef INTEL	/* should be in stdio, but isn't on MAC */
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

/* for use by TTFF.h, from TTTypes.h */
typedef char CHAR;	 /* lcp 3/97 take away signed so as not to conflict with winnt.h */
typedef unsigned short USHORT;
typedef short SHORT;
typedef long LONG;
typedef unsigned long ULONG;
typedef short FWord;
typedef unsigned short uFWord;
typedef short F2Dot14;
typedef unsigned char UCHAR;
typedef unsigned char BYTE;
typedef int BOOL;
/* #ifdef INTEL	lcp 5/1/97 well, this IS needed after all */
typedef long Fixed;
/* #endif */

#ifdef ICECAP
#define PRIVATE	 /* don't define so Icecap will print function names */
#else
#define PRIVATE         static
#endif

#define MAXBUFFERLEN 256 /* convenient for temp buffers */

#if 0		  /* for mac and other compilers without stricmp */
#include "mystring.h"
#define _stricmp my_stricmp
#define _strnicmp my_strnicmp
#endif

// on IA64 when we need to access data with an unaligned pointer, we need to use __unaligned
// this is typically when reading of writing data that has a specific alignement corresponding
// to a specific file format, ie Reading/Writing TrueType data

// (from ntdef.h)

#ifndef     UNALIGNED

#if defined(_M_MRX000) || defined(_M_AMD64) || defined(_M_PPC) || defined(_M_IA64)

#define UNALIGNED __unaligned

#else

#define UNALIGNED

#endif

#endif


#endif  /* TYPEDEFS_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfacc1\ttfcntrl.c ===
/***************************************************************************
 * module: TTFCNTRL.C
 *
 * author: Louise Pathe
 * date:   Nov 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * companion to TTFF.h for generic platform independant read and swap handling 
 * if TTFF.h is updated for platform performance reasons, this should be updated
 * as well 
 *
 **************************************************************************/


/* Inclusions ----------------------------------------------------------- */


#include "typedefs.h"
#include "ttff.h" /* for TESTPORT definition */
#include "ttfacc.h"
#include "ttfcntrl.h"

uint8 BYTE_CONTROL[2] = 
	{
	1,
	TTFACC_BYTE
	} ;
uint8 WORD_CONTROL[2] = 
	{
	1,
	TTFACC_WORD
	};
uint8 LONG_CONTROL[2] = 
	{
	1,
	TTFACC_LONG
	};

/* TTC header */
#define TTC_HEADER_CONTROL_COUNT 3
uint8 TTC_HEADER_CONTROL [TTC_HEADER_CONTROL_COUNT+1] =
{
   TTC_HEADER_CONTROL_COUNT,
   TTFACC_LONG, /* TTCTag */
   TTFACC_LONG, /*  version */
   TTFACC_LONG, /*  DirectoryCount */
   /* ULONG TableDirectoryOffset */
 } ; /* TTC_HEADER */


#define OFFSET_TABLE_CONTROL_COUNT 5
uint8 OFFSET_TABLE_CONTROL [OFFSET_TABLE_CONTROL_COUNT+1]	=
   {
   OFFSET_TABLE_CONTROL_COUNT,
   TTFACC_LONG, /* Fixed   version */
   TTFACC_WORD, /* TTFACC_WORD, /*  numTables */
   TTFACC_WORD, /* TTFACC_WORD, /*  searchRange */	
   TTFACC_WORD, /* TTFACC_WORD, /*  entrySelector */ 
   TTFACC_WORD /* TTFACC_WORD, /*  rangeShift */ 
   }; /*  */

#define DIRECTORY_CONTROL_COUNT 4
uint8 DIRECTORY_CONTROL[DIRECTORY_CONTROL_COUNT+1] =
   {
   DIRECTORY_CONTROL_COUNT,
   TTFACC_LONG,  /* TTFACC_LONG, /*  tag */
   TTFACC_LONG,  /* TTFACC_LONG, /*  checkSum */
   TTFACC_LONG,  /* TTFACC_LONG, /*  offset */
   TTFACC_LONG  /* TTFACC_LONG, /*  length */

   }; /*  */

#define DIRECTORY_NO_XLATE_CONTROL_COUNT 4	  /* no translation */
uint8 DIRECTORY_NO_XLATE_CONTROL[DIRECTORY_NO_XLATE_CONTROL_COUNT+1] =
   {
   DIRECTORY_NO_XLATE_CONTROL_COUNT,
   TTFACC_LONG|TTFACC_NO_XLATE,  /* TTFACC_LONG, /*  tag */
   TTFACC_LONG|TTFACC_NO_XLATE,  /* TTFACC_LONG, /*  checkSum */
   TTFACC_LONG|TTFACC_NO_XLATE,  /* TTFACC_LONG, /*  offset */
   TTFACC_LONG|TTFACC_NO_XLATE  /* TTFACC_LONG, /*  length */

   }; /*  */

#define CMAP_HEADER_CONTROL_COUNT 2
uint8 CMAP_HEADER_CONTROL[CMAP_HEADER_CONTROL_COUNT+1] = 
   {
   CMAP_HEADER_CONTROL_COUNT,
   TTFACC_WORD, /*  versionNumber */
   TTFACC_WORD  /*  numTables */
   }; /*  CMAP_HEADER */


#define CMAP_TABLELOC_CONTROL_COUNT 3
uint8 CMAP_TABLELOC_CONTROL[CMAP_TABLELOC_CONTROL_COUNT+1] =
   {
   CMAP_TABLELOC_CONTROL_COUNT,
   TTFACC_WORD, /*  platformID */
   TTFACC_WORD, /*  encodingID */
   TTFACC_LONG /*   offset */
   }; /*  CMAP_TABLELOC */

#define CMAP_SUBHEADER_CONTROL_COUNT 3 
uint8 CMAP_SUBHEADER_CONTROL[CMAP_SUBHEADER_CONTROL_COUNT+1] =
   {
   CMAP_SUBHEADER_CONTROL_COUNT,
   TTFACC_WORD, /*  format */
   TTFACC_WORD, /*  length for old tables */
   TTFACC_LONG, /*  length for new surragate tables */
   }; /*  CMAP_SUBHEADER */

#define CMAP_FORMAT0_CONTROL_COUNT 3
uint8 CMAP_FORMAT0_CONTROL[CMAP_FORMAT0_CONTROL_COUNT+1] =
   {
   CMAP_FORMAT0_CONTROL_COUNT,
   TTFACC_WORD, /*  format */
   TTFACC_WORD, /*  length */
   TTFACC_WORD  /*  revision */
   }; /*  CMAP_FORMAT0 */

#define CMAP_FORMAT6_CONTROL_COUNT 5
uint8 CMAP_FORMAT6_CONTROL[CMAP_FORMAT6_CONTROL_COUNT+1] =
   {
   CMAP_FORMAT6_CONTROL_COUNT,
   TTFACC_WORD, /*  format */
   TTFACC_WORD, /*  length */
   TTFACC_WORD, /*  revision */
   TTFACC_WORD, /*  firstCode */
   TTFACC_WORD  /*  entryCount */

   }; /*  CMAP_FORMAT6 */

#define CMAP_FORMAT4_CONTROL_COUNT 7
uint8 CMAP_FORMAT4_CONTROL[CMAP_FORMAT4_CONTROL_COUNT+1] =
   {
   CMAP_FORMAT4_CONTROL_COUNT,
   TTFACC_WORD, /*  format */
   TTFACC_WORD, /*  length */
   TTFACC_WORD, /*  revision */
   TTFACC_WORD, /*  segCountX2 */
   TTFACC_WORD, /*  searchRange */
   TTFACC_WORD, /*  entrySelector */
   TTFACC_WORD  /*  rangeShift */
   }; /*  CMAP_FORMAT4 */

#define FORMAT4_SEGMENTS_CONTROL_COUNT 4
uint8 FORMAT4_SEGMENTS_CONTROL[FORMAT4_SEGMENTS_CONTROL_COUNT+1] =
   {
   FORMAT4_SEGMENTS_CONTROL_COUNT,
   TTFACC_WORD, /*  endCount */
   TTFACC_WORD, /*  startCount */
   TTFACC_WORD, /*   idDelta */
   TTFACC_WORD  /*  idRangeOffset */
   }; /*  FORMAT4_SEGMENTS */
    
/* 'post' postscript table */

#define POST_CONTROL_COUNT 9
uint8 POST_CONTROL[POST_CONTROL_COUNT+1] =
   {
   POST_CONTROL_COUNT,
   TTFACC_LONG, /*  formatType */
   TTFACC_LONG, /*  italicAngle */
   TTFACC_WORD, /* underlinePos */
   TTFACC_WORD, /* underlineThickness */
   TTFACC_LONG, /*  isTTFACC_LONG, /*Pitch */
   TTFACC_LONG, /*  minMemType42 */
   TTFACC_LONG, /*  maxMemType42 */
   TTFACC_LONG, /*  minMemType1 */
   TTFACC_LONG  /*  maxMemType1 */
   }; /*  POST */

/* 'glyf' glyph data table */

#define GLYF_HEADER_CONTROL_COUNT 5
uint8 GLYF_HEADER_CONTROL[GLYF_HEADER_CONTROL_COUNT+1] =
   {
   GLYF_HEADER_CONTROL_COUNT,
   TTFACC_WORD, /*  numberOfContours */
   TTFACC_WORD, /* xMin */
   TTFACC_WORD, /* yMin */
   TTFACC_WORD, /* xMax */
   TTFACC_WORD  /* yMax */
   }; /*  GLYF_HEADER */

#define SIMPLE_GLYPH_CONTROL_COUNT 5
uint8 SIMPLE_GLYPH_CONTROL[SIMPLE_GLYPH_CONTROL_COUNT+1] =
   {
   SIMPLE_GLYPH_CONTROL_COUNT,
   TTFACC_WORD, /* *endPtsOfContours */
   TTFACC_WORD, /* instructionLength */
   TTFACC_BYTE, /*   *instructions */
   TTFACC_BYTE, /*   *flags */
   TTFACC_BYTE  /*   *Coordinates */       /* length of x,y coord's depends on flags */
   }; /*  SIMPLE_GLYPH */

#define COMPOSITE_GLYPH_CONTROL_COUNT 1
uint8 COMPOSITE_GLYPH_CONTROL[COMPOSITE_GLYPH_CONTROL_COUNT+1] =
   {
   COMPOSITE_GLYPH_CONTROL_COUNT,
   TTFACC_BYTE  /* TBD */
   }; /*  COMPOSITE_GLYPH */

#define HEAD_CONTROL_COUNT 19 
uint8 HEAD_CONTROL[HEAD_CONTROL_COUNT+1] =
   {
   HEAD_CONTROL_COUNT,
   TTFACC_LONG, /*        version */
   TTFACC_LONG, /*        fontRevision */
   TTFACC_LONG, /*        checkSumAdjustment */
   TTFACC_LONG, /*        magicNumber */
   TTFACC_WORD, /*       flags */
   TTFACC_WORD, /*       unitsPerEm */
   TTFACC_LONG, /* created[0] */
   TTFACC_LONG, /* created[1] */
   TTFACC_LONG, /* modified[0] */
   TTFACC_LONG, /* modified[1] */
   TTFACC_WORD, /*       xMin */
   TTFACC_WORD, /*       yMin */
   TTFACC_WORD, /*       xMax */
   TTFACC_WORD, /*        yMax */
   TTFACC_WORD, /*       macStyle */
   TTFACC_WORD, /*       lowestRecPPEM */
   TTFACC_WORD, /*        fontDirectionHint */
   TTFACC_WORD, /*        indexToLocFormat */
   TTFACC_WORD /*        glyphDataFormat */

   }; /*  HEAD */


/* 'hhea' horizontal header table */

#define HHEA_CONTROL_COUNT 17
uint8 HHEA_CONTROL[HHEA_CONTROL_COUNT+1] =
   {
   HHEA_CONTROL_COUNT,
   TTFACC_LONG, /*  version */
   TTFACC_WORD, /* Ascender */
   TTFACC_WORD, /* Descender */
   TTFACC_WORD, /* LineGap */
   TTFACC_WORD, /*advanceWidthMax */
   TTFACC_WORD, /* minLeftSideBearing */
   TTFACC_WORD, /* minRightSideBearing */
   TTFACC_WORD, /* xMaxExtent */
   TTFACC_WORD, /*  caretSlopeRise */
   TTFACC_WORD, /*  caretSlopeRun */
   TTFACC_WORD, /*  reserved1 */
   TTFACC_WORD, /*  reserved2 */
   TTFACC_WORD, /*  reserved3 */
   TTFACC_WORD, /*  reserved4 */
   TTFACC_WORD, /*  reserved5 */
   TTFACC_WORD, /*  metricDataFormat */
   TTFACC_WORD  /* numLongMetrics */

   }; /*  HHEA */


/* 'hmtx' horizontal metrics table */

#define LONGHORMETRIC_CONTROL_COUNT 2
uint8 LONGHORMETRIC_CONTROL[LONGHORMETRIC_CONTROL_COUNT+1] =
   {
   LONGHORMETRIC_CONTROL_COUNT,
   TTFACC_WORD, /* advanceWidth */
   TTFACC_WORD  /*  lsb */
   }; /*  LONGHORMETRIC */

#define LSB_CONTROL_COUNT 1
uint8 LSB_CONTROL[LSB_CONTROL_COUNT+1] = 
	{
	LSB_CONTROL_COUNT,
 	TTFACC_WORD
	};

/* 'vhea' horizontal header table */

#define  VHEA_CONTROL_COUNT 17
uint8 VHEA_CONTROL[VHEA_CONTROL_COUNT+1] =
   {
   VHEA_CONTROL_COUNT,
   TTFACC_LONG, /*  version */
   TTFACC_WORD, /* Ascender */
   TTFACC_WORD, /* Descender */
   TTFACC_WORD, /* LineGap */
   TTFACC_WORD, /*advanceHeightMax */
   TTFACC_WORD, /* minTopSideBearing */
   TTFACC_WORD, /* minBottomSideBearing */
   TTFACC_WORD, /* yMaxExtent */
   TTFACC_WORD, /*  caretSlopeRise */
   TTFACC_WORD, /*  caretSlopeRun */
   TTFACC_WORD, /*  caretOffset */
   TTFACC_WORD, /*  reserved2 */
   TTFACC_WORD, /*  reserved3 */
   TTFACC_WORD, /*  reserved4 */
   TTFACC_WORD, /*  reserved5 */
   TTFACC_WORD, /*  metricDataFormat */
   TTFACC_WORD  /* numLongMetrics */

   }; /*  VHEA */


/* 'hmtx' horizontal metrics table */

#define LONGVERMETRIC_CONTROL_COUNT 2
uint8 LONGVERMETRIC_CONTROL[LONGVERMETRIC_CONTROL_COUNT+1] =
   {
   LONGVERMETRIC_CONTROL_COUNT,
   TTFACC_WORD,  /* advanceHeight */
   TTFACC_WORD   /* tsb */

   }; /*  LONGVERMETRIC */


/* generic 'hmtx', 'vmtx' tables */
#define XHEA_CONTROL_COUNT 17
uint8 XHEA_CONTROL[XHEA_CONTROL_COUNT+1] =
   {
   XHEA_CONTROL_COUNT,
   TTFACC_LONG, /*  version */
   TTFACC_WORD, /* Ascender */
   TTFACC_WORD, /* Descender */
   TTFACC_WORD, /* LineGap */
   TTFACC_WORD, /*advanceWidthHeightMax */
   TTFACC_WORD, /* minLeftTopSideBearing */
   TTFACC_WORD, /* minRightBottomSideBearing */
   TTFACC_WORD, /* xyMaxExtent */
   TTFACC_WORD, /*  caretSlopeRise */
   TTFACC_WORD, /*  caretSlopeRun */
   TTFACC_WORD, /*  caretOffset */
   TTFACC_WORD, /*  reserved2 */
   TTFACC_WORD, /*  reserved3 */
   TTFACC_WORD, /*  reserved4 */
   TTFACC_WORD, /*  reserved5 */
   TTFACC_WORD, /*  metricDataFormat */
   TTFACC_WORD  /* numLongMetrics */

   }; /*  XHEA */


#define LONGXMETRIC_CONTROL_COUNT 2
uint8 LONGXMETRIC_CONTROL[LONGXMETRIC_CONTROL_COUNT+1] =
   {
   LONGXMETRIC_CONTROL_COUNT,
   TTFACC_WORD, /* advanceWidth */
   TTFACC_WORD  /*  lsb */
   }; /*  LONGXMETRIC */

#define XSB_CONTROL_COUNT 1
uint8 XSB_CONTROL[XSB_CONTROL_COUNT+1] = 
	{
	XSB_CONTROL_COUNT,
 	TTFACC_WORD
	};

#define TSB_CONTROL_COUNT 1
uint8 TSB_CONTROL[TSB_CONTROL_COUNT+1] = 
	{
	TSB_CONTROL_COUNT,
 	TTFACC_WORD
	};

/* 'LTSH' linear threshold table */

#define LTSH_CONTROL_COUNT 2
uint8 LTSH_CONTROL[LTSH_CONTROL_COUNT+1] =
   {
   LTSH_CONTROL_COUNT,
   TTFACC_WORD, /*      version */
   TTFACC_WORD /*      numGlyphs */
   }; /*  LTSH */

/* 'maxp' maximum profile table */

#define MAXP_CONTROL_COUNT 15
uint8 MAXP_CONTROL[MAXP_CONTROL_COUNT+1] =
   {
   MAXP_CONTROL_COUNT,
   TTFACC_LONG, /*   version */
   TTFACC_WORD, /*  numGlyphs */
   TTFACC_WORD, /*  maxPoints */
   TTFACC_WORD, /*  maxContours */
   TTFACC_WORD, /*  maxCompositePoints */
   TTFACC_WORD, /*  maxCompositeContours */
   TTFACC_WORD, /*  maxElements */
   TTFACC_WORD, /*  maxTwilightPoints */
   TTFACC_WORD, /*  maxStorage */
   TTFACC_WORD, /*  maxFunctionDefs */
   TTFACC_WORD, /*  maxInstructionDefs */
   TTFACC_WORD, /*  maxStackElements */
   TTFACC_WORD, /*  maxSizeOfInstructions */
   TTFACC_WORD, /*  maxComponentElements */
   TTFACC_WORD  /*  maxComponentDepth */
   }; /*  MAXP */


#define NAME_RECORD_CONTROL_COUNT 6
uint8 NAME_RECORD_CONTROL[NAME_RECORD_CONTROL_COUNT+1] =
   {
   NAME_RECORD_CONTROL_COUNT,
   TTFACC_WORD, /*  platformID */
   TTFACC_WORD, /*  encodingID */
   TTFACC_WORD, /*  languageID */
   TTFACC_WORD, /*  nameID */
   TTFACC_WORD, /*  stringLength */
   TTFACC_WORD  /*  stringOffset */
   }; /*  NAME_RECORD */

#define NAME_HEADER_CONTROL_COUNT 3
uint8 	NAME_HEADER_CONTROL[NAME_HEADER_CONTROL_COUNT+1] =
   {
   NAME_HEADER_CONTROL_COUNT,
   TTFACC_WORD, /*       formatSelector */
   TTFACC_WORD, /*       numNameRecords */
   TTFACC_WORD  /*       offsetToStringStorage */   /* from start of table */
   }; /*  NAME_HEADER */


/* 'hdmx' horizontal device metrix table */
          
#define HDMX_DEVICE_REC_CONTROL_COUNT 2
uint8 	HDMX_DEVICE_REC_CONTROL[HDMX_DEVICE_REC_CONTROL_COUNT+1] = 
   {
   HDMX_DEVICE_REC_CONTROL_COUNT,
   TTFACC_BYTE, /*  pixelSize */
   TTFACC_BYTE  /*  maxWidth */
   }; /*  HDMX_DEVICE_REC */

#define HDMX_CONTROL_COUNT 3
uint8  HDMX_CONTROL[HDMX_CONTROL_COUNT+1] = 
   {
   HDMX_CONTROL_COUNT,
   TTFACC_WORD, /*         formatVersion */
   TTFACC_WORD, /*		  numDeviceRecords */
   TTFACC_LONG  /*           sizeDeviceRecord */
   }; /*  HDMX */

/* 'VDMX' Vertical Device Metrics Table */
#define VDMXVTABLE_CONTROL_COUNT 4
uint8 VDMXVTABLE_CONTROL[VDMXVTABLE_CONTROL_COUNT+1] =
{
	VDMXVTABLE_CONTROL_COUNT,
	TTFACC_WORD,  /* yPelHeight */
	TTFACC_WORD,  /* yMax */
	TTFACC_WORD,	  /* yMin */
    TTFACC_WORD|TTFACC_PAD /* PadForRISC */  /* lcp for platform independence */
}; /* VDMXvTable */

#define VDMXGROUP_CONTROL_COUNT 3 
uint8 VDMXGROUP_CONTROL[VDMXGROUP_CONTROL_COUNT+1] = 
{
	VDMXGROUP_CONTROL_COUNT,
	TTFACC_WORD,  /* recs */
	TTFACC_BYTE,  /* startSize */
	TTFACC_BYTE	  /* endSize */
};  /* VDMXGroup */

#define VDMXRATIO_CONTROL_COUNT 4 
uint8 VDMXRATIO_CONTROL[VDMXRATIO_CONTROL_COUNT+1] = 
{
	VDMXRATIO_CONTROL_COUNT,
	TTFACC_BYTE,  /* bCharSet */
	TTFACC_BYTE,	  /* xRatio */
	TTFACC_BYTE,  /* yStartRatio */
	TTFACC_BYTE	  /* yEndRatio */
};  /* VDMXRatio */

#define VDMX_CONTROL_COUNT 3
uint8 VDMX_CONTROL[VDMX_CONTROL_COUNT+1] = 
{
	VDMX_CONTROL_COUNT,
	TTFACC_WORD,  /* version */
	TTFACC_WORD,  /* numRecs */
	TTFACC_WORD   /* numRatios */
}; /* VDMX */

/* 'dttf' delta ttf table */
#define DTTF_HEADER_CONTROL_COUNT 7
uint8 DTTF_HEADER_CONTROL[DTTF_HEADER_CONTROL_COUNT+1] = 
{
	DTTF_HEADER_CONTROL_COUNT,
	TTFACC_LONG,		/* version */
	TTFACC_LONG,		/* checkSum */
	TTFACC_WORD,		/* OriginalNumGlyphs */
	TTFACC_WORD,		/* maxGlyphIndexUsed */
	TTFACC_WORD,		/* format */
	TTFACC_WORD,		/* fflags */
	TTFACC_WORD		/* glyphCount */
/*  USHORT GlyphIndexArray[glyphCount] */
};
/* end 'dttf' delta ttf table */

/* 'kern' kerning table */

#define KERN_HEADER_CONTROL_COUNT 2
uint8 KERN_HEADER_CONTROL[KERN_HEADER_CONTROL_COUNT+1] =
   {
   KERN_HEADER_CONTROL_COUNT,
   TTFACC_WORD, /* format */
   TTFACC_WORD  /* nTables */
   }; /*  KERN_HEADER */

#define KERN_SUB_HEADER_CONTROL_COUNT 4
uint8 KERN_SUB_HEADER_CONTROL[KERN_SUB_HEADER_CONTROL_COUNT+1] = 
   {
   KERN_SUB_HEADER_CONTROL_COUNT,
   TTFACC_WORD, /* format */
   TTFACC_WORD, /* length */
   TTFACC_WORD, /* coverage */
   TTFACC_WORD|TTFACC_PAD /* PadForRISC */  /* lcp for platform independence */
  }; /*  KERN_SUB_HEADER */

#define  KERN_FORMAT_0_CONTROL_COUNT 4
uint8 KERN_FORMAT_0_CONTROL[KERN_FORMAT_0_CONTROL_COUNT+1] =
   {
   KERN_FORMAT_0_CONTROL_COUNT,
   TTFACC_WORD, /*  nPairs */
   TTFACC_WORD, /*  searchRange */
   TTFACC_WORD, /*  entrySelector */
   TTFACC_WORD  /*  rangeShift */
   }; /*  KERN_FORMAT_0 */

#define KERN_PAIR_CONTROL_COUNT 4
uint8 KERN_PAIR_CONTROL[KERN_PAIR_CONTROL_COUNT+1] =
   {
   KERN_PAIR_CONTROL_COUNT,
   TTFACC_WORD, /*  left */
   TTFACC_WORD, /*  right */
   TTFACC_WORD,  /*  value */
   TTFACC_WORD|TTFACC_PAD /* PadForRISC */  /* lcp for platform independence */
  }; /*  KERN_PAIR */

#define SEARCH_PAIRS_CONTROL_COUNT 3
uint8 SEARCH_PAIRS_CONTROL[SEARCH_PAIRS_CONTROL_COUNT+1] =
   {
   SEARCH_PAIRS_CONTROL_COUNT,
   TTFACC_LONG, /* leftAndRight */
   TTFACC_WORD,  /*value */
   TTFACC_WORD|TTFACC_PAD /* PadForRISC */  /* lcp for platform independence */
   }; /*  SEARCH_PAIRS */


/* 'OS/2' OS/2 and Windows metrics table */

#define OS2_PANOSE_CONTROL_COUNT 10
uint8 OS2_PANOSE_CONTROL[OS2_PANOSE_CONTROL_COUNT+1] =
   {
	OS2_PANOSE_CONTROL_COUNT,
	TTFACC_BYTE, /*  bFamilyType */
	TTFACC_BYTE, /*  bSerifStyle */
	TTFACC_BYTE, /*  bWeight */
	TTFACC_BYTE, /*  bProportion */
	TTFACC_BYTE, /*  bContrast */
	TTFACC_BYTE, /*  bStrokeVariation */
	TTFACC_BYTE, /*  bArmStyle */
	TTFACC_BYTE, /*  bLetterform */
	TTFACC_BYTE, /*  bMidline */
	TTFACC_BYTE  /*  bXHeight */
   }; /*  OS2_PANOSE */

#define OS2_CONTROL_COUNT 43
uint8 OS2_CONTROL[OS2_CONTROL_COUNT+1] =
   {
   OS2_CONTROL_COUNT, 
   TTFACC_WORD, /*      usVersion */
   TTFACC_WORD, /*       xAvgCharWidth */
   TTFACC_WORD, /*      usWeightClass */
   TTFACC_WORD, /*      usWidthClass */
   TTFACC_WORD, /*       fsTypeFlags */
   TTFACC_WORD, /*       ySubscriptXSize */
   TTFACC_WORD, /*       ySubscriptYSize */
   TTFACC_WORD, /*       ySubscriptXOffset */
   TTFACC_WORD, /*       ySubscriptYOffset */
   TTFACC_WORD, /*       ySuperscriptXSize */
   TTFACC_WORD, /*       ySuperscriptYSize */
   TTFACC_WORD, /*       ySuperscriptXOffset */
   TTFACC_WORD, /*       ySuperscriptYOffset */
   TTFACC_WORD, /*       yStrikeoutSize */
   TTFACC_WORD, /*       yStrikeoutPosition */
   TTFACC_WORD, /*       sFamilyClass */
      TTFACC_BYTE, /*  bFamilyType */
      TTFACC_BYTE, /*  bSerifStyle */
      TTFACC_BYTE, /*  bWeight */
      TTFACC_BYTE, /*  bProportion */
      TTFACC_BYTE, /*  bContrast */
      TTFACC_BYTE, /*  bStrokeVariation */
      TTFACC_BYTE, /*  bArmStyle */
      TTFACC_BYTE, /*  bLetterform */
      TTFACC_BYTE, /*  bMidline */
      TTFACC_BYTE, /*  bXHeight */
   TTFACC_WORD|TTFACC_PAD, /*	   PadForRISC */  /* lcp for platform independence */
   TTFACC_LONG, /*       ulCharRange[0] */
   TTFACC_LONG, /*       ulCharRange[1] */
   TTFACC_LONG, /*       ulCharRange[2] */
   TTFACC_LONG, /*       ulCharRange[3] */
   TTFACC_BYTE, /*        achVendID[0] */
   TTFACC_BYTE, /*        achVendID[1] */
   TTFACC_BYTE, /*        achVendID[2] */
   TTFACC_BYTE, /*        achVendID[3] */
   TTFACC_WORD, /*      fsSelection */
   TTFACC_WORD, /*      usFirstCharIndex */
   TTFACC_WORD, /*      usLastCharIndex */
   TTFACC_WORD, /*       sTypoAscender */
   TTFACC_WORD, /*       sTypoDescender */
   TTFACC_WORD, /*       sTypoLineGap */
   TTFACC_WORD, /*      usWinAscent */
   TTFACC_WORD  /*      usWinDescent */
   }; /*  OS2 */

#define NEWOS2_CONTROL_COUNT 45
uint8 NEWOS2_CONTROL[NEWOS2_CONTROL_COUNT+1] =
   { 
   NEWOS2_CONTROL_COUNT,
   TTFACC_WORD, /*      usVersion */
   TTFACC_WORD, /*       xAvgCharWidth */
   TTFACC_WORD, /*      usWeightClass */
   TTFACC_WORD, /*      usWidthClass */
   TTFACC_WORD, /*       fsTypeFlags */
   TTFACC_WORD, /*       ySubscriptXSize */
   TTFACC_WORD, /*       ySubscriptYSize */
   TTFACC_WORD, /*       ySubscriptXOffset */
   TTFACC_WORD, /*       ySubscriptYOffset */
   TTFACC_WORD, /*       ySuperscriptXSize */
   TTFACC_WORD, /*       ySuperscriptYSize */
   TTFACC_WORD, /*       ySuperscriptXOffset */
   TTFACC_WORD, /*       ySuperscriptYOffset */
   TTFACC_WORD, /*       yStrikeoutSize */
   TTFACC_WORD, /*       yStrikeoutPosition */
   TTFACC_WORD, /*       sFamilyClass */
      TTFACC_BYTE, /*  bFamilyType */
      TTFACC_BYTE, /*  bSerifStyle */
      TTFACC_BYTE, /*  bWeight */
      TTFACC_BYTE, /*  bProportion */
      TTFACC_BYTE, /*  bContrast */
      TTFACC_BYTE, /*  bStrokeVariation */
      TTFACC_BYTE, /*  bArmStyle */
      TTFACC_BYTE, /*  bLetterform */
      TTFACC_BYTE, /*  bMidline */
      TTFACC_BYTE, /*  bXHeight */
   TTFACC_WORD|TTFACC_PAD, /*	   PadForRISC */  /* lcp for platform independence */
   TTFACC_LONG, /*	   ulUnicodeRange1 */
   TTFACC_LONG, /*	   ulUnicodeRange2 */
   TTFACC_LONG, /*	   ulUnicodeRange3 */
   TTFACC_LONG, /*	   ulUnicodeRange4 */
   TTFACC_BYTE, /*        achVendID[0] */
   TTFACC_BYTE, /*        achVendID[1] */
   TTFACC_BYTE, /*        achVendID[2] */
   TTFACC_BYTE, /*        achVendID[3] */
   TTFACC_WORD, /*      fsSelection */
   TTFACC_WORD, /*      usFirstCharIndex */
   TTFACC_WORD, /*      usLastCharIndex */
   TTFACC_WORD, /*       sTypoAscender */
   TTFACC_WORD, /*       sTypoDescender */
   TTFACC_WORD, /*       sTypoLineGap */
   TTFACC_WORD, /*      usWinAscent */
   TTFACC_WORD, /*	   usWinDescent */
   TTFACC_LONG, /*	   ulCodePageRange1 */
   TTFACC_LONG  /*	   ulCodePageRange2 */
   }; /*  NEWOS2 */

#define VERSION2OS2_CONTROL_COUNT 50
uint8 VERSION2OS2_CONTROL[VERSION2OS2_CONTROL_COUNT+1] =
   { 
   VERSION2OS2_CONTROL_COUNT,
   TTFACC_WORD, /*      usVersion */
   TTFACC_WORD, /*       xAvgCharWidth */
   TTFACC_WORD, /*      usWeightClass */
   TTFACC_WORD, /*      usWidthClass */
   TTFACC_WORD, /*       fsTypeFlags */
   TTFACC_WORD, /*       ySubscriptXSize */
   TTFACC_WORD, /*       ySubscriptYSize */
   TTFACC_WORD, /*       ySubscriptXOffset */
   TTFACC_WORD, /*       ySubscriptYOffset */
   TTFACC_WORD, /*       ySuperscriptXSize */
   TTFACC_WORD, /*       ySuperscriptYSize */
   TTFACC_WORD, /*       ySuperscriptXOffset */
   TTFACC_WORD, /*       ySuperscriptYOffset */
   TTFACC_WORD, /*       yStrikeoutSize */
   TTFACC_WORD, /*       yStrikeoutPosition */
   TTFACC_WORD, /*       sFamilyClass */
      TTFACC_BYTE, /*  bFamilyType */
      TTFACC_BYTE, /*  bSerifStyle */
      TTFACC_BYTE, /*  bWeight */
      TTFACC_BYTE, /*  bProportion */
      TTFACC_BYTE, /*  bContrast */
      TTFACC_BYTE, /*  bStrokeVariation */
      TTFACC_BYTE, /*  bArmStyle */
      TTFACC_BYTE, /*  bLetterform */
      TTFACC_BYTE, /*  bMidline */
      TTFACC_BYTE, /*  bXHeight */
   TTFACC_WORD|TTFACC_PAD, /*	   PadForRISC */  /* lcp for platform independence */
   TTFACC_LONG, /*	   ulUnicodeRange1 */
   TTFACC_LONG, /*	   ulUnicodeRange2 */
   TTFACC_LONG, /*	   ulUnicodeRange3 */
   TTFACC_LONG, /*	   ulUnicodeRange4 */
   TTFACC_BYTE, /*        achVendID[0] */
   TTFACC_BYTE, /*        achVendID[1] */
   TTFACC_BYTE, /*        achVendID[2] */
   TTFACC_BYTE, /*        achVendID[3] */
   TTFACC_WORD, /*      fsSelection */
   TTFACC_WORD, /*      usFirstCharIndex */
   TTFACC_WORD, /*      usLastCharIndex */
   TTFACC_WORD, /*       sTypoAscender */
   TTFACC_WORD, /*       sTypoDescender */
   TTFACC_WORD, /*       sTypoLineGap */
   TTFACC_WORD, /*      usWinAscent */
   TTFACC_WORD, /*	   usWinDescent */
   TTFACC_LONG, /*	   ulCodePageRange1 */
   TTFACC_LONG,  /*	   ulCodePageRange2 */
   TTFACC_WORD, /*	   sXHeight */
   TTFACC_WORD, /*	   sCapHeight */
   TTFACC_WORD, /*	   usDefaultChar */
   TTFACC_WORD, /*	   usBreakChar */
   TTFACC_WORD  /*	   usMaxLookups */   
   }; /*  VERSION2OS2 */


/*  EBLC, EBDT and EBSC file constants    */

/*	This first EBLC is common to both EBLC and EBSC tables */

#define EBLCHEADER_CONTROL_COUNT 2
uint8 	EBLCHEADER_CONTROL[EBLCHEADER_CONTROL_COUNT+1] =
   {
   EBLCHEADER_CONTROL_COUNT,
   TTFACC_LONG, /*		fxVersion */
   TTFACC_LONG  /*		ulNumSizes */
   }; /*  EBLCHEADER */

#define SBITLINEMETRICS_CONTROL_COUNT 12
uint8 	SBITLINEMETRICS_CONTROL[SBITLINEMETRICS_CONTROL_COUNT+1] =
{
	SBITLINEMETRICS_CONTROL_COUNT,
	TTFACC_BYTE, /*		cAscender */
	TTFACC_BYTE, /*		cDescender */
	TTFACC_BYTE, /*		byWidthMax */
	TTFACC_BYTE, /*		cCaretSlopeNumerator */
	TTFACC_BYTE, /*		cCaretSlopeDenominator */
	TTFACC_BYTE, /*		cCaretOffset */
	TTFACC_BYTE, /*		cMinOriginSB */
	TTFACC_BYTE, /*		cMinAdvanceSB */
	TTFACC_BYTE, /*		cMaxBeforeBL */
	TTFACC_BYTE, /*		cMinAfterBL */
	TTFACC_BYTE, /*		cPad1 */
	TTFACC_BYTE  /*		cPad2 */
}; /*  SBITLINEMETRICS */

#ifdef TESTPORT
#define BITMAPSIZETABLE_CONTROL_COUNT 36
#else
#define BITMAPSIZETABLE_CONTROL_COUNT 34
#endif
uint8 BITMAPSIZETABLE_CONTROL[BITMAPSIZETABLE_CONTROL_COUNT+1] =
{
	BITMAPSIZETABLE_CONTROL_COUNT,
	TTFACC_LONG, /*		ulIndexSubTableArrayOffset */
	TTFACC_LONG, /*		ulIndexTablesSize */
#ifdef TESTPORT
	TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD, /*		pad2;	*/
#endif
	TTFACC_LONG, /*		ulNumberOfIndexSubTables */
	TTFACC_LONG, /*		ulColorRef */
	/* SBITLINEMETRICS hori */
	TTFACC_BYTE, /*		cAscender */
	TTFACC_BYTE, /*		cDescender */
	TTFACC_BYTE, /*		byWidthMax */
	TTFACC_BYTE, /*		cCaretSlopeNumerator */
	TTFACC_BYTE, /*		cCaretSlopeDenominator */
	TTFACC_BYTE, /*		cCaretOffset */
	TTFACC_BYTE, /*		cMinOriginSB */
	TTFACC_BYTE, /*		cMinAdvanceSB */
	TTFACC_BYTE, /*		cMaxBeforeBL */
	TTFACC_BYTE, /*		cMinAfterBL */
	TTFACC_BYTE, /*		cPad1 */
	TTFACC_BYTE,  /*		cPad2 */
	/* SBITLINEMETRICS vert */
	TTFACC_BYTE, /*		cAscender */
	TTFACC_BYTE, /*		cDescender */
	TTFACC_BYTE, /*		byWidthMax */
	TTFACC_BYTE, /*		cCaretSlopeNumerator */
	TTFACC_BYTE, /*		cCaretSlopeDenominator */
	TTFACC_BYTE, /*		cCaretOffset */
	TTFACC_BYTE, /*		cMinOriginSB */
	TTFACC_BYTE, /*		cMinAdvanceSB */
	TTFACC_BYTE, /*		cMaxBeforeBL */
	TTFACC_BYTE, /*		cMinAfterBL */
	TTFACC_BYTE, /*		cPad1 */
	TTFACC_BYTE,  /*		cPad2 */
	TTFACC_WORD, /*		usStartGlyphIndex */
	TTFACC_WORD, /*		usEndGlyphIndex */
	TTFACC_BYTE, /*		byPpemX */
	TTFACC_BYTE, /*		byPpemY */
	TTFACC_BYTE, /*		byBitDepth */
	TTFACC_BYTE  /*		fFlags */
}; /*  BITMAPSIZETABLE */

#define BIGGLYPHMETRICS_CONTROL_COUNT 8
uint8 BIGGLYPHMETRICS_CONTROL[BIGGLYPHMETRICS_CONTROL_COUNT+1] =
{
	BIGGLYPHMETRICS_CONTROL_COUNT,
	TTFACC_BYTE, /*		byHeight */
	TTFACC_BYTE, /*		byWidth */
	TTFACC_BYTE, /*		cHoriBearingX */
	TTFACC_BYTE, /*		cHoriBearingY */
	TTFACC_BYTE, /*		byHoriAdvance */
	TTFACC_BYTE, /*		cVertBearingX */
	TTFACC_BYTE, /*		cVertBearingY */
	TTFACC_BYTE  /*		byVertAdvance */
}; /*  BIGGLYPHMETRICS */

#define SMALLGLYPHMETRICS_CONTROL_COUNT 5
uint8 SMALLGLYPHMETRICS_CONTROL[SMALLGLYPHMETRICS_CONTROL_COUNT+1] =
{
	SMALLGLYPHMETRICS_CONTROL_COUNT,
	TTFACC_BYTE, /*		byHeight */
	TTFACC_BYTE, /*		byWidth */
	TTFACC_BYTE, /*		cBearingX */
	TTFACC_BYTE, /*		cBearingY */
	TTFACC_BYTE  /*		byAdvance */
}; /*  SMALLGLYPHMETRICS */

#ifdef TESTPORT
#define INDEXSUBTABLEARRAY_CONTROL_COUNT 5
#else
#define INDEXSUBTABLEARRAY_CONTROL_COUNT 3
#endif
uint8 INDEXSUBTABLEARRAY_CONTROL[INDEXSUBTABLEARRAY_CONTROL_COUNT+1] =
{
	INDEXSUBTABLEARRAY_CONTROL_COUNT,
	TTFACC_WORD, /*		usFirstGlyphIndex */
	TTFACC_WORD, /*		usLastGlyphIndex */
#ifdef TESTPORT
	TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD, /*		pad2;	*/
#endif
	TTFACC_LONG  /*		ulAdditionalOffsetToIndexSubtable */
}; /*  INDEXSUBTABLEARRAY */

#ifdef TESTPORT
#define INDEXSUBHEADER_CONTROL_COUNT 5
#else
#define INDEXSUBHEADER_CONTROL_COUNT 3
#endif
uint8 INDEXSUBHEADER_CONTROL[INDEXSUBHEADER_CONTROL_COUNT+1] =
{
	INDEXSUBHEADER_CONTROL_COUNT,
	TTFACC_WORD, /*		usIndexFormat */
	TTFACC_WORD, /*		usImageFormat */
#ifdef TESTPORT
	TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD, /*		pad2;	*/
#endif
	TTFACC_LONG  /*		ulImageDataOffset */
}; /*  INDEXSUBHEADER */

#ifdef TESTPORT
#define INDEXSUBTABLE1_CONTROL_COUNT 7
#else
#define INDEXSUBTABLE1_CONTROL_COUNT 3
#endif
uint8 INDEXSUBTABLE1_CONTROL[INDEXSUBTABLE1_CONTROL_COUNT+1] =
{
	INDEXSUBTABLE1_CONTROL_COUNT,
	/* INDEXSUBHEADER	header */
		TTFACC_WORD, /*		usIndexFormat */
		TTFACC_WORD, /*		usImageFormat */
#ifdef TESTPORT
	TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD, /*		pad2;	*/
#endif
		TTFACC_LONG,  /*		ulImageDataOffset */
#ifdef TESTPORT
	TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD, /*		pad2;	*/
#endif
	/* TTFACC_LONG  			aulOffsetArray[1] */
}; /*  INDEXSUBTABLE1 */

#ifdef TESTPORT
#define INDEXSUBTABLE2_CONTROL_COUNT 16
#else
#define INDEXSUBTABLE2_CONTROL_COUNT 12
#endif
uint8 INDEXSUBTABLE2_CONTROL[INDEXSUBTABLE2_CONTROL_COUNT+1] =
{
	INDEXSUBTABLE2_CONTROL_COUNT,
	/* INDEXSUBHEADER	header */
		TTFACC_WORD, /*		usIndexFormat */
		TTFACC_WORD, /*		usImageFormat */
#ifdef TESTPORT
	TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD, /*		pad2;	*/
#endif
		TTFACC_LONG,  /*		ulImageDataOffset */
#ifdef TESTPORT
	TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD, /*		pad2;	*/
#endif
	TTFACC_LONG, /*			ulImageSize */
	/* BIGGLYPHMETRICS bigMetrics */
		TTFACC_BYTE, /*		byHeight */
		TTFACC_BYTE, /*		byWidth */
		TTFACC_BYTE, /*		cHoriBearingX */
		TTFACC_BYTE, /*		cHoriBearingY */
		TTFACC_BYTE, /*		byHoriAdvance */
		TTFACC_BYTE, /*		cVertBearingX */
		TTFACC_BYTE, /*		cVertBearingY */
		TTFACC_BYTE  /*		byVertAdvance */
}; /*  INDEXSUBTABLE2 */

#ifdef TESTPORT
#define INDEXSUBTABLE3_CONTROL_COUNT 7
#else
#define INDEXSUBTABLE3_CONTROL_COUNT 3
#endif
uint8 INDEXSUBTABLE3_CONTROL[INDEXSUBTABLE3_CONTROL_COUNT+1] =
{
	INDEXSUBTABLE3_CONTROL_COUNT,
	/* INDEXSUBHEADER	header */
		TTFACC_WORD, /*		usIndexFormat */
		TTFACC_WORD, /*		usImageFormat */
#ifdef TESTPORT
	TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD, /*		pad2;	*/
#endif
		TTFACC_LONG  /*		ulImageDataOffset */
#ifdef TESTPORT
	, TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD /*		pad2;	*/
#endif
	/* TTFACC_WORD, 			ausOffsetArray[1] */
}; /*  INDEXSUBTABLE3 */

#ifdef TESTPORT
#define  CODEOFFSETPAIR_CONTROL_COUNT 4
#else
#define  CODEOFFSETPAIR_CONTROL_COUNT 2
#endif
uint8 CODEOFFSETPAIR_CONTROL[CODEOFFSETPAIR_CONTROL_COUNT+1] =
{	CODEOFFSETPAIR_CONTROL_COUNT,
#ifdef TESTPORT
	TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD, /*		pad2;	*/
#endif
	TTFACC_WORD, /*			usGlyphCode */
	TTFACC_WORD  /*			usOffset */
}; /*  CODEOFFSETPAIR */

#ifdef TESTPORT
#define INDEXSUBTABLE4_CONTROL_COUNT 8
#else
#define INDEXSUBTABLE4_CONTROL_COUNT 4
#endif
uint8 INDEXSUBTABLE4_CONTROL[INDEXSUBTABLE4_CONTROL_COUNT+1] =
{
	INDEXSUBTABLE4_CONTROL_COUNT,
	/* INDEXSUBHEADER	header */
		TTFACC_WORD, /*		usIndexFormat */
		TTFACC_WORD, /*		usImageFormat */
#ifdef TESTPORT
	TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD, /*		pad2;	*/
#endif
		TTFACC_LONG, /*		ulImageDataOffset */
	TTFACC_LONG  /*			ulNumGlyphs */
#ifdef TESTPORT
	, TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD /*		pad2;	*/
#endif
	/* CODEOFFSETPAIR	glyphArray[1] */
}; /*  INDEXSUBTABLE4 */

#ifdef TESTPORT
#define INDEXSUBTABLE5_CONTROL_COUNT 17
#else
#define INDEXSUBTABLE5_CONTROL_COUNT 13
#endif
uint8 INDEXSUBTABLE5_CONTROL[INDEXSUBTABLE5_CONTROL_COUNT+1] =
{
	INDEXSUBTABLE5_CONTROL_COUNT,
	/* INDEXSUBHEADER	header */
		TTFACC_WORD, /*		usIndexFormat */
		TTFACC_WORD, /*		usImageFormat */
#ifdef TESTPORT
	TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD, /*		pad2;	*/
#endif
		TTFACC_LONG,  /*		ulImageDataOffset */
#ifdef TESTPORT
	TTFACC_WORD|TTFACC_PAD, /*	pad1 to test portability */
	TTFACC_WORD|TTFACC_PAD, /*		pad2;	*/
#endif
	TTFACC_LONG, /*			ulImageSize */
	/* BIGGLYPHMETRICS bigMetrics */
		TTFACC_BYTE, /*		byHeight */
		TTFACC_BYTE, /*		byWidth */
		TTFACC_BYTE, /*		cHoriBearingX */
		TTFACC_BYTE, /*		cHoriBearingY */
		TTFACC_BYTE, /*		byHoriAdvance */
		TTFACC_BYTE, /*		cVertBearingX */
		TTFACC_BYTE, /*		cVertBearingY */
		TTFACC_BYTE, /*		byVertAdvance */
	TTFACC_LONG  /*			ulNumGlyphs */
	/* TTFACC_WORD,  			ausGlyphCodeArray[1] */
}; /*  INDEXSUBTABLE5 */

#define EBDTHEADER_CONTROL_COUNT 1
uint8 	EBDTHEADER_CONTROL[EBDTHEADER_CONTROL_COUNT+1] =
   {
   EBDTHEADER_CONTROL_COUNT,
   TTFACC_LONG /*		fxVersion */
   }; /*  EBDTHEADER */

#define EBDTHEADERNOXLATENOPAD_CONTROL_COUNT 1
uint8 	EBDTHEADERNOXLATENOPAD_CONTROL[EBDTHEADERNOXLATENOPAD_CONTROL_COUNT+1] =
{
   EBDTHEADERNOXLATENOPAD_CONTROL_COUNT,
   TTFACC_LONG|TTFACC_NO_XLATE /*		fxVersion */
}; /*  EBDTHEADER */

#define EBDTCOMPONENT_CONTROL_COUNT 3
uint8 EBDTCOMPONENT_CONTROL[EBDTCOMPONENT_CONTROL_COUNT+1] =
{
	EBDTCOMPONENT_CONTROL_COUNT,
	TTFACC_WORD, /* glyphCode */
	TTFACC_BYTE, /* xOffset */
	TTFACC_BYTE, /* yOffset */
}; /*  EBDTCOMPONENT */

#define EBDTFORMAT8SIZE_CONTROL_COUNT 7
uint8 EBDTFORMAT8SIZE_CONTROL[EBDTFORMAT8SIZE_CONTROL_COUNT+1] =
{
	EBDTFORMAT8SIZE_CONTROL_COUNT,
	/* SMALLGLYPHMETRICS smallMetrics */
		TTFACC_BYTE, /*		byHeight */
		TTFACC_BYTE, /*		byWidth */
		TTFACC_BYTE, /*		cBearingX */
		TTFACC_BYTE, /*		cBearingY */
		TTFACC_BYTE,  /*		byAdvance */
	TTFACC_BYTE, /* pad */
	TTFACC_WORD  /* 	numComponents */
/* 	EBDTCOMPONENT componentArray[1] */
}; /*  EBDTFORMAT8 */

#define  EBDTFORMAT9_CONTROL_COUNT 10
uint8 EBDTFORMAT9_CONTROL[EBDTFORMAT9_CONTROL_COUNT+1] =
{
	EBDTFORMAT9_CONTROL_COUNT,
	/* BIGGLYPHMETRICS bigMetrics */
		TTFACC_BYTE, /*		byHeight */
		TTFACC_BYTE, /*		byWidth */
		TTFACC_BYTE, /*		cHoriBearingX */
		TTFACC_BYTE, /*		cHoriBearingY */
		TTFACC_BYTE, /*		byHoriAdvance */
		TTFACC_BYTE, /*		cVertBearingX */
		TTFACC_BYTE, /*		cVertBearingY */
		TTFACC_BYTE, /*		byVertAdvance */
	TTFACC_WORD,  /* 	numComponents */
    TTFACC_WORD|TTFACC_PAD /*	   PadForRISC */  /* lcp for platform independence */
	/* EBDTCOMPONENT componentArray[1] */
}; /*  EBDTFORMAT9 */

/* TrueType Open GSUB Tables, needed for Auto Mapping of unmapped Glyphs. */
#define GSUBFEATURE_CONTROL_COUNT 3
uint8 GSUBFEATURE_CONTROL[GSUBFEATURE_CONTROL_COUNT+1] =
{
	GSUBFEATURE_CONTROL_COUNT,
	TTFACC_WORD, /* FeatureParamsOffset */  /* dummy, NULL */
	TTFACC_WORD, /* FeatureLookupCount */
	TTFACC_WORD  /* LookupListIndexArray[1] */
}; /*  GSUBFEATURE */

#define GSUBFEATURERECORD_CONTROL_COUNT 3
uint8 GSUBFEATURERECORD_CONTROL[GSUBFEATURERECORD_CONTROL_COUNT+1] =
{
	GSUBFEATURERECORD_CONTROL_COUNT,
	TTFACC_LONG, /* Tag */
	TTFACC_WORD,  /* FeatureOffset */
    TTFACC_WORD|TTFACC_PAD /*	   PadForRISC */  /* lcp for platform independence */
}; /*  GSUBFEATURERECORD */

#define   GSUBFEATURELIST_CONTROL_COUNT 2
uint8 	GSUBFEATURELIST_CONTROL[GSUBFEATURELIST_CONTROL_COUNT+1] =
{
    GSUBFEATURELIST_CONTROL_COUNT,
    TTFACC_WORD,  /* FeatureCount */
    TTFACC_WORD|TTFACC_PAD /*	   PadForRISC */  /* lcp for platform independence */
 /*   GSUBFEATURERECORD FeatureRecordArray[1] */ 
}; /*  GSUBFEATURELIST */

#define GSUBLOOKUP_CONTROL_COUNT 3
uint8 GSUBLOOKUP_CONTROL[GSUBLOOKUP_CONTROL_COUNT+1] =
{
	GSUBLOOKUP_CONTROL_COUNT,
	TTFACC_WORD, /*	LookupType */
	TTFACC_WORD, /* 	LookupFlag */
	TTFACC_WORD  /* 	SubTableCount */
	/* TTFACC_WORD   	SubstTableOffsetArray[1] */
}; /*  GSUBLOOKUP */

#define GSUBLOOKUPLIST_CONTROL_COUNT 1
uint8 GSUBLOOKUPLIST_CONTROL[GSUBLOOKUPLIST_CONTROL_COUNT+1] =
{
	GSUBLOOKUPLIST_CONTROL_COUNT,
	TTFACC_WORD  /*	LookupCount */
	/* TTFACC_WORD,   	LookupTableOffsetArray[1] */
}; /*  GSUBLOOKUPLIST */

#define GSUBCOVERAGEFORMAT1_CONTROL_COUNT 2
uint8 GSUBCOVERAGEFORMAT1_CONTROL[GSUBCOVERAGEFORMAT1_CONTROL_COUNT+1] =
{
	GSUBCOVERAGEFORMAT1_CONTROL_COUNT,
	TTFACC_WORD, /* Format */
	TTFACC_WORD  /* GlyphCount */
	/* TTFACC_WORD,  GlyphIDArray[1] */
}; /*  GSUBCOVERAGEFORMAT1 */

#define GSUBRANGERECORD_CONTROL_COUNT 4
uint8 GSUBRANGERECORD_CONTROL[GSUBRANGERECORD_CONTROL_COUNT+1] =
{
	GSUBRANGERECORD_CONTROL_COUNT,
	TTFACC_WORD, /* RangeStart */
	TTFACC_WORD, /* RangeEnd */
	TTFACC_WORD,  /* StartCoverageIndex */
    TTFACC_WORD|TTFACC_PAD /* PadForRISC */  /* lcp for platform independence */
}; /*  GSUBRANGERECORD */

#define GSUBCOVERAGEFORMAT2_CONTROL_COUNT 2
uint8 GSUBCOVERAGEFORMAT2_CONTROL[GSUBCOVERAGEFORMAT2_CONTROL_COUNT+1] =
{
	GSUBCOVERAGEFORMAT2_CONTROL_COUNT,
	TTFACC_WORD, /* Format */
	TTFACC_WORD  /* CoverageRangeCount */
	/* GSUBRANGERECORD RangeRecordArray[1] */
}; /*  GSUBCOVERAGEFORMAT2 */

#define GSUBHEADER_CONTROL_COUNT 4
uint8 GSUBHEADER_CONTROL[GSUBHEADER_CONTROL_COUNT+1] =
{
	GSUBHEADER_CONTROL_COUNT,
	TTFACC_LONG, /* Version */
	TTFACC_WORD, /* ScriptListOffset */
	TTFACC_WORD, /* FeatureListOffset */
	TTFACC_WORD  /* LookupListOffset */
}; /*  GSUBHEADER */

#define GSUBSINGLESUBSTFORMAT1_CONTROL_COUNT 3
uint8 GSUBSINGLESUBSTFORMAT1_CONTROL[GSUBSINGLESUBSTFORMAT1_CONTROL_COUNT+1] =
{
	GSUBSINGLESUBSTFORMAT1_CONTROL_COUNT,
	TTFACC_WORD, /* Format */
	TTFACC_WORD, /* CoverageOffset */
	TTFACC_WORD  /* DeltaGlyphID */
}; /*  GSUBSINGLESUBSTFORMAT1 */

#define GSUBSINGLESUBSTFORMAT2_CONTROL_COUNT 3
uint8 GSUBSINGLESUBSTFORMAT2_CONTROL[GSUBSINGLESUBSTFORMAT2_CONTROL_COUNT+1] =
{
	GSUBSINGLESUBSTFORMAT2_CONTROL_COUNT,
	TTFACC_WORD, /* Format */
	TTFACC_WORD, /* CoverageOffset */
	TTFACC_WORD  /* GlyphCount */ 
/* 	TTFACC_WORD, /* GlyphIDArray[1] */
}; /*  GSUBSINGLESUBSTFORMAT2 */

#define GSUBSEQUENCE_CONTROL_COUNT 1
uint8 GSUBSEQUENCE_CONTROL[GSUBSEQUENCE_CONTROL_COUNT+1] =
{ 
	GSUBSEQUENCE_CONTROL_COUNT,
	TTFACC_WORD , /* SequenceGlyphCount */
	/* TTFACC_WORD, /* GlyphIDArray[1] */
}; /*  GSUBSEQUENCE */

#define GSUBMULTIPLESUBSTFORMAT1_CONTROL_COUNT 3
uint8 GSUBMULTIPLESUBSTFORMAT1_CONTROL[GSUBMULTIPLESUBSTFORMAT1_CONTROL_COUNT+1] =
{
	GSUBMULTIPLESUBSTFORMAT1_CONTROL_COUNT,
	TTFACC_WORD, /* Format */
	TTFACC_WORD, /* CoverageOffset */
	TTFACC_WORD  /* SequenceCount */ 
	/* TTFACC_WORD, /* SequenceOffsetArray[1] */
}; /*  GSUBMULTIPLESUBSTFORMAT1 */	

#define GSUBALTERNATESET_CONTROL_COUNT 1
uint8 GSUBALTERNATESET_CONTROL[GSUBALTERNATESET_CONTROL_COUNT+1] =
{ 
	GSUBALTERNATESET_CONTROL_COUNT,
	TTFACC_WORD  /* GlyphCount */
	/* TTFACC_WORD, /* GlyphIDArray[1] */
}; /*  GSUBALTERNATESET */

#define GSUBALTERNATESUBSTFORMAT1_CONTROL_COUNT 3
uint8 GSUBALTERNATESUBSTFORMAT1_CONTROL[GSUBALTERNATESUBSTFORMAT1_CONTROL_COUNT+1] =
{
	GSUBALTERNATESUBSTFORMAT1_CONTROL_COUNT,
	TTFACC_WORD, /* Format */
	TTFACC_WORD, /* CoverageOffset */
	TTFACC_WORD  /* AlternateSetCount */ 
	/* TTFACC_WORD, /* AlternateSetOffsetArray[1] */
}; /*  GSUBALTERNATESUBSTFORMAT1 */

#define GSUBLIGATURE_CONTROL_COUNT 2
uint8 GSUBLIGATURE_CONTROL[GSUBLIGATURE_CONTROL_COUNT+1] =
{
	GSUBLIGATURE_CONTROL_COUNT,
	TTFACC_WORD, /* GlyphID */
	TTFACC_WORD  /* LigatureCompCount */
	/* TTFACC_WORD, /* GlyphIDArray[1] */
}; /*  GSUBLIGATURE */

#define GSUBLIGATURESET_CONTROL_COUNT 1
uint8 GSUBLIGATURESET_CONTROL[GSUBLIGATURESET_CONTROL_COUNT+1] =
{
	GSUBLIGATURESET_CONTROL_COUNT,
	TTFACC_WORD  /* LigatureCount */
	/* TTFACC_WORD, /* LigatureOffsetArray[1] */
}; /*  GSUBLIGATURESET */

#define GSUBLIGATURESUBSTFORMAT1_CONTROL_COUNT 3
uint8 GSUBLIGATURESUBSTFORMAT1_CONTROL[GSUBLIGATURESUBSTFORMAT1_CONTROL_COUNT+1] =
{
	GSUBLIGATURESUBSTFORMAT1_CONTROL_COUNT,
	TTFACC_WORD, /* Format */
	TTFACC_WORD, /* CoverageOffset */
	TTFACC_WORD  /* LigatureSetCount */
	/* TTFACC_WORD, /* LigatureSetOffsetArray[1] */
}; /*  GSUBLIGATURESUBSTFORMAT1 */

#define GSUBSUBSTLOOKUPRECORD_CONTROL_COUNT 2
uint8 GSUBSUBSTLOOKUPRECORD_CONTROL[GSUBSUBSTLOOKUPRECORD_CONTROL_COUNT+1] =
{
	GSUBSUBSTLOOKUPRECORD_CONTROL_COUNT,
	TTFACC_WORD, /* SequenceIndex */
	TTFACC_WORD  /* LookupListIndex */
}; /*  GSUBSUBSTLOOKUPRECORD */

#define GSUBSUBRULE_CONTROL_COUNT 2
uint8 GSUBSUBRULE_CONTROL[GSUBSUBRULE_CONTROL_COUNT+1] =
{
	GSUBSUBRULE_CONTROL_COUNT,
	TTFACC_WORD, /* SubRuleGlyphCount */
	TTFACC_WORD  /* SubRuleSubstCount */
	/* TTFACC_WORD, /* GlyphIDArray[1] */
/* TTFACC_WORD, /* SubstLookupRecordArray[1] */  /* can't put this here - in code */
}; /*  GSUBSUBRULE */

#define GSUBSUBRULESET_CONTROL_COUNT 1
uint8 GSUBSUBRULESET_CONTROL[GSUBSUBRULESET_CONTROL_COUNT+1] =
{
	GSUBSUBRULESET_CONTROL_COUNT,
	TTFACC_WORD  /* SubRuleCount */
	/* TTFACC_WORD, /* SubRuleOffsetArray[1] */
}; /*  GSUBSUBRULESET */

#define GSUBCONTEXTSUBSTFORMAT1_CONTROL_COUNT 3 
uint8 GSUBCONTEXTSUBSTFORMAT1_CONTROL[GSUBCONTEXTSUBSTFORMAT1_CONTROL_COUNT+1] =
{
	GSUBCONTEXTSUBSTFORMAT1_CONTROL_COUNT,
	TTFACC_WORD, /* Format */
	TTFACC_WORD, /* CoverageOffset */
	TTFACC_WORD  /* SubRuleSetCount */
	/* TTFACC_WORD, /* SubRuleSetOffsetArray[1] */
}; /*  GSUBCONTEXTSUBSTFORMAT1 */

#define GSUBSUBCLASSRULE_CONTROL_COUNT 2
uint8 GSUBSUBCLASSRULE_CONTROL[GSUBSUBCLASSRULE_CONTROL_COUNT+1] =
{
	GSUBSUBCLASSRULE_CONTROL_COUNT,
	TTFACC_WORD, /* SubClassRuleGlyphCount */
	TTFACC_WORD  /* SubClassRuleSubstCount */
	/* TTFACC_WORD, /* ClassArray[1] */
/* TTFACC_WORD, /* SubstLookupRecordArray[1] */  /* can't put this here - in code */
}; /*  GSUBSUBCLASSRULE */

#define  GSUBSUBCLASSSET_CONTROL_COUNT 1
uint8 GSUBSUBCLASSSET_CONTROL[GSUBSUBCLASSSET_CONTROL_COUNT+1] =
{
	GSUBSUBCLASSSET_CONTROL_COUNT,
	TTFACC_WORD  /* SubClassRuleCount */
	/* TTFACC_WORD, /* SubClassRuleOffsetArray[1] */
}; /*  GSUBSUBCLASSSET */

#define GSUBCONTEXTSUBSTFORMAT2_CONTROL_COUNT 4
uint8 GSUBCONTEXTSUBSTFORMAT2_CONTROL[GSUBCONTEXTSUBSTFORMAT2_CONTROL_COUNT+1] =
{
	GSUBCONTEXTSUBSTFORMAT2_CONTROL_COUNT,
	TTFACC_WORD, /* Format */
	TTFACC_WORD, /* CoverageOffset */
	TTFACC_WORD, /* ClassDefOffset */
	TTFACC_WORD  /* SubClassSetCount */
	/* TTFACC_WORD, /* SubClassSetOffsetArray[1] */
}; /*  GSUBCONTEXTSUBSTFORMAT2 */

#define  GSUBCONTEXTSUBSTFORMAT3_CONTROL_COUNT 3
uint8 GSUBCONTEXTSUBSTFORMAT3_CONTROL[GSUBCONTEXTSUBSTFORMAT3_CONTROL_COUNT+1] =
{
	GSUBCONTEXTSUBSTFORMAT3_CONTROL_COUNT,
	TTFACC_WORD, /* Format */
	TTFACC_WORD, /* GlyphCount */
	TTFACC_WORD  /* SubstCount */
/*	TTFACC_WORD, /* CoverageOffsetArray[1] */
/* TTFACC_WORD, /* SubstLookupRecordArray[1] */
}; /*  GSUBCONTEXTSUBSTFORMAT3 */

/* just enough jstf info to get the Automap working for jstf */
#define JSTFSCRIPTRECORD_CONTROL_COUNT 3
uint8 JSTFSCRIPTRECORD_CONTROL[JSTFSCRIPTRECORD_CONTROL_COUNT+1] =
{
	JSTFSCRIPTRECORD_CONTROL_COUNT,
	TTFACC_LONG, /* Tag */
	TTFACC_WORD,  /* JstfScriptOffset */
    TTFACC_WORD|TTFACC_PAD /*	   PadForRISC */  /* lcp for platform independence */
}; /*  JSTFSCRIPTRECORD */

#define JSTFHEADER_CONTROL_COUNT 3
uint8 JSTFHEADER_CONTROL[JSTFHEADER_CONTROL_COUNT+1] =
{
	JSTFHEADER_CONTROL_COUNT,
	TTFACC_LONG, /* Version */
	TTFACC_WORD,  /* ScriptCount */
    TTFACC_WORD|TTFACC_PAD /*	   PadForRISC */  /* lcp for platform independence */
	/* JSTFSCRIPTRECORD ScriptRecordArray[1] */
}; /*  JSTFHEADER */

#define JSTFLANGSYSRECORD_CONTROL_COUNT 3
uint8 JSTFLANGSYSRECORD_CONTROL[JSTFLANGSYSRECORD_CONTROL_COUNT+1] =
{
	JSTFLANGSYSRECORD_CONTROL_COUNT,
	TTFACC_LONG, /* Tag */
	TTFACC_WORD,  /* LangSysOffset */
    TTFACC_WORD|TTFACC_PAD /*	   PadForRISC */  /* lcp for platform independence */
}; /*  JSTFLANGSYSRECORD */

#define JSTFSCRIPT_CONTROL_COUNT 4
uint8 JSTFSCRIPT_CONTROL[JSTFSCRIPT_CONTROL_COUNT+1] =
{
	JSTFSCRIPT_CONTROL_COUNT,
	TTFACC_WORD, /* ExtenderGlyphOffset */
	TTFACC_WORD, /* LangSysOffset */
	TTFACC_WORD,  /* LangSysCount */
    TTFACC_WORD|TTFACC_PAD /*	   PadForRISC */  /* lcp for platform independence */
/* JSTFLANGSYSRECORD LangSysRecordArray[1] */
}; /*  JSTFSCRIPT */

#define JSTFEXTENDERGLYPH_CONTROL_COUNT 1
uint8 JSTFEXTENDERGLYPH_CONTROL[JSTFEXTENDERGLYPH_CONTROL_COUNT+1] =
{
	JSTFEXTENDERGLYPH_CONTROL_COUNT,
	TTFACC_WORD  /* ExtenderGlyphCount */
/* TTFACC_WORD, /* GlyphIDArray[1] */
}; /*  JSTFEXTENDERGLYPH */

/* BASE TTO Table, enough to do TTOAutoMap */

#define BASEHEADER_CONTROL_COUNT 3
uint8 BASEHEADER_CONTROL[BASEHEADER_CONTROL_COUNT+1] =
{
	BASEHEADER_CONTROL_COUNT,
	TTFACC_LONG, /* version */              
	TTFACC_WORD, /* HorizAxisOffset */                          
	TTFACC_WORD  /* VertAxisOffset */             
}; /*  BASEHEADER */

#define BASEAXIS_CONTROL_COUNT 2
uint8 BASEAXIS_CONTROL[BASEAXIS_CONTROL_COUNT+1] =
{
	BASEAXIS_CONTROL_COUNT,
	TTFACC_WORD, /* BaseTagListOffset */
	TTFACC_WORD  /* BaseScriptListOffset */
}; /*  BASEAXIS */

#define BASESCRIPTRECORD_CONTROL_COUNT 3
uint8 BASESCRIPTRECORD_CONTROL[BASESCRIPTRECORD_CONTROL_COUNT+1] =
{
	BASESCRIPTRECORD_CONTROL_COUNT,
	TTFACC_LONG, /* Tag */                
	TTFACC_WORD,  /* BaseScriptOffset */
    TTFACC_WORD|TTFACC_PAD /*	   PadForRISC */  /* lcp for platform independence */
}; /*  BASESCRIPTRECORD */

#define BASESCRIPTLIST_CONTROL_COUNT 2
uint8 BASESCRIPTLIST_CONTROL[BASESCRIPTLIST_CONTROL_COUNT+1] =
{
	BASESCRIPTLIST_CONTROL_COUNT,
	TTFACC_WORD,  /* BaseScriptCount */
    TTFACC_WORD|TTFACC_PAD /*	   PadForRISC */  /* lcp for platform independence */
}; /*  BASESCRIPTLIST */

#define BASELANGSYSRECORD_CONTROL_COUNT 3
uint8 BASELANGSYSRECORD_CONTROL[BASELANGSYSRECORD_CONTROL_COUNT+1] =
{
	BASELANGSYSRECORD_CONTROL_COUNT,
	TTFACC_LONG, /* Tag */                                 
	TTFACC_WORD,  /* MinMaxOffset */
    TTFACC_WORD|TTFACC_PAD /*	   PadForRISC */  /* lcp for platform independence */
}; /*  BASELANGSYSRECORD */

#define BASESCRIPT_CONTROL_COUNT 4
uint8 BASESCRIPT_CONTROL[BASESCRIPT_CONTROL_COUNT+1] =
{
	BASESCRIPT_CONTROL_COUNT,
	TTFACC_WORD, /* BaseValuesOffset */
	TTFACC_WORD, /* MinMaxOffset */
	TTFACC_WORD,  /* BaseLangSysCount */
    TTFACC_WORD|TTFACC_PAD /*	   PadForRISC */  /* lcp for platform independence */
}; /*  BASESCRIPT */

#define  BASEVALUES_CONTROL_COUNT 2
uint8 BASEVALUES_CONTROL[BASEVALUES_CONTROL_COUNT+1] =
{
	BASEVALUES_CONTROL_COUNT,
	TTFACC_WORD, /* DefaultIndex */
	TTFACC_WORD  /* BaseCoordCount */
	/* TTFACC_WORD, /* BaseCoordOffsetArray[1] */
}; /*  BASEVALUES */

#define BASEFEATMINMAXRECORD_CONTROL_COUNT 3
uint8 BASEFEATMINMAXRECORD_CONTROL[BASEFEATMINMAXRECORD_CONTROL_COUNT+1] =
{
	BASEFEATMINMAXRECORD_CONTROL_COUNT,
	TTFACC_LONG, /* Tag */
	TTFACC_WORD, /* MinCoordOffset */
	TTFACC_WORD  /* MaxCoordOffset */
}; /*  BASEFEATMINMAXRECORD */

#define BASEMINMAX_CONTROL_COUNT 4 
uint8 BASEMINMAX_CONTROL[BASEMINMAX_CONTROL_COUNT+1] =
{
	BASEMINMAX_CONTROL_COUNT,
	TTFACC_WORD, /* MinCoordOffset */ 
	TTFACC_WORD, /* MaxCoordOffset */		               
	TTFACC_WORD,  /* FeatMinMaxCount */
    TTFACC_WORD|TTFACC_PAD /*	   PadForRISC */  /* lcp for platform independence */
/* BASEFEATMINMAXRECORD FeatMinMaxRecordArray[1] */
}; /*  BASEMINMAX */

#define BASECOORDFORMAT2_CONTROL_COUNT 4
uint8 BASECOORDFORMAT2_CONTROL[BASECOORDFORMAT2_CONTROL_COUNT+1] =
{
	BASECOORDFORMAT2_CONTROL_COUNT,
	TTFACC_WORD, /* Format */ 
	TTFACC_WORD, /* Coord */
	TTFACC_WORD, /* GlyphID */
	TTFACC_WORD  /* BaseCoordPoint */                                
}; /*  BASECOORDFORMAT2 */

/* Glyph Metamorphosis table (mort) structures */
#define MORTBINSRCHHEADER_CONTROL_COUNT	5
uint8 MORTBINSRCHHEADER_CONTROL[MORTBINSRCHHEADER_CONTROL_COUNT+1] =
{
	MORTBINSRCHHEADER_CONTROL_COUNT,
    TTFACC_WORD, /* entrySize */
    TTFACC_WORD, /* nEntries */
    TTFACC_WORD, /* searchRange */
    TTFACC_WORD, /* entrySelector */
    TTFACC_WORD  /* rangeShift */
}; /*  BINSRCHHEADER */

#define MORTLOOKUPSINGLE_CONTROL_COUNT 2
uint8 MORTLOOKUPSINGLE_CONTROL[MORTLOOKUPSINGLE_CONTROL_COUNT + 1] =
{
	MORTLOOKUPSINGLE_CONTROL_COUNT, 
    TTFACC_WORD, /* glyphid1 */
    TTFACC_WORD /* glyphid2 */
};  /* LOOKUPSINGLE */

#define MORTHEADER_CONTROL_COUNT 62
uint8 MORTHEADER_CONTROL[MORTHEADER_CONTROL_COUNT+1] =
{
	MORTHEADER_CONTROL_COUNT,
    TTFACC_BYTE,         /*   constants1[0]; */
    TTFACC_BYTE,         /*   constants1[1]; */
    TTFACC_BYTE,         /*   constants1[2]; */
    TTFACC_BYTE,         /*   constants1[3]; */
    TTFACC_BYTE,         /*   constants1[4]; */
    TTFACC_BYTE,         /*   constants1[5]; */
    TTFACC_BYTE,         /*   constants1[6]; */
    TTFACC_BYTE,         /*   constants1[7]; */
    TTFACC_BYTE,         /*   constants1[8]; */
    TTFACC_BYTE,         /*   constants1[9]; */
    TTFACC_BYTE,         /*   constants1[10]; */
    TTFACC_BYTE,         /*   constants1[11]; */
    TTFACC_LONG,         /*   length1; */
    TTFACC_BYTE,          /* constants2[0]; */
    TTFACC_BYTE,          /* constants2[1]; */
    TTFACC_BYTE,          /* constants2[2]; */
    TTFACC_BYTE,          /* constants2[3]; */
    TTFACC_BYTE,          /* constants2[4]; */
    TTFACC_BYTE,          /* constants2[5]; */
    TTFACC_BYTE,          /* constants2[6]; */
    TTFACC_BYTE,          /* constants2[7]; */
    TTFACC_BYTE,          /* constants2[8]; */
    TTFACC_BYTE,          /* constants2[9]; */
    TTFACC_BYTE,          /* constants2[10]; */
    TTFACC_BYTE,          /* constants2[11]; */
    TTFACC_BYTE,          /* constants2[12]; */
    TTFACC_BYTE,          /* constants2[13]; */
    TTFACC_BYTE,          /* constants2[14]; */
    TTFACC_BYTE,          /* constants2[15]; */
    TTFACC_BYTE,          /* constants3[0]; */
    TTFACC_BYTE,          /* constants3[1]; */
    TTFACC_BYTE,          /* constants3[2]; */
    TTFACC_BYTE,          /* constants3[3]; */
    TTFACC_BYTE,          /* constants3[4]; */
    TTFACC_BYTE,          /* constants3[5]; */
    TTFACC_BYTE,          /* constants3[6]; */
    TTFACC_BYTE,          /* constants3[7]; */
    TTFACC_BYTE,          /* constants3[8]; */
    TTFACC_BYTE,          /* constants3[9]; */
    TTFACC_BYTE,          /* constants3[10]; */
    TTFACC_BYTE,          /* constants3[11]; */
    TTFACC_BYTE,          /* constants3[12]; */
    TTFACC_BYTE,          /* constants3[13]; */
    TTFACC_BYTE,          /* constants3[14]; */
    TTFACC_BYTE,          /* constants3[15]; */
    TTFACC_BYTE,          /* constants4[0]; */
    TTFACC_BYTE,          /* constants4[1]; */
    TTFACC_BYTE,          /* constants4[2]; */
    TTFACC_BYTE,          /* constants4[3]; */
    TTFACC_BYTE,          /* constants4[4]; */
    TTFACC_BYTE,          /* constants4[5]; */
    TTFACC_BYTE,          /* constants4[6]; */
    TTFACC_BYTE,          /* constants4[7]; */
    TTFACC_WORD,          /* length2; */
    TTFACC_BYTE,          /* constants5[0]; */
    TTFACC_BYTE,          /* constants5[1]; */
    TTFACC_BYTE,          /* constants5[2]; */
    TTFACC_BYTE,          /* constants5[3]; */
    TTFACC_BYTE,          /* constants5[4]; */
    TTFACC_BYTE,          /* constants5[5]; */
    TTFACC_BYTE,          /* constants5[6]; */
    TTFACC_BYTE           /* constants5[7]; */
/*    BinSrchHeader  SearchHeader; */
/*    LookupSingle   entries[1];  */
}; /* MORTTABLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\basefmt.c ===
/* Copyright 1990-1997. Microsoft Corporation. */
#include "typedefs.h"  /* for Far declaration in ttofmt.h header */
#include "ttofmt.h"
/* from TTOBASE.FMT 1.2	*/
 
char * g_BASEFmt[] = {
  "DEFINE ZERO=0",
  "DEFINE MAXCOUNT=0xFFFF",
  "BASEHeader, HEAD {",
  "fixed32, 0x00010000",
  "Offset, Axis",
  "Offset, Axis",
  "}",
  "DeviceTableFormat1, TABLE {",
  "uint16",
  "uint16",
  "uint16, 1",
  "Array, $T2 - $T1+1, packedint2",
  "}",
  "DeviceTableFormat2, TABLE {",
  "uint16",
  "uint16",
  "uint16, 2",
  "Array, $T2 - $T1+1, packedint4",
  "}",
  "DeviceTableFormat3, TABLE {",
  "uint16",
  "uint16",
  "uint16, 3",
  "Array, $T2 - $T1+1, packedint8",
  "}",
  "DeviceTable, CLASS, , $B4 {",
  "DeviceTableFormat1",
  "DeviceTableFormat2",
  "DeviceTableFormat3",
  "}",
  "Axis, TABLE {",
  "Offset, BaseTagList",
  "Offset, BaseScriptList, NOTNULL",
  "}",
  "BaseTagList, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, Tag",
  "}",
  "BaseScriptList, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, BaseScriptRecord",
  "}",
  "BaseScriptRecord, RECORD {",
  "Tag",
  "Offset, BaseScript, NOTNULL",
  "}",
  "BaseScript, TABLE {",
  "Offset, BaseValues",
  "Offset, MinMax",
  "Count",
  "Array, $T3, BaseLangSysRecord",
  "}",
  "BaseLangSysRecord, RECORD {",
  "Tag",
  "Offset, MinMax, NOTNULL",
  "}",
  "BaseValues, TABLE {",
  "uint16",
  "Count",
  "Array, $T2, Offset, BaseCoord, NOTNULL",
  "}",
  "MinMax, TABLE {",
  "Offset, BaseCoord",
  "Offset, BaseCoord",
  "Count",
  "Array, $T3, FeatMinMaxRecord",
  "}",
  "FeatMinMaxRecord, RECORD {",
  "Tag",
  "Offset, BaseCoord",
  "Offset, BaseCoord",
  "}",
  "BaseCoordFormat1, TABLE {",
  "uint16, 1",
  "int16",
  "}",
  "BaseCoordFormat2, TABLE {",
  "uint16, 2",
  "int16",
  "GlyphID, 0, MAXGLYPHID",
  "uint16",
  "}",
  "BaseCoordFormat3, TABLE {",
  "uint16, 3",
  "int16",
  "Offset, DeviceTable, NOTNULL",
  "}",
  "BaseCoord, CLASS, , $B0 {",
  "BaseCoordFormat1",
  "BaseCoordFormat2",
  "BaseCoordFormat3",
  "}",
  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\automap.h ===
/*
  * Automap.h: Interface file for Automap.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */
  
#ifndef AUTOMAP_DOT_H_DEFINED
#define AUTOMAP_DOT_H_DEFINED        

int16 TTOAutoMap( TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint8 * pabKeepGlyphs, uint16 usnGlyphs, uint16 fKeepFlag);
int16 MortAutoMap( TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint8 * pabKeepGlyphs, uint16 usnGlyphs, uint16 fKeepFlag);
int16 AppleAutoMap(TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint8 * pabKeepGlyphs, uint16 usnGlyphs, uint16 fKeepFlag);

#endif /* AUTOMAP_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\automap.c ===
/***************************************************************************
 * module: AutoMap.C   
 *						  
 * author: Louise Pathe
 * date:   1995
 * Copyright 1990-1997. Microsoft Corporation. 
 * 
 * Module to Add Glyph Indices into list of Indices to keep, based on 
 * information found in the Font File's GSUB, JSTF and BASE tables, if any. 
 **************************************************************************/

/* Inclusions ----------------------------------------------------------- */

#include "typedefs.h"
#include "ttff.h"
#include "ttfacc.h"
#include "ttfcntrl.h"
#include "ttftable.h"
#include "ttftabl1.h"
#include "util.h"
#include "ttferror.h" /* for error codes */
#include "ttmem.h"
#include "automap.h"


int16 MortAutoMap(TTFACC_FILEBUFFERINFO * pInputBufferInfo,   /* ttfacc info */
				 uint8 * pabKeepGlyphs, /* binary list of glyphs to keep - to be updated here */
				 uint16 usnGlyphs,	/* number of glyphs in list */
				 uint16 fKeepFlag)
{
MORTBINSRCHHEADER MortBinSrchHeader;
MORTLOOKUPSINGLE  MortLookup;
uint16 nEntries;
uint16 usBytesRead;
uint32 ulOffset;
uint32 ulLength;
uint32 ulLastOffset;
int16 errCode = NO_ERROR;

	ulOffset = TTTableOffset( pInputBufferInfo, MORT_TAG );
 	ulLength = TTTableLength( pInputBufferInfo, MORT_TAG );
	ulLastOffset = ulOffset+ulLength;

	if (ulOffset == DIRECTORY_ERROR || ulLength == 0)	/* nothing to map, we're done */
		return NO_ERROR;

	ulOffset += GetGenericSize(MORTHEADER_CONTROL);	 /* skip over mortheader */

	if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *)&MortBinSrchHeader, SIZEOF_MORTBINSRCHHEADER, MORTBINSRCHHEADER_CONTROL, ulOffset, &usBytesRead ) )!= NO_ERROR)
		return errCode;

	ulOffset += usBytesRead;

	for ( nEntries = MortBinSrchHeader.nEntries; nEntries > 0 && ulOffset < ulLastOffset;nEntries--)
    {
		if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *)&MortLookup, SIZEOF_MORTLOOKUPSINGLE, MORTLOOKUPSINGLE_CONTROL, ulOffset, &usBytesRead ) )!= NO_ERROR)
			return errCode;
		ulOffset += usBytesRead;
		
        if ( MortLookup.glyphid1 < usnGlyphs && pabKeepGlyphs[MortLookup.glyphid1] == fKeepFlag && MortLookup.glyphid2 < usnGlyphs && pabKeepGlyphs[MortLookup.glyphid2] == 0)
            pabKeepGlyphs[MortLookup.glyphid2] = fKeepFlag + 1; /* set this value too */
    }
	return NO_ERROR;
}

/* ------------------------------------------------------------------- */
/* Static function to syncronize the Keep Glyph List with the Coverage list */
/* (add in values if necessary) */ 
/* ------------------------------------------------------------------- */
static int16 UpdateKeepWithCoverage(TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint8 * pabKeepGlyphs, uint16 usnGlyphs, uint16 fKeepFlag, uint32 ulBaseOffset, uint32 ulCoverageOffset, uint16 *pArray, uint16 usLookupType, uint16 usSubstFormat)
{
uint32 ulOffset;
uint16 usCoverageFormat;
GSUBCOVERAGEFORMAT1	Coverage1;
GSUBCOVERAGEFORMAT2	Coverage2;
uint16 usCount;	/* number of array elements in coverage table */
uint16 usGlyphCount; /* number of glyphs processed in Coverage Table */
uint16 usGlyphID;
uint16 *pGlyphIDArray = NULL;
GSUBRANGERECORD *pRangeRecordArray = NULL;
uint16 i, j, k, l;
uint16 usBytesRead;
uint32 ulBytesRead;
int16 errCode = NO_ERROR;

	if ((ulCoverageOffset == 0) || (pArray == NULL))
		return NO_ERROR;
	ulOffset = ulBaseOffset + ulCoverageOffset;
	if ((errCode = ReadWord( pInputBufferInfo, &usCoverageFormat, ulOffset)) != NO_ERROR)
		return errCode;
	/* OK, read in the actual Coverage Table */
	switch (usCoverageFormat)
	{
	case 1:
		if ((errCode = ReadGeneric( pInputBufferInfo,  (uint8 *)&Coverage1, SIZEOF_GSUBCOVERAGEFORMAT1, GSUBCOVERAGEFORMAT1_CONTROL, ulOffset, &usBytesRead) )!= NO_ERROR)
			return errCode;
		ulOffset += usBytesRead;
		usCount = Coverage1.GlyphCount;
		pGlyphIDArray = Mem_Alloc(usCount * sizeof(uint16));
		if (pGlyphIDArray == NULL)
			return ERR_MEM;
		if ((errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *)pGlyphIDArray, WORD_CONTROL, ulOffset, &ulBytesRead, usCount, sizeof(uint16)) )!= NO_ERROR)
		{
			Mem_Free(pGlyphIDArray);
			return errCode;
		}
	  	break;
	case 2:
		if ((errCode = ReadGeneric( pInputBufferInfo,  (uint8 *)&Coverage2, SIZEOF_GSUBCOVERAGEFORMAT2, GSUBCOVERAGEFORMAT2_CONTROL, ulOffset, &usBytesRead) )!= NO_ERROR)
			return errCode;
		ulOffset += usBytesRead;
		usCount = Coverage2.CoverageRangeCount;
		pRangeRecordArray = Mem_Alloc(usCount * SIZEOF_GSUBRANGERECORD);
		if (pRangeRecordArray == NULL)
			return ERR_MEM;
		if ((errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *) pRangeRecordArray,  GSUBRANGERECORD_CONTROL, ulOffset, &ulBytesRead, usCount, SIZEOF_GSUBRANGERECORD) )!= NO_ERROR)
		{
			Mem_Free(pRangeRecordArray);
			return errCode;
		}
		break;
	default:
		return ERR_INVALID_TTO;
	}
	
	for (i = 0, j = 0, usGlyphCount = 0; i < usCount && errCode == NO_ERROR; ++usGlyphCount) /* while the entire Coverage Table has not been processed */
	{
		/* First, get a glyph Code from coverage table */
		if (usCoverageFormat == 1)
		{  
			usGlyphID = pGlyphIDArray[i];
			++i; 
		}
		else 
		{ 	
		  	usGlyphID = (uint16) (pRangeRecordArray[i].RangeStart + j);
			if (usGlyphID < pRangeRecordArray[i].RangeEnd)
				++j;
			else  /* go to next range */
			{
				++i;
				j = 0;
			}
		}
		
		/* Next, see if it exists, and deal with corresponding Substitute data */
		if (usGlyphID >= usnGlyphs || pabKeepGlyphs[usGlyphID] != fKeepFlag)
			continue;

		/* now read in the actual Subtitute Glyph Data and process */
		switch (usLookupType)
		{
		case GSUBSingleLookupType: 
			if (usSubstFormat == 1)
			{
				if ((usGlyphID + (int16) *pArray) < usnGlyphs && pabKeepGlyphs[usGlyphID + (int16) *pArray] == 0)
					pabKeepGlyphs[usGlyphID + (int16) *pArray] = fKeepFlag + 1;
			}
			else
			{
				if (pArray[usGlyphCount] < usnGlyphs && pabKeepGlyphs[pArray[usGlyphCount]] == 0)
					pabKeepGlyphs[pArray[usGlyphCount]] = fKeepFlag + 1;
			}
			break;
		case GSUBMultipleLookupType:
		{
			uint16 usSequenceGlyphCount;
			uint16 *pausGlyphID = NULL;

			if (pArray[usGlyphCount] == 0)
				break;
			ulOffset = ulBaseOffset + pArray[usGlyphCount];
			if ((errCode = ReadWord( pInputBufferInfo, &usSequenceGlyphCount, ulOffset ) )!= NO_ERROR)
				break;
			ulOffset += sizeof(uint16);
			pausGlyphID = Mem_Alloc(usSequenceGlyphCount * sizeof(uint16));
			if (pausGlyphID == NULL)
			{
				errCode = ERR_MEM;
				break;
			}
			errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *)pausGlyphID, WORD_CONTROL, ulOffset, &ulBytesRead, usSequenceGlyphCount, sizeof(uint16));
			if (errCode == NO_ERROR)
			{			
				for (k = 0; k < usSequenceGlyphCount; ++k)
				{
			 		if (pausGlyphID[k] < usnGlyphs && pabKeepGlyphs[pausGlyphID[k]] == 0)
					   pabKeepGlyphs[pausGlyphID[k]] = fKeepFlag + 1;
				}
			}
			Mem_Free (pausGlyphID);
			break;
		}
		case GSUBAlternateLookupType:	
		{
			uint16 usAlternateGlyphCount;
			uint16 *pausGlyphID = NULL;

			if (pArray[usGlyphCount] == 0)
				break;
			ulOffset = ulBaseOffset + pArray[usGlyphCount];
			if ((errCode = ReadWord( pInputBufferInfo, &usAlternateGlyphCount, ulOffset ) )!= NO_ERROR)
				break;
			ulOffset += sizeof(uint16);
			pausGlyphID = Mem_Alloc(usAlternateGlyphCount * sizeof(uint16));
			if (pausGlyphID == NULL)
			{
				errCode = ERR_MEM;
				break;
			}
			if ((errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *)pausGlyphID, WORD_CONTROL, ulOffset, &ulBytesRead, usAlternateGlyphCount, sizeof(uint16)) )== NO_ERROR)
			{
				for (k = 0; k < usAlternateGlyphCount; ++k)
				{
			 		if (pausGlyphID[k] < usnGlyphs && pabKeepGlyphs[pausGlyphID[k]] == 0)
					   pabKeepGlyphs[pausGlyphID[k]] = fKeepFlag + 1;
				}
			}
			Mem_Free (pausGlyphID);
			break;
		}
		case GSUBLigatureLookupType:
		{
			uint16 usLigatureCompCount;
			uint16 usLigatureCount;
			uint16 *pausCompGlyphID = NULL; /* glyph IDs components of ligature */
			uint16 usLigatureGlyphID;   /* actual glyph to substitute for ligatures */
			uint16 *pausLigatureOffsetArray = NULL;
			GSUBLIGATURE GSUBLigature;

			if (pArray[usGlyphCount] == 0)
				break;
			ulOffset = ulBaseOffset + pArray[usGlyphCount];
			if ((errCode = ReadWord( pInputBufferInfo, &usLigatureCount, ulOffset ) )!= NO_ERROR)
				break;
			ulOffset += sizeof(uint16);
			pausLigatureOffsetArray = Mem_Alloc(usLigatureCount * sizeof(uint16));
			if (pausLigatureOffsetArray == NULL)
			{
				errCode = ERR_MEM;
				break;
			}
			if ((errCode = ReadGenericRepeat( pInputBufferInfo,  (uint8 *)pausLigatureOffsetArray, WORD_CONTROL, ulOffset, &ulBytesRead, usLigatureCount, sizeof(uint16)) ) == NO_ERROR)
			{		
				for (l = 0; l < usLigatureCount; ++l)
				{
					if (pausLigatureOffsetArray[l] == 0)
						continue;
					ulOffset = ulBaseOffset + (pArray)[usGlyphCount] + pausLigatureOffsetArray[l];
					if ((errCode = ReadGeneric( pInputBufferInfo,  (uint8 *)&GSUBLigature, SIZEOF_GSUBLIGATURE, GSUBLIGATURE_CONTROL, ulOffset, &usBytesRead) )!= NO_ERROR)
					{
						Mem_Free (pausLigatureOffsetArray);
						Mem_Free(pGlyphIDArray);
						Mem_Free(pRangeRecordArray);
						return errCode;
					}
					ulOffset += usBytesRead;
					usLigatureCompCount = GSUBLigature.LigatureCompCount; 
					usLigatureGlyphID = GSUBLigature.GlyphID; 
					if (usLigatureGlyphID >= usnGlyphs || pabKeepGlyphs[usLigatureGlyphID] != 0)
						continue;  /* already in list, go to next ligature */
					pausCompGlyphID = Mem_Alloc((usLigatureCompCount - 1) * sizeof(uint16));
					if (pausCompGlyphID == NULL)
					{
						Mem_Free (pausLigatureOffsetArray);
						Mem_Free(pGlyphIDArray);
						Mem_Free(pRangeRecordArray);
						return ERR_MEM;
					}
					if ((errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *)pausCompGlyphID, WORD_CONTROL, ulOffset, &ulBytesRead, (uint16) (usLigatureCompCount - 1) , sizeof(uint16)) )!= NO_ERROR)
					{
						Mem_Free (pausCompGlyphID);
						Mem_Free (pausLigatureOffsetArray);
						Mem_Free(pGlyphIDArray);
						Mem_Free(pRangeRecordArray);
						return errCode;
					}
					for (k = 0; k < usLigatureCompCount - 1; ++k)
					{
				 		if (pausCompGlyphID[k] >= usnGlyphs || pabKeepGlyphs[pausCompGlyphID[k]] == 0)
							break; /* if one of the components is not in list, don't worry about ligature */
					}
					if (k == (usLigatureCompCount - 1) && pabKeepGlyphs[usLigatureGlyphID] == 0) /* got to the end of the component list */
						pabKeepGlyphs[usLigatureGlyphID] = fKeepFlag+1;
					Mem_Free(pausCompGlyphID);
				}
			}
			Mem_Free (pausLigatureOffsetArray);
			break;
			}
		}

	}
	Mem_Free(pGlyphIDArray);
	Mem_Free(pRangeRecordArray);
	return errCode;
} 
/* ------------------------------------------------------------------- */
/* static function to read glyphid out of BaseCoordFormat2 table and   */
/* add it to the KeepGlyph list */
/* ------------------------------------------------------------------- */
static int16 ProcessBaseCoord(TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint32 ulOffset, uint8 * pabKeepGlyphs, uint16 usnGlyphs, uint16 fKeepFlag)
{
BASECOORDFORMAT2 BASECoordFormat2;
uint16 BASECoordFormat;
int16 errCode;
uint16 usBytesRead;

	if ((errCode = ReadWord( pInputBufferInfo,  &BASECoordFormat, ulOffset ) )!= NO_ERROR)
		return errCode;
	if (BASECoordFormat != 2)
		return NO_ERROR;
 	if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *) &BASECoordFormat2, SIZEOF_BASECOORDFORMAT2, BASECOORDFORMAT2_CONTROL, ulOffset, &usBytesRead ) )!= NO_ERROR)
		return errCode;
	if (BASECoordFormat2.GlyphID < usnGlyphs && pabKeepGlyphs[BASECoordFormat2.GlyphID] == 0)
		pabKeepGlyphs[BASECoordFormat2.GlyphID] = fKeepFlag + 1;
	return NO_ERROR;

}
/* ------------------------------------------------------------------- */
/* static function to read the glyphids from a MinMax record and add it*/
/* to the KeepGlyph list */
/* ------------------------------------------------------------------- */
static int16 ProcessMinMax(TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint32 ulOffset, uint8 * pabKeepGlyphs, uint16 usnGlyphs, uint16 fKeepFlag)
{
BASEMINMAX BASEMinMax;
BASEFEATMINMAXRECORD BASEFeatMinMaxRecord;
uint16 i;
uint16 usBytesRead;
uint32 ulCurrentOffset;
int16 errCode;

	if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *)&BASEMinMax, SIZEOF_BASEMINMAX, BASEMINMAX_CONTROL, ulOffset, &usBytesRead ) )!= NO_ERROR)
		return errCode;
	if (BASEMinMax.MinCoordOffset != 0)
		if ((errCode = ProcessBaseCoord( pInputBufferInfo, ulOffset + BASEMinMax.MinCoordOffset, pabKeepGlyphs, usnGlyphs, fKeepFlag))!= NO_ERROR)
			return errCode;
	if (BASEMinMax.MaxCoordOffset != 0)
		if ((errCode = ProcessBaseCoord( pInputBufferInfo, ulOffset + BASEMinMax.MaxCoordOffset, pabKeepGlyphs, usnGlyphs, fKeepFlag))!= NO_ERROR)
			return errCode;
	ulCurrentOffset = ulOffset + usBytesRead;
	for (i = 0; i < BASEMinMax.FeatMinMaxCount; ++i)
	{
		if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *)&BASEFeatMinMaxRecord, SIZEOF_BASEFEATMINMAXRECORD, BASEFEATMINMAXRECORD_CONTROL, ulCurrentOffset, &usBytesRead ) )!= NO_ERROR)
			return errCode;
		ulCurrentOffset += usBytesRead;
		if (BASEFeatMinMaxRecord.MinCoordOffset != 0)
			if ((errCode = ProcessBaseCoord( pInputBufferInfo, ulOffset + BASEFeatMinMaxRecord.MinCoordOffset, pabKeepGlyphs, usnGlyphs, fKeepFlag))!= NO_ERROR)
				return errCode;
		if (BASEFeatMinMaxRecord.MaxCoordOffset != 0)
			if ((errCode = ProcessBaseCoord( pInputBufferInfo, ulOffset + BASEFeatMinMaxRecord.MaxCoordOffset, pabKeepGlyphs, usnGlyphs, fKeepFlag))!= NO_ERROR)
				return errCode;
	}
	return NO_ERROR;
}
/* ------------------------------------------------------------------- */
/* Entry Point to module */
/* function to grab all referenced glyph IDs from GSUB, JSTF and BASE */
/* TTO tables and add them into the list of glyphs to keep */ 
/* ------------------------------------------------------------------- */
int16 TTOAutoMap( TTFACC_FILEBUFFERINFO * pInputBufferInfo,   /* ttfacc info */
				 uint8 * pabKeepGlyphs, /* binary list of glyphs to keep - to be updated here */
				 uint16 usnGlyphs,	/* number of glyphs in list */
				 uint16 fKeepFlag) /* flag index (really contains a number) of what to set in the pabKeepGlyph list */
{
GSUBHEADER GSUBHeader;
GSUBLOOKUPLIST GSUBLookupList, *pGSUBLookupList = NULL;
JSTFHEADER JSTFHeader;
JSTFSCRIPTRECORD *ScriptRecordArray;
JSTFSCRIPT JSTFScript;
JSTFEXTENDERGLYPH JSTFExtenderGlyph;
uint16 *GlyphIDArray;
BASEHEADER BASEHeader;
BASEAXIS BASEAxis;
BASESCRIPTLIST BASEScriptList;
BASESCRIPTRECORD BASEScriptRecord;
BASESCRIPT BASEScript;
BASEVALUES BASEValues;
BASELANGSYSRECORD BASELangSysRecord;
uint16 BASECoordOffset;
uint16 AxisOffset;
uint32 ulHeaderOffset;
uint32 ulCurrentOffset;
uint32 ulLangSysOffset;
uint16 usMaxLookupCount;
uint32 ulOffset;
uint16 i, j, k;
uint16 usBytesRead;
uint32 ulBytesRead;
int16 errCode = NO_ERROR;


/* Process GSUB Table */
	while (1)  /* so we can break out on null offsets */
	{
		ulHeaderOffset = TTTableOffset( pInputBufferInfo, GSUB_TAG );

		if (ulHeaderOffset == 0)
			break;

		if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *)&GSUBHeader, SIZEOF_GSUBHEADER, GSUBHEADER_CONTROL, ulHeaderOffset, &usBytesRead ) )!= NO_ERROR)
			return errCode;

		/* now read the max number of lookups, for allocation of the lookup list */

		if (GSUBHeader.LookupListOffset == 0)
			break;
		if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *)&GSUBLookupList, SIZEOF_GSUBLOOKUPLIST, GSUBLOOKUPLIST_CONTROL, ulHeaderOffset + GSUBHeader.LookupListOffset, &usBytesRead) )!= NO_ERROR)
			return errCode;
		usMaxLookupCount = GSUBLookupList.LookupCount;

		if (usMaxLookupCount == 0)
			break;
	
		while (1) /* so we can break out and clean up on error */
		/* Now look at lookup table, and add to list from Context lookups */
		{
		GSUBLOOKUP GSUBLookup;
		uint16 *SubstTableOffsetArray = NULL;

			ulOffset = ulHeaderOffset + GSUBHeader.LookupListOffset;
			pGSUBLookupList = Mem_Alloc(SIZEOF_GSUBLOOKUPLIST + usMaxLookupCount * sizeof(uint16));
			if (pGSUBLookupList == NULL)
			{
				errCode = ERR_MEM;
				break;
			}
			/* read the first part */
 			if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *) pGSUBLookupList, SIZEOF_GSUBLOOKUPLIST, GSUBLOOKUPLIST_CONTROL, ulOffset, &usBytesRead) )!= NO_ERROR)
				break;
			/* now read the array */
			if ((errCode = ReadGenericRepeat( pInputBufferInfo,  (uint8 *) ((uint8 *)pGSUBLookupList + SIZEOF_GSUBLOOKUPLIST), WORD_CONTROL, ulOffset + usBytesRead, &ulBytesRead, usMaxLookupCount, sizeof(uint16)) )!= NO_ERROR)
				break;

	/* now make sure all the referenced glyphs are in the keep table */

			for (i = 0; i < usMaxLookupCount; ++i)
			{
			uint16 usSubTableCount;

				if (pGSUBLookupList->LookupTableOffsetArray[i] == 0)
					continue;
				ulOffset = ulHeaderOffset + 
							GSUBHeader.LookupListOffset + 
							pGSUBLookupList->LookupTableOffsetArray[i];
				if ((errCode = ReadGeneric( pInputBufferInfo,  (uint8 *)&GSUBLookup, SIZEOF_GSUBLOOKUP, GSUBLOOKUP_CONTROL, ulOffset, &usBytesRead) )!= NO_ERROR)
					break;
				if (GSUBLookup.LookupType == GSUBContextLookupType)  /* not looking for context lookups */
					continue;
				usSubTableCount = GSUBLookup.SubTableCount;
				SubstTableOffsetArray = Mem_Alloc(sizeof(uint16) * usSubTableCount);
				if (SubstTableOffsetArray == NULL)
				{
					errCode = ERR_MEM;
					break;
				}
				if ((errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *) SubstTableOffsetArray, WORD_CONTROL, ulOffset + usBytesRead, &ulBytesRead, usSubTableCount, sizeof(uint16)) )!= NO_ERROR)
					break;
			
				for (j = 0; j < usSubTableCount; ++j)
				{
				uint16 Format;

		 			if (SubstTableOffsetArray[j] == 0)
						continue;
		 			ulOffset = ulHeaderOffset + 
								GSUBHeader.LookupListOffset + 
								pGSUBLookupList->LookupTableOffsetArray[i] +
								SubstTableOffsetArray[j];
					if ((errCode = ReadWord( pInputBufferInfo, &Format, ulOffset) )!= NO_ERROR)
						break;
					switch(GSUBLookup.LookupType)
					{
					case GSUBSingleLookupType:
					{
						switch	(Format)
						{
						case 1:
						{
						GSUBSINGLESUBSTFORMAT1 GSUBSubstTable;

							if ((errCode = ReadGeneric( pInputBufferInfo,  (uint8 *)&GSUBSubstTable, SIZEOF_GSUBSINGLESUBSTFORMAT1, GSUBSINGLESUBSTFORMAT1_CONTROL, ulOffset, &usBytesRead) )== NO_ERROR)
								errCode = UpdateKeepWithCoverage( pInputBufferInfo, pabKeepGlyphs, usnGlyphs, fKeepFlag, ulOffset, GSUBSubstTable.CoverageOffset , (uint16 *) &(GSUBSubstTable.DeltaGlyphID), GSUBLookup.LookupType, Format);
							break;
						}
						case 2:
						{
						GSUBSINGLESUBSTFORMAT2 GSUBSubstTable;
						uint16 usGlyphCount;
						uint16 *pGlyphIDArray = NULL;

							if ((errCode = ReadGeneric( pInputBufferInfo,  (uint8 *)&GSUBSubstTable, SIZEOF_GSUBSINGLESUBSTFORMAT2, GSUBSINGLESUBSTFORMAT2_CONTROL, ulOffset, &usBytesRead) )!= NO_ERROR)
								break;
							usGlyphCount = GSUBSubstTable.GlyphCount;
							pGlyphIDArray = Mem_Alloc(sizeof(uint16) * usGlyphCount);
							if (pGlyphIDArray == NULL)
							{
								errCode = ERR_MEM;
								break;
							}
							if ((errCode = ReadGenericRepeat( pInputBufferInfo,  (uint8 *)pGlyphIDArray, WORD_CONTROL, ulOffset + usBytesRead, &ulBytesRead, usGlyphCount, sizeof(uint16)) )== NO_ERROR)
								errCode = UpdateKeepWithCoverage( pInputBufferInfo, pabKeepGlyphs, usnGlyphs, fKeepFlag, ulOffset, GSUBSubstTable.CoverageOffset , pGlyphIDArray, GSUBLookup.LookupType, Format);
							Mem_Free(pGlyphIDArray);
							break;
						}

						default:
							errCode = ERR_INVALID_GSUB;
							break;
						}
						break;
					}
					case GSUBMultipleLookupType:
					{
					GSUBMULTIPLESUBSTFORMAT1 GSUBSubstTable;
					uint16 usCount;
					uint16 *pOffsetArray = NULL;

						if (Format != 1)
							break;
						if ((errCode = ReadGeneric( pInputBufferInfo,  (uint8 *)&GSUBSubstTable, SIZEOF_GSUBMULTIPLESUBSTFORMAT1, GSUBMULTIPLESUBSTFORMAT1_CONTROL, ulOffset, &usBytesRead) )!= NO_ERROR)
							break;
						usCount = GSUBSubstTable.SequenceCount;
						pOffsetArray = Mem_Alloc(sizeof(uint16) * usCount);
						if (pOffsetArray == NULL)
						{
							errCode = ERR_MEM;
							break;
						}
						if ((errCode = ReadGenericRepeat( pInputBufferInfo,  (uint8 *)pOffsetArray, WORD_CONTROL, ulOffset + usBytesRead, &ulBytesRead, usCount, sizeof(uint16)) )== NO_ERROR)
							errCode = UpdateKeepWithCoverage( pInputBufferInfo, pabKeepGlyphs, usnGlyphs, fKeepFlag, ulOffset, GSUBSubstTable.CoverageOffset , pOffsetArray, GSUBLookup.LookupType, Format);
						Mem_Free(pOffsetArray);
						break;
					}
					case GSUBAlternateLookupType:
					{
					GSUBALTERNATESUBSTFORMAT1 GSUBSubstTable;
					uint16 usCount;
					uint16 *pOffsetArray = NULL;

						if (Format != 1)
							break;
						if ((errCode = ReadGeneric( pInputBufferInfo,  (uint8 *)&GSUBSubstTable, SIZEOF_GSUBALTERNATESUBSTFORMAT1, GSUBALTERNATESUBSTFORMAT1_CONTROL, ulOffset, &usBytesRead) )!= NO_ERROR)
							break;
						usCount = GSUBSubstTable.AlternateSetCount;
						pOffsetArray = Mem_Alloc(sizeof(uint16) * usCount);
						if (pOffsetArray == NULL)
						{
							errCode = ERR_MEM;
							break;
						}
						if ((errCode = ReadGenericRepeat( pInputBufferInfo,  (uint8 *)pOffsetArray, WORD_CONTROL, ulOffset + usBytesRead, &ulBytesRead, usCount, sizeof(uint16)) )== NO_ERROR)
							errCode = UpdateKeepWithCoverage( pInputBufferInfo, pabKeepGlyphs, usnGlyphs, fKeepFlag, ulOffset, GSUBSubstTable.CoverageOffset , pOffsetArray, GSUBLookup.LookupType, Format);
						Mem_Free(pOffsetArray);
						break;
					}
					case GSUBLigatureLookupType:
					{
					GSUBLIGATURESUBSTFORMAT1 GSUBSubstTable;
					uint16 usCount;
					uint16 *pOffsetArray = NULL;

						if (Format != 1)
							break;
						if ((errCode = ReadGeneric( pInputBufferInfo,  (uint8 *)&GSUBSubstTable, SIZEOF_GSUBLIGATURESUBSTFORMAT1, GSUBLIGATURESUBSTFORMAT1_CONTROL, ulOffset, &usBytesRead) )!= NO_ERROR)
							break;
						usCount = GSUBSubstTable.LigatureSetCount;
						pOffsetArray = Mem_Alloc(sizeof(uint16) * usCount);
						if (pOffsetArray == NULL)
						{
							errCode = ERR_MEM;
							break;
						}
						if ((errCode = ReadGenericRepeat( pInputBufferInfo,  (uint8 *)pOffsetArray, WORD_CONTROL, ulOffset + usBytesRead, &ulBytesRead, usCount, sizeof(uint16)) )== NO_ERROR)
	 						errCode = UpdateKeepWithCoverage( pInputBufferInfo, pabKeepGlyphs, usnGlyphs, fKeepFlag, ulOffset, GSUBSubstTable.CoverageOffset , pOffsetArray, GSUBLookup.LookupType, Format);
						Mem_Free(pOffsetArray);
						break;
					}
					default:
						break;
					}
					if (errCode != NO_ERROR)
						break;

				}
				Mem_Free(SubstTableOffsetArray);
				if (errCode != NO_ERROR)
					break;
			}
			break; /* artificial while for error conditions */
		}	
		Mem_Free(pGSUBLookupList);
		break;
	}

	if (errCode != NO_ERROR)
		return errCode;
/* Process JSTF Table */
	while (1) /* so we can break out on NULL offsets */
	{
		ulHeaderOffset = TTTableOffset( pInputBufferInfo, JSTF_TAG );

		if (ulHeaderOffset == 0)
			break;

		if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *)&JSTFHeader, SIZEOF_JSTFHEADER, JSTFHEADER_CONTROL, ulHeaderOffset, &usBytesRead ) )!= NO_ERROR)
			break;
		ScriptRecordArray = Mem_Alloc(SIZEOF_JSTFSCRIPTRECORD * JSTFHeader.ScriptCount);
		if (ScriptRecordArray == NULL)
		{
			errCode = ERR_MEM;
			break;
		}

		ulOffset = ulHeaderOffset;
		if ((errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *)ScriptRecordArray, JSTFSCRIPTRECORD_CONTROL, ulOffset + usBytesRead, & ulBytesRead, JSTFHeader.ScriptCount, SIZEOF_JSTFSCRIPTRECORD ) )!= NO_ERROR)
			break;
	
		for (i = 0 ; i < JSTFHeader.ScriptCount; ++i)
		{
			if (ScriptRecordArray[i].JstfScriptOffset == 0)
				continue;
			ulOffset = ulHeaderOffset + ScriptRecordArray[i].JstfScriptOffset;
			if ((errCode = ReadGeneric( pInputBufferInfo,  (uint8 *)&JSTFScript, SIZEOF_JSTFSCRIPT, JSTFSCRIPT_CONTROL, ulOffset, &usBytesRead) )!= NO_ERROR)
				break;
			if (JSTFScript.ExtenderGlyphOffset == 0)
				continue;
			ulOffset = ulOffset = ulHeaderOffset + ScriptRecordArray[i].JstfScriptOffset + JSTFScript.ExtenderGlyphOffset;

			if ((errCode = ReadGeneric( pInputBufferInfo,  (uint8 *)&JSTFExtenderGlyph, SIZEOF_JSTFEXTENDERGLYPH, JSTFEXTENDERGLYPH_CONTROL, ulOffset, &usBytesRead) )!= NO_ERROR)
				break;

			GlyphIDArray = Mem_Alloc((sizeof(uint16) * JSTFExtenderGlyph.ExtenderGlyphCount));
			if (GlyphIDArray == NULL)
			{
				errCode = ERR_MEM;
				break;
			}
			if ((errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *)GlyphIDArray, WORD_CONTROL, ulOffset + usBytesRead, &ulBytesRead, JSTFExtenderGlyph.ExtenderGlyphCount, sizeof(uint16)) )== NO_ERROR)
			{
				for (j = 0; j < JSTFExtenderGlyph.ExtenderGlyphCount; ++j)
				{
					if (GlyphIDArray[j] < usnGlyphs && pabKeepGlyphs[GlyphIDArray[j]] == 0)
						pabKeepGlyphs[GlyphIDArray[j]] =  fKeepFlag + 1;
				} 
			}
			Mem_Free(GlyphIDArray);
			if (errCode != NO_ERROR)
				break;
		}
		Mem_Free(ScriptRecordArray);
		break; 
	}
	if (errCode != NO_ERROR)
		return errCode;
 /* Process BASE Table */
	while (1)
	{
		ulHeaderOffset = TTTableOffset( pInputBufferInfo, BASE_TAG );

		if (ulHeaderOffset == 0)
			break;

		if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *)&BASEHeader, SIZEOF_BASEHEADER, BASEHEADER_CONTROL, ulHeaderOffset, &usBytesRead ) )!= NO_ERROR)
			break;

		AxisOffset = BASEHeader.HorizAxisOffset;
		for (i = 0; i < 2; ++i, AxisOffset = BASEHeader.VertAxisOffset)  /* process the 2 axis */
		{
		 	if (AxisOffset == 0)
				continue;
		 	ulOffset = ulHeaderOffset + AxisOffset;
			if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *)&BASEAxis, SIZEOF_BASEAXIS, BASEAXIS_CONTROL, ulOffset, &usBytesRead ) )!= NO_ERROR)
				break;
		 	if (BASEAxis.BaseScriptListOffset == 0)
				continue;
		 	ulOffset = ulHeaderOffset + AxisOffset + BASEAxis.BaseScriptListOffset;
			if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *)&BASEScriptList, SIZEOF_BASESCRIPTLIST, BASESCRIPTLIST_CONTROL, ulOffset, &usBytesRead ) )!= NO_ERROR)
				break;
			ulCurrentOffset = ulOffset + usBytesRead;
			for (j = 0; j < BASEScriptList.BaseScriptCount; ++j)
			{
			uint32 ulLocalOffset;

				if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *)&BASEScriptRecord, SIZEOF_BASESCRIPTRECORD, BASESCRIPTRECORD_CONTROL, ulCurrentOffset, &usBytesRead ) )!= NO_ERROR)
					break;
				ulCurrentOffset += usBytesRead;
				if (BASEScriptRecord.BaseScriptOffset == 0)
					continue;

				if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *)&BASEScript, SIZEOF_BASESCRIPT, BASESCRIPT_CONTROL, ulOffset + BASEScriptRecord.BaseScriptOffset, &usBytesRead ) )!= NO_ERROR)
					break;

				ulLangSysOffset = ulOffset + BASEScriptRecord.BaseScriptOffset + usBytesRead; 

				/* PROCESS BaseValuesOffset */
				if (BASEScript.BaseValuesOffset	!= 0)
				{
					ulLocalOffset = ulOffset + BASEScriptRecord.BaseScriptOffset + BASEScript.BaseValuesOffset ;
		
					if ((errCode = ReadGeneric( pInputBufferInfo,   (uint8 *)&BASEValues, SIZEOF_BASEVALUES, BASEVALUES_CONTROL, ulLocalOffset, &usBytesRead ) )!= NO_ERROR)
						break;
					ulLocalOffset += usBytesRead;
					for (k = 0; k < BASEValues.BaseCoordCount; ++k)
					{
						if ((errCode = ReadWord( pInputBufferInfo,  &BASECoordOffset, ulLocalOffset ) )!= NO_ERROR)
							break;
						ulLocalOffset += sizeof(uint16);
						if ((errCode = ProcessBaseCoord( pInputBufferInfo, ulOffset + BASEScriptRecord.BaseScriptOffset + BASEScript.BaseValuesOffset + BASECoordOffset, pabKeepGlyphs, usnGlyphs, fKeepFlag))!= NO_ERROR)
							break;
					}
					if (errCode != NO_ERROR)
						break;
				}
				/* Process MinMaxOffset */
				if (BASEScript.MinMaxOffset != 0)
				{
					ulLocalOffset = ulOffset + BASEScriptRecord.BaseScriptOffset + BASEScript.MinMaxOffset ;
					if ((errCode = ProcessMinMax( pInputBufferInfo, ulLocalOffset, pabKeepGlyphs, usnGlyphs, fKeepFlag))!= NO_ERROR)
						break;
				}
				/* Process BaseLangSysRecordArray */
				for (k = 0; k < BASEScript.BaseLangSysCount; ++k)
				{
					if ((errCode = ReadGeneric( pInputBufferInfo,  (uint8 *)&BASELangSysRecord, SIZEOF_BASELANGSYSRECORD, BASELANGSYSRECORD_CONTROL, ulLangSysOffset, &usBytesRead ) )!= NO_ERROR)
						break;
					ulLangSysOffset += usBytesRead;
					if (BASELangSysRecord.MinMaxOffset != 0)
						if ((errCode = ProcessMinMax( pInputBufferInfo, ulOffset + BASEScriptRecord.BaseScriptOffset + BASELangSysRecord.MinMaxOffset, pabKeepGlyphs, usnGlyphs, fKeepFlag))!= NO_ERROR)
							break;
				}
				if (errCode != NO_ERROR)
					break;
			}
			if (errCode != NO_ERROR)
				break;
		}
		break;
	}
	return errCode;

}
#ifdef APPLE_AUTOMAP   /* this is not defined for now. */
/* ------------------------------------------------------------------- */
/* Entry Point for Module */
/* function to read all the glyph IDs from the Apple cmap, and add them*/
/* into the list of glyphs to keep */
/* ------------------------------------------------------------------- */
int16 AppleAutoMap( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
				   uint8 * pabKeepGlyphs, 
				   uint16 usnGlyphs,
				   uint16 fKeepFlag)
{
   /* this routine adds any glyphs from the Macintosh (Apple) Cmap */
   /* into the list of glyphs to keep. */ 
CMAP_FORMAT0 CmapFormat0;
CMAP_FORMAT6 CmapFormat6;
uint16 usFoundEncoding;
uint16 *glyphIndexArray;
uint16 i;

   /* read the apple table, if present */

	if ( ReadCmapFormat0( pInputBufferInfo, TTFSUB_APPLE_PLATFORMID, TTFSUB_STD_MAC_CHAR_SET, &usFoundEncoding, &CmapFormat0 ) == NO_ERROR)
	{
		/* read the apple cmap data so that all glyphs in apple cmap will be */
	    /* added to the list of glyphs to keep */

		for ( i = 0; i < CMAP_FORMAT0_ARRAYCOUNT; i++ )	 /* these are byte values, so don't need to swap */
		{
   			if (CmapFormat0.glyphIndexArray[i] < usnGlyphs && pabKeepGlyphs[CmapFormat0.glyphIndexArray[i]] == 0) 
				pabKeepGlyphs[CmapFormat0.glyphIndexArray[i]] = fKeepFlag + 1;  /* keep this one */
		}
	}
	if ( ReadAllocCmapFormat6( pInputBufferInfo, TTFSUB_APPLE_PLATFORMID, TTFSUB_STD_MAC_CHAR_SET, &usFoundEncoding, &CmapFormat6, &glyphIndexArray) == NO_ERROR)
	{
		/* read the apple cmap data so that all glyphs in apple cmap will be */
	    /* added to the list of glyphs to keep */

	   for ( i = 0; i < CmapFormat6.entryCount; i++ )	 /* these are byte values, so don't need to swap */
	   {
   			if (glyphIndexArray[i] < usnGlyphs && pabKeepGlyphs[glyphIndexArray[i]] == 0)
				pabKeepGlyphs[glyphIndexArray[i]] = fKeepFlag + 1;  /* keep this one */
	   }
	   FreeCmapFormat6(glyphIndexArray);
	}

   return NO_ERROR;
}
#endif

/* ------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\gdeffmt.c ===
/* Copyright 1990-1997. Microsoft Corporation. */
#include "typedefs.h"  /* for Far declaration in ttofmt.h header */
#include "ttofmt.h"
/* from TTOGDEF.FMT 1.2	*/

char * g_GDEFFmt[] = {
  "DEFINE ZERO=0",
  "DEFINE MAXCOUNT=0xFFFF",
  "GDEFHeader, HEAD {",
  "fixed32, 0x00010000",
  "Offset, ClassDef",
  "Offset, AttachList",
  "Offset, LigCaretList",
  "}",
  "CoverageFormat1, TABLE {",
  "uint16, 1",
  "Count, 1, MAXCOUNT",
  "Array, $T2, GlyphID, 0, MAXGLYPHID",
  "}",
  "CoverageFormat2, TABLE {",
  "uint16, 2",
  "Count, 1, MAXCOUNT",
  "Array, $T2, RangeRecord",
  "}",
  "RangeRecord, RECORD {",
  "GlyphID, 0, MAXGLYPHID",
  "GlyphID, $R1, MAXGLYPHID",
  "uint16, CheckRangeRecord()",
  "}",
  "Coverage, CLASS, , $B0 {",
  "CoverageFormat1",
  "CoverageFormat2",
  "}",
  "ClassDefFormat1, TABLE {",
  "uint16, 1",
  "GlyphID, 0, MAXGLYPHID",
  "Count, 1, MAXGLYPHID",
  "Array, $T3, uint16",
  "}",
  "ClassDefFormat2, TABLE {",
  "uint16, 2",
  "Count, 1, MAXCOUNT",
  "Array, $T2, ClassRangeRecord",
  "}",
  "ClassRangeRecord, RECORD {",
  "GlyphID, 0, MAXGLYPHID",
  "GlyphID, $R1, MAXGLYPHID",
  "uint16",
  "}",
  "ClassDef, CLASS, , $B0 {",
  "ClassDefFormat1",
  "ClassDefFormat2",
  "}",
  "DeviceTableFormat1, TABLE {",
  "uint16",
  "uint16",
  "uint16, 1",
  "Array, $T2 - $T1+1, packedint2",
  "}",
  "DeviceTableFormat2, TABLE {",
  "uint16",
  "uint16",
  "uint16, 2",
  "Array, $T2 - $T1+1, packedint4",
  "}",
  "DeviceTableFormat3, TABLE {",
  "uint16",
  "uint16",
  "uint16, 3",
  "Array, $T2 - $T1+1, packedint8",
  "}",
  "DeviceTable, CLASS, , $B4 {",
  "DeviceTableFormat1",
  "DeviceTableFormat2",
  "DeviceTableFormat3",
  "}",
  "AttachList, TABLE {",
  "Offset, Coverage, NOTNULL",
  "Count, CoverageCount($T1)",
  "Array, $T2, Offset, AttachPoint, NOTNULL",
  "}",
  "AttachPoint, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, uint16",
  "}",
  "LigCaretList, TABLE {",
  "Offset, Coverage, NOTNULL",
  "Count, CoverageCount($T1)",
  "Array, $T2, Offset, LigGlyph, NOTNULL",
  "}",
  "LigGlyph, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, Offset, CaretValue, NOTNULL",
  "}",
  "CaretValueFormat1, TABLE {",
  "uint16, 1",
  "int16",
  "}",
  "CaretValueFormat2, TABLE {",
  "uint16, 2",
  "uint16",
  "}",
  "CaretValueFormat3, TABLE {",
  "uint16, 3",
  "int16",
  "Offset, DeviceTable, NOTNULL",
  "}",
  "CaretValue, CLASS, , $B0 {",
  "CaretValueFormat1",
  "CaretValueFormat2",
  "CaretValueFormat3",
  "}",
  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\gsubfmt.c ===
/* Copyright 1990-1997. Microsoft Corporation. */
#include "typedefs.h"  /* for Far declaration in ttofmt.h header */
#include "ttofmt.h"
/* from TTOGSUB.FMT 1.2 */

char * g_GSUBFmt[] = {
  "DEFINE ZERO=0",
  "DEFINE MAXCOUNT=0xFFFF",
  "GSUBHeader, HEAD {",
  "fixed32, 0x00010000",
  "Offset, ScriptList, NOTNULL",
  "Offset, FeatureList, NOTNULL",
  "Offset, LookupList, NOTNULL",
  "}",
  "ScriptList, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, ScriptRecord",
  "}",
  "ScriptRecord, RECORD {",
  "Tag",
  "Offset, Script, NOTNULL",
  "}",
  "Script, TABLE {",
  "Offset, LangSys",
  "Count",
  "Array, $T2, LangSysRecord",
  "}",
  "LangSysRecord, RECORD {",
  "Tag",
  "Offset, LangSys, NOTNULL",
  "}",
  "LangSys, TABLE {",
  "Offset, LookupOrder, NULL",
  "GSUBFeatureIndex",
  "Count, 0, MAXFEATURECOUNT",
  "Array, $T3, GSUBFeatureIndex, 0, MAXFEATURECOUNT-1",
  "}",
  "LookupOrder, TABLE {",
  "int16",
  "}",
  "FeatureList, TABLE {",
  "Count, 1, MAXFEATURECOUNT",
  "Array, $T1, FeatureRecord : $IGSUBFeatureIndex",
  "}",
  "FeatureRecord, RECORD {",
  "Tag",
  "Offset, Feature, NOTNULL",
  "}",
  "Feature, TABLE {",
  "Offset, FeatureParams, NULL",
  "Count, 1, MAXLOOKUPCOUNT",
  "Array, $T2, GSUBLookupIndex, 0, MAXLOOKUPCOUNT-1",
  "}",
  "FeatureParams, TABLE {",
  "uint16",
  "}",
  "LookupList, TABLE {",
  "Count, 1, MAXLOOKUPCOUNT",
  "Array, $T1, Offset, Lookup, NOTNULL : $IGSUBLookupIndex",
  "}",
  "Lookup, TABLE {",
  "uint16, 1, 5",
  "uint16",
  "Count, 1, MAXCOUNT",
  "Array, $T3, Offset, SubstTable, NOTNULL, $T1",
  "}",
  "CoverageFormat1, TABLE {",
  "uint16, 1",
  "Count, 1, MAXCOUNT",
  "Array, $T2, GlyphID, 0, MAXGLYPHID",
  "}",
  "CoverageFormat2, TABLE {",
  "uint16, 2",
  "Count, 1, MAXCOUNT",
  "Array, $T2, RangeRecord",
  "}",
  "RangeRecord, RECORD {",
  "GlyphID, 0, MAXGLYPHID",
  "GlyphID, $R1, MAXGLYPHID",
  "uint16, CheckRangeRecord()",
  "}",
  "Coverage, CLASS, , $B0 {",
  "CoverageFormat1",
  "CoverageFormat2",
  "}",
  "ClassDefFormat1, TABLE {",
  "uint16, 1",
  "GlyphID, 0, MAXGLYPHID",
  "Count, 1, MAXGLYPHID",
  "Array, $T3, uint16",
  "}",
  "ClassDefFormat2, TABLE {",
  "uint16, 2",
  "Count, 1, MAXCOUNT",
  "Array, $T2, ClassRangeRecord",
  "}",
  "ClassRangeRecord, RECORD {",
  "GlyphID, 0, MAXGLYPHID",
  "GlyphID, $R1, MAXGLYPHID",
  "uint16",
  "}",
  "ClassDef, CLASS, , $B0 {",
  "ClassDefFormat1",
  "ClassDefFormat2",
  "}",
  "SingleSubstFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "int16",
  "}",
  "SingleSubstFormat2, TABLE {",
  "uint16, 2",
  "Offset, Coverage, NOTNULL",
  "Count, CoverageCount($T2)",
  "Array, $T3, GlyphID, 0, MAXGLYPHID",
  "}",
  "MultipleSubstFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Count, CoverageCount($T2)",
  "Array, $T3, Offset, Sequence, NOTNULL",
  "}",
  "Sequence, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, GlyphID, 0, MAXGLYPHID: DelNone",
  "}",
  "AlternateSubstFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Count, CoverageCount($T2)",
  "Array, $T3, Offset, AlternateSet, NOTNULL",
  "}",
  "AlternateSet, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, GlyphID, 0, MAXGLYPHID",
  "}",
  "LigatureSubstFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Count, CoverageCount($T2)",
  "Array, $T3, Offset, LigatureSet, NOTNULL",
  "}",
  "LigatureSet, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, Offset, Ligature, NOTNULL",
  "}",
  "Ligature, TABLE {",
  "GlyphID, 0, MAXGLYPHID",
  "Count, 2, MAXCOUNT",
  "Array, $T2-1, GlyphID, 0, MAXGLYPHID : DelNone",
  "}",
  "SubstLookupRecord, RECORD {",
  "uint16",
  "GSUBLookupIndex, 0, MAXLOOKUPCOUNT",
  "}",
  "ContextSubstFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Count, CoverageCount($T2)",
  "Array, $T3, Offset, SubRuleSet, NOTNULL",
  "}",
  "SubRuleSet, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, Offset, SubRule, NOTNULL",
  "}",
  "SubRule, TABLE {",
  "Count, 2, MAXCOUNT",
  "Count, 1, MAXCOUNT",
  "Array, $T1-1, GlyphID, 0, MAXGLYPHID : DelNone",
  "Array, $T2, SubstLookupRecord :DelNone",
  "}",
  "ContextSubstFormat2, TABLE {",
  "uint16, 2",
  "Offset, Coverage, NOTNULL",
  "Offset, ClassDef, NOTNULL",
  "Count, ClassCount($T3)",
  "Array, $T4, Offset, SubClassSet",
  "}",
  "SubClassSet, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, Offset, SubClassRule, NOTNULL",
  "}",
  "SubClassRule, TABLE {",
  "Count, 2, MAXCOUNT",
  "Count, 1, MAXCOUNT",
  "Array, $T1-1, uint16 : DelNone",
  "Array, $T2, SubstLookupRecord : DelNone",
  "}",
  "ContextSubstFormat3, TABLE {",
  "uint16, 3",
  "Count, 2, MAXCOUNT",
  "Count, 1, MAXCOUNT",
  "Array, $T2, Offset, Coverage, NOTNULL : DelNone",
  "Array, $T3, SubstLookupRecord : DelNone",
  "}",
  "SubstTable, CLASS, 1, $P1 {",
  "SingleSubstClass",
  "MultipleSubstClass",
  "AlternateSubstClass",
  "LigatureSubstClass",
  "ContextSubstClass",
  "}",
  "SingleSubstClass, CLASS, , $B0 {",
  "SingleSubstFormat1",
  "SingleSubstFormat2",
  "}",
  "MultipleSubstClass, CLASS, , $B0 {",
  "MultipleSubstFormat1",
  "}",
  "AlternateSubstClass, CLASS, , $B0 {",
  "AlternateSubstFormat1",
  "}",
  "LigatureSubstClass, CLASS, , $B0 {",
  "LigatureSubstFormat1",
  "}",
  "ContextSubstClass, CLASS, , $B0 {",
  "ContextSubstFormat1",
  "ContextSubstFormat2",
  "ContextSubstFormat3",
  "}",
  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\jstffmt.c ===
/* Copyright 1990-1997. Microsoft Corporation. */
#include "typedefs.h"  /* for Far declaration in ttofmt.h header */
#include "ttofmt.h"
/* from TTOJSTF.FMT 1.1	*/

char * g_JSTFFmt[] = {
  "DEFINE ZERO=0",
  "DEFINE MAXCOUNT=0xFFFF",
  "JSTFHeader, HEAD {",
  "fixed32, 0x00010000",
  "Count, 1, MAXCOUNT",
  "Array, $T2, JstfScriptRecord",
  "}",
  "JstfScriptRecord, RECORD {",
  "Tag",
  "Offset, JstfScript, NOTNULL",
  "}",
  "JstfScript, TABLE {",
  "Offset, ExtenderGlyph",
  "Offset, JstfLangSys",
  "Count",
  "Array, $T3, JstfLangSysRecord",
  "}",
  "JstfLangSysRecord, RECORD {",
  "Tag",
  "Offset, JstfLangSys, NOTNULL",
  "}",
  "ExtenderGlyph, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, GlyphID, 0, MAXGLYPHID",
  "}",
  "JstfLangSys, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, Offset, JstfPriority, NOTNULL",
  "}",
  "JstfPriority, TABLE {",
  "Offset, JstfGSUBModList",
  "Offset, JstfGSUBModList",
  "Offset, JstfGPOSModList",
  "Offset, JstfGPOSModList",
  "Offset, JstfMax",
  "Offset, JstfGSUBModList",
  "Offset, JstfGSUBModList",
  "Offset, JstfGPOSModList",
  "Offset, JstfGPOSModList",
  "Offset, JstfMax",
  "}",
  "JstfGSUBModList, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, GSUBLookupIndex, 0, MAXLOOKUPCOUNT",
  "}",
  "JstfGPOSModList, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, GPOSLookupIndex, 0, MAXLOOKUPCOUNT",
  "}",
  "JstfMax, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, Offset, Lookup, NOTNULL",
  "}",
  "Lookup, TABLE {",
  "uint16, 1, 6",
  "uint16",
  "Count, 1, MAXCOUNT",
  "Array, $T3, Offset, PosTable, NOTNULL, $T1",
  "}",
  "CoverageFormat1, TABLE {",
  "uint16, 1",
  "Count, 1, MAXCOUNT",
  "Array, $T2, GlyphID, 0, MAXGLYPHID",
  "}",
  "CoverageFormat2, TABLE {",
  "uint16, 2",
  "Count, 1, MAXCOUNT",
  "Array, $T2, RangeRecord",
  "}",
  "RangeRecord, RECORD {",
  "GlyphID, 0, MAXGLYPHID",
  "GlyphID, $R1, MAXGLYPHID",
  "uint16, CheckRangeRecord()",
  "}",
  "Coverage, CLASS, , $B0 {",
  "CoverageFormat1",
  "CoverageFormat2",
  "}",
  "ClassDefFormat1, TABLE {",
  "uint16, 1",
  "GlyphID, 0, MAXGLYPHID",
  "Count, 1, MAXGLYPHID",
  "Array, $T3, uint16",
  "}",
  "ClassDefFormat2, TABLE {",
  "uint16, 2",
  "Count, 1, MAXCOUNT",
  "Array, $T2, ClassRangeRecord",
  "}",
  "ClassRangeRecord, RECORD {",
  "GlyphID, 0, MAXGLYPHID",
  "GlyphID, $R1, MAXGLYPHID",
  "uint16",
  "}",
  "ClassDef, CLASS, , $B0 {",
  "ClassDefFormat1",
  "ClassDefFormat2",
  "}",
  "DeviceTableFormat1, TABLE {",
  "uint16",
  "uint16",
  "uint16, 1",
  "Array, $T2 - $T1+1, packedint2",
  "}",
  "DeviceTableFormat2, TABLE {",
  "uint16",
  "uint16",
  "uint16, 2",
  "Array, $T2 - $T1+1, packedint4",
  "}",
  "DeviceTableFormat3, TABLE {",
  "uint16",
  "uint16",
  "uint16, 3",
  "Array, $T2 - $T1+1, packedint8",
  "}",
  "DeviceTable, CLASS, , $B4 {",
  "DeviceTableFormat1",
  "DeviceTableFormat2",
  "DeviceTableFormat3",
  "}",
  "AnchorFormat1, TABLE {",
  "uint16, 1",
  "int16",
  "int16",
  "}",
  "AnchorFormat2, TABLE {",
  "uint16, 2",
  "int16",
  "int16",
  "uint16",
  "}",
  "AnchorFormat3, TABLE {",
  "uint16, 3",
  "int16",
  "int16",
  "Offset, DeviceTable",
  "Offset, DeviceTable",
  "}",
  "Anchor, CLASS, , $B0 {",
  "AnchorFormat1",
  "AnchorFormat2",
  "AnchorFormat3",
  "}",
  "SinglePosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "uint16, 0, 0x00FF",
  "Array, BitCount0F($T3), int16",
  "Array, BitCountF0($T3), Offset, DeviceTable, NOTNULL",
  "}",
  "SinglePosFormat2, TABLE {",
  "uint16, 2",
  "Offset, Coverage, NOTNULL",
  "uint16, 0, 0x00FF",
  "Count, CoverageCount($T2)",
  "Array, $T4, SinglePosFormat2ValueRecord",
  "}",
  "SinglePosFormat2ValueRecord, RECORD {",
  "Array, BitCount0F($T3), int16",
  "Array, BitCountF0($T3), Offset, DeviceTable, NOTNULL",
  "}",
  "PairPosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "uint16, 0, 0x00FF",
  "uint16, 0, 0x00FF",
  "Count, CoverageCount($T2)",
  "Array, $T5, Offset, PairSet, NOTNULL, $T3, $T4",
  "}",
  "PairSet, TABLE, 2 {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, PairValueRecord",
  "}",
  "PairValueRecord, RECORD {",
  "GlyphID, 0, MAXGLYPHID",
  "Array, BitCount0F($P1), int16",
  "Array, BitCountF0($P1), Offset, DeviceTable, NOTNULL",
  "Array, BitCount0F($P2), int16",
  "Array, BitCountF0($P2), Offset, DeviceTable, NOTNULL",
  "}",
  "PairPosFormat2, TABLE {",
  "uint16, 2",
  "Offset, Coverage, NOTNULL",
  "uint16, 0, 0x00FF",
  "uint16, 0, 0x00FF",
  "Offset, ClassDef, NOTNULL",
  "Offset, ClassDef, NOTNULL",
  "Count, ClassCount($T5)",
  "Count, ClassCount($T6)",
  "Array, $T7, PairPosFormat2Class1Record",
  "}",
  "PairPosFormat2Class1Record, RECORD {",
  "Array, $T8, PairPosFormat2ClassRecord",
  "}",
  "PairPosFormat2ClassRecord, RECORD {",
  "Array, BitCount0F($T3), int16",
  "Array, BitCountF0($T3), Offset, DeviceTable, NOTNULL",
  "Array, BitCount0F($T4), int16",
  "Array, BitCountF0($T4), Offset, DeviceTable, NOTNULL",
  "}",
  "CursivePosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Count, CoverageCount($T2)",
  "Array, $T3, EntryExitRecord",
  "}",
  "EntryExitRecord, RECORD {",
  "Offset, Anchor",
  "Offset, Anchor",
  "}",
  "MarkBasePosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Offset, Coverage, NOTNULL",
  "Count, 1, MAXCOUNT",
  "Offset, MarkArray, NOTNULL, $T2",
  "Offset, BaseArray, NOTNULL, $T3, $T4",
  "}",
  "MarkArray, TABLE, 1 {",
  "Count, CoverageCount($P1)",
  "Array, $T1, MarkRecord",
  "}",
  "MarkRecord, RECORD {",
  "uint16",
  "Offset, Anchor, NOTNULL",
  "}",
  "BaseArray, TABLE, 2 {",
  "Count, CoverageCount($P1)",
  "Array, $T1, BaseRecord",
  "}",
  "BaseRecord, RECORD{",
  "Array, $P2, Offset, Anchor, NOTNULL",
  "}",
  "MarkLigPosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Offset, Coverage, NOTNULL",
  "Count, 1, MAXCOUNT",
  "Offset, MarkArray, NOTNULL, $T2",
  "Offset, LigatureArray, NOTNULL, $T3, $T4",
  "}",
  "LigatureArray, TABLE, 2 {",
  "Count, CoverageCount($P1)",
  "Array, $T1, Offset, LigatureAttach, NOTNULL, $P2",
  "}",
  "LigatureAttach, TABLE, 1 {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, ComponentRecord",
  "}",
  "ComponentRecord, RECORD {",
  "Array, $P1, Offset, Anchor",
  "}",
  "MarkMarkPosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Offset, Coverage, NOTNULL",
  "Count, 1, MAXCOUNT",
  "Offset, MarkArray, NOTNULL, $T2",
  "Offset, Mark2Array, NOTNULL, $T3, $T4",
  "}",
  "Mark2Array, TABLE, 2 {",
  "Count, CoverageCount($P1)",
  "Array, $T1, Mark2Record",
  "}",
  "Mark2Record, RECORD {",
  "Array, $P2, Offset, Anchor, NOTNULL",
  "}",
  "PosTable, CLASS, 1, $P1 {",
  "SinglePosClass",
  "PairPosClass",
  "CursivePosClass",
  "MarkBasePosClass",
  "MarkLigPosClass",
  "MarkMarkPosClass",
  "}",
  "SinglePosClass, CLASS, , $B0 {",
  "SinglePosFormat1",
  "SinglePosFormat2",
  "}",
  "PairPosClass, CLASS, , $B0 {",
  "PairPosFormat1",
  "PairPosFormat2",
  "}",
  "CursivePosClass, CLASS, , $B0 {",
  "CursivePosFormat1",
  "}",
  "MarkBasePosClass, CLASS, , $B0 {",
  "MarkBasePosFormat1",
  "}",
  "MarkLigPosClass, CLASS, , $B0 {",
  "MarkLigPosFormat1",
  "}",
  "MarkMarkPosClass, CLASS, , $B0 {",
  "MarkMarkPosFormat1",
  "}",
  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\gposfmt.c ===
/* Copyright 1990-1997. Microsoft Corporation. */
#include "typedefs.h"  /* for Far declaration in ttofmt.h header */
#include "ttofmt.h"
/* from TTOGPOS.FMT ver 1.3 */

char * g_GPOSFmt[] = {
  "DEFINE ZERO=0",
  "DEFINE MAXCOUNT=0xFFFF",
  "GPOSHeader, HEAD {",
  "fixed32, 0x00010000",
  "Offset, ScriptList, NOTNULL",
  "Offset, FeatureList, NOTNULL",
  "Offset, LookupList, NOTNULL",
  "}",
  "ScriptList, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, ScriptRecord",
  "}",
  "ScriptRecord, RECORD {",
  "Tag",
  "Offset, Script, NOTNULL",
  "}",
  "Script, TABLE {",
  "Offset, LangSys",
  "Count",
  "Array, $T2, LangSysRecord",
  "}",
  "LangSysRecord, RECORD {",
  "Tag",
  "Offset, LangSys, NOTNULL",
  "}",
  "LangSys, TABLE {",
  "Offset, LookupOrder, NULL",
  "GPOSFeatureIndex",
  "Count, 0, MAXFEATURECOUNT",
  "Array, $T3, GPOSFeatureIndex, 0, MAXFEATURECOUNT-1",
  "}",
  "LookupOrder, TABLE {",
  "int16",
  "}",
  "FeatureList, TABLE {",
  "Count, 1, MAXFEATURECOUNT",
  "Array, $T1, FeatureRecord : $IGPOSFeatureIndex",
  "}",
  "FeatureRecord, RECORD {",
  "Tag",
  "Offset, Feature, NOTNULL",
  "}",
  "Feature, TABLE {",
  "Offset, FeatureParams, NULL",
  "Count, 1, MAXLOOKUPCOUNT",
  "Array, $T2, GPOSLookupIndex, 0, MAXLOOKUPCOUNT-1",
  "}",
  "FeatureParams, TABLE {",
  "uint16",
  "}",
  "LookupList, TABLE {",
  "Count, 1, MAXLOOKUPCOUNT",
  "Array, $T1, Offset, Lookup, NOTNULL: $IGPOSLookupIndex",
  "}",
  "Lookup, TABLE {",
  "uint16, 1, 7",
  "uint16",
  "Count, 1, MAXCOUNT",
  "Array, $T3, Offset, PosTable, NOTNULL, $T1",
  "}",
  "CoverageFormat1, TABLE {",
  "uint16, 1",
  "Count, 1, MAXCOUNT",
  "Array, $T2, GlyphID, 0, MAXGLYPHID",
  "}",
  "CoverageFormat2, TABLE {",
  "uint16, 2",
  "Count, 1, MAXCOUNT",
  "Array, $T2, RangeRecord",
  "}",
  "RangeRecord, RECORD {",
  "GlyphID, 0, MAXGLYPHID",
  "GlyphID, $R1, MAXGLYPHID",
  "uint16, CheckRangeRecord()",
  "}",
  "Coverage, CLASS, , $B0 {",
  "CoverageFormat1",
  "CoverageFormat2",
  "}",
  "ClassDefFormat1, TABLE {",
  "uint16, 1",
  "GlyphID, 0, MAXGLYPHID",
  "Count, 1, MAXGLYPHID",
  "Array, $T3, uint16",
  "}",
  "ClassDefFormat2, TABLE {",
  "uint16, 2",
  "Count, 1, MAXCOUNT",
  "Array, $T2, ClassRangeRecord",
  "}",
  "ClassRangeRecord, RECORD {",
  "GlyphID, 0, MAXGLYPHID",
  "GlyphID, $R1, MAXGLYPHID",
  "uint16",
  "}",
  "ClassDef, CLASS, , $B0 {",
  "ClassDefFormat1",
  "ClassDefFormat2",
  "}",
  "DeviceTableFormat1, TABLE {",
  "uint16",
  "uint16",
  "uint16, 1",
  "Array, $T2 - $T1+1, packedint2",
  "}",
  "DeviceTableFormat2, TABLE {",
  "uint16",
  "uint16",
  "uint16, 2",
  "Array, $T2 - $T1+1, packedint4",
  "}",
  "DeviceTableFormat3, TABLE {",
  "uint16",
  "uint16",
  "uint16, 3",
  "Array, $T2 - $T1+1, packedint8",
  "}",
  "DeviceTable, CLASS, , $B4 {",
  "DeviceTableFormat1",
  "DeviceTableFormat2",
  "DeviceTableFormat3",
  "}",
  "AnchorFormat1, TABLE {",
  "uint16, 1",
  "int16",
  "int16",
  "}",
  "AnchorFormat2, TABLE {",
  "uint16, 2",
  "int16",
  "int16",
  "uint16",
  "}",
  "AnchorFormat3, TABLE {",
  "uint16, 3",
  "int16",
  "int16",
  "Offset, DeviceTable",
  "Offset, DeviceTable",
  "}",
  "Anchor, CLASS, , $B0 {",
  "AnchorFormat1",
  "AnchorFormat2",
  "AnchorFormat3",
  "}",
  "SinglePosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "uint16, 0, 0x00FF",
  "Array, BitCount0F($T3), int16",
  "Array, BitCountF0($T3), Offset, DeviceTable, NOTNULL",
  "}",
  "SinglePosFormat2, TABLE {",
  "uint16, 2",
  "Offset, Coverage, NOTNULL",
  "uint16, 0, 0x00FF",
  "Count, CoverageCount($T2)",
  "Array, $T4, SinglePosFormat2ValueRecord",
  "}",
  "SinglePosFormat2ValueRecord, RECORD {",
  "Array, BitCount0F($T3), int16",
  "Array, BitCountF0($T3), Offset, DeviceTable, NOTNULL",
  "}",
  "PairPosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "uint16, 0, 0x00FF",
  "uint16, 0, 0x00FF",
  "Count, CoverageCount($T2)",
  "Array, $T5, Offset, PairSet, NOTNULL, $T3, $T4",
  "}",
  "PairSet, TABLE, 2 {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, PairValueRecord",
  "}",
  "PairValueRecord, RECORD {",
  "GlyphID, 0, MAXGLYPHID",
  "Array, BitCount0F($P1), int16",
  "Array, BitCountF0($P1), Offset, DeviceTable, NOTNULL",
  "Array, BitCount0F($P2), int16",
  "Array, BitCountF0($P2), Offset, DeviceTable, NOTNULL",
  "}",
  "PairPosFormat2, TABLE {",
  "uint16, 2",
  "Offset, Coverage, NOTNULL",
  "uint16, 0, 0x00FF",
  "uint16, 0, 0x00FF",
  "Offset, ClassDef, NOTNULL",
  "Offset, ClassDef, NOTNULL",
  "Count, ClassCount($T5)",
  "Count, ClassCount($T6)",
  "Array, $T7, PairPosFormat2Class1Record",
  "}",
  "PairPosFormat2Class1Record, RECORD {",
  "Array, $T8, PairPosFormat2ClassRecord",
  "}",
  "PairPosFormat2ClassRecord, RECORD {",
  "Array, BitCount0F($T3), int16",
  "Array, BitCountF0($T3), Offset, DeviceTable, NOTNULL",
  "Array, BitCount0F($T4), int16",
  "Array, BitCountF0($T4), Offset, DeviceTable, NOTNULL",
  "}",
  "CursivePosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Count, CoverageCount($T2)",
  "Array, $T3, EntryExitRecord",
  "}",
  "EntryExitRecord, RECORD {",
  "Offset, Anchor",
  "Offset, Anchor",
  "}",
  "MarkBasePosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Offset, Coverage, NOTNULL",
  "Count, 1, MAXCOUNT",
  "Offset, MarkArray, NOTNULL, $T2",
  "Offset, BaseArray, NOTNULL, $T3, $T4",
  "}",
  "MarkArray, TABLE, 1 {",
  "Count, CoverageCount($P1)",
  "Array, $T1, MarkRecord",
  "}",
  "MarkRecord, RECORD {",
  "uint16",
  "Offset, Anchor, NOTNULL",
  "}",
  "BaseArray, TABLE, 2 {",
  "Count, CoverageCount($P1)",
  "Array, $T1, BaseRecord",
  "}",
  "BaseRecord, RECORD{",
  "Array, $P2, Offset, Anchor, NOTNULL",
  "}",
  "MarkLigPosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Offset, Coverage, NOTNULL",
  "Count, 1, MAXCOUNT",
  "Offset, MarkArray, NOTNULL, $T2",
  "Offset, LigatureArray, NOTNULL, $T3, $T4",
  "}",
  "LigatureArray, TABLE, 2 {",
  "Count, CoverageCount($P1)",
  "Array, $T1, Offset, LigatureAttach, NOTNULL, $P2",
  "}",
  "LigatureAttach, TABLE, 1 {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, ComponentRecord",
  "}",
  "ComponentRecord, RECORD {",
  "Array, $P1, Offset, Anchor",
  "}",
  "MarkMarkPosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Offset, Coverage, NOTNULL",
  "Count, 1, MAXCOUNT",
  "Offset, MarkArray, NOTNULL, $T2",
  "Offset, Mark2Array, NOTNULL, $T3, $T4",
  "}",
  "Mark2Array, TABLE, 2 {",
  "Count, CoverageCount($P1)",
  "Array, $T1, Mark2Record",
  "}",
  "Mark2Record, RECORD {",
  "Array, $P2, Offset, Anchor, NOTNULL",
  "}",
  "PosLookupRecord, RECORD {",
  "uint16",
  "GPOSLookupIndex, 0, MAXLOOKUPCOUNT-1",
  "}",
  "ContextPosFormat1, TABLE {",
  "uint16, 1",
  "Offset, Coverage, NOTNULL",
  "Count, CoverageCount($T2)",
  "Array, $T3, Offset, PosRuleSet, NOTNULL",
  "}",
  "PosRuleSet, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, Offset, PosRule, NOTNULL",
  "}",
  "PosRule, TABLE {",
  "Count, 2, MAXCOUNT",
  "Count, 1, MAXCOUNT",
  "Array, $T1-1, GlyphID, 0, MAXGLYPHID : DelNone",
  "Array, $T2, PosLookupRecord",
  "}",
  "ContextPosFormat2, TABLE {",
  "uint16, 2",
  "Offset, Coverage, NOTNULL",
  "Offset, ClassDef, NOTNULL",
  "Count, ClassCount($T3)",
  "Array, $T4, Offset, PosClassSet",
  "}",
  "PosClassSet, TABLE {",
  "Count, 1, MAXCOUNT",
  "Array, $T1, Offset, PosClassRule",
  "}",
  "PosClassRule, TABLE, 1 {",
  "Count, 2, MAXCOUNT",
  "Count, 1, MAXCOUNT",
  "Array, $T1-1, uint16",
  "Array, $T2, PosLookupRecord",
  "}",
  "ContextPosFormat3, TABLE {",
  "uint16, 3",
  "Count, 2, MAXCOUNT",
  "Count, 1, MAXCOUNT",
  "Array, $T2, Offset, Coverage, NOTNULL: DelNone",
  "Array, $T3, PosLookupRecord : DelNone",
  "}",
  "PosTable, CLASS, 1, $P1 {",
  "SinglePosClass",
  "PairPosClass",
  "CursivePosClass",
  "MarkBasePosClass",
  "MarkLigPosClass",
  "MarkMarkPosClass",
  "ContextPosClass",
  "}",
  "SinglePosClass, CLASS, , $B0 {",
  "SinglePosFormat1",
  "SinglePosFormat2",
  "}",
  "PairPosClass, CLASS, , $B0 {",
  "PairPosFormat1",
  "PairPosFormat2",
  "}",
  "CursivePosClass, CLASS, , $B0 {",
  "CursivePosFormat1",
  "}",
  "MarkBasePosClass, CLASS, , $B0 {",
  "MarkBasePosFormat1",
  "}",
  "MarkLigPosClass, CLASS, , $B0 {",
  "MarkLigPosFormat1",
  "}",
  "MarkMarkPosClass, CLASS, , $B0 {",
  "MarkMarkPosFormat1",
  "}",
  "ContextPosClass, CLASS, , $B0 {",
  "ContextPosFormat1",
  "ContextPosFormat2",
  "ContextPosFormat3",
  "}",
  0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\makeglst.h ===
/*
  * MakeGLst.h: Interface file for MakeGLst.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */
  
#ifndef MAKEGLIST_DOT_H_DEFINED
#define MAKEGLIST_DOT_H_DEFINED        

int16 MakeKeepGlyphList(
TTFACC_FILEBUFFERINFO * pInputBufferInfo,
CONST uint16 usListType, /* 0 = character list, 1 = glyph list */
CONST uint16 usPlatform,
CONST uint16 usEncoding,
CONST uint16 *pusKeepCharCodeList,
CONST uint16 usCharListCount,
uint8 *puchKeepGlyphList, /* pointer to an array of characters representing glyphs 0-usGlyphListCount. */
CONST uint16 usGlyphListCount,
uint16 *pusMaxGlyphIndexUsed,
uint16 *pusGlyphKeepCount
);
#endif /* MAKEGLIST_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\makeglst.c ===
/***************************************************************************
 * module: MakeGLst.C
 *
 * author: Louise Pathe [v-lpathe]
 * date:   Nov 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * fill in an array of chars with 1 and 0 for keep and don't keep specific
 * glyphs. the index into the array corresponds to the glyph index
 * use data in GSUB, JSTF, BASE and composite glyphs to expand beyond list
 * of characters given by client to include all related glyphs that may
 * be needed (automap).
 *
 **************************************************************************/
#if 0
Read this email thread in reverse order to see why the ~Backward Compatibility~ hack is needed in this code.
Because of the NT hack, you could create a document on an NT machine which would include ONLY the unicode 0xB7. 
If a document is created on an NT machine, the unicode 0xB7 will be in the list of characters to keep. 
The resulting font, when viewed on an Windows95 machine, will show a missing character for WinAnsi character 0xB7, 
as on that system, the unicode 0x2219 character is required, and the font will not contain it.    
----------
From: 	Bodin Dresevic
Sent: 	Thursday, April 25, 1996 8:34 AM
To: 	K.D. Chang (RhoTech); David Michael Silver; Paul Linnerud; Lori Brownell; Greg Hitchcock
Cc: 	Louise Pathe (Science Information Associ
Subject: 	RE: Middle Dot

I hate to revisit this issue. 

NT has the following hack in the tt font driver which I put in to be win 3.1 compatible. 
If a font claims to have both unicode code point b7 and 2219 supported through the cmap 
table we do nothing, that is we report the set of supported glyphs to the engine as it is in the cmap.  
However, if the font does not have unicode code point b7 in its cmap table, but it does 
have 2219, then the font driver lies to the engine that unicode b7 is actually supported by the font. 
For such a font, the request to display unicode point b7 results in displaying 2219. I do not remember
which app was broken because we did not have this behavior before. 
Previously we used to treat all fonts the same, that is we would report to the engine the set of 
supported glyphs exactly as in the cmap table. 
bodin

----------
From:  Greg Hitchcock
Sent:  Wednesday, April 24, 1996 6:36 PM
To:  K.D. Chang (RhoTech); David Michael Silver; Paul Linnerud; Lori Brownell
Cc:  Louise Pathe (Science Information Associ; Bodin Dresevic
Subject:  RE: Middle Dot

I guess I can understand keeping the .nls file the same for compatibility reasons, but I'm not exactly clear as to why it is "correct the way it is."
For Win 3.1, Win 95, & Win NT,  the character WinANSI 0xB7 has been remapped to U+2219. To me, this was a redefinition of WinANSI that was comparable 
to the work we did when we added the DTP characters in the 0x80+ range of WinANSI.

GregH

----------
From:  Lori Brownell
Sent:  Tuesday, April 23, 1996 8:41 AM
To:  K.D. Chang (RhoTech); David Michael Silver; Greg Hitchcock; Paul Linnerud
Cc:  Louise Pathe (Science Information Associ
Subject:  RE: Middle Dot

The .nls file will not change because it's correct the way that it is.  If you wish to have fonts have the glyph associated with U+00B7 be the bullet instead of the middle dot, that is the typography teams decision.

----------
From: 	Paul Linnerud
Sent: 	jeudi 18 avril 1996 11:10 
To: 	K.D. Chang (RhoTech); Lori Brownell; David Michael Silver; Greg Hitchcock
Cc: 	Louise Pathe (Science Information Associ; Paul Linnerud
Subject: 	RE: Middle Dot

Any resolution with respect to what NT will do about this?

Thanks,
Paul

----------
From: 	Greg Hitchcock
Sent: 	Friday, April 05, 1996 8:11 PM
To: 	K.D. Chang (RhoTech); Paul Linnerud; Lori Brownell; David Michael Silver
Cc: 	Louise Pathe (Science Information Associ
Subject: 	RE: Middle Dot

This goes back actually to February 1992,  right before we shipped Win 3.1
The Middle Dot is actually an accent character, used for example with the L dot. As such, it is positioned to the right of the glyph box. In the previous bitmap fonts that Windows shipped, there was a bullet in that position. Word used (uses) this bullet to display space characters when in full view mode, and with the mid dot, it collided with other glyphs at small sizes.
DavidW, EliK, and myself made the decision to remap in Windows to U+2219 and redefine WinAnsi 0xB7 to the bullet. It has been that way ever since.

GregH

----------
From:  David Michael Silver
Sent:  Friday, April 05, 1996 11:23 AM
To:  K.D. Chang (RhoTech); Greg Hitchcock; Paul Linnerud; Lori Brownell
Cc:  Louise Pathe (Science Information Associ
Subject:  RE: Middle Dot

0xB7 is the bullet - changed after bugs reported (by the word team I believe).  JohnWin is the one who instansiated the chagne, you should check with him where the info came from.

----------
From: 	Lori Brownell
Sent: 	Friday, 05 April, 1996 10:44 AM
To: 	K.D. Chang (RhoTech); Greg Hitchcock; Paul Linnerud; David Michael Silver
Cc: 	Louise Pathe (Science Information Associ
Subject: 	RE: Middle Dot

It shouldn't and if it does, then it's a Win95 GDI bug.

----------
From: 	Paul Linnerud
Sent: 	Friday, April 05, 1996 10:34 AM
To: 	K.D. Chang (RhoTech); Greg Hitchcock
Cc: 	Lori Brownell; Paul Linnerud; Louise Pathe (Science Information Associ
Subject: 	FW: Middle Dot

I know that Windows 95 WinANSI defines 0xb7 as U+2219. If you output text with the "A" functions, you get this mapping. 

Thanks,
Paul
----------
From: 	K.D. Chang (RhoTech)
Sent: 	Friday, April 05, 1996 10:14 AM
To: 	Paul Linnerud
Cc: 	Lori Brownell
Subject: 	RE: Middle Dot

Unicode U+00a0 thru U+00ff are defined the same as ANSI  0xa0 thru 0xff (see Unicode Standard Ver. 1.0 Vol. 1 Page 522 - 524).

Can you point out where WinANSI defines 0xb7 as Unicode U+2219 ?

thanks, kd

----------
From: 	Paul Linnerud
Sent: 	Thursday, April 04, 1996 3:58 PM
To: 	Lori Brownell
Cc: 	Greg Hitchcock; Louise Pathe (Science Information Associ
Subject: 	Middle Dot

For code page 1252, the nls file defines code point 0xb7 as Unicode 0x00b7. WinANSI actually defines 0xb7 as Unicode 0x2219. Could you please look into having the nls file changed. 

Thanks,
PaulLi

/**************************************************************************/

#endif

#include <stdlib.h>	 /* for min and max functions */

#include "typedefs.h"
#include "ttfacc.h"
#include "ttfcntrl.h"
#include "ttff.h"
#include "ttftabl1.h"
#include "ttftable.h"
#include "ttmem.h"
#include "makeglst.h"
#include "automap.h"
#include "ttferror.h" /* for error codes */
#include "ttfdelta.h"

#define WIN_ANSI_MIDDLEDOT 0xB7
#define WIN_ANSI_BULLET 0x2219

/* ---------------------------------------------------------------------- */
int16 MakeKeepGlyphList(
TTFACC_FILEBUFFERINFO * pInputBufferInfo, /* ttfacc info */
CONST uint16 usListType, /* 0 = character list, 1 = glyph list */
CONST uint16 usPlatform, /* cmap platform to look for */
CONST uint16 usEncoding, /* cmap encoding to look for */
CONST uint16 *pusKeepCharCodeList, /* list of chars to keep - from client */
CONST uint16 usCharListCount,	   /* count of list of chars to keep */
uint8 *puchKeepGlyphList, /* pointer to an array of chars representing glyphs 0-usGlyphListCount. */
CONST uint16 usGlyphListCount, /* count of puchKeepGlyphList array */
uint16 *pusMaxGlyphIndexUsed,
uint16 *pusGlyphKeepCount
)
{
uint16 i,j;
uint16 usGlyphIdx;
FORMAT4_SEGMENTS * Format4Segments=NULL;	/* pointer to Format4Segments array */
GLYPH_ID * GlyphId=NULL;	/* pointer to GlyphID array - for Format4 subtable */
CMAP_FORMAT6 CmapFormat6;	  /* cmap subtable headers */
CMAP_FORMAT4 CmapFormat4;
CMAP_FORMAT0 CmapFormat0;
MAXP Maxp;	/* local copy */
HEAD Head;	/* local copy */
uint16 usnComponents;
uint16 usnMaxComponents;
uint16 *pausComponents = NULL;
uint16 usnComponentDepth = 0;	
uint16 usIdxToLocFmt;
uint32 ulLocaOffset;
uint32 ulGlyfOffset;
uint16 *glyphIndexArray; /* for format 6 cmap subtables */
int16 errCode=NO_ERROR;
uint16 usFoundEncoding;
int16 KeepBullet = FALSE;
int16 FoundBullet = FALSE;
uint16 fKeepFlag; 
uint16 usGlyphKeepCount;
uint16 usMaxGlyphIndexUsed;

	if ( ! GetHead( pInputBufferInfo, &Head ))
		return( ERR_MISSING_HEAD );
	usIdxToLocFmt = Head.indexToLocFormat;

	if ( ! GetMaxp(pInputBufferInfo, &Maxp))
		return( ERR_MISSING_MAXP );
	
	if ((ulLocaOffset = TTTableOffset( pInputBufferInfo, LOCA_TAG )) == DIRECTORY_ERROR)
		return (ERR_MISSING_LOCA);

	if ((ulGlyfOffset = TTTableOffset( pInputBufferInfo, GLYF_TAG )) == DIRECTORY_ERROR)
		return (ERR_MISSING_GLYF);

	usnMaxComponents = Maxp.maxComponentElements * Maxp.maxComponentDepth; /* maximum total possible */
	pausComponents = Mem_Alloc(usnMaxComponents * sizeof(uint16));
	if (pausComponents == NULL)
		return(ERR_MEM);

	/* fill in array of glyphs to keep.  Glyph 0 is the missing chr glyph,
	glyph 1 is the NULL glyph. */
	puchKeepGlyphList[ 0 ] = 1;
	puchKeepGlyphList[ 1 ] = 1;
	puchKeepGlyphList[ 2 ] = 1;

	if (usListType == TTFDELTA_GLYPHLIST)
	{
		for ( i = 0; i < usCharListCount; i++ )
			if (pusKeepCharCodeList[ i ] < usGlyphListCount)  /* don't violate array ! */
				puchKeepGlyphList[ pusKeepCharCodeList[ i ] ] = 1;
	}
	else
	{
		if ((errCode = ReadAllocCmapFormat4( pInputBufferInfo, usPlatform, usEncoding, &usFoundEncoding, &CmapFormat4, &Format4Segments, &GlyphId )) == NO_ERROR)	 /* found a Format4 Cmap */
		{

			for ( i = 0; i < usCharListCount; i++ )
			{
				usGlyphIdx = GetGlyphIdx( pusKeepCharCodeList[ i ], Format4Segments, (uint16)(CmapFormat4.segCountX2 / 2), GlyphId );
				if (usGlyphIdx != 0 && usGlyphIdx != INVALID_GLYPH_INDEX && usGlyphIdx < usGlyphListCount)
				{
					/* If the chr code exists, keep the glyph and its components.  Also
					account for this in the MinMax chr code global. */
					puchKeepGlyphList[ usGlyphIdx ] = 1;
					if (pusKeepCharCodeList[ i ] == WIN_ANSI_MIDDLEDOT) /* ~Backward Compatibility~! See comment at top of file */
						KeepBullet = TRUE;
					if (pusKeepCharCodeList[ i ] == WIN_ANSI_BULLET) /* ~Backward Compatibility~! See comment at top of file */
						FoundBullet = TRUE;
				}
			}
			/* ~Backward Compatibility~! See comment at top of file */
			if ((usPlatform == TTFSUB_MS_PLATFORMID && usFoundEncoding == TTFSUB_UNICODE_CHAR_SET &&
				KeepBullet && !FoundBullet))  /* need to add that bullet into the list of CharCodes to keep, and glyphs to keep */
			{
				usGlyphIdx = GetGlyphIdx( WIN_ANSI_BULLET, Format4Segments, (uint16)(CmapFormat4.segCountX2 / 2), GlyphId );
				if (usGlyphIdx != 0 && usGlyphIdx != INVALID_GLYPH_INDEX && usGlyphIdx < usGlyphListCount)
				{
					puchKeepGlyphList[ usGlyphIdx ] = 1;  /* we are keeping 0xB7, so we must make sure to keep 0x2219 */
				}
			}
			FreeCmapFormat4( Format4Segments, GlyphId );
		}
		else if ( (errCode = ReadCmapFormat0( pInputBufferInfo, usPlatform, usEncoding, &usFoundEncoding, &CmapFormat0)) == NO_ERROR)	 /* found a Format0 Cmap */
 		{
	 		for (i = 0; i < usCharListCount; ++i)
			{
				if (pusKeepCharCodeList[ i ] < CMAP_FORMAT0_ARRAYCOUNT)
				{
			 		usGlyphIdx = CmapFormat0.glyphIndexArray[pusKeepCharCodeList[ i ]];
					if (usGlyphIdx < usGlyphListCount)
						puchKeepGlyphList[ usGlyphIdx ] = 1;	
				}
			}
		}
		else if ( (errCode = ReadAllocCmapFormat6( pInputBufferInfo, usPlatform, usEncoding, &usFoundEncoding, &CmapFormat6, &glyphIndexArray)) == NO_ERROR)	 /* found a Format6 Cmap */
 		{
		uint16 firstCode = CmapFormat6.firstCode;

	 		for (i = 0; i < usCharListCount; ++i)
			{
				if 	((pusKeepCharCodeList[ i ] >= firstCode) && 
					 (pusKeepCharCodeList[ i ] < firstCode + CmapFormat6.entryCount))
				{
			 		usGlyphIdx = glyphIndexArray[pusKeepCharCodeList[ i ] - firstCode];
					if (usGlyphIdx < usGlyphListCount)
						puchKeepGlyphList[ usGlyphIdx ] = 1;	
				}
			}
			FreeCmapFormat6(glyphIndexArray);
		}
	}
	*pusGlyphKeepCount = 0;
	*pusMaxGlyphIndexUsed = 0;
	for (fKeepFlag = 1; errCode == NO_ERROR ; ++fKeepFlag)
	{
		usGlyphKeepCount = 0;
		usMaxGlyphIndexUsed = 0;
		/* Now gather up any components referenced by the list of glyphs to keep and TTO glyphs */
		for (usGlyphIdx = 0; usGlyphIdx < usGlyphListCount; ++usGlyphIdx) /* gather up any components */
		{
			if (puchKeepGlyphList[ usGlyphIdx ] == fKeepFlag)
			{
				usMaxGlyphIndexUsed = usGlyphIdx;
				++ (usGlyphKeepCount);

				GetComponentGlyphList( pInputBufferInfo, usGlyphIdx, &usnComponents, pausComponents, usnMaxComponents, &usnComponentDepth, 0, usIdxToLocFmt, ulLocaOffset, ulGlyfOffset);
				for ( j = 0; j < usnComponents; j++ )	/* check component value before assignment */
				{
					if ((pausComponents[ j ] < usGlyphListCount) && ((puchKeepGlyphList)[ pausComponents[ j ] ] == 0))
						(puchKeepGlyphList)[ pausComponents[ j ] ] = fKeepFlag + 1;  /* so it will be grabbed next time around */
				}
			}
		}
		*pusGlyphKeepCount += usGlyphKeepCount;
		*pusMaxGlyphIndexUsed = max(usMaxGlyphIndexUsed, *pusMaxGlyphIndexUsed);
		if (!usGlyphKeepCount) /* we didn't find any more */
			break;

		/* Now gather up any glyphs referenced by GSUB, GPOS, JSTF or BASE tables */
		if ((errCode = TTOAutoMap(pInputBufferInfo, puchKeepGlyphList, usGlyphListCount, fKeepFlag)) != NO_ERROR)  /* Add to the list of KeepGlyphs based on data from GSUB, BASE and JSTF table */
			break;

		if ((errCode = MortAutoMap(pInputBufferInfo, puchKeepGlyphList, usGlyphListCount, fKeepFlag)) != NO_ERROR)  /* Add to the list of KeepGlyphs based on data from Mort table */
			break;

	}
	Mem_Free(pausComponents);
	
	return errCode;
}
/* ---------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\mergsbit.h ===
/*
  * mergsbit.h: Interface file for Mergsbit.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */
  
#ifndef MERGSBIT_DOT_H_DEFINED
#define MERGSBIT_DOT_H_DEFINED   

int16 MergeEblcEbdtTables(TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDestOffset,					  /* offset into dest buffer where to write data */
						uint32 *pulEblcLength,
						uint32 *pulEbdtOffset,
						uint32 *pulEbdtLength,				      /* number of bytes written to the EBDT table Output buffer */
						char * szEBLCTag,						 /* for use with bloc  */
						char * szEBDTTag);						 /* for use with bdat */

#endif	/* MERGSBIT_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\modcmap.h ===
/*
  * ModCmap.h: Interface file for ModCmap.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */
  
#ifndef MODCMAP_DOT_H_DEFINED
#define MODCMAP_DOT_H_DEFINED        

int16 ModCmap(CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
				TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
				uint8 *puchKeepGlyphList, /* glyphs to keep - boolean */
				uint16 usGlyphCount,  /* count of puchKeepGlyphList */
				uint16 * OS2MinChr,	 /* for setting in the OS/2 table */
				uint16 * OS2MaxChr,	 /* for setting in the OS/2 table */
				uint32 *pulNewOutOffset );

#endif	/* MODCMAP_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\mergsbit.c ===
/***************************************************************************
 * module: MergSbit.C
 *
 * author: Louise Pathe [v-lpathe]
 * date:   Nov 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * TTFSub library entry point MergeDeltaTTF()
 *
 **************************************************************************/

/* Inclusions ----------------------------------------------------------- */
#include <stdlib.h>
#include <string.h> /* for memset */

#include "typedefs.h"
#include "ttff.h"
#include "ttfacc.h"
#include "ttfcntrl.h"
#include "ttftabl1.h"
#include "ttferror.h"
#include "ttfmerge.h"
#include "mergsbit.h"
#include "ttmem.h"
#include "util.h"
#include "ttftable.h"
#include "ttfdcnfg.h"

/* ------------------------------------------------------------------- */
typedef struct {
	uint32 ulNewImageDataOffset;
	uint32 ulImageDataLength; /* length of this block of data */
	uint16 usImageFormat;
	uint16 usIndexFormat;
} ImageDataBlock;  /* info on the Image Data, for shared image data */

typedef struct {
	uint32 ulOldOffset;
	ImageDataBlock ImageDataBlock;
} GlyphOffsetRecord;

typedef struct glyphoffsetrecordkeeper *PGLYPHOFFSETRECORDKEEPER;	 
typedef struct glyphoffsetrecordkeeper GLYPHOFFSETRECORDKEEPER;	 

struct glyphoffsetrecordkeeper	  /* housekeeping structure */
{  
	GlyphOffsetRecord *pGlyphOffsetArray;
	uint32 ulOffsetArrayLen;
	uint32 ulNextArrayIndex;
};

/* ------------------------------------------------------------------- */
PRIVATE int16 RecordGlyphOffset(PGLYPHOFFSETRECORDKEEPER pKeeper, 
							   uint32 ulOldOffset, 
							   ImageDataBlock * pImageDataBlock)  /* record this block as being used */
{

	if (pKeeper->ulNextArrayIndex >= pKeeper->ulOffsetArrayLen)
	{
	 	pKeeper->pGlyphOffsetArray = (GlyphOffsetRecord *) Mem_ReAlloc(pKeeper->pGlyphOffsetArray, (pKeeper->ulOffsetArrayLen + 100) * sizeof(*(pKeeper->pGlyphOffsetArray)));
 		if (pKeeper->pGlyphOffsetArray == NULL)
			return ERR_MEM; /* ("EBLC: Not enough memory to allocate Offset Array."); */
        memset((char *)(pKeeper->pGlyphOffsetArray) + (sizeof(*(pKeeper->pGlyphOffsetArray)) * pKeeper->ulOffsetArrayLen), '\0', sizeof(*(pKeeper->pGlyphOffsetArray)) * 100); 
		pKeeper->ulOffsetArrayLen += 100;
	}
	pKeeper->pGlyphOffsetArray[pKeeper->ulNextArrayIndex].ulOldOffset = ulOldOffset;
	pKeeper->pGlyphOffsetArray[pKeeper->ulNextArrayIndex].ImageDataBlock.ulNewImageDataOffset = pImageDataBlock->ulNewImageDataOffset;
	pKeeper->pGlyphOffsetArray[pKeeper->ulNextArrayIndex].ImageDataBlock.ulImageDataLength =  pImageDataBlock->ulImageDataLength;
	pKeeper->pGlyphOffsetArray[pKeeper->ulNextArrayIndex].ImageDataBlock.usImageFormat = pImageDataBlock->usImageFormat;
	pKeeper->pGlyphOffsetArray[pKeeper->ulNextArrayIndex].ImageDataBlock.usIndexFormat = pImageDataBlock->usIndexFormat;
	++(pKeeper->ulNextArrayIndex);
	return NO_ERROR;
}

/* ------------------------------------------------------------------- */
PRIVATE uint32 LookupGlyphOffset(PGLYPHOFFSETRECORDKEEPER pKeeper, 
								uint32 ulOldOffset, 
								ImageDataBlock *pImageDataBlock)
{
uint32 i;

	for (i = 0; i < pKeeper->ulNextArrayIndex; ++i)
	{
	 	if (ulOldOffset == pKeeper->pGlyphOffsetArray[i].ulOldOffset)
		{
			pImageDataBlock->ulNewImageDataOffset = pKeeper->pGlyphOffsetArray[i].ImageDataBlock.ulNewImageDataOffset;
			pImageDataBlock->ulImageDataLength = pKeeper->pGlyphOffsetArray[i].ImageDataBlock.ulImageDataLength;
			pImageDataBlock->usImageFormat = pKeeper->pGlyphOffsetArray[i].ImageDataBlock.usImageFormat;
			pImageDataBlock->usIndexFormat = pKeeper->pGlyphOffsetArray[i].ImageDataBlock.usIndexFormat;
			return (TRUE);
		}
	}
	return(FALSE);
}
/* ------------------------------------------------------------------- */
PRIVATE int16 CopySbitSubTable(TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pSrcBufferInfo,   /* buffer Info */
						uint32 ulDestIndexSubTableOffset, /* absolute offset EBLC SubTable */ 
						uint32 ulSrcIndexSubTableOffset, 	 /* absolute offset EBLC Subtable */
						uint16 usGlyphCount,
						TTFACC_FILEBUFFERINFO *pEBDTBufferInfo,   /* buffer Info */
						uint32 ulDestImageDataOffset, /* offset into EBDT buffer */
						uint32 ulSrcEBDTOffset,
						GLYPHOFFSETRECORDKEEPER *pKeeper,  /* too keep track of multiply referenced glyph data */
						uint32 *pulEBLCBytesWritten,  /* set so caller can increment pointers */
						uint32 *pulEBDTBytesWritten) /* set so caller can increment pointers */
{
INDEXSUBHEADER	IndexSubHeader;
uint16		i;
uint32		ulOldImageDataOffset;
uint32		ulDestGlyphOffset;
uint32		ulCurrentImageDataOffset;  /* place where current IndexSubTable is pointing - usually NewImageDataOffset */
ImageDataBlock	ImageDataBlock;
uint16		usSparseGlyphCount;
uint32		ulSrcOffset, ulDestOffset;  /* for EBLC read/write */
BOOL		DoCopy = TRUE; /* copy glyph imgage data or not */ 
int16 errCode;
uint16 usBytesRead;
uint16 usBytesWritten;

	if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &IndexSubHeader, SIZEOF_INDEXSUBHEADER, INDEXSUBHEADER_CONTROL, ulSrcIndexSubTableOffset, &usBytesRead )) != NO_ERROR)
		return errCode;
	/* ulOffset += usBytesRead;   don't increment because we will read again */
	*pulEBLCBytesWritten = 0;
	*pulEBDTBytesWritten = 0;
	ulDestGlyphOffset = 0;
	ulOldImageDataOffset = IndexSubHeader.ulImageDataOffset;	  /* save the old one */
	ulCurrentImageDataOffset = ulDestImageDataOffset;
	if (LookupGlyphOffset(pKeeper, ulOldImageDataOffset, &ImageDataBlock) == FALSE)  /* glyph range not copied already */
	{   /* use the current last offset into glyph area */
		ImageDataBlock.ulNewImageDataOffset = ulCurrentImageDataOffset; 
		ImageDataBlock.ulImageDataLength = 0; /* will set this below */
		ImageDataBlock.usIndexFormat = IndexSubHeader.usIndexFormat;
		ImageDataBlock.usImageFormat = IndexSubHeader.usImageFormat;
	/*	if ((errCode = RecordGlyphOffset(pKeeper, ulOldImageDataOffset, &ImageDataBlock)) != NO_ERROR)  record this block as being used, below */
	/*		return errCode;	 */
	}
	else
	{
		if (ImageDataBlock.usImageFormat != IndexSubHeader.usImageFormat ) 
			return(NO_ERROR); /* ~ copy nothing */
		DoCopy = FALSE;   /* Copy the IndexSubTable, but don't copy the glyphs over */
		ulCurrentImageDataOffset = ImageDataBlock.ulNewImageDataOffset; /* need to set the pointers here */
	}

	/* For each of the five cases below we will:
		1. Read from File the structure and any attached arrays, translating to Intel format on the way. 
		2. return the length of the subtable to the caller, so additionalOffsetToIndex values
		   may be calculated.
    */
	ulSrcOffset = ulSrcIndexSubTableOffset;
	ulDestOffset = ulDestIndexSubTableOffset;
	switch (IndexSubHeader.usIndexFormat)
	{
		case 1:	   /* Error. Shouldn't get any of these from Create */
			return ERR_FORMAT;
		case 2:	
		{		 
			INDEXSUBTABLE2 IndexSubTable2;

			/* read the table entry */	
			if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &IndexSubTable2, SIZEOF_INDEXSUBTABLE2, INDEXSUBTABLE2_CONTROL, ulSrcOffset, &usBytesRead )) != NO_ERROR) 
					return errCode;
			IndexSubTable2.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */
			/* write the table entry */	
			if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &IndexSubTable2, SIZEOF_INDEXSUBTABLE2, INDEXSUBTABLE2_CONTROL, ulDestOffset, &usBytesWritten )) != NO_ERROR) 
				return errCode;
			ulDestOffset += usBytesWritten;
    		ulDestGlyphOffset = IndexSubTable2.ulImageSize*usGlyphCount;
			if (DoCopy)  /* we need to copy bytes for Glyph data */
			{
				if ((errCode = CopyBlockOver( pEBDTBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *)pSrcBufferInfo, IndexSubTable2.header.ulImageDataOffset,
							   ulSrcEBDTOffset + ulOldImageDataOffset,ulDestGlyphOffset)) != NO_ERROR) 
					return errCode;
			}
			break; 
		}
		case 3:	/* just like format 1, but with short offsets instead */
		{
			INDEXSUBTABLE3	IndexSubTable3;
			uint16		usOldGlyphOffset;	/* the old offset of the glyph */
			uint16		usNextGlyphOffset;	/* the offset of the glyph after this glyph, to calculate length */
			uint16		usNewGlyphOffset;	/* the new offset in the new Glyph table */
			uint16		usGlyphLength;

				if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &IndexSubTable3, SIZEOF_INDEXSUBTABLE3, INDEXSUBTABLE3_CONTROL, ulSrcOffset, &usBytesRead )) != NO_ERROR) 
					return errCode;
				ulSrcOffset += usBytesRead;
				IndexSubTable3.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */
				if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &IndexSubTable3, SIZEOF_INDEXSUBTABLE3, INDEXSUBTABLE3_CONTROL, ulDestOffset, &usBytesWritten )) != NO_ERROR) 
					return errCode;
				ulDestOffset += usBytesWritten;

				usNewGlyphOffset = 0;
				/* read the first offset value */
				if ((errCode = ReadWord( pSrcBufferInfo, &usOldGlyphOffset, ulSrcOffset)) != NO_ERROR) 
					return errCode;
				ulSrcOffset += sizeof(usOldGlyphOffset);
				for( i = 0; i <= usGlyphCount; i++ )
				{
					if ((errCode = WriteWord( pDestBufferInfo, usNewGlyphOffset, ulDestOffset )) != NO_ERROR) 
						return errCode;
					ulDestOffset +=sizeof(usNewGlyphOffset);	/* update the size of the table */
					if (i == usGlyphCount)/* Did the last table entry, which is just for Glyph size calculation purposes */
						break; 

					if ((errCode = ReadWord( pSrcBufferInfo, &usNextGlyphOffset, ulSrcOffset )) != NO_ERROR) 
						return errCode;
   					ulSrcOffset += sizeof(usNewGlyphOffset);

					Assert(usNextGlyphOffset>=usOldGlyphOffset);
					usGlyphLength = usNextGlyphOffset-usOldGlyphOffset;
					if (DoCopy)
					{
						if ((errCode = CopyBlockOver( pEBDTBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *) pSrcBufferInfo, IndexSubTable3.header.ulImageDataOffset + usNewGlyphOffset,
								  ulSrcEBDTOffset + ulOldImageDataOffset + usOldGlyphOffset, 
								  usGlyphLength)) != NO_ERROR)
							return errCode;
					}
					usNewGlyphOffset += usGlyphLength;
					usOldGlyphOffset = usNextGlyphOffset;
				}
 				ulDestGlyphOffset = usNewGlyphOffset;
				break;
		}
		case 4:
		{
			INDEXSUBTABLE4	IndexSubTable4;
			CODEOFFSETPAIR	CodeOffsetPair;
			uint16		usOldGlyphOffset;	/* the old offset of the glyph */
			uint16		usNextGlyphOffset;	/* the offset of the glyph after this glyph, to calculate length */
			uint16		usNewGlyphOffset;	/* the new offset in the new Glyph table */
			uint16		usGlyphLength;
			uint16		usFormat4FirstGlyphIndex = 0; /* need to set to return to caller */

				if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &IndexSubTable4, SIZEOF_INDEXSUBTABLE4, INDEXSUBTABLE4_CONTROL, ulSrcIndexSubTableOffset, &usBytesRead )) != NO_ERROR) 
					return errCode;
				ulSrcOffset += usBytesRead;
				IndexSubTable4.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */
				if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &IndexSubTable4, SIZEOF_INDEXSUBTABLE4, INDEXSUBTABLE4_CONTROL, ulDestIndexSubTableOffset, &usBytesWritten )) != NO_ERROR) 
					return errCode;
				ulDestOffset += usBytesRead;

				usNewGlyphOffset = 0;
				Assert(IndexSubTable4.ulNumGlyphs <= USHRT_MAX);
				usSparseGlyphCount = (uint16) IndexSubTable4.ulNumGlyphs;

				if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &CodeOffsetPair, SIZEOF_CODEOFFSETPAIR, CODEOFFSETPAIR_CONTROL, ulSrcOffset, &usBytesRead )) != NO_ERROR) 
					return errCode;
				ulSrcOffset += usBytesRead;
				usOldGlyphOffset = CodeOffsetPair.usOffset;	  
				for( i = 0;  i <= usSparseGlyphCount; ++i)	 /* do the one extra */
				{
					CodeOffsetPair.usOffset =  usNewGlyphOffset;
					if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &CodeOffsetPair, SIZEOF_CODEOFFSETPAIR, CODEOFFSETPAIR_CONTROL, ulDestOffset, &usBytesWritten )) != NO_ERROR) 
						return errCode;
					ulDestOffset += usBytesWritten;
					if (i == usSparseGlyphCount)
						break; /* the last 'dummy' one */

					if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &CodeOffsetPair, SIZEOF_CODEOFFSETPAIR, CODEOFFSETPAIR_CONTROL, ulSrcOffset, &usBytesRead )) != NO_ERROR) 
						return errCode;
					ulSrcOffset += usBytesRead;
					usNextGlyphOffset = CodeOffsetPair.usOffset;
					usGlyphLength = usNextGlyphOffset-usOldGlyphOffset;
					if (DoCopy)
					{
						if ((errCode = CopyBlockOver( pEBDTBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *) pSrcBufferInfo, IndexSubTable4.header.ulImageDataOffset + usNewGlyphOffset,
								  ulSrcEBDTOffset + ulOldImageDataOffset + usOldGlyphOffset, 
								  usGlyphLength)) != NO_ERROR)
							return errCode;
					}
					usNewGlyphOffset += usGlyphLength;
					usOldGlyphOffset = usNextGlyphOffset;
				}
 				ulDestGlyphOffset = usNewGlyphOffset;
				break;
		}
		case 5:
		{
			INDEXSUBTABLE5	IndexSubTable5;

			if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &IndexSubTable5, SIZEOF_INDEXSUBTABLE5, INDEXSUBTABLE5_CONTROL, ulSrcOffset, &usBytesRead )) != NO_ERROR) 
				return errCode;
			ulSrcOffset += usBytesRead;
			IndexSubTable5.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */
			if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &IndexSubTable5, SIZEOF_INDEXSUBTABLE5, INDEXSUBTABLE5_CONTROL, ulDestOffset, &usBytesWritten )) != NO_ERROR) 
				return errCode;
			ulDestOffset += usBytesWritten;

			Assert(IndexSubTable5.ulNumGlyphs <= USHRT_MAX);
			CopyBlockOver(pDestBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *) pSrcBufferInfo, ulDestOffset, ulSrcOffset, IndexSubTable5.ulNumGlyphs * sizeof(uint16));
			ulDestOffset += IndexSubTable5.ulNumGlyphs * sizeof(uint16);

			ulDestGlyphOffset = IndexSubTable5.ulImageSize * IndexSubTable5.ulNumGlyphs;
			if (DoCopy)
			{
				if ((errCode = CopyBlockOver( pEBDTBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *) pSrcBufferInfo, IndexSubTable5.header.ulImageDataOffset,
						  ulSrcEBDTOffset + ulOldImageDataOffset, ulDestGlyphOffset)) != NO_ERROR)
					return errCode;
			}
			break;
		}
		default:
			return(NO_ERROR);	  /* don't copy ! */
			break;

	}
	ulDestOffset += ZeroLongWordAlign(pDestBufferInfo, ulDestOffset);

	if (ulDestGlyphOffset == 0) /* yoiks, this won't do */
	   return NO_ERROR; 	/* don't copy anything */

 	*pulEBLCBytesWritten = ulDestOffset - ulDestIndexSubTableOffset;

	if (DoCopy)	/* we need to record the ImageDataBlock info */
	{
		*pulEBDTBytesWritten = ulDestGlyphOffset;
		ImageDataBlock.ulImageDataLength = ulDestGlyphOffset; 
		if ((errCode = RecordGlyphOffset(pKeeper, ulOldImageDataOffset, &ImageDataBlock)) != NO_ERROR)  /* record this block as being used */
			return errCode;
	}
	else if (ulDestGlyphOffset > ImageDataBlock.ulImageDataLength) /* need to check that the offset isn't exceeding the ImageDataLength */
		return ERR_GENERIC; /* we cannot handle this case */

	return NO_ERROR;
}
/* ---------------------------------------------------------------------- */
typedef struct {
  TTFACC_FILEBUFFERINFO *pInputBufferInfo;
  uint32 ulImageDataOffset;	/* absolute offset into file */
  uint32 ulImageLength;	
  uint16 usFirstGlyphIndex;
  GLYPHOFFSETRECORDKEEPER *pKeeper; 
} EBDTImageDataInfo;

typedef struct {
	uint16 usIndexFormat;
	uint16 usImageFormat;
	uint32 ulImageSize;
	uint16 usEntryCount;
	EBDTImageDataInfo *pImageDataInfo; /* allocated array of data to sort and output */
	BIGGLYPHMETRICS bigMetrics;
} EBLCMergeTableInfo;

typedef struct  {
	INDEXSUBTABLEARRAY SrcIndexSubTableArrayElement;
	INDEXSUBHEADER	SrcIndexSubHeader;
	uint32 ulImageSize;	 /* for use with comparing if should be merged */
	BIGGLYPHMETRICS bigMetrics;	/* for use with comparing if should be merged */
	uint32 ulSrcEBDTOffset;
	uint32 ulSrcIndexSubTableArrayOffset; /* absolute offset */
	uint32 ulSrcIndexSubTableArrayOffsetBase; /* the original one from the bmSizeTable */
	uint16 MergeWith; /* 0 = none, 1 = next 1, 2 = next 2 */
	TTFACC_FILEBUFFERINFO *pInputBufferInfo; /* will be set to pMergeBufferInfo, or pDestBufferInfo */
	GLYPHOFFSETRECORDKEEPER	*pKeeper;
} SubTablePlus;


typedef struct {
	uint32 ulNumSubTables; /* number of array elements allocated */
	SubTablePlus *SubTablePlusArray;
	uint16 usMergeType; /* 1 = copy delta, 2 = copy merge, 3 = merge*/
	uint32 ulDestIndexTableSize;   /* for output */
	uint32 ulDestNumberOfIndexSubTables; /* for output */
	BITMAPSIZETABLE bmSizeTable;  /* on copy this could be merge or delta data. On merge, this is merge data */
	BITMAPSIZETABLE bmDeltaSizeTable;
} SubTablePointers;					/* there will be one filled for each BitmapSize in Dest table.*/
									/* only merge items will have SubTablePlusArrays filled.  */

/* sort by ascending glyph Index, and secondarily, by decending ImageLength */
/* ---------------------------------------------------------------------- */
PRIVATE int CRTCB AscendingGlyphIndexCompare( CONST void *arg1, CONST void *arg2 )
{
	if (((EBDTImageDataInfo *)(arg1))->usFirstGlyphIndex == ((EBDTImageDataInfo *)(arg2))->usFirstGlyphIndex) /* they're the same */
	{
		if (((EBDTImageDataInfo *)(arg1))->ulImageLength == ((EBDTImageDataInfo *)(arg2))->ulImageLength) 
			return 0;
		else if (((EBDTImageDataInfo *)(arg1))->ulImageLength < ((EBDTImageDataInfo *)(arg2))->ulImageLength)  
			return 1; /* this one should come second */
		else
			return -1;
	}
	if (((EBDTImageDataInfo *)(arg1))->usFirstGlyphIndex < ((EBDTImageDataInfo *)(arg2))->usFirstGlyphIndex)
		return -1;
	return 1;
}

/* ---------------------------------------------------------------------- */

PRIVATE void SortByGlyphIndex(EBDTImageDataInfo *pImageDataInfo, uint16 usCount)
{
	if (pImageDataInfo != NULL && usCount != 0)
		qsort(pImageDataInfo, usCount, sizeof(*pImageDataInfo), AscendingGlyphIndexCompare);

}

/* ---------------------------------------------------------------------- */
/* will create a pMergeTableInfo array with data for the glyphs represented by a single format */
/* There may be a mixture of format 2 and format 5 data. This will be delt with on write */
/* ---------------------------------------------------------------------- */
PRIVATE int16 ReadTableIntoStructure(SubTablePlus *pSubTablePlus, EBLCMergeTableInfo *pMergeTableInfo, uint16 *pCurrIndex)
{
int16 errCode;
uint16 usBytesRead;
uint32 ulSrcOffset;
uint16 usFirstGlyphIndex;
uint16 usLastGlyphIndex;
uint16 i;
uint16		usCurrGlyphOffset;	/* the offset of the glyph */
uint16		usNextGlyphOffset;	/* the offset of the glyph after this glyph, to calculate length */
uint16		usGlyphCount;
TTFACC_FILEBUFFERINFO *pSrcBufferInfo; 
		
		
		ulSrcOffset = pSubTablePlus->ulSrcIndexSubTableArrayOffsetBase + pSubTablePlus->SrcIndexSubTableArrayElement.ulAdditionalOffsetToIndexSubtable;
		usFirstGlyphIndex = pSubTablePlus->SrcIndexSubTableArrayElement.usFirstGlyphIndex;
		usLastGlyphIndex = pSubTablePlus->SrcIndexSubTableArrayElement.usLastGlyphIndex;
		pSrcBufferInfo = pSubTablePlus->pInputBufferInfo; 
		if (*pCurrIndex == 0) /* first time, set these values */
		{
			pMergeTableInfo->usIndexFormat = pSubTablePlus->SrcIndexSubHeader.usIndexFormat;
			pMergeTableInfo->usImageFormat = pSubTablePlus->SrcIndexSubHeader.usImageFormat;
		}
		switch(pSubTablePlus->SrcIndexSubHeader.usIndexFormat) /* need to read in a structure depending on the format */
		{
		case 1:
			break;
		case 2:
			{
			INDEXSUBTABLE2 IndexSubTable2;

			if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &IndexSubTable2, SIZEOF_INDEXSUBTABLE2, INDEXSUBTABLE2_CONTROL, ulSrcOffset, &usBytesRead )) != NO_ERROR) 
					return errCode;
			if (*pCurrIndex == 0) /* first time, set these values */
			{
				pMergeTableInfo->ulImageSize = IndexSubTable2.ulImageSize;
				pMergeTableInfo->bigMetrics = IndexSubTable2.bigMetrics;
			}
 			usGlyphCount = usLastGlyphIndex - usFirstGlyphIndex + 1;
			for (i = 0; i < usGlyphCount; ++i)
			{
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].usFirstGlyphIndex = usFirstGlyphIndex+i;
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].ulImageLength = IndexSubTable2.ulImageSize;
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].ulImageDataOffset = pSubTablePlus->ulSrcEBDTOffset + pSubTablePlus->SrcIndexSubHeader.ulImageDataOffset + IndexSubTable2.ulImageSize * i;
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].pInputBufferInfo = pSrcBufferInfo;
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].pKeeper = pSubTablePlus->pKeeper;
				++ (*pCurrIndex);  /* bump this for next time around */
			}
			break;
			}
		case 3:
			{
			/* need to have one entry per glyph */
			INDEXSUBTABLE3	IndexSubTable3;

			if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &IndexSubTable3, SIZEOF_INDEXSUBTABLE3, INDEXSUBTABLE3_CONTROL, ulSrcOffset, &usBytesRead )) != NO_ERROR) 
				return errCode;
			ulSrcOffset += usBytesRead;
 			usGlyphCount = usLastGlyphIndex - usFirstGlyphIndex + 1;

			if ((errCode = ReadWord( pSrcBufferInfo, &usCurrGlyphOffset, ulSrcOffset)) != NO_ERROR) 
				return errCode;
			ulSrcOffset += sizeof(usCurrGlyphOffset);

			for (i = 0; i < usGlyphCount; ++i)
			{
				if ((errCode = ReadWord( pSrcBufferInfo, &usNextGlyphOffset, ulSrcOffset )) != NO_ERROR) 
					return errCode;
   				ulSrcOffset += sizeof(usNextGlyphOffset);
  				Assert(usNextGlyphOffset>=usCurrGlyphOffset);

				pMergeTableInfo->pImageDataInfo[*pCurrIndex].usFirstGlyphIndex = usFirstGlyphIndex+i;
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].ulImageLength = usNextGlyphOffset-usCurrGlyphOffset;
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].ulImageDataOffset = pSubTablePlus->ulSrcEBDTOffset + pSubTablePlus->SrcIndexSubHeader.ulImageDataOffset + usCurrGlyphOffset;
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].pInputBufferInfo = pSrcBufferInfo;
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].pKeeper = pSubTablePlus->pKeeper;
				usCurrGlyphOffset = usNextGlyphOffset;
				++ (*pCurrIndex);  /* bump this for next time around */
			}
			break;
			}
		case 4:
			{
			INDEXSUBTABLE4	IndexSubTable4;
			CODEOFFSETPAIR	CodeOffsetPair;

				if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &IndexSubTable4, SIZEOF_INDEXSUBTABLE4, INDEXSUBTABLE4_CONTROL, ulSrcOffset, &usBytesRead )) != NO_ERROR) 
					return errCode;
				ulSrcOffset += usBytesRead;

				Assert(IndexSubTable4.ulNumGlyphs <= USHRT_MAX);

				if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &CodeOffsetPair, SIZEOF_CODEOFFSETPAIR, CODEOFFSETPAIR_CONTROL, ulSrcOffset, &usBytesRead )) != NO_ERROR) 
					return errCode;
				ulSrcOffset += usBytesRead;
				usCurrGlyphOffset = CodeOffsetPair.usOffset;	  
				for( i = 0;  i < IndexSubTable4.ulNumGlyphs; ++i)	
				{
					pMergeTableInfo->pImageDataInfo[*pCurrIndex].usFirstGlyphIndex = CodeOffsetPair.usGlyphCode;
					if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &CodeOffsetPair, SIZEOF_CODEOFFSETPAIR, CODEOFFSETPAIR_CONTROL, ulSrcOffset, &usBytesRead )) != NO_ERROR) 
						return errCode;
					ulSrcOffset += usBytesRead;
					usNextGlyphOffset = CodeOffsetPair.usOffset;

					pMergeTableInfo->pImageDataInfo[*pCurrIndex].ulImageLength = usNextGlyphOffset-usCurrGlyphOffset;
					pMergeTableInfo->pImageDataInfo[*pCurrIndex].ulImageDataOffset = pSubTablePlus->ulSrcEBDTOffset + pSubTablePlus->SrcIndexSubHeader.ulImageDataOffset + usCurrGlyphOffset;
					pMergeTableInfo->pImageDataInfo[*pCurrIndex].pInputBufferInfo = pSrcBufferInfo;
					pMergeTableInfo->pImageDataInfo[*pCurrIndex].pKeeper = pSubTablePlus->pKeeper;
					usCurrGlyphOffset = usNextGlyphOffset;
					++ (*pCurrIndex);  /* bump this for next time around */
				}
			break;
			}
		case 5:
			{
			INDEXSUBTABLE5 IndexSubTable5;
			uint16 usGlyphIndex;

			if ((errCode = ReadGeneric( pSrcBufferInfo, (uint8 *) &IndexSubTable5, SIZEOF_INDEXSUBTABLE5, INDEXSUBTABLE5_CONTROL, ulSrcOffset, &usBytesRead )) != NO_ERROR) 
				return errCode;
			ulSrcOffset += usBytesRead;

			if (*pCurrIndex == 0) /* first time, set these values */
			{
				pMergeTableInfo->ulImageSize = IndexSubTable5.ulImageSize;
				pMergeTableInfo->bigMetrics = IndexSubTable5.bigMetrics;
			}
			Assert(IndexSubTable5.ulNumGlyphs <= USHRT_MAX);

			for( i = 0;  i < IndexSubTable5.ulNumGlyphs; ++i)	 
			{
				if ((errCode = ReadWord( pSrcBufferInfo, &usGlyphIndex, ulSrcOffset )) != NO_ERROR) 
					return errCode;
   				ulSrcOffset += sizeof(usGlyphIndex);
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].usFirstGlyphIndex = usGlyphIndex;
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].ulImageLength = pMergeTableInfo->ulImageSize;
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].ulImageDataOffset = pSubTablePlus->ulSrcEBDTOffset + pSubTablePlus->SrcIndexSubHeader.ulImageDataOffset + (pMergeTableInfo->ulImageSize*i);
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].pInputBufferInfo = pSrcBufferInfo;
				pMergeTableInfo->pImageDataInfo[*pCurrIndex].pKeeper = pSubTablePlus->pKeeper;
				++ (*pCurrIndex);  /* bump this for next time around */
			}
			break;
			}
		default:
			return ERR_INVALID_EBLC;
		}
		return NO_ERROR;
}

/* ---------------------------------------------------------------------- */

 PRIVATE int16 WriteTableFromStructure(TTFACC_FILEBUFFERINFO *pDestBufferInfo, 
										uint32 ulDestIndexSubTableOffset, 
										TTFACC_FILEBUFFERINFO *pEBDTBufferInfo,
										uint32 ulDestImageDataOffset, 
										EBLCMergeTableInfo *pMergeTableInfo, 
										uint32 *pulEBLCBytesWritten, 
										uint32 *pulEBDTBytesWritten,
										uint16 *pusFirstGlyphIndex, 
										uint16 *pusLastGlyphIndex)
 {

uint16		i;
uint32		ulCurrentImageDataOffset;  /* place where current IndexSubTable is pointing - usually NewImageDataOffset */
uint32		ulDestOffset;  /* for EBLC read/write */
uint32		ulDestGlyphOffset = 0;	/* into EBDT */
uint16		usDestGlyphOffset = 0;	/* into EBDT - short version */
int16 errCode;
uint16 usBytesWritten;
uint32 ulGlyphLength;
uint32 ulNumGlyphs = 0;
uint16 ufContiguous;
ImageDataBlock ImageDataBlock;
uint16 DoCopy = TRUE;


	*pulEBLCBytesWritten = 0;
	*pulEBDTBytesWritten = 0;
	*pusFirstGlyphIndex = pMergeTableInfo->pImageDataInfo[0].usFirstGlyphIndex; /* set this to start */
	*pusLastGlyphIndex = 0;
	ulCurrentImageDataOffset = ulDestImageDataOffset;
	ulDestOffset = ulDestIndexSubTableOffset;

	/* check if we are turning some 5s back into 2s */
	if (pMergeTableInfo->usIndexFormat == 2 || pMergeTableInfo->usIndexFormat == 5) /* need to check the contiguousness */
	{
		ufContiguous = TRUE;
		for (i = 1; i < pMergeTableInfo->usEntryCount; ++i)
		{
			if (pMergeTableInfo->pImageDataInfo[i].usFirstGlyphIndex > pMergeTableInfo->pImageDataInfo[i-1].usFirstGlyphIndex + 1)  /* not contiguous */
				ufContiguous = FALSE;
		}
		if (!ufContiguous) /* need to write out as a format 5 */
			pMergeTableInfo->usIndexFormat = 5;
		else
			pMergeTableInfo->usIndexFormat = 2;
	}

 	if (LookupGlyphOffset(pMergeTableInfo->pImageDataInfo[0].pKeeper, pMergeTableInfo->pImageDataInfo[0].ulImageDataOffset, &ImageDataBlock) == FALSE)  /* glyph range not copied already */
	{   /* use the current last offset into glyph area */
		ImageDataBlock.ulNewImageDataOffset = ulCurrentImageDataOffset; 
		ImageDataBlock.ulImageDataLength = 0; 
		ImageDataBlock.usIndexFormat = pMergeTableInfo->usIndexFormat;
		ImageDataBlock.usImageFormat = pMergeTableInfo->usImageFormat;
		/* if ((errCode = RecordGlyphOffset(pKeeper, pMergeTableInfo->pImageDataInfo[0].ulImageDataOffset, &ImageDataBlock)) != NO_ERROR) record this block as being used below */
		/* 	return errCode;	*/
	}
	else
	{
		if (ImageDataBlock.usImageFormat != pMergeTableInfo->usImageFormat )  /* copy nothing */
			return (NO_ERROR);
		DoCopy = FALSE;   /* Copy the IndexSubTable, but don't copy the glyphs over */
		ulCurrentImageDataOffset = ImageDataBlock.ulNewImageDataOffset; /* need to set the pointers here */
	}

	switch (pMergeTableInfo->usIndexFormat)
	{
		case 1:	   /* Error. Shouldn't get any of these from Create */
			return ERR_FORMAT;
		case 2:	
		{		 
			INDEXSUBTABLE2 IndexSubTable2;
			uint16 usGlyphCount = 0;
			uint16 usShiftValue = 0;

			IndexSubTable2.header.usIndexFormat = pMergeTableInfo->usIndexFormat;
			IndexSubTable2.header.usImageFormat = pMergeTableInfo->usImageFormat;
			IndexSubTable2.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */
			IndexSubTable2.ulImageSize = pMergeTableInfo->ulImageSize;
			IndexSubTable2.bigMetrics = pMergeTableInfo->bigMetrics;
			/* write the table entry */	
			if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &IndexSubTable2, SIZEOF_INDEXSUBTABLE2, INDEXSUBTABLE2_CONTROL, ulDestOffset, &usBytesWritten )) != NO_ERROR) 
				return errCode;
			ulDestOffset += usBytesWritten;

			for (i = 0; i < pMergeTableInfo->usEntryCount; ++i)
			{
				if ((i > 0) && (pMergeTableInfo->pImageDataInfo[i].usFirstGlyphIndex == pMergeTableInfo->pImageDataInfo[i-1].usFirstGlyphIndex))
 					continue;

				if (DoCopy) /* now we need to read the data from the sourceBuffer to the destEBDT buffer. */
				{
					if ((errCode = CopyBlockOver( pEBDTBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *)pMergeTableInfo->pImageDataInfo[i].pInputBufferInfo, 
							  IndexSubTable2.header.ulImageDataOffset+ulDestGlyphOffset,
							  pMergeTableInfo->pImageDataInfo[i].ulImageDataOffset, 
							  IndexSubTable2.ulImageSize)) != NO_ERROR)
						return errCode;
				}
				ulDestGlyphOffset += IndexSubTable2.ulImageSize;
				++ulNumGlyphs;
			}
			*pusLastGlyphIndex = *pusFirstGlyphIndex + (uint16) ulNumGlyphs - 1;
			break;
		}
		case 3:	/* just like format 1, but with short offsets instead */
		{
			INDEXSUBTABLE3	IndexSubTable3;

			IndexSubTable3.header.usIndexFormat = pMergeTableInfo->usIndexFormat;
			IndexSubTable3.header.usImageFormat = pMergeTableInfo->usImageFormat;
			IndexSubTable3.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */

			if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &IndexSubTable3, SIZEOF_INDEXSUBTABLE3, INDEXSUBTABLE3_CONTROL, ulDestOffset, &usBytesWritten )) != NO_ERROR) 
				return errCode;
			ulDestOffset += usBytesWritten;

			for (i = 0; i < pMergeTableInfo->usEntryCount; ++i)
			{
				/* check for duplicate entries */
				if ((i > 0) && (pMergeTableInfo->pImageDataInfo[i].usFirstGlyphIndex == pMergeTableInfo->pImageDataInfo[i-1].usFirstGlyphIndex))
 					continue;
				usDestGlyphOffset = (uint16) ulDestGlyphOffset;	
				if ((errCode = WriteWord( pDestBufferInfo, usDestGlyphOffset, ulDestOffset)) != NO_ERROR) 
					return errCode;
				ulDestOffset += sizeof(uint16);
				++ulNumGlyphs;

				ulGlyphLength = pMergeTableInfo->pImageDataInfo[i].ulImageLength;
				if (DoCopy) /* now we need to read the data from the sourceBuffer to the EBDT Buffer. */
				{
					if ((errCode = CopyBlockOver( pEBDTBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *)pMergeTableInfo->pImageDataInfo[i].pInputBufferInfo, 
							  IndexSubTable3.header.ulImageDataOffset + ulDestGlyphOffset,
							  pMergeTableInfo->pImageDataInfo[i].ulImageDataOffset, 
							  ulGlyphLength)) != NO_ERROR)
						return errCode;
				}
				ulDestGlyphOffset += ulGlyphLength;	
				if (!ValueOKForShort(ulDestGlyphOffset)) /* need to make another format 3 table */
					; /* ~ */
		}
			/* write the last one for length calculation */
			usDestGlyphOffset = (uint16) ulDestGlyphOffset; 
 			if ((errCode = WriteWord( pDestBufferInfo, usDestGlyphOffset, ulDestOffset)) != NO_ERROR) 
				return errCode;
			ulDestOffset += sizeof(uint16);
 			*pusLastGlyphIndex = *pusFirstGlyphIndex + (uint16)ulNumGlyphs - 1; 

			break;
		}
		case 4:
		{
			INDEXSUBTABLE4	IndexSubTable4;
			CODEOFFSETPAIR	CodeOffsetPair;

			IndexSubTable4.header.usIndexFormat = pMergeTableInfo->usIndexFormat;
			IndexSubTable4.header.usImageFormat = pMergeTableInfo->usImageFormat;
			IndexSubTable4.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */

			ulDestOffset += GetGenericSize(INDEXSUBTABLE4_CONTROL);/* need to skip this for now */

			for( i = 0;  i < pMergeTableInfo->usEntryCount; ++i)
			{
				/* check for duplicate entries */
				if ((i > 0) && (pMergeTableInfo->pImageDataInfo[i].usFirstGlyphIndex == pMergeTableInfo->pImageDataInfo[i-1].usFirstGlyphIndex))
 					continue;
				/* otherwise, write out that data */
				CodeOffsetPair.usOffset =  (uint16)ulDestGlyphOffset; 
				CodeOffsetPair.usGlyphCode = pMergeTableInfo->pImageDataInfo[i].usFirstGlyphIndex;

				if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &CodeOffsetPair, SIZEOF_CODEOFFSETPAIR, CODEOFFSETPAIR_CONTROL, ulDestOffset, &usBytesWritten )) != NO_ERROR) 
					return errCode;
				ulDestOffset += usBytesWritten;
				++ulNumGlyphs;

				ulGlyphLength = pMergeTableInfo->pImageDataInfo[i].ulImageLength;
				if (DoCopy) /* now we need to read the data from the sourceBuffer to the EBDT Buffer. */
				{
					if ((errCode = CopyBlockOver( pEBDTBufferInfo, (CONST_TTFACC_FILEBUFFERINFO*)pMergeTableInfo->pImageDataInfo[i].pInputBufferInfo, 
							  IndexSubTable4.header.ulImageDataOffset + ulDestGlyphOffset,
							  pMergeTableInfo->pImageDataInfo[i].ulImageDataOffset, 
							  ulGlyphLength)) != NO_ERROR)
						return errCode;
				}
				ulDestGlyphOffset += ulGlyphLength;	
				if (!ValueOKForShort(ulDestGlyphOffset)) /* need to make another table */
					; /* ~ */
				*pusLastGlyphIndex = max(pMergeTableInfo->pImageDataInfo[i].usFirstGlyphIndex, *pusLastGlyphIndex); /* set this to start */
			}
			CodeOffsetPair.usOffset =  (uint16)ulDestGlyphOffset; 
			CodeOffsetPair.usGlyphCode = 0; /* dummy one */
			if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &CodeOffsetPair, SIZEOF_CODEOFFSETPAIR, CODEOFFSETPAIR_CONTROL, ulDestOffset, &usBytesWritten )) != NO_ERROR) 
				return errCode;
			ulDestOffset += usBytesWritten;

			/* now set the numGlyphs value */
			IndexSubTable4.ulNumGlyphs = ulNumGlyphs;

			if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &IndexSubTable4, SIZEOF_INDEXSUBTABLE4, INDEXSUBTABLE4_CONTROL, ulDestIndexSubTableOffset, &usBytesWritten )) != NO_ERROR) 
					return errCode;
			break;
		}
		case 5:
		{
			INDEXSUBTABLE5	IndexSubTable5;

			IndexSubTable5.header.usIndexFormat = pMergeTableInfo->usIndexFormat;
			IndexSubTable5.header.usImageFormat = pMergeTableInfo->usImageFormat;
			IndexSubTable5.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */
			IndexSubTable5.ulImageSize = pMergeTableInfo->ulImageSize;
			IndexSubTable5.bigMetrics = pMergeTableInfo->bigMetrics;

			ulDestOffset += GetGenericSize(INDEXSUBTABLE5_CONTROL);/* need to skip this for now */
			ulGlyphLength = IndexSubTable5.ulImageSize;

 			for( i = 0;  i < pMergeTableInfo->usEntryCount; ++i)
			{
				/* check for duplicate entries */
				if ((i > 0) && (pMergeTableInfo->pImageDataInfo[i].usFirstGlyphIndex == pMergeTableInfo->pImageDataInfo[i-1].usFirstGlyphIndex))
 					continue;
 				/* write out the glyphID value */
				if ((errCode = WriteWord( pDestBufferInfo, pMergeTableInfo->pImageDataInfo[i].usFirstGlyphIndex, ulDestOffset)) != NO_ERROR) 
					return errCode;
				ulDestOffset += sizeof(uint16);
				++ulNumGlyphs;

				if (DoCopy) /* now we need to read the data from the sourceBuffer to the EBDT Buffer. */
				{
					if ((errCode = CopyBlockOver( pEBDTBufferInfo, (CONST_TTFACC_FILEBUFFERINFO*)pMergeTableInfo->pImageDataInfo[i].pInputBufferInfo, 
							  IndexSubTable5.header.ulImageDataOffset+ulDestGlyphOffset,
							  pMergeTableInfo->pImageDataInfo[i].ulImageDataOffset, 
							  ulGlyphLength)) != NO_ERROR)
						return errCode;
				}
				ulDestGlyphOffset += ulGlyphLength;
				*pusLastGlyphIndex = max(pMergeTableInfo->pImageDataInfo[i].usFirstGlyphIndex, *pusLastGlyphIndex); /* set this to start */
			}
			IndexSubTable5.ulNumGlyphs = ulNumGlyphs;
			/* write the table entry */	
			if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &IndexSubTable5, SIZEOF_INDEXSUBTABLE5, INDEXSUBTABLE5_CONTROL, ulDestIndexSubTableOffset, &usBytesWritten )) != NO_ERROR) 
				return errCode;

			break;
		}
		default:
			return(NO_ERROR);	  /* don't copy ! */
			break;

	}
	ulDestOffset += ZeroLongWordAlign(pDestBufferInfo, ulDestOffset);

	if (ulDestGlyphOffset == 0) /* yoiks, this won't do */
	   return NO_ERROR; 	/* don't copy anything */

	if (DoCopy) /* now we need to read the data from the sourceBuffer to the EBDT Buffer. */
	{
		*pulEBDTBytesWritten = ulDestGlyphOffset; 
		ImageDataBlock.ulImageDataLength = ulDestGlyphOffset; 
		/* record this info for next time */
		if ((errCode = RecordGlyphOffset(pMergeTableInfo->pImageDataInfo[0].pKeeper, pMergeTableInfo->pImageDataInfo[0].ulImageDataOffset, &ImageDataBlock)) != NO_ERROR)  /* record this block as being used */
			return errCode;
	}
	else if (ulDestGlyphOffset > ImageDataBlock.ulImageDataLength) /* need to check that the offset isn't exceeding the ImageDataLength */
		return NO_ERROR; /* we cannot handle this case - don't write this one */
	
	*pulEBLCBytesWritten = ulDestOffset - ulDestIndexSubTableOffset;

	return NO_ERROR;
}
PRIVATE int16 ReadSubTableInfo( TTFACC_FILEBUFFERINFO *pInputBufferInfo, INDEXSUBHEADER *pIndexSubHeader, uint32 *pulImageSize, BIGGLYPHMETRICS *pBigMetrics, uint32 ulOffset)
{
uint16 usBytesRead;
int16 errCode;
INDEXSUBTABLE2 IndexSubTable2;
INDEXSUBTABLE5 IndexSubTable5;

  	if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) pIndexSubHeader, SIZEOF_INDEXSUBHEADER, INDEXSUBHEADER_CONTROL, 
					ulOffset, &usBytesRead )) != NO_ERROR) 
		return errCode;
	if (pIndexSubHeader->usIndexFormat == 2) /* need to get the rest of the stuff */
	{
		if ((errCode = ReadGeneric(pInputBufferInfo,(uint8 *) &IndexSubTable2, SIZEOF_INDEXSUBTABLE2, INDEXSUBTABLE2_CONTROL, 
					ulOffset, &usBytesRead )) != NO_ERROR)
			return errCode;
		*pulImageSize = IndexSubTable2.ulImageSize;
		*pBigMetrics = IndexSubTable2.bigMetrics;
	}
	else if (pIndexSubHeader->usIndexFormat == 5)
	{
		if ((errCode = ReadGeneric(pInputBufferInfo,(uint8 *) &IndexSubTable5, SIZEOF_INDEXSUBTABLE5, INDEXSUBTABLE5_CONTROL, 
					ulOffset, &usBytesRead )) != NO_ERROR)
			return errCode;
		*pulImageSize = IndexSubTable5.ulImageSize;
		*pBigMetrics = IndexSubTable5.bigMetrics;
	}
	else
	{
		*pulImageSize = 0;
		memset(pBigMetrics, 0, sizeof(pBigMetrics));	
	}
	return NO_ERROR;
}

/* ---------------------------------------------------------------------- */
#define MERGE_TYPE_COPY_DELTA 1
#define MERGE_TYPE_COPY_MERGE 2
#define MERGE_TYPE_MERGE 3

/* ---------------------------------------------------------------------- */
int16 MergeEblcEbdtTables(TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDestEBLCOffset,				/* offset into dest buffer where to write data */
						uint32 *pulEblcLength,
						uint32 *pulEbdtOffset,
						uint32 *pulEbdtLength,				      /* number of bytes written to the EBDT table Output buffer */
						char * szEBLCTag,						 /* for use with bloc  */
						char * szEBDTTag)						 /* for use with bdat */
{
uint32 ulDeltaEBLCOffset, ulMergeEBLCOffset, ulSrcEBLCOffset;
uint32 ulDeltaEBDTOffset, ulMergeEBDTOffset,ulSrcEBDTOffset;
uint32 ulMergeEBDTLength, ulDeltaEBDTLength, ulMergeEBLCLength, ulDeltaEBLCLength;
uint8 *puchEBDTDestPtr; /* where to copy the data for the EBDT before writing to disk */
TTFACC_FILEBUFFERINFO EBDTBufferInfo;  /* to keep track of EBDT buffer */
uint32 ulDeltaIndexSubTableArrayOffset = 0, ulMergeIndexSubTableArrayOffset = 0, ulDestIndexSubTableArrayOffset = 0;
uint32 ulDestIndexSubTableOffset;
uint32 ulDeltaBitmapOffset = 0, ulMergeBitmapOffset = 0, ulDestBitmapOffset = 0;
uint16 usDeltaIndex, usMergeIndex, usDestIndex, usIndex;
SubTablePointers *SubTablePointerArray = NULL;
EBLCHEADER DeltaEBLCHeader, MergeEBLCHeader, DestEBLCHeader;
BITMAPSIZETABLE DeltaBMSizeTable, MergeBMSizeTable, DestBMSizeTable;
BITMAPSIZETABLE *pMergeBitmapSizeTable, *pDeltaBitmapSizeTable;
INDEXSUBTABLEARRAY DeltaIndexSubTableArrayElement, MergeIndexSubTableArrayElement, DestIndexSubTableArrayElement;
SubTablePlus *SubTablePlusArray;
int16 errCode = NO_ERROR;
uint32 ulBytesWritten = 0;
uint16 usBytesWritten;
uint16 usBytesRead;
uint32 ulNumSizes;
uint32 ulDestNumSubTables;
uint32 ulFinalNumSubTables;
uint32 ulDestImageDataOffset;
uint32 ulEBLCBytesWritten;
uint32 ulEBDTBytesWritten;
uint16 usMergeSizesIndex, usDeltaSizesIndex, usDestSizesIndex;
uint16 usnDestSizes = 0; /* number of sizes to be output to Dest font */
boolean ReadNextMerge;
boolean	ReadNextDelta;
TTFACC_FILEBUFFERINFO *pInputBufferInfo; /* where to read from when copying */
GLYPHOFFSETRECORDKEEPER MergeKeeper;
GLYPHOFFSETRECORDKEEPER DeltaKeeper;
EBLCMergeTableInfo MergeTableInfo;


	*pulEbdtLength = 0;
	*pulEblcLength = 0;
	*pulEbdtOffset = 0;

	ulDeltaEBLCOffset = TTTableOffset( pDeltaBufferInfo, szEBLCTag);
 	ulDeltaEBDTOffset = TTTableOffset( pDeltaBufferInfo, szEBDTTag);
 	ulDeltaEBDTLength = TTTableLength(pDeltaBufferInfo, szEBDTTag);
 	ulDeltaEBLCLength = TTTableLength(pDeltaBufferInfo, szEBLCTag);
	
	ulMergeEBLCOffset = TTTableOffset( pMergeBufferInfo, szEBLCTag);
 	ulMergeEBDTOffset = TTTableOffset( pMergeBufferInfo, szEBDTTag);
	ulMergeEBDTLength = TTTableLength(pMergeBufferInfo, szEBDTTag);
	ulMergeEBLCLength = TTTableLength(pMergeBufferInfo, szEBLCTag);

	if (ulDeltaEBLCOffset == DIRECTORY_ERROR && ulMergeEBLCOffset == DIRECTORY_ERROR)
		return ERR_FORMAT; /* nothing to merge. why are we being called? */
	if (ulDeltaEBDTOffset == DIRECTORY_ERROR && ulMergeEBDTOffset == DIRECTORY_ERROR)
		return ERR_FORMAT; /* nothing to merge. why are we being called? */

	/* take care of case where there's only one valid set of tables */
	if (ulDeltaEBLCOffset == DIRECTORY_ERROR || ulMergeEBLCOffset == DIRECTORY_ERROR)  
	{
		if (ulDeltaEBLCOffset == DIRECTORY_ERROR)  /* then merge is good */	 /* tested */
		{
			pInputBufferInfo = pMergeBufferInfo;
			ulSrcEBLCOffset = ulMergeEBLCOffset;
			ulSrcEBDTOffset = ulMergeEBDTOffset;
			*pulEbdtLength = ulMergeEBDTLength;
			*pulEblcLength = ulMergeEBLCLength;
		}
		else	 /* tested */
		{
 			pInputBufferInfo = pDeltaBufferInfo;
			ulSrcEBLCOffset = ulDeltaEBLCOffset;
			ulSrcEBDTOffset = ulDeltaEBDTOffset;
			*pulEbdtLength = ulDeltaEBDTLength;
			*pulEblcLength = ulDeltaEBLCLength;
		}
		if (*pulEbdtLength == 0 || *pulEblcLength == 0)	
			return ERR_INVALID_EBLC;

		/* copy over the EBLC table */
		if ((errCode = CopyBlockOver( pDestBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *) pInputBufferInfo, ulDestEBLCOffset, ulSrcEBLCOffset, *pulEblcLength )) != NO_ERROR) 
			return errCode;
		*pulEbdtOffset = ulDestEBLCOffset + *pulEblcLength;
		*pulEbdtOffset += ZeroLongWordAlign(pDestBufferInfo, *pulEbdtOffset);  /* to align the EBDT */
		if (ulSrcEBDTOffset == DIRECTORY_ERROR)
			return ERR_MISSING_EBDT;  /* need to have an EBDT table */
  		if ((errCode = CopyBlockOver( pDestBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *) pInputBufferInfo, *pulEbdtOffset, ulSrcEBDTOffset, *pulEbdtLength )) != NO_ERROR) 
			return errCode;
		return NO_ERROR;
	}

	/* otherwise, we know we're safe, and need to merge the tables */
	MergeKeeper.pGlyphOffsetArray = NULL;
	MergeKeeper.ulOffsetArrayLen = 0;
	MergeKeeper.ulNextArrayIndex = 0;
	DeltaKeeper.pGlyphOffsetArray = NULL;
	DeltaKeeper.ulOffsetArrayLen = 0;
	DeltaKeeper.ulNextArrayIndex = 0;

	if (ulDeltaEBDTLength == 0 || ulMergeEBDTLength == 0 || ulDeltaEBLCLength == 0 || ulMergeEBLCLength == 0)
		return ERR_FORMAT;

	if ((errCode = ReadGeneric( pMergeBufferInfo, (uint8 *) &MergeEBLCHeader, SIZEOF_EBLCHEADER, EBLCHEADER_CONTROL, ulMergeEBLCOffset, &usBytesRead )) != NO_ERROR) 
		return errCode;

 	ulMergeBitmapOffset = ulMergeEBLCOffset + usBytesRead;
	if ((errCode = ReadGeneric( pDeltaBufferInfo, (uint8 *) &DeltaEBLCHeader, SIZEOF_EBLCHEADER, EBLCHEADER_CONTROL, ulDeltaEBLCOffset, &usBytesRead )) != NO_ERROR) 
		return errCode;

 	ulDeltaBitmapOffset = ulDeltaEBLCOffset + usBytesRead;
	ulNumSizes = DeltaEBLCHeader.ulNumSizes + MergeEBLCHeader.ulNumSizes; 
  	/* allocate some space to store pointer info */
	SubTablePointerArray = (SubTablePointers *) Mem_Alloc(sizeof(SubTablePointers) * ulNumSizes);   /* make an array of pointers */
	if (!SubTablePointerArray)
		return ERR_MEM;

	puchEBDTDestPtr = (uint8 *) Mem_Alloc(ulMergeEBDTLength + ulDeltaEBDTLength);  /* we'll be copying the EBDT (raw bytes) table here temporarily */
	if (!puchEBDTDestPtr)
	{
		Mem_Free(SubTablePointerArray);
		return ERR_MEM;
	}
	EBDTBufferInfo.puchBuffer = puchEBDTDestPtr;
	EBDTBufferInfo.ulBufferSize = ulMergeEBDTLength + ulDeltaEBDTLength;
	EBDTBufferInfo.lpfnReAllocate = Mem_ReAlloc;
	EBDTBufferInfo.ulOffsetTableOffset = 0;
	/* read raw bytes for Header info from Merge table */
	/* copy one, doesn't matter */
	usBytesRead = GetGenericSize(EBDTHEADER_CONTROL);
	ulDestImageDataOffset = 0;
	if ((errCode = CopyBlockOver( &EBDTBufferInfo, (CONST_TTFACC_FILEBUFFERINFO*) pMergeBufferInfo, ulDestImageDataOffset, ulMergeEBDTOffset, usBytesRead )) != NO_ERROR) 
	{
		Mem_Free(SubTablePointerArray);
		Mem_Free(puchEBDTDestPtr);
		return errCode;
	}
	ulDestImageDataOffset = usBytesRead;  /* move past the header of the EBDT table */

	/* first count how many sizes we will end up, so we can figure out where to put them */
  ReadNextMerge = TRUE;
  ReadNextDelta = TRUE;
  for (usMergeSizesIndex = usDeltaSizesIndex = usDestSizesIndex = 0; 
	   usDestSizesIndex < ulNumSizes && (usDeltaSizesIndex < DeltaEBLCHeader.ulNumSizes || usMergeSizesIndex < MergeEBLCHeader.ulNumSizes);
		++usDestSizesIndex )
  {
	if (ReadNextDelta == TRUE)
	{
		if (usDeltaSizesIndex < DeltaEBLCHeader.ulNumSizes) 
		{
			if ((errCode = ReadGeneric( pDeltaBufferInfo, (uint8 *) &DeltaBMSizeTable, SIZEOF_BITMAPSIZETABLE, BITMAPSIZETABLE_CONTROL, ulDeltaBitmapOffset, &usBytesRead )) != NO_ERROR) 
				break;

 			ulDeltaBitmapOffset += usBytesRead;
		}
 		ReadNextDelta = FALSE;
	}
	if (ReadNextMerge == TRUE)
	{
		if (usMergeSizesIndex < MergeEBLCHeader.ulNumSizes)
		{
			if ((errCode = ReadGeneric( pMergeBufferInfo, (uint8 *) &MergeBMSizeTable, SIZEOF_BITMAPSIZETABLE, BITMAPSIZETABLE_CONTROL, ulMergeBitmapOffset, &usBytesRead )) != NO_ERROR) 
				break;

 			ulMergeBitmapOffset += usBytesRead;
		}
		ReadNextMerge = FALSE;
	}
	/* for each size in each file, must either copy or merge */
	/* if both MergeSizes indices are valid, must compare the ppemx and ppemy */
	  /* if they match, must check if startGlyphIndex-endGlyphIndex ranges overlap */
	  /* if they do not, then copy each separately, and update the numSizes variable */
	if ((usDeltaSizesIndex < DeltaEBLCHeader.ulNumSizes) && (DeltaBMSizeTable.ulNumberOfIndexSubTables > 0))
	{
		if ((usMergeSizesIndex < MergeEBLCHeader.ulNumSizes) && (MergeBMSizeTable.ulNumberOfIndexSubTables > 0))

		{
			if (((DeltaBMSizeTable.byPpemX == MergeBMSizeTable.byPpemX) && 
				(DeltaBMSizeTable.byPpemY == MergeBMSizeTable.byPpemY)) /* && */
			/*	((MergeBMSizeTable.usStartGlyphIndex <= DeltaBMSizeTable.usEndGlyphIndex) && */	   /* the regions overlap */
				  /* (MergeBMSizeTable.usEndGlyphIndex >= DeltaBMSizeTable.usStartGlyphIndex)) */)
			{
				SubTablePointerArray[usDestSizesIndex].usMergeType = MERGE_TYPE_MERGE; /* merge */
				SubTablePointerArray[usDestSizesIndex].bmSizeTable = MergeBMSizeTable; /* just take this one, doesn't matter */
				SubTablePointerArray[usDestSizesIndex].bmDeltaSizeTable = DeltaBMSizeTable;
				ReadNextMerge = TRUE;
				ReadNextDelta = TRUE;
			}
			else   /* copy the smallest one */
			{
				if ((DeltaBMSizeTable.byPpemX < MergeBMSizeTable.byPpemX) ||
				   ((DeltaBMSizeTable.byPpemX == MergeBMSizeTable.byPpemX) && 
				   (DeltaBMSizeTable.byPpemY < MergeBMSizeTable.byPpemY)))
				{
					SubTablePointerArray[usDestSizesIndex].usMergeType = MERGE_TYPE_COPY_DELTA; /* copy delta */
					SubTablePointerArray[usDestSizesIndex].bmSizeTable = DeltaBMSizeTable; 
					ReadNextDelta = TRUE;  /* leave merge one to look at next time around */
				}
				else 
				{
					SubTablePointerArray[usDestSizesIndex].usMergeType = MERGE_TYPE_COPY_MERGE; /* copy merge */
					SubTablePointerArray[usDestSizesIndex].bmSizeTable = MergeBMSizeTable; 
					ReadNextMerge = TRUE;	/* leave delta one to look at next time around */
				}
			}
		}
		else
		{
			SubTablePointerArray[usDestSizesIndex].usMergeType = MERGE_TYPE_COPY_DELTA; /* copy delta */
			SubTablePointerArray[usDestSizesIndex].bmSizeTable = DeltaBMSizeTable; 
			ReadNextDelta = TRUE;
		}
	}
	else if ((usMergeSizesIndex < MergeEBLCHeader.ulNumSizes) && (MergeBMSizeTable.ulNumberOfIndexSubTables > 0))
	{
		SubTablePointerArray[usDestSizesIndex].usMergeType = MERGE_TYPE_COPY_MERGE; /* copy merge */
		SubTablePointerArray[usDestSizesIndex].bmSizeTable = MergeBMSizeTable; 
		ReadNextMerge = TRUE;
	}
	else
		break; /* something was wacky with one of the entries.  don't continue, just process what we have */
	if (ReadNextMerge == TRUE) /* we used one up */
		++usMergeSizesIndex;
	if (ReadNextDelta == TRUE)
 		++usDeltaSizesIndex;

  }
  
  if (errCode == NO_ERROR)
  {
	  DestEBLCHeader = MergeEBLCHeader; /* doesn't matter which one we take it from */
	  DestEBLCHeader.ulNumSizes = usnDestSizes = usDestSizesIndex;	/* we know how many sizes we'll have on output */

	  if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &DestEBLCHeader, SIZEOF_EBLCHEADER, EBLCHEADER_CONTROL, ulDestEBLCOffset, &usBytesWritten )) == NO_ERROR) 
	  {
		  ulDestBitmapOffset = ulDestEBLCOffset + usBytesWritten;
		  /* calculate the absolute (not relative) offset value */
		  ulDestIndexSubTableArrayOffset = ulDestBitmapOffset + (GetGenericSize(BITMAPSIZETABLE_CONTROL) * usnDestSizes);
		  /* ok, now go through this list of bmSize tables that we have gathered, and merge those we should, and copy the others */
	  }
  }
  for (usDestSizesIndex = 0; usDestSizesIndex < usnDestSizes; ++usDestSizesIndex )
  {
	if (errCode != NO_ERROR)
		break;
	if (SubTablePointerArray[usDestSizesIndex].usMergeType == MERGE_TYPE_MERGE)	/* do the merge dance */
	{
		/* local pointers to BitmapSizeTables */
		pMergeBitmapSizeTable = (&SubTablePointerArray[usDestSizesIndex].bmSizeTable);
		pDeltaBitmapSizeTable = &(SubTablePointerArray[usDestSizesIndex].bmDeltaSizeTable);

		/* calculate IndexSubTableArrayOffsets - absolute, not relative */
		ulMergeIndexSubTableArrayOffset = ulMergeEBLCOffset + pMergeBitmapSizeTable->ulIndexSubTableArrayOffset;
	    ulDeltaIndexSubTableArrayOffset = ulDeltaEBLCOffset + pDeltaBitmapSizeTable->ulIndexSubTableArrayOffset;
				
		ulDestNumSubTables = pDeltaBitmapSizeTable->ulNumberOfIndexSubTables + pMergeBitmapSizeTable->ulNumberOfIndexSubTables;

		/* allocate some space to store pointer info */
		SubTablePlusArray = (SubTablePlus *) Mem_Alloc(sizeof(SubTablePlus) * ulDestNumSubTables);   /* make an array of pointers */
		if (SubTablePlusArray == NULL)
		{
			errCode = ERR_MEM;
			break;
		}
  		SubTablePointerArray[usDestSizesIndex].SubTablePlusArray = SubTablePlusArray;
		SubTablePointerArray[usDestSizesIndex].ulNumSubTables = ulDestNumSubTables;
		ReadNextMerge = TRUE;
		ReadNextDelta = TRUE;

		/* now go through the list of subtables, and read some of their data in in order */
		for (usDestIndex = usDeltaIndex = usMergeIndex = 0; usDestIndex < ulDestNumSubTables; ++usDestIndex)  /* read, in order, the data from the Delta and Merge EBLCs */
		{
			if (ReadNextMerge == TRUE)
			{
				if (usMergeIndex < pMergeBitmapSizeTable->ulNumberOfIndexSubTables) 
				{
  					if ((errCode = ReadGeneric( pMergeBufferInfo, (uint8 *) &MergeIndexSubTableArrayElement, SIZEOF_INDEXSUBTABLEARRAY, INDEXSUBTABLEARRAY_CONTROL, ulMergeIndexSubTableArrayOffset, &usBytesRead )) != NO_ERROR) 
						break;
 				 /*	ulMergeIndexSubTableArrayOffset += usBytesRead;	 will do this below */
				}
				ReadNextMerge = FALSE;
			}
 			if (ReadNextDelta == TRUE)
			{
				if (usDeltaIndex < pDeltaBitmapSizeTable->ulNumberOfIndexSubTables)
				{
  					if ((errCode = ReadGeneric( pDeltaBufferInfo, (uint8 *) &DeltaIndexSubTableArrayElement, SIZEOF_INDEXSUBTABLEARRAY, INDEXSUBTABLEARRAY_CONTROL, ulDeltaIndexSubTableArrayOffset, &usBytesRead )) != NO_ERROR) 
						break;
 				/* 	ulDeltaIndexSubTableArrayOffset += usBytesRead;	 will do this below */
				}
				ReadNextDelta = FALSE;
			}

			if (usMergeIndex < pMergeBitmapSizeTable->ulNumberOfIndexSubTables) 
			{
				if ((usDeltaIndex >= pDeltaBitmapSizeTable->ulNumberOfIndexSubTables) || 
				   (MergeIndexSubTableArrayElement.usFirstGlyphIndex <= DeltaIndexSubTableArrayElement.usFirstGlyphIndex))  /* copy the merge one */
				{
					/* read the merge data */
					SubTablePlusArray[usDestIndex].SrcIndexSubTableArrayElement = MergeIndexSubTableArrayElement;
					if ((errCode = ReadSubTableInfo( pMergeBufferInfo, &(SubTablePlusArray[usDestIndex].SrcIndexSubHeader), &(SubTablePlusArray[usDestIndex].ulImageSize), &(SubTablePlusArray[usDestIndex].bigMetrics),
						ulMergeEBLCOffset + pMergeBitmapSizeTable->ulIndexSubTableArrayOffset + MergeIndexSubTableArrayElement.ulAdditionalOffsetToIndexSubtable)) != NO_ERROR)
						break;
					SubTablePlusArray[usDestIndex].pInputBufferInfo = pMergeBufferInfo;
					SubTablePlusArray[usDestIndex].pKeeper = &MergeKeeper;
					SubTablePlusArray[usDestIndex].ulSrcEBDTOffset = ulMergeEBDTOffset;
					SubTablePlusArray[usDestIndex].ulSrcIndexSubTableArrayOffset = ulMergeIndexSubTableArrayOffset;	 /* absolute */
					SubTablePlusArray[usDestIndex].ulSrcIndexSubTableArrayOffsetBase = ulMergeEBLCOffset + pMergeBitmapSizeTable->ulIndexSubTableArrayOffset;	 /* absolute */
 
					ulMergeIndexSubTableArrayOffset += GetGenericSize(INDEXSUBTABLEARRAY_CONTROL);
					++ usMergeIndex;
					ReadNextMerge = TRUE;
					continue;
				}
			   /* otherwise we want to go on ahead and read the delta one */
			}
			if (usDeltaIndex < pDeltaBitmapSizeTable->ulNumberOfIndexSubTables) /* read the delta one */
			{
				SubTablePlusArray[usDestIndex].SrcIndexSubTableArrayElement = DeltaIndexSubTableArrayElement;
 				if ((errCode = ReadSubTableInfo( pDeltaBufferInfo, &(SubTablePlusArray[usDestIndex].SrcIndexSubHeader), &(SubTablePlusArray[usDestIndex].ulImageSize), &(SubTablePlusArray[usDestIndex].bigMetrics),
					ulDeltaEBLCOffset + pDeltaBitmapSizeTable->ulIndexSubTableArrayOffset + DeltaIndexSubTableArrayElement.ulAdditionalOffsetToIndexSubtable)) != NO_ERROR)
					break;
				SubTablePlusArray[usDestIndex].pInputBufferInfo = pDeltaBufferInfo;
				SubTablePlusArray[usDestIndex].pKeeper = &DeltaKeeper;
				SubTablePlusArray[usDestIndex].ulSrcEBDTOffset = ulDeltaEBDTOffset;
				SubTablePlusArray[usDestIndex].ulSrcIndexSubTableArrayOffset = ulDeltaIndexSubTableArrayOffset;
				SubTablePlusArray[usDestIndex].ulSrcIndexSubTableArrayOffsetBase = ulDeltaEBLCOffset + pDeltaBitmapSizeTable->ulIndexSubTableArrayOffset;	 /* absolute */
 				ulDeltaIndexSubTableArrayOffset += GetGenericSize(INDEXSUBTABLEARRAY_CONTROL);
				++ usDeltaIndex;
				ReadNextDelta = TRUE;
			}
			else
				break; /* error? */
		}
		if (errCode != NO_ERROR)
			break;
		ulDestNumSubTables = usDestIndex;  /* set this in case some of them were "bad" */
		/* OK, now we have a sorted array of entries in the SubTablePlusArray */
		/* we need to figure out which ones are mergable */
		/* they are mergable iff */
		/*    same imageFormat */
		/*    same indexFormat */
		/*    touching ranges of glyph indices */
		ulFinalNumSubTables = ulDestNumSubTables;  /* will be modified if tables are merged */

		for (usDestIndex = 1; usDestIndex < ulDestNumSubTables; ++usDestIndex)
		{	/* merger will occur if 1) ranges touch and the formats are the same OR, 
			   ranges do not touch, but the metrics are the same in a 2-5. 5-2, or 5-5 pair */
			if ( (
				  (SubTablePlusArray[usDestIndex].SrcIndexSubHeader.usImageFormat == SubTablePlusArray[usDestIndex-1].SrcIndexSubHeader.usImageFormat) &&
				  /* for formats 2 and 5, these will have values. Otherwise, they are set to 0 */
				  (SubTablePlusArray[usDestIndex].ulImageSize == SubTablePlusArray[usDestIndex-1].ulImageSize) &&
				  (memcmp(&(SubTablePlusArray[usDestIndex].bigMetrics),&(SubTablePlusArray[usDestIndex-1].bigMetrics), sizeof(SubTablePlusArray[usDestIndex].bigMetrics)) == 0) 
				 )
				 &&
				 (
				  (
				   (SubTablePlusArray[usDestIndex].SrcIndexSubHeader.usIndexFormat == SubTablePlusArray[usDestIndex-1].SrcIndexSubHeader.usIndexFormat) &&
				   (SubTablePlusArray[usDestIndex].SrcIndexSubTableArrayElement.usFirstGlyphIndex <= SubTablePlusArray[usDestIndex-1].SrcIndexSubTableArrayElement.usLastGlyphIndex+1) && 	  /* +1 for touching, not overlapping ranges */
				   (SubTablePlusArray[usDestIndex-1].SrcIndexSubTableArrayElement.usFirstGlyphIndex <= SubTablePlusArray[usDestIndex].SrcIndexSubTableArrayElement.usLastGlyphIndex+1)
				  )
				  ||  /* or we have a 2-2, 2-5, 5-2, or 5-5 thing going on - don't have to touch ranges */
				  (
				   ((SubTablePlusArray[usDestIndex].SrcIndexSubHeader.usIndexFormat == 2 || SubTablePlusArray[usDestIndex].SrcIndexSubHeader.usIndexFormat == 5)) && /* these can be merged into a format 2 */
				   ((SubTablePlusArray[usDestIndex-1].SrcIndexSubHeader.usIndexFormat == 2 || SubTablePlusArray[usDestIndex-1].SrcIndexSubHeader.usIndexFormat == 5))
				  )
				 )
			   ) /* set merge bit */
			{
				SubTablePlusArray[usDestIndex-1].MergeWith = 1;
				for (usIndex = usDestIndex-1; usIndex > 0; --usIndex)	/* now go back an fix up any others that need to be fixed for multiple merges */
				{
				   if (SubTablePlusArray[usIndex-1].MergeWith == 0)
					   break;
				   ++SubTablePlusArray[usIndex-1].MergeWith;
				}
				--ulFinalNumSubTables;
			}
		}
 		/* initialize this absolute offset value */
		ulDestIndexSubTableOffset = ulDestIndexSubTableArrayOffset + (ulFinalNumSubTables * GetGenericSize(INDEXSUBTABLEARRAY_CONTROL));

  		DestBMSizeTable = *pMergeBitmapSizeTable; /* copy one, so we can modify the values */
		DestBMSizeTable.ulIndexSubTableArrayOffset = ulDestIndexSubTableArrayOffset - ulDestEBLCOffset; /* current relative location for table data */
		DestBMSizeTable.usStartGlyphIndex =  min(pMergeBitmapSizeTable->usStartGlyphIndex, pDeltaBitmapSizeTable->usStartGlyphIndex);
		DestBMSizeTable.usEndGlyphIndex =  max(pMergeBitmapSizeTable->usEndGlyphIndex, pDeltaBitmapSizeTable->usEndGlyphIndex);
		DestBMSizeTable.ulNumberOfIndexSubTables = ulFinalNumSubTables; /*  modified by those that are merged */
		for (usDestIndex = usDeltaIndex = usMergeIndex = 0; usDestIndex < ulDestNumSubTables; ++usDestIndex)  /* read, in order, the data from the Delta and Merge EBLCs */
		{
		uint16 i;
		uint16 usCurrIndex;

			DestIndexSubTableArrayElement = SubTablePlusArray[usDestIndex].SrcIndexSubTableArrayElement; /* make a copy */
 			DestIndexSubTableArrayElement.ulAdditionalOffsetToIndexSubtable = ulDestIndexSubTableOffset - ulDestEBLCOffset - DestBMSizeTable.ulIndexSubTableArrayOffset; 

			if (SubTablePlusArray[usDestIndex].MergeWith > 0) /* need to merge the actual table */
			{
				memset(&MergeTableInfo, 0, sizeof(MergeTableInfo));
				/* figure out how many glyphs or glyph groups we need to track */
				for (i = 0; i <= SubTablePlusArray[usDestIndex].MergeWith; ++i) /* need to gather up info about the table */
					MergeTableInfo.usEntryCount += (SubTablePlusArray[usDestIndex+i].SrcIndexSubTableArrayElement.usLastGlyphIndex -
													SubTablePlusArray[usDestIndex+i].SrcIndexSubTableArrayElement.usFirstGlyphIndex + 1);

				MergeTableInfo.pImageDataInfo = Mem_Alloc(sizeof(EBDTImageDataInfo) * MergeTableInfo.usEntryCount); /* allocate an array for this */

                if (MergeTableInfo.pImageDataInfo  == NULL)
                {
                   errCode = ERR_MEM;
	               break;
	            }				
				
				usCurrIndex = 0; /* where to start in the array */
				for (i = 0; i <= SubTablePlusArray[usDestIndex].MergeWith; ++i) /* need to gather up info about the table */
					if ((errCode = ReadTableIntoStructure(&(SubTablePlusArray[usDestIndex+i]),&MergeTableInfo,  &usCurrIndex )) != NO_ERROR)
						break;
				if (errCode != NO_ERROR)
				{
					Mem_Free(MergeTableInfo.pImageDataInfo);
					break;
				}
				MergeTableInfo.usEntryCount = usCurrIndex;

				SortByGlyphIndex(MergeTableInfo.pImageDataInfo, MergeTableInfo.usEntryCount);

				if ((errCode = WriteTableFromStructure(pDestBufferInfo, ulDestIndexSubTableOffset, &EBDTBufferInfo, 
					ulDestImageDataOffset, &MergeTableInfo, &ulEBLCBytesWritten, &ulEBDTBytesWritten, 
					&(DestIndexSubTableArrayElement.usFirstGlyphIndex), &(DestIndexSubTableArrayElement.usLastGlyphIndex))) != NO_ERROR)
					{
						Mem_Free(MergeTableInfo.pImageDataInfo);
						break;
				}

				if (ulEBLCBytesWritten > 0)	/* if we successfully merged them */
				{
					ulDestIndexSubTableOffset += ulEBLCBytesWritten; /* update the offset to the table */
					ulDestImageDataOffset += ulEBDTBytesWritten;
					/* now update the SubTableArrayElement */

					if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &DestIndexSubTableArrayElement, SIZEOF_INDEXSUBTABLEARRAY, INDEXSUBTABLEARRAY_CONTROL, ulDestIndexSubTableArrayOffset, &usBytesWritten )) != NO_ERROR) 
					{
						Mem_Free(MergeTableInfo.pImageDataInfo);
						break;
					}
					ulDestIndexSubTableArrayOffset += usBytesWritten; /* update the offset to the array element */
 				}

				Mem_Free(MergeTableInfo.pImageDataInfo);
				usDestIndex += SubTablePlusArray[usDestIndex].MergeWith; /* increment past them, they've been processed */
				continue;
			}
			/* otherwise, copy the data from each subtable */
			if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &DestIndexSubTableArrayElement, SIZEOF_INDEXSUBTABLEARRAY, INDEXSUBTABLEARRAY_CONTROL, ulDestIndexSubTableArrayOffset, &usBytesWritten )) != NO_ERROR) 
				break;
			ulDestIndexSubTableArrayOffset += usBytesWritten; /* update the offset to the array element */
			if ((errCode = CopySbitSubTable(pDestBufferInfo, SubTablePlusArray[usDestIndex].pInputBufferInfo,  /* buffer Info */
						ulDestIndexSubTableOffset, 
						SubTablePlusArray[usDestIndex].ulSrcIndexSubTableArrayOffsetBase + SubTablePlusArray[usDestIndex].SrcIndexSubTableArrayElement.ulAdditionalOffsetToIndexSubtable, 
						(uint16) (SubTablePlusArray[usDestIndex].SrcIndexSubTableArrayElement.usLastGlyphIndex -  SubTablePlusArray[usDestIndex].SrcIndexSubTableArrayElement.usFirstGlyphIndex + 1), /* EBLC info */
						&EBDTBufferInfo, ulDestImageDataOffset, SubTablePlusArray[usDestIndex].ulSrcEBDTOffset, SubTablePlusArray[usDestIndex].pKeeper, &ulEBLCBytesWritten, &ulEBDTBytesWritten)) != NO_ERROR)
						break;
			ulDestIndexSubTableOffset += ulEBLCBytesWritten; /* update the offset to the table */
			ulDestImageDataOffset += ulEBDTBytesWritten;
		}
		if (errCode != NO_ERROR)
			break;
			/* turn absolute to relative, then subtract off the relative origin */
		DestBMSizeTable.ulIndexTablesSize = (ulDestIndexSubTableOffset - ulDestEBLCOffset) - DestBMSizeTable.ulIndexSubTableArrayOffset;
		/* now copy the BitmapSizeTable element over, modifying the offset value */
		if ((errCode = WriteGeneric(pDestBufferInfo, (uint8 *) &DestBMSizeTable, SIZEOF_BITMAPSIZETABLE, BITMAPSIZETABLE_CONTROL, ulDestBitmapOffset, &usBytesWritten)) != NO_ERROR)
			break;
		ulDestBitmapOffset += usBytesWritten;  /* update for next go-around */
		ulDestIndexSubTableArrayOffset = ulDestIndexSubTableOffset; /* set this up for next time */
	}
	else /* we are just going to copy an entire size at a time */  /* tested */
	{
	uint32 ulSrcIndexSubTableArrayOffset;
	uint32 ulSrcIndexSubTableOffsetBase;
	INDEXSUBTABLEARRAY SrcIndexSubTableArrayElement;
	GLYPHOFFSETRECORDKEEPER	*pKeeper;

		if (SubTablePointerArray[usDestSizesIndex].usMergeType == MERGE_TYPE_COPY_MERGE)	/* copy from the merge file */
		{
			pInputBufferInfo = pMergeBufferInfo;
 			ulSrcIndexSubTableArrayOffset = ulMergeEBLCOffset + SubTablePointerArray[usDestSizesIndex].bmSizeTable.ulIndexSubTableArrayOffset;
			ulSrcEBDTOffset = ulMergeEBDTOffset;
			pKeeper = &MergeKeeper;
		}
		else /* copy from the delta file */
		{
			pInputBufferInfo = pDeltaBufferInfo;
			ulSrcIndexSubTableArrayOffset = ulDeltaEBLCOffset + SubTablePointerArray[usDestSizesIndex].bmSizeTable.ulIndexSubTableArrayOffset;
			ulSrcEBDTOffset = ulDeltaEBDTOffset;
			pKeeper = &DeltaKeeper;
		}
 		ulSrcIndexSubTableOffsetBase = ulSrcIndexSubTableArrayOffset; /* value that won't change */

		/* now we need to go through the indexSubTable entries and copy over the glyph info, if not already copied */
		/* and update any offset values */
  		DestBMSizeTable = SubTablePointerArray[usDestSizesIndex].bmSizeTable; /* copy the one to copy, so we can modify the offset value */
		DestBMSizeTable.ulIndexSubTableArrayOffset = ulDestIndexSubTableArrayOffset - ulDestEBLCOffset; /* current relative location for table data */
		ulDestIndexSubTableOffset = ulDestIndexSubTableArrayOffset + (DestBMSizeTable.ulNumberOfIndexSubTables * GetGenericSize(INDEXSUBTABLEARRAY_CONTROL));
		for (usDestIndex = 0; usDestIndex < DestBMSizeTable.ulNumberOfIndexSubTables; ++usDestIndex)
		{
		/* now read in the element */
			if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) &SrcIndexSubTableArrayElement, SIZEOF_INDEXSUBTABLEARRAY, INDEXSUBTABLEARRAY_CONTROL, ulSrcIndexSubTableArrayOffset, &usBytesRead )) != NO_ERROR) 
				break;
 			ulSrcIndexSubTableArrayOffset += usBytesRead;
			/* write the SubTableArrayElement. */
			DestIndexSubTableArrayElement = SrcIndexSubTableArrayElement;	/* make a copy */
			DestIndexSubTableArrayElement.ulAdditionalOffsetToIndexSubtable = ulDestIndexSubTableOffset - ulDestEBLCOffset - DestBMSizeTable.ulIndexSubTableArrayOffset; 
			if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &DestIndexSubTableArrayElement, SIZEOF_INDEXSUBTABLEARRAY, INDEXSUBTABLEARRAY_CONTROL, ulDestIndexSubTableArrayOffset, &usBytesWritten )) != NO_ERROR) 
				return errCode;
			ulDestIndexSubTableArrayOffset += usBytesWritten; /* update the offset to the array element */
			/* get the Absolute offset of the SubTable */
			if ((errCode = CopySbitSubTable(pDestBufferInfo, pInputBufferInfo,  /* buffer Info */
						ulDestIndexSubTableOffset, ulSrcIndexSubTableOffsetBase + SrcIndexSubTableArrayElement.ulAdditionalOffsetToIndexSubtable, 
						(uint16) (SrcIndexSubTableArrayElement.usLastGlyphIndex -  SrcIndexSubTableArrayElement.usFirstGlyphIndex + 1), /* EBLC info */
						&EBDTBufferInfo, ulDestImageDataOffset, ulSrcEBDTOffset, pKeeper, &ulEBLCBytesWritten, &ulEBDTBytesWritten)) != NO_ERROR)
						break;
			ulDestIndexSubTableOffset += ulEBLCBytesWritten;
			ulDestImageDataOffset += ulEBDTBytesWritten;
		}											   /* turn absolute to relative, then subtract off the relative origin */
		Assert(DestBMSizeTable.indexTableSize == (ulDestIndexSubTableArrayOffset - ulDestEBLCOffset) - DestBMSizeTable.ulIndexSubTableArrayOffset);
		/* now copy the BitmapSizeTable element over, modifying the offset value */
		if ((errCode = WriteGeneric(pDestBufferInfo, (uint8 *) &DestBMSizeTable, SIZEOF_BITMAPSIZETABLE, BITMAPSIZETABLE_CONTROL, ulDestBitmapOffset, &usBytesWritten)) != NO_ERROR)
			break;
		ulDestBitmapOffset += usBytesWritten;  /* update for next go-around */
		ulDestIndexSubTableArrayOffset = ulDestIndexSubTableOffset;
	}
  }

  for (usDestSizesIndex = 0; usDestSizesIndex < usnDestSizes; ++usDestSizesIndex )
  {
	  Mem_Free(SubTablePointerArray[usDestSizesIndex].SubTablePlusArray);
  }
  Mem_Free(SubTablePointerArray);
  Mem_Free(MergeKeeper.pGlyphOffsetArray);
  Mem_Free(DeltaKeeper.pGlyphOffsetArray);

  if (errCode == NO_ERROR)
  {
	  *pulEblcLength = ulDestIndexSubTableOffset - ulDestEBLCOffset; /* calculate length */
	  *pulEbdtOffset = ulDestIndexSubTableOffset;
	  *pulEbdtOffset += ZeroLongWordAlign(pDestBufferInfo, *pulEbdtOffset);  /* to align the EBDT */
	  *pulEbdtLength = ulDestImageDataOffset;
	  /* now we need to write out the puchEBDTDestPtr to the output location */
	  errCode = CopyBlockOver(pDestBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *)&EBDTBufferInfo, *pulEbdtOffset, 0, *pulEbdtLength);
  }
  Mem_Free(EBDTBufferInfo.puchBuffer);
  return errCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\modglyf.h ===
/*
  * ModGlyf.h: Interface file for ModGlyf.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */
  
#ifndef MODGLYF_DOT_H_DEFINED
#define MODGLYF_DOT_H_DEFINED        

int16 ModGlyfLocaAndHead( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
					 TTFACC_FILEBUFFERINFO * pOutBufferInfo,
					 uint8 *puchKeepGlyphList, 
					 uint16 usGlyphListCount, 
					 uint32 *pCheckSumAdjustment,
					 uint32 *pulNewOutOffset);

#endif /* MODGLYF_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\modglyf.c ===
/***************************************************************************
 * module: MODGLYF.C
 *
 * author: Louise Pathe
 * date:   November 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 **************************************************************************/


/* Inclusions ----------------------------------------------------------- */
#include <stdlib.h> /* for max and min */
#include <assert.h>

#include "typedefs.h"
#include "ttff.h"
#include "ttfacc.h"
#include "ttfcntrl.h"
#include "ttftabl1.h"
#include "ttftable.h"
#include "ttmem.h"
#include "util.h"
#include "modglyf.h"
#include "ttferror.h"	 /* for error codes */

/* ------------------------------------------------------------------- */
/* this function modifies the glyf and loca tables by copying only glyfs
 from the glyf table that are to be kept and changing the references in the loca
table so that they indicate zero length entries in the glyf table.
The described action is taken here to reduce the size of the font file. */
/* this function will work if a glyf and or loca table already exist in the output */
/* file or not */
/* ------------------------------------------------------------------- */
int16 ModGlyfLocaAndHead( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
						 TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
						 uint8 *puchKeepGlyphList, 
						 uint16 usGlyphCount,
						 uint32 *pCheckSumAdjustment,	/* this is returned to be saved with a subset1 or delta format font */
						 uint32 *pulNewOutOffset)
{

uint16 i;
uint16 usOffset;
uint16 usIdxToLocFmt;
uint16 usBytesWritten;
uint32 ulBytesWritten;
int16 errCode = NO_ERROR;
uint32 * aulLoca;
uint32 ulGlyphLength;
uint32 ulOutLoca;
uint32 ulGlyfOffset;
uint32 ulOutGlyfOffset;
uint32 ulOutGlyfDirectoryOffset;
uint32 ulHeadOffset;
uint32 ulOutLocaOffset;
uint32 ulOutLocaDirectoryOffset;
DIRECTORY LocaDirectory, GlyfDirectory;
HEAD Head;

/* allocate memory for and read loca table */

	aulLoca = Mem_Alloc( (usGlyphCount + 1) * sizeof( uint32 ));
	if ( aulLoca == NULL )
		return ERR_MEM;

	if (GetLoca((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, aulLoca, (uint16)(usGlyphCount + 1)) == 0L)
	{
		Mem_Free(aulLoca);
		return ERR_INVALID_LOCA;
	}

    if ((ulHeadOffset = GetHead(pOutputBufferInfo, &Head)) == 0L)
	{
		/* copy over head table. will update below */
		if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, HEAD_TAG, pulNewOutOffset))!=NO_ERROR)
		{
			Mem_Free(aulLoca);
			return errCode;
		}
		ulHeadOffset = GetHead(pOutputBufferInfo, &Head);
	}
	
	ulOutLoca     = 0L;
	ulGlyfOffset  = TTTableOffset( (TTFACC_FILEBUFFERINFO *)pInputBufferInfo, GLYF_TAG );
	if (ulGlyfOffset == DIRECTORY_ERROR) /* this should have been setup */
	{
		Mem_Free(aulLoca);
		return ERR_MISSING_GLYF; 
	}
	ulOutGlyfDirectoryOffset = GetTTDirectory( pOutputBufferInfo, GLYF_TAG, &GlyfDirectory); 
	/* make sure there is a directory entry */
	if (ulOutGlyfDirectoryOffset == DIRECTORY_ERROR) /* this should have been setup */
	{
		Mem_Free(aulLoca);
		return ERR_MISSING_GLYF; 
	}
	if (GlyfDirectory.offset == DIRECTORY_ERROR)
	{
		*pulNewOutOffset += ZeroLongWordAlign(pOutputBufferInfo, *pulNewOutOffset);
		GlyfDirectory.offset = *pulNewOutOffset;
	}

	ulOutGlyfOffset = GlyfDirectory.offset;

	/* go thru the glyf table, copying up the glyphs to be saved */
	for ( i = 0; i < usGlyphCount; i++ )
	{
		ulGlyphLength = 0L;
		if (puchKeepGlyphList[i])	/* we want to keep this one */
		{
			/* copy existing glyph data to new location */

			if ( aulLoca[ i ] < aulLoca[ i+1 ] )
				ulGlyphLength = aulLoca[ i+1 ] - aulLoca[ i ];

			if ( ulGlyphLength )
			{
				if ((errCode = CopyBlockOver( pOutputBufferInfo, pInputBufferInfo, ulOutGlyfOffset + ulOutLoca, 
						ulGlyfOffset + aulLoca[ i ], ulGlyphLength )) != NO_ERROR)
					break;
			}
		}
		assert((ulOutLoca & 1) != 1);
		aulLoca[ i ] = ulOutLoca;
		ulOutLoca += ulGlyphLength;
		if (ulOutLoca & 1)
		{  		/* the glyph offset is on an odd-byte boundry. get ready for next time */
			if ((errCode = WriteByte( pOutputBufferInfo, 0, ulOutGlyfOffset + ulOutLoca)) != NO_ERROR)
				break;
			++ulOutLoca;
		}
	}
	if (errCode == NO_ERROR)
	{
	/* The last loca entry is the end of the last glyph! */
		*pulNewOutOffset += ulOutLoca;
		aulLoca[ usGlyphCount ] = ulOutLoca;
		GlyfDirectory.length = ulOutLoca;
		errCode = WriteGeneric( pOutputBufferInfo, (uint8 *)&GlyfDirectory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOutGlyfDirectoryOffset, &usBytesWritten );
	}

	if (errCode != NO_ERROR)
	{
		Mem_Free(aulLoca);
		return errCode;
	}

 	/* write out the modified 'loca' table */
 
	ulOutLocaDirectoryOffset = GetTTDirectory( pOutputBufferInfo, LOCA_TAG, &LocaDirectory); 
	/* make sure there is a directory entry */
	if (ulOutLocaDirectoryOffset == DIRECTORY_ERROR) /* this should have been setup */
	{
		Mem_Free(aulLoca);
		return ERR_MISSING_LOCA;
	}

	*pulNewOutOffset += ZeroLongWordAlign(pOutputBufferInfo, *pulNewOutOffset);
	ulOutLocaOffset = LocaDirectory.offset = *pulNewOutOffset;	/* where to write the loca */

	/* Check to see what format to use */
	if (ulOutLoca <= 0x1FFFC)   /* maximum number stored here (0xFFFE * 2) Chosen as conservative value over 0xFFFF * 2 */
	{
		usIdxToLocFmt = SHORT_OFFSETS;
		for ( i = 0; i <= usGlyphCount; i++ )
		{
			assert((aulLoca[i] & 1) != 1);	 /* can't have this, would be truncated */
			usOffset = (uint16) (aulLoca[ i ] / 2L);
			if ((errCode = WriteWord( pOutputBufferInfo,  usOffset, ulOutLocaOffset + i*sizeof(uint16) )) != NO_ERROR)
				break;
		}
		ulOutLoca = (uint32) (usGlyphCount+1) * sizeof(uint16);
	}
	else
	{
		usIdxToLocFmt = LONG_OFFSETS;
		errCode = WriteGenericRepeat(pOutputBufferInfo,  (uint8 *) aulLoca, LONG_CONTROL,ulOutLocaOffset,&ulBytesWritten,(uint16) (usGlyphCount+1), sizeof(uint32)); 
		ulOutLoca = ulBytesWritten;
	}

	if (errCode == NO_ERROR)
	{
		/* update the length, etc. for the loca table as well */

		LocaDirectory.length = ulOutLoca;
		*pulNewOutOffset += ulOutLoca;
		if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &LocaDirectory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOutLocaDirectoryOffset, &usBytesWritten )) == NO_ERROR)
		{
			*pCheckSumAdjustment = Head.checkSumAdjustment;/* for use by dttf table */
			Head.checkSumAdjustment = 0L;	 /* needs to be 0 when setting the file checksum value */
			Head.indexToLocFormat = usIdxToLocFmt;
			errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &Head, SIZEOF_HEAD, HEAD_CONTROL, ulHeadOffset, &usBytesWritten);
		}
	}

	/* clean up */

	Mem_Free( aulLoca );
	return errCode;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\modsbit.h ===
/*
  * ModSBIT.h: Interface file for ModSBIT.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */
  
#ifndef MODSBIT_DOT_H_DEFINED
#define MODSBIT_DOT_H_DEFINED        

int16 ModSbit( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo,
			  TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
			  CONST uint8 *puchKeepGlyphList, 
			  CONST uint16 usGlyphListCount,  
			  uint32 *pulNewOutOffset);

#endif /* MODSBIT_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\modsbit.c ===
/***************************************************************************
 * module: modsbit.C
 *
 * author: Greg Hitchcock, Louise Pathe
 * date:   Dec, 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 **************************************************************************/

/* Inclusions ----------------------------------------------------------- */

#include <string.h>	/* for memset */
#include <assert.h>

#include "typedefs.h"
#include "ttferror.h"
#include "ttff.h"
#include "ttfacc.h"
#include "ttfcntrl.h"
#include "ttftabl1.h"
#include "ttftable.h"
#include "modsbit.h"
#include "ttmem.h"
#include "util.h"

/* ------------------------------------------------------------------- */
typedef struct {
	uint32 ulNewImageDataOffset;
	uint16 usOldGlyphIndex;
	uint16 usImageFormat;
	uint16 usIndexFormat;
} ImageDataBlock;  /* info on the Image Data, for shared image data */

typedef struct {
	uint32 ulOldOffset;
	ImageDataBlock ImageDataBlock;
} GlyphOffsetRecord;

typedef struct glyphoffsetrecordkeeper *PGLYPHOFFSETRECORDKEEPER;	 
typedef struct glyphoffsetrecordkeeper GLYPHOFFSETRECORDKEEPER;	 

struct glyphoffsetrecordkeeper	  /* housekeeping structure */
{  
	GlyphOffsetRecord *pGlyphOffsetArray;
	uint32 ulOffsetArrayLen;
	uint32 ulNextArrayIndex;
};

/* ------------------------------------------------------------------- */
PRIVATE int16 RecordGlyphOffset(PGLYPHOFFSETRECORDKEEPER pKeeper, 
							   uint32 ulOldOffset, 
							   ImageDataBlock * pImageDataBlock)  /* record this block as being used */
{

	if (pKeeper->ulNextArrayIndex >= pKeeper->ulOffsetArrayLen)
	{
	 	pKeeper->pGlyphOffsetArray = (GlyphOffsetRecord *) Mem_ReAlloc(pKeeper->pGlyphOffsetArray, (pKeeper->ulOffsetArrayLen + 100) * sizeof(*(pKeeper->pGlyphOffsetArray)));
 		if (pKeeper->pGlyphOffsetArray == NULL)
			return ERR_MEM; /* ("EBLC: Not enough memory to allocate Offset Array."); */
        memset((char *)(pKeeper->pGlyphOffsetArray) + (sizeof(*(pKeeper->pGlyphOffsetArray)) * pKeeper->ulOffsetArrayLen), '\0', sizeof(*(pKeeper->pGlyphOffsetArray)) * 100); 
		pKeeper->ulOffsetArrayLen += 100;
	}
	pKeeper->pGlyphOffsetArray[pKeeper->ulNextArrayIndex].ulOldOffset = ulOldOffset;
	pKeeper->pGlyphOffsetArray[pKeeper->ulNextArrayIndex].ImageDataBlock.ulNewImageDataOffset = pImageDataBlock->ulNewImageDataOffset ;
	pKeeper->pGlyphOffsetArray[pKeeper->ulNextArrayIndex].ImageDataBlock.usOldGlyphIndex = pImageDataBlock->usOldGlyphIndex;
	pKeeper->pGlyphOffsetArray[pKeeper->ulNextArrayIndex].ImageDataBlock.usImageFormat = pImageDataBlock->usImageFormat;
	pKeeper->pGlyphOffsetArray[pKeeper->ulNextArrayIndex].ImageDataBlock.usIndexFormat = pImageDataBlock->usIndexFormat;
	++(pKeeper->ulNextArrayIndex);
	return NO_ERROR;
}

/* ------------------------------------------------------------------- */
PRIVATE uint32 LookupGlyphOffset(PGLYPHOFFSETRECORDKEEPER pKeeper, 
								uint32 ulOldOffset, 
								ImageDataBlock *pImageDataBlock)
{
uint32 i;

	for (i = 0; i < pKeeper->ulNextArrayIndex; ++i)
	{
	 	if (ulOldOffset == pKeeper->pGlyphOffsetArray[i].ulOldOffset)
		{
			pImageDataBlock->ulNewImageDataOffset = pKeeper->pGlyphOffsetArray[i].ImageDataBlock.ulNewImageDataOffset;
			pImageDataBlock->usOldGlyphIndex = pKeeper->pGlyphOffsetArray[i].ImageDataBlock.usOldGlyphIndex;
			pImageDataBlock->usImageFormat = pKeeper->pGlyphOffsetArray[i].ImageDataBlock.usImageFormat;
			pImageDataBlock->usIndexFormat = pKeeper->pGlyphOffsetArray[i].ImageDataBlock.usIndexFormat;
			return (TRUE);
		}
	}
	return(FALSE);
}
/* ------------------------------------------------------------------- */
/* process one index subtable */
/* Note there are a few peculiar aspects to this function that have to do with code history and evolution.
   1. The EBLC data is read from the OutputBuffer, and entered into the puchIndexSubTable buffer. 
   2. No data is written to the OutputBuffer
   3. The EBDT data is read from the InputBufferInfo and written to the puchEBDTDestPtr buffer 
   4. There are many parameters that may be changed by this function. 
      pusNewFirstGlyphIndex,
      pusNewLastGlyphIndex,
      pulIndexSubTableSize,
	  pulEBDTBytesWritten,
	  pusTableSize
/* ------------------------------------------------------------------- */
PRIVATE int16 FixSbitSubTables(CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, /* input TTF data */
							  TTFACC_FILEBUFFERINFO * pOutputBufferInfo, /* output TTF data */
							  uint32 ulOffset, /* offset where to read the indexSubHeader (from the Output buffer) */ 
							  uint16 usOldFirstGlyphIndex, 	/* first glyph index of this subtable */
							  uint16 usOldLastGlyphIndex,  /* last glyph index of this subtable */
							  uint16 *pusNewFirstGlyphIndex, /* new first glyph index, after glyphs removed */
							  uint16 *pusNewLastGlyphIndex, /* new last glyph index, after glyphs removed */
							  uint8 ** ppuchIndexSubTable, /* pointer to buffer where IndexSubTable info is put. can be realloced  */
							  uint32 *pulIndexSubTableSize, /* Size of indexSubTable buffer - entire array - can be reset */
							  uint16 *pusTableSize,	/* Size of data written tppuchIndexSubTable. Platform dependent. Not true TTF table size. Updated when written to file */
							  uint32 ulCurrAdditionalOffset, /* AdditionalOffset of this item in SubTables array */ 
							  uint32 ulInitialOffset, /* ulCurrAdditionalOffset of first item in SubTables array */
							  CONST uint8 *puchKeepGlyphList, /* list of glyphs to keep */
							  CONST uint16 usGlyphListCount, /* number of glyphs in that list to keep */
							  uint32 ulImageDataOffset, /* offset into EBDT table of where to write the next ImageData */
							  uint32 *pulEBDTBytesWritten, /* number of bytes written to the EBDT table buffer */
							  uint8 *puchEBDTDestPtr, /* EBDT data byffer */
							  uint32 ulEBDTSrcOffset, /* beginning of EBDT table in the InputBufferInfo */
							  PGLYPHOFFSETRECORDKEEPER pKeeper)	 /* structure to keep track of multiply referenced EBDT data */
{
	INDEXSUBHEADER	IndexSubHeader;
	uint16		i;
	uint32		ulLocalCurrentOffset;/* offset relative to memory buffer, not indexSubTableArray */
	uint32		ulOldImageDataOffset;
	uint32		ulCurrentImageDataOffset;  /* place where current IndexSubTable is pointing - usually NewImageDataOffset */
	ImageDataBlock	ImageDataBlock;
	uint16		usIndexFormat;
	uint16		usOldGlyphCount;
	uint16		usGlyphIndex;
	uint16		usNextGlyphIndex;
	uint16		usTableSize;
	uint32		ulNumGlyphs;
	BOOL		DoCopy = TRUE; /* copy glyph imgage data or not */ 
	int16		errCode;
	uint16		usBytesRead;
 	uint32		ulNewGlyphOffset;	/* the new offset in the new Glyph table */
 	uint32		ulOldGlyphOffset;	/* the Old offset of the glyph */
	uint32		ulNextGlyphOffset;	/* the offset of the glyph after this glyph, to calculate length */
	uint32		ulGlyphLength;
 	uint16		usOldGlyphOffset;	/* the old offset of the glyph */
	uint16		usNextGlyphOffset;	/* the offset of the glyph after this glyph, to calculate length */
	uint16		usNewGlyphOffset;	/* the new offset in the new Glyph table */
	uint16		usGlyphLength;
	TTFACC_FILEBUFFERINFO LocalBufferInfo;  /* for copying data to *ppuchIndexSubTable */

	if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &IndexSubHeader, SIZEOF_INDEXSUBHEADER, INDEXSUBHEADER_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR)
		return errCode;
	/* ulOffset += usBytesRead;   don't increment because we will read again */
	usIndexFormat = IndexSubHeader.usIndexFormat;
	ulOldImageDataOffset = IndexSubHeader.ulImageDataOffset;	  /* save the old one */
	ulCurrentImageDataOffset = ulImageDataOffset;
	ulNewGlyphOffset = 0;
	*pulEBDTBytesWritten = 0;
	*pusTableSize = 0;
	LocalBufferInfo.puchBuffer = *ppuchIndexSubTable;


	if (LookupGlyphOffset(pKeeper, ulOldImageDataOffset, &ImageDataBlock) == FALSE)  /* glyph range not copied already */
	{   /* use the current last offset into glyph area */
		ImageDataBlock.ulNewImageDataOffset = ulCurrentImageDataOffset; 
		ImageDataBlock.usIndexFormat = IndexSubHeader.usIndexFormat;
		ImageDataBlock.usImageFormat = IndexSubHeader.usImageFormat;
		ImageDataBlock.usOldGlyphIndex = usOldFirstGlyphIndex;
		if ((errCode = RecordGlyphOffset(pKeeper, ulOldImageDataOffset, &ImageDataBlock)) != NO_ERROR)  /* record this block as being used */
			return errCode;
	}
	else
	{
#if 0
		if (ImageDataBlock.usOldGlyphIndex != usOldFirstGlyphIndex)
			return(NO_ERROR); /* don't copy anything */
		if (ImageDataBlock.usIndexFormat != IndexSubHeader.usIndexFormat || 
			ImageDataBlock.usImageFormat != IndexSubHeader.usImageFormat ) 
			return(NO_ERROR); /* copy nothing */
#endif
		if (ImageDataBlock.usImageFormat != IndexSubHeader.usImageFormat ) 
			return(NO_ERROR); /* copy nothing */
		DoCopy = FALSE;   /* Copy the IndexSubTable, but don't copy the glyphs over */
		ulCurrentImageDataOffset = ImageDataBlock.ulNewImageDataOffset; /* need to set the pointers here */
	}

		
	ulLocalCurrentOffset = ulCurrAdditionalOffset - ulInitialOffset; /* offset within memory buffer */
	/* For each of the five cases below we will:
		1. Read from File the structure and any attached arrays, translating to Intel format on the way. 
		3. Copy to a memory buffer the newly translated table, compressing from both ends if
		   the range of the subtable has shrunk, that is if the first and or last char was 
		   deleted from the file.
		4. return the length of the subtable to the caller, so additionalOffsetToIndex values
		   may be calculated.
    */
	assert(usOldLastGlyphIndex >= usOldFirstGlyphIndex);
	usOldGlyphCount = usOldLastGlyphIndex - usOldFirstGlyphIndex+1;
	switch (usIndexFormat)
	{
		case 1:	   /* leave as a 1 for now. Eventually change to a 3 */
		{
			INDEXSUBTABLE1	IndexSubTable1;

				if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &IndexSubTable1, SIZEOF_INDEXSUBTABLE1, INDEXSUBTABLE1_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR)
					return errCode;
				ulOffset += usBytesRead;
				IndexSubTable1.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */
				memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset, &IndexSubTable1, SIZEOF_INDEXSUBTABLE1);
				usTableSize = SIZEOF_INDEXSUBTABLE1;
                         
				ulNewGlyphOffset = 0;
				if ((errCode = ReadLong( pOutputBufferInfo, &ulOldGlyphOffset, ulOffset)) != NO_ERROR) 
					return errCode;
				ulOffset += sizeof(ulOldGlyphOffset);
				for( i = 0; i < usOldGlyphCount; i++ )
				{
					if ((errCode = ReadLong( pOutputBufferInfo,  &ulNextGlyphOffset, ulOffset )) != NO_ERROR) 
						return errCode;
					ulOffset += sizeof(ulNextGlyphOffset);
					usGlyphIndex = usOldFirstGlyphIndex+i;
					if (usGlyphIndex > *pusNewLastGlyphIndex)	   /* test for the last one */
						break;
					if (usGlyphIndex >= *pusNewFirstGlyphIndex) /* haven't started the table yet */
					{
					 /* if the indexTableSize length field was incorrect */
					 /* use 2* to account for the extra offset at the end */
				 		if (ulLocalCurrentOffset + usTableSize + (2 * sizeof(ulNewGlyphOffset)) > *pulIndexSubTableSize)
							return ERR_INVALID_EBLC;

						memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset+usTableSize, &ulNewGlyphOffset, 
								sizeof(ulNewGlyphOffset));		/* copy over the table entry regardless of whether glyph is to be kept. */
						usTableSize +=sizeof(ulNewGlyphOffset);	/* update the size of the table */
						if (puchKeepGlyphList[usGlyphIndex])	/* if this glyph is supposed to be kept, copy glyph. */
						{
							assert(ulNextGlyphOffset >= ulOldGlyphOffset);
							ulGlyphLength = ulNextGlyphOffset-ulOldGlyphOffset;
							if (DoCopy)
							{
								if ((errCode = ReadBytes((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, puchEBDTDestPtr + IndexSubTable1.header.ulImageDataOffset + ulNewGlyphOffset,
										  ulEBDTSrcOffset + ulOldImageDataOffset + ulOldGlyphOffset, 
										  ulGlyphLength)) != NO_ERROR)
									return errCode;
							}
							ulNewGlyphOffset += ulGlyphLength;
						}
					}
					ulOldGlyphOffset = ulNextGlyphOffset;
				}
				if (ulNewGlyphOffset == 0)
					return NO_ERROR; /* don't copy */
				/* Do the last table entry, which is just for Glyph size calculation purposes */
				memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset+usTableSize, &ulNewGlyphOffset,sizeof(ulNewGlyphOffset));
				usTableSize +=sizeof(ulNewGlyphOffset);
				break;
		}
		case 2:	/* need to turn a format 2 into a format 5 if any middle glyphs are deleted */
		{		 
			INDEXSUBTABLE2 IndexSubTable2;
			INDEXSUBTABLE5 IndexSubTable5;
			uint16 *ausGlyphCodeArray = NULL;

				if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &IndexSubTable2, SIZEOF_INDEXSUBTABLE2, INDEXSUBTABLE2_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR) 
					return errCode;
				ulOffset += usBytesRead;
				IndexSubTable2.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */
				ulNewGlyphOffset = 0;
				ulOldGlyphOffset = 0;
				ulGlyphLength = IndexSubTable2.ulImageSize;
				/* in case we have to change to format 5 */
				memcpy(&IndexSubTable5, &IndexSubTable2, SIZEOF_INDEXSUBTABLE2);
				IndexSubTable5.header.usIndexFormat = 5;
				IndexSubTable5.ulNumGlyphs = 0;
				for (i = *pusNewFirstGlyphIndex; i <= *pusNewLastGlyphIndex; ++i)
				{
					if (puchKeepGlyphList[i])
						++IndexSubTable5.ulNumGlyphs;
				}
				if (IndexSubTable5.ulNumGlyphs == 0)
					return NO_ERROR; /* don't copy */
				/*  check if there are any gaps */
				if (IndexSubTable5.ulNumGlyphs != (uint32) (*pusNewLastGlyphIndex - *pusNewFirstGlyphIndex + 1)) /* not sparse, we got everyone */
				{
					ausGlyphCodeArray = (uint16 *) Mem_Alloc(sizeof(uint16) * IndexSubTable5.ulNumGlyphs);
					/* Need to enlarge pointer too by the difference between Format 2 and format 5 */
					*pulIndexSubTableSize += (IndexSubTable5.ulNumGlyphs * sizeof(uint16) + sizeof(uint32));
					*ppuchIndexSubTable = Mem_ReAlloc(*ppuchIndexSubTable, *pulIndexSubTableSize); 
					if ((ausGlyphCodeArray == NULL) || (*ppuchIndexSubTable == NULL))
					{
						Mem_Free(ausGlyphCodeArray);
						return ERR_MEM;
					}
				}

				IndexSubTable5.ulNumGlyphs = 0;
				for (i = usOldFirstGlyphIndex; i <= usOldLastGlyphIndex; ++i)
				{
					if (i < usGlyphListCount && puchKeepGlyphList[i])
					{
						if (ausGlyphCodeArray != NULL)
							ausGlyphCodeArray[IndexSubTable5.ulNumGlyphs++] = i;
						if (DoCopy)	/* if this glyph is supposed to be kept, copy glyph. */
						{
							if ((errCode = ReadBytes( (TTFACC_FILEBUFFERINFO *)pInputBufferInfo, puchEBDTDestPtr + IndexSubTable2.header.ulImageDataOffset + ulNewGlyphOffset,
								      ulEBDTSrcOffset + ulOldImageDataOffset + ulOldGlyphOffset, 
								      ulGlyphLength)) != NO_ERROR)
							{
								Mem_Free(ausGlyphCodeArray); /* in case it got allocated */
								return errCode;
							}
						}
						ulNewGlyphOffset += ulGlyphLength;
					}
					ulOldGlyphOffset += ulGlyphLength;
				}
 				if (ulNewGlyphOffset == 0)
				{
					Mem_Free(ausGlyphCodeArray); /* in case it got allocated */
					return NO_ERROR; /* don't copy */
				}

 				if (ausGlyphCodeArray != NULL) /* we changed to format 5 */
				{
 					usTableSize = (uint16)(SIZEOF_INDEXSUBTABLE5 + sizeof(*ausGlyphCodeArray) * IndexSubTable5.ulNumGlyphs);
				 	if (ulLocalCurrentOffset + usTableSize > *pulIndexSubTableSize)
					{
						Mem_Free(ausGlyphCodeArray); /* in case it got allocated */
						return ERR_INVALID_EBLC;
					}
 					memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset, &IndexSubTable5, SIZEOF_INDEXSUBTABLE5);
					memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset + SIZEOF_INDEXSUBTABLE5, ausGlyphCodeArray, sizeof(*ausGlyphCodeArray) * IndexSubTable5.ulNumGlyphs);
					Mem_Free(ausGlyphCodeArray);
				}
 				else
				{
					usTableSize = SIZEOF_INDEXSUBTABLE2;
 				 	if (ulLocalCurrentOffset + usTableSize > *pulIndexSubTableSize)
						return ERR_INVALID_EBLC;
					memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset, &IndexSubTable2, usTableSize);
				}
				break;
		}
		case 3:	/* just like format 1, but with short offsets instead */
		{
			INDEXSUBTABLE3	IndexSubTable3;

				if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &IndexSubTable3, SIZEOF_INDEXSUBTABLE3, INDEXSUBTABLE3_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR) 
					return errCode;
				ulOffset += usBytesRead;
				IndexSubTable3.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */
				memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset, &IndexSubTable3, SIZEOF_INDEXSUBTABLE3);
				usTableSize = SIZEOF_INDEXSUBTABLE3;

				usNewGlyphOffset = 0;
				if ((errCode = ReadWord( pOutputBufferInfo, &usOldGlyphOffset, ulOffset)) != NO_ERROR) 
					return errCode;
				ulOffset += sizeof(uint16);
				for( i = 0; i < usOldGlyphCount; i++ )
				{
					if ((errCode = ReadWord( pOutputBufferInfo,  &usNextGlyphOffset, ulOffset )) != NO_ERROR) 
						return errCode;
					ulOffset += sizeof(uint16);
					usGlyphIndex = usOldFirstGlyphIndex+i;
					if (usGlyphIndex > *pusNewLastGlyphIndex)	   /* test for the last one */
						break;
					if (usGlyphIndex >= *pusNewFirstGlyphIndex) /* haven't started the table yet */

					{
					/* if the indexTableSize length field was incorrect */
					 /* use 2* to account for the extra offset at the end */
				 		if (ulLocalCurrentOffset + usTableSize + (2 * sizeof(usNewGlyphOffset)) > *pulIndexSubTableSize)
							return ERR_INVALID_EBLC;
						memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset+usTableSize, &usNewGlyphOffset, 
								sizeof(usNewGlyphOffset));		/* copy over the table entry */
						usTableSize +=sizeof(usNewGlyphOffset);	/* update the size of the table */
						if (puchKeepGlyphList[usGlyphIndex])	/* if this glyph is supposed to be kept, copy glyph. */
						{
							assert(usNextGlyphOffset>=usOldGlyphOffset);
							usGlyphLength = usNextGlyphOffset-usOldGlyphOffset;
							if (DoCopy)
							{
								if ((errCode = ReadBytes( (TTFACC_FILEBUFFERINFO *) pInputBufferInfo, puchEBDTDestPtr + IndexSubTable3.header.ulImageDataOffset + usNewGlyphOffset,
										  ulEBDTSrcOffset + ulOldImageDataOffset + usOldGlyphOffset, 
										  usGlyphLength)) != NO_ERROR)
									return errCode;
							}
							usNewGlyphOffset += usGlyphLength;
						}
					}
					usOldGlyphOffset = usNextGlyphOffset;
				}
				if (usNewGlyphOffset == 0)
					return NO_ERROR; /* don't copy */
			/* Do the last table entry, which is just for Glyph size calculation purposes */
				memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset+usTableSize, &usNewGlyphOffset,sizeof(usNewGlyphOffset));
				usTableSize +=sizeof(usNewGlyphOffset);
				ulNewGlyphOffset = usNewGlyphOffset;
				break;
		}
		case 4:
		{
			INDEXSUBTABLE4	IndexSubTable4;
			CODEOFFSETPAIR	CodeOffsetPair;
			uint16	usFormat4FirstGlyphIndex = 0; /* need to set to return to caller */

				if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &IndexSubTable4, SIZEOF_INDEXSUBTABLE4, INDEXSUBTABLE4_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR) 
					return errCode;
				ulOffset += usBytesRead;
				IndexSubTable4.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */
				usTableSize = SIZEOF_INDEXSUBTABLE4;
				usNewGlyphOffset = 0;
				assert(IndexSubTable4.ulNumGlyphs <= USHRT_MAX);
				usOldGlyphCount = (uint16) IndexSubTable4.ulNumGlyphs;

				if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &CodeOffsetPair, SIZEOF_CODEOFFSETPAIR, CODEOFFSETPAIR_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR) 
					return errCode;
				ulOffset += usBytesRead;
				usGlyphIndex = CodeOffsetPair.usGlyphCode;
				usOldGlyphOffset = CodeOffsetPair.usOffset;	  
				for( i = 0, ulNumGlyphs = 0;  (i < usOldGlyphCount) && usGlyphIndex <= usOldLastGlyphIndex; ++i)
				{
					if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &CodeOffsetPair, SIZEOF_CODEOFFSETPAIR, CODEOFFSETPAIR_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR) 
						return errCode;
					ulOffset += usBytesRead;
					usNextGlyphIndex = CodeOffsetPair.usGlyphCode;
					usNextGlyphOffset = CodeOffsetPair.usOffset;
					if (usGlyphIndex < usGlyphListCount && puchKeepGlyphList[usGlyphIndex])  /* don't copy entry if there is no glyph */
					{
						if (usFormat4FirstGlyphIndex == 0) /* haven't set yet */
							usFormat4FirstGlyphIndex = usGlyphIndex;
					 /* if the indexTableSize length field was incorrect */
					 /* use 2* to account for the extra offset at the end */
					 	if (ulLocalCurrentOffset + usTableSize + (2 * SIZEOF_CODEOFFSETPAIR) > *pulIndexSubTableSize)
							return ERR_INVALID_EBLC;
						memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset+usTableSize, &usGlyphIndex, sizeof(usGlyphIndex));
						usTableSize +=sizeof(usGlyphIndex);
						memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset+usTableSize, &usNewGlyphOffset, sizeof(usNewGlyphOffset));
						usTableSize +=sizeof(usNewGlyphOffset);
						usGlyphLength = usNextGlyphOffset-usOldGlyphOffset;
						if (DoCopy)
						{
							if ((errCode = ReadBytes( (TTFACC_FILEBUFFERINFO *) pInputBufferInfo, puchEBDTDestPtr + IndexSubTable4.header.ulImageDataOffset + usNewGlyphOffset,
								      ulEBDTSrcOffset + ulOldImageDataOffset + usOldGlyphOffset, 
								      usGlyphLength)) != NO_ERROR)
								return errCode;
						}

						usNewGlyphOffset += usGlyphLength;
						++ulNumGlyphs;
						*pusNewLastGlyphIndex = usGlyphIndex; 
					}
					usOldGlyphOffset = usNextGlyphOffset;
					usGlyphIndex = usNextGlyphIndex;
				}
				if (ulNumGlyphs == 0)
					return NO_ERROR;	   /* don't copy this one */

				/* Do the last one, which is used for Glyph size calculation */
				CodeOffsetPair.usGlyphCode = 0;
				CodeOffsetPair.usOffset = usNewGlyphOffset;
				memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset+usTableSize, &CodeOffsetPair, SIZEOF_CODEOFFSETPAIR);
				usTableSize += SIZEOF_CODEOFFSETPAIR;
				/* now copy the SubTable header entry */
				IndexSubTable4.ulNumGlyphs = ulNumGlyphs;
				memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset, &IndexSubTable4, SIZEOF_INDEXSUBTABLE4);
				*pusNewFirstGlyphIndex = usFormat4FirstGlyphIndex; /* set this for updating above */
				ulNewGlyphOffset = usNewGlyphOffset;
				break;
		}
		case 5:
		{
			INDEXSUBTABLE5	IndexSubTable5;
			uint16 usFormat5FirstGlyphIndex = 0;

				if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &IndexSubTable5, SIZEOF_INDEXSUBTABLE5, INDEXSUBTABLE5_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR) 
					return errCode;
				ulOffset += usBytesRead;
				IndexSubTable5.header.ulImageDataOffset = ulCurrentImageDataOffset;  /* set to the new one */
				usTableSize = SIZEOF_INDEXSUBTABLE5;
				ulNewGlyphOffset = 0;
				ulOldGlyphOffset = 0;
				ulGlyphLength = IndexSubTable5.ulImageSize;

				assert(IndexSubTable5.ulNumGlyphs <= USHRT_MAX);
				usOldGlyphCount = (uint16) IndexSubTable5.ulNumGlyphs;
				for( i = 0, usGlyphIndex = 0, ulNumGlyphs = 0; (i < usOldGlyphCount) && (usGlyphIndex < usOldLastGlyphIndex); ++i )
				{
					if ((errCode = ReadWord( pOutputBufferInfo, &usGlyphIndex,ulOffset)) != NO_ERROR) 
						return errCode;
					ulOffset += sizeof(uint16);

					if (usGlyphIndex < usGlyphListCount && puchKeepGlyphList[usGlyphIndex])
					{
						if (usFormat5FirstGlyphIndex == 0)
							usFormat5FirstGlyphIndex = usGlyphIndex;
					 /* if the indexTableSize length field was incorrect */
					 	if (ulLocalCurrentOffset + usTableSize + sizeof(usGlyphIndex) > *pulIndexSubTableSize)
							return ERR_INVALID_EBLC;
						memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset+usTableSize, &usGlyphIndex, sizeof(usGlyphIndex));
						usTableSize += sizeof(usGlyphIndex);
						if (DoCopy)
						{
							if ((errCode = ReadBytes( (TTFACC_FILEBUFFERINFO *) pInputBufferInfo, puchEBDTDestPtr + IndexSubTable5.header.ulImageDataOffset + ulNewGlyphOffset,
								      ulEBDTSrcOffset + ulOldImageDataOffset + ulOldGlyphOffset, 
								      ulGlyphLength)) != NO_ERROR)
								return errCode;
						}
						++ulNumGlyphs;
						ulNewGlyphOffset += ulGlyphLength;
						*pusNewLastGlyphIndex = usGlyphIndex; 
					}
					ulOldGlyphOffset += ulGlyphLength;  /* increment regardless */
				}
				if (ulNumGlyphs == 0)
					return (NO_ERROR);	   /* don't copy this one */
				/* now copy the IndexSubTable5 entry */
				IndexSubTable5.ulNumGlyphs = ulNumGlyphs;
				memcpy(*ppuchIndexSubTable + ulLocalCurrentOffset, &IndexSubTable5, SIZEOF_INDEXSUBTABLE5);

				*pusNewFirstGlyphIndex = usFormat5FirstGlyphIndex; /* set this for updating above */

				break;
		}
		default:
			return(NO_ERROR);	  /* don't copy ! */
			break;

	}
	usTableSize = (uint16) RoundToLongWord((uint32)usTableSize);  /* if we aren't on a long word boundary */

	if (DoCopy)
		*pulEBDTBytesWritten = ulNewGlyphOffset;
	*pusTableSize = usTableSize;
	return NO_ERROR;
}


/* ------------------------------------------------------------------- */
typedef struct {
	uint32 ulNumSubTables; /* number of array elements allocated */
	INDEXSUBTABLEARRAY * pIndexSubTableArray; /* pointer to memory to hold IndexSubTableArray */
	uint32 nIndexSubTablesLen;
	uint8 * puchIndexSubTables; /* pointer to memory to hold IndexSubTables */
	BITMAPSIZETABLE bmSizeTable; /* values in these point to memory based info. Then at write time are updated to reflect file buffer info */
} SubTablePointers;

/* ------------------------------------------------------------------- */
/* this routine will take a format 1 SubTable and convert it into 1+ format */
/* 3 subtables. This should result in a space savings. */
/* this only works because we assume the size of the puchIndexSubTable will get smaller */
/* this is not true IFF: */
/* The format 1 table is broken into greater than 1 format 3 tables AND */
/* each Format 3 table contains < 4 glyphs */
/* this is HIGHLY unlikely, as this would mean that the glyph data size */
/* would average 0x4000 bytes per glyph */
/* There is an error reported if this occurs */
/* ------------------------------------------------------------------- */

PRIVATE uint16 FixSbitSubTableFormat1(uint16 usFirstIndex, /* index of first Glyph in table */
									uint16 * pusLastIndex, /* pointer to index of last glyph in table - will set if not all table will fit */
			         				uint8 * puchIndexSubTable, /* buffer into which to stuff the Format 3 table(s) - does not include IndexSubTableArray */
									uint16 usImageFormat,  /* in order to set the Format 3 header */
			         				uint32 ulCurrAdditionalOffset, 	/* offset from indexSubTableArray of the IndexSubTable */ 
			         				uint32 ulInitialOffset,  /* relative offset from IndexSubTableArray of first IndexSubTable - same as CurrAdditionalOffset for first SubTable */
									uint32 *pulSourceOffset, /* pointer to offset to first offset in the Format 1 SubTable offsetArray */
			         				uint32 *pulNewImageDataOffset) /* updated to point to Next block of ImageData */
{
INDEXSUBTABLE3 IndexSubTable3;
uint32 ulNewGlyphOffset;	/* the long version of the offset */
uint16 usNewGlyphOffset;	/* the new offset in the new Glyph table */
uint32 ulLocalCurrentOffset;
uint16 usTableSize;
uint32 ulAdjustGlyphOffset;	  /* amount to subtract to get the relative offset */
uint16 usIndex;

		ulLocalCurrentOffset = ulCurrAdditionalOffset - ulInitialOffset; /* offset within memory buffer */

		IndexSubTable3.header.usImageFormat = usImageFormat;
		IndexSubTable3.header.usIndexFormat = 3;
		IndexSubTable3.header.ulImageDataOffset = *pulNewImageDataOffset;  /* set to the new one */
		memcpy(puchIndexSubTable + ulLocalCurrentOffset, &IndexSubTable3, SIZEOF_INDEXSUBTABLE3);
		usTableSize = SIZEOF_INDEXSUBTABLE3;

		ulAdjustGlyphOffset = * ((uint32 *) (puchIndexSubTable + *pulSourceOffset));   /* first offset is what we adjust from */
		ulNewGlyphOffset = (* ((uint32 *) (puchIndexSubTable + *pulSourceOffset))) - ulAdjustGlyphOffset;	  /* first one of array */
		*pulSourceOffset += sizeof(uint32);

		for( usIndex = usFirstIndex; usIndex <= (* pusLastIndex); ++usIndex )
		{
			usNewGlyphOffset = (uint16) ulNewGlyphOffset;  /* short version of the new glyph offset */
			/* now grab the next one */
			ulNewGlyphOffset = (* ((uint32 *) (puchIndexSubTable + *pulSourceOffset))) - ulAdjustGlyphOffset;

			if (ulNewGlyphOffset > USHRT_MAX)	 /* we need to go to the next table */
				break;

			*pulSourceOffset += sizeof(uint32); /* copied this one */
			
			memcpy(puchIndexSubTable + ulLocalCurrentOffset+usTableSize, &usNewGlyphOffset, 
						sizeof(usNewGlyphOffset));		/* copy over the table entry */
			usTableSize +=sizeof(usNewGlyphOffset);	/* update the size of the table */
		}
		if (usIndex > (* pusLastIndex))	/* we need to grab one more */
			usNewGlyphOffset = (uint16) ulNewGlyphOffset;  /* short version of the new glyph offset */
		else if (usIndex - usFirstIndex < 4) /* our break even point for staying within the buffer */
			return 0; /* ("EBLC: Internal. Cannot convert this Format1 table to format 3. Glyph Data too large.");  */
		*pulNewImageDataOffset += usNewGlyphOffset;	

		if (usIndex > (* pusLastIndex))	/* we need to copy one more */
		/* Do the last table entry, which is just for Glyph size calculation purposes */
		{
			memcpy(puchIndexSubTable + ulLocalCurrentOffset+usTableSize, &usNewGlyphOffset,sizeof(usNewGlyphOffset));
			usTableSize +=sizeof(usNewGlyphOffset);
		}
		/* do we need to pad? */
		if (usTableSize & 0x03)  /* if we aren't on a long word boundary */
			usTableSize +=sizeof(usNewGlyphOffset);
		*pusLastIndex = usIndex - 1; /* the one we were working on last */
		return(usTableSize);
}

/* ------------------------------------------------------------------- */
/* process all IndexSubTables in an IndexSubTable Array */
/* ------------------------------------------------------------------- */
PRIVATE int16 FixSbitSubTableArray(CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo,
								  TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
						  uint32 ulOffset,
						  SubTablePointers *pSubTablePointers, /* structure of vital data to modify */
						  CONST uint8 *puchKeepGlyphList, 
						  CONST uint16 usGlyphListCount,
						  uint32 *pulNewImageDataOffset,
						  uint8 *puchEBDTDestPtr,
						  uint32 ulEBDTSrcOffset,
						  PGLYPHOFFSETRECORDKEEPER pKeeper)
{
	INDEXSUBTABLEARRAY IndexSubTableArray;
	uint32		ulSubTableArrayIndex;
	uint32		ulIndexTableOffset;
	uint32		ulCurrAdditionalOffset;
	uint32		ulInitialOffset;
	uint32		ulNewNumSubTables = 0;
	uint32		ulSubTableArrayCount;  /* can be updated when making format 3 tables from format 1 tables */
	uint32		ulSaveImageDataOffset;
	uint32		ulSaveNumSubTables;
	uint32		ulIndexSubTableArrayOffset;
	int32		lAdjust; /* used to adjust Additional Offset values */
	uint16 		usFirstIndex;
	uint16		usLastIndex;
	uint16		usSaveFirstIndex;
	uint16 		usSaveLastIndex;
	uint16		usIndexSubTableSize;
	uint16 		usBytesRead;
	int16 		errCode;
	uint32		ulEBDTBytesWritten;

	ulIndexSubTableArrayOffset = ulOffset; /* need this for additional offsetting */
	ulInitialOffset = pSubTablePointers->ulNumSubTables * GetGenericSize(INDEXSUBTABLEARRAY_CONTROL);
	ulSaveNumSubTables = ulSubTableArrayCount = pSubTablePointers->ulNumSubTables;
	ulCurrAdditionalOffset = ulInitialOffset;  /* first location */ 

	for( ulSubTableArrayIndex = 0; ulSubTableArrayIndex < ulSaveNumSubTables; ulSubTableArrayIndex++)
	{
		if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &IndexSubTableArray, SIZEOF_INDEXSUBTABLEARRAY, INDEXSUBTABLEARRAY_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR) 
			return errCode;
		ulOffset += usBytesRead;
		ulIndexTableOffset = IndexSubTableArray.ulAdditionalOffsetToIndexSubtable;
		if (ulIndexTableOffset >= pSubTablePointers->nIndexSubTablesLen + ulInitialOffset)	 /* if input data is bad */
		{
			return ERR_INVALID_EBLC;
		/*
			sprintf(szErrorBuf, "EBLC: File input error. Trying to read at offset %u when %u specified as indexTableSize.\n",
					ulIndexTableOffset, pSubTablePointers->nIndexSubTablesLen + ulInitialOffset);
			fatal_err(szErrorBuf);
		*/
		}
		usSaveFirstIndex = usFirstIndex = IndexSubTableArray.usFirstGlyphIndex;
		usSaveLastIndex = usLastIndex = IndexSubTableArray.usLastGlyphIndex;

		if (usFirstIndex >= usGlyphListCount)
			continue;

		 if (usLastIndex >= usGlyphListCount)
			 usLastIndex = usGlyphListCount-1;

		while (!puchKeepGlyphList[usFirstIndex] && (usFirstIndex < usLastIndex)) 
			  ++usFirstIndex;

		while (!puchKeepGlyphList[usLastIndex] && (usLastIndex > usFirstIndex))
			--usLastIndex;

		if ((usFirstIndex == usLastIndex) && !puchKeepGlyphList[usLastIndex])  /* if there are not still characters */
			continue;
		ulSaveImageDataOffset = *pulNewImageDataOffset;
		errCode = FixSbitSubTables(pInputBufferInfo,
								pOutputBufferInfo,
								ulIndexSubTableArrayOffset + ulIndexTableOffset, 
								usSaveFirstIndex, usSaveLastIndex, &usFirstIndex, &usLastIndex,
			         			&(pSubTablePointers->puchIndexSubTables), 
			         			&(pSubTablePointers->nIndexSubTablesLen), /* can be realloced */
								&usIndexSubTableSize,
								ulCurrAdditionalOffset, 
			         			ulInitialOffset, 
			         			puchKeepGlyphList, 
			         			usGlyphListCount, 
			         			*pulNewImageDataOffset,
								&ulEBDTBytesWritten,
			         			puchEBDTDestPtr,
			         			ulEBDTSrcOffset,
								pKeeper);
		if (errCode != NO_ERROR)
			return errCode;
		if (usIndexSubTableSize > 0)   /* entry may not have been copied if it is in error, or all things were deleted  */
		{
			*pulNewImageDataOffset += ulEBDTBytesWritten;
			if (((INDEXSUBHEADER *) (pSubTablePointers->puchIndexSubTables + ulCurrAdditionalOffset - ulInitialOffset))->usIndexFormat != 1)  /* just copy */
			{
				IndexSubTableArray.usFirstGlyphIndex = usFirstIndex;
		 		IndexSubTableArray.usLastGlyphIndex = usLastIndex;
				IndexSubTableArray.ulAdditionalOffsetToIndexSubtable = ulCurrAdditionalOffset;
			   	memcpy((char *)(pSubTablePointers->pIndexSubTableArray + ulNewNumSubTables), (char *) &IndexSubTableArray, SIZEOF_INDEXSUBTABLEARRAY);
				ulCurrAdditionalOffset += usIndexSubTableSize;
				++ulNewNumSubTables;  /* increment for the count of subtables */
			}
			else  /* we want to change this Format 1 to a bunch of 3s */
			{
				BOOL Done = FALSE;
				/* calculate a relative offset to the first offsetArray element to use */
				uint32 ulSourceOffset = SIZEOF_INDEXSUBTABLE1 + ulCurrAdditionalOffset-ulInitialOffset /* + ((usFirstIndex - usSaveFirstIndex) * sizeof(uint32))*/;

				usSaveFirstIndex = usFirstIndex;
				usSaveLastIndex = usLastIndex;
				while (!Done)
				{
					usIndexSubTableSize = FixSbitSubTableFormat1( 
								usFirstIndex, 
								&usLastIndex, 
			         			pSubTablePointers->puchIndexSubTables, 
			         			((INDEXSUBHEADER *) (pSubTablePointers->puchIndexSubTables + ulCurrAdditionalOffset-ulInitialOffset))->usImageFormat,
			         			ulCurrAdditionalOffset, 
			         			ulInitialOffset,
			         			&ulSourceOffset, 
			         			&ulSaveImageDataOffset);
					
					if (usIndexSubTableSize == 0)  /* changing to format 3 would cause it to GROW */
						return ERR_GENERIC;  /* oops, didn't work */

					IndexSubTableArray.usFirstGlyphIndex = usSaveFirstIndex;
			 		IndexSubTableArray.usLastGlyphIndex = usSaveLastIndex;
					IndexSubTableArray.ulAdditionalOffsetToIndexSubtable = ulCurrAdditionalOffset;
				   	memcpy((char *)(pSubTablePointers->pIndexSubTableArray + ulNewNumSubTables), (char *) &IndexSubTableArray, SIZEOF_INDEXSUBTABLEARRAY);
					ulCurrAdditionalOffset += usIndexSubTableSize;
					++ulNewNumSubTables;  /* increment for the count of subtables */
					++ulSubTableArrayCount;
					if (usLastIndex == usSaveLastIndex)
						Done = TRUE;
					else
					{	 /* lcp 12-2-96 - ahh, this realloc is Wrong! need to add to the ulSaveNumSubTables! */
						pSubTablePointers->pIndexSubTableArray = Mem_ReAlloc(pSubTablePointers->pIndexSubTableArray, /* ulNewNumSubTables */ ulSubTableArrayCount * SIZEOF_INDEXSUBTABLEARRAY);
						if (pSubTablePointers->pIndexSubTableArray == NULL)
							return ERR_MEM; /* ("EBLC: Unable to allocate memory for IndexSubTableArray."); */
						usFirstIndex = usLastIndex;
						usLastIndex = usSaveLastIndex;
					}
				}
				if (ulSaveImageDataOffset != *pulNewImageDataOffset)
					return ERR_GENERIC; /* fatal_err("EBLC: Internal calculation error for Format 1 to Format 3 conversion.");	*/
			}
		}
	}
	/* if we got larger or smaller, adjust additional offset values */
 	lAdjust = (ulNewNumSubTables - ulSaveNumSubTables) * GetGenericSize(INDEXSUBTABLEARRAY_CONTROL); 
	for( ulSubTableArrayIndex = 0; ulSubTableArrayIndex < ulNewNumSubTables; ulSubTableArrayIndex++)
		(pSubTablePointers->pIndexSubTableArray)[ulSubTableArrayIndex].ulAdditionalOffsetToIndexSubtable += lAdjust;

	pSubTablePointers->bmSizeTable.ulIndexTablesSize = ulCurrAdditionalOffset;  /* update with size of table - memory version, not file version */
	pSubTablePointers->ulNumSubTables = pSubTablePointers->bmSizeTable.ulNumberOfIndexSubTables = ulNewNumSubTables;
	return(NO_ERROR);  /* this table is valid, don't delete */
}

/* ------------------------------------------------------------------- */
PRIVATE int16 WriteIndexSubTables(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
								 INDEXSUBTABLEARRAY *pIndexSubTableArray, 
								 uint8 * puchIndexSubTables, 	
								 uint16 usnIndexSubTables, 
								 uint32 ulOffset,  /* absolute offset to beginning of IndexSubTables for output */
								 uint32 ulIndexSubTableArrayLength, 
								 uint32 *pulBytesWritten)
{
uint16 i;
uint8 *puchCurrIndexSubTable;
INDEXSUBTABLE1 * pIndexSubTable1;
INDEXSUBTABLE2 * pIndexSubTable2;
INDEXSUBTABLE3 * pIndexSubTable3;
INDEXSUBTABLE4 * pIndexSubTable4;
INDEXSUBTABLE5 * pIndexSubTable5;
uint16 usArrayLength;
int16 errCode;
uint16 usBytesWritten;
uint32 ulBytesWritten;
uint32 ulStartOffset;


	ulStartOffset = ulOffset; /* absolute offset to beginning of IndexSubTables to calculate bytes written */
	for (i = 0; i < usnIndexSubTables; ++i)
	{
		assert(pIndexSubTableArray[i].ulAdditionalOffsetToIndexSubtable >= ulIndexSubTableArrayLength);
		puchCurrIndexSubTable = puchIndexSubTables + pIndexSubTableArray[i].ulAdditionalOffsetToIndexSubtable - ulIndexSubTableArrayLength;
		/* now need to set this value to what it will be in the FILE, not the buffer */
		pIndexSubTableArray[i].ulAdditionalOffsetToIndexSubtable = ulOffset - ulStartOffset + ulIndexSubTableArrayLength; /* get the relative offset from indexSubTableArrayOffset, will be the same if structures are packed */
		switch (((INDEXSUBHEADER *) puchCurrIndexSubTable)->usIndexFormat)
		{
		case 1:
			usArrayLength = pIndexSubTableArray[i].usLastGlyphIndex - pIndexSubTableArray[i].usFirstGlyphIndex + 1 + 1 /* for calculations */;
		 	pIndexSubTable1 = (INDEXSUBTABLE1 *) puchCurrIndexSubTable;
			if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) pIndexSubTable1, SIZEOF_INDEXSUBTABLE1, INDEXSUBTABLE1_CONTROL, ulOffset, &usBytesWritten )) != NO_ERROR)
				return errCode;
			ulOffset += usBytesWritten;
			if ((errCode = WriteGenericRepeat( pOutputBufferInfo, (uint8 *) pIndexSubTable1->aulOffsetArray, LONG_CONTROL, ulOffset, &ulBytesWritten, usArrayLength, sizeof(uint32))) != NO_ERROR)
				return errCode;
			ulOffset += ulBytesWritten;
 		break;
		case 2:
		 	pIndexSubTable2 = (INDEXSUBTABLE2 *) puchCurrIndexSubTable;
			if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) pIndexSubTable2, SIZEOF_INDEXSUBTABLE2, INDEXSUBTABLE2_CONTROL, ulOffset, &usBytesWritten )) != NO_ERROR)
				return errCode;
			ulOffset += usBytesWritten;
		break;
		case 3:
			usArrayLength = pIndexSubTableArray[i].usLastGlyphIndex - pIndexSubTableArray[i].usFirstGlyphIndex + 1 + 1 /* for calculations */;
		 	pIndexSubTable3 = (INDEXSUBTABLE3 *) puchCurrIndexSubTable;
			if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) pIndexSubTable3, SIZEOF_INDEXSUBTABLE3, INDEXSUBTABLE3_CONTROL, ulOffset, &usBytesWritten )) != NO_ERROR)
				return errCode;
			ulOffset += usBytesWritten;
			if ((errCode = WriteGenericRepeat( pOutputBufferInfo, (uint8 *) pIndexSubTable3->ausOffsetArray, WORD_CONTROL, ulOffset, &ulBytesWritten, usArrayLength, sizeof(uint16))) != NO_ERROR)
				return errCode;
			ulOffset += ulBytesWritten;
		break;
		case 4:
 		 	pIndexSubTable4 = (INDEXSUBTABLE4 *) puchCurrIndexSubTable;
			if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) pIndexSubTable4, SIZEOF_INDEXSUBTABLE4, INDEXSUBTABLE4_CONTROL, ulOffset, &usBytesWritten )) != NO_ERROR)
				return errCode;
			ulOffset += usBytesWritten;
			if ((errCode = WriteGenericRepeat( pOutputBufferInfo, (uint8 *) pIndexSubTable4->glyphArray, CODEOFFSETPAIR_CONTROL, ulOffset, &ulBytesWritten, (uint16) (pIndexSubTable4->ulNumGlyphs+1), SIZEOF_CODEOFFSETPAIR)) != NO_ERROR)
				return errCode;
			ulOffset += ulBytesWritten;
		break;
		case 5:
  		 	pIndexSubTable5 = (INDEXSUBTABLE5 *) puchCurrIndexSubTable;
			if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) pIndexSubTable5, SIZEOF_INDEXSUBTABLE5, INDEXSUBTABLE5_CONTROL, ulOffset, &usBytesWritten )) != NO_ERROR)
				return errCode;
			ulOffset += usBytesWritten;
			if ((errCode = WriteGenericRepeat( pOutputBufferInfo, (uint8 *) pIndexSubTable5->ausGlyphCodeArray, WORD_CONTROL, ulOffset, &ulBytesWritten, (uint16) pIndexSubTable5->ulNumGlyphs, sizeof(uint16))) != NO_ERROR)
				return errCode;
			ulOffset += ulBytesWritten;
		break;
		default:
			return ERR_INVALID_EBLC;
		}
		ulOffset += ZeroLongWordAlign(pOutputBufferInfo, ulOffset); /* inter-table padding */
	}
	*pulBytesWritten = ulOffset - ulStartOffset;	
	return NO_ERROR;
}
/* ------------------------------------------------------------------- */
void Cleanup_SubTablePointers(SubTablePointers *pSubTablePointers,uint32 ulNumSizes)
{
uint16 ulSizeIndex;

	if (pSubTablePointers == NULL)
		return;

	for(ulSizeIndex = 0; ulSizeIndex < ulNumSizes; ulSizeIndex++)
	{
		if (pSubTablePointers[ulSizeIndex].puchIndexSubTables != NULL)
			Mem_Free(pSubTablePointers[ulSizeIndex].puchIndexSubTables);
		if (pSubTablePointers[ulSizeIndex].pIndexSubTableArray != NULL)
			Mem_Free(pSubTablePointers[ulSizeIndex].pIndexSubTableArray);
	}
	Mem_Free(pSubTablePointers);
}
/* ------------------------------------------------------------------- */
/* Entry Point */
/* This routine will go through the EBLC and EBDT tables deleting glyphs */
/* that should be deleted */
/* ModSbit proceeds Strike by strike, calling FixSbitSubTableArray for each strike (size) */
/* FixSbitSubTableArray proceeds IndexSubTable by IndexSubTable, calling */
/* FixSbitSubTables once per Subtable.*/
/* FixSbitSubTables decides what type of Subtable it is (1-5) and processes */
/* the subtable and copies the glyph in the EBDT if appropriate */
/* NOTE: many different things may happen. A Subtable may disappear if all its */
/* glyphs are deleted, SubTableArrays may disappear if all the glyphs in the strike */
/* are deleted, and the entire EBLC and EBDT may be deleted if all glyphs are deleted. */
/* If a component of a composite character is deleted (but not the character), */
/* this is an error */
/* ------------------------------------------------------------------- */
int16 ModSbit( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, /* input buffer, we will read EBDT data from here */
			   TTFACC_FILEBUFFERINFO * pOutputBufferInfo, /* output buffer, we will copy EBLC data here, then modify */
				CONST uint8 *puchKeepGlyphList, /* list of glyphs to keep */
				CONST uint16 usGlyphListCount, /* length of puchKeepGlyphList */
				uint32 *pulNewOutOffset)
{
EBLCHEADER	EBLCHeader;
uint32		ulOffset;
uint32		ulEBLCDestOffset=DIRECTORY_ERROR; /* absolute offset into file */
uint32		ulEBLCSrcOffset;
uint32 		ulEBLCLength;
uint32		ulEBDTDestOffset=DIRECTORY_ERROR; /* where we will write the EBDT data */
uint32		ulEBDTSrcOffset; /* from where we read the EBDT data */ 
uint32		ulEBDTLength; /* where we will write the EBDT data */
uint32		ulBlocDestOffset;	/* offset to an apple bloc table */
uint32		ulBdatDestOffset;	/* offset to an apple bdat table */
uint32		ulNumSizes=0;
uint32		ulNumberOfIndexSubTables;
uint32		ulIndexSubTableArrayOffset;
uint32		ulNewNumSizes;
uint32		ulIndexTablesSize;
uint32		ulSubTableOffset;
uint32		ulSizeIndex;
uint32		ulNewImageDataOffset; /* relative offset into EBDT table */
uint16		usStartIndex;
uint16		usEndIndex;
SubTablePointers *pSubTablePointers = NULL;
uint8		*puchEBDTDestPtr = NULL;
int16		errCode = NO_ERROR;
uint16		usBytesRead;
uint16		usBytesWritten;
uint32		ulBytesWritten;
uint16		usBitmapSizeTableSize;
uint16		usIndexSubTableArraySize;
uint32		ulIndexSubTableArrayLength;
uint16		i;
GLYPHOFFSETRECORDKEEPER keeper;
char *EBDTTag;
char *EBLCTag;
char *EBSCTag;


  keeper.pGlyphOffsetArray = NULL;

  /* potentially do this once for EBLC, and once again for bloc */
  for (i = 0; i < 2; ++i )
  {
	if (i == 0)   /* we're here the first time */
	{
		EBSCTag = EBSC_TAG;
		EBDTTag = EBDT_TAG;  
		EBLCTag = EBLC_TAG;
		/* set the static offset variables for the EBDT table */
		ulEBDTSrcOffset = TTTableOffset( (TTFACC_FILEBUFFERINFO *)pInputBufferInfo, EBDTTag );
		ulEBLCSrcOffset = TTTableOffset( (TTFACC_FILEBUFFERINFO *)pInputBufferInfo, EBLCTag );
		if ( ulEBLCSrcOffset == DIRECTORY_ERROR || ulEBDTSrcOffset == DIRECTORY_ERROR)
		{	/* Delete them if both aren't there */
			MarkTableForDeletion( pOutputBufferInfo, EBLCTag );
			MarkTableForDeletion( pOutputBufferInfo, EBDTTag );
			MarkTableForDeletion( pOutputBufferInfo, EBSCTag );
			continue;	 
		}
	}
	else /* this is the 2nd time. Look for bloc stuff */
	{
		/* clean up from last time around */
		Cleanup_SubTablePointers(pSubTablePointers,ulNumSizes);
		Mem_Free(keeper.pGlyphOffsetArray);
		Mem_Free(puchEBDTDestPtr);
		ulNumSizes = 0;
		pSubTablePointers = NULL;
		keeper.pGlyphOffsetArray = NULL;
		puchEBDTDestPtr = NULL;

		EBDTTag = BDAT_TAG;  
		EBSCTag = BSCA_TAG;
		EBLCTag = BLOC_TAG;

		ulBdatDestOffset = TTTableOffset( (TTFACC_FILEBUFFERINFO *)pInputBufferInfo, EBDTTag );
		ulBlocDestOffset = TTTableOffset( (TTFACC_FILEBUFFERINFO *)pInputBufferInfo, EBLCTag );
		if (( ulBlocDestOffset == DIRECTORY_ERROR || ulBdatDestOffset == DIRECTORY_ERROR) ||
			(  (ulBlocDestOffset == ulEBLCSrcOffset || ulBdatDestOffset == ulEBDTSrcOffset) && 
			   (ulEBLCDestOffset == DIRECTORY_ERROR || ulEBDTDestOffset == DIRECTORY_ERROR) 
			)) /* table was deleted first time around */
		{	/* Delete them if both aren't there */
			MarkTableForDeletion( pOutputBufferInfo, EBLCTag );
			MarkTableForDeletion( pOutputBufferInfo, EBDTTag );
			MarkTableForDeletion( pOutputBufferInfo, EBSCTag );
			break;		 /* we'll let this slide. we just won't reduce it */
		}
		if (ulBlocDestOffset == ulEBLCSrcOffset || ulBdatDestOffset == ulEBDTSrcOffset)/* same thing, don't need to redo */
		{	  /* must do both, can't do one without the other */
			/* but we do need to update the bloc DirectoryEntry */
			UpdateDirEntryAll(pOutputBufferInfo, EBLCTag, ulEBLCLength, ulEBLCDestOffset);	/* ulEBLCoffset set last time around */
			UpdateDirEntryAll(pOutputBufferInfo, EBDTTag, ulEBDTLength, ulEBDTDestOffset);
			break;
		}
		/* otherwise, set these offset values up to process the bloc table */
		ulEBDTSrcOffset = ulBdatDestOffset;
		ulEBLCSrcOffset = ulBlocDestOffset;
	}
	/* copy the EBLC table from the input buffer to the output buffer */
	if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, EBLCTag, pulNewOutOffset)) != NO_ERROR)
		break;
	ulEBLCDestOffset = TTTableOffset( pOutputBufferInfo, EBLCTag );

	ulNewNumSizes = 0;	  
	
	keeper.pGlyphOffsetArray = NULL;
	keeper.ulOffsetArrayLen = 0;
	keeper.ulNextArrayIndex = 0;

	/* create a buffer for the EBDT table */
	puchEBDTDestPtr = (uint8 *) Mem_Alloc(TTTableLength((TTFACC_FILEBUFFERINFO *) pInputBufferInfo, EBDTTag));  /* we'll be copying the EBDT (raw bytes) table here temporarily */
	if (!puchEBDTDestPtr)
	{
		errCode = ERR_MEM;
		break;
	}
	
	/* read raw bytes for Header info */
	if ((errCode = ReadGeneric( (TTFACC_FILEBUFFERINFO *) pInputBufferInfo, (uint8 *) puchEBDTDestPtr, SIZEOF_EBDTHEADER, EBDTHEADERNOXLATENOPAD_CONTROL, ulEBDTSrcOffset, &usBytesRead )) != NO_ERROR) 
		break;

	ulNewImageDataOffset = usBytesRead;  /* move past the header of the EBDT table */
		
	ulOffset = ulEBLCDestOffset;

	if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &EBLCHeader, SIZEOF_EBLCHEADER, EBLCHEADER_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR) 
		break;

	ulOffset += usBytesRead;
	ulNumSizes = EBLCHeader.ulNumSizes;
 	usIndexSubTableArraySize = GetGenericSize(INDEXSUBTABLEARRAY_CONTROL);

	/* allocate some space to store pointer info */
	pSubTablePointers = (SubTablePointers *) Mem_Alloc(sizeof(* pSubTablePointers) * ulNumSizes);   /* make an array of pointers */
	if (!pSubTablePointers)
	{
		errCode = ERR_MEM;
		break;
	}

	/* process each strike */
	for(ulSizeIndex = 0; ulSizeIndex < ulNumSizes; ulSizeIndex++)	 
	{
		if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &(pSubTablePointers[ulSizeIndex].bmSizeTable), SIZEOF_BITMAPSIZETABLE, BITMAPSIZETABLE_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR) 
			break;

		ulOffset += usBytesRead;

		usStartIndex = pSubTablePointers[ulSizeIndex].bmSizeTable.usStartGlyphIndex ;
		usEndIndex = pSubTablePointers[ulSizeIndex].bmSizeTable.usEndGlyphIndex;
		if (usStartIndex >= usGlyphListCount) 
		{
			/* mark for deletion */
			pSubTablePointers[ulSizeIndex].bmSizeTable.usStartGlyphIndex = 0;
			pSubTablePointers[ulSizeIndex].bmSizeTable.usEndGlyphIndex = 0;
			pSubTablePointers[ulSizeIndex].puchIndexSubTables = NULL;
			pSubTablePointers[ulSizeIndex].pIndexSubTableArray = NULL;
			continue;
		}

 		if (usEndIndex >= usGlyphListCount)	   /* bogus value */
			usEndIndex = usGlyphListCount-1; 

		/* now find out where the subset of glyphs starts within this range */ 

		while (!puchKeepGlyphList[usStartIndex] && (usStartIndex < usEndIndex))    /* collaps range */
			  ++usStartIndex;

		/* find out where the subset of glyphs ends within this range */ 
		while (!puchKeepGlyphList[usEndIndex] && (usEndIndex > usStartIndex))
			--usEndIndex;
		
		/* if there are no chars in range */
		if ((usStartIndex == usEndIndex) && !puchKeepGlyphList[usEndIndex])
		{
			/* mark for deletion */
			pSubTablePointers[ulSizeIndex].bmSizeTable.usStartGlyphIndex = 0;
			pSubTablePointers[ulSizeIndex].bmSizeTable.usEndGlyphIndex = 0;
			pSubTablePointers[ulSizeIndex].puchIndexSubTables = NULL;
			pSubTablePointers[ulSizeIndex].pIndexSubTableArray = NULL;
			continue;
		}
		 /* otherwise, set the new value in the bmSizeTable - to be written later */
		
		pSubTablePointers[ulSizeIndex].bmSizeTable.usStartGlyphIndex = usStartIndex;
		pSubTablePointers[ulSizeIndex].bmSizeTable.usEndGlyphIndex = usEndIndex;

		ulNumberOfIndexSubTables = pSubTablePointers[ulSizeIndex].bmSizeTable.ulNumberOfIndexSubTables ;
		ulIndexTablesSize 		 = pSubTablePointers[ulSizeIndex].bmSizeTable.ulIndexTablesSize;
		ulSubTableOffset 		 = pSubTablePointers[ulSizeIndex].bmSizeTable.ulIndexSubTableArrayOffset;
		pSubTablePointers[ulSizeIndex].nIndexSubTablesLen = (ulIndexTablesSize + 2 - 
							 (ulNumberOfIndexSubTables * usIndexSubTableArraySize)) * PORTABILITY_FACTOR; 	/* + 2 in case last table is padded and not included in size */ 
		pSubTablePointers[ulSizeIndex].puchIndexSubTables = (uint8 *) Mem_Alloc(pSubTablePointers[ulSizeIndex].nIndexSubTablesLen); 
		if (pSubTablePointers[ulSizeIndex].puchIndexSubTables == NULL) 
		{
			errCode = ERR_MEM;
			break;
		}
							 
 		pSubTablePointers[ulSizeIndex].ulNumSubTables = ulNumberOfIndexSubTables; 
 		pSubTablePointers[ulSizeIndex].pIndexSubTableArray  = (INDEXSUBTABLEARRAY *) Mem_Alloc(ulNumberOfIndexSubTables * SIZEOF_INDEXSUBTABLEARRAY); 

		if (pSubTablePointers[ulSizeIndex].pIndexSubTableArray == NULL)
		{
			Mem_Free(pSubTablePointers[ulSizeIndex].puchIndexSubTables);
			errCode = ERR_MEM;
			break;
		}
		if ((FixSbitSubTableArray(pInputBufferInfo,
								 pOutputBufferInfo, 
								 ulEBLCDestOffset + ulSubTableOffset, 
								 &(pSubTablePointers[ulSizeIndex]),
								 puchKeepGlyphList, 
								 usGlyphListCount, 
								 &ulNewImageDataOffset, 
								 puchEBDTDestPtr,
								 ulEBDTSrcOffset,
								 &keeper) == NO_ERROR)  /* valid table */
								 && 
								 pSubTablePointers[ulSizeIndex].ulNumSubTables != 0)
		{
			++ulNewNumSizes;
		}
		else
		{	  /* mark for deletion on pass2 */
			pSubTablePointers[ulSizeIndex].bmSizeTable.usStartGlyphIndex = 0;
			pSubTablePointers[ulSizeIndex].bmSizeTable.usEndGlyphIndex = 0;
		}
	}

	if (errCode != NO_ERROR)
		break;

	if (ulNewNumSizes == 0)  /* The entire table is to be deleted ! */
	{
		MarkTableForDeletion( pOutputBufferInfo, EBLCTag );
		MarkTableForDeletion( pOutputBufferInfo, EBDTTag );
		MarkTableForDeletion( pOutputBufferInfo, EBSCTag );
		ulEBLCDestOffset = DIRECTORY_ERROR;
		ulEBDTDestOffset = DIRECTORY_ERROR;
		continue;	/* do bloc if any */
	}
	/* write memory to disk */
	EBLCHeader.ulNumSizes = ulNewNumSizes;
	ulOffset = ulEBLCDestOffset;
	if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *)&EBLCHeader, SIZEOF_EBLCHEADER, EBLCHEADER_CONTROL, ulOffset, &usBytesWritten)) != NO_ERROR) 
		break;

	ulOffset += usBytesWritten;
	usBitmapSizeTableSize = GetGenericSize(BITMAPSIZETABLE_CONTROL);
	assert(usBitmapSizeTableSize != 0);
	ulEBLCLength = usBytesWritten + usBitmapSizeTableSize * ulNewNumSizes; /* start off with header and bitmapSizeTables accounted for */
	for(ulSizeIndex = 0; ulSizeIndex < ulNumSizes; ulSizeIndex++)
	{
		if (pSubTablePointers[ulSizeIndex].bmSizeTable.usEndGlyphIndex != 0) /* if we aren't deleting the sizeTable */
		{
 			pSubTablePointers[ulSizeIndex].bmSizeTable.ulIndexSubTableArrayOffset = ulIndexSubTableArrayOffset = ulEBLCLength;	 /* set to the current offset of where the IndexArray will go  */
			ulNumberOfIndexSubTables = pSubTablePointers[ulSizeIndex].bmSizeTable.ulNumberOfIndexSubTables;
		
			ulIndexSubTableArrayLength = usIndexSubTableArraySize * ulNumberOfIndexSubTables;  /* calc space for array */

			/* now write out the IndexSubTables */
		
			if ((errCode = WriteIndexSubTables(pOutputBufferInfo, pSubTablePointers[ulSizeIndex].pIndexSubTableArray, 
							 pSubTablePointers[ulSizeIndex].puchIndexSubTables, (uint16) pSubTablePointers[ulSizeIndex].ulNumSubTables,
							 ulEBLCDestOffset + ulIndexSubTableArrayOffset + ulIndexSubTableArrayLength, ulIndexSubTableArrayLength, &ulBytesWritten)) != NO_ERROR)
				break;
			ulEBLCLength += ulBytesWritten;

			/* update TableSize */
			pSubTablePointers[ulSizeIndex].bmSizeTable.ulIndexTablesSize = ulBytesWritten;
 			
			/* now write out the IndexSubTableArray, which was changed by WriteIndexSubTables */

			if ((errCode = WriteGenericRepeat( pOutputBufferInfo, (uint8 *) pSubTablePointers[ulSizeIndex].pIndexSubTableArray, INDEXSUBTABLEARRAY_CONTROL, ulEBLCDestOffset + ulIndexSubTableArrayOffset, &ulBytesWritten, (uint16) ulNumberOfIndexSubTables, 
						SIZEOF_INDEXSUBTABLEARRAY)) != NO_ERROR)   /* write out the sub table array */
				break;

			ulEBLCLength += ulBytesWritten;
				/* update TableSize */
			pSubTablePointers[ulSizeIndex].bmSizeTable.ulIndexTablesSize += ulBytesWritten;

			/* now write out the bitmapSizeTable itself at beginning */
			if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &(pSubTablePointers[ulSizeIndex].bmSizeTable), SIZEOF_BITMAPSIZETABLE, BITMAPSIZETABLE_CONTROL, ulOffset, &usBytesWritten)) != NO_ERROR) 
				break;

			ulOffset += usBytesWritten;	 /* only update for the bitmapSizeTables */
			/* ulEBLCLength += usBytesWritten;	don't update the length as we did it outside the loop */					 
		}
	}
	if (errCode == NO_ERROR)
	{
		/* update EBDT DATA */
		*pulNewOutOffset = ulEBLCDestOffset + ulEBLCLength;	 /* figure out what we have written */
		ulEBDTDestOffset = *pulNewOutOffset + ZeroLongWordAlign(pOutputBufferInfo, *pulNewOutOffset);
		if ((errCode = WriteBytes( pOutputBufferInfo, puchEBDTDestPtr, ulEBDTDestOffset, ulNewImageDataOffset)) == NO_ERROR)
		{
			ulEBDTLength = ulNewImageDataOffset;
			*pulNewOutOffset = ulEBDTDestOffset + ulEBDTLength;
			/* update EBDT Directory length */
	   		if ((errCode = UpdateDirEntryAll(pOutputBufferInfo, EBDTTag, ulEBDTLength, ulEBDTDestOffset)) == NO_ERROR)
			{
		/* update EBLC Directory length */
	   			errCode = UpdateDirEntry(pOutputBufferInfo, EBLCTag, ulEBLCLength);
			}
		}
	}
	else
		break;
  }

  Cleanup_SubTablePointers(pSubTablePointers,ulNumSizes);
  Mem_Free(keeper.pGlyphOffsetArray);
  Mem_Free(puchEBDTDestPtr);

  return errCode;
}

 /* ------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\modcmap.c ===
/***************************************************************************
 * module: modcmap.C
 *
 * author: Louise Pathe
 * date:   Dec 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 **************************************************************************/


/* Inclusions ----------------------------------------------------------- */
#include <string.h>	 /* for memcpy */
#include <stdlib.h> /* for qsort */

#include "typedefs.h"
#include "ttff.h"
#include "ttfacc.h"
#include "ttfcntrl.h"
#include "ttftabl1.h"
#include "ttftable.h"
#include "ttmem.h"
#include "util.h"
#include "modcmap.h"
#include "ttferror.h"	 /* for error codes */

/* Definitions local to this file ---------------------------------------- */
/* ------------------------------------------------------------------- */
typedef struct {
	uint32 ulOldCmapOffset;
	uint32 ulNewCmapOffset;
} CmapOffsetRecord;

/* ------------------------------------------------------------------- */
typedef struct cmapoffsetrecordkeeper *PCMAPOFFSETRECORDKEEPER;	 
typedef struct cmapoffsetrecordkeeper CMAPOFFSETRECORDKEEPER;	 

struct cmapoffsetrecordkeeper	  /* housekeeping structure */
{
	CmapOffsetRecord * pCmapOffsetArray;
	uint16 usCmapOffsetArrayLen;
	uint16 usNextArrayIndex;
};

/* ------------------------------------------------------------------- */
PRIVATE int16 InitCmapOffsetArray(PCMAPOFFSETRECORDKEEPER pKeeper, 
								  uint16 usRecordCount)
{
	pKeeper->pCmapOffsetArray = (CmapOffsetRecord *) Mem_Alloc(usRecordCount * sizeof(*(pKeeper->pCmapOffsetArray)));
	if (pKeeper->pCmapOffsetArray == NULL)
		return ERR_MEM;
	pKeeper->usCmapOffsetArrayLen = usRecordCount;
	pKeeper->usNextArrayIndex = 0;
	return NO_ERROR;
}
/* ------------------------------------------------------------------- */
PRIVATE void FreeCmapOffsetArray(PCMAPOFFSETRECORDKEEPER pKeeper)
{
	Mem_Free(pKeeper->pCmapOffsetArray);
	pKeeper->pCmapOffsetArray = NULL;
	pKeeper->usCmapOffsetArrayLen = 0;
	pKeeper->usNextArrayIndex = 0;
}
/* ------------------------------------------------------------------- */
PRIVATE int16 RecordCmapOffset(PCMAPOFFSETRECORDKEEPER pKeeper, 
								uint32 ulOldCmapOffset,
								uint32 ulNewCmapOffset)
  /* record this block as being used */
{
	if (pKeeper->usNextArrayIndex >= pKeeper->usCmapOffsetArrayLen)
		return ERR_INVALID_CMAP;
	pKeeper->pCmapOffsetArray[pKeeper->usNextArrayIndex].ulOldCmapOffset = ulOldCmapOffset;
	pKeeper->pCmapOffsetArray[pKeeper->usNextArrayIndex].ulNewCmapOffset = ulNewCmapOffset ;
	++pKeeper->usNextArrayIndex;
	return NO_ERROR;
}

/* ------------------------------------------------------------------- */
PRIVATE uint32 LookupCmapOffset(PCMAPOFFSETRECORDKEEPER pKeeper, 
								uint32 ulOldCmapOffset)
{
uint16 i;

	for (i = 0; i < pKeeper->usNextArrayIndex; ++i)
	{
	 	if (ulOldCmapOffset == pKeeper->pCmapOffsetArray[i].ulOldCmapOffset)
			return(pKeeper->pCmapOffsetArray[i].ulNewCmapOffset);
	}
	return(0L);
}

/* ------------------------------------------------------------------- */
/* ------------------------------------------------------------------- */
typedef struct {  /* used to sort and keep track of new offsets */
	uint16 usIndex;	/* index into the CMAP_TABLELOC array read from the original font */
	uint32 ulNewOffset;
} IndexOffset;

/* ------------------------------------------------------------------- */
/* Must sort subtables by offset, so that their data blocks may be moved in order */
/* output of this function is the IndexOffset array */
/* ------------------------------------------------------------------- */
PRIVATE void SortCmapSubByOffset(CMAP_TABLELOC *pCmapTableLoc, uint16 usSubTableCount, IndexOffset *pIndexArray)
{
uint16 i, j, k;

	for (i = 0; i < usSubTableCount; ++i)
	{
		for (j = 0; j < i; ++j)	/* look for where to insert this index in the Index array thingum */
		{
			if (pCmapTableLoc[i].offset < pCmapTableLoc[pIndexArray[j].usIndex].offset) /* need to insert it here */
			{  /* push down any that are ahead of this one */
				for (k = i; k > j; -- k)
				{
				  	pIndexArray[k].usIndex = pIndexArray[k-1].usIndex;
				}
				break;
			}
		}
		pIndexArray[j].usIndex = i;	  /* insert it */
	}
} 

/* ------------------------------------------------------------------- */
/* now compress out extra space between subtables */
/* when subtables are updated, they become smaller (or remain the same) */
/* what is left are shortened subtables in their original positions */
/* this function compresses them into one contiguous block of data */
/* once the subtables are moved, their new offsets must be written to the */
/* CMAP_TABLELOC array */
/* lcp change long word pad between subtables to short word pad. Caused tables */
/* to grow unnecessarily */
/* ------------------------------------------------------------------- */
PRIVATE int16 CompressCmapSubTables(TTFACC_FILEBUFFERINFO * pOutputBufferInfo,  /* ttfacc info */
					CMAP_TABLELOC *pCmapTableLoc, /* array of CmapSubTable locators */
					uint16 usSubTableCount, /* count of that array */
					uint32 ulCmapOffset, /* offset to cmap table */
					uint32 ulSubTableOffset, /* offset to beginning of Subtables */
					uint32 ulCmapOldLength,	/* length of old cmap table - not to be exceeded */
					uint32 *pulCmapNewLength)
{
IndexOffset *pIndexArray;  /* local array of structures to keep track of new offsets of sorted subtables */
CMAP_SUBHEADER CmapSubHeader;	
int16 errCode = NO_ERROR;
uint32 ulCurrentOffset;
uint32 ulLastOffset;
uint16 usIndex;
uint32 ulCmapTableLength = 0;
uint32 ulCmapSubTableDirOffset;
uint32 ulPadOffset;
uint16 i,j;
uint16 usBytesRead;
uint16 usPadBytes;

	pIndexArray = (IndexOffset *) Mem_Alloc(usSubTableCount * sizeof(*pIndexArray));
	if (pIndexArray == NULL)
		return ERR_MEM;
	
	/* sort them by old offsets, so we can move the blocks in order */
	SortCmapSubByOffset(pCmapTableLoc, usSubTableCount, pIndexArray); 

	ulCurrentOffset = ulSubTableOffset; /* end of the Cmap Directories */
	ulLastOffset = 0;
	for (i = 0; i < usSubTableCount; ++i)	/* process each subtable */
	{
		usIndex = pIndexArray[i].usIndex;
		/* check to see if this offset is the same as the last one copied. If so, ignore, as it has already been copied */
		if (i > 0 && pCmapTableLoc[usIndex].offset == ulLastOffset) /* we're pointing to some already copied data */
		{
			pIndexArray[i].ulNewOffset = pIndexArray[i-1].ulNewOffset;
			continue;
		}
		/* read the CmapSub Header */
	 	if ((errCode = ReadGeneric(pOutputBufferInfo, (uint8 *)&CmapSubHeader, SIZEOF_CMAP_SUBHEADER, CMAP_SUBHEADER_CONTROL, ulCmapOffset + pCmapTableLoc[usIndex].offset, &usBytesRead)) != NO_ERROR)
			break;
		/* do we need to pad? */

	 	if (CmapSubHeader.format < 8)
	 	{
			/* old tables (non surragate) */
			CmapSubHeader.NewLength = CmapSubHeader.OldLength;
	 	}

		ulPadOffset = ulCurrentOffset;
		ulCurrentOffset = (ulPadOffset + 1) & ~1;	  /* we may need to pad, but do it after we move data in case we would overwrite data */
		usPadBytes = (uint16) (ulCurrentOffset - ulPadOffset);

		if (ulCmapTableLength + usPadBytes + CmapSubHeader.NewLength > ulCmapOldLength) /* if we are about to exceed the bounds */
		{
			errCode = ERR_WOULD_GROW;  /* can't do it. Bail and restore the old cmap table */
			break;
		}
		pIndexArray[i].ulNewOffset = ulCurrentOffset-ulCmapOffset;	/* calculate the new offset of the cmap subtable, and store in local structure */
		ulLastOffset = pCmapTableLoc[usIndex].offset;
		/* now copy the subtable to it's new locations */
		if ((errCode = CopyBlock(pOutputBufferInfo, ulCurrentOffset, ulCmapOffset + pCmapTableLoc[usIndex].offset,CmapSubHeader.NewLength)) != NO_ERROR)
			break;
		for (j = 0; j < usPadBytes; ++j)
			WriteByte(pOutputBufferInfo,(uint8) 0, ulPadOffset+j);	 /* now clear out those pad bytes */

		ulCurrentOffset += CmapSubHeader.NewLength;
		ulCmapTableLength = ulCurrentOffset - ulCmapOffset;  /* to update the Font Directory values */
	} 
	if (errCode == NO_ERROR)
	{
		for (i = 0; i < usSubTableCount; ++i) /* now set the new offsets - retrieved from the local structure array */
			pCmapTableLoc[pIndexArray[i].usIndex].offset = pIndexArray[i].ulNewOffset;

		ulCmapSubTableDirOffset = ulCmapOffset + GetGenericSize( CMAP_HEADER_CONTROL );
		for (i = 0; i < usSubTableCount; ++i) /* now write the new offsets in their original order (Plat/encoding order) */
		{
 	 		if ((errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &(pCmapTableLoc[i]), SIZEOF_CMAP_TABLELOC, CMAP_TABLELOC_CONTROL, ulCmapSubTableDirOffset, &usBytesRead)) != NO_ERROR)
				break; 
			ulCmapSubTableDirOffset += usBytesRead;  /* for next time around */
		}
	}
	Mem_Free(pIndexArray);
	if (errCode == NO_ERROR)
		/* now update the Directory Entry for the file */
		errCode = UpdateDirEntry(pOutputBufferInfo, CMAP_TAG, ulCmapTableLength);

	*pulCmapNewLength = ulCmapTableLength;

	return errCode;
}
/* ------------------------------------------------------------------- */
PRIVATE uint16 GetCmapSubtableCount( TTFACC_FILEBUFFERINFO * pInputBufferInfo,
uint32 ulCmapOffset)
{
CMAP_HEADER CmapHdr;
uint16 usBytesRead;

	if (ReadGeneric( pInputBufferInfo, (uint8 *) &CmapHdr, SIZEOF_CMAP_HEADER, CMAP_HEADER_CONTROL, ulCmapOffset, &usBytesRead ) != NO_ERROR)
		return 0;

	return(CmapHdr.numTables);
} /* GetCmapSubtableCount() */
/* ------------------------------------------------------------------- */
/* modify format 0 cmap subtable - remove references to glyphs no longer with us */
   /* this routine modifies the apple cmap table so that characters 
      referencing deleted glyphs are mapped to the missing character. */ 
/* ------------------------------------------------------------------- */
PRIVATE int16 ModMacStandardCmap( TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint32 ulOffset, uint8 *puchKeepGlyphList, uint16 usGlyphCount )
{
uint16 i;
uint8 GlyphIndex;
int16 errCode;

	for ( i = 0; i < CMAP_FORMAT0_ARRAYCOUNT; i++ )
	{
		if ((errCode = ReadByte(pOutputBufferInfo, &GlyphIndex, ulOffset)) != NO_ERROR)
			return errCode;
		if (GlyphIndex > usGlyphCount || puchKeepGlyphList[GlyphIndex] == 0) /* not a glyph to be used */
		{
			if ((errCode = WriteByte(pOutputBufferInfo, (uint8) 0, ulOffset)) != NO_ERROR)
				return errCode;
		}
		ulOffset += sizeof(GlyphIndex);
	}
	return NO_ERROR;
}
/* ------------------------------------------------------------------- */
/* modify format 6 cmap subtable - remove references to glyphs no longer with us
   this routine modifies the apple cmap table so that characters 
   referencing deleted glphs are mapped to the missing character. It will also shorten
   the table if possible. */ 
/* ------------------------------------------------------------------- */
PRIVATE int16 ModMacTrimmedCmap( TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
							   uint32 ulOffset, 
							   uint8 *puchKeepGlyphList, 
							   uint16 usGlyphCount )
{
uint16 i;
uint16 GlyphIndex;
CMAP_FORMAT6 CmapFormat6;
int16 errCode;
uint16 usBytesRead;
uint16 usBytesWritten;
uint16 usNewFirstCode= 0xFFFF;
uint16 usNewLastCode=0;  /* saved to calc NewEntryCount */
uint32 ulInGlyphOffset;  /* to point to a glyph value to read */
uint32 ulOutGlyphOffset;  /* to point to a glyph value to write */


	if ((errCode = ReadGeneric(pOutputBufferInfo, (uint8 *)&CmapFormat6, SIZEOF_CMAP_FORMAT6, CMAP_FORMAT6_CONTROL, ulOffset, &usBytesRead)) != NO_ERROR)
		return errCode; 
	ulInGlyphOffset = ulOutGlyphOffset = ulOffset + usBytesRead;
	/* first figure out where the start and end are */
	for ( i = 0; i < CmapFormat6.entryCount; i++ )
	{
		if ((errCode = ReadWord(pOutputBufferInfo, &GlyphIndex, ulInGlyphOffset)) != NO_ERROR)
			return errCode;
		if (GlyphIndex <= usGlyphCount && puchKeepGlyphList[GlyphIndex] != 0) /* a glyph to be used */
		{
			if (usNewFirstCode == 0xFFFF)  /* default first code, set only if hasn't been set already */
				usNewFirstCode = CmapFormat6.firstCode + i;	/* may be zero */
			usNewLastCode = CmapFormat6.firstCode+i;
		}
		ulInGlyphOffset += sizeof(GlyphIndex);
	}
	if (usNewFirstCode == 0xFFFF) /* none were found */
	{
		CmapFormat6.firstCode = 0;
		CmapFormat6.entryCount = 0; 
	}
	else
	{
		/* now calculate the new table */
		CmapFormat6.firstCode = usNewFirstCode;
		CmapFormat6.entryCount = usNewLastCode - usNewFirstCode+1;
		
		ulInGlyphOffset = ulOutGlyphOffset + usNewFirstCode * sizeof(GlyphIndex); /* where to read the first code */
		for ( i = usNewFirstCode; i <= usNewLastCode; i++ )
		{
			if ((errCode = ReadWord(pOutputBufferInfo, &GlyphIndex, ulInGlyphOffset)) != NO_ERROR)
				return errCode;
			if (GlyphIndex > usGlyphCount || puchKeepGlyphList[GlyphIndex] == 0) /* not a glyph to be used */
			{
				if ((errCode = WriteWord(pOutputBufferInfo, (uint16) 0, ulOutGlyphOffset)) != NO_ERROR)
					return errCode;
			}
			else  /* write the glyph Index to the new location */
			{
				if ((errCode = WriteWord(pOutputBufferInfo, GlyphIndex, ulOutGlyphOffset)) != NO_ERROR)
					return errCode;
			}
			ulInGlyphOffset += sizeof(GlyphIndex);
			ulOutGlyphOffset += sizeof(GlyphIndex);
		}
	}
	CmapFormat6.length = (uint16) (ulOutGlyphOffset - ulOffset);
	/* write out new cmap subtable header */
	if ((errCode = WriteGeneric(pOutputBufferInfo, (uint8 *)&CmapFormat6, SIZEOF_CMAP_FORMAT6, CMAP_FORMAT6_CONTROL, ulOffset, &usBytesWritten)) != NO_ERROR)
		return errCode; 

	return NO_ERROR;
}
/* ------------------------------------------------------------------- */
/* ENTRY POINT !!!														*/
/* This function will modify the CMAP tables Thusly:					*/
/* It will go through the list of Cmap Subtables. If it finds a format	*/
/* 4 table, it will try to update it based on the list of glyph		*/
/* codes to keep.														*/
/* if it finds a MAC cmap (format 0, or 6) it will set to zero any		*/
/* glyphs referenced that have been removed using the puchKeepGlyphList */
/* if the resulting CMAP table will be larger than the original, then	*/
/* the cmap will be restored the original								*/
/* ------------------------------------------------------------------- */
int16 ModCmap(CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo,
			    TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
				uint8 *puchKeepGlyphList, /* glyphs to keep - boolean */
				uint16 usGlyphCount,  /* count of puchKeepGlyphList */
				uint16 * pOS2MinChr,	 /* for setting in the OS/2 table */
				uint16 * pOS2MaxChr,	 /* for setting in the OS/2 table */
				uint32 *pulNewOutOffset)
{
FORMAT4_SEGMENTS *NewFormat4Segments = NULL;   /* used to create a Segments	array for format 4 subtables */
uint16 usnSegment;
GLYPH_ID *NewFormat4GlyphIdArray = NULL; /* used to create a GlyphID array for format 4 subtables */
uint16 snFormat4GlyphIdArray;
CMAP_FORMAT4 CmapFormat4;
CMAP_TABLELOC *pCmapTableLoc=NULL;
uint16 usSubTableCount;
CMAP_SUBHEADER CmapSubHeader;
PCHAR_GLYPH_MAP_LIST pCharGlyphMapList = NULL;	/* sorted list of character codes to keep and their glyph indices */
uint16 usnCharGlyphMapListCount= 0;	/* length of pCharGlyphMapList array */
CMAPOFFSETRECORDKEEPER CmapSubtableKeeper;
uint32 ulCmapOffset;
uint32 ulCmapLength;
uint32 ulCmapNewLength;
uint32 ulCmapSubTableDirOffset;
uint32 ulCmapSubtableNewOffset;
uint32 ulBytesWritten;
uint16 i;
int16 errCode= NO_ERROR;
uint16 usBytesRead;
uint32 ulZeroZeroOffset=0; /* for shared Subtable info */

	if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, CMAP_TAG, pulNewOutOffset)) != NO_ERROR)
		return errCode;

	ulCmapOffset = TTTableOffset( pOutputBufferInfo, CMAP_TAG );
	ulCmapLength = TTTableLength( pOutputBufferInfo, CMAP_TAG);
	*pOS2MinChr = 0;
	*pOS2MaxChr = 0;
	if (ulCmapOffset == 0L || ulCmapLength == 0L)
		return ERR_INVALID_CMAP;  /* huh?*/

	usSubTableCount = GetCmapSubtableCount(pOutputBufferInfo, ulCmapOffset);
	pCmapTableLoc = (CMAP_TABLELOC *)Mem_Alloc(SIZEOF_CMAP_TABLELOC * usSubTableCount);
	if (pCmapTableLoc == NULL)
		return ERR_MEM;
    ulCmapSubTableDirOffset  = ulCmapOffset + GetGenericSize( CMAP_HEADER_CONTROL );

	InitCmapOffsetArray(&CmapSubtableKeeper, usSubTableCount);
	
	for (i = 0; i < usSubTableCount; ++i)
	{
		/* read the cmap directory entry */
	 	if ((errCode = ReadGeneric(pOutputBufferInfo, (uint8 *) &(pCmapTableLoc[i]), SIZEOF_CMAP_TABLELOC, CMAP_TABLELOC_CONTROL, ulCmapSubTableDirOffset, &usBytesRead)) != NO_ERROR)
			break; 
		ulCmapSubTableDirOffset += usBytesRead;  /* for next time around */

		/* Check to see if this subtable is shared, and has been modified already */
		if ((ulCmapSubtableNewOffset = LookupCmapOffset(&CmapSubtableKeeper, pCmapTableLoc[i].offset)) != 0)
		{
			pCmapTableLoc[i].offset = ulCmapSubtableNewOffset;
			continue;
		}
		/* now read the CmapSub Header, to determine the format */
	 	if ((errCode = ReadGeneric(pOutputBufferInfo, (uint8 *)&CmapSubHeader, SIZEOF_CMAP_SUBHEADER, CMAP_SUBHEADER_CONTROL, ulCmapOffset + pCmapTableLoc[i].offset, &usBytesRead)) != NO_ERROR)
			break; 

	 	if (CmapSubHeader.format < 8)
	 	{
			/* old tables (non surragate) */
			CmapSubHeader.NewLength = CmapSubHeader.OldLength;
			usBytesRead -= 2;
	 	}

		/* Will subset: Format 0, Format 4 and Format 6 Cmap Subtables */
		/* Otherwise, leave them alone */

		if (CmapSubHeader.format == FORMAT0_CMAP_FORMAT)
		{
			if ((errCode = ModMacStandardCmap(pOutputBufferInfo, ulCmapOffset + pCmapTableLoc[i].offset + usBytesRead, puchKeepGlyphList, usGlyphCount)) != NO_ERROR)
				break;
		}
		else if (CmapSubHeader.format == FORMAT6_CMAP_FORMAT)
		{
			if ((errCode = ModMacTrimmedCmap(pOutputBufferInfo, ulCmapOffset + pCmapTableLoc[i].offset, puchKeepGlyphList, usGlyphCount)) != NO_ERROR)
				break;
		}
		else if (CmapSubHeader.format == FORMAT4_CMAP_FORMAT)
		{
		
			/* process Format 4 Cmap Subtable */
			 /*need to come up with a CharCodeList, from the puchKeepGlyphList  */
			errCode = ReadAllocFormat4CharGlyphMapList(pOutputBufferInfo, pCmapTableLoc[i].platformID, pCmapTableLoc[i].encodingID, puchKeepGlyphList, usGlyphCount, &pCharGlyphMapList, &usnCharGlyphMapListCount); 

			if (errCode != NO_ERROR)
				break;

			NewFormat4Segments = (FORMAT4_SEGMENTS *) Mem_Alloc( (usnCharGlyphMapListCount+1) * SIZEOF_FORMAT4_SEGMENTS ); /* add one for the extra dummy segment */
			NewFormat4GlyphIdArray = (GLYPH_ID *) Mem_Alloc( usnCharGlyphMapListCount * sizeof( *NewFormat4GlyphIdArray ) );

			if ( NewFormat4Segments == NULL || NewFormat4GlyphIdArray == NULL )
			{
				errCode = ERR_MEM;
				break;
			}

			/* compute new format 4 data */

			ComputeFormat4CmapData( &CmapFormat4, NewFormat4Segments, &usnSegment, 
									NewFormat4GlyphIdArray, &snFormat4GlyphIdArray, pCharGlyphMapList, usnCharGlyphMapListCount );


			/* Donald, if you don't care if the Cmap subtable grows, you could comment out the next line */
			
			if (CmapFormat4.length <= CmapSubHeader.NewLength) /* if the new length is smaller than the old, we can write it in the old place */
			{
				if (pCmapTableLoc[i].platformID == MS_PLATFORMID)  /* only applies to this platform */
				{
					*pOS2MinChr = pCharGlyphMapList[0].usCharCode;
					*pOS2MaxChr = pCharGlyphMapList[usnCharGlyphMapListCount-1].usCharCode;
				}
				errCode = WriteOutFormat4CmapData( pOutputBufferInfo, &CmapFormat4, NewFormat4Segments, NewFormat4GlyphIdArray, usnSegment,
							 snFormat4GlyphIdArray, ulCmapOffset + pCmapTableLoc[i].offset, &ulBytesWritten );
			}
			/* else: leave cmap subtable alone */

			/* clean up */

			Mem_Free(NewFormat4Segments);
			Mem_Free(NewFormat4GlyphIdArray );
			FreeFormat4CharCodes(pCharGlyphMapList);
			
			NewFormat4Segments = NULL;
			NewFormat4GlyphIdArray = NULL;
			pCharGlyphMapList = NULL;
		}
		RecordCmapOffset(&CmapSubtableKeeper, pCmapTableLoc[i].offset, pCmapTableLoc[i].offset); /* record the new offset (didn't change) */
	}
	/* now need to compress out empty bytes from ends of Cmap Subtables */
	if (errCode == NO_ERROR)
	{
		errCode = CompressCmapSubTables(pOutputBufferInfo, pCmapTableLoc, usSubTableCount, ulCmapOffset, ulCmapSubTableDirOffset, ulCmapLength, &ulCmapNewLength);
		*pulNewOutOffset = ulCmapOffset + ulCmapNewLength; /* hand back to caller */
	}
	else /* these weren't taken care of yet (necessarily) */
	{
		Mem_Free(NewFormat4Segments); /* may be non-null */
		Mem_Free(NewFormat4GlyphIdArray );
		FreeFormat4CharCodes(pCharGlyphMapList);
		if (errCode == ERR_WOULD_GROW)  /* fragmentation has caused a larger cmap table, copy table again */
		{
			*pulNewOutOffset = ulCmapOffset; /* reset */
			errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, CMAP_TAG, pulNewOutOffset);
		}
	}
	Mem_Free(pCmapTableLoc);
	FreeCmapOffsetArray(&CmapSubtableKeeper);

	return errCode;

} /* ModCmap() */

/* ------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\modtto.h ===
/*
  * ModTTO.h: Interface file for ModTTO.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */

#ifndef MODTTO_DOT_H_DEFINED
#define MODTTO_DOT_H_DEFINED

int16 ModTTO( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo,
			  TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
			  CONST uint8 *puchKeepGlyphList, 
			  CONST uint16 usGlyphListCount,
			  CONST uint16 usFormat,
			  uint32 *pulNewOutOffset);
#endif /* MODTTO_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\modtto.c ===
/***************************************************************************
 * module: modtto.C
 *
 * author: Louise Pathe
 * date:   1995
 * Copyright 1990-1997. Microsoft Corporation.
 * This is a modified copy of modtto.c from ttoshare directory
 * The functionality is the same, but these 3 areas have been modified.
 * 1. error reporting (string msgs) has been removed
 * 2. file i/o has been changed to interface with ttfacc
 * 3. Get rid of translmotorola stuff
 *
 **************************************************************************/

/* Inclusions ----------------------------------------------------------- */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>  /* for isalpha etc. functions */ 
#include <math.h>
#include <assert.h>
#include <limits.h>

#include "typedefs.h"
#include "ttfdelta.h"	/* for error codes */
#include "ttff.h"
#include "ttfacc.h"
#include "ttfcntrl.h"
#include "ttftabl1.h"
#include "ttftable.h"
#include "modtto.h"
#include "ttmem.h" 
#include "util.h"
/* support for ttopen from ttoshare */
#include "ttofile.h"
#include "ttostruc.h" 
#include "symbol.h"
#include "ttoutil.h"
#include "readff.h"
#include "ttoerror.h" /* for debugging */
#include "ttofmt.h"  /* format file C files for 5 formats */  
#include "ttodepen.h"  /* structure for dependency info */ 

/* Macro Definitions -------------------------------------------------- */

#ifdef _DEBUG
#define ErrTrap(a) ErrorTrap(a)
#else
#define ErrTrap(a) a
#endif

/* constant definitions -------------------------------------------------- */   
#define TTOErr -1
#define TTONoErr 0
#define MAXSTRUCTDEPTH 20
/* unsigned var values */
#define INVALID_FILE_OFFSET 0xFFFF
#define INVALID_COUNT 0xFFFF
/* signed var values */
#define INVALID_OFFSET -1

/* special cases that need special handling */
#define SZCoverageFormat1 "CoverageFormat1"
#define SZCoverageFormat2 "CoverageFormat2" 
#define SZClassDefFormat1 "ClassDefFormat1"
#define SZClassDefFormat2 "ClassDefFormat2"  
#define SZBaseCoordFormat2 "BaseCoordFormat2"
#define SZSingleSubstFormat1 "SingleSubstFormat1"   

#define TableFlagCoverageFormat1Count 1
#define TableFlagCoverageFormat2Count 2 
#define TableFlagClassDefFormat1Count 4
#define TableFlagClassDefFormat2Count 8
#define TableFlagSyncCount (TableFlagCoverageFormat1Count | TableFlagCoverageFormat2Count | TableFlagClassDefFormat1Count | TableFlagClassDefFormat2Count)
#define TableFlagBaseCoordFormat2 16
#define TableFlagSingleSubstFormat1 32   

#define MAXARRAYS 10 /* maximum number of arrays per table */ 
 
/* structure definitions ------------------------------------------------- */   
/* This structure is used to keep track of Array counts, so they can be updated if the array size changes */
typedef struct arraycountreference ARRAYCOUNTREFERENCE;
typedef struct arraycountreference *PARRAYCOUNTREFERENCE, **PPARRAYCOUNTREFERENCE;
struct arraycountreference {
	uint16 uValue;	  	  /* value of the array count */
	uint16 uFileOffset;   /* offset where this array count is written, relative to the uBaseOffset */
	uint16 uBaseOffset;   /* Base offset of the table that references this table */
	uint16 cMinCount;     /* can this array be zero or not */
};
					
/* This structure is used to hold values of parameters passed to tables */
typedef struct parameter PARAMETER ;
struct parameter {	      /* to keep track of values passed from other tables */
	int32 lValue;  		  /* parameters passed to this table by a referencing element */
	int16 iTableIndex;    /* TableReferenceIndex of parameter being passed */
	uint16 uInOffset; 	  /* Absolute offset of this parameter element */
	ARRAYCOUNTREFERENCE ArrayCountReference; /* store where this parameter came from */
};

/* This data is stored, one per table in the font, to be retrieved when needed */
typedef struct ttosymbol_data *PTTOSYMBOL_DATA;
typedef struct ttosymbol_data TTOSYMBOL_DATA;
struct ttosymbol_data {      /* Source TTO File Symbol Data */
	int16 iStructureIndex;   /* Index into structure array of this table */
	int16 iTableIndex;    	 /* index into TableReference dependency array - stored separately, variable length */
	char szTableType[MAXBUFFERLEN];	/* store the string which is the type of table here */
	PARAMETER Param[MaxParameterCount];
};
  
/* information about an element of a table being processed */
typedef struct elementvalue_list ELEMENTVALUE_LIST;
typedef struct elementvalue_list *PELEMENTVALUE_LIST;
struct elementvalue_list {
	int32 lValue;       /* value of element */
	int16 iTableIndex;  /* TableReferenceIndex of table whose count is used. -1 if none */
	uint16 uFileOffset; /* offset into file of this element, relative to base offset of table */
	uint16 uInOffset; 	  /* Absolute offset of this element */
};
  
/* information about the table or record currently being processed. Pushed onto a stack */
typedef struct structstack_list STRUCTSTACK_LIST; 
typedef struct structstack_list *PSTRUCTSTACK_LIST; 
struct structstack_list {
 	int16  iStructureIndex; /* index into structure array of this structure on the stack */
 	int16  cArrayCount;     /* number of items in array. Starts at number and is decremented */
 	int16  cRecordCount;    /* number of record arrays */ 
	int16  iCountTableReferenceIndex; /* index to TABLEREFERENCE array of structure cArrayCount depends upon */
	int16  iCurrArrayCountIndex; /* index into ArrayCountReference Array */
	int16  iTableIndex; 	/* index into TABLEREFERENCE array of this structure */
	int16  fTrackIndex;  	/* if -1, not tracking Lookup or Feature Indexes, otherwise, this it the index into the IndexRemapArray in State */
 	uint16 iElementIndex;  	/* index to element we are working on currently - 0 based */ 
	uint16 fWriteElement;  	/* write the Element or not, sync with coverage table */
	uint16 fWriteRecord;  	/* if something goes bad in the record, turn this off */
	uint16 uBeforeRecordOffset; /* offset where we were writing before we went into a record, in order to back out if record deleted */
	ARRAYCOUNTREFERENCE ArrayCountReference[MAXARRAYS];
	PELEMENT_LIST pCurrElement; /* current element in structure we are considering */
	PELEMENTVALUE_LIST pValueList; /* array of actual values found in datafile - size determined by number of elements in Element list */
}; 

/* used to keep track of LookupList and FeatureList indexes that may need to be remapped */
typedef struct indexremaptable INDEXREMAPTABLE;
typedef struct indexremaptable *PINDEXREMAPTABLE;

struct indexremaptable
{
	uint16 uCount;
	uint16 *pNewIndex;	/* dynamic array of new index values */
};

#define IndexRemapCount 4

/* State of the process */  
typedef struct datafile_state DATA_FILE_STATE;
typedef struct datafile_state *PDATA_FILE_STATE;
struct datafile_state {
	PSYMBOL_TABLE pTTOSymbolTable;  /* symbol table for the Source TTO File - contains constants and offset labels */
	PSYMBOL_TABLE pFFSymbolTable; 	/* symbol table for the Format File, contains structure type names */ 
   	PSTRUCTURE_LIST pStructureList; /* list of structure created by Format File reader */ 
	TTFACC_FILEBUFFERINFO * pInputBufferInfo; /* info for file buffer */ 
   	uint32 ulInputTTOOffset; 			/* offset to TTOTable in input file */
	uint16 uCurrentOutOffset;     	/* Where we are currently writing in the output buffer */
	uint16 uCurrentInOffset;     	/* Where we are currently reading from in the input table */
	uint16 uOutBaseOffset;			/* offset of current table on Output */
	uint16 uInBaseOffset;			/* offset of current table on Input */
	int16  iStructStackIndex;       /* index into aStructStack of current table or record */
	BOOL   fPass2;          		/* If false, it is pass 1 */
	BOOL   fVerbose; 				/* let user in on all deletion stuff */
	int16  SpecialTable;   	/* Am I tracking something and if so what?*/
	unsigned char * OutputBuffer;   /* buffer where data will be written. Copied to Output file */
	uint16 cBufferBytes;            /* number of Bytes written to Output Buffer */     
	uint32 ulDataFileBytes;  		/* size of the table to be modified. */
	uint16 uCoverageFormat2Glyphs;	/* number of glyphs in Coverage Format 2 tables - may cause expansion of table */
	TTOSYMBOL_DATA ttoSymbolData; 	/* local copy of the ttoSymbolData for table entries */  
	STRUCTSTACK_LIST aStructStack[MAXSTRUCTDEPTH]; /* structure stack. [0] = table, [1] .. [n] = Records */
	TABLEREFERENCEKEEPER keeper;  /* to keep track of cross table references */	 
	PINDEXREMAPTABLE pIndexRemapArray;	/* the 4 types of indices */
	uint16 fIndexUnmapped; /* flag to indicate if an IndexUnmap has occurred */
};

static CONST uint16 f_aMinMax[MaxMinMax] = {    /* unchangeable for ttfsub */
	0,
	USHRT_MAX,
	0,
	USHRT_MAX,
	0,
	USHRT_MAX
} ;

/* used to process all the TTO tables */
typedef struct tag_type TAG_TYPE; 

struct tag_type {
	char *szTag;
	char ** pFileArray;  /* pointer to the global string array that describes the format of the table */
};

#define TagTableCount 5

static CONST TAG_TYPE f_TagTable[TagTableCount] = {
  {GPOS_TAG, g_GPOSFmt},  /* must come before jstf for Index remapping */
  {GSUB_TAG, g_GSUBFmt},  /* must come before jstf for Index remapping */
  {GDEF_TAG, g_GDEFFmt},
  {JSTF_TAG, g_JSTFFmt},
  {BASE_TAG, g_BASEFmt}
};
  
/* function definitions ------------------------------------------------- */ 
#ifdef _DEBUG
int16 ErrorTrap(int16 code)	 /* for debugging */
{
	return code;
}
#endif

/* ---------------------------------------------------------------------- */ 
/* used to pad the offset to a double word boundary to determine if we have */
/* reached the end of the tto table */
/* ---------------------------------------------------------------------- */ 
PRIVATE uint16 TTOPad(uint16 uOffset)
{
 	if ((uOffset%4) == 0)
 		return(uOffset);
 	return((uint16) (uOffset + (4 - (uOffset%4))));  /* pad to the nearest 4 bytes */
} 

/* ---------------------------------------------------------------------- */ 
/* comparison function passed to GetSymbolByFunction function */
/* ---------------------------------------------------------------------- */ 

PRIVATE BOOL TTOCompareFFSymbolIndex(int16 iStructureIndex, PFFSYMBOL_DATA pffSymbolData) 
{

 	if (iStructureIndex == pffSymbolData->iStructureIndex)
 		return(TRUE);
 	return(FALSE);

} 

/* ---------------------------------------------------------------------- */ 
/* counts the elements in an element list */
/* arrays are counted as 1 element */
/* ---------------------------------------------------------------------- */ 
PRIVATE uint16 TTOCountElements(PELEMENT_LIST CONST pFirst)
{
uint16 Count = 0; 
PELEMENT_LIST pEList;

	for (pEList = pFirst ; pEList; pEList = pEList->pNext)
	    ++Count;
    return(Count);
}

/* ---------------------------------------------------------------------- */ 
PRIVATE void TTOInitTTOSymbolData(PTTOSYMBOL_DATA pttoSymbolData)
{
uint16 i;

	memset(pttoSymbolData, 0, sizeof(*pttoSymbolData));
	pttoSymbolData->iStructureIndex = INVALID_INDEX;
	for (i = 0; i < MaxParameterCount; ++i)
		pttoSymbolData->Param[i].iTableIndex = INVALID_INDEX;
}

/* ---------------------------------------------------------------------- */ 
/* determine if a structure is a member of another structure */
/* recursive! */
/* ---------------------------------------------------------------------- */ 
PRIVATE BOOL TTOIsMember(PSTRUCTURE_LIST CONST pStructureList, 
						int16 CONST iMemberIndex, 
						int16 CONST iClassIndex)
{
PELEMENT_LIST pClassElement;
PSTRUCTURE_DEF pClassStructureDef; 

	if (iMemberIndex == iClassIndex)
		return(TRUE);
	pClassStructureDef = pStructureList->pStructureDef + iClassIndex;  
	for (pClassElement = pClassStructureDef->pFirst; pClassElement != NULL; pClassElement = pClassElement->pNext)
	{
		if (pClassElement->uType != ETClassMember)
			return(FALSE);
		if (TTOIsMember(pStructureList, iMemberIndex, pClassElement->iStructureIndex) == TRUE)
			return(TRUE); 
		/* otherwise keep looking */
	}
  	return(FALSE);
}
 
/* ---------------------------------------------------------------------- */ 
PRIVATE int16 TTOGetElementValue(PDATA_FILE_STATE CONST pState, uint16 CONST iElementIndex, uint16 CONST uSymbElementType, int32 *pElementValue, int16 *piTableIndex, uint16 *puInOffset, PARRAYCOUNTREFERENCE pArrayCountReference); 
/* ---------------------------------------------------------------------- */ 
PRIVATE int16 TTODeCodeLimitCalc(PDATA_FILE_STATE CONST pState, 
								PCALC_LIST CONST pLimitCalc)
{
int16 Limit;
PCALC_LIST pCalc;
int32 lValue; 
int32 lAccumulator;

    
    lAccumulator = lValue = 0L;
	for (pCalc = pLimitCalc; pCalc != NULL; pCalc = pCalc->pNext)
	{    
		if (pCalc->pFunctionList != NULL)
		{    
			lAccumulator = lValue = 1L;	/* assume it shouldn't be 0 */
			break;
		}
		else if (pCalc->iElementIndex != 0)  /* symbolic element reference $T, $R or $P */
		{ 
			if (TTOGetElementValue(pState, pCalc->iElementIndex, pCalc->uSymbElementType, &lValue, NULL, NULL, NULL) == TTOErr)	/* appears to be a circular reference, but it is not */
				return ErrTrap(TTOErr);
		}
		else if (pCalc->uMinMax != 0) /* its a MinMax value */ 
		{
			if (pCalc->uMinMax > MaxMinMax)
				/* "Internal! Unknown MinMax in count field.", 0, TTOErr); */
				return ErrTrap(TTOErr);
		   	lValue = f_aMinMax[pCalc->uMinMax - 1];
		}
		else /* just a value */
			lValue = pCalc->lValue;
		
		switch(pCalc->uOperation)
		{
		case CalcOperIdentity:	
			lAccumulator = lValue; 
			break;
		case CalcOperAdd:
			lAccumulator += lValue;
			break;
		case CalcOperSubtract:
			lAccumulator -= lValue;
			break;
		case CalcOperDivide:
			lAccumulator = lAccumulator/lValue;
			break;
		case CalcOperMultiply:
			lAccumulator = lAccumulator*lValue;
			break;
		}
		
	} 
    Limit = (int16) lAccumulator;
    return(Limit);
}
/* ---------------------------------------------------------------------- */ 
/* Given a symbolic element reference, return the actual value of that element */
/* also return other information about the element */
/* ---------------------------------------------------------------------- */ 
PRIVATE int16 TTOGetElementValue(PDATA_FILE_STATE CONST pState, 
								uint16 CONST iElementIndex, 
								uint16 CONST uSymbElementType, 
								int32 *pElementValue, 
								int16 *piTableIndex, 
								uint16 *puInOffset, 
								PARRAYCOUNTREFERENCE pArrayCountReference) 
{   
PSTRUCTSTACK_LIST pStruct;
uint16 iStackIndex;
uint16 i; 

  	if (uSymbElementType == SymbElementTypeRecord)
  		iStackIndex = pState->iStructStackIndex; /* $R - current record */ 
	else  /* $T or $P it has to be a table */
  		iStackIndex = 0;   /* parent table */
  	pStruct = &pState->aStructStack[iStackIndex];  
	if (uSymbElementType == SymbElementTypeParameter)     /* $P */
	{   
		if (iElementIndex > pState->pStructureList->pStructureDef[pStruct->iStructureIndex].cParameters)
	   	{    
			/* "Parameter number out of range specified in FORMAT FILE for this element. Max is %d.", pState->pStructureList->pStructureDef[pStruct->iStructureIndex].cParameters);
	   		return Error(szErrorBuf, 0, TTOErr); */
			return ErrTrap(TTOErr);
	   	}
		else if (iElementIndex >= 1 && iElementIndex <= MaxParameterCount) 
		{          /* check also for cParameters */
	   		if (pElementValue != NULL)
	   			*pElementValue = pState->ttoSymbolData.Param[iElementIndex-1].lValue;
	   		if (piTableIndex != NULL)
	   			*piTableIndex = pState->ttoSymbolData.Param[iElementIndex-1].iTableIndex;
			if (puInOffset)
				*puInOffset = pState->ttoSymbolData.Param[iElementIndex-1].uInOffset;
			if (pArrayCountReference != NULL)
			{
				pArrayCountReference->uValue = pState->ttoSymbolData.Param[iElementIndex-1].ArrayCountReference.uValue; /* seemingly redundant, but the easiest way */
				pArrayCountReference->uFileOffset = pState->ttoSymbolData.Param[iElementIndex-1].ArrayCountReference.uFileOffset;		  /* offset where this array count is written, relative to the uBaseOffset */
				pArrayCountReference->uBaseOffset = pState->ttoSymbolData.Param[iElementIndex-1].ArrayCountReference.uBaseOffset;   /* Base offset of the table that references this table */
		   		pArrayCountReference->cMinCount = pState->ttoSymbolData.Param[iElementIndex-1].ArrayCountReference.cMinCount;
	   		}
	   	}
	   	else
	   	{    
	   		/* "Parameter number out of range in FORMAT FILE for this element. Max is %d.", MaxParameterCount);
	   		return Error(szErrorBuf, 0, TTOErr); */
			return ErrTrap(TTOErr);
	   	}
	} 
	else 
	{
	PELEMENT_LIST pCurrElement;   /* element to process */
	PSTRUCTURE_DEF pStructureDef; /* structure we are in */

	  	if (pStruct->iElementIndex < iElementIndex) /* forward reference */
	  		/* Invalid forward element reference.",0, TTOErr); */ 
			return ErrTrap(TTOErr);
	  	if (pElementValue != NULL)
	  		*pElementValue = pStruct->pValueList[iElementIndex-1].lValue;
		if (piTableIndex != NULL)
			*piTableIndex = pStruct->pValueList[iElementIndex-1].iTableIndex;
		if (puInOffset)
			*puInOffset = pStruct->pValueList[iElementIndex-1].uInOffset;
		if (pArrayCountReference != NULL)
		{
			pArrayCountReference->uValue = (uint16) pStruct->pValueList[iElementIndex-1].lValue; /* seemingly redundant, but the easiest way */
			pArrayCountReference->uFileOffset = pStruct->pValueList[iElementIndex-1].uFileOffset;	/* relative to uBaseOffset */
			pArrayCountReference->uBaseOffset = pState->uOutBaseOffset;   /* Base offset of the table that references this table */
			pStructureDef = pState->pStructureList->pStructureDef + pStruct->iStructureIndex;     /* grab that structure */
			pCurrElement = pStructureDef->pFirst;
		   	for (i = 1; i < iElementIndex; ++i)
				pCurrElement = pCurrElement->pNext;	 /* get the CurrElement */
			if (pCurrElement) /* if there's a range, save that value */
				pArrayCountReference->cMinCount = TTODeCodeLimitCalc(pState, pCurrElement->pMinCalc);
			else
				pArrayCountReference->cMinCount = 0;
		}
	} 
	return (TTONoErr);
}
/* ---------------------------------------------------------------------- */ 
/*  pState - passed to TTOGetElementValue */
/*  Given a calc record, determine the actual value */
/*  recursive */ 
/* ---------------------------------------------------------------------- */ 
PRIVATE int16 TTODeCodeCountCalc(PDATA_FILE_STATE CONST pState, 
								PCALC_LIST CONST pCountCalc, 
								int16 * pCount, 
								int16 *piTableIndex, 
								uint16 *puInOffset, 
								PARRAYCOUNTREFERENCE pArrayCountReference)
{
int16 i;
PCALC_LIST pCalc;
int32 lValue; 
int16 sValue;
int32 lAccumulator;
int16 BitCount;
int16 mask;

    
	if (pArrayCountReference != NULL)
	{
		pArrayCountReference->uValue = 0;
		pArrayCountReference->uFileOffset = INVALID_FILE_OFFSET;
		pArrayCountReference->uBaseOffset = 0;
		pArrayCountReference->cMinCount = 0;
	}
    lAccumulator = lValue = 0L;
	for (pCalc = pCountCalc; pCalc != NULL; pCalc = pCalc->pNext)
	{    
		if (pCalc->pFunctionList != NULL)
		{    
			sValue = 0;
			BitCount = 0;
			if (TTODeCodeCountCalc(pState, pCalc->pFunctionList, &sValue, NULL, NULL, NULL) == TTOErr) 
				return ErrTrap(TTOErr);
			if (pCalc->uFunction == CalcFuncBitCount0F)
				mask = 0x0001;
			else if (pCalc->uFunction == CalcFuncBitCountF0)
				mask = 0x0010;
			else 
			{
				/* "Unknown function in Format File in count field of Array element at offset %#04x", pState->uCurrentInOffset);
				return Error(szErrorBuf, 0, TTOErr); */
				return ErrTrap(TTOErr);
			}
		    for (i = 0; i < 4; ++i)
		    {
		    	BitCount += ((int16)sValue & mask) ? (int16) 1 : (int16) 0; 
		    	mask =  mask << 1;
		    }
		    lValue = BitCount;
		}
		else if (pCalc->iElementIndex != 0)  /* symbolic element reference $T, $R or $P */
		{ 
			if (TTOGetElementValue(pState, pCalc->iElementIndex, pCalc->uSymbElementType, &lValue, piTableIndex, puInOffset, pArrayCountReference) == TTOErr)
				return ErrTrap(TTOErr);
		}
		else if (pCalc->uMinMax != 0) /* its a MinMax value */ 
		{
			if (pCalc->uMinMax > MaxMinMax)
				/* Internal! Unknown MinMax in count field.", 0, TTOErr); */
				return ErrTrap(TTOErr);
		   	lValue = f_aMinMax[pCalc->uMinMax - 1];
		}
		else /* just a value */
			lValue = pCalc->lValue;
		
		switch(pCalc->uOperation)
		{
		case CalcOperIdentity:	
			lAccumulator = lValue; 
			break;
		case CalcOperAdd:
			lAccumulator += lValue;
			break;
		case CalcOperSubtract:
			lAccumulator -= lValue;
			break;
		case CalcOperDivide:
			lAccumulator = lAccumulator/lValue;
			break;
		case CalcOperMultiply:
			lAccumulator = lAccumulator*lValue;
			break;
		default:
			/* "Unknown operator in Count field of Array at offset %#04x", pState->uCurrentInOffset);
			return Error(szErrorBuf, 0, TTOErr); */
			return ErrTrap(TTOErr);
			break;
		}
		
	} 
	if (lAccumulator & 0xFFFF0000)  /* if we have some high bits on!!! */   
	{    
		/*  "Count field invalid. Value \'%ld\' too large or negative at offset %#04x.", lAccumulator, pState->uCurrentInOffset);
	 	return Error(szErrorBuf, 0, TTOErr); */
		return ErrTrap(TTOErr);
	}
    *pCount = (int16) lAccumulator;
    return(TTONoErr);
}
/* ---------------------------------------------------------------------- */ 
/* given a count element, look at the calc list to determine if the count should be linked */
/* to another table's coverage or class count. if so, return the table index of that table */ 
/* ---------------------------------------------------------------------- */ 
PRIVATE int16 OffsetFunctionIndex(PDATA_FILE_STATE pState, 
								 PSTRUCTSTACK_LIST pStruct)
{
int16 iTableIndex = INVALID_INDEX;
PCALC_LIST pCalc;
int32 lValue;

	if ((pStruct->pCurrElement->pMinCalc != NULL) && 
		(pStruct->pCurrElement->pMaxCalc == NULL))
		pCalc = pStruct->pCurrElement->pMinCalc;
	else if ((pStruct->pCurrElement->pMinCalc == NULL) && 
		(pStruct->pCurrElement->pMaxCalc != NULL))
		pCalc = pStruct->pCurrElement->pMaxCalc;
	else
		return(iTableIndex);

	if (pCalc->pFunctionList != NULL)
	{    
		if ((pCalc->uFunction == CalcFuncClassCount) || (pCalc->uFunction == CalcFuncCoverageCount) )
			if (TTOGetElementValue(pState, pCalc->pFunctionList->iElementIndex, pCalc->pFunctionList->uSymbElementType, &lValue, &iTableIndex, NULL, NULL) == TTOErr)   
				return(INVALID_INDEX); 
	}
	return(iTableIndex);
}
/* ---------------------------------------------------------------------- */ 
/* Initialize an IndexRemapArray array */
/* ---------------------------------------------------------------------- */ 
PRIVATE int16 TTOInitIndexRemap(uint16 iArrayIndex, 
							   uint16 fAllocate, 
							   PINDEXREMAPTABLE pIndexRemapArray)
{
uint16 i;
	if (iArrayIndex >= IndexRemapCount)
		return(TTONoErr);
	if (fAllocate == 0)
	{
		pIndexRemapArray[iArrayIndex].uCount = 0;
		pIndexRemapArray[iArrayIndex].pNewIndex = NULL;
	}
	else
	{
		if (pIndexRemapArray[iArrayIndex].uCount > 0) 
		{
			pIndexRemapArray[iArrayIndex].pNewIndex = (uint16 *) Mem_Alloc(pIndexRemapArray[iArrayIndex].uCount * sizeof(uint16));
			if (pIndexRemapArray[iArrayIndex].pNewIndex == NULL)
				/* Unable to allocate memory in TTOInitIndexRemap", 0,TTOErr);	*/
				return ErrTrap(TTOErr);
			for (i = 0; i < pIndexRemapArray[iArrayIndex].uCount; ++i)
				pIndexRemapArray[iArrayIndex].pNewIndex[i] = i;
		}
	}
	return(TTONoErr);	

}
/* ---------------------------------------------------------------------- */ 
/* given an ArrayIndex (type of array), and an IndexValue (index into that type), */
/* remove that Index Value from the array - invalidating that index. Used when a member */
/* of a FeatureList or LookupList is deleted */
/* ---------------------------------------------------------------------- */ 

PRIVATE int16 TTOIndexUnmap(uint16 iArrayIndex, 
						   uint16 iIndexValue, 
						   PINDEXREMAPTABLE pIndexRemapArray, 
						   int16 fIndexUnmapped)
{
uint16 i;
uint16 iUnmapIndex;

	if ((iArrayIndex >= IndexRemapCount) || 
		(iIndexValue >= pIndexRemapArray[iArrayIndex].uCount) ||
		(pIndexRemapArray[iArrayIndex].pNewIndex == NULL))
		return fIndexUnmapped;
	iUnmapIndex = pIndexRemapArray[iArrayIndex].pNewIndex[iIndexValue];
	if (iUnmapIndex != (uint16) INVALID_INDEX)
	{
		pIndexRemapArray[iArrayIndex].pNewIndex[iIndexValue] = (uint16) INVALID_INDEX; /* turn it off */
		for (i = 0; i < pIndexRemapArray[iArrayIndex].uCount; ++i)
			if ((pIndexRemapArray[iArrayIndex].pNewIndex[i] != (uint16) INVALID_INDEX) &&
				(pIndexRemapArray[iArrayIndex].pNewIndex[i] > iUnmapIndex)) /* shuffle only those bigger lcp 1/97 */
					pIndexRemapArray[iArrayIndex].pNewIndex[i] -= 1; /* shuffle everyone down one */
		return TRUE;
	}
	return fIndexUnmapped;
}
/* ---------------------------------------------------------------------- */ 
/* given a type of IndexArray, and a Value, return the remapped Index value */
/* used after a FeatureList or LookupList element is deleted */
/* ---------------------------------------------------------------------- */ 
PRIVATE uint16 TTOIndexRemap(uint16 uType, 
							uint16 uValue, 
							PINDEXREMAPTABLE pIndexRemapArray)
{
uint16 iArrayIndex;

	switch(uType) 
	{
	case ETGSUBLookupIndex:
		iArrayIndex = ConfigIGSUBLookupIndex;
		break;
	case ETGSUBFeatureIndex:
		iArrayIndex = ConfigIGSUBFeatureIndex;
		break;
	case ETGPOSLookupIndex:
		iArrayIndex = ConfigIGPOSLookupIndex;
		break;
	case ETGPOSFeatureIndex:
		iArrayIndex = ConfigIGPOSFeatureIndex;
		break;
	default:
		return((uint16)INVALID_INDEX);
		break;
	}
	if ((pIndexRemapArray[iArrayIndex].uCount == 0) || pIndexRemapArray[iArrayIndex].pNewIndex == NULL)
		return(uValue);
	if (uValue < pIndexRemapArray[iArrayIndex].uCount)
		return (pIndexRemapArray[iArrayIndex].pNewIndex[uValue]);
	return((uint16)INVALID_INDEX);
}

/* ---------------------------------------------------------------------- */ 
/* RETURNS TTOErr, 0 or 1 for whether important data was actually written */
/* struct stack 0 = TABLE structure */
/* struct stack 1 .. n = RECORD structure */ 
/* our state here is that pCurrElement is pointing at the next element in the current struct stack structure */
/* it may be that that element is NULL (we haven't started the structure) or it may be a Record element */
/* in which case that record must be put onto the stack */
/* ---------------------------------------------------------------------- */ 
PRIVATE int16 TTOProcessElement(PDATA_FILE_STATE pState, 
							   CONST uint8 *puchKeepGlyphList, 
							   CONST uint16 usGlyphListCount, 
							   uint16 uTableDataWritten)
{ 
PELEMENT_LIST pCurrElement;   /* element to process */
PSTRUCTURE_DEF pStructureDef; /* structure we are in */
PSTRUCTSTACK_LIST pStruct;    /* local pointer into structure stack */
PPARAM_LIST pCurrParam;       /* pointer to loop through parameter list */
TTOSYMBOL_DATA ttoSymbolData; /* local copy for offsets */  
TABLEREFERENCE TableReference; /* for tracking dependencies */
PTABLEREFERENCE pTableReference; /* for updating dependency values */
int32 lValue = 0L;            /* where to hold the value of the element - read from file */ 
uint16 uValue = 0; 
int8 bValue = 0;
uint8 *lValue_bytes = (uint8 *) &lValue; /* Used for tags */
int32 lParamValue = 0L;     /* where to hold parameter value */
int16 iStructureIndex;      /* index into structure array of structure we are looking at (record,Offset) */
uint16 uType;               /* type of this element */
uint16 i, j, k, l, m;		/* you know what these are */
uint16 cElements;           /* number of elements in structure */
uint16 uOffset;             /* holds an offset value to be written */
uint16 PackedShift = 0;		/* used for packedints */
uint16 PackedMask = 0;  
uint16 PackedNeg = 0;
int16 PackedCount=0;
int16 PackedStartCount= 0; /* index into packed buffer to begin with */ 
int16 iTableIndex = INVALID_INDEX;	/* dummy var used to hold value from GetElementValue */
uint16 usBitValue;
int16 iCountTableReferenceIndex = INVALID_INDEX; /* index to TABLEREFERENCE array of structure array count depends on */
uint16 uInOffset = 0;   	/* input offset of reference to structure used for count */
uint16 fWriteData = TRUE;	/* should data be written to the file? */
uint16 fWriteElement=TRUE;	/* should this element be written to the file */
uint16 fAlreadyWritten=FALSE; /* special structure writes stuff out before general case */
uint16 uOldGlyphIDValue;	/* the original, unaltered glyphID from the file */
uint16 fDelNone = FALSE;	/* can we delete any elements from the array? */
uint16 fNOTNULL = FALSE;	/* can this offset be NULL? */
REFERENCE Reference;		/* reference record	to add to TableReference structure */
uint16 uNewSingleSubstFormat1DeltaValue; /* flag to indicate whether to write out this or not in Offset */
uint16 uTableOffset; /* used for Symbol Table */

	/* where are we? Need to be in the aStructStack */
	if (pState->iStructStackIndex == INVALID_INDEX) 
	{
		/*  "Internal. Structure Stack Empty at offset %#04x", pState->uCurrentInOffset);
		return Error(szErrorBuf, 0, TTOErr); */
		return ErrTrap(TTOErr); 
	}

	/* hike the structures to simplify code */
	pStruct = &pState->aStructStack[pState->iStructStackIndex];
	if ((uint16)(iStructureIndex = pStruct->iStructureIndex) > pState->pStructureList->cStructures)
	{
		/*  "Internal. Structure Stack Index greater than number of structures at offset %#04x", pState->uCurrentInOffset);
		return Error(szErrorBuf, 0, TTOErr) */
		return ErrTrap(TTOErr); 
	}
	pStructureDef = pState->pStructureList->pStructureDef + iStructureIndex;     /* grab that structure */

	if (pStruct->iElementIndex == 0) /* this is the first element we are looking at */ 
	{
		pStruct->pCurrElement = pStructureDef->pFirst;
		if (pStruct->pCurrElement == NULL)    /* no elements for this structure.  */
		{   
          	if (--pState->iStructStackIndex == INVALID_INDEX) 	 /* pop structure off stack */    
          		return(TTONoErr);                    /* no elements in TABLE - OK. */ 
			pStruct = &pState->aStructStack[pState->iStructStackIndex]; /* otherwise we're up a level and need to hike again */
        } 
        else /* need to allocate a ValueList to hold the element values */ 
        {
           	cElements = TTOCountElements(pStruct->pCurrElement); /* find out how many elements there are */
			pStruct->pValueList = (PELEMENTVALUE_LIST) Mem_Alloc(cElements * sizeof(ELEMENTVALUE_LIST));
			if (pStruct->pValueList == NULL)
				return ErrTrap(TTOErr);
		}		
    } 
    if (pStruct->pCurrElement == NULL)    /* the last element of that structure has been processed */
	{
		/*  "Internal. Structure Stack corrupt at offset %#04x", pState->uCurrentInOffset);
		return Error(szErrorBuf, 0, TTOErr);  */
		return ErrTrap(TTOErr);
	}

	/* hike pCurrElement */																			  
	pCurrElement = pStruct->pCurrElement;   
	uType = pCurrElement->uType & ~ETArray;
	if (pCurrElement->uType & ETArray) /* have to get the count value */
	{   
		while (1)   /* cruise down nested arrays to where we find an actual data element */
		{
			if (pStruct->cArrayCount <= 0)	/* we need to get the count, may already have it if this is Record Array */ 
			{
				if (TTODeCodeCountCalc(pState, pCurrElement->pCountCalc, &(pStruct->cArrayCount), 
					&iCountTableReferenceIndex,  &uInOffset, &(pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex])) == TTOErr)
				{
					/*  "Internal. CountCalc structure corrupt at offset %#04x", pState->uCurrentInOffset);
					return Error(szErrorBuf, 0, TTOErr);  */
					return ErrTrap(TTOErr);
				} 
				pStruct->cRecordCount=pStruct->cArrayCount; /* set here for reporting record indexes */
				pStruct->iCountTableReferenceIndex = iCountTableReferenceIndex;
/* 				pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].cMinCount = TTODeCodeLimitCalc(pState, pCurrElement->pMinCalc); override what came from decode calc count */
				
				/* now check if this array controls a Feature or Lookup Index */
				if ((pCurrElement->pConfig) && (pCurrElement->pConfig->uFlag >= MinIndexValue) && (pCurrElement->pConfig->uFlag < IndexRemapCount))  /* if we have an Index to track */
				{
					pState->pIndexRemapArray[pCurrElement->pConfig->uFlag].uCount = pStruct->cArrayCount;
					pStruct->fTrackIndex = pCurrElement->pConfig->uFlag; 
				}
			}
			if ((uType == ETRecord) && (pStruct->cArrayCount > 0)) /* need to push Record on the stack to process it */
			{ 
				fWriteElement = pStruct->fWriteElement;  /* get the one from before */
				if (pStruct->iCountTableReferenceIndex > INVALID_INDEX)  /* this array count depends on a CoverageCount or ClassCount function */
				{
					GetTTOBitFlag(&(pState->keeper), pStruct->iCountTableReferenceIndex, (uint16) (pStruct->cRecordCount - pStruct->cArrayCount), &usBitValue);
					if ((usBitValue == 0) && (pState->fPass2)) /* it's ok, we're syncronised */
						fWriteElement = FALSE;
				}
				pStruct->uBeforeRecordOffset = pState->uCurrentOutOffset;  /* save this in case we have to back out */
				if (++pState->iStructStackIndex >= MAXSTRUCTDEPTH) /* next stack structure - don't go too deep */ 
				{
				    /* "Record Nesting too deep. Maximum level %d", MAXSTRUCTDEPTH); 
				    return Error(szErrorBuf,0,TTOErr);	 */
					return ErrTrap(TTOErr);
				}
				                
				pStruct = &pState->aStructStack[pState->iStructStackIndex]; /* hike code */
				pStruct->iStructureIndex = pCurrElement->iStructureIndex; /* save record type */
				pStruct->iElementIndex = 0;   /* no elements processed yet */
				pStruct->cRecordCount=0;
				pStruct->fWriteElement = fWriteElement;
				pStruct->fWriteRecord = TRUE;	
				pStruct->fTrackIndex = INVALID_INDEX;
				pStruct->iTableIndex = pState->ttoSymbolData.iTableIndex; /* use the same as the Table */
				pStruct->iCountTableReferenceIndex = iCountTableReferenceIndex;
				pStruct->iCurrArrayCountIndex = 0;
				pStructureDef = pState->pStructureList->pStructureDef + pCurrElement->iStructureIndex; /* hike code */
				pCurrElement = pStruct->pCurrElement = pStructureDef->pFirst; /* initialize CurrElements */
				cElements = TTOCountElements(pCurrElement);  /* create a value list to save the items */
				pStruct->pValueList = (PELEMENTVALUE_LIST) Mem_Alloc(cElements * sizeof(ELEMENTVALUE_LIST));				
  				if (pStruct->pValueList == NULL)
					return ErrTrap(TTOErr);

				uType = pCurrElement->uType & ~ETArray; /* knock off the array value to process 1 at a time */
				if (!(pCurrElement->uType & ETArray)) 	/* Does this records start with an array? */ 
				{
					pStruct->cArrayCount = 1;   /* no, just an item */
					break;  
				} 
				/* otherwise we'll go around again to grab the arraycount value */
			}
			else
				break;  /* if its not a record we don't need to push the stack again */ 
		} /* end while (1)  */
	}  /* end if array */
	else
		pStruct->cArrayCount = 1;    
	
	/* check to see if deleting this element negates the entire table */
	if  (pCurrElement->pConfig && (pCurrElement->pConfig->uFlag & ConfigDelNone))
		fDelNone = TRUE;
	if ((uType == ETTableOffset) && TTODeCodeLimitCalc(pState, pCurrElement->pMinCalc) > 0)
	   	fNOTNULL = TRUE;
	pTableReference = GetTTOTableReference(&(pState->keeper), pStruct->iTableIndex);
	if ((pTableReference != NULL) && (pTableReference->fDelTable==TRUE))	  /* if this table isn't to be, don't write out data */
		pStruct->fWriteElement = FALSE; 

/* ok, now read data out of the Source TTO File, and process all elements in the array */	
	while (pStruct->cArrayCount > 0 && pTableReference)
	{
 		if ((pStruct->fWriteElement == FALSE) && (fDelNone == TRUE)) /* we aren't supposed to delete this element, so delete the table */
			pTableReference->fDelTable = TRUE;
		fWriteElement = TRUE;	/* deleted by removal from coverage table? */
		fWriteData = TRUE;
		fAlreadyWritten = FALSE;  /* special case already writes data */
		if (pStruct->cRecordCount > 0)	/* we're dealing with a non-record array (record arrays set cRecordCount in the previous pStruct) */
		{
			if (pStruct->iCountTableReferenceIndex > INVALID_INDEX)   /* this array count depends on a CoverageCount or ClassCount function */
			{
				GetTTOBitFlag(&(pState->keeper), pStruct->iCountTableReferenceIndex, (uint16) (pStruct->cRecordCount - pStruct->cArrayCount), &usBitValue);
				if ((usBitValue == 0) && (pState->fPass2)) /* it's ok, we're syncronised */
					fWriteElement = FALSE;
			}
		}
		fWriteElement = pStruct->fWriteElement && fWriteElement;		 /* record and element write flags */
		if (fWriteElement && fWriteData)
			pStruct->pValueList[pStruct->iElementIndex].uFileOffset = pState->uCurrentOutOffset - pState->uOutBaseOffset;   /* save this before incrementing */
		else
			pStruct->pValueList[pStruct->iElementIndex].uFileOffset = INVALID_FILE_OFFSET; /* special value for "Don't re-write this puppy" */
		pStruct->pValueList[pStruct->iElementIndex].uInOffset = pState->uCurrentInOffset;   /* save this before incrementing */
 
 		/* NOW, find out what type of element we have, and process it */
        switch(uType)
        {  
		case ETuint8:	
		case ETint8:
			if (ReadByte(pState->pInputBufferInfo, &bValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
				return ErrTrap(TTOErr);
			pState->uCurrentInOffset += sizeof(uint8);
			if (fWriteElement && fWriteData)
			{
	    		if (pState->OutputBuffer && (pState->uCurrentOutOffset >= pState->cBufferBytes)) 
	    			/* Internal. Attempt to write past end of output buffer.",0, TTOErr); */
					return ErrTrap(TTOErr);
				WriteByteToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, (uint8) bValue);  
				pState->uCurrentOutOffset += sizeof(char); 
				uTableDataWritten = 1;
			}
			else if (fDelNone)  /* we aren't allowed NOT to write this */
			{
				pTableReference->fDelTable = TRUE;
			}
			lValue = bValue;		
			break;
		case ETuint16:
  		case ETint16:
		case ETCount:
	      	if (ReadWord( pState->pInputBufferInfo, &uValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
				return ErrTrap(TTOErr);

			pState->uCurrentInOffset += sizeof(uint16);
			/* now, see if we need to update the coverage value */
			lValue = uValue;
			if (uType == ETCount)  /* need to handle this a little differently */
			{
				iTableIndex = OffsetFunctionIndex(pState, pStruct);
				if (iTableIndex != INVALID_INDEX)	 /* may need to update the count value of an array */
				{	
					uValue = GetTTOBitFlagsCount(&(pState->keeper), iTableIndex);
					if (uValue > (uint16) lValue)  /* the input file is bogus */
					{
						/* "Bad data in input file for count field in at offset %#04x",pState->uCurrentInOffset + pState->ulInputTTOOffset);
						fatal_err(szErrorBuf);  */
						return ErrTrap(TTOErr);
					}
					if (pState->fPass2 && (uValue < lValue) && fDelNone) /* we aren't supposed to delete this element, so delete the table */
					{
						pTableReference->fDelTable = TRUE;
						fWriteData = FALSE;
					}
				}
				if (pState->SpecialTable & TableFlagCoverageFormat2Count) 
	        
	        	{	  /* need to process the whole structure right here, and move on */
					uint16 uOldRangeStartValue, uOldRangeEndValue;
					uint16 uNewRangeStartValue, uNewRangeEndValue;
					uint16 uOldCoverageCount;
					uint16 uOldRangeRecordIndex, uNewRangeRecordIndex;
					uint16 uNewRangeCount, uOldRangeCount;
					uint16 fWarn = FALSE;

		        	uOldRangeCount = uValue;  /* number of ranges to process */
					uNewRangeCount = 0;
					uOldCoverageCount = 0;
					uOldRangeRecordIndex = uNewRangeRecordIndex = 0;

					if (fWriteElement && fWriteData)  /* pretend to write out the count */
		 				pState->uCurrentOutOffset += sizeof(uint16);
					fAlreadyWritten = TRUE; /* don't write out stuff twice */
					if (pTableReference == NULL)
						/* fatal_err("No TableReference created for CoverageFormat2 Table."); */
						return ErrTrap(TTOErr);
					for (i = 0; i < uOldRangeCount; ++i)
					{
			        	if (ReadWord(pState->pInputBufferInfo, &uOldRangeStartValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
							return ErrTrap(TTOErr);
						pState->uCurrentInOffset += sizeof(uint16);
			        	if (ReadWord(pState->pInputBufferInfo, &uOldRangeEndValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
							return ErrTrap(TTOErr);
						pState->uCurrentInOffset += sizeof(uint16);
			        	if (ReadWord(pState->pInputBufferInfo, &uValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
							return ErrTrap(TTOErr);  /* eat up the StartCoverageIndex value */
						pState->uCurrentInOffset += sizeof(uint16);

						uNewRangeStartValue = uNewRangeEndValue = 0;

						if (uOldRangeEndValue >= usGlyphListCount ||
							uOldRangeStartValue >= usGlyphListCount ||
							uOldRangeEndValue < uOldRangeStartValue)  /* make sure this makes sense */
							continue;  /* just go on to the next one */
						for (uValue = uOldRangeStartValue; uValue <= uOldRangeEndValue; ++uValue, ++uOldCoverageCount)
						{
							if (puchKeepGlyphList[uValue] == 0)
								SetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, uOldCoverageCount, 0);
							else  	
								SetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, uOldCoverageCount, 1);
						}
			        	for (j = 0; uOldRangeStartValue + j <= uOldRangeEndValue; ++j)  /* the first glyph is null */
						{
			        		if (puchKeepGlyphList[uOldRangeStartValue + j])
							{
								GetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, (uint16) (uOldRangeRecordIndex + j), &usBitValue);
								if (usBitValue == 1) 
			        			{
			        				uNewRangeStartValue = uOldRangeStartValue + j;
									break;
								}
								/* check to see if this table is referenced by more than one table. If so, warn user */
								if (pTableReference->cReferenceCount > 1)
									fWarn = TRUE;
							}
							if (uOldRangeStartValue + j == uOldRangeEndValue)
								break;
						}
						for (k = uOldRangeEndValue - uOldRangeStartValue;  uOldRangeStartValue + k >= uOldRangeStartValue; --k)
						{
			        		if (puchKeepGlyphList[uOldRangeStartValue + k])
							{
								GetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, (uint16) (uOldRangeRecordIndex + k), &usBitValue);
								if (usBitValue == 1)
			        			{
									uNewRangeEndValue = uOldRangeStartValue + k; /* translate */
									break;
								}
								/* check to see if this table is referenced by more than one table. If so, warn user */
								if (pTableReference->cReferenceCount > 1)
									fWarn = TRUE;
							}
							if (k == j) /* we've run up against our start range */
							{
								fWriteData = FALSE;
								break;
							}
						}
						if (fWriteElement && fWriteData) /* need to see if we have any holes that will need extra ranges */
						{
							for (m=0, l=0 ; ; )  /* make sure we have a contiguous range */
							{
								GetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, (uint16) (uOldRangeRecordIndex + j + l), &usBitValue);
								if ((usBitValue == 0 && (puchKeepGlyphList[uOldRangeStartValue+j + l])) ||   /* if it is to be deleted, this range will compress */
									(j + l > k)) /* need to write a range and start a new one */
								{ 
						    		if (pState->OutputBuffer && (pState->uCurrentOutOffset + (sizeof(uint16) * 2) >= pState->cBufferBytes)) 
						    			/* Internal. Attempt to write past end of output buffer - CoverageFormat2 Split",0, TTOErr);  */
										return ErrTrap(TTOErr);
					  				WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uNewRangeStartValue);
					 				pState->uCurrentOutOffset += sizeof(uint16);
									uNewRangeEndValue = uOldRangeStartValue + j + l-1;
					  				WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uNewRangeEndValue);
					 				pState->uCurrentOutOffset += sizeof(uint16);	 
					  				WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uNewRangeRecordIndex);
					 				pState->uCurrentOutOffset += sizeof(uint16);
									uTableDataWritten = 1;
									++uNewRangeCount;  /* we wrote this range */
									uNewRangeRecordIndex += (uNewRangeEndValue-uNewRangeStartValue+1);	/* increment it by the change */
									m = l+1;  /* save the place of the last good one */
									/* now find the next range */
									while (j + m <= k)
									{
										GetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, (uint16) (uOldRangeRecordIndex + j + m), &usBitValue);
										if (usBitValue == 1)
										{
											uNewRangeStartValue = uOldRangeStartValue + j + m;
											break;
										}
										else
											++m;
									}
									if (j + m > k)	   /* we're done with ranges */
										break;
									l = m; /* start here for next range */	
									/* check to see if this table is referenced by more than one table. If so, warn user */
									if (pTableReference->cReferenceCount > 1)
										fWarn = TRUE; /* coverage glyph isn't deleted, but a referencing table element is */
								}
								else
								{
									++l;
								}
							}
						/* need to do some special checking for SingleSubstFormat1 Tables refering to this coverage */

							for (uOldGlyphIDValue = uOldRangeStartValue+j, l=0; uOldGlyphIDValue + l <= uOldRangeStartValue + k; ++ l)
							{
								GetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, (uint16) (uOldRangeRecordIndex + j + l), &usBitValue);
								if ((usBitValue == 1)/* && pState->fPass2 */) 
				        		{
									for (m = 0; m < pTableReference->cReferenceCount; ++m)
									{
									PTABLEREFERENCE pLocalTableReference;
								  
										if (pTableReference->Reference[m].uOldSingleSubstFormat1DeltaValue == 0)  /* we don't have to deal with this */
											continue;
										pLocalTableReference = GetTTOTableReference(&(pState->keeper), pTableReference->Reference[m].iTableIndex);
										if (pLocalTableReference == NULL || pLocalTableReference->fDelTable == TRUE)
											continue;
										if (uOldGlyphIDValue + l + pTableReference->Reference[m].uOldSingleSubstFormat1DeltaValue >= usGlyphListCount)
											pLocalTableReference->fDelTable = TRUE; /* delete the SingleSubstFormat1 table */
										else
										{
											if (pTableReference->Reference[m].uNewSingleSubstFormat1DeltaValue == 0)  /* we don't have to set this */
											{
												if (puchKeepGlyphList[uOldGlyphIDValue + l + pTableReference->Reference[m].uOldSingleSubstFormat1DeltaValue]) /* is the mapped glyph still available ? */
													pTableReference->Reference[m].uNewSingleSubstFormat1DeltaValue = pTableReference->Reference[m].uOldSingleSubstFormat1DeltaValue;
												else /* uh oh, this is a bad table */
												{
													/*  "Must delete %s table referencing Coverage Table %s, as new Glyph Indices do not work with DeltaGlyphID", SZSingleSubstFormat1, szTableName);
													Warning(szErrorBuf, 0) */
													pLocalTableReference->fDelTable = TRUE; /* delete the SingleSubstFormat1 table */
												}	
												continue;
											}
											if (puchKeepGlyphList[uOldGlyphIDValue + l + pTableReference->Reference[m].uOldSingleSubstFormat1DeltaValue])
											{
												/*  "Must delete %s table referencing Coverage Table %s, as new Glyph Indices do not work with DeltaGlyphID", SZSingleSubstFormat1, szTableName);
												Warning(szErrorBuf, 0);	*/
												pLocalTableReference->fDelTable = TRUE; /* delete the SingleSubstFormat1 table */
											}
										}
									}
								}
							}
						}
						/* set these for next go-around */
						uOldRangeRecordIndex = uOldCoverageCount;
						fWriteData = TRUE;  
					}

					/* now fix up things so it appears we did one element at a time */
	     			pStruct->pCurrElement = pStruct->pCurrElement->pNext;
					if (pStruct->pCurrElement == NULL) /* oy */
						/* fatal_err("Lost in CoverageFormat2 RangeRecord element 3"); */
						return ErrTrap(TTOErr);
	     			pStruct->iElementIndex+=1;

					/* now set up to output the NewRangeCount */
					if (fWriteElement && fWriteData)
					{
					/* set up for later writing out the count and count checking */
						pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uValue = uNewRangeCount;
						pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uFileOffset = sizeof(uint16);
						pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uBaseOffset = pState->uOutBaseOffset;
						pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].cMinCount = TTODeCodeLimitCalc(pState, pStruct->pCurrElement->pMinCalc);
					}
					else
						pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uFileOffset = INVALID_FILE_OFFSET;
					
					if (fWarn && pState->fPass2)
					{
						/*  "Shared CoverageFormat2 table %d (%s) modified by referencing table. Will affect any tables that reference it.", pStruct->iTableIndex, szTableName);
						Warning(szErrorBuf, 0);	*/
				
					}
				}
			}
			if (!fAlreadyWritten)
			{
				if (fWriteElement && fWriteData) 
				{
		    		if (pState->OutputBuffer && (pState->uCurrentOutOffset >= pState->cBufferBytes)) 
		    			/* Internal. Attempt to write past end of output buffer.",0, TTOErr); */
						return ErrTrap(TTOErr);
		  			WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uValue);
					pState->uCurrentOutOffset += sizeof(uint16);
					if (uType != ETCount)
						uTableDataWritten = 1;
				}
				else if (fDelNone)  /* we aren't allowed NOT to write this */
				{
					pTableReference->fDelTable = TRUE;
				}
			}
         	break;
		case ETGSUBLookupIndex:
		case ETGSUBFeatureIndex:
		case ETGPOSLookupIndex:
		case ETGPOSFeatureIndex:
	      	if (ReadWord( pState->pInputBufferInfo, &uValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
				return ErrTrap(TTOErr);
			pState->uCurrentInOffset += sizeof(uint16);
			/* now, see if we need to update the coverage value */
			lValue = uValue = TTOIndexRemap(uType, uValue, pState->pIndexRemapArray);
			fWriteData = TRUE;
			if ((uValue == (uint16) INVALID_INDEX) && pCurrElement->pMinCalc && TTODeCodeLimitCalc(pState, pCurrElement->pMinCalc) >= 0)/* not valid */
			{
				fWriteData = FALSE;
				if ((pState->iStructStackIndex == 0) && !(pCurrElement->uType & ETArray))  /* this is a table */
				{
					pTableReference->fDelTable = TRUE;
				}
			}
			if (fWriteElement && fWriteData)
			{
	    		if (pState->OutputBuffer && (pState->uCurrentOutOffset >= pState->cBufferBytes)) 
	    			/* Internal. Attempt to write past end of output buffer.",0, TTOErr);  */
					return ErrTrap(TTOErr);
	  			WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uValue);
				pState->uCurrentOutOffset += sizeof(uint16);
				uTableDataWritten = 1;
			}
			else if (fDelNone)  /* we aren't allowed NOT to write this */
			{
				pTableReference->fDelTable = TRUE;
			}
			break;
		case ETTableOffset:
        	if (ReadWord( pState->pInputBufferInfo, &uValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
				return ErrTrap(TTOErr);					
			pState->uCurrentInOffset += sizeof(uint16);
			uOffset = 0;
			lValue = uValue;
			uNewSingleSubstFormat1DeltaValue = 0;
			if (lValue != 0)	/* it's a null offset, don't need to do anything */
			{
				uTableOffset = uOffset = (uint16) lValue + pState->uInBaseOffset;  /* get the real offset for this thing */
				/* check if it's already there, may be referenced twice */
				if (GetSymbol(pState->pTTOSymbolTable, NULL, uTableOffset, &ttoSymbolData) == SymErr) /* symbol not found - good */
				{   
					if (pState->fPass2)  
					{
						/*  "Internal. Unknown Symbol %s at offset %#04x", szOffsetTableName, pState->uCurrentInOffset); 
						return Error(szErrorBuf,0,TTOErr);  */
						return ErrTrap(TTOErr);
					} 
					TTOInitTTOSymbolData(&ttoSymbolData);
					ttoSymbolData.iStructureIndex = pCurrElement->iStructureIndex; /* save structureIndex in SymbolData structure */
					for (i = 0,pCurrParam = pCurrElement->pParamList; i < MaxParameterCount && pCurrParam != NULL; ++i, pCurrParam = pCurrParam->pNext)    /* save any parameter values that need to be passed to the table */
					{
						if (TTOGetElementValue(pState, pCurrParam->iElementIndex, pCurrParam->uSymbElementType, &(ttoSymbolData.Param[i].lValue),&(ttoSymbolData.Param[i].iTableIndex), 
							&(ttoSymbolData.Param[i].uInOffset), &(ttoSymbolData.Param[i].ArrayCountReference)) == TTOErr)
							return ErrTrap(TTOErr);	
					}
					if (pState->SpecialTable & TableFlagSingleSubstFormat1)  /* if we need to pass the coverage table a special value */
					{
			        	if (ReadWord( pState->pInputBufferInfo, &uValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
							return ErrTrap(TTOErr);
						/* don't increment the pointer for later processing */
					  	TableReference.Reference[0].uOldSingleSubstFormat1DeltaValue = uValue;
					}
					else
						TableReference.Reference[0].uOldSingleSubstFormat1DeltaValue = 0;

					TableReference.fDelTable = FALSE;
					TableReference.cCount = 0;
					TableReference.pBitFlags = NULL;	/* will be set inside AddTTOTableReference Call */
					TableReference.cAllocedBitFlags = 0;  	/* will be set inside AddTTOTableReference Call */
					TableReference.ulDefaultBitFlag = 0; 	/* will be set inside AddTTOTableReference Call */
					TableReference.cReferenceCount = 1;
					TableReference.Reference[0].iTableIndex = pState->ttoSymbolData.iTableIndex;  /* the index of the current table */
					TableReference.Reference[0].uInOffset = pState->uCurrentInOffset;
					TableReference.Reference[0].uFileOffset = pState->uCurrentOutOffset - pState->uOutBaseOffset;  /* where this offset is written, relative to the table */
					TableReference.Reference[0].uOffsetValue = 0; /* not available yet */
					TableReference.Reference[0].uBaseOffset = pState->uOutBaseOffset;  /* base of table where offset is written */
					TableReference.Reference[0].fDelIfDel = (fNOTNULL && (!(pCurrElement->uType & ETArray)) && (pState->iStructStackIndex == 0)); /* delete referencing table */
					TableReference.Reference[0].pBitFlags = NULL;	/* will be set inside AddTTOTableReference Call */
					TableReference.Reference[0].cAllocedBitFlags = 0;  	/* will be set inside AddTTOTableReference Call */
					TableReference.Reference[0].fFlag = 0; 	/* will be set inside AddTTOTableReference Call */
					TableReference.Reference[0].uNewSingleSubstFormat1DeltaValue = 0;
					ttoSymbolData.iTableIndex = AddTTOTableReference(&(pState->keeper), &TableReference, ULONG_MAX);
					if (AddSymbol(pState->pTTOSymbolTable, NULL, uTableOffset, &(ttoSymbolData)) != SymNoErr)    /* create the symbol for this table */
					{
						/*  "Out of Memory or other error Defining Offset Table Label \'%s\'", szOffsetTableName);
						return Error(szErrorBuf, 0, TTOErr);  */
						return ErrTrap(TTOErr);
					}
				}
				else if (!pState->fPass2)  /* Found symbol - check that all the stuff aligns */
				{  
					if (! TTOIsMember(pState->pStructureList, ttoSymbolData.iStructureIndex,pCurrElement->iStructureIndex))
					{
						/*  "Structure type mismatch between structure element and structure label at offset %#04x", pState->uCurrentInOffset);
						return Error(szErrorBuf, 0, TTOErr);  */
						return ErrTrap(TTOErr);
					}	
				   /* check that offset value not already set. */
					if (*(ttoSymbolData.szTableType) != '\0') /* if this has been set already, negative offset ! */
					{
						/*  "Internal. Offset %#04x referenced after definition.", pState->uCurrentInOffset);
						return Error(szErrorBuf, 0, TTOErr);  */
						return ErrTrap(TTOErr);
					}	
				   /* compare parameter values */ 
					for (i = 0,pCurrParam = pCurrElement->pParamList; i < MaxParameterCount && pCurrParam != NULL; ++i, pCurrParam = pCurrParam->pNext)    /* save any parameter values that need to be passed to the table */
					{
						if (TTOGetElementValue(pState, pCurrParam->iElementIndex, pCurrParam->uSymbElementType, &lParamValue, &iTableIndex, NULL, NULL) == TTOErr)
							return ErrTrap(TTOErr);	
						if (ttoSymbolData.Param[i].lValue != lParamValue)
						{  
							/* "Parameter %d value does not match other offset label at offset %#04x. Expecting %ld, found %ld.",i+1,pState->uCurrentInOffset, ttoSymbolData.Param[i].lValue, lParamValue);
							return Error( szErrorBuf, 0, TTOErr);  */
							return ErrTrap(TTOErr);
						} 
					}
					if (pState->SpecialTable & TableFlagSingleSubstFormat1)  /* if we need to pass the coverage table a special value */
					{
			        	if (ReadWord( pState->pInputBufferInfo, &uValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
							return ErrTrap(TTOErr);
						/* leave the pointer alone for later processing */
					  	Reference.uOldSingleSubstFormat1DeltaValue = uValue;
					}
					else
						Reference.uOldSingleSubstFormat1DeltaValue = 0;

					Reference.iTableIndex = pState->ttoSymbolData.iTableIndex;  /* the index of the current table */
					Reference.uInOffset = pState->uCurrentInOffset;	/* uniquely Identify this reference */
					Reference.uFileOffset = pState->uCurrentOutOffset - pState->uOutBaseOffset;  /* where this offset is written, relative to the table */
					Reference.uOffsetValue = 0;
					Reference.uBaseOffset = pState->uOutBaseOffset;  /* base of table where offset is written */
					Reference.fDelIfDel = (fNOTNULL && (!(pCurrElement->uType & ETArray)) && (pState->iStructStackIndex == 0));	 /* delete this table if offset is deleted? */
					Reference.uNewSingleSubstFormat1DeltaValue = 0;
					AddTTOTableReferenceReference(&(pState->keeper), ttoSymbolData.iTableIndex, &Reference);
				}
				else /* Pass2, we found the symbol. need to get it's offset value */
				{
				PTABLEREFERENCE pLocalTableReference;

					pLocalTableReference = GetTTOTableReference(&(pState->keeper), ttoSymbolData.iTableIndex);
					if (pLocalTableReference == NULL)
						/* fatal_err("No TableReference created for Offset."); */
						return ErrTrap(TTOErr);
					if (pLocalTableReference->fDelTable == TRUE)  /* this referenced table is to be deleted! */
					{	
						if (fDelNone) /* we aren't supposed to delete this element, so delete the table */
						{
							pTableReference->fDelTable = TRUE;
							fWriteData = FALSE ;
						}
						else if (fNOTNULL)
							fWriteData = FALSE;	 /* can't write it out as a NULL, skip it */
						else
							uOffset = 0;  /* need to write out a NULL */
					}
					for (i = 0; i < pLocalTableReference->cReferenceCount; ++i)
					{	/* need to update the reference record */
						if ((pLocalTableReference->Reference[i].iTableIndex == pState->ttoSymbolData.iTableIndex) &&  /* if we're looking at the one we're referencing */
							(pLocalTableReference->Reference[i].uInOffset == pState->uCurrentInOffset) ) /* we have the exact reference */
						{
							if (!fWriteElement || !fWriteData || pLocalTableReference->fDelTable == TRUE)	 /* if we aren't writing the offset, we need to delete this reference */
							{
						    	pLocalTableReference->Reference[i].iTableIndex = INVALID_INDEX;  /* delete that reference */
						    }
						    else 
						    {
							    if (pLocalTableReference->Reference[i].uOffsetValue == 0)
								{
									/*  "Table \"%s\" does not exist.", szOffsetTableName);
									return Error(szErrorBuf, 0, TTOErr);  */
									return ErrTrap(TTOErr);
								}
								uOffset = pLocalTableReference->Reference[i].uOffsetValue;
								pLocalTableReference->Reference[i].uFileOffset = pState->uCurrentOutOffset - pState->uOutBaseOffset;  /* where this offset is written, relative to the table */
							 	pLocalTableReference->Reference[i].uBaseOffset = pState->uOutBaseOffset;
								/* need to update the DeltaGlyphID value if this is a SingleSubstFormat1 table */
			
				 				if (pState->SpecialTable & TableFlagSingleSubstFormat1)
								{
			  						if (pLocalTableReference->Reference[i].uNewSingleSubstFormat1DeltaValue == 0) /* didn't get set, error in glyph list */
									{
										/*  "Must delete %s table, as new Glyph Indices in Coverage do not work with DeltaGlyphID", szTableName);
										Warning(szErrorBuf, 0);	 */
										pTableReference->fDelTable = TRUE; /* delete the SingleSubstFormat1 table */
									}
									else
									{
										uNewSingleSubstFormat1DeltaValue = pLocalTableReference->Reference[i].uNewSingleSubstFormat1DeltaValue;
									}
								}
							}
						}
					}
					/* Also need to update the parameter record */
					for (i = 0,pCurrParam = pCurrElement->pParamList; i < MaxParameterCount && pCurrParam != NULL; ++i, pCurrParam = pCurrParam->pNext)    /* save any parameter values that need to be passed to the table */
					{
						if (TTOGetElementValue(pState, pCurrParam->iElementIndex, pCurrParam->uSymbElementType, &lParamValue, NULL, NULL, &(ttoSymbolData.Param[i].ArrayCountReference)) == TTOErr)
							return ErrTrap(TTOErr);	
					}
					ModifySymbol(pState->pTTOSymbolTable, NULL, uTableOffset, &ttoSymbolData);
				}
			}
			if (pStruct->iCountTableReferenceIndex > INVALID_INDEX)  /* this array count depends on a CoverageCount or ClassCount function */
			{
				if (!fWriteElement || !fWriteData)  /* need to set Coverage count */
					SetTTOReferenceBitFlag(&(pState->keeper), pStruct->iCountTableReferenceIndex, uInOffset, (uint16) (pStruct->cRecordCount - pStruct->cArrayCount), 0);
			}
			/* this will be updated later when actual table is written */
			if (fWriteElement && fWriteData)
			{
	    		if (pState->OutputBuffer && (pState->uCurrentOutOffset >= pState->cBufferBytes)) 
	    			/* Internal. Attempt to write past end of output buffer.",0, TTOErr); */
					return ErrTrap(TTOErr);
				WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, (uint16) uOffset);
				pState->uCurrentOutOffset += sizeof(uint16); 
				if (uOffset != 0)
					uTableDataWritten = 1;
			}
			else if (fNOTNULL && (pState->iStructStackIndex > 1))
				pStruct->fWriteRecord = FALSE;	/* this offset went bad, need to not write the entire record */
			if (uNewSingleSubstFormat1DeltaValue != 0) /* we have something to say */
			{							        	
				if (ReadWord( pState->pInputBufferInfo, &uValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
					return ErrTrap(TTOErr);	/* eat the oldDeltaGlyphID value */
				pState->uCurrentInOffset += sizeof(uint16);
				/* march ahead to process this field */
				WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uNewSingleSubstFormat1DeltaValue);
				pState->uCurrentOutOffset += sizeof(uint16); 
     			
     			pStruct->pCurrElement = pStruct->pCurrElement->pNext;
				if (pStruct->pCurrElement == NULL) /* oy */
					/* fatal_err("Lost in SingleSubstFormat1 element 2"); */
					return ErrTrap(TTOErr);
     			pStruct->iElementIndex+=1;
			}
			lValue = 0;  /* don't need to keep the offset value in the pValueList array */  
        	break;
		case ETGlyphID: 
        	if (ReadWord( pState->pInputBufferInfo, &uOldGlyphIDValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
							return ErrTrap(TTOErr);
			pState->uCurrentInOffset += sizeof(uint16);
       		lValue = uValue = uOldGlyphIDValue;
			fWriteData = TRUE;
			/* Sync up Coverage tables with arrays that depend upon them */
		 	if (pState->SpecialTable & TableFlagCoverageFormat1Count)
			{
				if ((uOldGlyphIDValue < usGlyphListCount) && puchKeepGlyphList[uOldGlyphIDValue])
				{
					GetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, (uint16) (pStruct->cRecordCount - pStruct->cArrayCount), &usBitValue);
					if ((usBitValue == 1) || (!pState->fPass2)) /* it's ok, we're syncronised, or this is pass1 */
						uValue = 1;
					else
					{
					/*	GetTTO	 */
						fWriteData = FALSE;
						uValue = 0; /* turn off and inc coverage count */
						if ((pTableReference->cReferenceCount > 1) && (pState->fPass2))
						{
							/*  "Shared CoverageFormat1 table %d (%s) modified by referencing table. Will affect any tables that reference it.", pStruct->iTableIndex, szTableName);
							Warning(szErrorBuf, 0);	*/
						}
					}
				}
				else
				{
					fWriteData = FALSE;
					uValue = 0;
				}
 				SetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, (uint16) (pStruct->cRecordCount - pStruct->cArrayCount), uValue);  	
				uValue = uOldGlyphIDValue; /* set new value */
				/* need to do some special checking for SingleSubstFormat1 Tables refering to this coverage */
				if (fWriteData && fWriteElement && puchKeepGlyphList[uOldGlyphIDValue])
				{
					for (i = 0; i < pTableReference->cReferenceCount; ++i)
					{
					PTABLEREFERENCE pLocalTableReference;

						if (pTableReference->Reference[i].uOldSingleSubstFormat1DeltaValue == 0)  /* we don't have to deal with this */
							continue;
						pLocalTableReference = GetTTOTableReference(&(pState->keeper), pTableReference->Reference[i].iTableIndex);
						if (pLocalTableReference == NULL || pLocalTableReference->fDelTable == TRUE)
							continue;
						if (uOldGlyphIDValue + pTableReference->Reference[i].uOldSingleSubstFormat1DeltaValue >= usGlyphListCount)
							pLocalTableReference->fDelTable = TRUE; /* delete the SingleSubstFormat1 table */
						else
						{
							if (pTableReference->Reference[i].uNewSingleSubstFormat1DeltaValue == 0)  /* we don't have to set this */
							{
								if (puchKeepGlyphList[uOldGlyphIDValue + pTableReference->Reference[i].uOldSingleSubstFormat1DeltaValue]) /* is the mapped glyph still available ? */
									pTableReference->Reference[i].uNewSingleSubstFormat1DeltaValue = 
										pTableReference->Reference[i].uOldSingleSubstFormat1DeltaValue; 
								else /* uh oh, this is a bad table */
								{
									/*  "Must delete %s table referencing Coverage Table %s, as new Glyph Indices do not work with DeltaGlyphID", SZSingleSubstFormat1, szTableName);
									Warning(szErrorBuf, 0);	 */
									pLocalTableReference->fDelTable = TRUE; /* delete the SingleSubstFormat1 table */
								}	
								continue;
							}
							if (puchKeepGlyphList[uOldGlyphIDValue + pTableReference->Reference[i].uOldSingleSubstFormat1DeltaValue] == 0)
							{
								/*  "Must delete %s table referencing Coverage Table %s, as new Glyph Indices do not work with DeltaGlyphID", SZSingleSubstFormat1, szTableName);
								Warning(szErrorBuf, 0);	 */
								pLocalTableReference->fDelTable = TRUE; /* delete the SingleSubstFormat1 table */
							}
						}
					}
				} 
  			}
   			else if ((pState->SpecialTable & TableFlagClassDefFormat2Count) &&  /* similar to CoverageFormat2 */
	        		(pState->iStructStackIndex == 1))  /* We're in the record not the table */
	        
	        {	  /* need to process the whole structure right here, and move on */
			uint16 uOldRangeStartValue, uOldRangeEndValue;
			uint16 uNewRangeStartValue, uNewRangeEndValue;

	        	uOldRangeStartValue = uOldGlyphIDValue;
	        	if (ReadWord(pState->pInputBufferInfo, &uOldRangeEndValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
					return ErrTrap(TTOErr);
				pState->uCurrentInOffset += sizeof(uint16);
	  			
	        	if (ReadWord(pState->pInputBufferInfo, &uValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
					return ErrTrap(TTOErr);  /* get the Class value */
				pState->uCurrentInOffset += sizeof(uint16);
 
				uNewRangeStartValue = uNewRangeEndValue = 0;

				if (uOldRangeStartValue < usGlyphListCount &&
 					uOldRangeEndValue < usGlyphListCount &&
					uOldRangeStartValue <= uOldRangeEndValue)

				{
	        		while (uOldRangeStartValue <= uOldRangeEndValue)  /* the first glyph is null */
					{
	        			if (puchKeepGlyphList[uOldRangeStartValue])
						{
	        				uNewRangeStartValue = uOldRangeStartValue;
							break;
						}
						++uOldRangeStartValue;
					}
					while (uOldRangeEndValue >= uOldRangeStartValue)
					{
	        			if (puchKeepGlyphList[uOldRangeEndValue])
						{
							uNewRangeEndValue = uOldRangeEndValue; 
							break;
						}
						--uOldRangeEndValue;
					}


					if ((puchKeepGlyphList[uOldRangeStartValue]) == 0 || (puchKeepGlyphList[uOldRangeEndValue]) == 0)
						fWriteData = FALSE;
				}
				else
					fWriteData = FALSE;	   /*error on input. Don't perpetuate */

				if (fWriteElement && fWriteData)
				{
		    		if (pState->OutputBuffer && (pState->uCurrentOutOffset + sizeof(uint16) >= pState->cBufferBytes)) 
		    			/* Internal. Attempt to write past end of output buffer.",0, TTOErr); */
						return ErrTrap(TTOErr);
					SetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, uValue, 1);  /* set the class value on */
	  				WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uNewRangeStartValue);
	 				pState->uCurrentOutOffset += sizeof(uint16);
	  				WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uNewRangeEndValue);
	 				pState->uCurrentOutOffset += sizeof(uint16);
					pStruct->fWriteRecord = TRUE;
					uTableDataWritten = 1;
				}
				else
				{
					pStruct->fWriteRecord = FALSE;	/* turn off by default */
				}

				SetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, 0, 1);  /* set the class 0 value on */

				/* we'll write the Class value below */
				GetTTOClassValue(&(pState->keeper), pStruct->iTableIndex, uValue, &uValue);  /* compress list of classes */
				/* now fix up things so it appears we did one element at a time */
     			pStruct->pCurrElement = pStruct->pCurrElement->pNext;
				if (pStruct->pCurrElement == NULL) /* oy */
					/* fatal_err("Lost in ClassDefFormat2 RangeRecord element 2"); */
					return ErrTrap(TTOErr);
     			pStruct->pCurrElement = pStruct->pCurrElement->pNext;
				if (pStruct->pCurrElement == NULL) /* oy */
					/* fatal_err("Lost in ClassDefFormat2 RangeRecord element 3");	*/
					return ErrTrap(TTOErr);
     			pStruct->iElementIndex+=2;
			}
  			else if ((pState->SpecialTable & TableFlagClassDefFormat1Count) &&  /* 2nd element of ClassDefFormat1 structure */
	        		(pStruct->iElementIndex == 1))  
	        
	        {	  /* need to process the rest of structure right here, and move on */
			uint16 uOldStartGlyphIDValue, uNewStartGlyphIDValue;
			uint16 uOldGlyphCountValue, uNewGlyphCountValue;

	        	uOldStartGlyphIDValue = uOldGlyphIDValue;
	        	if (ReadWord(pState->pInputBufferInfo, &uOldGlyphCountValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
					return ErrTrap(TTOErr);  
				pState->uCurrentInOffset+= sizeof(uint16);
				uNewStartGlyphIDValue =  0;
				uNewGlyphCountValue = uOldGlyphCountValue;

	        	while (uNewGlyphCountValue > 0) 
				{
	        		if (puchKeepGlyphList[uOldStartGlyphIDValue])
					{
	        			uNewStartGlyphIDValue = uOldStartGlyphIDValue;
						break;
					}
					++uOldStartGlyphIDValue;
					--uNewGlyphCountValue;
				}
				if (uNewGlyphCountValue == 0)	/* There is nothing here ! */
				{
					fWriteData = FALSE;
					pTableReference->fDelTable = TRUE;
				}
				if (fWriteData && fWriteElement)
				{
		    		if (pState->OutputBuffer && (pState->uCurrentOutOffset + sizeof(uint16) >= pState->cBufferBytes)) 
		    			/* Internal. Attempt to write past end of output buffer.",0, TTOErr); */
	  					return ErrTrap(TTOErr);
					WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uNewStartGlyphIDValue);
	 				pState->uCurrentOutOffset += sizeof(uint16);
	  				WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uNewGlyphCountValue);
	 				pState->uCurrentOutOffset += sizeof(uint16);
					uTableDataWritten = 1;
				}
     			pStruct->pCurrElement = pStruct->pCurrElement->pNext;
				if (pStruct->pCurrElement == NULL) /* oy */
					/* fatal_err("Lost in ClassDefFormat1 element 3"); */
					return ErrTrap(TTOErr);

     			pStruct->iElementIndex+=1;

				pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uValue = uOldGlyphCountValue;
				pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uFileOffset = 2 * sizeof(uint16);
				pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uBaseOffset = pState->uOutBaseOffset;
				pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].cMinCount = TTODeCodeLimitCalc(pState, pStruct->pCurrElement->pMinCalc);
					
				pStruct->pCurrElement = pStruct->pCurrElement->pNext;
				if (pStruct->pCurrElement == NULL) /* oy */
					/* fatal_err("Lost in ClassDefFormat1  element 4"); */
					return ErrTrap(TTOErr);

     			pStruct->iElementIndex+=1;
			/* now deal with the array of classes */
				for (i = 0; i < uOldGlyphCountValue; ++i)
				{
		        	if (ReadWord(pState->pInputBufferInfo, &uValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
						return ErrTrap(TTOErr); 	  /* read class value */
					pState->uCurrentInOffset += sizeof(uint16);
					if (uOldGlyphIDValue+i < uOldStartGlyphIDValue) /* if we haven't gotten to beginning of new range yet */
					{
						--(pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uValue);
						continue;
					}
					if (fWriteData && fWriteElement)
					{
						if (puchKeepGlyphList[uOldGlyphIDValue+i])
						{
				    		if (pState->OutputBuffer && (pState->uCurrentOutOffset >= pState->cBufferBytes)) 
				    			/* Internal. Attempt to write past end of output buffer.",0, TTOErr); */
								return ErrTrap(TTOErr);
							SetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, uValue, 1);
							GetTTOClassValue(&(pState->keeper), pStruct->iTableIndex, uValue, &uValue);  /* compress list of classes */
			  				WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uValue);
			 				pState->uCurrentOutOffset += sizeof(uint16);
							uTableDataWritten = 1;
						}
						else   /* there is a gap in the glyph Index range, shorten table */
						{
							--(pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uValue);
						}
					}
					else
						--(pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uValue);

				}
				SetTTOBitFlag(&(pState->keeper), pStruct->iTableIndex, 0, 1);  /* set the class 0 value on */
				fAlreadyWritten = TRUE; /* we've already written everything out, don't do more */
			}
  			else if (pState->SpecialTable & TableFlagBaseCoordFormat2)  
 			{
				if (puchKeepGlyphList[uOldGlyphIDValue] == 0) /* oops, this base glyph is to be deleted */
				{
					/* need to change to format 1 */
					if (fWriteElement && fWriteData)
					{
						if (!pState->fPass2)  /* only warn once */
						{
							/* "Glyph Index %d deleted so changing %s to Format 1 at offset %#04x",uOldGlyphIDValue, SZBaseCoordFormat2,pState->uInBaseOffset);  
							Warning(szErrorBuf, 0);*/
						}
						/* need to write a Format 1 and leave it at that */
		  				WriteWordToBuffer(pState->OutputBuffer, pState->uOutBaseOffset, 1);
     				}
 					/* now fix things up to appear that we've read the next data */
	     			pStruct->pCurrElement = pStruct->pCurrElement->pNext;
					if (pStruct->pCurrElement == NULL) /* oy */
						/* fatal_err("Lost in BaseCoordFormat2"); */
						return ErrTrap(TTOErr);
	     			pStruct->iElementIndex+=1;
		        	
		        	if (ReadWord(pState->pInputBufferInfo, &uValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
						return ErrTrap(TTOErr); 	  /* read BaseCoordPoint value */
					pState->uCurrentInOffset+= sizeof(uint16);
					uTableDataWritten = 1;

					fAlreadyWritten = TRUE;	/* don't write anything below */
				} 
			}
			else if (pStruct->iCountTableReferenceIndex > INVALID_INDEX)  /* this array count depends on a CoverageCount or ClassCount function */
			{
				if (puchKeepGlyphList[uOldGlyphIDValue] == 0)  /* need to check if Coverage count is not 0 */
				{
					GetTTOBitFlag(&(pState->keeper), pStruct->iCountTableReferenceIndex, (uint16) (pStruct->cRecordCount - pStruct->cArrayCount), &usBitValue);
					if ((usBitValue == 0) && (pState->fPass2)) /* it's ok, we're syncronised */
						fWriteData = FALSE;
				}
				else /* need to set Coverage Count bit to 0 */
				{
					fWriteData = FALSE;
					SetTTOReferenceBitFlag(&(pState->keeper), pStruct->iCountTableReferenceIndex, uInOffset, (uint16) (pStruct->cRecordCount - pStruct->cArrayCount), 0);
				}
			}
			else if (puchKeepGlyphList[uOldGlyphIDValue] == 0) /* this is not a special case */
			{
				fWriteData = FALSE;
				if (!(pCurrElement->uType & ETArray))	 /* a glyph all by itself */
					if (pState->iStructStackIndex == 0)	/* if it's part of a table */
						pTableReference->fDelTable = TRUE;
					else
						pStruct->fWriteRecord = FALSE;
			} 
			if (!fAlreadyWritten)
			{
				if (fWriteData && fWriteElement)
				{
		    		if (pState->OutputBuffer && (pState->uCurrentOutOffset >= pState->cBufferBytes)) 
	    				/* Internal. Attempt to write past end of output buffer.",0, TTOErr); */
						return ErrTrap(TTOErr);
	  				WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uValue);
	 				pState->uCurrentOutOffset += sizeof(uint16);
					uTableDataWritten = 1;
				}
				else if (fDelNone)
					pTableReference->fDelTable = TRUE;  /* delete this table and all that it references */
			}
        	break;
		case ETPackedInt2:   
		case ETPackedInt4:
		case ETPackedInt8:
        	if (ReadWord( pState->pInputBufferInfo, &uValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
				return ErrTrap(TTOErr); 
        	pState->uCurrentInOffset += sizeof(uint16);
			lValue = uValue;
 			if (fWriteElement && fWriteData)
			{
	    		if (pState->OutputBuffer && (pState->uCurrentOutOffset >= pState->cBufferBytes)) 
	    			/* Internal. Attempt to write past end of output buffer.",0, TTOErr); */
					return ErrTrap(TTOErr);
				WriteWordToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, uValue);
				pState->uCurrentOutOffset += sizeof(uint16);
				uTableDataWritten = 1;
			}
			else if (fDelNone)
				pTableReference->fDelTable = TRUE;  /* delete this table and all that it references */
			if (uType == ETPackedInt2)
				PackedCount = 7;
			else if (uType == ETPackedInt4)
				PackedCount = 3;
			else if (uType == ETPackedInt8)
				PackedCount = 1;
			if (pStruct->cArrayCount > PackedCount)
				pStruct->cArrayCount -= PackedCount;
			else
				pStruct->cArrayCount = 1; /* we finished it off - last one will be decremented below */
			break;
		case ETint32:
		case ETfixed32:
		case ETTag: 
			if (ReadLong( pState->pInputBufferInfo, &lValue, pState->ulInputTTOOffset + pState->uCurrentInOffset) != NO_ERROR) 
				return ErrTrap(TTOErr);
			pState->uCurrentInOffset += sizeof(int32);
			if (fWriteElement && fWriteData)
			{
	    		if (pState->OutputBuffer && (pState->uCurrentOutOffset + sizeof(uint16) >= pState->cBufferBytes)) 
	    			/* Internal. Attempt to write past end of output buffer.",0, TTOErr); */
					return ErrTrap(TTOErr);
				WriteLongToBuffer(pState->OutputBuffer, pState->uCurrentOutOffset, lValue); 
				pState->uCurrentOutOffset += sizeof(uint32);
				if (uType != ETfixed32)	 /* if it's just a version number, it doesn't count */
					uTableDataWritten = 1;
			}
			else if (fDelNone)
				pTableReference->fDelTable = TRUE;  /* delete this table and all that it references */
			break;
		default: 
			/*  "Internal. Unknown Type of element at offset %#04x", pState->uCurrentInOffset);
			return Error(szErrorBuf, 0, TTOErr);   */
			return ErrTrap(TTOErr);
			break;
        }

		if (uType == ETTableOffset)     
 		  	pStruct->pValueList[pStruct->iElementIndex].iTableIndex = ttoSymbolData.iTableIndex;
		else
			pStruct->pValueList[pStruct->iElementIndex].iTableIndex = OffsetFunctionIndex(pState, pStruct);         
        
		pStruct->pValueList[pStruct->iElementIndex].lValue = lValue;

		if ((pStruct->pCurrElement->uType & ETArray) && (!fWriteElement || !fWriteData)) /* this element didn't get written, better decrement the count value */ 
		{
			--(pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uValue);
			if (pStruct->fTrackIndex != INVALID_INDEX)
			{
				pState->fIndexUnmapped = TTOIndexUnmap(pStruct->fTrackIndex,(uint16) (pStruct->cRecordCount - pStruct->cArrayCount),pState->pIndexRemapArray, pState->fIndexUnmapped);  /* remove this index as a possible choice */ 
			}
		}
  		--pStruct->cArrayCount;   /* we've processed one element, or one element of an array */    
	}
	
	/* Go to next element of structure. If Last Element, may need to pop the stack */   
	while (1)
	{ 
	    /* see if we need to update any array references */	     
	   	if ((pStruct->pCurrElement->uType & ETArray) && (pStruct->cArrayCount == 0))
		{
			if (pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uFileOffset != INVALID_FILE_OFFSET)
			{
				if (pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uValue <
					pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].cMinCount)  /* if we're not allowed to have a count this small */
				{
					if (pState->iStructStackIndex == 0) 
						pTableReference->fDelTable = TRUE;
					/* else we're in a record, take care of this in the array above */
				}
				else 
				{
					WriteWordToBuffer(pState->OutputBuffer,  
						(uint16) (pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uBaseOffset + pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uFileOffset), 
						 pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uValue);
	 			}
			}
 			if (++pStruct->iCurrArrayCountIndex >= MAXARRAYS) /* get ready for the next array */
 			{
 				/* "Too many arrays in table %s. Max is %d.", szTableName,MAXARRAYS); 
				return Error(szErrorBuf, 0, TTOErr);  */
				return ErrTrap(TTOErr);
			}
		}
		if (pStruct->pCurrElement->pNext == NULL)  /* last element, pop stack */
		{
			Mem_Free(pStruct->pValueList);
			pStruct->pValueList = NULL; 
			if (--(pState->iStructStackIndex) >= 0)  /* we were dealing with a Record, but it didn't get written */    
			{
				if ((!fWriteElement) || (!fWriteData) || (!pStruct->fWriteRecord )) /* this Record element didn't get written, better decrement the count value */ 
				{
					pStruct = &pState->aStructStack[pState->iStructStackIndex];  /* hoist the pointer */
					--(pStruct->ArrayCountReference[pStruct->iCurrArrayCountIndex].uValue);
					if (pStruct->fTrackIndex != INVALID_INDEX)
					{
						pState->fIndexUnmapped = TTOIndexUnmap(pStruct->fTrackIndex,(uint16) (pStruct->cRecordCount - pStruct->cArrayCount), pState->pIndexRemapArray, pState->fIndexUnmapped);  /* remove this index as a possible choice */ 
					}
 					pState->uCurrentOutOffset = pStruct->uBeforeRecordOffset;	  /* reset the output offset */
				}
				else
					pStruct = &pState->aStructStack[pState->iStructStackIndex];  /* hoist the pointer */

				if (--(pStruct->cArrayCount) != 0) /* we had a record and we processed it, decrement count */ 
					break; 
  				 /* else need to go around again to find an element we like */
				fWriteData = TRUE; /* for next level up on Struct stack */
				fWriteElement = TRUE; /* for next level up on Struct stack */
			}
			else /* we're completely done with this table */
			{
				if (pState->SpecialTable & TableFlagSyncCount)  /* check to see if we deleted an element that syncs with this. */
				{
					if (GetTTOBitFlagsCount(&(pState->keeper), pStruct->iTableIndex) == 0)
						pTableReference->fDelTable = TRUE;
				} 
				if (uTableDataWritten == 0)
					pTableReference->fDelTable = TRUE;	/* not enough to keep it around */
				break;
			}
	    }
	    else    /* more elements */
	    {
	    	if (pStruct->cArrayCount == 0)    /* done with this element */
	    	{
	     		pStruct->pCurrElement = pStruct->pCurrElement->pNext;
	     		++(pStruct->iElementIndex);
	     	}
	    	break; 
	    }
	} 
    return(uTableDataWritten);
} 
/* ---------------------------------------------------------------------- */ 
/* go down the list of structures in a class to find the one that matches the data */
/* then update the pState->ttoSymbolData structure with the structureIndex and structure name */
/* will need to read data out of the source file, and reset the file stream pointer */  
/* ---------------------------------------------------------------------- */ 

PRIVATE int16 TTOGetRealStructureIndex(PDATA_FILE_STATE pState, 
									  int16 iStructureIndex, 
									  PFFSYMBOL_DATA pffSymbolData)
{
PELEMENT_LIST pCurrElement; 
uint16 uIdentifier;
uint16 uIndex;
uint16 i;
int16 dummyValue;

	uIndex = pState->pStructureList->pStructureDef[iStructureIndex].iElementIndex;
	if (pState->pStructureList->pStructureDef[iStructureIndex].uSymbElementType == SymbElementTypeParameter)  /* $P */
	{  
		if (uIndex < 1 || uIndex > MaxParameterCount)  
		{
			/*  "Parameter index out of range for Class indentifier at offset %#04x", pState->uCurrentInOffset);
			return Error(szErrorBuf, 0, TTOErr);  */
			return ErrTrap(TTOErr);
		}	
		uIdentifier = (uint16) pState->ttoSymbolData.Param[uIndex - 1].lValue; 
	}
	else if (pState->pStructureList->pStructureDef[iStructureIndex].uSymbElementType == SymbElementTypeByte) /* $B */
	{  
		if (ReadWord( pState->pInputBufferInfo, &uIdentifier, pState->ulInputTTOOffset + pState->uCurrentInOffset+uIndex) != NO_ERROR) 
		{
			/* "Unable to determine which class member to use for offset %#04x - file error", pState->uCurrentInOffset); 
			return Error(szErrorBuf, 0, TTOErr);   */
			return ErrTrap(TTOErr);
		}
	}
    else 
    {
    	/*  "Unable to determine which member of a class to use for table at offset %#04x - Format File error for this CLASS.", pState->uCurrentInOffset);
    	return Error(szErrorBuf, 0, TTOErr);  */
		return ErrTrap(TTOErr); 
    }
  	
    for (i = 1, pCurrElement = pState->pStructureList->pStructureDef[iStructureIndex].pFirst; pCurrElement; pCurrElement = pCurrElement->pNext, ++i)
    {
    	if (i == uIdentifier)/* we found the actual member we want */   
    		break;
    }
    if (pCurrElement != NULL)
    {
     	pState->ttoSymbolData.iStructureIndex = pCurrElement->iStructureIndex; /* set to the structure index of the member structure */
	 	if (GetSymbolByFunction (pState->pFFSymbolTable, pState->ttoSymbolData.szTableType, &dummyValue, pffSymbolData, pState->ttoSymbolData.iStructureIndex, (pSymbolFunction)&TTOCompareFFSymbolIndex) == SymErr)
	    {
	    	/*  "Unable to determine the type for table at offset %#04x", pState->uCurrentInOffset);
	    	return Error(szErrorBuf, 0, TTOErr); */
			return ErrTrap(TTOErr);  
	    }
	 	return(TTONoErr);
	} 
	/*  "Unable to determine the type for table at offset %#04x", pState->uCurrentInOffset);
	return Error(szErrorBuf, 0, TTOErr); */
	return ErrTrap(TTOErr);  
}
/* ---------------------------------------------------------------------- */ 
/* process the Table Definition */
/* ---------------------------------------------------------------------- */ 
PRIVATE int16 TTOProcessTableDef(PDATA_FILE_STATE pState, 
								uint16 uOffset)
{
FFSYMBOL_DATA ffSymbolData; 
PSTRUCTSTACK_LIST pStruct;    /* pointer to structure in stack */
uint16 Reference = 0;
TABLEREFERENCE TableReference; 
PTABLEREFERENCE pTableReference; 
uint16 i;
uint16 FoundOne = FALSE;
int16 dummyValue;


 	if (GetSymbol(pState->pTTOSymbolTable, NULL, uOffset, &(pState->ttoSymbolData)) == SymErr) /* get the symbol for this offset */
 	{   
		if ((pState->uCurrentInOffset == 0) && (!pState->fPass2))  /* First table - need to create the symbol */
		{  
		/* will fill in ttoSymbolData structure */
		 	pState->ttoSymbolData.iStructureIndex = pState->pStructureList->iHeadIndex;
		 	if (GetSymbolByFunction (pState->pFFSymbolTable, pState->ttoSymbolData.szTableType, &dummyValue, &ffSymbolData, pState->ttoSymbolData.iStructureIndex,(pSymbolFunction) &TTOCompareFFSymbolIndex) == SymErr)
			{
				/*  "Unable to find structure definition for header at offset %#04x", pState->uCurrentInOffset);
				return Error(szErrorBuf, 0, TTOErr); */
				return ErrTrap(TTOErr); 
			}
			FoundOne = TRUE;	
			TableReference.fDelTable = FALSE;
			TableReference.cCount = 0;
			TableReference.pBitFlags = NULL;	/* will be set inside AddTTOTableReference Call */
			TableReference.cAllocedBitFlags = 0;  	/* will be set inside AddTTOTableReference Call */
			TableReference.ulDefaultBitFlag = 0; 	/* will be set inside AddTTOTableReference Call */
			TableReference.cReferenceCount = 0;
			TableReference.Reference[0].pBitFlags = NULL;	/* will be set inside AddTTOTableReference Call */
			TableReference.Reference[0].cAllocedBitFlags = 0;  	/* will be set inside AddTTOTableReference Call */
			TableReference.Reference[0].fFlag = 0; 	/* will be set inside AddTTOTableReference Call */
			pState->ttoSymbolData.iTableIndex = AddTTOTableReference(&(pState->keeper), &TableReference, ULONG_MAX);
		 	if (AddSymbol(pState->pTTOSymbolTable, NULL, uOffset, &pState->ttoSymbolData) == SymErr) 
		 		/* Out of Memory or other error while adding header symbol to TTO symbol table", 0, TTOErr); */
				return ErrTrap(TTOErr);
		}
 		else 
 		{
	 	 	/*  "Table \"%s\" not referenced. Data Misalignment?",szTableName);
	 	 	return Error(szErrorBuf,0, TTOErr);  */
			return ErrTrap(TTOErr);
	  	}
 	}
 	else  /* Symbol found */
 	{  
 		if (*(pState->ttoSymbolData.szTableType) == '\0') /* needs to be set */
 		{
 			if (GetSymbolByFunction(pState->pFFSymbolTable, pState->ttoSymbolData.szTableType, &dummyValue, &ffSymbolData, pState->ttoSymbolData.iStructureIndex, (pSymbolFunction)&TTOCompareFFSymbolIndex) == SymErr) 
 			{
 		     	/* "Invalid Structure Index %d for table at offset %#04x", pState->ttoSymbolData.iStructureIndex, pState->uCurrentInOffset); 
 		     	return Error(szErrorBuf, 0, TTOErr);  */
				return ErrTrap(TTOErr);
 			}
 		}
	 	else if (GetSymbol(pState->pFFSymbolTable, pState->ttoSymbolData.szTableType, 0, &ffSymbolData) == SymErr)  /* find the type of the symbol */
	 	{
	 	 	/*  "Unrecognized Table Type \"%s\" at offset %#04x.",pState->ttoSymbolData.szTableType, pState->uCurrentInOffset);
	 	 	return Error(szErrorBuf,0, TTOErr);  */
			return ErrTrap(TTOErr);
	 	} 
	 	if (pState->uCurrentInOffset == 0)
	 	{
	 		if (ffSymbolData.uSymbolType != StrucTypeHEAD)
	 			/* First Table must be type HEAD.", 0, TTOErr); */
				return ErrTrap(TTOErr);
	 		FoundOne = TRUE;	
	 	}
	 	else if ((ffSymbolData.uSymbolType != StrucTypeTABLE) && (ffSymbolData.uSymbolType != StrucTypeCLASS))
	 	{
	 	 	/*  "Table type must be TABLE or CLASS at offset %#04x", pState->uCurrentInOffset);
	 	 	return Error(szErrorBuf, 0, TTOErr);  */
			return ErrTrap(TTOErr);
	 	}
	}
	pState->uInBaseOffset = pState->uCurrentInOffset;  
	pState->uOutBaseOffset = pState->uCurrentOutOffset;  
	pState->iStructStackIndex = 0;
	pStruct = &(pState->aStructStack[0]);
    /* need to figure out the actual iStructureIndex if this is a class, then modify */  
    if (ffSymbolData.uSymbolType == StrucTypeCLASS)
    {                               /* fix up pState->ttoSymbolData to ready for modify */
    	while (ffSymbolData.uSymbolType == StrucTypeCLASS) /* for nested classes */
    		if (TTOGetRealStructureIndex(pState, ffSymbolData.iStructureIndex, &ffSymbolData) == TTOErr)
    			return ErrTrap(TTOErr); /* already reported */
    }
	pTableReference = GetTTOTableReference(&(pState->keeper), pState->ttoSymbolData.iTableIndex);
	if (pTableReference == NULL)
	{
		/* "No TableReference created for \"%s\" Table.",szTableName);
		fatal_err(szErrorBuf);	 */
		return ErrTrap(TTOErr);
	}

	if (pTableReference->fDelTable == FALSE)
	{
		for (i = 0; i < pTableReference->cReferenceCount; ++i)
		{
			if ((pTableReference->Reference[i].iTableIndex !=INVALID_INDEX) && (pTableReference->Reference[i].uFileOffset != INVALID_FILE_OFFSET))
			{
				FoundOne = TRUE;
				if (pTableReference->Reference[i].uOffsetValue + pTableReference->Reference[i].uBaseOffset 
					!= pState->uCurrentOutOffset) /* if things have shortened */
				{
					pTableReference->Reference[i].uOffsetValue = pState->uCurrentOutOffset - pTableReference->Reference[i].uBaseOffset;	/* save this relative offset */
					WriteWordToBuffer(pState->OutputBuffer,  (uint16) (pTableReference->Reference[i].uBaseOffset + pTableReference->Reference[i].uFileOffset), pTableReference->Reference[i].uOffsetValue);
				}
			}
		}
		if (!FoundOne)  /* There are no longer any references to this table */
		{
			pTableReference->fDelTable = TRUE;
		}
	}
	pStruct->iStructureIndex = pState->ttoSymbolData.iStructureIndex;  /* this is the structure we are working on */
    pStruct->iElementIndex = pStruct->cArrayCount = pStruct->cRecordCount = 0;
    pStruct->pValueList = NULL;
    pStruct->pCurrElement = NULL; 
	pStruct->iTableIndex = pState->ttoSymbolData.iTableIndex;
    pStruct->iCountTableReferenceIndex = INVALID_INDEX; 
	pStruct->fWriteElement = TRUE;
	pStruct->fWriteRecord = TRUE;
	pStruct->fTrackIndex = INVALID_INDEX;
 	pStruct->iCurrArrayCountIndex = 0;
	
	pState->SpecialTable = 0; 
	if (_stricmp(pState->ttoSymbolData.szTableType, SZCoverageFormat1) == 0) 
		pState->SpecialTable = TableFlagCoverageFormat1Count;
	else if (_stricmp(pState->ttoSymbolData.szTableType, SZCoverageFormat2) == 0) /* we know what this is. Have to set up some things */
		pState->SpecialTable = TableFlagCoverageFormat2Count;
 	else if (_stricmp(pState->ttoSymbolData.szTableType, SZClassDefFormat1) == 0)
 	{ 
		pState->SpecialTable = TableFlagClassDefFormat1Count;
		if (!pState->fPass2)
			SetTTOTableReferenceDefaultBitFlag(&(pState->keeper), pStruct->iTableIndex,0L);/* default is OFF not ON */
	}
 	else if (_stricmp(pState->ttoSymbolData.szTableType, SZClassDefFormat2) == 0)
	{
		pState->SpecialTable = TableFlagClassDefFormat2Count; 
		if (!pState->fPass2)
 			SetTTOTableReferenceDefaultBitFlag(&(pState->keeper), pStruct->iTableIndex,0L);
	}
	else if (_stricmp(pState->ttoSymbolData.szTableType, SZBaseCoordFormat2) == 0)
		pState->SpecialTable = TableFlagBaseCoordFormat2; 
 	else if (_stricmp(pState->ttoSymbolData.szTableType, SZSingleSubstFormat1) == 0)
		pState->SpecialTable = TableFlagSingleSubstFormat1; 
    /* initialize the rest of aStructStack in ProcessElement */
	return(TTONoErr);
}
/* ---------------------------------------------------------------------- */ 
/*  pState->fPass2 -- INPUT */       
/* ---------------------------------------------------------------------- */ 
PRIVATE int16 TTOPass1and2(PDATA_FILE_STATE pState, 
						  CONST uint8 *puchKeepGlyphList, 
						  CONST uint16 usGlyphListCount)   
{
uint16 uTableDataWritten; /* was ANY data of consequence written for this table */
int16 Value;
uint16 uTableOffset;

    while (1)  /* Process Pass 1 or 2 through file */	
    {              
    	if (pState->ulDataFileBytes <= TTOPad(pState->uCurrentInOffset)) /* if we're at the end of the file */
    		break;
        	
		uTableOffset = pState->uCurrentInOffset;
        if (TTOProcessTableDef(pState, uTableOffset) == TTOErr)
        	return ErrTrap(TTOErr); 
        uTableDataWritten = 0;
        while (1)   /* process all the elements in a table */
        {   /* process element - function will mess with the structure stack and state */
        	if ((Value = TTOProcessElement(pState, puchKeepGlyphList, usGlyphListCount, uTableDataWritten)) == TTOErr) 
        		return ErrTrap(TTOErr);	 
        	if (pState->iStructStackIndex < 0)  /* no more elements - Done with table*/
            	break;
			if (Value > 0)
				uTableDataWritten = Value;	
        }
		/* update with all the info accumulated for the table */
		ModifySymbol(pState->pTTOSymbolTable, NULL, uTableOffset, &(pState->ttoSymbolData));
	}
   
	return (TTONoErr);  
} 
/* ---------------------------------------------------------------------- */ 
PRIVATE int32 TTO_Cleanup(PDATA_FILE_STATE pState, 
						 int32 errorCode)
{
int16 i;
     
    for (i = pState->iStructStackIndex; i >= 0; --i)  /* clean up structstack if any */
	   Mem_Free(pState->aStructStack[i].pValueList);
    DestroySymbolTable(pState->pTTOSymbolTable);
	DestroyTTOTableReferenceArray(&(pState->keeper));
 	Mem_Free(pState->OutputBuffer);
	return(errorCode);
}
/* ---------------------------------------------------------------------- */ 
PRIVATE int32 ProcessTTOTable(CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo,
							 TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
							 PSTRUCTURE_LIST CONST pStructureList, 
							 char * szTag, 
							 CONST uint8 *puchKeepGlyphList, 
							 CONST uint16 usGlyphListCount, 
							 PINDEXREMAPTABLE pIndexRemapArray, 
							 int16 *pfIndexUnmapped, 
							 uint32 *pulNewOutOffset) 
{
DATA_FILE_STATE State;
uint16 uOldDelTableCount;
uint16 uNewDelTableCount; 

	/* Initialize state structure to get started */
	State.pFFSymbolTable = (PSYMBOL_TABLE) pStructureList->pSymbolTable;
	State.pInputBufferInfo = (TTFACC_FILEBUFFERINFO *) pInputBufferInfo;
	State.uCurrentOutOffset = State.uCurrentInOffset = 0;
	State.uOutBaseOffset = State.uInBaseOffset = 0;
	State.iStructStackIndex = INVALID_INDEX; 
	State.OutputBuffer = NULL;   /* allocated in pass 2 */
	State.cBufferBytes = 0;
    State.fPass2 = FALSE;
    State.pStructureList = pStructureList;
	State.ulDataFileBytes = TTTableLength(State.pInputBufferInfo, szTag); /* the size in bytes of the table */ 
    State.ulInputTTOOffset =	TTTableOffset(State.pInputBufferInfo, szTag);
	State.fVerbose = 0;
	State.pIndexRemapArray = pIndexRemapArray;  
	State.fIndexUnmapped = *pfIndexUnmapped;
	uOldDelTableCount = 0;


    memset(&(State.aStructStack),'\0', sizeof(STRUCTSTACK_LIST) * MAXSTRUCTDEPTH);
    
  	State.pTTOSymbolTable = CreateSymbolTable(sizeof(TTOSYMBOL_DATA), SYMBOLVALUETYPE); 
   	if (State.pTTOSymbolTable == NULL)
   		/* Could not create Source TTO Symbol table.",0, -1); */
		return ErrTrap(TTOErr);
   	TTOInitTTOSymbolData(&(State.ttoSymbolData));
    CreateTTOTableReferenceArray(&(State.keeper)); 

   	/* Do Pass1 */	
  	if (TTOPass1and2(&State, puchKeepGlyphList, usGlyphListCount) == TTOErr)
  		return TTO_Cleanup(&State,INVALID_OFFSET);   
	uNewDelTableCount = PropogateTTOTableReferenceDelTableFlag(&(State.keeper), State.fVerbose);
    State.fPass2 = TRUE;
	if (strcmp(szTag,GSUB_TAG) == 0)
	{
		if (TTOInitIndexRemap(ConfigIGSUBLookupIndex, 1, State.pIndexRemapArray) == TTOErr) /* allocate and initialize data */
			return TTO_Cleanup(&State,INVALID_OFFSET);
		if (TTOInitIndexRemap(ConfigIGSUBFeatureIndex, 1, State.pIndexRemapArray) == TTOErr) /* allocate and initialize data */
			return TTO_Cleanup(&State,INVALID_OFFSET);
	}
	else if (strcmp(szTag,GPOS_TAG) == 0)
	{
		if (TTOInitIndexRemap(ConfigIGPOSLookupIndex, 1, State.pIndexRemapArray) == TTOErr) /* allocate and initialize data */
			return TTO_Cleanup(&State,INVALID_OFFSET);
		if (TTOInitIndexRemap(ConfigIGPOSFeatureIndex, 1, State.pIndexRemapArray) == TTOErr) /* allocate and initialize data */
			return TTO_Cleanup(&State,INVALID_OFFSET);
	}
/* shake out all the tables deleted because of sub-table deletion */
	while (uOldDelTableCount != uNewDelTableCount)	/* process until deleted tables are stableized */
	{  		
    	memset(&(State.aStructStack),'\0', sizeof(STRUCTSTACK_LIST) * MAXSTRUCTDEPTH);
	    State.cBufferBytes = State.uCurrentOutOffset;  /* size of Data to be written to file */  
		State.uCurrentOutOffset = State.uCurrentInOffset = 0;
		State.uOutBaseOffset = State.uInBaseOffset = 0;
		State.iStructStackIndex = INVALID_INDEX; 
	  	TTOInitTTOSymbolData(&(State.ttoSymbolData));

	    /* Do Pass2 */
	  	if (TTOPass1and2(&State, puchKeepGlyphList, usGlyphListCount) == TTOErr)
	   		return TTO_Cleanup(&State,INVALID_OFFSET);
		uOldDelTableCount = uNewDelTableCount;
		uNewDelTableCount = PropogateTTOTableReferenceDelTableFlag(&(State.keeper), State.fVerbose);
	}
	if (State.uCurrentOutOffset == 0) /* lcp 1/97 nothing to keep, don't malloc 0 */
  		return TTO_Cleanup(&State,State.uCurrentOutOffset); /* everything is fine */              

 	if ((State.OutputBuffer = (unsigned char *) Mem_Alloc(State.uCurrentOutOffset)) == NULL)
	{ 
		/*( "Out of Memory allocating output buffer for TTO table",0, TTOErr); */
    	return TTO_Cleanup(&State,INVALID_OFFSET);
    }

/* now shake out the tables deleted because of FeatureIndex or LookupIndex remapping */
	uOldDelTableCount = INVALID_COUNT; /* reset to impossible number */
	while ((uOldDelTableCount != uNewDelTableCount)	|| (State.fIndexUnmapped == TRUE))/* process until deleted tables are stableized */
	{
	    memset(&(State.aStructStack),'\0', sizeof(STRUCTSTACK_LIST) * MAXSTRUCTDEPTH);
	    State.cBufferBytes = State.uCurrentOutOffset;  /* size of Data to be written to file */  
		State.uCurrentOutOffset = State.uCurrentInOffset = 0;
		State.uOutBaseOffset = State.uInBaseOffset = 0;
		State.iStructStackIndex = INVALID_INDEX; 
	  	TTOInitTTOSymbolData(&(State.ttoSymbolData));

		State.fIndexUnmapped = FALSE;
	    /* Do Pass2 */
		/* now really write the data out */
	  	if (TTOPass1and2(&State, puchKeepGlyphList, usGlyphListCount) == TTOErr)
	   		return TTO_Cleanup(&State,INVALID_OFFSET);
		uOldDelTableCount = uNewDelTableCount;
		uNewDelTableCount = PropogateTTOTableReferenceDelTableFlag(&(State.keeper), State.fVerbose);
	}
 	State.cBufferBytes = State.uCurrentOutOffset;  /* lcp 1/97 size of Data to be written to file */  
  	if ((State.cBufferBytes <= State.ulDataFileBytes) && /* Oops, table got bigger! Can't allow that. */
		(State.cBufferBytes > 0))
	{
		*pulNewOutOffset += ZeroLongWordAlign(pOutputBufferInfo, *pulNewOutOffset);
	   	if (WriteBytes(pOutputBufferInfo, State.OutputBuffer, *pulNewOutOffset, State.cBufferBytes) != NO_ERROR)
		{
	   		/* "Unable to write TTOpen Table.",0, -1); */
    		return TTO_Cleanup(&State,INVALID_OFFSET);
		}
		*pfIndexUnmapped = State.fIndexUnmapped; /* return for next time */
		UpdateDirEntryAll(pOutputBufferInfo, szTag, State.cBufferBytes, *pulNewOutOffset);
		*pulNewOutOffset += State.cBufferBytes;
	}
	/* otherwise, leave table un-written */
  	return TTO_Cleanup(&State,State.uCurrentOutOffset); /* everything is fine */              
}

/* ---------------------------------------------------------------------- */  

PRIVATE void Cleanup(PSTRUCTURE_LIST pStructureTable, 
					PINDEXREMAPTABLE pIndexRemapArray, 
					uint16 exit)
{
uint16 i;

	DestroyFFStructureTable(pStructureTable, exit);
	if (exit == 1)
		for (i = 0; i < IndexRemapCount; ++i)
		{
			Mem_Free(pIndexRemapArray[i].pNewIndex);
			pIndexRemapArray[i].pNewIndex = NULL;
		}

}

/* ---------------------------------------------------------------------- */  
/* Modify all 5 TTO tables */
/* ---------------------------------------------------------------------- */ 
/* ENTRY POINT */
/* ---------------------------------------------------------------------- */  
int16 ModTTO( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo,
			  TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
			  CONST uint8 *puchKeepGlyphList,  /* boolean array of glyphs to keep */
			  CONST uint16 usGlyphListCount,   /* number of glyphs in list */
			  CONST uint16 usFormat, /* format of deltafile */
			  uint32 *pulNewOutOffset)
{
STRUCTURE_LIST StructureTable;
int i;
DIRECTORY DirEntry;
int16 errCode = NO_ERROR;
INDEXREMAPTABLE IndexRemapArray[IndexRemapCount];	/* the 4 types of indices */
int16 fIndexUnmapped = FALSE;

#ifdef _DEBUG
	SetErrorFile(stdout); 	/* In case we get some errors */    
	SetErrorFilename("");   /* Name of Input file we are working on */
#endif
	/* For now we will shut off subsetting of OTL tables. We have discovered several bugs with relation to PairPosFormat2
		which prevents Palatino from being subsetted correctly. 10/5/98 paulli */
	return errCode; 

	if (usFormat == TTFDELTA_SUBSET1)	/* need to keep the full tto tables as we will send only once */
		return errCode;		 /* these will get copied later */
	
	if (usFormat != TTFDELTA_SUBSET) /* only formats for which this is valid */
	{
 		for (i = 0; i < TagTableCount; ++i)
			MarkTableForDeletion(pOutputBufferInfo, f_TagTable[i].szTag);
		return errCode;
	}

	
	TTOInitIndexRemap(ConfigIGSUBLookupIndex, 0, IndexRemapArray); /* make sure data initialized */
	TTOInitIndexRemap(ConfigIGSUBFeatureIndex, 0, IndexRemapArray);
	TTOInitIndexRemap(ConfigIGPOSLookupIndex, 0, IndexRemapArray);
	TTOInitIndexRemap(ConfigIGPOSFeatureIndex, 0, IndexRemapArray);
	memset(&StructureTable, 0, sizeof(STRUCTURE_LIST)); /* initialize */

	for (i = 0; i < TagTableCount; ++i)
	{
		if (GetTTDirectory( pOutputBufferInfo, f_TagTable[i].szTag, &DirEntry ) == DIRECTORY_ERROR)
			continue;

	    /* Read Format Description File */  
	    if ((errCode = CreateFFStructureTable(&StructureTable, f_TagTable[i].pFileArray)) != NO_ERROR) /* read from the pFileArray array, not from an actual file */
      	{
			Cleanup(&StructureTable, IndexRemapArray, 1);
			return ERR_GENERIC;	/* don't really know what the problem is */
    	}
	    /* Read and Process TTO Table */
	    if ((DirEntry.length = ProcessTTOTable(pInputBufferInfo, pOutputBufferInfo, &StructureTable, f_TagTable[i].szTag, puchKeepGlyphList, usGlyphListCount, IndexRemapArray, &fIndexUnmapped, pulNewOutOffset)) == INVALID_OFFSET)
      	{
			Cleanup(&StructureTable, IndexRemapArray, 1);
			return ERR_GENERIC;
    	}
		/* now update the directory length */
		if (DirEntry.length == 0) /* no data, delete entire table */
			MarkTableForDeletion(pOutputBufferInfo, f_TagTable[i].szTag);
		Cleanup(&StructureTable, IndexRemapArray, 0);
	}
	Cleanup(&StructureTable, IndexRemapArray, 1);
	return NO_ERROR;
}
/* ---------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\modtable.h ===
/*
  * ModTable.h: Interface file for ModTable.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */
  
#ifndef MODTABLE_DOT_H_DEFINED
#define MODTABLE_DOT_H_DEFINED        

int16 ModXmtxXhea( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, CONST uint8 *puchKeepGlyphList, CONST uint16 usGlyphListCount, CONST uint16 usGlyphIndexCount, CONST uint16 usMaxGlyphIndexUsed, BOOL isHmtx, uint32 *pulBytesWritten);
int16 ModLTSH( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, CONST uint8 *puchKeepGlyphList, CONST uint16 usGlyphListCount, CONST uint16 usGlyphIndexCount, uint32 *pulBytesWritten);
int16 ModHdmx( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, CONST uint8 *puchKeepGlyphList, CONST uint16 usGlyphListCount, CONST uint16 usGlyphIndexCount, uint32 *pulBytesWritten);
int16 ModHead( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, CONST uint16 usGlyphListCount, uint32 *pCheckSumAdjustment, uint32 *pulBytesWritten );
int16 ModKern( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, CONST uint8 *puchKeepGlyphList, CONST uint16 usGlyphListCount, CONST uint16 usFormat  , uint32 *pulBytesWritten);
int16 ModMaxP( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint32 *pulBytesWritten);
int16 ModName(CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, CONST uint16 usLanguage, CONST uint16 usFormat, uint32 *pulBytesWritten );
int16 ModOS2(CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint16 usMinChr, uint16 usMaxChr, CONST uint16 usFormat, uint32 *pulBytesWritten );
int16 ModPost(CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo , CONST uint16 usFormat, uint32 *pulBytesWritten );
int16 ModVDMX(CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, CONST uint16 usFormat, uint32 *pulBytesWritten );

#endif /* MODTABLE_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\modtable.c ===
/***************************************************************************
 * module: MODTABLE.C
 *
 * author: Louise Pathe
 * date:   December 1995
 * Copyright 1990-1997. Microsoft Corporation.
 * entry points:

		ModHead
		ModXmtxXhea
		ModKern
		ModMaxP
		ModName
		ModOS2
		ModPost
		ModLTSH
		ModHdmx
		ModVDMX

 **************************************************************************/


/* Inclusions ----------------------------------------------------------- */
#include <stdlib.h>
#include <string.h> /* for memset */

#include "typedefs.h"
#include "ttff.h"
#include "ttfacc.h"
#include "ttfcntrl.h"
#include "ttftabl1.h"
#include "ttftable.h"
#include "util.h"
#include "modtable.h"
#include "mtxcalc.h"
#include "ttmem.h"
#include "ttfdelta.h"	/* for format */
#include "ttferror.h"	/* for error codes */

/* here's the deal:
This function may do one of many things.
1. When GlyphIndexCount is 0, it will try to create a subsetted and shortened hmtx (or vmtx) table. 
   a. It can do this only if the highest used glyph index is less than the current numLongMetrics. 
      In this case it will write zeros to any glyph locations that are not used, and set
      the numLongMetrics value to the last used glyph index + 1, then fill the short section with
      zeros. 
   b. If this highest used glyph index is in the short section, it cannot shorten the table
      because doing so would put an incorrect advanced width value in for some of the missing glyphs.
	  In this case it will leave the table entirely alone, so that the hdmx table will not be modified either.
	  Modifying one without the other causes agfacomp to create huge delta values.
2. When GlyphIndexCount is not 0, it will create a Compact hmtx which only includes entries for the 
   glyphs that are actually in the font. 


/* ------------------------------------------------------------------- */
int16 ModXmtxXhea( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo,
				  TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
				  CONST uint8 *puchKeepGlyphList, 
				  CONST uint16 usGlyphListCount,
				  CONST uint16 usDttfGlyphIndexCount,
				  CONST uint16 usMaxGlyphIndexUsed,
				  BOOL isHmtx,
				  uint32 *pulNewOutOffset)
{						  

XHEA XHea;
uint16 i,j;
uint32 ulXmtxOffset;
uint32 ulXheaOffset;
uint32 ulCrntOffset;
uint32 ulXmtxLength;
LONGXMETRIC ZeroLongMetric;
LONGXMETRIC CurrLongMetric;
LONGXMETRIC *LongMetricsArray;
uint16 LongMetricSize;
int16 errCode;
uint16 usBytesRead;
uint16 usBytesWritten;
uint16 nNewLongMetrics;
uint32 ulBytesWritten;
char xmtx_tag[5];
char xhea_tag[5];

   /* determine number of long metrics in hmtx table */

	if (isHmtx)
	{
		strcpy(xmtx_tag, HMTX_TAG);
		strcpy(xhea_tag, HHEA_TAG);
		if ((ulXheaOffset = GetHHea( pOutputBufferInfo, (HHEA *) &XHea )) == 0L)
		{ /* hasn't been copied yet */
			if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, xhea_tag, pulNewOutOffset)) != NO_ERROR)
				return ERR_INVALID_HHEA;
			if ((ulXheaOffset = GetHHea( pOutputBufferInfo, (HHEA *) &XHea )) == 0L)
				return ERR_MISSING_HHEA;	/* required table */
		}
	}
	else
	{
		strcpy(xmtx_tag, VMTX_TAG);
		strcpy(xhea_tag, VHEA_TAG);
		ulXheaOffset = TTTableOffset( (TTFACC_FILEBUFFERINFO *)pInputBufferInfo, xhea_tag);
		ulXmtxOffset = TTTableOffset( (TTFACC_FILEBUFFERINFO *)pInputBufferInfo, xmtx_tag);
		if (ulXheaOffset != DIRECTORY_ERROR && ulXmtxOffset == DIRECTORY_ERROR)   /* this is bogus, get rid of the vhea table */
		{
			MarkTableForDeletion(pOutputBufferInfo, xhea_tag);	/* there is an entry in the output directory */
			return (NO_ERROR);
		} 

		if ((ulXheaOffset = GetVHea( pOutputBufferInfo, (VHEA *) &XHea )) == 0L)
		{
			if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, xhea_tag, pulNewOutOffset)) != NO_ERROR)
			{
				if (errCode == ERR_FORMAT)
					return NO_ERROR;	/* not required */
				else
					return errCode;
			}
			if ((ulXheaOffset = GetVHea( pOutputBufferInfo, (VHEA *) &XHea )) == 0L)
				return ERR_MISSING_VHEA;	/* */
		}
	}


	if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, xmtx_tag, pulNewOutOffset)) != NO_ERROR)
		return errCode;
	ulXmtxOffset = TTTableOffset( pOutputBufferInfo, xmtx_tag);
	ulXmtxLength = TTTableLength( pOutputBufferInfo, xmtx_tag);
  	

	if ((XHea.numLongMetrics == 0) || (XHea.numLongMetrics > usGlyphListCount))
		return ERR_INVALID_HHEA_OR_VHEA;		/* invalid values */
	
	if (ulXmtxOffset == DIRECTORY_ERROR )
		return ERR_MISSING_HMTX_OR_VMTX;	 	/* required table */
										
 	ulCrntOffset = ulXmtxOffset;
	ZeroLongMetric.xsb = 0;
	ZeroLongMetric.advanceX = 0;
  	LongMetricSize = GetGenericSize(LONGXMETRIC_CONTROL);

	if (usDttfGlyphIndexCount == 0)	   /* not trying to make a compact table, just subsetting */
	{
	/* check to see if we will grow. We will grow with subsetting if our last good glyph index is beyond the current numLongMetrics */

		if ((XHea.numLongMetrics != usGlyphListCount) && /* if longmetrics is the same as number of glyphs, table won't be growing  */ 
			/* need for zero based to 1 base + 1 for the dummy 0 entry */
			(usMaxGlyphIndexUsed + 1 + 1 > XHea.numLongMetrics)) /* check if we may make the table grow */
			return (ERR_WOULD_GROW);
		nNewLongMetrics = min(usGlyphListCount, usMaxGlyphIndexUsed + 1 + 1);  	/* + 1 again for dummy */
   		/* process all the Long metrics (and perhaps some short when we won't be modifying the table */
		for (i = 0; i < nNewLongMetrics; ++i)
		{
			if (puchKeepGlyphList[i] == FALSE)/* else we don't want to keep this one, 0 metrics to write */
			{
				if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *)&ZeroLongMetric, SIZEOF_LONGXMETRIC, LONGXMETRIC_CONTROL, ulCrntOffset, &usBytesWritten)) != NO_ERROR)
					return (errCode);
			}
			ulCrntOffset += LongMetricSize;
		}
 		/* write out short metrics of 0 for the rest of them*/
		for (i = nNewLongMetrics; i < usGlyphListCount; ++i)
		{
			if ((errCode = WriteWord(pOutputBufferInfo, 0, ulCrntOffset)) != NO_ERROR)
				return errCode;
			ulCrntOffset += sizeof (uint16);
		}
		ulBytesWritten = ulCrntOffset - ulXmtxOffset;
	}
	else  /* we want to make a compact table */
	{
	/* now collapse the table if we are in Compact form for Subsetting and Delta fonts */
	/* we will use an interrum table for simplification */
		ulCrntOffset = ulXmtxOffset;
		LongMetricsArray = Mem_Alloc(sizeof(LONGXMETRIC) * usDttfGlyphIndexCount);
		if (LongMetricsArray == NULL)
			return ERR_MEM;
		nNewLongMetrics = 0;
		for (i = 0, j= 0; i < XHea.numLongMetrics && j < usDttfGlyphIndexCount && errCode == NO_ERROR; ++i)  /* need to read and copy up the values */
		{
			if (puchKeepGlyphList[i]) /* if we want to keep the glyph, or its the last special one */
			{
				if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *)&CurrLongMetric, SIZEOF_LONGXMETRIC, LONGXMETRIC_CONTROL, ulCrntOffset, &usBytesRead)) != NO_ERROR)
					break;
				LongMetricsArray[j] = CurrLongMetric;
				++j;
				++nNewLongMetrics;
			}
			else if (i == XHea.numLongMetrics-1) /* its that special dummy "last" one, need AW value */
			{
 				if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *)&CurrLongMetric, SIZEOF_LONGXMETRIC, LONGXMETRIC_CONTROL, ulCrntOffset, &usBytesRead)) != NO_ERROR)
					break;
				++nNewLongMetrics; /* we will need an extra one, but guarenteed to be <= XHea.numLongMetrics */
			}
			ulCrntOffset += LongMetricSize;
		}
		if (errCode != NO_ERROR)
		{
			Mem_Free(LongMetricsArray);
			return errCode;
		}
		for (; i < usGlyphListCount && j < usDttfGlyphIndexCount; ++i) /* copy the xsb from the long metrics */
		{
			if (puchKeepGlyphList[i])
			{
				if ((errCode = ReadWord( pOutputBufferInfo, (uint16 *)&(CurrLongMetric.xsb), ulCrntOffset)) != NO_ERROR)
					break;
				LongMetricsArray[j] = CurrLongMetric;
				++j;
			}
			ulCrntOffset += sizeof(uint16);
		}
		if (errCode != NO_ERROR)
		{
			Mem_Free(LongMetricsArray);
			return errCode;
		}

		if (j != usDttfGlyphIndexCount)
		{
			Mem_Free(LongMetricsArray);
			return ERR_GENERIC;
		}
		/* first write out the long metrics */
		errCode = WriteGenericRepeat(pOutputBufferInfo,(uint8 *)LongMetricsArray, LONGXMETRIC_CONTROL,
				ulXmtxOffset,&ulBytesWritten, nNewLongMetrics, SIZEOF_LONGXMETRIC);
		/* then write out the short metrics */
		if (errCode == NO_ERROR)
		{
			ulCrntOffset = ulXmtxOffset + ulBytesWritten;
			for (i = nNewLongMetrics; i < usDttfGlyphIndexCount; ++i)
			{
				if ((errCode = WriteWord( pOutputBufferInfo, LongMetricsArray[i].xsb, ulCrntOffset)) != NO_ERROR)
					break;
				ulCrntOffset += sizeof(uint16);
			}
		}
	
		Mem_Free(LongMetricsArray);
		if (errCode != NO_ERROR)
			return errCode;
		ulBytesWritten = ulCrntOffset - ulXmtxOffset;
	}
  
		/* write out our new, shorter length... cleanup comes later */
	errCode = UpdateDirEntry( pOutputBufferInfo, xmtx_tag, ulBytesWritten );

	if (errCode == NO_ERROR && nNewLongMetrics != XHea.numLongMetrics) 
	{
		XHea.numLongMetrics = nNewLongMetrics;		/* leave these alone if the hmtx table will remain the same */
		if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &XHea, SIZEOF_XHEA, XHEA_CONTROL, ulXheaOffset, &usBytesWritten )) != NO_ERROR)
			return (errCode);
	}
	*pulNewOutOffset = ulCrntOffset;

	return errCode;
}

/* ------------------------------------------------------------------- */
int16 ModMaxP( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
			  TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
			  uint32 *pulNewOutOffset)
{
MAXP MaxP;
uint32 ulOffset;
uint16 usnMaxComponents;
uint16 *pausComponents;	
int16 errCode;
uint16 usBytesWritten;

   /* get old maxp record */
	if ((ulOffset = GetMaxp( pOutputBufferInfo, &MaxP)) == 0L)
	{ /* not copied over yet */
		if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, MAXP_TAG, pulNewOutOffset)) != NO_ERROR)
			return ERR_MISSING_MAXP; /* required */

		if ((ulOffset = GetMaxp( pOutputBufferInfo, &MaxP)) == 0L)
   			return ERR_GENERIC;
	}

   /* recompute maxp info */
    /* figure a conservative maximum total possible. 3x3 at minimum */
	usnMaxComponents = max(3,MaxP.maxComponentElements) * max(3,MaxP.maxComponentDepth);
	pausComponents = (uint16 *) Mem_Alloc(usnMaxComponents * sizeof(uint16));
	if (pausComponents == NULL)
		return ERR_MEM;

	errCode = ComputeMaxPStats( pOutputBufferInfo, &(MaxP.maxContours), &(MaxP.maxPoints), &(MaxP.maxCompositeContours),
	                 &(MaxP.maxCompositePoints), &(MaxP.maxSizeOfInstructions),
	                 &(MaxP.maxComponentElements), &(MaxP.maxComponentDepth), pausComponents, usnMaxComponents  );
   /* write out new maxp record with new maxp info */
	Mem_Free(pausComponents);

	if (errCode == NO_ERROR)
		errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &MaxP, SIZEOF_MAXP, MAXP_CONTROL, ulOffset, &usBytesWritten );

	return errCode;
}

/* NOTE: This function will work fine even if the OS/2 table becomes updated. 
   The version value is preserved, and the length of the table is not modified */
/* ------------------------------------------------------------------- */
int16 ModOS2( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
			 uint16 usMinChr, 
			 uint16 usMaxChr,
			  CONST uint16 usFormat,
			  uint32 *pulNewOutOffset)
{
/* read OS2 table, modify the max,min char field, and write out the
new table */

NEWOS2  Os2;
uint32   ulOffset;
BOOL bNewOS2 = FALSE;
uint16 usBytesWritten;
int16 errCode = NO_ERROR;

	if (usFormat == TTFDELTA_DELTA) /* only formats for which this is not valid */
	{
		MarkTableForDeletion(pOutputBufferInfo, OS2_TAG);
		return errCode;
	}

	if ((ulOffset = GetSmartOS2(pOutputBufferInfo,&Os2,&bNewOS2)) == 0L)
	{
		if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, OS2_TAG, pulNewOutOffset)) != NO_ERROR)
		{
			if (errCode == ERR_FORMAT)
				return NO_ERROR;	/* not required */
			return errCode;
		}
		if ((ulOffset = GetSmartOS2(pOutputBufferInfo,&Os2,&bNewOS2)) == 0L)
			return ERR_GENERIC;
	}

	if (usMinChr != 0 || usMaxChr != 0) /* couldn't set in modcmap because of growth */
	{
		if (Os2.usFirstCharIndex < 0xF000)	 /* lcp 5/26/97 don't want to change this if it is a Symbol font */
			Os2.usFirstCharIndex = usMinChr;
		Os2.usLastCharIndex  = usMaxChr;
		
		if( bNewOS2 )  /* write out the new one */
		{
			if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &Os2, SIZEOF_NEWOS2, NEWOS2_CONTROL, ulOffset, &usBytesWritten)) != NO_ERROR)
				return errCode;
		}
		else	 /* write out the old one */
		{
			if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &Os2, SIZEOF_OS2, OS2_CONTROL, ulOffset, &usBytesWritten )) != NO_ERROR)
				return errCode;
		}
	}
	return errCode;
}

/* ------------------------------------------------------------------- */



/* ------------------------------------------------------------------- */
/* this function changes all Post tables to format 3.0 for space savings */
/* ------------------------------------------------------------------- */
#define POST_FORMAT_3 0x0030000
int16 ModPost( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
			  TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
			  CONST uint16 usFormat,
			  uint32 *pulNewOutOffset)
{
POST    Post;
int16 errCode = NO_ERROR;
uint16 usBytesWritten;
uint32 ulOffset;

	/* verify table needs to be modified */

	if (usFormat == TTFDELTA_DELTA) /* only formats for which this is not valid */
	{
		MarkTableForDeletion(pOutputBufferInfo, POST_TAG);
		return errCode;
	}
	if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, POST_TAG, pulNewOutOffset)) != NO_ERROR)
	{
		if (errCode == ERR_FORMAT)
			return NO_ERROR;	/* not required */
		return errCode;
	}

	if ((ulOffset = GetPost( pOutputBufferInfo, &Post )) == 0L)
		return ERR_GENERIC;

	if ( Post.formatType != POST_FORMAT_3 )
	{
		/* Not POST format 3.0, so change it to 3.0 */
		Post.formatType = POST_FORMAT_3;
		if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &Post,SIZEOF_POST, POST_CONTROL, ulOffset, &usBytesWritten )) != NO_ERROR)
			return errCode;
		/* update the directory entry with new length */

		errCode = UpdateDirEntry( pOutputBufferInfo, POST_TAG, (uint32) usBytesWritten );
		*pulNewOutOffset = ulOffset + usBytesWritten;
	}
	return errCode;
}

/* ------------------------------------------------------------------- */
/* ModName definitions */
/* ------------------------------------------------------------------- */
/* will modify the name table thusly:
   look for name entries. If the entry is for a platform other than 3, or
   the entry is for platform 3 and the specified language, copy it to the
   output table. Otherwise don't copy it (delete it) to the table. 
   Must be certain that the end result is that there be at least 1 table with
   platform 3, if there were any to begin with.
   
/* since it is possible that string data may be shared among the Name records, 
we have to do a whole bunch of junk to avoid copying duplicate entries, and 
overwriting data we already have */

/* ------------------------------------------------------------------- */

int16 ModName( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
			  TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
			  CONST uint16 usLanguage,
			  CONST uint16 usFormat,
			  uint32 *pulNewOutOffset)
{
PNAMERECORD pNameRecordArray; /* internal representation of NameRecord - from ttftable.h */
uint16 NameRecordCount;
int16 errCode = NO_ERROR;
uint16 i;
uint16 bKeptMSPlatformRecord = FALSE; /* has a MS Platform record been kept? */
uint16 bDeleteStrings = FALSE; /* should we delete strings when writing out table? */
uint32 ulBytesWritten = 0;
uint32 ulNameOffset;
uint32 ulNameLength;
TTFACC_FILEBUFFERINFO NameTableBufferInfo; /* needed by WriteNameRecords */

	if (usFormat == TTFDELTA_DELTA) /* only formats for which this is not valid */
	{
		MarkTableForDeletion(pOutputBufferInfo, NAME_TAG);
		return errCode;
	}
	if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, NAME_TAG, pulNewOutOffset))!= NO_ERROR)
		return errCode; /*  required */

	ulNameOffset = TTTableOffset( pOutputBufferInfo, NAME_TAG);
	ulNameLength = TTTableLength( pOutputBufferInfo, NAME_TAG);

/* Get info about Name table */

	if ((errCode = ReadAllocNameRecords(pOutputBufferInfo, &pNameRecordArray, &NameRecordCount, Mem_Alloc, Mem_Free)) != NO_ERROR)
		return errCode;
	
	if (usLanguage != TTFSUB_LANG_KEEP_ALL)
	{
		for (i = 0; i < NameRecordCount; ++i)
		{
			if (pNameRecordArray[i].platformID == TTFSUB_MS_PLATFORMID) 
			{
				if (pNameRecordArray[i].languageID == usLanguage) /* we want to keep this one */
					bKeptMSPlatformRecord = TRUE;
				else  /* we don't want it */
				{
					pNameRecordArray[i].bDeleteString = TRUE;  /* mark it for deletion */
					bDeleteStrings = TRUE;
				}
			}
		}
		if (bDeleteStrings && !bKeptMSPlatformRecord)	 /* if we asked to keep a language that wasn't found, don't delete others */
			bDeleteStrings = FALSE;
	}
	/* now fake up a bufferinfo so that WriteNameRecords will write to the actual file buffer */
	NameTableBufferInfo.puchBuffer = pOutputBufferInfo->puchBuffer + ulNameOffset;
	NameTableBufferInfo.ulBufferSize = ulNameLength;
	NameTableBufferInfo.lpfnReAllocate = NULL; /* can't reallocate!!! */
	NameTableBufferInfo.ulOffsetTableOffset = 0;

	errCode = WriteNameRecords(&NameTableBufferInfo, pNameRecordArray, NameRecordCount, bDeleteStrings, TRUE, &ulBytesWritten);
	FreeNameRecords(pNameRecordArray, NameRecordCount, Mem_Free);

	if (errCode == NO_ERROR)
	{
		*pulNewOutOffset = ulNameOffset + ulBytesWritten;
		UpdateDirEntry(pOutputBufferInfo, NAME_TAG, ulBytesWritten);
	}
	else /* ran out of room? restore it */
	{
		*pulNewOutOffset = ulNameOffset;
		errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, NAME_TAG, pulNewOutOffset);
	}

	return errCode;
}
		
/* ------------------------------------------------------------------- */
PRIVATE int16 AdjustKernFormat0(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
						CONST uint8 *puchKeepGlyphList, 
						CONST uint16 usGlyphListCount, 
						KERN_SUB_HEADER   KernSubHeader,
                        uint32 ulOffset,
						uint16 usSubHeaderSize, /* size in file of usSubHeader */
                        uint16 * pusNewLength)
{
uint32 ulSourceOffset;
uint32 ulTargetOffset;
KERN_FORMAT_0 KernFormat0;
KERN_PAIR KernPair;
uint16 usKernFormat0Size;
uint16 i;
uint16 usUsedPairs;
uint16 usSearchRange;
uint16 usRangeShift;
uint16 usBytesRead;
uint16 usBytesWritten;
int16 errCode;
						 
	/* determine number of kern pairs */
	ulSourceOffset = ulOffset + usSubHeaderSize;
	if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *)&KernFormat0, SIZEOF_KERN_FORMAT_0, KERN_FORMAT_0_CONTROL, ulSourceOffset, &usBytesRead )) != NO_ERROR)
		return errCode;
	usKernFormat0Size = usBytesRead;
	ulSourceOffset += usKernFormat0Size;
	ulTargetOffset = ulSourceOffset;

	/* wade through list of pairs, copying those that do not include a
	deleted glyph and ignoring those that do */

	usUsedPairs = 0;
	for ( i = 0; i < KernFormat0.nPairs; i++ )
	{
		if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &KernPair, SIZEOF_KERN_PAIR, KERN_PAIR_CONTROL, ulSourceOffset, &usBytesRead )) != NO_ERROR)
		return errCode;

		if (( KernPair.left < usGlyphListCount && puchKeepGlyphList[KernPair.left] ) &&
		    ( KernPair.right < usGlyphListCount && puchKeepGlyphList[KernPair.right] ))
		{
			if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &KernPair, SIZEOF_KERN_PAIR, KERN_PAIR_CONTROL, ulTargetOffset, &usBytesWritten)) != NO_ERROR)
				return errCode;
			ulTargetOffset += usBytesWritten;
			usUsedPairs++;
		}
		ulSourceOffset += usBytesRead;
	}

	/* calc and write out revised subtable header */
	if (usUsedPairs > 0)
	{
		*pusNewLength = (uint16) (ulTargetOffset - ulOffset);
		KernSubHeader.length = *pusNewLength ;
		if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &KernSubHeader, SIZEOF_KERN_SUB_HEADER, KERN_SUB_HEADER_CONTROL, ulOffset, &usBytesWritten )) != NO_ERROR)
			return errCode;

		/* calc and write out revised format 0 header */

		usSearchRange = (0x0001 << log2( usUsedPairs )) * GetGenericSize( KERN_PAIR_CONTROL );
		usRangeShift  = (usUsedPairs * GetGenericSize( KERN_PAIR_CONTROL )) - usSearchRange;
		KernFormat0.nPairs      = usUsedPairs;
		KernFormat0.searchRange =  usSearchRange;
		KernFormat0.entrySelector = log2( usUsedPairs );
		KernFormat0.rangeShift    = usRangeShift;
		if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &KernFormat0, SIZEOF_KERN_FORMAT_0, KERN_FORMAT_0_CONTROL, ulOffset + usBytesWritten, &usBytesWritten )) != NO_ERROR)
			return errCode;
	}
	else
		*pusNewLength = 0;
	return NO_ERROR;
}

/* ------------------------------------------------------------------- */
int16 ModKern(  CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
			  CONST uint8 *puchKeepGlyphList, 
			  CONST uint16 usGlyphListCount,
			  CONST uint16 usFormat,
			  uint32 *pulNewOutOffset)
{
uint32 ulOffset;
uint32 ulSourceOffset;
uint32 ulTargetOffset;
KERN_HEADER KernHeader;
KERN_SUB_HEADER  KernSubHeader;
uint16 i;
uint16 usSubtableLength;
uint16 usBytesRead;
int16 errCode = NO_ERROR;
	/* read kern table header */

	
	if (usFormat == TTFDELTA_DELTA) /* only formats for which this is valid */
	{
		MarkTableForDeletion(pOutputBufferInfo, KERN_TAG);
		return NO_ERROR;
	}
	if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, KERN_TAG, pulNewOutOffset)) != NO_ERROR)	
	{
		if (errCode == ERR_FORMAT)
			return NO_ERROR;	/* not required */
		return errCode;
	}

	if (usFormat == TTFDELTA_SUBSET1)	/* need to keep the full kern table as we will send only once */
		return NO_ERROR;

	ulOffset = TTTableOffset( pOutputBufferInfo, KERN_TAG );
	if ( ulOffset == 0L )
		return ERR_GENERIC;	   /* should have been copied over */
	if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &KernHeader, SIZEOF_KERN_HEADER, KERN_HEADER_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR)
		return errCode;

	/* read each subtable.  If it is a format 0 subtable, remove
	kern pairs involving deleted glyphs.  Otherwise, copy
	the table down to its new location */

	ulSourceOffset = ulOffset + usBytesRead;
	ulTargetOffset = ulSourceOffset;
	for ( i = 0; i < KernHeader.nTables; i++ )
	{
		/* read subtable header */
		if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &KernSubHeader, SIZEOF_KERN_SUB_HEADER, KERN_SUB_HEADER_CONTROL, ulSourceOffset, &usBytesRead )) != NO_ERROR)
			return errCode;

		/* copy data to new location to cover any gaps left by shortening the previous
		format 0 subtable. Nothing happens first time around. */

		if ((errCode = CopyBlock( pOutputBufferInfo, ulTargetOffset, ulSourceOffset, KernSubHeader.length )) != NO_ERROR)
			return errCode;
		ulSourceOffset += KernSubHeader.length;

		/* if subtable is format 0, shorten it by deleting kern pairs
		involving deleted glyphs */

		if ( KernSubHeader.format == 0 )
		{
			if ((errCode = AdjustKernFormat0( pOutputBufferInfo, puchKeepGlyphList, usGlyphListCount, KernSubHeader, ulTargetOffset, usBytesRead, &usSubtableLength)) != NO_ERROR)
				return errCode;
			ulTargetOffset += usSubtableLength;
		}
		else
			ulTargetOffset += KernSubHeader.length;
	}

	/* Write out revised table length */
	if (ulTargetOffset == ulOffset + GetGenericSize( KERN_HEADER_CONTROL )) /* no Kern data written */
		MarkTableForDeletion(pOutputBufferInfo, KERN_TAG);
	else
		errCode = UpdateDirEntry( pOutputBufferInfo, KERN_TAG, ulTargetOffset - ulOffset );
	*pulNewOutOffset = ulTargetOffset;
	return errCode;
}

/* ------------------------------------------------------------------- */
/* clear out any unused glyphs. Calculate new maxWidth value for each device record */
/* assumes that hhea table has been updated with info for the modified hmtx table */
/* ------------------------------------------------------------------- */
int16 ModHdmx( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
			  CONST uint8 *puchKeepGlyphList, 
			  CONST uint16 usGlyphListCount,
			  CONST uint16 usDttfGlyphIndexCount,
			  uint32 *pulNewOutOffset)
{
HDMX Hdmx;
HDMX_DEVICE_REC DevRecord;
uint8 Width;
uint8 maxWidth;
uint16 i;
uint16 j,k;
uint32 ulHdmxOffset;
uint32 ulOffset;
uint32 ulDevOffset;
uint32 ulInOffset;
uint32 ulOutOffset;
uint32 ulInDevOffset;
uint32 ulOutDevOffset;
int16 errCode;
uint16 usBytesRead;
uint16 usBytesWritten;
uint32 ulOutSizeDeviceRecord;

	if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, HDMX_TAG, pulNewOutOffset)) != NO_ERROR)
	{
		if (errCode == ERR_FORMAT)
			return NO_ERROR;	/* not required */
		return errCode;
	}

	ulHdmxOffset = GetHdmx(pOutputBufferInfo, &Hdmx);
	if ( !ulHdmxOffset )
		return ERR_GENERIC;

	ulOffset = ulHdmxOffset + GetGenericSize( HDMX_CONTROL );

	if (usDttfGlyphIndexCount) /* we want compact form */
	{
		ulInOffset = ulOutOffset = ulOffset;
		ulOutSizeDeviceRecord = RoundToLongWord(GetGenericSize(HDMX_DEVICE_REC_CONTROL) + (sizeof(uint8) * usDttfGlyphIndexCount));
		for( j = 0; j < Hdmx.numDeviceRecords; j++)
		{
			ulInDevOffset = ulInOffset;
			ulOutDevOffset = ulOutOffset;
			if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *)&DevRecord, SIZEOF_HDMX_DEVICE_REC, HDMX_DEVICE_REC_CONTROL, ulInDevOffset, &usBytesRead )) != NO_ERROR)
				return errCode;
			ulInOffset += usBytesRead;
			ulOutOffset += usBytesRead;
			maxWidth = 0;

			for(i = 0, k= 0; i < usGlyphListCount && k < usDttfGlyphIndexCount; i++) /* process each glyph entry */
			{
				if (puchKeepGlyphList[ i ])
				{
					if ((errCode = ReadByte( pOutputBufferInfo, &Width, ulInOffset)) != NO_ERROR)
						return errCode;
					maxWidth = max( maxWidth, Width );
					if ((errCode = WriteByte( pOutputBufferInfo, Width, ulOutOffset)) != NO_ERROR)
						return errCode;
					ulOutOffset += sizeof(uint8);
					++k;
				}
				ulInOffset += sizeof(uint8);
			}
			ulOutOffset += ZeroLongWordAlign(pOutputBufferInfo, ulOutOffset);
			DevRecord.maxWidth = maxWidth;
			if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *)&DevRecord, SIZEOF_HDMX_DEVICE_REC, HDMX_DEVICE_REC_CONTROL, ulOutDevOffset, &usBytesWritten )) != NO_ERROR)
				return errCode;
			ulInOffset = ulInDevOffset + Hdmx.sizeDeviceRecord;
			ulOutOffset = ulOutDevOffset + ulOutSizeDeviceRecord;
		}
		/* now need to update hdmx record */
		Hdmx.sizeDeviceRecord = ulOutSizeDeviceRecord;
		if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *)&Hdmx, SIZEOF_HDMX, HDMX_CONTROL, ulHdmxOffset, &usBytesWritten )) != NO_ERROR)
			return errCode;
		errCode = UpdateDirEntry( pOutputBufferInfo, HDMX_TAG, ulOutOffset - ulHdmxOffset );
		*pulNewOutOffset = ulOutOffset;
	}
	else
	{

	/* 		if (GetHHea(pOutputBufferInfo, &Hhea) == 0L)
		   return ERR_FORMAT;  */

		for( j = 0; j < Hdmx.numDeviceRecords; j++)
		{
			ulDevOffset = ulOffset;
			if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *)&DevRecord, SIZEOF_HDMX_DEVICE_REC, HDMX_DEVICE_REC_CONTROL, ulDevOffset, &usBytesRead )) != NO_ERROR)
				return errCode;
			ulOffset += usBytesRead;
			maxWidth = 0;

			for(i = 0; i < usGlyphListCount; i++) /* process each glyph entry */
			{
				if (puchKeepGlyphList[ i ])
				{
					if ((errCode = ReadByte( pOutputBufferInfo, &Width, ulOffset)) != NO_ERROR)
						return errCode;
					maxWidth = max( maxWidth, Width );
				}
				else /* if (i != Hhea.numLongMetrics-1) clear the value in the file, so the compressor can do its work, except for any dummy entries in the hmtx table */
				{
					if ((errCode = WriteByte( pOutputBufferInfo, (uint8) 0, ulOffset)) != NO_ERROR)
						return errCode;
				}
				ulOffset += sizeof(uint8);
			}
			if (DevRecord.maxWidth != maxWidth) /* it's changed, we need to write it out again */
			{
				DevRecord.maxWidth = maxWidth;
				if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *)&DevRecord, SIZEOF_HDMX_DEVICE_REC, HDMX_DEVICE_REC_CONTROL, ulDevOffset, &usBytesWritten )) != NO_ERROR)
					return errCode;
			}
			ulOffset = ulDevOffset + Hdmx.sizeDeviceRecord;
		}
		*pulNewOutOffset = ulOffset;
	}

	return NO_ERROR;
}


/* ------------------------------------------------------------------- */
/* Zero out any unused glyphs */
/* ------------------------------------------------------------------- */
int16 ModLTSH(  CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
			  CONST uint8 *puchKeepGlyphList, 
			  CONST uint16 usGlyphListCount,
			  CONST uint16 usDttfGlyphIndexCount,
			  uint32 *pulNewOutOffset)
{
LTSH  Ltsh;
uint32 ulLtshOffset;
uint32 ulInOffset;
uint32 ulOutOffset;
uint16 i,j;
int16 errCode;
uint16 GlyphCount;
uint8 uchValue;
uint16 usBytesWritten;

   /* read ltsh table header */

  if ((errCode = CopyTableOver(pOutputBufferInfo, pInputBufferInfo, LTSH_TAG, pulNewOutOffset)) != NO_ERROR)
  {
	if (errCode == ERR_FORMAT)
		return NO_ERROR;	/* not required */
	return errCode;
  }
  ulLtshOffset = GetLTSH( pOutputBufferInfo, &Ltsh );
   if ( ulLtshOffset == 0 )
      return ERR_GENERIC;

   if (usDttfGlyphIndexCount)
   {
	   ulOutOffset = ulLtshOffset + GetGenericSize( LTSH_CONTROL );
	   ulInOffset = ulLtshOffset + GetGenericSize( LTSH_CONTROL );
	   GlyphCount = min(Ltsh.numGlyphs,	usGlyphListCount); /* don't want to process too many if file is buggy */

		for( i=0, j= 0; i < GlyphCount && j < usDttfGlyphIndexCount; i++)
		{
			if (puchKeepGlyphList[ i ])	/* need keep this one out */
			{
				if ((errCode = ReadByte( pOutputBufferInfo, (uint8 *) &uchValue, ulInOffset)) != NO_ERROR)
					return errCode;

				if ((errCode = WriteByte( pOutputBufferInfo, (uint8) uchValue, ulOutOffset)) != NO_ERROR)
					return errCode;
				ulOutOffset += sizeof(uint8);
				++j;
			}
			ulInOffset += sizeof(uint8);
		}
		/* now we need to update the count for the LTSH table */
		Ltsh.numGlyphs = usDttfGlyphIndexCount;
		if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *)&Ltsh, SIZEOF_LTSH, LTSH_CONTROL, ulLtshOffset, &usBytesWritten )) != NO_ERROR)
			return errCode;
		errCode = UpdateDirEntry( pOutputBufferInfo, LTSH_TAG, ulOutOffset - ulLtshOffset );
   }
   else
   {

	   ulOutOffset = ulLtshOffset + GetGenericSize( LTSH_CONTROL );
	   GlyphCount = min(Ltsh.numGlyphs,	usGlyphListCount); /* don't want to process too many if file is buggy */

		for( i=0; i < GlyphCount; i++)
		{
			if (!puchKeepGlyphList[ i ])	/* need to zero out */
			{
				if ((errCode = WriteByte( pOutputBufferInfo, (uint8) 0, ulOutOffset)) != NO_ERROR)
					return errCode;
			}
			ulOutOffset += sizeof(uint8);
		}
   }
   *pulNewOutOffset = ulOutOffset;
	return NO_ERROR;
}

/* ---------------------------------------------------------------------- */
/* Greatest Common Denominator */
/* recursive !! */
/* ---------------------------------------------------------------------- */
PRIVATE uint16 GCD (uint16 u, uint16 v)
{
	if (v == 0) 
		return (u);
	else 
		return GCD(v, (uint16) (u % v));
}
/* ---------------------------------------------------------------------- */
void ReduceRatio(uint16 *px, uint16 *py)
{
uint16 gcd; 

		gcd = GCD(*px, *py);
		if (gcd > 0) /* should never return 0, but check just in case */
		{
			*px = (*px) / gcd;
			*py = (*py) / gcd;
		}	
}
/* ------------------------------------------------------------------- */
typedef struct {
	uint16 usOldGroupOffset;
	uint16 usNewGroupOffset;
} GroupOffsetRecord;

/* ------------------------------------------------------------------- */
typedef struct groupoffsetrecordkeeper *PGROUPOFFSETRECORDKEEPER;	 
typedef struct groupoffsetrecordkeeper GROUPOFFSETRECORDKEEPER;	 

struct groupoffsetrecordkeeper	  /* housekeeping structure */
{
	GroupOffsetRecord * pGroupOffsetArray;
	uint16 usGroupOffsetArrayLen;
	uint16 usNextArrayIndex;
};

/* ------------------------------------------------------------------- */
PRIVATE int16 InitGroupOffsetArray(PGROUPOFFSETRECORDKEEPER pKeeper, 
								  uint16 usRecordCount)
{
	pKeeper->pGroupOffsetArray = (GroupOffsetRecord *) Mem_Alloc(usRecordCount * sizeof(*(pKeeper->pGroupOffsetArray)));
	if (pKeeper->pGroupOffsetArray == NULL)
		return ERR_MEM;
	pKeeper->usGroupOffsetArrayLen = usRecordCount;
	pKeeper->usNextArrayIndex = 0;
	return NO_ERROR;
}
/* ------------------------------------------------------------------- */
PRIVATE void FreeGroupOffsetArray(PGROUPOFFSETRECORDKEEPER pKeeper)
{
	Mem_Free(pKeeper->pGroupOffsetArray);
	pKeeper->pGroupOffsetArray = NULL;
	pKeeper->usGroupOffsetArrayLen = 0;
	pKeeper->usNextArrayIndex = 0;
}
/* ------------------------------------------------------------------- */
PRIVATE int16 RecordGroupOffset(PGROUPOFFSETRECORDKEEPER pKeeper, 
								uint16 usOldGroupOffset,
								uint16 usNewGroupOffset)
  /* record this block as being used */
{
	if (pKeeper->usNextArrayIndex >= pKeeper->usGroupOffsetArrayLen)
		return ERR_FORMAT;
	pKeeper->pGroupOffsetArray[pKeeper->usNextArrayIndex].usOldGroupOffset = usOldGroupOffset;
	pKeeper->pGroupOffsetArray[pKeeper->usNextArrayIndex].usNewGroupOffset = usNewGroupOffset ;
	++pKeeper->usNextArrayIndex;
	return NO_ERROR;
}

/* ------------------------------------------------------------------- */
PRIVATE uint16 LookupGroupOffset(PGROUPOFFSETRECORDKEEPER pKeeper, 
								uint16 usOldGroupOffset)
{
uint16 i;

	for (i = 0; i < pKeeper->usNextArrayIndex; ++i)
	{
	 	if (usOldGroupOffset == pKeeper->pGroupOffsetArray[i].usOldGroupOffset)
			return(pKeeper->pGroupOffsetArray[i].usNewGroupOffset);
	}
	return(0);
}
/* ------------------------------------------------------------------- */
#define EGA_X_RATIO 4
#define EGA_Y_RATIO 3	
/* ---------------------------------------------------------------------- */
/* need both input and output buffer info, because we don't want to overwrite blocks of data if not written in order */
/* need to remove 4:3 ratio and 0:0 ration (if a 1:1 already exists) */
/* don't have to copy the data over from the inputbuffer, as this function reads directly from there */
/* ------------------------------------------------------------------- */
int16 ModVDMX(CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
			  TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
			  CONST uint16 usFormat,
			  uint32 *pulNewOutOffset)
{
VDMX Vdmx;
uint32 ulSrcOffset;	/* offset to Src VDMX table */
uint32 ulSrcLength;	/* length of Src VDMX table */
uint32 ulDestOffset; /* offset to Dest VDMX table */
uint32 ulDestLength; /* length of Dest VDMX table */
uint32 ulSrcOffsetRatios;	/* absolute offset to Ratios in Src file */
uint32 ulSrcOffsetOffsets;	/* absolute offset to Offsets in Src file */
uint32 ulSrcOffsetGroups;	/* absolute offset to Groups in Src file */
uint32 ulDestOffsetRatios; 	/* absolute offset to Ratios in Dest file */
uint32 ulDestOffsetOffsets;	/* absolute offset to Offsets in Dest file */
uint32 ulDestOffsetGroups;	/* absolute offset to Groups in Dest file */
uint16 usCurrGroupSrcOffset; /* relative offset from beginning of VDMX table */
uint16 usCurrGroupDestOffset; /* relative offset from beginning of VDMX table */
uint32 ulCurrGroupDestOffset=0; /* relative offset from beginning of VDMX table - long value */
uint16 usGroupDestOffset; /* relative offset from beginning of VDMX table, local copy for writing */
uint16 usSrcRatioIndex,usDestRatioIndex;
uint16 i;
uint16 usBytesRead;
uint16 usBytesWritten;
uint32 ulBytesRead;
int16 errCode=NO_ERROR;
VDMXRatio *SrcRatioArray=NULL;
int8 *KeepSrcRatioArray = NULL;   /* parallel array to SrcRatioArray */
VDMXGroup GroupHeader;
uint8 *	pGroupBuffer=NULL;
uint32 ulGroupBufferLength;	/* total length of the Group Buffer (from source file) */
uint32 ulGroupLength; /* length of individual group to be read */
uint16 usGroupCount = 0; 
uint16 usKeepRatioCount = 0;
uint16 usRatioSize;
uint16 xRatio, yRatio; /* for reducing the ratios */
int16 Found1to1; 
GROUPOFFSETRECORDKEEPER keeper; 
TTFACC_FILEBUFFERINFO * pUnCONSTInputBufferInfo;

	if (usFormat == TTFDELTA_DELTA)  /* only formats for which this is not valid */
	{
		MarkTableForDeletion(pOutputBufferInfo, VDMX_TAG);
		return errCode;
	}

	pUnCONSTInputBufferInfo = (TTFACC_FILEBUFFERINFO *)	pInputBufferInfo; /* used for Read functions ONLY. Not for Write */
/* get input buffer information */
 	ulSrcOffset = TTTableOffset( pUnCONSTInputBufferInfo, VDMX_TAG );
	if ( ulSrcOffset == 0L )
		return NO_ERROR;
  	ulSrcLength = TTTableLength( pUnCONSTInputBufferInfo, VDMX_TAG );
	if ( ulSrcLength == 0L )
	{
		MarkTableForDeletion(pOutputBufferInfo, VDMX_TAG);
		return NO_ERROR;
	}
 	/* get output buffer information */
 	ulDestOffset = *pulNewOutOffset + ZeroLongWordAlign(pOutputBufferInfo, *pulNewOutOffset);

	if ((errCode = ReadGeneric( pUnCONSTInputBufferInfo, (uint8 *) &Vdmx, SIZEOF_VDMX, VDMX_CONTROL, ulSrcOffset, &usBytesRead )) != NO_ERROR)
		return errCode;
	if (Vdmx.numRatios == 0)
	{
		MarkTableForDeletion(pOutputBufferInfo, VDMX_TAG);
		return NO_ERROR;
	}


	ulSrcOffsetRatios = ulSrcOffset + usBytesRead;
	ulSrcOffsetOffsets = ulSrcOffsetRatios + GetGenericSize(VDMXRATIO_CONTROL) * Vdmx.numRatios;
	ulSrcOffsetGroups = ulSrcOffsetOffsets + sizeof(uint16) * Vdmx.numRatios;
	memset(&keeper, 0, sizeof(keeper));

	SrcRatioArray = Mem_Alloc(Vdmx.numRatios * sizeof(VDMXRatio));
	if (SrcRatioArray == NULL)
		errCode = ERR_MEM;
	else
	{
		KeepSrcRatioArray = Mem_Alloc(Vdmx.numRatios * sizeof(uint8));
 		if (KeepSrcRatioArray == NULL)
			errCode = ERR_MEM;
		else
			errCode = ReadGenericRepeat(pUnCONSTInputBufferInfo, (uint8 *) SrcRatioArray, VDMXRATIO_CONTROL, ulSrcOffsetRatios, &ulBytesRead, Vdmx.numRatios, SIZEOF_VDMXRATIO );
	}

	while (errCode == NO_ERROR)		/* while is so we can break out. Only go once through */
	{
		Found1to1 = FALSE;
		for (i = 0; i < Vdmx.numRatios ; ++i)	 /* keep all 1:1 aspect ratios */
		{
			KeepSrcRatioArray[i] = 1; /* assume we'll keep it */
			xRatio = SrcRatioArray[i].xRatio;
			yRatio = SrcRatioArray[i].yStartRatio;
			ReduceRatio(&xRatio,&yRatio);
			if (xRatio == yRatio)
			{
				if (SrcRatioArray[i].xRatio == 0)	/* anything after 0:0 is ignored */
				{
					if (!Found1to1)	/* need to keep this one */
						++usKeepRatioCount;
					break;
				}
				if (Found1to1)	/* already have one */
					KeepSrcRatioArray[i] = 0;  /* don't keep this one */
				else
				{
					Found1to1 = TRUE;
					++usKeepRatioCount;
				}
			}
			else if (xRatio == EGA_X_RATIO && yRatio == EGA_Y_RATIO)
				KeepSrcRatioArray[i] = 0;  /* don't keep this one */
			else
				++usKeepRatioCount;
		}

		if ((usKeepRatioCount == 0) || (usKeepRatioCount == Vdmx.numRatios))
		{						/* don't change a thing */
			Mem_Free(SrcRatioArray);
			Mem_Free(KeepSrcRatioArray);
			return CopyTableOver(pOutputBufferInfo, pInputBufferInfo, VDMX_TAG, pulNewOutOffset);
		}
		ulDestOffsetRatios = ulDestOffset + usBytesRead;
		/* figure out offset for the Offset array */
		ulDestOffsetOffsets = ulDestOffsetRatios + GetGenericSize(VDMXRATIO_CONTROL) * usKeepRatioCount;
		ulDestOffsetGroups = ulDestOffsetOffsets + sizeof(uint16) * usKeepRatioCount;
		usRatioSize = GetGenericSize(VDMXRATIO_CONTROL);
		ulCurrGroupDestOffset = ulDestOffsetGroups - ulDestOffset; /* calculate offset from start of VDMX table */
		if ((errCode = InitGroupOffsetArray(&keeper,usKeepRatioCount)) != NO_ERROR)  /* initialize structure to track offset re-use */ 
			break;
		ulGroupBufferLength = ulSrcLength - (ulSrcOffsetGroups - ulSrcOffset);	/* calculate the length of the group section */
		pGroupBuffer = Mem_Alloc(ulGroupBufferLength); /* allocate buffer the size of the group buffer */
		if (pGroupBuffer == NULL)
		{
			errCode = ERR_MEM;
			break;
		}
		
		for (usSrcRatioIndex = usDestRatioIndex = 0; usSrcRatioIndex < Vdmx.numRatios && usDestRatioIndex < usKeepRatioCount; ++usSrcRatioIndex)	 /* keep all 1:1 aspect ratios */
		{
			if (KeepSrcRatioArray[usSrcRatioIndex] == 1)
			{
				/* write out the Ratio to the proper location */
				if ((errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &(SrcRatioArray[usSrcRatioIndex]), SIZEOF_VDMXRATIO, VDMXRATIO_CONTROL, ulDestOffsetRatios + (usDestRatioIndex * usRatioSize), &usBytesWritten)) != NO_ERROR)
					break;
				/* now read the offset to the group */
				if ((errCode = ReadWord(pUnCONSTInputBufferInfo, &usCurrGroupSrcOffset, ulSrcOffsetOffsets + (usSrcRatioIndex * sizeof(uint16)) )) != NO_ERROR)
					break;
				/* check if offset already used */
				if ((usGroupDestOffset = LookupGroupOffset(&keeper, usCurrGroupSrcOffset)) == 0)  /* not there already */
				{
					if (ulCurrGroupDestOffset > USHRT_MAX)	/* check if will fit in unsigned short */
					{
						errCode = ERR_INVALID_VDMX;
						break;
					}
					usCurrGroupDestOffset = (uint16) ulCurrGroupDestOffset;	 /* already checked if in range */
					/* need to register the old and new group offsets */
					if ((errCode = RecordGroupOffset(&keeper, usCurrGroupSrcOffset, usCurrGroupDestOffset)) != NO_ERROR)
						break;

					usGroupDestOffset = usCurrGroupDestOffset;
					/* need to copy the group data over */
					if ((errCode = ReadGeneric(pUnCONSTInputBufferInfo, (uint8 *) &GroupHeader, SIZEOF_VDMXGROUP, VDMXGROUP_CONTROL, ulSrcOffset + usCurrGroupSrcOffset, &usBytesRead)) != NO_ERROR)
						break;
 
					ulGroupLength =  usBytesRead + (GroupHeader.recs * GetGenericSize(VDMXVTABLE_CONTROL));
					/* read the group data into a buffer */
					if (ulGroupLength > ulGroupBufferLength)
					{
						errCode = ERR_INVALID_VDMX; /* error in data! */
						break;
					}
					if ((errCode = ReadBytes(pUnCONSTInputBufferInfo, (uint8 *) pGroupBuffer, ulSrcOffset + usCurrGroupSrcOffset, ulGroupLength)) != NO_ERROR)
						break;
					/* and write them to the output buffer */
					if ((errCode = WriteBytes(pOutputBufferInfo, (uint8 *) pGroupBuffer, ulDestOffset + usCurrGroupDestOffset, ulGroupLength)) != NO_ERROR)
						break;
					++usGroupCount;
					/* increment our CurrGroupDestOffset value for next time around */
					ulCurrGroupDestOffset = usCurrGroupDestOffset + ulGroupLength;
				}
				/* now write out that relative offset value */
				if ((errCode = WriteWord(pOutputBufferInfo, usGroupDestOffset, ulDestOffsetOffsets + (usDestRatioIndex * sizeof(uint16)))) != NO_ERROR)
					break;

				++usDestRatioIndex; /* increment in dest array */
			}
		}
		break; /* out of while */
	}
	if (errCode == NO_ERROR)
	{
		Vdmx.numRatios = usKeepRatioCount;
		Vdmx.numRecs = usGroupCount;
		errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &Vdmx, SIZEOF_VDMX, VDMX_CONTROL, ulDestOffset, &usBytesWritten );
	}
	
	if (errCode == NO_ERROR)
	{
		ulDestLength = ulCurrGroupDestOffset; /* this is the size of the table */
		errCode = UpdateDirEntryAll( pOutputBufferInfo, VDMX_TAG, ulDestLength, ulDestOffset );
		*pulNewOutOffset = ulDestOffset + ulDestLength;
	}
 
 	FreeGroupOffsetArray(&keeper);  /* free up structure to track offset re-use */ 

 	Mem_Free(pGroupBuffer);

	Mem_Free(KeepSrcRatioArray);
	Mem_Free(SrcRatioArray);
	return errCode;
}

/* ------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\mtxcalc.h ===
/***************************************************************************
 * module: MTXCALC.H
 *
 * author: Steve McConnell [a-stevem]
 * date:   26 September 1990
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * Function prototypes for MTXCALC.C.
 *
 **************************************************************************/

#ifndef MTXCALC_DOT_H_DEFINED
#define MTXCALC_DOT_H_DEFINED

/* macro definitions ---------------------------------------------------- */

/* function prototypes -------------------------------------------------- */

int16 ComputeMaxPStats( TTFACC_FILEBUFFERINFO * pInputBufferInfo,
					    uint16 *  pusMaxContours,
						uint16 *  pusMaxPoints,
						uint16 *  pusMaxCompositeContours,
						uint16 *  pusMaxCompositePoints,
						uint16 *  pusMaxInstructions,
						uint16 *  pusMaxComponentElements,
						uint16 *  pusMaxComponentDepth,
						uint16 *  pausComponents, 
						uint16 usnMaxComponents);

#endif /* MTXCALC_DOT_H_DEFINED	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\readff.h ===
/*
  * ReadFF.h: Interface file for ReadFF.c -- Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  * This file must be included in order to use the access functions for the Read Format File module.
  *
  */
  
#ifndef READFF_DOT_H_DEFINED
#define READFF_DOT_H_DEFINED

/* Must include <stdio.h> for FILE definition */
/* must include "ttostruc.h" for PSTRUCTURE_DEF definition */ 

int16 CreateFFStructureTable(PSTRUCTURE_LIST pStructureList, char **pFileArray );
/* CreateFFStructureTable( pStructureList)
  *  
  * pStructureList
  *   a pointer to the Structure Definition List
  *	  to be filled in.
  *
  * pFileArray
  *   pointer to string buffer containing text data for format file
  * 
  * RETURN VALUE
  * 0 on success
  * other values - Error
  */

void DestroyFFStructureTable(PSTRUCTURE_LIST, uint16);
/* DestroyFFStructureTable(pStructureTable, exit);
  *
  * pStructureTable -- INPUT
  *   a pointer returned by CreateFFStructureTable
  * exit -- INPUT
  *   release the keyword symbol table too? 
  */

#endif /*  READFF_DOT_H_DEFINED  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\readff.c ===
/**************************************************************************
 * module: READFF.C
 *
 * author: Louise Pathe
 * date:   October 1994
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * module for reading TrueType Open Format Description data for ttfsub.lib
 *
 **************************************************************************/

/* Inclusions ----------------------------------------------------------- */

#include <stdlib.h>
#include <stdio.h> 
#include <ctype.h>  
#include <string.h>
#include <limits.h>

#include "typedefs.h" 
#include "ttofile.h"
#include "ttoerror.h"
#include "ttostruc.h"
#include "symbol.h"
#include "ttmem.h"
#include "readff.h"
#include "ttoutil.h"
#include "ttferror.h" /* for error codes */
#ifdef _DEBUG
#include "util.h"
#endif
                       
/* Local Macro Defines  ----------------------------------------------------------- */

#define FFErr -1
#define FFNoErr 0

#define NULL_TOK_VAL 0
#define NEGNULL_TOK_VAL	 0xFFFF
#define INVALID_COUNT -1
#define INVALID_TOKEN_COUNT -1
                       
#define BEGIN_STRUC_CHAR '{'
#define END_STRUC_CHAR '}' 

#define FFFieldTypeCount 1  /* Flags for when parsing arithmetic string with functions */
#define FFFieldTypeLimit 2 
#define FFFieldTypeConfig 3

#define KeywordTypeStrucType 1
#define KeywordValueHEAD StrucTypeHEAD     /* StrucTypeX from ttostruc.h */
#define KeywordValueTABLE StrucTypeTABLE
#define KeywordValueRECORD StrucTypeRECORD
#define KeywordValueCLASS StrucTypeCLASS 
#define SymbolConstantType	5

#define KeywordTypeValue 2 
#define KeywordValueNULL 1
#define KeywordValueNOTNULL 2
#define KeywordValueNEGNULL 3 

#define KeywordTypeFunction 3
#define KeywordValueBitCount0F CalcFuncBitCount0F
#define KeywordValueBitCountF0 CalcFuncBitCountF0
#define KeywordValueClassCount CalcFuncClassCount
#define KeywordValueCoverageCount CalcFuncCoverageCount
#define KeywordValueCheckRangeRecord CalcFuncCheckRangeRecord 

#define KeywordTypeElementPrimitive 4
#define KeywordValueUint8 ETuint8	
#define KeywordValueInt8 ETint8
#define KeywordValueUint16 ETuint16
#define KeywordValueInt16 ETint16
#define KeywordValueUint32 ETint32 /* we do this because we can't store a uint32 without confusing it with an int32 */
#define KeywordValueInt32 ETint32
#define KeywordValueFixed32 ETfixed32
#define KeywordValueTag ETTag
#define KeywordValueGlyphID ETGlyphID  
#define KeywordValueGSUBLookupIndex ETGSUBLookupIndex
#define KeywordValueGSUBFeatureIndex ETGSUBFeatureIndex
#define KeywordValueGPOSLookupIndex ETGPOSLookupIndex
#define KeywordValueGPOSFeatureIndex ETGPOSFeatureIndex
#define KeywordValueCount ETCount

#define KeywordTypeElementOffset 5
#define KeywordValueOffset ETTableOffset    

#define KeywordTypeElementArray 6
#define KeywordValueArray ETArray  

#define KeywordTypeElementPacked 7  /* only used with arrays */                                 
#define KeywordValuePackedInt2 ETPackedInt2
#define KeywordValuePackedInt4 ETPackedInt4
#define KeywordValuePackedInt8 ETPackedInt8
                                 
#define KeywordTypeDefine 8 
#define KeywordValueDefine 1 

#define KeywordTypeMinMax 9 
#define KeywordValueMINGLYPHID MMMinGIndex      
#define KeywordValueMAXGLYPHID MMMaxGIndex
#define KeywordValueMINLOOKUPCOUNT MMMinLIndex
#define KeywordValueMAXLOOKUPCOUNT MMMaxLIndex
#define KeywordValueMINFEATURECOUNT MMMinFIndex
#define KeywordValueMAXFEATURECOUNT MMMaxFIndex 

#define DELIMIT_CONFIG_INFO_CHAR ':'

#define KeywordTypeConfigValue 11

#define KeywordValueDelNone ConfigDelNone                             
#define KeywordValueIGSUBLookupIndex ConfigIGSUBLookupIndex
#define KeywordValueIGSUBFeatureIndex ConfigIGSUBFeatureIndex
#define KeywordValueIGPOSLookupIndex ConfigIGPOSLookupIndex
#define KeywordValueIGPOSFeatureIndex ConfigIGPOSFeatureIndex


/* The following strings are used to set up the Keyword Symbol Table */
/* most are not accessed elsewhere in the code except define and uint32 and NOTNULL */
#define KeywordStringHEAD "HEAD"
#define KeywordStringTABLE "TABLE"
#define KeywordStringRECORD "RECORD"
#define KeywordStringCLASS "CLASS"
#define KeywordStringDefine SZDEFINE
#define KeywordStringNULL SZNULL
#define KeywordStringNOTNULL "NOTNULL"
#define KeywordStringNEGNULL SZNEGNULL
#define KeywordStringBitCount0F "BitCount0F"
#define KeywordStringBitCountF0 "BitCountF0"
#define KeywordStringClassCount "ClassCount"
#define KeywordStringCoverageCount "CoverageCount"
#define KeywordStringCheckRangeRecord "CheckRangeRecord" 
#define KeywordStringUint8 "uint8"	
#define KeywordStringInt8 "int8"
#define KeywordStringUint16 "uint16"
#define KeywordStringInt16 "int16"
#define KeywordStringUint32 "uint32"
#define KeywordStringInt32 "int32"
#define KeywordStringFixed32 "fixed32"
#define KeywordStringTag "Tag"
#define KeywordStringOffset "Offset"
#define KeywordStringPackedInt2 "PackedInt2"
#define KeywordStringPackedInt4 "PackedInt4"
#define KeywordStringPackedInt8 "PackedInt8"
#define KeywordStringGlyphID "GlyphID"
#define KeywordStringGSUBLookupIndex "GSUBLookupIndex"
#define KeywordStringGSUBFeatureIndex "GSUBFeatureIndex"
#define KeywordStringGPOSLookupIndex "GPOSLookupIndex"
#define KeywordStringGPOSFeatureIndex "GPOSFeatureIndex"
#define KeywordStringCount "Count"
#define KeywordStringArray "Array" 
#define KeywordStringMINGLYPHID SZMINGLYPHID    
#define KeywordStringMAXGLYPHID SZMAXGLYPHID 
#define KeywordStringMINLOOKUPCOUNT SZMINLOOKUPCOUNT 
#define KeywordStringMAXLOOKUPCOUNT SZMAXLOOKUPCOUNT 
#define KeywordStringMINFEATURECOUNT SZMINFEATURECOUNT 
#define KeywordStringMAXFEATURECOUNT SZMAXFEATURECOUNT    

#define KeywordStringDelNone "DelNone"
#define KeywordStringIGSUBLookupIndex "$IGSUBLookupIndex"
#define KeywordStringIGSUBFeatureIndex "$IGSUBFeatureIndex"
#define KeywordStringIGPOSLookupIndex "$IGPOSLookupIndex"
#define KeywordStringIGPOSFeatureIndex "$IGPOSFeatureIndex"
	
/* These strings are used for symbolic element reference */
#define TableElementSymbolString "$T"   /* element index into Table */
#define RecordElementSymbolString "$R"  /* element index into record */
#define ParameterElementSymbolString "$P"  /* element index into Parameter list */
#define ByteElementSymbolString "$B" /* byte index into table */   
#define IndexElementSymbolString "$I" /* used in ffconfig index mapping */

#define TokenTypeSymbElement 1  /* used by arithmetic parser */
#define TokenTypeUint 2
#define TokenTypeOperation 3
#define TokenTypeFunction 4
#define TokenTypeMinMax 5  /* used for Global MINMAX defines */

#define TableElementToken SymbElementTypeTable 
#define RecordElementToken SymbElementTypeRecord
#define ParameterElementToken SymbElementTypeParameter 
#define ByteElementToken SymbElementTypeByte 
#define IndexElementToken SymbElementTypeIndex


/* Local Structure Defines  ----------------------------------------------------------- */

typedef struct keysymbol_data *PKEYSYMBOL_DATA;
typedef struct keysymbol_data KEYSYMBOL_DATA;
struct keysymbol_data {
	uint16 uKeyType;
	int32 lKeyValue;
};
                      

/* function definitions ------------------------------------------------- */    
/* ---------------------------------------------------------------------- */
/* Initialize the Keyword Symbol table with primitive keywords */
/* RETURN FFErr if AddSymbol failed - Out of Memory*/
/* Otherwise return FFNoErr */     
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFInitKeySymbolTable(PSYMBOL_TABLE pSymbolTable)
{  
KEYSYMBOL_DATA Symbol_Data;
/* change to initialize in alphabetic order */
    
    Symbol_Data.uKeyType = KeywordTypeStrucType;
    Symbol_Data.lKeyValue   = KeywordValueCLASS;
	if (AddSymbol(pSymbolTable, KeywordStringCLASS, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueHEAD;
	if (AddSymbol(pSymbolTable, KeywordStringHEAD, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueRECORD;
	if (AddSymbol(pSymbolTable, KeywordStringRECORD, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueTABLE;
	if (AddSymbol(pSymbolTable, KeywordStringTABLE, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
		
    Symbol_Data.uKeyType = KeywordTypeValue;
    Symbol_Data.lKeyValue   = KeywordValueNEGNULL;
	if (AddSymbol(pSymbolTable, KeywordStringNEGNULL, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueNOTNULL;
	if (AddSymbol(pSymbolTable, KeywordStringNOTNULL, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueNULL;
	if (AddSymbol(pSymbolTable, KeywordStringNULL, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
		
    Symbol_Data.uKeyType = KeywordTypeFunction;
    Symbol_Data.lKeyValue   = KeywordValueBitCount0F;
	if (AddSymbol(pSymbolTable, KeywordStringBitCount0F, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueBitCountF0;
	if (AddSymbol(pSymbolTable, KeywordStringBitCountF0, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueCheckRangeRecord;
	if (AddSymbol(pSymbolTable, KeywordStringCheckRangeRecord, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);   
    Symbol_Data.lKeyValue   = KeywordValueClassCount;
	if (AddSymbol(pSymbolTable, KeywordStringClassCount, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueCoverageCount;
	if (AddSymbol(pSymbolTable, KeywordStringCoverageCount, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
		
    Symbol_Data.uKeyType = KeywordTypeElementPrimitive;
    Symbol_Data.lKeyValue   = KeywordValueUint8;
	if (AddSymbol(pSymbolTable, KeywordStringUint8, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueInt8;
	if (AddSymbol(pSymbolTable, KeywordStringInt8, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueUint16;
	if (AddSymbol(pSymbolTable, KeywordStringUint16, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueInt16;
	if (AddSymbol(pSymbolTable, KeywordStringInt16, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueUint32;
	if (AddSymbol(pSymbolTable, KeywordStringUint32, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueInt32;
	if (AddSymbol(pSymbolTable, KeywordStringInt32, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueFixed32;
	if (AddSymbol(pSymbolTable, KeywordStringFixed32, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueTag;
	if (AddSymbol(pSymbolTable, KeywordStringTag, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueGlyphID;
	if (AddSymbol(pSymbolTable, KeywordStringGlyphID, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueGSUBLookupIndex;
	if (AddSymbol(pSymbolTable, KeywordStringGSUBLookupIndex, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueGSUBFeatureIndex;
	if (AddSymbol(pSymbolTable, KeywordStringGSUBFeatureIndex, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueGPOSLookupIndex;
	if (AddSymbol(pSymbolTable, KeywordStringGPOSLookupIndex, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueGPOSFeatureIndex;
	if (AddSymbol(pSymbolTable, KeywordStringGPOSFeatureIndex, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueCount;
	if (AddSymbol(pSymbolTable, KeywordStringCount, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);

    Symbol_Data.uKeyType = KeywordTypeElementOffset;
    Symbol_Data.lKeyValue   = KeywordValueOffset;
	if (AddSymbol(pSymbolTable, KeywordStringOffset, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);

    Symbol_Data.uKeyType = KeywordTypeElementArray;
    Symbol_Data.lKeyValue   = KeywordValueArray;
	if (AddSymbol(pSymbolTable, KeywordStringArray, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
		
    Symbol_Data.uKeyType = KeywordTypeElementPacked;  /* used with arrays */
    Symbol_Data.lKeyValue   = KeywordValuePackedInt2;
	if (AddSymbol(pSymbolTable, KeywordStringPackedInt2, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValuePackedInt4;
	if (AddSymbol(pSymbolTable, KeywordStringPackedInt4, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValuePackedInt8;
	if (AddSymbol(pSymbolTable, KeywordStringPackedInt8, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);

    Symbol_Data.uKeyType = KeywordTypeDefine;
    Symbol_Data.lKeyValue   = KeywordValueDefine;
	if (AddSymbol(pSymbolTable, KeywordStringDefine, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);

    Symbol_Data.uKeyType = KeywordTypeMinMax;
    Symbol_Data.lKeyValue   = KeywordValueMINGLYPHID;
	if (AddSymbol(pSymbolTable, KeywordStringMINGLYPHID, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueMAXGLYPHID;
	if (AddSymbol(pSymbolTable, KeywordStringMAXGLYPHID, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueMINLOOKUPCOUNT;
	if (AddSymbol(pSymbolTable, KeywordStringMINLOOKUPCOUNT, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueMAXLOOKUPCOUNT;
	if (AddSymbol(pSymbolTable, KeywordStringMAXLOOKUPCOUNT, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueMINFEATURECOUNT;
	if (AddSymbol(pSymbolTable, KeywordStringMINFEATURECOUNT, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueMAXFEATURECOUNT;
	if (AddSymbol(pSymbolTable, KeywordStringMAXFEATURECOUNT, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);

	/* now add special ffconfig strings - used only by ffconfig, but read anyway */
   	Symbol_Data.uKeyType = KeywordTypeConfigValue;
    Symbol_Data.lKeyValue   = KeywordValueDelNone;
	if (AddSymbol(pSymbolTable, KeywordStringDelNone, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueIGSUBLookupIndex;
	if (AddSymbol(pSymbolTable, KeywordStringIGSUBLookupIndex, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueIGSUBFeatureIndex;
	if (AddSymbol(pSymbolTable, KeywordStringIGSUBFeatureIndex, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueIGPOSLookupIndex;
	if (AddSymbol(pSymbolTable, KeywordStringIGPOSLookupIndex, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);
    Symbol_Data.lKeyValue   = KeywordValueIGPOSFeatureIndex;
	if (AddSymbol(pSymbolTable, KeywordStringIGPOSFeatureIndex, 0, &Symbol_Data) != SymNoErr)
		return(FFErr);

	return(FFNoErr);
}
 
/* ---------------------------------------------------------------------- */    
/* buzz through file, reading each line looking for the EndStruc character */
/* RETURN number of lines read if successful, 0 if not successful */
/* ---------------------------------------------------------------------- */
PRIVATE uint16 FFFindEndStruc(char * CONST szBuffer, char **pFileArray, int16 cLineNumber) 
{
int16 cLinesRead = 0; 
int16 iBufferIndex;
BOOL Done = FALSE;
BOOL bEOF = FALSE;

	while (!Done) 
	{
    	if (ReadTextLine(szBuffer, MAXBUFFERLEN, pFileArray, (int16) (cLineNumber+cLinesRead)) != FileNoErr) 
    	{ 
			bEOF = TRUE;    /* Don't care if EOF or File error, just want to get out of here */
			break; 
    	}    
		++cLinesRead;
        for (iBufferIndex = 0; *(szBuffer+iBufferIndex) != '\0'; ++iBufferIndex)
        {
           	if (*(szBuffer+iBufferIndex) == ';') /* comment - continue */
           		break;   
           	if (*(szBuffer+iBufferIndex) == END_STRUC_CHAR)
			{
           		Done = TRUE;    
           		break;
           	}
        }
    } 
    if (bEOF == TRUE)
    	return(0);
    return(cLinesRead);

}

/* ---------------------------------------------------------------------- */  
/* Scan a line looking for a particular character */
/* RETURN index into buffer where character is, INVALID_COUNT otherwise */  
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFFindExpectChar(char * CONST szBuffer, char theChar)
{
int16 iBufferIndex = 0;
int16 iWordIndex = 0;

	while ( (*(szBuffer + iBufferIndex) != '\0') && (*(szBuffer + iBufferIndex) != theChar))   
      	++iBufferIndex; 
    if  (*(szBuffer + iBufferIndex) == '\0')    /* didn't find the character*/
    	return (INVALID_COUNT);
    else
    	return(iBufferIndex);  

}
/* ---------------------------------------------------------------------- */    
/* copy a word from szBuffer to szWord buffer. A word is defined as ending at */
/* a '{', '}', ',', ';', ':' or EndChar (for example ' ' or '='.) */   
/* RETURN index into szBuffer where word ended */
/* fill szWord with characters and end with '\0' */  
/* This function, unlike SDF GetWord, ends at a newline */ 
/* If a ':' is encountered, and EndChar is not a ':' the function will not*/
/* advance past the ':' until the ':' is requested */
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFGetWord(char * CONST szBuffer, char *szWord, char EndChar)
{
int16 iBufferIndex = 0;
int16 iWordIndex = 0;
    
	while ( (*(szBuffer + iBufferIndex) != '\0') && isspace((int16) *(szBuffer + iBufferIndex))) /* move past white space */
      	++iBufferIndex;        
    while ( (*(szBuffer + iBufferIndex) != BEGIN_STRUC_CHAR) &&
    		(*(szBuffer + iBufferIndex) != END_STRUC_CHAR) &&  
    		(*(szBuffer + iBufferIndex) != DELIMIT_CONFIG_INFO_CHAR) &&
    		(*(szBuffer + iBufferIndex) != '\0') &&
    		(*(szBuffer + iBufferIndex) != ',') &&
    		(*(szBuffer + iBufferIndex) != ';') &&
    		(*(szBuffer + iBufferIndex) != EndChar)) 
    {
    	if (!isspace((int16) *(szBuffer + iBufferIndex)))   /* compactify */
       	   *(szWord + iWordIndex++) = *(szBuffer + iBufferIndex); 
       	++iBufferIndex;
    }  
    if (*(szBuffer + iBufferIndex) == DELIMIT_CONFIG_INFO_CHAR)
    {
     	if (EndChar == DELIMIT_CONFIG_INFO_CHAR)
     		++iBufferIndex; /* move past it, the caller is ready for it */  
     	/* if the caller isn't ready, don't move past it, stay here for next call */
    }
    else if  (*(szBuffer + iBufferIndex) == ',')  
    	++iBufferIndex; /* move past it */  
    else if (*(szBuffer + iBufferIndex) == END_STRUC_CHAR) 
    	; /* do nothing, */
    else if (iWordIndex == 0) /* comment, empty line or just spaces left. Be done with this line */
    	return INVALID_COUNT; /* lie */ 
    *(szWord + iWordIndex) = '\0';  /* terminate it */
	return iBufferIndex;    
}

/* ---------------------------------------------------------------------- */    
/* Perform Pass1 of ReadFormatFile module - Gather up Structure definition */
/* Symbols and add them to the Format File Symbol Table */
/* RETURN number of structures found in file, or 0 if error*/
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFPass1(int16 * piHeadIndex, PSYMBOL_TABLE pKeySymbolTable, PSYMBOL_TABLE pSymbolTable, char **pFileArray )      
{
struct keysymbol_data KeySymbolData; /* structure to hold data for Structure Definiton Keyword Symbols */
struct ffsymbol_data FFSymbolData;   /* structure to hold type data for Structure types */
BOOL Done;  
BOOL bEOF;
uint16 iBufferIndex; 
int16 cWordCount;
uint16 cNewLineNumber;
int16 iStructureIndex; 
int16 ErrorCode;
char szBuffer[MAXBUFFERLEN];
char szStrucDef[MAXBUFFERLEN];   
char szType[MAXBUFFERLEN];  
int16 cLineNumber; 

    cLineNumber = 0;
    *piHeadIndex = 0;
    iStructureIndex = INVALID_COUNT;                                
	Done = FALSE;  
	bEOF = FALSE;   
    
/* Pass 1 - Scan for all the structure definition names and enter into the Symbol table */
    while (!bEOF)  /* Process Pass1 through file */	
    {              
		while (!Done)   /* Until we find a structure definition */
		{
			iBufferIndex = 0; 
	    	ErrorCode = ReadTextLine(szBuffer, MAXBUFFERLEN, pFileArray, cLineNumber);
	    	if (ErrorCode == FileEOF)
	    	{  
				bEOF = TRUE; 
				break;
	    	}
	    	else if (ErrorCode == FileErr)
	    	{
#ifdef _DEBUG  
				Error("File Error Reading File.", cLineNumber, 0);
#endif
				return 0;
			}    
			++cLineNumber;
		    /* read text to find Structure Def and Type */
			while ((cWordCount = FFGetWord(szBuffer+iBufferIndex, szStrucDef, '=')) >= 0)  /* grab a word from the buffer */
			{  /* This is a One shot While for easy breaking */  
				iBufferIndex += cWordCount;  /* increment Buffer index */   
				if (*(szBuffer+iBufferIndex) == '=')   /* we may have a #define line, skip for now */
					break;
	    					    				
	            if ((cWordCount = FFGetWord(szBuffer+iBufferIndex, szType, BEGIN_STRUC_CHAR)) <= 0)     /* error ! */
	            {
#ifdef _DEBUG  
					sprintf(g_szErrorBuf, "Missing Type after \"%s\" definition.", szStrucDef);
	                Error(g_szErrorBuf, cLineNumber, 0); 
#endif
					return 0;
				}
	            if ((GetSymbol(pKeySymbolTable, szType, 0, &KeySymbolData) == SymErr) || (KeySymbolData.uKeyType != KeywordTypeStrucType)) /* get type symbol */
	           	{
#ifdef _DEBUG  
					sprintf(g_szErrorBuf, "Type \"%s\" not recognized for \"%s\" definition.", szType, szStrucDef);
	                Error(g_szErrorBuf, cLineNumber, 0);
#endif
					return 0;
	            } 
#ifdef _DEBUG  /*  only skip for pretested Format Files*/
				if (GetSymbol(pSymbolTable, szStrucDef, 0, &FFSymbolData) != SymErr)  /* Check if already defined */
	            {
#ifdef _DEBUG
					sprintf(g_szErrorBuf, "Structure \"%s\" defined twice.", szStrucDef);
	                Error(g_szErrorBuf, cLineNumber, 0);
#endif
					return 0; 
	            }
#endif
	            FFSymbolData.uSymbolType = (uint16) KeySymbolData.lKeyValue;  /* The value from the keyword symbol = the structure Type value */
	            FFSymbolData.iStructureIndex = ++iStructureIndex;
	            if (AddSymbol(pSymbolTable, szStrucDef, 0, &FFSymbolData) != SymNoErr)  /* add symbol to symbol table */
	           	{
#ifdef _DEBUG  
	                Error("Out of Memory or other error while defining structure", cLineNumber, 0);
#endif
					return 0;
				} 
	            if (KeySymbolData.lKeyValue == KeywordValueHEAD)
	            	*piHeadIndex = FFSymbolData.iStructureIndex;  /* keep for disassembler to use */
	            Done = TRUE; 
	            break;
	        }
		}
		 /* now buzz on through until we find the end structure character */
		if (!bEOF) 
		{
			cNewLineNumber = FFFindEndStruc(szBuffer,pFileArray,cLineNumber);
			if (cNewLineNumber == 0)     /* couldn't find end structure */
	       	{
#ifdef _DEBUG  
				sprintf(g_szErrorBuf, "No End structure character \'%c\' for structure \"%s\".", END_STRUC_CHAR, szStrucDef);
	            Error(g_szErrorBuf, cLineNumber, 0);
#endif
				return 0;
	        } 
			cLineNumber+=cNewLineNumber;
			Done = FALSE; /* go to next structure */	 
		}
    }
#ifdef _DEBUG
	DebugMsg("Finished function FFPass1", "", cLineNumber);
#endif
#if 0
	PrintSymbolTable(pKeySymbolTable);
	PrintSymbolTable(pSymbolTable);
#endif      
	return((int16)(iStructureIndex+1));
} 
/* ---------------------------------------------------------------------- */   
/* Used By Pass2 - Parse and process an input line for Structure Definition */ 
/* RETURNS FFErr or number of parameters */
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFProcessStructureLine(char * CONST szBuffer, PSYMBOL_TABLE pSymbolTable, PFFSYMBOL_DATA pFFSymbolData, PSTRUCTURE_DEF CONST pStructure)
{   
uint16 iBufferIndex = 0; 
int16 cWordCount;
char szStrucDef[MAXBUFFERLEN];   
char szWord[MAXBUFFERLEN];   
            
	if ((cWordCount = FFGetWord(szBuffer+iBufferIndex, szStrucDef, '\0')) == INVALID_COUNT)  /* grab a word from the buffer */ 
	{
#ifdef _DEBUG
        Error("Expecting structure definition.", 0, FFErr);
#endif
		return FFErr;
	}

	iBufferIndex += cWordCount;  /* increment Buffer index */  	        				
    if ((GetSymbol(pSymbolTable, szStrucDef, 0, pFFSymbolData) == SymErr)) /* get type symbol */
   	{  
       
#ifdef _DEBUG
		sprintf(g_szErrorBuf,"Internal! Symbol \"%s\" not found in Symbol Table.",szStrucDef);
        Error(g_szErrorBuf, 0, FFErr);
#endif
		return FFErr;
    }

    /* read type */
    if ((cWordCount = FFGetWord(szBuffer+iBufferIndex, szWord, BEGIN_STRUC_CHAR)) <= 0)     /* error ! */
	{
#ifdef _DEBUG
        Error("Internal! Format File Pass2 not aligned with Pass1.", 0, FFErr);
#endif
		return FFErr;
	}
	iBufferIndex += cWordCount;  /* increment Buffer index */   
    /* Process Parameters if any */
    if ((cWordCount = FFGetWord(szBuffer+iBufferIndex, szWord, BEGIN_STRUC_CHAR)) <= 0)     /* No Parameters */
    	pStructure->cParameters = 0;
    else 
    {    
        if ((pStructure->cParameters = (uint16) atoi(szWord)) > MaxParameterCount)
        {                                                
#ifdef _DEBUG  
			sprintf(g_szErrorBuf,"Too many parameters specified for structure \"%s\". Specified %d, max is %d.", szStrucDef, pStructure->cParameters, MaxParameterCount);
			Error(g_szErrorBuf, 0, FFErr);
#endif
 	return FFErr;
       }  
		iBufferIndex += cWordCount;  /* increment Buffer index */  
    	if ((cWordCount = FFGetWord(szBuffer+iBufferIndex, szWord, BEGIN_STRUC_CHAR)) <= 0)     /* No Parameters */
    		pStructure->iElementIndex = 0; 
    	else 
    	{
    		if (strncmp(szWord,ParameterElementSymbolString,2) == 0) 
				pStructure->uSymbElementType = SymbElementTypeParameter;	
			else if (strncmp(szWord,ByteElementSymbolString,2) == 0)
				pStructure->uSymbElementType = SymbElementTypeByte;	
			else
			{
			 	
#ifdef _DEBUG  
				sprintf(g_szErrorBuf,"Invalid Class Identifier Element string \"%s\"",szWord);
			 	Error(g_szErrorBuf, 0, FFErr);
#endif
				return FFErr;
			}
    		pStructure->iElementIndex = (uint16) atoi(szWord+2); 
    	}
	} 
	if (FFFindExpectChar(szBuffer+iBufferIndex, BEGIN_STRUC_CHAR) < 0)
	{
	  	
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"Missing Structure Begin character \'%c\' for structure %d.", BEGIN_STRUC_CHAR, szStrucDef);
	  	Error(g_szErrorBuf, 0, FFErr);
#endif
		return FFErr;
	} 
	return(FFNoErr);

}     
/* ---------------------------------------------------------------------- */    
/* Parse and process an input text line containing a Constant Definition */
/* RETURN FFErr or FFNoErr */
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFProcessConstantLine(char * CONST szBuffer, PSYMBOL_TABLE pKeySymbolTable)
{
int16 iBufferIndex = 0;
int16 cWordCount; 
char szWord[MAXBUFFERLEN]; 
char szNumber[MAXBUFFERLEN]; 
KEYSYMBOL_DATA KeySymbolData;

	if ((cWordCount = FFGetWord(szBuffer+iBufferIndex, szWord, ' ')) <= 0)  /* grab a word from the buffer up to the space */
	{
#ifdef _DEBUG
	    Error("Syntax error.", 0, FFErr);
#endif
		return FFErr;
	}

	if ((GetSymbol(pKeySymbolTable, szWord, 0, &KeySymbolData) == SymErr) || 
		(KeySymbolData.uKeyType != KeywordTypeDefine) )	/* Check if valid */
  	{
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"Expecting \"%d\" on line with '='.", KeywordStringDefine);
  		Error(g_szErrorBuf, 0, FFErr);
#endif
 		return FFErr;
 	} 
  	iBufferIndex += cWordCount;
	if ((cWordCount = FFGetWord(szBuffer+iBufferIndex, szWord, '=')) <= 0)  /* grab a word from the buffer up to the = */
	{
#ifdef _DEBUG
	    Error("Syntax error. Expecting \'=\'",0, FFErr);
#endif
		return FFErr;
	}

  	iBufferIndex += (int16) (cWordCount+1); /* increment past the '=' */
	if ((cWordCount = FFGetWord(szBuffer+iBufferIndex, szNumber, ' ')) <= 0)  /* grab a word from the buffer up to the end */
  	{      
  	
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"Syntax error. Expecting value after \'%s=\'", KeywordStringDefine); 
	    Error(g_szErrorBuf, 0, FFErr);
#endif
		return FFErr;
	}

	iBufferIndex += cWordCount;
	if (GetSymbol(pKeySymbolTable, szWord, 0, &KeySymbolData) == SymNoErr) 
	{
	 	
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"\"%s\" defined twice.", szWord);
	 	Error(g_szErrorBuf,0, FFErr);
#endif
		return FFErr;

	} 
	if (ConvertNumber(szNumber,&(KeySymbolData.lKeyValue), 0 ) == INVALID_NUMBER_STRING) /* Note: no tag strings allowed */
	{
#ifdef _DEBUG  
	    Error("Syntax error. Invalid number format.", 0, FFErr);	  
#endif
		return FFErr;
	}

    KeySymbolData.uKeyType = KeywordTypeDefine;

	if (AddSymbol(pKeySymbolTable, szWord, 0, &KeySymbolData) != SymNoErr) 
	{
	 	
#ifdef _DEBUG
		sprintf(g_szErrorBuf,"Out of memory or other error while defining %d.", szWord);
	 	Error(g_szErrorBuf,0, FFErr);
#endif
		return FFErr;
	}   
	CheckLineClear(szBuffer+iBufferIndex, 0 );
  	return(FFNoErr);
}
/* ---------------------------------------------------------------------- */
/* Parse and process an Element line for a CLASS structure */    
/* RETURN FFErr or FFNoErr */
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFProcessClassElementLine(char * CONST szBuffer,PSTRUCTURE_DEF CONST pStructure, PELEMENT_LIST * ppCurrElement,  PSYMBOL_TABLE pSymbolTable)
{
FFSYMBOL_DATA FFSymbolData;
PELEMENT_LIST pElement;
uint16 iBufferIndex = 0; 
int16 cWordCount;   
char szWord[MAXBUFFERLEN]; 

	if ((cWordCount = FFGetWord(szBuffer, szWord, '\0')) == INVALID_COUNT)  /* grab a word from the buffer */ 
		return(FFNoErr);	/* empty line or comment */
	  
	iBufferIndex += cWordCount;  /* increment Buffer index */  	    		/* Otherwise its a structure def - check that it exists and read type */			    				
    if (*(szBuffer + iBufferIndex) == END_STRUC_CHAR)  /* no more elements */
    {
       *ppCurrElement = NULL;  
       return(FFNoErr);
    }     
	if ((GetSymbol(pSymbolTable, szWord, 0, &FFSymbolData) == SymErr)) /* get primitive symbol */   
	{
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"Unknown Class Element Type \"%s\".",szWord);
		Error(g_szErrorBuf,0, FFErr);
#endif
		return FFErr;
	} 
  	else if ((FFSymbolData.uSymbolType != StrucTypeTABLE) &&
  			 (FFSymbolData.uSymbolType != StrucTypeCLASS)) 
  	{
  		
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"Invalid Class Member of structure \"%s\". Must be TABLE or CLASS", szWord);
  		Error(g_szErrorBuf, 0, FFErr);
#endif
		return FFErr;
  	}
    if ((pElement = (PELEMENT_LIST) Mem_Alloc(sizeof(*pElement))) == NULL)
  	{
#ifdef _DEBUG  
      	Error("Out of Memory for CLASS structure element.", 0, FFErr);
#endif
		return FFErr;
  	}

    if (pStructure->pFirst == NULL)
    	pStructure->pFirst = pElement;
    else
    	(*ppCurrElement)->pNext = pElement;
    *ppCurrElement = pElement;  /* change this value */  
    pElement->uType = ETClassMember; 
    pElement->iStructureIndex = FFSymbolData.iStructureIndex; /* the structure that is a member */ 
    /* pointers already Nulled by memory manager */ 
    return(FFNoErr);
}
/* ---------------------------------------------------------------------- */
PRIVATE void Free_ParamList(PPARAM_LIST pParamList)
{
PPARAM_LIST pNextParamList;

	while (pParamList != NULL)
	{
	 	pNextParamList = pParamList->pNext;
	 	Mem_Free(pParamList);
	 	pParamList = pNextParamList;	
	}	
}
/* ---------------------------------------------------------------------- */
/* recursive ! */
PRIVATE void Free_CalcList(PCALC_LIST pCalcList)
{
PCALC_LIST pNextCalcList;

	while (pCalcList != NULL)
	{
	 	Free_CalcList(pCalcList->pFunctionList); 
	 	pNextCalcList = pCalcList->pNext;
	 	Mem_Free(pCalcList);
	 	pCalcList = pNextCalcList;	
	}	

}


/* ---------------------------------------------------------------------- */  
/* Parse and process a RANGE field for an Offset element */  
/* RETURN FFErr or FFNoErr */
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFProcessRange(char * CONST szWord,PCALC_LIST *ppCalcList1,PCALC_LIST *ppCalcList2, PSYMBOL_TABLE pKeySymbolTable)
{
KEYSYMBOL_DATA  KeySymbolData;

	if ((GetSymbol(pKeySymbolTable, szWord, 0, &KeySymbolData) == SymErr) || 
		(KeySymbolData.uKeyType != KeywordTypeValue) )	/* Check if valid */
  	{
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"Unknown or invalid Offset Range \"%s\".", szWord);
  		Error(g_szErrorBuf, 0, FFErr);
#endif
		return FFErr;
	} 
  	if ((*ppCalcList1 = (PCALC_LIST) Mem_Alloc(sizeof(**ppCalcList1)))==NULL)
  	{
#ifdef _DEBUG  
  		Error("Out of Memory while processing Offset Range.", 0, FFErr);
#endif
		return FFErr;
  	}

    if (KeySymbolData.lKeyValue == KeywordValueNEGNULL)   /* NULL taken care of by memory manager */
    {                            	
#ifdef _DEBUG  
		sprintf(g_szErrorBuf, "Invalid value \'%s\' specified for Offset Range.",szWord);
       	Error(g_szErrorBuf, 0, FFErr);
#endif
		return FFErr;
	}
    else if (KeySymbolData.lKeyValue  == KeywordValueNOTNULL)
    {  
       	(*ppCalcList1)->lValue = 1;  /* min value */
	  	if ((*ppCalcList2 = (PCALC_LIST) Mem_Alloc(sizeof(**ppCalcList2)))==NULL)
	  	{
	  		Mem_Free(*ppCalcList1);
	  		*ppCalcList1 = NULL;
#ifdef _DEBUG  
	  		Error("Out of Memory while processing NOTNULL Range", 0, FFErr);
#endif
			return FFErr;
	  	} 
       	(*ppCalcList2)->lValue = USHRT_MAX; /* max value  - ~ Platform dependant */
    }
    return(FFNoErr);
}
/* ---------------------------------------------------------------------- */ 
/* Parse and process a Parameter Field for an Offset Element */   
/* RETURN FFErr or FFNoErr */
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFProcessParameter(char * CONST szWord, PPARAM_LIST *ppParamList)
{
PPARAM_LIST pParamList; 
PPARAM_LIST pCurrParam = NULL; 
int16 Number;
	
	for (pParamList = *ppParamList; pParamList != NULL; pParamList = pParamList->pNext)
	  	pCurrParam = pParamList;

	if ((pParamList = (PPARAM_LIST) Mem_Alloc(sizeof(*pParamList))) == NULL)
	{
#ifdef _DEBUG
	 	Error("Out of Memory while processing parameters.",0, FFErr);
#endif
		return FFErr;
	}

	Number = (int16) atoi(szWord+2);  /* convert the string to integer */ 
	if ((strlen(szWord) <= 2) || (strlen(szWord) > 5) ||  /* not valid */
		(Number <= 0))  
	{
#ifdef _DEBUG
		sprintf(g_szErrorBuf,"Invalid Parameter string \"%s\"",szWord);
	 	Error(g_szErrorBuf, 0, FFErr);
#endif
		Mem_Free(pParamList);
		return FFErr;
	} 
	pParamList->iElementIndex = (uint16) Number;
	if (strncmp(szWord,ParameterElementSymbolString,2) == 0) 
		pParamList->uSymbElementType = SymbElementTypeParameter;	
	else if (strncmp(szWord,TableElementSymbolString,2) == 0)
		pParamList->uSymbElementType = SymbElementTypeTable;	
	else if (strncmp(szWord,RecordElementSymbolString,2) == 0) 
		pParamList->uSymbElementType = SymbElementTypeRecord;	
	else
	{
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"Invalid Parameter string \"%s\"",szWord);
	 	Error(g_szErrorBuf, 0, FFErr);
#endif
		Mem_Free(pParamList);
		return FFErr;
	}
	 
	/* hook it up */
	if (pCurrParam == NULL)
		*ppParamList = pParamList;
	else
		pCurrParam->pNext = pParamList;
		   
   	return (FFNoErr);
}
/* ---------------------------------------------------------------------- */
/* Parse and Process an Offset element */    
/* RETURN FFErr or FFNoErr */
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFProcessOffset(char * CONST szBuffer, PELEMENT_LIST CONST pElement, PSYMBOL_TABLE pKeySymbolTable, PSYMBOL_TABLE pSymbolTable)
{  
FFSYMBOL_DATA SymbolData;
uint16 iBufferIndex = 0; 
int16 cWordCount;
BOOL Done;   
char szWord[MAXBUFFERLEN]; 

	cWordCount = FFGetWord(szBuffer, szWord, ',');  /* grab a word from the buffer */   
	if (cWordCount <= 0)  /* no more data */   
	{
#ifdef _DEBUG  
		Error("Missing Offset Type.", 0, FFErr);  
#endif
		return FFErr;
	}

	iBufferIndex += cWordCount;  /* increment Buffer index */ 
	if (GetSymbol(pSymbolTable, szWord, 0, &SymbolData) == SymErr)	/* Might be record */
  	{
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"Unknown Offset Type \"%s\".", szWord);
  		Error(g_szErrorBuf, 0, FFErr);
#endif
		return FFErr;
	}
  	else if ((SymbolData.uSymbolType != StrucTypeTABLE) &&
  			 (SymbolData.uSymbolType != StrucTypeCLASS)) 
  	{
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"Invalid Offset Type \"%s\".", szWord);
  		Error(g_szErrorBuf, 0, FFErr);
#endif
		return FFErr;
  	}
  	else
  		pElement->iStructureIndex = SymbolData.iStructureIndex;  
	/* Now look for Range */
	cWordCount = FFGetWord(szBuffer+iBufferIndex, szWord, ',');  /* grab a word from the buffer */ 
	if (cWordCount > 0)  /* range specified */ 
	{
		iBufferIndex += cWordCount;  /* increment Buffer index */ 
		if (*szWord != '\0')
		{
			if (FFProcessRange(szWord,&(pElement->pMinCalc),&(pElement->pMaxCalc), pKeySymbolTable) == FFErr) 
				return(FFErr);
		}
	}
		
    /* Now look for Parameters */
    Done = FALSE;
    while (!Done)
    {
		cWordCount = FFGetWord(szBuffer+iBufferIndex, szWord, ',');  /* grab a word from the buffer */ 

		if (cWordCount > 0)
		{
			iBufferIndex += cWordCount;  /* increment Buffer index */ 
		
			if (FFProcessParameter(szWord,&(pElement->pParamList)) == FFErr)   /* create and hookup parameter list */
				return(FFErr); 
		}
		else
			break;
	} 
	return(iBufferIndex);
}  
/* ---------------------------------------------------------------------- */  
/* Given a Word (stuff between commas) that is either a Count or Limit field */
/* RETURN the next token of the word and the number of characters in */
/* that token, and Token Type. */ 
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFGetToken(char * CONST szWord, char *szToken, int16 *puTokType, int32 *plTokValue, PSYMBOL_TABLE pKeySymbolTable) 
{
int16 iBufferIndex=0;
int16 iTokenIndex = 0; 
KEYSYMBOL_DATA KeySymbolData; 

		*(szToken) = *(szWord); /* copy the character over */  
		iBufferIndex ++;  
		iTokenIndex ++;
   		switch (*(szWord))
   		{
   		case '\0':
   			return(0); /* eol */
   			break;
   		case '+':  
   			*puTokType = TokenTypeOperation;
   			*plTokValue = CalcOperAdd; 
   			break;
   		case '-':
   			*puTokType = TokenTypeOperation;
   			*plTokValue = CalcOperSubtract;
   			break;
		case '*':
			*puTokType = TokenTypeOperation;
			*plTokValue = CalcOperMultiply;
			break;
   		case '/':
   			*puTokType = TokenTypeOperation;
   			*plTokValue = CalcOperDivide;
   			break;
   		case '$':    /* B1.4 and below used '*', confusing for parsing */
   			/* check to see if which Symbol element */
			if (strncmp(szWord,TableElementSymbolString,2) == 0)
				*plTokValue = TableElementToken;
			else if (strncmp(szWord,RecordElementSymbolString,2) == 0)   
				*plTokValue = RecordElementToken;
			else if (strncmp(szWord,ParameterElementSymbolString,2) == 0)   
				*plTokValue = ParameterElementToken; 
			else if (strncmp(szWord,ByteElementSymbolString,2) == 0)   
				*plTokValue = ByteElementToken; 
#if 0
			else if (strncmp(szWord,IndexElementSymbolString,2) == 0)   
				*plTokValue = IndexElementToken; 
#endif
			else
	    	{
#ifdef _DEBUG  
			  	Error("Syntax error.",0, 0);
#endif
				return INVALID_TOKEN_COUNT;
			}
			*puTokType = TokenTypeSymbElement;  

			*(szToken+iTokenIndex++) = *(szWord+iBufferIndex++); /* copy the Type character over */  
#if 0
			if (*plTokValue == IndexElementToken)	 /* it's a string we want */
				while ((!isspace(*(szWord+iBufferIndex))) && (*(szWord+iBufferIndex) != '\0'))
					*(szToken+iTokenIndex++) = *(szWord+iBufferIndex++); /* copy the integer character over */  
			else
#endif
				while (isdigit(*(szWord+iBufferIndex)))
					*(szToken+iTokenIndex++) = *(szWord+iBufferIndex++); /* copy the integer character over */  
			break;
   		default: 
   			if (isdigit(*szWord))  /* process for integer value */
   			{  
   				iTokenIndex = ConvertNumber(szWord,plTokValue, 0 );
   				if (iTokenIndex <= 0)
   					return(INVALID_TOKEN_COUNT); 
   				strncpy(szToken,szWord,iTokenIndex);  /* copy that token over */
   				iBufferIndex = iTokenIndex;
 				*puTokType = TokenTypeUint; 
  			}
 			else if (isalpha(*szWord))
 			{
   				while ((isalnum(*(szWord+iBufferIndex))) &&   /* if it is a function */
   						(*(szWord+iBufferIndex) != '(') && 
   						(*(szWord+iBufferIndex) != '\0') )
 					*(szToken+iTokenIndex++) = *(szWord+iBufferIndex++); /* copy the character over */ 
 				*(szToken+iTokenIndex) = '\0';  
			   	if (GetSymbol(pKeySymbolTable, szToken, 0, &KeySymbolData) != SymErr) /* get primitive symbol */
			   	{   
			   		switch (KeySymbolData.uKeyType) 
			   		{
			   		case KeywordTypeFunction:  /* Function */
 						if (*(szWord+iBufferIndex) != '(')  /* we were expecting this */
 						{
#ifdef _DEBUG  
			    			Error("Syntax error.",0, 0);
#endif
							return INVALID_TOKEN_COUNT;
						}
			    		++iBufferIndex;  /* skip over '(' */
				   		iTokenIndex=0;   
				   		/* now we need to fix up the szToken string to be filled with the function arguments */
				   		while ((*(szWord+iBufferIndex+iTokenIndex) != ')') && (*(szWord+iBufferIndex+iTokenIndex) != '\0') )
				   		{
				   		 	*(szToken+iTokenIndex) = *(szWord+iBufferIndex+iTokenIndex);
				   		 	++iTokenIndex; 
				   		}
				        if (*(szWord+iBufferIndex+iTokenIndex) != ')') /* where are we? */
	    				{
#ifdef _DEBUG  
				          	Error("Missing \')\' for function",0, 0);
#endif
							return INVALID_TOKEN_COUNT;
						}
				   		*puTokType = TokenTypeFunction;
				   		*plTokValue = KeySymbolData.lKeyValue;  
				   		iBufferIndex += (int16) (iTokenIndex + 1); /* position buffer pointer after arguments and ')' */
                     	break;
				   	case KeywordTypeDefine:  /* Define foo=7 */
   						strncpy(szToken,szWord,iTokenIndex);  /* copy that token over */
				   		*puTokType = TokenTypeUint;   /* process like uint */
				   		*plTokValue = KeySymbolData.lKeyValue; 
				   		break; 
				   	case KeywordTypeValue:   
				   		*puTokType = TokenTypeUint;
				   		if (KeySymbolData.lKeyValue == KeywordValueNULL)
				   			*plTokValue = NULL_TOK_VAL; 
				   		else if (KeySymbolData.lKeyValue == KeywordValueNEGNULL)   
				   			*plTokValue = NEGNULL_TOK_VAL;
				   		else  
				   		{
#ifdef _DEBUG  
							sprintf(g_szErrorBuf,"Syntax error. Invalid keyword in field. \'%s\' is valid only for Offset Ranges.", KeywordStringNOTNULL); 
				   			Error(g_szErrorBuf,0, 0);
#endif
							return INVALID_TOKEN_COUNT;
						}
				   		break;
				   	case KeywordTypeMinMax:
				   		*puTokType = TokenTypeMinMax;
				   		*plTokValue = KeySymbolData.lKeyValue;
				   		break;
				   default:
#ifdef _DEBUG  
				   		Error("Syntax error. Invalid keyword in field. Must be constant or function.",0, 0);
#endif
						return INVALID_TOKEN_COUNT;
			   	        break;
			   	   }
			   	}
  				else
	    		{
#ifdef _DEBUG  
		    		Error("Syntax error. Unknown string in field.",0, 0);
 #endif
					return INVALID_TOKEN_COUNT;
				}
			} 
  			else
	    	{
#ifdef _DEBUG  
		    	Error("Syntax error. Invalid character(s) in field.",0, 0);
#endif
				return INVALID_TOKEN_COUNT;
			}
 		}	
    	*(szToken+iTokenIndex) = '\0'; /* null terminate */  
   		return(iBufferIndex);

}


/* ---------------------------------------------------------------------- */    
/* recursive */                                                       
/* Given a Limit or Count field, Parse and process by creating a CalcList */
/* the tokens in the field */
/* RETURN a pointer to the allocated CALC_LIST, or NULL on error */
/* ---------------------------------------------------------------------- */    
PRIVATE PCALC_LIST FFProcessLimitOrCount(char * CONST szWord, uint16 CONST uFieldType, PSYMBOL_TABLE pKeySymbolTable)
{
PCALC_LIST pCalcList = NULL; 
PCALC_LIST pCurrCalc = NULL;
PCALC_LIST pLastCalc = NULL;
BOOL KeepCalcRecord = FALSE;	/* if an operation is read, need to keep same calc record for value to come */ 
int16 iBufferIndex = 0; 
int16 iIncrement;
int16 sTokType;
int32 lTokValue;
char szToken[MAXBUFFERLEN];
BOOL First = TRUE;
	
	/* inch forward in buffer grabbing tokens and adding them to the calc list */
	while (*(szWord +iBufferIndex) != '\0')   /* while not end of line */
	{ 
		if (KeepCalcRecord == FALSE)
		{ 
			pLastCalc = pCurrCalc;
			if ((pCurrCalc = (PCALC_LIST) Mem_Alloc(sizeof(*pCurrCalc))) == NULL)
			{
#ifdef _DEBUG  
		 		Error("Out of Memory while processing Count or Limit field.",0, 0);
#endif
				return(NULL);
			}
			if (pLastCalc == NULL)     /* hook things up */
				pCalcList = pCurrCalc;
			else
			    pLastCalc->pNext = pCurrCalc;
		}
		KeepCalcRecord = FALSE; 
	    if ((iIncrement = FFGetToken(szWord+iBufferIndex,szToken,&sTokType,&lTokValue, pKeySymbolTable)) <= 0)
	    	if (iIncrement < 0) /* error */
			{
				Free_CalcList(pCalcList);
	    		return(NULL);
			}
	    	else
	    		break; /* eol */
	    else
	    {   
	    	iBufferIndex += iIncrement;
	    	switch (sTokType) {
		    	case TokenTypeUint: /* integer value */
		    		pCurrCalc->lValue = lTokValue;
		    		break;
		    	case TokenTypeOperation:
		    		if (pCurrCalc->uOperation != 0)  /* if already set */
		    		{
						
#ifdef _DEBUG  
						sprintf(g_szErrorBuf,"Invalid operation \"%s\" in \"%s\" field.",szToken, (uFieldType == FFFieldTypeCount) ? "Count": (uFieldType == FFFieldTypeLimit) ? "Limit" : "Config");
				 		Error(g_szErrorBuf,0, 0);
#endif
						Free_CalcList(pCalcList);
				    	return(NULL);
		    		}
		    		pCurrCalc->uOperation = (int16) lTokValue;
		    	    KeepCalcRecord = TRUE;
		    		break;
		    	case TokenTypeFunction:
		    		/* iBufferIndex now points after the function ')', and szTok contains the function arguments */
		    		if ((uFieldType == FFFieldTypeCount) && 
		    		     ((lTokValue != CalcFuncBitCount0F) &&   /* only valid functions */
		    		     (lTokValue != CalcFuncBitCountF0))
		    		   )  
					{    
#ifdef _DEBUG  
				 		Error("Invalid function in Array Count field.",0, 0);
#endif
						Free_CalcList(pCalcList);
				    	return(NULL);
					} 
		    		if ((uFieldType == FFFieldTypeLimit) && 
		    		     ((lTokValue != CalcFuncCoverageCount) &&   /* only valid functions */
		    		     (lTokValue != CalcFuncClassCount) && 
		    		     (lTokValue != CalcFuncCheckRangeRecord))
		    		   )  
					{    
#ifdef _DEBUG  
				 		Error("Invalid function in limit field.",0, 0);
#endif
						Free_CalcList(pCalcList);
				    	return(NULL);
					} 
					
		    		pCurrCalc->uFunction = (uint16) lTokValue;
	                pCurrCalc->pFunctionList = FFProcessLimitOrCount(szToken, uFieldType, pKeySymbolTable); /* recursive! process stuff within parens */
	                if ((pCurrCalc->pFunctionList == NULL) && (lTokValue != CalcFuncCheckRangeRecord))  
	                {   
#ifdef _DEBUG  
	                	Error("Expecting argument for function.",0, 0);
#endif
						Free_CalcList(pCalcList);
	                	return(NULL);                                                
	                }
		    		break;
		    	case TokenTypeSymbElement:  
					pCurrCalc->iElementIndex = (uint16) atoi(szToken+2);      /* already checked for valid string */
		    	    pCurrCalc->uSymbElementType = (uint16) lTokValue;   /* type of Symbolic element reference */
		    		break;
		    	case TokenTypeMinMax:   
					pCurrCalc->uMinMax = (uint16) lTokValue;      /* set the minmax field - like a uint, but saved in a different place for later interpretation */
					break;
		    	default:
		    	{
#ifdef _DEBUG  
				 	Error("Internal! Invalid Token Type for Count or Limit Field.",0, 0);
#endif
					Free_CalcList(pCalcList);
				    return(NULL);
		    	}
	    	}
	    	if ((pCurrCalc->uOperation == CalcOperIdentity) && First != TRUE)
	    	{
#ifdef _DEBUG  
	    	 	Error("Syntax error in Count or Limit Field. Missing operator?", 0, 0);
#endif
				Free_CalcList(pCalcList);
	    	 	return(NULL);
	    	}
	    	First = FALSE;  /* this is no longer the first item in the calculation */
	    }
	}
	return(pCalcList);
}
	


/* ---------------------------------------------------------------------- */   
/* Parse and process a Primitive element */
/* RETURN FFErr or FFNoErr */
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFProcessPrimitive(char * CONST szBuffer,PELEMENT_LIST CONST pElement, PSYMBOL_TABLE pKeySymbolTable)
{
uint16 iBufferIndex = 0; 
int16 cWordCount;
char szWord[MAXBUFFERLEN]; 

	cWordCount = FFGetWord(szBuffer, szWord, ',');  /* grab a word from the buffer */   
	if (cWordCount == INVALID_COUNT)  /* no more data */
	 	return(FFNoErr); 
	if (cWordCount > 0)
	{
		iBufferIndex += cWordCount;  /* increment Buffer index */
		if (*szWord != '\0')
			if ((pElement->pMinCalc = FFProcessLimitOrCount(szWord,FFFieldTypeLimit,pKeySymbolTable)) == NULL) /* creates and fills a calc record for limit field */
				return(FFErr); 
	}
	cWordCount = FFGetWord(szBuffer+iBufferIndex, szWord, ',');  /* grab a word from the buffer */ 
	if (cWordCount == INVALID_COUNT)  /* no more data */
	 	return(FFNoErr);
	if (cWordCount > 0) 
	{
		iBufferIndex += cWordCount;  /* increment Buffer index */
		if (*szWord != '\0')
			if ((pElement->pMaxCalc = FFProcessLimitOrCount(szWord, FFFieldTypeLimit,pKeySymbolTable)) == NULL) /* creates and fills a calc record for limit field */
				return(FFErr); 
	}  
#if 0
	CheckLineClear(szBuffer+iBufferIndex, cLineNumber ); /* report warning if line not clear except comments */
#endif
	return(iBufferIndex);	
}
/* ---------------------------------------------------------------------- */
/* Parse and process an Array Element */    
/* Set Calc record and uType in element. set puKeyType for next stuff to process */  
/* RETURN index into buffer of where to continue processing (for offset arrays) */ 
/* or 0 on error */
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFProcessArray(char * CONST szBuffer, PELEMENT_LIST CONST pElement, uint16 *puKeyType, PSYMBOL_TABLE pKeySymbolTable, PSYMBOL_TABLE pSymbolTable)
{
KEYSYMBOL_DATA KeySymbolData; 
FFSYMBOL_DATA SymbolData; 
PCALC_LIST pCalcList;
uint16 iBufferIndex = 0; 
int16 cWordCount;
uint16 uElementType;   
char szWord[MAXBUFFERLEN]; 

	cWordCount = FFGetWord(szBuffer, szWord, ',');  /* grab a word from the buffer */   
	if ((cWordCount <= 0) || (*szWord == '\0'))
	{
#ifdef _DEBUG  
	 	Error("Missing Array Count",0, FFErr);
#endif
		return FFErr;
	}

	iBufferIndex += cWordCount;  /* increment Buffer index */
	if ((pCalcList = FFProcessLimitOrCount(szWord,FFFieldTypeCount,pKeySymbolTable)) == NULL) /* creates and fills a calc record for count field */
		return(FFErr);
	pElement->pCountCalc = pCalcList;  /* set the value */ 
	cWordCount = FFGetWord(szBuffer+iBufferIndex, szWord, ',');  /* grab a word from the buffer */   
	if ((cWordCount <= 0) || (*szWord == '\0'))
	{
#ifdef _DEBUG  
	 	Error("Missing Array Type field.",0, FFErr); 
#endif
		return FFErr;
	}

	iBufferIndex += cWordCount;  /* increment Buffer index */
   	if (GetSymbol(pKeySymbolTable, szWord, 0, &KeySymbolData) != SymErr) /* get primitive symbol */
   	{ 
   		uElementType = (uint16) KeySymbolData.lKeyValue  ; 
    	*puKeyType = KeySymbolData.uKeyType; /* set to process offsets and primitives */ 
   	}
   	else if (GetSymbol(pSymbolTable, szWord, 0, &SymbolData) == SymErr)	/* Might be record */
  	{
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"Unknown Array Type \"%s\"", szWord);
  		Error(g_szErrorBuf, 0, FFErr);
#endif
		return FFErr;
	}
  	else if (SymbolData.uSymbolType != StrucTypeRECORD)
  	{
  		
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"Invalid Array Type \"%s\".", szWord);
  		Error(g_szErrorBuf, 0, FFErr);
#endif
		return FFErr;
	}
  	else
  	{
  		uElementType = ETRecord;
  		pElement->iStructureIndex = SymbolData.iStructureIndex;  
  		*puKeyType = 0;  /* set to nothing */
  	} 
  			    				
    pElement->uType |= uElementType;  /* or it in - we have an array to remember */  
#if 0   /* Don't check this anymore, may be ffConfig stuff to come */
    /* Check to see if there should be any more on the line */   
    if ((*puKeyType != KeywordTypeElementPrimitive) && 
    	(*puKeyType != KeywordTypeElementOffset) &&
    	(*puKeyType != KeywordTypeElementPacked) ) /* if its not one that should have more data */
    	CheckLineClear(szBuffer + iBufferIndex, cLineNumber); /* print out warning if line isn't clear */
#endif
    return(iBufferIndex);
 
}

/* ---------------------------------------------------------------------- */
PRIVATE int16 FFProcessConfig(char * CONST szBuffer,PCONFIG *ppConfig, PSYMBOL_TABLE pKeySymbolTable)
{
KEYSYMBOL_DATA KeySymbolData; 
PCONFIG pConfig;
uint16 iBufferIndex = 0; 
int16 cWordCount;
char szWord[MAXBUFFERLEN]; 
  
    *ppConfig = NULL;        
	cWordCount = FFGetWord(szBuffer, szWord, ',');  /* grab a word from the buffer */ 
	if (cWordCount <= 0)
		return(FFNoErr); 	/* empty line */  
 
	iBufferIndex += cWordCount;  /* increment Buffer index */	    				
   	if ((GetSymbol(pKeySymbolTable, szWord, 0, &KeySymbolData) != SymErr) &&  /* get primitive symbol */
		(KeySymbolData.uKeyType == KeywordTypeConfigValue))
   	{
	    if ((pConfig = (PCONFIG) Mem_Alloc(sizeof(*pConfig))) == NULL)
		{
#ifdef _DEBUG  
	      	Error("Out of Memory for Config Info.", 0, FFErr);
#endif
			return FFErr;
		}
	    *ppConfig = pConfig;  /* change this value */  
	    pConfig->uFlag = (uint16) KeySymbolData.lKeyValue; /* set the type of Flag */
  	} 
  	else 
  	{
#ifdef _DEBUG  
		sprintf(g_szErrorBuf,"Invalid Config string \"%s\"",szWord);
	 	Error(g_szErrorBuf, 0, FFErr);
#endif
		return FFErr;
	}

	return(FFNoErr);     
}

/* ---------------------------------------------------------------------- */
/* Given a line read from the file, parse and process it as an element */
/* Need to determine what type of element the line is, then call the */
/* correct processor */    
/* RETURN FFErr or FFNoErr */
/* ---------------------------------------------------------------------- */    
PRIVATE int16 FFProcessElementLine(char * CONST szBuffer, PSTRUCTURE_DEF CONST pStructure, PELEMENT_LIST * ppCurrElement, PSYMBOL_TABLE pKeySymbolTable, PSYMBOL_TABLE pSymbolTable)
{
KEYSYMBOL_DATA KeySymbolData; 
PELEMENT_LIST pElement;
BOOL Done;
uint16 iBufferIndex = 0; 
int16 cWordCount;
uint16 uKeyType;   
char szWord[MAXBUFFERLEN]; 
  
            
	cWordCount = FFGetWord(szBuffer, szWord, ',');  /* grab a word from the buffer */ 
	if (cWordCount == INVALID_COUNT)
		return(FFNoErr); 	/* empty line */  
	iBufferIndex += cWordCount;  /* increment Buffer index */	    				
    if (*(szBuffer + iBufferIndex) == END_STRUC_CHAR)  /* no more elements */
    {
       *ppCurrElement = NULL;   
       return(FFNoErr);
    }
   	if (GetSymbol(pKeySymbolTable, szWord, 0, &KeySymbolData) == SymErr) /* get primitive symbol */
   	{
  		
#ifdef _DEBUG 
		sprintf(g_szErrorBuf,"Unknown Element Type \"%s\".", szWord);
  		Error(g_szErrorBuf, 0, FFErr);
#endif
		return FFErr;
	}
    if (_stricmp(szWord, KeywordStringUint32) == 0)
    {
    	
#ifdef _DEBUG 
		sprintf(g_szErrorBuf, "Type %s is obsolete. Value will be stored as an int32", szWord);
        Warning(g_szErrorBuf, 0);
#endif
	}
    /* allocate a new element */
    if ((pElement = (PELEMENT_LIST) Mem_Alloc(sizeof(*pElement))) == NULL)
	{
#ifdef _DEBUG  
      	Error("Out of Memory for structure element.", 0, FFErr);
#endif
		return FFErr;
	}
    if (pStructure->pFirst == NULL)
    	pStructure->pFirst = pElement;
    else
    	(*ppCurrElement)->pNext = pElement;
    *ppCurrElement = pElement;  /* change this value */  
    pElement->uType = (uint16) KeySymbolData.lKeyValue; /* the type is the value of the keyword symbol */
    /* pointers already Nulled by memory manager */
    uKeyType = KeySymbolData.uKeyType;  
    Done = FALSE;
    
    while (!Done) /* process the buffer */
    {
	
	    switch(uKeyType) /* different type of keywords */
	    {
	    case KeywordTypeElementPrimitive:   /* deal with limits */
	    case KeywordTypeElementPacked:
	    	if ((cWordCount = FFProcessPrimitive(szBuffer+iBufferIndex, pElement, pKeySymbolTable)) == FFErr)
	    		return(FFErr); 
	    	Done = TRUE;
	    	break;
	    case KeywordTypeElementOffset:   /* deal with type and ranges */
	    	if ((cWordCount = FFProcessOffset(szBuffer+iBufferIndex, pElement, pKeySymbolTable, pSymbolTable)) == FFErr)
	    		return(FFErr); 
	    	Done = TRUE;
	    	break;
	    case KeywordTypeElementArray:    /* deal with count and type */
	    	/* create calc record and set type of array */
	    	if ((cWordCount = FFProcessArray(szBuffer+iBufferIndex,pElement,&uKeyType, pKeySymbolTable, pSymbolTable)) == FFErr)
	    		return(FFErr);   /* error already reported */ 
	    	if (!((uKeyType == KeywordTypeElementPrimitive) || (uKeyType == KeywordTypeElementOffset) || 
	    		(uKeyType == KeywordTypeElementPacked)))
 	    		Done = TRUE;    /* this was an array of Records */
	    	break;
	    default:
	  		
#ifdef _DEBUG 
			sprintf(g_szErrorBuf,"Invalid Element Type \"%s\"", szWord);
	  		Error(g_szErrorBuf, 0, FFErr);
#endif
			return FFErr;
	  		break;
	  	}
 	    iBufferIndex += cWordCount; /* increment so other functions can handle it */ 
   } 
    
    /* now let's see if we have any ffconfig info */
	cWordCount = FFGetWord(szBuffer+iBufferIndex, szWord, DELIMIT_CONFIG_INFO_CHAR);  /* grab the ':' */ 
  	if (cWordCount == 1)  /* we found the ':' */
    {
	    iBufferIndex += cWordCount;
		if (FFProcessConfig(szBuffer+iBufferIndex,&(pElement->pConfig),pKeySymbolTable) == FFErr)   /* create and hookup ffConfig info */
			return(FFErr);
	}
	return(FFNoErr);     
}

/* ---------------------------------------------------------------------- */    
#if 0
void PrintStructureList(PSTRUCTURE_DEF pStructureDef, uint16 CONST cStructures)
{                                                     
uint16 i,j; 
PELEMENT_LIST pEList;

	for (i = 0; i< cStructures; ++i)
	{  
		printf("StructureIndex %d\n", i);
		printf("  cParameters: %d\n", pStructureDef[i].cParameters);
		for (pEList = pStructureDef[i].pFirst, j=1; pEList; pEList = pEList->pNext, ++j)
		{
	    printf("  Element %d\n",j); 
	    printf("    uType: %x, iStructureIndex: %d\n",pEList->uType,pEList->iStructureIndex);
	    printf("    pMinCalc: %d, pMaxCalc: %d\n",pEList->pMinCalc,pEList->pMaxCalc);
	    printf("    pCountCalc: %d, pParamList: %d\n",pEList->pCountCalc,pEList->pParamList);
	    }
	}
	printf("End of structures\n");
}
#endif   
/* ---------------------------------------------------------------------- */ 
/* find a comment, allocate memory for it, copy it to that memory, and return the pointer to it */
PRIVATE char * FFGrabComment(char * CONST szBuffer)
{
int16 iBufferIndex = 0;
size_t uCommentSize = 0; 
char * szComment = NULL; 
    
	while ( (*(szBuffer + iBufferIndex) != '\0') && (*(szBuffer + iBufferIndex) != ';')) /* move past data */
      	++iBufferIndex; 
    if (*(szBuffer + iBufferIndex) != ';')
    	return NULL;
    
	uCommentSize = strlen((char *) (szBuffer + iBufferIndex)) + 1;
    if ((szComment = (char *) Mem_Alloc(uCommentSize)) == NULL)
    	return(NULL);
    strcpy(szComment, szBuffer+iBufferIndex);
    return(szComment);
}  
/* ---------------------------------------------------------------------- */ 
/* Pass2 of Read Format File */
/* Read the lines from the file, determine what type of line it is and call */
/* the appropriate line handler (structure, constant or element) */   
/* RETURN Pointer to the Structure Def array or NULL on error */
/* ---------------------------------------------------------------------- */    
PRIVATE PSTRUCTURE_DEF FFPass2( uint16 CONST cStructures, PSYMBOL_TABLE pKeySymbolTable, PSYMBOL_TABLE pSymbolTable, char **pFileArray)
{   
FFSYMBOL_DATA FFSymbolData;
PELEMENT_LIST pCurrentElement;
BOOL Done;  
BOOL bEOF;
uint16 iBufferIndex; 
int16 cWordCount;
int16 iStructureIndex; 
int16 ErrorCode;
char szBuffer[MAXBUFFERLEN];
char szStrucDef[MAXBUFFERLEN];
int16 cLineNumber;
PSTRUCTURE_DEF aStructureArray;  /* array of structures in index order  - Returned to caller for ReadSDF */
    
    /* create the array to hold the structures */
	if ((aStructureArray = (PSTRUCTURE_DEF) Mem_Alloc(sizeof(*aStructureArray) * cStructures)) == NULL)
		return(NULL);  

    cLineNumber = 0; 
    iStructureIndex = INVALID_COUNT;                                
	bEOF = FALSE;   
    
	/* Create Format structures */
    while (!bEOF) 
    {              
		Done = FALSE;  
		while (!Done)        /* looking for a structure definition*/
		{
			iBufferIndex = 0; 
	    	ErrorCode = ReadTextLine(szBuffer, MAXBUFFERLEN, pFileArray, cLineNumber);
	    	if (ErrorCode == FileEOF) 
	    	{  
				bEOF = TRUE; 
				break;
	    	} 
	    	else if (ErrorCode == FileErr)
	    	{
#ifdef _DEBUG  
	    	  	Error("File Error Reading File.", cLineNumber, 0);  
#endif
				Mem_Free(aStructureArray);
				return(NULL);
	    	}    
			++cLineNumber;
		    /* read text to find Structure Def and Type */
			if ((cWordCount = FFGetWord(szBuffer+iBufferIndex, szStrucDef, '=')) >= 0)  /* grab a word from the buffer */
			{    
				iBufferIndex += cWordCount;  /* increment Buffer index */   
				if (*(szBuffer+iBufferIndex) == '=')   /* we have a define line, process this constant */  
				{
				    if (FFProcessConstantLine(szBuffer, pKeySymbolTable) == FFErr)	/* will add constant to symbol table */ 
					{
#ifdef _DEBUG  
       					Error("Constant error", cLineNumber, FFErr);  /* so the line number gets reported */
#endif
						Mem_Free(aStructureArray);
						return(NULL); 
					}
				}
				else
				{   
					++iStructureIndex; /* we found one - process the first line of the structure */
					if (FFProcessStructureLine(szBuffer, pSymbolTable, &FFSymbolData,&(aStructureArray[iStructureIndex])) == FFErr)
					{
#ifdef _DEBUG  
       					Error("Structure error", cLineNumber, FFErr);  /* so the line number gets reported */
#endif
						Mem_Free(aStructureArray);
						return(NULL); /* error already reported cleanup */
					}
    				if (FFSymbolData.iStructureIndex != iStructureIndex) /* we're out of sync */ 
    				{
#ifdef _DEBUG  
       					Error("Internal! Format File Structure Index out of sync.", cLineNumber, FFErr); 
#endif
						Mem_Free(aStructureArray);
						return(NULL);
        			}
	            	Done = TRUE; 
				}  /* end if constant */
	        } /* end FFGetWord */
		} /* end while !Done */
		 /* now buzz on through processing the elements of the structure */
		if (!bEOF) 
		{  
			aStructureArray[iStructureIndex].szComment = FFGrabComment(szBuffer);  /* Grab the comment for the disassembler */
			Done = FALSE;
			pCurrentElement = aStructureArray[iStructureIndex].pFirst = NULL;
			while (!Done)
			{
				iBufferIndex = 0; 
		    	ErrorCode = ReadTextLine(szBuffer, MAXBUFFERLEN, pFileArray, cLineNumber);
		    	if (ErrorCode != FileNoErr) 
		    	{  
					bEOF = TRUE;
					
#ifdef _DEBUG 
					sprintf(g_szErrorBuf,"EOF or File Error before end of structure \"%s\".", szStrucDef);  
					Error(g_szErrorBuf,cLineNumber, 0);
#endif
					Mem_Free(aStructureArray);
					return(NULL);
		    	}
				++cLineNumber;
		    	if (FFSymbolData.uSymbolType == StrucTypeCLASS)
		    	{
					if (FFProcessClassElementLine(szBuffer,&(aStructureArray[iStructureIndex]), &pCurrentElement, pSymbolTable) == FFErr)
					{
#ifdef _DEBUG  
       					Error("Class Element error", cLineNumber, FFErr);  /* so the line number gets reported */
#endif
						Mem_Free(aStructureArray);
						return(NULL); 
					}
				}
			    else
			    {	     
					if (FFProcessElementLine(szBuffer,&(aStructureArray[iStructureIndex]), &pCurrentElement, pKeySymbolTable, pSymbolTable) == FFErr)
					{
#ifdef _DEBUG  
       					Error("Element error", cLineNumber, FFErr);  /* so the line number gets reported */
#endif
						Mem_Free(aStructureArray);
						return(NULL); 
					}
				}
				if (pCurrentElement == NULL)  /* last element and END_STRUC_CHAR read */    
				{
					Done = TRUE;    
			/* 		DebugMsg("Finished FFPass2 structure", szStrucDef, cLineNumber);	  */
				}
				else 
					pCurrentElement->szComment = FFGrabComment(szBuffer);  /* copy comment for dissassembler */
			}   	
		}
    }
#ifdef _DEBUG
	DebugMsg("Finished function FFPass2", "", cLineNumber);   
#endif
#if 0 
	PrintStructureList(aStructureArray,cStructures);
#endif
	
	return(aStructureArray);    
} 

PRIVATE BOOL CompareKeySymbolType(int16 uKeyType, KEYSYMBOL_DATA *pKeySymbolData) 
{
 	if (uKeyType == pKeySymbolData->uKeyType)
 		return(TRUE);
 	return(FALSE);
} 

/* ---------------------------------------------------------------------- */ 
/* ENTRY POINT */
/* Free up memory used by this module and clear values in pStructureList. */
/* May be used again*/   
/* ---------------------------------------------------------------------- */    
void DestroyFFStructureTable(PSTRUCTURE_LIST pStructureList, uint16 exit)
{
PSTRUCTURE_DEF pStructureDef;
PELEMENT_LIST pElement;
PELEMENT_LIST pNextElement;
KEYSYMBOL_DATA keySymbolData;
char szKeyName[MAXBUFFERLEN];
uint16 i;
int16 dummyValue;

	if (exit == TRUE)
	{
		DestroySymbolTable(pStructureList->pKeySymbolTable); 
		pStructureList->pKeySymbolTable = NULL;  
	}
	else  /* need to destroy user defined symbols, but not DEFINE itself */
	{
		while (1)
		{
	 		if (GetSymbolByFunction (pStructureList->pKeySymbolTable, szKeyName, &dummyValue, &keySymbolData, KeywordTypeDefine, (pSymbolFunction)&CompareKeySymbolType) != SymErr)
				DeleteSymbol(pStructureList->pKeySymbolTable,szKeyName,0);
			else
				break;
		}
		keySymbolData.uKeyType = KeywordTypeDefine;
		keySymbolData.lKeyValue  = KeywordValueDefine;
		if (AddSymbol(pStructureList->pKeySymbolTable, KeywordStringDefine, 0, &keySymbolData) != SymNoErr)
			return;	/* need to add this baby back in */
	}


	DestroySymbolTable(pStructureList->pSymbolTable);  
	pStructureList->pSymbolTable = NULL;

    if (pStructureList->pStructureDef != NULL)
    {
        for (i = 0; i < pStructureList->cStructures; ++i)
        {
      	    pStructureDef = pStructureList->pStructureDef + i;
       	    for (pElement = pStructureDef->pFirst; pElement != NULL;) 
      	    {
               Free_CalcList(pElement->pMinCalc);
               Free_CalcList(pElement->pMaxCalc);
               Free_CalcList(pElement->pCountCalc); 
               Free_ParamList(pElement->pParamList);
               Mem_Free(pElement->szComment);
               Mem_Free(pElement->pConfig);
	           pNextElement = pElement->pNext;
	           Mem_Free(pElement);
	           pElement = pNextElement;
      	    }
            Mem_Free(pStructureDef->szComment);
        }
        Mem_Free(pStructureList->pStructureDef); /* free the structure array */
        pStructureList->pStructureDef = NULL;
    }
	pStructureList->cStructures = 0;
}
/* ---------------------------------------------------------------------- */
/* ENTRY POINT */    
/* Read data from file in 2 passes to create the Format File Structure */
/* table to be used by the Process Data File module */
/* RETURN pointer to that Format File Structure table or NULL on error */ 
/* ---------------------------------------------------------------------- */    
int16 CreateFFStructureTable(PSTRUCTURE_LIST pStructureList, char **pFileArray )
{  
	if (pStructureList == NULL)
		return (ERR_GENERIC);
   	pStructureList->pSymbolTable = CreateSymbolTable(sizeof(FFSYMBOL_DATA), SYMBOLSTRINGTYPE); 
   	if (pStructureList->pSymbolTable == NULL)
   	{
#ifdef _DEBUG  
   		Error("Could not create Format File Symbol table.",0, 0);
#endif
		DestroyFFStructureTable(pStructureList, 1); /* free up this and more */
		return(ERR_GENERIC);
   	} 
   	
	if (pStructureList->pKeySymbolTable == NULL)  /* only create the FIRST time */
	{
   		pStructureList->pKeySymbolTable = CreateSymbolTable(sizeof(KEYSYMBOL_DATA), SYMBOLSTRINGTYPE); 
   		if (pStructureList->pKeySymbolTable == NULL)
   		{
#ifdef _DEBUG  
  			Error("Could not create Keyword Symbol table.",0, 0);
#endif
			DestroyFFStructureTable(pStructureList, 1); /* free up this and more */
			return(ERR_GENERIC);
   		} 
   		
   		if (FFInitKeySymbolTable(pStructureList->pKeySymbolTable) != FFNoErr) /* fill it with keywords for Types */ 
   		{   
#ifdef _DEBUG  
   			Error("Out of Memory while initilizing keyword symbol table.", 0,0);
#endif
			DestroyFFStructureTable(pStructureList, 1); /* free up this and more */
			return(ERR_GENERIC);
   		} 
	}
    
    if ((pStructureList->cStructures = FFPass1(&(pStructureList->iHeadIndex),pStructureList->pKeySymbolTable,pStructureList->pSymbolTable, pFileArray)) == 0)
    {
		DestroyFFStructureTable(pStructureList, 1); /* free up this and more */
		return(ERR_GENERIC);
	}
    	 
    if ((pStructureList->pStructureDef = FFPass2((pStructureList->cStructures),pStructureList->pKeySymbolTable,pStructureList->pSymbolTable, pFileArray)) == NULL)
	{
		DestroyFFStructureTable(pStructureList, 1); /* free up this and more */
	  	return(ERR_GENERIC);
	}	
    else
    	return(NO_ERROR);
    
}   	
/* ---------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\mtxcalc.c ===
/***************************************************************************
 * module: MTXCALC.C
 *
 * author: Steve McConnell [a-stevem]
 * date:   26 September 1990
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * Routines to calc metrics from font file data.
 *
 **************************************************************************/

/* Inclusions ----------------------------------------------------------- */
#include <stdlib.h>

#include "typedefs.h"
#include "ttff.h"
#include "ttfacc.h"
#include "ttfcntrl.h"
#include "ttftabl1.h"
#include "ttftable.h"
#include "ttferror.h" /* error codes */
#include "mtxcalc.h"


/* function definitions ---------------------------------------------- */
/* ------------------------------------------------------------------- */
PRIVATE int16 GetGlyphStats( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
uint16    usGlyphIdx,
int16 *   psnContours,
uint16 *  pusnPoints,
uint16 *  pusnInstructions,
uint16 indexToLocFormat,
uint32 ulLocaOffset,
uint32 ulGlyfOffset,
BOOL *bStatus )
{
uint32 ulOffset;
uint16 usLength;
GLYF_HEADER GlyfHeader;
uint32 ulLastPointOffset;
int16 errCode;

	*psnContours      = 0;
	*pusnPoints       = 0;
	*pusnInstructions = 0;
	*bStatus = FALSE;	/* assume no glyph there */
	if ((errCode = GetGlyphHeader( pInputBufferInfo, usGlyphIdx, indexToLocFormat, ulLocaOffset, ulGlyfOffset, &GlyfHeader, &ulOffset, &usLength )) != NO_ERROR)
		return errCode;
	if ( usLength == 0 )
		return( NO_ERROR );

	*psnContours = GlyfHeader.numberOfContours;
	if (*psnContours > 0)
	{
		/* calculate offset of last point */
		ulLastPointOffset = ulOffset + GetGenericSize( GLYF_HEADER_CONTROL ) + (*psnContours-1) * sizeof( uint16 );
		if ((errCode = ReadWord( pInputBufferInfo, pusnPoints, ulLastPointOffset)) != NO_ERROR)
			return errCode;
		(*pusnPoints)++;
		if ((errCode = ReadWord( pInputBufferInfo, pusnInstructions, ulLastPointOffset + sizeof(uint16))) != NO_ERROR)
			return errCode;
	}
	*bStatus = TRUE;
	return( NO_ERROR );
}


/* ------------------------------------------------------------------- */
/* NOT recursive, operates on "flat" tree */
PRIVATE int16 GetCompositeGlyphStats( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
			 uint16 usGlyphIdx,
			 int16 * psnContours,
			 uint16 * pusnPoints,
			 uint16 * pusnInstructions,
			 uint16 * pusnComponentElements,
			 uint16 * pusnComponentDepth,
			 uint16 indexToLocFormat,
			 uint32 ulLocaOffset,
			 uint32 ulGlyfOffset,
			 uint16 *  pausComponents, 
			 uint16 usnMaxComponents)

{
int16    snContours;
uint16   usnPoints;
uint16   usnInstructions;
uint16   usnGlyphs;
uint16   i;
uint16   usTtlContours     = 0;
uint16   usTtlPoints       = 0;
uint16   usMaxInstructions = 0;
int16 errCode;
BOOL bStatus;

	
/* This call has changed to be recursive, will flatten out the tree */
	GetComponentGlyphList( pInputBufferInfo, usGlyphIdx, &usnGlyphs, pausComponents, usnMaxComponents, pusnComponentDepth, 0, indexToLocFormat, ulLocaOffset, ulGlyfOffset);

	/* track max number of components at any given level */
	*pusnComponentElements = max( *pusnComponentElements, usnGlyphs );

	for ( i = 0; i < usnGlyphs; i++ )
	{
		if ((errCode = GetGlyphStats( pInputBufferInfo, pausComponents[i], &snContours, &usnPoints, &usnInstructions, indexToLocFormat, ulLocaOffset, ulGlyfOffset, &bStatus )) != NO_ERROR)
			return errCode;
		if ((bStatus == TRUE) && ( snContours > 0 ))
		{
			usTtlContours     += snContours;
			usTtlPoints       += usnPoints;
			usMaxInstructions = max( usMaxInstructions, usnInstructions );
		}
	}

	*psnContours      = usTtlContours;
	*pusnPoints       = usTtlPoints;
	*pusnInstructions = usMaxInstructions;
	return NO_ERROR;
}

/* ------------------------------------------------------------------- */
int16 ComputeMaxPStats( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
			uint16 *  pusMaxContours,
			uint16 *  pusMaxPoints,
			uint16 *  pusMaxCompositeContours,
			uint16 *  pusMaxCompositePoints,
			uint16 *  pusMaxInstructions,
			uint16 *  pusMaxComponentElements,
			uint16 *  pusMaxComponentDepth,
			uint16 *  pausComponents, 
			uint16 usnMaxComponents)
{
HEAD Head;
int16    snContours;
uint16   usnPoints;
uint16   usnInstructions;
uint16   usGlyphIdx;
uint16   prepLength;
uint16   fpgmLength;
uint16   usnCompElements;
uint16   usnCompDepth;
uint16 usGlyphCount;
uint32 ulLocaOffset;
uint32 ulGlyfOffset;
int16 errCode;
BOOL bStatus;

	*pusMaxContours          = 0;
	*pusMaxPoints            = 0;
	*pusMaxInstructions      = 0;
	*pusMaxCompositeContours = 0;
	*pusMaxCompositePoints   = 0;
	*pusMaxComponentElements = 0;
	*pusMaxComponentDepth    = 0;

	/* Build a Loca table that will be used to decide if a glyph has contours
	or not. There are g_usnGlyphs+1 Loca entries. */

	usGlyphCount = GetNumGlyphs(pInputBufferInfo);
	if (usGlyphCount == 0)
		return ERR_NO_GLYPHS;

	ulLocaOffset = TTTableOffset(pInputBufferInfo, LOCA_TAG);
	if ( ulLocaOffset == 0L )
		return ERR_MISSING_LOCA;

	ulGlyfOffset = TTTableOffset(pInputBufferInfo, GLYF_TAG);
	if ( ulGlyfOffset == 0L )
		return ERR_MISSING_GLYF;

	if (!GetHead(pInputBufferInfo, &Head))   /* for Head.indexToLocFormat */
		return ERR_MISSING_HEAD;

	for ( usGlyphIdx = 0; usGlyphIdx < usGlyphCount; usGlyphIdx++ )
	{
	/* get statistics on the glyph component */

		if ((errCode = GetGlyphStats(pInputBufferInfo, usGlyphIdx, &snContours, &usnPoints, &usnInstructions,
					Head.indexToLocFormat, ulLocaOffset, ulGlyfOffset, &bStatus)) != NO_ERROR)
			return errCode;
		if (bStatus == FALSE) 
			continue;
		
		/* remember maxes for simple glyph */

		if ( snContours >= 0 )
		{
			*pusMaxContours     = max( *pusMaxContours, (uint16) snContours );
			*pusMaxPoints       = max( *pusMaxPoints, usnPoints );
			*pusMaxInstructions = max( *pusMaxInstructions, usnInstructions );
		}
		/* remember maxes for composite glyph */
		else if (snContours == -1)
		{
		/* start with usnInstructions at 0 for MAX test in fn call... */
			usnCompElements = usnCompDepth = usnInstructions = 0;
			GetCompositeGlyphStats( pInputBufferInfo, usGlyphIdx, &snContours, &usnPoints,
			     &usnInstructions, &usnCompElements, &usnCompDepth,
			     Head.indexToLocFormat, ulLocaOffset, ulGlyfOffset, pausComponents, usnMaxComponents );
			*pusMaxCompositeContours = max( *pusMaxCompositeContours, (uint16) snContours );
			*pusMaxCompositePoints   = max( *pusMaxCompositePoints, usnPoints );
			*pusMaxInstructions      = max( *pusMaxInstructions, usnInstructions );
			*pusMaxComponentElements = max( *pusMaxComponentElements, usnCompElements );
			*pusMaxComponentDepth    = max( *pusMaxComponentDepth, usnCompDepth );
		}
		else 
			return ERR_INVALID_GLYF;  /* what is it? */
	}

	prepLength = (uint16) TTTableLength( pInputBufferInfo, PREP_TAG );
	fpgmLength = (uint16) TTTableLength( pInputBufferInfo, FPGM_TAG );
	*pusMaxInstructions = max( max( prepLength, fpgmLength), *pusMaxInstructions );

	return NO_ERROR;
}

/* ------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttfdelta.c ===
/***************************************************************************
 * module: TTFDelta.C
 *
 * author: Louise Pathe [v-lpathe]
 * date:   Nov 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * TTFSub library entry point SubsetTTF() and CreateDeltaTTF()
 * This library allows the subsetting of a font to prepare it for font 
 * embedding. Subsetting involves removing the data for glyphs not needed
 * but keeping Glyph Indices the same. Also, reducing table sizes for some
 * of the other tables if possible.
 *
 **************************************************************************/

/* Inclusions ----------------------------------------------------------- */
#include <stdlib.h>
#include <string.h> /* for memcpy */

#include "typedefs.h"
#include "ttff.h"
#include "ttfacc.h"
#include "ttfcntrl.h"
#include "ttftabl1.h"
#include "ttfdelta.h"
#include "ttferror.h"
#include "ttmem.h"
#include "makeglst.h"
#include "ttftable.h"
#include "modtable.h"
#include "modglyf.h"
#include "modcmap.h"
#include "modsbit.h"
#include "modtto.h"
#include "util.h"

/* ---------------------------------------------------------------------- */
int16 TTCOffsetTableOffset(
	/* 0 */ CONST unsigned char * puchSrcBuffer, /* input TTF or TTC buffer */
	/* 1 */	CONST unsigned long ulSrcBufferSize, /* size of input TTF or TTC buffer data */
	/* 6 */ CONST unsigned short usTTCIndex,	/* TTC Index, only used if TTC bit set */
			uint32 *pulOffsetTableOffset)
{
CONST_TTFACC_FILEBUFFERINFO InputBufferInfo;
int16 errCode = NO_ERROR;
TTC_HEADER TTCHeader;
uint16 usBytesRead;
uint32 ulOffset;

	InputBufferInfo.puchBuffer = puchSrcBuffer;
	InputBufferInfo.ulBufferSize = ulSrcBufferSize;
	InputBufferInfo.ulOffsetTableOffset = *pulOffsetTableOffset = 0;
	InputBufferInfo.lpfnReAllocate = NULL; /* can't reallocate input buffer */

	if ((errCode = ReadGeneric((TTFACC_FILEBUFFERINFO *) &InputBufferInfo, (uint8 *) &TTCHeader, SIZEOF_TTC_HEADER, TTC_HEADER_CONTROL, 0, &usBytesRead)) != NO_ERROR)
		return(errCode);
	ulOffset = usBytesRead;

	if (TTCHeader.TTCTag != TTC_LONG_TAG) /* this isn't a ttc */
		return ERR_NOT_TTC;	 /* offset set correctly for ttf */

	if (usTTCIndex >= TTCHeader.DirectoryCount)
		return ERR_INVALID_TTC_INDEX;

	ulOffset += GetGenericSize(LONG_CONTROL) * usTTCIndex;
	if ((errCode = ReadLong((TTFACC_FILEBUFFERINFO *) &InputBufferInfo, pulOffsetTableOffset, ulOffset)) != NO_ERROR)
		return(errCode);

	return errCode;
}
/* ---------------------------------------------------------------------- */
PRIVATE int16 ExitCleanup(int16 errCode)
{
  	Mem_End();
	return(errCode);
}
/* ------------------------------------------------------------------- */

PRIVATE int16 CopyOffsetDirectoryTables(CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
									   TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
									   uint16 usFormat, 
									   uint32 * pulNewOutOffset )
{
DIRECTORY *aDirectory;
DIRECTORY Directory;
OFFSET_TABLE OffsetTable;
DTTF_HEADER DttfHeader;
uint16 usnTables;
uint16 usnNewTables;
uint32 ulOffset;
uint32 ulDttfOffset;
uint16 usTableIdx;
uint16 usBytesRead;
uint16 usBytesWritten;
uint32 ulBytesWritten;
int16 errCode;

 	ulDttfOffset = TTTableOffset( (TTFACC_FILEBUFFERINFO *)pInputBufferInfo, DTTF_TAG); /* check to see if one there already */
	if (ulDttfOffset != DIRECTORY_ERROR)
	{
		if ((errCode = ReadGeneric((TTFACC_FILEBUFFERINFO *) pInputBufferInfo, (uint8 *) &DttfHeader, SIZEOF_DTTF_HEADER, DTTF_HEADER_CONTROL, ulDttfOffset, &usBytesRead)) != NO_ERROR)
			return(errCode);
		if (DttfHeader.format != TTFDELTA_MERGE) /* only acceptable delta font at this time */
			return(ERR_INVALID_DELTA_FORMAT);
	}

	/* read offset table and determine number of existing tables */
	ulOffset = pInputBufferInfo->ulOffsetTableOffset;
	if ((errCode = ReadGeneric((TTFACC_FILEBUFFERINFO *) pInputBufferInfo, (uint8 *) &OffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulOffset, &usBytesRead)) != NO_ERROR)
		return(errCode);
	usnTables = OffsetTable.numTables;
	ulOffset += usBytesRead;
	/* Create a list of valid tables */

	aDirectory = (DIRECTORY *) Mem_Alloc((usnTables + (ulDttfOffset == 0)) * sizeof(DIRECTORY));	/* one extra for possible private table */
	if (aDirectory == NULL)
		return(ERR_MEM);
	

	/* sort directories by offset */

	for ( usTableIdx = usnNewTables = 0; usTableIdx < usnTables; usTableIdx++ )
	{
 		errCode = ReadGeneric((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, (uint8 *) &Directory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesRead);
		ulOffset += usBytesRead;

		if (errCode != NO_ERROR)
		{
			Mem_Free(aDirectory);
			return errCode;
		}
		if (usFormat == TTFDELTA_DELTA)	/* need to get rid of some of the tables */
		{
			switch(Directory.tag)/* only want to keep these */
			{
			/* tables sent each time */
			case HEAD_LONG_TAG:
			case MAXP_LONG_TAG:
			case HHEA_LONG_TAG:
			case VHEA_LONG_TAG:
				/* tables subsetted */
			case CMAP_LONG_TAG:
			case GLYF_LONG_TAG:
			case EBLC_LONG_TAG:
			case EBDT_LONG_TAG:
			case BLOC_LONG_TAG:
			case BDAT_LONG_TAG:
				/* tables compacted */
			case LTSH_LONG_TAG:
			case HMTX_LONG_TAG:
			case VMTX_LONG_TAG:
			case HDMX_LONG_TAG:
			case LOCA_LONG_TAG:
				/* private table - keep shell */
			case DTTF_LONG_TAG:
				break;
			default:  /* any others, just get rid of */
			  continue; /* don't copy this over */
			}
		}

		/* empty out the entries */
		aDirectory[ usnNewTables ].length = 0;
		aDirectory[ usnNewTables ].offset = DIRECTORY_ERROR;
		aDirectory[ usnNewTables ].tag = Directory.tag; /* don't worry about the checksum */
		++ usnNewTables;
	}
	/* add in dttf entry */
	if (ulDttfOffset == 0 && usFormat == TTFDELTA_SUBSET1 || usFormat == TTFDELTA_DELTA)
	{
		aDirectory[ usnNewTables].length = 0;
		aDirectory[ usnNewTables].offset = DIRECTORY_ERROR;
		aDirectory[ usnNewTables].tag = DTTF_LONG_TAG;
		++usnNewTables;
		SortByTag( aDirectory, usnNewTables );	  /* to insert the dttf table */
	}

	OffsetTable.numTables = usnNewTables; /* don't worry if other fields not ok, will be updated in compress tables */
	ulOffset = pOutputBufferInfo->ulOffsetTableOffset;
	errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &OffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulOffset, &usBytesWritten);
	/* write out the new directory info to the output buffer */
	ulOffset += usBytesWritten;
	if (errCode == NO_ERROR)
	{
		errCode = WriteGenericRepeat( pOutputBufferInfo, (uint8 *) aDirectory, DIRECTORY_CONTROL, ulOffset, &ulBytesWritten, usnNewTables, SIZEOF_DIRECTORY );
		if (errCode == NO_ERROR)
			*pulNewOutOffset = ulOffset+ulBytesWritten;	 /* end of written to data */
	}
	Mem_Free(aDirectory);

	return(errCode);
}
/* ---------------------------------------------------------------------- */
PRIVATE int16 CopyForgottenTables( CONST_TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
								 TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
								 uint32 * pulNewOutOffset )
{
DIRECTORY *aDirectory;
OFFSET_TABLE OffsetTable;
uint16 usnTables;
uint16 usTableIdx;
uint16 usBytesRead;
uint32 ulBytesRead;
uint32 ulOffset;
int16 errCode;
char szTag[5];

	/* read offset table and determine number of existing tables */
	ulOffset = pOutputBufferInfo->ulOffsetTableOffset;
	if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &OffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulOffset, &usBytesRead)) != NO_ERROR)
		return(ERR_MEM);
	ulOffset += usBytesRead;

	usnTables = OffsetTable.numTables;
	/* Create a list of valid tables */

	aDirectory = (DIRECTORY *) Mem_Alloc((usnTables) * sizeof(DIRECTORY));
	if (aDirectory == NULL)
		return(ERR_MEM);

	errCode = ReadGenericRepeat( pOutputBufferInfo, (uint8 *) aDirectory, DIRECTORY_CONTROL, ulOffset, &ulBytesRead, usnTables, SIZEOF_DIRECTORY );

	if (errCode != NO_ERROR)
	{
		Mem_Free(aDirectory);
		return errCode;
	}
	/* sort directories by offset */

	SortByOffset( aDirectory, usnTables );	/* will sort all the zero offsets to the beginning */
	
	for ( usTableIdx = 0; usTableIdx < usnTables; usTableIdx++ )
	{
		/* copy the forgotten table from the input file to the output file */
		if (aDirectory[ usTableIdx ].length == 0 &&
			aDirectory[ usTableIdx ].offset == DIRECTORY_ERROR)
		{
			if (aDirectory[ usTableIdx ].tag != DELETETABLETAG)	/* it hasn't been marked for deletion */
			{
			/* Copy the table contents over, and update the directory */
				ConvertLongTagToString(aDirectory[ usTableIdx ].tag, szTag);
				if ((errCode = CopyTableOver( pOutputBufferInfo, pInputBufferInfo, szTag, pulNewOutOffset )) != NO_ERROR)
					break;
			}
		}
		else
			break; /* we're done with all the forgotten tables */
	}

	Mem_Free(aDirectory);

	return(errCode);
}
/* ---------------------------------------------------------------------- */

/* ---------------------------------------------------------------------- */
PRIVATE void FillGlyphIndexArray(CONST uint8 *puchKeepGlyphList, 
							CONST uint16 usGlyphListCount,
							uint16 *pusGlyphIndexArray,
							uint16 usDttfGlyphIndexCount)
{
uint16 i;
uint16 usGlyphIndex = 0;

	for (i = 0; i < usGlyphListCount && usGlyphIndex < usDttfGlyphIndexCount; ++i)
	{
		if (puchKeepGlyphList[i])
		{
			pusGlyphIndexArray[usGlyphIndex] = i;
			++usGlyphIndex;
		}
	}
}
/* ------------------------------------------------------------------- */
/* call this at the very end, before tables. */
/* ------------------------------------------------------------------- */
PRIVATE int16 CompactMaxpLocaTable(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
								 uint8 *puchKeepGlyphList, 
								 uint16 usGlyphListCount, 
								 uint16 usDttfGlyphIndexCount)
{
uint16 i,j;
uint16 usOffset;
uint16 usBytesWritten;
int16 errCode = NO_ERROR;
uint32 * aulLoca;
uint32 ulLocaLength;
uint32 ulHeadOffset;
uint32 ulLocaOffset;
uint32 ulMaxpOffset;
MAXP MaxP;
HEAD Head;

	/* Check if we need to collapse loca into a compact format */
	if (!usDttfGlyphIndexCount) /* it means we have a shorter list than the full glyph list */
		return errCode;

	if ((ulHeadOffset = GetHead(pOutputBufferInfo, &Head)) == 0L)
		errCode = ERR_MISSING_HEAD;
	aulLoca = Mem_Alloc( (usGlyphListCount + 1) * sizeof( uint32 ));
	if ( aulLoca == NULL )
		return ERR_MEM;

	if ((ulLocaOffset = GetLoca(pOutputBufferInfo, aulLoca, (uint16)(usGlyphListCount + 1))) == 0L)
	{
		Mem_Free(aulLoca);
		return ERR_MISSING_LOCA;
	}

	/* write out the compact 'loca' table */
	/* Check to see what format to use */
	if (Head.indexToLocFormat == SHORT_OFFSETS)   /* maximum number stored here */
	{
		for ( i = 0, j= 0; i <= usGlyphListCount && j <= usDttfGlyphIndexCount; i++ )
		{
			if ((puchKeepGlyphList[i]) || (j == usDttfGlyphIndexCount))
			{
				usOffset = (uint16) (aulLoca[ i ] / 2L);
				if ((errCode = WriteWord( pOutputBufferInfo,  usOffset, ulLocaOffset + j*sizeof(uint16) )) != NO_ERROR)
					break;
				++j;
			}
		}
		ulLocaLength = (uint32) (usDttfGlyphIndexCount+1) * sizeof(uint16);
	}
	else
	{
		for ( i = 0, j= 0; i <= usGlyphListCount && j <= usDttfGlyphIndexCount; i++ )
		{
			if ((puchKeepGlyphList[i]) || (j == usDttfGlyphIndexCount))
			{
				if ((errCode = WriteLong( pOutputBufferInfo,  aulLoca[ i ], ulLocaOffset + j*sizeof(uint32) )) != NO_ERROR)
					break;
				++j;
			}
		}
		ulLocaLength = (uint32) (usDttfGlyphIndexCount+1) * sizeof(uint32);
	}

	Mem_Free(aulLoca);
 	if ((errCode = UpdateDirEntry( pOutputBufferInfo, LOCA_TAG, ulLocaLength )) != NO_ERROR)
		return errCode;

	/* get old maxp record */
	if ((ulMaxpOffset = GetMaxp( pOutputBufferInfo, &MaxP)) == 0L)
   		return ERR_MISSING_MAXP;

	MaxP.numGlyphs = usDttfGlyphIndexCount;	/* set to fake value to save space in loca, hmtx, vmtx, hdmx, LTSH */
	if (errCode == NO_ERROR)
		errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &MaxP, SIZEOF_MAXP, MAXP_CONTROL, ulMaxpOffset, &usBytesWritten );
	return errCode;
}

/* ---------------------------------------------------------------------- */
/* if a private dttf table is needed, check to make sure there is room.
/* if there is:
  1. create the Directory entry
  2. Read in offset table
  3. Read in Directory entries
  4. If there is no dttf directory entry, 
	 a   move all data in file forward by size of directory entry - yech
	 b. Insert dttf entry in directory
	 c. update all offset values by the incremented value
  5. Otherwise, write out new dttf directory entry data w/ length
  7. Write the dttf table to the end of the file
  8. Re-calculate file checksum and update head table

/* ---------------------------------------------------------------------- */
PRIVATE int16 UpdatePrivateTable(TTFACC_FILEBUFFERINFO *pOutputBufferInfo, 
								uint32 *pulNewOutOffset, 
								CONST uint16 * pusGlyphIndexArray, 
								CONST uint16 usDttfGlyphIndexCount, 
								CONST uint16 usNumGlyphs, 
								CONST uint16 usFormat, 
								CONST uint32 ulCheckSum)
{	
DTTF_HEADER dttf_header;
DIRECTORY DttfDirectory;
uint32 ulOffset;
int16 errCode;
uint16 i;
uint16 usBytesWritten;
BOOL DttfWritten = FALSE;


	if (usFormat != TTFDELTA_SUBSET1 && usFormat != TTFDELTA_DELTA) /* formats with dttf tables */
		return NO_ERROR;

	ulOffset = GetTTDirectory( pOutputBufferInfo, DTTF_TAG, &DttfDirectory); 

	DttfDirectory.offset = *pulNewOutOffset + ZeroLongWordAlign(pOutputBufferInfo, *pulNewOutOffset); /* end of file */;
	DttfDirectory.length = GetGenericSize(DTTF_HEADER_CONTROL) + usDttfGlyphIndexCount * sizeof(uint16);

	if (ulOffset == DIRECTORY_ERROR)  /* there wasn't one there - don't really need this code - its obsolete  */
		return ERR_GENERIC;
	if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &DttfDirectory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesWritten)) != NO_ERROR)
		return errCode; /* update the length and offset */

	/* now write out that dttf table */
	dttf_header.version = CURRENT_DTTF_VERSION;
	dttf_header.checkSum = ulCheckSum;
	dttf_header.originalNumGlyphs = usNumGlyphs; 
	dttf_header.maxGlyphIndexUsed = pusGlyphIndexArray[usDttfGlyphIndexCount-1]; /* this is needed for format 1 fonts that become format 3 fonts after a merge */
	dttf_header.format = usFormat; 
	dttf_header.fflags = 0;
	dttf_header.glyphCount = usDttfGlyphIndexCount;
	ulOffset = DttfDirectory.offset;
	
	if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &dttf_header, SIZEOF_DTTF_HEADER, DTTF_HEADER_CONTROL, ulOffset, &usBytesWritten)) != NO_ERROR)
		return errCode;

	ulOffset += usBytesWritten;
	for (i = 0; i < usDttfGlyphIndexCount; ++i)
	{
		if ((errCode = WriteWord( pOutputBufferInfo, pusGlyphIndexArray[i], ulOffset)) != NO_ERROR)
			return errCode;
		ulOffset += sizeof(uint16);
	}
	ulOffset += ZeroLongWordAlign(pOutputBufferInfo, ulOffset);
	*pulNewOutOffset = ulOffset;

	return NO_ERROR;
}
/* Format Subset will keep all tables, but discard a percentage of the Glyf and EBDT tables */
/* Format Subset1 will keep all tables, but discard a percentage of the Glyf and EBDT tables */
/*                in addition any array tables (LTSH, loca, hmtx, hdmx, vmtx) will have a percentage discarded */
/* Format Delta will keep only a list of tables, and the Subset1 compacted and Glyf tables will keep only a portion */
/* ---------------------------------------------------------------------- */
PRIVATE void CalcOutputBufferSize(CONST_TTFACC_FILEBUFFERINFO *pInputBufferInfo,
								 uint16 usGlyphListCount,
								 uint16 usGlyphKeepCount,
								 uint16 usFormat,
								 uint32 ulSrcBufferSize,
								 uint32 *pulOutputBufferLength)
{
int32 flDiscardPercent, flKeepPercent;
uint32 ulGlyphDependentDataLength = 0;
uint32 ulEBDTTableLength = 0, ulEBDTTableOffset = 0;
uint32 ulBdatTableLength= 0;  
uint32 ulAllGlyphsLength= 0;  /* glyf, EBDT, bloc length */
uint32 ulDeletedTablesLength = 0;
uint32 ulKeepTablesLength = 0;

		/* make a good guess as to how much memory we will need */
		/* first figure out percentage of glyph's being discarded */
		flDiscardPercent =  ((usGlyphListCount - usGlyphKeepCount) *100 )/usGlyphListCount;
		flDiscardPercent -= 10;  /* subtract in 10% to reduce unneccesary reallocing */
		if (flDiscardPercent < 0)
			flDiscardPercent = 0;
		flKeepPercent = 100-flDiscardPercent;

		ulEBDTTableLength = TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, EBDT_TAG);
		/* check if EBDT and bdat are the same table */
		ulBdatTableLength =	TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, BDAT_TAG);
		if (ulEBDTTableLength != DIRECTORY_ERROR && ulEBDTTableLength == ulBdatTableLength)
		{
			ulEBDTTableOffset =	TTTableOffset((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, EBDT_TAG);
			if (ulEBDTTableOffset != TTTableOffset((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, BDAT_TAG))
				ulBdatTableLength = 0;			
		}
		ulAllGlyphsLength = ulEBDTTableLength + ulBdatTableLength;
		ulAllGlyphsLength += TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, GLYF_TAG);

		if (usFormat == TTFDELTA_DELTA || usFormat == TTFDELTA_SUBSET1)
		{  /* these formats will compact some tables, discarding a percentage of these tables as well */
				/* tables compacted */
			ulGlyphDependentDataLength = TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, LTSH_TAG);
			ulGlyphDependentDataLength += TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, HMTX_TAG);
			ulGlyphDependentDataLength += TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, VMTX_TAG);
			ulGlyphDependentDataLength += TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, HDMX_TAG);
			ulGlyphDependentDataLength += TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, LOCA_TAG);
		}
   		ulGlyphDependentDataLength += ulAllGlyphsLength; /* all formats will discard a percentage of the glyph data */

		if (usFormat == TTFDELTA_DELTA) /* we're going to keep just a handfull of tables tables */
		{
			ulKeepTablesLength = TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, HEAD_TAG);
			ulKeepTablesLength += TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, MAXP_TAG);
			ulKeepTablesLength += TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, HHEA_TAG);
			ulKeepTablesLength += TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, VHEA_TAG);
			ulKeepTablesLength += TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, CMAP_TAG);
			if (ulEBDTTableLength > 0)
				ulKeepTablesLength += TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, EBLC_TAG);
			if (ulBdatTableLength > 0)
				ulKeepTablesLength += TTTableLength((TTFACC_FILEBUFFERINFO *)pInputBufferInfo, BLOC_TAG);
			
 			*pulOutputBufferLength = ulKeepTablesLength + (uint32)(flKeepPercent * ulGlyphDependentDataLength/100);
		}
		else
		/* for straight subset, this will be: ulSrcBufferSize - (discard % * (Glyf table size + EBDT table size + bdat table size)) */
			*pulOutputBufferLength = ulSrcBufferSize - (uint32)(flDiscardPercent * ulGlyphDependentDataLength/100);
}
/* ---------------------------------------------------------------------- */
/* ENTRY POINT !!!!
/* ---------------------------------------------------------------------- */
/*   This is the entry point to the TTFSub library
	(CONST uint8 * puchSrcBuffer   is a pointer to buffer containing source TTF or TTC data
  	uint8 * puchDestBuffer         is a pointer to buffer for destination TTFData
	CONST uint32 ulBufferSize      is the size in bytes of puchSrcBuffer (and puchDestBuffer)
	uint32 * pulBytesWritten       is a pointer to a long integer where the length in bytes 
					               of the data written to the puchDestBuffer will be written.
	CONST uint16 usLanguage        is the language in the Name table to retain. Set to 0 
					               if all languages should be retained.
	CONST uint16 usPlatform        specifies, with usEncoding which Cmap to use. By using this 
					               cmap and the pusKeepCharCodeList, a list of glyphs to retain 
								   in the output font can be created. 
	CONST uint16 usEncoding        used with usPlatform. Set to TTFSUB_DONT_CARE if any encoding cmap will do.
	CONST uint16 *pusKeepCharCodeList is an array of integers which comprise a list of 
					               character codes that should be retained in the output font. 
					               This list may be unicode, if used with a unicode Platform-Encoding cmap,
				                   or it may be some other type of encoding.
	CONST uint16 usListCount       is the number of elements in the pusKeepCharCodeList
	CONST uint16 usTTCIndex        is the index of the TrueType Collection in the TTC data of the TTF
					               to extract. This will be ignored.
/* ---------------------------------------------------------------------- */
int16 SubsetTTF(CONST uint8 * puchSrcBuffer,
	      	uint8 * puchDestBuffer,
			CONST uint32 ulBufferSize,
			uint32 * pulBytesWritten,
			CONST uint16 usLanguage,
			CONST uint16 usPlatform,
			CONST uint16 usEncoding,
			CONST uint16 *pusKeepCharCodeList,
			CONST uint16 usListCount,
			CONST uint16 usTTCIndex)  
{
uint32 ulDestBufferSize = ulBufferSize;
uint8 * puchDestBufferLocal = puchDestBuffer; 
uint32 ulOffsetTableOffset=0;
int16 errCode;

		if (puchSrcBuffer == NULL) /* yoiks */
			return ERR_PARAMETER0;
		if (puchDestBuffer == NULL) /* yoiks */
			return ERR_PARAMETER1;
		if (ulBufferSize == 0) /* yoiks */
			return ERR_PARAMETER2;
		if (pulBytesWritten == NULL) /* yoiks */
			return ERR_PARAMETER3;

		errCode = TTCOffsetTableOffset(puchSrcBuffer,
			ulBufferSize, usTTCIndex, &ulOffsetTableOffset);
		if (errCode != NO_ERROR && errCode != ERR_NOT_TTC)
			return ERR_PARAMETER4;

		return CreateDeltaTTF(puchSrcBuffer,
			ulBufferSize,
	      	&puchDestBufferLocal, 
			&ulDestBufferSize,
			pulBytesWritten,
			0,
			usLanguage,
			usPlatform,
			usEncoding,
			TTFDELTA_CHARLIST,
			pusKeepCharCodeList,
			usListCount,
			NULL,
			NULL,
			ulOffsetTableOffset,
			NULL);

}

/* ---------------------------------------------------------------------- */
/* ENTRY POINT !!!!
/* ---------------------------------------------------------------------- */
/*	(CONST uint8 * puchSrcBuffer   is a pointer to buffer containing source TTF or TTC data
 	CONST uint32 ulSrcBufferSize   is the size in bytes of puchSrcBuffer 
 	uint8 ** ppuchDestBuffer       is a pointer to buffer pointer for destination TTFData. 
								   If this is null, it will be set by this function by calling lpfnReAllocate below.
 	uint32 *pulDestBufferSize	   is a pointer to a long integer that will be set with the size 
								   in bytes of puchDestBuffer 
	uint32 * pulBytesWritten       is a pointer to a long integer where the length in bytes 
					               of the data written to the puchDestBuffer will be written.
	CONST uint16 usFormat		   format of the subset font to create. 0 = Subset, 1 = Subset/Compact, 
								   2 = Subset/Delta
	CONST uint16 usLanguage        is the language in the Name table to retain. Set to 0 
					               if all languages should be retained.
	CONST uint16 usListType		   0 means KeepCharCodeList represents character codes from the Platform Encoding
								   cmap specified. 1 means the KeepCharCodeList represents raw Glyph indices from
								   the font.
	CONST uint16 usPlatform        specifies, which usEncoding which Cmap to use. By using this 
					               cmap and the pusKeepCharCodeList, a list of glyphs to retain 
								   in the output font can be created. Ignored for usListType = 1. 
	CONST uint16 usEncoding        used with usPlatform. Set to TTFSUB_DONT_CARE if any encoding cmap will do.
								   Ignored for usListType = 1. 
	CONST uint16 *pusSubsetCharCodeList  ignored for now. List of characters already subsetted. 
	CONST uint16 usSubsetListCount		 ignored for now  count of List of characters already subsetted. 
	CONST uint16 *pusKeepCharCodeList is an array of integers which comprise a list of 
					               character codes that should be retained in the output font. 
					               This list may be unicode, if used with a unicode Platform-Encoding cmap,
				                   or it may be some other type of encoding.
	CONST uint16 usListCount       is the number of elements in the pusKeepCharCodeList
	CFP_REALLOCPROC lpfnReAllocate	   function supplied to reallocate memory. Defined as
								   typedef void *(CFP_REALLOCPROC) (void *, size_t );
	void *lpvReserved
/* ---------------------------------------------------------------------- */
int16 CreateDeltaTTF(CONST uint8 * puchSrcBuffer,
			CONST uint32 ulSrcBufferSize,
	      	uint8 ** ppuchDestBuffer,
			uint32 * pulDestBufferSize,
			uint32 * pulBytesWritten,
			CONST uint16 usFormat,
			CONST uint16 usLanguage,
			CONST uint16 usPlatform,
			CONST uint16 usEncoding,
			CONST uint16 usListType,
			CONST uint16 *pusKeepCharCodeList,
			CONST uint16 usListCount,
			CFP_REALLOCPROC lpfnReAllocate,	  /* call back function to reallocate temp and output buffers */
			CFP_FREEPROC lpfnFree,	  /* call back function to output buffers on error */
			uint32 ulOffsetTableOffset,   /* for .ttf this will be 0, for .ttc, this will be a value */
			void *lpvReserved)
{
uint32 ulOffset = 0;
uint16 usGlyphListCount = 0;   /* number of glyph spots in font */
uint16 usDttfGlyphIndexCount = 0;   /* number of actual glyphs in font used for GlyphIndexArray */
uint16 usGlyphKeepCount = 0; /* number of actual glyphs in font */
uint8 *puchKeepGlyphList = NULL;  /* list of glyphs to keep (0 = don't keep, 1 = keep)	*/
uint16 *pusGlyphIndexArray = NULL;
uint16 usKeepExtraChar = 0;
int16 errCode = NO_ERROR;
uint16 usMaxGlyphIndexUsed;
uint16 OS2MinChr = USHRT_MAX;
uint16 OS2MaxChr = 0;
uint32 checkSumAdjustment; /* to save in private dttf table */
boolean Mod_HDMX = TRUE;
uint32 ulNewOutOffset = 0;
TTFACC_FILEBUFFERINFO OutputBufferInfo;	/* used by ttfacc routines */
CONST_TTFACC_FILEBUFFERINFO InputBufferInfo;

	/* Check inputs */
	if (puchSrcBuffer == NULL) 
		return ERR_PARAMETER0;
	if (ulSrcBufferSize == 0)
		return ERR_PARAMETER1;
	if (ppuchDestBuffer == NULL)
		return ERR_PARAMETER2;
	if (pulDestBufferSize == NULL)
		return ERR_PARAMETER3;
	if (pulBytesWritten == NULL)
		return ERR_PARAMETER4;
	if (usFormat > TTFDELTA_DELTA)  /* biggest one we know */
		return ERR_PARAMETER5;

	if (Mem_Init() != MemNoErr)	  /* initialize memory manager */
		return ERR_MEM;

	InputBufferInfo.puchBuffer = puchSrcBuffer;
	InputBufferInfo.ulBufferSize = ulSrcBufferSize;
	InputBufferInfo.ulOffsetTableOffset = ulOffsetTableOffset; /* will be non 0 for ttc support */
	InputBufferInfo.lpfnReAllocate = NULL; /* can't reallocate input buffer */

	/* initialize */
	*pulBytesWritten = 0;
	
	/* find out how many glyphs */
	usGlyphListCount = GetNumGlyphs((TTFACC_FILEBUFFERINFO *)&InputBufferInfo);
	if (usGlyphListCount == 0)
		return ExitCleanup(ERR_NO_GLYPHS);

	/* allocate array of glyphs to keep */
	puchKeepGlyphList = Mem_Alloc(usGlyphListCount * sizeof(uint8));
	if (puchKeepGlyphList == NULL)
		return ExitCleanup(ERR_MEM);

	/* read list of char codes from input list. Enter intersection of list and specified cmap into pusKeepCharCodeList. */
	if ((errCode = MakeKeepGlyphList((TTFACC_FILEBUFFERINFO *)&InputBufferInfo, usListType, usPlatform, usEncoding, pusKeepCharCodeList, usListCount, 
			puchKeepGlyphList, usGlyphListCount, &usMaxGlyphIndexUsed, &usGlyphKeepCount)) != NO_ERROR)
	{
		Mem_Free(puchKeepGlyphList);
		return ExitCleanup(errCode); 
	}
	/* Hey Donald, you could calculate your DSIG table anytime now */
	/* and while you're at it why don't you calculate a size delta if it will */
	/* grow or shrink from its original size */

	if (*ppuchDestBuffer == NULL || *pulDestBufferSize == 0) /* need to allocate some memory */
	{
		CalcOutputBufferSize(&InputBufferInfo, usGlyphListCount, usGlyphKeepCount, usFormat, ulSrcBufferSize, pulDestBufferSize);
#ifdef _DEBUG
/*		printf("Allocating %lu bytes for output buffer.\n", *pulDestBufferSize);  */
#endif
		/* ok Donald, before the allocation is done, why don't you update *pulDestBufferSize with */
		/* info from your DSIG table calculation */
		*ppuchDestBuffer = lpfnReAllocate(NULL, *pulDestBufferSize);
		if (*ppuchDestBuffer == NULL)
		{
			errCode = ERR_MEM;
			Mem_Free(puchKeepGlyphList);
			return ExitCleanup(errCode);
		}
	}

	OutputBufferInfo.puchBuffer = *ppuchDestBuffer;
	OutputBufferInfo.ulBufferSize = *pulDestBufferSize;
	OutputBufferInfo.ulOffsetTableOffset = 0;
	OutputBufferInfo.lpfnReAllocate = lpfnReAllocate;  /* for reallocation */

	if (usFormat == TTFDELTA_SUBSET1 || usFormat == TTFDELTA_DELTA)   /* if we will be trying to compact the font */
		usDttfGlyphIndexCount = usGlyphKeepCount;
	
	/* now call routines to modify each of the tables we care about. */
	/* ModMaxp must happen after ModGlyfLoca */
	/* must be called first followed by ModCmap. Then other tables may be processed in any order */
	/* lcp 4-10-97 output table order change to optimized rasterizer table access - order found in */
	/* ttfmerge.c g_DirOptimizeTagArray */
	/* modify glyph and loca before maxp, */
	/* modify hmtx before hdmx */
	/* modify cmap before os2 */
	
	while (1)	/* while loop used for handy break out */
	{	
		/* need to copy over directories for and make room for dttf table  */
		/* keep syncronised with calculations above */
		if (errCode = CopyOffsetDirectoryTables(&InputBufferInfo, &OutputBufferInfo, usFormat, &ulNewOutOffset)) break;	 /* sets pulNewOutOffset */
		/* this resulting font will have all the other tables and directory entries for the missing */
		/* tables with 0 length entries */ 
		/* now copy some static tables over to reserve space for them in the font */
		/* this is to conform to the table order for font access optimizations */
		if ((errCode = CopyTableOver( &OutputBufferInfo, &InputBufferInfo, HEAD_TAG, &ulNewOutOffset )) != NO_ERROR)
			break;
		if ((errCode = CopyTableOver( &OutputBufferInfo, &InputBufferInfo, HHEA_TAG, &ulNewOutOffset )) != NO_ERROR)
			break;
		if ((errCode = CopyTableOver( &OutputBufferInfo, &InputBufferInfo, MAXP_TAG, &ulNewOutOffset )) != NO_ERROR)
			break;
		/* don't care if these next tables aren't there */
		if (usFormat != TTFDELTA_DELTA)
		{
			CopyTableOver( &OutputBufferInfo, &InputBufferInfo, OS2_TAG, &ulNewOutOffset );
		}
		/* shorten hhea.numLongHorMetrics if possible. zero out unused entries */
		if (errCode = ModXmtxXhea(&InputBufferInfo, &OutputBufferInfo, puchKeepGlyphList, usGlyphListCount, usDttfGlyphIndexCount, usMaxGlyphIndexUsed, TRUE, &ulNewOutOffset))
		{
			if (errCode == ERR_WOULD_GROW)
				Mod_HDMX = FALSE;		/* turn off this flag */
			else
				break;
		}
		/* set to 0 any entries that have been removed */
		if (errCode = ModLTSH(&InputBufferInfo, &OutputBufferInfo, puchKeepGlyphList, usGlyphListCount, usDttfGlyphIndexCount, &ulNewOutOffset)) break;
		/* remove 4:3 ratio and 0:0 ratio (if a 1:1 already exists) */
		if (errCode = ModVDMX(&InputBufferInfo, &OutputBufferInfo, usFormat, &ulNewOutOffset)) break;
		/* set to 0 any entries that have been removed */
		if (Mod_HDMX == TRUE)	/* don't mod if hmtx was left alone */
		{
			if (errCode = ModHdmx(&InputBufferInfo, &OutputBufferInfo, puchKeepGlyphList, usGlyphListCount, usDttfGlyphIndexCount, &ulNewOutOffset)) break;
		}
		else
 			CopyTableOver( &OutputBufferInfo, &InputBufferInfo, HDMX_TAG, &ulNewOutOffset );

		/* update the Cmap to reflect changed glyph list. fragmented cmap subtables may grow */
		if (errCode = ModCmap(&InputBufferInfo, &OutputBufferInfo, puchKeepGlyphList, usGlyphListCount, &OS2MinChr, &OS2MaxChr, &ulNewOutOffset)) break;  

		if (usFormat != TTFDELTA_DELTA)
		{
			CopyTableOver( &OutputBufferInfo, &InputBufferInfo, FPGM_TAG, &ulNewOutOffset );
 			CopyTableOver( &OutputBufferInfo, &InputBufferInfo, PREP_TAG, &ulNewOutOffset );
			CopyTableOver( &OutputBufferInfo, &InputBufferInfo, CVT_TAG, &ulNewOutOffset );
		}
		/* may delete cvt, prep and fpgm if there are no instructions in glyf table */		
		/* copy up any glyphs that are to be kept, squeezing out unused glyphs - adds to &ulNewOutOffset */
		/* will copy over glyf, loca and head tables */
		/* Updates bounding box and clears file checksum */
		if (errCode = ModGlyfLocaAndHead(&InputBufferInfo, &OutputBufferInfo, puchKeepGlyphList, usGlyphListCount,  &checkSumAdjustment, &ulNewOutOffset)) break;
		/* glyph related maximums: contours, num glyphs... */
		if (errCode = ModMaxP(&InputBufferInfo, &OutputBufferInfo, &ulNewOutOffset)) break;
		/* metric related maximums (except bounding box);  */
		if (errCode = ModOS2(&InputBufferInfo, &OutputBufferInfo, OS2MinChr, OS2MaxChr, usFormat, &ulNewOutOffset)) break; 
		/* Modify Embedded bitmap tables - EBLC, EBDT, EBSC, as well as bloc, bdat, bsca */
		/* for Subset format remove any pairs where a member has been removed */
		/* for subset 1, copy entire table, not subset */
		/* for Delta format, don't copy table */
		if (errCode = ModKern(&InputBufferInfo, &OutputBufferInfo, puchKeepGlyphList, usGlyphListCount, usFormat, &ulNewOutOffset)) break;
		/* remove any MS platform name entries that are not usLanguage */
		/* will optimize the table format - share strings */
		if (errCode = ModName(&InputBufferInfo, &OutputBufferInfo, usLanguage, usFormat, &ulNewOutOffset)) break;
		/* change to format 3.0 if not already */
		if (errCode = ModPost(&InputBufferInfo, &OutputBufferInfo, usFormat, &ulNewOutOffset)) break;
		CopyTableOver( &OutputBufferInfo, &InputBufferInfo, GASP_TAG, &ulNewOutOffset );
		CopyTableOver( &OutputBufferInfo, &InputBufferInfo, PCLT_TAG, &ulNewOutOffset );
		CopyTableOver( &OutputBufferInfo, &InputBufferInfo, VHEA_TAG, &ulNewOutOffset );
		/* shorten vhea.numLongVerMetrics if possible. zero out unused entries */
		if (errCode = ModXmtxXhea(&InputBufferInfo, &OutputBufferInfo, puchKeepGlyphList, usGlyphListCount, usDttfGlyphIndexCount, usMaxGlyphIndexUsed, FALSE, &ulNewOutOffset))
			if (errCode != ERR_WOULD_GROW) /* the error we can live with, go on ahead */
				break;
		if (errCode = ModSbit(&InputBufferInfo, &OutputBufferInfo, puchKeepGlyphList, usGlyphListCount, &ulNewOutOffset)) break;
		/* for subset format modify TrueType Open tables BASE, JSTF, GSUB, GPOS, and GDEF */
		/* for subset 1, copy entire tables, not subset */
		/* for Delta format, don't copy table */
		if (errCode = ModTTO (&InputBufferInfo, &OutputBufferInfo, puchKeepGlyphList, usGlyphListCount, usFormat, &ulNewOutOffset)) break;
		break;
	}

	if (errCode == NO_ERROR)
	{
		if (usDttfGlyphIndexCount)   /* Subset1 and Delta we will be trying to compact the font */
		{
			errCode = CompactMaxpLocaTable(&OutputBufferInfo, puchKeepGlyphList, usGlyphListCount, usDttfGlyphIndexCount); 
			if (errCode == NO_ERROR)
			{
				/* now we need to allocate an array to keep a list of the actual glyphs we are keeping in the font */
				pusGlyphIndexArray = Mem_Alloc(usDttfGlyphIndexCount * sizeof(*pusGlyphIndexArray)); /* big as we would ever need */
				if (pusGlyphIndexArray == NULL)
					errCode = ERR_MEM; 
				else
				{
					FillGlyphIndexArray(puchKeepGlyphList, usGlyphListCount, pusGlyphIndexArray, usDttfGlyphIndexCount);
					/* update dttf table with glyph list */
					errCode = UpdatePrivateTable(&OutputBufferInfo, &ulNewOutOffset, pusGlyphIndexArray, usDttfGlyphIndexCount, usGlyphListCount, usFormat, checkSumAdjustment);
					Mem_Free(pusGlyphIndexArray);
				}
			}
		}
		/* Donald, if a DSIG table were to be added, this might be a good time */

		if (errCode == NO_ERROR) /* for Subset and Subset1, copy any other unknown tables */
			errCode = CopyForgottenTables(&InputBufferInfo, &OutputBufferInfo, &ulNewOutOffset);
		/* now, squeeze out any data in file buffer that is no longer referenced */
		if (errCode == NO_ERROR)
			errCode = CompressTables(&OutputBufferInfo, &ulNewOutOffset );
		if (errCode == NO_ERROR)
			SetFileChecksum(&OutputBufferInfo, ulNewOutOffset);	 /* include dttf directory */
	}

	/* free up memory used here */
	Mem_Free(puchKeepGlyphList);
	/* reset these in case they changed */
	if (errCode == NO_ERROR && ulNewOutOffset > ulSrcBufferSize) /* if the font grew!!! (because of format fixes, or fragmentation) */
		errCode = ERR_WOULD_GROW;	/* use the original font */
	if (errCode == NO_ERROR)
	{
		*ppuchDestBuffer = OutputBufferInfo.puchBuffer;
		*pulDestBufferSize = OutputBufferInfo.ulBufferSize;
		*pulBytesWritten = ulNewOutOffset;
	}
	else  /* lcp free this up on error, if we allocated it in here */
	{
		if (*ppuchDestBuffer == NULL && lpfnFree != NULL)  /* if we allocated it here */
			lpfnFree(OutputBufferInfo.puchBuffer);
	}

	return ExitCleanup(errCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttferror.h ===
/*
  * TTFerror.h: error codes returned by ttfdelta and ttfmerge modules - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */

#ifndef TTFERROR_DOT_H_DEFINED
#define TTFERROR_DOT_H_DEFINED        
/* Return codes */
#ifndef NO_ERROR
#define NO_ERROR 0
#endif
#ifndef ERR_GENERIC
#define ERR_GENERIC 1000  
#define ERR_READOUTOFBOUNDS 1001	/* trying to read from memory not allowed - data error? */
#define ERR_WRITEOUTOFBOUNDS 1002	/* trying to write to memory not allowed - data error? */
#define ERR_READCONTROL 1003	/* read control structure does not match data */
#define ERR_WRITECONTROL 1004	/* write control structure does not match data */
#define ERR_MEM 1005   /* error allocating memory */
#define ERR_FORMAT 1006 /* input data format error */
#endif

#define ERR_WOULD_GROW 1007 /* action would cause data to grow. use original data */
#define ERR_VERSION 1008	/* major dttf.version of the input data is greater than the version this program can read */
#define ERR_NO_GLYPHS 1009
#define ERR_INVALID_MERGE_FORMATS 1010 /* trying to merge fonts with the wrong dttf formats */
#define ERR_INVALID_MERGE_CHECKSUMS 1011  /* trying to merge 2 fonts from different mother font */
#define ERR_INVALID_MERGE_NUMGLYPHS 1012  /* trying to merge 2 fonts from different mother font */
#define	ERR_INVALID_DELTA_FORMAT	1013  /* trying to subset a format 1 or 2 font */
#define ERR_NOT_TTC 1014
#define ERR_INVALID_TTC_INDEX 1015


#define ERR_MISSING_CMAP 1030
#define ERR_MISSING_GLYF 1031
#define ERR_MISSING_HEAD 1032
#define ERR_MISSING_HHEA 1033
#define ERR_MISSING_HMTX 1034
#define ERR_MISSING_LOCA 1035
#define ERR_MISSING_MAXP 1036
#define ERR_MISSING_NAME 1037
#define ERR_MISSING_POST 1038
#define ERR_MISSING_OS2  1039
#define ERR_MISSING_VHEA 1040
#define ERR_MISSING_VMTX 1041
#define ERR_MISSING_HHEA_OR_VHEA 1042
#define ERR_MISSING_HMTX_OR_VMTX 1043
#define ERR_MISSING_EBDT 1044

#define ERR_INVALID_CMAP 1060
#define ERR_INVALID_GLYF 1061
#define ERR_INVALID_HEAD 1062
#define ERR_INVALID_HHEA 1063
#define ERR_INVALID_HMTX 1064
#define ERR_INVALID_LOCA 1065
#define ERR_INVALID_MAXP 1066
#define ERR_INVALID_NAME 1067
#define ERR_INVALID_POST 1068
#define ERR_INVALID_OS2 1069
#define ERR_INVALID_VHEA 1070
#define ERR_INVALID_VMTX 1071
#define ERR_INVALID_HHEA_OR_VHEA 1072
#define ERR_INVALID_HMTX_OR_VMTX 1073
																															 
#define ERR_INVALID_TTO 1080
#define ERR_INVALID_GSUB 1081
#define ERR_INVALID_GPOS 1082
#define ERR_INVALID_GDEF 1083
#define ERR_INVALID_JSTF 1084
#define ERR_INVALID_BASE 1085
#define ERR_INVALID_EBLC 1086
#define ERR_INVALID_LTSH 1087
#define	ERR_INVALID_VDMX 1088
#define	ERR_INVALID_HDMX 1089

#define ERR_PARAMETER0 1100  /* calling function argument 0 is invalid */
#define ERR_PARAMETER1 1101  /* calling function argument 1 is invalid */
#define ERR_PARAMETER2 1102  /* calling function argument 2 is invalid */
#define ERR_PARAMETER3 1103  /* calling function argument 3 is invalid */
#define ERR_PARAMETER4 1104  /* calling function argument 4 is invalid */
#define ERR_PARAMETER5 1105  /* calling function argument 5 is invalid */
#define ERR_PARAMETER6 1106  /* calling function argument 6 is invalid */
#define ERR_PARAMETER7 1107  /* calling function argument 7 is invalid */
#define ERR_PARAMETER8 1108  /* calling function argument 8 is invalid */
#define ERR_PARAMETER9 1109  /* calling function argument 9 is invalid */
#define ERR_PARAMETER10 1110  /* calling function argument 10 is invalid */
#define ERR_PARAMETER11 1111  /* calling function argument 11 is invalid */
#define ERR_PARAMETER12 1112  /* calling function argument 12 is invalid */
#define ERR_PARAMETER13 1113  /* calling function argument 13 is invalid */
#define ERR_PARAMETER14 1114  /* calling function argument 14 is invalid */
#define ERR_PARAMETER15 1115  /* calling function argument 15 is invalid */
#define ERR_PARAMETER16 1116  /* calling function argument 16 is invalid */


#endif /* TTFERROR_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttfmerge.c ===
/***************************************************************************
 * module: TTFmerge.C
 *
 * author: Louise Pathe [v-lpathe]
 * date:   Nov 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * Merge functions for MergeFontPackage library
 *
 **************************************************************************/

/* Inclusions ----------------------------------------------------------- */
#include <stdlib.h>
#include <string.h> /* for memcpy */

#include "typedefs.h"
#include "ttff.h"
#include "ttfacc.h"
#include "ttfcntrl.h"
#include "ttftabl1.h"
#include "ttfmerge.h"
#include "ttferror.h"  
#include "ttmem.h"
#include "util.h"
#include "ttftable.h"
#include "mergsbit.h"

/* ---------------------------------------------------------------------- */
PRIVATE int16 ExitCleanup(int16 errCode)
{
  	Mem_End();
	return(errCode);
}
/* ---------------------------------------------------------------------- */
/* Calculate the size of the font after array tables have been expanded from */
/* their compressed format (entries only for glyphs in subset) */ 
/* ---------------------------------------------------------------------- */
PRIVATE int16 CalcUncompactFontSize(TTFACC_FILEBUFFERINFO *pInputBufferInfo, 
								   uint32 *pulDestBufferSize)
{
int16 errCode = NO_ERROR;
uint16 usBytesRead;
uint16 usNumGlyphs;
uint32 ulDttfOffset;
uint32 ulDttfLength;
uint32 ulOffset;
uint32 ulLength;
uint32 ulUncompactSize;
HDMX hdmx;
DTTF_HEADER dttf;
HEAD head; 

	ulDttfOffset = TTTableOffset( pInputBufferInfo, DTTF_TAG );
	ulDttfLength = TTTableLength( pInputBufferInfo, DTTF_TAG);
	if (ulDttfOffset != DIRECTORY_ERROR && 	ulDttfLength != 0)
		errCode = ReadGeneric(pInputBufferInfo, (uint8 *) &dttf, SIZEOF_DTTF_HEADER, DTTF_HEADER_CONTROL, ulDttfOffset, &usBytesRead);
	if (errCode != NO_ERROR)
		return errCode;

	*pulDestBufferSize = pInputBufferInfo->ulBufferSize; /* this is the start size. We will add the delta of uncompressing to this */
	if (dttf.format != TTFDELTA_SUBSET1 && dttf.format != TTFDELTA_DELTA) /* the only compact format */
		return NO_ERROR;

	usNumGlyphs = dttf.originalNumGlyphs; /* number of glyphs in original font*/

	/* calc uncompact size of LTSH, hmtx, vmtx and hdmx and loca table */
	/* first LTSH */
	ulOffset = TTTableOffset( pInputBufferInfo, LTSH_TAG );
	if (ulOffset != DIRECTORY_ERROR) /* need to calculate the delta of the uncompact size */
	{
		ulLength = TTTableLength( pInputBufferInfo, LTSH_TAG);
		ulUncompactSize = SIZEOF_LTSH_YPELS * usNumGlyphs + GetGenericSize(LTSH_CONTROL);
		*pulDestBufferSize += (RoundToLongWord(ulUncompactSize) - RoundToLongWord(ulLength)); /* add in the delta */
	}
	/* next hmtx */
	ulOffset = TTTableOffset( pInputBufferInfo, HMTX_TAG );
	if (ulOffset != DIRECTORY_ERROR) /* need to calculate the delta of the uncompact size */
	{
		ulLength = TTTableLength( pInputBufferInfo, HMTX_TAG);
		ulUncompactSize = usNumGlyphs * GetGenericSize(LONGHORMETRIC_CONTROL); /* worst case */
		*pulDestBufferSize += (RoundToLongWord(ulUncompactSize) - RoundToLongWord(ulLength)); /* add in the delta */
	}
	/* next vmtx */
	ulOffset = TTTableOffset( pInputBufferInfo, VMTX_TAG );
	if (ulOffset != DIRECTORY_ERROR) /* need to calculate the delta of the uncompact size */
	{
		ulLength = TTTableLength( pInputBufferInfo, VMTX_TAG);
		ulUncompactSize = usNumGlyphs * GetGenericSize(LONGVERMETRIC_CONTROL); /* worst case */
		*pulDestBufferSize += (RoundToLongWord(ulUncompactSize) - RoundToLongWord(ulLength)); /* add in the delta */
	}
 	/* next hdmx */
	ulOffset = GetHdmx( pInputBufferInfo, &hdmx);
	if (ulOffset != 0L) /* need to calculate the delta of the uncompact size */
	{
		ulLength = TTTableLength( pInputBufferInfo, HDMX_TAG);
 		/* calculate the length of the HDMX + the HDMX Device Records and widths arrays */
		ulUncompactSize = usBytesRead + (hdmx.numDeviceRecords * (RoundToLongWord(GetGenericSize(HDMX_DEVICE_REC_CONTROL) + usNumGlyphs))); 
		*pulDestBufferSize += (RoundToLongWord(ulUncompactSize) - RoundToLongWord(ulLength)); /* add in the delta */
	}
	/* next loca */
	ulOffset = GetHead(pInputBufferInfo, &head);
	if (ulOffset == 0L)
		return ERR_MISSING_HEAD;
	ulOffset = TTTableOffset( pInputBufferInfo, LOCA_TAG );
	if (ulOffset == DIRECTORY_ERROR) /* need to calculate the delta of the uncompact size */
		return ERR_MISSING_LOCA;
 	ulLength = TTTableLength( pInputBufferInfo, LOCA_TAG);
 	/* calculate the length of the HDMX + the HDMX Device Records and widths arrays */
	if (head.indexToLocFormat == 0)
		ulUncompactSize = (usNumGlyphs+1) * sizeof(uint16);
	else
		ulUncompactSize = (usNumGlyphs+1) * sizeof(uint32);
	*pulDestBufferSize += (RoundToLongWord(ulUncompactSize) - RoundToLongWord(ulLength)); /* add in the delta */
	return NO_ERROR;
}
/* ---------------------------------------------------------------------- */
/* we're going to use this for VMTX as well, even though we use LONGHORMETRICS etc */
/* this routine will create an expanded HMTX or VMTX table from the compact form, adding */
/* one dummy long metrics after the last metric from the compact table (pGlyphIndexArray[usGlyphCount-1])
/* then a bunch of zeros after for the short metrics. The calling function must understand this */
/* behavior so that it can set the hhea and vhea numLongMetrics correctly */
/* ---------------------------------------------------------------------- */
PRIVATE int16 UnCompactXmtx(TTFACC_FILEBUFFERINFO *pInputBufferInfo,
						   TTFACC_FILEBUFFERINFO *pOutputBufferInfo, 
						   uint32 ulInOffset,  /* offset to beginning of HMTX table in Input buffer */
						   uint32 ulOutOffset, /* offset to beginning of HMTX table in Output buffer */
						   uint16 numGlyphs,   /* maxp.numGlyphs from input buffer */
						   uint16 usGlyphCount,/* dttf.glyphCount from input buffer */ 
						   uint16 *pGlyphIndexArray, /* array of GlyphIndices for the HMTX table elements */
						   uint16 *pNumLongMetrics,  /* input - number of long metrics from xhea, output new number */
						   uint32 *pulBytesWritten)
{
uint16 usInputIndex, usOutputIndex;
int16 errCode = NO_ERROR;
uint16 usBytesWritten;
uint16 usBytesRead;
uint16 xsb;
uint16 usNumLongMetrics = 0;
LONGXMETRIC lxm;
LONGXMETRIC zerolxm;

	*pulBytesWritten = 0;
	zerolxm.advanceX = 0;
	zerolxm.xsb = 0;
	for (usOutputIndex = usInputIndex = 0; usOutputIndex < numGlyphs; ++usOutputIndex)
	{
		if (usInputIndex < *pNumLongMetrics) 
		{
			if (usOutputIndex == pGlyphIndexArray[usInputIndex]) /* this one should come from the input table */
			{
				if ((errCode = ReadGeneric(pInputBufferInfo, (uint8 *) &lxm, SIZEOF_LONGXMETRIC, LONGXMETRIC_CONTROL, ulInOffset, &usBytesRead)) != NO_ERROR)
					return errCode;
				ulInOffset += usBytesRead;
				if ((errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &lxm, SIZEOF_LONGXMETRIC, LONGXMETRIC_CONTROL, ulOutOffset+*pulBytesWritten, &usBytesWritten)) != NO_ERROR)
					return errCode;
				if (usInputIndex == *pNumLongMetrics-1)  /* that last one, need to set the new numlongmetrics */
					usNumLongMetrics = usOutputIndex+1;
				++ usInputIndex;

			}
			else 
			{
 				if ((errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &zerolxm, SIZEOF_LONGXMETRIC, LONGXMETRIC_CONTROL, ulOutOffset+*pulBytesWritten, &usBytesWritten)) != NO_ERROR)
					return errCode;
			}
			*pulBytesWritten += usBytesWritten;
		}
		else
		{
			if (usInputIndex < usGlyphCount && usOutputIndex == pGlyphIndexArray[usInputIndex]) /* this one should come from the input table */
			{
				if ((errCode = ReadWord(pInputBufferInfo, &xsb, ulInOffset)) != NO_ERROR)
					return errCode;
				ulInOffset += sizeof(uint16);
   				if ((errCode = WriteWord(pOutputBufferInfo, xsb, ulOutOffset+*pulBytesWritten)) != NO_ERROR)
					return errCode;
				++ usInputIndex;
			}
		/* note: in the case that there are only long metrics in the compact table, we need to add a dummy zero entry */
			/* in this way, the remainder of the glyphs will have an advance width of 0 */
			else if ((usGlyphCount == *pNumLongMetrics) && (usInputIndex == usGlyphCount)) /* we processed the last one- no short metrics */
			{
				if ((errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &zerolxm, SIZEOF_LONGXMETRIC, LONGXMETRIC_CONTROL, ulOutOffset+*pulBytesWritten, &usBytesWritten)) != NO_ERROR)
					return errCode;
				*pulBytesWritten += usBytesWritten;
				++ usNumLongMetrics;
				++ usInputIndex; /* bump this so we only do this once */
				continue;
			}
			else
			{
				if ((errCode = WriteWord(pOutputBufferInfo, 0, ulOutOffset+*pulBytesWritten)) != NO_ERROR)
					return errCode;
			}
			*pulBytesWritten += sizeof(uint16);
		}
	}
	*pNumLongMetrics = usNumLongMetrics;
	return NO_ERROR;

}
/* ---------------------------------------------------------------------- */
PRIVATE int16 UnCompactLTSH(TTFACC_FILEBUFFERINFO *pInputBufferInfo,
						   TTFACC_FILEBUFFERINFO *pOutputBufferInfo, 
						   uint32 ulInOffset,  /* offset to beginning of HMTX table in Input buffer */
						   uint32 ulOutOffset, /* offset to beginning of HMTX table in Output buffer */
						   uint16 numGlyphs,   /* maxp.numGlyphs from input buffer */
						   uint16 usGlyphCount,/* dttf.glyphCount from input buffer */ 
						   uint16 *pGlyphIndexArray, /* array of GlyphIndices for the HMTX table elements */
						   uint32 *pulBytesWritten)
{
uint16 usInputIndex, usOutputIndex;
int16 errCode = NO_ERROR;
uint16 usBytesRead;
uint16 usBytesWritten;
LTSH ltsh;
uint8 byteValue;

	*pulBytesWritten = 0;

	if ((errCode = ReadGeneric(pInputBufferInfo, (uint8 *) &ltsh, SIZEOF_LTSH, LTSH_CONTROL, ulInOffset, &usBytesRead)) != NO_ERROR)
		return errCode;
	ulInOffset += usBytesRead;
	if (usGlyphCount != ltsh.numGlyphs)
		return ERR_INVALID_LTSH;
	ltsh.numGlyphs = numGlyphs; /* reset to the real value */
	if ((errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &ltsh, SIZEOF_LTSH, LTSH_CONTROL, ulOutOffset, &usBytesWritten)) != NO_ERROR)
		return errCode;
	*pulBytesWritten += usBytesWritten;

	for (usOutputIndex = usInputIndex = 0; usOutputIndex < numGlyphs; ++usOutputIndex)
	{
		if ((usInputIndex < usGlyphCount) && (usOutputIndex == pGlyphIndexArray[usInputIndex])) /* this one should come from the input table */
		{
			if ((errCode = ReadByte(pInputBufferInfo, &byteValue, ulInOffset)) != NO_ERROR)
				return errCode;
			ulInOffset += sizeof(uint8);
			if ((errCode = WriteByte(pOutputBufferInfo, byteValue, ulOutOffset+*pulBytesWritten)) != NO_ERROR)
				return errCode;
			++ usInputIndex;
		}
		else   /* set to 1 = always scales linearly */
		{
 			if ((errCode = WriteByte(pOutputBufferInfo, 1, ulOutOffset+*pulBytesWritten)) != NO_ERROR)
				return errCode;
		}
		*pulBytesWritten += sizeof(uint8);
	}
	return NO_ERROR;
}
/* ---------------------------------------------------------------------- */
PRIVATE int16 UnCompactHDMX(TTFACC_FILEBUFFERINFO *pInputBufferInfo,
						   TTFACC_FILEBUFFERINFO *pOutputBufferInfo, 
						   uint32 ulInOffset,  /* offset to beginning of HDMX table in Input buffer */
						   uint32 ulOutOffset, /* offset to beginning of HDMX table in Output buffer */
						   uint16 numGlyphs,   /* maxp.numGlyphs from input buffer */
						   uint16 usGlyphCount,/* dttf.glyphCount from input buffer */ 
						   uint16 *pGlyphIndexArray, /* array of GlyphIndices for the HDMX table elements */
						   uint32 *pulBytesWritten)
{
uint16 usInputIndex, usOutputIndex;
int16 errCode = NO_ERROR;
uint16 i;
uint16 usBytesRead;
uint16 usBytesWritten;
uint32 ulInSizeDevRecord;
uint32 ulInDevRecordOffset;
HDMX hdmx;
HDMX_DEVICE_REC hdmx_dev_rec;
uint8 byteValue;

	*pulBytesWritten = 0;

	if ((errCode = ReadGeneric(pInputBufferInfo, (uint8 *) &hdmx, SIZEOF_HDMX, HDMX_CONTROL, ulInOffset, &usBytesRead)) != NO_ERROR)
		return errCode;
	ulInOffset += usBytesRead;
	ulInSizeDevRecord = hdmx.sizeDeviceRecord; 
	ulInDevRecordOffset = ulInOffset;
	hdmx.sizeDeviceRecord = RoundToLongWord(GetGenericSize(HDMX_DEVICE_REC_CONTROL) + (sizeof(uint8) * numGlyphs)); /* reset to the real value */
	if ((errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &hdmx, SIZEOF_HDMX, HDMX_CONTROL, ulOutOffset, &usBytesWritten)) != NO_ERROR)
		return errCode;
	*pulBytesWritten += usBytesWritten;

	for (i = 0 ; i < hdmx.numDeviceRecords; ++i)
	{
 		ulInOffset = ulInDevRecordOffset + (i * ulInSizeDevRecord);
		if ((errCode = ReadGeneric(pInputBufferInfo, (uint8 *) &hdmx_dev_rec, SIZEOF_HDMX_DEVICE_REC, HDMX_DEVICE_REC_CONTROL, ulInOffset, &usBytesRead)) != NO_ERROR)
			return errCode;
		ulInOffset += usBytesRead;
		if ((errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &hdmx_dev_rec, SIZEOF_HDMX_DEVICE_REC, HDMX_DEVICE_REC_CONTROL, ulOutOffset + *pulBytesWritten, &usBytesWritten)) != NO_ERROR)
			return errCode;
		*pulBytesWritten += usBytesWritten;

		for (usOutputIndex = usInputIndex = 0; usOutputIndex < numGlyphs; ++usOutputIndex)
		{
			if ((usInputIndex < usGlyphCount) && (usOutputIndex == pGlyphIndexArray[usInputIndex])) /* this one should come from the input table */
			{
				if ((errCode = ReadByte(pInputBufferInfo, &byteValue, ulInOffset)) != NO_ERROR)
					return errCode;
				ulInOffset += sizeof(uint8);
				if ((errCode = WriteByte(pOutputBufferInfo, byteValue, ulOutOffset+*pulBytesWritten)) != NO_ERROR)
					return errCode;
				++ usInputIndex;
			}
			else  
			{
 				if ((errCode = WriteByte(pOutputBufferInfo, 0, ulOutOffset+*pulBytesWritten)) != NO_ERROR)
					return errCode;
			}
			*pulBytesWritten += sizeof(uint8);
		}
		*pulBytesWritten += ZeroLongWordAlign(pOutputBufferInfo, ulOutOffset+*pulBytesWritten);
	}
	return NO_ERROR;
}

/* ---------------------------------------------------------------------- */
PRIVATE int16 UnCompactLOCA(TTFACC_FILEBUFFERINFO *pInputBufferInfo,
						   TTFACC_FILEBUFFERINFO *pOutputBufferInfo, 
						   uint32 ulInOffset,  /* offset to beginning of LOCA table in Input buffer */
						   uint32 ulOutOffset, /* offset to beginning of LOCA table in Output buffer */
						   uint16 numGlyphs,   /* dttf.OriginalNumGlyphs from input buffer */
						   uint16 usGlyphCount,/* dttf.glyphCount from input buffer */ 
						   uint16 *pGlyphIndexArray, /* array of GlyphIndices for the LOCA table elements */
						   uint32 *pulBytesWritten)
{
uint16 usInputIndex, usOutputIndex;
int16 errCode = NO_ERROR;
HEAD head;
uint16 usValue=0;
uint32 ulValue=0;

	*pulBytesWritten = 0;
	if (GetHead(pInputBufferInfo, &head) == 0L)  /* need to find index to loc format */
		return ERR_MISSING_HEAD;

	if (head.indexToLocFormat == 0)
	{
		/* read the first offset by itself */
		if ((errCode = ReadWord(pInputBufferInfo, &usValue, ulInOffset)) != NO_ERROR)
			return errCode;
		ulInOffset += sizeof(uint16);
		for (usOutputIndex = usInputIndex = 0; usOutputIndex <= numGlyphs; ++usOutputIndex)	   /* <= for extra "last" glyph */
		{
			if ((errCode = WriteWord(pOutputBufferInfo, usValue, ulOutOffset+*pulBytesWritten)) != NO_ERROR)
				return errCode;
			*pulBytesWritten += sizeof(uint16);
			if ((usInputIndex < usGlyphCount) && (usOutputIndex == pGlyphIndexArray[usInputIndex])) /* this one should come from the input table */
			{	/* read the next word for next time */
				if ((errCode = ReadWord(pInputBufferInfo, &usValue, ulInOffset)) != NO_ERROR)
					return errCode;
				ulInOffset += sizeof(uint16);
				++ usInputIndex;
			}
		}
	}
	else
 	{
		/* read the first offset by itself */
		if ((errCode = ReadLong(pInputBufferInfo, &ulValue, ulInOffset)) != NO_ERROR)
			return errCode;
		ulInOffset += sizeof(uint32);
		for (usOutputIndex = usInputIndex = 0; usOutputIndex <= numGlyphs; ++usOutputIndex)
		{
			if ((errCode = WriteLong(pOutputBufferInfo, ulValue, ulOutOffset+*pulBytesWritten)) != NO_ERROR)
				return errCode;
			*pulBytesWritten += sizeof(uint32);
			if ((usInputIndex < usGlyphCount) && (usOutputIndex == pGlyphIndexArray[usInputIndex])) /* this one should come from the input table */
			{	/* read the next word for next time */
				if ((errCode = ReadLong(pInputBufferInfo, &ulValue, ulInOffset)) != NO_ERROR)
					return errCode;
				ulInOffset += sizeof(uint32);
				++ usInputIndex;
			}
		}
	}

	return NO_ERROR;
}
/* ---------------------------------------------------------------------- */
/* uncompact and copy the data from the puchDeltaFontBuffer to *ppuchDestBuffer */
/* set the 'dttf' format value to 3, */
/* remove the dttf.GlyphIndexArray */
/* similar to compresstables */
/* ---------------------------------------------------------------------- */

PRIVATE int16 UnCompactSubset1Font(TTFACC_FILEBUFFERINFO *pInputBufferInfo, 	/* input compact format 1 font */
						TTFACC_FILEBUFFERINFO *pOutputBufferInfo, /* where to write the output */
						uint16 usGlyphCount, 					  /* number of elements in the pGlyphIndexArray from the Delta font */
						uint16 *pGlyphIndexArray, 				  /* holds the mapping between entries in the Loca and actual Glyph Index numbers */
						uint16 usNumGlyphs, 						  /* number of glyphs in the original (uncompact) font. Should match number in the merge font */
						uint32 *pulBytesWritten)				  /* number of bytes written to the Output buffer */
{
DIRECTORY *aDirectory;
uint16 i;
OFFSET_TABLE  OffsetTable;
uint16 usnTables;
uint32 ulOffset;
uint32 ulOutOffset;
uint16 usTableIdx;
uint16 usBytesRead;
uint16 usBytesWritten;
uint32 ulBytesWritten;
uint16 DoTwo;
int16 errCode=NO_ERROR;
HHEA hhea;
VHEA vhea;
MAXP maxp;
HEAD head;
DTTF_HEADER dttf;
XHEA XHea;
int16 hhea_index = -1;
int16 vhea_index = -1;
uint16 numLongHorMetrics = 0;
uint16 numLongVerMetrics = 0;

	/* read offset table and determine number of existing tables */

	if (GetHHea(pInputBufferInfo, (HHEA *) &XHea) == 0L)
		return ERR_MISSING_HHEA;
	numLongHorMetrics = XHea.numLongMetrics;
	if (GetVHea(pInputBufferInfo, (VHEA *) &XHea) != 0L)
		numLongVerMetrics = XHea.numLongMetrics;

	ulOffset = pInputBufferInfo->ulOffsetTableOffset;
	if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) &OffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulOffset, &usBytesRead)) != NO_ERROR)
		return(errCode);
	usnTables = OffsetTable.numTables;
	ulOffset += usBytesRead;
	/* Create a list of valid tables */

	aDirectory = (DIRECTORY *) Mem_Alloc(usnTables * SIZEOF_DIRECTORY);
	if (aDirectory == NULL)
		return(ERR_MEM);

	for (i = 0; i < usnTables; ++i )
	{
		if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) &(aDirectory[ i ]), SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR)
			break;
		ulOffset += usBytesRead;
	}

	if (errCode != NO_ERROR)
	{
		Mem_Free(aDirectory);
		return errCode;
	}


	/* sort directories by offset, so we can see if 2 or more tables share data */

	SortByOffset( aDirectory, usnTables );
	
	/* uncompact table data and adjust directory entries to reflect
	the changes */
	ulOutOffset = pInputBufferInfo->ulOffsetTableOffset + GetGenericSize( OFFSET_TABLE_CONTROL ) + (usnTables * GetGenericSize( DIRECTORY_CONTROL ));
	/* zero out any pad bytes  */
	ulOutOffset += ZeroLongWordAlign( pOutputBufferInfo, ulOutOffset);
	DoTwo = FALSE;
	for ( usTableIdx = 0; usTableIdx < usnTables; usTableIdx++ )
	{
		/* copy the table from where it currently is to the output file */
	  ulBytesWritten = 0;
	  if (!DoTwo)	  /* if not the 2nd of two directories pointing to the same data */
	  {
		if (usGlyphCount > 0)
		{
			switch(aDirectory[usTableIdx].tag)	  /* ~ portable? */
			{
				case HMTX_LONG_TAG: 
					errCode = UnCompactXmtx(pInputBufferInfo, pOutputBufferInfo, aDirectory[usTableIdx].offset, ulOutOffset, usNumGlyphs, usGlyphCount, pGlyphIndexArray, &numLongHorMetrics, &ulBytesWritten); 
					break;
				case VMTX_LONG_TAG: 
					errCode = UnCompactXmtx(pInputBufferInfo, pOutputBufferInfo, aDirectory[usTableIdx].offset, ulOutOffset, usNumGlyphs, usGlyphCount, pGlyphIndexArray, &numLongVerMetrics, &ulBytesWritten); 
					break;
				case LTSH_LONG_TAG: 
					errCode = UnCompactLTSH(pInputBufferInfo, pOutputBufferInfo, aDirectory[usTableIdx].offset, ulOutOffset, usNumGlyphs, usGlyphCount, pGlyphIndexArray, &ulBytesWritten); 
					break;
				case HDMX_LONG_TAG: 
					errCode = UnCompactHDMX(pInputBufferInfo, pOutputBufferInfo, aDirectory[usTableIdx].offset, ulOutOffset, usNumGlyphs, usGlyphCount, pGlyphIndexArray, &ulBytesWritten); 
					break;
				case LOCA_LONG_TAG: 
					errCode = UnCompactLOCA(pInputBufferInfo, pOutputBufferInfo, aDirectory[usTableIdx].offset, ulOutOffset, usNumGlyphs, usGlyphCount, pGlyphIndexArray, &ulBytesWritten); 
					break;
				case DTTF_LONG_TAG:   /* need to truncate the GlyphIndexArray table */
					if ((errCode = ReadGeneric(pInputBufferInfo, (uint8 *) &dttf, SIZEOF_DTTF_HEADER, DTTF_HEADER_CONTROL, aDirectory[usTableIdx].offset, &usBytesRead)) == NO_ERROR)
					{
						dttf.glyphCount = 0;
						dttf.format = TTFDELTA_MERGE; 
						errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &dttf, SIZEOF_DTTF_HEADER, DTTF_HEADER_CONTROL, ulOutOffset, &usBytesWritten);
						ulBytesWritten = usBytesWritten;
					}
					break;
				case MAXP_LONG_TAG:  /* need to update the numGlyphs */
					if ((errCode = ReadGeneric(pInputBufferInfo, (uint8 *) &maxp, SIZEOF_MAXP, MAXP_CONTROL, aDirectory[usTableIdx].offset, &usBytesRead)) == NO_ERROR)
					{
						maxp.numGlyphs = usNumGlyphs; 
						errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &maxp, SIZEOF_MAXP, MAXP_CONTROL, ulOutOffset, &usBytesWritten);
						ulBytesWritten = usBytesWritten;
					}
					break;
				case HHEA_LONG_TAG:  /* need to remember this table's index, to modify later */
					if ((errCode = ReadGeneric(pInputBufferInfo, (uint8 *) &hhea, SIZEOF_HHEA, HHEA_CONTROL, aDirectory[usTableIdx].offset, &usBytesRead)) == NO_ERROR)
						hhea_index = usTableIdx;
					break;
				case VHEA_LONG_TAG:  /* need to remember this table's index, to modify later */
					if ((errCode = ReadGeneric(pInputBufferInfo, (uint8 *) &vhea, SIZEOF_VHEA, VHEA_CONTROL, aDirectory[usTableIdx].offset, &usBytesRead)) == NO_ERROR)
						vhea_index = usTableIdx;
					break;
				case HEAD_LONG_TAG: 
					if ((errCode = ReadGeneric(pInputBufferInfo, (uint8 *) &head, SIZEOF_HEAD, HEAD_CONTROL, aDirectory[usTableIdx].offset, &usBytesRead)) == NO_ERROR)
					{
						head.checkSumAdjustment = 0; 
						errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &head, SIZEOF_HEAD, HEAD_CONTROL, ulOutOffset, &usBytesWritten);
						ulBytesWritten = usBytesWritten;
					}
					break;
			}
		}
		if (errCode != NO_ERROR)
			break;

		if (ulBytesWritten == 0 && aDirectory[usTableIdx].length)  /* nothing happened yet */
			CopyBlockOver(pOutputBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *)pInputBufferInfo, ulOutOffset, aDirectory[usTableIdx].offset, aDirectory[usTableIdx].length);
		else
			aDirectory[ usTableIdx ].length = ulBytesWritten;


		if (usTableIdx + 1 < usnTables)
		{  /* special case for bloc and bdat tables */
			if ( (aDirectory[ usTableIdx ].offset == aDirectory[ usTableIdx + 1 ].offset) &&
				 (aDirectory[ usTableIdx ].length != 0) 
			   )
			{
				DoTwo = TRUE;  /* need to process 2 directories pointing to same data */
				aDirectory[ usTableIdx + 1 ].offset = ulOutOffset;
				aDirectory[ usTableIdx + 1 ].length = aDirectory[ usTableIdx ].length;
			}
		}
		aDirectory[ usTableIdx ].offset = ulOutOffset;

		/* calc offset for next table */
		ulOutOffset += aDirectory[ usTableIdx ].length;
		ulOutOffset += ZeroLongWordAlign( pOutputBufferInfo, ulOutOffset); /* align so checksum will work */
	  }
	  else
		 DoTwo = FALSE; /* so next time we'll perform the copy */
		/* and determine the checksum for the entry */
	  CalcChecksum( pOutputBufferInfo, aDirectory[ usTableIdx ].offset, aDirectory[ usTableIdx ].length, &(aDirectory[ usTableIdx ].checkSum) );
	}

	while (errCode == NO_ERROR)	/* so we can break out on error */
	{
		/* may need to update hhea and vhea if hmtx or vmtx were compacted */
		if (hhea_index != -1)
		{
			hhea.numLongMetrics = numLongHorMetrics;
			errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &hhea, SIZEOF_HHEA, HHEA_CONTROL, aDirectory[hhea_index].offset, &usBytesWritten);
			CalcChecksum( pOutputBufferInfo, aDirectory[ hhea_index ].offset, aDirectory[ hhea_index ].length, &(aDirectory[ hhea_index ].checkSum) );
		}
		if (vhea_index != -1)
		{
			vhea.numLongMetrics = numLongVerMetrics;
			errCode = WriteGeneric(pOutputBufferInfo, (uint8 *) &vhea, SIZEOF_VHEA, VHEA_CONTROL, aDirectory[vhea_index].offset, &usBytesWritten);
			CalcChecksum( pOutputBufferInfo, aDirectory[ vhea_index ].offset, aDirectory[ vhea_index ].length, &(aDirectory[ vhea_index ].checkSum) );
		}

		*pulBytesWritten = ulOutOffset;
		/* write out the offset header */
		ulOutOffset = pOutputBufferInfo->ulOffsetTableOffset;

		if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &OffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulOutOffset, &usBytesWritten)) != NO_ERROR)
			break;
	/* write out the new directory info */

		SortByTag( aDirectory, usnTables );

		ulOutOffset += usBytesWritten;

		for ( i = 0; i < usnTables; i++ )
		{
			if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &(aDirectory[ i ]), SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOutOffset, &usBytesWritten)) != NO_ERROR)
				break;
			ulOutOffset += usBytesWritten;
		}
		if (errCode != NO_ERROR)
			break;

		SetFileChecksum(pOutputBufferInfo, *pulBytesWritten);	
		break;
	}

	Mem_Free(aDirectory);

	return errCode;
}

/* ---------------------------------------------------------------------- */
/* assumes entries are already sorted by tag */
/* need to come up with a count of the directories that is a union of the 2 lists */
PRIVATE	uint16 MergeDirectories(DIRECTORY *pDeltaDirectory, 
								uint16 usDeltaNumTables, 
								DIRECTORY *pMergeDirectory, 
								uint16 usMergeNumTables, 
								DIRECTORY *pDestDirectory)
{
uint16 usDeltaIndex, usMergeIndex, usDestIndex;

	for (usDeltaIndex = 0, usMergeIndex = 0, usDestIndex = 0;;++usDestIndex)
	{
		if (usDeltaIndex >= usDeltaNumTables) /* done with delta list */
		{
			if (usMergeIndex >= usMergeNumTables) /* this takes care of the usMergeIndex and usDeltaIndex reaching their end together */
				break; 
 			pDestDirectory[usDestIndex].tag = pMergeDirectory[usMergeIndex].tag;
			++usMergeIndex;
		}
		else if (usMergeIndex >= usMergeNumTables)
		{
			pDestDirectory[usDestIndex].tag = pDeltaDirectory[usDeltaIndex].tag;
			++usDeltaIndex;
		}
		else if (pDeltaDirectory[usDeltaIndex].tag > pMergeDirectory[usMergeIndex].tag) /* we have an extra in the merge list */
		{
			pDestDirectory[usDestIndex].tag = pMergeDirectory[usMergeIndex].tag;
			++usMergeIndex;
		}
		else if (pDeltaDirectory[usDeltaIndex].tag < pMergeDirectory[usMergeIndex].tag)  /* we have an extra in the delta list */
		{
			pDestDirectory[usDestIndex].tag = pDeltaDirectory[usDeltaIndex].tag;
			++usDeltaIndex;
		}
		else   /* the're the same, increment them both */
		{
			pDestDirectory[usDestIndex].tag = pMergeDirectory[usMergeIndex].tag;   /* the're the same, take it from merge */
			++usDeltaIndex;
			++usMergeIndex;
		}
	}
	return usDestIndex;
}
/* ------------------------------------------------------------------- */
PRIVATE uint16 GetCmapSubtableCount( TTFACC_FILEBUFFERINFO * pInputBufferInfo,
									uint32 ulCmapOffset)
{
CMAP_HEADER CmapHdr;
uint16 usBytesRead;

	if (ReadGeneric( pInputBufferInfo, (uint8 *) &CmapHdr, SIZEOF_CMAP_HEADER, CMAP_HEADER_CONTROL, ulCmapOffset, &usBytesRead ) != NO_ERROR)
		return 0;

	return(CmapHdr.numTables);
} /* GetCmapSubtableCount() */

/* ------------------------------------------------------------------- */
/* merge format 0 cmap subtable */
/* ------------------------------------------------------------------- */
PRIVATE int16 MergeMacStandardCmap( TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDeltaOffset,				/* offset of Mac Cmap Subtable */
						uint32 ulMergeOffset,				/* offset of Mac Cmap Subtable */
						uint32 ulDestOffset,				/* offset into dest buffer where to write data */
						uint32 *pulBytesWritten)			/* number of bytes written to the Output buffer */
{
uint16 i;
uint16 usBytesRead;
uint16 usBytesWritten;
uint8 GlyphIndex;
int16 errCode= NO_ERROR;
CMAP_SUBHEADER CmapSubHeader;

	*pulBytesWritten = 0;
	if ((errCode = ReadGeneric(pMergeBufferInfo, (uint8 *)&CmapSubHeader, SIZEOF_CMAP_SUBHEADER, CMAP_SUBHEADER_CONTROL, ulMergeOffset, &usBytesRead)) != NO_ERROR)
		return errCode;
	ulMergeOffset += usBytesRead;
	ulDeltaOffset += usBytesRead; /* skip delta header */
	if ((errCode = WriteGeneric(pDestBufferInfo, (uint8 *)&CmapSubHeader, SIZEOF_CMAP_SUBHEADER, CMAP_SUBHEADER_CONTROL, ulDestOffset, &usBytesWritten)) != NO_ERROR)
		return errCode;
	*pulBytesWritten = usBytesWritten;

	for ( i = 0; i < CMAP_FORMAT0_ARRAYCOUNT; i++ )
	{
		if ((errCode = ReadByte(pDeltaBufferInfo, &GlyphIndex, ulDeltaOffset)) != NO_ERROR)
			break;
		ulDeltaOffset += sizeof(GlyphIndex);
		if (GlyphIndex == 0) /* there is no value here, read from merge */
			if ((errCode = ReadByte(pMergeBufferInfo, &GlyphIndex, ulMergeOffset)) != NO_ERROR)
				break;
		ulMergeOffset += sizeof(GlyphIndex);  /* always increment this */

		if ((errCode = WriteByte(pDestBufferInfo, GlyphIndex, ulDestOffset + *pulBytesWritten)) != NO_ERROR)
			break;
		*pulBytesWritten += sizeof(GlyphIndex);
	}
	return errCode;
}
/* ------------------------------------------------------------------- */
/* merge format 6 cmap subtables */
/* ------------------------------------------------------------------- */
PRIVATE int16 MergeMacTrimmedCmap(  TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDeltaOffset,				/* offset of Mac Cmap Subtable */
						uint32 ulMergeOffset,				/* offset of Mac Cmap Subtable */
						uint32 ulDestOffset,				/* offset into dest buffer where to write data */
						uint32 *pulBytesWritten)			/* number of bytes written to the Output buffer */
{
CMAP_FORMAT6 MergeCmapSubHeader, DeltaCmapSubHeader, DestCmapSubHeader;
uint16 usIndex;
uint16 usGlyphIndex;
uint16 usBytesRead, usBytesWritten;
int16 errCode;
uint16 usFirstCode;	  /* the first code of either table */
uint16 usLastCode;	  /* the last code of either table */
uint16 usMergeLastCode;
uint16 usDeltaLastCode;
uint16 usMergeGlyphIndex;
uint16 usDeltaGlyphIndex;

	*pulBytesWritten = 0;
	if ((errCode = ReadGeneric(pMergeBufferInfo, (uint8 *)&MergeCmapSubHeader, SIZEOF_CMAP_FORMAT6, CMAP_FORMAT6_CONTROL, ulMergeOffset, &usBytesRead)) != NO_ERROR)
		return errCode;
	ulMergeOffset += usBytesRead;
	if ((errCode = ReadGeneric(pDeltaBufferInfo, (uint8 *)&DeltaCmapSubHeader, SIZEOF_CMAP_FORMAT6, CMAP_FORMAT6_CONTROL, ulDeltaOffset, &usBytesRead)) != NO_ERROR)
		return errCode;
	ulDeltaOffset += usBytesRead; 

    if ((DeltaCmapSubHeader.firstCode + DeltaCmapSubHeader.entryCount) == 0)
        usDeltaLastCode = 0;
    else
    	usDeltaLastCode = DeltaCmapSubHeader.firstCode + DeltaCmapSubHeader.entryCount -1;
    	
    if ((MergeCmapSubHeader.firstCode + MergeCmapSubHeader.entryCount) == 0)    	
        usMergeLastCode = 0;
    else
    	usMergeLastCode = MergeCmapSubHeader.firstCode + MergeCmapSubHeader.entryCount - 1;
	
	usFirstCode = min(MergeCmapSubHeader.firstCode, DeltaCmapSubHeader.firstCode);
	usLastCode = max (usMergeLastCode, usDeltaLastCode);

	memcpy(&DestCmapSubHeader, &MergeCmapSubHeader, sizeof(MergeCmapSubHeader));
	DestCmapSubHeader.firstCode = usFirstCode;
	DestCmapSubHeader.entryCount = usLastCode - usFirstCode + 1;
	
	*pulBytesWritten = GetGenericSize(CMAP_FORMAT6_CONTROL); /* skip this at first, need length to update it */

	for ( usIndex = usFirstCode; usIndex <= usLastCode; usIndex++ )
	{
		usDeltaGlyphIndex = 0;
		usMergeGlyphIndex = 0;
		if (usIndex >= DeltaCmapSubHeader.firstCode	&& usIndex <= usDeltaLastCode)
		{
			if ((errCode = ReadWord(pDeltaBufferInfo, &usDeltaGlyphIndex, ulDeltaOffset)) != NO_ERROR)
				return errCode;
			ulDeltaOffset += sizeof(usDeltaGlyphIndex);
		}
		if (usIndex >= MergeCmapSubHeader.firstCode	&& usIndex <= usMergeLastCode)
		{
			if ((errCode = ReadWord(pMergeBufferInfo, &usMergeGlyphIndex, ulMergeOffset)) != NO_ERROR)
				return errCode;
			ulMergeOffset += sizeof(usMergeGlyphIndex);
		}
		usGlyphIndex = max(usDeltaGlyphIndex, usMergeGlyphIndex);  /* choose one that is not zero */
		if ((errCode = WriteWord(pDestBufferInfo, usGlyphIndex, ulDestOffset + *pulBytesWritten)) != NO_ERROR)
			return errCode;
		*pulBytesWritten += sizeof(usGlyphIndex);
	}

	DestCmapSubHeader.length = (uint16) *pulBytesWritten;
	errCode = WriteGeneric(pDestBufferInfo, (uint8 *)&DestCmapSubHeader, SIZEOF_CMAP_FORMAT6, CMAP_FORMAT6_CONTROL, ulDestOffset, &usBytesWritten);

	return errCode;
}

/* ------------------------------------------------------------------- */
PRIVATE void FreeFormat4MergedGlyphList(PCHAR_GLYPH_MAP_LIST pCharGlyphMapArray)
{
	Mem_Free(pCharGlyphMapArray);
}

/* ------------------------------------------------------------------- */
/* this routine makes a list of glyphs corresponding to each 
character code in the Format4 Cmap table */ 
/* ------------------------------------------------------------------- */
PRIVATE int16 MakeFormat4MergedGlyphList(
							FORMAT4_SEGMENTS * pDeltaFormat4Segments,
                            uint16 usDeltaSegCount, /* count of pDeltaFormat4Segments */
                            GLYPH_ID * pDeltaGlyphId, /* Delta font glyph id array */
                            uint16  usnDeltaGlyphIds, /* count of pDeltaFormat4Segments */
							FORMAT4_SEGMENTS * pMergeFormat4Segments,
                            uint16 usMergeSegCount, /* count of pMergeFormat4Segments */
                            GLYPH_ID * pMergeGlyphId, /* Merge font glyph ID array */
                            uint16  usnMergeGlyphIds, /* count of pMergeFormatGlyph ID array*/
							PCHAR_GLYPH_MAP_LIST *ppCharGlyphMapArray,
							uint16 *pusnCharGlyphMaps) /* number of entries in the 2 arrays with values in them */
{

uint16 usCharCode;
uint16 usGlyphIdx;
uint16 sIDIdx;
int16 errCode = NO_ERROR;
uint16 usMaxCode;
uint16 usDeltaSegIndex;
uint16 usMergeSegIndex;
   

	/* find the largest Char code we need to represent */
	usMaxCode = max(pDeltaFormat4Segments[usDeltaSegCount-2].endCount, pMergeFormat4Segments[usMergeSegCount-2].endCount);
	*ppCharGlyphMapArray = Mem_Alloc(usMaxCode * sizeof(**ppCharGlyphMapArray));
	if (*ppCharGlyphMapArray == NULL)
		return ERR_MEM;

	*pusnCharGlyphMaps = 0;
		
   for (usCharCode = usDeltaSegIndex = usMergeSegIndex = 0; usCharCode <= usMaxCode; ++usCharCode)
   {
	   /* first look in usDeltaSegment */
	   while (usDeltaSegIndex < usDeltaSegCount && 
		   usCharCode > pDeltaFormat4Segments[usDeltaSegIndex].endCount)
		   ++usDeltaSegIndex;  /* find the right segment to look in */
	   while (usMergeSegIndex < usMergeSegCount && 
		   usCharCode > pMergeFormat4Segments[usMergeSegIndex].endCount)
		   ++usMergeSegIndex;  /* find the right segment to look in */
	   if (usDeltaSegIndex < usDeltaSegCount && usCharCode >= pDeltaFormat4Segments[usDeltaSegIndex].startCount) /* we found a range! */
	   {
			if ( pDeltaFormat4Segments[usDeltaSegIndex].idRangeOffset == 0 )
				usGlyphIdx = usCharCode + pDeltaFormat4Segments[usDeltaSegIndex].idDelta;
			else
			{
				sIDIdx = (uint16) usDeltaSegIndex - (uint16) usDeltaSegCount; 
				sIDIdx += (uint16) (pDeltaFormat4Segments[usDeltaSegIndex].idRangeOffset / 2) + usCharCode - pDeltaFormat4Segments[usDeltaSegIndex].startCount;
				usGlyphIdx = pDeltaGlyphId[ sIDIdx ];
				if (usGlyphIdx)
					/* Only add in idDelta if we've really got a glyph! */
					usGlyphIdx += pDeltaFormat4Segments[usDeltaSegIndex].idDelta;
			}
	   }
	   else if (usMergeSegIndex < usMergeSegCount && usCharCode >= pMergeFormat4Segments[usMergeSegIndex].startCount) /* we found a range! */
	   {
			if ( pMergeFormat4Segments[usMergeSegIndex].idRangeOffset == 0 )
				usGlyphIdx = usCharCode + pMergeFormat4Segments[usMergeSegIndex].idDelta;
			else
			{
				sIDIdx = (uint16) usMergeSegIndex - (uint16) usMergeSegCount; 
				sIDIdx += (uint16) (pMergeFormat4Segments[usMergeSegIndex].idRangeOffset / 2) + usCharCode - pMergeFormat4Segments[usMergeSegIndex].startCount;
				usGlyphIdx = pMergeGlyphId[ sIDIdx ];
				if (usGlyphIdx)
					/* Only add in idDelta if we've really got a glyph! */
					usGlyphIdx += pMergeFormat4Segments[usMergeSegIndex].idDelta;
			}
	   }
	   else
			continue; /* this code was not found */

 		(*ppCharGlyphMapArray)[*pusnCharGlyphMaps].usCharCode = usCharCode;
		(*ppCharGlyphMapArray)[ *pusnCharGlyphMaps ].usGlyphIndex = usGlyphIdx;
		++(*pusnCharGlyphMaps);
  }




#if 0
	/* build glyph index array */

	for ( i = 0, *pusnCharGlyphMaps = 0; i <= usMaxCode; i++ )
	{
 		usGlyphIdx = GetGlyphIdx( i, pDeltaFormat4Segments, usDeltaSegCount, pDeltaGlyphId );
		if (usGlyphIdx == INVALID_GLYPH_INDEX)
 			usGlyphIdx = GetGlyphIdx( i, pMergeFormat4Segments, usMergeSegCount, pMergeGlyphId );

		if (usGlyphIdx != INVALID_GLYPH_INDEX)
		{
			(*ppCharGlyphMapArray)[*pusnCharGlyphMaps].usCharCode = i;
			(*ppCharGlyphMapArray)[ *pusnCharGlyphMaps ].usGlyphIndex = usGlyphIdx;
			++(*pusnCharGlyphMaps);
		}
	}
#endif
	return(NO_ERROR);
}

/* ------------------------------------------------------------------- */
/* this routine computes new values for the format 4 cmap table 
based on a list of character codes and glyph indices */ 
/* ------------------------------------------------------------------- */
/* ------------------------------------------------------------------- */

PRIVATE int16 MergeFormat4Cmap(  TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDeltaOffset,				/* offset of Mac Cmap Subtable */
						uint32 ulMergeOffset,				/* offset of Mac Cmap Subtable */
						uint32 ulDestOffset,				/* offset into dest buffer where to write data */
						uint16 *pusMaxCode,				/* maxmimum code value of the two fonts - used by OS/2 */
						uint16 *pusMinCode,				/* minimum code value of the two fonts - used by OS/2 */
						uint32 *pulBytesWritten)				/* number of bytes written to the Output buffer */
{
int16 errCode = NO_ERROR;
FORMAT4_SEGMENTS *pDeltaFormat4Segments, *pMergeFormat4Segments;
FORMAT4_SEGMENTS *pDestFormat4Segments = NULL;   /* used to create a Segments	array for format 4 subtables */
GLYPH_ID *pDeltaGlyphId, *pMergeGlyphId;
GLYPH_ID *pDestGlyphId = NULL; /* used to create a GlyphID array for format 4 subtables */
CMAP_FORMAT4 MergeCmapSubHeader, DeltaCmapSubHeader, DestCmapSubHeader;
uint16 usDeltaSegCount, usMergeSegCount, usDestSegCount;
uint16 usnDeltaGlyphIds, usnMergeGlyphIds, usnDestGlyphIds;
uint16 usBytesRead;
uint32 ulBytesRead;
PCHAR_GLYPH_MAP_LIST pCharGlyphMapArray;
uint16 usnCharGlyphMapEntries; /* number of entries in the 2 arrays with values in them */


	*pulBytesWritten = 0;
	if ((errCode = ReadGeneric(pDeltaBufferInfo, (uint8 *)&DeltaCmapSubHeader, SIZEOF_CMAP_FORMAT4, CMAP_FORMAT4_CONTROL, ulDeltaOffset, &usBytesRead)) != NO_ERROR)
		return errCode;
	ulDeltaOffset += usBytesRead; 

   	usDeltaSegCount = DeltaCmapSubHeader.segCountX2 / 2;

   /* read variable length part */

	if ((errCode = ReadAllocCmapFormat4Segs( pDeltaBufferInfo, usDeltaSegCount, &pDeltaFormat4Segments, ulDeltaOffset, &ulBytesRead )) != NO_ERROR)
		return(errCode);
	if ( ulBytesRead == 0)	/* 0 could mean okey dokey */
		; /* ~ do what? */
    ulDeltaOffset += ulBytesRead;

  	if ((errCode = ReadAllocCmapFormat4Ids( pDeltaBufferInfo, usDeltaSegCount, pDeltaFormat4Segments, &pDeltaGlyphId, &usnDeltaGlyphIds, ulDeltaOffset, &ulBytesRead )) != NO_ERROR)
	{
		FreeCmapFormat4Segs( pDeltaFormat4Segments);
		return errCode ;
	}

	if ((errCode = ReadGeneric(pMergeBufferInfo, (uint8 *)&MergeCmapSubHeader, SIZEOF_CMAP_FORMAT4, CMAP_FORMAT4_CONTROL, ulMergeOffset, &usBytesRead)) != NO_ERROR)
	{
		FreeCmapFormat4( pDeltaFormat4Segments, pDeltaGlyphId);		
		return errCode;
	}
	ulMergeOffset += usBytesRead;

   /* read variable length part */
    usMergeSegCount = MergeCmapSubHeader.segCountX2 / 2;

	if ((errCode = ReadAllocCmapFormat4Segs( pMergeBufferInfo, usMergeSegCount, &pMergeFormat4Segments, ulMergeOffset, &ulBytesRead )) != NO_ERROR)
	{
		FreeCmapFormat4( pDeltaFormat4Segments, pDeltaGlyphId);		
		return errCode;
	}
	if ( ulBytesRead == 0)	/* 0 could mean okey dokey */
		; /* ~ do what? */
    ulMergeOffset += ulBytesRead;

  	if ((errCode = ReadAllocCmapFormat4Ids( pMergeBufferInfo, usMergeSegCount, pMergeFormat4Segments, &pMergeGlyphId, &usnMergeGlyphIds, ulMergeOffset, &ulBytesRead )) != NO_ERROR)
	{
		FreeCmapFormat4( pDeltaFormat4Segments, pDeltaGlyphId);		
		FreeCmapFormat4Segs( pMergeFormat4Segments);
		return errCode;
	}

	usDestSegCount = (usDeltaSegCount + usMergeSegCount); /* calculate the worst case */
	pDestFormat4Segments = (FORMAT4_SEGMENTS *) Mem_Alloc( usDestSegCount * SIZEOF_FORMAT4_SEGMENTS ); 
	usnDestGlyphIds = max(pMergeFormat4Segments[usMergeSegCount-2].endCount,  pDeltaFormat4Segments[usDeltaSegCount-2].endCount);/* worst case */
	pDestGlyphId = (GLYPH_ID *) Mem_Alloc( usnDestGlyphIds * SIZEOF_GLYPH_ID );

	if ( pDestFormat4Segments == NULL || pDestGlyphId == NULL )
	{
		FreeCmapFormat4( pDeltaFormat4Segments, pDeltaGlyphId);		
		FreeCmapFormat4( pMergeFormat4Segments, pMergeGlyphId );
		Mem_Free(pDestFormat4Segments);
		Mem_Free(pDestGlyphId);
		errCode = ERR_MEM;
		return errCode;
	}

	errCode = MakeFormat4MergedGlyphList(pDeltaFormat4Segments, usDeltaSegCount, pDeltaGlyphId, usnDeltaGlyphIds,
										 pMergeFormat4Segments, usMergeSegCount, pMergeGlyphId, usnMergeGlyphIds, 
										 &pCharGlyphMapArray, &usnCharGlyphMapEntries);
						
  	FreeCmapFormat4( pDeltaFormat4Segments, pDeltaGlyphId );
	FreeCmapFormat4( pMergeFormat4Segments, pMergeGlyphId );
	/* compute new format 4 data */
	if (errCode == NO_ERROR)
	{
		ComputeFormat4CmapData( &DestCmapSubHeader, pDestFormat4Segments,  &usDestSegCount, pDestGlyphId,  &usnDestGlyphIds, pCharGlyphMapArray, usnCharGlyphMapEntries);

		FreeFormat4MergedGlyphList(pCharGlyphMapArray);

		errCode = WriteOutFormat4CmapData( pDestBufferInfo, &DestCmapSubHeader, 
							  pDestFormat4Segments,  pDestGlyphId, usDestSegCount, usnDestGlyphIds,
							  ulDestOffset, pulBytesWritten );
		if (errCode == NO_ERROR)
		{
			*pusMaxCode = pDestFormat4Segments[usDestSegCount-2].endCount;
			*pusMinCode = pDestFormat4Segments[0].startCount;
		}
	/* clean up */
	}

	Mem_Free(pDestFormat4Segments);
	Mem_Free(pDestGlyphId );
	
	return errCode;
}
/* ---------------------------------------------------------------------- */
PRIVATE int16 MergeCmapTables(TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDestOffset,					  /* offset into dest buffer where to write data */
						uint16 *pusMaxCode,						  /* maxmimum code value of the two fonts - used by OS/2 */
						uint16 *pusMinCode,						  /* minimum code value of the two fonts - used by OS/2 */
						uint32 *pulBytesWritten)				  /* number of bytes written to the Output buffer */
{
CMAP_HEADER CmapHeader;
CMAP_TABLELOC *pDeltaCmapTableLoc, *pMergeCmapTableLoc, *pDestCmapTableLoc;
CMAP_SUBHEADER DeltaCmapSubHeader, MergeCmapSubHeader;
uint16 usDeltaSubTableCount, usMergeSubTableCount, usDestSubTableCount;
uint32 ulDeltaCmapOffset, ulMergeCmapOffset;
uint32 ulLength;
uint32 ulDestDirOffset;
uint16 i,j;
int16 errCode= NO_ERROR;
uint16 usBytesRead;
uint16 usBytesWritten;
uint32 ulBytesRead;
uint32 ulBytesWritten;
uint16 usZeroZeroIndex=0; /* for shared Subtable info */

	*pusMaxCode = 0;
	*pusMinCode = 0;
	*pulBytesWritten = 0;
	ulDeltaCmapOffset = TTTableOffset( pDeltaBufferInfo, CMAP_TAG);
	ulLength = TTTableLength( pDeltaBufferInfo, CMAP_TAG);

	if (ulDeltaCmapOffset == 0L || ulLength == 0L)
		return ERR_FORMAT;  /* nothing to do */

	ulMergeCmapOffset = TTTableOffset( pMergeBufferInfo, CMAP_TAG );
	ulLength = TTTableLength( pMergeBufferInfo, CMAP_TAG);

	if (ulMergeCmapOffset == 0L || ulLength == 0L)
		return ERR_FORMAT;  /* nothing to do */

	usDeltaSubTableCount = GetCmapSubtableCount(pDeltaBufferInfo, ulDeltaCmapOffset);
	pDeltaCmapTableLoc = (CMAP_TABLELOC *)Mem_Alloc(SIZEOF_CMAP_TABLELOC * usDeltaSubTableCount);
	if (pDeltaCmapTableLoc == NULL)
		return ERR_MEM;

	usMergeSubTableCount = GetCmapSubtableCount(pMergeBufferInfo, ulMergeCmapOffset);
	pMergeCmapTableLoc = (CMAP_TABLELOC *)Mem_Alloc(SIZEOF_CMAP_TABLELOC * usMergeSubTableCount);
	if (pMergeCmapTableLoc == NULL)
	{
		Mem_Free(pDeltaCmapTableLoc);
		return ERR_MEM;
	}

	if (usDeltaSubTableCount != usMergeSubTableCount) /* uh oh, */
	{
		Mem_Free(pDeltaCmapTableLoc);
		Mem_Free(pMergeCmapTableLoc);
		return ERR_INVALID_CMAP;
	}

	usDestSubTableCount = usMergeSubTableCount;
	pDestCmapTableLoc = (CMAP_TABLELOC *)Mem_Alloc(SIZEOF_CMAP_TABLELOC * usDestSubTableCount);
	if (pDestCmapTableLoc == NULL)
	{
		Mem_Free(pDeltaCmapTableLoc);
		Mem_Free(pMergeCmapTableLoc);
		return ERR_MEM;
	}


	if ((errCode = ReadGeneric(pMergeBufferInfo, (uint8 *)&CmapHeader, SIZEOF_CMAP_HEADER, CMAP_HEADER_CONTROL, ulMergeCmapOffset, &usBytesRead)) == NO_ERROR)
	{
 		errCode = WriteGeneric(pDestBufferInfo, (uint8 *)&CmapHeader, SIZEOF_CMAP_HEADER, CMAP_HEADER_CONTROL, ulDestOffset, &usBytesWritten);
		
		*pulBytesWritten = usBytesWritten; 
		ulDestDirOffset = ulDestOffset + usBytesWritten;
	}

	if (errCode == NO_ERROR)
	{

		if ((errCode = ReadGenericRepeat(pDeltaBufferInfo, (uint8 *) pDeltaCmapTableLoc, CMAP_TABLELOC_CONTROL, ulDeltaCmapOffset + usBytesRead, &ulBytesRead, usDeltaSubTableCount , SIZEOF_CMAP_TABLELOC)) == NO_ERROR)
			errCode = ReadGenericRepeat(pMergeBufferInfo, (uint8 *) pMergeCmapTableLoc, CMAP_TABLELOC_CONTROL, ulMergeCmapOffset + usBytesRead, &ulBytesRead, usMergeSubTableCount , SIZEOF_CMAP_TABLELOC);
		
		*pulBytesWritten += ulBytesRead; /* leave space for the location directory table */
	}

	for (i = 0; i < usMergeSubTableCount && errCode == NO_ERROR; ++i)
	{
		if ((ulDestOffset + *pulBytesWritten) & 1) /* on an odd word boundary */
		{
			WriteByte(pDestBufferInfo, (uint8) 0, ulDestOffset + *pulBytesWritten);
			++ (*pulBytesWritten);
		}
		/* don't long word align, short word align */
		/* *pulBytesWritten += ZeroLongWordAlign(pDestBufferInfo, ulDestOffset + *pulBytesWritten);	*/
		/* read the cmap directory entry */
		/* now read the CmapSub Header, to determine the format */
	 	if ((errCode = ReadGeneric(pDeltaBufferInfo, (uint8 *)&DeltaCmapSubHeader, SIZEOF_CMAP_SUBHEADER, CMAP_SUBHEADER_CONTROL, ulDeltaCmapOffset + pDeltaCmapTableLoc[i].offset, &usBytesRead)) != NO_ERROR)
			break; 
		/* now read the CmapSub Header, to determine the format */
	 	if ((errCode = ReadGeneric(pMergeBufferInfo, (uint8 *)&MergeCmapSubHeader, SIZEOF_CMAP_SUBHEADER, CMAP_SUBHEADER_CONTROL, ulMergeCmapOffset + pMergeCmapTableLoc[i].offset, &usBytesRead)) != NO_ERROR)
			break; 
		
		/* can handle Format0, Format 4 and Format 6 */
		/* Otherwise, copy from Merge */
		if (MergeCmapSubHeader.format != DeltaCmapSubHeader.format)
		{
			errCode = ERR_INVALID_CMAP;
			break;
		}

		if (MergeCmapSubHeader.format < 8)
		{
			/* old tables (non surragate) */
			MergeCmapSubHeader.NewLength = MergeCmapSubHeader.OldLength;
		}

		if (DeltaCmapSubHeader.format < 8)
		{
			/* old tables (non surragate) */
			DeltaCmapSubHeader.NewLength = DeltaCmapSubHeader.OldLength;
		}

		pDestCmapTableLoc[i].platformID = pMergeCmapTableLoc[i].platformID;
		pDestCmapTableLoc[i].encodingID = pMergeCmapTableLoc[i].encodingID;
		pDestCmapTableLoc[i].offset = *pulBytesWritten;

		/* now check to see if we've done this one before */
		for (j = 0; j < i; ++j)
		{
			if (pMergeCmapTableLoc[i].offset == pMergeCmapTableLoc[j].offset) /* we've done this before */
			{
				pDestCmapTableLoc[i].offset = pDestCmapTableLoc[j].offset;
				continue;
			}
		}
		switch (MergeCmapSubHeader.format)
		{
		case FORMAT0_CMAP_FORMAT:
			errCode = MergeMacStandardCmap(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, 
					ulDeltaCmapOffset + pDeltaCmapTableLoc[i].offset, 
					ulMergeCmapOffset + pMergeCmapTableLoc[i].offset, 
					ulDestOffset + *pulBytesWritten, &ulBytesWritten);
			break;
		case FORMAT4_CMAP_FORMAT:
 			errCode = MergeFormat4Cmap(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, 
				ulDeltaCmapOffset + pDeltaCmapTableLoc[i].offset, 
				ulMergeCmapOffset + pMergeCmapTableLoc[i].offset, 
				ulDestOffset + *pulBytesWritten, pusMaxCode, pusMinCode,  &ulBytesWritten);
			break;
		case FORMAT6_CMAP_FORMAT:
			errCode = MergeMacTrimmedCmap(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, 
				ulDeltaCmapOffset + pDeltaCmapTableLoc[i].offset, 
				ulMergeCmapOffset + pMergeCmapTableLoc[i].offset, 
				ulDestOffset + *pulBytesWritten, &ulBytesWritten);
			break;
		default:  /* don't know how to merge, just copy from the merge place */
			errCode = CopyBlockOver(pDestBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *)pMergeBufferInfo, ulMergeCmapOffset + pMergeCmapTableLoc[i].offset, ulDestOffset + *pulBytesWritten, MergeCmapSubHeader.NewLength);
			ulBytesWritten = MergeCmapSubHeader.NewLength;
			break;
		}
		if (errCode != NO_ERROR)
			break;
		*pulBytesWritten += ulBytesWritten;
	}

	if (errCode == NO_ERROR)
	{
		/* now write out the pDestCmapTableLoc array */
		errCode = WriteGenericRepeat(pDestBufferInfo, (uint8 *) pDestCmapTableLoc, CMAP_TABLELOC_CONTROL, ulDestDirOffset, &ulBytesWritten, usDestSubTableCount , SIZEOF_CMAP_TABLELOC);
	}
	Mem_Free(pDeltaCmapTableLoc);
	Mem_Free(pMergeCmapTableLoc);
	Mem_Free(pDestCmapTableLoc);
	
	return errCode;
}
/* ---------------------------------------------------------------------- */
PRIVATE int16 MergeGlyfLocaTables(TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDestOffset,					  /* offset into dest buffer where to write data */
						uint16 usGlyphCount, 					  /* number of elements in the pGlyphIndexArray from the Delta font */
						uint16 *pGlyphIndexArray, 				  /* holds the mapping between entries in the Loca and actual Glyph Index numbers */
						uint16 numGlyphs, 						  /* number of glyphs in the original (uncompact) font. Should match number in the merge font */
						uint32 *pulGlyfLength,				      /* number of bytes written to the glyf table Output buffer */
						uint16 *pusIdxToLocFmt,					  /* may change from short to long */
						uint32 *pulLocaOffset,
						uint32 *pulLocaLength )
{
uint32 ulDeltaOffset, ulMergeOffset;
uint16 usDeltaIndex, usMergeIndex, usDestIndex;
uint16 usLength;
int16 errCode = NO_ERROR;
uint32 ulBytesWritten = 0;
uint32 *pDeltaLoca=NULL, *pMergeLoca = NULL, *pDestLoca = NULL;
uint16 *pDestLocaWord = NULL; /* used to point int pDestLoca array */

	*pulGlyfLength = 0;

	pDeltaLoca = Mem_Alloc(sizeof(uint32) * (usGlyphCount + 1)); /* need this much roomto read into */
	pMergeLoca = Mem_Alloc(sizeof(uint32) * (numGlyphs + 1)); /* need this much room to read into */

	if (pDeltaLoca == NULL || pMergeLoca == NULL)
	{
		Mem_Free(pDeltaLoca);
		Mem_Free(pMergeLoca);
		return ERR_MEM;
	}
	ulDeltaOffset = TTTableOffset( pDeltaBufferInfo, GLYF_TAG);
	ulMergeOffset = TTTableOffset( pMergeBufferInfo, GLYF_TAG);

	if (GetLoca(pDeltaBufferInfo, pDeltaLoca, (uint16) (usGlyphCount + 1)) == 0L)
		errCode = ERR_INVALID_LOCA;
	else if (GetLoca(pMergeBufferInfo, pMergeLoca, (uint16) (numGlyphs + 1)) == 0L)
		errCode = ERR_INVALID_LOCA;

	if (errCode != NO_ERROR)
	{
		Mem_Free(pDeltaLoca);
		Mem_Free(pMergeLoca);
		return errCode;
	}

 	pDestLoca = Mem_Alloc(sizeof(uint32) * (numGlyphs + 1)); /* need this much room to write into */
 	if (pDestLoca == NULL)
	{
		Mem_Free(pDeltaLoca);
		Mem_Free(pMergeLoca);
		return ERR_MEM;
	}

	pDestLoca[0] = 0;
	for (usDeltaIndex = 0, usMergeIndex = 0; usMergeIndex < numGlyphs ; ++ usMergeIndex)
	{
		if ((usDeltaIndex < usGlyphCount) && (usMergeIndex == pGlyphIndexArray[usDeltaIndex])) /* this one should come from the delta table */
		{
			usLength = (uint16) (pDeltaLoca[usDeltaIndex + 1] - pDeltaLoca[usDeltaIndex]);
			if ((errCode = CopyBlockOver(pDestBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *)pDeltaBufferInfo, ulDestOffset + ulBytesWritten, ulDeltaOffset + pDeltaLoca[usDeltaIndex], usLength)) != NO_ERROR)
				break;
			++usDeltaIndex;
		}
		else  /* copy from the merge buffer */
		{
			usLength = (uint16) (pMergeLoca[usMergeIndex + 1] - pMergeLoca[usMergeIndex]);
			if ((errCode = CopyBlockOver(pDestBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *)pMergeBufferInfo, ulDestOffset + ulBytesWritten, ulMergeOffset + pMergeLoca[usMergeIndex], usLength)) != NO_ERROR)
				break;
		}
		ulBytesWritten += usLength;
		if (usLength && ulBytesWritten & 1) /* we're on an odd byte boundary, write out a zero */
		{
			if ((errCode = WriteByte(pDestBufferInfo, 0, ulDestOffset + ulBytesWritten)) != NO_ERROR)
				break;
			++ ulBytesWritten;
		}
		pDestLoca[usMergeIndex+1] = ulBytesWritten;
	}
	/* now write out the Loca table */
	if (errCode == NO_ERROR)
	{
		*pulGlyfLength = ulBytesWritten;
		*pulLocaOffset = ulDestOffset + *pulGlyfLength;
		*pulLocaOffset += ZeroLongWordAlign(pDestBufferInfo, *pulLocaOffset);
		
		if (ulBytesWritten <= 0x1FFFC)   /* maximum number stored here - 2* FFFE*/
		{
			*pusIdxToLocFmt = SHORT_OFFSETS;
			pDestLocaWord = (uint16 *) pDestLoca; /* trick to copy into a short array */
 			for ( usDestIndex = 0; usDestIndex <= numGlyphs; usDestIndex++ )
			{
				pDestLocaWord[usDestIndex] = (uint16) (pDestLoca[usDestIndex ] / 2L);
			}
			errCode = WriteGenericRepeat(pDestBufferInfo,  (uint8 *) pDestLocaWord, WORD_CONTROL, *pulLocaOffset, pulLocaLength,(uint16) (numGlyphs+1), sizeof(uint16)); 
			
#if 0
			for ( usDestIndex = 0; usDestIndex <= numGlyphs; usDestIndex++ )
			{
				usOffset = (uint16) (pDestLoca[usDestIndex ] / 2L);
				if ((errCode = WriteWord( pDestBufferInfo,  usOffset, *pulLocaOffset + usDestIndex*sizeof(uint16) )) != NO_ERROR)
					break;
			}
			*pulLocaLength = (uint32) (numGlyphs+1) * sizeof(uint16);
#endif
		}
		else
		{
			*pusIdxToLocFmt = LONG_OFFSETS;
			errCode = WriteGenericRepeat(pDestBufferInfo,  (uint8 *) pDestLoca, LONG_CONTROL, *pulLocaOffset, pulLocaLength,(uint16) (numGlyphs+1), sizeof(uint32)); 
		}
	}

	Mem_Free(pDeltaLoca);
	Mem_Free(pMergeLoca);
	Mem_Free(pDestLoca);

	return errCode;
}

/* ---------------------------------------------------------------------- */
/* we're going to use this for VMTX as well,  */
/* this routine will create an expanded HMTX or VMTX table from the compact form, adding */
/* one dummy long metrics after the last metric from the compact table (pGlyphIndexArray[usGlyphCount-1])
/* then a bunch of zeros after for the short metrics. */
/* ---------------------------------------------------------------------- */
PRIVATE int16 MergeXmtxTables(TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDestOffset,					/* offset into dest buffer where to write data */
						DTTF_HEADER *pDelta_dttf, 				/* includes number of elements in the pGlyphIndexArray from the Delta font */
						uint16 *pGlyphIndexArray, 				/* holds the mapping between entries in the Loca and actual Glyph Index numbers */
						DTTF_HEADER *pMerge_dttf, 				/* includes maximum Glyph index number of the Merge font */
						char * tag,								/* vmtx or hmtx */
						uint16 *pNewNumLongMetrics,			/* output is the number of long metrics written to dest font */
						uint32 *pulBytesWritten)				/* number of bytes written to the Output buffer */
{
uint16 usDeltaIndex, usMergeIndex;
uint32 ulDeltaOffset;  /* offset to beginning of HMTX table in Delta buffer */
uint32 ulMergeOffset; /* offset to beginning of HMTX table in Merge buffer */
int16 errCode = NO_ERROR;
uint16 usBytesWritten;
uint16 usBytesRead;
LONGXMETRIC lxm;
LONGXMETRIC delta_lxm;
LONGXMETRIC merge_lxm;
LONGXMETRIC zerolxm;
uint16 usLongMetricSize;
uint16 newNumLongMetrics=0;
uint16 effectiveDeltaNumLongMetrics;
uint16 effectiveMergeNumLongMetrics;
uint16 usLastGlyphIndex;
XHEA DeltaXhea, MergeXhea;
uint16 usDummyIndex;


	/* need to uncompact the merge font first */
	if (strcmp(tag,HMTX_TAG) == 0) 
	{
		GetHHea(pDeltaBufferInfo, (HHEA *)&DeltaXhea);
		GetHHea(pMergeBufferInfo, (HHEA *)&MergeXhea);
	}
	else if (strcmp(tag,VMTX_TAG) == 0) 
	{
		GetVHea(pDeltaBufferInfo, (VHEA *)&DeltaXhea);
		GetVHea(pMergeBufferInfo, (VHEA *)&MergeXhea);
	}
	else
		return ERR_GENERIC;

	*pulBytesWritten = 0;
	ulDeltaOffset = TTTableOffset(pDeltaBufferInfo, tag);
	ulMergeOffset = TTTableOffset(pMergeBufferInfo, tag);
	zerolxm.advanceX = 0;
	zerolxm.xsb = 0;

	/* let's pre-calculate where our numLongMetrics will end up, shall we? */
	/* add in 1 for zero to 1 base conversion,*/

	// Line replaced paulli 12/10/97
	//usLastGlyphIndex = max(pGlyphIndexArray[DeltaXhea.numLongMetrics-1],pMerge_dttf->maxGlyphIndexUsed); 
	usLastGlyphIndex = max(pDelta_dttf->maxGlyphIndexUsed,pMerge_dttf->maxGlyphIndexUsed);
	
	// Line replaced paulli 12/10/97
	// effectiveDeltaNumLongMetrics = 	pGlyphIndexArray[DeltaXhea.numLongMetrics-1] + 1;
	effectiveDeltaNumLongMetrics = pDelta_dttf->maxGlyphIndexUsed + 1;

	/*  v-lpathe comment: then add in any dummy entry if any (DeltaXhea.numLongMetrics - pDelta_dttf->glyphCount) should be 1 or 0*/
	/* 	effectiveDeltaNumLongMetrics = 	pDelta_dttf->maxGlyphIndexUsed + 1 + (DeltaXhea.numLongMetrics - pDelta_dttf->glyphCount); */
		
	effectiveMergeNumLongMetrics = min(MergeXhea.numLongMetrics, pMerge_dttf->maxGlyphIndexUsed + 1);
	newNumLongMetrics = max(effectiveDeltaNumLongMetrics,effectiveMergeNumLongMetrics); 
	usDummyIndex = newNumLongMetrics; /* if we are to have a dummy index, it would be here */

	usLongMetricSize = GetGenericSize(LONGXMETRIC_CONTROL);

	for (usMergeIndex = usDeltaIndex = 0; usMergeIndex < pMerge_dttf->originalNumGlyphs; ++usMergeIndex)
	{
		if (usDeltaIndex < pDelta_dttf->glyphCount && (usMergeIndex == pGlyphIndexArray[usDeltaIndex])) /* there may be some good delta stuff to keep from Delta file */
		{
			/* we want to keep delta data if:
				1. we have found an entry for which there is data in the delta file OR
				2. the long metrics part of the merge file is shorter than the long metrics part of the delta file */
			/* Otherwise, we want to read from the merge font */
		
			if (usDeltaIndex < DeltaXhea.numLongMetrics)  /* read a long metric from the Delta font */
			{
				if ((errCode = ReadGeneric(pDeltaBufferInfo, (uint8 *) &delta_lxm, SIZEOF_LONGXMETRIC, LONGXMETRIC_CONTROL, ulDeltaOffset, &usBytesRead)) != NO_ERROR)
					return errCode;
				ulDeltaOffset += usLongMetricSize;
			}
			else   /* read from the short section. will have the proper advanceWidth already */
			{
				if ((errCode = ReadWord(pDeltaBufferInfo, &(delta_lxm.xsb), ulDeltaOffset)) != NO_ERROR)
					return errCode;
 				ulDeltaOffset += sizeof(uint16);
			}
			lxm = delta_lxm;
			++ usDeltaIndex;
			if (usMergeIndex < MergeXhea.numLongMetrics)	/* the size of a long metric */
			{
				if (usMergeIndex == MergeXhea.numLongMetrics - 1) /*special case, need to read that metric */
   					if ((errCode = ReadGeneric(pMergeBufferInfo, (uint8 *) &merge_lxm, SIZEOF_LONGXMETRIC, LONGXMETRIC_CONTROL, ulMergeOffset, &usBytesRead)) != NO_ERROR)
						return errCode;
				ulMergeOffset += usLongMetricSize;
			}
			else
				ulMergeOffset += sizeof(uint16);
		}
		else  /* read from the merge table */
		{
			if (usMergeIndex < MergeXhea.numLongMetrics) /* read a long metric from the merge file */
			{
				if ((errCode = ReadGeneric(pMergeBufferInfo, (uint8 *) &merge_lxm, SIZEOF_LONGXMETRIC, LONGXMETRIC_CONTROL, ulMergeOffset, &usBytesRead)) != NO_ERROR)
					return errCode;
				ulMergeOffset += usLongMetricSize;
			}
			else /* otherwise, read the short metric from the merge font, will have the proper advanceWidth already */
			{
				if ((errCode = ReadWord(pMergeBufferInfo, &(merge_lxm.xsb), ulMergeOffset)) != NO_ERROR)
					return errCode;
 				ulMergeOffset += sizeof(uint16);
			}
			lxm = merge_lxm;
		}

		/* now, write out that metric */
		if (usMergeIndex < newNumLongMetrics) /* we can output a long */
		{
			if ((errCode = WriteGeneric(pDestBufferInfo, (uint8 *) &lxm, SIZEOF_LONGXMETRIC, LONGXMETRIC_CONTROL, ulDestOffset+*pulBytesWritten, &usBytesWritten)) != NO_ERROR)
				return errCode;
			*pulBytesWritten += usBytesWritten;
		}
		/* there is a special case where the newNumLongMetrics is also the last metric written. (the values in the short metric are zero) */
		/* in this case we wish to write out a "dummy" zero long metric so that subsequent merges will work correctly. this is similar */
		/* to when a table is uncompacted */
		/* in this way, the remainder of the glyphs will have an advance width of 0 */
		else if ((usMergeIndex == usDummyIndex) && (usMergeIndex > usLastGlyphIndex)) /* we processed the last one- no short metrics */
		{
			if ((errCode = WriteGeneric(pDestBufferInfo, (uint8 *) &zerolxm, SIZEOF_LONGXMETRIC, LONGXMETRIC_CONTROL, ulDestOffset+*pulBytesWritten, &usBytesWritten)) != NO_ERROR)
				return errCode;
			*pulBytesWritten += usBytesWritten;
			++ newNumLongMetrics;
		}
		else
		{
 			if ((errCode = WriteWord(pDestBufferInfo, lxm.xsb, ulDestOffset+*pulBytesWritten)) != NO_ERROR)
				return errCode;
			*pulBytesWritten += sizeof(uint16);
		}
	}

	*pNewNumLongMetrics = newNumLongMetrics;
	return NO_ERROR;

}
/* ---------------------------------------------------------------------- */
/* this routine will create an expanded hdmx table from the compact form and */
/* merge it with an exiting expanded hdmx table */
/* ---------------------------------------------------------------------- */
PRIVATE int16 MergeHdmxTables(TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDestOffset,					  /* offset into dest buffer where to write data */
						uint16 usGlyphCount, 					  /* number of elements in the pGlyphIndexArray from the Delta font */
						uint16 *pGlyphIndexArray, 				  /* holds the mapping between entries in the Loca and actual Glyph Index numbers */
						uint16 numGlyphs, 						  /* number of glyphs in the original (uncompact) font. Should match number in the merge font */
						uint32 *pulBytesWritten)				  /* number of bytes written to the Output buffer */
{

uint16 usDeltaIndex, usMergeIndex;
uint32 ulDeltaOffset, ulMergeOffset;
int16 errCode = NO_ERROR;
uint16 i;
uint16 usBytesRead;
uint16 usBytesWritten;
uint32 ulMergeDevRecordOffset;
uint32 ulDeltaDevRecordOffset;
HDMX merge_hdmx;
HDMX delta_hdmx;
HDMX_DEVICE_REC merge_hdmx_dev_rec;
HDMX_DEVICE_REC delta_hdmx_dev_rec;
uint8 byteValue;

	*pulBytesWritten = 0;

	ulDeltaOffset = TTTableOffset(pDeltaBufferInfo, HDMX_TAG);
	ulMergeOffset = TTTableOffset(pMergeBufferInfo, HDMX_TAG);

	if ((errCode = ReadGeneric(pMergeBufferInfo, (uint8 *) &merge_hdmx, SIZEOF_HDMX, HDMX_CONTROL, ulMergeOffset, &usBytesRead)) != NO_ERROR)
		return errCode;
	ulMergeOffset += usBytesRead;
	if ((errCode = ReadGeneric(pDeltaBufferInfo, (uint8 *) &delta_hdmx, SIZEOF_HDMX, HDMX_CONTROL, ulDeltaOffset, &usBytesRead)) != NO_ERROR)
		return errCode;
	ulDeltaOffset += usBytesRead;

	ulMergeDevRecordOffset = ulMergeOffset;
	ulDeltaDevRecordOffset = ulDeltaOffset;
	if ((errCode = WriteGeneric(pDestBufferInfo, (uint8 *) &merge_hdmx, SIZEOF_HDMX, HDMX_CONTROL, ulDestOffset, &usBytesWritten)) != NO_ERROR)
		return errCode;
	*pulBytesWritten += usBytesWritten;

	for (i = 0 ; i < merge_hdmx.numDeviceRecords; ++i)
	{
 		ulMergeOffset = ulMergeDevRecordOffset + (i * merge_hdmx.sizeDeviceRecord);
		ulDeltaOffset = ulDeltaDevRecordOffset + (i * delta_hdmx.sizeDeviceRecord);
		if ((errCode = ReadGeneric(pMergeBufferInfo, (uint8 *) &merge_hdmx_dev_rec, SIZEOF_HDMX_DEVICE_REC, HDMX_DEVICE_REC_CONTROL, ulMergeOffset, &usBytesRead)) != NO_ERROR)
			return errCode;
		ulMergeOffset += usBytesRead;
		if ((errCode = ReadGeneric(pDeltaBufferInfo, (uint8 *) &delta_hdmx_dev_rec, SIZEOF_HDMX_DEVICE_REC, HDMX_DEVICE_REC_CONTROL, ulDeltaOffset, &usBytesRead)) != NO_ERROR)
			return errCode;
		ulDeltaOffset += usBytesRead; 
		if (merge_hdmx_dev_rec.pixelSize != delta_hdmx_dev_rec.pixelSize)
			return ERR_INVALID_HDMX;
		/* need to set the maxWidth value */
		merge_hdmx_dev_rec.maxWidth = max(merge_hdmx_dev_rec.maxWidth, delta_hdmx_dev_rec.maxWidth);
		if ((errCode = WriteGeneric(pDestBufferInfo, (uint8 *) &merge_hdmx_dev_rec, SIZEOF_HDMX_DEVICE_REC, HDMX_DEVICE_REC_CONTROL, ulDestOffset + *pulBytesWritten, &usBytesWritten)) != NO_ERROR)
			return errCode;
		*pulBytesWritten += usBytesWritten;

		for (usMergeIndex = usDeltaIndex = 0; usMergeIndex < numGlyphs; ++usMergeIndex)
		{
			if ((usDeltaIndex < usGlyphCount) && (usMergeIndex == pGlyphIndexArray[usDeltaIndex])) /* this one should come from the input table */
			{
				if ((errCode = ReadByte(pDeltaBufferInfo, &byteValue, ulDeltaOffset)) != NO_ERROR)
					return errCode;
				ulDeltaOffset += sizeof(uint8);
				++ usDeltaIndex;
			}
			else  
			{
				if ((errCode = ReadByte(pMergeBufferInfo, &byteValue, ulMergeOffset)) != NO_ERROR)
					return errCode;
			}
			ulMergeOffset += sizeof(uint8);
			if ((errCode = WriteByte(pDestBufferInfo, byteValue, ulDestOffset+*pulBytesWritten)) != NO_ERROR)
				return errCode;
			*pulBytesWritten += sizeof(uint8);
		}
 		*pulBytesWritten += ZeroLongWordAlign(pDestBufferInfo, ulDestOffset+*pulBytesWritten);
	}
	return NO_ERROR;
}

/* ---------------------------------------------------------------------- */
/* this routine will create an expanded LTSH table from the compact form and */
/* merge it with an exiting expanded LTSH table */
/* ---------------------------------------------------------------------- */
PRIVATE int16 MergeLTSHTables(TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDestOffset,					  /* offset into dest buffer where to write data */
						uint16 usGlyphCount, 					  /* number of elements in the pGlyphIndexArray from the Delta font */
						uint16 *pGlyphIndexArray, 				  /* holds the mapping between entries in the Loca and actual Glyph Index numbers */
						uint16 numGlyphs, 						  /* number of glyphs in the original (uncompact) font. Should match number in the merge font */
						uint32 *pulBytesWritten)				  /* number of bytes written to the Output buffer */
{
uint16 usDeltaIndex, usMergeIndex;
uint32 ulDeltaOffset, ulMergeOffset;
int16 errCode = NO_ERROR;
uint16 usBytesRead;
uint16 usBytesWritten;
LTSH ltsh;
uint8 byteValue;

	*pulBytesWritten = 0;

	ulDeltaOffset = TTTableOffset(pDeltaBufferInfo, LTSH_TAG);
	ulMergeOffset = TTTableOffset(pMergeBufferInfo, LTSH_TAG);
	if ((errCode = ReadGeneric(pMergeBufferInfo, (uint8 *) &ltsh, SIZEOF_LTSH, LTSH_CONTROL, ulMergeOffset, &usBytesRead)) != NO_ERROR)
		return errCode;
	ulMergeOffset += usBytesRead;
	ulDeltaOffset += usBytesRead;
	if (numGlyphs != ltsh.numGlyphs)  /* should match */
		return ERR_INVALID_LTSH;
	if ((errCode = WriteGeneric(pDestBufferInfo, (uint8 *) &ltsh, SIZEOF_LTSH, LTSH_CONTROL, ulDestOffset, &usBytesWritten)) != NO_ERROR)
		return errCode;
	*pulBytesWritten += usBytesWritten;

	for (usMergeIndex = usDeltaIndex = 0; usMergeIndex < numGlyphs; ++usMergeIndex)
	{
		if ((usDeltaIndex < usGlyphCount) && (usMergeIndex == pGlyphIndexArray[usDeltaIndex])) /* this one should come from the delta table */
		{
			if ((errCode = ReadByte(pDeltaBufferInfo, &byteValue, ulDeltaOffset)) != NO_ERROR)
				return errCode;
			ulDeltaOffset += sizeof(uint8);
			++ usDeltaIndex;
		}
		else   /* read from Merge Buffer */
		{
			if ((errCode = ReadByte(pMergeBufferInfo, &byteValue, ulMergeOffset)) != NO_ERROR)
				return errCode;
		}
		ulMergeOffset += sizeof(uint8);
		if ((errCode = WriteByte(pDestBufferInfo, byteValue, ulDestOffset+*pulBytesWritten)) != NO_ERROR)
			return errCode;
		*pulBytesWritten += sizeof(uint8);
	}
	return NO_ERROR;
}
/* ---------------------------------------------------------------------- */
/* calculate max of maxes */
/* ---------------------------------------------------------------------- */
PRIVATE int16 MergeMaxpTables(TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDestOffset,					  /* offset into dest buffer where to write data */
						uint32 *pulBytesWritten)				  /* number of bytes written to the Output buffer */
{
MAXP DeltaMaxp, MergeMaxp, DestMaxp;
int16 errCode;
uint16 usBytesWritten;

	if (GetMaxp(pDeltaBufferInfo, &DeltaMaxp) == DIRECTORY_ERROR)
		return ERR_INVALID_MAXP;

	if (GetMaxp(pMergeBufferInfo, &MergeMaxp) == DIRECTORY_ERROR)
		return ERR_INVALID_MAXP;

   DestMaxp.version = MergeMaxp.version;
   DestMaxp.numGlyphs = MergeMaxp.numGlyphs;
   DestMaxp.maxPoints = max(MergeMaxp.maxPoints, DeltaMaxp.maxPoints);
   DestMaxp.maxContours = max(MergeMaxp.maxContours, DeltaMaxp.maxContours);
   DestMaxp.maxCompositePoints = max(MergeMaxp.maxCompositePoints, DeltaMaxp.maxCompositePoints);
   DestMaxp.maxCompositeContours = max(MergeMaxp.maxCompositeContours, DeltaMaxp.maxCompositeContours);
   DestMaxp.maxElements = max(MergeMaxp.maxElements, DeltaMaxp.maxElements);
   DestMaxp.maxTwilightPoints = max(MergeMaxp.maxTwilightPoints, DeltaMaxp.maxTwilightPoints);
   DestMaxp.maxStorage = max(MergeMaxp.maxStorage, DeltaMaxp.maxStorage);
   DestMaxp.maxFunctionDefs = max(MergeMaxp.maxFunctionDefs, DeltaMaxp.maxFunctionDefs);
   DestMaxp.maxInstructionDefs = max(MergeMaxp.maxInstructionDefs, DeltaMaxp.maxInstructionDefs);
   DestMaxp.maxStackElements = max(MergeMaxp.maxStackElements, DeltaMaxp.maxStackElements);
   DestMaxp.maxSizeOfInstructions = max(MergeMaxp.maxSizeOfInstructions, DeltaMaxp.maxSizeOfInstructions);
   DestMaxp.maxComponentElements = max(MergeMaxp.maxComponentElements, DeltaMaxp.maxComponentElements);
   DestMaxp.maxComponentDepth = max(MergeMaxp.maxComponentDepth, DeltaMaxp.maxComponentDepth);

   errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &DestMaxp, SIZEOF_MAXP, MAXP_CONTROL, ulDestOffset, &usBytesWritten);
   *pulBytesWritten = usBytesWritten;
   
   return errCode;

}
/* ---------------------------------------------------------------------- */
PRIVATE int16 MergeHeadTables(TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDestOffset,					/* offset into dest buffer where to write data */
						uint32 *pulBytesWritten)				/* number of bytes written to the Output buffer */
{
HEAD DeltaHead, MergeHead, DestHead;
int16 errCode;
uint16 usBytesWritten;

	if (GetHead(pDeltaBufferInfo, &DeltaHead) == DIRECTORY_ERROR)
		return ERR_MISSING_HEAD;

	if (GetHead(pMergeBufferInfo, &MergeHead) == DIRECTORY_ERROR)
		return ERR_MISSING_HEAD;

   memcpy(&DestHead, &MergeHead, SIZEOF_HEAD);

   DestHead.checkSumAdjustment = 0;
 /* don't know IndexToLocFmt yet (glyf comes after head) /* will set later */
   DestHead.indexToLocFormat = 0;
   DestHead.xMin = min(MergeHead.xMin, DeltaHead.xMin);
   DestHead.yMin = min(MergeHead.yMin, DeltaHead.yMin);
   DestHead.xMax = max(MergeHead.xMax, DeltaHead.xMax);
   DestHead.yMax = max(MergeHead.yMax, DeltaHead.yMax);

   errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &DestHead, SIZEOF_HEAD, HEAD_CONTROL, ulDestOffset, &usBytesWritten);
   *pulBytesWritten = usBytesWritten;
   
   return errCode;

}
/* ---------------------------------------------------------------------- */
PRIVATE int16 MergeHheaTables(TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDestOffset,					/* offset into dest buffer where to write data */
						uint32 *pulBytesWritten)				/* number of bytes written to the Output buffer */
{
HHEA DeltaHhea, MergeHhea, DestHhea;
int16 errCode;
uint16 usBytesWritten;

	if (GetHHea(pDeltaBufferInfo, &DeltaHhea) == DIRECTORY_ERROR)
		return ERR_MISSING_HHEA;

	if (GetHHea(pMergeBufferInfo, &MergeHhea) == DIRECTORY_ERROR)
		return ERR_MISSING_HHEA;

	memcpy(&DestHhea, &MergeHhea, SIZEOF_HHEA);

	DestHhea.minLeftSideBearing = min(MergeHhea.minLeftSideBearing, DeltaHhea.minLeftSideBearing);
	DestHhea.minRightSideBearing = min(MergeHhea.minRightSideBearing, DeltaHhea.minRightSideBearing);
	DestHhea.advanceWidthMax = max(MergeHhea.advanceWidthMax, DeltaHhea.advanceWidthMax);
	DestHhea.xMaxExtent = max(MergeHhea.xMaxExtent, DeltaHhea.xMaxExtent);

	errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &DestHhea, SIZEOF_HHEA, HHEA_CONTROL, ulDestOffset, &usBytesWritten);
	*pulBytesWritten = usBytesWritten;
	return errCode;

}
/* ---------------------------------------------------------------------- */
PRIVATE int16 MergeVheaTables(TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDestOffset,					/* offset into dest buffer where to write data */
						uint32 *pulBytesWritten)				/* number of bytes written to the Output buffer */
{
VHEA DeltaVhea, MergeVhea, DestVhea;
int16 errCode;
uint16 usBytesWritten;

	if (GetVHea(pDeltaBufferInfo, &DeltaVhea) == DIRECTORY_ERROR)
		return NO_ERROR;

	if (GetVHea(pMergeBufferInfo, &MergeVhea) == DIRECTORY_ERROR)
		return ERR_MISSING_VHEA;

	memcpy(&DestVhea, &MergeVhea, SIZEOF_VHEA);

	DestVhea.minTopSideBearing = min(MergeVhea.minTopSideBearing, DeltaVhea.minTopSideBearing);
	DestVhea.minBottomSideBearing = min(MergeVhea.minBottomSideBearing, DeltaVhea.minBottomSideBearing);
	DestVhea.advanceHeightMax = max(MergeVhea.advanceHeightMax, DeltaVhea.advanceHeightMax);
	DestVhea.yMaxExtent = max(MergeVhea.yMaxExtent, DeltaVhea.yMaxExtent);

	errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &DestVhea, SIZEOF_VHEA, VHEA_CONTROL, ulDestOffset, &usBytesWritten);
	*pulBytesWritten = usBytesWritten;

	return errCode;
}
/* ------------------------------------------------------------------- */
int16 ModOS2Table(TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						uint32 ulDestOffset,					/* offset into dest buffer where to write data */
						uint16 usMaxChr,						/* values taken when cmap was calculated */
						uint16 usMinChr)
{
OS2  Os2;
uint16 usBytesWritten;
uint16 usBytesRead;
int16 errCode = NO_ERROR;

/* just read an old OS2 table, even if the new one is there */

	if ((errCode = ReadGeneric( pDestBufferInfo, (uint8 *) &Os2, SIZEOF_OS2, OS2_CONTROL, ulDestOffset, &usBytesRead)) != NO_ERROR)
		return NO_ERROR;

	Os2.usFirstCharIndex = usMinChr;
	Os2.usLastCharIndex  = usMaxChr;

	if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &Os2, SIZEOF_OS2, OS2_CONTROL, ulDestOffset, &usBytesWritten )) != NO_ERROR)
		return errCode;

	return errCode;
}
/* ---------------------------------------------------------------------- */
/* this routine sorts an array of directory entries by optimized offset value */
#define DIR_OPTIMIZE_TAG_COUNT 33
ULONG g_DirOptimizeTagArray[DIR_OPTIMIZE_TAG_COUNT] = 
{
HEAD_LONG_TAG,
HHEA_LONG_TAG,
MAXP_LONG_TAG,
OS2_LONG_TAG,
HMTX_LONG_TAG,
LTSH_LONG_TAG,
VDMX_LONG_TAG,
HDMX_LONG_TAG,
CMAP_LONG_TAG,
FPGM_LONG_TAG,
PREP_LONG_TAG,
CVT_LONG_TAG,
GLYF_LONG_TAG,
LOCA_LONG_TAG,
KERN_LONG_TAG,
NAME_LONG_TAG,
POST_LONG_TAG,
GASP_LONG_TAG,
PCLT_LONG_TAG,
VHEA_LONG_TAG,
VMTX_LONG_TAG,
EBDT_LONG_TAG,
EBLC_LONG_TAG,
EBSC_LONG_TAG,
BDAT_LONG_TAG,
BLOC_LONG_TAG,
BSCA_LONG_TAG,
GPOS_LONG_TAG,
GSUB_LONG_TAG,
GDEF_LONG_TAG,
JSTF_LONG_TAG,
BASE_LONG_TAG,
DTTF_LONG_TAG,


} ;
/* ---------------------------------------------------------------------- */
int16 FindTagInDirArray(uint32 ulTag, DIRECTORY * aDirectory, uint16 usStartIndex, uint16 usnDirs)
{
uint16 usDirIndex;

	for (usDirIndex = usStartIndex;	usDirIndex < usnDirs; ++ usDirIndex)
	{
		if (ulTag == aDirectory[usDirIndex].tag)
			return (int16) usDirIndex;
	}
	return -1;
}

/* ---------------------------------------------------------------------- */
PRIVATE void SortByOptimizedOffset( DIRECTORY * aDirectory,
					uint16      usnDirs )
{
DIRECTORY tmpDir;
uint16 usDirIndex;
uint16 usTagIndex;
int16 sFoundIndex;

	if (aDirectory == NULL || usnDirs == 0)
		return;
	for (usDirIndex = usTagIndex = 0; usTagIndex < DIR_OPTIMIZE_TAG_COUNT && usDirIndex < usnDirs; ++usTagIndex)
	{
		sFoundIndex = FindTagInDirArray(g_DirOptimizeTagArray[usTagIndex], aDirectory, usDirIndex, usnDirs);
		if (sFoundIndex >= 0 && sFoundIndex < usnDirs)	/* found it */
		{	/* Swap them */
		   tmpDir = aDirectory[usDirIndex];
		   aDirectory[usDirIndex] = aDirectory[sFoundIndex];
		   aDirectory[sFoundIndex] = tmpDir;
		   ++usDirIndex;
		}
	}
}


/* ---------------------------------------------------------------------- */
PRIVATE int16 MergeFonts(TTFACC_FILEBUFFERINFO *pDeltaBufferInfo, /* buffer that holds the Delta font in compact form */
						TTFACC_FILEBUFFERINFO *pMergeBufferInfo, /* buffer that holds the font to merge with in TrueType form */
						TTFACC_FILEBUFFERINFO *pDestBufferInfo, /* where to write the output */
						DTTF_HEADER *pDelta_dttf, 				/* includes number of elements in the pGlyphIndexArray from the Delta font */
						uint16 *pGlyphIndexArray, 				  /* holds the mapping between entries in the Loca and actual Glyph Index numbers */
						DTTF_HEADER *pMerge_dttf, 				/* includes maximum Glyph index number of the Merge font */
						uint32 *pulBytesWritten)				  /* number of bytes written to the Output buffer */
{
DIRECTORY *pDeltaDirectory;	/* Input */
DIRECTORY *pMergeDirectory;
DIRECTORY *pDestDirectory;	/* Output */
OFFSET_TABLE DeltaOffsetTable;	/* Input */
OFFSET_TABLE MergeOffsetTable;
OFFSET_TABLE DestOffsetTable;	/* Output */
/* table indices of table that need to be updated by info from tables that occur after them */
int16 head_index = -1;
int16 hhea_index = -1;
int16 vhea_index = -1;
int16 os2_index = -1;
uint16 usnTables;
uint32 ulDirOffset;
uint32 ulDestOffset;
uint32 ulDestLocaOffset = 0;
uint32 ulDestLocaLength = 0;
uint32 ulDestGlyfLength;
uint16 usTempMergeIndex, usTempDeltaIndex;
uint16 usNumGlyphs; 
uint16 usBytesRead;
uint16 usBytesWritten;
uint32 ulBytesRead;
uint32 ulBytesWritten; /* local copy */
/* uint16 DoTwo; for eblc - bloc dealings */
int16 errCode=NO_ERROR;
uint16 usNewNumLongHorMetrics;
uint16 usNewNumLongVerMetrics;
uint16 indexToLocFmt=0;
uint16 usDestTableIndex, usMergeTableIndex, usDeltaTableIndex;
uint16 usDestEBDTTableIndex = 0;
uint16 usDestBdatTableIndex = 0;
uint16 OS2MaxCode, OS2MinCode;
uint16 savedMaxGlyphIndexUsed;
HEAD head;
HHEA hhea;
VHEA vhea;

	/* if format in the 'dttf' table of the puchMergeFontBuffer != 3 return error */
	if ((pMerge_dttf->format != TTFDELTA_MERGE) || (pDelta_dttf->format != TTFDELTA_DELTA))
		errCode = ERR_INVALID_MERGE_FORMATS;
	else if (pDelta_dttf->checkSum != pMerge_dttf->checkSum)
		errCode = ERR_INVALID_MERGE_CHECKSUMS;
	else if (pDelta_dttf->originalNumGlyphs != pMerge_dttf->originalNumGlyphs)
		errCode = ERR_INVALID_MERGE_NUMGLYPHS;

	if (errCode != NO_ERROR)
		return errCode;

	*pulBytesWritten = 0;
	usNumGlyphs = pMerge_dttf->originalNumGlyphs;
	/* read offset table and determine number of existing tables */
	ulDirOffset = pDeltaBufferInfo->ulOffsetTableOffset;
	if ((errCode = ReadGeneric( pDeltaBufferInfo, (uint8 *) &DeltaOffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulDirOffset, &usBytesRead)) != NO_ERROR)
		return(errCode);
	ulDirOffset += usBytesRead;
	/* Create a list of valid tables */

	pDeltaDirectory = (DIRECTORY *) Mem_Alloc(DeltaOffsetTable.numTables * SIZEOF_DIRECTORY);	
	if (pDeltaDirectory == NULL)
		return(ERR_MEM);

	if ((errCode = ReadGenericRepeat( pDeltaBufferInfo, (uint8 *) pDeltaDirectory, DIRECTORY_CONTROL, ulDirOffset, &ulBytesRead, DeltaOffsetTable.numTables , SIZEOF_DIRECTORY )) != NO_ERROR)
	{
		Mem_Free(pDeltaDirectory);
		return errCode;
	}
	ulDirOffset = pMergeBufferInfo->ulOffsetTableOffset;
	/* now read merge data */
	if ((errCode = ReadGeneric( pMergeBufferInfo, (uint8 *) &MergeOffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulDirOffset, &usBytesRead)) != NO_ERROR)
	{
		Mem_Free(pDeltaDirectory);
		return(errCode);
	}
	ulDirOffset += usBytesRead;
	/* Create a list of valid tables */

	pMergeDirectory = (DIRECTORY *) Mem_Alloc(MergeOffsetTable.numTables * SIZEOF_DIRECTORY);	
	if (pMergeDirectory == NULL)
	{
		Mem_Free(pDeltaDirectory);
		return(ERR_MEM);
	}

	if ((errCode = ReadGenericRepeat( pMergeBufferInfo, (uint8 *) pMergeDirectory, DIRECTORY_CONTROL, ulDirOffset, &ulBytesRead, MergeOffsetTable.numTables , SIZEOF_DIRECTORY )) != NO_ERROR)
	{
		Mem_Free(pDeltaDirectory);
		Mem_Free(pMergeDirectory);
		return errCode;
	}
 	/* worst case allocation */
	pDestDirectory = (DIRECTORY *) Mem_Alloc((DeltaOffsetTable.numTables + MergeOffsetTable.numTables) * SIZEOF_DIRECTORY);	
	if (pDestDirectory == NULL)
	{
		Mem_Free(pDeltaDirectory);
		Mem_Free(pMergeDirectory);
		return(ERR_MEM);
	}

/* 1.  A directory is created with the union of tables from the puchMergeFontBuffer and puchDeltaFontBuffer. This is because EBLC and EBDT may exist only in the puchDeltaFontBuffer font. */
	usnTables = MergeDirectories(pDeltaDirectory, DeltaOffsetTable.numTables, pMergeDirectory, MergeOffsetTable.numTables, pDestDirectory); 
	DestOffsetTable.version = MergeOffsetTable.version;
	DestOffsetTable.numTables = usnTables;
	DestOffsetTable.searchRange = (uint16)((0x0001 << ( log2( usnTables ))) << 4 );
	DestOffsetTable.entrySelector = (uint16)(log2((uint16)(0x0001 << ( log2( usnTables )))));
	DestOffsetTable.rangeShift = (uint16)((usnTables << 4) - ((0x0001 << ( log2( usnTables ))) * 16 ));

	ulDestOffset = pDestBufferInfo->ulOffsetTableOffset;
	if ((errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &DestOffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulDestOffset, &usBytesWritten)) != NO_ERROR)
	{
		Mem_Free(pDeltaDirectory);
		Mem_Free(pMergeDirectory);
		Mem_Free(pDestDirectory);
		return(errCode);
	}

	ulDestOffset = ulDestOffset + usBytesWritten + (usnTables * GetGenericSize(DIRECTORY_CONTROL));
	
	SortByOptimizedOffset(pDestDirectory, usnTables);
	SortByOptimizedOffset(pMergeDirectory, MergeOffsetTable.numTables);
 	SortByOptimizedOffset(pDeltaDirectory, DeltaOffsetTable.numTables);

	/* now copy over actual tables */
	for (usDestTableIndex = usMergeTableIndex = usDeltaTableIndex = 0; usDestTableIndex < usnTables && errCode == NO_ERROR; ++ usDestTableIndex)
	{
		ulDestOffset += ZeroLongWordAlign(pDestBufferInfo, ulDestOffset);
		pDestDirectory[usDestTableIndex].offset = ulDestOffset;
		usTempMergeIndex = usMergeTableIndex;
		usTempDeltaIndex = usDeltaTableIndex;
		if (usMergeTableIndex < MergeOffsetTable.numTables)
		{
			if (pMergeDirectory[usMergeTableIndex].tag == pDestDirectory[usDestTableIndex].tag)
			    ++usMergeTableIndex;
		}
		if (usDeltaTableIndex < DeltaOffsetTable.numTables)
		{
			if (pDeltaDirectory[usDeltaTableIndex].tag == pDestDirectory[usDestTableIndex].tag)
			    ++usDeltaTableIndex;
		}

		switch (pDestDirectory[usDestTableIndex].tag)
		{
		case HEAD_LONG_TAG: 
			errCode = MergeHeadTables(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, ulDestOffset, &ulBytesWritten);
			head_index = usDestTableIndex;
			break;	
		case HHEA_LONG_TAG: /* don't yet know numLongMetrics */
			errCode = MergeHheaTables(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, ulDestOffset, &ulBytesWritten);
			hhea_index = usDestTableIndex;
			break;	
		case MAXP_LONG_TAG: /*  */
			errCode = MergeMaxpTables(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, ulDestOffset, &ulBytesWritten);
			break;	
		case HMTX_LONG_TAG:	  /* may need to change numLongHorMetrics */
			errCode = MergeXmtxTables(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, ulDestOffset, pDelta_dttf, pGlyphIndexArray, pMerge_dttf, HMTX_TAG, &usNewNumLongHorMetrics, &ulBytesWritten);
			break;	
		case LTSH_LONG_TAG: /* can simply merge in the values from the delta font, as size won't change */
			errCode = MergeLTSHTables(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, ulDestOffset, pDelta_dttf->glyphCount, pGlyphIndexArray, usNumGlyphs, &ulBytesWritten);
			break;	
		case HDMX_LONG_TAG:
			errCode = MergeHdmxTables(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, ulDestOffset, pDelta_dttf->glyphCount, pGlyphIndexArray, usNumGlyphs, &ulBytesWritten);
			break;	
		case CMAP_LONG_TAG:
			errCode = MergeCmapTables(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, ulDestOffset, &OS2MaxCode, &OS2MinCode, &ulBytesWritten );
			break;
		case GLYF_LONG_TAG:	/* need to walk through both locas, picking out the glyphs to copy 1 by 1 */
			errCode = MergeGlyfLocaTables(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, ulDestOffset, pDelta_dttf->glyphCount, pGlyphIndexArray, usNumGlyphs, &ulDestGlyfLength, &indexToLocFmt, &ulDestLocaOffset, &ulDestLocaLength );
			pDestDirectory[usDestTableIndex].length = ulDestGlyfLength;
			ulDestOffset = ulDestLocaOffset + ulDestLocaLength;  /* set this for next go around */
			continue;
		case LOCA_LONG_TAG:
		 /* skip, we created a new one when we wrote glyf table */
			pDestDirectory[usDestTableIndex].offset = ulDestLocaOffset;
			pDestDirectory[usDestTableIndex].length = ulDestLocaLength;
			continue;
		case VHEA_LONG_TAG: /* don't yet know numLongMetrics */
			errCode = MergeVheaTables(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, ulDestOffset, &ulBytesWritten);
			vhea_index = usDestTableIndex;
			break;	
		case VMTX_LONG_TAG:	/* may need to change numLongVerMetrics */
			errCode = MergeXmtxTables(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, ulDestOffset, pDelta_dttf, pGlyphIndexArray, pMerge_dttf, VMTX_TAG, &usNewNumLongVerMetrics, &ulBytesWritten);
			break;	
		case DTTF_LONG_TAG: /* need to write out dttf table  */
			savedMaxGlyphIndexUsed = pMerge_dttf->maxGlyphIndexUsed;
			pMerge_dttf->maxGlyphIndexUsed = max(savedMaxGlyphIndexUsed,pDelta_dttf->maxGlyphIndexUsed);
			errCode = WriteGeneric(pDestBufferInfo, (uint8 *) pMerge_dttf, SIZEOF_DTTF_HEADER, DTTF_HEADER_CONTROL, pDestDirectory[usDestTableIndex].offset, &usBytesWritten);
			pMerge_dttf->maxGlyphIndexUsed = savedMaxGlyphIndexUsed;
			ulBytesWritten = usBytesWritten;
			break;
		case BDAT_LONG_TAG:
			usDestBdatTableIndex = usDestTableIndex;   /* save this so we know what to update */
			continue; /* skip, we'll create a new one when we process EBLC */
		case BLOC_LONG_TAG:
			errCode = MergeEblcEbdtTables(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, /* where to write the output */
						ulDestOffset, 
						&(pDestDirectory[usDestTableIndex].length), 
						&(pDestDirectory[usDestBdatTableIndex].offset),
						&(pDestDirectory[usDestBdatTableIndex].length),
						BLOC_TAG, BDAT_TAG);			
			ulDestOffset = pDestDirectory[usDestBdatTableIndex].offset+pDestDirectory[usDestBdatTableIndex].length;
			continue;				
		case EBDT_LONG_TAG:
			usDestEBDTTableIndex = usDestTableIndex;   /* save this so we know what to update */
			continue; /* skip, we'll create a new one when we process EBLC */
		case EBLC_LONG_TAG:
			errCode = MergeEblcEbdtTables(pDeltaBufferInfo, pMergeBufferInfo, pDestBufferInfo, /* where to write the output */
						ulDestOffset, 
						&(pDestDirectory[usDestTableIndex].length), 
						&(pDestDirectory[usDestEBDTTableIndex].offset),
						&(pDestDirectory[usDestEBDTTableIndex].length),
						EBLC_TAG, EBDT_TAG);			
			ulDestOffset = pDestDirectory[usDestEBDTTableIndex].offset+pDestDirectory[usDestEBDTTableIndex].length;
			continue;				
		default:
 			if (pDestDirectory[usDestTableIndex].tag == OS2_LONG_TAG) /*  */
				os2_index = usDestTableIndex;
 			 			/*	copy the data over from the merge buffer */
			if (pMergeDirectory[usTempMergeIndex].tag == pDestDirectory[usDestTableIndex].tag) /* where is this coming from? */
			{
				ulBytesWritten = pMergeDirectory[usTempMergeIndex].length;
				errCode = CopyBlockOver(pDestBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *)pMergeBufferInfo,pDestDirectory[usDestTableIndex].offset, pMergeDirectory[usTempMergeIndex].offset, ulBytesWritten); 
			}
			else if (pDeltaDirectory[usTempDeltaIndex].tag == pDestDirectory[usDestTableIndex].tag) /* where is this coming from? */
			{
				ulBytesWritten = pDeltaDirectory[usTempDeltaIndex].length;
				errCode = CopyBlockOver(pDestBufferInfo, (CONST_TTFACC_FILEBUFFERINFO *)pDeltaBufferInfo,pDestDirectory[usDestTableIndex].offset, pDeltaDirectory[usTempDeltaIndex].offset, ulBytesWritten); 
			}
			else 
				errCode = ERR_FORMAT; /* huh? */
			break;	
		}
		if (errCode != NO_ERROR)
			break;
		pDestDirectory[usDestTableIndex].length = ulBytesWritten;

		ulDestOffset += pDestDirectory[usDestTableIndex].length;
	}
	if (errCode == NO_ERROR)
	{
		/* now fix up some tables */
		/* hhea, vhea, head.checkSumAdjust = 0, and head.indexToLocFmt */
		if (head_index > -1 && (errCode = ReadGeneric( pDestBufferInfo, (uint8 *) &head, SIZEOF_HEAD, HEAD_CONTROL, pDestDirectory[head_index].offset, &usBytesRead)) == NO_ERROR)
		{
			head.indexToLocFormat = indexToLocFmt;
			errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &head, SIZEOF_HEAD, HEAD_CONTROL, pDestDirectory[head_index].offset, &usBytesWritten);
		}
		if (hhea_index > -1 && (errCode = ReadGeneric( pDestBufferInfo, (uint8 *) &hhea, SIZEOF_HHEA, HHEA_CONTROL, pDestDirectory[hhea_index].offset, &usBytesRead)) == NO_ERROR)
		{
			hhea.numLongMetrics = usNewNumLongHorMetrics;
			errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &hhea, SIZEOF_HHEA, HHEA_CONTROL, pDestDirectory[hhea_index].offset, &usBytesWritten);
		}
		if (vhea_index > -1 && (errCode = ReadGeneric( pDestBufferInfo, (uint8 *) &vhea, SIZEOF_VHEA, VHEA_CONTROL, pDestDirectory[vhea_index].offset, &usBytesRead)) == NO_ERROR)
		{
			vhea.numLongMetrics = usNewNumLongVerMetrics;
			errCode = WriteGeneric( pDestBufferInfo, (uint8 *) &vhea, SIZEOF_VHEA, VHEA_CONTROL, pDestDirectory[vhea_index].offset, &usBytesWritten);
		}
		if (os2_index > -1) /*  */
		{
			errCode = ModOS2Table(pDestBufferInfo, pDestDirectory[os2_index].offset, OS2MaxCode, OS2MinCode);
		}
		/* calculate checksums */ 
		ulDestOffset += ZeroLongWordAlign(pDestBufferInfo, ulDestOffset);  /* so that last checksum will work ok. */
		for (usDestTableIndex = 0; usDestTableIndex < usnTables; ++ usDestTableIndex)
		{
			CalcChecksum( pDestBufferInfo, pDestDirectory[ usDestTableIndex ].offset, pDestDirectory[ usDestTableIndex ].length , &(pDestDirectory[ usDestTableIndex ].checkSum) );
		}

		/* Now write out Directory, in tag order */
		SortByTag(pDestDirectory, usnTables);

		if ((errCode = WriteGenericRepeat( pDestBufferInfo, (uint8 *) pDestDirectory, DIRECTORY_CONTROL, ulDirOffset, &ulBytesWritten, usnTables , SIZEOF_DIRECTORY )) == NO_ERROR)
		{
			/* now calc file checksum, and update head table */
			SetFileChecksum( pDestBufferInfo, ulDestOffset );
			/* and update pulBytesWritten; */
			*pulBytesWritten = ulDestOffset;
		}
	}
 	/* cleanup */
	Mem_Free(pDeltaDirectory);
	Mem_Free(pMergeDirectory);
	Mem_Free(pDestDirectory);

	return errCode;
}
/* ---------------------------------------------------------------------- */
/* ENTRY POINT !!!!
/* ---------------------------------------------------------------------- */
/*	puchMergeFontBuffer		is a pointer to a buffer containing a font containing a format 3 'dttf' 
							table to merge with. This is used only when usMode is 2.
	ulMergeFontBufferSize	is the size in bytes of puchMergeFontBuffer.
	puchDeltaFontBuffer		is a pointer to buffer for the Delta Font data. This should contain a 
							simple subsetted font when usMode is 0, a font with a 'dttf' format 1 
							table when usMode is 1, and a font with a 'dttf' format 2 tables when 
							usMode is 2.
	ulDeltaFontBufferSize	is the size in bytes of puchDeltaFontBuffer.
	**ppuchDestBuffer		is a pointer to a buffer pointer for destination subset or format 3 font
	*pulDestBufferSize		is a pointer to a long pointer which will contain the size of puchDestBuffer. 
							This will be set by the function.
	pulBytesWritten			is a pointer to a long integer where the length in bytes of the data 
							written to the puchDestBuffer will be written.
	usMode					determines what kind of process to perform. A merger or a simple 
							expansion. If usMode is 0, puchDeltaFontBuffer should contain a simple 
							font with no 'dttf' table. If usMode is 1, the puchMergeFontBuffer will 
							be ignored and the puchDeltaFontBuffer should contain a format 1 font. 
							If usMode is 2, the puchDeltaFontBuffer should contain a format 2 font, 
							and the puchMergeFontBuffer should contain a format 3 font to merge with. 
	lpfnReAllocate			is the callback function to allocate memory for the puchDestBuffer.
	lpvReserved				Set to NULL.

	Return Value is:
	0 if success
	various non-zero values for error conditions to be specified.

	CFP_REALLOCPROC is defined as:
	typedef void *(*CFP_REALLOCPROC)(void *, size_t);
	where argument = Number of bytes to allocate	
*/
/* ---------------------------------------------------------------------- */

int16 MergeDeltaTTF(CONST uint8 * puchMergeFontBuffer,
					CONST uint32 ulMergeFontBufferSize,
					CONST uint8 * puchDeltaFontBuffer,
					CONST uint32 ulDeltaFontBufferSize,
					uint8 **ppuchDestBuffer, /* output */
					uint32 *pulDestBufferSize, /* output */
					uint32 *pulBytesWritten, /* output */
					CONST uint16 usMode,
					CFP_REALLOCPROC lpfnReAllocate,
					void *lpvReserved)
{
uint32 ulOffset = 0;
uint32 ulDttfOffset = 0;
uint32 ulDttfLength = 0;
uint16 *pGlyphIndexArray = NULL;
int16 errCode = NO_ERROR;
uint16 usBytesRead;
uint32 ulBytesRead; /* for ReadGenericRepeat */
TTFACC_FILEBUFFERINFO OutputBufferInfo;	/* used by ttfacc routines */
CONST_TTFACC_FILEBUFFERINFO InputBufferInfo;
CONST_TTFACC_FILEBUFFERINFO MergeBufferInfo;
DTTF_HEADER merge_dttf;
DTTF_HEADER delta_dttf;

	if (puchDeltaFontBuffer == NULL)
		return ERR_GENERIC;

	if (Mem_Init() != MemNoErr)	  /* initialize memory manager */
		return ERR_MEM;

	InputBufferInfo.puchBuffer = puchDeltaFontBuffer;
	InputBufferInfo.ulBufferSize = ulDeltaFontBufferSize;
	InputBufferInfo.ulOffsetTableOffset = 0;
	InputBufferInfo.lpfnReAllocate = NULL;
	delta_dttf.format = 0;

	ulDttfOffset = TTTableOffset( (TTFACC_FILEBUFFERINFO *) &InputBufferInfo, DTTF_TAG );
	ulDttfLength = TTTableLength( (TTFACC_FILEBUFFERINFO *) &InputBufferInfo, DTTF_TAG);
	if (ulDttfOffset != DIRECTORY_ERROR && ulDttfLength != 0)
	{
		errCode = ReadGeneric((TTFACC_FILEBUFFERINFO *) &InputBufferInfo, (uint8 *) &delta_dttf, SIZEOF_DTTF_HEADER, DTTF_HEADER_CONTROL, ulDttfOffset, &usBytesRead);
		
		if (errCode == NO_ERROR)
		{
			/*  check version */
			if ((delta_dttf.version != CURRENT_DTTF_VERSION) &&  /* we may not be able to understand that format */
				/* first check if it's a major version change */
				((delta_dttf.version >> ONEVECSHIFT) != (CURRENT_DTTF_VERSION >> ONEVECSHIFT)))
					errCode = ERR_VERSION;	/* major version different */
			else if (delta_dttf.glyphCount != 0)
			{
				pGlyphIndexArray = Mem_Alloc(delta_dttf.glyphCount * sizeof(uint16));
				if (pGlyphIndexArray == NULL)
					errCode = ERR_MEM;
				else
					errCode = ReadGenericRepeat((TTFACC_FILEBUFFERINFO *) &InputBufferInfo, (uint8 *) pGlyphIndexArray,WORD_CONTROL, ulDttfOffset + usBytesRead, &ulBytesRead, delta_dttf.glyphCount, sizeof(uint16)); 
			}
		}
	}

	/* initialize */
	*pulBytesWritten = *pulDestBufferSize = 0;

	while (errCode == NO_ERROR)	/* dummy while to provide for break ability */
	{
		if (usMode == TTFMERGE_SUBSET)
		{
		/* if  puchDeltaFontBuffer contains a 'dttf' table return error*/
			if (delta_dttf.format != 0)
			{
				errCode = ERR_FORMAT;
				break;
			}
			/* allocate the dest buffer */
			/* make call to lpfnReAllocate with ulDeltaFontBufferSize to allocate *ppuchDestBuffer */
			*ppuchDestBuffer = (uint8 *) lpfnReAllocate(NULL,ulDeltaFontBufferSize);
			if (*ppuchDestBuffer == NULL)
			{
				errCode = ERR_MEM;
				break;
			}

			OutputBufferInfo.puchBuffer = *ppuchDestBuffer;
			OutputBufferInfo.ulBufferSize = ulDeltaFontBufferSize;
			InputBufferInfo.ulOffsetTableOffset = 0;
			OutputBufferInfo.lpfnReAllocate = NULL;
			
			/* copy data from puchDeltaFontBuffer to *ppuchDestBuffer */

			CopyBlockOver(&OutputBufferInfo, &InputBufferInfo, 0, 0, ulDeltaFontBufferSize); /* copy input file buffer to output file buffer */
			/* update * pulBytesWritten	*/
			*pulBytesWritten = *pulDestBufferSize = ulDeltaFontBufferSize;
		}
		else if (usMode == TTFMERGE_SUBSET1) 
		{
			/* if format in the 'dttf' table of the puchDeltaFontBuffer != 1 return error */
			if (delta_dttf.format != TTFDELTA_SUBSET1)
				errCode = ERR_FORMAT;
			else errCode = CalcUncompactFontSize((TTFACC_FILEBUFFERINFO *)&InputBufferInfo, pulDestBufferSize);
			
			if (errCode != NO_ERROR)
				break;

			/* make call to lpfnAllocate with correct size for uncompacted font to allocate *ppuchDestBuffer */
			*ppuchDestBuffer = (uint8 *) lpfnReAllocate(NULL,*pulDestBufferSize);
			if (*ppuchDestBuffer == NULL)
			{
				errCode = ERR_MEM;
				break;
			}

			OutputBufferInfo.puchBuffer = *ppuchDestBuffer;
			OutputBufferInfo.ulBufferSize = *pulDestBufferSize;
			OutputBufferInfo.ulOffsetTableOffset = 0;
			OutputBufferInfo.lpfnReAllocate = lpfnReAllocate;
			/* uncompact and copy the data from the puchDeltaFontBuffer to *ppuchDestBuffer */
			/* set the 'dttf' format value to 3, */
			/* remove the dttf.GlyphIndexArray */

			errCode = UnCompactSubset1Font((TTFACC_FILEBUFFERINFO *)&InputBufferInfo, &OutputBufferInfo, delta_dttf.glyphCount, pGlyphIndexArray, delta_dttf.originalNumGlyphs, pulBytesWritten);
		}
		else if (usMode == TTFMERGE_DELTA) 
		{
			if (puchMergeFontBuffer==NULL)
				errCode = ERR_GENERIC;
			/* if format in the 'dttf' table of the puchDeltaFontBuffer != 1 return error */
			else if (delta_dttf.format != TTFDELTA_DELTA)
				errCode = ERR_FORMAT;

			if (errCode != NO_ERROR)
				break;

			MergeBufferInfo.puchBuffer = puchMergeFontBuffer;
			MergeBufferInfo.ulBufferSize = ulMergeFontBufferSize;
			MergeBufferInfo.ulOffsetTableOffset = 0;
			MergeBufferInfo.lpfnReAllocate = NULL;

			ulDttfOffset = TTTableOffset( (TTFACC_FILEBUFFERINFO *)&MergeBufferInfo, DTTF_TAG );
			ulDttfLength = TTTableLength( (TTFACC_FILEBUFFERINFO *)&MergeBufferInfo, DTTF_TAG);
			if (ulDttfOffset != DIRECTORY_ERROR && 	ulDttfLength != 0)
			{
				if ((errCode = ReadGeneric((TTFACC_FILEBUFFERINFO *)&MergeBufferInfo, (uint8 *) &merge_dttf, SIZEOF_DTTF_HEADER, DTTF_HEADER_CONTROL, ulDttfOffset, &usBytesRead)) != NO_ERROR)
					break;
			}

			if (errCode != NO_ERROR)
				break;


			*pulDestBufferSize = ulDeltaFontBufferSize + ulMergeFontBufferSize;
			/* need to allow some room for growth in the vmtx and hmtx tables */
			if (TTTableOffset( (TTFACC_FILEBUFFERINFO *)&MergeBufferInfo, VMTX_TAG ) != DIRECTORY_ERROR)	/* there is a vmtx table */
				*pulDestBufferSize += (GetGenericSize(LONGXMETRIC_CONTROL) * merge_dttf.originalNumGlyphs * 2);
			else
				*pulDestBufferSize += (GetGenericSize(LONGXMETRIC_CONTROL) * merge_dttf.originalNumGlyphs);
			
			*ppuchDestBuffer = (uint8 *) lpfnReAllocate(NULL, *pulDestBufferSize);
			if (*ppuchDestBuffer == NULL)
			{
				errCode = ERR_MEM;
				break;
			}

			/* merge fonts */ 
			OutputBufferInfo.puchBuffer = *ppuchDestBuffer;
			OutputBufferInfo.ulBufferSize = *pulDestBufferSize;
			OutputBufferInfo.ulOffsetTableOffset =	0;
			OutputBufferInfo.lpfnReAllocate =	lpfnReAllocate;

			errCode = MergeFonts((TTFACC_FILEBUFFERINFO *)&InputBufferInfo, (TTFACC_FILEBUFFERINFO *)&MergeBufferInfo, &OutputBufferInfo, &delta_dttf, pGlyphIndexArray, &merge_dttf, pulBytesWritten);

		}
		else
			errCode = ERR_GENERIC;
		break;
	}
	Mem_Free(pGlyphIndexArray);
	return ExitCleanup(errCode);
}
/* ---------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\symbol.c ===
/**************************************************************************
 * module: SYMBOL.C
 *
 * author: Louise Pathe
 * date:   October 1994
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * Routines to manage the Symbol table 
 *
 **************************************************************************/


/* Inclusions ----------------------------------------------------------- */

#include <stdlib.h>  
#include <ctype.h> /* for is functions */

#include "typedefs.h"  
#include "symbol.h"
#include "ttmem.h"

#include <stdio.h>                                       
#include <string.h>
 
/* structure definitions ------------------------------------------------- */  
 
#define MAX_SYMBOL_INDEX 26	/* 26 chars + 1 we don't know about */
typedef struct symbol *PSYMBOL;

struct symbol 
{
	char *szSymbolString; /* only one of these will be used - symbol string OR symbol value */
	uint16 uSymbolValue;  
	void *pDataBlock;
	PSYMBOL pNext;
};


struct symbol_table 
{ 
	char signature[4]; /* signature so we know a pointer is valid */
	uint16 usSymbolType;  /* 0 = string, 1 = long */
	PSYMBOL SymbolList[MAX_SYMBOL_INDEX + 1]; /* array of symbol lists (buckets A-Z + 1)*/
	uint16 uDataSize;   
}; 
  
#define SYMSIG "sym"    /* must <= 3 chars */
  
/* function definitions ------------------------------------------------- */  
PRIVATE int16 SymbolGetIndex(char uchChar)
{
uint16 usIndex = MAX_SYMBOL_INDEX; /* last bucket for "other" chars */

	if (isalpha((int) uchChar))
	{
		if (isupper( (int) uchChar))
			usIndex = uchChar - 'A';
		else
			usIndex = uchChar - 'a';
	}
	return usIndex;
}
/* --------------------------------------------------------------------- */
PSYMBOL_TABLE CreateSymbolTable(uint16 CONST uDataSize, uint16 CONST usSymbolType)
{  
PSYMBOL_TABLE pSymbolTable;

/* Allocate a symbol_table structure array */ 
	if ((pSymbolTable = (PSYMBOL_TABLE) Mem_Alloc ((size_t) sizeof(*pSymbolTable))) == NULL)
		return(NULL);
/* fill in head with signature */
    strcpy(pSymbolTable->signature, SYMSIG);
    pSymbolTable->uDataSize = uDataSize; 
	pSymbolTable->usSymbolType = usSymbolType;

	/* return the pointer */
   return(pSymbolTable);
}

/* --------------------------------------------------------------------- */
void DestroySymbolTable(PSYMBOL_TABLE pSymbolTable)
{    
PSYMBOL pCurrSymbol = NULL;  /* current Symbol in linked list */
PSYMBOL pLastSymbol = NULL;  /* Last symbol in linked list. remove symbol here */
int16 i;

	if (pSymbolTable == NULL)
		return;
	/* check signature */  
	if (strcmp(pSymbolTable->signature,SYMSIG) != 0)
		return;
	for (i = 0; i <= MAX_SYMBOL_INDEX; ++i)
	{
		/* traverse linked list to free each symbol in chain */
		for (pCurrSymbol = pSymbolTable->SymbolList[i]; pCurrSymbol != NULL;)   
		{
			pLastSymbol = pCurrSymbol->pNext; 
			Mem_Free(pCurrSymbol->szSymbolString);
			Mem_Free(pCurrSymbol->pDataBlock);
			Mem_Free(pCurrSymbol);
			pCurrSymbol = pLastSymbol;
		}
	}
 	/* free symbol table  */  
 	Mem_Free(pSymbolTable);
}

/* --------------------------------------------------------------------- */
int16 GetSymbol (PSYMBOL_TABLE CONST pSymbolTable, char *CONST szSymbolString, uint16 uSymbolValue, void *pDataBlock)
{
PSYMBOL pCurrSymbol = NULL;  /* current Symbol in linked list */
int16 sCmp;
uint16 usIndex; 
uint16 i; 
char UpperString[MAXBUFFERLEN];

	if (pSymbolTable == NULL)
		return(SymErr);
	/* check signature */ 
	if (strcmp(pSymbolTable->signature,SYMSIG) != 0)
		return(SymErr);

	if (pSymbolTable->usSymbolType == 0) /* string type */
	{
		for (i = 0; i < MAXBUFFERLEN; ++i)
		{
			UpperString[i]=(char)toupper(szSymbolString[i]); 
			if (szSymbolString[i] == '\0')
				break;
		}

		usIndex = SymbolGetIndex(UpperString[0]);
		/* traverse linked list to find symbol string */
		for (pCurrSymbol = pSymbolTable->SymbolList[usIndex]; pCurrSymbol != NULL; pCurrSymbol = pCurrSymbol->pNext)   
		{
			if ((sCmp = (int16)strcmp(pCurrSymbol->szSymbolString, UpperString)) == 0)  
			{  
		/* copy data from symbol.pDataBlock to *pDataBlock */
				memcpy(pDataBlock, pCurrSymbol->pDataBlock, pSymbolTable->uDataSize);
	    		return(SymNoErr);	/* found the symbol */ 
			}
			else if (sCmp < 0)
				break;
		} 
	}
	else
	{
		usIndex = uSymbolValue % (MAX_SYMBOL_INDEX + 1);  /* which of the buckets is it in? */
		for (pCurrSymbol = pSymbolTable->SymbolList[usIndex]; pCurrSymbol != NULL; pCurrSymbol = pCurrSymbol->pNext)   
		{
			if (pCurrSymbol->uSymbolValue == uSymbolValue)  
			{  
		/* copy data from symbol.pDataBlock to *pDataBlock */
				memcpy(pDataBlock, pCurrSymbol->pDataBlock, pSymbolTable->uDataSize);
	    		return(SymNoErr);	/* found the symbol */ 
			}
		} 
	}

	return(SymErr);  /* didn't find it */
}

/* --------------------------------------------------------------------- */
int16 GetSymbolByFunction (PSYMBOL_TABLE CONST pSymbolTable, char * szSymbolString, uint16 *puSymbolValue, void *pDataBlock, uint16 uValue, pSymbolFunction pFunction)
{
PSYMBOL pCurrSymbol = NULL;  /* current Symbol in linked list */
uint16 i;

	if (pSymbolTable == NULL)
		return(SymErr);
	/* check signature */ 
	if (strcmp(pSymbolTable->signature,SYMSIG) != 0)
		return(SymErr);
	/* traverse linked list to find symbol string */
	for (i = 0; i <= MAX_SYMBOL_INDEX; ++i)
	{
		for (pCurrSymbol = pSymbolTable->SymbolList[i]; pCurrSymbol != NULL; pCurrSymbol = pCurrSymbol->pNext)   
		{
			if (pFunction(uValue, pCurrSymbol->pDataBlock) == TRUE)  /* we did a compare and found a symbol */
			{  
		/* copy data from symbol.pDataBlock to *pDataBlock */
				memcpy(pDataBlock, pCurrSymbol->pDataBlock, pSymbolTable->uDataSize);
				if (pCurrSymbol->szSymbolString != NULL)
					strcpy(szSymbolString, pCurrSymbol->szSymbolString);  /* copy the string */
				*puSymbolValue = pCurrSymbol->uSymbolValue;
	    		return(SymNoErr);	/* found the symbol */ 
			}
		} 
	}
	return(SymErr);  /* didn't find it */
}

/* --------------------------------------------------------------------- */
int16 AddSymbol (PSYMBOL_TABLE CONST pSymbolTable, char * CONST szSymbolString, uint16 uSymbolValue, void * CONST pDataBlock)
{                                                                                      
PSYMBOL pCurrSymbol = NULL;  /* current Symbol in linked list */
PSYMBOL pLastSymbol = NULL;  /* Last symbol in linked list. Add new symbol here */
PSYMBOL pNextSymbol = NULL;  /* Next symbol in linked list. Add new symbol before here */
int16 sCmp;
uint16 usIndex;
uint16 i;
char UpperString[MAXBUFFERLEN];

	if (pSymbolTable == NULL)
		return(SymErr);
	/* check signature */ 
	if (strcmp(pSymbolTable->signature,SYMSIG) != 0)
		return(SymErr);
	if (pSymbolTable->usSymbolType == 0) /* string type */
	{
		for (i = 0; i < MAXBUFFERLEN; ++i)
		{
			UpperString[i]=(char)toupper(szSymbolString[i]); 
			if (szSymbolString[i] == '\0')
				break;
		}
		usIndex = SymbolGetIndex(UpperString[0]);
		/* traverse linked list to check if symbol there, and find end of chain */
		for (pCurrSymbol = pSymbolTable->SymbolList[usIndex]; pCurrSymbol != NULL; pCurrSymbol = pCurrSymbol->pNext)   
		{
			if ((sCmp = (int16)strcmp(pCurrSymbol->szSymbolString, UpperString)) == 0)  
	    		return(SymErr);	/* found the symbol, can't add it */ 
			else if (sCmp < 0)
				break;
			pLastSymbol = pCurrSymbol;
		}
		pNextSymbol = pCurrSymbol;  /* will be null if fell off the end, or a valid thing, if we broke out */
		/* allocate a new Symbol, symbol string, and datablock */   
		if ((pCurrSymbol = (PSYMBOL) Mem_Alloc ((size_t)sizeof (* pCurrSymbol))) == NULL)
			return(SymMemErr);
		/* set string value */
		pCurrSymbol->szSymbolString = (char *) Mem_Alloc((size_t) strlen(UpperString) + 1);
		if (pCurrSymbol->szSymbolString == NULL)
		{
			Mem_Free(pCurrSymbol);
			return(SymMemErr);    
		}
		strcpy(pCurrSymbol->szSymbolString,UpperString);
	}
	else
	{
		usIndex = uSymbolValue % (MAX_SYMBOL_INDEX + 1);  /* which of the buckets is it in? */
		for (pCurrSymbol = pSymbolTable->SymbolList[usIndex]; pCurrSymbol != NULL; pCurrSymbol = pCurrSymbol->pNext)   
		{
			if (uSymbolValue == pCurrSymbol->uSymbolValue)
				return (SymErr);
			else 
				pLastSymbol = pCurrSymbol;
		}
		pNextSymbol = pCurrSymbol;  /* will be null if fell off the end, or a valid thing, if we broke out */
		/* allocate a new Symbol, symbol string, and datablock */   
		if ((pCurrSymbol = (PSYMBOL) Mem_Alloc ((size_t)sizeof (* pCurrSymbol))) == NULL)
			return(SymMemErr);
		pCurrSymbol->uSymbolValue = uSymbolValue;
	}	

	/* set datablock value */
	pCurrSymbol->pDataBlock = Mem_Alloc((size_t) pSymbolTable->uDataSize);
	if (pCurrSymbol->pDataBlock == NULL)
	{
		Mem_Free(pCurrSymbol->szSymbolString);	/* may be null but that's ok */
		Mem_Free(pCurrSymbol);
		return(SymMemErr);
	}
	/* copy data from *pDataBlock to symbol.pDataBlock */
	memcpy(pCurrSymbol->pDataBlock, pDataBlock, pSymbolTable->uDataSize);
	/* set next value */
	pCurrSymbol->pNext = pNextSymbol;
	if (pSymbolTable->SymbolList[usIndex] == NULL)
	    pSymbolTable->SymbolList[usIndex] = pCurrSymbol;
	else if ((pLastSymbol == NULL))	/* add before the first one */
		pSymbolTable->SymbolList[usIndex] = pCurrSymbol; 
	else
		pLastSymbol->pNext = pCurrSymbol;	/* hook it up */
    return(SymNoErr);
}
/* --------------------------------------------------------------------- */
int16 DeleteSymbol (PSYMBOL_TABLE CONST pSymbolTable, char * CONST szSymbolString, uint16 uSymbolValue)
{                                                                                      
PSYMBOL pCurrSymbol = NULL;  /* current Symbol in linked list */
PSYMBOL pLastSymbol = NULL;  /* Last symbol in linked list. Add new symbol here */
PSYMBOL pNextSymbol = NULL;  /* Next symbol in linked list. Add new symbol before here */
int16 sCmp;
uint16 usIndex;
uint16 i;
char UpperString[MAXBUFFERLEN];

	if (pSymbolTable == NULL)
		return(SymErr);
	/* check signature */ 
	if (strcmp(pSymbolTable->signature,SYMSIG) != 0)
		return(SymErr);
	if (pSymbolTable->usSymbolType == 0) /* string type */
	{
		for (i = 0; i < MAXBUFFERLEN; ++i)
		{
			UpperString[i]=(char)toupper(szSymbolString[i]); 
			if (szSymbolString[i] == '\0')
				break;
		}
		/* traverse linked list to check if symbol there */
		usIndex = SymbolGetIndex(UpperString[0]);
		/* traverse linked list to check if symbol there, and find end of chain */
		for (pCurrSymbol = pSymbolTable->SymbolList[usIndex]; pCurrSymbol != NULL; pCurrSymbol = pCurrSymbol->pNext)   
		{
			if ((sCmp = (int16)strcmp(pCurrSymbol->szSymbolString, UpperString)) == 0)   /* found symbol. Delete it */
			{
				if (pLastSymbol == NULL)	/* remove it from the beginning */
					pSymbolTable->SymbolList[usIndex] = pCurrSymbol->pNext; 
				else
					pLastSymbol->pNext = pCurrSymbol->pNext;	/* hook it up */
				Mem_Free(pCurrSymbol->pDataBlock);
				Mem_Free(pCurrSymbol->szSymbolString);
				Mem_Free(pCurrSymbol);
				break;
			}
			else if (sCmp < 0)
				break;
			pLastSymbol = pCurrSymbol;
		}
	}
	else
	{
		usIndex = uSymbolValue % (MAX_SYMBOL_INDEX + 1);  /* which of the buckets is it in? */
		for (pCurrSymbol = pSymbolTable->SymbolList[usIndex]; pCurrSymbol != NULL; pCurrSymbol = pCurrSymbol->pNext)   
		{
			if (uSymbolValue == pCurrSymbol->uSymbolValue)
			{
				if (pLastSymbol == NULL)	/* remove it from the beginning */
					pSymbolTable->SymbolList[usIndex] = pCurrSymbol->pNext; 
				else
					pLastSymbol->pNext = pCurrSymbol->pNext;	/* hook it up */
				Mem_Free(pCurrSymbol->pDataBlock);
				Mem_Free(pCurrSymbol->szSymbolString);
				Mem_Free(pCurrSymbol);
				break;
			}
			pLastSymbol = pCurrSymbol;
		}
	}
	return(SymNoErr);
}

/* --------------------------------------------------------------------- */
int16 ModifySymbol (PSYMBOL_TABLE CONST pSymbolTable, char * CONST szSymbolString, uint16 uSymbolValue, void * CONST pDataBlock)
{ 
PSYMBOL pCurrSymbol = NULL;  /* current Symbol in linked list */
uint16 usIndex;
uint16 i;
int16 sCmp;
char UpperString[MAXBUFFERLEN];

	if (pSymbolTable == NULL)
		return(SymErr);
	/* check signature */ 
	if (strcmp(pSymbolTable->signature,SYMSIG) != 0)
		return(SymErr);
	if (pSymbolTable->usSymbolType == 0) /* string type */
	{
		if (szSymbolString == NULL)
			return(SymErr);
		for (i = 0; i < MAXBUFFERLEN; ++i)
		{
			UpperString[i]=(char)toupper(szSymbolString[i]); 
			if (szSymbolString[i] == '\0')
				break;
		}
		usIndex = SymbolGetIndex(UpperString[0]);
		/* traverse linked list to check if symbol there, and find end of chain */
		for (pCurrSymbol = pSymbolTable->SymbolList[usIndex]; pCurrSymbol != NULL; pCurrSymbol = pCurrSymbol->pNext)   
		{
			if ((sCmp = (int16)strcmp(pCurrSymbol->szSymbolString, UpperString)) == 0)  
			{  
		/* copy data from *pDataBlock to symbol->pDataBlock */
				memcpy(pCurrSymbol->pDataBlock, pDataBlock, pSymbolTable->uDataSize);
	    		return(SymNoErr);	/* found the symbol */ 
			}
			else if (sCmp < 0)	 /* can't find it */
				return(SymErr);
		} 
	}
	else
	{
		usIndex = uSymbolValue % (MAX_SYMBOL_INDEX + 1);  /* which of the buckets is it in? */
		/* traverse linked list to check if symbol there, and find end of chain */
		for (pCurrSymbol = pSymbolTable->SymbolList[usIndex]; pCurrSymbol != NULL; pCurrSymbol = pCurrSymbol->pNext)   
		{
			if (uSymbolValue == pCurrSymbol->uSymbolValue)
			{  
		/* copy data from *pDataBlock to symbol->pDataBlock */
				memcpy(pCurrSymbol->pDataBlock, pDataBlock, pSymbolTable->uDataSize);
	    		return(SymNoErr);	/* found the symbol */ 
			}
		} 
	}
	return(SymErr);  /* didn't find it */
}

/* --------------------------------------------------------------------- */
#if 0 
typedef struct symbol_data *PSYMBOL_DATA;

struct symbol_data {        /* the common data of the 2 symbol table data structures */
	uint16 uSymbolType;
};  

void PrintSymbolTable(PSYMBOL_TABLE CONST pSymbolTable)
{
PSYMBOL pCurrSymbol = NULL;  /* current Symbol in linked list */
char szBuffer[MAXBUFFERLEN];
uint16 i;

	if (pSymbolTable == NULL)
		return;
	/* check signature */ 
	if (strcmp(pSymbolTable->signature,SYMSIG) != 0)
		return;
	/* traverse linked list to find symbol string */
	for (i = 0; i <= MAX_SYMBOL_INDEX; ++i)
	{
		for (pCurrSymbol = pSymbolTable->SymbolList[i]; pCurrSymbol != NULL; pCurrSymbol = pCurrSymbol->pNext)   
		{
			sprintf(szBuffer,"Symbol: \"%s\", Type=%d\n", pCurrSymbol->szSymbolString, ((PSYMBOL_DATA)(pCurrSymbol->pDataBlock))->uSymbolType);
			DebugMsg(szBuffer,"",0);
		}
	}

}
#endif
/* --------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttfmerge.h ===
/*
  * TTFmerge.h: Interface file for TTFmerge.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */
  
#ifndef TTFMERGE_DOT_H_DEFINED
#define TTFMERGE_DOT_H_DEFINED   

#ifndef CONST
#define CONST const
#endif     

#ifndef CFP_ALLOCPROC_DEFINED
#define CFP_ALLOCPROC_DEFINED
typedef void *(*CFP_ALLOCPROC)(size_t);
typedef void *(*CFP_REALLOCPROC)(void *, size_t);
typedef void (*CFP_FREEPROC)(void *);
#endif

/* return codes defined in ttferror.h */
short MergeDeltaTTF(CONST unsigned char * puchMergeFontBuffer,
					CONST unsigned long ulMergeFontBufferSize,
					CONST unsigned char * puchDeltaFontBuffer,
					CONST unsigned long ulDeltaFontBufferSize,
					unsigned char **ppuchDestBuffer, /* output */
					unsigned long *pulDestBufferSize, /* output */
					unsigned long *pulBytesWritten, /* output */
					CONST unsigned short usMode,
					CFP_REALLOCPROC lpfnReAllocate,	  /* call back function to allocate or reallocate output and intermediate buffers */
					void *lpvReserved);

/* for Formats */
#define TTFDELTA_SUBSET 0	  /* Straight Subset Font */
#define TTFDELTA_SUBSET1 1	  /* Subset font with full TTO and Kern tables. For later merge */
#define TTFDELTA_DELTA 2	  /* Delta font */
#define TTFDELTA_MERGE 3

/* for MergeDelta Modes */
#define TTFMERGE_SUBSET 0	  /* Straight Subset Font */
#define TTFMERGE_SUBSET1 1	  /* Expand a format 1 font */
#define TTFMERGE_DELTA 2	  /* Merge a format 2 with a format 3 font */

#endif /* TTFMERGE_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttfdelta.h ===
/*
  * TTFDelta.h: Interface file for TTFDelta.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */
  
#ifndef TTFDELTA_DOT_H_DEFINED
#define TTFDELTA_DOT_H_DEFINED        

#ifndef CONST
#define CONST const
#endif     

#ifndef CFP_ALLOCPROC_DEFINED
#define CFP_ALLOCPROC_DEFINED
typedef void *(*CFP_ALLOCPROC)(size_t);
typedef void *(*CFP_REALLOCPROC)(void *, size_t);
typedef void (*CFP_FREEPROC)(void *);
#endif

short TTCOffsetTableOffset(CONST unsigned char * puchSrcBuffer,
			CONST unsigned long ulSrcBufferSize,
			CONST unsigned short usTTCIndex,
			unsigned long *pulOffsetTableOffset);


/* return codes defined in ttferror.h */
short SubsetTTF(CONST unsigned char * puchSrcBuffer,
      	unsigned char * puchDestBuffer,
		CONST unsigned long ulBufferSize,
		unsigned long * pulBytesWritten,
		CONST unsigned short usLanguage,
		CONST unsigned short usPlatform,
		CONST unsigned short usEncoding,
		CONST unsigned short *pusKeepCharCodeList,
		CONST unsigned short usListCount,
		CONST unsigned short usTTCIndex);

/* return codes defined in ttferror.h */
short CreateDeltaTTF(CONST unsigned char * puchSrcBuffer,
			CONST unsigned long ulSrcBufferSize,
	      	unsigned char ** ppuchDestBuffer,
			unsigned long * pulDestBufferSize,
			unsigned long * pulBytesWritten,
			CONST unsigned short usFormat,
			CONST unsigned short usLanguage,
			CONST unsigned short usPlatform,
			CONST unsigned short usEncoding,
			CONST unsigned short usListType,
			CONST unsigned short *pusKeepCodeList,
			CONST unsigned short usKeepListCount,
			CFP_REALLOCPROC lpfnReAllocate,
			CFP_FREEPROC lpfnFree,
			unsigned long ulOffsetTableOffset,  
			void * lpvReserved);


/* for CreateDelta Formats */
#define TTFDELTA_SUBSET 0	  /* Straight Subset Font */
#define TTFDELTA_SUBSET1 1	  /* Subset font with full TTO and Kern tables. For later merge */
#define TTFDELTA_DELTA 2	  /* Delta font */
#define TTFDELTA_MERGE 3	  /* already merged font - for checking input */

/* for usListType argument */
#define TTFDELTA_CHARLIST 0
#define TTFDELTA_GLYPHLIST 1

/* for usPlatform ID values */
#define TTFSUB_UNICODE_PLATFORMID 0
#define TTFSUB_APPLE_PLATFORMID   1
#define TTFSUB_ISO_PLATFORMID     2
#define TTFSUB_MS_PLATFORMID      3
#define TTFSUB_NUM_PLATFORMS      4

/* for usEncoding values */
#define TTFSUB_STD_MAC_CHAR_SET  0	/* goes with TTFSUB_APPLE_PLATFORMID */
#define TTFSUB_SYMBOL_CHAR_SET  0	/* goes with TTFSUB_MS_PLATFORMID */
#define TTFSUB_UNICODE_CHAR_SET  1	/* goes with TTFSUB_MS_PLATFORMID */
#define TTFSUB_DONT_CARE         0xFFFF

/* for usLanguage values */
#define TTFSUB_LANG_KEEP_ALL 0


#endif /* TTFDELTA_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\symbol.h ===
/*
  * Symbol.h: Interface file for Symbol.c -- Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  * This file must be included in order to use the access functions for the Symbol handler.
  *
  */
  
#ifndef SYMBOL_DOT_H_DEFINED
#define SYMBOL_DOT_H_DEFINED

#define SymNoErr 0
#define SymErr -1  
#define SymMemErr -2

#define SYMBOLSTRINGTYPE 0
#define SYMBOLVALUETYPE 1


struct symbol_table; /* opaque data type  -- not exposed to client. Defined in Symbol.c */
typedef struct symbol_table *PSYMBOL_TABLE;

PSYMBOL_TABLE CreateSymbolTable(uint16 CONST, uint16 CONST);
/* CreateSymbolTable(uDataSize, usSymbolType)
  *
  * usDataSize -- INPUT
  *  size of data to be stored with each symbol
  * 
  * usSymbolType -- INPUT
  *   Data will be string or value type
  *
  * RETURN VALUE
  *   a valid pointer to a Symbol Table on success
  *   NULL indicates an out-of-memory condition
  */

void DestroySymbolTable(PSYMBOL_TABLE);
/* DestroySymbolTable(pSymbolTable)
  *
  * pSymbolTable -- INPUT
  *   pointer to a SymbolTable returned by CreateSymbolTable
  *
  */

int16 GetSymbol (PSYMBOL_TABLE CONST , char * CONST, uint16, void *);
/* GetSymbol (pSymbolTable, szSymbolString, uSymbolValue, pDataBlock)
  *
  * pSymbolTable -- INPUT
  *   pointer to a SymbolTable returned by CreateSymbolTable
  *
  * szSymbolString -- INPUT
  *   String containing the symbol whose datablock is requested
  *
  * uSymbolValue --  INPUT
  *   Symbol value whose datablock is requested. - used if usSymbolType == 1
  *
  * pDataBlock -- OUTPUT
  *   the block of data associated with a Symbol. Data copied from Symbol table to pDataBlock.
  *
  * RETURN VALUE
  *    SymNoErr if  symbol found
  *    SymErr if szSymbolString or pSymbolTable not valid, or szSymbolString not found   
  */

typedef BOOL (*pSymbolFunction) (uint16, void *);

int16 GetSymbolByFunction (PSYMBOL_TABLE CONST pSymbolTable, char * szSymbolString, uint16 *puSymbolValue, void *pDataBlock, uint16 uValue, pSymbolFunction pFunction);
/* GetSymbolByFunction (PSYMBOL_TABLE CONST pSymbolTable, char * szSymbolString, void *pDataBlock, uint16 uValue, pSymbolFunction pFunction)  
  *
  * pSymbolTable -- INPUT
  *   pointer to a SymbolTable returned by CreateSymbolTable
  *
  * szSymbolString -- OUTPUT
  *   String containing the symbol whose datablock is requested
  *
  * puSymbolValue --  INPUT
  *   Symbol value whose datablock is returned. - returned if usSymbolType == 1
  *
  * pDataBlock -- OUTPUT
  *   the block of data associated with a Symbol. Data copied from Symbol table to pDataBlock.
  *
  * uValue -- INPUT 
  *	  value handed to the function to compare with data in the Symbol table 
  *
  * pFunction -- INPUT
  *    function to call with uValue and the pDataBlock of the current symbol. Returns TRUE if a match if found
  *
  * RETURN VALUE
  *    SymNoErr if  symbol found
  *    SymErr if szSymbolString or pSymbolTable not valid, or szSymbolString not found   
  */



int16 AddSymbol (PSYMBOL_TABLE CONST, char * CONST, uint16, void * CONST);
/* AddSymbol (pSymbolTable, szSymbolString, uSymbolValue, pDataBlock)
  *
  * pSymbolTable -- INPUT
  *   pointer to a SymbolTable returned by CreateSymbolTable
  *
  * szSymbolString -- INPUT
  *   String containing the symbol to be added
  *
  * uSymbolValue --  INPUT
  *   Symbol value whose datablock is added. - used if usSymbolType == 1
  *
  * pDataBlock -- INPUT
  *   the block of data associated with a Symbol. Data copied from pDataBlock to Symbol table.
  *
  * RETURN VALUE
  *    SymNoErr if symbol added successfully
  *    SymErr if szSymbolString, pDataBlock, or pSymbolTable not valid, or if szSymbolString 
  *    already in table
  *    SymMemErr if memory error
  */

int16 DeleteSymbol (PSYMBOL_TABLE CONST pSymbolTable, char * CONST szSymbolString, uint16 uSymbolValue);


int16 ModifySymbol (PSYMBOL_TABLE CONST, char * CONST, uint16, void * CONST);
/* ModifySymbol (pSymbolTable, szSymbolString, uSymbolValue, pDataBlock)
  *
  * pSymbolTable -- INPUT
  *   pointer to a SymbolTable returned by CreateSymbolTable
  *
  * szSymbolString -- INPUT
  *   String containing the symbol whose data block is to be modified.
  *
  * uSymbolValue --  INPUT
  *   Symbol value whose datablock is added. - used if usSymbolType == 1
  *
  * pDataBlock -- INPUT
  *   the block of data associated with a Symbol to be modified .
  *
  * RETURN VALUE
  *    SymNoErr if symbol modified successfully
  *    SymErr if szSymbolString, pDataBlock, or pSymbolTable not valid, or if szSymbolString not found
  */

#ifdef _DEBUG
void PrintSymbolTable(PSYMBOL_TABLE CONST);
#endif

#endif /* SYMBOL_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttftable.c ===
/***************************************************************************
 * module: TTFTABLE.C
 *
 * author: Louise Pathe
 * date:   Nov 1995
 * Copyright 1990-1998. Microsoft Corporation.
 *
 * aRoutines to read true type tables and table information from 
 * a true type file buffer
 *
 **************************************************************************/


/* Inclusions ----------------------------------------------------------- */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "typedefs.h"
#include "ttff.h"                       /* true type font file def's */
#include "ttfacc.h"
#include "ttftable.h"
#include "ttftabl1.h"
#include "ttfcntrl.h"
#include "ttmem.h"
#include "util.h"
#include "ttfdelta.h" /* for Dont care info */
#include "ttferror.h"
#include "ttfdcnfg.h"

/* ---------------------------------------------------------------------- */
PRIVATE int CRTCB AscendingTagCompare( CONST void *arg1, CONST void *arg2 )
{
	if (((DIRECTORY *)(arg1))->tag == ((DIRECTORY *)(arg2))->tag) /* they're the same */
		return 0;
	if (((DIRECTORY *)(arg1))->tag < ((DIRECTORY *)(arg2))->tag)
		return -1;
	return 1;
}
/* ---------------------------------------------------------------------- */
PRIVATE int CRTCB AscendingOffsetCompare( CONST void *arg1, CONST void *arg2 )
{
	if (((DIRECTORY *)(arg1))->offset == ((DIRECTORY *)(arg2))->offset) /* they're the same */
		return 0;
	if (((DIRECTORY *)(arg1))->offset < ((DIRECTORY *)(arg2))->offset)
		return -1;
	return 1;
}

/* ---------------------------------------------------------------------- */
/* this routine sorts an array of directory entries by tag value using
  a qsort */
/* ---------------------------------------------------------------------- */
void SortByTag( DIRECTORY * aDirectory,
				uint16      usnDirs )
{
	if (aDirectory == NULL || usnDirs == 0)
		return;
	qsort (aDirectory, usnDirs, sizeof(*aDirectory),AscendingTagCompare); 
}
/* ---------------------------------------------------------------------- */
/* this routine sorts an array of directory entries by offset value using
  a qsort */
/* ---------------------------------------------------------------------- */
void SortByOffset( DIRECTORY * aDirectory,
					uint16      usnDirs )
{
	if (aDirectory == NULL || usnDirs == 0)
		return;
	qsort (aDirectory, usnDirs, sizeof(*aDirectory),AscendingOffsetCompare); 
}



/* ---------------------------------------------------------------------- */
/* this routine marks a font file table for deletion.  To do so,
it sets the tag to something unrecognizable so it will be
filtered out by the compress tables operation at the end
of program execution. */
/* ---------------------------------------------------------------------- */
void MarkTableForDeletion( TTFACC_FILEBUFFERINFO * pOutputBufferInfo, char *  szDirTag )
                   
{
DIRECTORY Directory;
uint32 ulOffset;
uint16 usBytesMoved;

	/* read existing directory entry */
  	ulOffset = GetTTDirectory( pOutputBufferInfo, szDirTag, &Directory );
	if ( ulOffset == DIRECTORY_ERROR )
		return;
	
	/* set bad directory tag using an arbitrary, nonsensical value */

	Directory.tag = DELETETABLETAG;

	/* write new directory entry */
	WriteGeneric( pOutputBufferInfo, (uint8 *) &Directory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesMoved );
} /* MarkTableForDeletion() */

/* ---------------------------------------------------------------------- */
uint32 FindCmapSubtable( TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
						uint16   usDesiredPlatform,
                        uint16   usDesiredEncodingID, 
						uint16 *pusFoundEncoding )
{
int16 i;
CMAP_HEADER CmapHeader;
CMAP_TABLELOC CmapTableLoc;
BOOL bFound;
int16 nCmapTables;
uint16 usBytesRead;
uint32 ulOffset;
uint32 ulCmapOffset;
   
   /* Read header of the 'cmap' table */

	if (!(ulCmapOffset = TTTableOffset( pOutputBufferInfo, CMAP_TAG )))
		return (0L);
	if (ReadGeneric( pOutputBufferInfo, (uint8 *) &CmapHeader, SIZEOF_CMAP_HEADER, CMAP_HEADER_CONTROL, ulCmapOffset, &usBytesRead) != NO_ERROR)
		return (0L);

   /* read directory entries to find the desired encoding table.
      The directory entries for subtables give the offset from
      the beginning of the 'cmap' table to where the desired table 
      begins. */

	i = 0;
	bFound = FALSE;
	ulOffset = ulCmapOffset + usBytesRead;
	nCmapTables = CmapHeader.numTables;
	for (i = 0; i < nCmapTables && ! bFound ; ++i, ulOffset += usBytesRead)
	{
		if (ReadGeneric( pOutputBufferInfo, (uint8 *) &CmapTableLoc, SIZEOF_CMAP_TABLELOC, CMAP_TABLELOC_CONTROL, ulOffset, &usBytesRead) != NO_ERROR)
			return (0L);
		if ( CmapTableLoc.platformID == usDesiredPlatform &&
			( CmapTableLoc.encodingID == usDesiredEncodingID ||
			usDesiredEncodingID == TTFSUB_DONT_CARE ) )
		{
			bFound = TRUE;
			*pusFoundEncoding = CmapTableLoc.encodingID;
		}
	} 

	if ( bFound == FALSE )
		return( 0L );

	/* return address of cmap subtable relative to start of file */

	return( ulCmapOffset + CmapTableLoc.offset );
   
} /* FindCmapSubtable() */

/* ---------------------------------------------------------------------- */
PRIVATE uint16 GuessNumCmapGlyphIds( uint16 usnSegments,
                             FORMAT4_SEGMENTS *  Format4Segments )
{
/* this routine guesses the approximate number of entries in the
	GlyphId array of the format 4 cmap table.  This guessing is
	necessary because there is nothing in the format 4 table that
	explicitly indicates the number of GlyphId entries, and it is
	not valid to assume any particular number, such as one based on
	the number of glyphs or the size of the format 4 cmap table. */

int32          sIdIdx;
uint16         usCharCode;
uint16         i;
uint16         usMaxGlyphIdIdx;

/* zip through cmap entries, checking each entry to see if it indexes
	into the GlyphId array.  If it does, determine the array index,
	and keep track of the maximum array index used.  The maximum used
	then becomes the guess as to the number of GlyphIds. */

	usMaxGlyphIdIdx = 0;
	for ( i = 0; i < usnSegments; i++ )
	{
		if ( Format4Segments[i].idRangeOffset == 0 )
			continue;

		for ( usCharCode = Format4Segments[ i ].startCount;
			usCharCode <= Format4Segments[ i ].endCount && Format4Segments[ i ].endCount != INVALID_CHAR_CODE;
			usCharCode++ )
		{
			sIdIdx  = (uint16) i - (uint16) usnSegments;
			sIdIdx += (uint16) (Format4Segments[i].idRangeOffset / 2) + usCharCode - Format4Segments[i].startCount;
			usMaxGlyphIdIdx = max( usMaxGlyphIdIdx, (uint16) (sIdIdx+1) );
		}
	}
	return( usMaxGlyphIdIdx );
}
 /* ---------------------------------------------------------------------- */
/* special case, need to read long or short repeatedly into long buffer */
/* buffer must have been allocated large enough for the number of glyphs */
uint32 GetLoca( TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint32 *pulLoca, uint16 usAllocedCount)
{
uint32 ulOffset = 0;
uint16 usOffset;
HEAD Head;
uint16 usIdxToLocFmt;
uint16 usGlyphCount;
uint16 i;
uint32 ulBytesRead;

	if ( ! GetHead( pInputBufferInfo, &Head ))
		return( 0L );
	usIdxToLocFmt = Head.indexToLocFormat;

	usGlyphCount = GetNumGlyphs(pInputBufferInfo );
	if (usAllocedCount < usGlyphCount + 1) /* not enough room to read this */
		return 0L;

	if (!(ulOffset = TTTableOffset( pInputBufferInfo, LOCA_TAG )))
		return 0L;

	if ( usIdxToLocFmt == SHORT_OFFSETS )
	{
		for (i = 0; i <= usGlyphCount; ++i)
		{
			if (ReadWord( pInputBufferInfo, &usOffset, ulOffset + (i*sizeof(uint16))) != NO_ERROR)
				return 0L;
			pulLoca[i] = (int32) usOffset * 2L;
		}
	}
	else
	{
		if (ReadGenericRepeat(pInputBufferInfo, (uint8 *)pulLoca, LONG_CONTROL, ulOffset, &ulBytesRead, (uint16) (usGlyphCount + 1), sizeof(uint32)) != NO_ERROR) 
			return 0L;
	}
	return( ulOffset );
}
PRIVATE int CRTCB CompareSegments(const void *elem1, const void *elem2)
{

	if ((((FORMAT4_SEGMENTS *)(elem1))->endCount <= ((FORMAT4_SEGMENTS *)(elem2))->endCount) /* it is within this range */
		&& (((FORMAT4_SEGMENTS *)(elem1))->startCount >= ((FORMAT4_SEGMENTS *)(elem2))->startCount))
		return 0;
	if (((FORMAT4_SEGMENTS *)(elem1))->startCount < ((FORMAT4_SEGMENTS *)(elem2))->startCount)
		return -1;
	return 1;

}

/* ---------------------------------------------------------------------- */
uint16 GetGlyphIdx( uint16 usCharCode,
                    FORMAT4_SEGMENTS * Format4Segments,
                    uint16 usnSegments,
                    GLYPH_ID * GlyphId )
{
uint16 usGlyphIdx;
int32 sIDIdx;
FORMAT4_SEGMENTS *pFormat4Segment;
FORMAT4_SEGMENTS KeySegment;

	KeySegment.startCount = usCharCode;
	KeySegment.endCount = usCharCode;
	/* find segment containing the character code */
	pFormat4Segment = bsearch(&KeySegment, Format4Segments, usnSegments, sizeof(*Format4Segments), CompareSegments);

	if ( pFormat4Segment == NULL )
		return( INVALID_GLYPH_INDEX );

	/* calculate the glyph index */

	if ( pFormat4Segment->idRangeOffset == 0 )
		usGlyphIdx = usCharCode + pFormat4Segment->idDelta;
	else
	{
		sIDIdx = (int32)(pFormat4Segment - (Format4Segments + usnSegments));
		/* sIDIdx = (uint16) i - (uint16) usnSegments; */
		sIDIdx += (int32) (pFormat4Segment->idRangeOffset / 2) + usCharCode - pFormat4Segment->startCount;
		usGlyphIdx = GlyphId[ sIDIdx ];
		if (usGlyphIdx)
			/* Only add in idDelta if we've really got a glyph! */
			usGlyphIdx += pFormat4Segment->idDelta;
	}

	return( usGlyphIdx );
} /* GetGlyphIdx */

/* ---------------------------------------------------------------------- */
void FreeCmapFormat4Ids( GLYPH_ID *GlyphId )
{
	Mem_Free( GlyphId );
}
/* ---------------------------------------------------------------------- */
void FreeCmapFormat4Segs( FORMAT4_SEGMENTS *Format4Segments)
{
	Mem_Free( Format4Segments );
}
/* ---------------------------------------------------------------------- */
void FreeCmapFormat4( FORMAT4_SEGMENTS *Format4Segments,
                 GLYPH_ID *GlyphId )
{
	FreeCmapFormat4Segs( Format4Segments );
	FreeCmapFormat4Ids( GlyphId );
}

/* ---------------------------------------------------------------------- */
int16 ReadAllocCmapFormat4Ids( TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint16 usSegCount,
                         FORMAT4_SEGMENTS * Format4Segments,
                         GLYPH_ID ** ppGlyphId,
                         uint16 * pusnIds,
                         uint32 ulOffset,
                         uint32 *pulBytesRead )
{
uint16 i;
uint16 usBlockSize;
int16 errCode;

	/* calc number of glyph indexes while making sure the start and end
	count numbers used to calc the number of indexes is reasonable */

	*ppGlyphId = NULL;
	for ( i=0; i < usSegCount; i++ )
	{                    
		/* check for reasonable start and end counts */
		if ( Format4Segments[i].endCount < Format4Segments[i].startCount )
			return(ERR_INVALID_CMAP);
	}

	/* set the return value for number of glyph Ids.  As of this writing
		(9/20/90), there was no reliable way to calculate the size of
		the ppGlyphId array, so here we just read a lot of values and assume
		that it will be enough. */

	*pusnIds = GuessNumCmapGlyphIds( usSegCount, Format4Segments );

	/* allocate memory for GlyphID array */

	if ( *pusnIds == 0 )
		return(NO_ERROR);

	usBlockSize = *pusnIds * sizeof( (*ppGlyphId)[0] );
	*ppGlyphId = Mem_Alloc(usBlockSize);
	if ( *ppGlyphId == NULL )
		return(ERR_MEM);

	/* read glyph index array */
	if ((errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *) *ppGlyphId, WORD_CONTROL, ulOffset, pulBytesRead, *pusnIds, sizeof( (*ppGlyphId)[0] ))) != NO_ERROR)
    {
        Mem_Free(*ppGlyphId);
        *ppGlyphId = NULL;
		return (errCode);
    }
	return(NO_ERROR );

} /* ReadAllocCmapFormat4Ids() */


/* ---------------------------------------------------------------------- */
int16 ReadAllocCmapFormat4Segs( TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint16 usSegCount,
                          FORMAT4_SEGMENTS ** Format4Segments, 
                          uint32 ulOffset,
                          uint32 *pulBytesRead)
{
uint16 i;
uint16 usReservedPad;
uint16 usWordSize;
uint32 ulCurrentOffset = ulOffset;
int16 errCode;
uint32 ulBytesRead;

/* allocate memory for variable length part of table */

	*Format4Segments = Mem_Alloc( usSegCount * SIZEOF_FORMAT4_SEGMENTS);
	if ( *Format4Segments == NULL )
		return( ERR_MEM );

	usWordSize = sizeof(uint16);
	for ( i = 0; i < usSegCount; i++ )
		if ((errCode = ReadWord( pInputBufferInfo, &(*Format4Segments)[i].endCount, ulCurrentOffset+(i*usWordSize))) != NO_ERROR)
        {
            Mem_Free( *Format4Segments);
            *Format4Segments = NULL;
			return errCode; 
        }
	ulCurrentOffset += usSegCount * usWordSize;

	if ((errCode = ReadWord( pInputBufferInfo,  &usReservedPad,ulCurrentOffset)) != NO_ERROR)
    {
        Mem_Free( *Format4Segments);
        *Format4Segments = NULL;
		return errCode;
    }
	ulCurrentOffset += usWordSize;

	for ( i = 0; i < usSegCount; i++ )
		if ((errCode = ReadWord( pInputBufferInfo,  &(*Format4Segments)[i].startCount, ulCurrentOffset+(i*usWordSize))) != NO_ERROR)
        {
            Mem_Free( *Format4Segments);
            *Format4Segments = NULL;
			return errCode; 
        }
	ulCurrentOffset += usWordSize * usSegCount;

	for ( i = 0; i < usSegCount; i++ )
		if ((errCode = ReadWord( pInputBufferInfo,  (uint16 *)&(*Format4Segments)[i].idDelta, ulCurrentOffset+(i*usWordSize))) != NO_ERROR)
        {
            Mem_Free( *Format4Segments);
            *Format4Segments = NULL;
			return errCode; 
        }
	ulCurrentOffset += usWordSize * usSegCount;

	for ( i = 0; i < usSegCount; i++ )
		if ((errCode = ReadWord( pInputBufferInfo,  &(*Format4Segments)[i].idRangeOffset, ulCurrentOffset+(i*usWordSize))) != NO_ERROR)
        {
            Mem_Free( *Format4Segments);
            *Format4Segments = NULL;
			return errCode; 
        }
	ulCurrentOffset += usWordSize * usSegCount;

	ulBytesRead = ( ulCurrentOffset - ulOffset); /* this is defined to fit into an unsigned short */

// claudebe 2/25/00, we are shipping FE fonts with cmap subtable format 4 that have a lenght that doesn't fit in a USHORT
// commenting out the test
	*pulBytesRead = ulBytesRead;
//	if (*pulBytesRead != ulBytesRead)	/* overrun the unsigned short */
//		return(ERR_INVALID_CMAP);
	return( NO_ERROR );  

} /* ReadAllocCmapFormat4Segs( ) */

/* ---------------------------------------------------------------------- */
int16 ReadAllocCmapFormat4( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
				      CONST uint16 usPlatform,
					  CONST uint16 usEncoding,
					  uint16 *pusFoundEncoding,
					  CMAP_FORMAT4 * pCmapFormat4,
                      FORMAT4_SEGMENTS **  ppFormat4Segments,
                      GLYPH_ID ** ppGlyphId )
{
uint32 ulOffset;
uint16 usSegCount;
uint16 usnGlyphIds;
uint16 usBytesRead;
uint32 ulBytesRead;
int16 errCode;
CMAP_SUBHEADER CmapSubHeader;

   /* find Format4 part of 'cmap' table */

   	*ppFormat4Segments = NULL;	/* in case of error */
	*ppGlyphId = NULL;
	ulOffset = FindCmapSubtable( pInputBufferInfo, usPlatform, usEncoding, pusFoundEncoding );
   	if ( ulOffset == 0 )          
      	return( ERR_FORMAT );

   /* read fixed length part of the table */
	/* test the waters with this little read */
   	if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) &CmapSubHeader, SIZEOF_CMAP_SUBHEADER, CMAP_SUBHEADER_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR)
		return(errCode);

   	if (CmapSubHeader.format < 8)
   	{
   	   	/* old tables (non surragate) */
   	   	CmapSubHeader.NewLength = CmapSubHeader.OldLength;
   	}

   	if (CmapSubHeader.format != FORMAT4_CMAP_FORMAT)
      	return( ERR_FORMAT );

	/* OK, it really is format 4, read the whole thing */
	if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) pCmapFormat4, SIZEOF_CMAP_FORMAT4, CMAP_FORMAT4_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR)
		return(errCode);

   	usSegCount = pCmapFormat4->segCountX2 / 2;

   /* read variable length part */
   	ulOffset += usBytesRead;

	if ((errCode = ReadAllocCmapFormat4Segs( pInputBufferInfo, usSegCount, ppFormat4Segments, ulOffset, &ulBytesRead )) != NO_ERROR)
		return(errCode);
	if ( ulBytesRead == 0)	/* 0 could mean okey dokey */
      	return( NO_ERROR );                
   
    ulOffset += ulBytesRead;
  	if ((errCode = ReadAllocCmapFormat4Ids( pInputBufferInfo, usSegCount, *ppFormat4Segments, ppGlyphId, &usnGlyphIds, ulOffset, &ulBytesRead )) != NO_ERROR)
	{
		FreeCmapFormat4( *ppFormat4Segments, *ppGlyphId );
		*ppFormat4Segments = NULL;
		*ppGlyphId = NULL;
		return( errCode );
	}

   return( NO_ERROR );

} /* ReadAllocCmapFormat4() */
/* ---------------------------------------------------------------------- */
void FreeCmapFormat6( uint16 *  glyphIndexArray)
{
	Mem_Free( glyphIndexArray );
}

/* ---------------------------------------------------------------------- */
int16 ReadAllocCmapFormat6( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
				      CONST uint16 usPlatform,
					  CONST uint16 usEncoding,
					  uint16 *pusFoundEncoding,
					  CMAP_FORMAT6 * pCmap,
                      uint16 **  glyphIndexArray)
{
uint32 ulOffset;
uint16 usBytesRead;
uint32 ulBytesRead;
int16 errCode;

   /* locate the cmap subtable */
   
	ulOffset = FindCmapSubtable( pInputBufferInfo, usPlatform, usEncoding, pusFoundEncoding  );
	if ( ulOffset == 0 )
		return( ERR_FORMAT );

   /* Read cmap table */

	if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) pCmap, SIZEOF_CMAP_FORMAT6, CMAP_FORMAT6_CONTROL, ulOffset, &usBytesRead)) != NO_ERROR)
		return (errCode);

   	if (pCmap->format != FORMAT6_CMAP_FORMAT)
      	return( ERR_FORMAT );

	*glyphIndexArray = Mem_Alloc( pCmap->entryCount * sizeof( uint16 ));
	if ( *glyphIndexArray == NULL )
		return( ERR_MEM );

	if ((errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *) *glyphIndexArray, WORD_CONTROL, ulOffset + usBytesRead, &ulBytesRead, pCmap->entryCount, sizeof(uint16))) != NO_ERROR)
    {
        Mem_Free(*glyphIndexArray);
        *glyphIndexArray = NULL;
		return(errCode); 
    }
	return( NO_ERROR );
}

/* ---------------------------------------------------------------------- */
int16 ReadCmapFormat0( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
					  CONST uint16 usPlatform,
					  CONST uint16 usEncoding,
					  uint16 *pusFoundEncoding,
					  CMAP_FORMAT0 *pCmap)
{
uint32 ulOffset;
uint16 usBytesRead;
uint32 ulBytesRead;
int16 errCode;

   /* locate the cmap subtable */
   
	ulOffset = FindCmapSubtable( pInputBufferInfo, usPlatform, usEncoding, pusFoundEncoding  );
	if ( ulOffset == 0L )
		return( ERR_FORMAT );

   /* Read cmap table */

	if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) pCmap, SIZEOF_CMAP_FORMAT0, CMAP_FORMAT0_CONTROL, ulOffset, &usBytesRead)) != NO_ERROR)
		return (errCode);

   	if (pCmap->format != FORMAT0_CMAP_FORMAT)
      	return( ERR_FORMAT );

	if ((errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *) &(pCmap->glyphIndexArray), BYTE_CONTROL, ulOffset + usBytesRead, &ulBytesRead, CMAP_FORMAT0_ARRAYCOUNT, sizeof(uint8))) != NO_ERROR)
		return(errCode); 
	return( NO_ERROR );

}


/* ---------------------------------------------------------------------- */
int16 GetGlyphHeader( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
					 uint16 GlyfIdx,
                     uint16 usIdxToLocFmt,
                     uint32 ulLocaOffset,
                     uint32 ulGlyfOffset,
                     GLYF_HEADER * pGlyfHeader,
                     uint32 * pulOffset,
                     uint16 * pusLength )
{
uint16 usOffset;
uint32 ulOffset;
uint32 ulNextOffset;
uint16 usNextOffset;
uint16 usBytesRead;
int16 errCode;

	/* determine location of glyph data */

	if ( usIdxToLocFmt == SHORT_OFFSETS )
	{
		ulLocaOffset += GlyfIdx * sizeof( uint16 );
		if ((errCode = ReadWord( pInputBufferInfo,  &usOffset, ulLocaOffset)) != NO_ERROR)
			return(errCode);
		if ((errCode = ReadWord( pInputBufferInfo,  &usNextOffset, ulLocaOffset + sizeof(uint16) )) != NO_ERROR)
			return(errCode);
		ulOffset = usOffset * 2L;
		ulNextOffset = usNextOffset * 2L;
	}
	else
	{
		ulLocaOffset += GlyfIdx * sizeof( uint32 );
		if ((errCode = ReadLong( pInputBufferInfo,  &ulOffset, ulLocaOffset)) != NO_ERROR)
			return(errCode);
		if ((errCode = ReadLong( pInputBufferInfo,  &ulNextOffset, ulLocaOffset + sizeof(uint32))) != NO_ERROR)
			return(errCode);
	}

	/* read glyph header, unless it's non-existent, in which case
	set GlyphHeader to null and return */

	*pusLength = (uint16) (ulNextOffset - ulOffset);
	if ( *pusLength == 0 )
	{
		memset( pGlyfHeader, 0, SIZEOF_GLYF_HEADER );
		*pulOffset = ulGlyfOffset;
		return NO_ERROR;
	}

	*pulOffset = ulGlyfOffset + ulOffset;
	return ReadGeneric( pInputBufferInfo,  (uint8 *) pGlyfHeader, SIZEOF_GLYF_HEADER, GLYF_HEADER_CONTROL, ulGlyfOffset + ulOffset, &usBytesRead );

} /* GetGlyphHeader() */

/* ---------------------------------------------------------------------- */
/* Recursive!! */
/* Bug Trackers: It is possible that this function could run out of stack */
/* if the font defines a VERY deep component tree. */
/* ---------------------------------------------------------------------- */
int16 GetComponentGlyphList( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
							uint16 usCompositeGlyphIdx,
                            uint16 * pusnGlyphs,
                            uint16 * ausGlyphIdxs,
 							uint16 cMaxGlyphs, /* number of elements allocated in ausGlyphIdx array */
                            uint16 *pusnComponentDepth,
                            uint16 usLevelValue, /* level of recursion we are at */
                            uint16 usIdxToLocFmt,
                            uint32 ulLocaOffset,
							uint32 ulGlyfOffset)
{
uint16 usFlags;
uint16 usComponentGlyphIdx;
uint32 ulCrntOffset;
GLYF_HEADER GlyfHeader;
uint32 ulOffset;
uint16 usLength;
uint16 usnGlyphs;
int16 errCode;

/* check if this is a composite glyph */

	*pusnGlyphs = 0;  /* number of glyphs at this level and below */
	if ((errCode = GetGlyphHeader( pInputBufferInfo, usCompositeGlyphIdx, usIdxToLocFmt, ulLocaOffset, ulGlyfOffset, &GlyfHeader, &ulOffset, &usLength )) != NO_ERROR)
		return(errCode);
	if (*pusnComponentDepth < usLevelValue)
		*pusnComponentDepth = usLevelValue;  /* keep track of this */

	if ( GlyfHeader.numberOfContours >= 0 )
		return NO_ERROR;	   /* this is not a composite, just a glyph */

	/* move to beginning of composite glyph description */

	ulCrntOffset = ulOffset + GetGenericSize( GLYF_HEADER_CONTROL );
	/* read composite glyph components, adding each component's
	reference */

	do
	{
		if (*pusnGlyphs >= cMaxGlyphs)	 /* cannot do. the maxp table lied to us about maxdepth or maxelements! */
			return ERR_INVALID_MAXP;
	 /* read flag word and glyph component */

		if ((errCode = ReadWord( pInputBufferInfo,   &usFlags, ulCrntOffset)) != NO_ERROR)
			return(errCode);

		ulCrntOffset += sizeof( uint16 );
		if ((errCode = ReadWord( pInputBufferInfo,  &usComponentGlyphIdx, ulCrntOffset)) != NO_ERROR)
			return(errCode);

		ulCrntOffset += sizeof( uint16 );

		ausGlyphIdxs[ *pusnGlyphs ] = usComponentGlyphIdx;
		(*pusnGlyphs)++;

		/* navigate through rest of entry to get to next glyph component */

		if ( usFlags & ARG_1_AND_2_ARE_WORDS )
			ulCrntOffset += 2 * sizeof( uint16 );
		else
			ulCrntOffset += sizeof( uint16 );

		if ( usFlags & WE_HAVE_A_SCALE )
			ulCrntOffset += sizeof( uint16 );
		else if ( usFlags & WE_HAVE_AN_X_AND_Y_SCALE )
			ulCrntOffset += 2 * sizeof( uint16 );
		else if ( usFlags & WE_HAVE_A_TWO_BY_TWO )
			ulCrntOffset += 4 * sizeof( uint16 );
		/* now deal with any components of this component */
		if ((errCode = GetComponentGlyphList(pInputBufferInfo, usComponentGlyphIdx, &usnGlyphs, &(ausGlyphIdxs[*pusnGlyphs]), (uint16) (cMaxGlyphs - *pusnGlyphs), pusnComponentDepth, 
							(uint16) (usLevelValue + 1), usIdxToLocFmt, ulLocaOffset, ulGlyfOffset)) != NO_ERROR)
			return(errCode);
		if (usnGlyphs > 0)
			*pusnGlyphs += usnGlyphs;  /* increment count by number of sub components */

	}
	while ( usFlags & MORE_COMPONENTS);
	
	return(NO_ERROR);

} /* GetComponentGlyphList() */
/* ------------------------------------------------------------------- */
/* support for Cmap Modifying and merging */
/* ------------------------------------------------------------------- */
PRIVATE int CRTCB AscendingCodeCompare( CONST void *arg1, CONST void *arg2 )
{
	if (((PCHAR_GLYPH_MAP_LIST)(arg1))->usCharCode == ((PCHAR_GLYPH_MAP_LIST)(arg2))->usCharCode) /* they're the same */
		return 0;
	if (((PCHAR_GLYPH_MAP_LIST)(arg1))->usCharCode < ((PCHAR_GLYPH_MAP_LIST)(arg2))->usCharCode)
		return -1;
	return 1;
}

/* ------------------------------------------------------------------- */
PRIVATE void SortCodeList( PCHAR_GLYPH_MAP_LIST pCharGlyphMapList,
						  uint16 *pusnCharMapListLength )
{
uint16 i, j;

	/* sort list of character codes to keep using an insertion sort */ 

	if (pCharGlyphMapList == NULL || *pusnCharMapListLength == 0)
		return;

	qsort(pCharGlyphMapList, *pusnCharMapListLength, sizeof(*pCharGlyphMapList),  AscendingCodeCompare);
	
	/* now remove duplicates */

	for (i = 0, j = 1 ; j < *pusnCharMapListLength ; ++j)
	{
		if (pCharGlyphMapList[i].usCharCode != pCharGlyphMapList[j].usCharCode) /* not a duplicate, keep it */
		{
			if (j > i+1) /* we have removed one */
				pCharGlyphMapList[i+1] = pCharGlyphMapList[j];	 /* copy it down */
			++i; /* go to next one */
		} 
		/* otherwise, we stay where we are on i, and go look at the next j */
	}
	*pusnCharMapListLength = i+1;	/* the last good i value */
}
/* ------------------------------------------------------------------- */
void FreeFormat4CharCodes(PCHAR_GLYPH_MAP_LIST pusCharCodeList)
{
	Mem_Free(pusCharCodeList);
}
/* ---------------------------------------------------------------------- */
/* create a list of character codes to keep, based on the glyph list */
int16 ReadAllocFormat4CharGlyphMapList(TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
								CONST uint16 usPlatform,
								CONST uint16 usEncoding,
								uint8 *puchKeepGlyphList, /* glyphs to keep - boolean */
								uint16 usGlyphCount,  /* count of puchKeepGlyphList */
								PCHAR_GLYPH_MAP_LIST *ppCharGlyphMapList,
								uint16 *pusnCharGlyphMapListCount)
{
uint16 usSegCount;
FORMAT4_SEGMENTS * pFormat4Segments; 
GLYPH_ID * pFormat4GlyphIdArray;
CMAP_FORMAT4 CmapFormat4;
uint16 i;
uint16 usCharCodeValue;
uint16 usCharCodeCount;
uint16 usCharCodeIndex;
uint16 usGlyphIndex;
uint16 usFoundEncoding;
int32 sIDIdx;
int16 errCode = NO_ERROR;

/* allocate memory for variable length part of table */

	*ppCharGlyphMapList = NULL;
	*pusnCharGlyphMapListCount = 0;

	errCode = ReadAllocCmapFormat4( pInputBufferInfo, usPlatform, usEncoding, &usFoundEncoding, &CmapFormat4, &pFormat4Segments, &pFormat4GlyphIdArray);
	if (errCode != NO_ERROR)
		return errCode;

  	usSegCount = CmapFormat4.segCountX2 / 2;

/* zip through cmap entries,counting the char code entries */

	usCharCodeCount = 0;
	for ( i = 0; i < usSegCount; i++ )
	{
		if (pFormat4Segments[ i ].endCount == INVALID_CHAR_CODE)
			continue;
		if (pFormat4Segments[ i ].endCount < pFormat4Segments[ i ].startCount)
			continue;
		usCharCodeCount += (pFormat4Segments[ i ].endCount - pFormat4Segments[ i ].startCount + 1);
	}

	*ppCharGlyphMapList = Mem_Alloc(usCharCodeCount * sizeof(PCHAR_GLYPH_MAP_LIST));
	if (*ppCharGlyphMapList == NULL)
	{
		FreeCmapFormat4(pFormat4Segments, pFormat4GlyphIdArray);
		return ERR_MEM;
	}

	*pusnCharGlyphMapListCount = usCharCodeCount;

	usCharCodeIndex = 0;
	for ( i = 0; i < usSegCount; i++ )
	{
		if (pFormat4Segments[ i ].endCount == INVALID_CHAR_CODE)
			continue;
		if (pFormat4Segments[ i ].endCount < pFormat4Segments[ i ].startCount)
			continue;
		for (usCharCodeValue = pFormat4Segments[ i ].startCount; usCharCodeValue <= pFormat4Segments[ i ].endCount; ++usCharCodeValue)
		{
		   /* grab this from GetGlyphIndex to speed things up */
			if ( pFormat4Segments[ i ].idRangeOffset == 0 )
				usGlyphIndex = usCharCodeValue + pFormat4Segments[ i ].idDelta;
			else
			{
				sIDIdx = (uint16) i - (uint16) usSegCount; 
				sIDIdx += (uint16) (pFormat4Segments[i].idRangeOffset / 2) + usCharCodeValue - pFormat4Segments[i].startCount;
				usGlyphIndex = pFormat4GlyphIdArray[ sIDIdx ];
				if (usGlyphIndex)
					/* Only add in idDelta if we've really got a glyph! */
					usGlyphIndex += pFormat4Segments[i].idDelta;
			}
	/* check to see if this glyphIndex is supported */
	/*		usGlyphIndex = GetGlyphIdx( usCharCodeValue, pFormat4Segments, usSegCount, pFormat4GlyphIdArray );	*/
			if (usGlyphIndex != 0 && usGlyphIndex != INVALID_GLYPH_INDEX && usGlyphIndex < usGlyphCount)
				if (puchKeepGlyphList[ usGlyphIndex ]) 
			{
					(*ppCharGlyphMapList)[usCharCodeIndex].usCharCode = usCharCodeValue; /* assign the Character code */
					(*ppCharGlyphMapList)[usCharCodeIndex++].usGlyphIndex = usGlyphIndex; /* assign the GlyphIndex */
			}
		}
	}
	*pusnCharGlyphMapListCount = usCharCodeIndex;

	FreeCmapFormat4(pFormat4Segments, pFormat4GlyphIdArray);

	SortCodeList(*ppCharGlyphMapList, pusnCharGlyphMapListCount);

	return( errCode );
}
/* ------------------------------------------------------------------- */
PRIVATE uint32 Format4CmapLength( uint16 usnSegments,
                    uint16 usnGlyphIdxs )
{
	return( GetGenericSize( CMAP_FORMAT4_CONTROL ) + usnSegments * GetGenericSize( FORMAT4_SEGMENTS_CONTROL ) +
               usnGlyphIdxs * sizeof(int16) + sizeof( uint16 ));   
}
/* ------------------------------------------------------------------- */
/* this routine computes new values for the format 4 cmap table 
based on a list of character codes and corresponding glyph 
indexes.  */ 
/* ------------------------------------------------------------------- */
void ComputeFormat4CmapData( CMAP_FORMAT4 * pCmapFormat4, /* to be set by this routine */
                            FORMAT4_SEGMENTS * NewFormat4Segments, /* to be set by this routine */
                            uint16 * pusnSegment, /* count of NewFormat4Segments - returned */
							GLYPH_ID * NewFormat4GlyphIdArray, /* to be set by this routine */
                            uint16 * psnFormat4GlyphIdArray, /* count of NewFormat4GlyphIdArray - returned */
							PCHAR_GLYPH_MAP_LIST pCharGlyphMapList, /* input - map of CharCode to GlyphIndex */
							uint16 usnCharGlyphMapListCount)	 /* input */
{
uint16         usnConsecutiveCodes;
uint16         i;
uint16         j;
uint16         usFormat4GlyphIdArrayIndex;
BOOL           bUseIdDelta;
uint16         usStartIndex;
uint16         usEndIndex;

	/* compute new format 4 data */

	i            = 0;
	*pusnSegment = 0;
	*psnFormat4GlyphIdArray = 0;

	while ( i < usnCharGlyphMapListCount )
	{
		/* find the number of consecutive entries */

		usStartIndex = i;
		usnConsecutiveCodes = 1;
		while ( i < usnCharGlyphMapListCount-1 && pCharGlyphMapList[ i ].usCharCode + 1 == pCharGlyphMapList[ i+1 ].usCharCode )
			i++;
		usEndIndex = i;
		i++;

		/* determine whether to use idDelta or idRangeOffset representation. 
		Default is to use idDelta if all glyphId's are also consecutive
		because that is more space-efficient.  A second pass is made 
		through the data later to compute idRangeOffset values. */

		bUseIdDelta = TRUE;
		for ( j = usStartIndex; j < usEndIndex && bUseIdDelta; j++ )
		{
			if ( pCharGlyphMapList[ j ].usGlyphIndex + 1 != pCharGlyphMapList[ j + 1 ].usGlyphIndex )
			bUseIdDelta = FALSE;
		}

		/* save cmap data */

		NewFormat4Segments[ *pusnSegment ].startCount = pCharGlyphMapList[ usStartIndex ].usCharCode;
		NewFormat4Segments[ *pusnSegment ].endCount   = pCharGlyphMapList[ usEndIndex ].usCharCode;
		if ( bUseIdDelta )
		{
			NewFormat4Segments[ *pusnSegment ].idDelta = pCharGlyphMapList[ usStartIndex ].usGlyphIndex - 
			                             pCharGlyphMapList[ usStartIndex ].usCharCode;
			NewFormat4Segments[ *pusnSegment ].idRangeOffset = FALSE; /* This is mis-used temporarily, but will be set below to the proper value */
		}
		else
		{
			NewFormat4Segments[ *pusnSegment ].idDelta = 0;
			NewFormat4Segments[ *pusnSegment ].idRangeOffset = TRUE; /* This is mis-used temporarily, but will be set below to the proper value */
		}
		(*pusnSegment)++;
	}

	/* make pass through data to compute idRangeOffset info.  This is 
	deferred to this point because we need to know the number of 
	segments before we can compute the idRangeOffset entries. */ 

	usFormat4GlyphIdArrayIndex = 0;
	for ( i = 0; i < *pusnSegment; i++ )
	{
		if ( NewFormat4Segments[ i ].idRangeOffset == FALSE )
		{
			/* We've done it all with sequential glyph ranges... */
			usFormat4GlyphIdArrayIndex += NewFormat4Segments[ i ].endCount - NewFormat4Segments[ i ].startCount + 1;
			NewFormat4Segments[ i ].idRangeOffset = 0;
		}
		else  	/* Non-sequential glyph range: compute idRangeOffset for the segment */
		{
			NewFormat4Segments[ i ].idRangeOffset = (*pusnSegment + 1 - i + *psnFormat4GlyphIdArray) * 2;

			/* insert glyph indices into the GlyphId array */
			for ( j = NewFormat4Segments[ i ].startCount ; j <= NewFormat4Segments[ i ].endCount ; j++ )
				NewFormat4GlyphIdArray[ (*psnFormat4GlyphIdArray)++ ] = pCharGlyphMapList[ usFormat4GlyphIdArrayIndex++ ].usGlyphIndex;
		}
	}

	/* add the final, required 0xFFFF entry */

	NewFormat4Segments[ *pusnSegment ].idRangeOffset = 0;
	NewFormat4Segments[ *pusnSegment ].idDelta       = 1;
	NewFormat4Segments[ *pusnSegment ].endCount      = INVALID_CHAR_CODE;
	NewFormat4Segments[ *pusnSegment ].startCount    = INVALID_CHAR_CODE;
	(*pusnSegment)++;

	/* modify format 4 header data and write out the data */
	pCmapFormat4->format		= FORMAT4_CMAP_FORMAT;
	pCmapFormat4->revision		= 0;
	pCmapFormat4->length        = (uint16) Format4CmapLength( *pusnSegment, *psnFormat4GlyphIdArray );
	pCmapFormat4->segCountX2    = *pusnSegment * 2;
	pCmapFormat4->searchRange   = 0x0001 << ( log2( *pusnSegment ) + 1 );
	pCmapFormat4->entrySelector = log2( (uint16)(pCmapFormat4->searchRange / 2) );
	pCmapFormat4->rangeShift    = 2 * *pusnSegment - pCmapFormat4->searchRange;
}


/* ------------------------------------------------------------------- */
/* this routine writes out the cmap data after it has been 
reconstructed around the missing glyphs.  It assumes that there 
is already enough space allocated to hold the new format 4 
subtable. */ 
/* ------------------------------------------------------------------- */
int16 WriteOutFormat4CmapData( 
			   TTFACC_FILEBUFFERINFO * pOutputBufferInfo,		  
			   CMAP_FORMAT4 *pCmapFormat4,	/* created by ComputeNewFormat4Data */
               FORMAT4_SEGMENTS * NewFormat4Segments, /* created by ComputeNewFormat4Data */
               GLYPH_ID * NewFormat4GlyphIdArray, /* created by ComputeNewFormat4Data */
               uint16 usnSegment, /* number of NewFormat4Segments elements */ 
               uint16 snFormat4GlyphIdArray, /* number of NewFormat4GlyphIdArray elements */
			   uint32 ulNewOffset,  /* where to write the table */
			   uint32 *pulBytesWritten)  /* number of bytes written to table */
{
uint16 i;
uint16 usBytesWritten;
int16 errCode;
uint32 ulOffset;

	ulOffset = ulNewOffset;
	if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) pCmapFormat4, SIZEOF_CMAP_FORMAT4, CMAP_FORMAT4_CONTROL, ulOffset, &usBytesWritten )) != NO_ERROR)
		return errCode;
	ulOffset += usBytesWritten;

	/* write out modified cmap arrays */
	for ( i = 0; i < usnSegment; i++ )
		if ((errCode = WriteWord( pOutputBufferInfo, NewFormat4Segments[ i ].endCount, ulOffset + (i * sizeof(uint16)) )) != NO_ERROR)
			return errCode;
	ulOffset += usnSegment*sizeof(uint16);
	
	if ((errCode = WriteWord( pOutputBufferInfo, (uint16) 0, ulOffset )) != NO_ERROR)  /* pad word */
		return errCode;
	ulOffset += sizeof(uint16); 

	for ( i = 0; i < usnSegment; i++ )
		if ((errCode = WriteWord( pOutputBufferInfo, NewFormat4Segments[ i ].startCount, ulOffset + (i * sizeof(uint16)) )) != NO_ERROR)
			return errCode;
 	ulOffset += usnSegment*sizeof(uint16);

	for ( i = 0; i < usnSegment; i++ )
		if ((errCode = WriteWord( pOutputBufferInfo, NewFormat4Segments[ i ].idDelta, ulOffset + (i * sizeof(uint16)) )) != NO_ERROR)
			return errCode;
 	ulOffset += usnSegment*sizeof(uint16);

	for ( i = 0; i < usnSegment; i++ )
		if ((errCode = WriteWord( pOutputBufferInfo, NewFormat4Segments[ i ].idRangeOffset, ulOffset + (i * sizeof(uint16)) )) != NO_ERROR)
			return errCode;
 	ulOffset += usnSegment*sizeof(uint16);

	/* write out glyph id array */
	for ( i = 0; i < snFormat4GlyphIdArray; i++ )
		if ((errCode = WriteWord( pOutputBufferInfo, NewFormat4GlyphIdArray[ i ], ulOffset + (i * sizeof(uint16)) )) != NO_ERROR)
			return errCode;
	ulOffset += snFormat4GlyphIdArray * sizeof(uint16);

	*pulBytesWritten = ulOffset - ulNewOffset;
			
	return NO_ERROR;

}
/* ---------------------------------------------------------------------- */
/* This function will allocate memory and read into that memory an array of NAMERECORD structures. */
/* note this structure is defined in the .h file for this module, and is similar, but not identical */
/* to the NAME_RECORD structure as described in TTFF.H. The first 6 elements are the same, but extra */
/* data is needed for these functions. When this function returns NO_ERROR, the *ppNameRecordArray */
/* will point to the allocated array and the *pNameRecordCount value will be set to the number of */
/* records in the array. */
/* ---------------------------------------------------------------------- */
int16 ReadAllocNameRecords(TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
						   PNAMERECORD *ppNameRecordArray, /* allocated by this function */
						   uint16 *pNameRecordCount, /* number of records in array */
						   CFP_ALLOCPROC lfpnAllocate,  /* how to allocate array, and strings */
						   CFP_FREEPROC lfpnFree) /* how to free in case of error */
{
NAME_HEADER NameHeader;
int16 errCode;
uint32 ulNameOffset;
uint32 ulNameLength;
uint32 ulOffset;
uint16 usBytesRead;
uint16 i;

	*ppNameRecordArray = NULL;
	*pNameRecordCount = 0;
	ulNameOffset = TTTableOffset( pInputBufferInfo, NAME_TAG );
	if ( ulNameOffset == DIRECTORY_ERROR )
		return ERR_MISSING_NAME;	/* no table there */
	ulNameLength = TTTableLength( pInputBufferInfo, NAME_TAG );
	if ( ulNameLength == DIRECTORY_ERROR )
		return ERR_INVALID_NAME;
	if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) &NameHeader, SIZEOF_NAME_HEADER, NAME_HEADER_CONTROL, ulNameOffset, &usBytesRead )) != NO_ERROR)
		return errCode;
	ulOffset = ulNameOffset + usBytesRead;

	*ppNameRecordArray = (PNAMERECORD) lfpnAllocate(NameHeader.numNameRecords * sizeof(**ppNameRecordArray));
	if (*ppNameRecordArray == NULL)
		return ERR_MEM;
	*pNameRecordCount = NameHeader.numNameRecords; 

	for (i = 0; i < *pNameRecordCount; ++i)
	{
		/* This read into NAMERECORD instead of NAME_RECORD works because the first 6 elements are the same */
		if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) &((*ppNameRecordArray)[i]), SIZEOF_NAME_RECORD, NAME_RECORD_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR)
			break;
		ulOffset += usBytesRead;
		if ((*ppNameRecordArray)[i].stringLength == INVALID_NAME_STRING_LENGTH)	/* will get removed upon write */
			continue;
		(*ppNameRecordArray)[i].pNameString = lfpnAllocate((*ppNameRecordArray)[i].stringLength);
		if ((*ppNameRecordArray)[i].pNameString == NULL)
		{
			errCode = ERR_MEM;
			break;
		}
		if ((errCode = ReadBytes( pInputBufferInfo, (*ppNameRecordArray)[i].pNameString, ulNameOffset + NameHeader.offsetToStringStorage + (*ppNameRecordArray)[i].stringOffset, (*ppNameRecordArray)[i].stringLength)) != NO_ERROR)
			break;
		(*ppNameRecordArray)[i].pNewNameString = NULL;
		(*ppNameRecordArray)[i].bStringWritten = FALSE;
		(*ppNameRecordArray)[i].bDeleteString = FALSE;
	}
	if (errCode != NO_ERROR)  /* need to free up allocated stuff */
	{
		FreeNameRecords(*ppNameRecordArray, *pNameRecordCount, lfpnFree);
		*ppNameRecordArray = NULL;
		*pNameRecordCount = 0;
	}

	return errCode;
}

/* ---------------------------------------------------------------------- */
uint32 CalcMaxNameTableLength(PNAMERECORD pNameRecordArray, 
							  uint16 NameRecordCount)
{
uint16 i;
uint32 ulNameTableLength= 0;
uint16 ValidNameRecordCount = 0;

	if (pNameRecordArray == NULL || NameRecordCount == 0)
		return 0L;

	/*  add in all the space for the strings */
	for (i = 0; i < NameRecordCount; ++i)
	{
		if (pNameRecordArray[i].stringLength != INVALID_NAME_STRING_LENGTH)
			++ValidNameRecordCount;
		ulNameTableLength += pNameRecordArray[i].stringLength;
	}
	/* now add in the array */
	ulNameTableLength += (GetGenericSize(NAME_HEADER_CONTROL) + GetGenericSize(NAME_RECORD_CONTROL) * ValidNameRecordCount);

	return ulNameTableLength;
}

/* ---------------------------------------------------------------------- */
/* Local structure to be made into an array with a 1 to 1 correspondence with the NameRecordArray */
/* this array will be used to sort the records by string length, and then later by NameRecordIndex */
/* without actually changing the order of the NameRecordArray elements */
/* ---------------------------------------------------------------------- */
typedef struct namerecordstrings NAMERECORDSTRINGS;

struct namerecordstrings
{
	uint16 usNameRecordIndex; /* index into name record array */
	uint16 usNameRecordStringLength;  /* length of that string */
	uint16 usNameRecordStringIndex; /* index of Name record who's string this should use*/
	uint16 usNameRecordStringCharIndex; /* index into string referenced by StringIndex of where this string starts */
};
/* ---------------------------------------------------------------------- */
PRIVATE int CRTCB DescendingStringLengthCompare( CONST void *arg1, CONST void *arg2 )
{
	if (((NAMERECORDSTRINGS *)(arg1))->usNameRecordStringLength == ((NAMERECORDSTRINGS *)(arg2))->usNameRecordStringLength) /* they're the same */
		return 0;
	if (((NAMERECORDSTRINGS *)(arg1))->usNameRecordStringLength < ((NAMERECORDSTRINGS *)(arg2))->usNameRecordStringLength)
		return 1; /* reversed because we want descending order */
	return -1;  
}
/* ---------------------------------------------------------------------- */

PRIVATE int CRTCB AscendingRecordIndexCompare( CONST void *arg1, CONST void *arg2 )
{
	if (((NAMERECORDSTRINGS *)(arg1))->usNameRecordIndex == ((NAMERECORDSTRINGS *)(arg2))->usNameRecordIndex) /* they're the same */
		return 0;
	if (((NAMERECORDSTRINGS *)(arg1))->usNameRecordIndex < ((NAMERECORDSTRINGS *)(arg2))->usNameRecordIndex)
		return -1;
	return 1;
}

/* ---------------------------------------------------------------------- */
/* sort largest first */
PRIVATE void SortNameRecordsByStringLength(NAMERECORDSTRINGS *pNameRecordStrings,uint16 NameRecordCount)
{
	if (pNameRecordStrings == NULL || NameRecordCount == 0)
		return;

	qsort (pNameRecordStrings, NameRecordCount, sizeof(*pNameRecordStrings),DescendingStringLengthCompare); 

}
/* ---------------------------------------------------------------------- */
/* sorts by index */
PRIVATE void SortNameRecordsByNameRecordIndex(NAMERECORDSTRINGS *pNameRecordStrings,uint16 NameRecordCount)
{
	if (pNameRecordStrings == NULL || NameRecordCount == 0)
		return;

	qsort (pNameRecordStrings, NameRecordCount, sizeof(*pNameRecordStrings),AscendingRecordIndexCompare); 

}
/* ---------------------------------------------------------------------- */
/* sorts by platformID, then encodingID, then languageID, then nameID */
PRIVATE int CRTCB AscendingNameRecordCompare( CONST void *arg1, CONST void *arg2 )
{

	if (((PNAMERECORD)(arg1))->platformID == ((PNAMERECORD)(arg2))->platformID) /* they're the same */
	{
 		if (((PNAMERECORD)(arg1))->encodingID == ((PNAMERECORD)(arg2))->encodingID) /* they're the same */
		{
			if (((PNAMERECORD)(arg1))->languageID == ((PNAMERECORD)(arg2))->languageID) /* they're the same */
			{
				if (((PNAMERECORD)(arg1))->nameID == ((PNAMERECORD)(arg2))->nameID) /* they're the same */
				{
					return 0;
				}
   				if (((PNAMERECORD)(arg1))->nameID < ((PNAMERECORD)(arg2))->nameID) /* they're the same */
					return -1;
				return 1;
			}
   			if (((PNAMERECORD)(arg1))->languageID < ((PNAMERECORD)(arg2))->languageID) /* they're the same */
				return -1;
			return 1;
		}
   		if (((PNAMERECORD)(arg1))->encodingID < ((PNAMERECORD)(arg2))->encodingID) /* they're the same */
			return -1;
		return 1;
	}
   	if (((PNAMERECORD)(arg1))->platformID < ((PNAMERECORD)(arg2))->platformID) /* they're the same */
		return -1;
	return 1;
}
/* ---------------------------------------------------------------------- */
/* This module will take as input the pNameRecordArray that has been created by ReadAllocNameRecords and possible modified */
/* by the client, and write the records out the the OutputBuffer in and optimized fashion. That is if there is possible */
/* sharing of string data among NameRecords, it is written that way. */
/* note, this function is not the inverse of ReadAllocNameRecords because it writes the name table directly to the buffer at */
/* offset 0. It is up to the client to place that data in a TrueType file and update the directory that points to it */
/* To get a maximum size for the buffer to pass in, call CalcMaxNameTableLength. This will return the size of an unoptimized */
/* name table. */
/* ---------------------------------------------------------------------- */
int16 WriteNameRecords(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, /* bufferInfo for a NAME table, not a TrueType file */
					   PNAMERECORD pNameRecordArray, 
					   uint16 NameRecordCount,
					   BOOL bDeleteStrings,   /* if true don't write out strings marked for deletion. if false, write out all strings */
					   BOOL bOptimize, /* lcp 4/8/97, if True optimize the string storage for smallest space */
					   uint32 *pulBytesWritten)
{
NAME_HEADER NameHeader;
NAMERECORDSTRINGS *pNameRecordStrings; /* structure array to allow sorting by string length */
int16 errCode = NO_ERROR;
uint32 ulNameOffset;/* an absolute offset from beginning of buffer */
uint16 usStringsOffset;	  /* a relative offset from beginning of the name table */
uint32 ulOffset;   /* current absolute offset used for writing out Name_Records */
uint16 usBytesWritten;
uint16 i,j,k;
uint16 index;
uint16 BaseIndex;
uint16 ValidNameRecordCount = 0;
char *pStr1, *pStr2; /* temps to point to either new or old string from PNAMERECORD Array */
	
	
	*pulBytesWritten = 0;
	if (pNameRecordArray == NULL || NameRecordCount == 0)
		return ERR_GENERIC;

	/* before we start this, need to sort the actual NameRecords by platformID etc */
	qsort (pNameRecordArray, NameRecordCount, sizeof(*pNameRecordArray),AscendingNameRecordCompare); 
	
	ulNameOffset = 0L;
	NameHeader.formatSelector = 0;

	ulOffset = ulNameOffset + GetGenericSize(NAME_HEADER_CONTROL);

	/* first create the NameRecordStrings array to sort */
	pNameRecordStrings = Mem_Alloc(NameRecordCount * sizeof(*pNameRecordStrings));
	if (pNameRecordStrings == NULL)
		return ERR_MEM;

	for (i = ValidNameRecordCount = 0; i < NameRecordCount; ++i)
	{
		if (bDeleteStrings && pNameRecordArray[i].bDeleteString)  
			continue;
		pNameRecordStrings[ValidNameRecordCount].usNameRecordIndex = i;
		pNameRecordStrings[ValidNameRecordCount].usNameRecordStringLength = pNameRecordArray[i].stringLength;
		pNameRecordStrings[ValidNameRecordCount].usNameRecordStringIndex = i;
		pNameRecordStrings[ValidNameRecordCount].usNameRecordStringCharIndex = 0;
		pNameRecordArray[i].stringOffset = 0; /* initialize for the Write activity below */
		++ValidNameRecordCount;
	}

	usStringsOffset = 0;
 	NameHeader.offsetToStringStorage = GetGenericSize(NAME_HEADER_CONTROL) + (GetGenericSize(NAME_RECORD_CONTROL)*ValidNameRecordCount);

	if (bOptimize)
	{
	uint16 maxCharIndex;
		/* need to sort these babies by length  */
		SortNameRecordsByStringLength(pNameRecordStrings,ValidNameRecordCount);

		 /* now look for identical lengths, and compare, if the same, mark them */
		for (i = 1; i < ValidNameRecordCount; ++i)
		{
			if ((pStr1 = pNameRecordArray[pNameRecordStrings[i].usNameRecordIndex].pNewNameString) == NULL) /* if we're just using the old string */
				pStr1 = pNameRecordArray[pNameRecordStrings[i].usNameRecordIndex].pNameString;

			if ((pStr2 = pNameRecordArray[pNameRecordStrings[i-1].usNameRecordIndex].pNewNameString) == NULL)
				pStr2 = pNameRecordArray[pNameRecordStrings[i-1].usNameRecordIndex].pNameString;
			
			if (  (pNameRecordStrings[i].usNameRecordStringLength == pNameRecordStrings[i-1].usNameRecordStringLength) 
				 && (memcmp(pStr1, pStr2,pNameRecordStrings[i].usNameRecordStringLength) == 0)) /* they are the same */
			{
				pNameRecordStrings[i].usNameRecordStringIndex = pNameRecordStrings[i-1].usNameRecordStringIndex; /* set the index the same */	
				pNameRecordStrings[i].usNameRecordStringCharIndex = pNameRecordStrings[i-1].usNameRecordStringCharIndex;
			}
			else /* i string is shorter (or the same), because of sort */
				/* now look for subsets (smaller within larger), if found, mark with array index and char index */
			{
				for (j = 0; j < i - 1; ++j)	/* check if contained in any the string before */
				{
					if ((pStr2 = pNameRecordArray[pNameRecordStrings[j].usNameRecordStringIndex].pNewNameString) == NULL)
						pStr2 = pNameRecordArray[pNameRecordStrings[j].usNameRecordStringIndex].pNameString;
					/* Calculate the maximum index beyond which the string compare would go off the end of Str2 */
					maxCharIndex = pNameRecordStrings[j].usNameRecordStringLength - pNameRecordStrings[i].usNameRecordStringLength;
					for (k = 0; k <= maxCharIndex; ++k) /* move along string to look for compare */
					{
						if (memcmp(pStr1, pStr2 + k,pNameRecordStrings[i].usNameRecordStringLength) == 0) /* one is contained in the other */
						{
							pNameRecordStrings[i].usNameRecordStringIndex = pNameRecordStrings[j].usNameRecordStringIndex; /* set the index the same */	
							pNameRecordStrings[i].usNameRecordStringCharIndex = k; /* set the char index */	
							break;
						}
					}
					if (k <= maxCharIndex) /* we found a match and we set the values */
						break;
				}
			}
		}
		/* now put it back the way it was. NOTE, we are only sorting ValidNameRecordCount records */
		SortNameRecordsByNameRecordIndex(pNameRecordStrings,ValidNameRecordCount);
	}
	/* now, we have an array of structures we can output */
 	for (i = 0; i < ValidNameRecordCount && errCode == NO_ERROR; ++i)
	{
		index = pNameRecordStrings[i].usNameRecordIndex; 
		BaseIndex = pNameRecordStrings[i].usNameRecordStringIndex;
			
		if (!pNameRecordArray[index].bStringWritten) /* this baby has not been written */
		{
			if (index != BaseIndex) /* if this points to another string, that has not been written */
			{
				if (!pNameRecordArray[BaseIndex].bStringWritten) /* base string hasn't been written */
				{
					pNameRecordArray[BaseIndex].stringOffset = usStringsOffset;  /* set this one too */
					pNameRecordArray[BaseIndex].bStringWritten = TRUE;
					if ((pStr1 = pNameRecordArray[BaseIndex].pNewNameString) == NULL)
						pStr1 = pNameRecordArray[BaseIndex].pNameString;
					errCode = WriteBytes(pOutputBufferInfo,pStr1, ulNameOffset + NameHeader.offsetToStringStorage + usStringsOffset,pNameRecordArray[BaseIndex].stringLength);
					usStringsOffset += pNameRecordArray[BaseIndex].stringLength;
				}
				pNameRecordArray[index].stringOffset = pNameRecordArray[BaseIndex].stringOffset + 
													   pNameRecordStrings[i].usNameRecordStringCharIndex;	 
			}
			else
			{
  				pNameRecordArray[index].stringOffset = usStringsOffset + pNameRecordStrings[i].usNameRecordStringCharIndex;
				if ((pStr1 = pNameRecordArray[index].pNewNameString) == NULL)
					pStr1 = pNameRecordArray[index].pNameString;
				errCode = WriteBytes(pOutputBufferInfo,pStr1, ulNameOffset + NameHeader.offsetToStringStorage + usStringsOffset,pNameRecordArray[index].stringLength);
				usStringsOffset += pNameRecordArray[index].stringLength;
			}
			pNameRecordArray[index].bStringWritten = TRUE;
		}
		/* now write that NameRecord thing */
		errCode = WriteGeneric(pOutputBufferInfo,(uint8 *) &(pNameRecordArray[index]), SIZEOF_NAME_RECORD, NAME_RECORD_CONTROL, ulOffset, &usBytesWritten);
		ulOffset += usBytesWritten;
	}
	if (errCode == NO_ERROR)
	{
		NameHeader.numNameRecords = ValidNameRecordCount;
		*pulBytesWritten = NameHeader.offsetToStringStorage + usStringsOffset;
		errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &NameHeader, SIZEOF_NAME_HEADER, NAME_HEADER_CONTROL, ulNameOffset, &usBytesWritten );
	}
	Mem_Free(pNameRecordStrings);
	return errCode;
}
/* ---------------------------------------------------------------------- */
/* will free up both strings, as well as the array. NOTE: the NewNameString must */
/* have been allocated with the same function as was handed to the ReadAllocNameRecords function */
/* or something compatible with the lpfnFree function */
/* ---------------------------------------------------------------------- */
void FreeNameRecords(PNAMERECORD pNameRecordArray, uint16 NameRecordCount, CFP_FREEPROC lfpnFree)
{
uint16 i;
	
	if (pNameRecordArray == NULL)
		return;

	for (i = 0; i < NameRecordCount; ++i)
	{
		if (pNameRecordArray[i].pNameString != NULL)
			lfpnFree(pNameRecordArray[i].pNameString); 
		if (pNameRecordArray[i].pNewNameString != NULL)
			lfpnFree(pNameRecordArray[i].pNewNameString); 
	}
	lfpnFree(pNameRecordArray);
}
/* ---------------------------------------------------------------------- */
/* next three functions only used by Name Wizard and Embedding .dll, not by CreateFontPackage */
/* or MergeFontPackage */
/* ---------------------------------------------------------------------- */
int16 InsertTable(TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint8 * szTag, uint8 * puchTableBuffer, uint32 ulTableBufferLength)
{
uint32 ulTableOffset;
uint32 ulTableLength;
uint32 ulOffset;
int16 errCode = NO_ERROR;
uint16 usnTables;
uint16 i;
uint16 usBytesRead;
uint16 usBytesWritten;
OFFSET_TABLE OffsetTable;
DIRECTORY Directory;
uint32 ulTag; 
int32 lCopySize;

	if (puchTableBuffer == NULL || ulTableBufferLength == 0)
		return ERR_GENERIC;
	
	ulTableOffset = TTTableOffset( pOutputBufferInfo, szTag);
	ulTableLength = TTTableLength( pOutputBufferInfo, szTag);

	ConvertStringTagToLong(szTag,&ulTag);

	if (ulTableOffset == DIRECTORY_ERROR)
	{
		DIRECTORY *aDirectory;
		OFFSET_TABLE OffsetTable;
		uint16 usnTables, usnNewTables;
		uint32 ulBytesRead, ulBytesWritten, ulNewSize, ulTableDirSize, ulNewTableDirSize;		
		
		/* read offset table and determine number of existing tables */
		ulOffset = pOutputBufferInfo->ulOffsetTableOffset;
		if ((errCode = ReadGeneric((TTFACC_FILEBUFFERINFO *) pOutputBufferInfo, (uint8 *) &OffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulOffset, &usBytesRead)) != NO_ERROR)
			return(errCode);
		usnTables = OffsetTable.numTables;
		usnNewTables = usnTables + 1;
		ulOffset += usBytesRead;
		
		aDirectory = (DIRECTORY *) Mem_Alloc((usnNewTables) * sizeof(DIRECTORY));	/* one extra for new table */
		if (aDirectory == NULL)
			return(ERR_MEM);

		/* read directory entries */
		if ((errCode = ReadGenericRepeat((TTFACC_FILEBUFFERINFO *) pOutputBufferInfo, (uint8 *)aDirectory, DIRECTORY_CONTROL, ulOffset, &ulBytesRead, usnTables, SIZEOF_DIRECTORY)) != NO_ERROR)
		{
			Mem_Free(aDirectory);
			return(errCode);
		}
		ulOffset += ulBytesRead;

		/* update existing offsets to account for new entry */
		for(i = 0; i < usnTables; i++)
			aDirectory[ i ].offset += SIZEOF_DIRECTORY;	
		
		ulNewSize = SIZEOF_DIRECTORY + RoundToLongWord(pOutputBufferInfo->ulBufferSize);

		/* setup new entry point to end of file with zero size */
		aDirectory[ usnTables ].length = 0;
		aDirectory[ usnTables ].offset = ulNewSize;
		aDirectory[ usnTables ].tag = ulTag;
		aDirectory[ usnTables ].checkSum = 0;

		SortByTag( aDirectory, usnNewTables );
		OffsetTable.numTables =  usnNewTables;

		OffsetTable.searchRange	 = (uint16)((0x0001 << ( log2( usnNewTables ))) << 4 );
		OffsetTable.entrySelector = (uint16)(log2((uint16)(0x0001 << ( log2( usnNewTables )))));
		OffsetTable.rangeShift	 = (uint16)((usnNewTables << 4) - ((0x0001 << ( log2( usnNewTables ))) * 16 ));

		/* allocate space for new font image */		
		pOutputBufferInfo->puchBuffer = pOutputBufferInfo->lpfnReAllocate(pOutputBufferInfo->puchBuffer,ulNewSize);
		if (pOutputBufferInfo->puchBuffer == NULL)
		{
			Mem_Free(aDirectory);
			return ERR_MEM;
		}		
		ZeroLongWordAlign(pOutputBufferInfo,pOutputBufferInfo->ulBufferSize + SIZEOF_DIRECTORY);

		ulTableDirSize = SIZEOF_OFFSET_TABLE + (usnTables * SIZEOF_DIRECTORY);
		ulNewTableDirSize = SIZEOF_OFFSET_TABLE + (usnNewTables * SIZEOF_DIRECTORY);
		lCopySize = pOutputBufferInfo->ulBufferSize - ulTableDirSize;

		pOutputBufferInfo->ulBufferSize = ulNewSize;

		if (lCopySize>0 && (errCode = CopyBlock(pOutputBufferInfo,ulNewTableDirSize,ulTableDirSize,lCopySize)) != NO_ERROR)
		{
			Mem_Free(aDirectory);
			return errCode;
		}		

		/* copy in directory header */
		ulOffset = pOutputBufferInfo->ulOffsetTableOffset;
		if ((errCode = WriteGeneric((TTFACC_FILEBUFFERINFO *) pOutputBufferInfo, (uint8 *) &OffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulOffset, &usBytesWritten)) != NO_ERROR)
		{
			Mem_Free(aDirectory);
			return(errCode);
		}
		ulOffset += usBytesWritten;

		/* copy in directory entries */
		if ((errCode = WriteGenericRepeat((TTFACC_FILEBUFFERINFO *) pOutputBufferInfo, (uint8 *)aDirectory, DIRECTORY_CONTROL, ulOffset, &ulBytesWritten, usnNewTables, SIZEOF_DIRECTORY)) != NO_ERROR)
		{
			Mem_Free(aDirectory);
			return(errCode);
		}
		ulOffset += ulBytesWritten;

		Mem_Free(aDirectory);

		ulTableOffset = TTTableOffset( pOutputBufferInfo, szTag);
		ulTableLength = TTTableLength( pOutputBufferInfo, szTag);
		if (ulTableOffset == DIRECTORY_ERROR)
			return ERR_GENERIC;		
	}

	if(ulTableLength == 0)
	{
		uint32 ulNewOffset = RoundToLongWord(pOutputBufferInfo->ulBufferSize);		
		
		pOutputBufferInfo->puchBuffer = pOutputBufferInfo->lpfnReAllocate(pOutputBufferInfo->puchBuffer,ulNewOffset + RoundToLongWord(ulTableBufferLength));
		if (pOutputBufferInfo->puchBuffer == NULL)
			return ERR_MEM;
		ZeroLongWordAlign(pOutputBufferInfo,pOutputBufferInfo->ulBufferSize);		
		pOutputBufferInfo->ulBufferSize = ulNewOffset + RoundToLongWord(ulTableBufferLength);

		ulOffset = pOutputBufferInfo->ulOffsetTableOffset;
		if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &OffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulOffset, &usBytesRead)) != NO_ERROR)
			return(errCode);
		usnTables = OffsetTable.numTables;
		ulOffset += usBytesRead;  /* where to start reading the Directory entries */
		for (i = 0; i < usnTables; ++i )
		{
			if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &Directory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR)
				break;
			if (Directory.tag == ulTag) /* need to update the offset */
			{
				Directory.offset = ulNewOffset;
				if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &Directory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesWritten )) != NO_ERROR)
					break;
			}
			ulOffset += usBytesRead; /* increment for next time */
		}
		if (errCode != NO_ERROR)
			return errCode;

		ulTableOffset = ulNewOffset;
	}else
	{
		int32 lShift;
		uint32 ulStartShiftOffset;		

		lShift = RoundToLongWord(ulTableBufferLength) - RoundToLongWord(ulTableLength);  /* number of bytes to shift the tables forward */
		ulStartShiftOffset =  ulTableOffset + RoundToLongWord(ulTableLength); /* the offset of the table after this one */
		lCopySize = pOutputBufferInfo->ulBufferSize - ulStartShiftOffset;
	  /* need to move everything forward, or back, then insert this one */
		if (lShift > 0)	 /* need more room */
		{
			pOutputBufferInfo->puchBuffer = pOutputBufferInfo->lpfnReAllocate(pOutputBufferInfo->puchBuffer,pOutputBufferInfo->ulBufferSize + lShift);
			if (pOutputBufferInfo->puchBuffer == NULL)
				return ERR_MEM;
			pOutputBufferInfo->ulBufferSize += lShift;
		}
		if (lCopySize>0 && (errCode = CopyBlock(pOutputBufferInfo,ulStartShiftOffset + lShift, ulStartShiftOffset,lCopySize)) != NO_ERROR)
				return errCode;
		if (lShift < 0)	   /* it shrank */
			pOutputBufferInfo->ulBufferSize += lShift; 

		/* now we need to update all of the offsets in the directory */
		ulOffset = pOutputBufferInfo->ulOffsetTableOffset;
		if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &OffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulOffset, &usBytesRead)) != NO_ERROR)
			return(errCode);
		usnTables = OffsetTable.numTables;
		ulOffset += usBytesRead;  /* where to start reading the Directory entries */
		for (i = 0; i < usnTables; ++i )
		{
			if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &Directory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR)
				break;
			if (Directory.offset >= ulStartShiftOffset) /* need to update the offset */
			{
				Directory.offset += lShift;
				if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &Directory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesWritten )) != NO_ERROR)
					break;
			}
			ulOffset += usBytesRead; /* increment for next time */
		}
		if (errCode != NO_ERROR)
			return errCode;
	}
	
	if ((errCode = WriteBytes(pOutputBufferInfo, puchTableBuffer, ulTableOffset, ulTableBufferLength)) != NO_ERROR)
		return errCode;
	if ((errCode = UpdateDirEntry(pOutputBufferInfo, szTag, ulTableBufferLength)) != NO_ERROR)
		return errCode;
	SetFileChecksum(pOutputBufferInfo, pOutputBufferInfo->ulBufferSize); /* lcp add this 5/20/97 */
	return errCode;
}

/* ---------------------------------------------------------------------- */
int16 WriteNameTable(TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
					 PNAMERECORD pNameRecordArray, 	/* internal representation of NameRecord - from ttftable.h */
					 uint16 NameRecordCount,
					 BOOL bOptimize)  /* lcp 4/8/97, optimize string storage for size */
{
uint8 * puchBuffer;
int16 errCode = NO_ERROR;
uint32 ulBytesWritten = 0;
uint32 ulMaxNewNameTableLength;
TTFACC_FILEBUFFERINFO NameTableBufferInfo; /* needed by WriteNameRecords */

	
	ulMaxNewNameTableLength = CalcMaxNameTableLength(pNameRecordArray, NameRecordCount);

	if ((errCode = Mem_Init()) != NO_ERROR) /* need to initialize for debug mode, but make sure we're not stomping already initiated stuff */
 		return errCode;
	puchBuffer = (uint8 *) Mem_Alloc(ulMaxNewNameTableLength);
	if (puchBuffer == NULL)
		return ERR_MEM;
	/* now fake up a bufferinfo so that WriteNameRecords will write to the actual file buffer */
	NameTableBufferInfo.puchBuffer = puchBuffer;
	NameTableBufferInfo.ulBufferSize = ulMaxNewNameTableLength;
	NameTableBufferInfo.lpfnReAllocate = NULL; /* can't reallocate!!! */
	NameTableBufferInfo.ulOffsetTableOffset = 0;

	if ((errCode = WriteNameRecords(&NameTableBufferInfo, pNameRecordArray, NameRecordCount, TRUE, bOptimize, &ulBytesWritten)) == NO_ERROR)
    /* insert the Name table here, shifting other tables forward if necessary */
		errCode = InsertTable(pOutputBufferInfo, NAME_TAG, puchBuffer, ulBytesWritten); 

	Mem_Free(puchBuffer);
	Mem_End();  /* need free up the track for debug mode */

	return errCode;
}

/* ---------------------------------------------------------------------- */
int16 WriteSmartOS2Table(TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
						 MAINOS2 * pOS2)  
{
uint8 * puchBuffer;
int16 errCode = NO_ERROR;
uint32 ulBytesWritten = 0;
uint16 usBytesWritten = 0;
uint16 usMaxOS2Len;
DIRECTORY Directory;
MAINOS2 OldOS2;	
TTFACC_FILEBUFFERINFO OS2TableBufferInfo;
BOOL bWritten = FALSE;

	/* look at what is in the font already to make sure it is a version we understand */
	if ( (GetTTDirectory( pOutputBufferInfo, OS2_TAG, &Directory ) != DIRECTORY_ERROR) &&
		 (GetSmarterOS2( pOutputBufferInfo, &OldOS2) != 0)
	   )
	{
		/* if the version is beyond what we understand */
		if(OldOS2.usVersion > 2)
		{
			/* make sure there is enough room to write what we do understand */
			if(Directory.length >= GetGenericSize(VERSION2OS2_CONTROL))
			{
				pOS2->usVersion = OldOS2.usVersion;
				if((errCode = WriteGeneric(pOutputBufferInfo, (uint8 *)pOS2, SIZEOF_VERSION2OS2, VERSION2OS2_CONTROL, 
								Directory.offset, &usBytesWritten)) != NO_ERROR)
					return errCode;
				bWritten = TRUE;
			}else
			{
				return ERR_FORMAT;
			}
		}
	}

	if(!bWritten)
	{
		/* if we have gotton here that means the font contains a OS2 table who's format we undestand */

		if ((errCode = Mem_Init()) != NO_ERROR) /* need to initialize for debug mode, but make sure we're not stomping already initiated stuff */
 			return errCode;

		usMaxOS2Len = GetGenericSize(VERSION2OS2_CONTROL);
		puchBuffer = (uint8 *) Mem_Alloc(usMaxOS2Len);
		if (puchBuffer == NULL)
			return ERR_MEM;
		/* now fake up a bufferinfo so that we will write to the actual file buffer */
		OS2TableBufferInfo.puchBuffer = puchBuffer;
		OS2TableBufferInfo.ulBufferSize = usMaxOS2Len;
		OS2TableBufferInfo.lpfnReAllocate = NULL; /* can't reallocate!!! */
		OS2TableBufferInfo.ulOffsetTableOffset = 0;

		if(pOS2->usVersion == 0)
			errCode = WriteGeneric(&OS2TableBufferInfo, (uint8 *)pOS2, SIZEOF_OS2, OS2_CONTROL, 0, &usBytesWritten);
		else if(pOS2->usVersion == 1)
			errCode = WriteGeneric(&OS2TableBufferInfo, (uint8 *)pOS2, SIZEOF_NEWOS2, NEWOS2_CONTROL, 0, &usBytesWritten);
		else if(pOS2->usVersion == 2)
			errCode = WriteGeneric(&OS2TableBufferInfo, (uint8 *)pOS2, SIZEOF_VERSION2OS2, VERSION2OS2_CONTROL, 0, &usBytesWritten);
		
		if(errCode == NO_ERROR)
			errCode = InsertTable(pOutputBufferInfo, OS2_TAG, puchBuffer, usBytesWritten); 
		
		Mem_Free(puchBuffer);
		Mem_End();  /* need free up the track for debug mode */
	}

	return errCode;
}

/* ---------------------------------------------------------------------- */
int16 CompressTables( TTFACC_FILEBUFFERINFO * pOutputBufferInfo, uint32 * pulBytesWritten )
{
/* this routine compresses the tables present in a font file by removing
space between them which is unused.  It follows four basic steps:

1.  Make a list of tables to keep.
2.  Sort the list of tables by offset so that the gaps between
	them are easy to detect and fill in.
3.  Move the tables to eliminate gaps.  Clean up by
	recalculating checksums and putting in zero pad bytes for
	long word alignment at the same time.
4.  Sort the list of tables by tag (as required for the table
	directory) and write out a new table directory.
*/
DIRECTORY *aDirectory;
DIRECTORY CandDirectory;
uint16 i;
OFFSET_TABLE  OffsetTable;
uint16 usnTables;
uint16 usnNewTables;
uint32 ulOffset;
uint16 usTableIdx;
uint16 usBytesRead;
uint16 usBytesWritten;
uint32 ulSaveBytesWritten = 0;
uint16 DoTwo;
int16 errCode;

	/* read offset table and determine number of existing tables */

	ulOffset = pOutputBufferInfo->ulOffsetTableOffset;
	if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &OffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulOffset, &usBytesRead)) != NO_ERROR)
		return(ERR_MEM);
	usnTables = OffsetTable.numTables;
	ulOffset += usBytesRead;
	/* Create a list of valid tables */

	aDirectory = (DIRECTORY *) Mem_Alloc((usnTables) * sizeof(DIRECTORY));
	if (aDirectory == NULL)
		return(ERR_MEM);

	usnNewTables = 0;
	for (i = 0; i < usnTables; ++i )
	{
		if ((errCode = ReadGeneric( pOutputBufferInfo, (uint8 *) &CandDirectory, SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR)
			break;
		ulOffset += usBytesRead;
		if (CandDirectory.tag != DELETETABLETAG && 
			CandDirectory.length != 0 && 
			CandDirectory.offset != 0)
		{
			aDirectory[ usnNewTables ] = CandDirectory;
			usnNewTables++;
		}
	}

	if (errCode != NO_ERROR)
	{
		Mem_Free(aDirectory);
		return errCode;
	}
	/* sort directories by offset */

	SortByOffset( aDirectory, usnNewTables );
	
	/* compress table data and adjust directory entries to reflect
	the changes */

	ulOffset = pOutputBufferInfo->ulOffsetTableOffset + GetGenericSize( OFFSET_TABLE_CONTROL ) + (usnNewTables) * GetGenericSize( DIRECTORY_CONTROL );
	ulOffset += ZeroLongWordAlign(pOutputBufferInfo, ulOffset);
	DoTwo = FALSE;
	for ( usTableIdx = 0; usTableIdx < usnNewTables; usTableIdx++ )
	{
		/* copy the table from where it currently is to the lowest available
		spot, thus filling in any existing gaps */
		if (!DoTwo)	  /* if not the 2nd of two directories pointing to the same data */
		{
			if ((errCode = CopyBlock( pOutputBufferInfo, ulOffset, aDirectory[ usTableIdx ].offset, aDirectory[ usTableIdx ].length )) != NO_ERROR)
				break;

			if (usTableIdx + 1 < usnNewTables)
			{  /* special case for bloc and bdat tables */
				if ( (aDirectory[ usTableIdx ].offset == aDirectory[ usTableIdx + 1 ].offset) &&
				     (aDirectory[ usTableIdx ].length != 0) 
				   )
				{
					DoTwo = TRUE;  /* need to proccess 2 directories pointing to same data */
					aDirectory[ usTableIdx + 1 ].offset = ulOffset;
					aDirectory[ usTableIdx + 1 ].length = aDirectory[ usTableIdx ].length;
				}
			}
			aDirectory[ usTableIdx ].offset = ulOffset;
			/* calc offset for next table */

		/* zero out any pad bytes and determine the checksum for the entry */
			ZeroLongWordGap( pOutputBufferInfo, aDirectory[ usTableIdx ].offset,
				   aDirectory[ usTableIdx ].length );
			ulOffset += RoundToLongWord( aDirectory[ usTableIdx ].length );
		}
		else
			DoTwo = FALSE; /* so next time we'll perform the copy */
		if ((errCode = CalcChecksum( pOutputBufferInfo, aDirectory[ usTableIdx ].offset, aDirectory[ usTableIdx ].length, &aDirectory[ usTableIdx ].checkSum )) != NO_ERROR)
			break;
	}


	while (errCode == NO_ERROR)	/* so we can break out on error */
	{
		ulSaveBytesWritten = ulOffset;
	/* write out the new directory info */

		SortByTag( aDirectory, usnNewTables );
		OffsetTable.numTables =  usnNewTables ;

		OffsetTable.searchRange	 = (uint16)((0x0001 << ( log2( usnNewTables ))) << 4 );
		OffsetTable.entrySelector = (uint16)(log2((uint16)(0x0001 << ( log2( usnNewTables )))));
		OffsetTable.rangeShift	 = (uint16)((usnNewTables << 4) - ((0x0001 << ( log2( usnNewTables ))) * 16 ));

		ulOffset = pOutputBufferInfo->ulOffsetTableOffset;
		if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &OffsetTable, SIZEOF_OFFSET_TABLE, OFFSET_TABLE_CONTROL, ulOffset, &usBytesWritten)) != NO_ERROR)
			break;
		ulOffset += usBytesWritten;
		for ( i = 0; i < usnNewTables; i++ )
		{
			if ((errCode = WriteGeneric( pOutputBufferInfo, (uint8 *) &(aDirectory[ i ]), SIZEOF_DIRECTORY, DIRECTORY_CONTROL, ulOffset, &usBytesWritten)) != NO_ERROR)
				break;
			ulOffset += usBytesWritten;
		}
		if (errCode != NO_ERROR)
			break;

		*pulBytesWritten = ulSaveBytesWritten;
		break;
	}

	Mem_Free(aDirectory);

	return(errCode);
}
/* ---------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttftable.h ===
/***************************************************************************
 * module: TTFTABLE.H
 *
 * author: Louise Pathe
 * date:   November 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * Function prototypes for TTFTABLE.C for TTFSub.lib
 *
 **************************************************************************/

#ifndef TTFTABLE_DOT_H_DEFINED
#define TTFTABLE_DOT_H_DEFINED        
/* preprocessor macros -------------------------------------------------- */
#define INVALID_GLYPH_INDEX 0xFFFF
#define INVALID_CHAR_CODE 0xFFFF
#define DELETETABLETAG 0x01010101L
#define INVALID_NAME_STRING_LENGTH 0   /* must be 0 */

/* used by ReadAllocNameRecords etc. */
typedef struct namerecord *PNAMERECORD;
typedef struct namerecord NAMERECORD;
struct namerecord /* MUST be same as NAME_RECORD from ttff.h for the first 6 elements */
{   
	uint16  platformID;
	uint16  encodingID;
	uint16  languageID;
	uint16  nameID;
	uint16  stringLength; /* value of 0 means invalid string - don't write */
	uint16	stringOffset; /* offset into string pool */
	uint16	bStringWritten; /* set to FALSE if not written yet */
	char *  pNameString;  /* note: extra element. Alloced in ReadAllocNameRecords */
	char *  pNewNameString; /* If a different string should be written out, it is set here */
							/* allocation of this string occurs outside of entry points. */
							/* deallocation must occur before FreeNameRecords */
	BOOL bDeleteString; /* set if string is to be deleted */
};

/* exported functions --------------------------------------------------- */

void MarkTableForDeletion( 
			TTFACC_FILEBUFFERINFO * pInputBufferInfo,
			char *  szDirTag );	 /* pointer to null terminated string with tag name */

uint32 FindCmapSubtable( 
			TTFACC_FILEBUFFERINFO * pInputBufferInfo,
			uint16 usDesiredPlatform,
			uint16 usDesiredEncodingID,
			uint16 *pusFoundEncoding);
void FreeCmapFormat4Ids( GLYPH_ID * GlyphId );
void FreeCmapFormat4Segs( FORMAT4_SEGMENTS * Format4Segments);
void FreeCmapFormat4( 
			FORMAT4_SEGMENTS * Format4Segments,
			GLYPH_ID * GlyphId );
int16 ReadAllocCmapFormat4Ids( 
			TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint16 usSegCount,
			FORMAT4_SEGMENTS * Format4Segments,
			GLYPH_ID ** ppGlyphId,
			uint16 * pusnIds,
			uint32 ulOffset,
			uint32 *pulBytesRead );
int16 ReadAllocCmapFormat4Segs( 
			TTFACC_FILEBUFFERINFO * pInputBufferInfo, uint16 usSegCount,
			FORMAT4_SEGMENTS ** Format4Segments, 
			uint32 ulOffset,
			uint32 *pulBytesRead);
int16 ReadAllocCmapFormat4( 
			TTFACC_FILEBUFFERINFO * pInputBufferInfo,
			CONST uint16 usPlatform,
			CONST uint16 usEncoding,
			uint16 *pusFoundEncoding,
			CMAP_FORMAT4 * CmapFormat4,
			FORMAT4_SEGMENTS ** Format4Segments,
			GLYPH_ID ** GlyphId );
void FreeCmapFormat6( uint16 *  glyphIndexArray);
int16 ReadAllocCmapFormat6( 
			TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
			CONST uint16 usPlatform,
			CONST uint16 usEncoding,
			uint16 *pusFoundEncoding,
			CMAP_FORMAT6 * pCmap,
			uint16 **  glyphIndexArray);
int16 ReadCmapFormat0( 
			TTFACC_FILEBUFFERINFO * pInputBufferInfo,
			CONST uint16 usPlatform,
			CONST uint16 usEncoding,
			uint16 *pusFoundEncoding,
			CMAP_FORMAT0 * CmapFormat0);
uint16 GetGlyphIdx( 
			uint16 CharCode,
			FORMAT4_SEGMENTS * Format4Segments,
			uint16 usnSegments,
			GLYPH_ID * GlyphId );
int16 GetGlyphHeader( 
			TTFACC_FILEBUFFERINFO * pInputBufferInfo,
			uint16 GlyfIdx,
			uint16 usIdxToLocFmt,
			uint32 ulLocaOffset,
			uint32 ulGlyfOffset,	
			GLYF_HEADER * GlyfHeader,
			uint32 * pulOffset,
			uint16 * pusLength );
uint32 GetLoca( 
			TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
			uint32 *pulBuffer, 
			uint16 usAllocedCount );
int16 GetComponentGlyphList( 
			TTFACC_FILEBUFFERINFO * pInputBufferInfo,
			uint16 usCompositeGlyphIdx,
			uint16 * pusnGlyphs,
			uint16 * ausGlyphIdxs,
			uint16 cMaxGlyphs,
			uint16 *pusnComponentDepth,
			uint16 usLevelValue, 
			uint16 usIdxToLocFmt,
			uint32 ulLocaOffset,
			uint32 ulGlyfOffset);
int16 ReadAllocNameRecords(
			TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
			PNAMERECORD *ppNameRecordArray, 
			uint16 *pNameRecordCount, 
			CFP_ALLOCPROC lfpnAllocate, 
			CFP_FREEPROC lfpnFree);
uint32 CalcMaxNameTableLength(
			PNAMERECORD pNameRecordArray, 
			uint16 NameRecordCount);
int16 WriteNameRecords(
			TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
			PNAMERECORD pNameRecordArray, 
			uint16 NameRecordCount, 
			BOOL bDeleteStrings, 
			BOOL bOptimize, 
			uint32 *pulBytesWritten);
void FreeNameRecords(
			PNAMERECORD pNameRecordArray, 
			uint16 NameRecordCount, 
			CFP_FREEPROC lfpnFree);

int16 InsertTable(
			TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
			uint8 * szTag, 
			uint8 * puchTableBuffer, 
			uint32 ulTableBufferLength);
int16 WriteNameTable(
			TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
			PNAMERECORD pNameRecordArray, 	/* internal representation of NameRecord - from ttftable.h */
			uint16 NameRecordCount,
			BOOL bOptimize); /* lcp 4/8/97, if set to TRUE, optimize Name string storage for size */
int16 WriteSmartOS2Table(
			TTFACC_FILEBUFFERINFO * pOutputBufferInfo,
			MAINOS2 * pOS2);
void SortByTag( 
			DIRECTORY * aDirectory, 
			uint16 usnDirs);
void SortByOffset( 
			DIRECTORY * aDirectory, 
			uint16 usnDirs);
int16 CompressTables( 
			TTFACC_FILEBUFFERINFO * pOutputBufferInfo, 
			uint32 * pulBytesWritten);

typedef struct Char_Glyph_Map_List *PCHAR_GLYPH_MAP_LIST;
typedef struct Char_Glyph_Map_List {
	uint16 usCharCode;
	uint16 usGlyphIndex;
} CHARGLYPHMAPLIST;

void FreeFormat4CharCodes(PCHAR_GLYPH_MAP_LIST pusCharCodeList);
int16 ReadAllocFormat4CharGlyphMapList(
			TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
			CONST uint16 usPlatform,
			CONST uint16 usEncoding,
			uint8 *puchKeepGlyphList, /* glyphs to keep - boolean */
			uint16 usGlyphCount,  /* count of puchKeepGlyphList */
			PCHAR_GLYPH_MAP_LIST *ppCharGlyphMapList,
			uint16 *pusnCharGlyphMapListCount);

void ComputeFormat4CmapData( 
			CMAP_FORMAT4 * pCmapFormat4, /* to be set by this routine */
			FORMAT4_SEGMENTS * NewFormat4Segments, /* to be set by this routine */
			uint16 * pusnSegment, /* count of NewFormat4Segments - returned */
			GLYPH_ID * NewFormat4GlyphIdArray, /* to be set by this routine */
			uint16 * psnFormat4GlyphIdArray, /* count of NewFormat4GlyphIdArray - returned */
			PCHAR_GLYPH_MAP_LIST pCharGlyphMapList, /* input - map of CharCode to GlyphIndex */
			uint16 usnCharGlyphMapListCount);	 /* input */
int16 WriteOutFormat4CmapData( 
			TTFACC_FILEBUFFERINFO * pOutputBufferInfo,		  
			CMAP_FORMAT4 *pCmapFormat4,	/* created by ComputeNewFormat4Data */
			FORMAT4_SEGMENTS * NewFormat4Segments, /* created by ComputeNewFormat4Data */
			GLYPH_ID * NewFormat4GlyphIdArray, /* created by ComputeNewFormat4Data */
			uint16 usnSegment, /* number of NewFormat4Segments elements */ 
			uint16 snFormat4GlyphIdArray, /* number of NewFormat4GlyphIdArray elements */
			uint32 ulNewOffset,  /* where to write the table */
			uint32 *pulBytesWritten);  /* number of bytes written to table */

#endif TTFTABLE_DOT_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttmem.h ===
/*
  * TTmem.h: Interface file for TTmem.c -- Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  * This file must be included in order to use the memory manager access functions.
  */
  
#ifndef TTMEM_DOT_H_DEFINED
#define TTMEM_DOT_H_DEFINED        

#define MemNoErr 0
#define MemErr -1 

int16 Mem_Init(void);
/* Initialize memory manager internal structures */ 
/* return MemNoErr if successful */

void Mem_End(void);  
/* free all memory previously allocated and free memory structure */


void *Mem_Alloc(CONST size_t); 
/* void *Mem_Alloc(size)
  * allocate a size bytes of memory   
  *
  * RETURN VALUE
  *  Pointer to a block of data  
  */

void Mem_Free(void *);
/* free up a block of data */

void *Mem_ReAlloc(void *, CONST size_t);
/* void *Mem_ReAlloc( pOldPtr, newSize)
 * reallocate and copy data
 *
 * INPUT 
 * pOldPtr - pointer to old block
 * newSize - size of new pointer to allocate 
 *
 * RETURN VALUE
 *  Pointer to a block of data 
 */
 void *Mem_ReAllocDelta(void * pOldPtr, CONST size_t Delta);
/* void *Mem_ReAllocDelta( pOldPtr, Delta)
 * reallocate and copy data
 *
 * INPUT 
 * pOldPtr - pointer to old block
 * Delta - Amount to increment block size 
 *
 * RETURN VALUE
 *  Pointer to a block of data 
 */

#endif /* CTTMEM_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttodepen.c ===
/***************************************************************************
 * module: TTODepen.C
 *
 * author: Louise Pathe
 * date:   1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * Module to manage the TableReference array of Dependency info for TTO tables
 **************************************************************************/

/* Inclusions ----------------------------------------------------------- */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>  /* for isalpha etc. functions */ 
#include <math.h>
#include <assert.h>
#include <limits.h>

#include "typedefs.h"
#include "ttmem.h"
#include "ttoerror.h"
#include "ttodepen.h"
#ifdef _DEBUG
#include "util.h"
#endif

/* ---------------------------------------------------------------------- */ 
/* hand in a structure initialized to zero */
void CreateTTOTableReferenceArray(PTABLEREFERENCEKEEPER pKeeper)
{
	pKeeper->cAllocedRecords = 100;
 	pKeeper->PointerArray = (PPTABLEREFERENCE) Mem_Alloc((size_t) (sizeof(PTABLEREFERENCE) * pKeeper->cAllocedRecords));
	pKeeper->cRecordCount = 0;
}

/* ---------------------------------------------------------------------- */ 
void DestroyTTOTableReferenceArray(PTABLEREFERENCEKEEPER pKeeper)
{
uint16 i,j;

	if (pKeeper->PointerArray == NULL)
		return;
	for (i = 0; i < pKeeper->cRecordCount; ++i)
	{
	 	if (pKeeper->PointerArray[i] == NULL)
			continue;
		Mem_Free(pKeeper->PointerArray[i]->Reference[0].pBitFlags); /* first one allocated as a matter of course */
		for (j = 1; j < pKeeper->PointerArray[i]->cReferenceCount; ++j)
			Mem_Free(pKeeper->PointerArray[i]->Reference[j].pBitFlags);
		Mem_Free(pKeeper->PointerArray[i]->pBitFlags);
		Mem_Free(pKeeper->PointerArray[i]);
	}
	Mem_Free(pKeeper->PointerArray);
	pKeeper->PointerArray = NULL;
	pKeeper->cAllocedRecords = 0;
	pKeeper->cRecordCount = 0;
}

/* ---------------------------------------------------------------------- */ 
PTABLEREFERENCE GetTTOTableReference(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex)
{

 	if (pKeeper->PointerArray == NULL || 
 		iIndex < 0 ||
 		iIndex >= pKeeper->cRecordCount)
		return(NULL);

	return(pKeeper->PointerArray[iIndex]);
}

/* ---------------------------------------------------------------------- */ 
int16 AddTTOTableReference(PTABLEREFERENCEKEEPER pKeeper, PTABLEREFERENCE pTableReference, uint32 ulDefaultBitFlag)
{

	if (pKeeper->PointerArray == NULL)
		return (INVALID_INDEX);
	if (pKeeper->cRecordCount >= pKeeper->cAllocedRecords)
	{
		pKeeper->cAllocedRecords += 100;
		pKeeper->PointerArray = (PPTABLEREFERENCE) Mem_ReAlloc(pKeeper->PointerArray, (size_t) (sizeof(PTABLEREFERENCE) * pKeeper->cAllocedRecords));
		if (pKeeper->PointerArray == NULL)
			return (INVALID_INDEX);
	}
	pKeeper->PointerArray[pKeeper->cRecordCount] = (PTABLEREFERENCE) Mem_Alloc(sizeof(TABLEREFERENCE));	
	if (pKeeper->PointerArray[pKeeper->cRecordCount] == NULL)
		return(INVALID_INDEX);
	memcpy(pKeeper->PointerArray[pKeeper->cRecordCount],pTableReference, sizeof(TABLEREFERENCE)); 
	pKeeper->PointerArray[pKeeper->cRecordCount]->ulDefaultBitFlag = ulDefaultBitFlag;
	pKeeper->PointerArray[pKeeper->cRecordCount]->pBitFlags = (uint32 *) Mem_Alloc(sizeof(uint32));
	pKeeper->PointerArray[pKeeper->cRecordCount]->pBitFlags[0] = ulDefaultBitFlag; /* keep all the glyphs in the coverage */
	pKeeper->PointerArray[pKeeper->cRecordCount]->cAllocedBitFlags = 1;
	pKeeper->PointerArray[pKeeper->cRecordCount]->Reference[0].pBitFlags = (uint32 *) Mem_Alloc(sizeof(uint32));
	pKeeper->PointerArray[pKeeper->cRecordCount]->Reference[0].pBitFlags[0] = ulDefaultBitFlag; /* keep all the glyphs in the coverage */
	pKeeper->PointerArray[pKeeper->cRecordCount]->Reference[0].cAllocedBitFlags = 1;
return pKeeper->cRecordCount++;
}

/* ---------------------------------------------------------------------- */ 
void AddTTOTableReferenceReference(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, PREFERENCE Reference)
{
size_t RecordSize;

 	if (pKeeper->PointerArray == NULL || 
 		iIndex < 0 ||
 		iIndex >= pKeeper->cRecordCount ||
 		pKeeper->PointerArray[iIndex] == NULL)
		return;
	RecordSize = sizeof(TABLEREFERENCE) + (sizeof(pKeeper->PointerArray[iIndex]->Reference[0]) * pKeeper->PointerArray[iIndex]->cReferenceCount);
	pKeeper->PointerArray[iIndex] = (PTABLEREFERENCE) Mem_ReAlloc(pKeeper->PointerArray[iIndex], RecordSize);	
	if (pKeeper->PointerArray[iIndex] == NULL)
		return;
	memcpy(&(pKeeper->PointerArray[iIndex]->Reference[pKeeper->PointerArray[iIndex]->cReferenceCount]), Reference, sizeof(*Reference));
	pKeeper->PointerArray[iIndex]->Reference[pKeeper->PointerArray[iIndex]->cReferenceCount].pBitFlags = (uint32 *) Mem_Alloc(sizeof(uint32));
	pKeeper->PointerArray[iIndex]->Reference[pKeeper->PointerArray[iIndex]->cReferenceCount].pBitFlags[0] = pKeeper->PointerArray[iIndex]->ulDefaultBitFlag; /* keep all the glyphs in the coverage */
	pKeeper->PointerArray[iIndex]->Reference[pKeeper->PointerArray[iIndex]->cReferenceCount].cAllocedBitFlags = 1;
	++(pKeeper->PointerArray[iIndex]->cReferenceCount);	
}
/* ---------------------------------------------------------------------- */ 
/* set bitflags and default value  */
void SetTTOTableReferenceDefaultBitFlag(PTABLEREFERENCEKEEPER pKeeper, uint16 iIndex, uint32 ulDefaultBitFlag)
{
uint16 i; //,j;

 	if (pKeeper->PointerArray == NULL || 
 		iIndex < 0 ||
 		iIndex >= pKeeper->cRecordCount ||
 		pKeeper->PointerArray[iIndex] == NULL)
		return;
	pKeeper->PointerArray[iIndex]->ulDefaultBitFlag = ulDefaultBitFlag;
	for (i = 0; i < pKeeper->PointerArray[iIndex]->cAllocedBitFlags; ++i)
	{
		pKeeper->PointerArray[iIndex]->pBitFlags[i] = ulDefaultBitFlag;
	}
	/* !!! for (i = 0; i < pKeeper->PointerArray[iIndex]->cReferenceCount; ++i)
	{
		for (j = 0; j < pKeeper->PointerArray[iIndex]->Reference[i].cAllocedBitFlags; ++j)
			pKeeper->PointerArray[iIndex]->Reference[i].pBitFlags[j] = ulDefaultBitFlag;
	}*/
}


/* ---------------------------------------------------------------------- */ 
/* set bitflags for reference to table, not table itself */
void SetTTOReferenceBitFlag(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, uint16 uInOffset, uint16 usFlagBit,uint16 usValue)
{
uint16 newSize;
ldiv_t lDivResult;
uint16 BitIndex;
uint32 BitMask;
uint16 ShiftValue;
uint16 i;
uint16 iReference;

 	if (pKeeper->PointerArray == NULL || 
 		iIndex < 0 ||
 		iIndex >= pKeeper->cRecordCount ||
 		pKeeper->PointerArray[iIndex] == NULL)
		return;
	for (iReference = 0; iReference < pKeeper->PointerArray[iIndex]->cReferenceCount; ++iReference)
		if (uInOffset == pKeeper->PointerArray[iIndex]->Reference[iReference].uInOffset)
			break;
	if (iReference >= pKeeper->PointerArray[iIndex]->cReferenceCount)
		return;
	lDivResult = ldiv(usFlagBit,32);
	BitIndex = (uint16) lDivResult.quot;
	if (BitIndex + 1 > pKeeper->PointerArray[iIndex]->Reference[iReference].cAllocedBitFlags)
	{ /* need to allocate some more */
		newSize = BitIndex + 1;
		pKeeper->PointerArray[iIndex]->Reference[iReference].pBitFlags = (uint32 *) Mem_ReAlloc(pKeeper->PointerArray[iIndex]->Reference[iReference].pBitFlags, sizeof(uint32)*newSize);
		if (pKeeper->PointerArray[iIndex]->Reference[iReference].pBitFlags == NULL)
			return;
		for (i = pKeeper->PointerArray[iIndex]->Reference[iReference].cAllocedBitFlags; i < newSize; ++i)
			pKeeper->PointerArray[iIndex]->Reference[iReference].pBitFlags[i] = pKeeper->PointerArray[iIndex]->ulDefaultBitFlag; /* keep all the glyphs in the coverage */
		pKeeper->PointerArray[iIndex]->Reference[iReference].cAllocedBitFlags = newSize;
	}
#if 0  /* we never look at this, why do we bother? */
	if (usFlagBit >= pKeeper->PointerArray[iIndex]->Reference[iReference].cCount) /* if this is bigger than we've seen before */ 
		pKeeper->PointerArray[iIndex]->Reference[iReference].cCount = usFlagBit+1;  /* set to this one */
#endif
	ShiftValue = (uint16) lDivResult.rem;
	BitMask = 0x00000001 << ShiftValue;	 /* make a mask */
	if (usValue == TRUE)
	  	pKeeper->PointerArray[iIndex]->Reference[iReference].pBitFlags[BitIndex] = pKeeper->PointerArray[iIndex]->Reference[iReference].pBitFlags[BitIndex] | BitMask;
	else
	  	pKeeper->PointerArray[iIndex]->Reference[iReference].pBitFlags[BitIndex] = pKeeper->PointerArray[iIndex]->Reference[iReference].pBitFlags[BitIndex] & ~ BitMask;
}

/* ---------------------------------------------------------------------- */ 
void SetTTOBitFlag(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, uint16 usFlagBit,uint16 usValue) /* set the bitflags for the table itself */
{
uint16 newSize;
ldiv_t lDivResult;
uint16 BitIndex;
uint32 BitMask;
uint16 ShiftValue;
uint16 i;

 	if (pKeeper->PointerArray == NULL || 
 		iIndex < 0 ||
 		iIndex >= pKeeper->cRecordCount ||
 		pKeeper->PointerArray[iIndex] == NULL)
		return;
	lDivResult = ldiv(usFlagBit,32);
	BitIndex = (uint16) lDivResult.quot;
	if (BitIndex + 1 > pKeeper->PointerArray[iIndex]->cAllocedBitFlags)
	{ /* need to allocate some more */
		newSize = BitIndex + 1;
		pKeeper->PointerArray[iIndex]->pBitFlags = (uint32 *) Mem_ReAlloc(pKeeper->PointerArray[iIndex]->pBitFlags, sizeof(uint32)*newSize);
		if (pKeeper->PointerArray[iIndex]->pBitFlags == NULL)
			return;
		for (i = pKeeper->PointerArray[iIndex]->cAllocedBitFlags; i < newSize; ++i)
			pKeeper->PointerArray[iIndex]->pBitFlags[i] = pKeeper->PointerArray[iIndex]->ulDefaultBitFlag; /* keep all the glyphs in the coverage */
		pKeeper->PointerArray[iIndex]->cAllocedBitFlags = newSize;
	}
	if (usFlagBit >= pKeeper->PointerArray[iIndex]->cCount) /* if this is bigger than we've seen before */ 
		pKeeper->PointerArray[iIndex]->cCount = usFlagBit+1;  /* set to this one */
	ShiftValue = (uint16) lDivResult.rem;
	BitMask = 0x00000001 << ShiftValue;	 /* make a mask */
	if (usValue == TRUE)
	  	pKeeper->PointerArray[iIndex]->pBitFlags[BitIndex] = pKeeper->PointerArray[iIndex]->pBitFlags[BitIndex] | BitMask;
	else
	  	pKeeper->PointerArray[iIndex]->pBitFlags[BitIndex] = pKeeper->PointerArray[iIndex]->pBitFlags[BitIndex] & ~ BitMask;
}

/* ---------------------------------------------------------------------- */ 
PRIVATE int16 GetTTOReferenceBitFlagsCount(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, uint16 uInOffset)
{
ldiv_t lDivResult;
uint32 BitMask;
uint16 BitCount;
uint16 i, j;
uint16 Count = 0;
uint16 iReference;
	
 	if (pKeeper->PointerArray == NULL || 
 		iIndex < 0 ||
 		iIndex >= pKeeper->cRecordCount ||
 		pKeeper->PointerArray[iIndex] == NULL)
		return(INVALID_INDEX);
	for (iReference = 0; iReference < pKeeper->PointerArray[iIndex]->cReferenceCount; ++iReference)
		if (uInOffset == pKeeper->PointerArray[iIndex]->Reference[iReference].uInOffset)
			break;
	if (iReference >= pKeeper->PointerArray[iIndex]->cReferenceCount)
		return(INVALID_INDEX);
	BitCount = 32;
	lDivResult = ldiv(pKeeper->PointerArray[iIndex]->cCount,BitCount);	/* use the coverage table's count, referencing table may not have a count */
	for (i = 0; i <= lDivResult.quot; ++i)
	{
		BitMask = 0x00000001;
		if (i == lDivResult.quot)
			BitCount = (uint16) lDivResult.rem;
		if (i >= pKeeper->PointerArray[iIndex]->Reference[iReference].cAllocedBitFlags)
		{  /* referencer never allocated this, but is turned on */
			Count += BitCount;
			continue;
		}
		for (j = 0; j < BitCount; ++j)
		{
			
			if (pKeeper->PointerArray[iIndex]->Reference[iReference].pBitFlags[i] & BitMask)
				++Count;
			BitMask <<= 1;
		}
	}
	return Count;
}
/* ---------------------------------------------------------------------- */ 
int16 GetTTOBitFlagsCount(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex)
{
ldiv_t lDivResult;
uint32 BitMask;
uint16 BitCount;
uint16 i, j;
uint16 Count = 0;
uint16 iReference;  /* count from reference */
BOOL TableOn;
BOOL ReferencesOn;
	
 	if (pKeeper->PointerArray == NULL || 
 		iIndex < 0 ||
 		iIndex >= pKeeper->cRecordCount ||
 		pKeeper->PointerArray[iIndex] == NULL)
		return(INVALID_INDEX);
	for (iReference = 0; iReference < pKeeper->PointerArray[iIndex]->cReferenceCount; ++iReference)
		pKeeper->PointerArray[iIndex]->Reference[iReference].fFlag = GetTTOReferenceBitFlagsCount(pKeeper, iIndex,pKeeper->PointerArray[iIndex]->Reference[iReference].uInOffset); 
	BitCount = 32;
	lDivResult = ldiv(pKeeper->PointerArray[iIndex]->cCount,BitCount);
	for (i = 0; i <= lDivResult.quot; ++i)
	{
		BitMask = 0x00000001;
		if (i == lDivResult.quot)
			BitCount = (uint16) lDivResult.rem;
		for (j = 0; j < BitCount; ++j)
		{
			TableOn = FALSE;
			ReferencesOn = TRUE;
			if (pKeeper->PointerArray[iIndex]->pBitFlags[i] & BitMask)
			{
				TableOn = TRUE;;
				for (iReference = 0; iReference < pKeeper->PointerArray[iIndex]->cReferenceCount; ++iReference)
				{
					if (i >= pKeeper->PointerArray[iIndex]->Reference[iReference].cAllocedBitFlags)
			  			continue; /* referencer never allocated this, but is turned on */
					if (pKeeper->PointerArray[iIndex]->Reference[iReference].fFlag &&  
						!(pKeeper->PointerArray[iIndex]->Reference[iReference].pBitFlags[i] & BitMask)) /* if this one isn't on */
						ReferencesOn = FALSE;
				}
				if (TableOn && ReferencesOn)
					++Count;
			}
			BitMask <<= 1;
		}
	}
	return Count;
}

/* ---------------------------------------------------------------------- */ 
void GetTTOBitFlag(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, uint16 usFlagBit, uint16* pusValue)
{
ldiv_t lDivResult;
uint16 BitIndex;
uint32 BitMask;
uint16 ShiftValue;
uint16 iReference;
BOOL TableOn = FALSE;
BOOL ReferencesOn = TRUE;
	
	*pusValue = 0;

 	if (pKeeper->PointerArray == NULL || 
 		iIndex < 0 ||
 		iIndex >= pKeeper->cRecordCount ||
 		pKeeper->PointerArray[iIndex] == NULL)
		return;
	lDivResult = ldiv(usFlagBit,32);
	BitIndex = (uint16) lDivResult.quot;
	if (BitIndex >= pKeeper->PointerArray[iIndex]->cAllocedBitFlags)
	  	return;  /* off the end of the array so far */
	ShiftValue = (uint16) lDivResult.rem;
	BitMask = 0x00000001 << ShiftValue;	 /* make a mask */
	if (pKeeper->PointerArray[iIndex]->pBitFlags[BitIndex] & BitMask)
	{	
		TableOn = TRUE;
		for (iReference = 0; iReference < pKeeper->PointerArray[iIndex]->cReferenceCount; ++iReference)
		{
			if (BitIndex >= pKeeper->PointerArray[iIndex]->Reference[iReference].cAllocedBitFlags)
			  	continue; /* referencer never allocated this, but is turned on */
			if (GetTTOReferenceBitFlagsCount(pKeeper, iIndex,pKeeper->PointerArray[iIndex]->Reference[iReference].uInOffset) &&
			   !(pKeeper->PointerArray[iIndex]->Reference[iReference].pBitFlags[BitIndex] & BitMask))
			   ReferencesOn = FALSE;
	   	}
	   	if (TableOn && ReferencesOn)
	   		*pusValue = 1;
	}
}
/* ---------------------------------------------------------------------- */ 
/* compress the classes, remove those that don't exist */
void GetTTOClassValue(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, uint16 usFlagBit, uint16* pusValue)
{
ldiv_t lDivResult;
uint32 BitMask;
uint16 BitCount;
uint16 BitIndex;
uint16 i, j;
uint16 Count = 0;
	
 	*pusValue = 0;
 	if (pKeeper->PointerArray == NULL || 
 		iIndex < 0 ||
 		iIndex >= pKeeper->cRecordCount ||
 		pKeeper->PointerArray[iIndex] == NULL)
		return;
	BitCount = 32;
	lDivResult = ldiv(usFlagBit,BitCount);
	BitIndex = (uint16) lDivResult.quot;
	if (BitIndex >= pKeeper->PointerArray[iIndex]->cAllocedBitFlags)
	  	return;  /* off the end of the array so far */
	BitMask = 0x00000001 << (uint16) lDivResult.rem;	 /* make a mask */
	if (!(pKeeper->PointerArray[iIndex]->pBitFlags[BitIndex] & BitMask))
		return;
	for (i = 0; i <= BitIndex; ++i)
	{
		BitMask = 0x00000001;
		if (i == BitIndex)
			BitCount = (uint16) lDivResult.rem;
		for (j = 0; j < BitCount; ++j)
		{
			if (pKeeper->PointerArray[iIndex]->pBitFlags[i] & BitMask)
				++Count;
			BitMask <<= 1;
		}
	}
	*pusValue = Count;
}
#if 0 /* not used */
/* ---------------------------------------------------------------------- */ 
int16 ModifyTTOTableReference (PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, PTABLEREFERENCE pTableReference, PREFERENCE Reference)
{
size_t oldRecordSize, newRecordSize;

 	if (pKeeper->PointerArray == NULL || 
 		iIndex < 0 ||
 		iIndex >= pKeeper->cRecordCount ||
 		pKeeper->PointerArray[iIndex] == NULL)
		return (0);
	oldRecordSize = sizeof(TABLEREFERENCE) + (sizeof(pKeeper->PointerArray[iIndex]->Reference[0]) * (pKeeper->PointerArray[iIndex]->cReferenceCount - 1)); 
	newRecordSize = sizeof(TABLEREFERENCE) + (sizeof(pTableReference->Reference[0]) * (pTableReference->cReferenceCount - 1));
	if (oldRecordSize < newRecordSize)
	{
		pKeeper->PointerArray[iIndex] = (PTABLEREFERENCE) Mem_ReAlloc(pKeeper->PointerArray[iIndex], newRecordSize);	
		if (pKeeper->PointerArray[iIndex] == NULL)
			return(0);
	}
	memcpy(	pKeeper->PointerArray[iIndex], pTableReference, sizeof(TABLEREFERENCE));	
	memcpy(pKeeper->PointerArray[iIndex]->Reference, Reference, sizeof(*Reference) * pTableReference->cReferenceCount);
	return 1;
}
/* ---------------------------------------------------------------------- */ 
PPTABLEREFERENCE GetTTOTableReferenceArray(PTABLEREFERENCEKEEPER pKeeper, uint16 *pCount)
{

	*pCount = pKeeper->cRecordCount;
	return(pKeeper->PointerArray);
}
#endif
	
/* ---------------------------------------------------------------------- */ 
uint16 PropogateTTOTableReferenceDelTableFlag(PTABLEREFERENCEKEEPER pKeeper, BOOL fVerbose)
{
int16 i, j;
uint16 uDelTableCount = 0;

	for (i = pKeeper->cRecordCount-1; i >= 0; --i)
	{
		if ((pKeeper->PointerArray[i] != NULL) && pKeeper->PointerArray[i]->fDelTable)  /* if this table is to be deleted, tell the other tables */
		{
			for (j = 0; j < pKeeper->PointerArray[i]->cReferenceCount; ++j)
			{
			  	if (pKeeper->PointerArray[i]->Reference[j].fDelIfDel) /* if this table is now to be deleted */
					if (pKeeper->PointerArray[i]->Reference[j].iTableIndex >= 0 && pKeeper->PointerArray[i]->Reference[j].iTableIndex	< pKeeper->cRecordCount) 
						if (pKeeper->PointerArray[pKeeper->PointerArray[i]->Reference[j].iTableIndex]->fDelTable == FALSE)
						{
							pKeeper->PointerArray[pKeeper->PointerArray[i]->Reference[j].iTableIndex]->fDelTable = TRUE;	
#ifdef _DEBUG
							if (fVerbose == TRUE)
							{
							char szBuffer[80];
								sprintf(szBuffer, "Propogating fDelFlag to table %d from table %d.", pKeeper->PointerArray[i]->Reference[j].iTableIndex, i);
								DebugMsg(szBuffer, "", 0);
							}
#endif
						}
			}
			++uDelTableCount;
		}
	}
   	return(uDelTableCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttmem.c ===
/**************************************************************************
 * module: TTMEM.C
 *
 * author: Louise Pathe
 * date:   Sept 1997
 * Copyright 1990-1996. Microsoft Corporation.
 *
 * Routines to allocate, free, and track memory
 *
 **************************************************************************/


/* Inclusions ----------------------------------------------------------- */

#include <stdlib.h>
#include <string.h> 
#include <memory.h>

/* MEMTRACK defined on command line for compiler */

#ifdef MEMTRACK	   /* can only have MEMTRACK in DEBUG mode, as this code isn't reentrant */
#ifndef _DEBUG
#undef MEMTRACK
#endif
#endif
                   
#include "typedefs.h"                  
#include "ttmem.h"
#ifdef MEMTRACK
#include "util.h" 
#endif


#ifdef MEMTRACK

/* structure definitions ------------------------------------------------ */
/* linked list of memory from which to parcel out pointers */
typedef struct memory *PMEMORY;
struct memory
{
   void *pBlock;
   size_t uBlockSize;  
   PMEMORY pNext;  /* next memory structure */ 
   PMEMORY pLast;
};
  
/* static variable definitions ------------------------------------------- */
static PMEMORY f_pMemHead = NULL;  /* pointer to head of memory chain */  
static PMEMORY f_pMemTail = NULL;  /* pointer to tail of memory chain */
static PMEMORY f_pMemAvail = NULL; /* pointer to a freed up block */

#endif  
/* ----------------------------------------------------------------------- */
int16 Mem_Init(void)
{
/* Initialize memory manager internal structures */
#ifdef MEMTRACK
	if (f_pMemHead != NULL)
		return(MemErr);
#ifdef _MAC
	if ((f_pMemHead = (PMEMORY) NewPtr(sizeof(*f_pMemHead))) == NULL)
	  	return(MemErr);
#else
	if ((f_pMemHead = (PMEMORY) malloc(sizeof(*f_pMemHead))) == NULL)
	  	return(MemErr);
#endif // _MAC
	f_pMemHead->pBlock = NULL;
	f_pMemHead->uBlockSize = 0; 
	f_pMemHead->pNext = NULL;  
	f_pMemHead->pLast = NULL;  
	f_pMemTail = f_pMemHead; 
#endif
	return(MemNoErr);	
}
/* --------------------------------------------------------------------- */
void Mem_End(void)  
/* free all memory previously allocated and free memory structure */
{
#ifdef MEMTRACK
PMEMORY pMemCurr; 
PMEMORY pMemLast; 


	for (pMemCurr = f_pMemHead; pMemCurr != NULL; )
	{
	   pMemLast = pMemCurr->pNext;
	   if (pMemCurr->pBlock != NULL) 
	   {
		   DebugMsg("Memory Leak!", "", 0);
#ifdef _MAC
		   DisposPtr(pMemCurr->pBlock);
#else
		   free(pMemCurr->pBlock);
#endif // _MAC

	   }
#ifdef _MAC
	   DisposPtr((char *)pMemCurr);
#else
	   free(pMemCurr);
#endif // _MAC
	   pMemCurr = pMemLast;
	}   
	f_pMemHead = NULL;
	f_pMemTail = NULL;
	f_pMemAvail = NULL;
#endif
}

/* --------------------------------------------------------------------- */
void *Mem_Alloc(CONST size_t size)
{  
void *pBlock;

#ifdef _MAC
	pBlock = NewPtr(size);
#else
	pBlock = malloc(size);
#endif // _MAC

	if (pBlock == NULL)
		return(NULL);
  	memset(pBlock,0,size);	/* set it all to zeros */

#ifdef MEMTRACK

    if (f_pMemTail == NULL)
    	return (NULL);

	if (f_pMemAvail != NULL) /* we have one in the list already to work with */
	{
		f_pMemAvail->pBlock = pBlock;
		f_pMemAvail->uBlockSize = size;
		f_pMemAvail = NULL; /* don't have one now */
	}
	else
	{
		f_pMemTail->pBlock = pBlock;
 		f_pMemTail->uBlockSize = size;

#ifdef _MAC
		if ((f_pMemTail->pNext = (PMEMORY) NewPtr(sizeof(*f_pMemTail))) == NULL)
			  return(NULL); 
#else
		if ((f_pMemTail->pNext = (PMEMORY) malloc(sizeof(*f_pMemTail))) == NULL)
			  return(NULL); 
#endif // _MAC
				
		f_pMemTail->pNext->pLast = f_pMemTail;
		f_pMemTail = f_pMemTail->pNext;
		f_pMemTail->pBlock = NULL;
		f_pMemTail->uBlockSize = 0;
		f_pMemTail->pNext = NULL;  
	}
#endif
   	return(pBlock);  
       
}
/* --------------------------------------------------------------------- */
void Mem_Free(void *pBlock)
/* free up a block of data */   
{
#ifdef MEMTRACK
PMEMORY pMemCurr; 
#endif

    if (pBlock == NULL) 
        return;
#ifdef MEMTRACK
	for (pMemCurr = f_pMemTail; pMemCurr != NULL; pMemCurr = pMemCurr->pLast )
	{
	   	if (pMemCurr->pBlock == pBlock)
	   	{
#ifdef _MAC
	   		DisposPtr(pMemCurr->pBlock);
#else
	   		free(pMemCurr->pBlock);
#endif // _MAC
			pMemCurr->pBlock = NULL;
			pMemCurr->uBlockSize = 0;
			f_pMemAvail = pMemCurr;  /* set this so we use it next time */
			break;
		}
	}
#else
#ifdef _MAC
	DisposPtr(pBlock);
#else
	free(pBlock);
#endif // _MAC
#endif
}

/* --------------------------------------------------------------------- */
/* note - Mem_Realloc does NOT null out the extra space that is being allocated ! */
/* --------------------------------------------------------------------- */
void *Mem_ReAlloc(void * pOldPtr, CONST size_t newSize)
{  
#ifdef MEMTRACK
PMEMORY pMemCurr; 
#endif

    if (pOldPtr == NULL)   /* lcp - Change from return NULL to return something */
        return Mem_Alloc(newSize);
#ifdef MEMTRACK
	for (pMemCurr = f_pMemTail; pMemCurr != NULL; pMemCurr = pMemCurr->pLast )
	{
	   	if (pMemCurr->pBlock == pOldPtr)
	   	{
#ifdef _MAC
			pMemCurr->pBlock = NewPtr(newSize);
			BlockMove(pOldPtr,pMemCurr->pBlock,newSize);
			DisposPtr(pOldPtr);
#else
			pMemCurr->pBlock = realloc(pOldPtr, newSize);
#endif // _MAC

			pMemCurr->uBlockSize = newSize;
			return(pMemCurr->pBlock);
		}
	}
	return(NULL);
#else
#ifdef _MAC
	{
		void * pNewPtr;
		Size OldPtrSize;
		OldPtrSize = GetPtrSize(pOldPtr);
		if ((Size) newSize == OldPtrSize)
			return pOldPtr;
	
		SetPtrSize((Ptr) pOldPtr,newSize);  /* try to just set the size */
		if (MemError() == noErr)  
 			pNewPtr = pOldPtr;

		else if ((Size) newSize > OldPtrSize)	 /* need to get a new spot */
		{
			pNewPtr = NewPtrClear(newSize);
			if (pNewPtr != NULL)
				BlockMove(pOldPtr, pNewPtr, OldPtrSize);
 			DisposPtr((Ptr)pOldPtr);
		}
		return pNewPtr;
	}
#else
	return realloc(pOldPtr, newSize);
#endif // _MAC

#endif

}
/* --------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttofile.c ===
/**************************************************************************
 * module: TTOFILE.C
 *
 * author: Louise Pathe
 * date:   October 1994
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * Routines to read from and write to files
 *
 **************************************************************************/


/* Inclusions ----------------------------------------------------------- */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "typedefs.h" 
#include "ttofile.h"

#ifdef _DEBUG
int16 WriteTextLine(FILE * CONST pFile, char * CONST szText) 
{  
	if (pFile != NULL)
	  if (fputs(szText,pFile) == EOF)
	    return(FileErr);
    return(FileNoErr);
} 
#endif
 
/* --------------------------------------------------------------------- */
int16 ReadTextLine(char *szText, int16 CONST bufsize, char **pFileArray, int16 iFileLine)
{

    if (pFileArray[iFileLine] == NULL)
    	return(FileEOF); 
    strncpy(szText, pFileArray[iFileLine],bufsize); /* copy over the string from current line */  
    return(FileNoErr);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttodepen.h ===
/*
  * ttodepen.h: Interface file for ttodepen.c -- Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  * used to keep track of dependencies when deleting and modifying tables 
*/
  
#ifndef TTODEPEN_DOT_H_DEFINED
#define TTODEPEN_DOT_H_DEFINED

#define INVALID_INDEX -1

/* used to keep track of dependencies when deleting and modifying tables */
typedef struct reference REFERENCE;
typedef struct reference *PREFERENCE, **PPREFERENCE;
struct reference {
	int16 iTableIndex;	  /* index of table that references this table, if -1 the table is no longer referenced */
	uint16 uInOffset;  /* unique identifier of this reference - for identification purposes */
	uint16 uFileOffset;		  /* offset where this table's offset is written, relative to the uBaseOffset */
	uint16 uOffsetValue;   /* value relative to the uBaseOffset of the table referenced */
	uint16 uBaseOffset;   /* Base offset of the table that references this table */
	uint16 fDelIfDel;  /* delete referencing table if this reference deleted */
	uint32 *pBitFlags;  /* FFFFFFFF means 32 elements are to be kept */
	uint16 fFlag;    /* used during count calculations inside ttodepen.c */
	uint16 cAllocedBitFlags; /* number of 32 Bit Flags alloced already */
	uint16 uOldSingleSubstFormat1DeltaValue; /* Special case for processing Coverage for this table */ 
	uint16 uNewSingleSubstFormat1DeltaValue; /* Special case for processing Coverage for this table */ 
};					

typedef struct tablereference TABLEREFERENCE;
typedef struct tablereference *PTABLEREFERENCE, **PPTABLEREFERENCE;
struct tablereference {
	uint16 fDelTable;	/* TRUE or FALSE setting */
	uint16 cCount;		/* original number of elements in table */
	uint32 ulDefaultBitFlag; /* 0 for ClassDef, 0xFFFFFFFF for Coverage */
	uint32 *pBitFlags;  /* FFFFFFFF means 32 elements are to be kept */
	uint16 cAllocedBitFlags; /* number of 32 Bit Flags alloced already */
	uint16 cReferenceCount;		/* count of other records that refer to this one */
	REFERENCE Reference[1];  /* array of indices to referencing tables */ 
};

typedef struct tablereferencekeeper *PTABLEREFERENCEKEEPER;	 
typedef struct tablereferencekeeper TABLEREFERENCEKEEPER;	 

struct tablereferencekeeper	  /* housekeeping structure */
{  
	PPTABLEREFERENCE PointerArray; /* array of pointers to TABLEREFERENCEs */
	uint16 cAllocedRecords;
	uint16 cRecordCount;
};

void CreateTTOTableReferenceArray(PTABLEREFERENCEKEEPER pKeeper);
void DestroyTTOTableReferenceArray(PTABLEREFERENCEKEEPER pKeeper);
PTABLEREFERENCE GetTTOTableReference(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex);
int16 AddTTOTableReference(PTABLEREFERENCEKEEPER pKeeper, PTABLEREFERENCE pTableReference, uint32 ulDefaultBitFlag);
void AddTTOTableReferenceReference(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, PREFERENCE Reference);
void SetTTOReferenceBitFlag(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, uint16 uInOffset, uint16 usFlagBit, uint16 usValue);
void SetTTOBitFlag(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, uint16 usFlagBit, uint16 usValue);
void GetTTOBitFlag(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, uint16 usFlagBit, uint16 *pusValue );
void SetTTOTableReferenceDefaultBitFlag(PTABLEREFERENCEKEEPER pKeeper, uint16 iIndex, uint32 ulDefaultBitFlag);
int16 ModifyTTOTableReference (PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, PTABLEREFERENCE pTableRecord, PREFERENCE Reference);
PPTABLEREFERENCE GetTTOTableReferenceArray(PTABLEREFERENCEKEEPER pKeeper, uint16 *pCount);
int16 GetTTOBitFlagsCount(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex);
void GetTTOClassValue(PTABLEREFERENCEKEEPER pKeeper, int16 iIndex, uint16 usFlagBit, uint16* pusValue);
uint16 PropogateTTOTableReferenceDelTableFlag(PTABLEREFERENCEKEEPER pKeeper, BOOL fVerbose);

#endif /* TTODEPEN_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttofmt.h ===
/*
  * TTOFMT.h: interface file for gposfmt.c etc -- Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  * This file must be included in order to access the g_XXXXFmt arrays
  *
  */
  
#ifndef TTOFMT_DOT_H_DEFINED
#define TTOFMT_DOT_H_DEFINED


extern char * FAR g_GPOSFmt[]; /* from GPOSFmt.c */
extern char * FAR g_GSUBFmt[]; /* from GSUBFmt.c */
extern char * FAR g_GDEFFmt[]; /* from GDEFFmt.c */
extern char * FAR g_BASEFmt[]; /* from BASEFmt.c */
extern char * FAR g_JSTFFmt[]; /* from JSTFFmt.c */

#endif /* TTOFMT_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttoerror.c ===
/**************************************************************************
 * module: TTOERROR.C
 *
 * author: Louise Pathe
 * date:   October 1994
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * Routines which print error messages.
 *
 **************************************************************************/


/* Inclusions ----------------------------------------------------------- */

#include <stdlib.h>
#include <stdio.h> 
#include <string.h>  

#include "typedefs.h"
#include "ttofile.h"
#include "ttoerror.h" 

#ifdef _DEBUG

#define WRITETEXTLINE(X,Y) WriteTextLine(X,Y)

/* constant definitions -------------------------------------------------- */  
#define MaxFileNameLen 80    

/* global variable definitions ------------------------------------------- */  
char FAR g_szErrorBuf[MAXBUFFERLEN];      /* used by calling routines */

/* static variable definitions ------------------------------------------- */  
static FILE * f_errorfile; 
static char f_szErrorBuf[MAXBUFFERLEN];
static char f_szFileName[MaxFileNameLen+1];

/* function definitions -------------------------------------------------- */  
/* ----------------------------------------------------------------------- */ 
/* If  a simple error message is desired, specify cLineNumber = 0*/
int16 Error( char * CONST msg, uint16 CONST cLineNumber, int16 CONST errorCode )
{
	if (f_errorfile != NULL)  
	{ 
		if (cLineNumber > 0)
   			sprintf( f_szErrorBuf, "Error: %s line %d: %s\n", f_szFileName, cLineNumber, msg );
   		else
   			sprintf( f_szErrorBuf, "Error: %s\n", msg );
   			
   		if (WRITETEXTLINE(f_errorfile, f_szErrorBuf) != FileNoErr)   
   		{
   			fprintf(stderr,"Error writing to error file.\n");
   			fprintf(stderr,f_szErrorBuf);  
   		}
   	}
   	if (g_szErrorBuf != msg) /* not the same string */
   		strcpy(g_szErrorBuf, msg); /* modify to signify an error has occurred */
   	return(errorCode);
}
   
/* ----------------------------------------------------------------------- */
void Warning( char * CONST msg, uint16 CONST cLineNumber)
{
	if (f_errorfile != NULL)  
	{
		if (cLineNumber > 0) 
   			sprintf( f_szErrorBuf, "Warning: %s line %d: %s\n", f_szFileName, cLineNumber, msg );		
        else
   			sprintf( f_szErrorBuf, "Warning: %s\n", msg );
   		if (WRITETEXTLINE(f_errorfile, f_szErrorBuf) != FileNoErr)   
   		{
   			fprintf(stderr,"Error writing to error file.\n");
   			fprintf(stderr,f_szErrorBuf);  
   		}
   	}
   	if (g_szErrorBuf != msg) /* not the same string */
   		strcpy(g_szErrorBuf, msg); /* modify to signify an error has occurred */
}

/* ----------------------------------------------------------------------- */    
/* Set the file we are reporting to */
void SetErrorFile( FILE * CONST pFile)
{
  f_errorfile = pFile;
}
  
/* ----------------------------------------------------------------------- */  
/* Set the Name of the file we are reading */
void SetErrorFilename( char * CONST szFileName)
{
	strncpy(f_szFileName, szFileName, MaxFileNameLen);	
}
/* ----------------------------------------------------------------------- */

#endif DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttoerror.h ===
/*
  * TTOError.h: Interface file for TTOError.c -- Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  * This file must be included in order to use the access functions for the Error handler.
  *
  */
  
#ifndef TTOERROR_DOT_H_DEFINED
#define TTOERROR_DOT_H_DEFINED 
    
#ifdef _DEBUG
extern char FAR g_szErrorBuf[];  /* 256 byte byffer available for error reporting */

int16 Error( char * CONST, uint16 CONST, int16 CONST);
/* Error(szErrorString, cLineNumber, ErrorCode)
  *                                
  * szErrorString -- INPUT
  *   error string to report 
  *
  * cLinenumber -- INPUT
  *   the line in the input file where the error occured 
  *
  * ErrorCode -- INPUT
  *   the code to be returned by the function
  */

void Warning( char * CONST, uint16 CONST);
/* Warning(szWarningString, cLineNumber)
  * 
  * szWarningString -- INPUT
  *   warning string to report
  *
  * cLinenumber -- INPUT
  *   the line in the input file where the error occured
  */

void SetErrorFile( FILE * CONST);
/* SetErrorFile(pErrorFile)
  *  sets the local ErrorFile variable in the Error Module
  *  If this is null, errors will get sent to console
  *
  * pErrorFile -- INPUT
  *  pointer to File handle of File opened in text mode for write.
  *  TTOConsole means Console
  *  TTONoOutput means No Output.
  */

void SetErrorFilename( char * CONST szFileName);
/* SetErrorFilename(pErrorFile)
  *  sets the local Filename variable in the Error Module
  *
  * szFileName -- INPUT
  *  string containing filename. May be "" 
  */



#endif

#endif TTOERROR_DOT_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttofile.h ===
/*
  * ttofile.h: Interface file for ttofile.c -- Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  * This file must be included in order to use the access functions for the file handler.
  *
  */
/* include typedefs.h for int16 definition */
 
#ifndef TTOFILE_DOT_H_DEFINED
#define TTOFILE_DOT_H_DEFINED        

#define FileNoErr 0
#define FileErr -1 
#define FileEOF -2 


#ifdef _DEBUG

/* ----------------------------------------------------------------------- */
int16 WriteTextLine(FILE * CONST , char * CONST); 
/* WriteTextLine(pFile, szText)
  * Write a string of text to a file including a newline character
  *
  * pFile -- INPUT
  *  File pointer to file opened in text mode for write
  *  If file pointer is NULL don't write output 
  *
  * szText -- INPUT
  *  string of text to write to file
  *
  * RETURN VALUE
  * FileNoErr if OK
  * FileErr if not OK
  */
#endif

/* ----------------------------------------------------------------------- */
int16 ReadTextLine(char * szText, int16 CONST sBufSize, char **pFileArray, int16 iFileLine);
/* ReadTextLine(szText, sBufSize)
  * Read a string of text from a file up to the newline character
  *
  * szText -- OUTPUT
  *  buffer to be filled with line from file 
  *
  * sBufSize -- INPUT
  *  maximum size of szText buffer
  *
  * RETURN VALUE
  * FileNoErr if OK
  * FileErr if not OK
  */
#endif /* TTOFILE_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttostruc.h ===
/*
  * TTOSTRUC.h: structure definition file for TTOASM.EXE -- Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  * This file must be included in order to create or interpret structure_def structures
  *   for Format Description files.
  *
  */
  
#ifndef TTOSTRUC_DOT_H_DEFINED
#define TTOSTRUC_DOT_H_DEFINED

/* Element Type for uType */
#define ETuint8 1	
#define ETint8 2
#define ETuint16 3
#define ETint16 4
/* #define ETuint32 5  */
#define ETint32 6
#define ETfixed32 7
#define ETTag 8
#define ETTableOffset 9
#define ETPackedInt2 10
#define ETPackedInt4 11
#define ETPackedInt8 12
#define ETGlyphID 13 
#define ETGSUBLookupIndex 14
#define ETGSUBFeatureIndex 15
#define ETGPOSLookupIndex 16
#define ETGPOSFeatureIndex 17
#define ETCount 18
/* inferred types */
#define ETRecord 19
#define ETClassMember 20
#define ETMaxUType 20 
/* array type can be combined with any above */
#define ETArray 0x8000  
#define ETUdef 0x7E00                                  
                           
#define MMMinGIndex 1    /* Must be in this order, do not change */
#define MMMaxGIndex 2
#define MMMinLIndex 3
#define MMMaxLIndex 4
#define MMMinFIndex 5
#define MMMaxFIndex 6                           

#define MaxMinMax 6   

/* strings shared between the Format File and the Source Data File */
                           
#define SZMINGLYPHID "MINGLYPHID"      
#define SZMAXGLYPHID "MAXGLYPHID"
#define SZMINLOOKUPCOUNT "MINLOOKUPCOUNT"
#define SZMAXLOOKUPCOUNT "MAXLOOKUPCOUNT"
#define SZMINFEATURECOUNT "MINFEATURECOUNT"
#define SZMAXFEATURECOUNT "MAXFEATURECOUNT"  
#define SZNULL "NULL"
#define SZNEGNULL "NEGNULL"
#define SZDEFINE "DEFINE"

/* uOperator value in Calc_record*/
#define CalcOperIdentity 0
#define CalcOperAdd 1
#define CalcOperSubtract 2
#define CalcOperMultiply 3
#define CalcOperDivide 4  
/* uFunction value in Calc_record */
#define CalcFuncBitCount0F 5
#define CalcFuncBitCountF0 6
#define CalcFuncCoverageCount 7
#define CalcFuncClassCount 8 
#define CalcFuncCheckRangeRecord 9   

#define StrucTypeHEAD 1
#define StrucTypeTABLE 2
#define StrucTypeRECORD 3
#define StrucTypeCLASS 4 

#define MaxParameterCount 5 

#define SymbElementTypeTable 1
#define SymbElementTypeRecord 2 
#define SymbElementTypeParameter 3  
#define SymbElementTypeByte 4
#define SymbElementTypeIndex 5 

/* these next four must not be modified */
#define ConfigIGSUBLookupIndex 0
#define ConfigIGSUBFeatureIndex	1
#define ConfigIGPOSLookupIndex 2
#define ConfigIGPOSFeatureIndex	3
#define ConfigDelNone 4

#define MinIndexValue ConfigIGSUBLookupIndex

typedef struct calc_record *PCALC_LIST;

struct calc_record {
	int32 lValue;	 	/* numeric value instead of symbol. */  
	uint16 uMinMax;	 	/* index for global MinMax defines (such as MMMinGIndex), 0 means none */  
	uint16 uSymbElementType;	/* 0 = none, 1 = $T, 2 = $R, 3 = $P */   
	uint16 iElementIndex;	 /* index to element in calculation - 1 based */ 
	uint16 uOperation;	/* operation to be performed on accumulated value */
	uint16 uFunction; 	/* function to be performed on stuff in the function list. */
	PCALC_LIST pFunctionList; /* calc list of stuff in function */
	PCALC_LIST pNext;	/* next record to include in calc. If NULL, end of calc */
};

typedef struct config_record *PCONFIG;

struct config_record {
	uint16 uFlag; 			 /* DelNone, or Index info */
};

typedef struct parameter_record *PPARAM_LIST;

struct parameter_record {
	uint16 iElementIndex;	/* which element or passed in parameter - 1 based */   
	uint16 uSymbElementType; /* - see calc_record above. */
	PPARAM_LIST pNext;
};

typedef struct structure_element *PELEMENT_LIST;
typedef struct structure_element ELEMENT_LIST;

struct structure_element {
	uint16 uType;			/* 16 bits, see Element types above */
	int16 iStructureIndex;  /* used for Structure Type for Table Offset,  Record or class member*/
    char * szComment;  		/* Comment string for this element, used by dissassembler */
	PCALC_LIST pMinCalc;  	/* calc record representing minimum value for this element */
	PCALC_LIST pMaxCalc;  	/* if pMaxCalc is NULL, pMinCalc is identity */
	PCALC_LIST pCountCalc;  /* used to Calculate array Count */
	PPARAM_LIST pParamList;	/* list of parameters used for TableOffset types */  
	PCONFIG pConfig;        /* record for ffconfig use */
	PELEMENT_LIST pNext;	/* when NULL, this is the last element */
};

typedef struct structure_def * PSTRUCTURE_DEF;
typedef struct structure_def STRUCTURE_DEF; 

struct structure_def {
	PELEMENT_LIST pFirst;
	uint16 cParameters;   /* number of parameters this structure will reference */ 
	uint16 uSymbElementType;	/* 0 = none, 1 = $T, 4 = $B - used for Classes only - for dissassembler */   
	uint16 iElementIndex;  /* which parameter or byte offset identifies this structure (for Classes only - used by dissassembler) */
    char * szComment;  /* Comment string, used by dissassembler */
};     

typedef struct structure_list * PSTRUCTURE_LIST;
typedef struct structure_list	STRUCTURE_LIST;

struct structure_list {  
	uint16 cStructures;      /* number of structures in pStructureDef array */  
	int16 iHeadIndex;		/* index to the HEAD structure - needed for disassembler */
	PSTRUCTURE_DEF pStructureDef;   /* array of structure_def structures */
	void * pSymbolTable; /* Format File Symbol Table - void because ttoasm.c needn't know about it */
	void * pKeySymbolTable; /* Keyword Symbol Table - needed to avoid statics in ttfsub.lib */
};	

/* Symbol stuff */
typedef struct ffsymbol_data *PFFSYMBOL_DATA;
typedef struct ffsymbol_data FFSYMBOL_DATA;

struct ffsymbol_data {
	uint16 uSymbolType;  /* TABLE, CLASS, RECORD, HEAD */
	int16 iStructureIndex;  /* index into structure_list.pStructureDef array of this structure */
};  
	

#endif /*  TTOSTRUC_DOT_H_DEFINED  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttoutil.c ===
/**************************************************************************
 * module: TTOUTIL.C
 *
 * author: Louise Pathe
 * date:   October 1994
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * utility module for tto stuff
 *
 **************************************************************************/

/* Inclusions ----------------------------------------------------------- */

#include <stdlib.h>
#include <stdio.h> 
#include <ctype.h>  
#include <string.h>

#include "typedefs.h" /* for CONST definition */
#include "ttoerror.h" 
#include "ttoutil.h"
/* ---------------------------------------------------------------------- */ 
/* check that there is no more data on a line */   
void CheckLineClear(char * CONST szBuffer, uint16 CONST cLineNumber)
{
uint16 iBufferIndex;

	for (iBufferIndex = 0; *(szBuffer+iBufferIndex) != '\0'; ++iBufferIndex)
	{
	  	if (*(szBuffer+iBufferIndex) == ';')
	  		break;
	  	if (!isspace(*(szBuffer+iBufferIndex)))
	  	{
#ifdef _DEBUG
			sprintf(g_szErrorBuf, "Extra characters \"%s\"",szBuffer+iBufferIndex);
	  	    Warning(g_szErrorBuf,cLineNumber);
#endif
	  	    return;
	  	}
	}
}

long HexStringToInt(
        const char *nptr
        )
{
        int c;              /* current char */
        long total;         /* current total */

        total = 0;
		c = (int)(unsigned char)*nptr++;

        while (isxdigit(c)) {
			if (isdigit(c))
				total = 16 * total + (c - '0');     /* accumulate digit */
			else if ( (c >= 'A') && (c <='F') ) /* uppercase A..F */
				total = 16 * total + (c - 'A' + 10);     /* accumulate digit */
			else /* lowercase a..f */
				total = 16 * total + (c - 'a' + 10);     /* accumulate digit */

            c = (int)(unsigned char)*nptr++;    /* get next char */
        }

            return total;   /* return result, negated if necessary */
}

/* ---------------------------------------------------------------------- */     
/* convert a number from ascii to integer */
int16 ConvertNumber(char * CONST szBuffer, int32 * plNumber, uint16 CONST cLineNumber)
{
uint16 iBufferIndex = 0; 
int16 iWordIndex = 0;
char szWord[MAXBUFFERLEN];

	if (_strnicmp(szBuffer,"0x",2) == 0) /* we're looking at a hex value */  
	{
	  	iBufferIndex += 2;  /* skip the 0x */   
		while (isxdigit(*(szBuffer+iBufferIndex)))
			*(szWord+iWordIndex++) = *(szBuffer+iBufferIndex++); /* copy the hex integer character over */   				  	
	}
	else
	{   
		if (*(szBuffer+iBufferIndex) == '+' || *(szBuffer+iBufferIndex) == '-')
		   *(szWord+iWordIndex++) = *(szBuffer+iBufferIndex++); /* copy the sign */
		if (!isdigit(*(szBuffer+iBufferIndex)))
#ifdef _DEBUG
			return Error("Missing number.", cLineNumber, INVALID_NUMBER_STRING);  /* syntax error! */
#else
			return INVALID_NUMBER_STRING;
#endif
		while (isdigit(*(szBuffer+iBufferIndex)))
			*(szWord+iWordIndex++) = *(szBuffer+iBufferIndex++); /* copy the integer character over */  
	}
	*(szWord+iWordIndex) = '\0';
/*     CheckLineClear(szBuffer + iBufferIndex,cLineNumber);   */
    
	if (_strnicmp(szBuffer,"0x",2) == 0) /* we're looking at a hex value */  
		*plNumber = (int32) HexStringToInt(szWord);  
	else
		*plNumber = (int32) atol(szWord);  
	return(iBufferIndex);
}

/* ---------------------------------------------------------------------- */  
/* this is platform dependent */        
/* convert from an ascii string to a tag long value */
void ConvertTag(char * CONST szBuffer, int32 * plNumber, uint16 CONST cLineNumber)
{
uint16 iBufferIndex = 1;    /* move past the " */
int16 iWordIndex = 0;
uint8  *tag_bytes = (uint8 *) plNumber;


	while ((*(szBuffer+iBufferIndex) != *szBuffer) && (iWordIndex < 4) && (*(szBuffer+iBufferIndex) != '\0'))
#ifdef INTEL
		tag_bytes[3-iWordIndex++] = *(szBuffer+iBufferIndex++); /* copy the tag character over in reverse order */  
#else
		tag_bytes[iWordIndex++] = *(szBuffer+iBufferIndex++); /* copy the tag character over */  
#endif /* INTEL */
#ifdef _DEBUG
	if (*(szBuffer+iBufferIndex) != *szBuffer) 
		Warning("Tag string malformed. Maximum 4 characters.", cLineNumber);
#endif
	while (iWordIndex < 4) 
		tag_bytes[3-iWordIndex++] = ' '; /* fill with spaces */  
}
/* ---------------------------------------------------------------------- */    

void WriteByteToBuffer(unsigned char * OutputBuffer, uint16 uCurrentOffset, uint8 intel_byte)
{  
	if (OutputBuffer != NULL)
		*(OutputBuffer + uCurrentOffset) = intel_byte;  /* copy into buffer */		
}
/* ---------------------------------------------------------------------- */    
void WriteWordToBuffer(unsigned char * OutputBuffer, uint16 uCurrentOffset, uint16 intel_word)
{
uint8  *intel_bytes = (uint8 *) &intel_word;
uint16 motorola_word; 
uint8 *motorola_bytes = (uint8 *) &motorola_word;
uint16 i;			

	if (OutputBuffer != NULL)
    {
#ifdef INTEL
	   	motorola_word = ( ( ((uint16) intel_bytes[0]) << 8 ) +  /* swap bytes */
	                    ((uint16) intel_bytes[1]) );
#else
		motorola_word = intel_word; 
#endif /* INTEL */
		for (i= 0; i < 2; ++i)
		*(OutputBuffer + uCurrentOffset+i) = motorola_bytes[i];  /* copy into buffer */ 
	}  
}
/* ---------------------------------------------------------------------- */    
void WriteLongToBuffer(unsigned char * OutputBuffer, uint16 uCurrentOffset, uint32 intel_long)
{
uint8  *intel_bytes = (uint8 *) &intel_long;
uint32 motorola_long; 
uint8 *motorola_bytes = (uint8 *) &motorola_long;
uint16 i;			

	if (OutputBuffer != NULL)
	{
#ifdef INTEL
	   	motorola_long = ( ( ((uint32) intel_bytes[0]) << 24 ) +     /* swap bytes */
                  ( ((uint32) intel_bytes[1]) << 16 ) +
                  ( ((uint32) intel_bytes[2]) << 8 ) +
                    ((uint32) intel_bytes[3]) );
#else
		motorola_long = intel_long; 
#endif /* INTEL */
		for (i= 0; i < 4; ++i)
		*(OutputBuffer + uCurrentOffset+i) = motorola_bytes[i];  /* copy into buffer */  
	} 
}
/* ---------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\util.c ===
/**************************************************************************
 * module: UTIL.C
 *
 * author: Louise Pathe
 * date:   Sept 1995
 * Copyright 1990-1997. Microsoft Corporation.
 *
 * utility module 
 *
 **************************************************************************/

/* Inclusions ----------------------------------------------------------- */
#include <stdlib.h>
#ifdef _DEBUG
#include <stdio.h>
#endif

#include "typedefs.h"
#include "util.h"

/* ---------------------------------------------------------------------- */
/* stolen from ffconfig mtxcalc.c */
uint16 log2( uint16 arg )
   {
   if ( arg < 2 )     return( 0 );
   if ( arg < 4 )     return( 1 );
   if ( arg < 8 )     return( 2 );
   if ( arg < 16 )    return( 3 );
   if ( arg < 32 )    return( 4 );
   if ( arg < 64 )    return( 5 );
   if ( arg < 128 )   return( 6 );
   if ( arg < 256 )   return( 7 );
   if ( arg < 512 )   return( 8 );
   if ( arg < 1024 )  return( 9 );
   if ( arg < 2048 )  return( 10 );
   if ( arg < 4096 )  return( 11 );
   if ( arg < 8192 )  return( 12 );
   if ( arg < 16384 ) return( 13 );
   if ( arg < 32768 ) return( 14 );
   return( 15 );
   }

/* ---------------------------------------------------------------------- */
int16 ValueOKForShort(uint32 ulValue)
{
	if (ulValue & 0xFFFF0000) /* any high bits turned on */
		return(0);
	return(1);
}

#ifdef _DEBUG
/* ---------------------------------------------------------------------- */
void DebugMsg( char * CONST msg1, char * CONST msg2, uint16 CONST cLineNumber)
{
char szErrorBuf[256];

	if (cLineNumber == 0)
		sprintf(szErrorBuf,"DEBUG: %s %s.\n", msg1, msg2);
	else
		sprintf(szErrorBuf,"DEBUG: %s %s. Line: %d\n", msg1, msg2, cLineNumber);
	fprintf(stdout, szErrorBuf);

}
/* ---------------------------------------------------------------------- */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\ttoutil.h ===
/*
  * TTOUTIL.h: utility functions for TTOASM.EXE -- Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  * This file must be included in order to use the utility functions
  *
  */
  
#ifndef TTOUTIL_DOT_H_DEFINED
#define TTOUTIL_DOT_H_DEFINED

#define INVALID_NUMBER_STRING -1

void CheckLineClear(char * CONST, uint16 CONST);
/*
void CheckLineClear(char * CONST szBuffer, uint16 CONST cLineNumber)
   
*/
   
int16 ConvertNumber(char * CONST, int32 *, uint16 CONST);
/*
int16 ConvertNumber(char * CONST szBuffer, int32 * sNumber, uint16 CONST cLineNumber)
 
*/
                   
void ConvertTag(char * CONST szBuffer, int32 * sNumber, uint16 CONST cLineNumber);

void WriteByteToBuffer(unsigned char *, uint16, uint8);
/*int16 WriteByte(char * OutputBuffer, uint16 uCurrentOffset, uint8 lNumber) */
void WriteWordToBuffer(unsigned char *, uint16, uint16);
/* int16 WriteWord(char * OutputBuffer, uint16 uCurrentOffset, uint16 lNumber)  */
void WriteLongToBuffer(unsigned char *, uint16, uint32);
/* int16 WriteLong(char * OutputBuffer, uint16 uCurrentOffset, uint32 lNumber)  */

#endif /* TTOUTIL_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\subset\ttfdelta\util.h ===
/*
  * util.h: Interface file for util.c - Written by Louise Pathe
  *
  * Copyright 1990-1997. Microsoft Corporation.
  * 
  */
  
#ifndef UTIL_DOT_H_DEFINED
#define UTIL_DOT_H_DEFINED        


uint16 log2( uint16 arg );
int16 ValueOKForShort(uint32 ulValue);
void DebugMsg( char * CONST, char * CONST, uint16 CONST);
#endif /* UTIL_DOT_H_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fnterr.h ===
#ifndef _FNTERR_H
#define _FNTERR_H
/**********************************************************************
	
	fnterr.h -- Error Support Routines prototypes.

	(c) Copyright 1992  Microsoft Corp.
	All rights reserved.

	This header file provides prototypes for the fnterr.c 
	 source module.  This module keys on the #define FSCFG_FNTERR
	which is defined in fsconfig.h

	 7/28/92 dj         First cut.

 **********************************************************************/


#ifdef FSCFG_FNTERR

#define ERR_RANGE                 1
#define ERR_ASSERTION             2
#define ERR_CVT                   3
#define ERR_FDEF                  4
#define ERR_ELEMENT               5
#define ERR_INDEX                 6
#define ERR_STORAGE               7
#define ERR_STACK                 8
#define ERR_POINT                 9
#define ERR_POINT_TLP             10
#define ERR_POINT_PP              11
#define ERR_CONTOUR               12
#define ERR_VECTOR                13
#define ERR_LARGER                14
#define ERR_INT8                  15
#define ERR_INT16                 16
#define ERR_SCANMODE              17
#define ERR_SELECTOR              18
#define ERR_STATE                 19
#define ERR_GETSINGLEWIDTHNIL     20
#define ERR_GETCVTENTRYNIL        21
#define ERR_INVOPC                22
#define ERR_UNBALANCEDIF          23

#define ERR_CONTEXT_FILE          0
#define ERR_CONTEXT_SIZE          1
#define ERR_CONTEXT_CODE          2

#define ERR_CONTEXT(a,b,c,d)      fnterr_Context((a),(b),(c),(d))
#define ERR_START()               fnterr_Start()
#define ERR_RECORD(a)             fnterr_Record((int)(a))
#define ERR_REPORT(a,b,c,d,e)     fnterr_Report((int)(a),(long)(b),(long)(c),(long)(d),(long)(e))
#define ERR_BREAK()               { if ( fnterr_Break() ) break; }
#define ERR_OPC(a)                fnterr_Opc(a)
#define ERR_END()                 fnterr_End()
#define ERR_IF(a)                 fnterr_If(a)

void fnterr_Context (int, char *, unsigned short, unsigned short);
void fnterr_Start (void);
void fnterr_Record (int);
void fnterr_Report (int, long, long, long, long);
int  fnterr_Break (void);
void fnterr_Opc (char*);
void fnterr_End (void);
void fnterr_If (int);

#else

#define ERR_CONTEXT(a,b,c,d)
#define ERR_START()
#define ERR_RECORD(a)
#define ERR_REPORT(a,b,c,d,e)     DEBUGGER ()
#define ERR_BREAK()
#define ERR_OPC(a)
#define ERR_END()
#define ERR_IF(a)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\sbit\sbit.cxx ===
/******************************Module*Header*******************************\
* Module Name: sbit.cxx
*
* (Brief description)
*
* Created: 14-Nov-1993 09:39:47
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* utility for generating bdat and bloc tables out of the set of
* individual .DBF files, where each .DBF (Distribution Bitmap Format)
* file contains a set of bitmaps at one point size, i.e. one "strike",
* in the commonly accepted jargon.
*
*
*
*
*
\**************************************************************************/

#define DEBUGTABLES

extern "C" {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include "windows.h"
};

#include "table.h" // no function declarations only structures

#include "FSERROR.H"
//#include "FSCDEFS.H"    // inlcudes fsconfig.h
#include "FONTMATH.H"
#include "SFNT.H"       // includes sfnt_en.h
#include "FNT.H"
#include "INTERP.H"
#include "FNTERR.H"
#include "SFNTACCS.H"
#include "FSGLUE.H"
#include "SCENTRY.H"
#include "SBIT.H"
#include "FSCALER.H"
#include "SCGLOBAL.H"


#include "sbit.hxx"


BOOL bCreateWriteToAndCloseFile
(
PBYTE      pj,  // buffer with the information to be written to the file
ULONG      cj,  // size of the buffer above
PSZ        pszFileName  // name of the file to be created
);


#ifdef DEBUGTABLES
BOOL bView(ULONG cjBLOC, ULONG cjBDAT);
#endif // DEBUGTABLES


BOOL bCompute_bitmapSizeTable(
    int              iSizeTable,
    bitmapSizeTable *p,
    char            *psz,
    uint32          *pcjBDAT,
    BYTE            *pjBLOC,
    BYTE            *pjBDAT,
    BYTE            *pj
    );

VOID vConvertToBigEndian(BYTE *pjBLOC, BYTE *pjBDAT);

typedef struct _GLYPHMET
{
    LONG              gi;
    LONG              cjGlyph; // how much room it takes in the tt file
    smallGlyphMetrics sgm;
} GLYPHMET;

BOOL bDoAGlyph(
FILEVIEW  *pfvw,
LONG       gi,
LONG       dp,
GLYPHMET  *pgm,     // various useful glyph information
BYTE      *pjBuf    // copy glyph to this buffer
);

#define CCH_FILENAME  40

CHAR achBDT[CCH_FILENAME];
CHAR achBLC[CCH_FILENAME];


static char szMe[] = "SBIT";            /* program name */

int main (int argc, char** argv)
{
    int iFile, cSizes       = argc - 2;
    bitmapSizeTable  abmpsz[C_SIZES];         // one for every input file
    uint32 cjBLOC,  cjBDAT, cjBDATdbg;
    uint32 cchTTF;
    PSTR   pszTTF;

    if  (cSizes == 0)
    {
        fprintf(stderr, "%s: Usage is \"%s file1.dbf file2.dbf ... file.ttf\".\n", szMe,szMe);
        return EXIT_FAILURE;
    }

    if  (cSizes > C_SIZES)
    {
        fprintf(stderr, "%s: must have less than %ld input files. \n", szMe,C_SIZES);
        return EXIT_FAILURE;
    }

// map lucon.ttf to make sure that glyph indicies in the dbf fonts are
// computed correctly:

    pszTTF = argv[argc - 1];
    cchTTF = strlen(pszTTF) + 1;

// 6 = strlen(".ttf") + 1           +  1
//                  (for term. '\0')  (for at least one more glyph before .ttf)

    if
    (
     (cchTTF < 6)            ||
     (cchTTF > CCH_FILENAME) ||
     _strcmpi(&pszTTF[cchTTF - 5],".ttf")
    )
    {
        fprintf(stderr, ".ttf file name too long or not a .ttf file\n");
        return EXIT_FAILURE;
    }

// prepare buffers with output file names:

    strcpy(achBLC, pszTTF); strcpy(&achBLC[cchTTF - 4], "blc");
    strcpy(achBDT, pszTTF); strcpy(&achBDT[cchTTF - 4], "bdt");

    MAPFILEOBJ mfoTTF(pszTTF);
    if (!mfoTTF.bValid())
        return EXIT_FAILURE;

    BYTE *pjTTF = mfoTTF.fvw.pjView;
    BYTE *pjMap = pjMapTable(&mfoTTF.fvw);
    if (!pjMap)
        return EXIT_FAILURE;

// init only

    cjBDATdbg = cjBDAT = sizeof(bdatHeader);

    for (iFile = 1; iFile <= cSizes; iFile++)
    {
        if
        (
            !bCompute_bitmapSizeTable(
                (iFile - 1),
                &abmpsz[iFile - 1],
                argv[iFile],
                &cjBDAT,
                NULL,
                NULL,
                pjMap
                )
        )
        {
            fprintf(stderr,
                    "%s: bitmapSizeTable computation error for \"%s\".\n",
                    szMe,
                    argv[iFile]
                    );

            return EXIT_FAILURE;
        }
    }

// compute the size of bloc and bdat tables

    cjBLOC = sizeof(blocHeader) + cSizes * sizeof(bitmapSizeTable);

    for (iFile = 0; iFile < cSizes; iFile++)
    {
        abmpsz[iFile].indexSubTableArrayOffset = cjBLOC;
        cjBLOC += abmpsz[iFile].indexTablesSize;
    }

// done with BLOC, BDAT sizes, allocate memory for those two tables

    MALLOCOBJ memoBLOC((size_t)cjBLOC);
    MALLOCOBJ memoBDAT((size_t)cjBDAT);
    if (!memoBLOC.bValid() || !memoBDAT.bValid())
        return EXIT_FAILURE;

// do the headers:

    ((blocHeader *)memoBLOC.pv())->version = 0x20000;
    ((blocHeader *)memoBLOC.pv())->numSizes = cSizes;

    ((bdatHeader *)memoBDAT.pv())->version = 0x20000;

// do the tables:

    for (iFile = 1; iFile <= cSizes; iFile++)
    {
        if
        (
            !bCompute_bitmapSizeTable(
                (iFile - 1),
                &abmpsz[iFile - 1],
                argv[iFile],
                &cjBDATdbg,              // dbg one for control
                (BYTE *)memoBLOC.pv(),
                (BYTE *)memoBDAT.pv(),
                NULL                     // no ttf, already done checking
                )
        )
        {
            fprintf(stderr,
                    "%s: bitmapSizeTable computation error for \"%s\".\n",
                    szMe,
                    argv[iFile]
                    );
            return EXIT_FAILURE;
        }
    }

    ASSERT(cjBDATdbg == cjBDAT, "problem in cjBDAT computation\n");

// all data has to be converted to Big Endian format

    vConvertToBigEndian((BYTE *)memoBLOC.pv(),(BYTE *)memoBDAT.pv());

// create .blc and .bdt files and write to them. When done close these files
// and exit.

    if
    (
        !bCreateWriteToAndCloseFile ((BYTE *)memoBLOC.pv(),cjBLOC,achBLC) ||
        !bCreateWriteToAndCloseFile ((BYTE *)memoBDAT.pv(),cjBDAT,achBDT)
    )
    {
        fprintf(stderr, "failed to create bdat or bloc files\n");
        return EXIT_FAILURE;
    }

// this routine is here for debugging purposes only.
// It looks through bloc and bdat files and makes sure that
// the data is in place where you would expect it.

#ifdef DEBUGTABLES
    bView(cjBLOC, cjBDAT);
#endif //

    return EXIT_SUCCESS;
}



/******************************Public*Routine******************************\
*
* BYTE *pjNextLine(BYTE *pjLine)
*
* get to the beginning of the next line. The line pointed to by pjLine
* finishes with /r/n
*
*
* History:
*  16-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BYTE *pjNextLine(BYTE *pjLine, BYTE *pjEOF)
{
    BYTE *pjBegin = pjLine;

    if (pjLine >= pjEOF)
    {
        fprintf(stderr,"pjLine >= pjEOF\n");
        return NULL;
    }

    while ((pjLine < pjEOF) && (*pjLine++ != '\r'))
        ;

// skip '\n' following \r

    pjLine++;

    if ((pjLine - pjBegin) >= C_BIG)
    {
        fprintf(stderr,"too long line\n");
        return NULL;
    }

    return pjLine;

}


/******************************Public*Routine******************************\
*
* pjNextWord
*
* History:
*  16-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



// word defined as a sequence of nonspace glyphs

#define ISSPACE(c) (((c) == ' ') || ((c) == '\t') || ((c) == '\r') || ((c) == '\n') || ((c) == '.'))

BYTE *pjNextWord(BYTE *pjWord, BYTE *pjEnd, BYTE * psz)
{
// zero init in case no nonwhitespace on this line

    *psz = '\0';

// skip the possible space at the beginning of the line

    while ((pjWord < pjEnd) && ISSPACE(*pjWord)) // skip space
        pjWord++;

// we are at the beginning at the nonwhite space now, copy it out

    while ((pjWord < pjEnd) && !ISSPACE(*pjWord))
        *psz++ = *pjWord++;

// zero terminate the string in the buffer

    *psz = '\0';

// go to the beginning of the next word

    while ((pjWord < pjEnd) && ISSPACE(*pjWord)) // skip space
        pjWord++;

    return pjWord;
}

/******************************Public*Routine******************************\
*
* BYTE *pjGetNextNumber(BYTE *pjWord, BYTE *pjEnd, BYTE * psz, LONG *pl)
*
*
* History:
*  17-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BYTE *pjGetNextNumber(BYTE *pjWord, BYTE *pjEnd, BYTE * psz, LONG *pl)
{
    BYTE *pj = pjNextWord(pjWord,pjEnd,psz);
    if (pl)
        *pl = atol((char *)psz);
    return pj;
}






/******************************Public*Routine******************************\
*
* bCompute_bitmapSizeTable
*
* Effects:
*
* Warnings:
*
* History:
*  15-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL  bCompute_bitmapSizeTable(
    int              iSizeTable,
    bitmapSizeTable *pbmpsz,
    char *           pszFileName,
    uint32          *pcjBDAT,
    BYTE            *pjBLOC,
    BYTE            *pjBDAT,
    BYTE            *pjCMAP   // optionaly can be NULL
    )
{
    BYTE     *pjLine, *pjNext, *pjEOF;
    BYTE ajWord[C_BIG]; // buffer for words
    BYTE *pjWord;
    LONG ppemX, ppemY, xRes, yRes;
    RECT rc;
    LONG cChars;
    LONG lWidth, cx,cy;
    ULONG i;
    uint16   indexFormat,cjOffset;

    MAPFILEOBJ mfo(pszFileName);
    if (!mfo.bValid())
        return FALSE;

    pjEOF = mfo.fvw.pjView + mfo.fvw.cjView;

    if (!pjBLOC)
    {
        pbmpsz->indexSubTableArrayOffset = 0;   /* ptr to array of ranges */
        pbmpsz->colorRef= 0;                    /* reserved, set to 0 */
        memset(&pbmpsz->vert,0,sizeof(sbitLineMetrics));
        pbmpsz->grayScaleLevels = 1;            /* 1 = Black; >1 = Gray */
        pbmpsz->flags = flgHorizontal;          /* hori or vert metrics */
    }
    else
    {
    // this is second pass of this function, we are actually writing this to
    // the buffer

        ((bitmapSizeTable *)(pjBLOC + sizeof(blocHeader)))[iSizeTable] = *pbmpsz;
    }

// parse the header info

    for (pjLine = mfo.fvw.pjView; pjLine < pjEOF; pjLine = pjNext)
    {
        if (!(pjNext = pjNextLine(pjLine, pjEOF))) return FALSE;

    // get the keyword at the beginning of the line

        pjWord = pjNextWord(pjLine,pjNext, ajWord);

        if (!strcmp((char *)ajWord,"STARTFONT"))
        {
        // get the next word and convert it to the hex number

            pjWord = pjNextWord(pjWord,pjNext, ajWord);
        }
        else if (!strcmp((char *)ajWord,"COMMENT"))
        {
            continue; // ignore this line
        }
        else if (!strcmp((char *)ajWord,"FONT"))
        {
            continue; // ignore this line
        }
        else if (!strcmp((char *)ajWord,"SIZE"))
        {
            if (!pjBLOC)
            {
                pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &ppemY);
                pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &xRes);
                pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &yRes);

                ppemX = ppemY;

                if (yRes != 72)
                    ppemY = MulDiv((int)ppemY,(int)72,(int)yRes);
                pbmpsz->ppemY = (uint8)ppemY;

                if (xRes != 72)
                    ppemX = MulDiv((int)ppemX,(int)72,(int)xRes);
                pbmpsz->ppemX = (uint8)ppemX;

#ifdef DEBUGOUTPUT
                fprintf(stdout,
                    "ppemY = %ld, xRes = %ld, yRes = %ld \n",
                    pbmpsz->ppemY,
                    xRes,
                    yRes);
#endif // DEBUGOUTPUT
            }
        }
        else if (!strcmp((char *)ajWord,"FONTBOUNDINGBOX"))
        {
            pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &cx);
            pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &cy);
            pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &rc.left);
            pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &rc.bottom);

            rc.right = rc.left   + cx;
            rc.top   = rc.bottom + cy;

#ifdef DEBUGOUTPUT
            fprintf(stdout,
                    "rcBound: l = %ld, t = %ld, r = %ld, b = %ld \n",
                    rc.left, rc.top, rc.right, rc.bottom
                    );
#endif // DEBUGOUTPUT
        }
        else if (!strcmp((char *)ajWord,"STARTPROPERTIES"))
        {
        // go to the end of the section

            for (pjLine = pjNext; pjLine < pjEOF; pjLine = pjNext)
            {
                if (!(pjNext = pjNextLine(pjLine, pjEOF))) return FALSE;
                pjWord = pjNextWord(pjLine,pjNext, ajWord);
                if (!strcmp((char *)ajWord,"ENDPROPERTIES"))
                    break;
            }
        }
        else if (!strcmp((char *)ajWord,"CHARS"))
        {
        // Get the number of chars and get out of the loop

            pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &cChars);
#ifdef DEBUGOUTPUT
            fprintf(stdout,"cChars = %ld\n", cChars);
#endif // DEBUGOUTPUT

        // get out of this loop and get into the loop over chars

            pjLine = pjNext;
            break;
        }
        else
        {
            continue;
        }
    } // header loop

// now that we have cChars and font bounding box we can estimate
// the size of the BDAT table and use it to determine the index format
// for the bloc table. We assume imageFormat = 1 in either case
// which means every glyph has a different glyph metrics

    {
        ULONG cjAllGlyphs = (ULONG)cChars *
            (ULONG)(sizeof(smallGlyphMetrics) + cy * ((cx + 7) >> 3));

        if (cjAllGlyphs <= (0xffff - sizeof(bdatHeader)))
        {
            indexFormat = 3; // 16 bit offsets
            cjOffset = sizeof(uint16);
        }
        else
        {
            indexFormat = 1; // 32 bit offsets
            cjOffset = sizeof(uint32);
        }
        fprintf(stdout, "indexFormat = %d\n", indexFormat);
    }

// pjLine now points to the first STARTCHAR

    MALLOCOBJ memo((size_t)(cChars * sizeof(GINDEX)));
    if (!memo.bValid())
        return FALSE;

    GINDEX *pgix = (GINDEX *)memo.pv();

    ULONG cRuns = cComputeGlyphRanges(&mfo.fvw, pgix, cChars,pjCMAP);
    if (!cRuns)
        return FALSE;

    MALLOCOBJ memoIndexSet((size_t)(SZ_INDEXSET(cRuns,cChars)));
    if (!memoIndexSet.bValid())
        return FALSE;

// now compute the index set

    INDEXSET *piset = (INDEXSET *)memoIndexSet.pv();
    cComputeIndexSet (pgix,cChars,cRuns, piset);

// if we are writing to the BLOC and BDAT buffers it is now time to
// initialize indexSubTableArray

    indexSubTableArray *pista = NULL;

    if (pjBLOC)
    {
        pista = (indexSubTableArray *)(pjBLOC + pbmpsz->indexSubTableArrayOffset);

    // dpAdditionalOffset is computed relative to the top of the FIRST
    // indexSubTableArray, not relative to the top of pjBLOC table.
    // That is the offset from the beginning of the pjBLOC table is computed
    // as pbmpsz->indexSubTableArrayOffset + dpAdditionalOffset

        uint32 dpAdditionalOffset = piset->cRuns * sizeof(indexSubTableArray);

        for (i = 0; i < piset->cRuns; i++)
        {
            pista[i].firstGlyphIndex = piset->agirun[i].giLow;
            pista[i].lastGlyphIndex = piset->agirun[i].giLow +
                                      piset->agirun[i].cGlyphs - 1;
            pista[i].additionalOffsetToIndexSubtable = dpAdditionalOffset;

        // need one more offset than there are glyphs, the size of the last
        // glyph is equal to (offsetArray[cGlyphs] - offsetArray[cGlyphs - 1])

            dpAdditionalOffset += (
                offsetof(indexSubTable1,offsetArray) +
                (piset->agirun[i].cGlyphs + 1) * cjOffset  // need an extra offset
                );
        }
    }
    else // pjBLOC == 0
    {
    // initialize some variables;

        pbmpsz->numberOfIndexSubTables = piset->cRuns;     /* array size */

    //  bytes array+subtables

        pbmpsz->indexTablesSize = piset->cRuns * sizeof(indexSubTableArray);
    }

    BYTE *pjBuf = NULL; // initialization is essential

// now go through the loop with glyphs:
// pjLine points to the first STARTCHAR line

    lWidth = 0;

    for (i = 0; i < piset->cRuns; i++)
    {
    // need one more offset than there are glyphs, the size of the last
    // glyph is equal to (offsetArray[cGlyphs] - offsetArray[cGlyphs - 1])

        uint32  cjSubTableSize;
        if (indexFormat == 1)
        {
            cjSubTableSize = offsetof(indexSubTable1,offsetArray) +
                                (piset->agirun[i].cGlyphs + 1) * cjOffset;
        }
        else
        {
            ASSERT(indexFormat == 3, "indexFormat is in trouble \n");
            cjSubTableSize = offsetof(indexSubTable3,offsetArray) +
                                (piset->agirun[i].cGlyphs + 1) * cjOffset;

        // cjSubTableSize has to be DWORD aligned according to APPLE's spec
        // for the next indexSubTable to start at the DWORD boundary:

            cjSubTableSize = ((cjSubTableSize + 3) & ~3);
        }

        indexSubTable1 * pist1 = NULL;
        indexSubTable3 * pist3 = NULL;

        if (!pjBLOC)
        {
            pbmpsz->indexTablesSize += cjSubTableSize;
        }
        else
        {
           pist1 = (indexSubTable1 *)(
                       pjBLOC                                   +
                       pbmpsz->indexSubTableArrayOffset         +
                       pista[i].additionalOffsetToIndexSubtable );
           pist3 = (indexSubTable3 *)pist1;

           pist1->header.indexFormat = indexFormat;
           pist1->header.imageFormat = 1;
           pist1->header.imageDataOffset = *pcjBDAT;
        }

        for (USHORT iGlyph = 0; iGlyph < piset->agirun[i].cGlyphs; iGlyph++)
        {
            GLYPHMET  gm;

            if (pjBLOC)
            {
                if (indexFormat == 1)
                {
                    pist1->offsetArray[iGlyph] =
                        (*pcjBDAT - pist1->header.imageDataOffset);
                    pjBuf = pjBDAT + pist1->header.imageDataOffset + pist1->offsetArray[iGlyph];
                }
                else
                {
                    ASSERT(indexFormat == 3, "indexFormat is in trouble \n");
                    pist3->offsetArray[iGlyph] =
                        (uint16)(*pcjBDAT - pist3->header.imageDataOffset);
                    pjBuf = pjBDAT + pist3->header.imageDataOffset + pist3->offsetArray[iGlyph];
                }
            }

            if
            (
                !bDoAGlyph(
                    &mfo.fvw,
                    iGlyph + piset->agirun[i].giLow,
                    piset->agirun[i].pdp[iGlyph],
                    &gm,
                    pjBuf
                    )
            )
            {
                return FALSE;
            }

        // do a comparison on the width

            if ((LONG)gm.sgm.advance > lWidth)
                lWidth = gm.sgm.advance;

        // add size

            *pcjBDAT += gm.cjGlyph;
        }

    // Now need to fill an extra offset at the end of offsetArray

        if (pjBLOC)
        {
            if (indexFormat == 1)
            {
                pist1->offsetArray[piset->agirun[i].cGlyphs] =
                    *pcjBDAT - pist1->header.imageDataOffset;
            }
            else
            {
                ASSERT(indexFormat == 3, "indexFormat is in trouble \n");
                pist3->offsetArray[piset->agirun[i].cGlyphs] =
                    (uint16)(*pcjBDAT - pist3->header.imageDataOffset);
            }
        }

    }  // end of the loop through glyphs

    if (!pjBLOC)
    {
        pbmpsz->numberOfIndexSubTables = piset->cRuns;
        pbmpsz->startGlyphIndex = (uint16)piset->agirun[0].giLow;
        pbmpsz->endGlyphIndex = piset->agirun[piset->cRuns - 1].giLow +
                                piset->agirun[piset->cRuns - 1].cGlyphs - 1;
    // strike wide metrics

        pbmpsz->hori.ascender = (int8)rc.top;
        pbmpsz->hori.descender = (int8)(-rc.bottom);
        pbmpsz->hori.widthMax = (uint8)lWidth;
        pbmpsz->hori.caretSlopeNumerator = 1;
        pbmpsz->hori.caretSlopeDenominator = 0;
        pbmpsz->hori.caretOffset = 0;
        pbmpsz->hori.minOriginSB = (int8)rc.left;
        pbmpsz->hori.minAdvanceSB = (int8)(rc.right - lWidth);
        pbmpsz->hori.maxBeforeBL = (int8)rc.top;
        pbmpsz->hori.minAfterBL = (int8)rc.bottom;
        pbmpsz->hori.pad1 = 0;
        pbmpsz->hori.pad2 = 0;
    }
    return TRUE;
}

BYTE jNibble(BYTE j)
{
    switch(j)
    {
    case '0':
        return 0;
    case '1':
        return 1;
    case '2':
        return 2;
    case '3':
        return 3;
    case '4':
        return 4;
    case '5':
        return 5;
    case '6':
        return 6;
    case '7':
        return 7;
    case '8':
        return 8;
    case '9':
        return 9;
    case 'a':
    case 'A':
        return 10;
    case 'b':
    case 'B':
        return 11;
    case 'c':
    case 'C':
        return 12;
    case 'd':
    case 'D':
        return 13;
    case 'e':
    case 'E':
        return 14;
    case 'f':
    case 'F':
        return 15;
    default :
        ASSERT(0, "bogus bitmap\n");
        return 0;
    }
}



VOID vDoARow(BYTE *pjRow, LONG cjRow, BYTE * ajWord)
{
    ASSERT((2*cjRow) == (LONG)strlen((char *)ajWord), "cjRow problem \n");

    BYTE *pjRowEnd = pjRow + cjRow;

    for ( ; pjRow < pjRowEnd; pjRow++)
    {
        (*pjRow) = jNibble(*ajWord) << 4;
        ajWord++;
        (*pjRow) |= jNibble(*ajWord);
        ajWord++;
    }
}


PSZ gpsz[16] = {
"    ",
"   X",
"  X ",
"  XX",
" X  ",
" X X",
" XX ",
" XXX",
"X   ",
"X  X",
"X X ",
"X XX",
"XX  ",
"XX X",
"XXX ",
"XXXX"
};


VOID vFakeARow(BYTE *ajWord)
{
#ifdef DEBUGOUTPUT
    for ( ; *ajWord != '\0'; ajWord++)
    {
        fprintf(stdout, "%s", gpsz[jNibble(*ajWord)]);
    }
    fprintf(stdout, "\n");
#endif // DEBUGOUTPUT
}


BOOL bDoAGlyph(
FILEVIEW  *pfvw,
LONG       gi,
LONG       dp,
GLYPHMET  *pgm,     // various useful glyph information
BYTE      *pjBuf    // copy glyph to this buffer
)
{
    BYTE *pjLine, *pjNext, *pjEOF, *pjWord;
    BYTE ajWord[C_BIG]; // buffer for words
    RECT rcChar;
    LONG cx,cy, iRow;
    POINTL ptlDevD, ptlScD;
    LONG   giDbg;

    pgm->gi = gi;

    pjLine = pfvw->pjView + dp;
    pjEOF  = pfvw->pjView + pfvw->cjView;

    if (!(pjNext = pjNextLine(pjLine, pjEOF))) return FALSE;

// get the keyword at the beginning of the line

    pjWord = pjNextWord(pjLine,pjNext, ajWord);

    if (!strcmp((char *)ajWord,"STARTCHAR"))
    {
    // get the next word and convert it to the hex number

        ULONG lUnicode;

        pjWord = pjNextWord(pjWord,pjNext, ajWord);
#ifdef DEBUGOUTPUT
        fprintf(stdout, "STARTCHAR %s\n", ajWord);
#endif // DEBUGOUTPUT

    // get unicode code point for this glyph

        pjWord = pjGetHexNumber(pjWord,pjNext, ajWord, &lUnicode);

    // get glyph index, store the offset

        pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &giDbg);
        if (giDbg != gi)
        {
            fprintf(stderr,
                "gi problem: lUnicode = 0x%lx, gi = %ld, giDbg = %ld\n",
                lUnicode, gi, giDbg);
        }
    }
    else
    {
        fprintf(stderr, "STARTCHAR problem: %s\n", ajWord);
        return FALSE;
    }

    pjLine = pjNext;  // reset pjLine to point to ENCODING

// ENCODING, we ignore this value, it has no importance to us

    if (!(pjNext = pjNextLine(pjLine, pjEOF))) return FALSE;

// get the keyword at the beginning of the line

    pjWord = pjNextWord(pjLine,pjNext, ajWord);

    if (!strcmp((char *)ajWord,"ENCODING"))
    {
    // get the next word and convert it to the hex number

#ifdef DEBUGOUTPUT
        pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &gi);
        fprintf(stdout, "ENCODING %ld\n", gi);
#endif // DEBUGOUTPUT
    }
    else
    {
        fprintf(stderr, "ENCODING problem\n");
        return FALSE;
    }

    pjLine = pjNext;  // reset pjLine to point to SWIDTH

// SWIDTH

    if (!(pjNext = pjNextLine(pjLine, pjEOF))) return FALSE;

// get the keyword at the beginning of the line

    pjWord = pjNextWord(pjLine,pjNext, ajWord);

    if (!strcmp((char *)ajWord,"SWIDTH"))
    {
    // get swidth

        pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &ptlScD.x);
        pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &ptlScD.y);
#ifdef DEBUGOUTPUT
        fprintf(stdout, "SWIDTH = %ld, %ld\n",ptlScD.x,ptlScD.y);
#endif // DEBUGOUTPUT
    }
    else
    {
        fprintf(stderr, "SWIDTH problem\n");
        return FALSE;
    }

    pjLine = pjNext;  // reset pjLine to point to DWIDTH

// DWIDTH

    if (!(pjNext = pjNextLine(pjLine, pjEOF))) return FALSE;

// get the keyword at the beginning of the line

    pjWord = pjNextWord(pjLine,pjNext, ajWord);

    if (!strcmp((char *)ajWord,"DWIDTH"))
    {
    // get dwidth

        pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &ptlDevD.x);
        pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &ptlDevD.y);
#ifdef DEBUGOUTPUT
        fprintf(stdout, "DWIDTH = %ld, %ld\n",ptlDevD.x,ptlDevD.y);
#endif // DEBUGOUTPUT
        pgm->sgm.advance = (uint8)ptlDevD.x;
        ASSERT(ptlDevD.y == 0, "DWIDTH.y != 0\n");
    }
    else
    {
        fprintf(stderr, "DWIDTH problem\n");
        return FALSE;
    }

    pjLine = pjNext;  // reset pjLine to point to BBOX

// BBX

    if (!(pjNext = pjNextLine(pjLine, pjEOF))) return FALSE;

// get the keyword at the beginning of the line

    pjWord = pjNextWord(pjLine,pjNext, ajWord);

    if (!strcmp((char *)ajWord,"BBX"))
    {
    // get BBX

        pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &cx);
        pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &cy);
        pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &rcChar.left);
        pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &rcChar.bottom);

        rcChar.right = rcChar.left   + cx;
        rcChar.top   = rcChar.bottom + cy;

#ifdef DEBUGOUTPUT
        fprintf(stdout,
                "BBX: l = %ld, t = %ld, r = %ld, b = %ld \n",
                rcChar.left, rcChar.top, rcChar.right, rcChar.bottom
                );
#endif // DEBUGOUTPUT

        pgm->sgm.width  = (uint8)cx;
        pgm->sgm.height = (uint8)cy;
        pgm->sgm.bearingX = (int8)rcChar.left;
        pgm->sgm.bearingY = (int8)rcChar.top;

    // use cx and cy to compute how much room will this bitmap take in the
    // bdat table, we are assuming imageFormat1

        pgm->cjGlyph = sizeof(smallGlyphMetrics) + cy * ((cx + 7) >> 3);
    }
    else
    {
        fprintf(stderr, "BBX problem\n");
        return FALSE;
    }

    pjLine = pjNext;  // reset pjLine to point to BITMAP

// BITMAP

    if (!(pjNext = pjNextLine(pjLine, pjEOF))) return FALSE;

// get the keyword at the beginning of the line

    pjWord = pjNextWord(pjLine,pjNext, ajWord);

    if (!strcmp((char *)ajWord,"BITMAP"))
    {
#ifdef DEBUGOUTPUT
        fprintf(stdout, "BITMAP\n");
#endif // DEBUGOUTPUT
    }
    else
    {
        fprintf(stderr, "BITMAP problem\n");
        return FALSE;
    }

    pjLine = pjNext;  // reset pjLine to point to the first row of the bitmap

// process the rows of the bitmap, one at the time
// if the glyph has to be written out let us do it

    if (pjBuf)
    {
        *((smallGlyphMetrics *)pjBuf) = pgm->sgm;
        pjBuf += sizeof(smallGlyphMetrics);
    }

    LONG cjRow = (cx + 7) >> 3;
    BYTE *pjRow = pjBuf;
    for (iRow = 0; iRow < cy; iRow++, pjRow += cjRow)
    {
        if (!(pjNext = pjNextLine(pjLine, pjEOF))) return FALSE;

    // get the keyword at the beginning of the line

        pjWord = pjNextWord(pjLine,pjNext, ajWord);
        if (!pjBuf)
        {
            vFakeARow(ajWord);
        }
        else
        {
            vDoARow(pjRow,cjRow,ajWord);
        }

        pjLine = pjNext;  // reset pjLine to point to the next row
    }


// ENDCHAR

    if (!(pjNext = pjNextLine(pjLine, pjEOF))) return FALSE;

// get the keyword at the beginning of the line

    pjWord = pjNextWord(pjLine,pjNext, ajWord);

    if (!strcmp((char *)ajWord,"ENDCHAR"))
    {
#ifdef DEBUGOUTPUT
        fprintf(stdout, "ENDCHAR\n");
#endif // DEBUGOUTPUT
    }
    else
    {
        fprintf(stderr, "ENDCHAR problem\n");
        return FALSE;
    }
    return TRUE;
}



/******************************Public*Routine******************************\
*
*
*
* Effects:
*
* Warnings:
*
* History:
*  19-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bCreateWriteToAndCloseFile
(
PBYTE      pj,  // buffer with the information to be written to the file
ULONG      cj,  // size of the buffer above
PSZ        pszFileName  // name of the file to be created
)
{
    HANDLE         hf;
    ULONG          cjWritten;
    BOOL           bRet;

    hf = CreateFile(pszFileName,  // file name of the new converted file
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    0,
                    CREATE_ALWAYS,    //
                    FILE_ATTRIBUTE_NORMAL,
                    0);

    if (hf == (HANDLE)-1)
    {
        fprintf(stderr,"CreateFile failed\n");
        bRet = FALSE;
        goto exit;
    }

// set file ptr to the beginning of the file

    if (SetFilePointer(hf, 0, NULL, FILE_BEGIN) == -1)
    {
        fprintf(stderr,"SetFilePointer failed\n");
        bRet = FALSE;
        goto closefile;
    }

    if (
        !WriteFile(hf, (PVOID)pj, cj, &cjWritten, NULL) ||
        (cjWritten != cj)
       )
    {
        fprintf(stderr,"WriteFile failed");
        bRet = FALSE;
        goto closefile;
    }

    bRet = TRUE;

closefile:

    if (!CloseHandle(hf))
    {
        fprintf(stderr,"CloseHandle failed");
        bRet = FALSE;
    }

exit:

    return(bRet);
}



VOID vSwap_bdatHeader(bdatHeader *p)
{
    p->version  = (Fixed) SWAPL(p->version);
}

VOID vSwap_blocHeader(blocHeader *p)
{
    p->version  = (Fixed) SWAPL(p->version);
    p->numSizes = (uint32)SWAPL(p->numSizes);
}

VOID vSwap_bitmapSizeTable(bitmapSizeTable *p)
{
    p->indexSubTableArrayOffset = (uint32)SWAPL(p->indexSubTableArrayOffset);
    p->indexTablesSize          = (uint32)SWAPL(p->indexTablesSize);
    p->numberOfIndexSubTables   = (uint32)SWAPL(p->numberOfIndexSubTables);
    p->colorRef                 = (uint32)SWAPL(p->colorRef);
    p->startGlyphIndex          = (uint16)SWAPW(p->startGlyphIndex);
    p->endGlyphIndex            = (uint16)SWAPW(p->endGlyphIndex);
}

VOID vSwap_indexSubTableArray(indexSubTableArray *p)
{
    p->firstGlyphIndex                 = (uint16)SWAPW(p->firstGlyphIndex);
    p->lastGlyphIndex                  = (uint16)SWAPW(p->lastGlyphIndex);
    p->additionalOffsetToIndexSubtable = (uint32)SWAPL(p->additionalOffsetToIndexSubtable);
}

VOID vSwap_indexSubHeader(indexSubHeader *p)
{
    p->indexFormat     = (uint16)SWAPW(p->indexFormat);
    p->imageFormat     = (uint16)SWAPW(p->imageFormat);
    p->imageDataOffset = (uint32)SWAPL(p->imageDataOffset);
}






#ifdef DEBUGTABLES

VOID vDoAGlyph(BYTE *pjGlyph, ULONG ulGlyphIndex)
{
    smallGlyphMetrics *psgm = (smallGlyphMetrics *)pjGlyph;
    ULONG cx,cy, iRow, cjRow;

    cx = psgm->width;
    cy = psgm->height;
    cjRow = (cx + 7) >> 3;

    fprintf(stdout, "\nStarting Glyph, gi = %ld, cx = %ld, cy = %ld\n",
        ulGlyphIndex, cx, cy);

// point pjGlyph into bits:

    pjGlyph += sizeof(smallGlyphMetrics);

    for (iRow = 0; iRow < cy; iRow++, pjGlyph += cjRow)
    {
        BYTE *pjRow = pjGlyph;
        BYTE *pjRowEnd = pjGlyph + cjRow;
        for ( ; pjRow < pjRowEnd; pjRow++)
        {
            fprintf(stdout, "%s", gpsz[(*pjRow) >> 4]);
            fprintf(stdout, "%s", gpsz[(*pjRow) & 0x0f]);
        }
        fprintf(stdout, "\n");
    }
    fprintf(stdout, "Ending Glyph\n");
}




/******************************Public*Routine******************************\
*     bView
*
* this routine is here for debugging purposes only.
* It looks through bloc and bdat files and makes sure that
* the data is in place where you would expect it.
*
* History:
*  20-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




BOOL bView(ULONG cjBLOC, ULONG cjBDAT)
{

    MAPFILEOBJ mfoBLOC(achBLC);
    MAPFILEOBJ mfoBDAT(achBDT);
    if (!mfoBLOC.bValid() || !mfoBDAT.bValid())
        return FALSE;

    ASSERT(mfoBLOC.fvw.cjView == cjBLOC, "bView, cjBLOC\n");
    ASSERT(mfoBDAT.fvw.cjView == cjBDAT, "bView, cjBDAT\n");

    BYTE *pjBLOC = mfoBLOC.fvw.pjView;
    BYTE *pjBDAT = mfoBDAT.fvw.pjView;

    ULONG cSizes = (ULONG)SWAPL(((blocHeader *)pjBLOC)->numSizes);

    bitmapSizeTable * pbmpsz = (bitmapSizeTable *)
                                   (pjBLOC + sizeof(blocHeader));

// loop through the sizes:

    for (ULONG iSize = 0; iSize < cSizes; iSize++)
    {

        bitmapSizeTable bmpsz = pbmpsz[iSize];
        vSwap_bitmapSizeTable(&bmpsz);

        fprintf(stdout, "\n\nSize = %ld\n\n",
            (ULONG)bmpsz.ppemY
            );

        ULONG cGlyphs = 0; // total nubmer of glyphs supported at this size;
        indexSubTableArray *pista, *pistaEnd;

        pista = (indexSubTableArray *)(pjBLOC + bmpsz.indexSubTableArrayOffset);
        pistaEnd = pista + bmpsz.numberOfIndexSubTables;

        ASSERT(pista->firstGlyphIndex == pbmpsz[iSize].startGlyphIndex,
            "pista->firstGlyphIndex \n");
        ASSERT(pistaEnd[-1].lastGlyphIndex == pbmpsz[iSize].endGlyphIndex,
            "pista->firstGlyphIndex \n");

        for ( ; pista < pistaEnd; pista++)
        {
            indexSubTableArray ista = *pista;
            vSwap_indexSubTableArray(&ista);

            ULONG cGlyphsInRun = (ULONG)(ista.lastGlyphIndex
                                - ista.firstGlyphIndex + 1);

            cGlyphs += cGlyphsInRun;

            indexSubTable1 * pist1 = (indexSubTable1 *) (
                                         pjBLOC                              +
                                         bmpsz.indexSubTableArrayOffset      +
                                         ista.additionalOffsetToIndexSubtable);

            indexSubTable3 * pist3 = (indexSubTable3 *) pist1;

            fprintf(stdout, "\nStarting glyph run: giStart = %d\n", ista.firstGlyphIndex);

            for (ULONG iGlyph = 0; iGlyph < cGlyphsInRun; iGlyph++)
            {
                BYTE *pjGlyph;

                if (pist1->header.indexFormat == 0x0100)
                {
                    pjGlyph = pjBDAT                               +
                              SWAPL(pist1->header.imageDataOffset) +
                              SWAPL(pist1->offsetArray[iGlyph])    ;
                }
                else
                {
                    ASSERT(pist1->header.indexFormat == 0x0300, "indexFormat in trouble 2\n");
                    pjGlyph = pjBDAT                               +
                              SWAPL(pist3->header.imageDataOffset) +
                              SWAPW(pist3->offsetArray[iGlyph])    ;
                }

                vDoAGlyph(pjGlyph, (ULONG)(ista.firstGlyphIndex + iGlyph));
            }

            fprintf(stdout, "\nEnding glyph run: giEnd = %d\n", ista.lastGlyphIndex);
        }

        fprintf(stdout, "\nThere are %ld glyphs supported at size %ld.\n",
            cGlyphs,
            (ULONG)bmpsz.ppemY);
    }
    return TRUE;
}


#endif // DEBUGTABLES


VOID vConvertToBigEndian(BYTE *pjBLOC, BYTE *pjBDAT)
{
    uint16          indexFormat;

// this is the only DWORD or WORD information in the BDAT table:

    vSwap_bdatHeader((bdatHeader *)pjBDAT);

// now do BLOC table:

    ULONG cSizes = ((blocHeader *)pjBLOC)->numSizes;

    vSwap_blocHeader((blocHeader *)pjBLOC);

    bitmapSizeTable * pbmpsz = (bitmapSizeTable *)
                                   (pjBLOC + sizeof(blocHeader));

// loop through the sizes:

    for (ULONG iSize = 0; iSize < cSizes; iSize++)
    {
        bitmapSizeTable bmpsz = pbmpsz[iSize];

        vSwap_bitmapSizeTable(&pbmpsz[iSize]);

        indexSubTableArray *pista, *pistaEnd;

        pista = (indexSubTableArray *)(pjBLOC + bmpsz.indexSubTableArrayOffset);
        pistaEnd = pista + bmpsz.numberOfIndexSubTables;

        for ( ; pista < pistaEnd; pista++)
        {
            indexSubTableArray ista = *pista;
            vSwap_indexSubTableArray(pista);

            ULONG cGlyphsInRun = (ULONG)(ista.lastGlyphIndex
                                - ista.firstGlyphIndex + 1);

            indexSubTable1 * pist1 = (indexSubTable1 *)(
                                         pjBLOC                              +
                                         bmpsz.indexSubTableArrayOffset      +
                                         ista.additionalOffsetToIndexSubtable);

            indexSubTable3 *pist3 = (indexSubTable3 *)pist1;
            indexFormat = pist1->header.indexFormat;

            vSwap_indexSubHeader(&pist1->header);

        // do not forget to swap the last index in the array, the one that
        // does not point to any glyph data but is only used instead
        // for the computation of the size of the last glyph.

            ULONG iGlyph;
            if (indexFormat == 1) // 32 bit indicies
            {
                for (iGlyph = 0; iGlyph < (cGlyphsInRun + 1); iGlyph++)
                {
                    pist1->offsetArray[iGlyph]
                        = (uint32)SWAPL(pist1->offsetArray[iGlyph]);
                }
            }
            else // 16 indicies
            {
                ASSERT(indexFormat == 3, "indexFormat is messed up\n");
                for (iGlyph = 0; iGlyph < (cGlyphsInRun + 1); iGlyph++)
                {
                    pist3->offsetArray[iGlyph]
                        = (uint16)SWAPW(pist3->offsetArray[iGlyph]);
                }
            }
        }
    }
}



BYTE *pjGetHexNumber(BYTE *pjWord, BYTE *pjEnd, BYTE * psz, ULONG *pul)
{
    BYTE *pj = pjNextWord(pjWord,pjEnd,psz);
    if (pul)
    {
        *pul = 0;

    // skip the zeros at the beginning:

        for ( ; *psz && (*psz == '0'); psz++)
            ;

        for ( ; *psz != '\0'; psz++)
        {
            *pul = (*pul << 4) + jNibble(*psz);
        }
    }
    return pj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\sbit\tt.cxx ===
/******************************Module*Header*******************************\
* Module Name: tt.cxx
*
* tt stuff, mostly stolen from ttfd
*
* Created: 24-Nov-1993 11:17:35
* Author: Bodin Dresevic [BodinD]
*
\**************************************************************************/

extern "C" {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include "windows.h"

// tt stuff

#include "FSERROR.H"
#include "FSCDEFS.H"    // inlcudes fsconfig.h
#include "FONTMATH.H"
#include "SFNT.H"       // includes sfnt_en.h
#include "FNT.H"
#include "INTERP.H"
#include "FNTERR.H"
#include "SFNTACCS.H"
#include "FSGLUE.H"
#include "SCENTRY.H"
#include "SBIT.H"
#include "FSCALER.H"
#include "SCGLOBAL.H"
};



#include "sbit.hxx"


/******************************Public*Routine******************************\
* PBYTE pjTable(ULONG ulTag, FILEVIEW *pfvw, ULONG *pcjTable)
*
* stolen from ttfd, find a table given a tag
*
* History:
*  24-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



PBYTE pjTable(ULONG ulTag, FILEVIEW *pfvw, ULONG *pcjTable)
{
    INT                 cTables;
    sfnt_OffsetTable    *pofft;
    register sfnt_DirectoryEntry *pdire, *pdireEnd;

// offset table is at the very top of the file,

    pofft = (sfnt_OffsetTable *) pfvw->pjView;
    cTables = (INT) SWAPW(pofft->numOffsets);

//!!! here we do linear search, but perhaps we could optimize and do binary
//!!! search since tags are ordered in ascending order

    pdireEnd = &pofft->table[cTables];

    ulTag = SWAPL(ulTag);

    for
    (
        pdire = &pofft->table[0];
        pdire < pdireEnd;
        pdire++
    )
    {

        if (ulTag == pdire->tag)
        {
            ULONG ulOffset = (ULONG)SWAPL(pdire->offset);
            ULONG ulLength = (ULONG)SWAPL(pdire->length);

        // check if the ends of all tables are within the scope of the
        // tt file. If this is is not the case trying to access the field in the
        // table may result in an access violation, as is the case with the
        // spurious FONT.TTF that had the beginning of the cmap table below the
        // end of file, which was resulting in the system crash reported by beta
        // testers. [bodind]

            if
            (
                !ulLength ||
                ((ulOffset + ulLength) > pfvw->cjView)
            )
            {
                return NULL;
            }
            else // we found it
            {
                *pcjTable = ulLength;
                return ((PBYTE)pfvw->pjView + ulOffset);
            }
        }
    }

// if we are here, we did not find it.

    return NULL;
}

#define SIZEOF_CMAPTABLE  (3 * sizeof(uint16))

#define OFF_segCountX2  6
#define OFF_endCount    14

/******************************Public*Routine******************************\
*
* bWcharToIndex
*
* stolen and modified from ttfd
*
* History:
*  24-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bWcharToIndex (PBYTE pmap, uint16 wc, uint16 * pgi)
{
    uint16 *pstartCount, *pendCount,            // Arrays that define the
           *pidDelta, *pidRangeOffset;          // Unicode runs supported
                                                // by the CMAP table.
    uint16 *pendCountStart;                     // Beginning of arrays.
    uint16  cRuns;                              // Number of Unicode runs.
    uint16  usLo, usHi, idDelta, idRangeOffset; // Current Unicode run.

    *pgi = 0;                                   // ZERO init
    cRuns = SWAPW(pmap[OFF_segCountX2]) >> 1;

// Get the pointer to the beginning of the array of endCount code points

    pendCountStart = (uint16 *)(pmap + OFF_endCount);

// The final endCode has to be 0xffff; if this is not the case, there
// is a bug in the TT file or in our code:

    ASSERT(pendCountStart[cRuns - 1] == 0xFFFF,
              "TTFD!_bIndexToWchar pendCount[cRuns - 1] != 0xFFFF\n");

// Loop through the four paralel arrays (startCount, endCount, idDelta, and
// idRangeOffset) and find wc that usIndex corresponds to.  Each iteration
// scans a continuous range of Unicode characters supported by the TT font.
//
// To be Win3.1 compatible, we are looking for the LAST Unicode character
// that corresponds to usIndex.  So we scan all the arrays backwards,
// starting at the end of each of the arrays.
//
// Please note the following:
// For resons known only to the TT designers, startCount array does not
// begin immediately after the end of endCount array, i.e. at
// &pendCount[cRuns]. Instead, they insert an uint16 padding which has to
// set to zero and the startCount array begins after the padding. This
// padding in no way helps alignment of the structure.
//
// Here is the format of the arrays:
// ________________________________________________________________________________________
// | endCount[cRuns] | skip 1 | startCount[cRuns] | idDelta[cRuns] | idRangeOffset[cRuns] |
// |_________________|________|___________________|________________|______________________|

    pendCount      = &pendCountStart[cRuns - 1];
    pstartCount    = &pendCount[cRuns + 1];   // add 1 because of padding
    pidDelta       = &pstartCount[cRuns];
    pidRangeOffset = &pidDelta[cRuns];

    for ( ;
         pendCount >= pendCountStart;
         pstartCount--, pendCount--,pidDelta--,pidRangeOffset--
        )
    {
        usLo          = SWAPW(pstartCount[0]);     // current Unicode run
        usHi          = SWAPW(pendCount[0]);       // [usLo, usHi], inclusive
        idDelta       = SWAPW(pidDelta[0]);
        idRangeOffset = SWAPW(pidRangeOffset[0]);

        ASSERT(usLo <= usHi, "bWcharToIndex: usLo > usHi\n");

        if ((wc < usLo) || (wc > usHi))
            continue;

    // Depending on idRangeOffset for the run, indexes are computed
    // differently.
    //
    // If idRangeOffset is zero, then index is the Unicode codepoint
    // plus the delta value.
    //
    // Otherwise, idRangeOffset specifies the BYTE offset of an array of
    // glyph indices (elements of which correspond to the Unicode range
    // [usLo, usHi], inclusive).  Actually, each element of the array is
    // the glyph index minus idDelta, so idDelta must be added in order
    // to derive the actual glyph indices from the array values.
    //
    // Notice that the delta arithmetic is always mod 65536.

        if (idRangeOffset == 0)
        {
        // Glyph index == Unicode codepoint + delta.
        //
        // If (usIndex-idDelta) is within the range [usLo, usHi], inclusive,
        // we have found the glyph index.  We'll overload usIndexBE
        // to be usIndex-idDelta == Unicode codepoint.

            *pgi = ((uint32)wc + idDelta) & 0xffff;
            return TRUE;

        }
        else
        {
        /*
            fprintf(stdout,
                "usLo = 0x%x, usHi = 0x%x, idDelta = 0x%x, idRangeOffset = 0x%x\n",
                usLo,usHi,idDelta,idRangeOffset);
        */
        // this line is a black magic prescription of the tt spec:

            uint16 usIndex = *(pidRangeOffset + ((wc - usLo) + idRangeOffset/2));
            uint32 ulIndex = (uint32)SWAPW(usIndex);
            *pgi = (uint16)((ulIndex + idDelta) & 0xffff); // modulo 65536
            return (TRUE);
        }
    }

    fprintf(stderr, "bWcharToIndex: wchar 0x%x not found in cmap table\n",wc);
    return FALSE;
}





BYTE * pjMapTable(FILEVIEW  *pfvw)
{
    ULONG cjTable;

    sfnt_char2IndexDirectory * pcmap =
            (sfnt_char2IndexDirectory *)pjTable(tag_CharToIndexMap, pfvw, &cjTable);

    if (!pcmap)
        return NULL;

    sfnt_platformEntry * pplat = &pcmap->platform[0];
    sfnt_platformEntry * pplatEnd = pplat + SWAPW(pcmap->numTables);

    BYTE *pjMap = NULL;

    if (pcmap->version != 0) // no need to swap bytes, 0 == be 0
    {
        fprintf(stderr,"TTFD!_bComputeIDs: version number\n");
        return NULL;
    }

// find the first sfnt_platformEntry with platformID == PLAT_ID_MS,
// if there was no MS mapping table, go for the mac one

    for (; pplat < pplatEnd; pplat++)
    {
        if ((pplat->platformID == 0x300) && (pplat->specificID == 0x100))
        {
            pjMap =  ((PBYTE)pcmap + SWAPL(pplat->offset));
            break;
        }
    }

    return pjMap;
}





BOOL bCheckGlyphIndex1(BYTE *pjMap, UINT wcIn, UINT giIn)
{

    uint16 gi;
    if (!bWcharToIndex(pjMap, (uint16)wcIn, &gi))
        return FALSE;

    BOOL bRet = (gi == (uint16)giIn);
    if (!bRet)
        fprintf(stderr,
            "wc = 0x%lx, giTTF = %ld, giBDF = %ld\n",
             (ULONG)wcIn, (ULONG)gi, giIn
            );
    return bRet;
}


/*****************************************************************************\
 *
 * FOR THIS STUFF TO WORK FSCALER.LIB HAS TO BE ADDED TO UMLIB LINE IN SOURCES
 *
\*****************************************************************************/



#ifdef LINK_IN_FSCALER

// in the debug version of the rasterizer STAMPEXTRA shoud be added to the
// sizes. strictly speaking this is illegal, but nevertheless very useful.
// it assumes the knowlege of rasterizer internalls [bodind],
// see fscaler.c

#define STAMPEXTRA 4


#define CJ_0  NATURAL_ALIGN(sizeof(fs_SplineKey) + STAMPEXTRA)

#define DONTUSE(X) (X) = (X)

voidPtr   FS_CALLBACK_PROTO
pvGetPointerCallback(
    long clientID,
    long dp,
    long cjData
    )
{
    DONTUSE(cjData);

// clientID is just the pointer to the top of the font file

    return (voidPtr)((PBYTE)clientID + dp);
}


void FS_CALLBACK_PROTO
vReleasePointerCallback(
    voidPtr pv
    )
{
    DONTUSE(pv);
}

/******************************Public*Routine******************************\
* bCheckGlyphIndex
*
* // make sure that the glyph index gi indeed corresponds
* // to the unicode code point wc according to the cmap table of the
* // font file pointed to by pjTTF
*
* History:
*  23-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define DWORD_ALIGN(x) (((x) + 3L) & ~3L)
#define QWORD_ALIGN(x) (((x) + 7L) & ~7L)

#if defined(i386)
// natural alignment for x86 is on 32 bit boundary

#define NATURAL           DWORD
#define NATURAL_ALIGN(x)  DWORD_ALIGN(x)

#else
// for mips and alpha we want 64 bit alignment

#define NATURAL           ULONGLONG
#define NATURAL_ALIGN(x)  QWORD_ALIGN(x)

#endif



BOOL bCheckGlyphIndex(BYTE *pjTTF, UINT wc, UINT gi)
{
    FS_ENTRY          iRet;
    fs_GlyphInputType gin;
    fs_GlyphInfoType  gout;
    NATURAL           anat0[CJ_0 / sizeof(NATURAL)];

// Notice that this information is totaly independent
// of the font file in question, seems to be right according to fsglue.h
// and compfont code

    if ((iRet = fs_OpenFonts(&gin, &gout)) != NO_ERR)
    {
        return (FALSE);
    }

    ASSERT(NATURAL_ALIGN(gout.memorySizes[0]) == CJ_0, "TTFD!_mem size 0\n");
    ASSERT(gout.memorySizes[1] == 0,  "TTFD!_mem size 1\n");

    #if DBG
    if (gout.memorySizes[2] != 0)
        fprintf(stderr,"TTFD!_mem size 2 = 0x%lx \n", gout.memorySizes[2]);
    #endif

    gin.memoryBases[0] = (char *)anat0;
    gin.memoryBases[1] = NULL;
    gin.memoryBases[2] = NULL;

// initialize the font scaler, notice no fields of gin are initialized [BodinD]

    if ((iRet = fs_Initialize(&gin, &gout)) != NO_ERR)
    {
        return (FALSE);
    }

// initialize info needed by NewSfnt function

    gin.sfntDirectory  = (int32 *)pjTTF; // pointer to the top of the view of the ttf file
    gin.clientID = (int32)pjTTF;         // pointer to the top of the view of the ttf file

    gin.GetSfntFragmentPtr = pvGetPointerCallback;
    gin.ReleaseSfntFrag  = vReleasePointerCallback;

    gin.param.newsfnt.platformID = 0x03; // MSFT
    gin.param.newsfnt.specificID = 0x01; // UGL

    if ((iRet = fs_NewSfnt(&gin, &gout)) != NO_ERR)
    {
        return (FALSE);
    }

    gin.param.newglyph.characterCode = (uint16)wc;
    gin.param.newglyph.glyphIndex = 0;

// compute the glyph index from the character code:

    if ((iRet = fs_NewGlyph(&gin, &gout)) != NO_ERR)
    {
        return FALSE;
    }

// return the glyph index corresponding to this hglyph:

    return (gout.glyphIndex == (uint16)gi);
}


#endif // LINK_IN_FSCALER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\sbit\table.h ===
/********************************************************************
 *                                                                  *
 *    sbit.h -- Embedded BitMap Definitions                         *
 *                                                                  *
 *    (c) Copyright 1993  Microsoft Corp.  All rights reserved.     *
 *                                                                  *
 *    11/02/93 deanb    First cut                                   *
 *                                                                  *
 ********************************************************************/

#include "fscdefs.h"                /* for type definitions */

/********************************************************************
 *                                                                  *
 *                            BLOC                                  *
 *                                                                  *
 *                    BitMap Location Table                         *
 *                                                                  *
 * This table contains various global metrics and index tables used *
 * to define and locate bitmaps stored in the BDAT table            *
 *                                                                  *
 ********************************************************************/

/*  Header at top of table, followed by SubTables */

typedef struct {
	Fixed           version;
	uint32          numSizes;   /* number of sizes (strikes) in the table */
} blocHeader;


/********************************************************************/

/*  Metrics that apply to the entire strike */

typedef struct {
	int8            ascender;
	int8            descender;
	uint8           widthMax;
	int8            caretSlopeNumerator;
	int8            caretSlopeDenominator;
	int8            caretOffset;
	int8            minOriginSB;
	int8            minAdvanceSB;
	int8            maxBeforeBL;
	int8            minAfterBL;
	int8            pad1;
	int8            pad2;
} sbitLineMetrics;


/*                      Strike definition.                               */ 
/*  There will be one of these for each strike in the font.  A strike is */
/*  basically a particular size, though it is defined by both ppemX and  */
/*  ppemY to allow for non-square strikes as well.  An array of these    */
/*  structures immediately follows the blocHeader in the bloc table.     */

typedef struct {
	uint32          indexSubTableArrayOffset;   /* ptr to array of ranges */
	uint32          indexTablesSize;            /* bytes array+subtables */
	uint32          numberOfIndexSubTables;     /* array size */
	uint32          colorRef;                   /* reserved, set to 0 */
	sbitLineMetrics hori;                       /* strike wide metrics */
	sbitLineMetrics vert;
	uint16          startGlyphIndex;            /* first glyph */
	uint16          endGlyphIndex;              /* last glyph */
	uint8           ppemX;                      /* hori strike size def */
	uint8           ppemY;                      /* vert strike size def */
	uint8           grayScaleLevels;            /* 1 = Black; >1 = Gray */
	uint8           flags;                      /* hori or vert metrics */
} bitmapSizeTable;

typedef enum {
    flgHorizontal = 0x01,
    flgVertical   = 0x02
} bitmapFlags;


/********************************************************************/

/*  Glyph metrics are used in both bloc and bdat tables */
/*  bloc when metrics are the same for the entire range of glyphs */
/*  bdat when each glyph needs its own metrics */

/*  Per glyph metrics - both horizontal & vertical */

typedef struct {
	uint8           height;
	uint8           width;
	int8            horiBearingX;
	int8            horiBearingY;
	uint8           horiAdvance;
	int8            vertBearingX;
	int8            vertBearingY;
	uint8           vertAdvance;
} bigGlyphMetrics;

/*  Per glyph metrics - either horizontal or vertical */

typedef struct {
	uint8           height;
	uint8           width;
	int8            bearingX;
	int8            bearingY;
	uint8           advance;
} smallGlyphMetrics;


/********************************************************************/

/*  An array of these per strike */

typedef struct {
	uint16          firstGlyphIndex;
	uint16          lastGlyphIndex;
	uint32          additionalOffsetToIndexSubtable;
} indexSubTableArray;


/*  At the start of each SubTable */

typedef struct {
	uint16          indexFormat;
	uint16          imageFormat;
	uint32          imageDataOffset;        /* into bdat table */
} indexSubHeader;


/*  Four different types of SubTables */

/*  Use SubTable1 for large ranges of glyphs requiring 32 bit offsets */

typedef struct {
	indexSubHeader  header;
        uint32          offsetArray[1];          /* one per glyph */
} indexSubTable1;

/*  Use SubTable2 for glyphs that all have same metrics AND same data size */

typedef struct {
	indexSubHeader  header;
	uint32          imageSize;              /* bytes per glyph data */
	bigGlyphMetrics bigMetrics;             /* glyphs have same metrics */
} indexSubTable2;

/*  Use SubTable3 for small ranges of glyphs needing only 16 bit offsets */

typedef struct {
	indexSubHeader  header;
        uint16          offsetArray[1];          /* one per glyph */
											/* pad to long boundary */
} indexSubTable3;

/*  Use SubTable4 for a sparse set of glyphs over a large range */

typedef struct {
	indexSubHeader  header;
	uint32          numGlyphs;
        uint32          offsetArray[1];          /* one per glyph present */
        uint16          glyphIndexArray[1];      /* which glyphs present */
											/* pad to long boundary */
} indexSubTable4;


/******************************************************************** 
 *                                                                  * 
 *                            BDAT                                  * 
 *                                                                  * 
 *                      BitMap Data Table                           * 
 *                                                                  * 
 ********************************************************************/

/*  Header at top of table, followed by glyph data */

typedef struct {
	Fixed           version;
} bdatHeader;


/********************************************************************/

typedef struct {
	smallGlyphMetrics   smallMetrics;
/*  byte aligned bitmap data */
} glyphBitmap_1;


typedef struct {
	smallGlyphMetrics   smallMetrics;
/*  bit aligned bitmap data */
} glyphBitmap_2;


/* compressed bitmap, different metrics per glyph */
/* glyphBitmap_3 MAY be obsolete!  stay tuned for details... */

typedef struct {
	bigGlyphMetrics     bigMetrics;
	uint32              whiteTreeOffset;
	uint32              blackTreeOffset;
	uint32              glyphDataOffset;
} glyphBitmap_3;


/* compressed bitmap with constant metrics */

typedef struct {
	uint32              whiteTreeOffset;
	uint32              blackTreeOffset;
	uint32              glyphDataOffset;
} glyphBitmap_4;


/* glyphBitmap_5 is an array of bit aligned bitmap data, */
/* constant data size and constant metrics per glyph */


typedef struct {
	bigGlyphMetrics     bigMetrics;
/*  byte aligned bitmap data */
} glyphBitmap_6;


typedef struct {
	bigGlyphMetrics     bigMetrics;
/*  bit aligned bitmap data */
} glyphBitmap_7;

/*  there is one of these per component glyph in formats 8 & 9 */

typedef struct {
	uint16              glyphCode;
	int8                xOffset;
	int8                yOffset;
} bdatComponent;


typedef struct {
	smallGlyphMetrics   smallMetrics;
	uint8               pad;
	uint16              numComponents;
        bdatComponent       componentArray[1];
} glyphBitmap_8;


typedef struct {
	bigGlyphMetrics     bigMetrics;
	uint8               pad[2];
	uint16              numComponents;
        bdatComponent       componentArray[1];
} glyphBitmap_9;


/******************************************************************** 
 *                                                                  * 
 *                            BSCA                                  * 
 *                                                                  * 
 *                      BitMap Scale Table                          * 
 *                                                                  * 
 ********************************************************************/

// VERY PRELIMINARY!


/*  Header at top of table, followed by SubTables */

typedef struct {
	Fixed           version;
	uint32          numSizes;
} bscaHeader;


/********************************************************************/

typedef struct {
	Fixed           slope;
	Fixed           intercept;
} scaleFactor;

/*  Scaled strike definition */

typedef struct {
	uint32          colorRef;
	sbitLineMetrics hori;
	sbitLineMetrics vert;
	scaleFactor     height;
	scaleFactor     width;
	scaleFactor     horiBearingX;
	scaleFactor     horiBearingY;
	scaleFactor     horiAdvance;
	scaleFactor     vertBearingX;
	scaleFactor     vertBearingY;
	scaleFactor     vertAdvance;
	uint16          startGlyphIndex;
	uint16          endGlyphIndex;
	uint8           ppemX;
	uint8           ppemY;
	uint8           bitDepth;
	uint8           flags;
	uint8           TargetPpemX;
	uint8           TargetPpemY;
	int8            pad1;
	int8            pad2;
} bitmapScaleTable;


/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fnt.h ===
/*
	File:       fnt.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		  <>     4/30/97    CB      ClaudeBe, catching infinite loops/recursions
	      <>     2/21/97    CB      ClaudeBe, scaled component in composite glyphs
	      <>     2/05/96    CB      ClaudeBe, add bHintForGray in globalGS
	   <11+>     9/15/90    MR,rb   Change pvx and pvy to proj.[xy].  Same for freedom vector.
									Conditionalize vectors for Fracts or ShortFracts.
		<10>     7/26/90    MR      rearrange local graphic state, remove unused parBlockPtr
		 <9>     7/18/90    MR      change loop variable from long to short, and other Ansi-changes
		 <8>     7/13/90    MR      Prototypes for function pointers
		 <5>      6/4/90    MR      Remove MVT
		 <4>      5/3/90    RB      replaced dropoutcontrol with scancontrolin and scancontrol out
									in global graphics state
		 <3>     3/20/90    CL      fields for multiple preprograms fields for ppemDot6 and
									pointSizeDot6 changed SROUND to take D/2 as argument
		 <2>     2/27/90    CL      Added DSPVTL[] instruction.  Dropoutcontrol scanconverter and
									SCANCTRL[] instruction
	   <3.1>    11/14/89    CEL     Fixed two small bugs/feature in RTHG, and RUTG. Added SROUND &
									S45ROUND.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.6>     6/13/89    SJK     Comment
	   <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.4>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.3>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

	To Do:
*/
/*  rwb 4/24/90 Replaced dropoutControl with scanControlIn and scanControlOut in
		global graphics state. 
		<3+>     3/20/90    mrr     Added support for IDEFs.  Made funcDefs long aligned
									by storing int16 length instead of int32 end.
*/

#ifndef FNT_DEFINED
#define FNT_DEFINED

#define STUBCONTROL 0x10000
#define NODOCONTROL 0x20000

#define FNT_PIXELSIZE  ((F26Dot6)0x40)
#define FNT_PIXELSHIFT 6

// public phantom points (cf. scale.c for private phantom points), relative to number of points in glyph
#define LEFTSIDEBEARING		0
#define RIGHTSIDEBEARING	1

#define TOPSIDEBEARING		2
#define BOTTOMSIDEBEARING	3

#define VECTORTYPE	ShortFract

#define NON90DEGTRANS_ROTATED	0x01
#define NON90DEGTRANS_STRETCH	0x02

#ifdef FSCFG_SUBPIXEL
/* For the SubPixel hinting flag field, internal flags */
#define FNT_SP_SUB_PIXEL			0x0001      /* set when calling fs_NewTransformation() */
#define FNT_SP_COMPATIBLE_WIDTH		0x0002      /* set when calling fs_NewTransformation() */
#define FNT_SP_VERTICAL_DIRECTION	0x0004		// set when calling fs_NewTransformation()
#define FNT_SP_BGR_ORDER			0x0008		// set when calling fs_NewTransformation()

#define SPCF_iupxCalled				0x0001		// individual bits of GlobalGS.subPixelCompatibilityFlags
#define SPCF_iupyCalled				0x0002
#define SPCF_inDiagEndCtrl			0x0004
#define SPCF_inVacuformRound		0x0008
#define SPCF_inSkippableDeltaFn		0x0010
#define SPCF_detectedDandIStroke	0x0100
#define SPCF_detectedJellesSpacing	0x0200
#define SPCF_detectedVacuformRound	0x0400
#define SPCF_detectedTomsDiagonal	0x0800


#endif // FSCFG_SUBPIXEL

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA

	#define BADREL	0x01
	#define DONE	0x02
	#define DOING	0x04

	// Data structure for information leap. This information leap is necessary because of the following reason:
	// Technically, what we're doing is to automatically add on-the-fly in-line deltas to the stream of instructions. Such deltas appear
	// after an incoming "link" (MIRP, MDRP), but before one or more outgoing "links". If one of these outgoing links controls a stroke,
	// then this stroke's phase may need to be adjusted (by a delta). However, we don't know whether any of the outgoing links controls a
	// stroke, nor which one, until we've interpreted them all, at which point it is too late to apply a delta, because the delta has to be
	// applied before any outgoing links (dependency). Conversely, the incoming link does not bear any information that would suggest that
	// it links to a stroke (don't know the future). To make matters worse, it is possible that in the stream of instructions the link that
	// controls a stroke comes at the very end of the TT code, even though there may have been many other, unrelated instructions inbetween.
	// Therefore, we have to interpert the entire TT code (upto the IUP instruction in the SP direction) before we know all we need to 
	// calculate and apply the phase control.
	
	typedef struct {
		int16 parent0,parent1; // -1 for none
		int16 child; // for black links (we can satisfy 1 phase shift only, hence no need for several children), else -1
		uint16 flags; // BADREL, DONE, DOING
		F26Dot6 phaseShift;
	} PhaseControlRelation; // 12 bytes (?)
	
#endif

typedef struct VECTOR {
	VECTORTYPE x;
	VECTORTYPE y;
} VECTOR;

typedef struct {
	F26Dot6 *x;         /* The Points the Interpreter modifies */
	F26Dot6 *y;         /* The Points the Interpreter modifies */
	F26Dot6 *ox;        /* Old Points */
	F26Dot6 *oy;        /* Old Points */
	F26Dot6 *oox;       /* Old Unscaled Points, really ints */
	F26Dot6 *ooy;       /* Old Unscaled Points, really ints */
	uint8   *onCurve;   /* indicates if a point is on or off the curve */
	int16   *sp;        /* Start points */
	int16   *ep;        /* End points */
	uint8   *f;         /* Internal flags, one byte for every point */
	int16   nc;         /* Number of contours */
	uint8   *fc;         /* contour flags, one byte for every contour */
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	boolean phaseControlExecuted;
	PhaseControlRelation *pcr;
#endif
} fnt_ElementType;

/* flags for contour flags : */
#define OUTLINE_MISORIENTED 1

typedef struct {
	int32 start;        /* offset to first instruction */
	uint16 length;      /* number of bytes to execute <4> */
	uint16 pgmIndex;    /* index to appropriate preprogram for this func (0..1) */
} fnt_funcDef;

/* <4> pretty much the same as fnt_funcDef, with the addition of opCode */
typedef struct {
	int32 start;
	uint16 length;
	uint8  pgmIndex;
	uint8  opCode;
} fnt_instrDef;

typedef struct {
	uint8 *    Instruction;
	uint32     Length;
} fnt_pgmList;

struct fnt_LocalGraphicStateType;
typedef void (FS_CALLBACK_PROTO *FntTraceFunc)(struct fnt_LocalGraphicStateType*, uint8*);

#ifdef FSCFG_REENTRANT
typedef uint8* (*FntFunc)(struct fnt_LocalGraphicStateType*, uint8*, int32);
typedef void (*FntMoveFunc)(struct fnt_LocalGraphicStateType*, fnt_ElementType*, int32, F26Dot6);
typedef F26Dot6 (*FntProject)(struct fnt_LocalGraphicStateType*, F26Dot6, F26Dot6);
typedef void (*InterpreterFunc)(struct fnt_LocalGraphicStateType*, uint8*, uint8*);
typedef F26Dot6 (*FntRoundFunc)(struct fnt_LocalGraphicStateType*, F26Dot6, F26Dot6);
#else 
typedef uint8* (*FntFunc)(uint8*, int32);
typedef void (*FntMoveFunc)(fnt_ElementType*, int32, F26Dot6);
typedef F26Dot6 (*FntProject)(F26Dot6 x, F26Dot6 y);
typedef void (*InterpreterFunc)(uint8*, uint8*);
typedef F26Dot6 (*FntRoundFunc)(F26Dot6 xin, F26Dot6 engine);
#endif 

typedef struct {

/* PARAMETERS CHANGEABLE BY TT INSTRUCTIONS */
	F26Dot6 wTCI;                   /* width table cut in */
	F26Dot6 sWCI;                   /* single width cut in */
	F26Dot6 scaledSW;               /* scaled single width */
	int32 scanControl;              /* controls kind and when of dropout control */
	int32 instructControl;          /* controls gridfitting and default setting */
	
	F26Dot6 minimumDistance;        /* moved from local gs  7/1/90  */
	FntRoundFunc RoundValue;        /*                              */
#ifdef FSCFG_SUBPIXEL
	uint16		roundState;			// see comments in interp.c
#endif
	F26Dot6 periodMask;             /* ~(gs->period-1)              */
	VECTORTYPE period45;            /*                              */
	int16   period;                 /* for power of 2 periods       */
	int16   phase;                  /*                              */
	int16   threshold;              /* moved from local gs  7/1/90  */

	int16 deltaBase;
	int16 deltaShift;
	int16 angleWeight;
	int16 sW;                       /* single width, expressed in the same units as the character */
	int8 autoFlip;                  /* The auto flip Boolean */
	int8 pad;   
#ifndef FSCFG_NOPAD_PARAMETER_BLOCK_4
	int16 pad2;   
#endif 
} fnt_ParameterBlock;               /* this is exported to client */

#define PREPROGRAM     0
#define FONTPROGRAM    1
#define GLYPHPROGRAM   2

#define MAXPREPROGRAMS 2

#ifdef FSCFG_SUBPIXEL
	#define maxDeltaFunctions	4
#endif

typedef struct fnt_ScaleRecord {
	Fixed fixedScale;       /* Slow Scale */
	int32 denom;            /* Fast and Medium Scale */
	int32 numer;            /* Fast and Medium Scale */
	int32 shift;            /* Fast Scale */
} fnt_ScaleRecord;

typedef F26Dot6 (*GlobalGSScaleFunc)(fnt_ScaleRecord*, F26Dot6);

typedef struct fnt_GlobalGraphicStateType {
	F26Dot6* stackBase;             /* the stack area */
	F26Dot6* store;                 /* the storage area */
	F26Dot6* controlValueTable;     /* the control value table */
	
	uint16  pixelsPerEm;            /* number of pixels per em as an integer */
	uint16  pointSize;              /* the requested point size as an integer */
	Fixed   fpem;                   /* fractional pixels per em    <3> */
	F26Dot6 engine[4];              /* Engine Characteristics */
	
	fnt_ParameterBlock defaultParBlock; /* variables settable by TT instructions */
	fnt_ParameterBlock localParBlock;

	/* Only the above is exported to Client throught FontScaler.h */

/* VARIABLES NOT DIRECTLY MANIPULABLE BY TT INSTRUCTIONS  */
	
	fnt_funcDef*    funcDef;           /* function Definitions identifiers */
	fnt_instrDef*   instrDef;         /* instruction Definitions identifiers */
	GlobalGSScaleFunc ScaleFuncXChild; /* child scaling when !bSameTransformAsMaster */
	GlobalGSScaleFunc ScaleFuncYChild; /* child scaling when !bSameTransformAsMaster */
	GlobalGSScaleFunc ScaleFuncX;
	GlobalGSScaleFunc ScaleFuncY;
	GlobalGSScaleFunc ScaleFuncCVT;
	fnt_pgmList     pgmList[MAXPREPROGRAMS];  /* each program ptr is in here */
	
/* These are parameters used by the call back function */
	fnt_ScaleRecord   scaleXChild; /* child scaling when !bSameTransformAsMaster */
	fnt_ScaleRecord   scaleYChild; /* child scaling when !bSameTransformAsMaster */
	fnt_ScaleRecord   scaleX;
	fnt_ScaleRecord   scaleY;
	fnt_ScaleRecord   scaleCVT;

	Fixed           cvtStretchX;
	Fixed           cvtStretchY;

	int8            identityTransformation;  /* true/false  (does not mean identity from a global sense) */
	int8            non90DegreeTransformation; /* bit 0 is 1 if non-90 degree, bit 1 is 1 if x scale doesn't equal y scale */
	Fixed           xStretch;           /* Tweaking for glyphs under transformational stress <4> */
	Fixed           yStretch;           /* Tweaking for glyphs under transformational stress <4> */
	
	int8            init;               /* executing preprogram ?? */
	/* !!! Should not be uint8, instead fnt_ProgramIndex */
	uint8           pgmIndex;           /* which preprogram is current */
	int32           instrDefCount;      /* number of currently defined IDefs */
	uint8			bSameStretch;
	uint8			bCompositeGlyph;	/* Flag that indicates composite glyph */
	LocalMaxProfile *	 maxp;
	uint16          cvtCount;
	Fixed           interpScalarX;      /* scalar for instructable things */
	Fixed           interpScalarY;      /* scalar for instructable things */
	Fixed           fxMetricScalarX;    /* scalar for metric things */
	Fixed           fxMetricScalarY;    /* scalar for metric things */
	/* int16  pad2; */

	boolean	bHintForGray;
	uint8			bSameTransformAsMaster;	/* for composite glyph, indicate the the sub-componenent has the same scaling than the master glyph */
	uint8			bOriginalPointIsInvalid;/* original point are invalid, we need to use ox/oy instead of scaling oox/ooy */

	uint32		ulMaxJumpCounter;			/* jump counter used to catch infinite loops */
	uint32		ulMaxRecursiveCall;		/* recursive calls counter used to check the level of recursion */
    ClientIDType            clientID;  /* client private id/stamp, it's saved here to allow a trace function to access it */
#ifdef FSCFG_SECURE
	F26Dot6* stackMax;             /* maximum stack area */
	int32      maxPointsIncludePhantom;  /* in an individual glyph, including maxCompositePoints  */
#endif // FSCFG_SECURE
	uint16	uBoldSimulVertShift; /* vertical and horizontal (along baseline) shift for embolding simulation */
	uint16	uBoldSimulHorShift;
	F26Dot6	fxScaledDescender; /* scaled descender, used to clip emboldening if necessary */
#ifdef FSCFG_SUBPIXEL
	uint16	flHintForSubPixel;
	uint16	subPixelCompatibilityFlags;
	uint16	numDeltaFunctionsDetected;		  // fns to implement delta instr for range of ppem sizes or odd delta size use SHPIX,
	uint16	deltaFunction[maxDeltaFunctions]; // keep track of these cases to intelligently skip SHPIX
	Fixed	compatibleWidthStemConcertina;
#endif // FSCFG_SUBPIXEL
	boolean bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
									   or text animation where we want to turn off gridfitting hinting
									   but for fonts where glyphs are build by hinting, we still want the
									   glyph shape to be correct */
} fnt_GlobalGraphicStateType;

/* 
 * This is the local graphics state  
 */
typedef struct fnt_LocalGraphicStateType {
	fnt_ElementType *CE0, *CE1, *CE2;   /* The character element pointers */
	VECTOR proj;                        /* Projection Vector */
	VECTOR free;                        /* Freedom Vector */
	VECTOR oldProj;                     /* Old Projection Vector */
	F26Dot6 *stackPointer;

	uint8 *insPtr;                      /* Pointer to the instruction we are about to execute */
	fnt_ElementType *elements;
	fnt_GlobalGraphicStateType *globalGS;
		FntTraceFunc TraceFunc;

	int32 Pt0, Pt1, Pt2;           /* The internal reference points */
	int16 roundToGrid;
	int32 loop;                         /* The loop variable */
	uint8 opCode;                       /* The instruction we are executing */
	uint8 padByte;
	int16 padWord;

	/* Above is exported to client in FontScaler.h */

	VECTORTYPE pfProj; /* = pvx * fvx + pvy * fvy */

	FntMoveFunc MovePoint;
	FntProject Project;
	FntProject OldProject;
	InterpreterFunc Interpreter;
#ifdef FSCFG_REENTRANT
		F26Dot6 (*GetCVTEntry) (struct fnt_LocalGraphicStateType*,int32);
		F26Dot6 (*GetSingleWidth) (struct fnt_LocalGraphicStateType*);
#else 
		F26Dot6 (*GetCVTEntry) (int32 n);
		F26Dot6 (*GetSingleWidth) (void);
#endif 
	FntMoveFunc ChangeCvt;
	Fixed       cvtDiagonalStretch;

	int16       MIRPCode;               /* for fast or slow MIRP's */

	ErrorCode   ercReturn;              /* NO_ERR unless illegal instruction */
	uint8       *pbyEndInst;            /* one past last instruction */
	uint8       *pbyStartInst;          /* used to detect a jump before the begining of the program */

	uint32		ulJumpCounter;			/* jump counter used to catch infinite loops */
	uint32		ulRecursiveCall;		/* recursive calls counter used to check the level of recursion */
#ifdef FSCFG_SUBPIXEL
	uint16		inSubPixelDirection;
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	int16		pt0,pt1;
#endif
#endif
} fnt_LocalGraphicStateType;

#endif  /* FNT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fontmath.c ===
/*
	File:       FontMath.c

	Contains:   xxx put contents here xxx

	Written by: xxx put writers here xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		  <>     2/21/97	CB		ClaudeBe, add mth_UnitarySquare for scaled component in composite glyphs
		 <3>     11/9/90    MR      Fix CompDiv when numer and denom have zero hi longs. [rb]
		 <2>     11/5/90    MR      Remove Types.h from include list, rename FixMulDiv to LongMulDiv
									[rb]
		 <1>    10/20/90    MR      Math routines for font scaler. [rj]

	To Do:
*/

#define FSCFG_INTERNAL

#include "fscdefs.h"
#include "fserror.h"
#include "fontmath.h"


#define HIBITSET                      0x80000000UL
#define POSINFINITY               0x7FFFFFFFUL
#define NEGINFINITY               0x80000000UL
#define POINTSPERINCH               72
#define ALMOSTZERO 33
#define ISNOTPOWEROF2(n)        ((n) & ((n)-1))
#define CLOSETOONE(x)   ((x) >= ONEFIX-ALMOSTZERO && (x) <= ONEFIX+ALMOSTZERO)
#define MAKEABS(x)  if (x < 0) x = -x
#define FXABS(x)  ((x) >= 0L ? (x) : -(x))
#define FRACT2FIX(n)    (((n) + (1 << (sizeof (Fract) - 3))) >> 14)

#define FASTMUL26LIMIT      46340
#define FASTDIV26LIMIT  (1L << 25)

#define USHORTMUL(a, b) ((uint32)((uint32)(uint16)(a)*(uint32)(uint16)(b)))

boolean mth_Max45Trick (Fixed x, Fixed y);

/*******************************************************************/

/* local prototypes */


/*******************************************************************/


#define CompMul(src1, src2, Result)  {                           \
    *((__int64*) (Result)) = (__int64) (src1) *  (__int64) (src2);            \
    }

/*******************************************************************/


int32
CompDiv (
    int32          Denominator,
    LARGE_INTEGER  Dividend
    )
{

    uint32 Divisor;
    int32  Negate;
    uint32 Quotient;
    uint32 Remainder;
    int32  Result;

    //
    // Compute the sign of the result value. If the denominator is zero,
    // then return plus of minus infinity depending of the sign of the
    // result. Otherwise, negate the dividend and divisor as appropriate.
    //

    Negate = Denominator ^ Dividend.HighPart;
    if (Denominator == 0) {
        if (Negate < 0) {
            return NEGINFINITY;

        } else {
            return POSINFINITY;
        }
    }

    if (Denominator < 0) {
        Denominator = - Denominator;
    }

    if (Dividend.HighPart < 0) {
        Dividend.LowPart = - (LONG)Dividend.LowPart;
        if (Dividend.LowPart != 0) {
            Dividend.HighPart = ~Dividend.HighPart;

        } else {
            Dividend.HighPart = - Dividend.HighPart;
        }
    }

    //
    // If there are any high order product bits, then the quotient will
    // overflow.
    //

    Divisor = (uint32)Denominator;
    Remainder = (uint32)Dividend.HighPart;
    if (Divisor <= Remainder) {
        if (Negate < 0) {
            return NEGINFINITY;

        } else {
            return POSINFINITY;
        }
    }

    //
    // Divide the 64-bit product by the 32-bit divisor forming a 32-bit
    // quotient and a 32-bit remainder.
    //

#ifdef i386

    Quotient = (uint32)Dividend.LowPart;
        _asm {
                  mov edx,Remainder
                  mov eax,Quotient
                  div Divisor
                  mov Remainder,edx
                  mov Quotient,eax
             }
#else



    Quotient = RtlEnlargedUnsignedDivide(*(PULARGE_INTEGER)&Dividend,
                                         Divisor,
                                         &Remainder);

#endif


    //
    // Round the result if the remainder is greater than or equal to one
    // half the divisor. If the rounded quotient is zero, then overflow
    // has occured.
    //

    if (Remainder >= (Divisor >> 1)) {
        Quotient += 1;
        if (Quotient == 0) {
            if (Negate < 0) {
                return NEGINFINITY;

            } else {
                return POSINFINITY;
            }
        }
    }

    //
    // Compute the final signed result.
    //

    Result = (int32)Quotient;
    if (Negate >= 0) {
        if (Result >= 0) {
            return Result;

        } else {
            return POSINFINITY;
        }

    } else {
        if ((Result >= 0) || ((Result < 0) && (Quotient == 0x80000000))) {
            return - Result;

        } else {
            return NEGINFINITY;
        }
    }
}


/*******************************************************************/

/*
 *  a*b/c
 */
int32 FS_ENTRY_PROTO LongMulDiv(int32 a, int32 b, int32 c)
{
        LARGE_INTEGER temp;

        CompMul(a, b, &temp);
        return CompDiv(c, temp);
}

/*******************************************************************/

F26Dot6 ShortFracMul (F26Dot6 aDot6, ShortFract b)
{
        LARGE_INTEGER Temp;
	uint32      ulLow;
	F26Dot6     fxProduct;

        CompMul(aDot6, b, &Temp);

        ulLow = (((uint32)Temp.LowPart) >> 13) + 1;           /* rounds up */
        fxProduct = (F26Dot6)(Temp.HighPart << 18) + (F26Dot6)(ulLow >> 1);

	return (fxProduct);
}

/*******************************************************************/

ShortFract FS_ENTRY_PROTO ShortFracDot (ShortFract a, ShortFract b)
{
	return (ShortFract)((((int32)a * (int32)b) + (1L << 13)) >> 14);
}


int32 ShortMulDiv(int32 a, int16 b, int16 c)
{
	return LongMulDiv(a, (int32)b, (int32)c);
}

int16 MulDivShorts (int16 a, int16 b, int16 c)
{
	return (int16)LongMulDiv((int32)a, (int32)b, (int32)c);
}

/*
 *  Total precision routine to multiply two 26.6 numbers        <3>
 */
F26Dot6 Mul26Dot6(F26Dot6 a, F26Dot6 b)
{
	 int32 negative = false;
	uint16 al, bl, ah, bh;
	uint32 lowlong, midlong, hilong;

	if ((a <= FASTMUL26LIMIT) && (b <= FASTMUL26LIMIT) && (a >= -FASTMUL26LIMIT) && (b >= -FASTMUL26LIMIT))
		  return (F26Dot6)(((int32)a * b + (1 << 5)) >> 6);                            /* fast case */

	if (a < 0) { a = -a; negative = true; }
	if (b < 0) { b = -b; negative ^= true; }

	 al = FS_LOWORD(a); ah = FS_HIWORD(a);
	 bl = FS_LOWORD(b); bh = FS_HIWORD(b);

	midlong = USHORTMUL(al, bh) + USHORTMUL(ah, bl);
	 hilong = USHORTMUL(ah, bh) + (uint32)FS_HIWORD(midlong);
	midlong <<= 16;
	midlong += 1 << 5;
	lowlong = USHORTMUL(al, bl) + midlong;
	hilong += (uint32)(lowlong < midlong);

	midlong = (lowlong >> 6) | (hilong << 26);
	if( negative)
	{
		return  (F26Dot6)-((int32)midlong);
	}
	else
	{
		return (F26Dot6)midlong;
	}
}

/*
 *  Total precision routine to divide two 26.6 numbers          <3>
 */
F26Dot6 Div26Dot6(F26Dot6 num, F26Dot6 den)
{
	 int32 negative = false;
	uint32 hinum, lownum, hiden, lowden, result, place;

	if (den == 0L)
	{
		if (num < 0L )
		{
				return (F26Dot6)NEGINFINITY;
		}
		else
		{
			return (F26Dot6)POSINFINITY;
		}
	}

	if ( (num <= FASTDIV26LIMIT) && (num >= -FASTDIV26LIMIT) )          /* fast case */
		  return (F26Dot6)(((int32)num << 6) / den);

	if (num < 0)
	{
		num = -num;
		negative = true;
	}
	if (den < 0)
	{
		den = -den;
		negative ^= true;
	}

	hinum = ((uint32)num >> 26);
	lownum = ((uint32)num << 6);
	hiden = (uint32)den;
	lowden = 0;
	result = 0;
	place = HIBITSET;

	if (hinum >= hiden)
	{
		if( negative )
		{
				return (F26Dot6)(uint32)NEGINFINITY;
		}
		else
		{
			return (F26Dot6)POSINFINITY;
		}
	}

	while (place)
	{
		lowden >>= 1;
		if (hiden & 1)
		{
			lowden += HIBITSET;
		}
		hiden >>= 1;
		if (hiden < hinum)
		{
			hinum -= hiden;
			hinum -= (uint32)(lowden > lownum);
			lownum -= lowden;
			result += place;
		}
		else if (hiden == hinum && lowden <= lownum)
		{
			hinum = 0;
			lownum -= lowden;
			result += place;
		}
		place >>= 1;
	}

	if (negative)
	{
		return (F26Dot6)-((int32)result);
	}
	else
	{
		return (F26Dot6)result;
	}
}

ShortFract ShortFracDiv(ShortFract num,ShortFract denum)
{
	return (ShortFract)(((int32)(num) << 14) / (int32)denum);
}

ShortFract ShortFracMulDiv(ShortFract numA,ShortFract numB,ShortFract denum)
{
	return (ShortFract) LongMulDiv ((int32) numA,(int32) numB, (int32)denum);
}

/* ------------------------------------------------------------ */

#ifndef FSCFG_USE_EXTERNAL_FIXMATH
/*  Here we define Fixed [16.16] and Fract [2.30] precision 
 *  multiplication and division functions and a Fract square root 
 *  function which are compatible with those in the Macintosh toolbox.
 *
 *  The division functions load the 32-bit numerator into the "middle"
 *  bits of a 64-bit numerator, then call the 64-bit by 32-bit CompDiv()
 *  function defined above, which can return a NEGINFINITY or POSINFINITY
 *  overflow return code.
 *
 *  The multiply functions call the 32-bit by 32-bit CompMul() function
 *  defined above which produces a 64-bit result, then they extract the
 *  "interesting" 32-bits from the middle of the 64-bit result and test 
 *  for overflow.
 *
 *  The GET32(a,i) macro defined below extracts a 32-bit value with "i" 
 *  bits of fractional precision from the 64-bit value in "a", a 2-element
 *  array of longs.
 *
 *  The CHKOVF(a,i,v) macro tests the most significant bits of the 
 *  64-bit value in "a", a 2-element array of longs, and tests the 
 *  32-bit result "v" for overflow.  "v" is defined as having "i" bits
 *  of fractional precision.
 *
 *  BIT() and OVFMASK() are "helper" macros used by GET32() and CHKOVF().
 *
 *  BIT(i) returns a mask with the "i"-th bit set.
 *  OVFMASK(i) returns a mask with the most-significant "32-i" bits set.
 */

#define BIT(i)          (1L<<(i))
#define OVFMASK(i)   ( ~0L ^ ( ((uint32)BIT(i)) - 1 ) )
#define CHKOVF(a,i,v)   (\
                ( ((uint32)(a).HighPart & OVFMASK(i))==0)          ? ( (v)>=0 ?(v) :POSINFINITY) : \
                ( ((uint32)(a).HighPart & OVFMASK(i))==OVFMASK(i)) ? ( (v)<=0 ?(v) :NEGINFINITY) : \
                ( ((uint32)(a).HighPart & BIT(31))                 ? POSINFINITY   :NEGINFINITY)   \
	)

#define GET32(b,a,i) \
((((a).HighPart<<(32-(i))) | (int32)((uint32)((a).LowPart)>>(i))) + \
(int32)!!( ((a).LowPart & BIT((i)-1))  && ( b ? ( ( ((a).LowPart & ~OVFMASK(i-1) )) & ~OVFMASK(i-1) ) : TRUE ) ) )

FS_MAC_PASCAL Fixed FS_PC_PASCAL FS_ENTRY_PROTO FixMul (Fixed fxA, Fixed fxB)
{
        LARGE_INTEGER alCompProd;
	Fixed fxProd;
	int  bNegative=FALSE;

	if  (fxA == 0 || fxB == 0)
		return 0;

	if( ((fxA > 0) && (fxB < 0)) || ((fxA < 0) && (fxB > 0)) )
		bNegative = TRUE;

        CompMul ((int32)fxA, (int32)fxB, &alCompProd);

	fxProd = (Fixed)GET32 (bNegative,alCompProd,16);

	return (Fixed)CHKOVF(alCompProd,16,fxProd);
}

FS_MAC_PASCAL Fixed FS_PC_PASCAL FS_ENTRY_PROTO FixDiv (Fixed fxA, Fixed fxB)
{
        LARGE_INTEGER alCompProd;
	
        alCompProd.HighPart = fxA >> 16;
        alCompProd.LowPart = fxA << 16;

        return CompDiv ((int32)fxB, alCompProd);
}

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixRatio (int16 sA, int16 sB)
{
        LARGE_INTEGER alCompProd;
	
        alCompProd.HighPart = ((int32)(sA)) >> 16;
        alCompProd.LowPart = ((int32)(sA)) << 16;

        return CompDiv ((int32)(sB), alCompProd);
}

FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul (Fract frA, Fract frB)
{
        LARGE_INTEGER alCompProd;
	Fract frProd;
	int  bNegative=FALSE;

	if  (frA == 0 || frB == 0)
		return 0;

	if( ((frA > 0) && (frB < 0)) || ((frA < 0) && (frB > 0)) )
		bNegative = TRUE;

        CompMul (frA,frB,&alCompProd);
	frProd = (Fract)GET32 (bNegative,alCompProd,30);

	return (Fract)CHKOVF(alCompProd,30,frProd);
}

FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv (Fract frA, Fract frB)
{
        LARGE_INTEGER alCompProd;

        alCompProd.HighPart = frA >> 2;
        alCompProd.LowPart  = frA << 30;
        return CompDiv ((int32)frB, alCompProd);
}

/*******************************************************************/

#if !defined(i386) && (!defined(MIPS) || !defined(R4000))
/* 
   Fract FracSqrt (Fract xf)
   Input:  xf           2.30 fixed point value
   Return: sqrt(xf)     2.30 fixed point value
*/

FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt (Fract xf)
{
	Fract b = 0L;
	uint32 c, d, x = xf;
	
	if (xf < 0) return (NEGINFINITY);

	/*
	The algorithm extracts one bit at a time, starting from the
	left, and accumulates the square root in b.  The algorithm 
	takes advantage of the fact that non-negative input values
	range from zero to just under two, and corresponding output
	ranges from zero to just under sqrt(2).  Input is assigned
	to temporary value x (unsigned) so we can use the sign bit
	for more precision.
	*/
	
	if (x >= 0x40000000)
	{
		x -= 0x40000000; 
		b  = 0x40000000; 
	}

	/*
	This is the main loop.  If we had more precision, we could 
	do everything here, but the lines above perform the first
	iteration (to align the 2.30 radix properly in b, and to 
	preserve full precision in x without overflow), and afterward 
	we do two more iterations.
	*/
	
	for (c = 0x10000000; c; c >>= 1)
	{
		d = b + c;
		if (x >= d)
		{
			x -= d; 
			b += (c<<1); 
		}
		x <<= 1;
	}

	/*
	Iteration to get last significant bit.
	
	This code has been reduced beyond recognition, but basically,
	at this point c == 1L>>1 (phantom bit on right).  We would
	like to shift x and d left 1 bit when we enter this iteration,
	instead of at the end.  That way we could get phantom bit in
	d back into the word.  Unfortunately, that may cause overflow
	in x.  The solution is to break d into b+c, subtract b from x,
	then shift x left, then subtract c<<1 (1L).
	*/
	
	if (x > (uint32)b) /* if (x == b) then (x < d).  We want to test (x >= d). */
	{
		x -= b;
		x <<= 1;
		x -= 1L;
		b += 1L; /* b += (c<<1) */
	}
	else
	{
		x <<= 1;
	}

	/* 
	Final iteration is simple, since we don't have to maintain x.
	We just need to calculate the bit to the right of the least
	significant bit in b, and use the result to round our final answer.
	*/
	
	return ( b + (Fract)(x>(uint32)b) );
}

#endif  /* FracSqrt */

/*******************************************************************/

#endif


/* TRANSFORMATION ROUTINES */

/*
 *  Good for transforming fixed point values.  Assumes NO translate  <4>
 */
void mth_FixXYMul (Fixed*x, Fixed*y, transMatrix*matrix)
{
  Fixed xTemp, yTemp;
  Fixed *m0, *m1;

  m0 = (Fixed *) & matrix->transform[0][0];
  m1 = (Fixed *) & matrix->transform[1][0];

  xTemp = *x;
  yTemp = *y;
  *x = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);
  *y = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);

#ifndef PC_OS   /* Never a perspecitive with Windows */ /* !!!DISCUSS   */

  if (*m0 || *m1)     /* these two are Fracts */
  {
	Fixed tmp = FracMul (*m0, xTemp) + FracMul (*m1, yTemp);
	tmp += matrix->transform[2][2];
	if (tmp && tmp != ONEFIX)
	{
	  *x = FixDiv (*x, tmp);
	  *y = FixDiv (*y, tmp);
	}
  }
#endif
}


/*
 *  This could be faster        <4>
 */
void mth_FixVectorMul (vectorType*v, transMatrix*matrix)
{
  mth_FixXYMul (&v->x, &v->y, matrix);
}


/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void mth_MxConcat2x2 (transMatrix*A, transMatrix*B)
{
  Fixed storage[6];
  Fixed * s = storage;
  int32 i, j;

  for (j = 0; j < 2; j++)
	for (i = 0; i < 3; i++)
	  *s++ = FixMul (A->transform[j][0], B->transform[0][i]) + FixMul (A->transform[j][1], B->transform[1][i]);

  {
	Fixed*dst = &B->transform[2][0];
	Fixed*src = s;
	int16 i;
	for (i = 5; i >= 0; --i)
	  *--dst = *--src;
  }
}


/*
 * scales a matrix by sx and sy.
 *
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 *
 */
void mth_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB)
{
  int32       i;
  Fixed  *m = (Fixed *) & matrixB->transform[0][0];

  for (i = 0; i < 3; i++, m++)
	*m = FixMul (sx, *m);

  for (i = 0; i < 3; i++, m++)
	*m = FixMul (sy, *m);
}


/*
 *  Return 45 degreeness
 */
#ifndef PC_OS   /* !!!DISCUSS   */
boolean mth_Max45Trick (Fixed x, Fixed y)
{
  MAKEABS (x);
  MAKEABS (y);

  if (x < y)      /* make sure x > y */
  {
	Fixed z = x;
	x = y;
	y = z;
  }

  return  (x - y <= ALMOSTZERO);
}
#else
  #define mth_Max45Trick(x,y)     (x == y || x == -y)
#endif


/*
 *  Sets bPhaseShift to true if X or Y are at 45 degrees, flaging the outline
 *  to be moved in the low bit just before scan-conversion.
 *  Sets [xy]Stretch factors to be applied before hinting.
 *  Returns true if the contours need to be reversed.
 */
boolean mth_IsMatrixStretched (transMatrix*trans)
{
  Fixed*matrix = &trans->transform[0][0];
  Fixed x, y;
  int32 i;
  boolean   bPhaseShift;

  bPhaseShift = FALSE;

  for (i = 0; i < 2; i++, matrix++)
  {
	x = *matrix++;
	y = *matrix++;
	bPhaseShift |= mth_Max45Trick (x, y);
  }
  return( bPhaseShift );
}


/*
 * Returns true if we have the identity matrix.
 */

boolean mth_PositiveSquare (transMatrix *matrix)
{
	return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] >= 0);
}

boolean mth_Identity (transMatrix *matrix)
{
	return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[0][0] == ONEFIX);
}


boolean mth_PositiveRectangle (transMatrix *matrix)
{
	 return (matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[0][0] >= 0 && matrix->transform[1][1] >= 0);
}

/*
 * unitary Square
 *
 *              | +-1    0  0  |
 *    matrix =  |   0  +-1  0  |
 *              |   0    0  1  |
 */

boolean mth_UnitarySquare (transMatrix *matrix)
{
	return (matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && FXABS(matrix->transform[0][0]) == FXABS(matrix->transform[1][1]) && FXABS(matrix->transform[0][0]) == ONEFIX);
}

boolean mth_SameStretch (Fixed fxScaleX, Fixed fxScaleY)
{
	return(fxScaleX == fxScaleY);
}

boolean mth_GeneralRotation (transMatrix *matrix)
{
  return ((matrix->transform[0][0] || matrix->transform[1][1]) && (matrix->transform[1][0] || matrix->transform[0][1]));
}

/* for a rotation that is a multiple of 90 degrees, return the multiplier factor */
/* for non 90 degree rotations, return 4  (this is used for sbit rotations) */

uint16 mth_90degRotationFactor (transMatrix *matrix)
{
	if (matrix->transform[1][0] == 0 && matrix->transform[0][1] == 0)
    {
    	if (matrix->transform[0][0] > 0 && matrix->transform[1][1] > 0)
            return (0);
    	else if (matrix->transform[0][0] < 0 && matrix->transform[1][1] < 0)
            return (2);
    }
	else if (matrix->transform[0][0] == 0 && matrix->transform[1][1] == 0)
    {
        if (matrix->transform[1][0] < 0 && matrix->transform[0][1] > 0)
            return (1);
       	else if (matrix->transform[1][0] > 0 && matrix->transform[0][1] < 0)
            return (3);
	}
    return (4);                 /* non 90 degree rotation */
}

uint16 mth_90degRotationFactorForEmboldening (transMatrix *matrix)
{
	if (matrix->transform[1][0] == 0 && matrix->transform[0][1] == 0)
    {
		if (matrix->transform[0][0] > 0){
			if(matrix->transform[1][1] > 0)
				return (0);	// 0 degree with sx>0 & sy>0 or 180 degree with sx<0 & sy<0
			else
				return (4); // 0 degree with sx>0 & sy<0 or 180 degree with sx<0 & sy>0
		}
		else if (matrix->transform[0][0] < 0){
			if(matrix->transform[1][1] < 0)
				return (2); // 180 degree with sx>0 & sy>0 or 0 degree with sx<0 & sy<0
			else
				return (6); // 180 degree with sx>0 & sy<0 or 0 degree with sx<0 & sy>0
		}
    }
	else if (matrix->transform[0][0] == 0 && matrix->transform[1][1] == 0)
    {
        if (matrix->transform[1][0] < 0){
			if(matrix->transform[0][1] > 0)
				return (1); // 90 degree with sx>0 & sy>0 or 270 degree with sx<0 & sy<0
			else
				return (7); // 270 degree with sx>0 & sy<0 or 90 degree with sx<0 & sy>0
		}
       	else if (matrix->transform[1][0] > 0){
			if(matrix->transform[0][1] < 0)
				return (3); // 270 degree with sx>0 & sy>0 or 90 degree with sx<0 & sy<0
			else
				return (5); // 90 degree with sx>0 & sy<0 or 270 degree with sx<0 & sy>0
		}
	}
    return (8);                 /* non 90 degree rotation */
}

/* This is for Italic simulation.

/* return values with non-vertical
			Sx>0 & Sy>0		Sx>0 & Sy<0		Sx<0 & Sy>0		Sx<0 & Sy<0
0   degree	0				4				6				2
90  degree	1				5				7				3
180 degree	2				6				4				0
270 degree	3				7				5				1

/* return values with vertical
			Sx>0 & Sy>0		Sx>0 & Sy<0		Sx<0 & Sy>0		Sx<0 & Sy<0
0   degree	1				7				5				3
90  degree	2				4				6				0
180 degree	3				5				7				1
270 degree	0				6				4				2
*/

uint16 mth_90degClosestRotationFactor (transMatrix *matrix)
{
	if (matrix->transform[0][0] > 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] > 0 ||
        matrix->transform[0][0] > 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] > 0 ) 
        return (0); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] > 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] == 0 ) 
        return (1); 
	else if (matrix->transform[0][0] < 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] < 0 ) 
        return (2); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] ==  0 ) 
        return (3); 
	else if (matrix->transform[0][0] > 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] < 0 ||
			 matrix->transform[0][0] > 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] < 0 ) 
        return (4); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] == 0 ) 
        return (5); 
	else if (matrix->transform[0][0] < 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] > 0 ) 
        return (6); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] > 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] ==  0 ) 
        return (7); 
    // anything else
    else
        return (8); 
}

void mth_Non90DegreeTransformation(transMatrix *matrix, boolean *non90degreeRotation, boolean *nonUniformStretching) {
	Fixed Xx,Xy,Yx,Yy;

	// first, we apply the matrix to the base vectors X = (1, 0) and Y = (0, 1)
	// this seemingly trivial step tends to be a hidden trap because there are two ways to apply a matrix to a vector, prefix and postfix.
	// in the rasterizer we seem to apply matrices as postfix operators, i.e.
	//
	//          (a00 a01)
	// (x, y) * (       ) = (a00*x + a10*y, a01*x + a11*y)
	//          (a10 a11)
	//
	//   apply to X = (1, 0)           apply to Y = (0, 1)
	Xx = matrix->transform[0][0]; Yx = matrix->transform[1][0];
	Xy = matrix->transform[0][1]; Yy = matrix->transform[1][1];

	// then we test whether the transformation shears the coordinates
	// if so, the transformed base vectors are no longer perpendicular, so we test their dot product against 0
	// notice that due to the limited precision of the fixed point representation , we may introduce a numerical error in general. 	
	// however, we're interested in identifying special cases like multiples of 90 rotations, for which one of the components
	// of the transformed vectors will be 0, hence the dot product should be accurate in these cases.
	if (FixMul(Xx,Yx) + FixMul(Xy,Yy) == 0) { // we're perpendicular

		// next we analyze whether the transformation rotates by a multiple of 90 or not
		// rotations which are multiples of 90 have 0s in either both non-diagonal matrix elements or both diagonal matrix elements
		// notice that this analysis includes mirrorings in x or y, which are handled in much the same way
		*non90degreeRotation = !(Xx == 0 && Yy == 0 || Xy == 0 && Yx == 0);

		// finally we analyze whether the transformation stretches the coordinates uniformly or not
		// for uniform stretchings the transformed base vectors have the same lengths
		// notice again that due to limited precision we may introduce a numerical error which we can ignore for the same reasons
		*nonUniformStretching = FixMul(Xx,Xx) + FixMul(Xy,Xy) != FixMul(Yx,Yx) + FixMul(Yy,Yy);
	
	} else { // we're sheared
		
		// here, we analyze whether the transformation rotates the x-axis by a multiple of 90 or not
		// we do not consider the y-axis because we don't want to exclude italicized fonts
		// for a multiple of 90 rotation, the transformed base vector X is either [anti-]parallel or perpendicular to its original
		// to be perpendicular, its x-component must be 0, hence a00 = 0; to be [anti-]parallel, its y-component must be 0, hence a01 = 0
		*non90degreeRotation = !(Xx == 0 || Xy == 0);

		// finally, we need to know whether the transformation stretches the coordinates at all
		// we know already that the stretching is not uniform, except in the unlikely case that the transformation rotates the y-axis
		// relative to the x-axis, which is a combination of stretching in y (actually, squeezing) by a particular amount, followed by
		// shearing, which stretches the y-axis again. For the correct combination of squeezing and shearing, this yields a uniform
		// stretching. For italicizing characters, this is an unlikely scenario, as italics tend to have the same [x-]height as their
		// roman ancestors. Italicizing is achieved by a shearing without separate stretching, which is a much more likely scenario.
		// For the reasons of their likelyhood, we consider shearing a uniform stretching, but not the rotation of the y-axis. Further-
		// more, for the purpose of identifying special cases, we do so only for rotations by multiples of 90, and only if the area
		// of the parallelogram defined by the two transformed base vectors remains 1, which is what happens under shearing. The area
		// of the parallelogram equals the determinant of the matrix. All other cases are considered proper non-uniform stretchings.
		
		*nonUniformStretching = *non90degreeRotation || FixMul(Xx,Xx) + FixMul(Xy,Xy) != ONEFIX || FixMul(Xx,Yy) - FixMul(Xy,Yx) != ONEFIX;
	}

} // mth_Non90DegreeTransformation

/*
 * mth_GetShift
 * return 2log of n if n is a power of 2 otherwise -1;
 */
int32 mth_GetShift( uint32 n )
{
		if (ISNOTPOWEROF2(n) || !n)
				return -1;
		else
				return mth_CountLowZeros( n );
}

int32 mth_CountLowZeros( uint32 n )
{
		  int32 shift = 0;
		  uint32    one = 1;
		for (shift = 0; !( n & one ); shift++)
				n >>= 1;
		return shift;
}

Fixed mth_max_abs (Fixed a, Fixed b)
{
  if (a < 0)
	a = -a;
  if (b < 0)
	b = -b;
  return (a > b ? a : b);
}

/*
 *  Call this guy before you use the matrix.  He does two things:
 *      He folds any perspective-translation back into perspective,
 *       and then changes the [2][2] element from a Fract to a fixed.
 */
void mth_ReduceMatrix(transMatrix *trans)
{
	Fixed a, *matrix = &trans->transform[0][0];
	Fract bottom = matrix[8];

/*
 *  First, fold translation into perspective, if any.
 */
	a = matrix[2];

	if (a != 0)
	{
		matrix[0] -= LongMulDiv(a, matrix[6], bottom);
		matrix[1] -= LongMulDiv(a, matrix[7], bottom);
	}

	a = matrix[5];

	if (a != 0)
	{
		matrix[3] -= LongMulDiv(a, matrix[6], bottom);
		matrix[4] -= LongMulDiv(a, matrix[7], bottom);
	}
	matrix[6] = matrix[7] = 0;
	matrix[8] = FRACT2FIX(bottom);      /* make this guy a fixed for XYMul routines */
}

void mth_IntelMul (
	int32           lNumPts,
	F26Dot6 *       fxX,
	F26Dot6 *       fxY,
	transMatrix *   trans,
	Fixed           fxXStretch,
	Fixed           fxYStretch)

{
	Fixed   fxM00;
	Fixed   fxM01;
	Fixed   fxM10;
	Fixed   fxM11;
	Fixed   fxOrigX;
	Fixed   fxOrigY;

	if (fxXStretch == 0L || fxYStretch == 0L)
	{
		for (--lNumPts; lNumPts >= 0; --lNumPts)
		{
			*fxY++ = 0;
			*fxX++ = 0;
		}
	}
	else
	{
		if(fxXStretch != ONEFIX)
		{
			fxM00 = FixDiv (trans->transform[0][0], fxXStretch);
			fxM01 = FixDiv (trans->transform[0][1], fxXStretch);
		}
		else
		{
			fxM00 = trans->transform[0][0];
			fxM01 = trans->transform[0][1];
		}

		if(fxYStretch != ONEFIX)
		{
			fxM10 = FixDiv (trans->transform[1][0], fxYStretch);
			fxM11 = FixDiv (trans->transform[1][1], fxYStretch);
		}
		else
		{
			fxM10 = trans->transform[1][0];
			fxM11 = trans->transform[1][1];
		}

		for (--lNumPts; lNumPts >= 0; --lNumPts)
		{
			fxOrigX = *fxX;
			fxOrigY = *fxY;

			*fxX++ = (F26Dot6) (FixMul (fxM00, fxOrigX) + FixMul (fxM10, fxOrigY));
			*fxY++ = (F26Dot6) (FixMul (fxM01, fxOrigX) + FixMul (fxM11, fxOrigY));
		}
	}
}


/*
 *  Fold the point size and resolution into the matrix
 */

void    mth_FoldPointSizeResolution(
	Fixed           fxPointSize,
	int16           sXResolution,
	int16           sYResolution,
	transMatrix *   trans)
{
	Fixed fxScale;

	fxScale = ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH);
	trans->transform[0][1] = FixMul( trans->transform[0][1], fxScale );
	trans->transform[1][1] = FixMul( trans->transform[1][1], fxScale );
	trans->transform[2][1] = FixMul( trans->transform[2][1], fxScale );

	fxScale = ShortMulDiv(fxPointSize, sXResolution, POINTSPERINCH);
	trans->transform[0][0] = FixMul( trans->transform[0][0], fxScale );
	trans->transform[1][0] = FixMul( trans->transform[1][0], fxScale );
	trans->transform[2][0] = FixMul( trans->transform[2][0], fxScale );
}


/*********************************************************************/

/*  Find the power of 2 greater than the absolute value of passed parameter  */

int32 PowerOf2(
		int32 lValue )
{
	static const int32 iTable[] = { 0, 1, 2, 2, 3, 3, 3, 3,
								  4, 4, 4, 4, 4, 4, 4, 4  };

	if (lValue < 0L)
	{
		lValue = -lValue;
	}

	if (lValue < (1L << 16))
	{
		if (lValue < (1L << 8))
		{
			if (lValue < (1L << 4))
			{
				return (iTable[lValue]);
			}
			else
			{
				return (iTable[lValue >> 4] + 4);
			}
		}
		else
		{
			if (lValue < (1L << 12))
			{
				return (iTable[lValue >> 8] + 8);
			}
			else
			{
				return (iTable[lValue >> 12] + 12);
			}
		}
	}
	else
	{
		if (lValue < (1L << 24))
		{
			if (lValue < (1L << 20))
			{
				return (iTable[lValue >> 16] + 16);
			}
			else
			{
				return (iTable[lValue >> 20] + 20);
			}
		}
		else
		{
			if (lValue < (1L << 28))
			{
				return (iTable[lValue >> 24] + 24);
			}
			else
			{
				return (iTable[lValue >> 28] + 28);
			}
		}
	}
}

/********************************************************************/



/* divide by shifting for translation invariant negatives */

FS_PUBLIC int16 mth_DivShiftShort(int16 sValue, int16 sFactor)
{
	return (int16)mth_DivShiftLong((int32)sValue, sFactor);
}

FS_PUBLIC int32 mth_DivShiftLong(int32 lValue, int16 sFactor)
{
	switch (sFactor)
	{
	case 0:
	case 1:
		break;
	case 2:
		lValue >>= 1;
		break;
	case 4:
		lValue >>= 2;
		break;
	case 8:
		lValue >>= 3;
		break;
	default:
		if (lValue >= 0)
		{
			lValue /= (int32)sFactor;
		}
		else
		{
			lValue = ((lValue - (int32)sFactor + 1) / (int32)sFactor);
		}
		break;
	}
	return lValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fontmath.h ===
/*
		File:           fontmath.h

		Contains:       xxx put contents here xxx

		Written by:     xxx put writers here xxx

		Copyright:      c 1990 by Apple Computer, Inc., all rights reserved.
						(c) 1989-1997. Microsoft Corporation, all rights reserved.

		Change History (most recent first):

				  <>     2/21/97		CB				ClaudeBe, add mth_UnitarySquare for scaled component in composite glyphs
				 <4>    11/27/90        MR              make pascal declaration a macro, conditionalize traps -vs-
																		externs for Fix/Frac math routines. [ph]
				 <3>     11/5/90        MR              Move [U]SHORTMUL into fscdefs.h Rename FixMulDiv to LongMulDiv.
																		[rb]
				 <2>    10/20/90        MR              Add some new math routines (stolen from skia). [rj]
				 <1>     4/11/90        dba             first checked in

		To Do:
*/

#define HIWORDMASK              0xffff0000
#define LOWORDMASK              0x0000ffff
#define DOT6ONEHALF             0x00000020
#define ONESHORTFRAC            (1 << 14)

#define ROUNDFIXTOINT( x )      (int16)((((Fixed) x) + ONEHALFFIX) >> 16)
#define ROUNDFIXED( x )         (((x) + (Fixed)ONEHALFFIX) & (Fixed)HIWORDMASK)
#define DOT6TOFIX(n)            ((Fixed) (n) << 10)
#define FIXEDTODOT6(n)          (F26Dot6) (((n) + ((1) << (9))) >> 10)
#define INTTOFIX(n)             ((Fixed) (n) << 16)
#define INTTODOT6(n)            ((F26Dot6) (n) << 6)
#define FS_HIWORD(n)            ((uint16)((uint32)(n) >> 16))
#define FS_LOWORD(n)            ((uint16)(n))
#define LOWSIXBITS              0x3F


#ifndef __TOOLUTILS__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FS_ENTRY_PROTO FixMul(Fixed,Fixed)   FS_MAC_TRAP(0xA868);
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixRatio (int16 sA, int16 sB);
#endif

#ifndef __FIXMATH__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FS_ENTRY_PROTO FixDiv(Fixed,Fixed)  FS_MAC_TRAP(0xA84D);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul(Fract,Fract) FS_MAC_TRAP(0xA84A);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv(Fract,Fract) FS_MAC_TRAP(0xA84B);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt(Fract)      FS_MAC_TRAP(0xA849);
#endif



ShortFract      FS_ENTRY_PROTO  ShortFracDot (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR ShortFracMul (F26Dot6 x, ShortFract y);
ShortFract      TMP_CONV NEAR ShortFracDiv (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR Mul26Dot6 (F26Dot6 a, F26Dot6 b);
F26Dot6         TMP_CONV NEAR Div26Dot6 (F26Dot6 num, F26Dot6 den);
int16           TMP_CONV NEAR MulDivShorts (int16 x, int16 y, int16 z);


#define MulDiv26Dot6(a,b,c) LongMulDiv(a,b,c)

int32 FS_ENTRY_PROTO LongMulDiv(int32 a, int32 b, int32 c);     /* (a*b)/c */

int32 ShortMulDiv(int32 a, int16 b, int16 c);     /* (a*b)/c */

ShortFract ShortFracMulDiv(ShortFract,ShortFract,ShortFract);

void mth_FixXYMul (Fixed* x, Fixed* y, transMatrix* matrix);
void mth_FixVectorMul (vectorType* v, transMatrix* matrix);

/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void mth_MxConcat2x2 (transMatrix* matrixA, transMatrix* matrixB);

/*
 * scales a matrix by sx and sy.
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 */
void mth_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB);

boolean mth_IsMatrixStretched (transMatrix*trans);

boolean mth_Identity (transMatrix *matrix);
boolean mth_PositiveSquare (transMatrix *matrix);
boolean mth_PositiveRectangle (transMatrix *matrix);

/*
 * unitary Square
 *
 *              | +-1    0  0  |
 *    matrix =  |   0  +-1  0  |
 *              |   0    0  1  |
 */

boolean mth_UnitarySquare (transMatrix *matrix);

boolean mth_SameStretch (Fixed fxScaleX, Fixed fxScaleY);

boolean mth_GeneralRotation (transMatrix *matrix);
uint16 mth_90degRotationFactor (transMatrix *matrix);
uint16 mth_90degRotationFactorForEmboldening (transMatrix *matrix);
uint16 mth_90degClosestRotationFactor (transMatrix *matrix);
void mth_Non90DegreeTransformation(transMatrix *matrix, boolean *non90degreeRotation, boolean *nonUniformStretching);

int32 mth_CountLowZeros (uint32 n );
Fixed mth_max_abs (Fixed a, Fixed b);

int32 mth_GetShift (uint32 n);

void mth_ReduceMatrix(transMatrix *trans);

void mth_IntelMul (
	int32           lNumPts,
	F26Dot6 *       fxX,
	F26Dot6 *       fxY,
	transMatrix *   trans,
	Fixed           fxXStretch,
	Fixed           fxYStretch);

void    mth_FoldPointSizeResolution(
	Fixed           fxPointSize,
	int16           sXResolution,
	int16           sYResolution,
	transMatrix *   trans);

/*********************************************************************/

/*  Scan Converter Math Functions Appended for now         <5> DeanB */

/*********************************************************************/

int32 PowerOf2(
		int32                   /* + or - 32 bit value */
);

FS_PUBLIC int16 mth_DivShiftShort(int16 sValue, int16 sFactor);
FS_PUBLIC int32 mth_DivShiftLong(int32 sValue, int16 sFactor);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\sbit\util.cxx ===
/******************************Module*Header*******************************\
* Module Name: util.cxx
*
* (Brief description)
*
* Created: 18-Nov-1993 08:56:00
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
*   (#defines)
*   (#includes)
*
\**************************************************************************/


extern "C" {
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <assert.h>
#include "windows.h"
};

#include "table.h" // no function declarations only structures

#include "sbit.hxx"


/******************************Public*Routine******************************\
*
* bMapFile // for read access
*
* History:
*  16-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bMapFile(PSZ pszFileName, FILEVIEW *pfvw)
{
    if (!(pfvw->hf = _lopen(pszFileName,OF_READ | OF_SHARE_EXCLUSIVE)))
    {
        fprintf(stderr,
               "can not open \"%s\".\n",
               pszFileName
               );
        return FALSE;
    }

    pfvw->cjView = SetFilePointer((HANDLE)pfvw->hf, 0, NULL, FILE_END);
    SetFilePointer((HANDLE)pfvw->hf, 0, NULL, FILE_BEGIN);

    if (!(pfvw->hm = CreateFileMapping((HANDLE)pfvw->hf,NULL,PAGE_READONLY,0,0,NULL)))
    {
        _lclose(pfvw->hf);
        fprintf(stderr,
                "can not CreateFileMapping \"%s\".\n",
                pszFileName
                );
        return FALSE;
    }

    if (!(pfvw->pjView = (BYTE *)MapViewOfFile(pfvw->hm,FILE_MAP_READ,0,0,0)))
    {
        CloseHandle(pfvw->hm);
        _lclose(pfvw->hf);
        fprintf(stderr,
                "can not MapViewOfFile \"%s\".\n",
                pszFileName
                );
        return FALSE;
    }
    return TRUE;
}

/******************************Public*Routine******************************\
*
* VOID vUnmapFile(FILEVIEW *pfvw)
* clean up
*
*
* History:
*  16-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vUnmapFile(FILEVIEW *pfvw)
{
    UnmapViewOfFile(pfvw->pjView);
    CloseHandle(pfvw->hm);
    _lclose(pfvw->hf);
}


/******************************Public*Routine******************************\
*
* VOID vSort(GINDEX *pgix, LONG cChar)
*
*
* History:
*  18-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vSort(GINDEX *pgix, LONG cChar)
{
    INT i;

    for (i = 1; i < cChar; i++)
    {
    // upon every entry to this loop the array 0,1,..., (i-1) will be sorted

        INT j;
        GINDEX gixTmp = pgix[i];

        for (j = i - 1; (j >= 0) && (pgix[j].gi > gixTmp.gi); j--)
        {
            pgix[j+1] = pgix[j];
        }
        pgix[j+1] = gixTmp;
    }

}




/******************************Public*Routine******************************\
*
* ULONG cComputeGlyphRanges(FILEVIEW *pfvw, GINDEX *pgix, LONG cChar)
*
*
* Effects:
*
* Warnings:
*
* History:
*  18-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


ULONG cComputeGlyphRanges(FILEVIEW *pfvw, GINDEX *pgix, LONG cChar, BYTE *pjCMAP)
{
    BYTE *pjLine, *pjEOF, *pjNext, *pjWord;
    BYTE  ajWord[C_BIG];
    LONG  cChar_ = 0; // for debugging
    GINDEX *pgixStart = pgix;

    pjLine = pfvw->pjView;
    pjEOF  = pfvw->pjView + pfvw->cjView;

    for (; pjLine < pjEOF; pjLine = pjNext)
    {
        if (!(pjNext = pjNextLine(pjLine, pjEOF))) return FALSE;

    // get the keyword at the beginning of the line

        pjWord = pjNextWord(pjLine,pjNext, ajWord);

        if (!strcmp((char *)ajWord,"STARTCHAR"))
        {
            ULONG lUnicode;

        // get the string identifier

            pjWord = pjNextWord(pjWord,pjNext, ajWord);

        // get unicode code point for this glyph

            pjWord = pjGetHexNumber(pjWord,pjNext, ajWord, &lUnicode);

        // get glyph index, store the offset

            pjWord = pjGetNextNumber(pjWord,pjNext, ajWord, &pgix->gi);

        // check consistency

            if (pjCMAP)
            {
                if (!bCheckGlyphIndex1(pjCMAP, (UINT)lUnicode, (UINT)pgix->gi))
                {
                    fprintf(stderr, "GlyphIndex not ok\n");
                    return FALSE;
                }
            }
            pgix->dp = (LONG)(pjLine - pfvw->pjView);

            cChar_ += 1;
            pgix++;
        }
    }

    if (cChar_ != cChar)
    {
        fprintf(stderr, "bogus cChar\n");
        return FALSE;
    }

// now we have all the glyph indicies in pgix array, we can sort the array
// and then compute the ranges of glyph indicies:

    vSort(pgixStart, cChar);

    return cComputeIndexSet(pgixStart,cChar,0,NULL);
}


/******************************Public*Routine******************************\
*
* LONG cComputeIndexSet, stolen from mapfile.c
*
* History:
*  18-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




LONG cComputeIndexSet
(
GINDEX        *pgix,     // input buffer with a sorted array of cChar supported WCHAR's
LONG           cChar,
LONG           cRuns,    // if nonzero, the same as return value
INDEXSET     *piset      // output buffer to be filled with cRanges runs
)
{
    LONG     iRun, iFirst, iFirstNext;
    LONG    *pdp, *pdpEnd = NULL;
    GINDEX  *pgixTmp;

    if (piset)
    {
        piset->cjThis  = SZ_INDEXSET(cRuns,cChar);
        piset->cRuns   = cRuns;

    // init the sum before entering the loop

        piset->cGlyphsSupported = 0;

    // glyph handles are stored at the bottom, below runs:

        pdp = (LONG *) ((BYTE *)piset + (offsetof(INDEXSET,agirun) + cRuns * sizeof(GIRUN)));
    }

// now compute cRuns if piset == 0 and fill in the glyphset if piset != 0

    for (iFirst = 0, iRun = 0; iFirst < cChar; iRun++, iFirst = iFirstNext)
    {
    // find iFirst corresponding to the next range.

        for (iFirstNext = iFirst + 1; iFirstNext < cChar; iFirstNext++)
        {
            if ((pgix[iFirstNext].gi - pgix[iFirstNext - 1].gi) > 1)
                break;
        }

        if (piset)
        {
            piset->agirun[iRun].giLow    = (USHORT)pgix[iFirst].gi;

            piset->agirun[iRun].cGlyphs  =
                (USHORT)(pgix[iFirstNext-1].gi - pgix[iFirst].gi + 1);

            piset->agirun[iRun].pdp      = pdp;

        // now store the offsets where to find glyphs in the original file

            pdpEnd = pdp + piset->agirun[iRun].cGlyphs;

            for (pgixTmp = &pgix[iFirst]; pdp < pdpEnd; pdp++,pgixTmp++)
            {
                *pdp = pgixTmp->dp;
            }

            piset->cGlyphsSupported += piset->agirun[iRun].cGlyphs;
        }
    }

#if DBG
    if (piset != NULL)
    {
        assert(iRun == cRuns);
        assert(cChar == piset->cGlyphsSupported);
    }
#endif

    return iRun;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fnterr.c ===
/**********************************************************************
	
	fnterr.c -- Error Support Routines.

	(c) Copyright 1992  Microsoft Corp.
	All rights reserved.

	This source file provides support for debugging routines in fnt.c
	(and macjob.c to a much lesser extent).  This module keys on the
	 #define FSCFG_FNTERR which is defined in fsconfig.h

	 7/28/92 dj         First cut.
	 8/12/94 deanb      included fnterr.h for mac
	12/07/94 deanb		changed %x to %hx or %lx; %d to %hd

 **********************************************************************/

#define FSCFG_INTERNAL

#include "fsconfig.h"
#include "fnterr.h"

#ifdef FSCFG_FNTERR
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/* FILE * fopen(); */
int    abs (int);
/*
int    strlen (char*);
int    strcmp (char*, char*);
int    strcpy (char*, char*);
int    strncpy( char*, char *, int);
*/

#define ERR_MAX_IFS      8
#define ERR_MAX_CODE     16
#define ERR_MAX_FNAME    80
#define ERR_MAX_MSG  512

static int               errOpc;
static int               errBreak;
static int               errIfOk  = 1;
static unsigned short    errSize  = 0;
static unsigned short    errCode  = 0;
static int               errIfNdx = 0;
static long              errInstCount;
static int               errIfs[ERR_MAX_IFS];
static char              errOpName[ERR_MAX_CODE];
static char              errFname[ERR_MAX_FNAME];
static char            * errOpcs[] =
{
  "SVTCA_0",
  "SVTCA_1",
  "SPVTCA",
  "SPVTCA",
  "SFVTCA",
  "SFVTCA",
  "SPVTL",
  "SPVTL",
  "SFVTL",
  "SFVTL",
  "WPV",
  "WFV",
  "RPV",
  "RFV",
  "SFVTPV",
  "ISECT",
  "SetLocalGraphicState",
  "SetLocalGraphicState",
  "SetLocalGraphicState",
  "SetElementPtr",
  "SetElementPtr",
  "SetElementPtr",
  "SetElementPtr",
  "SetLocalGraphicState",
  "SetRoundState",
  "SetRoundState",
  "LMD",
  "ELSE",
  "JMPR",
  "LWTCI",
  "LSWCI",
  "LSW",
  "DUP",
  "SetLocalGraphicState",
  "CLEAR",
  "SWAP",
  "DEPTH",
  "CINDEX",
  "MINDEX",
  "ALIGNPTS",
  "RAW",
  "UTP",
  "LOOPCALL",
  "CALL",
  "FDEF",
  "IllegalInstruction",
  "MDAP",
  "MDAP",
  "IUP",
  "IUP",
  "SHP",
  "SHP",
  "SHC",
  "SHC",
  "SHE",
  "SHE",
  "SHPIX",
  "IP",
  "MSIRP",
  "MSIRP",
  "ALIGNRP",
  "SetRoundState",
  "MIAP",
  "MIAP",
  "NPUSHB",
  "NPUSHW",
  "WS",
  "RS",
  "WCVT",
  "RCVT",
  "RC",
  "RC",
  "WC",
  "MD",
  "MD",
  "MPPEM",
  "MPS",
  "FLIPON",
  "FLIPOFF",
  "DEBUG",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "IF",
  "EIF",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "DELTAP1",
  "SDB",
  "SDS",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "ROUND",
  "ROUND",
  "ROUND",
  "ROUND",
  "NROUND",
  "NROUND",
  "NROUND",
  "NROUND",
  "WCVTFOD",
  "DELTAP2",
  "DELTAP3",
  "DELTAC1",
  "DELTAC2",
  "DELTAC3",
  "SROUND",
  "S45ROUND",
  "JROT",
  "JROF",
  "SetRoundState",
  "IllegalInstruction",
  "SetRoundState",
  "SetRoundState",
  "SANGW",
  "AA",
  "FLIPPT",
  "FLIPRGON",
  "FLIPRGOFF",
  "IDefPatch",
  "IDefPatch",
  "SCANCTRL",
  "SDPVTL",
  "SDPVTL",
  "GETINFO",
  "IDEF",
  "ROTATE",
  "BinaryOperand",
  "BinaryOperand",
  "SCANTYPE",
  "INSTCTRL",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP"
};

/*
  errOutput() - writes an error to standard out and to a log file.  the
  log file is always opened and closes in order to avoid file corruption
  by an application gone wild.
*/
static void errOutput( char * );
static void errOutput( char * msg )
{
  static  int firsttime = 1;
  FILE  * fp;

  printf("%s", msg);
  fp = fopen ("compfont.err", (firsttime ? "w" : "a"));
  if (fp)
  {
	fprintf (fp, "%s", msg);
	fclose (fp);
  }
  firsttime = 0;
  return;
}

/*
  errPrint() - used to generate a useful (?) error message based on the 
  error 'flag' and the parameters ('v1..v4').
*/
static void errPrint (int, long, long, long, long);
static void errPrint (int flag, long v1, long v2, long v3, long v4)
{
  char   msg[ERR_MAX_MSG];
  char * opcodeName;
  char   c;
  int    i;

/*
  build the context line.  it indicates the file being processed, the point
  size, the character code (or glyph index), as well as the releative inst 
  number of this instruction for this code.
*/
  i  = sprintf (msg,   "\n*** ERROR*** ");
  i += sprintf (msg+i, "\"%s\", ", errFname);
  i += sprintf (msg+i, "%hd Point, ", errSize);
  i += sprintf (msg+i, "Code %hd (0x%hX), ", errCode, errCode);
  i += sprintf (msg+i, "Inst: #%ld\n", errInstCount);

/*
  build the error line.  it indicates the name of the instruction followed
  by the actual error information.  note: finding the actual opcode name
  for some the instructions is sorta kludgy.  names like "SetLocalGraphicState",
  and "BinaryOperand" are not actual instructions.  In these cases, look to
  the second character of the name - if it is lower case, then we need to 
  work a little harder, so look to 'errOpName' (which should be set by this
  point) it should contain the correct instruction name.
*/
  c = *(errOpcs[errOpc]+1);
  opcodeName =(islower(c) && strlen(errOpName)) ? errOpName : errOpcs[errOpc];
  i += sprintf (msg+i, "(%s) ", opcodeName);
  errOpName[0] = '\0';

/*
  output what you have so far and then process the error
*/
  errOutput (msg);
  switch (flag)
  {
	case ERR_RANGE:
	  sprintf (msg, "Value out of range: value = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_ASSERTION:
	  sprintf (msg, "Assertion check failed\n"); 
	  break;
	case ERR_CVT:
	  sprintf (msg, "CVT out of range: CVT = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_FDEF:
	  sprintf (msg, "FDEF out of range: FDEF = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_ELEMENT:
	  sprintf (msg, "Element %ld exceeds max elements (%ld)\n", v1, v2, v3); 
	  break;
	case ERR_CONTOUR:
	  i = sprintf (msg, "CONTOUR out of range: ");
	sprintf (msg+i, "CONTOUR = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_POINT:
	  i = sprintf (msg, "POINT out of range: ");
	sprintf (msg+i, "POINT = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_INDEX:
	  i = sprintf (msg, "POINT 0x%lX is neither element[0] ", v1);
	  sprintf( msg+i, "(0x%lX) nor element[1] (0x%lX)\n", v2, v3); 
	  break;
	case ERR_STORAGE:
	  i = sprintf (msg, "Storage index out of range: ");
	sprintf (msg+i, "Index = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_STACK:
	  i = sprintf (msg, "Stack pointer out of range: ");
	sprintf (msg+i, "Pointer = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_VECTOR:
	  sprintf (msg, "Illegal (x.y) vector: (%ld.%ld)\n", v1, v2); 
	  break;
	case ERR_LARGER:
	  sprintf (msg, "Value too small: %ld is not larger than %ld\n", v2, v1); 
	  break;
	case ERR_INT8:
	  sprintf (msg, "Value too large: 0x%lX exceeds 1 byte capacity\n", v1);
	  break;
	case ERR_INT16:
	  sprintf (msg, "Value too large: 0x%lX exceeds 2 byte capacity\n", v1);
	  break;
	case ERR_SCANMODE:
	  sprintf (msg, "Invalid scan mode: %ld\n", v1);
	  break;
	case ERR_SELECTOR:
	  sprintf (msg, "Invalid scan value: %ld\n", v1);
	  break;
	case ERR_STATE:
	  i = sprintf (msg, "Boundry limit error: xmin = ");
	  sprintf (msg+1, "%ld, xmax = %ld, ymin = %ld, ymax = %ld\n",
				v1, v2, v3, v4); 
	  break;
	case ERR_GETSINGLEWIDTHNIL:
	  sprintf (msg, "Sanity: Single width is nil\n");
	  break;
	case ERR_GETCVTENTRYNIL:
	  sprintf (msg, "Sanity: CVT Entry is nil\n");
	  break;
	case ERR_INVOPC:
	  sprintf (msg, "Invalid opcode: %ld\n", v1);
	  break;
	case ERR_UNBALANCEDIF:
	  sprintf (msg, "Unbalanced: missing %s instruction\n",
				( v1 > 0 ) ? "EIF" : "IF" );
	  break;
	default:
	  sprintf (msg, "Unknown Error:\n");
	  break;
  }

/*
  output the rest and return
*/
  errOutput (msg);
  return;
}

/*
  fnterr_Context() - called before any other fnterr routine.  it records
  the job name, character size and character code / glyph index.
*/
void fnterr_Context (int sw, char * str, unsigned short sz, unsigned short cd)
{
/*
  record a piece of the context
*/
  switch (sw)
  {
	case ERR_CONTEXT_FILE:
	  strncpy ( errFname, str, ERR_MAX_FNAME);
	  errFname[ERR_MAX_FNAME-1] = '\0';
	  break;
	case ERR_CONTEXT_SIZE:
	  errSize = sz;
	  break;
	case ERR_CONTEXT_CODE:
	  errCode = cd;
	  break;
  }

/*
  reset errOpName to be NULL before we start any real processing
*/
  errOpName[0] = '\0';
  return;
}

/*
  fnterr_Start() - called before the main execute loop of fnt_Execute() and
  fnt_TraceExecute().  it resets the instruction count to zero, and errBreak
  to 0 (ie: don't break out of execution loop).  set up IF/EIF counter for
  this level.
*/
void fnterr_Start (void)
{
  errInstCount = 0L;
  errBreak = 0;

  if (errIfOk && (++errIfNdx < ERR_MAX_IFS ))
	errIfs[errIfNdx] = 0;
  else
	errIfOk = 0;

  return;
}

/*
  fnterr_Record() - called inside the main execute loop of fnt_Execute()
  and fnt_TraceExecute().  it increments the instruction count, and resets
  the opcode number.  IFs or EIFs are accounted for. (note: other IFs and
  EIFs will be accounted for by calls to ERR_IF() in fnt.c)
*/
void fnterr_Record (int opc)
{
  errInstCount++;
  errOpc = opc;

  if (!strcmp ("IF", errOpcs[errOpc]))
	fnterr_If (1);
  else if (!strcmp ("EIF", errOpcs[errOpc]))
	fnterr_If (-1);

  return;
}

/*
  fnterr_Report() - called inside the main execute loop of fnt_Execute()
  and fnt_TraceExecute().  it calls errPrint() (with the passed parameters)
  to note the error, and sets errBreak so that the execution loop will end.
*/
void fnterr_Report (int flag, long v1, long v2, long v3, long v4)
{
  errPrint (flag, v1, v2, v3, v4);
  errBreak = 1;
  return;
}

/*
  fnterr_Break() - returns the value of errBreak.  if a non-zero valid is
  returned (re: fnterr_Report()), the main execute loop of fnt_Execute()
  or fnt_TraceExecute() will terminate.
*/
int fnterr_Break (void)
{
  return (errBreak);
}

/*
  fnterr_Opc() - called by combinate fnt calls to indicate the actual
  opcode errGet() can use.  this is a kludgy way to get around the non
  real opcode name in the errOpcs[] table.
*/
void fnterr_Opc (char *opc)
{
  strcpy (errOpName, opc);
  return;
}

/*
  fnterr_End() - called after the main execute loop of fnt_Execute() and
  fnt_TraceExecute().  it checks for balanced IF/EIF pairs.
*/
void fnterr_End (void)
{
  if (errIfOk)
  {
	if (errIfs[errIfNdx])
	  errPrint (ERR_UNBALANCEDIF, (long)errIfs[errIfNdx], 0L, 0L, 0L);
	if (--errIfNdx < 0)
	  errIfOk = 0;
  }
  return;
}

/*
  fnterr_If() - records IF/EIF activity inside of fnt_IF(), fnt_ELSE() and
  fnt_EIF() (re: fnt.c).
*/
void fnterr_If (int val)
{
  if (errIfOk)
	errIfs[errIfNdx] += val;
  return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fserror.h ===
/*
    File:       fserror.h

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

		<>      10/14/97    CB      error if FDEF/IDEF in GlyphProgram
 		 <>     04/30/97    CB      ClaudeBe, missing ENDF, infinite loop/recursion
		 <>     03/1/97    CB      ClaudeBe, div by 0 in hinting error
        <4>     7/13/90    MR      made endif at bottom use a comment
         <3>      5/3/90    RB      Changed char to int8 for variable type.   Now it is legal to
                                    pass in zero as the address of memory when a piece of
         <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)
       <3.1>    11/14/89    CEL     Now it is legal to pass in zero as the address of memory when a
                                    piece of the sfnt is requested by the scaler. If this happens
                                    the scaler will simply exit with an error code !
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/************/
/** ERRORS **/
/************/
#define NO_ERR                      0x0000
#define NULL_KEY                    0x0000


/** EXTERNAL INTERFACE PACKAGE **/
#define NULL_KEY_ERR                0x1001
#define NULL_INPUT_PTR_ERR          0x1002
#define NULL_MEMORY_BASES_ERR       0x1003
#define VOID_FUNC_PTR_BASE_ERR      0x1004  /* No longer used */
#define OUT_OFF_SEQUENCE_CALL_ERR   0x1005
#define BAD_CLIENT_ID_ERR           0x1006
#define NULL_SFNT_DIR_ERR           0x1007
#define NULL_SFNT_FRAG_PTR_ERR      0x1008
#define NULL_OUTPUT_PTR_ERR         0x1009
#define INVALID_GLYPH_INDEX         0x100A
#define BAND_TOO_BIG_ERR            0x100B  /* possible with FindBandingSize */
#define INVALID_CHARCODE_ERR        0x100C

/* fnt_execute */
#define UNDEFINED_INSTRUCTION_ERR   0x1101
#define TRASHED_MEM_ERR             0x1102
#define DIV_BY_0_IN_HINTING_ERR     0x1103
#define MISSING_ENDF_ERR			0x1104
#define MISSING_EIF_ERR				0x1105
#define INFINITE_RECURSION_ERR		0x1106 
#define INFINITE_LOOP_ERR			0x1107 
#define FDEF_IN_GLYPHPGM_ERR		0x1108 
#define IDEF_IN_GLYPHPGM_ERR		0x1109 

#define TRACE_FAILURE_ERR			0x110A  /* can be used by a trace function to notify of an 
                                               internal error (memory allocation failed,...) */
#define JUMP_BEFORE_START_ERR	    0x110B
#define INSTRUCTION_ERR             0x110C  /* can be used by a trace function to notify the discovery of an error */

#define RAW_NOT_IN_GLYPHPGM_ERR		0x110D 

#define SECURE_STACK_UNDERFLOW      0x1110
#define SECURE_STACK_OVERFLOW       0x1111
#define SECURE_POINT_OUT_OF_RANGE   0x1112
#define SECURE_INVALID_STACK_ACCESS 0x1113
#define SECURE_FDEF_OUT_OF_RANGE    0x1114
#define SECURE_ERR_FUNCTION_NOT_DEFINED    0x1115
#define SECURE_INVALID_ZONE         0x1116
#define SECURE_INST_OPCODE_TO_LARGE 0x1117
#define SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP  0x1118
#define SECURE_STORAGE_OUT_OF_RANGE 0x1119
#define SECURE_CONTOUR_OUT_OF_RANGE 0x111A
#define SECURE_CVT_OUT_OF_RANGE     0x111B
#define SECURE_UNITIALIZED_ZONE     0x111C


/* fsg_CalculateBBox */
#define POINT_MIGRATION_ERR         0x1201

/* sc_ScanChar */
#define BAD_START_POINT_ERR         0x1301
#define SCAN_ERR                    0x1302
#define BAD_SCAN_KIND_ERR           0x1303
#define BAD_POINT_INDEX_ERR         0x1304

#define SMART_DROP_OVERFLOW_ERR     0x1305


/** SFNT DATA ERROR and errors in sfnt.c **/
#define SFNT_DATA_ERR               0x1400
#define POINTS_DATA_ERR             0x1401
#define INSTRUCTION_SIZE_ERR        0x1402
#define CONTOUR_DATA_ERR            0x1403
#define GLYPH_INDEX_ERR             0x1404
#define BAD_MAGIC_ERR               0x1405
#define OUT_OF_RANGE_SUBTABLE       0x1406
#define UNKNOWN_COMPOSITE_VERSION   0x1407
#define CLIENT_RETURNED_NULL        0x1408
#define MISSING_SFNT_TABLE          0x1409
#define UNKNOWN_CMAP_FORMAT         0x140A
#define BAD_MAXP_DATA               0x140B
#define SFNT_RECURSIVE_COMPOSITE_ERR 0x140C
#define GLYF_TABLE_CORRUPTION_ERR   0x140D
#define BAD_UNITSPEREM_ERR          0x140E
#define BAD_NUMLONGHORMETRICS_ERR   0x140F

/* spline call errors */
#define BAD_CALL_ERR                0x1500

#define TRASHED_OUTLINE_CACHE       0x1600

/* gray scale errors */
#define BAD_GRAY_LEVEL_ERR          0x1701
#define GRAY_OLD_BANDING_ERR        0x1703
#define GRAY_NO_OUTLINE_ERR         0x1704

/* embedded bitmap (sbit) errors */
#define SBIT_COMPONENT_MISSING_ERR  0x1801
#define SBIT_ROTATION_ERR           0x1802
#define SBIT_BANDING_ERR            0x1803
#define SBIT_OUTLINE_CACHE_ERR      0x1804

/* new transformation errors : */
#define TRAN_NULL_TRANSFORM_ERR     0x1901

/************ For Debugging *************/

#ifdef XXX
#define DEBUG_ON
pascal  Debug ()                     /* User break drop into Macsbug */
#ifdef  DEBUG_ON
extern  0xA9FF;
#else
{
    ;
}
#endif

#ifndef DEBUGGER
pascal void DEBUGGER(void) = 0xA9FF; 
#endif

#ifdef  LEAVEOUT
#ifndef DEBUGSTR
pascal  void DEBUGSTR (aString) int8 *aString; extern 0xABFF;
int8    *c2pstr ();
#define BugInfo( aString) DEBUGSTR( c2pstr(aString))
#endif
#endif

#endif  /* XXX */
/****************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fscaler.c ===
/*
    File:       FontScaler.c

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

   Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
               (c) 1989-1999. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

                 7/10/99  BeatS     Add support for native SP fonts, vertical RGB
                 4/01/99  BeatS     Implement alternative interpretation of TT instructions for SP
        <>      10/14/97    CB      move usOverScale to fs_NewTransformation
        <>       2/21/97    CB      no need to call pre-program if no hints (was causing div by zero)
        <>       1/10/97    CB      empty bitmap with bMatchBbox == TRUE causes crash
        <>      12/14/95    CB      add usNonScaledAH to the private key
        <11>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
                                    and one (always fractional) metrics. [rb]
        <10>    11/21/90    RB      Allow client to disable DropOutControl by returning a NIL
                                    pointer to memoryarea[7]. Also make it clear that we inhibit
                                    DOControl whenever we band. [This is a reversion to 8, so mr's
                                    initials are added by proxy]
         <9>    11/13/90    MR      (dnf) Revert back to revision 7 to fix a memmory-trashing bug
                                    (we hope). Also fix signed/unsigned comparison bug in outline
                                    caching.
         <8>    11/13/90    RB      Fix banding so that we can band down to one row, using only
                                    enough bitmap memory and auxillary memory for one row.[mr]
         <7>     11/9/90    MR      Add Default return to fs_dropoutval. Continue to fiddle with
                                    banding. [rb]
         <6>     11/5/90    MR      Remove FixMath.h from include list. Clean up Stamp macros. [rb]
         <5>    10/31/90    MR      Conditionalize call to ComputeMapping (to avoid linking
                                    MapString) [ha]
         <4>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
         <3>    10/30/90    RB      [MR] Inhibit DropOutControl when Banding
         <2>    10/20/90    MR      Restore changes since project died. Converting to smart math
                                    routines, integer ppem scaling. [rb]
        <16>     7/26/90    MR      don't include ToolUtils.h
        <15>     7/18/90    MR      Fix return bug in GetAdvanceWidth, internal errors are now ints.
        <14>     7/14/90    MR      remove unused fields from FSInfo
        <13>     7/13/90    MR      Ansi-C fixes, rev. for union in FSInput
        <11>     6/29/90    RB      Thus endeth the too long life of encryption
        <10>     6/21/90    MR      Add calls to ReleaseSfntFrag
         <9>     6/21/90    RB      add scanKind info to fs_dropoutVal
         <8>      6/5/90    MR      remove fs_MapCharCodes
         <7>      6/1/90    MR      
         <6>      6/1/90    RB      fixed bandingbug under dropout control
         <4>      5/3/90    RB      added dropoutval function.  simplified restore outlines.
                                    support for new scanconverter in contourscan, findbitmapsize,
                                    saveoutlines, restoreoutlines.
         <3>     3/20/90    CL      Changed to use fpem (16.16) instead of pixelsPerEm (int) Removed
                                    call to AdjustTransformation (not needed with fpem) Added call
                                    to RunXFormPgm Removed WECANNOTDOTHIS #ifdef Added
                                    fs_MapCharCodes
         <2>     2/27/90    CL      New error code for missing but needed table. (0x1409).  New
                                    CharToIndexMap Table format.
                                    Fixed transformed component bug.
       <3.6>    11/15/89    CEL     Put an else for the ifdef WeCanNotDoThis so Printer compile
                                    could use more effecient code.
       <3.5>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
                                    phantom points are in, even for components in a composite glyph.
                                    They should also work for transformations. Device metric are
                                    passed out in the output data structure. This should also work
                                    with transformations. Another leftsidebearing along the advance
                                    width vector is also passed out. whatever the metrics are for
                                    the component at it's level. Instructions are legal in
                                    components. Instructions are legal in components. The
                                    transformation is internally automatically normalized. This
                                    should also solve the overflow problem we had. Now it is legal
                                    to pass in zero as the address of memory when a piece of the
                                    sfnt is requested by the scaler. If this happens the scaler will
                                    simply exit with an error code ! Five unnecessary element in the
                                    output data structure have been deleted. (All the information is
                                    passed out in the bitmap data structure) fs_FindBMSize now also
                                    returns the bounding box.
       <3.4>     9/28/89    CEL     fs_newglyph did not initialize the output error. Caused routine
                                    to return error from previous routines.
       <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
       <3.2>     9/25/89    CEL     Changed the NEED_PROTOTYPE ifdef to use the NOT_ON_THE_MAC flag
                                    that existed previously.
       <3.1>     9/15/89    CEL     Changed dispatch scheme. Calling conventions through a trap
                                    needed to match Macintosh pascal. Pascal can not call C unless
                                    there is extra mucky glue. Bug that caused text not to appear.
                                    The font scaler state was set up correctly but the sfnt was
                                    purged. It was reloaded and the clientid changed but was still
                                    the same font. Under the rules of the FontScaler fs_newsfnt
                                    should not have to be called again to reset the state. The extra
                                    checks sent back a BAD_CLIENTID_ERROR so QuickDraw would think
                                    it was a bad font and not continue to draw.
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.4>     8/17/89    sjk     Coded around MPW C3.0 bug
       <2.3>     8/14/89    sjk     1 point contours now OK
       <2.2>      8/8/89    sjk     Improved encryption handling
       <2.1>      8/2/89    sjk     Fixed outline caching bug
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <y1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/*      <3+>     3/20/90    mrr     Conditionalized error checking in fs_SetUpKey.
                                    Compiler option for stamping memmory areas for debugging
                                    Removed error field from FSInfo structure.
                                    Added call to RunFontProgram
                                    Added private function prototypes.
                                    Optimizations from diet clinic

*/

/** FontScaler's Includes **/

#define FSCFG_INTERNAL

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"        /* For numeric conversion macros    */
#include "fnt.h"
#include "scentry.h"
#include "sfntaccs.h"
#include "fsglue.h"
#include "sbit.h"
#include "fscaler.h"         // moved this to be the last include file (key moved in dot h)


#include "stat.h"                   /* STAT timing card prototypes */
boolean gbTimer = FALSE;            /* set true when timer running */

#ifndef FSCFG_MOVE_KEY_IN_DOT_H
/* the definition of the key in fscaler.h and fscaler.c must be identical */

/** Private Structures  **/

/*** The Internal Key ***/
typedef struct fs_SplineKey {
    sfac_ClientRec      ClientInfo;         /* Client Information */
    char* const *       memoryBases;        /* array of memory Areas */
    char *              apbPrevMemoryBases[MEMORYFRAGMENTS];

    uint16              usScanType;         /* flags for dropout control etc.*/

    fsg_TransformRec    TransformInfo;

    uint16              usNonScaledAW;
    uint16              usNonScaledAH;

    LocalMaxProfile     maxProfile;         /* copy of profile */

    uint32              ulState;            /* for error checking purposes */
    
    boolean             bExecutePrePgm;
    boolean             bExecuteFontPgm;    /* <4> */

    fsg_WorkSpaceAddr   pWorkSpaceAddr;     /* Hard addresses in Work Space */
    fsg_WorkSpaceOffsets WorkSpaceOffsets;  /* Address offsets in Work Space     */
    fsg_PrivateSpaceOffsets PrivateSpaceOffsets; /* Address offsets in Private Space */

    uint16              usBandType;         /* old, small or fast */
    uint16              usBandWidth;        /* from FindBandingSize */

    GlyphBitMap         GBMap;              /* newscan bitmap type */
    WorkScan            WScan;              /* newscan workspace type */

    GlyphBitMap         OverGBMap;          /* for gray scale */
    uint16              usOverScale;        /* 0 => mono; mag factor => gray */
    boolean             bGrayScale;         /* FALSE if mono (usOverScale == 0) */
    boolean             bMatchBBox;         /* force bounding box match */
    boolean             bEmbeddedBitmap;    /* embedded bitmap found */         

    metricsType         metricInfo;         /* Glyph metrics info */
    verticalMetricsType     verticalMetricInfo;

    int32               lExtraWorkSpace;    /* Amount of extra space in workspace */

    boolean             bOutlineIsCached;   /* Outline is cached */
    boolean             bGlyphHasOutline;   /* Outline is empty */
    boolean             bGridFitSkipped;    /* sbit anticipated, no outline loaded */

    uint32              ulGlyphOutlineSize; /* Size of outline cache */
    
    sbit_State          SbitMono;           /* for monochrome bitmaps */
    boolean             bHintingEnabled;    /* hinting is enabled, set to FALSE when 
                                               fs_NewTransformNoGridFit is called */
    boolean             bBitmapEmboldening; /* bitmap emboldening simulation */
    int16               sBoldSimulHorShift; /* shift for emboldening simulation, horizonatlly */
    int16               sBoldSimulVertShift; /* shift for emboldening simulation, vertically */
#ifdef FSCFG_SUBPIXEL
    uint16              flSubPixel;
    fsg_TransformRec    TransformInfoSubPixel;
#endif // FSCFG_SUBPIXEL
} fs_SplineKey;

#endif // FSCFG_MOVE_KEY_IN_DOT_H

/*  CONSTANTS   */

/* Change this if the format for cached outlines change. */
/* Someone might be caching old stuff for years on a disk */

#define OUTLINESTAMP 0x2D0CBBAD
#define OUTLINESTAMP2 0xA5

#define BITMAP_MEMORY_COUNT 4       /* now for gray scale we need 4 */

/* for the key->ulState field */
#define INITIALIZED 0x0000L
#define NEWSFNT     0x0002L
#define NEWTRANS    0x0004L
#define GOTINDEX    0x0008L
#define GOTGLYPH    0x0010L
#define SIZEKNOWN   0x0020L

#define STAMPEXTRA      4

/* 'sfnt' in ASCII  */
#define STAMP           0x73666E74

/*** Memory shared between all fonts and sizes and transformations ***/
#define KEY_PTR_BASE                0 /* Constant Size ! */
#define VOID_FUNC_PTR_BASE          1 /* Constant Size ! */
#define SCAN_PTR_BASE               2 /* Constant Size ! */
#define WORK_SPACE_BASE             3 /* size is sfnt dependent, can't be shared between grid-fitting and scan-conversion */
/*** Memory that can not be shared between fonts and different sizes, can not dissappear after InitPreProgram () ***/
#define PRIVATE_FONT_SPACE_BASE     4 /* size is sfnt dependent */
/* Only needs to exist when ContourScan is called, and it can be shared */
#define BITMAP_PTR_1                5 /* the bitmap - size is glyph size dependent */
#define BITMAP_PTR_2                6 /* size is proportional to number of rows */
#define BITMAP_PTR_3                7 /* used for dropout control - glyph size dependent */
#define BITMAP_PTR_4                8 /* used in gray scale for overscaled bitmap */

static  const   transMatrix   IdentTransform =
    {{{ONEFIX,      0,      0},
      {     0, ONEFIX,      0},
      {     0,      0, ONEFIX}}};


/* PRIVATE DEFINITIONS    */

FS_PRIVATE fs_SplineKey *  fs_SetUpKey (fs_GlyphInputType* inptr, uint32 ulStateBits, ErrorCode * error);
FS_PRIVATE void            fs_InitializeKey(fs_SplineKey * key);
FS_PRIVATE int32           fs__Contour (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
FS_PRIVATE int32           fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
FS_PRIVATE void            fs_SetState(fs_SplineKey * key, uint32 ulState);
FS_PRIVATE void            FS_CALLBACK_PROTO dummyReleaseSfntFrag (voidPtr p);
FS_PRIVATE void            CHECKSTAMP (char * p);
FS_PRIVATE void            SETSTAMP (char * p);

FS_PRIVATE FS_ENTRY LookForSbitAdvanceWidth(fs_SplineKey *key, uint16 usGlyphIndex, boolean *pbBitmapFound, point *pf26DevAdvanceWidth );
FS_PRIVATE FS_ENTRY LookForSbitAdvanceHeight(fs_SplineKey *key, uint16 usGlyphIndex, boolean *pbBitmapFound,
    point *pf26DevAdvanceHeight);

/* FUNCTIONS    */

FS_PRIVATE void SETSTAMP (char * p)
{
    * ((uint32 *) ((p) - STAMPEXTRA)) = STAMP;
}


FS_PRIVATE void CHECKSTAMP (char * p)
{
    if (* ((uint32 *) ((p) - STAMPEXTRA)) != STAMP)
    {
#ifdef  NOT_ON_THE_MAC
        Assert(FALSE);
#else
        DEBUGGER ();
#endif
    }
}


FS_PRIVATE void FS_CALLBACK_PROTO dummyReleaseSfntFrag (voidPtr p)
{
    FS_UNUSED_PARAMETER(p);
}

FS_PRIVATE void   fs_SetState(fs_SplineKey * key, uint32 ulState)
{
    key->ulState = ulState;
}

/*
 *  Set up the key in case memmory has moved or been purged.
 */
FS_PRIVATE fs_SplineKey * fs_SetUpKey (
    fs_GlyphInputType * inptr,
    uint32              ulStateBits,
    ErrorCode *         error)
{
    fs_SplineKey *  key;

    key = (fs_SplineKey *)inptr->memoryBases[KEY_PTR_BASE];
    if (key == NULL)
    {
        *error = NULL_KEY_ERR;
        return 0;
    }

    key->memoryBases =                           inptr->memoryBases;
    if(key->memoryBases == NULL)
    {
        *error = NULL_MEMORY_BASES_ERR;
        return 0;
    }
    key->ClientInfo.GetSfntFragmentPtr =    inptr->GetSfntFragmentPtr;
    if(key->ClientInfo.GetSfntFragmentPtr == NULL)
    {
        *error = NULL_SFNT_FRAG_PTR_ERR;
        return 0;
    }

    key->ClientInfo.ReleaseSfntFrag = inptr->ReleaseSfntFrag;
    if (!(key->ClientInfo.ReleaseSfntFrag))
    {
        key->ClientInfo.ReleaseSfntFrag = dummyReleaseSfntFrag;
    }

    if ((key->ulState & ulStateBits) != ulStateBits)
    {
        *error = OUT_OFF_SEQUENCE_CALL_ERR;
        return 0;
    }

    key->ClientInfo.lClientID = inptr->clientID;
    *error = NO_ERR;

    return key;
}

FS_PRIVATE void fs_InitializeKey(fs_SplineKey * key)
{
    MEMSET(key, 0, sizeof(fs_SplineKey));
    key->TransformInfo.currentTMatrix = IdentTransform;
#ifdef FSCFG_SUBPIXEL
    key->TransformInfoSubPixel.currentTMatrix = IdentTransform;
#endif // FSCFG_SUBPIXEL
}

/*** FONT SCALER INTERFACE ***/

/*
 *
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    Assert(FS_SBIT_BITDEPTH_MASK == SBIT_BITDEPTH_MASK);
    /* sanity check that the embedded bitmap mask is the same in fscaler.h than in sfntaccs.h */

    if ( outputPtr )
    {
        outputPtr->memorySizes[KEY_PTR_BASE]        = (int32)sizeof (fs_SplineKey) + STAMPEXTRA;
        outputPtr->memorySizes[VOID_FUNC_PTR_BASE]  = 0;
        outputPtr->memorySizes[SCAN_PTR_BASE]       = 0;
        outputPtr->memorySizes[WORK_SPACE_BASE]      = 0; /* we need the sfnt for this */
        outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE] = 0; /* we need the sfnt for this */
        outputPtr->memorySizes[BITMAP_PTR_1]         = 0; /* we need the grid fitted outline for this */
        outputPtr->memorySizes[BITMAP_PTR_2]         = 0; /* we need the grid fitted outline for this */
        outputPtr->memorySizes[BITMAP_PTR_3]         = 0; /* we need the grid fitted outline for this */
        outputPtr->memorySizes[BITMAP_PTR_4]         = 0; /* gray scale memory */
    }
    else
    {
        return NULL_OUTPUT_PTR_ERR;
    }
    if ( inputPtr )
    {
        inputPtr->memoryBases[KEY_PTR_BASE]             = NULL;
        inputPtr->memoryBases[VOID_FUNC_PTR_BASE]       = NULL;
        inputPtr->memoryBases[SCAN_PTR_BASE]            = NULL;
        inputPtr->memoryBases[WORK_SPACE_BASE]          = NULL;
        inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE]  = NULL;
        inputPtr->memoryBases[BITMAP_PTR_1]             = NULL;
        inputPtr->memoryBases[BITMAP_PTR_2]             = NULL;
        inputPtr->memoryBases[BITMAP_PTR_3]             = NULL;
        inputPtr->memoryBases[BITMAP_PTR_4]             = NULL;
    }
    else
    {
        return NULL_INPUT_PTR_ERR;
    }
    return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    fs_SplineKey *  key;

    FS_UNUSED_PARAMETER(outputPtr);

    key = (fs_SplineKey *)inputPtr->memoryBases[KEY_PTR_BASE];
    SETSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    fs_InitializeKey(key);

    key->memoryBases = inputPtr->memoryBases;

    fs_SetState(key, INITIALIZED);

    fsc_Initialize();                            /* initialize scan converter */

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    return NO_ERR;
}


/*
 *  This guy asks for memmory for points, instructions, fdefs and idefs
 */
FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    ErrorCode       error;
    fs_SplineKey *  key;

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    STAT_ON_NEWSFNT;                 /* start STAT timer */

    key = fs_SetUpKey(inputPtr, INITIALIZED, &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    error = sfac_DoOffsetTableMap (&key->ClientInfo);  /* Map offset and length table */

    if(error != NO_ERR)
    {
        return (FS_ENTRY)error;
    }

    error = sfac_LoadCriticalSfntMetrics(
        &key->ClientInfo,
        &key->TransformInfo.usEmResolution,
        &key->TransformInfo.bIntegerScaling,
        &key->maxProfile);

    if(error != NO_ERR)
    {
        return (FS_ENTRY)error;
    }

    outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE] = (int32)fsg_PrivateFontSpaceSize (&key->ClientInfo, &key->maxProfile, &key->PrivateSpaceOffsets) + STAMPEXTRA;
    outputPtr->memorySizes[WORK_SPACE_BASE]         = (int32)fsg_WorkSpaceSetOffsets (&key->maxProfile, &key->WorkSpaceOffsets, &key->lExtraWorkSpace) + STAMPEXTRA;


    error = sfac_ComputeMapping (
        &key->ClientInfo,
        inputPtr->param.newsfnt.platformID,
        inputPtr->param.newsfnt.specificID);

    if(error != NO_ERR)
    {
        return (FS_ENTRY)error;
    }

    fs_SetState(key, (INITIALIZED | NEWSFNT));

    /*
     *  Can't run font program yet, we don't have any memory for the
     *  graphic state. Mark it to be run in NewTransformation.
     */

    key->bExecuteFontPgm = TRUE;

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    STAT_OFF_NEWSFNT;                /* stop STAT timer */

    return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    return fs__NewTransformation (inputPtr, outputPtr, FALSE);
}


FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    return fs__NewTransformation (inputPtr, outputPtr, TRUE);
}


FS_PRIVATE int32 fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints)
{
    void *          pvGlobalGS;
    void *          pvStack;
    void *          pvTwilightZone;
    void *          pvFontProgram;
    void *          pvPreProgram;
    ErrorCode       error;
    fs_SplineKey *  key;
    int16           xOverResolution;
#ifdef FSCFG_SUBPIXEL
    void *          pvGlobalGSSubPixel;
    uint16          flSubPixelHintFlag;
    void *          pvTwilightZoneSubPixel;
#endif // FSCFG_SUBPIXEL
    uint16            usPPEMX;                  /* for sbits */
    uint16            usPPEMY; 
    uint16            usRotation;

    if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
       (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
    {
        return NULL_MEMORY_BASES_ERR;
    }
    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    SETSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    SETSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_ON_NEWTRAN;                 /* start STAT timer */

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }


    key->bHintingEnabled = useHints;

    fsg_UpdateWorkSpaceAddresses(
        key->memoryBases[WORK_SPACE_BASE],
        &(key->WorkSpaceOffsets),
        &(key->pWorkSpaceAddr));

    fsg_UpdateWorkSpaceElement(
        &(key->WorkSpaceOffsets),
        &(key->pWorkSpaceAddr));

    pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

    fsg_UpdatePrivateSpaceAddresses(
        &key->ClientInfo,
        &key->maxProfile,
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets),
        pvStack,
        &pvFontProgram,
        &pvPreProgram);

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    pvTwilightZone = fsg_QueryTwilightElement(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);

    key->bExecutePrePgm = (boolean) !inputPtr->param.newtrans.traceFunc;

    if (!key->bHintingEnabled)
    {
        /* if fs_NewTransformNoGridFit was called, we disabled hinting : */
        key->bExecutePrePgm = TRUE;
        key->bExecuteFontPgm = FALSE;
    }

    /* Load the font program and pre program if necessary */

    if (key->bExecuteFontPgm)
    {
        error = sfac_CopyFontAndPrePrograms(
            &key->ClientInfo,
            (char *)pvFontProgram,
            (char *)pvPreProgram);

        if(error)
        {
            return (FS_ENTRY)error;
        }
    }

    key->TransformInfo.currentTMatrix = *inputPtr->param.newtrans.transformMatrix;
    key->TransformInfo.fxPixelDiameter  = inputPtr->param.newtrans.pixelDiameter;
    key->usOverScale = inputPtr->param.newtrans.usOverScale; /* read input param */

    xOverResolution = inputPtr->param.newtrans.xResolution;

#ifdef FSCFG_SUBPIXEL
    /* convert from external client flags to internal flags */
    key->flSubPixel = 0;
    if (inputPtr->param.newtrans.flSubPixel & SP_SUB_PIXEL)
    {
        key->flSubPixel |= FNT_SP_SUB_PIXEL;
    }
    if (inputPtr->param.newtrans.flSubPixel & SP_COMPATIBLE_WIDTH)
    {
        /* compatible width is disabled under rotation but kept under italization */
        if (key->TransformInfo.currentTMatrix.transform[0][1] == 0)
        {
            key->flSubPixel |= FNT_SP_COMPATIBLE_WIDTH;
        }
    }
    if (inputPtr->param.newtrans.flSubPixel & SP_VERTICAL_DIRECTION)
    {
        key->flSubPixel |= FNT_SP_VERTICAL_DIRECTION;
    }
    if (inputPtr->param.newtrans.flSubPixel & SP_SUB_PIXEL && key->TransformInfo.currentTMatrix.transform[0][0] == 0) {
    // we have a combination of rotation and/or mirroring which swaps the roles of the x- and y-axis
        key->flSubPixel ^= FNT_SP_VERTICAL_DIRECTION;
    }
    
    if (inputPtr->param.newtrans.flSubPixel & SP_BGR_ORDER)
    {
        key->flSubPixel |= FNT_SP_BGR_ORDER;
    }
    
    flSubPixelHintFlag = 0;

    if (((key->flSubPixel & FNT_SP_SUB_PIXEL) && (key->usOverScale != 0) ) || 
        (((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) || (key->flSubPixel & FNT_SP_VERTICAL_DIRECTION) || (key->flSubPixel & FNT_SP_BGR_ORDER)) && !(key->flSubPixel & FNT_SP_SUB_PIXEL)))
    {
        /*****
        We do not yet allow a combination of SubPixel and Gray antialiazing
        The following table lists legal combinations of flags in flSubPixel:

        SubPixel    CompWidth   VertDirect  BGROrder    Comment
            No          No          No          No      b/w
            No          No          No          Yes     Illegal to ask for BGR order without asking for SubPixel
            No          No          Yes         No      Illegal to ask for vertical direction without asking for SubPixel
            No          No          Yes         Yes     Illegal by disjunctive combination
            No          Yes         No          No      Illegal to ask for compatible width without asking for SubPixel 
            No          Yes         No          Yes     Illegal by disjunctive combination 
            No          Yes         Yes         No      Illegal by disjunctive combination
            No          Yes         Yes         Yes     Illegal by disjunctive combination
            Yes         No          No          No      Plain SubPixel horizontal direction RGB
            Yes         No          No          Yes     Plain SubPixel horizontal direction BGR
            Yes         No          Yes         No      Plain SubPixel vertical direction RGB
            Yes         No          Yes         Yes     Plain SubPixel vertical direction BGR
            Yes         Yes         No          No      b/w compatible advance width SubPixel horizontal direction RGB
            Yes         Yes         No          Yes     b/w compatible advance width SubPixel horizontal direction BGR
            Yes         Yes         Yes         No      b/w compatible advance width SubPixel vertical direction RGB
            Yes         Yes         Yes         Yes     b/w compatible advance width SubPixel vertical direction BGR
        
        Note that it could be argued that in vertical direction RGB|BGR, advance widths should be b/w compatible
        by nature, because we are not rounding any x-direction positions and distances any differently than
        in b/w. However, with vertical direction RGB, a glyph may assume a height that is closer to its natural
        height than what it would in b/w, and as a result may seem too narrow or too wide, which in turn would
        call for a correction in x, specific to SubPixel with vertical direction RGB and potentially making the
        advance width incompatible. Therefore, we allow the last two combinations of flags.
        *****/

        return BAD_GRAY_LEVEL_ERR;
    }
    
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
        if (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH)
        {
            pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
                key->memoryBases[PRIVATE_FONT_SPACE_BASE],
                &(key->PrivateSpaceOffsets));
            pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
                key->memoryBases[PRIVATE_FONT_SPACE_BASE],
                &(key->PrivateSpaceOffsets));
            key->TransformInfoSubPixel = key->TransformInfo;
        } else
        {
            xOverResolution = xOverResolution * HINTING_HOR_OVERSCALE;
            flSubPixelHintFlag = key->flSubPixel;
        }

    }
#endif // FSCFG_SUBPIXEL

    if (key->usOverScale != 0 && 
            (((1 << (key->usOverScale - 1)) & FS_GRAY_VALUE_MASK) == 0) || key->usOverScale > 31)
    {
        return BAD_GRAY_LEVEL_ERR;
    }


    key->bGrayScale = (key->usOverScale == 0) ? FALSE : TRUE;
    fsg_SetHintFlags(pvGlobalGS, key->bGrayScale
#ifdef FSCFG_SUBPIXEL
        ,flSubPixelHintFlag
#endif // FSCFG_SUBPIXEL
        );

    error = fsg_InitInterpreterTrans (
        &key->TransformInfo,
        pvGlobalGS,
        inputPtr->param.newtrans.pointSize,
#ifdef FSCFG_SUBPIXEL
        xOverResolution,
#else
        inputPtr->param.newtrans.xResolution,
#endif // FSCFG_SUBPIXEL
        inputPtr->param.newtrans.yResolution,
        inputPtr->param.newtrans.bHintAtEmSquare,
        inputPtr->param.newtrans.usEmboldWeightx ,
        inputPtr->param.newtrans.usEmboldWeighty,
        key->ClientInfo.sWinDescender,
        inputPtr->param.newtrans.lDescDev,
        &key->sBoldSimulHorShift,
        &key->sBoldSimulVertShift );

#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
        fsg_SetHintFlags(pvGlobalGSSubPixel, key->bGrayScale, key->flSubPixel);

        error = fsg_InitInterpreterTrans (
            &key->TransformInfoSubPixel,
            pvGlobalGSSubPixel,
            inputPtr->param.newtrans.pointSize,
            (int16)(xOverResolution * HINTING_HOR_OVERSCALE),
            inputPtr->param.newtrans.yResolution,
            inputPtr->param.newtrans.bHintAtEmSquare,
            inputPtr->param.newtrans.usEmboldWeightx ,
            inputPtr->param.newtrans.usEmboldWeighty,
            key->ClientInfo.sWinDescender,
            inputPtr->param.newtrans.lDescDev,
            &key->sBoldSimulHorShift,
            &key->sBoldSimulVertShift  );
    }
#endif // FSCFG_SUBPIXEL

    key->bBitmapEmboldening = inputPtr->param.newtrans.bBitmapEmboldening;

    if(error)
    {
        return (FS_ENTRY)error;
    }

    if (key->bExecuteFontPgm)
    {
        error = fsg_RunFontProgram (pvGlobalGS, &key->pWorkSpaceAddr, pvTwilightZone,
                                    inputPtr->param.newtrans.traceFunc);

        if(error)
        {
            return (FS_ENTRY)error;
        }

        key->bExecuteFontPgm = FALSE;
    }

#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
        fsg_CopyFontProgramResults (pvGlobalGS, pvGlobalGSSubPixel);
    }
#endif // FSCFG_SUBPIXEL

    if (!key->bExecutePrePgm)
    {

        /* Do this now so we do not confuse font editors    */
        /* Run the pre program and scale the control value table */
        /* Sets key->bExecutePrePgm to false          */

        error = fsg_RunPreProgram (
            &key->ClientInfo,
            &key->maxProfile,
            &key->TransformInfo,
            pvGlobalGS,
            &key->pWorkSpaceAddr,
            pvTwilightZone,
            inputPtr->param.newtrans.traceFunc);

        if(error)
        {
            /* If the pre-program fails, switch off hinting for further glyphs */
            key->bHintingEnabled = FALSE;
            return (FS_ENTRY)error;
        }
#ifdef FSCFG_SUBPIXEL
        if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
            error = fsg_RunPreProgram (
                &key->ClientInfo,
                &key->maxProfile,
                &key->TransformInfoSubPixel,
                pvGlobalGSSubPixel,
                &key->pWorkSpaceAddr,
                pvTwilightZoneSubPixel,
                inputPtr->param.newtrans.traceFunc);

            if(error)
            {
                /* If the pre-program fails, switch off hinting for further glyphs */
                key->bHintingEnabled = FALSE;
                return (FS_ENTRY)error;
            }
        }
#endif // FSCFG_SUBPIXEL
    }

    fsg_GetScaledCVT(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &key->PrivateSpaceOffsets,
        &outputPtr->scaledCVT);

    fsg_QueryPPEMXY(pvGlobalGS, &key->TransformInfo, 
                &usPPEMX, &usPPEMY, &usRotation);

    error = sbit_NewTransform(&key->SbitMono,key->TransformInfo.usEmResolution,
        key->sBoldSimulHorShift, key->sBoldSimulVertShift, usPPEMX, usPPEMY, usRotation );      /* setup for sbits */
    
    if(error)
    {
        return (FS_ENTRY)error;
    }

    fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS));

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_OFF_NEWTRAN;             /* stop STAT timer */

    return NO_ERR;
}


/*
 * Compute the glyph index from the character code.
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    ErrorCode         error;
    fs_SplineKey *    key;
    void *            pvGlobalGS;
    uint16            usBitDepth;           /* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */

    if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
       (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
    {
        return NULL_MEMORY_BASES_ERR;
    }
    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_ON_NEWGLYPH;                /* start STAT timer */

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if (inputPtr->param.newglyph.characterCode != NONVALID)
    {
        error = sfac_GetGlyphIndex(
            &key->ClientInfo,
            inputPtr->param.newglyph.characterCode);

        if(error)
        {
            return (FS_ENTRY)error;
        }

        outputPtr->numberOfBytesTaken = 2;  /*  !!!DISCUSS  */
        outputPtr->glyphIndex = key->ClientInfo.usGlyphIndex;
    }
    else
    {
        key->ClientInfo.usGlyphIndex = inputPtr->param.newglyph.glyphIndex;
        outputPtr->glyphIndex =        inputPtr->param.newglyph.glyphIndex;
        outputPtr->numberOfBytesTaken = 0;
    }

    if( key->ClientInfo.usGlyphIndex > key->maxProfile.numGlyphs - 1)
    {
        return INVALID_GLYPH_INDEX;
    }

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    key->bEmbeddedBitmap = !inputPtr->param.newglyph.bNoEmbeddedBitmap; /* read input param */

    key->bMatchBBox = inputPtr->param.newglyph.bMatchBBox;

    if (inputPtr->param.newglyph.bNoEmbeddedBitmap)
    {
        outputPtr->usBitmapFound = FALSE;
    } else {
        error = sbit_SearchForBitmap(
            &key->SbitMono,
            &key->ClientInfo,
            key->ClientInfo.usGlyphIndex,
            key->usOverScale,
            &usBitDepth,
            &outputPtr->usBitmapFound );
    
        if(error)
        {
            return (FS_ENTRY)error;
        }

    }

    if (key->usOverScale == 0)
    {
        outputPtr->usGrayLevels = 0; 
        /* usGrayLevels == 0 means 1 bit per pixel */
    } else {
#ifndef FSCFG_CONVERT_GRAY_LEVELS
        if(outputPtr->usBitmapFound)
        {
            outputPtr->usGrayLevels = 0x01 << usBitDepth;
        } else {
#endif // FSCFG_CONVERT_GRAY_LEVELS
            outputPtr->usGrayLevels = key->usOverScale * key->usOverScale + 1;
#ifndef FSCFG_CONVERT_GRAY_LEVELS
        }
#endif // FSCFG_CONVERT_GRAY_LEVELS
    }

    key->bEmbeddedBitmap = outputPtr->usBitmapFound;

#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
        outputPtr->usBitmapFound = FALSE;
    }
#endif // FSCFG_SUBPIXEL

    /* clear all other bits */

    fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX));

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_OFF_NEWGLYPH;                   /* stop STAT timer */

    return NO_ERR;
}


/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    ErrorCode       error;
    int16           sNonScaledLSB;
    fs_SplineKey *  key;
    void *          pvGlobalGS;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    error = sfac_ReadGlyphHorMetrics (
        &key->ClientInfo,
        key->ClientInfo.usGlyphIndex,
        &key->usNonScaledAW,
        &sNonScaledLSB);

    if(error)
    {
        return (FS_ENTRY)error;
    }

    fsg_UpdateAdvanceWidth (&key->TransformInfo, pvGlobalGS, key->usNonScaledAW,
        &outputPtr->metricInfo.advanceWidth);

#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
    {
        /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
        ROUND_FROM_HINT_OVERSCALE(outputPtr->metricInfo.advanceWidth.x);
    }
#endif // FSCFG_SUBPIXEL
    return NO_ERR;
}

/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceHeight (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    ErrorCode       error;
    int16           sNonScaledTSB;
    fs_SplineKey *  key;
    void *          pvGlobalGS;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));


    error = sfac_ReadGlyphVertMetrics (
        &key->ClientInfo,
        key->ClientInfo.usGlyphIndex,
        &key->usNonScaledAH,
        &sNonScaledTSB);

    if(error)
    {
        return (FS_ENTRY)error;
    }

    fsg_UpdateAdvanceHeight (&key->TransformInfo, pvGlobalGS, key->usNonScaledAH,
        &outputPtr->verticalMetricInfo.advanceHeight);

#ifdef FSCFG_SUBPIXEL   
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
    {
        /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
        ROUND_FROM_HINT_OVERSCALE(outputPtr->verticalMetricInfo.advanceHeight.x);
    }
#endif
    return NO_ERR;
}

FS_PRIVATE int32 fs__Contour (fs_GlyphInputType*inputPtr, fs_GlyphInfoType*outputPtr, boolean useHints)
{
    ErrorCode       error;
    void *          pvGlobalGS;
    fs_SplineKey *  key;
    point           f26DevAdvanceWidth;
    point           f26DevAdvanceHeight;
    void *          pvTwilightZone;
    void *          pvStack;
    void *          pvFontProgram;
    void *          pvPreProgram;
#ifdef FSCFG_SUBPIXEL   
    void *          pvGlobalGSSubPixel;
    void *          pvTwilightZoneSubPixel;
    boolean         bSubPixelWidth = FALSE;
#endif // FSCFG_SUBPIXEL

    if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
       (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
    {
        return NULL_MEMORY_BASES_ERR;
    }

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_ON_GRIDFIT;                 /* start STAT timer */

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
       (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
    {
        fsg_UpdateWorkSpaceAddresses(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

        fsg_UpdatePrivateSpaceAddresses(
            &key->ClientInfo,
            &key->maxProfile,
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets),
            pvStack,
            &pvFontProgram,
            &pvPreProgram);

        MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    /* The element data structures need to be updated here because if the    */
    /* WorkSpace memory is shared, the pointers will not be correct. Since  */
    /* fs_Contour[No]GridFit - fs_ContourScan must have the same shared      */
    /* base, these address do not have to be updated explicitly between      */
    /* each call, only if the memory base has physically moved.              */

    fsg_UpdateWorkSpaceElement(
        &(key->WorkSpaceOffsets),
        &(key->pWorkSpaceAddr));

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

#ifdef FSCFG_SUBPIXEL   
    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
        pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets));
        pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets));
    }

    if ( (key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) ) 
    {
        bSubPixelWidth = TRUE;
    }
#endif // FSCFG_SUBPIXEL

    pvTwilightZone = fsg_QueryTwilightElement(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    if (!key->bHintingEnabled)
    {
        /* if fs_NewTransformNoGridFit was called, we disabled hinting : */
        key->bExecutePrePgm = FALSE;
        useHints = FALSE;
    }

    /*  potentially do delayed pre program execution */

    if (key->bExecutePrePgm)
    {
        /* Run the pre program and scale the control value table */

        key->bExecutePrePgm = FALSE;

        error = fsg_RunPreProgram (
            &key->ClientInfo,
            &key->maxProfile,
            &key->TransformInfo,
            pvGlobalGS,
            &key->pWorkSpaceAddr,
            pvTwilightZone,
            NULL);

        if(error)
        {
            /* If the pre-program fails, switch off hinting for further glyphs */
            key->bHintingEnabled = FALSE;
            return (FS_ENTRY)error;
        }
#ifdef FSCFG_SUBPIXEL   
        if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
            error = fsg_RunPreProgram (
                &key->ClientInfo,
                &key->maxProfile,
                &key->TransformInfoSubPixel,
                pvGlobalGSSubPixel,
                &key->pWorkSpaceAddr,
                pvTwilightZoneSubPixel,
                NULL);

            if(error)
            {
                /* If the pre-program fails, switch off hinting for further glyphs */
                key->bHintingEnabled = FALSE;
                return (FS_ENTRY)error;
            }
        }
#endif // FSCFG_SUBPIXEL    
    }

#ifdef FSCFG_SUBPIXEL
    if (inputPtr->param.gridfit.bSkipIfBitmap && key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))
#else
    if (inputPtr->param.gridfit.bSkipIfBitmap && key->bEmbeddedBitmap)
#endif // FSCFG_SUBPIXEL    
    {
        key->bGridFitSkipped = TRUE;    /* disallow grayscale, outline caching, banding */
        
        error = sbit_GetDevAdvanceWidth (
            &key->SbitMono,
            &key->ClientInfo,
            &f26DevAdvanceWidth );
        
        if(error)
        {
            return (FS_ENTRY)error;
        }

        error = sbit_GetDevAdvanceHeight (
            &key->SbitMono,
            &key->ClientInfo,
            &f26DevAdvanceHeight );

        if(error)
        {
            return (FS_ENTRY)error;
        }

    }
    else                                /* if we're using the outline */
    {
        key->bGridFitSkipped = FALSE;   /* allow grayscale, outline caching, banding */

        /* THE CALL */

        error = fsg_GridFit (
            &key->ClientInfo,
            &key->maxProfile,
            &key->TransformInfo,
            pvGlobalGS,
            &key->pWorkSpaceAddr,
            pvTwilightZone,
            inputPtr->param.gridfit.traceFunc,
            useHints,
            &key->usScanType,
            &key->bGlyphHasOutline,
            &key->usNonScaledAW,
            key->bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
            ,bSubPixelWidth
#endif // FSCFG_SUBPIXEL
            );

        if(error)
        {
            return (FS_ENTRY)error;
        }

#ifdef FSCFG_SUBPIXEL

        if (key->flSubPixel & FNT_SP_SUB_PIXEL) {
            Fixed   fxCompatibleWidthScale;
            F26Dot6 devAdvanceWidthX, devLeftSideBearingX, devRightSideBearingX;
            F26Dot6 horTranslation;
            
            /* default scale back factor if we don't need to adjust for compatible width
               (FNT_SP_COMPATIBLE_WIDTH is set off under rotation at fs_NewTransformation) */
            
            fxCompatibleWidthScale = SUBPIXEL_SCALEBACK_FACTOR; 

            if (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) {
                Fixed concertFactor;

                // compute the B/W glyph metrics
                if (key->bEmbeddedBitmap) {
                    error = sbit_CalcDevHorMetrics (&key->SbitMono,&key->ClientInfo,&devAdvanceWidthX,&devLeftSideBearingX,&devRightSideBearingX);
                    if(error)
                        return (FS_ENTRY)error;
                } else {
                    fsg_CalcDevHorMetrics(&key->pWorkSpaceAddr,&devAdvanceWidthX,&devLeftSideBearingX,&devRightSideBearingX);
                }

                if (key->usNonScaledAW && devAdvanceWidthX) {
                    concertFactor = FixDiv(devAdvanceWidthX,((fnt_GlobalGraphicStateType *)pvGlobalGS)->ScaleFuncX(
                                           &((fnt_GlobalGraphicStateType *)pvGlobalGS)->scaleX,(F26Dot6)key->usNonScaledAW));
                    if (concertFactor < 0) concertFactor = -concertFactor;
                } else {
                    concertFactor = 0x10000; // Fixed 1.0 for 0 AW glyphs
                }
                ((fnt_GlobalGraphicStateType *)pvGlobalGSSubPixel)->compatibleWidthStemConcertina = concertFactor;
                
                /* grid fit for the SubPixel overscale resolution */
                error = fsg_GridFit (
                    &key->ClientInfo,
                    &key->maxProfile,
                    &key->TransformInfoSubPixel,
                    pvGlobalGSSubPixel,
                    &key->pWorkSpaceAddr,
                    pvTwilightZoneSubPixel,
                    inputPtr->param.gridfit.traceFunc,
                    useHints,
                    &key->usScanType,
                    &key->bGlyphHasOutline,
                    &key->usNonScaledAW,
                    key->bBitmapEmboldening,
                    (key->flSubPixel & FNT_SP_SUB_PIXEL)
                    );

                if(error) {
                    return (FS_ENTRY)error;
                }
            } // key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH
            
            fsg_ScaleToCompatibleWidth(&key->pWorkSpaceAddr,fxCompatibleWidthScale);

            if (useHints && (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH)) {
                horTranslation = 0;
                fsg_AdjustCompatibleMetrics (
                    &key->pWorkSpaceAddr,
                    horTranslation,
                    devAdvanceWidthX*RGB_OVERSCALE);
            }
        }
#endif // FSCFG_SUBPIXEL

        fsg_GetContourData(
            &key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
            (boolean)(key->flSubPixel & FNT_SP_SUB_PIXEL),            
#endif // FSCFG_SUBPIXEL
            &outputPtr->xPtr,
            &outputPtr->yPtr,
            &outputPtr->startPtr,
            &outputPtr->endPtr,
            &outputPtr->onCurve,
            &outputPtr->fc,
            &outputPtr->numberOfContours);

        fsg_GetDevAdvanceWidth(
            &key->pWorkSpaceAddr,
            &f26DevAdvanceWidth);

        fsg_GetDevAdvanceHeight(
            &key->pWorkSpaceAddr,
            &f26DevAdvanceHeight);
    }
    
    outputPtr->metricInfo.devAdvanceWidth.x = DOT6TOFIX(f26DevAdvanceWidth.x);
    outputPtr->metricInfo.devAdvanceWidth.y = DOT6TOFIX(f26DevAdvanceWidth.y);

    outputPtr->verticalMetricInfo.devAdvanceHeight.x = DOT6TOFIX(f26DevAdvanceHeight.x);
    outputPtr->verticalMetricInfo.devAdvanceHeight.y = DOT6TOFIX(f26DevAdvanceHeight.y);

#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
        ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devAdvanceWidth.x);
        ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devAdvanceHeight.x);
    }
#endif // FSCFG_SUBPIXEL

    outputPtr->outlinesExist = (uint16)key->bGlyphHasOutline;

    fsg_GetScaledCVT(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &key->PrivateSpaceOffsets,
        &outputPtr->scaledCVT);

    fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH));

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_OFF_GRIDFIT;             /* stop STAT timer */

    return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    return fs__Contour (inputPtr, outputPtr, FALSE);
}


FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    return fs__Contour (inputPtr, outputPtr, TRUE);
}

/*********************************************************************/

/* Calculate scan conversion memory requirements                     */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{

    ErrorCode       error;
    BitMap *        pBMI;

    ContourList     CList;        /* newscan contour list type */
    void *          pvGlobalGS;
    fs_SplineKey *  key;

    point           f26DevAdvanceWidth;
    point           f26DevLeftSideBearing;
    point           f26LeftSideBearing;
    point           f26DevLeftSideBearingLine;
    point           f26LeftSideBearingLine;

    point           f26DevAdvanceHeight;
    point           f26DevTopSideBearing;
    point           f26TopSideBearing;
    point           f26DevTopSideBearingLine;
    point           f26TopSideBearingLine;

    int16           sOverScale;
    uint16          usRoundXMin;
    Rect *          pOrigB;             /* original outline bounding box */
    Rect *          pOverB;             /* over scaled outline bounding box */
    GlyphBitMap *   pOverG;             /* over scaled glyph bitmap struct */
    GlyphBitMap *   pGBMap;             /* orig or over pointer */
    
    uint16          usRowBytes;
    uint32          ulSbitOutSize;      /* sbit output memory */
    uint32          ulSbitWorkSize;     /* sbit workspace memory */
    int16           sNonScaledLSB;      /* for non-dev metrics calc */
    int16           sNonScaledTSB;      /* for non-dev metrics calc */
    int16           sBitmapEmboldeningHorExtra;      
    int16           sBitmapEmboldeningVertExtra;      

    if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
       (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
    {
        return NULL_MEMORY_BASES_ERR;
    }

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_ON_FINDBMS;                 /* start STAT timer */
    
    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
    {
          fsg_UpdateWorkSpaceAddresses(
                key->memoryBases[WORK_SPACE_BASE],
                &(key->WorkSpaceOffsets),
                &(key->pWorkSpaceAddr));
        
          fsg_UpdateWorkSpaceElement(
                &(key->WorkSpaceOffsets),
                &(key->pWorkSpaceAddr));
        
          MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    pOrigB = &key->GBMap.rectBounds;    /* local copy of bounds pointer */

#ifdef FSCFG_SUBPIXEL
    if (key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))                  /* if bitmap are not disabled */
#else
    if (key->bEmbeddedBitmap)               /* if bitmap are not disabled */
#endif // FSCFG_SUBPIXEL    
    {
        error = sbit_GetMetrics (                   /* get device metrics */
            &key->SbitMono,
            &key->ClientInfo,
            &f26DevAdvanceWidth,
            &f26DevLeftSideBearing,
            &f26LeftSideBearing,
            &f26DevAdvanceHeight,
            &f26DevTopSideBearing,
            &f26TopSideBearing,
            pOrigB,
            &usRowBytes,
            &ulSbitOutSize,
            &ulSbitWorkSize );
        
        if (error != NO_ERR)
        {
            return(error);
        }
        
        outputPtr->metricInfo.devAdvanceWidth.x = DOT6TOFIX(f26DevAdvanceWidth.x);
        outputPtr->metricInfo.devAdvanceWidth.y = DOT6TOFIX(f26DevAdvanceWidth.y);
        outputPtr->metricInfo.devLeftSideBearing.x = DOT6TOFIX(f26DevLeftSideBearing.x);
        outputPtr->metricInfo.devLeftSideBearing.y = DOT6TOFIX(f26DevLeftSideBearing.y);
        outputPtr->metricInfo.leftSideBearing.x = DOT6TOFIX(f26LeftSideBearing.x);
        outputPtr->metricInfo.leftSideBearing.y = DOT6TOFIX(f26LeftSideBearing.y);
        
        outputPtr->verticalMetricInfo.devAdvanceHeight.x = DOT6TOFIX(f26DevAdvanceHeight.x);
        outputPtr->verticalMetricInfo.devAdvanceHeight.y = DOT6TOFIX(f26DevAdvanceHeight.y);
        outputPtr->verticalMetricInfo.devTopSideBearing.x = DOT6TOFIX(f26DevTopSideBearing.x);
        outputPtr->verticalMetricInfo.devTopSideBearing.y = DOT6TOFIX(f26DevTopSideBearing.y);
        outputPtr->verticalMetricInfo.topSideBearing.x = DOT6TOFIX(f26TopSideBearing.x);
        outputPtr->verticalMetricInfo.topSideBearing.y = DOT6TOFIX(f26TopSideBearing.y);
        
        /* just copy to 'Line' metrics */

        outputPtr->metricInfo.devLeftSideBearingLine.x = outputPtr->metricInfo.devLeftSideBearing.x;
        outputPtr->metricInfo.devLeftSideBearingLine.y = outputPtr->metricInfo.devLeftSideBearing.y;
        outputPtr->metricInfo.leftSideBearingLine.x = outputPtr->metricInfo.leftSideBearing.x;
        outputPtr->metricInfo.leftSideBearingLine.y = outputPtr->metricInfo.leftSideBearing.y;

        outputPtr->verticalMetricInfo.devTopSideBearingLine.x = outputPtr->verticalMetricInfo.devTopSideBearing.x;
        outputPtr->verticalMetricInfo.devTopSideBearingLine.y = outputPtr->verticalMetricInfo.devTopSideBearing.y;
        outputPtr->verticalMetricInfo.topSideBearingLine.x = outputPtr->verticalMetricInfo.topSideBearing.x;
        outputPtr->verticalMetricInfo.topSideBearingLine.y = outputPtr->verticalMetricInfo.topSideBearing.y;


    error = sfac_ReadGlyphMetrics (             /* get non-dev adv width */
            &key->ClientInfo,
            key->ClientInfo.usGlyphIndex,
            &key->usNonScaledAW,
            &key->usNonScaledAH,
            &sNonScaledLSB,
            &sNonScaledTSB);

        if(error != NO_ERR)
        {
            return error;
        }

        fsg_UpdateAdvanceWidth (
            &key->TransformInfo,                    /* scale the design adv width */
            pvGlobalGS, 
            key->usNonScaledAW,
            &outputPtr->metricInfo.advanceWidth );

        fsg_UpdateAdvanceHeight (
            &key->TransformInfo,                    /* scale the design adv height */
            pvGlobalGS, 
            key->usNonScaledAH,
            &outputPtr->verticalMetricInfo.advanceHeight );

        pBMI = &outputPtr->bitMapInfo;
        pBMI->bounds.left = pOrigB->left;               /* return bbox to client */
        pBMI->bounds.right = pOrigB->right;
        pBMI->bounds.top = pOrigB->bottom;              /* reversed! */
        pBMI->bounds.bottom = pOrigB->top;
        pBMI->rowBytes = (int16)usRowBytes;
        pBMI->baseAddr = 0L;

        outputPtr->memorySizes[BITMAP_PTR_1] = ulSbitOutSize;
        outputPtr->memorySizes[BITMAP_PTR_2] = ulSbitWorkSize;
        outputPtr->memorySizes[BITMAP_PTR_3] = 0L;
        outputPtr->memorySizes[BITMAP_PTR_4] = 0L;
    }
    else                                /* if rasterizing from a contour */
    {
        if (key->TransformInfo.bPhaseShift)
        {
            fsg_45DegreePhaseShift (&key->pWorkSpaceAddr);
        }

        fsg_GetContourData(
            &key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
            FALSE,            
#endif // FSCFG_SUBPIXEL
            &CList.afxXCoord,
            &CList.afxYCoord,
            &CList.asStartPoint,
            &CList.asEndPoint,
            &CList.abyOnCurve,
            &CList.abyFc,
            &CList.usContourCount);

        error = fsc_RemoveDups(&CList);                 /* collapse dup'd points */
        if (error != NO_ERR)
        {
            return(error);
        }

        pGBMap = &key->GBMap;                           /* default to usual structure */
        usRoundXMin = 1;

        if (key->bGrayScale)                                 /* if doing gray scale */
        {
            error = fsc_OverScaleOutline(&CList, key->usOverScale);
            if (error != NO_ERR)
            {
                return(error);
            }
            pGBMap = &key->OverGBMap;                   /* measure overscaled structure */
            usRoundXMin = key->usOverScale;
        }
        
        fsg_GetWorkSpaceExtra(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            &(key->WScan.pchRBuffer));
        key->WScan.lRMemSize = key->lExtraWorkSpace;    /* use extra for MeasureGlyph workspace */
        
        if (key->bBitmapEmboldening) 
        {
            if (key->bGrayScale)                                 /* if doing gray scale */
            {
                sBitmapEmboldeningHorExtra = key->usOverScale * key->sBoldSimulHorShift;
                sBitmapEmboldeningVertExtra = key->usOverScale * key->sBoldSimulVertShift;
            } 
#ifdef FSCFG_SUBPIXEL
            else if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
            {
                sBitmapEmboldeningHorExtra = RGB_OVERSCALE * key->sBoldSimulHorShift; 
                sBitmapEmboldeningVertExtra = key->sBoldSimulVertShift; 
            }
#endif // FSCFG_SUBPIXEL
            else
            {
                sBitmapEmboldeningHorExtra = key->sBoldSimulHorShift; 
                sBitmapEmboldeningVertExtra = key->sBoldSimulVertShift; 
            }
        }
        else
        {
            sBitmapEmboldeningHorExtra = 0;
            sBitmapEmboldeningVertExtra = 0;
        }

        error = fsc_MeasureGlyph(
            &CList, 
            pGBMap, 
            &key->WScan, 
            key->usScanType, 
            usRoundXMin,
            sBitmapEmboldeningHorExtra,
            sBitmapEmboldeningVertExtra );

        if (error == SMART_DROP_OVERFLOW_ERR)
        {
            /* glyph is too complex for the smart dropout control */
            key->usScanType &= ~SK_SMART;
            error = fsc_MeasureGlyph(
                &CList, 
                pGBMap, 
                &key->WScan, 
                key->usScanType, 
                usRoundXMin,
                sBitmapEmboldeningHorExtra,
                sBitmapEmboldeningVertExtra );
        }
        if (error != NO_ERR)
        {
            return(error);
        }
        Assert(key->WScan.lRMemSize < key->lExtraWorkSpace);
        
        if (key->bGrayScale)                                 /* if doing gray scale */
        {
            sOverScale = (int16)key->usOverScale;
            
            if (key->bMatchBBox)        /* if bounding box is fixed */
            {                                           /* the calc as if orig monochrome */
                pOverG = &key->OverGBMap;        
                pOrigB->left = (int16)((mth_DivShiftLong(pOverG->fxMinX, sOverScale) + 31L) >> 6);
                pOrigB->right = (int16)((mth_DivShiftLong(pOverG->fxMaxX, sOverScale) + 32L) >> 6);
                pOrigB->bottom = (int16)((mth_DivShiftLong(pOverG->fxMinY, sOverScale) + 31L) >> 6);
                pOrigB->top = (int16)((mth_DivShiftLong(pOverG->fxMaxY, sOverScale) + 32L) >> 6);

                /* force the bitmap to have at least one pixel wide and one pixel high */
                if (pOrigB->left == pOrigB->right)
                {
                    pOrigB->right++;                                /* force 1 pixel wide */
                }
                if (pOrigB->bottom == pOrigB->top)
                {
                    pOrigB->top++;                                /* force 1 pixel high */
                }

            }
            else                                        /* if bounding box can grow */
            {                                           /* then size to gray box */
                pOverB = &key->OverGBMap.rectBounds;        
                pOrigB->left = mth_DivShiftShort(pOverB->left, sOverScale);
                pOrigB->right = mth_DivShiftShort((int16)(pOverB->right + sOverScale - 1), sOverScale);
                pOrigB->bottom = mth_DivShiftShort(pOverB->bottom, sOverScale);
                pOrigB->top = mth_DivShiftShort((int16)(pOverB->top + sOverScale - 1), sOverScale);
            }
        }
        
        fsg_CalcLSBsAndAdvanceWidths(                   /* use original size for all metrics */
            &key->pWorkSpaceAddr,
            INTTODOT6(pOrigB->left),
            INTTODOT6(pOrigB->top),
            &f26DevAdvanceWidth,
            &f26DevLeftSideBearing,
            &f26LeftSideBearing,
            &f26DevLeftSideBearingLine,
            &f26LeftSideBearingLine);

        outputPtr->metricInfo.devAdvanceWidth.x        = DOT6TOFIX(f26DevAdvanceWidth.x);
        outputPtr->metricInfo.devAdvanceWidth.y        = DOT6TOFIX(f26DevAdvanceWidth.y);
        outputPtr->metricInfo.devLeftSideBearing.x     = DOT6TOFIX(f26DevLeftSideBearing.x);
        outputPtr->metricInfo.devLeftSideBearing.y     = DOT6TOFIX(f26DevLeftSideBearing.y);
        outputPtr->metricInfo.leftSideBearing.x        = DOT6TOFIX(f26LeftSideBearing.x);
        outputPtr->metricInfo.leftSideBearing.y        = DOT6TOFIX(f26LeftSideBearing.y);
        outputPtr->metricInfo.devLeftSideBearingLine.x = DOT6TOFIX(f26DevLeftSideBearingLine.x);
        outputPtr->metricInfo.devLeftSideBearingLine.y = DOT6TOFIX(f26DevLeftSideBearingLine.y);
        outputPtr->metricInfo.leftSideBearingLine.x    = DOT6TOFIX(f26LeftSideBearingLine.x);
        outputPtr->metricInfo.leftSideBearingLine.y    = DOT6TOFIX(f26LeftSideBearingLine.y);

        fsg_CalcTSBsAndAdvanceHeights(                   /* use original size for all metrics */
            &key->pWorkSpaceAddr,
            INTTODOT6(pOrigB->left),
            INTTODOT6(pOrigB->top),
            &f26DevAdvanceHeight,
            &f26DevTopSideBearing,
            &f26TopSideBearing,
            &f26DevTopSideBearingLine,
            &f26TopSideBearingLine);

        outputPtr->verticalMetricInfo.devAdvanceHeight.x      = DOT6TOFIX(f26DevAdvanceHeight.x);
        outputPtr->verticalMetricInfo.devAdvanceHeight.y      = DOT6TOFIX(f26DevAdvanceHeight.y);
        outputPtr->verticalMetricInfo.devTopSideBearing.x     = DOT6TOFIX(f26DevTopSideBearing.x);
        outputPtr->verticalMetricInfo.devTopSideBearing.y     = DOT6TOFIX(f26DevTopSideBearing.y);
        outputPtr->verticalMetricInfo.topSideBearing.x        = DOT6TOFIX(f26TopSideBearing.x);
        outputPtr->verticalMetricInfo.topSideBearing.y        = DOT6TOFIX(f26TopSideBearing.y);
        outputPtr->verticalMetricInfo.devTopSideBearingLine.x = DOT6TOFIX(f26DevTopSideBearingLine.x);
        outputPtr->verticalMetricInfo.devTopSideBearingLine.y = DOT6TOFIX(f26DevTopSideBearingLine.y);
        outputPtr->verticalMetricInfo.topSideBearingLine.x    = DOT6TOFIX(f26TopSideBearingLine.x);
        outputPtr->verticalMetricInfo.topSideBearingLine.y    = DOT6TOFIX(f26TopSideBearingLine.y);

        fsg_UpdateAdvanceWidth (&key->TransformInfo, pvGlobalGS, key->usNonScaledAW,
            &outputPtr->metricInfo.advanceWidth);

        fsg_UpdateAdvanceHeight (&key->TransformInfo, pvGlobalGS, key->usNonScaledAH,
            &outputPtr->verticalMetricInfo.advanceHeight);

        MEMCPY(&key->metricInfo, &outputPtr->metricInfo, sizeof( metricsType ));
        MEMCPY(&key->verticalMetricInfo, &outputPtr->verticalMetricInfo, sizeof( verticalMetricsType ));

        pBMI = &outputPtr->bitMapInfo;
        pBMI->bounds.top = pOrigB->bottom;              /* reversed! */
        pBMI->bounds.bottom = pOrigB->top;
        pBMI->baseAddr = 0;
        
#ifdef FSCFG_SUBPIXEL
        if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
        {
            if (!(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
            {
                /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
                ROUND_FROM_HINT_OVERSCALE(outputPtr->metricInfo.advanceWidth.x);
                ROUND_FROM_HINT_OVERSCALE(outputPtr->verticalMetricInfo.advanceHeight.x);
            }
            ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devAdvanceWidth.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devLeftSideBearing.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.leftSideBearing.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devLeftSideBearingLine.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.leftSideBearingLine.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devAdvanceHeight.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devTopSideBearing.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.topSideBearing.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devTopSideBearingLine.x);
            ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.topSideBearingLine.x);

            pBMI->bounds.left = FLOOR_RGB_OVERSCALE(pOrigB->left);               /* return bbox to client */
            pBMI->bounds.right = CEIL_RGB_OVERSCALE(pOrigB->right);

            pBMI->rowBytes = ((pBMI->bounds.right - pBMI->bounds.left) + 3) & (-4);

            key->OverGBMap = key->GBMap;
            key->GBMap.sRowBytes = pBMI->rowBytes;
            key->GBMap.rectBounds.left = pBMI->bounds.left;
            key->GBMap.rectBounds.right = pBMI->bounds.right;
            key->GBMap.lMMemSize = (int32)pBMI->rowBytes * (int32)(key->GBMap.rectBounds.top - key->GBMap.rectBounds.bottom);
            outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize; 
        }
        else
        {
#endif // FSCFG_SUBPIXEL
            pBMI->bounds.left = pOrigB->left;               /* return bbox to client */
            pBMI->bounds.right = pOrigB->right;
            pBMI->rowBytes = key->GBMap.sRowBytes;
#ifdef FSCFG_SUBPIXEL
        }
#endif // FSCFG_SUBPIXEL

        if (key->bGrayScale)                                 /* if doing gray scale */
        {
            pBMI->rowBytes = ((pOrigB->right - pOrigB->left) + 3) & (-4);
            key->GBMap.lMMemSize = (int32)pBMI->rowBytes * (int32)(pOrigB->top - pOrigB->bottom);
            outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize; 
        }
        
        key->GBMap.sRowBytes = pBMI->rowBytes;
        outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) key->GBMap.lMMemSize;
        outputPtr->memorySizes[BITMAP_PTR_2] = (FS_MEMORY_SIZE) key->WScan.lHMemSize;
        outputPtr->memorySizes[BITMAP_PTR_3] = (FS_MEMORY_SIZE) key->WScan.lVMemSize;

    }
    fsg_CheckWorkSpaceForFit(
        &(key->WorkSpaceOffsets),
        key->lExtraWorkSpace,
        key->WScan.lRMemSize,
        &(outputPtr->memorySizes[BITMAP_PTR_2]),
        &(outputPtr->memorySizes[BITMAP_PTR_3]));

    key->usBandType = FS_BANDINGOLD;                /* assume old banding */
    key->usBandWidth = 0;
    key->bOutlineIsCached = FALSE;                  /* assume no caching */

    fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

    STAT_OFF_FINDBMS;             /* stop STAT timer */
    
    return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    fs_SplineKey *     key;
    int32              ulSize;
    ErrorCode          error;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if (key->bEmbeddedBitmap)
    {
        return SBIT_OUTLINE_CACHE_ERR;      /* can't cache sbits */
    }

    if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
    {
        fsg_UpdateWorkSpaceAddresses(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        fsg_UpdateWorkSpaceElement(
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        key->WScan.pchRBuffer = (char *)fsg_QueryReusableMemory(
        key->memoryBases[WORK_SPACE_BASE],
        &(key->WorkSpaceOffsets));

        MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    ulSize = (uint32)sizeof( uint32 );                         /* OUTLINESTAMP              */
    ulSize += (uint32)( sizeof( FS_MEMORY_SIZE ) * BITMAP_MEMORY_COUNT );   /* Memory Bases */
    ulSize += (uint32)( sizeof( uint32 ));                     /* Outlines Exist (padded)   */
    ulSize += (uint32)( sizeof( uint32 ));                     /* Scan Type (padded)        */
    ulSize += (uint32)( sizeof( uint32 ));                     /* Glyph Index (padded)      */
    ulSize += (uint32)( sizeof( uint32 ));                     /* Outline Cache Size        */
    ulSize += (uint32)( sizeof( uint32 ));                     /* Gray Scale Over Factor    */
    ulSize += (uint32)( sizeof( uint32 ));                     /* Grid Fit Skipped Boolean  */
    ulSize += (uint32)( sizeof( uint32 ));                     /* no embedded bitmap Boolean*/
    ulSize += (uint32)sizeof( metricsType );                   /* Metrics information       */
    ulSize += (uint32)sizeof( verticalMetricsType );           /* Vert metrics information  */
    ulSize += (uint32)sizeof( GlyphBitMap );                   /* Glyph Bitmap              */
    ulSize += (uint32)sizeof( GlyphBitMap );                   /* Gray Overscaled Bitmap    */
    ulSize += (uint32)sizeof( WorkScan );                      /* Scanconverter Workspace   */
    ulSize += (uint32)key->WScan.lRMemSize;                    /* Reversal list             */
    ulSize += fsg_GetContourDataSize(&key->pWorkSpaceAddr);    /* Contour Data              */
    ulSize += (uint32)sizeof( uint32 );                        /* OUTLINESTAMP2             */
    ALIGN(uint32, ulSize);

    outputPtr->outlineCacheSize = ulSize;
    key->ulGlyphOutlineSize = ulSize;

    return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    uint8 *            pbyDest;

    fs_SplineKey *     key;
    ErrorCode          error;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
    {
        fsg_UpdateWorkSpaceAddresses(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        fsg_UpdateWorkSpaceElement(
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    if( (outputPtr->memorySizes[BITMAP_PTR_2] == 0L) || (outputPtr->memorySizes[BITMAP_PTR_3] == 0L))
    {
        fsg_GetRealBitmapSizes(
            &(key->WorkSpaceOffsets),
            &outputPtr->memorySizes[BITMAP_PTR_2],
            &outputPtr->memorySizes[BITMAP_PTR_3]);
    }

    pbyDest = (uint8 *)inputPtr->param.outlineCache;

    *((uint32 *)pbyDest) = OUTLINESTAMP;
    pbyDest += sizeof( uint32 );

    *((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_1];
    pbyDest += sizeof( FS_MEMORY_SIZE  );

    *((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_2];
    pbyDest += sizeof( FS_MEMORY_SIZE  );

    *((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_3];
    pbyDest += sizeof( FS_MEMORY_SIZE  );

    *((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_4];
    pbyDest += sizeof( FS_MEMORY_SIZE   );
     
    /* Outlines exist state */

    *((uint32 *)pbyDest) = (uint32)key->bGlyphHasOutline;
    pbyDest += sizeof( uint32 );

    /* Dropout control state */

    *((uint32 *)pbyDest) = (uint32)key->usScanType;
    pbyDest += sizeof( uint32 );

    /* Glyph Index */

    *((uint32 *)pbyDest) = (uint32)key->ClientInfo.usGlyphIndex;
    pbyDest += sizeof( uint32 );

    /* Outline Cache Size */

    *((uint32 *)pbyDest) = (uint32)key->ulGlyphOutlineSize;
    pbyDest += sizeof( uint32 );

    /* Gray Over Scale Factor */

    *((uint32 *)pbyDest) = (uint32)key->usOverScale;
    pbyDest += sizeof( uint32 );

    /* Grid Fit Skipped Boolean  */

    *((uint32 *)pbyDest) = (uint32)key->bGridFitSkipped;
    pbyDest += sizeof( uint32 );

    /* No embedded bitmap Boolean  */

    *((uint32 *)pbyDest) = (uint32)key->bEmbeddedBitmap;
    pbyDest += sizeof( uint32 );

    /* Glyph metrics */

    MEMCPY(pbyDest, &key->metricInfo, sizeof(metricsType));
    pbyDest += sizeof(metricsType);

    MEMCPY(pbyDest, &key->verticalMetricInfo, sizeof(verticalMetricsType));
    pbyDest += sizeof(verticalMetricsType);

    /* Scan Converter Data Structures */

    MEMCPY(pbyDest, &key->GBMap, sizeof(GlyphBitMap));
    pbyDest += sizeof(GlyphBitMap);

    MEMCPY(pbyDest, &key->OverGBMap, sizeof(GlyphBitMap));
    pbyDest += sizeof(GlyphBitMap);

    MEMCPY(pbyDest, &key->WScan, sizeof(WorkScan));
    pbyDest += sizeof(WorkScan);

    MEMCPY(pbyDest, key->WScan.pchRBuffer, (size_t)key->WScan.lRMemSize);
    pbyDest += key->WScan.lRMemSize;

    /*** save charData ***/

    fsg_DumpContourData(&key->pWorkSpaceAddr, &pbyDest);

    *((uint32 *)pbyDest) = OUTLINESTAMP2;

    fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));

    return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    fs_SplineKey *  key;
    uint8 *         pbySrc;
    ErrorCode       error;

    key = fs_SetUpKey(inputPtr, INITIALIZED, &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    pbySrc = (uint8 *)inputPtr->param.outlineCache;

    if ( *((uint32 *)pbySrc) != OUTLINESTAMP )
    {
        return TRASHED_OUTLINE_CACHE;
    }
    pbySrc += sizeof(uint32);

    outputPtr->memorySizes[BITMAP_PTR_1] = *((FS_MEMORY_SIZE *)pbySrc);
    pbySrc += sizeof( FS_MEMORY_SIZE   );

    outputPtr->memorySizes[BITMAP_PTR_2] = *((FS_MEMORY_SIZE *)pbySrc);
    pbySrc += sizeof( FS_MEMORY_SIZE   );

    outputPtr->memorySizes[BITMAP_PTR_3] = *((FS_MEMORY_SIZE *)pbySrc);
    pbySrc += sizeof( FS_MEMORY_SIZE   );

    outputPtr->memorySizes[BITMAP_PTR_4] = *((FS_MEMORY_SIZE *)pbySrc);
    pbySrc += sizeof( FS_MEMORY_SIZE    );

    /* Read in GlyphHasOutline */

    outputPtr->outlinesExist = (uint16)(*((uint32 *)pbySrc));
    pbySrc += sizeof( uint32 );

    /* Read ScanType state */

    key->usScanType = (uint16)(*((uint32 *)pbySrc));
    pbySrc += sizeof( uint32 );

    /* Read Glyph Index */

    outputPtr->glyphIndex = (uint16)(*((uint32 *)pbySrc));
    pbySrc += sizeof( uint32 );

    /* Read Size of Outline Cache  */

    outputPtr->outlineCacheSize = (uint16)(*((uint32 *)pbySrc));
    pbySrc += sizeof( uint32 );

    /* Read Gray Over Scale Factor  */

    key->usOverScale = (uint16)(*((uint32 *)pbySrc));
    outputPtr->usGrayLevels = key->usOverScale * key->usOverScale + 1;
    key->bGrayScale = (key->usOverScale == 0) ? FALSE : TRUE;
    pbySrc += sizeof( uint32 );

    /* Grid Fit Skipped Boolean  */

    key->bGridFitSkipped = (boolean)(*((uint32 *)pbySrc));
    pbySrc += sizeof( uint32 );

    /* No embedded bitmap Boolean  */

    key->bEmbeddedBitmap = (boolean)(*((uint32 *)pbySrc));
    pbySrc += sizeof( uint32 );

    /* Load fs_FindBitmapSize metrics */

    MEMCPY(&outputPtr->metricInfo, pbySrc, sizeof(metricsType));
    pbySrc += sizeof(metricsType);

    MEMCPY(&outputPtr->verticalMetricInfo, pbySrc, sizeof(verticalMetricsType));
    pbySrc += sizeof(verticalMetricsType);

    /* Load ScanConverter data structures */

    MEMCPY(&key->GBMap, pbySrc, sizeof(GlyphBitMap));
    pbySrc += sizeof(GlyphBitMap);

    MEMCPY(&key->OverGBMap, pbySrc, sizeof(GlyphBitMap));
    pbySrc += sizeof(GlyphBitMap);

    MEMCPY(&key->WScan, pbySrc, sizeof(WorkScan));
    pbySrc += sizeof(WorkScan);

    key->WScan.pchRBuffer = (char *)pbySrc;
    pbySrc += key->WScan.lRMemSize;

    fsg_RestoreContourData(
        &pbySrc,
        &outputPtr->xPtr,
        &outputPtr->yPtr,
        &outputPtr->startPtr,
        &outputPtr->endPtr,
        &outputPtr->onCurve,
        &outputPtr->fc,
        &outputPtr->numberOfContours);

    outputPtr->bitMapInfo.baseAddr = NULL;
    outputPtr->bitMapInfo.rowBytes = key->GBMap.sRowBytes;
    outputPtr->bitMapInfo.bounds.left = key->GBMap.rectBounds.left;
    outputPtr->bitMapInfo.bounds.right = key->GBMap.rectBounds.right;
    outputPtr->bitMapInfo.bounds.top = key->GBMap.rectBounds.bottom;   /* reversed! */
    outputPtr->bitMapInfo.bounds.bottom = key->GBMap.rectBounds.top;

    outputPtr->scaledCVT = NULL;
    outputPtr->numberOfBytesTaken = 0;

    key->usBandType = FS_BANDINGOLD;                    /* assume old banding */
    key->usBandWidth = 0;
    key->apbPrevMemoryBases[BITMAP_PTR_2] = NULL;       /* for fast/faster check */
    key->apbPrevMemoryBases[BITMAP_PTR_3] = NULL;

    key->bOutlineIsCached = TRUE;

    fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));
    return NO_ERR;
}

/*********************************************************************/

/* Calculate memory requirements for banding                         */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    ErrorCode       error;
    fs_SplineKey *  key;
    uint8 *         pbyOutline;
    int16           sMaxOvershoot;
    int16           sHiOvershoot;
    int16           sLoOvershoot;
    GlyphBitMap *   pGBMap;             /* orig or over pointer */


    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if (key->bGridFitSkipped || key->bEmbeddedBitmap)
    {
        return SBIT_BANDING_ERR;                /* can't band sbits */
    }
    
    if( !key->bOutlineIsCached )
    {
        CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
        key->WScan.pchRBuffer = (char *)fsg_QueryReusableMemory(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets));
    }
    else
    {
        /* Unload the outline cache */

        pbyOutline = (uint8 *)inputPtr->param.band.outlineCache;

        if( *((uint32 *)pbyOutline) != OUTLINESTAMP )
        {
              return TRASHED_OUTLINE_CACHE;
        }

        pbyOutline += sizeof( uint32 ) +
              (BITMAP_MEMORY_COUNT * sizeof (FS_MEMORY_SIZE))  /* !!! Skip over stamp & 3 bitmap sizes */
              + sizeof( uint32 )                      /* Outlines Exist (padded)  */
              + sizeof( uint32 )                      /* Scan Type (padded)        */
              + sizeof( uint32 )                      /* Glyph Index (padded)      */
              + sizeof( uint32 )                      /* Outline Cache Size        */
              + sizeof( uint32 )                      /* Gray Over Scale Factor    */
              + sizeof( uint32 )                      /* Grid Fit Skipped Boolean  */
              + sizeof( uint32 )                      /* no embedded bitmap Boolean*/
              + sizeof( metricsType )                 /* Metrics information       */
              + sizeof( verticalMetricsType )         /* Vert metrics information  */
              + sizeof( GlyphBitMap )
              + sizeof( GlyphBitMap )                 /* Over Scale structure      */
              + sizeof( WorkScan );

        key->WScan.pchRBuffer = (char *)pbyOutline;

        /* No need to further unload outline cache */
    }

    pGBMap = &key->GBMap;                           /* default usual structure */
    key->usBandWidth = inputPtr->param.band.usBandWidth;
    key->usBandType = inputPtr->param.band.usBandType;

    if (key->bGrayScale)                                 /* if doing gray scale */
    {
        pGBMap = &key->OverGBMap;                   /* measure overscaled structure */
        key->usBandWidth *= key->usOverScale;
/*  
 *  Band width for the over scaled bitmap is basically just the requested band 
 *  width times the overscale factor.  However! if the gray scaled bounding 
 *  box has been trimmed to match the monochrome box (i.e. bMatchBBox = TRUE),
 *  then top and bottom bands must be made bigger to include the entire over
 *  scaled bitmap.  If this were not done it would break dropout control, and
 *  bitmaps would change with banding.  So that's why we do this messing around
 *  with overshoot in the key->usBandWidth calculation.
 */
        sMaxOvershoot = 0;
        sHiOvershoot = (int16)(key->OverGBMap.rectBounds.top -
                       key->GBMap.rectBounds.top * (int16)key->usOverScale);
        if (sHiOvershoot > sMaxOvershoot)
        {
            sMaxOvershoot = sHiOvershoot;
        }
        sLoOvershoot = (int16)(key->GBMap.rectBounds.bottom * (int16)key->usOverScale -
                       key->OverGBMap.rectBounds.bottom);
        if (sLoOvershoot > sMaxOvershoot)
        {
            sMaxOvershoot = sLoOvershoot;
        }
        key->usBandWidth += (uint16)sMaxOvershoot;
    }

    error = fsc_MeasureBand(
        pGBMap,                     /* orig or over scaled bounding box, etc. */
        &key->WScan,
        key->usBandType,
        key->usBandWidth,           /* worst case band width */
        key->usScanType );
    if (error != NO_ERR)
    {
        return(error);
    }

    if (key->bGrayScale)                                 /* if doing gray scale */
    {
        key->GBMap.lMMemSize = (int32)key->GBMap.sRowBytes * (int32)inputPtr->param.band.usBandWidth;
        outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize;
    }
    
    outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) key->GBMap.lMMemSize;
    outputPtr->memorySizes[BITMAP_PTR_2] = (FS_MEMORY_SIZE) key->WScan.lHMemSize;
    outputPtr->memorySizes[BITMAP_PTR_3] = (FS_MEMORY_SIZE) key->WScan.lVMemSize;
    
    if( !key->bOutlineIsCached )
    {
        fsg_CheckWorkSpaceForFit(
            &(key->WorkSpaceOffsets),
            key->lExtraWorkSpace,
            key->WScan.lRMemSize,                             /* MeasureGlyph workspace */
            &(outputPtr->memorySizes[BITMAP_PTR_2]),
            &(outputPtr->memorySizes[BITMAP_PTR_3]));
    }

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    if( !key->bOutlineIsCached )
    {
        CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    }

    return NO_ERR;
}

/*********************************************************************/

#ifdef FSCFG_CONVERT_GRAY_LEVELS

// Tables to speed up bitmap translation from different GrayLevels.
uint8 Gray4To5Table[4]= {0,1,3,4};
uint8 Gray16To5Table[16]={0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4};

uint8 Gray4To17Table[4]= {0,5,11,16};
uint8 Gray16To17Table[16]={0,1,2,3,4,5,6,7,9,10,11,12,13,14,15,16};

uint8 Gray4To65Table[4]= {0,21,43,64};
uint8 Gray16To65Table[16]={0,4,9,13,17,21,26,30,34,38,43,47,51,55,60,64};

FS_PRIVATE FS_ENTRY  fs_ConvertGrayLevels (fs_GlyphInfoType *outputPtr, uint16 usOverScale, uint16 usBitDepth);

FS_PRIVATE FS_ENTRY  fs_ConvertGrayLevels (fs_GlyphInfoType *outputPtr, uint16 usOverScale, uint16 usBitDepth)
    {
      uint16    index; // Gray level xlate table index
      switch (usOverScale) {
       case 2:
           {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To5Table[index];
                } /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To5Table[index];
                } /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To5Table[index];
                } /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
             } /* endswitch */
           }
          break;
       case 4:
           {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To17Table[index];
                } /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To17Table[index];
                } /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To17Table[index];
                } /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
             } /* endswitch */
           }
          break;
       case 8:
           {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To65Table[index];
                } /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To65Table[index];
                } /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To65Table[index];
                } /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
             } /* endswitch */
           }
          break;

       default:
               return BAD_GRAY_LEVEL_ERR;
       } /* endswitch */
       return NO_ERR;

    } /* end if bGrayScale */

#endif // FSCFG_CONVERT_GRAY_LEVELS

/* Generate a bitmap                                                 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{    
    ContourList     CList;        /* newscan contour list type */
    fs_SplineKey *  key;
    char *          pBitmapPtr2;
    char *          pBitmapPtr3;
    uint8 *         pbyOutline;
    ErrorCode       error;
    GlyphBitMap *   pGBMap;             /* orig or over pointer */


    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

    STAT_ON_SCAN;                    /* start STAT timer */

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if( !key->bOutlineIsCached )                /* if outline or embedded bitmap */
    {
        CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);

        if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
        {
            fsg_UpdateWorkSpaceAddresses(
                 key->memoryBases[WORK_SPACE_BASE],
                 &(key->WorkSpaceOffsets),
                 &(key->pWorkSpaceAddr));

            fsg_UpdateWorkSpaceElement(
                 &(key->WorkSpaceOffsets),
                 &(key->pWorkSpaceAddr));

            key->apbPrevMemoryBases[WORK_SPACE_BASE] = key->memoryBases[WORK_SPACE_BASE];
        }

        fsg_SetUpWorkSpaceBitmapMemory(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            key->memoryBases[BITMAP_PTR_2],
            key->memoryBases[BITMAP_PTR_3],
            &pBitmapPtr2,                       /* sbits may need Ptr2 */
            &pBitmapPtr3);

        /* check for embedded bitmap, quick return if found */

#ifdef FSCFG_SUBPIXEL
        if (key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))                  /* if bitmap are not disabled */
#else
        if (key->bEmbeddedBitmap)               /* if bitmap are not disabled */
#endif // FSCFG_SUBPIXEL    
        {
            if ((inputPtr->param.scan.topClip > inputPtr->param.scan.bottomClip) &&  /* if legal band */
               ((inputPtr->param.scan.topClip < key->GBMap.rectBounds.top) ||
                (inputPtr->param.scan.bottomClip > key->GBMap.rectBounds.bottom)))
            {
                return SBIT_BANDING_ERR;            /* can't band sbits */
            }

            error = sbit_GetBitmap (
                &key->SbitMono,
                &key->ClientInfo,
                (uint8 *) inputPtr->memoryBases[BITMAP_PTR_1],
                (uint8 *) pBitmapPtr2 );
        
            if (error != NO_ERR)
            {
                return((FS_ENTRY)error);
            }
            outputPtr->bitMapInfo.baseAddr = key->memoryBases[BITMAP_PTR_1];  /* return bitmap addr */

            CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
            CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);

            STAT_OFF_SCAN;                  /* stop STAT timer */

#ifdef FSCFG_CONVERT_GRAY_LEVELS
            if (key->bGrayScale)
            {
                error = fs_ConvertGrayLevels (outputPtr, key->usOverScale, key->SbitMono.usBitDepth);
            
                if(error)
                {
                    return (FS_ENTRY)error;
                }
            } /* end if bGrayScale */
#endif // FSCFG_CONVERT_GRAY_LEVELS

            return NO_ERR;                  /* return now with an sbit */
        }
        else        /* if scan converting an outline */
        {
            fsg_GetWorkSpaceExtra(
                key->memoryBases[WORK_SPACE_BASE],
                &(key->WorkSpaceOffsets),
                &(key->WScan.pchRBuffer));

            fsg_GetContourData(
                &key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
                FALSE,            
#endif // FSCFG_SUBPIXEL
                &CList.afxXCoord,
                &CList.afxYCoord,
                &CList.asStartPoint,
                &CList.asEndPoint,
                &CList.abyOnCurve,
                &CList.abyFc,
                &CList.usContourCount);
        }
    }
    else            /* Unload the outline cache */
    {
        pbyOutline = (uint8 *)inputPtr->param.scan.outlineCache;

        if( *((uint32 *)pbyOutline) != OUTLINESTAMP )
        {
             return TRASHED_OUTLINE_CACHE;
        }

        pbyOutline += sizeof( uint32 ) +
            (BITMAP_MEMORY_COUNT * sizeof (FS_MEMORY_SIZE))  /* !!! Skip over stamp & 3 bitmap sizes */
            + sizeof( uint32 )                      /* Outlines Exist (padded)  */
            + sizeof( uint32 )                      /* Scan Type (padded)        */
            + sizeof( uint32 )                      /* Glyph Index (padded)      */
            + sizeof( uint32 )                      /* Outline Cache Size        */
            + sizeof( uint32 )                      /* Gray Over Scale Factor    */
            + sizeof( uint32 )                      /* Grid Fit Skipped Boolean  */
            + sizeof( uint32 )                      /* no embedded bitmap Boolean*/
            + sizeof( metricsType )                 /* Metrics information       */
            + sizeof( verticalMetricsType )         /* Vert metrics information  */
            + sizeof( GlyphBitMap )
            + sizeof( GlyphBitMap )                 /* Over Scale structure      */
            + sizeof( WorkScan );

        key->WScan.pchRBuffer = (char *)pbyOutline;
        pbyOutline += key->WScan.lRMemSize;

        fsg_RestoreContourData(
            &pbyOutline,
            &CList.afxXCoord,
            &CList.afxYCoord,
            &CList.asStartPoint,
            &CList.asEndPoint,
            &CList.abyOnCurve,
            &CList.abyFc,
            &CList.usContourCount);

        if( *((uint32 *)pbyOutline) != OUTLINESTAMP2 )
        {
            return TRASHED_OUTLINE_CACHE;
        }

        pBitmapPtr2 = key->memoryBases[BITMAP_PTR_2];
        pBitmapPtr3 = key->memoryBases[BITMAP_PTR_3];
    }

    if (pBitmapPtr3 == NULL)  /* Allow client to turn off DOControl */
    {
        key->usScanType = SK_NODROPOUT;
    }

    key->GBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_1];
    key->GBMap.sHiBand = inputPtr->param.scan.topClip;
    key->GBMap.sLoBand = inputPtr->param.scan.bottomClip;

    if (key->GBMap.sHiBand <= key->GBMap.sLoBand)            /* if negative or no band */
    {
        key->GBMap.sHiBand = key->GBMap.rectBounds.top;     /* then for Apple compatiblity */
        key->GBMap.sLoBand = key->GBMap.rectBounds.bottom;  /* do the entire bitmap */
    }
    if (key->GBMap.sHiBand > key->GBMap.rectBounds.top)
    {
        key->GBMap.sHiBand = key->GBMap.rectBounds.top;     /* clip to bounding box */
    }
    if (key->GBMap.sLoBand < key->GBMap.rectBounds.bottom)
    {
        key->GBMap.sLoBand = key->GBMap.rectBounds.bottom;  /* clip to bounding box */
    }
         
    if ((key->usBandType == FS_BANDINGFASTER) &&
        ((key->apbPrevMemoryBases[BITMAP_PTR_2] != pBitmapPtr2) ||
         (key->apbPrevMemoryBases[BITMAP_PTR_3] != pBitmapPtr3)))
    {
         key->usBandType = FS_BANDINGFAST;  /* to recalculate memory */
    }

    if (key->usBandType == FS_BANDINGOLD)   /* if FindGrayBandingSize wasn't called */
    {
        if ((key->GBMap.sHiBand != key->GBMap.rectBounds.top) ||
            (key->GBMap.sLoBand != key->GBMap.rectBounds.bottom))   /* if banding */
        {
            if (key->bGrayScale)
            {
                return GRAY_OLD_BANDING_ERR;        /* gray scale fails with old banding */
            }
            key->usScanType = SK_NODROPOUT;         /* else force dropout off */
        }
    }
    else if (key->usBandType == FS_BANDINGSMALL)  /* if small mem type */
    {
        if (key->bGrayScale)
        {
            if (key->usOverScale *(key->GBMap.sHiBand - key->GBMap.sLoBand) > (int16)key->usBandWidth)
            {
                return BAND_TOO_BIG_ERR;          /* don't let band exceed calc'd size */
            }
        } else {
            if (key->GBMap.sHiBand - key->GBMap.sLoBand > (int16)key->usBandWidth)
            {
                return BAND_TOO_BIG_ERR;          /* don't let band exceed calc'd size */
            }
        }
        key->usScanType = SK_NODROPOUT;       /* turn off dropout control */
    }
    pGBMap = &key->GBMap;                     /* default to usual structure */
    
    if (key->bGrayScale)
    {
        pGBMap = &key->OverGBMap;             /* measure overscaled structure */
        
        if (key->GBMap.sHiBand == key->GBMap.rectBounds.top)            /* if gray band at top */
        {
            key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top;     /* use over top */
        }
        else
        {
            key->OverGBMap.sHiBand = (int16)(key->GBMap.sHiBand * (int16)key->usOverScale);
            if (key->OverGBMap.sHiBand > key->OverGBMap.rectBounds.top)
            {
                key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top; /* clip */
            }
        }
        if (key->GBMap.sLoBand == key->GBMap.rectBounds.bottom)         /* if gray band at bottom */
        {
            key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;  /* use over bottom */
        }
        else
        {
            key->OverGBMap.sLoBand = (int16)(key->GBMap.sLoBand * (int16)key->usOverScale);
            if (key->OverGBMap.sLoBand < key->OverGBMap.rectBounds.bottom)
            {
                key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;  /* clip */
            }
        }
        key->OverGBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_4];
    }
#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
        pGBMap = &key->OverGBMap;             /* draw into the overscaled structure */

        key->OverGBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_4];

        /* no banding yet !!! */
        key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top;
        key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;
    }
#endif // FSCFG_SUBPIXEL

    key->WScan.pchHBuffer = pBitmapPtr2;
    key->WScan.pchVBuffer = pBitmapPtr3;

    error = fsc_FillGlyph(
        &CList,
        pGBMap,
        &key->WScan,
        key->usBandType,
        key->usScanType
        );
    if (error != NO_ERR)
    {
        return(error);
    }
     
    if (key->bGrayScale)
    {
        error = fsc_CalcGrayMap(
            &key->OverGBMap, 
            &key->GBMap, 
            key->usOverScale
            );
        if (error != NO_ERR)
        {
            return((FS_ENTRY)error);
        }
    }

#ifdef FSCFG_SUBPIXEL
    if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
#ifdef FSCFG_SUBPIXEL_STANDALONE // B.St.
        outputPtr->overscaledBitmapInfo.baseAddr = key->OverGBMap.pchBitMap;
        outputPtr->overscaledBitmapInfo.rowBytes = key->OverGBMap.sRowBytes;
        outputPtr->overscaledBitmapInfo.bounds = key->OverGBMap.rectBounds; // save for more detailed processing
#endif
        fsc_OverscaleToSubPixel (&key->OverGBMap, (key->flSubPixel & FNT_SP_BGR_ORDER) > 0, &key->GBMap);
    }
#endif // FSCFG_SUBPIXEL

    if (key->bBitmapEmboldening)
    {
        if (key->bGrayScale)
        {
            uint16 usGrayLevels = key->usOverScale * key->usOverScale + 1;
            sbit_EmboldenGray((uint8 *)key->GBMap.pchBitMap, (uint16)(key->GBMap.rectBounds.right - key->GBMap.rectBounds.left), 
                          (uint16)(key->GBMap.sHiBand - key->GBMap.sLoBand), key->GBMap.sRowBytes,usGrayLevels, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
        } 
#ifdef FSCFG_SUBPIXEL
        else if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
        {
            sbit_EmboldenSubPixel((uint8 *)key->GBMap.pchBitMap, (uint16)(key->GBMap.rectBounds.right - key->GBMap.rectBounds.left), 
                          (uint16)(key->GBMap.sHiBand - key->GBMap.sLoBand), key->GBMap.sRowBytes, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
        } 
#endif // FSCFG_SUBPIXEL
        else 
        {
            sbit_Embolden((uint8 *)pGBMap->pchBitMap, (uint16)(pGBMap->rectBounds.right - pGBMap->rectBounds.left), 
                          (uint16)(pGBMap->sHiBand - pGBMap->sLoBand), pGBMap->sRowBytes, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
        }
    }

/*  Setting the Band Type to FS_BANDINGFASTER will allow the next call      */
/*  to fsc_FillGlyph to skip the rendering phase of scan conversion and     */
/*  get right to the bitmap fill.  If the client moves either memoryBase[6] */ 
/*  or memoryBase[7] between fs_ContourScan calls, then we must reset the   */
/*  band type to FS_BANDINGFAST to regenerate the data structures.          */

    if (key->usBandType == FS_BANDINGFAST)
    {
        key->usBandType = FS_BANDINGFASTER;    /* to save re-rendering */
        key->apbPrevMemoryBases[BITMAP_PTR_2] = pBitmapPtr2;
        key->apbPrevMemoryBases[BITMAP_PTR_3] = pBitmapPtr3;
    }

    outputPtr->bitMapInfo.baseAddr = key->memoryBases[BITMAP_PTR_1];  /* return bitmap addr */

    CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
    if( !key->bOutlineIsCached )
    {
        CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
    }

    STAT_OFF_SCAN;                /* stop STAT timer */

    return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
    FS_UNUSED_PARAMETER(inputPtr);
    FS_UNUSED_PARAMETER(outputPtr);
    return NO_ERR;
}

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void FS_ENTRY_PROTO fs_InitializeData (void)
    {
        fsg_InitializeData ();
    }
#endif



/*********************************************************************/

/* fs_GetScaledAdvanceWidths returns only horizontal advance widths and is not meant to be used under rotation */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceWidths (
    fs_GlyphInputType * inputPtr,
    uint16              usFirstGlyph,
    uint16              usLastGlyph,
    int16 *             psGlyphWidths)
{
    fs_SplineKey *      key;
    void *              pvGlobalGS;
    void *              pvStack;
    void *              pvFontProgram;
    void *              pvPreProgram;
    void *              pvTwilightZone;
    uint16              usCurrentGlyphIndex;
    uint16              usGlyphIndex;
    uint16              usPPEm;
    int16               sNonScaledLSB;
    vectorType          fxGlyphWidth;
    point               f26DevAdvanceWidth;
    boolean             bHdmxEntryExist;
    boolean             bBitmapFound;
    ErrorCode           error;
#ifdef FSCFG_SUBPIXEL   
    boolean             bSubPixelWidth = FALSE;
    fsg_TransformRec *  TransformInfoForGridFit;
    void *              pvGlobalGSSubPixel;
    void *              pvTwilightZoneSubPixel;
#endif // FSCFG_SUBPIXEL

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS ), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
       (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
    {
        fsg_UpdateWorkSpaceAddresses(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

        fsg_UpdatePrivateSpaceAddresses(
            &key->ClientInfo,
            &key->maxProfile,
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets),
            pvStack,
            &pvFontProgram,
            &pvPreProgram);

        MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    /*  Initialization  */

    bHdmxEntryExist = FALSE;

#ifdef FSCFG_SUBPIXEL   
    if ( (key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) ) 
    {
        bSubPixelWidth = TRUE;
    }
#endif // FSCFG_SUBPIXEL    

    /*  Save current glyph index    */

    usCurrentGlyphIndex = key->ClientInfo.usGlyphIndex;

    /*  Check input parameters  */

    if( (usLastGlyph > key->maxProfile.numGlyphs ) ||
        (usLastGlyph < usFirstGlyph))
    {
        return INVALID_GLYPH_INDEX;
    }

    if( psGlyphWidths == NULL )
    {
        return NULL_INPUT_PTR_ERR;
    }

    /*  Find our current PPEm   */

    fsg_QueryPPEM(pvGlobalGS, &usPPEm);
    /* Only Grab 'hdmx' if not stretched or rotated */

#ifdef FSCFG_SUBPIXEL   
    /* for SubPixel, use Hdmx width only if we are in compatible width mode */
    if( !bSubPixelWidth &&
        (!fsg_IsTransformStretched( &key->TransformInfo )) &&
        (!fsg_IsTransformRotated( &key->TransformInfo )) )
#else
    if( (!fsg_IsTransformStretched( &key->TransformInfo )) &&
        (!fsg_IsTransformRotated( &key->TransformInfo )) )
#endif // FSCFG_SUBPIXEL    
    {

        /*  Check if we can quickly grab the widths from the 'hdmx' table   */

        error = sfac_CopyHdmxEntry(
            &key->ClientInfo,
            usPPEm,
            &bHdmxEntryExist,
            usFirstGlyph,
            usLastGlyph,
            psGlyphWidths);

        if (error != NO_ERR)
        {
            return(error);
        }

        /* If we got a hit on the 'hdmx' we are done    */

        if( bHdmxEntryExist )
        {
            return NO_ERR;
        }
    }

    /* No hit on 'hmdx', now it is time for the dirty work  */

    /* We need to prepare ourselves here for a potential grid fit */

    fsg_UpdateWorkSpaceElement(
        &(key->WorkSpaceOffsets),
        &(key->pWorkSpaceAddr));

    pvTwilightZone = fsg_QueryTwilightElement(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

#ifdef FSCFG_SUBPIXEL
    TransformInfoForGridFit = &key->TransformInfo;
    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
        pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets));
        pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets));
    }
#endif // FSCFG_SUBPIXEL

    /*  potentially do delayed pre program execution */

    if (key->bExecutePrePgm)
    {
        /* Run the pre program and scale the control value table */

        key->bExecutePrePgm = FALSE;

        error = fsg_RunPreProgram (
            &key->ClientInfo,
            &key->maxProfile,
            &key->TransformInfo,
            pvGlobalGS,
            &key->pWorkSpaceAddr,
            pvTwilightZone,
            NULL);

        if(error)
        {
            /* If the pre-program fails, prevent further glyphs from being called */
            fs_SetState(key, (INITIALIZED | NEWSFNT));

            /* If the pre-program fails, switch off hinting for further glyphs */
            key->bHintingEnabled = FALSE;
            return (FS_ENTRY)error;
        }
#ifdef FSCFG_SUBPIXEL   
        if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
            error = fsg_RunPreProgram (
                &key->ClientInfo,
                &key->maxProfile,
                &key->TransformInfoSubPixel,
                pvGlobalGSSubPixel,
                &key->pWorkSpaceAddr,
                pvTwilightZoneSubPixel,
                NULL);

            if(error)
            {
                /* If the pre-program fails, prevent further glyphs from being called */
                fs_SetState(key, (INITIALIZED | NEWSFNT));

                /* If the pre-program fails, switch off hinting for further glyphs */
                key->bHintingEnabled = FALSE;
                return (FS_ENTRY)error;
            }
        }
#endif // FSCFG_SUBPIXEL    
    }

    /*  Now check 'LTSH' table for linear cutoff information    */

    error = sfac_GetLTSHEntries(
        &key->ClientInfo,
        usPPEm,
        usFirstGlyph,
        usLastGlyph,
        psGlyphWidths);

    /* The pfxGlyphWidths array contains a boolean for each glyph (from     */
    /* first glyph to last glyph) that indicates if the glyph scales        */
    /* linearly.                                                            */

    /* Handle each glyph    */

    for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
    {
#ifdef FSCFG_SUBPIXEL
        /* for SubPixel, use linear width only if we are in compatible width mode */
        if( !bSubPixelWidth &&
            (psGlyphWidths[usGlyphIndex - usFirstGlyph]) &&
            (!fsg_IsTransformStretched( &key->TransformInfo )) &&
            (!fsg_IsTransformRotated( &key->TransformInfo )) )
#else
        if( (psGlyphWidths[usGlyphIndex - usFirstGlyph]) &&
            (!fsg_IsTransformStretched( &key->TransformInfo )) &&
            (!fsg_IsTransformRotated( &key->TransformInfo )) )
#endif // FSCFG_SUBPIXEL    
        {
            /* Glyph Scales Linearly    */


        error = sfac_ReadGlyphHorMetrics (
                &key->ClientInfo,
                usGlyphIndex,
                &key->usNonScaledAW,
                &sNonScaledLSB);

            if(error)
            {
                return (FS_ENTRY)error;
            }

            fsg_UpdateAdvanceWidth (
                &key->TransformInfo,
                pvGlobalGS,
                key->usNonScaledAW,
                &fxGlyphWidth);

            psGlyphWidths[usGlyphIndex - usFirstGlyph] = (int16)((fxGlyphWidth.x + ONEHALFFIX) >> 16);
        }
        else    /* Glyph does not scale linearly */
        {
            error = LookForSbitAdvanceWidth (
                key, 
                usGlyphIndex, 
                &bBitmapFound, 
                &f26DevAdvanceWidth );          /* value returned if found */
            
            if(error)
            {
                return (FS_ENTRY)error;
            }

            if (bBitmapFound == FALSE)
            {
                /* Glyph needs to be grid fitted */

                key->ClientInfo.usGlyphIndex = usGlyphIndex;

                error = fsg_GridFit (
                    &key->ClientInfo,
                    &key->maxProfile,
                    &key->TransformInfo,
                    pvGlobalGS,
                    &key->pWorkSpaceAddr,
                    pvTwilightZone,
                    (FntTraceFunc)NULL,
                    TRUE,
                    &key->usScanType,
                    &key->bGlyphHasOutline,
                    &key->usNonScaledAW,
                    key->bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
                    ,bSubPixelWidth
#endif // FSCFG_SUBPIXEL
                    );

                if(error)
                {
                    return (FS_ENTRY)error;
                }

                fsg_GetDevAdvanceWidth (
                    &key->pWorkSpaceAddr,
                    &f26DevAdvanceWidth );
#ifdef FSCFG_SUBPIXEL
                if (bSubPixelWidth)
                /* we need to scale the value downs from hinting overscale */
                {
                    ROUND_FROM_HINT_OVERSCALE(f26DevAdvanceWidth.x);
                }
#endif // FSCFG_SUBPIXEL
            }
            psGlyphWidths[(size_t)(usGlyphIndex - usFirstGlyph)] = (int16)((f26DevAdvanceWidth.x + DOT6ONEHALF) >> 6);
        }
    }

    /* Restore current glyph    */

    key->ClientInfo.usGlyphIndex = usCurrentGlyphIndex;
    
    return NO_ERR;
}

/*********************************************************************/

/*                  Vertical Metrics Helper Function                 */

/*            returns AdvanceHeight vectors for glyph range          */

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceHeights (
    fs_GlyphInputType * inputPtr,
    uint16              usFirstGlyph,
    uint16              usLastGlyph,
    shortVector *       psvAdvanceHeights)
{
    fs_SplineKey *      key;
    void *              pvGlobalGS;
    void *              pvFontProgram;
    void *              pvPreProgram;
    void *              pvStack;
    uint16              usGlyphIndex;
    uint16              usPPEm;
    uint16              usNonScaledAH;              /* advance height from vmtx */
    int16               sNonScaledTSB;              /* top side bearing from vmtx, not used */
    shortVector         svDevAdvanceHeight;         /* advance height from sbits */
    vectorType          vecAdvanceHeight;
    vectorType          vecTopSideBearing;          /* not used */
    point               f26DevAdvanceHeight;
    boolean             bBitmapFound;
    ErrorCode           error;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS ), &error);

    if(!key)
    {
        return (FS_ENTRY)error;
    }

    if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
       (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
    {
        fsg_UpdateWorkSpaceAddresses(
            key->memoryBases[WORK_SPACE_BASE],
            &(key->WorkSpaceOffsets),
            &(key->pWorkSpaceAddr));

        pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

        fsg_UpdatePrivateSpaceAddresses(
            &key->ClientInfo,
            &key->maxProfile,
            key->memoryBases[PRIVATE_FONT_SPACE_BASE],
            &(key->PrivateSpaceOffsets),
            pvStack,
            &pvFontProgram,
            &pvPreProgram);

        MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    pvGlobalGS = fsg_QueryGlobalGS(
        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
        &(key->PrivateSpaceOffsets));

    /*  Check input parameters  */

    if( (usLastGlyph > key->maxProfile.numGlyphs ) ||
        (usLastGlyph < usFirstGlyph))
    {
        return INVALID_GLYPH_INDEX;
    }

    if( psvAdvanceHeights == NULL )
    {
        return NULL_INPUT_PTR_ERR;
    }

    /*  Find our current PPEm   */

    fsg_QueryPPEM(pvGlobalGS, &usPPEm);

    /* Handle each glyph    */

    for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
    {
        error = LookForSbitAdvanceHeight (
                key, 
                usGlyphIndex, 
                &bBitmapFound, 
                &f26DevAdvanceHeight);           /* values returned if found */

        if(error)
        {
            return (FS_ENTRY)error;
        }

        if (bBitmapFound)                      /*   if bitmap metrics found */
        {
            svDevAdvanceHeight.x = (int16)((f26DevAdvanceHeight.x + DOT6ONEHALF) >> 6);
            svDevAdvanceHeight.y = (int16)((f26DevAdvanceHeight.y + DOT6ONEHALF) >> 6);
        }
        else        /* if (bBitmapFound == FALSE)   if no bitmap, read vmtx */
        {
            error = sfac_ReadGlyphVertMetrics (
                &key->ClientInfo,
                usGlyphIndex,
                &usNonScaledAH,
                &sNonScaledTSB);

            if(error)
            {
                return (FS_ENTRY)error;
            }

            fsg_ScaleVerticalMetrics (
                &key->TransformInfo,
                pvGlobalGS,
                usNonScaledAH,
                sNonScaledTSB,
                &vecAdvanceHeight,
                &vecTopSideBearing);

            svDevAdvanceHeight.x = (int16)((vecAdvanceHeight.x + ONEHALFFIX) >> 16);
            svDevAdvanceHeight.y = (int16)((vecAdvanceHeight.y + ONEHALFFIX) >> 16);
        }
        
        *psvAdvanceHeights++ = svDevAdvanceHeight;
    }

    return NO_ERR;
}

/*********************************************************************/

/*  Look for an embedded bitmap, if found return the advance width */

FS_PRIVATE FS_ENTRY LookForSbitAdvanceWidth(
    fs_SplineKey *key,
    uint16 usGlyphIndex, 
    boolean *pbBitmapFound, 
    point *pf26DevAdvanceWidth )
{
    uint16      usFoundCode;
    ErrorCode   error;
    uint16      usBitDepth;         /* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    
    *pbBitmapFound = FALSE;                 /* default value */

    error = sbit_SearchForBitmap(
        &key->SbitMono,
        &key->ClientInfo,
        usGlyphIndex, 
        key->usOverScale,
        &usBitDepth,
        &usFoundCode );

    if (error)
    {
        return (FS_ENTRY)error;
    }

    if (usFoundCode != 0)
    {
        error = sbit_GetDevAdvanceWidth (
            &key->SbitMono,
            &key->ClientInfo,
            pf26DevAdvanceWidth );
        
        if (error)
        {
            return (FS_ENTRY)error;
        }
        *pbBitmapFound = TRUE;
    }
    return NO_ERR;
}

/*********************************************************************/

/*  Look for an embedded bitmap, if found return the advance height */

FS_PRIVATE FS_ENTRY LookForSbitAdvanceHeight(
    fs_SplineKey *key,
    uint16 usGlyphIndex, 
    boolean *pbBitmapFound, 
    point *pf26DevAdvanceHeight )
{
    uint16      usFoundCode;
    ErrorCode   error;
    uint16      usBitDepth;         /* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    
    *pbBitmapFound = FALSE;                 /* default value */

    error = sbit_SearchForBitmap(
        &key->SbitMono,
        &key->ClientInfo,
        usGlyphIndex, 
        key->usOverScale,
        &usBitDepth,
        &usFoundCode );

    if (error)
    {
        return (FS_ENTRY)error;
    }

    if (usFoundCode != 0)
    {
        error = sbit_GetDevAdvanceHeight (
            &key->SbitMono,
            &key->ClientInfo,
            pf26DevAdvanceHeight);
        
        if (error)
        {
            return (FS_ENTRY)error;
        }
        *pbBitmapFound = TRUE;
    }
    return NO_ERR;
}


/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*      returns glyph IDs for array or range of character codes      */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetGlyphIDs (
    fs_GlyphInputType * inputPtr,
    uint16              usCharCount,
    uint16              usFirstChar,
    uint16 *            pusCharCode,
    uint16 *            pusGlyphID)
{
    ErrorCode           error;
    fs_SplineKey *      key;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    error = sfac_GetMultiGlyphIDs(
        &key->ClientInfo, 
        usCharCount, 
        usFirstChar, 
        pusCharCode, 
        pusGlyphID);

    if(error)
    {
        return (FS_ENTRY)error;
    }
    return NO_ERR;
}

/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*   specific to Win95 - needs no font context, just a cmap pointer  */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Win95GetGlyphIDs (
    uint8 *             pbyCmapSubTable,
    uint16              usCharCount,
    uint16              usFirstChar,
    uint16 *            pusCharCode,
    uint16 *            pusGlyphID)
{
    ErrorCode           error;

    error = sfac_GetWin95GlyphIDs(
        pbyCmapSubTable, 
        usCharCount, 
        usFirstChar, 
        pusCharCode, 
        pusGlyphID);

    if(error)
    {
        return (FS_ENTRY)error;
    }
    return NO_ERR;
}

/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*   specific to WinNT                                               */

/*********************************************************************/

/* special helper function fs_WinNTGetGlyphIDs
   - an offset ulCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_WinNTGetGlyphIDs (
    fs_GlyphInputType * inputPtr,
    uint16              usCharCount,
    uint16              usFirstChar,
    uint32              ulCharCodeOffset,
    uint32 *            pulCharCode,
    uint32 *            pulGlyphID)
{
    ErrorCode           error;
    fs_SplineKey *      key;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }

    error = sfac_GetWinNTGlyphIDs(
        &key->ClientInfo, 
        usCharCount, 
        usFirstChar, 
        ulCharCodeOffset,
        pulCharCode, 
        pulGlyphID);

    if(error)
    {
        return (FS_ENTRY)error;
    }
    return NO_ERR;
}


/*********************************************************************/

/*                Outline Coordinates Helper Function                */

/* returns (x,y) coordinates of array of points on the glyph outline */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetOutlineCoordinates (
    fs_GlyphInputType * inputPtr,
    uint16              usPointCount,
    uint16 *            pusPointIndex,
    shortVector *       psvCoordinates)
{
    ErrorCode       error;
    ContourList     CList;        /* newscan contour list type */
    fs_SplineKey *  key;

    key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH), &error);
    if(!key)
    {
        return (FS_ENTRY)error;
    }
    if (key->ulState & SIZEKNOWN)               /* fail a call after FindBimapSize */
    {
        return OUT_OFF_SEQUENCE_CALL_ERR;
    }
    
    if (key->bGlyphHasOutline == FALSE)
    {
        return BAD_POINT_INDEX_ERR;             /* no meaning if no outlines */
    }

    if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
    {
          fsg_UpdateWorkSpaceAddresses(
                key->memoryBases[WORK_SPACE_BASE],
                &(key->WorkSpaceOffsets),
                &(key->pWorkSpaceAddr));
        
          fsg_UpdateWorkSpaceElement(
                &(key->WorkSpaceOffsets),
                &(key->pWorkSpaceAddr));
        
          MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
    }

    fsg_GetContourData(
        &key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
        (boolean)(key->flSubPixel & FNT_SP_SUB_PIXEL),            
#endif // FSCFG_SUBPIXEL
        &CList.afxXCoord,
        &CList.afxYCoord,
        &CList.asStartPoint,
        &CList.asEndPoint,
        &CList.abyOnCurve,
        &CList.abyFc,
        &CList.usContourCount);

    error = fsc_GetCoords(&CList, usPointCount, pusPointIndex, (PixCoord *)psvCoordinates);
    if (error != NO_ERR)
    {
        return(error);
    }

    return NO_ERR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fshelper.h ===
/*
	 File:		 helper.h

	 Contains:	 Helper exports for Font Scaler

	 Written by: GregH

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1993. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

		 <1>		 6/11/93	 GregH		Created.
*/

#ifndef FS_MATH_PROTO
#define FS_MATH_PROTO
#endif

int32 FS_MATH_PROTO ShortMulDiv(int32 a, int16 b, int16 c);	 /* (a*b)/c */

Fract FS_MATH_PROTO FracSqrt(Fract);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\interp.h ===
/*
	 File:		 interp.h

	 Contains:	 Exports and constants used by TrueType Interpreter

	 Written by: GregH

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):
*/

#include 	"fnterr.h"

#define NOGRIDFITFLAG   1
#define DEFAULTFLAG     2
#define TUNED4SPFLAG	4

FS_PUBLIC ErrorCode itrp_SetDefaults (
    void *  pvGlobalGS,
    Fixed   fxPixelDiameter);

FS_PUBLIC void  itrp_UpdateGlobalGS(
    void *              pvGlobalGS, /* GlobalGS                             */
    void *              pvCVT,      /* Pointer to control value table       */
    void *              pvStore,    /* Pointer to storage                   */
    void *              pvFuncDef,  /* Pointer to function defintions       */
    void *              pvInstrDef, /* Pointer to instruction definitions   */
    void *              pvStack,    /* Pointer to the stack                 */
	 LocalMaxProfile *	maxp,
    uint16              cvtCount,
    uint32              ulLengthFontProgram, /* Length of font program      */
    void *              pvFontProgram, /* Pointer to font program           */
    uint32              ulLengthPreProgram, /* Length of pre program        */
    void *              pvPreProgram, /* Pointer to pre program             */
	ClientIDType        clientID);    /* User ID Number                     */

#ifdef FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC void itrp_InitializeData (void);
#endif

FS_PUBLIC ErrorCode   itrp_ExecuteFontPgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc);

FS_PUBLIC ErrorCode   itrp_ExecutePrePgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc);

FS_PUBLIC ErrorCode   itrp_ExecuteGlyphPgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    uint8 *             ptr,
    uint8 *             eptr,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc,
    uint16 *            pusScanType,
    uint16 *            pusScanControl,
    boolean *           pbChangeScanControl);

FS_PUBLIC boolean itrp_bApplyHints(
    void *      pvGlobalGS);

FS_PUBLIC void  itrp_QueryScanInfo(
    void *      pvGlobalGS,
    uint16 *    pusScanType,
    uint16 *    pusScanControl);

FS_PUBLIC void	itrp_SetCompositeFlag(
	void *      pvGlobalGS,
	uint8		bCompositeFlag);

FS_PUBLIC void	itrp_SetSameTransformFlag(
	void *      pvGlobalGS,
	boolean		bSameTransformAsMaster);

FS_PUBLIC void itrp_Normalize (F26Dot6 x, F26Dot6 y, VECTOR *pVec);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fscaler.h ===
#ifdef __cplusplus
extern "C" {
#endif

/*
	File:       fscaler.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		  <>    10/14/97    CB      move usOverScale to fs_NewTransformation
		<9+>     7/17/90    MR      Conditionalize names in FSInput
		 <9>     7/14/90    MR      rename SQRT2 to FIXEDSQRT2, removed specificID and lowestRecPPEM
									from FSInfo
		 <8>     7/13/90    MR      FSInput now has a union to save space, points to matrix instead
									of storing it
		 <6>     6/21/90    MR      Change fillFunc to ReleaseSfntFrag
		 <5>      6/5/90    MR      remove readmvt and mapcharcodes
		 <4>      5/3/90    RB      Added memory area for new scan converter. MIKE REED - Removed
									.error from fsinfo structure. Added MapCharCodes and ReadMVT
									calls.
		 <3>     3/20/90    CL      New comment style for BBS. 
		 <2>     2/27/90    CL      New CharToIndexMap Table format.
	   <3.5>    11/15/89    CEL     Placed an ifdef around inline MPW calls to the trap. This makes
									it easier to compile for skia and the likes who do not use the
									MPW compiler.
	   <3.4>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. Five
									unnecessary element in the output data structure have been
									deleted. (All the information is passed out in the bitmap data
									structure) fs_FindBMSize now also returns the bounding box.
	   <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
	   <3.2>     9/25/89    CEL     Took out Mac specific functions.
	   <3.1>     9/15/89    CEL     Re-working dispatcher.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/

#include    "fscdefs.h"
#include    "fnt.h"

/* QuickDraw Types */

#ifndef _Quickdraw_
#ifndef __QUICKDRAW__   
	typedef struct BitMap {
		char* baseAddr;
		int16 rowBytes;
		Rect bounds;
	} BitMap;
#endif
#endif

#define MEMORYFRAGMENTS 9           /* extra memory base for overscaled bitmap */

#define NONVALID        0xffff

/* For the flags field in the flags field */

/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_SHORT_IS_OK 0x0001          /* set when calling fs_OpenFonts() */
/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_LONG_IS_OK  0x0002          /* set when calling fs_OpenFonts() */

#ifdef FSCFG_SUBPIXEL
/* For the SubPixel flag field */
#define SP_SUB_PIXEL			0x0001          /* set when calling fs_NewTransformation() */
#define SP_COMPATIBLE_WIDTH		0x0002          /* set when calling fs_NewTransformation() */
#define SP_VERTICAL_DIRECTION	0x0004          /* set when calling fs_NewTransformation() */
#define SP_BGR_ORDER			0x0008          /* set when calling fs_NewTransformation() */
#endif // FSCFG_SUBPIXEL

typedef struct {
	vectorType      advanceWidth, leftSideBearing;
	vectorType      leftSideBearingLine, devLeftSideBearingLine;/* along AW line */
	vectorType      devAdvanceWidth, devLeftSideBearing;
} metricsType;

typedef struct {
	vectorType      advanceHeight, topSideBearing;
	vectorType      topSideBearingLine, devTopSideBearingLine;/* along AH line */
	vectorType      devAdvanceHeight, devTopSideBearing;
} verticalMetricsType;

#define FS_MEMORY_SIZE  int32

/*
 * Output data structure to the Font Scaler.
 */
typedef struct {
	FS_MEMORY_SIZE  memorySizes[MEMORYFRAGMENTS];

	uint16          glyphIndex;
	uint16          numberOfBytesTaken; /* from the character code */

	metricsType     metricInfo;
	BitMap          bitMapInfo;

	/* Spline Data */
	int32           outlineCacheSize;
	uint16          outlinesExist;
	uint16          numberOfContours;
	F26Dot6         *xPtr, *yPtr;
	int16           *startPtr;
	int16           *endPtr;
	uint8           *onCurve;
	/* End of spline data */

	/* Only of interest to editors */
	F26Dot6         *scaledCVT;

	/* embedded bitmap return values */
	uint16          usBitmapFound;

	/* vertical metrics */
	verticalMetricsType     verticalMetricInfo;

	/* resulting number of gray levels, 0 means black/white, 1 bit per pixel,
	   (grayscale bitmap are 1 byte per pixel)
	   the number of level you receive is not necessarily what you ask for.
	   If there is no embedded gray bitmap :
			usOverscale 2 -> usGrayLevels 5,
			usOverscale 4 -> usGrayLevels 17,
			usOverscale 8 -> usGrayLevels 65,
	   If an embedded gray bitmap is present in the font, the embedded bitmap
	   will be selected before a gray bitmap generated with an higher overscale.
	   If you are unhappy with the number of gray levels (usGrayLevels) you can force
	   the embedded bitmap off by setting bNoEmbeddedBitmap to TRUE  */
	uint16          usGrayLevels;            
#ifdef FSCFG_SUBPIXEL_STANDALONE // B.St.
	BitMap			overscaledBitmapInfo;
#endif
	uint8			*fc;         /* contour flags, one byte for every contour */
} fs_GlyphInfoType;

/*
 * Input data structure to the Font Scaler.
 *
 * styleFunc is not supported in this version of the Font Scalar. Should be set to NULL.
 *
 */

#ifndef UNNAMED_UNION

typedef struct {
	Fixed                   version;
	char*                   memoryBases[MEMORYFRAGMENTS];
	int32                   *sfntDirectory; 
	GetSFNTFunc             GetSfntFragmentPtr; /* (clientID, offset, length) */
	ReleaseSFNTFunc         ReleaseSfntFrag;
	ClientIDType            clientID; /* client private id/stamp (eg. handle for the sfnt) */

	union {
		struct {
			uint16          platformID;
			uint16          specificID;
		} newsfnt;
		struct {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			Fixed           pixelDiameter;      /* compute engine char from this */
			transMatrix*    transformMatrix;
			FntTraceFunc    traceFunc;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		} newtrans;
		struct {
			uint16          characterCode;
			uint16          glyphIndex;
			boolean         bMatchBBox;             /* force bounding box match */
			boolean         bNoEmbeddedBitmap;      /* disable the embedded bitmap */			
		} newglyph;
		struct {
			void            (*styleFunc) (fs_GlyphInfoType*);
			FntTraceFunc    traceFunc;
			boolean         bSkipIfBitmap;
		} gridfit;
		int32*  outlineCache;
		struct {                                    /* for fs_FindBandingSize */
			uint16          usBandType;             /* old, small or fast */
			uint16          usBandWidth;            /* number of scanlines */
			int32*          outlineCache;           /* cacheing works with banding */
		} band;
		struct {
			int16           bottomClip;
			int16           topClip;
			int32*          outlineCache;
		} scan;
	} param;
} fs_GlyphInputType;

#else

typedef struct {
	Fixed                   version;
	char*                   memoryBases[MEMORYFRAGMENTS];
	int32                   *sfntDirectory; 
	GetSFNTFunc             GetSfntFragmentPtr; /* (clientID, offset, length) */
	ReleaseSFNTFunc         ReleaseSfntFrag;
	ClientIDType            clientID; /* client private id/stamp (eg. handle for the sfnt) */

	union {
		struct {
			uint16          platformID;
			uint16          specificID;
		};
		struct {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			Fixed           pixelDiameter;      /* compute engine char from this */
			transMatrix*    transformMatrix;
			FntTraceFunc    tracePreProgramFunc;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		};
		struct {
			uint16          characterCode;
			uint16          glyphIndex;
			boolean         bMatchBBox;             /* force bounding box match */
			boolean         bNoEmbeddedBitmap;      /* disable the embedded bitmap */			
		};
		struct {
			void            (*styleFunc) (fs_GlyphInfoType*);
			FntTraceFunc    traceGridFitFunc;
			boolean         bSkipIfBitmap;
		};
		int32*              outlineCache1;
		struct {                                    /* for fs_FindBandingSize */
			uint16          usBandType;             /* old, small or fast */
			uint16          usBandWidth;            /* number of scanlines */
			int32*          outlineCache3;          /* cacheing works with banding */
		};
		struct {
			int16           bottomClip;
			int16           topClip;
			int32*          outlineCache2;
		};
	};
} fs_GlyphInputType;

#endif      /* unnamed union */

#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

/* Font scaler trap selctors */
#define OUTLINEFONTTRAP     0xA854
#define FS_OPENFONTS        0x8000
#define FS_INITIALIZE       0x8001
#define FS_NEWSFNT          0x8002
#define FS_NEWTRANS         0x8003
#define FS_NEWGLYPH         0x8004
#define FS_GETAW            0x8005
#define FS_GRIDFITT         0x8006
#define FS_NOGRIDFITT       0x8007
#define FS_FINDBMSIZE       0x8008
#define FS_SIZEOFOUTLINES   0x8009
#define FS_SAVEOUTLINES     0x800a
#define FS_RESTOREOUTLINES  0x800b
#define FS_CONTOURSCAN      0x800c
#define FS_CLOSE            0x800d
#define FS_READMVT          0x800e
#define FS_MAPCHAR_CODES    0x800f

#ifndef FS_ENTRY
#define FS_ENTRY int32
#endif

#ifdef MACINIT
extern FS_ENTRY fs__OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_OPENFONTS,0xA854};
extern FS_ENTRY fs__Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_INITIALIZE,0xA854};
extern FS_ENTRY fs__NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWSFNT,0xA854};
extern FS_ENTRY fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWTRANS,0xA854};
extern FS_ENTRY fs__NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWGLYPH,0xA854};
extern FS_ENTRY fs__GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_GETAW,0xA854};
extern FS_ENTRY fs__ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_GRIDFITT,0xA854};
extern FS_ENTRY fs__ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NOGRIDFITT,0xA854};
extern FS_ENTRY fs__FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_FINDBMSIZE,0xA854};
extern FS_ENTRY fs__FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_FINDBMSIZE,0xA854};

/* these three optional calls are for caching the outlines */
extern FS_ENTRY fs__SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_SIZEOFOUTLINES,0xA854};
extern FS_ENTRY fs__SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_SAVEOUTLINES,0xA854};
extern FS_ENTRY fs__RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_RESTOREOUTLINES,0xA854};

extern FS_ENTRY fs__ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_CONTOURSCAN,0xA854};
extern FS_ENTRY fs__CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_CLOSE,0xA854};

#else

/*** Direct Calls to Font Scaler Client Interface, for Clients not using the trap mechanism ***/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

/* these three optional calls are for caching the outlines */
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

#endif

#ifdef FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC void FS_ENTRY_PROTO fs_InitializeData (void);
#endif

/*** Rasterizer Helper Functions ***/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceWidths (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	int16 *             psGlyphWidths);

typedef struct {
	int16 x;
	int16 y;
} shortVector;

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceHeights (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	shortVector *       psvAdvanceHeights);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Win95GetGlyphIDs (
	uint8 *             pbyCmapSubTable,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID);


/* special helper function fs_WinNTGetGlyphIDs
   - an offset ulCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_WinNTGetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint32	            ulCharCodeOffset,
	uint32 *	        pulCharCode,
	uint32 *	        pulGlyphID);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetOutlineCoordinates (
	fs_GlyphInputType * inputPtr,
	uint16              usPointCount,
	uint16 *            pusPointIndex,
	shortVector *       psvCoordinates);

/*** Gray scale definitions ***/

#ifndef FSCFG_DISABLE_GRAYSCALE

#define FS_GRAY_VALUE_MASK  0x008B      /* support usOverScale of 1, 2, 4, & 8 */
#define FS_SBIT_BITDEPTH_MASK	0x0116	 /* support sbit with bitDepth of 1, 2, 4 and 8 */
/* FS_SBIT_BITDEPTH_MASK must have the same value as SBIT_BITDEPTH_MASK in sfntaccs.h */ 

#else

#define FS_GRAY_VALUE_MASK  0x0000      /* no grayscale support */
#define FS_SBIT_BITDEPTH_MASK	0x0002	 /* support only sbit with bitDepth of 1 */
/* FS_SBIT_BITDEPTH_MASK must have the same value as SBIT_BITDEPTH_MASK in sfntaccs.h */ 

#endif
/* the value of FS_GRAY_VALUE_MASK and FS_SBIT_BITDEPTH_MASK can be used to determine
   the usGrayLevels the client need to support.

   Fonts without embedded bitmap :
		usGrayLevels = usOverScale * usOverScale + 1;

   Fonts with embedded bitmap (sbit) :
		usGrayLevels = 0x01 << usBitDepth;

  The usGrayLevels the client may receive with the current version are :

  0 for black/white
  5, 17, 65 fonts without embedded bitmap
  4, 16, 256 fonts with embedded bitmap

*/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceHeight (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

#ifdef FSCFG_MOVE_KEY_IN_DOT_H
/* the definition of the key in fscaler.h and fscaler.c must be identical */

/*** The Internal Key ***/
typedef struct fs_SplineKey {
	sfac_ClientRec      ClientInfo;         /* Client Information */
	char* const *       memoryBases;        /* array of memory Areas */
	char *              apbPrevMemoryBases[MEMORYFRAGMENTS];

	uint16              usScanType;         /* flags for dropout control etc.*/

	fsg_TransformRec    TransformInfo;

	uint16              usNonScaledAW;
	uint16              usNonScaledAH;

	LocalMaxProfile     maxProfile;         /* copy of profile */

	uint32              ulState;            /* for error checking purposes */
	
	boolean             bExecutePrePgm;
	boolean             bExecuteFontPgm;    /* <4> */

	fsg_WorkSpaceAddr   pWorkSpaceAddr;     /* Hard addresses in Work Space */
	fsg_WorkSpaceOffsets WorkSpaceOffsets;  /* Address offsets in Work Space     */
	fsg_PrivateSpaceOffsets PrivateSpaceOffsets; /* Address offsets in Private Space */

	uint16              usBandType;         /* old, small or fast */
	uint16              usBandWidth;        /* from FindBandingSize */

	GlyphBitMap         GBMap;              /* newscan bitmap type */
	WorkScan            WScan;              /* newscan workspace type */

	GlyphBitMap         OverGBMap;          /* for gray scale */
	uint16              usOverScale;        /* 0 => mono; mag factor => gray */
	boolean             bGrayScale;			/* FALSE if mono (usOverScale == 0)	*/
	boolean             bMatchBBox;         /* force bounding box match */
	boolean             bEmbeddedBitmap;    /* embedded bitmap found */			

	metricsType         metricInfo;         /* Glyph metrics info */
	verticalMetricsType     verticalMetricInfo;

	int32               lExtraWorkSpace;    /* Amount of extra space in workspace */

	boolean             bOutlineIsCached;   /* Outline is cached */
	boolean             bGlyphHasOutline;   /* Outline is empty */
	boolean             bGridFitSkipped;    /* sbit anticipated, no outline loaded */

	uint32              ulGlyphOutlineSize; /* Size of outline cache */
	
	sbit_State          SbitMono;           /* for monochrome bitmaps */
	boolean             bHintingEnabled;    /* hinting is enabled, set to FALSE when 
                                               fs_NewTransformNoGridFit is called */
	boolean             bBitmapEmboldening; /* bitmap emboldening simulation */
	int16               sBoldSimulHorShift; /* shift for emboldening simulation, horizonatlly */
	int16               sBoldSimulVertShift; /* shift for emboldening simulation, vertically */
#ifdef FSCFG_SUBPIXEL
	uint16				flSubPixel;
	fsg_TransformRec    TransformInfoSubPixel;
#endif // FSCFG_SUBPIXEL
} fs_SplineKey;

#endif // FSCFG_MOVE_KEY_IN_DOT_H

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\sbit.h ===
/*********************************************************************

      sbit.h -- Embedded Bitmap Module Export Definitions

      (c) Copyright 1993-1996  Microsoft Corp.  All rights reserved.

      01/12/96  claudebe    Vertical metrics support
      02/07/95  deanb       Workspace pointers for GetMetrics & GetBitmap
      01/27/95  deanb       usShaveLeft & usShaveRight added to sbit state
      01/05/94  deanb       Bitmap scaling state
      11/29/93  deanb       First cut 
 
**********************************************************************/

/*      SBIT Module State Definition    */

typedef struct
{
    uint32  ulStrikeOffset;         /* into bloc or bsca */
    uint32  ulMetricsOffset;        /* may be either table */
    uint32  ulBitmapOffset;         /* into bdat table */
    uint32  ulBitmapLength;         /* bytes of bdat data */
    uint32  ulOutMemSize;           /* bytes of bitmap output data */
    uint32  ulWorkMemSize;          /* bytes of pre-scaled,rotated bitmap data */
    uint32  ulReadMemSize;          /* bytes of extra memory, to read gray sbit under scaling or rotation */
    uint16  usTableState;           /* unsearched, bloc, bsca, or not found */
    uint16  usPpemX;                /* x pixels per Em */
    uint16  usPpemY;                /* y pixels per Em */
    uint16  usSubPpemX;             /* substitute x ppem for bitmap scaling */
    uint16  usSubPpemY;             /* substitute y ppem for bitmap scaling */
	uint16	usRotation;				/* 0=none; 1=90; 2=180; 3=270; 4=other */
    uint16  usMetricsType;          /* horiz, vert, or big */
    uint16  usMetricsTable;         /* bloc or bdat */
    uint16  usBitmapFormat;         /* bdat definitions */
    uint16  usHeight;               /* bitmap rows */
    uint16  usWidth;                /* bitmap columns */
    uint16  usAdvanceWidth;         /* advance width */
    uint16  usAdvanceHeight;        /* advance height */     /* NEW */
    uint16  usOriginalRowBytes;     /* bytes per row (padded long) */
    uint16  usExpandedRowBytes;     /* bytes per row after grayscale expansion (padded long) */
    uint16  usScaledHeight;         /* scaled bitmap rows */
    uint16  usScaledWidth;          /* scaled bitmap columns */
    uint16  usScaledRowBytes;       /* scaled bytes per row (padded long) */
    uint16  usOutRowBytes;          /* reported bytes per row (for rotation) */
    uint16  usShaveLeft;            /* white pixels on left of bbox in format 5 */
    uint16  usShaveRight;           /* white pixels on right of bbox in format 5 */
    uint16  usShaveTop;             /* white pixels on top of bbox in format 5 */   /* NEW */
    uint16  usShaveBottom;          /* white pixels on bottom of bbox in format 5 */  /* NEW */
	int16   sLSBearingX;            /* left side bearing */
	int16   sLSBearingY;            /* y coord of top left corner */ 
	int16   sTopSBearingX;          /* top side bearing X */ /* NEW */
	int16   sTopSBearingY;          /* top side bearing Y */ /* NEW */
    boolean bGlyphFound;            /* TRUE if glyph found in strike */
    boolean bMetricsValid;          /* TRUE when metrics have been read */
	uint16  usEmResolution;			/* needed when substituting missing metrics */ /* NEW */
	uint16	usBitDepth;				/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16	uBoldSimulHorShift;
	uint16	uBoldSimulVertShift;
} 
sbit_State;

/**********************************************************************/

/*      SBIT Export Prototypes      */

FS_PUBLIC ErrorCode sbit_NewTransform(
    sbit_State  *pSbit,
    uint16		usEmResolution,
    int16 	sBoldSimulHorShift,
    int16 	sBoldSimulVertShift,
    uint16          usPpemX,
    uint16          usPpemY,
    uint16          usRotation             /* 0 - 3 => 90 deg rotation, else not 90 */
);

FS_PUBLIC ErrorCode sbit_SearchForBitmap(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	uint16			usGlyphCode,
	uint16          usOverScale,            /* outline magnification requested */
	uint16			*pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16          *pusFoundCode           /* 0 = not found, 1 = bloc, 2 = bsca */
);

FS_PUBLIC ErrorCode sbit_GetDevAdvanceWidth (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW 
);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC ErrorCode  sbit_CalcDevHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	F26Dot6 *       pDevAdvanceWidthX,
	F26Dot6 *       pDevLeftSideBearingX,
	F26Dot6 *       pDevRightSideBearingX);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC ErrorCode sbit_GetDevAdvanceHeight (	/* NEW */
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvH 
);

FS_PUBLIC ErrorCode sbit_GetMetrics (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvanceWidth,
    point           *pf26DevLeftSideBearing,
    point           *pf26LSB,
    point           *pf26DevAdvanceHeight, 	/* NEW */
    point           *pf26DevTopSideBearing,	/* NEW */
    point           *pf26TopSB,	/* NEW */
    Rect            *pRect,
    uint16          *pusRowBytes,
    uint32          *pulOutSize,
    uint32          *pulWorkSize
);

FS_PUBLIC ErrorCode sbit_GetBitmap (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint8           *pbyOut,
    uint8           *pbyWork
);


/**********************************************************************/

FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift);

FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 suBoldSimulHorShift, int16 sBoldSimulVertShift);
#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fsconfig.h ===
/*
	File:       fsconfig.h : (Portable "Standard C" version)

	Written by: Lenox Brassell

	Contains:   #define directives for FontScaler build options

   Copyright:  c 1989-1993 by Microsoft Corp., all rights reserved.

	Change History (most recent first):
		<3>      4/21/93 GregH Documented file
		<2>      7/16/92    DJ      Added fnt_Report_Error() declaration.
		<1>      8/27/91    LB      Created file.

	Usage:  This file is "#include"-ed as the first statement in
			"fscdefs.h".  This file contains platform-specific
			override definitions for the following #define-ed data
		types and macros, which have default definitions in
		"fscdefs.h":

	Purpose:

		This file gives the integrator a place to override the
		default definitions of these items, as well as a place
		to define other configuration-specific macros.

	Definitions:

		The following type definitations can be changed. The defaults have been
		set up for a 32-bit system. Caveat emptor: any change to the defaults may
		severly effect performace or place severe limitations on the capabilities
		of the TrueType rasterizer.

				F26Dot6
					 This is currently defined as a fixed point 26.6 number.
					 If changed to short, it is a 10.6 number.

		The following definition changes the return type for all Font Scalar
		Client Interface calls.

				FS_ENTRY

		The following definition changes the calling convention for all Font
		Scalar Client Interface calls.  By default, the rasterizer uses register
		calling conventions because of the performance gains.

				FS_ENTRY_PROTO

		The following definitions are used for all private and public entry points
		in the TrueType Rasterizer. By default FS_PRIVATE is set to static, but
		for some uses, like profiling and debugging this is undesirable, and
		FS_PRIVATE can be set to null. FS_PUBLIC defaults to null.

				FS_PRIVATE
				FS_PUBLIC

		The following definitions are used for calling conventions to external
		math routines. The Macintosh has external math routines that use pascal
		calling conventions. To enable these, the FS_MAC_PASCAL must be set to
		"pascal". Similary the FS_PC_PASCAL variable needs to be set to "pascal"
		when calling external routines using pascal calling conventions.

				FS_MAC_PASCAL
				FS_PC_PASCAL

		This definition is used for calling Macintosh ToolBox routines. If the
		rasterizer is implemented on a non-Macintosh platform, this Macro should
		be null.

				FS_MAC_TRAP

		These macros are used to override the C memcpy and memset routines

				MEMCPY
				MEMSET

		These math routines can be hooked out by system routines.

				SHORTDIV
				SHORTMUL

		These macros are used to convert big-endian to little-endian. When
		running on a big-endian platform these macros are not necessary.

				SWAPL
				SWAPW
				SWAPWINC

		These macros are used to replace some math routines by faster assembly
		language routines. The notation used for the assembly language routines
		should indicate the processor targeted. For example:

				#define CompMul   CompMul386
				#define CompDiv   CompDiv386
				#define FracSqrt      FracSqrt386

	The following definitions change the way the TrueType rasterizer works on
	specific implementations. These definitions are usually switches that are
	defined or not defined.

		FSCFG_DEBUG

		This is used to create a debugging version of the rasterizer. This
		version does additional error checking and creates a debugger trap
		when the TrueType DEBUG instruction is called.

		FSCFG_FNTERR

		This is used to create a error checking version of the rasterizer. With
		this set, parameters passed to TrueType instructions are range checked.
		If any instructions fails a test, a error message is returned.

		FSCFG_MOVEABLE_MEMBASE

		This is used to implement moveable memory bases. If it is possible that
		the address of a memory base could change between a Font Scaler Client
		Interface call, then this flag should be set in the rasterizer.

		FSCFG_MICROSOFT_KK

		This flag is used to implement the Microsoft KK version of the TrueType
		rasterizer. The effect of this flag is to use a slightly different
		algorithm for parsing the Format 2 cmap table.

		FSCFG_BIG_ENDIAN

		This flag indicates the target platform of the rasterizer uses big-endian
		representation of multiple-byte integers. If this flag is not set, SWAP
		macros are used to convert all multiple-byte integers read from TrueType
		Font Files.

		FSCFG_REENTRANT

		This flag indicates that the TrueType rasterizer should be reentrant.
		This allows multiple treads of execution through the executable and gives
		better system through put on multi-threaded/process environments. Slight
		performance gains are possible when not setting this flag in single tasking
		environments.

		FSCFG_NO_INITIALIZED_DATA

		This flag should be set for platforms that do not support static
		initialization of data. With this flag, a new Font Scalar Client Interface
		call fs_InitializeData needs to be made.

		FSCFG_USESTATCARD

		This flag is set to turn on stat card timing services in the rasterizer.
		This can be used to collect timing information for profiling.
		
		FSCFG_USE_MASK_SHIFT

		This flag is set to enable bitmask generated by shifting rather than by
		table lookup.  Shifted bitmasks use less memory and MAY be faster than
		table bitmasks.  On Big-Endian platforms shifted bitmasks will produce
		bitmaps that are identical to Apple's definition (same byte order).
		Table bitmaps will be identical for all platforms.

		FSCFG_DISABLE_GRAYSCALE

		This flag is set to disable all grayscale functions and save a little
		code space along the way. If defined, all grayscale functions return
		a BAD_GRAY_LEVEL_ERR error code.

		FSCFG_FONTOGRAPHER_BUG

		Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
		have the critical error : Inst: RCVT CVT Out of range. CVT = 255
		This flag is meant to be set under Windows. If will cause additional
		memory to be allocated for the CVT if necessary in order to be sure
		that this illegal read will access memory within the legal range.
		Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
		and CVT > NumCvt to be classified as error instead of critical error

		FSCFG_EUDC_EDITOR_BUG

		The EUDC editor under NT 4.0 has a bug and create bogous fonts.
        	The EUDC editor set maxp->maxStackElements to 0 and use 1 stack element
        	in the pre/font program. If this flag is defined, we will ensure that
        	at least one StackElement is reserved to avoid memory corruption.

       		FSCFG_CONVERT_GRAY_LEVELS

        	with grayscale embedded bitmap, the number of gray levels can be different than expected
        	4, 16, 256 instead of 5, 17, 65. If FSCFG_CONVERT_GRAY_LEVELS is defined, a conversion will be done
        	in the rasterizer to the expected number of gray levels

       FSCFG_SUBPIXEL

        will activate the SubPixel code

		FSCFG_SUBPIXEL_STANDALONE

		will activate a special variant of the SubPixel code for the stand-alone rasterizer
		
        	FSCFG_SECURE

        	Enable critical error checking in the TrueType rasterizer.

		MAC_INIT

		This flag indicates that the TrueType rasterizer will be implemented as
		a Macintosh Init.

		UNNAMED_UNION

		This flag is set for compilers that implement unnamed unions

                ClientIDType

                This definition allow the change the type definition for ClientID. If you are using ClientID to pass a pointer
                and compiling the TrueType rasterizer for a platform where pointer are bigger than 32 bits, 
                you need to change this definition.
*/

/* #define FSCFG_MICROSOFT_KK   */
/* #define FSCFG_USESTATCARD      */
/* #define FSCFG_NO_INITIALIZED_DATA */
/* #define FSCFG_FNTERR           */
/* #define FSCFG_DEBUG            */
/* #define FSCFG_MOVABLE_MEM_BASE */
/* #define FSCFG_BIG_ENDIAN   */
/* #define FSCFG_REENTRANT    */
/* #define FSCFG_NO_INITIALIZED_DATA */
/* #define FSCFG_USE_MASK_SHIFT */
/* #define FSCFG_DISABLE_GRAYSCALE */

#define FSCFG_FONTOGRAPHER_BUG

#define FSCFG_EUDC_EDITOR_BUG

#define FSCFG_SECURE

#define FSCFG_CONVERT_GRAY_LEVELS

#define FSCFG_SUBPIXEL


/* Windows NT, is moving the definition of the internal rasterizer key in fscaler.h for optimization purpose */
#define FSCFG_MOVE_KEY_IN_DOT_H

/* !!! This should be removed */
#define NOT_ON_THE_MAC

/* Assembly Optimization Switches */

/* #define CompMul      CompMul386  */
/* #define CompDiv      CompDiv386  */
/* #define FracSqrt     FracSqrt386 */

// use RtlRoutines for memory operations

// in all uses in the rasterizer MEMSET  is used to zero out the mem

// to get the prototype for RtlZeroMemory and RtlCopyMemory :

#ifdef FSCFG_INTERNAL
#include "nt.h"
#include "ntrtl.h"

#if DBG
/* to activate rasterizer assertions : */
VOID __cdecl TtfdDbgPrint(PCHAR DebugMessage,...);

#define FS_ASSERT(expression, message) { if (!(expression)) { TtfdDbgPrint(message); DbgBreakPoint();} }
#define Assert(expression) { if (!(expression)) { TtfdDbgPrint("FONT: TrueType rasterizer internal assert"); DbgBreakPoint();} }
#endif // DBG

#endif

#define MEMSET(dst, value, size) RtlZeroMemory(dst, size)
#define MEMCPY(dst, src, size)   RtlCopyMemory(dst, src, size)


// easier to debug with no static functions [BODIND]

#define FS_PRIVATE

// interface to the outside world [bodind]

#define FS_ENTRY_PROTO           __cdecl
#define FS_CALLBACK_PROTO	 __cdecl

// client ID is commonly used to pass a pointer to a structure, for backwards compatibility it
// need to be at least a 32 bits value, to get ready for the 64 bits platform, we define it as ULONG_PTR

#define ClientIDType ULONG_PTR

// only do stamp checking in the debug version

// #if DBG
// #define DEBUGSTAMP
// #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fsglue.h ===
/*
	File:       fsglue.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1996. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

	      <>    12/15/95    CB      add fsg_UpdateAdvanceHeight
	   <11+>     7/17/90    MR      Change error return type to int
		<11>     7/13/90    MR      Declared function pointer prototypes, Debug fields for runtime
									range checking
		 <8>     6/21/90    MR      Add field for ReleaseSfntFrag
		 <7>      6/5/90    MR      remove vectorMappingF
		 <6>      6/4/90    MR      Remove MVT
		 <5>      6/1/90    MR      Thus endeth the too-brief life of the MVT...
		 <4>      5/3/90    RB      adding support for new scan converter and decryption.
		 <3>     3/20/90    CL      Added function pointer for vector mapping
									Removed devRes field
									Added fpem field
		 <2>     2/27/90    CL      Change: The scaler handles both the old and new format
									simultaneously! It reconfigures itself during runtime !  Changed
									transformed width calculation.  Fixed transformed component bug.
	   <3.1>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Now it is legal to pass in zero as the address of
									memory when a piece of the sfnt is requested by the scaler. If
									this happens the scaler will simply exit with an error code !
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/*      <3+>     3/20/90    mrr     Added flag executeFontPgm, set in fs_NewSFNT
*/


/*** Offset table ***/

typedef struct {
	uint32 x;
	uint32 y;
	uint32 ox;
	uint32 oy;
	uint32 oox;
	uint32 ooy;
	uint32 onCurve;
	uint32 sp;
	uint32 ep;
	uint32 f;
	uint32 fc;        
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	uint32 pcr;
#endif
} fsg_OutlineFieldInfo;

typedef struct fsg_WorkSpaceAddr{
	 F26Dot6 *              pStack;                     /* Address of stack                  */
	 void *                 pGlyphOutlineBase;      /* Address of Glyph Outline Base     */
	 fnt_ElementType *  pGlyphElement;          /* Address of Glyph Element array    */
	 boolean *              pGlyphDataByteSet;      /* Address of ByteSet array          */
	 void *                 pvGlyphData;                /* Address of GlyphData array        */
	 void *                 pReusableMemoryMarker;  /* Address of reusable memory        */
} fsg_WorkSpaceAddr;

typedef struct fsg_WorkSpaceOffsets {
	uint32                  ulStackOffset;
	uint32                  ulGlyphOutlineOffset;
	uint32                  ulGlyphElementOffset;
	uint32                  ulGlyphDataByteSetOffset;
	uint32                  ulGlyphDataOffset;
	fsg_OutlineFieldInfo    GlyphOutlineFieldOffsets;
	 uint32                      ulReusableMemoryOffset;
	uint32                  ulMemoryBase6Offset;
	uint32                  ulMemoryBase7Offset;
	 uint32                      ulMemoryBase6Size;
	 uint32                      ulMemoryBase7Size;
} fsg_WorkSpaceOffsets;

typedef struct fsg_PrivateSpaceOffsets {
	 uint32                      offset_storage;
	 uint32                      offset_functions;
	 uint32                      offset_instrDefs;       /* <4> */
	 uint32                      offset_controlValues;
	 uint32                      offset_globalGS;
	 uint32                      offset_FontProgram;
	 uint32                      offset_PreProgram;
	 uint32                      offset_TwilightZone;
	 uint32                      offset_TwilightOutline;
	fsg_OutlineFieldInfo    TwilightOutlineFieldOffsets;
#ifdef FSCFG_SUBPIXEL
	 uint32                      offset_storageSubPixel;
	 uint32                      offset_functionsSubPixel;
	 uint32                      offset_instrDefsSubPixel;       /* <4> */
	 uint32                      offset_controlValuesSubPixel;
	 uint32                      offset_globalGSSubPixel;
	 uint32                      offset_TwilightZoneSubPixel;
	 uint32                      offset_TwilightOutlineSubPixel;
#endif // FSCFG_SUBPIXEL
} fsg_PrivateSpaceOffsets;

typedef struct fsg_TransformRec {
	uint16              usEmResolution;     /* used to be int32 <4> */
	transMatrix         currentTMatrix;     /* Current Transform Matrix */
	boolean             bPhaseShift;        /* 45 degrees flag <4> */
	boolean             bPositiveSquare;    /* Transform is a positive square */
	boolean             bIntegerScaling;    /* Font uses integer scaling */
	Fixed               fxPixelDiameter;
	uint32              ulImageState;       /* is glyph rotated, stretched, etc. */
	boolean				bEmboldSimulation; 
	uint16	uBoldSimulHorShift;
} fsg_TransformRec;

/**********************/
/** MODULE INTERFACE **/
/**********************/

/*      Memory Management Routines  */

FS_PUBLIC uint32  fsg_PrivateFontSpaceSize (
	sfac_ClientRec *            ClientInfo,
	 LocalMaxProfile *            pMaxProfile,    /* Max Profile Table    */
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets);

FS_PUBLIC uint32    fsg_WorkSpaceSetOffsets (
	 LocalMaxProfile *       pMaxProfile,    /* Max Profile Table    */
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plExtraWorkSpace);

FS_PUBLIC void  fsg_UpdatePrivateSpaceAddresses(
	sfac_ClientRec *        ClientInfo,      /* Cached sfnt information */
	 LocalMaxProfile *       pMaxProfile,    /* Max Profile Table         */
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets,
	void *                  pvStack,        /* pointer to stack         */
	void **                 pvFontProgram,  /* pointer to font program  */
	void **                 pvPreProgram);  /* pointer to pre program   */

FS_PUBLIC void  fsg_UpdateWorkSpaceAddresses(
	char *                  pWorkSpace,
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	 fsg_WorkSpaceAddr *     pWorkSpaceAddr);

FS_PUBLIC void  fsg_UpdateWorkSpaceElement(
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	 fsg_WorkSpaceAddr *     pWorkSpaceAddr);

FS_PUBLIC void *    fsg_QueryGlobalGS(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *    fsg_QueryGlobalGSSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryTwilightElement(
	char *                  pPrivateFontSpace,
	 fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *      fsg_QueryTwilightElementSubPixel(
	char *                  pPrivateFontSpace,
	 fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryStack(fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void *      fsg_QueryReusableMemory(
	char *                  pWorkSpace,
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets);

FS_PUBLIC void fsg_CheckWorkSpaceForFit(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32                   lExtraWorkSpace,
	int32                   lMGWorkSpace,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2);

FS_PUBLIC void  fsg_GetRealBitmapSizes(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plSizeBitmap1,
	 int32 *                     plSizeBitmap2);

FS_PUBLIC void  fsg_SetUpWorkSpaceBitmapMemory(
	 char *                      pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char *                  pClientBitmapPtr2,
	char *                  pClientBitmapPtr3,
	char **                 ppMemoryBase6,
	char **                 ppMemoryBase7);

FS_PUBLIC void  fsg_GetWorkSpaceExtra(
	 char *                      pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char **                 ppWorkSpaceExtra);

FS_PUBLIC void  fsg_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM);

FS_PUBLIC void  fsg_QueryPPEMXY(
	void *              pvGlobalGS,
	fsg_TransformRec *  TransformInfo,
	uint16 *            pusPPEMX,
	uint16 *            pusPPEMY,
	uint16 *            pusRotation);


/*      FSGlue Access Routines  */

FS_PUBLIC void  fsg_GetContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
	boolean				bSubPixel,            
#endif // FSCFG_SUBPIXEL
	F26Dot6 **          pX,
	F26Dot6 **          pY,
	int16 **            pSp,
	int16 **            pEp,
	uint8 **            pOnCurve,
	uint8 **			pFc,
	uint16 *            pNc);

FS_PUBLIC uint32      fsg_GetContourDataSize(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void  fsg_DumpContourData(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 uint8 **               pbyOutline);

FS_PUBLIC void  fsg_RestoreContourData(
	 uint8 **               ppbyOutline,
	 F26Dot6 **             ppX,
	 F26Dot6 **             ppY,
	 int16 **               ppSp,
	 int16 **               ppEp,
	 uint8 **               ppOnCurve,
	 uint8 **               ppFc,
	 uint16 *               pNc);

FS_PUBLIC void  fsg_GetDevAdvanceWidth(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 point *                pDevAdvanceWidth);

FS_PUBLIC void  fsg_GetDevAdvanceHeight(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 point *                pDevAdvanceHeight);

FS_PUBLIC void  fsg_GetScaledCVT(
	char *                      pPrivateFontSpace,
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets,
	F26Dot6 **                  ppScaledCVT);

FS_PUBLIC void  fsg_45DegreePhaseShift(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void  fsg_UpdateAdvanceWidth (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAW,
	vectorType *        AdvanceWidth);

FS_PUBLIC void  fsg_UpdateAdvanceHeight (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAH,
	vectorType *        AdvanceHeight);

FS_PUBLIC void  fsg_ScaleVerticalMetrics (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
	uint16              usNonScaledAH,
    int16               sNonScaledTSB,
	vectorType *        pvecAdvanceHeight,
	vectorType *        pvecTopSideBearing);

FS_PUBLIC void  fsg_CalcLSBsAndAdvanceWidths(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 F26Dot6                fxXMin,
	 F26Dot6                fxYMax,
	 point *                devAdvanceWidth,
	 point *                devLeftSideBearing,
	 point *                LeftSideBearing,
	 point *                devLeftSideBearingLine,
	 point *                LeftSideBearingLine);

FS_PUBLIC void  fsg_CalcTSBsAndAdvanceHeights(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 F26Dot6                fxXMin,
	 F26Dot6                fxYMax,
	 point *                devAdvanceHeight,
	 point *                devTopSideBearing,
	 point *                TopSideBearing,
	 point *                devTopSideBearingLine,
	 point *                TopSideBearingLine);

FS_PUBLIC boolean   fsg_IsTransformStretched(
	fsg_TransformRec *  TransformInfo);

FS_PUBLIC boolean   fsg_IsTransformRotated(
	fsg_TransformRec *  TransformInfo);

/*  Control Routines    */

FS_PUBLIC ErrorCode fsg_InitInterpreterTrans (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,     /* GlobalGS */
	Fixed               fxPointSize,
	int16               sXResolution,
	int16               sYResolution,
	boolean           bHintAtEmSquare,
	uint16             usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16             usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16               sWinDescender,
	int32               lDescDev,               /* descender in device metric, used for clipping */
	int16 *            psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *            psBoldSimulVertShift   /* shift for emboldening simulation, vertically */
	);

FS_PUBLIC void  fsg_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16				flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC ErrorCode fsg_RunFontProgram(
	 void *                 globalGS,           /* GlobalGS */
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc);

FS_PUBLIC ErrorCode fsg_RunPreProgram (
	 sfac_ClientRec *   ClientInfo,
	 LocalMaxProfile *  pMaxProfile,     /* Max Profile Table    */
	 fsg_TransformRec * TransformInfo,
	 void *                 pvGlobalGS,
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc);

FS_PUBLIC ErrorCode fsg_GridFit (
	 sfac_ClientRec *   ClientInfo,      /* sfnt Client information     */
	 LocalMaxProfile *  pMaxProfile,     /* Max Profile Table               */
	 fsg_TransformRec * TransformInfo,  /* Transformation information    */
	 void *                 pvGlobalGS,      /* GlobalGS                            */
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc,
	 boolean                bUseHints,
	 uint16 *               pusScanType,
	 boolean *              pbGlyphHasOutline,
	 uint16 *               pusNonScaledAW,
	boolean                bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean			    bSubPixel
#endif // FSCFG_SUBPIXEL
	 );

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void fsg_InitializeData (void);
#endif

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  fsg_CopyFontProgramResults(
	void *              pvGlobalGS,
	void *              pvGlobalGSSubPixel);


FS_PUBLIC void  fsg_ScaleToCompatibleWidth (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    Fixed   fxCompatibleWidthScale);  

FS_PUBLIC void  fsg_AdjustCompatibleMetrics (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX);  

FS_PUBLIC void  fsg_CalcDevHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX);

FS_PUBLIC void  fsg_CalcDevNatHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX);

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fsglue.c ===
/*++
	File:       FSglue.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):


				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		 <>     10/14/97    CB      rename ASSERT into FS_ASSERT
		 <>     02/21/97    CB      ClaudeBe, scaled component in composite glyphs
		 <>     12/14/95    CB      add usNonScaledAH and sNonScaledTSB to  GlyphData
		 <7>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
													and one (always fractional) metrics. [rb]
		 <6>    11/16/90    MR      Add SnapShotOutline to make instructions after components work
													[rb]
		 <5>     11/9/90    MR      Unrename fsg_ReleaseProgramPtrs to RELEASESFNTFRAG. [rb]
		 <4>     11/5/90    MR      Change globalGS.ppemDot6 to globalGS.fpem, change all instrPtr
													and curve flags to uint8. [rb]
		 <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <2>    10/20/90    MR      Change matrix[2][2] back to a fract (in response to change in
													skia). However, ReduceMatrix converts it to a fixed after it has
													been used to "regularize" the matrix. Changed scaling routines
													for outline and CVT to use integer pixelsPerEm. Removed
													scaleFunc from the splineKey. Change some routines that were
													calling FracDiv and FixDiv to use LongMulDiv and ShortMulDiv for
													greater speed and precision. Removed fsg_InitScaling. [rb]
		<20>     8/22/90    MR      Only call fixmul when needed in finalComponentPass loop
		<19>      8/1/90    MR      Add line to set non90DegreeTransformation
		<18>     7/26/90    MR      remove references to metricInfo junk, don't include ToolUtils.h
		<17>     7/18/90    MR      Change error return type to int, split WorkSpace routine into
													two calls, added SWAPW macros
		<16>     7/14/90    MR      Fixed reference to const SQRT2 to FIXEDSQRT2
		<15>     7/13/90    MR      Ansi-C stuff, tried to use correct sizes for variables to avoid
									coercion (sp?)
		<12>     6/21/90    MR      Add calls to ReleaseSfntFrag
		<11>      6/4/90    MR      Remove MVT, change matrix to have bottom right element be a
									fixed.
		<10>      6/1/90    MR      Thou shalt not pay no more attention to the MVT!
		<8+>     5/29/90    MR      look for problem in Max45Trick
		 <8>     5/21/90    RB      bugfix in fsg_InitInterpreterTrans setting key->imageState
		 <7>      5/9/90    MR      Fix bug in MoreThanXYStretch
		 <6>      5/4/90    RB      support for new scan converter and decryption          mrr - add
									fsg_ReverseContours and key->reverseContour         to account
									for glyphs that are flipped.         This keeps the
									winding-number correct for         the scan converter.  Mike
									fixed fsg_Identity
		 <5>      5/3/90    RB      support for new scan converter and decryption  mrr - add
									fsg_ReverseContours and key->reverseContour to account for
									glyphs that are flipped. This keeps the winding-number correct
									for the scan converter.
		 <4>     4/10/90    CL      Fixed infinite loop counter - changed uint16 to int16 (Mikey).
		 <3>     3/20/90    CL      Added HasPerspective for finding fast case
									Removed #ifdef SLOW, OLD
									Changed NormalizeTransformation to use fpem (16.16) and to use max instead of length
									and to loop instead of recurse.
									Removed compensation for int ppem in fsg_InitInterpreterTrans (not needed with fpem)
									Greased loops in PreTransformGlyph, PostTransformGlyph, LocalPostTransformGlyph,
													 ShiftChar, ZeroOutTwilightZone, InitLocalT
									Changed GetPreMultipliers to special case unit vector * 2x2 matrix
									Added support for ppemDot6 and pointSizeDot6
									Changed fsg_MxMul to treat the perspective elements as Fracts
									arrays to pointers in ScaleChar
									Fixed bugs in loops in posttransformglyph, convert loops to --numPts >= 0
		 <2>     2/27/90    CL      It reconfigures itself during runtime !  New lsb and rsb
									calculation.  Shift bug in instructed components:  New error
									code for missing but needed table. (0x1409)  Optimization which
									has to do with shifting and copying ox/x and oy/y.  Fixed new
									format bug.  Changed transformed width calculation.  Fixed
									device metrics for transformed uninstructed sidebearing
									characters.  Dropoutcontrol scanconverter and SCANCTRL[]
									instruction.  Fixed transformed component bug.
									
	   <3.3>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. The old perspective bug has been fixed. The
									transformation is internally automatically normalized. This
									should also solve the overflow problem we had. Changed
									sidebearing point calculations to use 16.16 precision. For zero
									or negative numbers in my tricky/fast square root computation it
									would go instable and loop forever. It was not able to handle
									large transformations correctly. This has been fixed and the
									normalization may call it self recursively to gain extra
									precision! It used to normalize an identity transformation
									unecessarily.
	   <3.2>     10/6/89    CEL     Phantom points were removed causing a rounding of last 2 points
									bug. Characters would become distorted.
	   <3.1>     9/27/89    CEL     Fixed transformation anchor point bug.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some
									enhanclocalpostements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/* rwb r/24/90 - Add support for scanControlIn and scanControlOut variables in global graphiscs
 * state
 */
/** System Includes **/

#define FSCFG_INTERNAL

/** FontScaler's Includes **/
#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "fnt.h"
#include "interp.h"
#include "sfntaccs.h"
#include "fsglue.h"
#include "scale.h"

/*  CONSTANTS   */

/*  These constants are used for interpreting the scan control and scan type
	fields returned by the interpreter. They are documented in the TrueType
	specification under the SCANCTRL and SCANTYPE instructions.
 */

#define SCANINFO_SIZE_MASK   0x000000FF
#define SCANINFO_FLAGS_MASK  0x00003F00
#define SCANINFO_TYPE_MASK   0xFFFF0000
#define SCANINFO_SIZE_CLEAR  ~SCANINFO_SIZE_MASK
#define SCANINFO_FLAGS_CLEAR ~SCANINFO_FLAGS_MASK
#define SCANINFO_TYPE_CLEAR  ~SCANINFO_TYPE_MASK
#define SCANINFO_FLAGS_DONT  0x00003800
#define SCANINFO_FLAGS_DO    0x00000700
#define SCANCTRL_SIZE_MASK                   0x000000FF
#define SCANCTRL_DROPOUT_ALL_SIZES           0xFF
#define SCANCTRL_DROPOUT_IF_LESS             0x0100
#define SCANCTRL_DROPOUT_IF_ROTATED          0x0200
#define SCANCTRL_DROPOUT_IF_STRETCHED        0x0400
#define SCANCTRL_NODROP_UNLESS_LESS          0x0800
#define SCANCTRL_NODROP_UNLESS_ROTATED       0x1000
#define SCANCTRL_NODROP_UNLESS_STRETCH       0x2000
#define SCANTYPE_UNINITIALIZED               0xFFFF

/* fo the key->imageState field */
#define IMAGESTATE_ROTATED      0x0400
#define IMAGESTATE_STRETCHED    0x1000
#define IMAGESTATE_NON_POS_RECT 0x2000
#define IMAGESTATE_SIZE_MASK    0x00FF
#define IMAGESTATE_MAX_PPEM_SIZE 0x000000FF

#define COMPOSITE_ROOT                  0
#define MAX_TWILIGHT_CONTOURS       1
#define DEFAULT_COMPONENT_ELEMENTS  3UL
#define DEFAULT_COMPONENT_DEPTH     1UL
static  const   transMatrix   IdentTransform =
	{{{ONEFIX,      0,      0},
	  {     0, ONEFIX,      0},
	  {     0,      0, ONEFIX}}};

/*********** macros ************/

#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define CHECK_GLYPHDATA(pglyphdata) FS_ASSERT((( (pglyphdata)->acIdent[0] == 'G') &&                            \
											( (pglyphdata)->acIdent[1] == 'D')),"Illegal GlyphData pointer");
#define MAX_COMPONENT_DEPTH(pMaxProfile) (uint32)MAX (pMaxProfile->maxComponentDepth, DEFAULT_COMPONENT_DEPTH)
#define MAX_COMPONENT_ELEMENTS(pMaxProfile) (uint32)MAX (pMaxProfile->maxComponentElements, DEFAULT_COMPONENT_ELEMENTS)

#define MAX_NESTED_GLYPHS(pMaxProfile) (uint32)((MAX_COMPONENT_DEPTH(pMaxProfile) + 1) + MAX_COMPONENT_ELEMENTS(pMaxProfile));

/**********************************************************************************/
/*  TYPEDEFS    */

typedef enum {
	glyphSimple,
	glyphIncompleteComposite,
	glyphComposite,
	glyphUndefined
} GlyphTypes;


/* Glyph Data   */

typedef struct GlyphData GlyphData;

struct GlyphData{
	char        acIdent[2];             /* Identifier for GlyphData                         */
	GlyphData * pSibling;               /* Pointer to siblings                              */
	GlyphData * pChild;                 /* Pointer to children                              */
	GlyphData * pParent;                /* Pointer to parent                                */
	sfac_GHandle hGlyph;                /* Handle for font access                           */
	GlyphTypes  GlyphType;              /* Type of glyph                                    */
	uint16      usGlyphIndex;           /* Glyph Index                                      */
	BBOX        bbox;                   /* Bounding box for glyph                           */
	uint16      usNonScaledAW;          /* Nonscaled Advance Width                          */
	uint16      usNonScaledAH;          /* Nonscaled Advance Height                         */
	int16       sNonScaledLSB;          /* Nonscaled Left Side Bearing                      */
	int16       sNonScaledTSB;          /* Nonscaled Top Side Bearing                       */
	uint16      usDepth;                /* Depth of Glyph in composite tree                 */
	sfac_ComponentTypes MultiplexingIndicator;/* Flag for arguments of composites                */
	boolean     bRoundXYToGrid;         /* Round composite offsets to grid                  */
	int16       sXOffset;               /* X offset for composite (if supplied)             */
	int16       sYOffset;               /* Y offset for composite (if supplied)             */
	uint16      usAnchorPoint1;         /* Anchor Point 1 for composites (if not offsets)   */
	uint16      usAnchorPoint2;         /* Anchor Point 2 for composites (if not offsets)   */
	transMatrix mulT;                   /* Transformation matrix for composite              */
	boolean     bUseChildMetrics;       /* Should use child metrics?                        */
	boolean     bUseMyMetrics;          /* Is glyph USE_MY_METRICS?                         */
	boolean     bScaleCompositeOffset; 	/* false by default, Apple scale the composite offset, MS doesn't */ 
	point       ptDevLSB;               /* Left Side Bearing Point                          */
	point       ptDevRSB;               /* Right Side Bearing Point                         */
	uint16      usScanType;             /* ScanType value for this glyph                    */
	uint16      usSizeOfInstructions;   /* Size (in bytes) of glyph instructions            */
	uint8 *     pbyInstructions;        /* Pointer to glyph instructions                    */
	fnt_ElementType * pGlyphElement;    /* Current glyph element pointer                    */

	/* the following variables were added to allow correct handling of scaled/rotated coposite glyphs */
	transMatrix currentTMatrix;         /* current Transf matrix, composite + user transform */
	boolean     bSameTransformAsMaster; /* same transformation as the master glyph, no composite scaling or rotation  */
};

/**********************************************************************************/

/* PRIVATE PROTOTYPES <4> */

FS_PRIVATE void fsg_GetOutlineSizeAndOffsets(
	uint16      usMaxPoints,
	uint16      usMaxContours,
	fsg_OutlineFieldInfo * offsetPtr,
	uint32 *    pulOutlineSize,
	uint32 *    pulReusableMarker);

FS_PRIVATE ErrorCode    fsg_CreateGlyphData(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information        */
	void *              pvGlobalGS,         /* GlobalGS                              */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter   */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	uint16 *            pusScanType,        /* ScanType value                        */
	boolean *           pbGlyphHasOutline,  /* Outline for glyph                 */
	uint16 *            pusNonScaledAW      /* Return NonScaled Advance Width    */
#ifdef FSCFG_SUBPIXEL
	,boolean			bSubPixel
#endif // FSCFG_SUBPIXEL
	);
	
FS_PRIVATE ErrorCode   fsg_ExecuteGlyph(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information         */
	uint32              ulGlyphDataCount,   /* Max nested components */
	void *              pvGlobalGS,         /* GlobalGS                              */
	GlyphData *         pGlyphData,         /* GlyphData pointer                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	boolean *           pbHasOutline,      /* True if glyph has outline         */
    uint32*             pCompositePoints,   /* total number of point for composites, to check for overflow */
    uint32*             pCompositeContours  /* total number of contours for composites, to check for overflow */
#ifdef FSCFG_SUBPIXEL
	,boolean			bSubPixel
#endif // FSCFG_SUBPIXEL
	);
	
FS_PRIVATE void fsg_ChooseNextGlyph(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address        */
	GlyphData *         pGlyphData,         /* GlyphData pointer        */
	GlyphData **        ppNextGlyphData);   /* Next GlyphData pointer   */

FS_PRIVATE ErrorCode    fsg_SimpleInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl);

FS_PRIVATE ErrorCode    fsg_CompositeInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl);

FS_PRIVATE void fsg_LinkChild(
	GlyphData *     pGlyphData,             /* GlyphData pointer        */
	GlyphData *     pChildGlyphData);       /* Child GlyphData pointer  */

FS_PRIVATE void fsg_MergeGlyphData(
	void *          pvGlobalGS,             /* GlobalGS            */
	GlyphData *     pChildGlyphData,       /* GlyphData pointer     */
	uint16          usEmResolution);

FS_PRIVATE void fsg_TransformChild(
	GlyphData *     pGlyphData);            /* GlyphData pointer    */

FS_PRIVATE void fsg_MergeScanType(
	GlyphData *     pGlyphData,             /* GlyphData pointer    */
	GlyphData *     pParentGlyphData);      /* GlyphData pointer    */

FS_PRIVATE boolean fsg_DoScanControl(
	uint16 usScanControl,
	uint32 ulImageState);

FS_PRIVATE void fsg_InitializeGlyphDataMemory(
	uint32                  ulGlyphDataCount,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr);/* WorkSpace Address    */

FS_PRIVATE  ErrorCode fsg_AllocateGlyphDataMemory(
	uint32                  ulGlyphDataCount,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	GlyphData **            ppGlyphData);   /* GlyphData pointer    */

FS_PRIVATE void fsg_DeallocateGlyphDataMemory(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address    */
	GlyphData *         pGlyphData);        /* GlyphData pointer    */

FS_PRIVATE void fsg_InitializeGlyphData(
	GlyphData *             pGlyphData,     /* GlyphData pointer    */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	uint16                  usGlyphIndex,   /* Glyph Index          */
	uint16                  usDepth);       /* Glyph depth          */

FS_PRIVATE void fsg_CheckFit(
	int32       lSize1,
	int32       lSize2,
	int32       lSize3,
	int32       lTotalSize,
	uint32 *    pfResult);

FS_PRIVATE void  fsg_Embold(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvGlobalGS,
	boolean             bUseHints, /* True if glyph is gridfitted       */
	boolean             bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
	);     

void fsg_CheckOutlineOrientation (fnt_ElementType *pElement);

/* FSGlue Code  */

/* ..............MEMORY MANAGEMENT ROUTINES................ */


/*                                                              
 * fsg_PrivateFontSpaceSize : This data should remain intact for the life of the sfnt
 *              because function and instruction defs may be defined in the font program
 *              and/or the preprogram.
 */
/*

	 PRIVATE SPACE Memory Layout

typedef struct fsg_PrivateSpaceOffsets {
	 0  +===========+   ---------------------  <- PrivateSpaceOffsets.offset_storage;
		|           |
		|           |   TrueType Storage
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_functions;
		|           |
		|           |   TrueType Function Defs
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_instrDefs;
		|           |
		|           |   TrueType Instruction Defs
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_controlValues;
		|           |
		|           |   TrueType Scaled CVT
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_globalGS;
		| pStack    |
		| pStorage  |
		| pCVT      |
		| pFDEF     |   TrueType Global GS
		| pIDEF     |
		| pFPGM     |
		| pPPGM     |
		| pGlyphPgm |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_FontProgram;
		|           |
		|           |   TrueType Font Program
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_PreProgram;
		|           |
		|           |   TrueType Pre Program
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_TwilightZone;
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Twilight Element
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_TwilightOutline;
		|x[maxtzpts]|   Twilight Outline
		+-----------+
		|y[maxtzpts]|
		+-----------+
		:   ...     :
		+-----------+
		|ep[maxtzct]|
		+-----------+
		|ox[maxtzpt]|
		+-----------+
		|oox[mxtzpt]|
		+-----------+
		:   ...     :
		+-----------+
		|f[maxtzpts]|
		+===========+   ---------------------

*/
FS_PUBLIC uint32  fsg_PrivateFontSpaceSize (
	sfac_ClientRec *            ClientInfo,
	LocalMaxProfile *           pMaxProfile,      /* Max Profile Table    */
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets)
{
	uint32  ulOutlineSize;
	uint32  ulReusableMarker;   /* Unused dummy variable */
    uint32  ulLastOffset;

	PrivateSpaceOffsets->offset_storage         = 0L;
	PrivateSpaceOffsets->offset_functions       = PrivateSpaceOffsets->offset_storage         + (uint32)sizeof (F26Dot6) * (uint32)pMaxProfile->maxStorage;
	PrivateSpaceOffsets->offset_instrDefs       = PrivateSpaceOffsets->offset_functions   + (uint32)sizeof (fnt_funcDef) * (uint32)pMaxProfile->maxFunctionDefs;
	PrivateSpaceOffsets->offset_controlValues   = PrivateSpaceOffsets->offset_instrDefs   + (uint32)sizeof (fnt_instrDef) * (uint32)pMaxProfile->maxInstructionDefs;     /* <4> */
	PrivateSpaceOffsets->offset_globalGS        = PrivateSpaceOffsets->offset_controlValues + (uint32)sizeof (F26Dot6) *
		((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue));

	ALIGN(voidPtr, PrivateSpaceOffsets->offset_globalGS);
#ifdef FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_storageSubPixel         = PrivateSpaceOffsets->offset_globalGS    + (uint32)sizeof (fnt_GlobalGraphicStateType);
	PrivateSpaceOffsets->offset_functionsSubPixel       = PrivateSpaceOffsets->offset_storageSubPixel         + (uint32)sizeof (F26Dot6) * (uint32)pMaxProfile->maxStorage;
	PrivateSpaceOffsets->offset_instrDefsSubPixel       = PrivateSpaceOffsets->offset_functionsSubPixel   + (uint32)sizeof (fnt_funcDef) * (uint32)pMaxProfile->maxFunctionDefs;
	PrivateSpaceOffsets->offset_controlValuesSubPixel   = PrivateSpaceOffsets->offset_instrDefsSubPixel   + (uint32)sizeof (fnt_instrDef) * (uint32)pMaxProfile->maxInstructionDefs;     /* <4> */
	PrivateSpaceOffsets->offset_globalGSSubPixel        = PrivateSpaceOffsets->offset_controlValuesSubPixel + (uint32)sizeof (F26Dot6) *
		((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue));

	ALIGN(voidPtr, PrivateSpaceOffsets->offset_globalGSSubPixel);
	PrivateSpaceOffsets->offset_FontProgram     = PrivateSpaceOffsets->offset_globalGSSubPixel + (uint32)sizeof (fnt_GlobalGraphicStateType);
#else
	PrivateSpaceOffsets->offset_FontProgram     = PrivateSpaceOffsets->offset_globalGS    + (uint32)sizeof (fnt_GlobalGraphicStateType);
#endif // FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_PreProgram      = PrivateSpaceOffsets->offset_FontProgram + (uint32)SFAC_LENGTH (ClientInfo, sfnt_fontProgram);

    PrivateSpaceOffsets->offset_TwilightZone    = PrivateSpaceOffsets->offset_PreProgram      + (uint32)SFAC_LENGTH (ClientInfo, sfnt_preProgram);
	ALIGN(voidPtr, PrivateSpaceOffsets->offset_TwilightZone);

#ifdef FSCFG_SUBPIXEL
    PrivateSpaceOffsets->offset_TwilightZoneSubPixel    = PrivateSpaceOffsets->offset_TwilightZone + (uint32)sizeof (fnt_ElementType);
	ALIGN(voidPtr, PrivateSpaceOffsets->offset_TwilightZoneSubPixel);
/*
	Setup the twilight zone element data structure. This data structure will
	contain all of the address into the twilight zone outline space.
*/
	PrivateSpaceOffsets->offset_TwilightOutline = PrivateSpaceOffsets->offset_TwilightZoneSubPixel + (uint32)sizeof (fnt_ElementType);
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutline);
#else
/*
	Setup the twilight zone element data structure. This data structure will
	contain all of the address into the twilight zone outline space.
*/
	PrivateSpaceOffsets->offset_TwilightOutline = PrivateSpaceOffsets->offset_TwilightZone + (uint32)sizeof (fnt_ElementType);
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutline);
    ulLastOffset = PrivateSpaceOffsets->offset_TwilightOutline;
#endif // FSCFG_SUBPIXEL

/*
	Setup Twilight Zone outline space. This space contains all of the components
	to describe a Twilight Zone outline. Set the offset to our current position,
	and as we calculate the size of this outline space, update the field
	offsets e.g. x, ox, oox, &c.
*/
	/*** Outline -- TWILIGHT ZONE ***/

	fsg_GetOutlineSizeAndOffsets(
		pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS,
		&(PrivateSpaceOffsets->TwilightOutlineFieldOffsets),
		&ulOutlineSize,
		&ulReusableMarker);

#ifdef FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_TwilightOutlineSubPixel = PrivateSpaceOffsets->offset_TwilightOutline + ulOutlineSize;
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutlineSubPixel);
    ulLastOffset = PrivateSpaceOffsets->offset_TwilightOutlineSubPixel;
#endif // FSCFG_SUBPIXEL

#ifdef FSCFG_FONTOGRAPHER_BUG
/*
		Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
		have the critical error : Inst: RCVT CVT Out of range. CVT = 255
		This flag is meant to be set under Windows. If will cause additional
		memory to be allocated for the CVT if necessary in order to be sure
		that this illegal read will access memory within the legal range.
		Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
		and CVT > NumCvt to be classified as error instead of critical error */

	if ((ulLastOffset + ulOutlineSize) - PrivateSpaceOffsets->offset_controlValues < 256 * (uint32)sizeof (F26Dot6))
	{
		ulOutlineSize = (256 * (uint32)sizeof (F26Dot6)) + PrivateSpaceOffsets->offset_controlValues - ulLastOffset;
	}
#endif // FSCFG_FONTOGRAPHER_BUG

	return ((ulLastOffset + ulOutlineSize) - PrivateSpaceOffsets->offset_storage);
}


/*                          
 * fsg_WorkSpaceSetOffsets : This stuff changes with each glyph
 *
 * Computes the workspace size and sets the offsets into it.
 *
 */

/*

	WORKSPACE Memory Layout

	  0 +===========+    ---------------------  <- WorkSpaceOffsets.ulGlyphElementOffset
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element 1
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element 2
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------
		|           |
		:           :          :
		|           |
		+===========+   ---------------------
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element [MaxComponentDepth + 1]
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphOutlineOffset
		|x[maxpts]  |   Glyph Outline
		+-----------+
		|y[maxpts]  |
		+-----------+
		:   ...     :
		+-----------+
		|ep[maxctrs]|
		+-----------+
		|ox[maxpts] |   <- WorkSpaceOffsets.ulReusableMemoryOffset


        !!! with SubPixel, we need to put the ulReusableMemoryOffset after ox because of the conversion done in GetContourData !!!
		+-----------+
		|oox[maxpts]|
		+-----------+
		:   ...     :
		+-----------+
		|f[maxpts]  |
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphDataByteSetBaseOffset
		| T| F| T| F|
		+-----------+
		| F| F| F| F|
		+-----------+
		| F| F| F| F|   Glyph Data Allocation ByteSet
		+-----------+   (number of bytes = ulGlyphDataCount)
		| F| F| F| F|
		+-----------+
		| F| F| F| F|
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphDataBaseOffset
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData 1
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData 2
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------
		|           |
		:           :           :
		|           |
		+===========+   ---------------------
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData [ulGlyphDataCount]
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------  <- WorkSpaceOffsets.ulStackOffset
		|           |
		|           |
		|           |   Stack
		|           |
		|           |
		|           |
		+===========+   ---------------------

*/

FS_PUBLIC uint32    fsg_WorkSpaceSetOffsets (
	LocalMaxProfile *        pMaxProfile,    /* Max Profile Table    */
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plExtraWorkSpace)
{
	uint32                       ulOutlineDataSize;
	uint32                       ulWorkSpacePos;
	uint32                       ulGlyphDataCount;
    uint16                       maxStackElements;

	ulWorkSpacePos = 0UL;

/*
	Setup the glyph element data array. This data structure contains all of the
	addresses into the glyph outline space. There are the same number of glyph
	element arrays as there are outline spaces; this allows us to handle the
	worstcase composite in the font.
*/
	WorkSpaceOffsets->ulGlyphElementOffset = ulWorkSpacePos;
	ulWorkSpacePos += (uint32)sizeof (fnt_ElementType) *
		  (uint32)(MAX_COMPONENT_DEPTH(pMaxProfile) + 1);

/*** Outline -- GLYPH *****/
/*
	Setup Glyph outline space. This space contains all of the components
	to describe a Glyph outline. Set the offset to our current position,
	and as we calculate the size of this outline space, update the elemental
	offsets e.g. x, ox, oox, &c.

	Once we have calculated the size of one outline space, we will duly note
	its size, and then add enough space to handle the outlines for the worst
	case composite depth in the font.
*/
	ALIGN(int16, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphOutlineOffset = ulWorkSpacePos; /* Remember start of Glyph Element */

	fsg_GetOutlineSizeAndOffsets(
		(uint16)(PHANTOMCOUNT + MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints)),
		(uint16)MAX (pMaxProfile->maxContours, pMaxProfile->maxCompositeContours),
		&(WorkSpaceOffsets->GlyphOutlineFieldOffsets),
		&ulOutlineDataSize,
		(uint32 *)&(WorkSpaceOffsets->ulReusableMemoryOffset));

	/* Adjust Reusable memory marker to be based from zero, rather than GlyphOutline */

	WorkSpaceOffsets->ulReusableMemoryOffset += WorkSpaceOffsets->ulGlyphOutlineOffset;

	ulWorkSpacePos += ulOutlineDataSize;
/*
	Set the GlyphData ByteSet array. This array is used to track the memory used
	in GlyphData. Each entry in this array is a boolean.  One needs to also
	calculate the number of GlyphData's that will be needed to handle the
	worstcase composite in the font.
*/
	ALIGN(boolean, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphDataByteSetOffset = ulWorkSpacePos;
	ulGlyphDataCount = MAX_NESTED_GLYPHS(pMaxProfile);

	ulWorkSpacePos += ulGlyphDataCount * (uint32)sizeof (boolean);
/*
	Set up the GlyphData array. This array contains the information needed
	to describe composites and components for a glyph.
*/
	ALIGN(voidPtr, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphDataOffset = ulWorkSpacePos;
	ulWorkSpacePos += (uint32)sizeof(GlyphData) * ulGlyphDataCount;


	ALIGN(F26Dot6, ulWorkSpacePos);
	WorkSpaceOffsets->ulStackOffset = ulWorkSpacePos;

    maxStackElements = pMaxProfile->maxStackElements;

#ifdef FSCFG_EUDC_EDITOR_BUG
    if (maxStackElements == 0)
    {
        maxStackElements = 1;
    }
#endif // FSCFG_EUDC_EDITOR_BUG

	ulWorkSpacePos += (uint32)maxStackElements * (uint32)sizeof (F26Dot6);

/* Calculate amount of extra memory */

	*plExtraWorkSpace = (int32)ulWorkSpacePos - (int32)WorkSpaceOffsets->ulReusableMemoryOffset;
	WorkSpaceOffsets->ulMemoryBase6Offset = 0L;
	WorkSpaceOffsets->ulMemoryBase7Offset = 0L;

/* Return the total size of the WorkSpace memory.   */

	return(ulWorkSpacePos);

}

FS_PRIVATE void fsg_GetOutlineSizeAndOffsets(
	uint16                  usMaxPoints,
	uint16                  usMaxContours,
	fsg_OutlineFieldInfo *  offsetPtr,
	uint32 *                pulOutlineSize,
	uint32 *                pulReusableMarker)

{
	uint32      ulArraySize;

	offsetPtr->onCurve = 0;

	*pulOutlineSize    = (uint32)usMaxPoints * (uint32)sizeof (uint8);
	ALIGN(int16, *pulOutlineSize);

	offsetPtr->sp   = *pulOutlineSize;
	ulArraySize = (uint32)usMaxContours * (uint32)sizeof (int16);
	*pulOutlineSize += ulArraySize;
	offsetPtr->ep   = *pulOutlineSize;
	*pulOutlineSize += ulArraySize;

	/* need to be before the reusable marker, now that this flag is exported */
	offsetPtr->fc       = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxContours * (uint32)sizeof (uint8);

	ALIGN(F26Dot6, *pulOutlineSize);
	offsetPtr->x       = *pulOutlineSize;
	ulArraySize = (uint32)usMaxPoints * (uint32)sizeof (F26Dot6);
	*pulOutlineSize    += ulArraySize;
	offsetPtr->y       = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

#ifndef FSCFG_SUBPIXEL
	*pulReusableMarker = *pulOutlineSize;
	ALIGN(voidPtr, *pulReusableMarker);
#endif // FSCFG_SUBPIXEL
	/* Everything below this point can be reused during contour scanning */

	offsetPtr->ox      = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

#ifdef FSCFG_SUBPIXEL
	*pulReusableMarker = *pulOutlineSize;
	ALIGN(voidPtr, *pulReusableMarker);
#endif // FSCFG_SUBPIXEL

    offsetPtr->oy      = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

    offsetPtr->oox     = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;
	offsetPtr->ooy     = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

	offsetPtr->f       = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxPoints * (uint32)sizeof (uint8);

    ALIGN(int32, *pulOutlineSize);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	offsetPtr->pcr      = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxPoints * (uint32)sizeof (PhaseControlRelation);
#endif

}


FS_PUBLIC void  fsg_UpdatePrivateSpaceAddresses(
	sfac_ClientRec *        ClientInfo,     /* Cached sfnt information  */
	LocalMaxProfile *       pMaxProfile,     /* Max Profile Table         */
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets,
	void *                  pvStack,        /* pointer to stack         */
	void **                 pvFontProgram,  /* pointer to font program  */
	void **                 pvPreProgram)   /* pointer to pre program   */
{
	void *                       pvGlobalGS;
	void *                       pvCVT;          /* pointer to CVT  */
	void *                       pvStore;
	void *                       pvFuncDef;
	void *                       pvInstrDef;
	uint32                       ulLengthFontProgram, ulLengthPreProgram;

	pvCVT =         pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValues;
	pvStore =       pPrivateFontSpace + PrivateSpaceOffsets->offset_storage;
	pvFuncDef =     pPrivateFontSpace + PrivateSpaceOffsets->offset_functions;
	pvInstrDef =    pPrivateFontSpace + PrivateSpaceOffsets->offset_instrDefs;
	pvGlobalGS =    pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGS;

	*pvFontProgram =  pPrivateFontSpace + PrivateSpaceOffsets->offset_FontProgram;
	ulLengthFontProgram = SFAC_LENGTH(ClientInfo, sfnt_fontProgram);
	*pvPreProgram =   pPrivateFontSpace + PrivateSpaceOffsets->offset_PreProgram;
	ulLengthPreProgram = SFAC_LENGTH(ClientInfo, sfnt_preProgram);

	itrp_UpdateGlobalGS(pvGlobalGS, pvCVT, pvStore, pvFuncDef, pvInstrDef, pvStack,
		pMaxProfile, (uint16)((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue)),
		ulLengthFontProgram, *pvFontProgram, ulLengthPreProgram, *pvPreProgram, ClientInfo->lClientID);

#ifdef FSCFG_SUBPIXEL
    /* prepare the second pvGlobalGS for SubPixel compatible width */
	pvCVT =         pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValuesSubPixel;
	pvStore =       pPrivateFontSpace + PrivateSpaceOffsets->offset_storageSubPixel;
	pvFuncDef =     pPrivateFontSpace + PrivateSpaceOffsets->offset_functionsSubPixel;
	pvInstrDef =    pPrivateFontSpace + PrivateSpaceOffsets->offset_instrDefsSubPixel;
	pvGlobalGS =    pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGSSubPixel;

	itrp_UpdateGlobalGS(pvGlobalGS, pvCVT, pvStore, pvFuncDef, pvInstrDef, pvStack,
		pMaxProfile, (uint16)((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue)),
		ulLengthFontProgram, *pvFontProgram, ulLengthPreProgram, *pvPreProgram, ClientInfo->lClientID);
#endif // FSCFG_SUBPIXEL

}

FS_PUBLIC void  fsg_UpdateWorkSpaceAddresses(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr)
{
	pWorkSpaceAddr->pStack = (F26Dot6 *)(WorkSpaceOffsets->ulStackOffset + pWorkSpace);
	pWorkSpaceAddr->pGlyphOutlineBase = WorkSpaceOffsets->ulGlyphOutlineOffset + pWorkSpace;
	pWorkSpaceAddr->pGlyphElement = (fnt_ElementType *)(WorkSpaceOffsets->ulGlyphElementOffset + pWorkSpace);
	pWorkSpaceAddr->pGlyphDataByteSet = (boolean *)(WorkSpaceOffsets->ulGlyphDataByteSetOffset + pWorkSpace);
	pWorkSpaceAddr->pvGlyphData = (void *)(WorkSpaceOffsets->ulGlyphDataOffset + pWorkSpace);
	pWorkSpaceAddr->pReusableMemoryMarker = WorkSpaceOffsets->ulReusableMemoryOffset + pWorkSpace;
}

FS_PUBLIC void  fsg_UpdateWorkSpaceElement(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr)
{
	char *                  pOutlineBase;
	fnt_ElementType *       pGlyphElement;        /* Address of Glyph Element array   */
	fsg_OutlineFieldInfo *  pOffset;

	pOutlineBase =  (char *)pWorkSpaceAddr->pGlyphOutlineBase;
	pGlyphElement = pWorkSpaceAddr->pGlyphElement;

	/* Note: only the first level glyph element has address updated. Second */
	/* levels are updated when referenced.                                           */

	pOffset             = & (WorkSpaceOffsets->GlyphOutlineFieldOffsets);

	pGlyphElement->x        = (F26Dot6 *) (pOutlineBase + pOffset->x);
	pGlyphElement->y        = (F26Dot6 *) (pOutlineBase + pOffset->y);
	pGlyphElement->ox       = (F26Dot6 *) (pOutlineBase + pOffset->ox);
	pGlyphElement->oy       = (F26Dot6 *) (pOutlineBase + pOffset->oy);
	pGlyphElement->oox      = (F26Dot6 *) (pOutlineBase + pOffset->oox);
	pGlyphElement->ooy      = (F26Dot6 *) (pOutlineBase + pOffset->ooy);
	pGlyphElement->sp       = (int16 *) (pOutlineBase + pOffset->sp);
	pGlyphElement->ep       = (int16 *) (pOutlineBase + pOffset->ep);
	pGlyphElement->onCurve  = (uint8 *) (pOutlineBase + pOffset->onCurve);
	pGlyphElement->f        = (uint8 *) (pOutlineBase + pOffset->f);

	pGlyphElement->fc       = (uint8 *) (pOutlineBase + pOffset->fc);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pGlyphElement->pcr      = (PhaseControlRelation *) (pOutlineBase + pOffset->pcr);
#endif
}

FS_PUBLIC void *    fsg_QueryGlobalGS(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	return ((void *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGS));
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *    fsg_QueryGlobalGSSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	return ((void *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGSSubPixel));
}
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryTwilightElement(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	fnt_ElementType *        pTwilightElement; /* Address of Twilight Zone Element */
	fsg_OutlineFieldInfo *  pOffset;
	char *                       pTemp;

	pOffset                 = &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets);
	pTemp                   = pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightOutline;
	pTwilightElement        = (fnt_ElementType *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightZone);

	pTwilightElement->x         = (F26Dot6 *) (pTemp + pOffset->x);
	pTwilightElement->y         = (F26Dot6 *) (pTemp + pOffset->y);
	pTwilightElement->ox        = (F26Dot6 *) (pTemp + pOffset->ox);
	pTwilightElement->oy        = (F26Dot6 *) (pTemp + pOffset->oy);
	pTwilightElement->oox       = (F26Dot6 *) (pTemp + pOffset->oox);
	pTwilightElement->ooy       = (F26Dot6 *) (pTemp + pOffset->ooy);
	pTwilightElement->sp        = (int16 *) (pTemp + pOffset->sp);
	pTwilightElement->ep        = (int16 *) (pTemp + pOffset->ep);
	pTwilightElement->onCurve   = (uint8 *) (pTemp + pOffset->onCurve);
	pTwilightElement->f         = (uint8 *) (pTemp + pOffset->f);

	pTwilightElement->fc        = (uint8 *) (pTemp + pOffset->fc);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pTwilightElement->pcr		= (PhaseControlRelation *) (pTemp + pOffset->pcr);
#endif

	return (void *)pTwilightElement;
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *      fsg_QueryTwilightElementSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	fnt_ElementType *        pTwilightElement; /* Address of Twilight Zone Element */
	fsg_OutlineFieldInfo *  pOffset;
	char *                       pTemp;

	pOffset                 = &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets);
	pTemp                   = pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightOutlineSubPixel;
	pTwilightElement        = (fnt_ElementType *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightZoneSubPixel);

	pTwilightElement->x         = (F26Dot6 *) (pTemp + pOffset->x);
	pTwilightElement->y         = (F26Dot6 *) (pTemp + pOffset->y);
	pTwilightElement->ox        = (F26Dot6 *) (pTemp + pOffset->ox);
	pTwilightElement->oy        = (F26Dot6 *) (pTemp + pOffset->oy);
	pTwilightElement->oox       = (F26Dot6 *) (pTemp + pOffset->oox);
	pTwilightElement->ooy       = (F26Dot6 *) (pTemp + pOffset->ooy);
	pTwilightElement->sp        = (int16 *) (pTemp + pOffset->sp);
	pTwilightElement->ep        = (int16 *) (pTemp + pOffset->ep);
	pTwilightElement->onCurve   = (uint8 *) (pTemp + pOffset->onCurve);
	pTwilightElement->f         = (uint8 *) (pTemp + pOffset->f);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pTwilightElement->pcr		= (PhaseControlRelation *) (pTemp + pOffset->pcr);
#endif
	return (void *)pTwilightElement;
}
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryStack(fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
    /* we don't allow the stack to be used to pass informations between pre-program and glyph program
       or between two glyph programs */
	return ((void *)pWorkSpaceAddr->pStack);
}

FS_PUBLIC void *      fsg_QueryReusableMemory(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets)
{
	return pWorkSpace + WorkSpaceOffsets->ulReusableMemoryOffset;
}

FS_PUBLIC void  fsg_CheckWorkSpaceForFit(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32                   lExtraWorkSpace,
	int32                   lMGWorkSpace,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2)
{
	uint32              ulMemoryOffset;

	ulMemoryOffset = WorkSpaceOffsets->ulReusableMemoryOffset;

	ulMemoryOffset += (uint32)lMGWorkSpace;  /* correct for MeasureGlyph Workspace */
	lExtraWorkSpace -= lMGWorkSpace;

	WorkSpaceOffsets->ulMemoryBase6Offset = 0L;
	WorkSpaceOffsets->ulMemoryBase7Offset = 0L;

	/* Save original sizes */

	WorkSpaceOffsets->ulMemoryBase6Size = *plSizeBitmap1;
	WorkSpaceOffsets->ulMemoryBase7Size = *plSizeBitmap2;

	if( *plSizeBitmap1 > *plSizeBitmap2)
	{
		if( *plSizeBitmap1 <= lExtraWorkSpace )
		{
			WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
			ulMemoryOffset += (uint32)*plSizeBitmap1;

			if (( *plSizeBitmap2 <= lExtraWorkSpace - *plSizeBitmap1 ) &&
				( *plSizeBitmap2 > 0L ))
			{
				WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
				*plSizeBitmap2 = 0L;
			}
			*plSizeBitmap1 = 0L;
		}
		else if (( *plSizeBitmap2 <= lExtraWorkSpace ) &&
				 ( *plSizeBitmap2 > 0L))
		{
			WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
			*plSizeBitmap2 = 0L;
		}

	}
	else  /* (plSizeBitmap1 <= *plSizeBitmap2) */
	{
		if(( *plSizeBitmap2 <= lExtraWorkSpace ) &&
		   ( *plSizeBitmap2 > 0L ))
		{
			WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
			ulMemoryOffset += (uint32)*plSizeBitmap2;

			if (( *plSizeBitmap1 <= lExtraWorkSpace - *plSizeBitmap2 ) &&
				 ( *plSizeBitmap1 > 0L ))
			{
				WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
				*plSizeBitmap1 = 0L;
			}
			*plSizeBitmap2 = 0L;
		}
		else if (( *plSizeBitmap1 <= lExtraWorkSpace ) &&
				 ( *plSizeBitmap1 > 0L ))
		{
			WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
			*plSizeBitmap1 = 0L;
		}
	}
}

FS_PUBLIC void  fsg_GetRealBitmapSizes(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2)
{
	 *plSizeBitmap1 = WorkSpaceOffsets->ulMemoryBase6Size;
	 *plSizeBitmap2 = WorkSpaceOffsets->ulMemoryBase7Size;
}

FS_PUBLIC void  fsg_SetUpWorkSpaceBitmapMemory(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char *                  pClientBitmapPtr2,
	char *                  pClientBitmapPtr3,
	char **                 ppMemoryBase6,
	char **                 ppMemoryBase7)
{
	if(WorkSpaceOffsets->ulMemoryBase6Offset != 0L)
	{
		*ppMemoryBase6 = WorkSpaceOffsets->ulMemoryBase6Offset + (char *)pWorkSpace;
	}
	else
	{
		*ppMemoryBase6 = pClientBitmapPtr2;
	}

	if(WorkSpaceOffsets->ulMemoryBase7Offset != 0L)
	{
		  *ppMemoryBase7 = WorkSpaceOffsets->ulMemoryBase7Offset + (char *)pWorkSpace;
	}
	else
	{
		*ppMemoryBase7 = pClientBitmapPtr3;
	}
}

FS_PUBLIC void  fsg_GetWorkSpaceExtra(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char **                 ppWorkSpaceExtra)
{
	 *ppWorkSpaceExtra = (char *)(pWorkSpace + WorkSpaceOffsets->ulReusableMemoryOffset);
}

FS_PUBLIC void  fsg_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM)
{
	scl_QueryPPEM(pvGlobalGS, pusPPEM);
}

/*  Return PPEM in both X and Y and 90 degree rotation factor for sbit matching */

FS_PUBLIC void  fsg_QueryPPEMXY(
	void *              pvGlobalGS,
	fsg_TransformRec *  TransformInfo,
	uint16 *            pusPPEMX,
	uint16 *            pusPPEMY,
	uint16 *            pusRotation)
{
	*pusRotation = mth_90degRotationFactor( &TransformInfo->currentTMatrix );
	scl_QueryPPEMXY(pvGlobalGS, pusPPEMX, pusPPEMY);
}


/*  FSGlue Access Routines  */

FS_PUBLIC void  fsg_GetContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
	boolean				bSubPixel,            
#endif // FSCFG_SUBPIXEL
	F26Dot6 **          pX,
	F26Dot6 **          pY,
	int16 **            pSp,
	int16 **            pEp,
	uint8 **            pOnCurve,
	uint8 **            pFc,
	uint16 *            pNc)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	*pX =       pElement->x;
	*pY =       pElement->y;
	*pSp =      pElement->sp;
	*pEp =      pElement->ep;
	*pOnCurve = pElement->onCurve;
	*pFc =     pElement->fc;
	*pNc      = (uint16)pElement->nc;
#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
	{
		/* we scale down the coordinate from x,y into ox, oy and return those */
		scl_ScaleDownFromSubPixelOverscale(pElement);
		*pX =       pElement->ox;
	}
#endif // FSCFG_SUBPIXEL
}

FS_PUBLIC uint32      fsg_GetContourDataSize(
	fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	return( scl_GetContourDataSize( pElement ) );
}

FS_PUBLIC void  fsg_DumpContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	uint8 **            ppbyOutline)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_DumpContourData(pElement, ppbyOutline);
}

FS_PUBLIC void  fsg_RestoreContourData(
	uint8 **        ppbyOutline,
	F26Dot6 **      ppX,
	F26Dot6 **      ppY,
	int16 **        ppSp,
	int16 **        ppEp,
	uint8 **        ppOnCurve,
	uint8 **        ppFc,
	uint16 *        pNc)
{
	fnt_ElementType     pElement;

	scl_RestoreContourData(&pElement, ppbyOutline);

	*ppX =          pElement.x;
	*ppY =          pElement.y;
	*ppSp =         pElement.sp;
	*ppEp =         pElement.ep;
	*ppOnCurve =    pElement.onCurve;
	*ppFc =         pElement.fc;
	*pNc =          (uint16)pElement.nc;
}

FS_PUBLIC void  fsg_GetDevAdvanceWidth(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	point *             pDevAdvanceWidth)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcDevAdvanceWidth(pElement, pDevAdvanceWidth);
}

FS_PUBLIC void  fsg_GetDevAdvanceHeight(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	point *             pDevAdvanceHeight)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcDevAdvanceHeight(pElement, pDevAdvanceHeight);
}

FS_PUBLIC void  fsg_GetScaledCVT(
	char *                      pPrivateFontSpace,
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets,
	F26Dot6 **                  ppScaledCVT)
{
	*ppScaledCVT = (F26Dot6 *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValues);
}

FS_PUBLIC void  fsg_45DegreePhaseShift(
	fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_45DegreePhaseShift(pElement);
}

FS_PUBLIC void  fsg_UpdateAdvanceWidth (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAW,
	vectorType *        AdvanceWidth)
{
	AdvanceWidth->y = 0;
	scl_ScaleAdvanceWidth(
		pvGlobalGS,
		AdvanceWidth,
		usNonScaledAW,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix);
}

FS_PUBLIC void  fsg_UpdateAdvanceHeight (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAH,
	vectorType *        AdvanceHeight)
{
	AdvanceHeight->x = 0;
	scl_ScaleAdvanceHeight(
		pvGlobalGS,
		AdvanceHeight,
		usNonScaledAH,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix);
}


FS_PUBLIC void  fsg_ScaleVerticalMetrics (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
	uint16              usNonScaledAH,
    int16               sNonScaledTSB,
	vectorType *        pvecAdvanceHeight,
	vectorType *        pvecTopSideBearing )
{
	pvecAdvanceHeight->x = 0;           /* start with x values at zero */
	pvecTopSideBearing->x = 0;          /* since 'vmtx' refers to y values */

    scl_ScaleVerticalMetrics (
    	pvGlobalGS,
    	usNonScaledAH,
    	sNonScaledTSB,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix,
    	pvecAdvanceHeight,
    	pvecTopSideBearing);
}


FS_PUBLIC void  fsg_CalcLSBsAndAdvanceWidths(
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	F26Dot6                 fxXMin,
	F26Dot6                 fxYMax,
	point *                 devAdvanceWidth,
	point *                 devLeftSideBearing,
	point *                 LeftSideBearing,
	point *                 devLeftSideBearingLine,
	point *                 LeftSideBearingLine)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcLSBsAndAdvanceWidths(
		pElement,
		fxXMin,
		fxYMax,
		devAdvanceWidth,
		devLeftSideBearing,
		LeftSideBearing,
		devLeftSideBearingLine,
		LeftSideBearingLine);
}

FS_PUBLIC void  fsg_CalcTSBsAndAdvanceHeights(
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	F26Dot6                 fxXMin,
	F26Dot6                 fxYMax,
	point *                 devAdvanceHeight,
	point *                 devTopSideBearing,
	point *                 TopSideBearing,
	point *                 devTopSideBearingLine,
	point *                 TopSideBearingLine)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcTSBsAndAdvanceHeights(
		pElement,
		fxXMin,
		fxYMax,
		devAdvanceHeight,
		devTopSideBearing,
		TopSideBearing,
		devTopSideBearingLine,
		TopSideBearingLine);
}

FS_PUBLIC boolean   fsg_IsTransformStretched(
	fsg_TransformRec *  TransformInfo)
{
	return (boolean)(( TransformInfo->ulImageState & IMAGESTATE_STRETCHED ) == IMAGESTATE_STRETCHED);
}

FS_PUBLIC boolean   fsg_IsTransformRotated(
	fsg_TransformRec *  TransformInfo)
{
	return (boolean)(( TransformInfo->ulImageState & IMAGESTATE_ROTATED ) == IMAGESTATE_ROTATED);
}

/*  Control Routines    */

FS_PUBLIC ErrorCode fsg_InitInterpreterTrans (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	Fixed               fxPointSize,
	int16               sXResolution,
	int16               sYResolution,
	boolean           bHintAtEmSquare,
	uint16            usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16              usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16               sWinDescender,
	int32               lDescDev,               /* descender in device metric, used for clipping */
	int16 *				psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *				psBoldSimulVertShift   /* shift for emboldening simulation, vertically */
	)
{
	ErrorCode       error;
	uint32          ulPixelsPerEm;
	transMatrix *   trans;

	trans = &TransformInfo->currentTMatrix;

	error = scl_InitializeScaling(
		pvGlobalGS,
		TransformInfo->bIntegerScaling,
		&TransformInfo->currentTMatrix,
		TransformInfo->usEmResolution,
		fxPointSize,
		sXResolution,
		sYResolution,
		usEmboldWeightx,       /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
		usEmboldWeighty,      /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
		sWinDescender,
		lDescDev,
		psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
		psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
		bHintAtEmSquare,
		&ulPixelsPerEm);

	if(error)
	{
		return error;
	}

	TransformInfo->bPhaseShift = false;

	if ( ulPixelsPerEm > IMAGESTATE_MAX_PPEM_SIZE )
	{
		TransformInfo->ulImageState = (uint32)IMAGESTATE_MAX_PPEM_SIZE;
	}
	else
	{
		TransformInfo->ulImageState = ulPixelsPerEm;
	}

	TransformInfo->bPositiveSquare = mth_PositiveSquare( trans );

	if ( !(mth_PositiveRectangle( trans )))
	{
		TransformInfo->ulImageState |= IMAGESTATE_NON_POS_RECT;
	}

	if ( !(TransformInfo->bPositiveSquare) )
	{
		if( mth_GeneralRotation (trans))
		{
			TransformInfo->ulImageState |=  IMAGESTATE_ROTATED;
		}

		TransformInfo->ulImageState |= IMAGESTATE_STRETCHED;

		TransformInfo->bPhaseShift = mth_IsMatrixStretched(trans); /*<8>*/
	}

	TransformInfo->bEmboldSimulation = ((usEmboldWeightx != 0) || (usEmboldWeighty != 0)); 

	return NO_ERR;
}

FS_PUBLIC void  fsg_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16				flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
	scl_SetHintFlags(
		pvGlobalGS,
		bHintForGray
#ifdef FSCFG_SUBPIXEL
	    ,flHintForSubPixel
#endif // FSCFG_SUBPIXEL
        );
}
/*
 *  All this guy does is record FDEFs and IDEFs, anything else is ILLEGAL
 */
FS_PUBLIC ErrorCode fsg_RunFontProgram(
	void *                  pvGlobalGS,               /* GlobalGS     */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	void *                  pvTwilightElement,
	FntTraceFunc           traceFunc)
{
	return itrp_ExecuteFontPgm (
		(fnt_ElementType *)pvTwilightElement,
		pWorkSpaceAddr->pGlyphElement,
		pvGlobalGS,
		traceFunc);
}

/*
 * fsg_RunPreProgram
 *
 * Runs the pre-program and scales the control value table
 *
 */
FS_PUBLIC ErrorCode fsg_RunPreProgram (
	sfac_ClientRec *    ClientInfo,
	LocalMaxProfile *   pMaxProfile,     /* Max Profile Table    */
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvTwilightElement,
	FntTraceFunc        traceFunc)
{
	ErrorCode           result;
	F26Dot6 *           pfxCVT;
	fnt_ElementType *   pTwilightElement;

	pTwilightElement = (fnt_ElementType *)pvTwilightElement;

	result = itrp_SetDefaults (pvGlobalGS, TransformInfo->fxPixelDiameter);

	if (result != NO_ERR)
	{
		return result;
	}

	scl_GetCVTPtr(pvGlobalGS, &pfxCVT);

	result = sfac_CopyCVT(ClientInfo, pfxCVT);

	if (result != NO_ERR)
	{
		return result;
	}

	scl_ScaleCVT (pvGlobalGS, pfxCVT);

	scl_InitializeTwilightContours(
		pTwilightElement,
		(int16)pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	scl_ZeroOutlineData(
		pTwilightElement,
		pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	result = itrp_ExecutePrePgm (
		pTwilightElement,
		pWorkSpaceAddr->pGlyphElement,
		pvGlobalGS,
		traceFunc);

	return result;
}

/*
 *      fsg_GridFit
 */
FS_PUBLIC ErrorCode fsg_GridFit (
	sfac_ClientRec *    ClientInfo,     /* sfnt Client information      */
	LocalMaxProfile *   pMaxProfile,    /* Max Profile Table            */
	fsg_TransformRec *  TransformInfo,  /* Transformation information   */
	void *              pvGlobalGS,     /* GlobalGS                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvTwilightElement,
	FntTraceFunc        traceFunc,
	boolean             bUseHints,
	uint16 *            pusScanType,
	boolean *           pbGlyphHasOutline,
	uint16 *            pusNonScaledAW,
	boolean            bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean			bSubPixel
#endif // FSCFG_SUBPIXEL
	)
{
	ErrorCode           result;
	fnt_ElementType *   pTwilightElement;
	fnt_GlobalGraphicStateType *globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	pTwilightElement = (fnt_ElementType *)pvTwilightElement;

	scl_InitializeTwilightContours(
		pTwilightElement,
		(int16)pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	result = fsg_CreateGlyphData (
		ClientInfo,
		pMaxProfile,
		TransformInfo,
		pvGlobalGS,
		pWorkSpaceAddr,
		pTwilightElement,
		traceFunc,
		bUseHints,
		pusScanType,
		pbGlyphHasOutline,
		pusNonScaledAW
#ifdef FSCFG_SUBPIXEL
		,bSubPixel
#endif // FSCFG_SUBPIXEL
		);

	if(result == NO_ERR)
	{
		if (TransformInfo->bEmboldSimulation)
		{
			fsg_Embold( pWorkSpaceAddr, pvGlobalGS, bUseHints, bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	                ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );
            if(*pusNonScaledAW)
				*pusNonScaledAW +=  (TransformInfo->usEmResolution * 2 - 1) / 100; /* adjust pusNonScaledAW by 2% of Em height */
		}

		if ((TransformInfo->ulImageState & (IMAGESTATE_NON_POS_RECT)) || globalGS->bHintAtEmSquare)
		{
			scl_PostTransformGlyph (
				pvGlobalGS,
				pWorkSpaceAddr->pGlyphElement,
				&TransformInfo->currentTMatrix);
		}

		/* apply the translation part of the transformation matrix */
		scl_ApplyTranslation (
			pWorkSpaceAddr->pGlyphElement,
			&TransformInfo->currentTMatrix,
			bUseHints,
			globalGS->bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	        ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );
	}
	return result;
}

FS_PRIVATE ErrorCode    fsg_CreateGlyphData(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information        */
	void *              pvGlobalGS,         /* GlobalGS                              */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	uint16 *            pusScanType,        /* ScanType value                        */
	boolean *           pbGlyphHasOutline,  /* Outline for glyph                 */
	uint16 *            pusNonScaledAW      /* Return NonScaled Advance Width    */
#ifdef FSCFG_SUBPIXEL
	,boolean			bSubPixel
#endif // FSCFG_SUBPIXEL
	)
{
	GlyphData * pGlyphData;
	GlyphData * pNextGlyphData;
	boolean      bHasOutline;
	uint32       ulGlyphDataCount;
	ErrorCode   ReturnCode;
    uint32      CompositePoints = 0;
    uint32      CompositeContours = 0;

	*pbGlyphHasOutline = FALSE;
	bHasOutline = FALSE;

	ulGlyphDataCount = MAX_NESTED_GLYPHS(pMaxProfile);

	fsg_InitializeGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr);
	ReturnCode = fsg_AllocateGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr, &pGlyphData); /* Allocates GlyphData for topmost   */
	if(ReturnCode != NO_ERR)
	{
		return ReturnCode;
	}
												 /* parent  */
	fsg_InitializeGlyphData(pGlyphData, pWorkSpaceAddr,
		ClientInfo->usGlyphIndex, COMPOSITE_ROOT);

	while(pGlyphData != NULL)
	{
		CHECK_GLYPHDATA( pGlyphData );

		ReturnCode = fsg_ExecuteGlyph(
			ClientInfo,
			pMaxProfile,
			TransformInfo,
			ulGlyphDataCount,
			pvGlobalGS,
			pGlyphData,
			pWorkSpaceAddr,
			pTwilightElement,
			traceFunc,
			bUseHints,
			&bHasOutline,
            &CompositePoints,
            &CompositeContours
#ifdef FSCFG_SUBPIXEL
            ,bSubPixel
#endif // FSCFG_SUBPIXEL
			);
		if(ReturnCode)
		{
			return ReturnCode;
		}
		*pbGlyphHasOutline |= bHasOutline;
		*pusScanType = pGlyphData->usScanType;
		fsg_ChooseNextGlyph(pWorkSpaceAddr, pGlyphData, &pNextGlyphData);
		*pusNonScaledAW = pGlyphData->usNonScaledAW;
		pGlyphData = pNextGlyphData;
	}

	return NO_ERR;
}

FS_PRIVATE ErrorCode    fsg_ExecuteGlyph(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information         */
	uint32              ulGlyphDataCount,   /* Max Number of nested glyphs */
	void *              pvGlobalGS,         /* GlobalGS                              */
	GlyphData *         pGlyphData,         /* GlyphData pointer                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                      */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	boolean *           pbHasOutline,       /* True if glyph has outline         */
    uint32*                pCompositePoints,/* total number of point for composites, to check for overflow */
    uint32*                pCompositeContours  /* total number of contours for composites, to check for overflow */
#ifdef FSCFG_SUBPIXEL
	,boolean			bSubPixel
#endif // FSCFG_SUBPIXEL
	)
{
	ErrorCode       ReturnCode;
	boolean         bCompositeGlyph;
	boolean         bLastComponent;
	boolean         bWeHaveInstructions;
	boolean         bWeHaveCompositeInstructions;
	boolean         bScanInfoChanged;
	boolean 		bWeHaveAScale;
	uint16          usScanType;
	uint16          usScanControl;
	GlyphData *     pChildGlyphData;
	uint16          usComponentElementCount;
	uint16          contour;

	*pbHasOutline = FALSE;

	if (pGlyphData->GlyphType == glyphUndefined)
	{
		if(pGlyphData->pParent != NULL)
		{
			scl_IncrementChildElement(pGlyphData->pGlyphElement, pGlyphData->pParent->pGlyphElement);
		} else {
			pGlyphData->currentTMatrix = TransformInfo->currentTMatrix;
		}

		ReturnCode = sfac_ReadGlyphHeader(ClientInfo, pGlyphData->usGlyphIndex,
			&pGlyphData->hGlyph, &bCompositeGlyph, pbHasOutline,
			&pGlyphData->pGlyphElement->nc, &pGlyphData->bbox);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		/* Get advance width, advance height, left side bearing and top side bearing information  */

		ReturnCode = sfac_ReadGlyphMetrics(
			ClientInfo, pGlyphData->usGlyphIndex,
			&pGlyphData->usNonScaledAW, &pGlyphData->usNonScaledAH, 
			&pGlyphData->sNonScaledLSB, &pGlyphData->sNonScaledTSB);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if (bCompositeGlyph)
		{
			pGlyphData->GlyphType = glyphIncompleteComposite;
		}
		else
		{
			pGlyphData->GlyphType = glyphSimple;
		}
	}

	if (pGlyphData->GlyphType == glyphSimple)
	{
		ReturnCode = sfac_ReadOutlineData(
			pGlyphData->pGlyphElement->onCurve,
			pGlyphData->pGlyphElement->ooy, pGlyphData->pGlyphElement->oox,
			&pGlyphData->hGlyph, pMaxProfile, *pbHasOutline, pGlyphData->pGlyphElement->nc,
			pGlyphData->pGlyphElement->sp, pGlyphData->pGlyphElement->ep,
			&pGlyphData->usSizeOfInstructions, &pGlyphData->pbyInstructions,
            pCompositePoints, pCompositeContours);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

        if (TransformInfo->bEmboldSimulation 
#ifdef FSCFG_SUBPIXEL
			|| bSubPixel
#endif // FSCFG_SUBPIXEL
			)
        {
            // in gdi we use the outline orientation test only for outline emboldening and subpixel rendering
            // doing that all the time affect performance
            fsg_CheckOutlineOrientation (pGlyphData->pGlyphElement);
        }
        else
        {
            int32 Contour;

            for (Contour = 0; Contour < pGlyphData->pGlyphElement->nc; Contour++)
            {
                pGlyphData->pGlyphElement->fc[Contour] = 0;
            }
        }

        ReturnCode = fsg_SimpleInnerGridFit(
			pvGlobalGS,
			pTwilightElement,
			pGlyphData->pGlyphElement,
			bUseHints,
			traceFunc,
			TransformInfo->usEmResolution,
			pGlyphData->usNonScaledAW,
			pGlyphData->usNonScaledAH,
			pGlyphData->sNonScaledLSB,
			pGlyphData->sNonScaledTSB,
			pGlyphData->bSameTransformAsMaster, /* current transf. same as master transf.   */
			pGlyphData->currentTMatrix, /* current transf. : user + composite transf. */
			&pGlyphData->bbox,
			pGlyphData->usSizeOfInstructions,
			pGlyphData->pbyInstructions,
			&usScanType,
			&usScanControl,
			&bScanInfoChanged);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if( ! fsg_DoScanControl(usScanControl, TransformInfo->ulImageState))
		{
			pGlyphData->usScanType = SK_NODROPOUT;
		}
		else
		{
			pGlyphData->usScanType = usScanType;
		}

		// here we update the contour orientation bit if necessary, to reflect the final orientation of the contours in the composite
		if (FixMul(pGlyphData->mulT.transform[0][0],pGlyphData->mulT.transform[1][1]) - FixMul(pGlyphData->mulT.transform[0][1],pGlyphData->mulT.transform[1][0]) < 0) {
			for (contour = 0; contour < pGlyphData->pGlyphElement->nc; contour++) {
				pGlyphData->pGlyphElement->fc[contour] ^= OUTLINE_MISORIENTED;
			}
		}

		if (pGlyphData->pParent != NULL)
		{
			fsg_MergeGlyphData(pvGlobalGS, pGlyphData, TransformInfo->usEmResolution);
		}

		ReturnCode = sfac_ReleaseGlyph(ClientInfo, &pGlyphData->hGlyph);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		pGlyphData->pbyInstructions = 0;
		pGlyphData->usSizeOfInstructions = 0;
	}
	else if (pGlyphData->GlyphType == glyphComposite)
	{
		ReturnCode = fsg_CompositeInnerGridFit(
			pvGlobalGS,
			pTwilightElement,
			pGlyphData->pGlyphElement,
			bUseHints,
			traceFunc,
			TransformInfo->usEmResolution,
			pGlyphData->usNonScaledAW,
			pGlyphData->usNonScaledAH,
			pGlyphData->sNonScaledLSB,
			pGlyphData->sNonScaledTSB,
			pGlyphData->bSameTransformAsMaster, /* current transf. same as master transf.   */
			pGlyphData->currentTMatrix, /* current transf. : user + composite transf. */
			&pGlyphData->bbox,
			pGlyphData->usSizeOfInstructions,
			pGlyphData->pbyInstructions,
			&usScanType,
			&usScanControl,
			&bScanInfoChanged);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if (pGlyphData->bUseChildMetrics)
		{
			scl_SetSideBearingPoints(
				pGlyphData->pGlyphElement,
				&pGlyphData->ptDevLSB,
				&pGlyphData->ptDevRSB);
		}

		/* If composite has set SCANCTRL, use that value, otherwise merged children */

		if(bScanInfoChanged)
		{
			if( ! fsg_DoScanControl(usScanControl, TransformInfo->ulImageState))
			{
				pGlyphData->usScanType = SK_NODROPOUT;
			}
			else
			{
				pGlyphData->usScanType = usScanType;
			}
		}

		if (pGlyphData->pParent != NULL)
		{
			fsg_MergeGlyphData(pvGlobalGS, pGlyphData, TransformInfo->usEmResolution);
		}

		ReturnCode = sfac_ReleaseGlyph(ClientInfo, &pGlyphData->hGlyph);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		pGlyphData->pbyInstructions = 0;
		pGlyphData->usSizeOfInstructions = 0;
	}
	else if (pGlyphData->GlyphType == glyphIncompleteComposite)
	{
		bLastComponent = FALSE;
		bWeHaveInstructions = FALSE;
		bWeHaveCompositeInstructions = FALSE;

		pGlyphData->GlyphType = glyphComposite;

		usComponentElementCount = 0;

		do
		{
			if(pGlyphData->usDepth + 1UL > MAX_COMPONENT_DEPTH(pMaxProfile))
			{
				return BAD_MAXP_DATA;
			}

			usComponentElementCount++;

			if(usComponentElementCount > MAX_COMPONENT_ELEMENTS(pMaxProfile))
			{
				return BAD_MAXP_DATA;
			}

			ReturnCode = fsg_AllocateGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr, &pChildGlyphData);
			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}

			fsg_InitializeGlyphData(
				pChildGlyphData,
				pWorkSpaceAddr,
				NULL_GLYPH,
				(uint16)(pGlyphData->usDepth + 1U) );

			fsg_LinkChild(pGlyphData, pChildGlyphData);

			ReturnCode = sfac_ReadComponentData(
				&pGlyphData->hGlyph,
				&pChildGlyphData->MultiplexingIndicator,
				&pChildGlyphData->bRoundXYToGrid,
				&pChildGlyphData->bUseMyMetrics,
				&pChildGlyphData->bScaleCompositeOffset,
				&bWeHaveInstructions,
				&pChildGlyphData->usGlyphIndex,
				&pChildGlyphData->sXOffset,
				&pChildGlyphData->sYOffset,
				&pChildGlyphData->usAnchorPoint1,
				&pChildGlyphData->usAnchorPoint2,
				&pChildGlyphData->mulT,
				&bWeHaveAScale,
				&bLastComponent);

			if (bWeHaveAScale)
			{
				mth_MxConcat2x2( &pChildGlyphData->mulT, &pChildGlyphData->currentTMatrix );
				if (!mth_UnitarySquare(&pChildGlyphData->mulT))
				{
					pChildGlyphData->bSameTransformAsMaster	= FALSE; /* the component is scaled/rotated */
				}

			}

			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}

			bWeHaveCompositeInstructions |= bWeHaveInstructions;
		}
		while (!bLastComponent);

		if(bWeHaveCompositeInstructions)
		{
			ReturnCode = sfac_ReadCompositeInstructions(
				&pGlyphData->hGlyph,
				&pGlyphData->pbyInstructions,
				&pGlyphData->usSizeOfInstructions);

			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}
		}

	}
	return NO_ERR;
}


/*
 *      fsg_SimpleInnerGridFit
 */
FS_PRIVATE ErrorCode    fsg_SimpleInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix			CurrentTMatrix,                  /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode           result;
/*
	On entry to fsg_SimpleInnerGrid fit the element structure should
	contain only valid original points (oox, ooy). The original points
	will be scaled into the old points (ox, oy) and those will be
	copied into the current points (x, y).
*/
	itrp_SetCompositeFlag(pvGlobalGS, FALSE);

	itrp_QueryScanInfo(pvGlobalGS, pusScanType, pusScanControl);
	*pbChangeScanControl = FALSE;

	scl_CalcOrigPhantomPoints(pGlyphElement, bbox, sNonScaledLSB, sNonScaledTSB, usNonScaledAW, usNonScaledAH);

	if (itrp_bApplyHints(pvGlobalGS) && bUseHints)
	{
		itrp_SetSameTransformFlag(pvGlobalGS, bSameTransformAsMaster);

		if (!bSameTransformAsMaster)
		{
			scl_InitializeChildScaling(
				pvGlobalGS,
				CurrentTMatrix,
				usEmResolution);
		}

		/* hint and same transformation as master glyph */
		scl_ScaleOldCharPoints (pGlyphElement, pvGlobalGS);
		scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

		scl_AdjustOldCharSideBearing(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);
		scl_AdjustOldPhantomSideBearing(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);

		scl_CopyCurrentCharPoints(pGlyphElement);
		scl_CopyCurrentPhantomPoints(pGlyphElement);

		scl_RoundCurrentSideBearingPnt(pGlyphElement, pvGlobalGS, usEmResolution);

		if (usSizeOfInstructions > 0)
		{
			scl_ZeroOutlineFlags(pGlyphElement);

			result = itrp_ExecuteGlyphPgm (
				pTwilightElement,
				pGlyphElement,
				instructionPtr,
				instructionPtr + usSizeOfInstructions,
				pvGlobalGS,
				traceFunc,
				pusScanType,
				pusScanControl,
				pbChangeScanControl);

			if(result != NO_ERR)
			{
				return result;
			}

		}

		if (!bSameTransformAsMaster)
		{
			/* scale back to fixed FUnits */
			scl_ScaleBackCurrentCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleBackCurrentPhantomPoints (pGlyphElement, pvGlobalGS);
		}
	}
	else 
		/* no hints */
	{
		if (bSameTransformAsMaster)
		{
			/* no hint and same transformation as master glyph */
			/* as ox/oy are not used in this case, we shouldn't need to first
			   scale the original coordinate oox/ooy into ox/oy before copying
			   them into the current coordinate x/y, the code is left as it
			   for historic reason */
			scl_ScaleOldCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

			scl_CopyCurrentCharPoints(pGlyphElement);
			scl_CopyCurrentPhantomPoints(pGlyphElement);
		}
		else
		{
			/* no hint and different transformation as master glyph */
			/* we shift directly the original coordinates oox/ooy into the
			   current coordinates x/y in FixedFUnits,
			   as ox/oy are not used in this case, we don't need to do
			   a temporary copy into ox/oy */
			scl_OriginalCharPointsToCurrentFixedFUnits (pGlyphElement);
			scl_OriginalPhantomPointsToCurrentFixedFUnits (pGlyphElement);
		}
	}

	return NO_ERR;
}


/*
 *      fsg_CompositeInnerGridFit
 */
FS_PRIVATE ErrorCode    fsg_CompositeInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode             result;
/*
	On entry to fsg_CompositeInnerGridFit, the current points (x, y)
	are the only valid points in the element. We copy the current points
	onto the old points (ox, oy)
*/
	itrp_SetCompositeFlag(pvGlobalGS, TRUE);

	itrp_QueryScanInfo(pvGlobalGS, pusScanType, pusScanControl);
	*pbChangeScanControl = FALSE;

	/* Note: The original composite character points are invalid at this point. */
	/*       The interpreter handles this case correctly for composites.        */

	scl_CalcOrigPhantomPoints(pGlyphElement, bbox, sNonScaledLSB, sNonScaledTSB, usNonScaledAW, usNonScaledAH);
																  
	scl_CopyOldCharPoints(pGlyphElement);


	if (itrp_bApplyHints(pvGlobalGS) && bUseHints)
	{
		itrp_SetSameTransformFlag(pvGlobalGS, bSameTransformAsMaster);

		if (!bSameTransformAsMaster)
		{
			scl_InitializeChildScaling(
				pvGlobalGS,
				CurrentTMatrix,
				usEmResolution);
			scl_ScaleFixedCurrentCharPoints (pGlyphElement, pvGlobalGS);
		}

		scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

		scl_AdjustOldSideBearingPoints(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);

		scl_CopyCurrentPhantomPoints(pGlyphElement);

		scl_RoundCurrentSideBearingPnt(pGlyphElement, pvGlobalGS, usEmResolution);

		if (usSizeOfInstructions > 0)
		{
			scl_ZeroOutlineFlags(pGlyphElement);

			result = itrp_ExecuteGlyphPgm (
				pTwilightElement,
				pGlyphElement,
				instructionPtr,
				instructionPtr + usSizeOfInstructions,
				pvGlobalGS,
				traceFunc,
				pusScanType,
				pusScanControl,
				pbChangeScanControl);

			if(result != NO_ERR)
			{
				return result;
			}
		}

		if (!bSameTransformAsMaster)
		{
			/* scale back to fixed FUnits */
			scl_ScaleBackCurrentCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleBackCurrentPhantomPoints (pGlyphElement, pvGlobalGS);
		}

	}
	else 
	{
		if (bSameTransformAsMaster)
		{
			/* no hint and same transformation as master glyph */
			/* as ox/oy are not used in this case, we shouldn't need to first
			   scale the original coordinate oox/ooy into ox/oy before copying
			   them into the current coordinate x/y, the code is left as it
			   for historic reason */
			scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

			scl_CopyCurrentPhantomPoints(pGlyphElement);

		}
		else
		{
			/* no hint and different transformation as master glyph */
			/* we shift directly the original coordinates oox/ooy into the
			   current coordinates x/y in FixedFUnits,
			   as ox/oy are not used in this case, we don't need to do
			   a temporary copy into ox/oy */
			scl_OriginalPhantomPointsToCurrentFixedFUnits (pGlyphElement);

		}
	}

	return NO_ERR;
}

FS_PRIVATE void fsg_ChooseNextGlyph(
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address        */
	GlyphData *         pGlyphData,     /* GlyphData pointer        */
	GlyphData **        ppNextGlyphData)/* Next GlyphData pointer   */
{
	if (pGlyphData->pChild != NULL)
	{
		*ppNextGlyphData = pGlyphData->pChild;
		CHECK_GLYPHDATA( *ppNextGlyphData );
		pGlyphData->pChild = NULL;
	}
	else
	{
		*ppNextGlyphData = pGlyphData->pSibling;
		fsg_DeallocateGlyphDataMemory(pWorkSpaceAddr, pGlyphData);
	}
}

#ifdef FSCFG_SUBPIXEL
long fsg_AnalyzeCurrentTransformationMatrix(transMatrix *CTM);
long fsg_AnalyzeCurrentTransformationMatrix(transMatrix *CTM) {
	if (CTM->transform[0][1] == 0 && CTM->transform[1][0] == 0) return 0; // Identity, 180 rotation, mirroring in x or y
	if (CTM->transform[0][0] == 0 && CTM->transform[1][1] == 0) return 1; // 90 rotation, 270 rotation, or any combination of these rotation with a mirroring in x or y
	return 2; // assume arbitrary rotation
} // fsg_AnalyzeCurrentTransformationMatrix
#endif

FS_PRIVATE void fsg_MergeGlyphData(
	void *          pvGlobalGS,             /* GlobalGS            */
	GlyphData *     pChildGlyphData,       /* GlyphData pointer     */
	uint16          usEmResolution)
{
	fnt_ElementType * pChildElement;
	fnt_ElementType * pParentElement;
	F26Dot6         fxXOffset, fxYOffset;
	GlyphData *     pParentGlyphData; /* Parent GlyphData pointer   */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParity;
#endif

	CHECK_GLYPHDATA(pChildGlyphData);
	pParentGlyphData = pChildGlyphData->pParent;
	CHECK_GLYPHDATA(pParentGlyphData);

	pChildElement = pChildGlyphData->pGlyphElement;
	pParentElement = pParentGlyphData->pGlyphElement;

	fsg_TransformChild(pChildGlyphData);

	if (!pChildGlyphData->bSameTransformAsMaster && pChildGlyphData->pParent->bSameTransformAsMaster)
	{
		/* coordinates need to be converted from fixed FUnits to user space */
		/* scaling the cordinate of the child glyph from fixed FUnits to user space,
		   scaling from original coordinate x/y to original coordinate x/y 
		   this is done to have the child and parent glyph at the same coordinate space */

		/* use the master transform */
		itrp_SetSameTransformFlag(pvGlobalGS, TRUE);

		scl_ScaleFixedCurrentCharPoints(pChildElement, pvGlobalGS);
		scl_ScaleFixedCurrentPhantomPoints(pChildElement, pvGlobalGS);

		pChildGlyphData->bSameTransformAsMaster = TRUE;
	}
	
#ifdef FSCFG_SUBPIXEL
	rotationParity = fsg_AnalyzeCurrentTransformationMatrix(&pParentGlyphData->currentTMatrix);
#endif

	if (pChildGlyphData->MultiplexingIndicator == OffsetPoints)
	{
		if (!pChildGlyphData->pParent->bSameTransformAsMaster)
		{
			/* we have both the parent and the child that are not at the same transformation as the master glyph
			   we need to use the scaling of the parent as a child scaling to scale the offset */
			scl_InitializeChildScaling(
				pvGlobalGS,
				pChildGlyphData->pParent->currentTMatrix,
				usEmResolution);
		}

		scl_CalcComponentOffset(
			pvGlobalGS,
			pChildGlyphData->sXOffset,
			pChildGlyphData->sYOffset,
			pChildGlyphData->bRoundXYToGrid,
			pChildGlyphData->bSameTransformAsMaster,
			pChildGlyphData->bScaleCompositeOffset,
			pChildGlyphData->mulT,
#ifdef FSCFG_SUBPIXEL
			rotationParity,
#endif
			&fxXOffset,
			&fxYOffset);
	}
	else        /* Values are anchor points */
	{
		FS_ASSERT(pChildGlyphData->MultiplexingIndicator == AnchorPoints,
			   "Bad Multiplexing Indicator");
		scl_CalcComponentAnchorOffset(
			pParentElement,
			pChildGlyphData->usAnchorPoint1,
			pChildElement,
			pChildGlyphData->usAnchorPoint2,
			&fxXOffset,
			&fxYOffset);
	}
	scl_ShiftCurrentCharPoints(pChildElement, fxXOffset, fxYOffset);


	/* If USE_MY_METRICS, copy side bearings to parent  */

	if (pChildGlyphData->bUseMyMetrics)
	{
		pParentGlyphData->bUseChildMetrics = TRUE;

		scl_SaveSideBearingPoints(
			pChildElement,
			&pParentGlyphData->ptDevLSB,
			&pParentGlyphData->ptDevRSB);
	}

	fsg_MergeScanType(pChildGlyphData, pParentGlyphData);

	/* Start the copy   */

	/* scl_AppendOutlineData(pChildElement, pParentElement); */

	scl_UpdateParentElement(pChildElement, pParentElement);

	pChildElement->nc = 0;
}



FS_PRIVATE void fsg_LinkChild(
	GlyphData *     pGlyphData,     /* GlyphData pointer        */
	GlyphData *     pChildGlyphData)/* Child GlyphData pointer  */
{
	GlyphData * pTempGlyphData;

	if (pGlyphData->pChild == NULL)
	{
		pGlyphData->pChild = pChildGlyphData;
	}
	else
	{

		pTempGlyphData = pGlyphData->pChild;

		CHECK_GLYPHDATA(pTempGlyphData);

		while (pTempGlyphData->pSibling != pGlyphData)
		{
			pTempGlyphData = pTempGlyphData->pSibling;
			CHECK_GLYPHDATA(pTempGlyphData);
		}

		pTempGlyphData->pSibling = pChildGlyphData;
	}
	pChildGlyphData->pSibling = pGlyphData;
	pChildGlyphData->pParent =  pGlyphData;

	/* copy the transformation info from the parent */
	pChildGlyphData->currentTMatrix = pGlyphData->currentTMatrix;
	pChildGlyphData->bSameTransformAsMaster = pGlyphData->bSameTransformAsMaster;
}

FS_PRIVATE void fsg_TransformChild(
	GlyphData *     pGlyphData)     /* GlyphData pointer    */
{

	/* Apply local transform to glyph   */

	if (!mth_Identity(&pGlyphData->mulT))
	{
		scl_LocalPostTransformGlyph (pGlyphData->pGlyphElement, &pGlyphData->mulT);
	}
}

FS_PRIVATE void fsg_MergeScanType(
	GlyphData *     pGlyphData,       /* GlyphData pointer  */
	GlyphData *     pParentGlyphData) /* GlyphData pointer  */
{
	CHECK_GLYPHDATA(pGlyphData);
	CHECK_GLYPHDATA(pParentGlyphData);

	/* Merge Scan Type of parent and child  */

	if(pParentGlyphData->usScanType != SCANTYPE_UNINITIALIZED)
	{

		pParentGlyphData->usScanType =
			(uint16)(((pParentGlyphData->usScanType & (SK_NODROPOUT | SK_STUBS)) &
			(pGlyphData->usScanType & (SK_NODROPOUT | SK_STUBS))) |
			(pParentGlyphData->usScanType & SK_SMART));
	}
	else
	{
		pParentGlyphData->usScanType = pGlyphData->usScanType;
	}
}

/* Use various spline key values to determine if dropout control is to be activated
 * for this glyph, and if so what kind of dropout control.
 * The use of dropout control mode in the scan converter is controlled by 3 conditions.
 * The conditions are: Is the glyph rotated?, is the glyph stretched?,
 * is the current pixels per Em less than a specified threshold?
 * These conditions can be OR'd or ANDed together to determine whether the dropout control
 * mode ought to be used.

Six bits are used to specify the joint condition.  Their meanings are:

BIT     Meaning if set
8       Do dropout mode if other conditions don't block it AND
			pixels per em is less than or equal to bits 0-7
9       Do dropout mode if other conditions don't block it AND
			glyph is rotated
10      Do dropout mode if other conditions don't block it AND
			glyph is stretched
11      Do not do dropout mode unless ppem is less than or equal to bits 0-7
			A value of FF in 0-7  means all sizes
			A value of 0 in 0-7 means no sizes
12      Do not do dropout mode unless glyph is rotated
13      Do not do dropout mode unless glyph is stretched

In other words, we do not do dropout control if:
No bits are set,
Bit 8 is set, but ppem is greater than threshold
Bit 9 is set, but glyph is not rotated
Bit 10 is set, but glyph is not stretched
None of the conditions specified by bits 11-13 are true.

For example, 0xA10 specifies turn dropout control on if the glyph is rotated providing
that it is also less than 0x10 pixels per em.  A glyph is considered stretched if
the X and Y resolutions are different either because of the device characteristics
or because of the transformation matrix.  If both X and Y are changed by the same factor
the glyph is not considered stretched.

 */

FS_PRIVATE boolean fsg_DoScanControl(
	uint16 usScanControl,
	uint32 ulImageState)
{
	if ((usScanControl & SCANCTRL_DROPOUT_IF_LESS) &&
		((uint8)(ulImageState & IMAGESTATE_SIZE_MASK) <= (uint8)(usScanControl & SCANCTRL_SIZE_MASK)))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_LESS) &&
		((usScanControl & SCANCTRL_SIZE_MASK) == SCANCTRL_DROPOUT_ALL_SIZES))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_ROTATED) &&
		(ulImageState & IMAGESTATE_ROTATED))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_STRETCHED) &&
		(ulImageState & IMAGESTATE_STRETCHED))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_LESS) &&
		((uint8)(ulImageState & IMAGESTATE_SIZE_MASK) > (uint8)(usScanControl & SCANCTRL_SIZE_MASK)))
	{
		return FALSE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_ROTATED) &&
		! (ulImageState & IMAGESTATE_ROTATED))
	{
		return FALSE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_STRETCH) &&
		! (ulImageState & IMAGESTATE_STRETCHED))
	{
		return FALSE;
	}

	return FALSE;
}

FS_PRIVATE void fsg_InitializeGlyphDataMemory(
	uint32              ulGlyphDataCount,
	fsg_WorkSpaceAddr * pWorkSpaceAddr) /* WorkSpace Address      */
{
	uint32      ulIndex;
	boolean *   abyGlyphDataFreeBlocks;

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	for(ulIndex = 0; ulIndex < ulGlyphDataCount; ulIndex++)
	{
		abyGlyphDataFreeBlocks[ulIndex] = TRUE;
	}
}

FS_PRIVATE  ErrorCode fsg_AllocateGlyphDataMemory(
	uint32              ulGlyphDataCount,
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address      */
	GlyphData **        ppGlyphData)      /* GlyphData pointer    */
{
	uint32      ulIndex;
	boolean *   abyGlyphDataFreeBlocks;

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	ulIndex = 0;
	while((!abyGlyphDataFreeBlocks[ulIndex]) && ulIndex < ulGlyphDataCount)
	{
		ulIndex++;
	}

	if (ulIndex == ulGlyphDataCount)
	{
		return SFNT_RECURSIVE_COMPOSITE_ERR;
	}

	abyGlyphDataFreeBlocks[ulIndex] = FALSE;

	*ppGlyphData = (GlyphData *)&((GlyphData *)pWorkSpaceAddr->pvGlyphData)[ulIndex];
	return NO_ERR;
}

FS_PRIVATE void fsg_DeallocateGlyphDataMemory(
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address    */
	GlyphData *         pGlyphData)     /* GlyphData pointer    */
{
	ptrdiff_t   ptIndex;
	boolean *   abyGlyphDataFreeBlocks;

	pGlyphData->acIdent[0] = '\0';
	pGlyphData->acIdent[1] = '\0';

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	ptIndex = (ptrdiff_t)(pGlyphData - (GlyphData *)pWorkSpaceAddr->pvGlyphData);

	abyGlyphDataFreeBlocks[ptIndex] = TRUE;
}

FS_PRIVATE void fsg_InitializeGlyphData(
	GlyphData *             pGlyphData,     /* GlyphData pointer    */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	uint16                  usGlyphIndex,   /* Glyph Index          */
	uint16                  usDepth)        /* Glyph depth          */
{
	pGlyphData->acIdent[0] = 'G';
	pGlyphData->acIdent[1] = 'D';
	pGlyphData->pSibling = NULL;
	pGlyphData->pChild = NULL;
	pGlyphData->pParent = NULL;
	pGlyphData->GlyphType = glyphUndefined;
	pGlyphData->hGlyph.pvGlyphBaseAddress = NULL;
	pGlyphData->hGlyph.pvGlyphNextAddress = NULL;
	pGlyphData->usDepth = usDepth;
	pGlyphData->bUseMyMetrics = FALSE;
	pGlyphData->bScaleCompositeOffset = FALSE;
	pGlyphData->bUseChildMetrics = FALSE;
	pGlyphData->bbox.xMin = SHRT_MAX;
	pGlyphData->bbox.yMin = SHRT_MAX;
	pGlyphData->bbox.xMax = SHRT_MIN;
	pGlyphData->bbox.yMax = SHRT_MIN;
	pGlyphData->usSizeOfInstructions = 0;
	pGlyphData->pbyInstructions = NULL;
	pGlyphData->usNonScaledAW = 0;
	pGlyphData->sNonScaledLSB = 0;
	pGlyphData->MultiplexingIndicator = Undefined;
	pGlyphData->bRoundXYToGrid = FALSE;
	pGlyphData->usGlyphIndex = usGlyphIndex;
	pGlyphData->sXOffset = 0;
	pGlyphData->sYOffset = 0;
	pGlyphData->usAnchorPoint1 = 0;
	pGlyphData->usAnchorPoint2 = 0;
	pGlyphData->mulT = IdentTransform;
	pGlyphData->usScanType = SCANTYPE_UNINITIALIZED;
	pGlyphData->ptDevLSB.x = 0L;
	pGlyphData->ptDevLSB.y = 0L;
	pGlyphData->ptDevRSB.x = 0L;
	pGlyphData->ptDevRSB.y = 0L;
	pGlyphData->pGlyphElement = &pWorkSpaceAddr->pGlyphElement[usDepth];
	pGlyphData->pGlyphElement->nc = 0;
	pGlyphData->currentTMatrix = IdentTransform;
	pGlyphData->bSameTransformAsMaster = TRUE;
}

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void fsg_InitializeData (void)
{
	itrp_InitializeData ();
}
#endif

/* definitions and prototype for functions used in emboldening */

#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

#define LEFTSIDEBEARING 0
#define RIGHTSIDEBEARING 1

#define TOPSIDEBEARING 2
#define BOTTOMSIDEBEARING 3

#define LSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTSIDEBEARING)
#define RSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + RIGHTSIDEBEARING)

#define TOPSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPSIDEBEARING)
#define BOTTOMSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + BOTTOMSIDEBEARING)

#define POSINFINITY               0x7FFFFFFFUL

#define NotSameKnot(a,b) ((a).x != (b).x || (a).y != (b).y)

/* used by QDiv2 and FQuadraticEqn */
#define places16 16
#define half16 (1 << (places16-1))

#define F32Dot32 int64

#ifndef	Sgn
	#define Sgn(a)		((a) < 0 ? -1 : ((a) > 0 ? 1 : 0))
#endif

typedef struct F26Dot6VECTOR {
	F26Dot6 x;
	F26Dot6 y;
} F26Dot6VECTOR;

typedef struct { long x,y; } Vector;

typedef enum { linkBlack, linkGrey, linkWhite } LinkColor;

short ComputeSign(int32 DeltaPrevX, int32 DeltaPrevY, int32 DeltaNextX, int32 DeltaNextY);

int64 QDiv2(int64 a, int64 b);

void FQuadraticEqn(int64 a, int64 b, int64 c, long* solutions, int64* t1, int64* t2);

F32Dot32 FSqrt(uint64 radicand);

long CurveTransitions(Vector V0, Vector V1, Vector W0, Vector W1, Vector W2);

long CurveTransitionsSegment(Vector V0, Vector V1, Vector W0, Vector W1);

void CalculateXExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY);

void CalculateYExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY);

void SetLineToInfinity (int16 extremumNumber, Vector extremum, Vector* C0, Vector* C1);

void MinMax2Vectors (Vector A,Vector B,Vector *Min, Vector *Max);

void MinMax3Vectors (Vector A,Vector B,Vector C, Vector *Min, Vector *Max);

boolean CheckBoundingBoxCurve(Vector C0,Vector W0,Vector W1,Vector W2,int16 extremumNumber);

boolean CheckBoundingBoxSegment(Vector C0,Vector W0,Vector W1,int16 extremumNumber);

void NormalizeVector26Dot6 (F26Dot6VECTOR *pVect);

void Intersect26Dot6(F26Dot6VECTOR Pt1, F26Dot6VECTOR Pt2, F26Dot6VECTOR Pt3, F26Dot6VECTOR Pt4, F26Dot6VECTOR *ResultPt);

void  EmboldPoint(int32 iPt, int32 iPt1, 
                  boolean bUnderTheThreshold, boolean bMisoriented, 
				  F26Dot6VECTOR PrevPt, 
				  F26Dot6VECTOR CurrPt, 
				  F26Dot6VECTOR NextPt, 
				  F26Dot6 fxRightShift, F26Dot6 fxLeftShift, 
				  F26Dot6 fxTopShift, F26Dot6 fxBottomShift, 
				  F26Dot6	fxScaledDescender,
				  fnt_ElementType * pElement); 
 
boolean Misoriented(int32 contour, uint16 extremumNumber, short extremumKnot, Vector extremum, fnt_ElementType *pElement);

/* emboldening related code */

void NormalizeVector26Dot6 (F26Dot6VECTOR *pVect)
{
	VECTOR Vec;

	itrp_Normalize (pVect->x, pVect->y, &Vec);

	/* transform from ShortFract to 26.6 */
	pVect->x = Vec.x >> 8;
	pVect->y = Vec.y >> 8;	
}

void Intersect26Dot6(F26Dot6VECTOR Pt1, F26Dot6VECTOR Pt2, F26Dot6VECTOR Pt3, F26Dot6VECTOR Pt4, F26Dot6VECTOR *ResultPt)
{
	/* this procedure was inspired by itrp_ISECT */
	F26Dot6 N, D;
	F26Dot6VECTOR B, A;
	F26Dot6VECTOR dB, dA;

	  dA.x = Pt2.x - (A.x = Pt1.x);
	  dA.y = Pt2.y - (A.y = Pt1.y);

	  dB.x = Pt4.x - (B.x = Pt3.x);
	  dB.y = Pt4.y - (B.y = Pt3.y);

	  if (dA.y == 0) 
	  {
		if (dB.x == 0) 
		{
		  ResultPt->x = B.x;
		  ResultPt->y = A.y;
		  return;
		}
		N = B.y - A.y;
		D = -dB.y;
	  } 
	  else if (dA.x == 0) 
	  {
		if (dB.y == 0) 
		{
		  ResultPt->x = A.x;
		  ResultPt->y = B.y;
		  return;
		}
		N = B.x - A.x;
		D = -dB.x;
	  } 
	  else if (MABS (dA.x) >= MABS (dA.y))
	  {
/* To prevent out of range problems divide both N and D with the max */
		N = (B.y - A.y) - MulDiv26Dot6 (B.x - A.x, dA.y, dA.x);
		D = MulDiv26Dot6 (dB.x, dA.y, dA.x) - dB.y;
	  } 
	  else 
	  {
		N = MulDiv26Dot6 (B.y - A.y, dA.x, dA.y) - (B.x - A.x);
		D = dB.x - MulDiv26Dot6 (dB.y, dA.x, dA.y);
	  }

	  if (MABS(D) > 16) /* this test used to be D != 0 but for very small D we get degenerescence */
	  {
		ResultPt->x = B.x + (F26Dot6) MulDiv26Dot6 (dB.x, N, D);
		ResultPt->y = B.y + (F26Dot6) MulDiv26Dot6 (dB.y, N, D);
	  } 
	  else 
	  {
/* degenerate case: parallell lines, what make sence in this special case is to take the
		  middle point between Pt2 and Pt3 */
		ResultPt->x = (Pt2.x + Pt3.x) >> 1;
		ResultPt->y = (Pt2.y + Pt3.y) >> 1;
	  }

	
}

void  EmboldPoint(int32 iPt, int32 iPt1, 
                  boolean bUnderTheThreshold, boolean bMisoriented,
				  F26Dot6VECTOR PrevPt, 
				  F26Dot6VECTOR CurrPt, 
				  F26Dot6VECTOR NextPt, 
				  F26Dot6 fxRightShift, F26Dot6 fxLeftShift, 
				  F26Dot6 fxTopShift, F26Dot6 fxBottomShift, 
				  F26Dot6	fxScaledDescender,
				  fnt_ElementType * pElement) 


{
	F26Dot6VECTOR dPrev, dNext, Shift, CurrPt1,  NewPt, Delta ;
	F26Dot6 fxTemp;
    int32 i;

	dPrev.x = CurrPt.x - PrevPt.x;
	dPrev.y = CurrPt.y - PrevPt.y;

	dNext.x = NextPt.x - CurrPt.x;
	dNext.y = NextPt.y - CurrPt.y;

	/* compute the orthogonal vectors */

	fxTemp = dPrev.x;
	dPrev.x = -dPrev.y;
	dPrev.y = fxTemp;

	fxTemp = dNext.x;
	dNext.x = -dNext.y;
	dNext.y = fxTemp;

    if (bMisoriented)
    {
	    dPrev.x = -dPrev.x;
	    dPrev.y = -dPrev.y;
	    dNext.x = -dNext.x;
	    dNext.y = -dNext.y;
    }

    /* copy of the current point */

	CurrPt1 = CurrPt;

    if (bUnderTheThreshold)
    {
        /* most common case, we are just moving control points one pixel horizontally */

 	    if (dPrev.x > 0)
	    {
            CurrPt1.x += fxRightShift;
	    }
	    if (dNext.x > 0)
	    {
            CurrPt.x += fxRightShift;
	    }
    } else 
    {
        /* generalization, move along the vector normal to the curve */

	    /* normalize the vectors */
	    NormalizeVector26Dot6 (&dPrev);
	    NormalizeVector26Dot6 (&dNext);


        /* apply the shift on the previous segment */

	    /* Multiply the normalized vector by the shift factor */
	    if (dPrev.x > 0)
	    {
		    Shift.x = Mul26Dot6(dPrev.x, fxRightShift);
	    } else {
		    Shift.x = Mul26Dot6(dPrev.x, fxLeftShift);
	    }

	    if (dPrev.y < 0)
	    {
		    Shift.y = Mul26Dot6(dPrev.y, fxBottomShift);
	    } else {
		    Shift.y = Mul26Dot6(dPrev.y, fxTopShift);
	    }

	    PrevPt.x += Shift.x;
	    PrevPt.y += Shift.y;

	    CurrPt1.x += Shift.x;
	    CurrPt1.y += Shift.y;

	    /* second segment */

	    /* Multiply the normalized vector by the shift factor */
	    if (dNext.x > 0)
	    {
		    Shift.x = Mul26Dot6(dNext.x, fxRightShift);
	    } else {
		    Shift.x = Mul26Dot6(dNext.x, fxLeftShift);
	    }

	    if (dNext.y < 0)
	    {
		    Shift.y = Mul26Dot6(dNext.y, fxBottomShift);
	    } else {
		    Shift.y = Mul26Dot6(dNext.y, fxTopShift);
	    }

	    NextPt.x += Shift.x;
	    NextPt.y += Shift.y;

	    CurrPt.x += Shift.x;
	    CurrPt.y += Shift.y;
    }

	if (CurrPt1.x == CurrPt.x && CurrPt1.y == CurrPt.y)
	{
		/* both points were moved by the same value, no need to intersect */
		pElement->x[iPt] = CurrPt.x;
		pElement->y[iPt] = CurrPt.y;
	} else
	{
	/* we need to reintersect */
		Intersect26Dot6(PrevPt, CurrPt1, CurrPt, NextPt, &NewPt);

		/* sanity check that we are not moving the point too far from it's original position,
			this happen at low ppem size when segment lenght get small compared to the shift 
			or when hinting caused outline overlapp */
		Delta.x = NewPt.x - pElement->x[iPt];
		Delta.y = NewPt.y - pElement->y[iPt];

		if (Delta.x > fxRightShift)
		{
			NewPt.x = pElement->x[iPt] + fxRightShift;
		}
		if (Delta.x < -fxLeftShift)
		{
			NewPt.x = pElement->x[iPt] - fxLeftShift;
		}
		if (Delta.y < -fxBottomShift)
		{
			NewPt.y = pElement->y[iPt] - fxBottomShift;
		} 
		if (Delta.y > fxTopShift)
		{
			NewPt.y = pElement->y[iPt] + fxBottomShift;
		} 

		pElement->x[iPt] = NewPt.x;
		pElement->y[iPt] = NewPt.y;

	}
	/* shift all points by fxLeftShift, fxTopShift */
	pElement->x[iPt] += fxLeftShift;
	pElement->y[iPt] += fxBottomShift;

	if (pElement->y[iPt] < fxScaledDescender)
	{
		/* clipping to prevent going below the descender and causing out of bounds problems */
		pElement->y[iPt] = fxScaledDescender;
	}

    if (iPt != iPt1)
    {
        /* duplicate points at the same coordinate, we need to move them all */
	    for(i= iPt + 1; i <= iPt1; i++)
        {
	        pElement->x[i] = pElement->x[iPt];
	        pElement->y[i] = pElement->y[iPt];
        }
    }

}

FS_PRIVATE void  fsg_Embold(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvGlobalGS,
	boolean             bUseHints, /* True if glyph is gridfitted       */
	boolean             bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
	fnt_ElementType *pElement;
	fnt_GlobalGraphicStateType *globalGS;
	int32 iContour, iPt, iPt1, iStartPt, iEndPt;
	F26Dot6VECTOR FirstPt, PrevPt, NextPt, CurrPt;
	F26Dot6 fxRightShift, fxLeftShift; 
	F26Dot6 fxTopShift, fxBottomShift; 
    boolean bUnderTheThreshold;
    boolean bMisoriented;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	pElement = pWorkSpaceAddr->pGlyphElement;

    bUnderTheThreshold = (globalGS->uBoldSimulHorShift == 1);

#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
    {
        bUnderTheThreshold = (globalGS->uBoldSimulHorShift <= HINTING_HOR_OVERSCALE);
    }
#endif // FSCFG_SUBPIXEL

	/* adjust the right sidebearing */
    if (pElement->x[RSBPOINTNUM(pElement)] != pElement->x[LSBPOINTNUM(pElement)]) 
        /* we don't increase the width of a zero width glyph, problem with indic script */
    {
#ifdef FSCFG_SUBPIXEL
	    if (bSubPixel)
        {
    	    pElement->x[RSBPOINTNUM(pElement)] += ( ( 1 / HINTING_HOR_OVERSCALE) << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
        } else {
#endif // FSCFG_SUBPIXEL
			pElement->x[RSBPOINTNUM(pElement)] += (1 << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
#ifdef FSCFG_SUBPIXEL
        }
#endif // FSCFG_SUBPIXEL
    }

	/* adjust the bottom sidebearing, this is done by the value of the HorShift and not the VertShift for backwards compatibility
	   in vertical writing */
    if (pElement->y[BOTTOMSBPOINTNUM(pElement)] != pElement->y[TOPSBPOINTNUM(pElement)])
        /* we don't increase the width of a zero width glyph, problem with indic script */
    {
    	pElement->y[BOTTOMSBPOINTNUM(pElement)] -= (1 << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
    }

	if (!bBitmapEmboldening)
	{    

		if (bUseHints)
		{
			/* to preserve the hinting, we should move by an integer amount of pixel */
			/* divide by 2, round to pixel, convert to 26.6 */
#ifdef FSCFG_SUBPIXEL
	        if (bSubPixel)
            {
			    fxLeftShift = ((globalGS->uBoldSimulHorShift /HINTING_HOR_OVERSCALE) >> 1) * HINTING_HOR_OVERSCALE; 
			    fxRightShift = (globalGS->uBoldSimulHorShift - fxLeftShift) << 6;
			    fxLeftShift = fxLeftShift << 6; 
            } else {
#endif // FSCFG_SUBPIXEL
			    fxLeftShift = globalGS->uBoldSimulHorShift >> 1; 
			    fxRightShift = (globalGS->uBoldSimulHorShift - fxLeftShift) << 6;
			    fxLeftShift = fxLeftShift << 6; 
#ifdef FSCFG_SUBPIXEL
            }
#endif // FSCFG_SUBPIXEL
			fxTopShift = globalGS->uBoldSimulVertShift >> 1;
			fxBottomShift = (globalGS->uBoldSimulVertShift - fxTopShift) << 6;
			fxTopShift = fxTopShift << 6;
		} else {
			/* divide by 2, convert to 26.6 */
			fxRightShift = globalGS->uBoldSimulHorShift << 5;
			fxLeftShift = globalGS->uBoldSimulHorShift << 5; 
			fxTopShift = globalGS->uBoldSimulVertShift << 5;
			fxBottomShift = globalGS->uBoldSimulVertShift << 5;
		}

		for (iContour = 0; iContour < pElement->nc; iContour++)
		{
			iStartPt = pElement->sp[iContour];
			iEndPt = pElement->ep[iContour];

			if (iEndPt - iStartPt >= 2)
			/* contour with less than 3 points cannot be emboldened */
			{
                bMisoriented = FALSE;
                if (pElement->fc[iContour] & OUTLINE_MISORIENTED)
                {
                    bMisoriented = TRUE;
                }
				/* we need to save the original coordinate of the first point for the computation of the last point */
				/* to compute the new coordinate for a point, we need the original coordinate of the point, the previous point
				  and the next point */

				FirstPt.x = pElement->x[iStartPt];
				FirstPt.y = pElement->y[iStartPt];

				CurrPt = FirstPt;

				PrevPt.x = pElement->x[iEndPt];
				PrevPt.y = pElement->y[iEndPt];

				NextPt.x = pElement->x[iStartPt+1];
				NextPt.y = pElement->y[iStartPt+1];

				iPt = iStartPt;

				while (iPt <= iEndPt)
				{
					iPt1 = iPt;

					/* deal with the special case of two points at the same coordinate, current and next */
					while ((NextPt.x == CurrPt.x) && (NextPt.y == CurrPt.y) && (iPt1 < iEndPt))
					{
						iPt1++;

						 if (iPt1 >= iEndPt)
							 /* the >= is to avoid goind out of bounds when preparing Prev, Next, Curr at the last step */
						{
							NextPt.x = FirstPt.x;
							NextPt.y = FirstPt.y;
						} else {
							NextPt.x = pElement->x[iPt1 +1];
							NextPt.y = pElement->y[iPt1 +1];
						}
					}

					/* we do the computation for the current point */

					EmboldPoint(iPt, iPt1, bUnderTheThreshold, bMisoriented, PrevPt, CurrPt, NextPt, 
							fxRightShift, fxLeftShift, fxTopShift, fxBottomShift, globalGS->fxScaledDescender, pElement); 
                
					iPt = iPt1;

					iPt++;
					/* we compute Prev, Next, Curr coordinate for the next point */

					PrevPt = CurrPt;

					CurrPt = NextPt;

					 if (iPt >= iEndPt)
						 /* the >= is to avoid goind out of bounds when preparing Prev, Next, Curr at the last step */
					{
						NextPt.x = FirstPt.x;
						NextPt.y = FirstPt.y;
					} else {
						NextPt.x = pElement->x[iPt +1];
						NextPt.y = pElement->y[iPt +1];
					}
				}
			}
		}
    }
}

short ComputeSign(int32 DeltaPrevX, int32 DeltaPrevY, int32 DeltaNextX, int32 DeltaNextY)
{
    int32 sgn;

	/* as our coordinates are in desing unit, they fit in 16 bits and we are not overflowing here */

    sgn = DeltaPrevX*DeltaNextY - DeltaPrevY*DeltaNextX;
	return (short)Sgn(sgn); // +1 => left turn, -1 => right turn, 0 => straight
}

Vector AddV(const Vector a, const Vector b) {
	Vector c;
	
	c.x = a.x + b.x;
	c.y = a.y + b.y;
	return c;
} // AddV

Vector SubV(const Vector a, const Vector b) {
	Vector c;
	
	c.x = a.x - b.x;
	c.y = a.y - b.y;
	return c;
} // SubV

Vector ShlV(const Vector a, long by) {
	Vector b;
	
	b.x = a.x << by;
	b.y = a.y << by;
	return b;
} // ShlV

Vector ShrV(const Vector a, long by) {
	Vector b;
	
	b.x = a.x >> by;
	b.y = a.y >> by;
	return b;
} // ShrV

int64 QDiv2(int64 a, int64 b) { // special version that replaces epsilons by 1, which is actually 1/65536 since we're actually returning F48Dot16
	int64 q;

	if (a < 0 != b < 0) {
		if (a < 0) a = -a; else b = -b;
		if (a < b) q = -1; else if (a > b << places16) q = -65536-1; else q = -((a + (b >> 1))/b);
	} else {
		if (a < 0) a = -a, b = -b;
		if (a < b) q = 1; else if (a > b << places16) q = 65536+1; else q = (a + (b >> 1))/b;
	}
	return q;
} // QDiv2

F32Dot32 FSqrt(uint64 radicand) {
	uint64 bit,root,s;

	root = 0;
	for (bit = (uint64)1 << 62; bit >= 0x8000 /* we don't need the last 16 bits */; bit >>= 1) {
		s = bit + root;
		if (s <= radicand) {
			radicand -= s;
			root |= (bit << 1);
		};
		radicand <<= 1;
	}
	return root;
} // FSqrt

void FQuadraticEqn(int64 a, int64 b, int64 c, long* solutions, int64* t1, int64* t2) {
	// the usual method for solving quadratic equations
	// input is actually in 32bit, output is F48Dot16
	int64 radicand,root,b1,b2,c1;
	
	*solutions = 0;
	if (a == 0) {
		if (b != 0) {
			*solutions = 1;
			c1 = -(c << places16);
			*t1 = QDiv2(c1,b);
		} // else b == 0, no solutions
	} else {
		a *= 2;
		radicand = b*b - 2*a*c;
		if (radicand > 0) {
			*solutions = 2;

            root = (FSqrt(radicand) + half16) >> places16;
            b <<= places16;

			b1 = -(b - root);
			b2 = -(b + root);
			*t1 = QDiv2(b1,a);
			*t2 = QDiv2(b2,a);
		} else if (radicand == 0) {
			*solutions = 1;
			b1 = -(b << places16);
			*t1 = QDiv2(b1,a);
		} // else radicand < 0, no solutions
	}
} // FQuadraticEqn

long CurveTransitionsSegment(Vector V0, Vector V1, Vector W0, Vector W1) {

//	here we're intersecting a straight line (W0, W1) with a straight line (V0, V1).
//	for the two to intersect, and writing both intersectees in standard polynomial form, there must be parameters u and v such that
//
//		A.x*u + B.x = C.x*v + D.x
//		A.y*u + B.y = C.y*v + D.y
//
//	a system of two "halfway" linear eqns. in two unknowns u and v
//	solving the first eqn. for v (which is linear in v, hence the "halfway") yields
//
//		v = (A.x*u + B.x - D.x)/C.x
//
//	substituting v into the second eqn. yields
//
//		A.y*u + B.y - D.y = C.y*(A.x*u + B.x - D.x)/C.x
//
//	rearranging terms by powers of u and multiplying by D.x yields
//
//		(A.y*C.x - C.y*A.x)*u + B.y*C.x - D.y*C.x + C.y*D.x - C.y*B.x = 0
//
//	which is a single linear eqn. in u with 0 thru 1 solutions obtained "the usual way".
//	solutions must be in the interval ]0,1] to make sure we only accept intersections of the actual segment
//	and we don't count start/end points twice by including them in adjacent segments as well (cf. also ColorTransitions above)

	Vector A,B,C,D;
    int64 a, b;
	long transitions;
	int64 u,vd;

//	re-write Line in polynomial form
//	(W1 - W0)*u + W0, which follows immediately from the "first degree" Bzier "curve" W0*(1-u) + W1*u
	A = SubV(W1,W0);
	B = W0;


//	re-write Line in polynomial form
//	(V1 - V0)*v + V0, which follows immediately from the "first degree" Bzier "curve" V0*(1-u) + V1*u
	C = SubV(V1,V0);
	D = V0;

    a = (A.y*C.x - C.y*A.x);

	transitions = 0;

    if (a != 0)
    {
        b = B.y*C.x - D.y*C.x + C.y*D.x - C.y*B.x;

    //  a*u + b = 0 => u = -b / a

	    b = -b << places16;
	    u = QDiv2(b,a); /* u stored in 48.16 */
	    
	    if (0 < u && u <= 0x10000) {
                /* to avoid loss of precision, select in which equation to replace the value of u[] */
            if (MABS(C.x) > MABS(C.y))
            {
			    vd = ((int64)A.x)*u  + ((int64)(B.x - D.x))*0x10000; // avoid division by 0 => multiply by C.x
		    //	transitions += 0 < vd && vd <= Abs(C.x);
			    if (C.x >= 0) {
				    if (0 < vd && vd <= ((int64)C.x)*0x10000) transitions++;
			    } else {
				    if (((int64)C.x)*0x10000 <= vd && vd < 0) transitions++;
			    }
            } else {
			    vd = ((int64)A.y)*u  + ((int64)(B.y - D.y))*0x10000; // avoid division by 0 => multiply by C.y
		    //	transitions += 0 < vd && vd <= Abs(C.y);
			    if (C.y >= 0) {
				    if (0 < vd && vd <= ((int64)C.y)*0x10000) transitions++;
			    } else {
				    if (((int64)C.y)*0x10000 <= vd && vd < 0) transitions++;
			    }
            }
	    }
    }

	return transitions;
} // CurveTransitionsSegment

long CurveTransitions(Vector V0, Vector V1, Vector W0, Vector W1, Vector W2) {

//	here we're intersecting a quadratic Bzier curve (W0, W1, W2) with a straight line (V0, V1).
//	for the two to intersect, and writing both intersectees in standard polynomial form, there must be parameters u and v such that
//
//		A.x*u^2 + B.x*u + C.x = D.x*v + E.x
//		A.y*u^2 + B.y*u + C.y = D.y*v + E.y
//
//	a system of two "halfway" quadratic eqns. in two unknowns u and v
//	solving the first eqn. for v (which is linear in v, hence the "halfway") yields
//
//		v = (A.x*u^2 + B.x*u + C.x - E.x)/D.x
//
//	substituting v into the second eqn. yields
//
//		A.y*u^2 + B.y*u + C.y - E.y = D.y*(A.x*u^2 + B.x*u + C.x - E.x)/D.x
//
//	rearranging terms by powers of u and multiplying by D.x yields
//
//		(A.y*D.x - D.y*A.x)*u^2 + (B.y*D.x - D.y*B.x)*u + C.y*D.x - D.y*C.x - E.y*D.x + D.y*E.x = 0
//
//	which is a single quadratic eqn. in u with 0 thru 2 solutions obtained "the usual way".
//	solutions must be in the interval ]0,1] to make sure we only accept intersections of the actual Bzier segment
//	and we don't count start/end points twice by including them in adjacent Bzier segments as well (cf. also ColorTransitions above)

	Vector A,B,C,D,E;
	long i,solutions,transitions;
	int64 u[2],vd;

//	re-write Bzier curve in polynomial form
//	W0*(1-u)^2 + 2*W1*(1-u)*u + W2*u^2 = W0*(1 - 2*u + u^2) + 2*W1*(u - u^2) + W2*u^2 = 
//	(W0 - 2*W1 + W2)*u^2 + 2*(W1 - W0)*u + W0
	A = AddV(SubV(W0,ShlV(W1,1)),W2);
	B = ShlV(SubV(W1,W0),1);
	C = W0;

//	re-write Line in polynomial form
//	(V1 - V0)*v + V0, which follows immediately from the "first degree" Bzier "curve" V0*(1-u) + V1*u
	D = SubV(V1,V0);
	E = V0;

	FQuadraticEqn(A.y*D.x - D.y*A.x,B.y*D.x - D.y*B.x,C.y*D.x - D.y*C.x - E.y*D.x + D.y*E.x,&solutions,&u[0],&u[1]);
	
	transitions = 0;
	for (i = 0; i < solutions; i++) {
		if (0 < u[i] && u[i] <= 0x10000) {
            /* to avoid loss of precision, select in which equation to replace the value of u[] */
            if (MABS(D.x) > MABS(D.y))
            {
			    vd = ((int64)A.x)*u[i]*u[i] + ((int64)B.x)*u[i]*0x10000 + ((int64)(C.x - E.x))*0x100000000; // avoid division by 0 => multiply by D.x
		    //	transitions += 0 < vd && vd <= Abs(D.x);
			    if (D.x >= 0) {
				    if (0 < vd && vd <= ((int64)D.x)*0x100000000) transitions++;
			    } else {
				    if (((int64)D.x)*0x100000000 <= vd && vd < 0) transitions++;
			    }
            } else {
			    vd = ((int64)A.y)*u[i]*u[i] + ((int64)B.y)*u[i]*0x10000 + ((int64)(C.y - E.y))*0x100000000; // avoid division by 0 => multiply by D.y
		    //	transitions += 0 < vd && vd <= Abs(D.y);
			    if (D.y >= 0) {
				    if (0 < vd && vd <= ((int64)D.y)*0x100000000) transitions++;
			    } else {
				    if (((int64)D.y)*0x100000000 <= vd && vd < 0) transitions++;
			    }
            }
		}
	}


	return transitions;
} // CurveTransitions

boolean CheckBoundingBoxCurve(Vector C0,Vector W0,Vector W1,Vector W2,int16 extremumNumber)
{
    Vector Min, Max;

    /* the curve is completely conatined in the triangle W0,W1,W2 */
    MinMax3Vectors (W0, W1, W2, &Min, &Max);

	switch (extremumNumber)
	{
	case 0:
        /* look for Min X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Min.x <= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 1:
        /* look for Max X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Max.x >= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 2:
        /* look for Min Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Min.y <= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 3:
        /* look for Max Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Max.y >= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, CheckBoundingBoxCurve, illegal case");
        return TRUE;
    }

}

boolean CheckBoundingBoxSegment(Vector C0,Vector W0,Vector W1, int16 extremumNumber)
{
    Vector Min, Max;

    MinMax2Vectors (W0, W1, &Min, &Max);

	switch (extremumNumber)
	{
	case 0:
        /* look for Min X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Min.x <= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 1:
        /* look for Max X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Max.x >= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 2:
        /* look for Min Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Min.y <= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 3:
        /* look for Max Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Max.y >= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, CheckBoundingBoxSegment, illegal case");
        return TRUE;
    }

}

void CalculateXExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY) {
	int64 uNum,u1Num,uDen2,xNum,yNum; // use int64 to avoid 32 bit integer overflow...
    int64 uDen = 0;

    if (V0On) {
		V0X = V0X << 1;
		V0Y = V0Y << 1;
	} else { // both V0 and V1 are off-curve points, hence calc implied on-curve point
		V0X = V0X + V1X;
		V0Y = V0Y + V1Y;
	}
	if (V2On) {
		V2X = V2X << 1;
		V2Y = V2Y << 1;
	} else { // both V2 and V1 are off-curve points, hence calc implied on-curve point
		V2X = V2X + V1X;
		V2Y = V2Y + V1Y;
	}
	V1X = V1X << 1;
	V1Y = V1Y << 1;
	// at this point we have a quadratic bezier curve V0*(1-u)^2 + 2*V1*(1-u)*u + V2*u^2,
	// with all its control points scaled by 2 to avoid precision loss upon calculating the implied on-curve point
	// its first derivative (with respect to u) is 2*(V0 - 2*V1 + V2)*u + 2*(V1 - V0),
	// which is zero for u = (V0 - V1)/(V0 - 2*V1 + V2)
	// likewise, for 1 - u = (V2 - V1)/(V0 - 2*V1 + V2)
	uDen = V0X - 2*V1X + V2X;
	if (uDen != 0) { // put that back into the eqn. of the quadratic bezier curve
		uNum = V0X - V1X;
		u1Num = V2X - V1X;
		uDen2 = uDen*uDen;
		xNum = V0X*u1Num*u1Num + 2*V1X*u1Num*uNum + V2X*uNum*uNum;
		yNum = V0Y*u1Num*u1Num + 2*V1Y*u1Num*uNum + V2Y*uNum*uNum;
	//	if we're calculating the left extremal point, we floor the result for the probing line
	//	not to start inside the contour as a result of rounding. Starting on the contour should be fine,
	//	as this is handled in CurveTransitions, which does not include the lower end of the interval.
		*extrX = min ? (long)(xNum/uDen2) : (long)((xNum + uDen2 - 1)/uDen2);
	//	symmetrical rounding here
		*extrY = yNum >= 0 ? (long)((yNum + uDen2)/uDen2) : -(long)((uDen2 - yNum)/uDen2);
	} else { // can't solve it
		*extrX = V1X;
		*extrY = V1Y;
	}
} // CalculateXExtremum

void CalculateYExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY) {
	int64 uNum,u1Num,uDen2,xNum,yNum; // use int64 to avoid 32 bit integer overflow...
    int64 uDen = 0;

    if (V0On) {
		V0X = V0X << 1;
		V0Y = V0Y << 1;
	} else { // both V0 and V1 are off-curve points, hence calc implied on-curve point
		V0X = V0X + V1X;
		V0Y = V0Y + V1Y;
	}
	if (V2On) {
		V2X = V2X << 1;
		V2Y = V2Y << 1;
	} else { // both V2 and V1 are off-curve points, hence calc implied on-curve point
		V2X = V2X + V1X;
		V2Y = V2Y + V1Y;
	}
	V1X = V1X << 1;
	V1Y = V1Y << 1;
	// at this point we have a quadratic bezier curve V0*(1-u)^2 + 2*V1*(1-u)*u + V2*u^2,
	// with all its control points scaled by 2 to avoid precision loss upon calculating the implied on-curve point
	// its first derivative (with respect to u) is 2*(V0 - 2*V1 + V2)*u + 2*(V1 - V0),
	// which is zero for u = (V0 - V1)/(V0 - 2*V1 + V2)
	// likewise, for 1 - u = (V2 - V1)/(V0 - 2*V1 + V2)
	uDen = V0Y - 2*V1Y + V2Y;
	if (uDen != 0) { // put that back into the eqn. of the quadratic bezier curve
		uNum = V0Y - V1Y;
		u1Num = V2Y - V1Y;
		uDen2 = uDen*uDen;
		xNum = V0X*u1Num*u1Num + 2*V1X*u1Num*uNum + V2X*uNum*uNum;
		yNum = V0Y*u1Num*u1Num + 2*V1Y*u1Num*uNum + V2Y*uNum*uNum;

        *extrY = min ? (long)(yNum/uDen2) : (long)((yNum + uDen2 - 1)/uDen2);
	//	symmetrical rounding here
		*extrX = xNum >= 0 ? (long)((xNum + uDen2)/uDen2) : -(long)((uDen2 - xNum)/uDen2);
	} else { // can't solve it
		*extrX = V1X;
		*extrY = V1Y;
	}
} // CalculateYExtremum

void SetLineToInfinity (int16 extremumNumber, Vector extremum, Vector* C0, Vector* C1)
{
/* extremumKnot = 0 : MinX
   extremumKnot = 1 : MaxX
   extremumKnot = 2 : MinY
   extremumKnot = 3 : MaxY,
    the coordinates returned in C0 and C1 are scaled by 2 */

    switch (extremumNumber) {
	case 0:
        /* line from minX to infinity */
	    C0->x = extremum.x+1;
	    C0->y = extremum.y;
	    C1->x = -32768;
	    C1->y = C0->y-1; // and make sure color transition test line does not align with any straight line in the glyph...
        break;
	case 1:
        /* line from maxX to infinity */
	    C0->x = extremum.x-1;
	    C0->y = extremum.y;
	    C1->x = 32767;
	    C1->y = C0->y-1; // and make sure color transition test line does not align with any straight line in the glyph...
        break;
	case 2:
        /* line from minY to infinity */
	    C0->x = extremum.x;
	    C0->y = extremum.y+1;
	    C1->x = C0->x-1; // and make sure color transition test line does not align with any straight line in the glyph...     
	    C1->y = -32768;
        break;
	case 3:
        /* line from maxY to infinity */
	    C0->x = extremum.x;
	    C0->y = extremum.y-1;
	    C1->x = C0->x-1; // and make sure color transition test line does not align with any straight line in the glyph...     
	    C1->y = 32767;
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, FindExtremaKnot, illegal case");
    }
}

void MinMax3Vectors (Vector A,Vector B,Vector C, Vector *Min, Vector *Max)
{
    *Min = A;
    if (B.x < Min->x) Min->x = B.x;
    if (C.x < Min->x) Min->x = C.x;
    if (B.y < Min->y) Min->y = B.y;
    if (C.y < Min->y) Min->y = C.y;
    *Max = A;
    if (B.x > Max->x) Max->x = B.x;
    if (C.x > Max->x) Max->x = C.x;
    if (B.y > Max->y) Max->y = B.y;
    if (C.y > Max->y) Max->y = C.y;
}

void MinMax2Vectors (Vector A,Vector B, Vector *Min, Vector *Max)
{
    *Min = A;
    if (B.x < Min->x) Min->x = B.x;
    if (B.y < Min->y) Min->y = B.y;
    *Max = A;
    if (B.x > Max->x) Max->x = B.x;
    if (B.y > Max->y) Max->y = B.y;
}

void fsg_CheckOutlineOrientation (fnt_ElementType *pElement)
{
    int32 Contour;
    boolean bMisoriented;
    short knot, n, i, start, end, predKnot, succKnot;
    short extremumKnot[4];
	Vector extremum[4];
    long minX, maxX, minY, maxY;
    long distance0_1, distance0_2, distance0_3;
    uint16 extremaNumber2, extremaNumber3;

    for (Contour = 0; Contour < pElement->nc; Contour++)
	{
        pElement->fc[Contour] = 0;

        start = pElement->sp[Contour];
        end = pElement->ep[Contour];
        
        n = end - start + 1;

        if (n > 2) 
        {
            /* we are not interested in degenerated contours */

            /* look for exterma knots to decide which direction to look to increase our chance of getting the correct result even on bad fonts */

            /* we will look for the following extrema :
               extremumKnot = 0 : MinX
               extremumKnot = 1 : MaxX
               extremumKnot = 2 : MinY
               extremumKnot = 3 : MaxY */

            for (i = 0; i < 4; i++) extremumKnot[i] = -1;
            
            minX = minY = 0x7fffffff;
    	    maxX = maxY = 0x80000000;

	        for (knot = 0; knot < n; knot++) {
                /* look for Min X */
		        if (pElement->oox[start + knot] < minX || 
			        pElement->oox[start + knot] == minX && !pElement->onCurve[extremumKnot[0]] ||  // try to get an on-curve point at same x coord
			        pElement->oox[start + knot] == minX && pElement->onCurve[extremumKnot[0]] && pElement->onCurve[start + knot] && pElement->ooy[start + knot] < pElement->ooy[extremumKnot[0]]) {
					extremumKnot[0] = start + knot;
					minX = pElement->oox[extremumKnot[0]];
					if (pElement->onCurve[extremumKnot[0]]) {
						extremum[0].x = pElement->oox[extremumKnot[0]] << 1;
						extremum[0].y = pElement->ooy[extremumKnot[0]] << 1;
					} else {
						predKnot = extremumKnot[0] == start ? end : extremumKnot[0] - 1;
						succKnot = extremumKnot[0] == end ? start : extremumKnot[0] + 1;
						CalculateXExtremum(true,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[0]],pElement->ooy[extremumKnot[0]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[0].x,&extremum[0].y);
					}
				}
                /* look for Max X */
		        if (pElement->oox[start + knot] > maxX || 
			        pElement->oox[start + knot] == maxX && !pElement->onCurve[extremumKnot[1]] ||  // try to get an on-curve point at same x coord
			        pElement->oox[start + knot] == maxX && pElement->onCurve[extremumKnot[1]] && pElement->onCurve[start + knot] && pElement->ooy[start + knot] > pElement->ooy[extremumKnot[1]]) {
					extremumKnot[1] = start + knot;
					maxX = pElement->oox[extremumKnot[1]];
					if (pElement->onCurve[extremumKnot[1]]) {
						extremum[1].x = pElement->oox[extremumKnot[1]] << 1;
						extremum[1].y = pElement->ooy[extremumKnot[1]] << 1;
					} else {
						predKnot = extremumKnot[1] == start ? end : extremumKnot[1] - 1;
						succKnot = extremumKnot[1] == end ? start : extremumKnot[1] + 1;
						CalculateXExtremum(false,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[1]],pElement->ooy[extremumKnot[1]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[1].x,&extremum[1].y);
		        		}
				}
                /* look for Min Y */
		        if (pElement->ooy[start + knot] < minY || 
			        pElement->ooy[start + knot] == minY && !pElement->onCurve[extremumKnot[2]] ||  // try to get an on-curve point at same y coord
			        pElement->ooy[start + knot] == minY && pElement->onCurve[extremumKnot[2]] && pElement->onCurve[start + knot] && pElement->oox[start + knot] > pElement->oox[extremumKnot[2]]) {
					extremumKnot[2] = start + knot;
					minY = pElement->ooy[extremumKnot[2]];
					if (pElement->onCurve[extremumKnot[2]]) {
						extremum[2].x = pElement->oox[extremumKnot[2]] << 1;
						extremum[2].y = pElement->ooy[extremumKnot[2]] << 1;
					} else {
						predKnot = extremumKnot[2] == start ? end : extremumKnot[2] - 1;
						succKnot = extremumKnot[2] == end ? start : extremumKnot[2] + 1;
						CalculateYExtremum(true,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[2]],pElement->ooy[extremumKnot[2]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[2].x,&extremum[2].y);
					}
				}
                /* look for Max Y */
		        if (pElement->ooy[start + knot] > maxY || 
			        pElement->ooy[start + knot] == maxY && !pElement->onCurve[extremumKnot[3]] ||  // try to get an on-curve point at same y coord
			        pElement->ooy[start + knot] == maxY && pElement->onCurve[extremumKnot[3]] && pElement->onCurve[start + knot] && pElement->oox[start + knot] < pElement->oox[extremumKnot[3]]) {
					extremumKnot[3] = start + knot;
					maxY = pElement->ooy[extremumKnot[3]];
					if (pElement->onCurve[extremumKnot[3]]) {
						extremum[3].x = pElement->oox[extremumKnot[3]] << 1;
						extremum[3].y = pElement->ooy[extremumKnot[3]] << 1;
					} else {
						predKnot = extremumKnot[3] == start ? end : extremumKnot[3] - 1;
						succKnot = extremumKnot[3] == end ? start : extremumKnot[3] + 1;
						CalculateYExtremum(false,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[3]],pElement->ooy[extremumKnot[3]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[3].x,&extremum[3].y);
					}
				}
	        }

            /* diagonal distance, we don't need a precise distance */

            distance0_1 = MABS(pElement->oox[extremumKnot[1]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[1]] - pElement->ooy[extremumKnot[0]]);
            distance0_2 = MABS(pElement->oox[extremumKnot[2]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[2]] - pElement->ooy[extremumKnot[0]]);
            distance0_3 = MABS(pElement->oox[extremumKnot[3]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[3]] - pElement->ooy[extremumKnot[0]]);

            if (distance0_2 > distance0_3)
            {
                /* we will look at MinY */
                extremaNumber2 = 2;
                if (distance0_3 > distance0_1)
                {
                    /* we will look then at MaxY */
                    extremaNumber3 = 3;
                } else {
                    /* we will look then at MaxX */
                    extremaNumber3 = 1;
                }
            } else {
                /* we will look at MaxY */
                extremaNumber2 = 3;
                if (distance0_2 > distance0_1)
                {
                    /* we will look then at MinY */
                    extremaNumber3 = 2;
                } else {
                    /* we will look then at MaxX */
                    extremaNumber3 = 1;
                }
            }

            bMisoriented = Misoriented(Contour, 0 /* MinX */, extremumKnot[0], extremum[0], pElement);

            /* look in a second direction to check if same result 
               this additional work help weed out problems with bad fonts having self-intersecting
               or overlapping outlines */
            if (bMisoriented != Misoriented(Contour, extremaNumber2, extremumKnot[extremaNumber2], extremum[extremaNumber2], pElement))
            {
                /* we need to look in a third direction */
                bMisoriented = Misoriented(Contour, extremaNumber3, extremumKnot[extremaNumber3], extremum[extremaNumber3], pElement);
            }

                // at this point we store the orientation of the original component (original in the sense of before the composite code potentially
                // applies a mirroring), such that the concertina code can work on the component w/o having to know about composite transformations
                if (bMisoriented) pElement->fc[Contour] |= OUTLINE_MISORIENTED;
        }
    }
}

boolean Misoriented(int32 contour, uint16 extremumNumber, short extremumKnot, Vector extremum, fnt_ElementType *pElement)
/* we will check the coutour orientation at the following extrema :
   extremumKnot = 0 : MinX
   extremumKnot = 1 : MaxX
   extremumKnot = 2 : MinY
   extremumKnot = 3 : MaxY */

{
	LinkColor color,orientation;
	short predKnot,cont,knot,start,iter,end,n;
	long parity;
	Vector V[3],D[2],C[2],W[3],Wi;
	boolean on[3];

    short dirChange = 0;      
    
	start = pElement->sp[contour];
	end = pElement->ep[contour];
	n = end - start + 1;

	// here we determine the straight line that runs from the extreme of the contour to infinity, to be used below.
    SetLineToInfinity(extremumNumber, extremum, &C[0], &C[1]);
	
	// find out the current orientation of the contour
	// to do so first determine what kinds of turns we make at each knot
	orientation = linkBlack; // assume as default

    knot = extremumKnot - start;
    predKnot = (knot+n-1)%n;

    V[0].x = pElement->oox[start+predKnot]; V[1].x = pElement->oox[start+knot];
	V[0].y = pElement->ooy[start+predKnot]; V[1].y = pElement->ooy[start+knot];
	D[0] = SubV(V[1],V[0]);
	for (iter = 0; iter < n && !dirChange; iter++) {
		V[2].x = pElement->oox[start + (knot + 1)%n];
		V[2].y = pElement->ooy[start + (knot + 1)%n];
		if (NotSameKnot(V[1],V[2])) {
    		D[1] = SubV(V[2],V[1]);
		    dirChange = ComputeSign(D[0].x, D[0].y, D[1].x, D[1].y);
		    V[0] = V[1]; V[1] = V[2]; D[0] = D[1];
        }
        knot = (knot + 1)%n;
	}

    if (iter < n && dirChange > 0)
    {
        orientation = linkWhite; /* counter clockwise */
    }
	
	// now find out what the orientation of the contour should really be
	// to do so we intersect the above probing line with all other contours.
	// If the number of intersections is odd, we have started inside, else outside.
	// if this doesn't correspond to the contour orientation determined above, then we're misoriented.
	// The loops below follow the same pattern used for Contour::Draw but are separate due to different underlying data structure.
	// Notice that this doesn't work for overlapping or self-intersecting contours. They're against the TT laws...
	parity = 0;
	for (cont = 0; cont < pElement->nc; cont++) {
        if (cont != contour) 
        /* we are not interested by the intersections of the contour with itself, optimization */
        {
		    start = pElement->sp[cont];
		    end = pElement->ep[cont];
		    n = end - start + 1;
		    W[1].x = pElement->oox[start] << 1;
		    W[1].y = pElement->ooy[start] << 1;
		    on[1] = pElement->onCurve[start];
		    if (!on[1]) { // we start amidst a curve => get curve start point
			    W[0].x = pElement->oox[end] << 1;
			    W[0].y = pElement->ooy[end] << 1;
			    on[0] = pElement->onCurve[end];
			    if (!on[0]) { // curve start point is implied on-curve point => compute
				    W[0] = ShrV(AddV(W[0],W[1]),1);
			    }
		    }
		    knot = start;
		    do {
			    knot = knot == end ? start : knot + 1;
			    W[2].x = pElement->oox[knot] << 1;
			    W[2].y = pElement->ooy[knot] << 1;
			    on[2] = pElement->onCurve[knot];
			    switch (on[1] << 1 | on[2]) {
				    case 3: // on---on => start and end a line => intersect with line
					    if (NotSameKnot(W[1],W[2]))
                        {
                        /* check bounding box before computing the intersection for performance */
							if (CheckBoundingBoxSegment(C[0],W[1],W[2],extremumNumber))
							{
                                parity += CurveTransitionsSegment(C[0],C[1],W[1],W[2]); // repeating first vertex makes Bzier curve a line...
							}
                        }
					    break;
				    case 2: // on---off => start a curve => intersect with nothing
					    W[0] = W[1];
					    break;
				    case 1: // off---on => end a curve => intersect with the curve
					    if (NotSameKnot(W[0],W[2])) 
                        {
                            /* check bounding box before computing the intersection for performance */
							if (CheckBoundingBoxCurve(C[0],W[0],W[1],W[2],extremumNumber))
							{
                                parity += CurveTransitions(C[0],C[1],W[0],W[1],W[2]);
							}
                        }
					    break;
				    case 0: // off---off => end a curve => intersect with the curve; then start a curve => intersect with nothing
					    Wi = ShrV(AddV(W[1],W[2]),1);
					    if (NotSameKnot(W[0],Wi))
                        {
							if (CheckBoundingBoxCurve(C[0],W[0],W[1],Wi,extremumNumber))
							{
                                parity += CurveTransitions(C[0],C[1],W[0],W[1],Wi);
							}
                        }
					    W[0] = Wi;
					    break;
			    }
			    W[1] = W[2]; on[1] = on[2];
		    } while (knot != start);
        }
	}
	color = parity & 1 ? linkBlack : linkWhite;

	return color == orientation; // cw (black) contours should have white to their left, and v.v., else they're oriented the wrong way round
} // Misoriented

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  fsg_CopyFontProgramResults(
	void *              pvGlobalGS,
	void *              pvGlobalGSSubPixel)
{
	fnt_GlobalGraphicStateType *globalGS, *globalGSSubPixel;
	int32 i;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGSSubPixel = (fnt_GlobalGraphicStateType *)pvGlobalGSSubPixel;

	for (i = 0; i < globalGS->maxp->maxFunctionDefs; i++)
	{
		globalGSSubPixel->funcDef[i] = globalGS->funcDef[i];

	}

    globalGSSubPixel->instrDefCount = globalGS->instrDefCount;

	for (i = 0; i < globalGS->instrDefCount; i++)
	{
		globalGSSubPixel->instrDef[i] = globalGS->instrDef[i];

	}
	globalGSSubPixel->subPixelCompatibilityFlags = globalGS->subPixelCompatibilityFlags;

	globalGSSubPixel->numDeltaFunctionsDetected = globalGS->numDeltaFunctionsDetected;
	for (i = 0; i < globalGSSubPixel->numDeltaFunctionsDetected; i++)
		globalGSSubPixel->deltaFunction[i] = globalGS->deltaFunction[i];
}


FS_PUBLIC void  fsg_ScaleToCompatibleWidth (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    Fixed   fxCompatibleWidthScale)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;
    scl_ScaleToCompatibleWidth(pElement, fxCompatibleWidthScale);
}


FS_PUBLIC void  fsg_AdjustCompatibleMetrics (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;
    scl_AdjustCompatibleMetrics(pElement, horTranslation, newDevAdvanceWidthX);
}

FS_PUBLIC void  fsg_CalcDevHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX)
{
    fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevHorMetrics(pElement, pDevAdvanceWidthX, pDevLeftSideBearingX, pDevRightSideBearingX);

}

FS_PUBLIC void  fsg_CalcDevNatHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX)
{
    fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevNatHorMetrics(pElement, pDevAdvanceWidthX, pDevLeftSideBearingX, pDevRightSideBearingX, pNatAdvanceWidthX, pNatLeftSideBearingX, pNatRightSideBearingX);

}

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\sbit.c ===
/*********************************************************************

      sbit.c -- Embedded Bitmap Module

      (c) Copyright 1993-96  Microsoft Corp.  All rights reserved.

      04/01/96  claudebe    adding support for embedded grayscale bitmap
      02/07/95  deanb       Workspace pointers for GetMetrics & GetBitmap
      01/31/95  deanb       memset unrotated bitmap to zero
      01/27/95  deanb       usShaveLeft & usShaveRight added to sbit state
      12/21/94  deanb       rotation and vertical metrics support
      08/02/94  deanb       pf26DevLSB->y calculated correctly
      01/05/94  deanb       Bitmap scaling added
      11/29/93  deanb       First cut 
 
**********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for inttodot6 macro */
        
#include    "sfntaccs.h"            /* sfnt access functions */
#include    "sbit.h"                /* own function prototypes */

/**********************************************************************/

#define MAX_BIT_INDEX	8			/* maximum bit index in a byte */

/*  Local structure */

typedef struct
{
    uint8*  pbySrc;                 /* unrotated source bitmap (as read) */
    uint8*  pbyDst;                 /* rotated destination bitmap (as returned) */
    uint16  usSrcBytesPerRow;       /* source bitmap width */
    uint16  usDstBytesPerRow;       /* destination bitmap width */
    uint16  usSrcX;                 /* source horiz pixel index */
    uint16  usSrcY;                 /* destination horiz pixel index */
    uint16  usDstX;                 /* source vert pixel index */
    uint16  usDstY;                 /* destination vert pixel index */
	uint16	usBitDepth;				/* bit depth of source/destination bitmap */
} 
CopyBlock;

/**********************************************************************/

/*  Local prototypes  */

FS_PRIVATE ErrorCode GetSbitMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);

FS_PRIVATE ErrorCode GetSbitComponent (
    sfac_ClientRec  *pClientInfo,
    uint32          ulStrikeOffset,
    uint16          usBitmapFormat,
    uint32          ulBitmapOffset,
    uint32          ulBitmapLength,
    uint16          usHeight,
    uint16          usWidth,
    uint16          usShaveLeft,
    uint16          usShaveRight,
    uint16          usShaveTop,
    uint16          usShaveBottom,
    uint16          usXOffset,
    uint16          usYOffset,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbyRead, 
    uint8           *pbyExpand 
);

FS_PRIVATE void ExpandSbitToBytePerPixel (
    uint16          usHeight,
    uint16          usWidth,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbySrcBitMap,
    uint8           *pbyDstBitMap );

FS_PRIVATE uint16 UScaleX(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE uint16 UScaleY(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE int16 SScaleX(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE int16 SScaleY(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE uint16 UEmScaleX(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE uint16 UEmScaleY(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE int16 SEmScaleX(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE int16 SEmScaleY(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE void ScaleVertical (
    uint8 *pbyBitmap,
    uint16 usBytesPerRow,
    uint16 usOrgHeight,
    uint16 usNewHeight
);

FS_PRIVATE void ScaleHorizontal (
    uint8 *pbyBitmap,
    uint16 usOrgBytesPerRow,
    uint16 usNewBytesPerRow,
	uint16 usBitDepth,
    uint16 usOrgWidth,
    uint16 usNewWidth,
    uint16 usRowCount
);

FS_PRIVATE void CopyBit(
    CopyBlock* pcb );

FS_PRIVATE ErrorCode SubstituteVertMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);

FS_PRIVATE ErrorCode SubstituteHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);



/**********************************************************************/
/***                                                                ***/
/***                       SBIT Functions                           ***/
/***                                                                ***/
/**********************************************************************/

/*  reset sbit state structure to default values */

#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

FS_PUBLIC ErrorCode sbit_NewTransform(
    sbit_State  *pSbit,
    uint16		usEmResolution,
    int16		sBoldSimulHorShift,
     int16		sBoldSimulVertShift,
    uint16          usPpemX,
    uint16          usPpemY,
    uint16          usRotation             /* 0 - 3 => 90 deg rotation, else not 90 */
	)
{
    pSbit->usPpemX = usPpemX;                       /* save requested ppem */
    pSbit->usPpemY = usPpemY;
    pSbit->usRotation = usRotation;                 /* used later on */

    pSbit->bGlyphFound = FALSE;
    pSbit->usTableState = SBIT_UN_SEARCHED;
    pSbit->usEmResolution = usEmResolution;

    /* with embedded bitmap, the emboldement is done before the rotation */
    pSbit->uBoldSimulHorShift = MABS(sBoldSimulHorShift); 
    pSbit->uBoldSimulVertShift = MABS(sBoldSimulVertShift); 
    if ((pSbit->usRotation == 1) || (pSbit->usRotation == 3))
    {
        /* with embedded bitmap, the emboldement is done before the rotation */
        uint16 temp;
        temp = pSbit->uBoldSimulHorShift;
        pSbit->uBoldSimulHorShift = pSbit->uBoldSimulVertShift;
        pSbit->uBoldSimulVertShift = temp;
    }
    return NO_ERR;
}

/**********************************************************************/

/*  Determine whether a glyph bitmap exists */

FS_PUBLIC ErrorCode sbit_SearchForBitmap(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint16          usGlyphCode,
	uint16          usOverScale,            /* outline magnification requested */
	uint16			*pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16          *pusFoundCode )         /* 0 = not found, 1 = bloc, 2 = bsca */
{    
    ErrorCode   ReturnCode;

    *pusFoundCode = 0;                              /* default */
    if (pSbit->usRotation > 3)
    {
        return NO_ERR;                              /* can't match a general rotation */
    }


    if (pSbit->usTableState == SBIT_UN_SEARCHED)    /* new trans - 1st glyph */
    {
        ReturnCode = sfac_SearchForStrike (         /* look for a strike */
            pClientInfo,
            pSbit->usPpemX, 
            pSbit->usPpemY, 
			usOverScale,            /* outline magnification requested */
			&pSbit->usBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
            &pSbit->usTableState,                   /* may set to BLOC or BSCA */
            &pSbit->usSubPpemX,                     /* if BSCA us this ppem */
            &pSbit->usSubPpemY,
            &pSbit->ulStrikeOffset );
        
        if (ReturnCode != NO_ERR) return ReturnCode;
    }

	*pusBitDepth = pSbit->usBitDepth;

    if ((pSbit->usTableState == SBIT_BLOC_FOUND) || 
        (pSbit->usTableState == SBIT_BSCA_FOUND))
    {
        ReturnCode = sfac_SearchForBitmap (         /* now look for this glyph */
            pClientInfo,
            usGlyphCode,
            pSbit->ulStrikeOffset,
            &pSbit->bGlyphFound,                    /* return values */
            &pSbit->usMetricsType,
            &pSbit->usMetricsTable,
            &pSbit->ulMetricsOffset,
            &pSbit->usBitmapFormat,
            &pSbit->ulBitmapOffset,
            &pSbit->ulBitmapLength );
        
        if (ReturnCode != NO_ERR) return ReturnCode;
        
        if (pSbit->bGlyphFound)
        {
            if (pSbit->usTableState == SBIT_BLOC_FOUND)
            {
                *pusFoundCode = 1;
            }
            else
            {
                *pusFoundCode = 2;
            }
            pSbit->bMetricsValid = FALSE;
        }
    }
    return NO_ERR;
}


/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetDevAdvanceWidth (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW )
{
    point       ptDevAdvW;                  /* unrotated metrics */
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound );
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	/* we are only interested in AdvanceWidth */
	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

    ptDevAdvW.x = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
    ptDevAdvW.y = 0L;                           /* always zero for horizontal metrics */

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        pf26DevAdvW->x = ptDevAdvW.x;
        pf26DevAdvW->y = ptDevAdvW.y;
		break;
	case 1:                                     /* 90 degree rotation */
        pf26DevAdvW->x = -ptDevAdvW.y;
        pf26DevAdvW->y = ptDevAdvW.x;
		break;
	case 2:                                     /* 180 degree rotation */
        pf26DevAdvW->x = -ptDevAdvW.x;
        pf26DevAdvW->y = -ptDevAdvW.y;
		break;
	case 3:                                     /* 270 degree rotation */
        pf26DevAdvW->x = ptDevAdvW.y;
        pf26DevAdvW->y = -ptDevAdvW.x;
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}

    return NO_ERR;
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC ErrorCode  sbit_CalcDevHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	F26Dot6 *       pDevAdvanceWidthX,
	F26Dot6 *       pDevLeftSideBearingX,
	F26Dot6 *       pDevRightSideBearingX)
{
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

	/* metrics without rotation */
    FS_ASSERT(((pSbit->usRotation == 0) || (pSbit->usRotation == 2)), "sbit_CalcDevHorMetrics called under rotation\n");

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound );
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        *pDevAdvanceWidthX = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
        *pDevLeftSideBearingX = INTTODOT6(UScaleX(pSbit, pSbit->sLSBearingX));
        *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevLeftSideBearingX - INTTODOT6(UScaleX(pSbit, pSbit->usWidth));
		break;
	case 2:                                     /* 180 degree rotation */
        *pDevAdvanceWidthX = -INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
        *pDevLeftSideBearingX = -INTTODOT6(UScaleX(pSbit, pSbit->sLSBearingX));
        *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevLeftSideBearingX + INTTODOT6(UScaleX(pSbit, pSbit->usWidth));
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}
    

    return NO_ERR;
}
#endif // FSCFG_SUBPIXEL

/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetDevAdvanceHeight (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvH )
{
    point       ptDevAdvH;                  /* unrotated metrics */
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound);
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	/* we are only interested in AdvanceHeight */
	if (!bVertMetricsFound)
	{
		ReturnCode = SubstituteVertMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

/* set x components to zero */

    ptDevAdvH.x = 0L;
    ptDevAdvH.y = INTTODOT6(UScaleY(pSbit, pSbit->usAdvanceHeight));
        
     switch(pSbit->usRotation)                   /* handle 90 degree rotations */
    {
    case 0:                                     /* no rotation */
           pf26DevAdvH->x = ptDevAdvH.x;
           pf26DevAdvH->y = ptDevAdvH.y;
    	break;
    case 1:                                     /* 90 degree rotation */
           pf26DevAdvH->x = -ptDevAdvH.y;
           pf26DevAdvH->y = ptDevAdvH.x;
    	break;
    case 2:                                     /* 180 degree rotation */
           pf26DevAdvH->x = -ptDevAdvH.x;
           pf26DevAdvH->y = -ptDevAdvH.y;
    	break;
    case 3:                                     /* 270 degree rotation */
           pf26DevAdvH->x = ptDevAdvH.y;
           pf26DevAdvH->y = -ptDevAdvH.x;
    	break;
    default:                                    /* non 90 degree rotation */
    	return SBIT_ROTATION_ERR;
    }
	return NO_ERR;
}

/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetMetrics (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW,
    point           *pf26DevLSB,
    point           *pf26LSB,
    point           *pf26DevAdvH, 	/* NEW */
    point           *pf26DevTopSB,	/* NEW */
    point           *pf26TopSB,	/* NEW */
    Rect            *pRect,
    uint16          *pusRowBytes,
    uint32          *pulOutSize,
    uint32          *pulWorkSize )
{
    ErrorCode   ReturnCode;
    uint32      ulOrgMemSize;               /* size of unscaled bitmap */
    uint32      ulExpMemSize;               /* size of unscaled bitmap after gray expansion */
    uint32      ulScaMemSize;               /* size of scaled bitmap */
    uint32      ulMaxMemSize;               /* size of larger of scaled, unscaled */
    
    F26Dot6     f26DevAdvWx;                /* unrotated metrics */
    F26Dot6     f26DevAdvWy;
    F26Dot6     f26DevLSBx;
    F26Dot6     f26DevLSBy;
    F26Dot6     f26DevAdvHx;                /* unrotated metrics */
    F26Dot6     f26DevAdvHy;
    F26Dot6     f26DevTopSBx;
    F26Dot6     f26DevTopSBy;
    int16       sTop;                       /* unrotated bounds */
    int16       sLeft;
    int16       sBottom;
    int16       sRight;
	uint16		usOutBitDepth;				/* number of bit per pixel in the output */

	if (pSbit->usBitDepth == 1)
	{
		usOutBitDepth = 1;
	} else {
		usOutBitDepth = 8;
	}

    ReturnCode = GetSbitMetrics(pSbit, pClientInfo);
    if (ReturnCode != NO_ERR) return ReturnCode;
    
    pSbit->usScaledWidth = UScaleX(pSbit, pSbit->usWidth);
    pSbit->usScaledHeight = UScaleY(pSbit, pSbit->usHeight);


    
    sTop = SScaleY(pSbit, pSbit->sLSBearingY);            /* calc scaled metrics */
    sLeft = SScaleX(pSbit, pSbit->sLSBearingX);
    sBottom = sTop - (int16)pSbit->usScaledHeight;
    sRight = sLeft + (int16)pSbit->usScaledWidth;

    f26DevAdvWx = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
    f26DevAdvWy = 0L;                   /* always zero for horizontal metrics */
    f26DevAdvHx = 0L;                   /* always zero for vertical metrics */
    f26DevAdvHy = INTTODOT6(UScaleY(pSbit, pSbit->usAdvanceHeight));
    f26DevLSBx = INTTODOT6(SScaleX(pSbit, pSbit->sLSBearingX));
    f26DevLSBy = INTTODOT6(SScaleY(pSbit, pSbit->sLSBearingY));
    f26DevTopSBx = INTTODOT6(SScaleX(pSbit, pSbit->sTopSBearingX));
    f26DevTopSBy = INTTODOT6(SScaleY(pSbit, pSbit->sTopSBearingY));

    pSbit->usOriginalRowBytes = ROWBYTESLONG(pSbit->usWidth * pSbit->usBitDepth);   /* keep unscaled */
    pSbit->usExpandedRowBytes = ROWBYTESLONG(pSbit->usWidth * usOutBitDepth);   /* keep unscaled */
    pSbit->usScaledRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);

	pSbit->ulReadMemSize = 0; /* size of extra memory, to read gray sbit under scaling or rotation */

    ulOrgMemSize = (uint32)pSbit->usHeight * (uint32)pSbit->usOriginalRowBytes;
    ulExpMemSize = (uint32)pSbit->usHeight * (uint32)pSbit->usExpandedRowBytes;
    ulScaMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usScaledRowBytes;
    if (ulExpMemSize >= ulScaMemSize)
    {
         ulMaxMemSize = ulExpMemSize;
    }
    else
    {
         ulMaxMemSize = ulScaMemSize;
    }

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        pRect->top = sTop;                      /* return scaled metrics */
        pRect->left = sLeft;
        pRect->bottom = sBottom;
        pRect->right = sRight;

        pf26DevAdvW->x = f26DevAdvWx;
        pf26DevAdvW->y = f26DevAdvWy;
        pf26DevLSB->x = f26DevLSBx;
        pf26DevLSB->y = f26DevLSBy;
        pf26LSB->x = f26DevLSBx;
        pf26LSB->y = INTTODOT6(sTop);

        pf26DevAdvH->x = f26DevAdvHx;
        pf26DevAdvH->y = f26DevAdvHy;
        pf26DevTopSB->x = f26DevTopSBx;
        pf26DevTopSB->y = f26DevTopSBy;
        pf26TopSB->x = f26DevTopSBx;
        pf26TopSB->y = f26DevTopSBy;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usOutRowBytes;

        if ((pSbit->usTableState == SBIT_BSCA_FOUND) || (pSbit->usBitDepth != 1))
        {
            pSbit->ulWorkMemSize = ulMaxMemSize;  /* room to read & scale or expand gray pixels */
			if (pSbit->usBitDepth != 1)
			{
				pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
				pSbit->ulReadMemSize = ulOrgMemSize;
			}
        }
        else
        {
            pSbit->ulWorkMemSize = 0L;
        }
		break;
	case 1:                                     /* 90 degree rotation */
        pRect->top = sRight;
        pRect->left = -sTop;
        pRect->bottom = sLeft;
        pRect->right = -sBottom;
        
        pf26DevAdvW->x = -f26DevAdvWy;
        pf26DevAdvW->y = f26DevAdvWx;
        pf26DevLSB->x = -f26DevLSBy;
        pf26DevLSB->y = f26DevLSBx + INTTODOT6(sRight - sLeft);
        pf26LSB->x = 0L;
        pf26LSB->y = INTTODOT6(sRight) - f26DevLSBx;

        pf26DevAdvH->x = -f26DevAdvHy;
        pf26DevAdvH->y = f26DevAdvHx;
        pf26DevTopSB->x = -f26DevTopSBy;
        pf26DevTopSB->y = f26DevTopSBx + INTTODOT6(sRight - sLeft);

        pf26TopSB->x = INTTODOT6(-sTop) - f26DevTopSBy; 
        pf26TopSB->y = 0L; 	

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledHeight * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledWidth * (uint32)pSbit->usOutRowBytes; 
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	case 2:                                     /* 180 degree rotation */
        pRect->top = -sBottom;
        pRect->left = -sRight;
        pRect->bottom = -sTop;
        pRect->right = -sLeft;

        pf26DevAdvW->x = -f26DevAdvWx;
        pf26DevAdvW->y = -f26DevAdvWy;
        pf26DevLSB->x = -f26DevLSBx + INTTODOT6(sLeft - sRight);
        pf26DevLSB->y = -f26DevLSBy + INTTODOT6(sTop - sBottom);
        pf26LSB->x = -f26DevLSBx;
        pf26LSB->y = INTTODOT6(-sBottom);

        pf26DevAdvH->x = -f26DevAdvHx;
        pf26DevAdvH->y = -f26DevAdvHy;
        pf26DevTopSB->x = -f26DevTopSBx + INTTODOT6(sLeft - sRight);
        pf26DevTopSB->y = -f26DevTopSBy + INTTODOT6(sTop - sBottom);

		pf26TopSB->x = INTTODOT6(-sRight);	
        pf26TopSB->y = -f26DevTopSBy;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usOutRowBytes;
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	case 3:                                     /* 270 degree rotation */
        pRect->top = -sLeft;
        pRect->left = sBottom;
        pRect->bottom = -sRight;
        pRect->right = sTop;
        
        pf26DevAdvW->x = f26DevAdvWy;
        pf26DevAdvW->y = -f26DevAdvWx;
        pf26DevLSB->x = f26DevLSBy + INTTODOT6(sBottom - sTop);
        pf26DevLSB->y = -f26DevLSBx;
        pf26LSB->x = 0L;
        pf26LSB->y = INTTODOT6(-sLeft) + f26DevLSBx;

        pf26DevAdvH->x = f26DevAdvHy;
        pf26DevAdvH->y = -f26DevAdvHx;
        pf26DevTopSB->x = f26DevTopSBy + INTTODOT6(sBottom - sTop);
        pf26DevTopSB->y = -f26DevTopSBx;

        pf26TopSB->x = INTTODOT6(sBottom) -INTTODOT6(sTop) -INTTODOT6(sTop) + f26DevTopSBy;
        pf26TopSB->y = 0L;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledHeight * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledWidth * (uint32)pSbit->usOutRowBytes;
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}
        
    *pusRowBytes = pSbit->usOutRowBytes;
    *pulOutSize = pSbit->ulOutMemSize;          /* return mem requirement */
    *pulWorkSize = pSbit->ulWorkMemSize;
    return NO_ERR;
}

/******************************Public*Routine******************************\
*
* sbit_Embolden adapted from vTtfdEmboldenX
*
* Does emboldening in the x direction
*
* History:
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  24-Jun-1997 -by- Bodin Dresevic [BodinD]
* Stole from YungT
\**************************************************************************/

#define CJ_MONOCHROME_SCAN(cx)  (((cx)+7)/8)

/* embold only one pixel in the x direction */
#define DXABSBOLD 1

// array of masks for the last byte in a row

static uint8 gjMaskLeft[8] = {0XFF, 0X80, 0XC0, 0XE0, 0XF0, 0XF8, 0XFC, 0XFE };
static uint8 gjMaskRight[8] = {0XFF, 0X01, 0X03, 0X07, 0X0F, 0X1f, 0X3f, 0X7f };

//FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8   *pCur, *pyCur, *pyCurEnd, *pAdd, newByte;	

    uint8    beginMask, endMask;
    int32    i, j;
    int32    noOfValidBitsAtEndBold;
    int32    noOfValidBitsAtEndNormal;
    int32    noOfBytesForOneLineNormal;
    int32    noOfBytesForOneLineBold;
    int32   nBytesMore;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	// we want to embolden by sBoldSimulHorShift pixels horizontally(if sBoldSimulHorShift>0 then to the right; else to the left) along the base line 
    // and by sBoldSimulVertShift vertically(if sBoldSimulVertShift>0 then to the bottom; else to the top) )

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}


    noOfValidBitsAtEndBold = usBitmapWidth & 7; // styoo: same as noOfValidBitsAtEndBold = usBitmapWidth % 8

    // Before emboldening,the origninal image had scans of width
    // usBitmapWidth - sBoldSimulHorShift.

    noOfBytesForOneLineBold = CJ_MONOCHROME_SCAN(usBitmapWidth);
    if( sBoldSimulHorShift >= 0 ){
        noOfBytesForOneLineNormal = CJ_MONOCHROME_SCAN(usBitmapWidth - sBoldSimulHorShift);
        noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) & 7; // styoo: same as noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) % 8
    }
    else{
        noOfBytesForOneLineNormal = CJ_MONOCHROME_SCAN(usBitmapWidth - (-sBoldSimulHorShift));
        noOfValidBitsAtEndNormal = (usBitmapWidth - (-sBoldSimulHorShift)) & 7; // styoo: same as noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) % 8
    }

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }

//=============================================================================================================
	//Horizontal To Right
    if( sBoldSimulHorShift > 0){
        endMask = gjMaskLeft[noOfValidBitsAtEndNormal];

        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/
            

            pCur = &pyCur[noOfBytesForOneLineNormal - 1];
            *pCur &= endMask;

            pCur++;
            while( pCur < pyCur+usRowBytes ){
                *pCur = 0;
                pCur++;
            }

            //
            pCur = &pyCur[noOfBytesForOneLineBold - 1];

            while( pCur >= pyCur)
            {
                newByte = *pCur;
                // nByteMore is how many bytes we have to borrow for bitwise oring
                // for example, if sBoldSimulHorShift is 8, we need to borrow 2 bytes(current byte(0) and previous byte(-1))
                // if if sBoldSimulHorShift is 9, we need to borrow 3 bytes(current byte(0) and 2 previous bytes(-1,-2)
                nBytesMore = (sBoldSimulHorShift+7)/8;

                for(i = 1; i <= sBoldSimulHorShift; i++){
                    for(j = 0; j<= nBytesMore; j++){
                        // if pCur-j < pyCur then out of bound
                        if(pCur-j < pyCur)
                            break;

                        if( (i-j*8) >= 0 && (i-j*8) < 8 )
                            newByte |= (pCur[-j] >> (i-j*8));
                        else if( (i-j*8) < 0 && (i-j*8) > -8 )
                            newByte |= (pCur[-j] << (j*8 - i));
                    }
                }
                *pCur = newByte;

                pCur--;
            }

        // Special implementation for the last byte, styoo: don't need to borrow from previous byte

        }
    }

    //Horizontal To Left
    else if( sBoldSimulHorShift < 0){
        beginMask = gjMaskRight[8-(-sBoldSimulHorShift)];
        endMask = gjMaskLeft[noOfValidBitsAtEndBold];

        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
            *pCur &= beginMask;

            pCur = &pyCur[noOfBytesForOneLineBold-1];
            *pCur &= endMask;
            pCur++;

            while( pCur < pyCur+usRowBytes ){
                *pCur = 0;
                pCur++;
            }

            //
            pCur = pyCur;
            pyCurEnd = pyCur+(noOfBytesForOneLineBold-1);

            while( pCur <= pyCurEnd)
            {
                newByte = *pCur;

                // nByteMore is how many bytes we have to borrow for bitwise oring
                // for example, if sBoldSimulHorShift is -8, we need to borrow 2 bytes(current byte(0) and next byte(+1))
                // if if sBoldSimulHorShift is -9, we need to borrow 3 bytes(current byte(0) and 2 next bytes(+1,+2)
                nBytesMore = (-sBoldSimulHorShift+7)/8;

                for(i = 1; i <= -sBoldSimulHorShift; i++){
                    for(j = 0; j<= nBytesMore; j++){
                        // if pCur+j > pyCur+usRowBytes then out of bound
                        if(pCur+j > pyCurEnd)
                            break;

                        if( (i-j*8) >= 0 && (i-j*8) < 8 )
                            newByte |= (pCur[j] << (i-j*8));
                        else if( (i-j*8) < 0 && (i-j*8) > -8 )
                            newByte |= (pCur[j] >> (j*8 - i));
                    }
                }
                *pCur = newByte;

                pCur++;
            }

            // Special implementation for the last byte, styoo: don't need to borrow from previous byte


        }
    }
    // Vertical To the Bottom
	if( sBoldSimulVertShift > 0 ){
		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usRowBytes;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }

        //
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<noOfBytesForOneLineBold;i++,pCur++){
				newByte = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
					if(pAdd >= pyTopNormal)
						newByte |= *pAdd;
					else 
						break;
				}

                *pCur = newByte;
			}

			pyCur -= usRowBytes;
		}

	}
    // Vertical To the Top
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usRowBytes;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<noOfBytesForOneLineBold;i++,pCur++){
				newByte = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
					if(pAdd < pyBottomNormal+usRowBytes)
						newByte |= *pAdd;
					else 
						break;
				}

                *pCur = newByte;
			}

			pyCur += usRowBytes;
		}
	}
}

/******************************Public*Routine******************************\
* sbit_EmboldenGray adapted from vEmboldenOneBitGrayBitmap
*
* History:
*  03-Mar-2000 -by- Sung-Tae Yoo [styoo]
*      Bitmap level emboldening
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  Wed 28-May-1997 by Tony Tsai [YungT]
*      Rename the function name, a special case for 1-bit embolden
*  Wed 22-Feb-1995 13:21:55 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8 newPix;
    uint8 *pCur, *pyCur, *pAdd;	
    int32  i, j;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }

	//Horizontal To Right
    if( sBoldSimulHorShift > 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels

            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur + (usBitmapWidth - 1);
			for(i=0; i<sBoldSimulHorShift;i++,pCur--)
				*pCur = 0;

            // set pCur to point to the last byte in the scan
            pCur = pyCur + (usBitmapWidth - 1);

            /***************************************************
            *    start at the right edge of the scan and work  *
            *    back toward the left edge                     *
            ***************************************************/

            while ( pCur > pyCur )
            {
			    newPix = *pCur;

			    for(i=1; i<=sBoldSimulHorShift; i++){
				    if( (pCur-i) >= pyCur )
                    {
					  newPix += *(pCur-i);
                      if (newPix >= usGrayLevels){
                          newPix = (uint8)(usGrayLevels -1);
                          break;
                      }
                    }
			    }

                *pCur = newPix;

			    pCur--;
            }
        }
	}
	//Horizontal To Left
    else if( sBoldSimulHorShift < 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
			for(i=0; i<-sBoldSimulHorShift;i++,pCur++)
				*pCur = 0;

            /***************************************************
            *    start at the leftt edge of the scan and work  *
            *    back toward the right edge                     *
            ***************************************************/

            pCur = pyCur;
            while ( pCur < pyCur+usBitmapWidth )
            {
			    newPix = *pCur;

			    for(i=1; i<=-sBoldSimulHorShift; i++){
				    if( (pCur+i) < pyCur+usBitmapWidth )
                    {
					    newPix += *(pCur+i);
                        if (newPix >= usGrayLevels){
                            newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
			    }


                *pCur = newPix;

			    pCur++;
            }
        }
	}

    // Vertical To Down
	if( sBoldSimulVertShift > 0 ){

		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }
        
		//
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
					if(pAdd >= pyTopNormal)
                    {
						newPix += *pAdd;
                        if (newPix >= usGrayLevels){
					        newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
					else 
						break;
				}


                *pCur = newPix;
			}

			pyCur -= usRowBytes;
		}
	}

    // Vertical To Up
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
					if(pAdd < pyBottomNormal+usRowBytes)
                    {
						newPix += *pAdd;
                        if (newPix >= usGrayLevels){
					        newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
					else 
						break;
				}


                *pCur = newPix;
			}

			pyCur += usRowBytes;
		}
	}
}

#ifdef FSCFG_SUBPIXEL

#define MAX(a,b)    ((a) > (b) ? (a) : (b))

/******************************Public*Routine******************************\
* sbit_EmboldenSubPixel adapted from vEmboldenOneBitGrayBitmap
*
* History:
*  03-Mar-2000 -by- Sung-Tae Yoo [styoo]
*      Bitmap level emboldening
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  Wed 28-May-1997 by Tony Tsai [YungT]
*      Rename the function name, a special case for 1-bit embolden
*  Wed 22-Feb-1995 13:21:55 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8 *pCur, *pyCur, *pAdd;	
    int32  i, j;
	uint8 newPix;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }


	//Horizontal To Right
    if( sBoldSimulHorShift > 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels in the right side
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur + (usBitmapWidth - 1);
			for(i=0; i<sBoldSimulHorShift;i++,pCur--)
				*pCur = 0;

            // set pCur to point to the last byte in the scan
            pCur = pyCur + (usBitmapWidth - 1);

            /***************************************************
            *    start at the right edge of the scan and work  *
            *    back toward the left edge                     *
            ***************************************************/

            while ( pCur > pyCur )
            {
			    newPix = *pCur;

			    for(i=1; i<=sBoldSimulHorShift; i++){
				    if( (pCur-i) >= pyCur && *(pCur-i) )
                    {
                        if(newPix){
                            newPix = (uint8)MAX_RGB_INDEX;
						    break;
                        }
					    else
						    newPix = *(pCur-i);
					}
			    }

                *pCur = newPix;

			    pCur--;
            }
        }
	}
	//Horizontal To Left
    else if( sBoldSimulHorShift < 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels in the left side
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
			for(i=0; i<-sBoldSimulHorShift;i++,pCur++)
				*pCur = 0;

            /***************************************************
            *    start at the left edge of the scan and work  *
            *    back toward the right edge                     *
            ***************************************************/

            pCur = pyCur;
            while ( pCur < pyCur+usBitmapWidth )
            {
			    newPix = *pCur;

			    for(i=1; i<=-sBoldSimulHorShift; i++){
                    if( (pCur+i) < pyCur+usBitmapWidth && *(pCur+i) ){
                        if(newPix){
                            newPix = (uint8)MAX_RGB_INDEX;
						    break;
                        }
					    else
						    newPix = *(pCur+i);
                    }
			    }

                *pCur = newPix;

			    pCur++;
            }
        }
	}

    // Vertical To Down
	if( sBoldSimulVertShift > 0 ){

		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }
        
		//
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
                    if(pAdd >= pyTopNormal){
                        if(*pAdd && newPix){
                            newPix = MAX(*pAdd,newPix);
                            break;
                        }
                        else if(*pAdd && !newPix){
                            newPix = *pAdd;
                        }
                    }
					else 
						break;
				}

                *pCur = newPix;
			}

			pyCur -= usRowBytes;
		}
	}
    // Vertical To Up
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
                    if(pAdd < pyBottomNormal+usRowBytes){
                        if(*pAdd && newPix){
                            newPix = MAX(*pAdd,newPix);
                            break;
                        }
                        else if(*pAdd && !newPix){
                            newPix = *pAdd;
                        }
                    }
                    else 
						break;
				}

                *pCur = newPix;
			}

			pyCur += usRowBytes;
		}
	}

    // Second Pass to modify non edge pixel to MaxIndex
    if( MABS(sBoldSimulVertShift) > 1 ){ // If adding 2 or more pix vertically
        pyCur = pyTopBold+usRowBytes;
        while(pyCur < pyBottomBold){
            uint8 *pEndOfLine = pyCur+usBitmapWidth-1;

            pCur = pyCur+1;
            while(pCur < pEndOfLine){
                if( *pCur > (uint8)0 && *pCur < (uint8)MAX_RGB_INDEX){  // If it's color pix
                    if( *(pCur-1) && *(pCur+1) && *(pCur-usRowBytes) && *(pCur+usRowBytes)){  // If it's not edge pix
                        *pCur = (uint8)MAX_RGB_INDEX;
                    }
                }
                pCur++;
            }
            pyCur += usRowBytes;
        }
    }
}
#endif // FSCFG_SUBPIXEL

/**********************************************************************/
/*  if scaling or rotating, read bitmap into workspace,               */
/*  fix it up and copy it to the output map                           */

FS_PUBLIC ErrorCode sbit_GetBitmap (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint8           *pbyOut,
    uint8           *pbyWork )
{
    ErrorCode   ReturnCode;
    uint8       *pbyRead;
    uint8       *pbyExpand;
    CopyBlock   cb;                                 /* for bitmap rotations */
    uint16      usSrcXMax;
    uint16      usSrcYMax;

    MEMSET(pbyOut, 0, pSbit->ulOutMemSize);         /* always clear the output map */

    if ((pSbit->usRotation == 0) &&                 /* if no rotation */
        (pSbit->usTableState != SBIT_BSCA_FOUND))   /* and no scaling */
    {
		if (pSbit->usBitDepth != 1)
		{
			MEMSET(pbyWork, 0, pSbit->ulWorkMemSize);
			pbyRead = pbyWork;                       /* read in the work memory */
			pbyExpand = pbyOut;						 /* expand in the output */
		} else {
			pbyRead = pbyOut;                           /* read straight to output map */
			pbyExpand = NULL;							/* expansion memory not used in that case */
		}
    } else                                            /* if any rotation or scaling */
    {
        MEMSET(pbyWork, 0, pSbit->ulWorkMemSize);
		if (pSbit->usBitDepth != 1)
		{
			pbyRead = pbyWork;                       /* read in the work memory */
			pbyExpand = pbyWork + pSbit->ulReadMemSize;	/* expand in the work memory */
		} else {
			pbyRead = pbyWork;                          /* read into workspace */
			pbyExpand = pbyWork;						/* scaling done in pbyExpand */
		}
    }

    ReturnCode = GetSbitComponent (                 /* fetch the bitmap */
        pClientInfo,
        pSbit->ulStrikeOffset,
        pSbit->usBitmapFormat,                      /* root data only in state */
        pSbit->ulBitmapOffset,
        pSbit->ulBitmapLength,
        pSbit->usHeight,
        pSbit->usWidth,
        pSbit->usShaveLeft,
        pSbit->usShaveRight,
        pSbit->usShaveTop,
        pSbit->usShaveBottom,
        0,                                          /* no offset for the root */
        0,
        pSbit->usOriginalRowBytes,
        pSbit->usExpandedRowBytes,
		pSbit->usBitDepth,
        pbyRead,
		pbyExpand);
            
    if (ReturnCode != NO_ERR) return ReturnCode;

    
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        ScaleVertical (
            pbyExpand, 
            pSbit->usExpandedRowBytes, 
            pSbit->usHeight, 
            pSbit->usScaledHeight );

        ScaleHorizontal (
            pbyExpand, 
            pSbit->usExpandedRowBytes,
            pSbit->usScaledRowBytes,
            pSbit->usBitDepth, 
            pSbit->usWidth, 
            pSbit->usScaledWidth,
            pSbit->usScaledHeight );
            
        if (pSbit->usRotation == 0)                         /* if no rotation */
        {
            MEMCPY (pbyOut, pbyExpand, pSbit->ulOutMemSize);  /* keep this one */
        }
		/* in the SBIT_BSCA_FOUND the bitmap was already scaled to the final usScaledWidth, no need for additional emboldment */
	} else {
		if ((pSbit->uBoldSimulHorShift != 0) || (pSbit->uBoldSimulVertShift != 0))
		{
			if (pSbit->usRotation == 0)                             /* if no rotation */
			{
				cb.pbySrc = pbyOut;
			} else 
			{
				cb.pbySrc = pbyExpand;
			}
    
			if (pSbit->usBitDepth == 1)
			{
				sbit_Embolden(cb.pbySrc, pSbit->usScaledWidth, pSbit->usScaledHeight, pSbit->usScaledRowBytes, pSbit->uBoldSimulHorShift, pSbit->uBoldSimulVertShift);
			} else {
				uint16 usGrayLevels = (0x01 << pSbit->usBitDepth) ; /* Max gray level index */
				sbit_EmboldenGray(cb.pbySrc, pSbit->usScaledWidth, pSbit->usScaledHeight, pSbit->usScaledRowBytes, usGrayLevels, pSbit->uBoldSimulHorShift, pSbit->uBoldSimulVertShift);
			}

		}
    }

    if (pSbit->usRotation == 0)                             /* if no rotation */
    {
        return NO_ERR;                                      /* done */
    }
    
    cb.pbySrc = pbyExpand;
    cb.pbyDst = pbyOut;
    cb.usSrcBytesPerRow = pSbit->usScaledRowBytes;
    cb.usDstBytesPerRow = pSbit->usOutRowBytes;

	cb.usBitDepth = 1;
	if (pSbit->usBitDepth != 1)
		cb.usBitDepth = 8;

    usSrcXMax = pSbit->usScaledWidth;
    usSrcYMax = pSbit->usScaledHeight;

   	switch(pSbit->usRotation)
	{
	case 1:                                     /* 90 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstX = cb.usSrcY;                          /* x' = y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstY = usSrcXMax - cb.usSrcX - 1;      /* y' = -x */
                CopyBit(&cb);
            }
        }
		break;
	case 2:                                     /* 180 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstY = usSrcYMax - cb.usSrcY - 1;          /* y' = -y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstX = usSrcXMax - cb.usSrcX - 1;      /* x' = -x */
                CopyBit(&cb);
            }
        }
		break;
	case 3:                                     /* 270 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstX = usSrcYMax - cb.usSrcY - 1;          /* x' = -y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstY = cb.usSrcX;                      /* y' = x */
                CopyBit(&cb);
            }
        }
		break;
	default:                                    /* shouldn't happen */
		return SBIT_ROTATION_ERR;
	}

    return NO_ERR;
}


/**********************************************************************/

/*      Private Functions                                             */

/**********************************************************************/

FS_PRIVATE ErrorCode GetSbitMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo
)
{
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    if (pSbit->bMetricsValid)
    {
        return NO_ERR;                      /* already got 'em */
    }

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound);
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

	if (!bVertMetricsFound)
	{
		ReturnCode = SubstituteVertMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

    ReturnCode = sfac_ShaveSbitMetrics (
	    pClientInfo,
        pSbit->usBitmapFormat,
	    pSbit->ulBitmapOffset,
        pSbit->ulBitmapLength,
		pSbit->usBitDepth,
    	&pSbit->usHeight,
    	&pSbit->usWidth,
        &pSbit->usShaveLeft,
        &pSbit->usShaveRight,
        &pSbit->usShaveTop,
        &pSbit->usShaveBottom,
    	&pSbit->sLSBearingX,
    	&pSbit->sLSBearingY,
    	&pSbit->sTopSBearingX,
    	&pSbit->sTopSBearingY);

    if (ReturnCode != NO_ERR) return ReturnCode;
        
    pSbit->bMetricsValid = TRUE;
    return NO_ERR;
}

/**********************************************************************/

FS_PRIVATE ErrorCode SubstituteVertMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
)
{
    ErrorCode   ReturnCode;
	uint16	usNonScaledAH;
	int16	sNonScaledTSB;

	ReturnCode = sfac_ReadGlyphVertMetrics (
		pClientInfo,
		pClientInfo->usGlyphIndex,
		&usNonScaledAH,
		&sNonScaledTSB);
	if (ReturnCode != NO_ERR) return ReturnCode;

	pSbit->usAdvanceHeight = UEmScaleY(pSbit, usNonScaledAH);

	pSbit->sTopSBearingX = pSbit->sLSBearingX;
	pSbit->sTopSBearingY = - SEmScaleY(pSbit, sNonScaledTSB);

    return NO_ERR;
}

/**********************************************************************/

FS_PRIVATE ErrorCode SubstituteHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
)
{
    ErrorCode   ReturnCode;
	uint16	usNonScaledAW;
	int16	sNonScaledLSB;

	ReturnCode = sfac_ReadGlyphHorMetrics (
		pClientInfo,
		pClientInfo->usGlyphIndex,
		&usNonScaledAW,
		&sNonScaledLSB);
	if (ReturnCode != NO_ERR) return ReturnCode;

	pSbit->usAdvanceWidth = UEmScaleX(pSbit, usNonScaledAW);

	pSbit->sLSBearingX = pSbit->sTopSBearingX;
	pSbit->sLSBearingY = SEmScaleY(pSbit, sNonScaledLSB);
	
    return NO_ERR;
}

FS_PRIVATE void ExpandSbitToBytePerPixel (
    uint16          usHeight,
    uint16          usWidth,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbySrcBitMap,
    uint8           *pbyDstBitMap )
{
	uint16          usCount;
	uint16			usBitIndex, usOriginalBitIndex;
	uint8			*pbyDstBitRow;
	uint8			*pbySrcBitRow;
	uint16			usMask, usShift, usMaxLevel;

	usMaxLevel = (0x01 << usBitDepth) -1; /* Max gray level index */

	if (usBitDepth == 2)
	{
		usMask = 0x03;
		usShift = 0x02;
		usOriginalBitIndex = ((usWidth -1) & 0x03) << 0x01;
	} else if (usBitDepth == 4)
	{
		usMask = 0x0F;
		usShift = 0x01;
		usOriginalBitIndex = ((usWidth -1) & 0x01) << 0x02;
	} else if (usBitDepth == 8)
	{
		usMask = 0xFF;
		usShift = 0x00;
		usOriginalBitIndex = 0; /* ((usWidth -1) & 0x00) << 0x03 */
	} else
	{
		return;
	}

	/* start from the end to be able to use overlapping memories */
	pbyDstBitRow = pbyDstBitMap + (long) (usHeight-1) * (long) usExpandedRowBytes;
	pbySrcBitRow = pbySrcBitMap + (long) (usHeight-1) * (long) usOriginalRowBytes;
	
	while (usHeight > 0)
	{
		pbyDstBitMap = pbyDstBitRow + (long)(usWidth -1);
		pbySrcBitMap = pbySrcBitRow + (long)((usWidth -1) >> usShift);
		usBitIndex = usOriginalBitIndex;

		*pbySrcBitMap = *pbySrcBitMap >> (MAX_BIT_INDEX - usBitDepth - usBitIndex);

		for (usCount = usWidth; usCount > 0; usCount--)
		{
			if (*pbyDstBitMap == 0)
			{
				/* 99.9% of the case */
				*pbyDstBitMap = *pbySrcBitMap & usMask;
			} else {
				*pbyDstBitMap = usMaxLevel - 
						(usMaxLevel - *pbyDstBitMap) * (usMaxLevel - *pbySrcBitMap & usMask) / usMaxLevel;
			}
			*pbySrcBitMap = *pbySrcBitMap >> usBitDepth;

			pbyDstBitMap--;
			if (usBitIndex == 0)
			{
				usBitIndex = MAX_BIT_INDEX;
				pbySrcBitMap--;
			}
			usBitIndex = usBitIndex - usBitDepth;

		}
		pbyDstBitRow -= usExpandedRowBytes;
		pbySrcBitRow -= usOriginalRowBytes;
		usHeight--;
	}
}
/**********************************************************************/

/*  This is the recursive composite routine */

FS_PRIVATE ErrorCode GetSbitComponent (
    sfac_ClientRec  *pClientInfo,
    uint32          ulStrikeOffset,
    uint16          usBitmapFormat,
    uint32          ulBitmapOffset,
    uint32          ulBitmapLength,
    uint16          usHeight,
    uint16          usWidth,
    uint16          usShaveLeft,
    uint16          usShaveRight,
    uint16          usShaveTop,
    uint16          usShaveBottom,
    uint16          usXOffset,
    uint16          usYOffset,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbyRead,
    uint8           *pbyExpand )
{
    uint32          ulCompMetricsOffset;            /* component params */
    uint32          ulCompBitmapOffset;
    uint32          ulCompBitmapLength;
    uint16          usComponent;                    /* index counter */
    uint16          usCompCount;
    uint16          usCompGlyphCode;
    uint16          usCompXOff;
    uint16          usCompYOff;
    uint16          usCompMetricsType;
    uint16          usCompMetricsTable;
    uint16          usCompBitmapFormat;
    uint16          usCompHeight;
    uint16          usCompWidth;
    uint16          usCompShaveLeft;
    uint16          usCompShaveRight;
    uint16          usCompShaveTop;
    uint16          usCompShaveBottom;
    uint16          usCompAdvanceWidth;
    uint16          usCompAdvanceHeight;
    int16           sCompLSBearingX;
    int16           sCompLSBearingY;
    int16           sCompTopSBearingX;
    int16           sCompTopSBearingY;
    boolean         bCompGlyphFound;
   	boolean         bCompHorMetricsFound;
   	boolean         bCompVertMetricsFound;
    ErrorCode       ReturnCode;

		ReturnCode = sfac_GetSbitBitmap (               /* fetch the bitmap */
        pClientInfo,
        usBitmapFormat,
        ulBitmapOffset,
        ulBitmapLength,
        usHeight,
        usWidth,
        usShaveLeft,
        usShaveRight,
        usShaveTop,
        usShaveBottom,
        usXOffset,
        usYOffset,
        usOriginalRowBytes,
		usBitDepth,
        pbyRead,
        &usCompCount );                             /* zero for simple glyph */
            
    if (ReturnCode != NO_ERR) return ReturnCode;
    
	/* we expand after handling composite glyphs and before scaling and applying rotation */	
	if (usBitDepth != 1 && usCompCount == 0)
		ExpandSbitToBytePerPixel (
			usHeight,
			usWidth,
			usOriginalRowBytes,
			usExpandedRowBytes,
			usBitDepth,
			pbyRead,
			pbyExpand );

    if (usCompCount > 0)                            /* if composite glyph */
    {
        for (usComponent = 0; usComponent < usCompCount; usComponent++)
        {
			if (usBitDepth != 1)
			{
				/* for grayscale, the composition is done during expansion, I need to
				   clean the memory used to read between each component */
				MEMSET(pbyRead, 0, usOriginalRowBytes*usHeight);
			}
            ReturnCode = sfac_GetSbitComponentInfo (
                pClientInfo,
                usComponent,                        /* component index */
                ulBitmapOffset,
                ulBitmapLength,
                &usCompGlyphCode,                   /* return values */
                &usCompXOff,
                &usCompYOff );
            
            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = sfac_SearchForBitmap (     /* look for component glyph */
                pClientInfo,
                usCompGlyphCode,
                ulStrikeOffset,                     /* same strike for all */
                &bCompGlyphFound,                   /* return values */
                &usCompMetricsType,
                &usCompMetricsTable,
                &ulCompMetricsOffset,
                &usCompBitmapFormat,
                &ulCompBitmapOffset,
                &ulCompBitmapLength );
            
            if (ReturnCode != NO_ERR) return ReturnCode;
            
            if (bCompGlyphFound == FALSE)           /* should be there! */
            {
                return SBIT_COMPONENT_MISSING_ERR;
            }

            ReturnCode = sfac_GetSbitMetrics (      /* get component's metrics */
                pClientInfo,
                usCompMetricsType,
                usCompMetricsTable,
                ulCompMetricsOffset,
                &usCompHeight,                      /* these matter */
                &usCompWidth,
                &sCompLSBearingX,                     /* these don't */
                &sCompLSBearingY,
                &sCompTopSBearingX,                     
                &sCompTopSBearingY,
                &usCompAdvanceWidth,
                &usCompAdvanceHeight,
   				&bCompHorMetricsFound,
   				&bCompVertMetricsFound	);
            
            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = sfac_ShaveSbitMetrics (    /* shave white space for const metrics */
        	    pClientInfo,
                usCompBitmapFormat,
                ulCompBitmapOffset,
                ulCompBitmapLength,
				usBitDepth,
            	&usCompHeight,
            	&usCompWidth,
                &usCompShaveLeft,
                &usCompShaveRight,
                &usCompShaveTop,
                &usCompShaveBottom,
            	&sCompLSBearingX,
            	&sCompLSBearingY,
            	&sCompTopSBearingX,
             	&sCompTopSBearingY );

            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = GetSbitComponent (         /* recurse here */
                pClientInfo,
                ulStrikeOffset,
                usCompBitmapFormat,
                ulCompBitmapOffset,
                ulCompBitmapLength,
                usCompHeight,
                usCompWidth,
                usCompShaveLeft,
                usCompShaveRight,
                usCompShaveTop,
                usCompShaveBottom,
                (uint16)(usCompXOff + usXOffset + usCompShaveLeft),   /* for nesting */
                (uint16)(usCompYOff + usYOffset + usCompShaveTop),
                usOriginalRowBytes,                         /* same for all */
                usExpandedRowBytes,                         /* same for all */
				usBitDepth,
                pbyRead,
				pbyExpand);
            
            if (ReturnCode != NO_ERR) return ReturnCode;
        }
    }
    return NO_ERR;
}

/********************************************************************/

/*                  Bitmap Scaling Routines                         */

/********************************************************************/

FS_PRIVATE uint16 UScaleX(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
        ulValue = (uint32)usValue;
        ulValue *= (uint32)pSbit->usPpemX << 1; 
        ulValue += (uint32)pSbit->usSubPpemX;       /* for rounding */
        ulValue /= (uint32)pSbit->usSubPpemX << 1;
        usValue = (uint16)ulValue;
    }
	if (pSbit->uBoldSimulHorShift != 0)
	{
        if (usValue != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    usValue += 1; /* we increase the width by one pixel regardless of size for backwards compatibility */
	}
    return usValue;
}

/********************************************************************/

FS_PRIVATE uint16 UScaleY(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
        ulValue = (uint32)usValue;
        ulValue *= (uint32)pSbit->usPpemY << 1; 
        ulValue += (uint32)pSbit->usSubPpemY;       /* for rounding */
        ulValue /= (uint32)pSbit->usSubPpemY << 1;
        usValue = (uint16)ulValue;
    }
    return usValue;
}

/********************************************************************/

FS_PRIVATE int16 SScaleX(
    sbit_State  *pSbit,
    int16       sValue
)
{
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        if (sValue >= 0)                    /* positive Value */
        {
            return (int16)UScaleX(pSbit, (uint16)sValue);
        }
        else                                /* negative Value */
        {
            return -(int16)(UScaleX(pSbit, (uint16)(-sValue)));
        }
    }
    else                                    /* no scaling needed */
    {
        return sValue;
    }
}

/********************************************************************/

FS_PRIVATE int16 SScaleY(
    sbit_State  *pSbit,
    int16       sValue
)
{
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        if (sValue >= 0)                    /* positive Value */
        {
            return (int16)UScaleY(pSbit, (uint16)sValue);
        }
        else                                /* negative Value */
        {
            return -(int16)(UScaleY(pSbit, (uint16)(-sValue)));
        }
    }
    else                                    /* no scaling needed */
    {
        return sValue;
    }
}


FS_PRIVATE uint16 UEmScaleX(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;
	uint16		usPpemX;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
		usPpemX = pSbit->usSubPpemX;
    } else {
		usPpemX = pSbit->usPpemX;
	}
    ulValue = (uint32)usValue;
    ulValue *= (uint32)usPpemX << 1; 
    ulValue += (uint32)pSbit->usEmResolution;       /* for rounding */
    ulValue /= (uint32)pSbit->usEmResolution << 1;
    usValue = (uint16)ulValue;
	if (pSbit->uBoldSimulHorShift != 0)
	{
        if (usValue != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    usValue += 1; /* we increase the width by one pixel regardless of size for backwards compatibility */
	}
    return usValue;
}

/********************************************************************/

FS_PRIVATE uint16 UEmScaleY(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;
	uint16		usPpemY;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
		usPpemY = pSbit->usSubPpemY;
    } else {
		usPpemY = pSbit->usPpemY;
	}
    ulValue = (uint32)usValue;
    ulValue *= (uint32)usPpemY << 1; 
    ulValue += (uint32)pSbit->usEmResolution;       /* for rounding */
    ulValue /= (uint32)pSbit->usEmResolution << 1;
    usValue = (uint16)ulValue;
    return usValue;
}

/********************************************************************/

FS_PRIVATE int16 SEmScaleX(
    sbit_State  *pSbit,
    int16       sValue
)
{
     if (sValue >= 0)                    /* positive Value */
     {
         return (int16)UEmScaleX(pSbit, (uint16)sValue);
     }
     else                                /* negative Value */
     {
         return -(int16)(UEmScaleX(pSbit, (uint16)(-sValue)));
     }
}

/********************************************************************/

FS_PRIVATE int16 SEmScaleY(
    sbit_State  *pSbit,
    int16       sValue
)
{
     if (sValue >= 0)                    /* positive Value */
     {
         return (int16)UEmScaleY(pSbit, (uint16)sValue);
     }
     else                                /* negative Value */
     {
         return -(int16)(UEmScaleY(pSbit, (uint16)(-sValue)));
     }
}

/********************************************************************/

FS_PRIVATE void ScaleVertical (
    uint8 *pbyBitmap,
    uint16 usBytesPerRow,
    uint16 usOrgHeight,
    uint16 usNewHeight
)
{
    uint8 *pbyOrgRow;                   /* original data pointer */
    uint8 *pbyNewRow;                   /* new data pointer */
    uint16 usErrorTerm;                 /* for 'Bresenham' calculation */
    uint16 usLine;                      /* loop counter */

    usErrorTerm = usOrgHeight >> 1;                 /* used by both comp and exp */

    if (usOrgHeight > usNewHeight)                  /* Compress Vertical */
    {
        pbyOrgRow = pbyBitmap;
        pbyNewRow = pbyBitmap;

        for (usLine = 0; usLine < usNewHeight; usLine++)
        {
            while (usErrorTerm >= usNewHeight)
            {
                pbyOrgRow += usBytesPerRow;         /* skip a row */
                usErrorTerm -= usNewHeight;
            }
            if (pbyOrgRow != pbyNewRow)
            {
                MEMCPY(pbyNewRow, pbyOrgRow, usBytesPerRow);
            }
            pbyNewRow += usBytesPerRow;
            usErrorTerm += usOrgHeight;
        }
        for (usLine = usNewHeight; usLine < usOrgHeight; usLine++)
        {
            MEMSET(pbyNewRow, 0, usBytesPerRow);    /* erase the leftover */
            pbyNewRow += usBytesPerRow;
        }
    }
    else if (usNewHeight > usOrgHeight)             /* Expand Vertical */
    {
        pbyOrgRow = pbyBitmap + (usOrgHeight - 1) * usBytesPerRow;
        pbyNewRow = pbyBitmap + (usNewHeight - 1) * usBytesPerRow;

        for (usLine = 0; usLine < usOrgHeight; usLine++)
        {
            usErrorTerm += usNewHeight;
            
            while (usErrorTerm >= usOrgHeight)      /* executes at least once */
            {
                if (pbyOrgRow != pbyNewRow)
                {
                    MEMCPY(pbyNewRow, pbyOrgRow, usBytesPerRow);
                }
                pbyNewRow -= usBytesPerRow;
                usErrorTerm -= usOrgHeight;
            }
            pbyOrgRow -= usBytesPerRow;
        }
    }
}

/********************************************************************/

FS_PRIVATE void ScaleHorizontal (
    uint8 *pbyBitmap,
    uint16 usOrgBytesPerRow,
    uint16 usNewBytesPerRow,
	uint16 usBitDepth,
    uint16 usOrgWidth,
    uint16 usNewWidth,
    uint16 usRowCount
)
{
    uint8 *pbyOrgRow;               /* points to original row beginning */
    uint8 *pbyNewRow;               /* points to new row beginning */
    uint8 *pbyOrg;                  /* original data pointer */
    uint8 *pbyNew;                  /* new data pointer */
    uint8 byOrgData;                /* original data read 1 byte at a time */
    uint8 byNewData;                /* new data assembled bit by bit */

    uint16 usErrorTerm;             /* for 'Bresenham' calculation */
    uint16 usByte;                  /* to byte counter */
    uint16 usOrgBytes;              /* from width rounded up in bytes */
    uint16 usNewBytes;              /* to width rounded up in bytes */
    
    int16 sOrgBits;                 /* counts valid bits of from data */
    int16 sNewBits;                 /* counts valid bits of to data */
    int16 sOrgBitsInit;             /* valid original bits at row begin */
    int16 sNewBitsInit;             /* valid new bits at row begin */

    
	if (usBitDepth == 1)
	{
		if (usOrgWidth > usNewWidth)                    /* Compress Horizontal */
		{
			pbyOrgRow = pbyBitmap;
			pbyNewRow = pbyBitmap;
			usNewBytes = (usNewWidth + 7) >> 3;

			while (usRowCount > 0)
			{
				pbyOrg = pbyOrgRow;
				pbyNew = pbyNewRow;
				usErrorTerm = usOrgWidth >> 1;
            
				sOrgBits = 0;                           /* start at left edge */
				sNewBits = 0;
				usByte = 0;
				byNewData = 0;
				while (usByte < usNewBytes)
				{
					while (usErrorTerm >= usNewWidth)
					{
						sOrgBits--;                     /* skip a bit */
						usErrorTerm -= usNewWidth;
					}
					while (sOrgBits <= 0)               /* if out of data */
					{
						byOrgData = *pbyOrg++;          /*   then get some fresh */
						sOrgBits += 8;
					}
					byNewData <<= 1;                    /* new bit to lsb */
					byNewData |= (byOrgData >> (sOrgBits - 1)) & 1;
                
					sNewBits++;
					if (sNewBits == 8)                  /* if to data byte is full */
					{
						*pbyNew++ = byNewData;          /*   then write it out */
						sNewBits = 0;
						usByte++;                       /* loop counter */
					}
					usErrorTerm += usOrgWidth;
				}
				while (usByte < usNewBytesPerRow)
				{
					*pbyNew++ = 0;                      /* blank out the rest */
					usByte++;
				}
				pbyOrgRow += usOrgBytesPerRow;
				pbyNewRow += usNewBytesPerRow;
				usRowCount--;
			}
		}
		else if (usNewWidth > usOrgWidth)               /* Expand Horizontal */
		{
			pbyOrgRow = pbyBitmap + (usRowCount - 1) * usOrgBytesPerRow;
			pbyNewRow = pbyBitmap + (usRowCount - 1) * usNewBytesPerRow;

			usOrgBytes = (usOrgWidth + 7) >> 3;
			sOrgBitsInit = (int16)((usOrgWidth + 7) & 0x07) - 7;
        
			usNewBytes = (usNewWidth + 7) >> 3;
			sNewBitsInit = 7 - (int16)((usNewWidth + 7) & 0x07);

			while (usRowCount > 0)                      /* for each row */
			{
				pbyOrg = pbyOrgRow + usOrgBytes - 1;    /* point to right edges */
				pbyNew = pbyNewRow + usNewBytes - 1;
				usErrorTerm = usOrgWidth >> 1;
            
				sOrgBits = sOrgBitsInit;                /* initially unaligned */
				sNewBits = sNewBitsInit;
				usByte = 0;
				byNewData = 0;
				while (usByte < usNewBytes)             /* for each output byte */
				{
					if (sOrgBits <= 0)                  /* if out of data */
					{
						byOrgData = *pbyOrg--;          /*   then get some fresh */
						sOrgBits += 8;
					}
					usErrorTerm += usNewWidth;
                
					while (usErrorTerm >= usOrgWidth)   /* executes at least once */
					{
						byNewData >>= 1;                /* use the msb of byte */
						byNewData |= (byOrgData << (sOrgBits - 1)) & 0x80;
                    
						sNewBits++;
						if (sNewBits == 8)              /* if to data byte is full */
						{
							*pbyNew-- = byNewData;      /*   then write it out */
							sNewBits = 0;
							usByte++;                   /* loop counter */
						}
						usErrorTerm -= usOrgWidth;
					}
					sOrgBits--;                         /* get next bit */
				}
				pbyOrgRow -= usOrgBytesPerRow;
				pbyNewRow -= usNewBytesPerRow;
				usRowCount--;
			}
        }
    } else {											/* one byte per pixel */
		if (usOrgWidth > usNewWidth)                    /* Compress Horizontal */
		{
			pbyOrgRow = pbyBitmap;
			pbyNewRow = pbyBitmap;

			while (usRowCount > 0)
			{
				pbyOrg = pbyOrgRow;
				pbyNew = pbyNewRow;
				usErrorTerm = usOrgWidth >> 1;
            
				usByte = 0;
				while (usByte < usNewWidth)
				{
					while (usErrorTerm >= usNewWidth)
					{
						pbyOrg++;                     /* skip a byte */
						usErrorTerm -= usNewWidth;
					}
					*pbyNew++ = *pbyOrg;
					usByte++;                       /* loop counter */
					usErrorTerm += usOrgWidth;
				}
				while (usByte < usNewBytesPerRow)
				{
					*pbyNew++ = 0;                      /* blank out the rest */
					usByte++;
				}
				pbyOrgRow += usOrgBytesPerRow;
				pbyNewRow += usNewBytesPerRow;
				usRowCount--;
			}
		}
		else if (usNewWidth > usOrgWidth)               /* Expand Horizontal */
		{
			pbyOrgRow = pbyBitmap + (usRowCount - 1) * usOrgBytesPerRow;
			pbyNewRow = pbyBitmap + (usRowCount - 1) * usNewBytesPerRow;

			usOrgBytes = usOrgWidth;        
			usNewBytes = usNewWidth ;

			while (usRowCount > 0)                      /* for each row */
			{
				pbyOrg = pbyOrgRow + usOrgBytes - 1;    /* point to right edges */
				pbyNew = pbyNewRow + usNewBytesPerRow - 1;
				usErrorTerm = usOrgWidth >> 1;
            
				usByte = usNewBytesPerRow;
				while (usByte > usNewBytes)
				{
					*pbyNew-- = 0;                      /* blank out the extra bytes on the right */
					usByte--;
				}
				while (usByte > 0)             /* for each output byte */
				{
					usErrorTerm += usNewWidth;
                
					while (usErrorTerm >= usOrgWidth)   /* executes at least once */
					{
						*pbyNew-- = *pbyOrg;

						usByte--;                   /* loop counter */
						usErrorTerm -= usOrgWidth;
					}
					pbyOrg--;
				}
				pbyOrgRow -= usOrgBytesPerRow;
				pbyNewRow -= usNewBytesPerRow;
				usRowCount--;
			}
        }
	}
}

/********************************************************************/

FS_PRIVATE void CopyBit(
    CopyBlock* pcb )
{
    uint16  usSrcOffset;
    uint16  usSrcShift;
    uint16  usDstOffset;
    uint16  usDstShift;
    
    static  uint16 usByteMask[8] = 
        { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };

/*  if speed becomes an issue, this next multiply could be moved up */
/*  to the calling routine, and placed outside the 'x' loop */

/*  if speed becomes an issue, the test between 1 bit and 1 byte per pixel */
/*  could be moved up to the calling routine */

	if (pcb->usBitDepth == 1)
	{
		usSrcOffset = (pcb->usSrcY * pcb->usSrcBytesPerRow) + (pcb->usSrcX >> 3);
		usSrcShift = pcb->usSrcX & 0x0007;

		if (pcb->pbySrc[usSrcOffset] & usByteMask[usSrcShift])
		{
			usDstOffset = (pcb->usDstY * pcb->usDstBytesPerRow) + (pcb->usDstX >> 3);
			usDstShift = pcb->usDstX & 0x0007;
			pcb->pbyDst[usDstOffset] |= usByteMask[usDstShift];
		}
	} else {
		usSrcOffset = (pcb->usSrcY * pcb->usSrcBytesPerRow) + pcb->usSrcX;
		usDstOffset = (pcb->usDstY * pcb->usDstBytesPerRow) + pcb->usDstX;
		pcb->pbyDst[usDstOffset] = pcb->pbySrc[usSrcOffset];
	}

}

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scanlist.h ===
/*********************************************************************

	  scanlist.h -- ScanList Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/23/93  deanb   gray scale pass through functions
	   6/10/93  deanb   fsc_InitializeScanlist added
	  12/22/92  deanb   Rectangle -> Rect
	  10/28/92  deanb   uiRowBytes moved from setup to fillbitmap
	  10/09/92  deanb   PSTP added
	  10/08/92  deanb   reworked for split workspace
	   9/25/92  deanb   separate entry for nodrop/dropout 
	   9/10/92  deanb   horiz & vert callbacks 
	   9/09/92  deanb   size_t changes 
	   9/08/92  deanb   SetElemGlobals added 
	   6/18/92  deanb   int x coord for HorizScanAdd 
	   6/01/92  deanb   New/Old FillBitMap for debug comparisons 
	   4/21/92  deanb   Single HorizScan with flag 
	   4/13/92  deanb   unsigned int to int for HorizScanOn/Off 
	   3/31/92  deanb   InitScanArray Rectangle param 
	   3/23/92  deanb   GetWorkSize added 
	   3/16/92  deanb   New types 
	   1/31/92  deanb   HorizScan[On/Off] export functions 
	   1/14/92  deanb   First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */
#include "scgray.h"                 /* for gray param definition */


typedef struct RevRoots *PRevRoot;  /* opaque type */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/


FS_PUBLIC void fsc_InitializeScanlist (
		void
);

FS_PUBLIC PRevRoot fsc_SetupRevRoots (
		char*,                      /* reversal list buffer space */
		int32                       /* size of buffer space */
);

FS_PUBLIC void fsc_AddYReversal (
		PRevRoot,                   /* pointer to reversal roots */
		F26Dot6,                    /* reversal coordinate */
		int16                       /* +1 / -1 reversal value */
);

FS_PUBLIC void fsc_AddXReversal (
		PRevRoot,                   /* pointer to reversal roots */
		F26Dot6,                    /* reversal coordinate */
		int16                       /* +1 / -1 reversal value */
);

FS_PUBLIC int32 fsc_GetReversalCount (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetHIxEstimate  (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetVIxEstimate (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetHIxBandEst  (
		PRevRoot,                   /* pointer to reversal roots */
		Rect*,                      /* bitmap bounding box */
		int32                                /* band width in scan lines */
);

FS_PUBLIC int32 fsc_GetRevMemSize(
		PRevRoot                    /* pointer to reversal roots */
);


/*********************************************************************/

FS_PUBLIC int32 fsc_GetScanHMem( 
		uint16,                     /* scan type */
		int32,                      /* number of horiz scanlines */
		int32                       /* number of horiz intersections */
);

FS_PUBLIC int32 fsc_GetScanVMem( 
		uint16,                     /* scan type */
		int32,                      /* number of vert scanlines */
		int32,                      /* number of vert intersections */
		int32                       /* number of contour element points */
);

/*********************************************************************/

FS_PUBLIC void fsc_SetupCallBacks( 
		PSTATE                      /* pointer to state variables */
		int16,                      /* element code (line, spline, endpoint) */
		F26Dot6 (*)(int32, F26Dot6*, F26Dot6*),   /* horiz callback */
		F26Dot6 (*)(int32, F26Dot6*, F26Dot6*)    /* vert callback */
);

FS_PUBLIC int32 fsc_SetupScan( 
		PSTATE                      /* pointer to state variables */
		Rect*,                      /* bitmap bounding box */
		uint16,                     /* scan type */
		int32,                      /* band scan upper limit */
		int32,                      /* band scan lower limit */
		boolean,                    /* save over scan bitmap row */
		int32,                      /* bytes per bitmap row */
		int32,                      /* estimate of horiz intersections */
		int32,                      /* estimate of vert intersections */
		int32,                      /* estimate of element points */
		PRevRoot                    /* reversal list Roots */ 
);


FS_PUBLIC void fsc_BeginContourScan(
		PSTATE                      /* pointer to state variables */
		uint16,                     /* scan type */
		F26Dot6,                    /* starting point x coordinate */
		F26Dot6                     /* starting point y coordinate */
);


FS_PUBLIC void fsc_BeginElement( 
		PSTATE                      /* pointer to state variables */
		uint16,                     /* type of dropout control */
		int32,                      /* determines scan on/off */   
		int32,                      /* element (line, spline, ep) */
		int32,                      /* number of points to store */
		F26Dot6*,                   /* next x control point(s) */
		F26Dot6*,                   /* next y control point(s) */
		void (**)(PSTATE int32, int32),    /* horiz add scan return */
		void (**)(PSTATE int32, int32)     /* vert add scan return */
);

/*********************************************************************/

FS_PUBLIC int32 fsc_FillBitMap( 
		PSTATE                      /* pointer to state variables */
		char*,                      /* target memory */
		int32,                      /* bitmap upper limit */
		int32,                      /* bitmap lower limit */
		int32,                      /* bitmap bytes per row */
		int32,                      /* original low band row */
		uint16                      /* scan type */
);

/*********************************************************************/

FS_PUBLIC int32 fsc_ScanClearBitMap ( 
		uint32,                     /* longs per bmp */
		uint32*                     /* bitmap ptr caste long */
);

FS_PUBLIC int32 fsc_ScanCalcGrayRow(
		GrayScaleParam*             /* pointer to param block */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\fscdefs.h ===
/*
	File:       fscdefs.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.
	Copyright:  c 1991-1999 by Microsoft Corp., all rights reserved.

	Change History (most recent first):
		
				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		         4/01/99  BeatS		Implement alternative interpretation of TT instructions for SP
		 <>     10/14/97    CB      rename ASSERT into FS_ASSERT
		 <3>    11/27/90    MR      Add #define for PASCAL. [ph]
		 <2>     11/5/90    MR      Move USHORTMUL from fontmath.h, add Debug definition [rb]
		 <7>     7/18/90    MR      Add byte swapping macros for INTEL, moved rounding macros from
									fnt.h to here
		 <6>     7/14/90    MR      changed defines to typedefs for int[8,16,32] and others
		 <5>     7/13/90    MR      Declared ReleaseSFNTFunc and GetSFNTFunc
		 <4>      5/3/90    RB      cant remember any changes
		 <3>     3/20/90    CL      type changes for Microsoft
		 <2>     2/27/90    CL      getting bbs headers
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/

#ifndef FSCDEFS_DEFINED
#define FSCDEFS_DEFINED

#include "fsconfig.h"
#include <stddef.h>
#include <limits.h>

#if !defined(__cplusplus)       // true/false are reserved words for C++
#define true 1
#define false 0
#endif

#ifndef TRUE
	#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef FS_PRIVATE
#define FS_PRIVATE static
#endif

#ifndef FS_PUBLIC
#define FS_PUBLIC
#endif

#define ONEFIX      ( 1L << 16 )
#define ONEFRAC     ( 1L << 30 )
#define ONEHALFFIX  0x8000L
#define ONEVECSHIFT 16
#define HALFVECDIV  (1L << (ONEVECSHIFT-1))

#define NULL_GLYPH  0

/* banding type constants */

#define FS_BANDINGOLD       0
#define FS_BANDINGSMALL     1
#define FS_BANDINGFAST      2
#define FS_BANDINGFASTER    3

/* Dropout control values are now defined as bit masks to retain compatability */
/* with the old definition, and to allow for current and future expansion */

#define SK_STUBS          0x0001       /* leave stubs white */
#define SK_NODROPOUT      0x0002       /* disable all dropout control */
#define SK_SMART              0x0004        /* symmetrical dropout, closest pixel */

/* Values used to decode curves */

#define ONCURVE             0x01

typedef signed char int8;
typedef unsigned char uint8;
typedef short int16;
typedef unsigned short uint16;
typedef long int32;
typedef unsigned long uint32;

typedef __int64 int64;
typedef unsigned __int64 uint64;

typedef short FUnit;
typedef unsigned short uFUnit;

typedef short ShortFract;                       /* 2.14 */

#ifndef F26Dot6
#define F26Dot6 long
#endif

#ifndef boolean
#define boolean int
#endif

#ifndef ClientIDType
#define ClientIDType int32
#endif

#ifndef CONST
#define CONST const
#endif

#ifndef FAR
#define FAR
#endif

#ifndef NEAR
#define NEAR
#endif

#ifndef TMP_CONV
#define TMP_CONV
#endif

#ifndef FS_MAC_PASCAL
#define FS_MAC_PASCAL
#endif

#ifndef FS_PC_PASCAL
#define FS_PC_PASCAL
#endif

#ifndef FS_MAC_TRAP
#define FS_MAC_TRAP(a)
#endif

/* QuickDraw Types */

#ifndef _MacTypes_
#ifndef __TYPES__
	typedef struct Rect {
		int16 top;
		int16 left;
		int16 bottom;
		int16 right;
	} Rect;

typedef long Fixed;         /* also defined in Mac's types.h */
typedef long Fract;

#endif
#endif

typedef struct {
	Fixed       transform[3][3];
} transMatrix;

typedef struct {
	Fixed       x, y;
} vectorType;

/* Private Data Types */
typedef struct {
	int16 xMin;
	int16 yMin;
	int16 xMax;
	int16 yMax;
} BBOX;

typedef struct {
	F26Dot6 x;
	F26Dot6 y;
} point;

typedef int32 ErrorCode;

#define ALIGN(object, p) p =    (p + ((uint32)sizeof(object) - 1)) & ~((uint32)sizeof(object) - 1);

#define ROWBYTESLONG(x)     (((x + 31) >> 5) << 2)

#ifndef SHORTMUL
#define SHORTMUL(a,b)   (int32)((int32)(a) * (b))
#endif

#ifndef SHORTDIV
#define SHORTDIV(a,b)   (int32)((int32)(a) / (b))
#endif

#ifdef FSCFG_BIG_ENDIAN /* target byte order matches Motorola 68000 */
	#define SWAPL(a)        (a)
	#define CSWAPL(a)       (a)
	#define SWAPW(a)        (a)
	#define CSWAPW(a)       (a)
	#define SWAPWINC(a)     (*(a)++)
#else
	/* Portable code to extract a short or a long from a 2- or 4-byte buffer */
	/* which was encoded using Motorola 68000 (TrueType "native") byte order. */
	#define FS_2BYTE(p) ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
	#define FS_4BYTE(p) ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )
	#define SWAPW(a)	((int16) FS_2BYTE( (unsigned char *)(&a) ))
	#define CSWAPW(num)	(((((num) & 0xff) << 8) & 0xff00) + (((num) >> 8) & 0xff)) // use this variant or else cannot apply to constants due to FS_2BYTE and FS_4BYTE
	#define SWAPL(a)	((int32) FS_4BYTE( (unsigned char *)(&a) ))
	#define CSWAPL(num)	((CSWAPW((num) & 0xffff) << 16) + CSWAPW((num) >> 16)) // use this variant or else cannot apply to constants due to FS_2BYTE and FS_4BYTE
	#define SWAPWINC(a) SWAPW(*(a)); a++    /* Do NOT parenthesize! */
#endif

#ifndef SWAPW // provoke compiler error if still not defined
	#define SWAPW	a
	#define SWAPW	b
#endif

#ifndef LoopCount
#define LoopCount int16      /* short gives us a Motorola DBF */
#endif

#ifndef ArrayIndex
#define ArrayIndex int32     /* avoids EXT.L on Motorola */
#endif

typedef void (*voidFunc) ();
typedef void * voidPtr;
typedef void (FS_CALLBACK_PROTO *ReleaseSFNTFunc) (voidPtr);
typedef void * (FS_CALLBACK_PROTO *GetSFNTFunc) (ClientIDType, int32, int32);

#ifndef	FS_ASSERT
#define FS_ASSERT(expression, message)
#endif

#ifndef Assert
#define Assert(a)
#endif

#ifndef MEMSET
#define MEMSET(dst, value, size) (void)memset(dst,value,(size_t)(size))
#define FS_NEED_STRING_DOT_H
#endif

#ifndef MEMCPY
#define MEMCPY(dst, src, size) (void)memcpy(dst,src,(size_t)(size))
#ifndef FS_NEED_STRING_DOT_H
#define FS_NEED_STRING_DOT_H
#endif
#endif

#ifdef FS_NEED_STRING_DOT_H
#undef FS_NEED_STRING_DOT_H
#include <string.h>
#endif

#ifndef FS_UNUSED_PARAMETER
#define FS_UNUSED_PARAMETER(a) (a=a)     /* Silence some warnings */
#endif

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */
	uint16      numGlyphs;
	uint16      maxPoints;              /* in an individual glyph */
	uint16      maxContours;            /* in an individual glyph */
	uint16      maxCompositePoints;     /* in an composite glyph */
	uint16      maxCompositeContours;   /* in an composite glyph */
	uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
	uint16      maxTwilightPoints;      /* max points in element zero */
	uint16      maxStorage;             /* max number of storage locations */
	uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
	uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
	uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
	uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
	uint16      maxComponentElements;   /* number of glyphs referenced at top level */
	uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} LocalMaxProfile;

#ifdef FSCFG_SUBPIXEL

	// master switch for turning on Backwards Compatible SubPixel
	// if we turn this off, we basically get the same as in b/w, but with coloured fringes
	// to get the complete original 16x overscaling behaviour back, set HINTING_HOR_OVERSCALE below to 16
	#define	SUBPIXEL_BC
	
	#define ProjVectInX(localGS)	((localGS).proj.x == ONEVECTOR && (localGS).proj.y == 0)
	#define	ProjVectInY(localGS)	((localGS).proj.y == ONEVECTOR && (localGS).proj.x == 0)
	
	#ifdef SUBPIXEL_BC
		
		// master switch for turning on Enhanced Backwards Compatible Advance Width SubPixel Algorithm
		#define SUBPIXEL_BC_AW_STEM_CONCERTINA
		
		#define RunningSubPixel(globalGS)		((uint16)((globalGS)->flHintForSubPixel & FNT_SP_SUB_PIXEL))
		#define CompatibleWidthSP(globalGS)		((uint16)((globalGS)->flHintForSubPixel & FNT_SP_COMPATIBLE_WIDTH))
		#define VerticalSPDirection(globalGS)	((uint16)((globalGS)->flHintForSubPixel & FNT_SP_VERTICAL_DIRECTION))
		#define BGROrderSP(globalGS)			((uint16)((globalGS)->flHintForSubPixel & FNT_SP_BGR_ORDER))
	//	assume that horizontal direction RGB is more frequent than vertical direction, hence put the latter into the else-path
	//	Notice that in order to decide whether we're currently in SubPixel direction, we look at the projection vector, because that's the direction
	//	along which distances are measured. If this projection vector has a non-zero component in the physical direction of our device, we will decide
	//	that rounding should be done in the SubPixel way. For example, if our device has its SubPixel direction in x, and if the projection vector
	//	points in any direction other than the y direction, the pv has a non-zero component in x, hence we round in the SubPixel way. This behaviour
	//	corresponds to the original implementation of the 16x overscaling rasterizer, where the non-zero component in x would be overscaled by 16.
		#define InSubPixelDirection(localGS)	((uint16)(!VerticalSPDirection((localGS).globalGS) ? !ProjVectInY(localGS) : !ProjVectInX(localGS)))
	//	primary values; in interp.c there are further values which are derived from these values, but which are specific to the interpreter
		#define VIRTUAL_OVERSCALE				16 // for itrp_RoundToGrid & al to work properly, this should be a power of two, else have to tabulate rounding
		#define VISUAL_OVERSCALE				2  // between 1.7 and 3, corresponding to the visually experienced resolution relative to the physical resolution.
												   // for our purposes, the exact value is not particularly crucial (cf. ENGINE_COMP_OVERSCALE, MIN_DIST_OVERSCALE,
												   // in interp.c) hence we set it to 2 for efficiency
	#else
		#define RunningSubPixel(globalGS)		false
		#define CompatibleWidthSP(globalGS)		false
		#define VerticalSPDirection(globalGS)	false
		#define InSubPixelDirection(localGS)	false
	//	primary values; in interp.c there are further values which are derived from these values, but which are specific to the interpreter
		#define VIRTUAL_OVERSCALE				1
		#define VISUAL_OVERSCALE				1
	#endif
//	#define VIRTUAL_PIXELSIZE		(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
//	these values are used in various rounding functions, which includes rounding the advance width
//	they are specific to the rounding operation, if this should become necessary in the future
	#define VIRTUAL_PIXELSIZE_RTDG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RDTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RUTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RTHG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_ROFF	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	

	#define HINTING_HOR_OVERSCALE 1 // see SUBPIXEL_BC above for further comments

#ifdef FSCFG_SUBPIXEL_STANDALONE
	
	#define R_Subpixels		5
	#define G_Subpixels		9
	#define B_Subpixels		2

	/* IMPORTANT :
 
	   If you change any of the above
	   make sure you update abColorIndexTable[] in scentry.c
	   and that (R_Subpixels + 1) * (G_Subpixels + 1) * (B_Subpixels + 1) <= 256

	  */

	#define RGB_OVERSCALE (R_Subpixels + G_Subpixels + B_Subpixels)

#else

	#define SUBPIXEL_OVERSCALE 2

	/* IMPORTANT :
 
	   If you change SUBPIXEL_OVERSCALE
	   make sure you update abColorIndexTable[] in scentry.c
	   and that (SUBPIXEL_OVERSCALE + 1) * (SUBPIXEL_OVERSCALE + 1) * (SUBPIXEL_OVERSCALE + 1) <= 256

	  */

	#define RGB_OVERSCALE (SUBPIXEL_OVERSCALE * 3)
#endif

	#define ROUND_FROM_RGB_OVERSCALE(x) x = ((x) + (RGB_OVERSCALE >> 1) ) / RGB_OVERSCALE
	#define ROUND_FROM_HINT_OVERSCALE(x) x = ((x) + (HINTING_HOR_OVERSCALE >> 1) ) / HINTING_HOR_OVERSCALE
	#define ROUND_RGB_OVERSCALE(x) ((x) + (RGB_OVERSCALE >> 1) ) / RGB_OVERSCALE

	#define FLOOR_RGB_OVERSCALE(x) ((x) < 0) ? -((-(x)+ RGB_OVERSCALE -1) / RGB_OVERSCALE) : ((x) / RGB_OVERSCALE) // by the way, this is NOT a floor operation
	#define CEIL_RGB_OVERSCALE(x) FLOOR_RGB_OVERSCALE((x) + RGB_OVERSCALE -1)

	/* we are storing into 2 bits per pixels, weight for each color can be 0,1 or 2 */
	#define MAX_RGB_INDEX (2 * 16 + 2 * 4 + 2 )

	#define SUBPIXEL_SCALEBACK_FACTOR ((RGB_OVERSCALE << 16) / HINTING_HOR_OVERSCALE)

	#define SUBPIXEL_SCALEBACK_UPPER_LIMIT (SUBPIXEL_SCALEBACK_FACTOR *120 /100)
	#define SUBPIXEL_SCALEBACK_LOWER_LIMIT (SUBPIXEL_SCALEBACK_FACTOR *100 /120)
#endif // FSCFG_SUBPIXEL

#endif  /* FSCDEFS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scale.h ===
/*

	Copyright:  (c) 1992-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				7/10/99  BeatS	Add support for native SP fonts, vertical RGB
	   <1>     02/21/97    CB   claudebe, scaled component in composite glyphs
	   <1>     12/14/95    CB   add private phantom points for vertical positionning
*/

/* total number of phantom points */

typedef enum { evenMult90DRotation = 0, oddMult90DRotation, arbitraryRotation } RotationParity;

#define PHANTOMCOUNT 8

FS_PUBLIC ErrorCode   scl_InitializeScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	boolean         bIntegerScaling,        /* Integer Scaling Flag     */
	transMatrix *   trans,                  /* Current Transformation   */
	uint16          usUpem,                 /* Current units per Em     */
	Fixed           fxPointSize,            /* Current point size       */
	int16           sXResolution,           /* Current X Resolution     */
	int16           sYResolution,           /* Current Y Resolution     */
	uint16          usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16          usEmboldWeighty,      /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16           sWinDescender,
	int32           lDescDev,               /* descender in device metric, used for clipping */
	int16 *			psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *			psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
	boolean			bHintAtEmSquare,
	uint32 *        pulPixelsPerEm);        /* OUT: Pixels Per Em       */

FS_PUBLIC void scl_InitializeChildScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	transMatrix     CurrentTMatrix,                  /* Current Transformation   */
	uint16          usUpem);                 /* Current units per Em     */

FS_PUBLIC void  scl_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16			flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC void  scl_GetCVTPtr(
	void *      pvGlobalGS,
	F26Dot6 **  pfxCVT);

FS_PUBLIC void  scl_ScaleCVT (
	void *      pvGlobalGS,
	F26Dot6 *   pfxCVT);

FS_PUBLIC void  scl_CalcOrigPhantomPoints(
	fnt_ElementType *   pElement,       /* Element                      */
	BBOX *              bbox,           /* Bounding Box                 */
	int16               sNonScaledLSB,  /* Non-scaled Left Side Bearing */
	int16               sNonScaledTSB,  /* Non-scaled Top Side Bearing  */
	uint16              usNonScaledAW,  /* Non-scaled Advance Width     */
	uint16              usNonScaledAH); /* Non-scaled Advance Height    */

FS_PUBLIC void  scl_ScaleOldCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleOldPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleBackCurrentCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleBackCurrentPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleFixedCurrentCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleFixedCurrentPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_OriginalCharPointsToCurrentFixedFUnits(
	fnt_ElementType *   pElement);/* Element */

FS_PUBLIC void  scl_OriginalPhantomPointsToCurrentFixedFUnits(
	fnt_ElementType *   pElement);/* Element */

FS_PUBLIC void  scl_AdjustOldCharSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_AdjustOldPhantomSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_AdjustOldSideBearingPoints(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_CopyOldCharPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_CopyCurrentCharPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_CopyCurrentPhantomPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_RoundCurrentSideBearingPnt(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS, /* GlobalGS */
	uint16              usEmResolution);

FS_PUBLIC void  scl_CalcComponentOffset(
	void *      pvGlobalGS,         /* GlobalGS             */
	int16       sXOffset,           /* IN: X Offset         */
	int16       sYOffset,           /* Y Offset             */
	boolean     bRounding,          /* Rounding Indicator   */
	boolean		bSameTransformAsMaster, /* local transf. same as master transf. */
	boolean     bScaleCompositeOffset,  /* does the component offset need to be scaled Apple/MS */
	transMatrix mulT,                   /* Transformation matrix for composite              */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParityParity,
#endif
	F26Dot6 *   pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *   pfxYOffset);        /* Y Offset             */

FS_PUBLIC void  scl_CalcComponentAnchorOffset(
	fnt_ElementType *   pParentElement,     /* Parent Element       */
	uint16              usAnchorPoint1,     /* Parent Anchor Point  */
	fnt_ElementType *   pChildElement,      /* Child Element        */
	uint16              usAnchorPoint2,     /* Child Anchor Point   */
	F26Dot6 *           pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *           pfxYOffset);        /* Y Offset             */


FS_PUBLIC void scl_ShiftCurrentCharPoints (
	fnt_ElementType *   pElement,
	F26Dot6             xShift,
	F26Dot6             yShift);

FS_PUBLIC void  scl_SetSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB);    /* Right Side Bearing point */

FS_PUBLIC void  scl_SaveSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB);    /* Right Side Bearing point */

FS_PUBLIC void  scl_InitializeTwilightContours(
	fnt_ElementType *   pElement,
	int16               sMaxPoints,
	int16               sMaxContours);

FS_PUBLIC void  scl_ZeroOutlineData(
	fnt_ElementType *   pElement,           /* Element              */
	uint16              usNumberOfPoints,   /* Number of Points     */
	uint16              usNumberOfContours);/* Number of Contours   */

FS_PUBLIC void scl_ZeroOutlineFlags(
	fnt_ElementType * pElement);            /* Element pointer  */

FS_PUBLIC void  scl_IncrementChildElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement);  /* Parent Element pointer   */

FS_PUBLIC void  scl_UpdateParentElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement);  /* Parent Element pointer   */

FS_PUBLIC uint32      scl_GetContourDataSize (
	 fnt_ElementType *  pElement);

FS_PUBLIC void  scl_DumpContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               pbyOutline);

FS_PUBLIC void  scl_RestoreContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline);

FS_PUBLIC void  scl_ScaleAdvanceWidth (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceWidth,
	uint16          usNonScaledAW,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans);

FS_PUBLIC void  scl_ScaleAdvanceHeight (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceHeight,
	uint16          usNonScaledAH,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans);

FS_PUBLIC void  scl_ScaleVerticalMetrics (
	void *          pvGlobalGS,
	uint16          usNonScaledAH,
	int16           sNonScaledTSB,
	boolean         bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans,
	vectorType *    pvecAdvanceHeight,
	vectorType *    pvecTopSideBearing);

FS_PUBLIC void  scl_CalcLSBsAndAdvanceWidths(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceWidth,
	point *             devLeftSideBearing,
	point *             LeftSideBearing,
	point *             devLeftSideBearingLine,
	point *             LeftSideBearingLine);

FS_PUBLIC void  scl_CalcTSBsAndAdvanceHeights(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceHeight,
	point *             devTopSideBearing,
	point *             TopSideBearing,
	point *             devTopSideBearingLine,
	point *             TopSideBearingLine);

FS_PUBLIC void  scl_CalcDevAdvanceWidth(
	fnt_ElementType *   pElement,
	point *             devAdvanceWidth);

FS_PUBLIC void  scl_CalcDevAdvanceHeight(
	fnt_ElementType *   pElement,
	point *             devAdvanceHeight);

FS_PUBLIC void  scl_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM);

FS_PUBLIC void  scl_QueryPPEMXY(
	void *      pvGlobalGS,
	uint16 *    pusPPEMX,
	uint16 *    pusPPEMY);

FS_PUBLIC void scl_45DegreePhaseShift (
	fnt_ElementType *   pElement);

FS_PUBLIC void  scl_PostTransformGlyph (
	void *              pvGlobalGS,         /* GlobalGS             */
	fnt_ElementType *   pElement,
	transMatrix *       trans);

FS_PUBLIC void  scl_ApplyTranslation (
	fnt_ElementType *   pElement,
	transMatrix *       trans,
	boolean             bUseHints,
	boolean             bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	,boolean             bSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC void  scl_LocalPostTransformGlyph(fnt_ElementType * pElement, transMatrix *trans);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  scl_ScaleDownFromSubPixelOverscale (
	fnt_ElementType *   pElement);   /* Element  */

FS_PUBLIC void  scl_ScaleToCompatibleWidth (
	fnt_ElementType *   pElement,  /* Element  */
    Fixed   fxCompatibleWidthScale);  

FS_PUBLIC void  scl_AdjustCompatibleMetrics (
	fnt_ElementType *   pElement,  /* Element  */
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX);  

FS_PUBLIC void  scl_CalcDevHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX);

FS_PUBLIC void  scl_CalcDevNatHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX);

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scale.c ===
/****************************** Module Header ******************************\
* Module Name: Scale.c
*
* Created: 16-Oct-1992
*
* Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
*             (c) 1989-1999. Microsoft Corporation.
*
* All Rights Reserved
*
* History:
*  Tue 16-Oct-1992 09:53:51 -by-  Greg Hitchcock [gregh]
* Created.
*   
*	 7/10/99	BeatS	   Add support for native SP fonts, vertical RGB
*	 4/01/99	BeatS	   Implement alternative interpretation of TT instructions for SP
*	02/21/97    claudebe   scaled component in composite glyphs
*	12/14/95    claudebe   adding two private phantom points for vertical positionning
* .
\***************************************************************************/

#define FSCFG_INTERNAL

/* INCLUDES */

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "fnt.h"
#include "scale.h"

#include "stat.h"

/* Constants    */

/* use the lower ones for public phantom points */

// public phantom points moved to fnt.h more global use

/* private phantom points start here */

#define ORIGINPOINT 4
#define LEFTEDGEPOINT 5

#define TOPORIGINPOINT 6
#define TOPEDGEPOINT 7

#define CANTAKESHIFT    0x02000000

/* MACROS   */

/* d is half of the denumerator */
#define FROUND( x, n, d, s ) \
		((SHORTMUL (x, n) + (d)) >> s)

#define SROUND( x, n, d, halfd ) \
	(x < 0 ? -((SHORTMUL (-(x), (n)) + (halfd)) / (d)) : ((SHORTMUL ((x), (n)) + (halfd)) / (d)))

#define NUMBEROFCHARPOINTS(pElement)  (uint16)(pElement->ep[pElement->nc - 1] + 1)
#define NUMBEROFTOTALPOINTS(pElement)  (uint16)(pElement->ep[pElement->nc - 1] + 1 + PHANTOMCOUNT)

#define LSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTSIDEBEARING)
#define RSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + RIGHTSIDEBEARING)

#define TOPSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPSIDEBEARING)
#define BOTTOMSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + BOTTOMSIDEBEARING)

#define ORIGINPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + ORIGINPOINT)
#define LEFTEDGEPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTEDGEPOINT)

#define TOPORIGINPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPORIGINPOINT)
#define TOPEDGEPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPEDGEPOINT)

/* PROTOTYPES   */

FS_PRIVATE GlobalGSScaleFunc scl_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D);
FS_PRIVATE F26Dot6 scl_FRound (fnt_ScaleRecord* rec, F26Dot6 value);
FS_PRIVATE F26Dot6 scl_SRound (fnt_ScaleRecord* rec, F26Dot6 value);
FS_PRIVATE F26Dot6 scl_FixRound (fnt_ScaleRecord* rec, F26Dot6 value);

FS_PRIVATE void scl_ShiftOldPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift,
	uint16              usFirstPoint,
	uint16              usNumPoints);

FS_PRIVATE void  scl_Scale (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ScaleBack (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ConvertToFixedFUnits (
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ScaleFromFixedFUnits (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);
/* FUNCTIONS    */

#define BOLD_FACTOR 0x51e
#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )
#define POINTSPERINCH               72

void  multiplyForEmbold(long a, long b, long *highRes, long *lowRes)
{
    long lowA, highA, lowB, highB, temp1, temp2;

    lowA = a & 0xffff;
    highA = (a & 0xffff0000) >> 16;
    lowB = b & 0xffff;
    highB = (b & 0xffff0000) >> 16;

    *highRes = highA*highB;
    *lowRes = lowA*lowB;

    temp1 = highA*lowB;
    temp2 = lowA*highB;

    *highRes += (temp1 & 0xffff0000) >> 16;
    *highRes += (temp2 & 0xffff0000) >> 16;

    *lowRes += (temp1 & 0xffff) << 16;
    *lowRes += (temp2 & 0xffff) << 16;
}

void  adjustTrans(transMatrix *trans)   //Adjust matrix for Emboldening
{
    int i,j;
    int  bNegative;
    long tmp, highRes, lowRes;

    for(i=0; i<2; i++)
        for(j=0; j<2; j++){
        
        	tmp = (long) trans->transform[i][j];

            bNegative = tmp < 0 ? TRUE: FALSE;
            tmp = MABS(tmp);

            multiplyForEmbold(tmp, BOLD_FACTOR, &highRes, &lowRes);

            highRes <<= 16;
            tmp -= highRes;

            if(bNegative)
	            tmp = -tmp;

            trans->transform[i][j] = tmp;
        }
}

FS_PUBLIC ErrorCode   scl_InitializeScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	boolean         bIntegerScaling,        /* Integer Scaling Flag     */
	transMatrix *   trans,                  /* Current Transformation   */
	uint16          usUpem,                 /* Current units per Em     */
	Fixed           fxPointSize,            /* Current point size       */
	int16           sXResolution,           /* Current X Resolution     */
	int16           sYResolution,           /* Current Y Resolution     */
	uint16          usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16          usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16           sWinDescender,
	int32           lDescDev,               /* descender in device metric, used for clipping */
	int16 *			psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *			psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
	boolean			bHintAtEmSquare,
	uint32 *        pulPixelsPerEm)         /* OUT: Pixels Per Em       */
{
	Fixed        maxScale;
	Fixed        fxUpem;
	fnt_GlobalGraphicStateType *    globalGS;
	transMatrix   origTrans = *trans;
	uint16		usRotation;
	boolean			non90degreeRotation,nonUniformStretching;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	mth_FoldPointSizeResolution(fxPointSize, sXResolution, sYResolution, trans);

	if ( ( (usEmboldWeightx != 0) || (usEmboldWeighty != 0))  && 							// Adjust matrix for Emboldening
		 (uint16)ROUNDFIXTOINT(ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH)) > 50 )// when bigger than 50 ppem
	{
        adjustTrans(trans);
    }

	mth_ReduceMatrix (trans);

	fxUpem = INTTOFIX(usUpem);

/*
 *  First set up the scalars...
 */

	/*save the flag for use in composite glyphs */
	globalGS->bHintAtEmSquare = bHintAtEmSquare;

	if (bHintAtEmSquare)
	{
		globalGS->interpScalarX = fxUpem;
		globalGS->interpScalarY = fxUpem;
		globalGS->fxMetricScalarX = mth_max_abs (trans->transform[0][0], trans->transform[0][1]);
		globalGS->fxMetricScalarY = mth_max_abs (trans->transform[1][0], trans->transform[1][1]);

		/* we don't want to round the interpScalar */
	}
	else
	{
		globalGS->interpScalarX = mth_max_abs (trans->transform[0][0], trans->transform[0][1]);
		globalGS->interpScalarY = mth_max_abs (trans->transform[1][0], trans->transform[1][1]);
		globalGS->fxMetricScalarX = globalGS->interpScalarX;
		globalGS->fxMetricScalarY = globalGS->interpScalarY;

		if (bIntegerScaling)
		{
			globalGS->interpScalarX = (Fixed)ROUNDFIXED(globalGS->interpScalarX);
			globalGS->interpScalarY = (Fixed)ROUNDFIXED(globalGS->interpScalarY);
		}
	}

	globalGS->ScaleFuncX = scl_ComputeScaling(&globalGS->scaleX, globalGS->interpScalarX, fxUpem);
	globalGS->ScaleFuncY = scl_ComputeScaling(&globalGS->scaleY, globalGS->interpScalarY, fxUpem);

	if (globalGS->interpScalarX >= globalGS->interpScalarY)
	{
		globalGS->ScaleFuncCVT = globalGS->ScaleFuncX;
		globalGS->scaleCVT = globalGS->scaleX;
		globalGS->cvtStretchX = ONEFIX;
		globalGS->cvtStretchY = FixDiv(globalGS->interpScalarY, globalGS->interpScalarX);;
		maxScale = globalGS->interpScalarX;
	}
	else
	{
		globalGS->ScaleFuncCVT = globalGS->ScaleFuncY;
		globalGS->scaleCVT = globalGS->scaleY;
		globalGS->cvtStretchX = FixDiv(globalGS->interpScalarX, globalGS->interpScalarY);
		globalGS->cvtStretchY = ONEFIX;
		maxScale = globalGS->interpScalarY;
	}

	*pulPixelsPerEm = (uint32)ROUNDFIXTOINT (globalGS->interpScalarY);

	globalGS->bSameStretch  = (uint8)mth_SameStretch( globalGS->interpScalarX, globalGS->interpScalarY );
	globalGS->pixelsPerEm   = (uint16)ROUNDFIXTOINT(maxScale);
	globalGS->pointSize     = (uint16)ROUNDFIXTOINT( fxPointSize );
	globalGS->fpem          = maxScale;
	globalGS->identityTransformation = (int8)mth_PositiveSquare( trans );

	/* Use bit 1 of non90degreeTransformation to signify stretching.  stretch = 2 */

	mth_Non90DegreeTransformation(&origTrans,&non90degreeRotation,&nonUniformStretching);

	globalGS->non90DegreeTransformation = 0;

	if (non90degreeRotation)  globalGS->non90DegreeTransformation |= NON90DEGTRANS_ROTATED;
	if (nonUniformStretching) globalGS->non90DegreeTransformation |= NON90DEGTRANS_STRETCH;


	*psBoldSimulHorShift = 0;
	*psBoldSimulVertShift = 0;

	if ((usEmboldWeightx != 0) || (usEmboldWeighty != 0))
	{
		/* we cannot use globalGS->pixelsPerEm because it s incorrect under non 90degree rotation */
		uint16 ppemY;
		Fixed fxBoldSimulHorShift,fxBoldSimulVertShift;
		F26Dot6	fxDefaultDescender;
        transMatrix reverseTrans;
        Fixed   fxDeterminant;
		Fixed fxScale;

		fxScale = ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH);
		ppemY = (uint16)ROUNDFIXTOINT(fxScale);  
		usRotation = mth_90degRotationFactorForEmboldening(trans);
		if( usRotation == 8 )   // Consider Italic/Bold case
            usRotation = mth_90degClosestRotationFactor(trans);

		if (bHintAtEmSquare)
		{
            *psBoldSimulVertShift = (ppemY * usEmboldWeighty - 10) /1000; /* save the number of pixels for bitmap emboldening */
			ppemY = usUpem;
		}

		/* this computation is intended to give backwards compatible results with the
			bitmap emboldening simulation done in Windows NT 4.0
		    The following computation was adapted to get the same cutoff than Win'98 between 50 and 51 ppem
			for an emboldening factor of 2% (usEmboldWeight = 20)
		*/

		globalGS->uBoldSimulVertShift = (ppemY * usEmboldWeighty - 10) /1000;
		globalGS->uBoldSimulHorShift = (ppemY * usEmboldWeightx - 10) /1000 + 1;

		if (!bHintAtEmSquare)
		    *psBoldSimulVertShift = globalGS->uBoldSimulVertShift; /* save the number of pixels for bitmap emboldening */

 		switch(usRotation)                   /* handle 90 degree rotations */
		{
		case 0:                                     // 0 degree with sx>0 & sy>0 or 180 degree with sx<0 & sy<0
			*psBoldSimulHorShift = *psBoldSimulVertShift+1;
			*psBoldSimulVertShift = -(*psBoldSimulVertShift);
 			break;
		case 1:                                     // 90 degree with sx>0 & sy>0 or 270 degree with sx<0 & sy<0
			*psBoldSimulHorShift = -(*psBoldSimulVertShift);
			*psBoldSimulVertShift = -(*psBoldSimulVertShift+1);
			break;
		case 2:                                     // 180 degree with sx>0 & sy>0 or 0 degree with sx<0 & sy<0
			*psBoldSimulHorShift = -(*psBoldSimulVertShift+1);
			*psBoldSimulVertShift = *psBoldSimulVertShift;
			break;
		case 3:                                     // 270 degree with sx>0 & sy>0 or 90 degree with sx<0 & sy<0
			*psBoldSimulHorShift = *psBoldSimulVertShift;
			*psBoldSimulVertShift = *psBoldSimulVertShift + 1;
			break;
		case 4:                                     // 0 degree with sx>0 & sy<0 or 180 degree with sx<0 & sy>0
			*psBoldSimulHorShift = *psBoldSimulVertShift+1;
			*psBoldSimulVertShift = *psBoldSimulVertShift;
 			break;
		case 5:                                     // 90 degree with sx>0 & sy<0 or 270 degree with sx<0 & sy>0
			*psBoldSimulHorShift = *psBoldSimulVertShift;
			*psBoldSimulVertShift = -(*psBoldSimulVertShift+1);
			break;
		case 6:                                     // 180 degree with sx>0 & sy<0 or 0 degree with sx<0 & sy>0
			*psBoldSimulHorShift = -(*psBoldSimulVertShift+1);
			*psBoldSimulVertShift = -*psBoldSimulVertShift;
			break;
		case 7:                                     // 270 degree with sx>0 & sy<0 or 90 degree with sx<0 & sy>0
			*psBoldSimulHorShift = -*psBoldSimulVertShift;
			*psBoldSimulVertShift = *psBoldSimulVertShift + 1;
			break;
		default:                                    /* non 90 degree rotation */
			*psBoldSimulHorShift = 0;
			*psBoldSimulVertShift = 0;
		}

		if (!bHintAtEmSquare && (sYResolution != sXResolution))
		{
			fxBoldSimulHorShift = globalGS->uBoldSimulHorShift << 16;
			fxBoldSimulVertShift = globalGS->uBoldSimulVertShift << 16;
            fxDeterminant = MABS( FixMul(origTrans.transform[0][0],origTrans.transform[1][1]) - FixMul(origTrans.transform[0][1],origTrans.transform[1][0]) );

			if (fxDeterminant == 0)
			{
				globalGS->uBoldSimulHorShift = 0;  
				globalGS->uBoldSimulVertShift = 0;  
			}
			else
			{
				origTrans.transform[0][0] = FixDiv(origTrans.transform[0][0], fxDeterminant);
				origTrans.transform[0][1] = FixDiv(origTrans.transform[0][1], fxDeterminant);
				origTrans.transform[1][0] = FixDiv(origTrans.transform[1][0], fxDeterminant);
				origTrans.transform[1][1] = FixDiv(origTrans.transform[1][1], fxDeterminant);
				reverseTrans = origTrans;
				reverseTrans.transform[0][1] = - reverseTrans.transform[0][1];
				reverseTrans.transform[1][0] = - reverseTrans.transform[1][0];

				mth_IntelMul (
					1,
					&fxBoldSimulHorShift,
					&fxBoldSimulVertShift,
					&origTrans,
					ONEFIX,
					ONEFIX);

				fxBoldSimulHorShift = ShortMulDiv(fxBoldSimulHorShift, sXResolution, sYResolution);

				mth_IntelMul (
					1,
					&fxBoldSimulHorShift,
					&fxBoldSimulVertShift,
					&reverseTrans,
					ONEFIX,
					ONEFIX);

				globalGS->uBoldSimulHorShift = (uint16)ROUNDFIXTOINT(MABS(fxBoldSimulHorShift));  
				globalGS->uBoldSimulVertShift = (uint16)ROUNDFIXTOINT(MABS(fxBoldSimulVertShift));  
			}

        }

		if (!bHintAtEmSquare && !(globalGS->non90DegreeTransformation & NON90DEGTRANS_ROTATED))
		{
			/* 90 degree rotation, convert the device value into 26.6 */
			globalGS->fxScaledDescender = -lDescDev << 6;
		} else 
		{
			/* under rotation, we use the value from head-Descender and scale it */
			fxDefaultDescender = sWinDescender;

			scl_Scale (&globalGS->scaleY,
					globalGS->ScaleFuncY,
					&fxDefaultDescender,
					&globalGS->fxScaledDescender,
					1);

			/* add the uBoldSimulVertShift and round to the next pixel */
			globalGS->fxScaledDescender = globalGS->fxScaledDescender & ~(LOWSIXBITS);
		}
	} else {
		globalGS->uBoldSimulHorShift = 0;
		globalGS->uBoldSimulVertShift = 0;
		globalGS->fxScaledDescender = 0;
	}
	return NO_ERR;
}

FS_PUBLIC void scl_InitializeChildScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	transMatrix     CurrentTMatrix,                  /* Current Transformation   */
	uint16          usUpem)                 /* Current units per Em     */
{
	Fixed        fxUpem;
	fnt_GlobalGraphicStateType *    globalGS;
	Fixed           interpScalarX;    
	Fixed           interpScalarY;    

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	fxUpem = INTTOFIX(usUpem);

/* 
 * This procedure is a subset from scl_InitializeScaling. 
 * There is no perfect solution here, we decided that the best, in the case of a
 * component that is not at the same transformation as the master glyph,
 * is to scale this child glyph to the user grid for hinting, without re-running
 * the pre-program, without rescaling the cvt or changing other GloblaGS information (pointSize, pixelPerEm,...)
 */

/*
 *  First set up the scalars...
 */
	if (globalGS->bHintAtEmSquare)
	{
		interpScalarX = fxUpem;
		interpScalarY = fxUpem;
	}
	else
	{
		interpScalarX = mth_max_abs (CurrentTMatrix.transform[0][0], CurrentTMatrix.transform[0][1]);
		interpScalarY = mth_max_abs (CurrentTMatrix.transform[1][0], CurrentTMatrix.transform[1][1]);
	}

	globalGS->ScaleFuncXChild = scl_ComputeScaling(&globalGS->scaleXChild, interpScalarX, fxUpem);
	globalGS->ScaleFuncYChild = scl_ComputeScaling(&globalGS->scaleYChild, interpScalarY, fxUpem);

}

FS_PUBLIC void  scl_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16			flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    )

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->bHintForGray = bHintForGray;

#ifdef FSCFG_SUBPIXEL
	globalGS->flHintForSubPixel = flHintForSubPixel;
#endif // FSCFG_SUBPIXEL
}

/******************** These three scale 26.6 to 26.6 ********************/
/*
 * Fast (scaling)
 */
FS_PRIVATE F26Dot6 scl_FRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	return (F26Dot6) FROUND (value, rec->numer, rec->denom >> 1, rec->shift);
}

/*
 * Medium (scaling)
 */
FS_PRIVATE F26Dot6 scl_SRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	int32 D;

	D = rec->denom;
	return (F26Dot6) SROUND (value, rec->numer, D, D >> 1);
}

/*
 * Fixed Rounding (scaling), really slow
 */
FS_PRIVATE F26Dot6 scl_FixRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	return (F26Dot6) FixMul ((Fixed)value, rec->fixedScale);
}

/********************************* End scaling utilities ************************/

FS_PRIVATE GlobalGSScaleFunc scl_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D)
{
	int32     lShift;

	lShift = mth_CountLowZeros((uint32)(N | D) ) - 1;

	if (lShift > 0)
	{
		N >>= lShift;
		D >>= lShift;
	}


	if ( N < CANTAKESHIFT )
	{
		N <<= FNT_PIXELSHIFT;
	}
	else
	{
		D >>= FNT_PIXELSHIFT;
	}

	/* fixedScale is now set in every case for the scale back in scaled composites */
	rec->fixedScale = FixDiv(N, D);

	if (N <= SHRT_MAX)   /* Check to see if N fits in a short    */
	{
		lShift = mth_GetShift ((uint32) D);
		rec->numer = (int32)N;
		rec->denom = (int32)D;

		if ( lShift >= 0 )                  /* FAST SCALE */
		{
			rec->shift = (int32)lShift;
			return (GlobalGSScaleFunc)scl_FRound;
		}
		else                                /* MEDIUM SCALE */
		{
			return (GlobalGSScaleFunc)scl_SRound;
		}
	}
	else                                    /* SLOW SCALE */
	{
		return (GlobalGSScaleFunc)scl_FixRound;
	}
}


FS_PRIVATE void  scl_Scale (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;

	if (ScaleFunc == scl_FRound)
	{
		for(Index = 0; Index < numPts; Index++)
		{
			p[Index] = (F26Dot6) FROUND (oop[Index], sr->numer, sr->denom >> 1, sr->shift);
		}
	}
	else
	{
		if (ScaleFunc == scl_SRound)
		{
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) SROUND (oop[Index], sr->numer, sr->denom, sr->denom >> 1);
			}
		}
		else
		{
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) FixMul ((Fixed)oop[Index], sr->fixedScale);
			}
		}
	}
}


FS_PRIVATE void  scl_ScaleFromFixedFUnits (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;
	int32	Scale;
	int32	Shift;
	int32	Numer;

	/* we are now multiplying a 26.6 by sr->numer, we could overflow if (sr->numer >= SHRT_MAX >> FNT_PIXELSHIFT) */
	if ((ScaleFunc == scl_FRound) && (sr->numer < (SHRT_MAX >> FNT_PIXELSHIFT) ))
	{
		
		Shift = sr->shift + FNT_PIXELSHIFT;

		for(Index = 0; Index < numPts; Index++)
		{
			p[Index] = (F26Dot6) FROUND (oop[Index], sr->numer, sr->denom >> 1, Shift);
		}
	}
	else
	{
		if (ScaleFunc == scl_SRound)
		{
			Numer = sr->numer >> FNT_PIXELSHIFT;

			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) SROUND (oop[Index], Numer, sr->denom, sr->denom >> 1);
			}
		}
		else
		{
			Scale = sr->fixedScale >> FNT_PIXELSHIFT;
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) FixMul ((Fixed)oop[Index], Scale);
			}
		}
	}
}

FS_PRIVATE void  scl_ScaleBack (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;
	int32	ScaleBack;

	ScaleBack = sr->fixedScale >> FNT_PIXELSHIFT;
	for(Index = 0; Index < numPts; Index++)
	{
		p[Index] = (F26Dot6) FixDiv ((Fixed)oop[Index], ScaleBack);
	}
}

FS_PRIVATE void  scl_ConvertToFixedFUnits (
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;

	for(Index = 0; Index < numPts; Index++)
	{
		p[Index] = (Fixed)oop[Index] << FNT_PIXELSHIFT;
	}
}

/*
 *  scl_ScaleChar                       <3>
 *
 *  Scales a character
 */

FS_PUBLIC void  scl_ScaleOldCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_Scale (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				pElement->oox,
				pElement->ox,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_Scale (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				pElement->ooy,
				pElement->oy,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_Scale (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pElement->oox,
				pElement->ox,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_Scale (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pElement->ooy,
				pElement->oy,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}
/*
 *  scl_ScaleChar                       <3>
 *
 *  Scales a character
 */

FS_PUBLIC void  scl_ScaleFixedCurrentCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleFromFixedFUnits (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleFromFixedFUnits (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_ScaleFromFixedFUnits (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleFromFixedFUnits (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}

FS_PUBLIC void  scl_ScaleOldPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	if (globalGS->bSameTransformAsMaster)
	{
		scl_Scale (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				&(pElement->oox[usFirstPhantomPoint]),
				&(pElement->ox[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_Scale (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				&(pElement->ooy[usFirstPhantomPoint]),
				&(pElement->oy[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
	else
	{
		scl_Scale (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				&(pElement->oox[usFirstPhantomPoint]),
				&(pElement->ox[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_Scale (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				&(pElement->ooy[usFirstPhantomPoint]),
				&(pElement->oy[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}

}

FS_PUBLIC void  scl_ScaleFixedCurrentPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;


	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	Assert(globalGS->bSameTransformAsMaster);

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	scl_ScaleFromFixedFUnits (&globalGS->scaleX,
			   globalGS->ScaleFuncX,
			   &(pElement->x[usFirstPhantomPoint]),
			   &(pElement->x[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

	scl_ScaleFromFixedFUnits (&globalGS->scaleY,
			   globalGS->ScaleFuncY,
			   &(pElement->y[usFirstPhantomPoint]),
			   &(pElement->y[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

}

/*
 *  scl_ScaleBackCurrentCharPoints                     
 *
 *  Scales back a character to hinted fixed FUnits
 */

FS_PUBLIC void  scl_ScaleBackCurrentCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleBack (&globalGS->scaleX,
			    globalGS->ScaleFuncX,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleBack (&globalGS->scaleY,
			    globalGS->ScaleFuncY,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_ScaleBack (&globalGS->scaleXChild,
			    globalGS->ScaleFuncXChild,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleBack (&globalGS->scaleYChild,
			    globalGS->ScaleFuncYChild,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}

FS_PUBLIC void  scl_ScaleBackCurrentPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleBack (&globalGS->scaleX,
			    globalGS->ScaleFuncX,
				&(pElement->x[usFirstPhantomPoint]),
				&(pElement->x[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_ScaleBack (&globalGS->scaleY,
			    globalGS->ScaleFuncY,
				&(pElement->y[usFirstPhantomPoint]),
				&(pElement->y[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
	else
	{
		scl_ScaleBack (&globalGS->scaleXChild,
			    globalGS->ScaleFuncXChild,
				&(pElement->x[usFirstPhantomPoint]),
				&(pElement->x[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_ScaleBack (&globalGS->scaleYChild,
			    globalGS->ScaleFuncYChild,
				&(pElement->y[usFirstPhantomPoint]),
				&(pElement->y[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
}

/*
 *  scl_OriginalCharPointsToCurrentFixedFUnits                     
 *
 *  Scales back a character to hinted fixed FUnits
 */

FS_PUBLIC void  scl_OriginalCharPointsToCurrentFixedFUnits (
	fnt_ElementType *   pElement) /* Element */
{

	scl_ConvertToFixedFUnits (
			   pElement->oox,
			   pElement->x,
			   (int32)NUMBEROFCHARPOINTS(pElement));

	scl_ConvertToFixedFUnits (
			   pElement->ooy,
			   pElement->y,
			   (int32)NUMBEROFCHARPOINTS(pElement));
}

FS_PUBLIC void  scl_OriginalPhantomPointsToCurrentFixedFUnits (
	fnt_ElementType *   pElement) /* Element */
{
	uint16                    usFirstPhantomPoint;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	scl_ConvertToFixedFUnits (
			   &(pElement->oox[usFirstPhantomPoint]),
			   &(pElement->x[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

	scl_ConvertToFixedFUnits (
			   &(pElement->ooy[usFirstPhantomPoint]),
			   &(pElement->y[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);
}

/*
 * scl_ScaleCVT
 */

FS_PUBLIC void  scl_ScaleCVT(
	void *      pvGlobalGS,
	F26Dot6 *   pfxCVT)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if(globalGS->cvtCount > 0)
	{
		scl_Scale (
			&globalGS->scaleCVT,
			globalGS->ScaleFuncCVT,
			pfxCVT,
			globalGS->controlValueTable,
			(int32)globalGS->cvtCount);
	}
}

FS_PUBLIC void  scl_GetCVTPtr(
	void *      pvGlobalGS,
	F26Dot6 **  pfxCVT)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pfxCVT = globalGS->controlValueTable;

}

FS_PUBLIC void  scl_CalcOrigPhantomPoints(
	fnt_ElementType *   pElement,       /* Element                      */
	BBOX *              bbox,           /* Bounding Box                 */
	int16               sNonScaledLSB,  /* Non-scaled Left Side Bearing */
	int16               sNonScaledTSB,  /* Non-scaled Top Side Bearing  */
	uint16              usNonScaledAW,  /* Non-scaled Advance Width     */
	uint16              usNonScaledAH)  /* Non-scaled Advance Height    */
{

	F26Dot6             fxXMinMinusLSB;
	F26Dot6             fxYMaxPlusTSB;

	MEMSET (&(pElement->ooy[LSBPOINTNUM(pElement)]),
			'\0',
			PHANTOMCOUNT * sizeof (pElement->ooy[0]));

	MEMSET (&(pElement->oox[LSBPOINTNUM(pElement)]),
			'\0',
			PHANTOMCOUNT * sizeof (pElement->oox[0]));

	fxXMinMinusLSB = ((F26Dot6)bbox->xMin - (F26Dot6)sNonScaledLSB);

	pElement->oox[LSBPOINTNUM(pElement)] = fxXMinMinusLSB;
	pElement->oox[RSBPOINTNUM(pElement)] = fxXMinMinusLSB + (F26Dot6)usNonScaledAW;
	pElement->oox[ORIGINPOINTNUM(pElement)] = fxXMinMinusLSB;
	pElement->oox[LEFTEDGEPOINTNUM(pElement)] = (F26Dot6)bbox->xMin;

	fxYMaxPlusTSB = ((F26Dot6)bbox->yMax + (F26Dot6)sNonScaledTSB);

	pElement->ooy[TOPSBPOINTNUM(pElement)] = fxYMaxPlusTSB;
	pElement->ooy[BOTTOMSBPOINTNUM(pElement)] = fxYMaxPlusTSB - (F26Dot6)usNonScaledAH;
	pElement->ooy[TOPORIGINPOINTNUM(pElement)] = fxYMaxPlusTSB;
	pElement->ooy[TOPEDGEPOINTNUM(pElement)] = (F26Dot6)bbox->yMax;
}

FS_PUBLIC void  scl_AdjustOldCharSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6     fxOldLeftOrigin;
	F26Dot6     fxNewLeftOrigin;
	uint16      cNumCharPoints;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	cNumCharPoints = NUMBEROFCHARPOINTS(pElement);

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	scl_ShiftOldPoints (
		pElement,
		fxNewLeftOrigin - fxOldLeftOrigin,
		0L,
		0,
		cNumCharPoints);

}

FS_PUBLIC void  scl_AdjustOldPhantomSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6     fxOldLeftOrigin;
	F26Dot6     fxNewLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	scl_ShiftOldPoints (
		pElement,
		fxNewLeftOrigin - fxOldLeftOrigin,
		0L,
		LSBPOINTNUM(pElement),
		PHANTOMCOUNT);
}

FS_PUBLIC void  scl_AdjustOldSideBearingPoints(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6 fxOldLeftOrigin;
	F26Dot6 fxNewLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	pElement->ox[LSBPOINTNUM(pElement)]  = fxNewLeftOrigin;
	pElement->ox[RSBPOINTNUM(pElement)] += fxNewLeftOrigin - fxOldLeftOrigin;
}

FS_PUBLIC void  scl_CopyOldCharPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	MEMCPY(pElement->ox, pElement->x, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
	MEMCPY(pElement->oy, pElement->y, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_CopyCurrentCharPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	MEMCPY(pElement->x, pElement->ox, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
	MEMCPY(pElement->y, pElement->oy, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_CopyCurrentPhantomPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	uint16    usFirstPhantomPoint;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);
	MEMCPY(&pElement->x[usFirstPhantomPoint],
		   &pElement->ox[usFirstPhantomPoint],
		   PHANTOMCOUNT * sizeof(F26Dot6));

	MEMCPY(&pElement->y[usFirstPhantomPoint],
		   &pElement->oy[usFirstPhantomPoint],
		   PHANTOMCOUNT * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_RoundCurrentSideBearingPnt(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS, /* GlobalGS */
	uint16              usEmResolution)
{
	F26Dot6     fxWidth;
	F26Dot6     fxHeight;
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	/* autoround the right side bearing */

	fxWidth = FIXEDTODOT6 (ShortMulDiv( (int32)globalGS->interpScalarX,
		(int16)(pElement->oox[RSBPOINTNUM(pElement)] - pElement->oox[LSBPOINTNUM(pElement)]),
		(int16)usEmResolution ));
/*
	fxWidth = globalGS->ScaleFuncX(&globalGS->scaleX,
		(pElement->oox[RSBPOINTNUM(pElement)] - pElement->oox[LSBPOINTNUM(pElement)]));
*/

#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)  ) {
		fxWidth += VIRTUAL_PIXELSIZE_RTG / 2;
		fxWidth &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else { // for SubPixel in compatible width mode, always round to full pixel to get full pixel advance width
#endif
		fxWidth += FNT_PIXELSIZE / 2;
		fxWidth &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif
	pElement->x[RSBPOINTNUM(pElement)] = pElement->x[LSBPOINTNUM(pElement)] + fxWidth;

	/* autoround the top side bearing */

	fxHeight = FIXEDTODOT6 (ShortMulDiv( (int32)globalGS->interpScalarY,
		(int16)(pElement->ooy[BOTTOMSBPOINTNUM(pElement)] - pElement->ooy[TOPSBPOINTNUM(pElement)]),
		(int16)usEmResolution ));
/*
	fxHeight = globalGS->ScaleFuncY(&globalGS->scaleY,
		(pElement->ooy[BOTTOMSBPOINTNUM(pElement)] - pElement->ooy[TOPSBPOINTNUM(pElement)]));
*/

	/* in the vertical direction, as we don't round the old TOPSBPOINT 
	    and do scl_ShiftOldPoints, we need to round TOPSBPOINT here */
	pElement->y[TOPSBPOINTNUM(pElement)] =
		(pElement->y[TOPSBPOINTNUM(pElement)] + DOT6ONEHALF) & ~(LOWSIXBITS);

	pElement->y[BOTTOMSBPOINTNUM(pElement)] =
		pElement->y[TOPSBPOINTNUM(pElement)] + (fxHeight + DOT6ONEHALF) & ~(LOWSIXBITS);
}

/*
 *  scl_ShiftChar
 *
 *  Shifts a character          <3>
 */
FS_PUBLIC void scl_ShiftCurrentCharPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift)

{
	uint32  ulCharIndex;

	if (fxXShift != 0)
	{
		for(ulCharIndex = 0; ulCharIndex < (uint32)NUMBEROFCHARPOINTS(pElement); ulCharIndex++)
		{
		   pElement->x[ulCharIndex] += fxXShift;
		}
	}

	if (fxYShift != 0)
	{
		for(ulCharIndex = 0; ulCharIndex < (uint32)NUMBEROFCHARPOINTS(pElement); ulCharIndex++)
		{
		   pElement->y[ulCharIndex] += fxYShift;
		}
	}
}

FS_PRIVATE void scl_ShiftOldPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift,
	uint16              usFirstPoint,
	uint16              usNumPoints)
{
	uint32  ulCharIndex;

	if (fxXShift != 0)
	{
		for(ulCharIndex = (uint32)usFirstPoint; ulCharIndex < ((uint32)usFirstPoint + (uint32)usNumPoints); ulCharIndex++)
		{
			pElement->ox[ulCharIndex] += fxXShift;
		}
	}

	if (fxYShift != 0)
	{
		for(ulCharIndex = (uint32)usFirstPoint; ulCharIndex < ((uint32)usFirstPoint + (uint32)usNumPoints); ulCharIndex++)
		{
			pElement->oy[ulCharIndex] += fxYShift;
		}
	}
}

FS_PUBLIC void  scl_CalcComponentOffset(
	void *      pvGlobalGS,         /* GlobalGS             */
	int16       sXOffset,           /* IN: X Offset         */
	int16       sYOffset,           /* Y Offset             */
	boolean     bRounding,          /* Rounding Indicator   */
	boolean		bSameTransformAsMaster, /* local transf. same as master transf. */
	boolean     bScaleCompositeOffset,  /* does the component offset need to be scaled Apple/MS */
	transMatrix mulT,                   /* Transformation matrix for composite              */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParity,
#endif
	F26Dot6 *   pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *   pfxYOffset)         /* Y Offset             */
{
	fnt_GlobalGraphicStateType *    globalGS;
	Fixed     scalarX;
	Fixed     scalarY;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (bSameTransformAsMaster) {
		*pfxXOffset = globalGS->ScaleFuncX(&globalGS->scaleX,(F26Dot6)sXOffset);
		*pfxYOffset = globalGS->ScaleFuncY(&globalGS->scaleY,(F26Dot6)sYOffset);
	} else {
		*pfxXOffset = globalGS->ScaleFuncXChild(&globalGS->scaleXChild,(F26Dot6)sXOffset);
		*pfxYOffset = globalGS->ScaleFuncYChild(&globalGS->scaleYChild,(F26Dot6)sYOffset);
	}

	if (bScaleCompositeOffset)
	/* the composite is designed to have its offset scaled (designed for Apple) */
	{
		/* Apple use a 45 degree special case that they are dropping on their GX rasterizer,
		   I'm not implementing this special rule here */
		scalarX = mth_max_abs (mulT.transform[0][0], mulT.transform[0][1]);
		scalarY = mth_max_abs (mulT.transform[1][0], mulT.transform[1][1]);
		if ((scalarX != ONEFIX) || (scalarY != ONEFIX)) {
			*pfxXOffset = (F26Dot6) FixMul ((Fixed)*pfxXOffset, scalarX);
			*pfxYOffset = (F26Dot6) FixMul ((Fixed)*pfxYOffset, scalarY);
		}
	}

	if (bRounding) {
#ifdef FSCFG_SUBPIXEL
		if (RunningSubPixel(globalGS) && ((rotationParity == arbitraryRotation) || ((rotationParity == evenMult90DRotation) != VerticalSPDirection(globalGS)))) {
			*pfxXOffset += VIRTUAL_PIXELSIZE_RTG / 2;
			*pfxXOffset &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
		} else {
#endif
			*pfxXOffset += FNT_PIXELSIZE / 2;
			*pfxXOffset &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
		}
#endif
#ifdef FSCFG_SUBPIXEL
		if (RunningSubPixel(globalGS) && ((rotationParity == arbitraryRotation) || ((rotationParity == evenMult90DRotation) == VerticalSPDirection(globalGS)))) {
			*pfxYOffset += VIRTUAL_PIXELSIZE_RTG / 2;
			*pfxYOffset &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
		} else {
#endif
			*pfxYOffset += FNT_PIXELSIZE / 2;
			*pfxYOffset &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
		}
#endif
	}
	if (!bSameTransformAsMaster)
	/* we need to scale back the offset in fixed FUnits */
	{
		scl_ScaleBack (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pfxXOffset,
				pfxXOffset,
				1 /* only one value to scale */);
		scl_ScaleBack (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pfxYOffset,
				pfxYOffset,
				1 /* only one value to scale */);
	}
}

FS_PUBLIC void  scl_CalcComponentAnchorOffset(
	fnt_ElementType *   pParentElement,     /* Parent Element       */
	uint16              usAnchorPoint1,     /* Parent Anchor Point  */
	fnt_ElementType *   pChildElement,      /* Child Element        */
	uint16              usAnchorPoint2,     /* Child Anchor Point   */
	F26Dot6 *           pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *           pfxYOffset)         /* Y Offset             */
{
	*pfxXOffset = pParentElement->x[usAnchorPoint1] - pChildElement->x[usAnchorPoint2];
	*pfxYOffset = pParentElement->y[usAnchorPoint1] - pChildElement->y[usAnchorPoint2];
}



FS_PUBLIC void  scl_SetSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB)     /* Right Side Bearing point */
{
	uint16    usPhantomPointNumber;

	usPhantomPointNumber = LSBPOINTNUM(pElement);
	pElement->x[usPhantomPointNumber] = pptLSB->x;
	pElement->y[usPhantomPointNumber] = pptLSB->y;
	usPhantomPointNumber++;
	pElement->x[usPhantomPointNumber] = pptRSB->x;
	pElement->y[usPhantomPointNumber] = pptRSB->y;
}

FS_PUBLIC void  scl_SaveSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB)     /* Right Side Bearing point */
{
	uint16    usPhantomPointNumber;

	usPhantomPointNumber = LSBPOINTNUM(pElement);
	pptLSB->x = pElement->x[usPhantomPointNumber];
	pptLSB->y = pElement->y[usPhantomPointNumber];
	usPhantomPointNumber++;
	pptRSB->x = pElement->x[usPhantomPointNumber];
	pptRSB->y = pElement->y[usPhantomPointNumber];
}

FS_PUBLIC void  scl_InitializeTwilightContours(
	fnt_ElementType *   pElement,       /* Element  */
	int16               sMaxPoints,
	int16               sMaxContours)
{
	pElement->sp[0] = 0;
	pElement->ep[0] = sMaxPoints - 1;
	pElement->nc = sMaxContours;
}

FS_PUBLIC void  scl_ZeroOutlineData(
	fnt_ElementType * pElement,     /* Element pointer  */
	uint16      usNumberOfPoints,
	uint16      usNumberOfContours)
{

	MEMSET (&pElement->x[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->ox[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->oox[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));

	MEMSET (&pElement->y[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->oy[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->ooy[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));

	MEMSET (&pElement->onCurve[0], 0, (size_t)usNumberOfPoints * sizeof(uint8));
	MEMSET (&pElement->f[0], 0, (size_t)usNumberOfPoints * sizeof(uint8));

	MEMSET (&pElement->sp[0], 0, (size_t)usNumberOfContours * sizeof(int16));
	MEMSET (&pElement->ep[0], 0, (size_t)usNumberOfContours * sizeof(int16));
}

FS_PUBLIC void scl_ZeroOutlineFlags(
	fnt_ElementType * pElement)     /* Element pointer  */
{
	MEMSET (&pElement->f[0], 0, (size_t)NUMBEROFTOTALPOINTS(pElement) * sizeof(uint8));
}

FS_PUBLIC void  scl_IncrementChildElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement)   /* Parent Element pointer   */
{
	uint16          usParentNewStartPoint;

	if(pParentElement->nc != 0)
	{
		usParentNewStartPoint = LSBPOINTNUM(pParentElement);

		pChildElement->x = &pParentElement->x[usParentNewStartPoint];
		pChildElement->y = &pParentElement->y[usParentNewStartPoint];

		pChildElement->ox = &pParentElement->ox[usParentNewStartPoint];
		pChildElement->oy = &pParentElement->oy[usParentNewStartPoint];

		pChildElement->oox = &pParentElement->oox[usParentNewStartPoint];
		pChildElement->ooy = &pParentElement->ooy[usParentNewStartPoint];

		pChildElement->onCurve = &pParentElement->onCurve[usParentNewStartPoint];
		pChildElement->f = &pParentElement->f[usParentNewStartPoint];

		pChildElement->fc = &pParentElement->fc[pParentElement->nc];

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		pChildElement->pcr = &pParentElement->pcr[usParentNewStartPoint];
#endif

		pChildElement->sp = &pParentElement->sp[pParentElement->nc];
		pChildElement->ep = &pParentElement->ep[pParentElement->nc];

		pChildElement->nc = 0;
	}
	else
	{
		MEMCPY(pChildElement, pParentElement, sizeof(fnt_ElementType));
	}
}

FS_PUBLIC void  scl_UpdateParentElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement)   /* Parent Element pointer   */
{
	uint16          usNumberOfParentPoints;
	uint32          ulPointIndex;

	if(pParentElement->nc != 0)
	{
		usNumberOfParentPoints = NUMBEROFCHARPOINTS(pParentElement);

		for(ulPointIndex = (uint32)(uint16)pParentElement->nc;
			ulPointIndex < (uint32)(uint16)pParentElement->nc + (uint32)(uint16)pChildElement->nc;
			ulPointIndex++)
		{
			pParentElement->sp[ulPointIndex] += (int16)usNumberOfParentPoints;
			pParentElement->ep[ulPointIndex] += (int16)usNumberOfParentPoints;
		}
	}

	pParentElement->nc += pChildElement->nc;
}

FS_PUBLIC uint32      scl_GetContourDataSize (
	 fnt_ElementType *  pElement)
{
	 uint16 usNumberOfPoints;
	 uint32 ulSize;

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 ulSize =  sizeof( pElement->nc );
	 ulSize += sizeof( *pElement->sp ) * (size_t)pElement->nc;
	 ulSize += sizeof( *pElement->ep ) * (size_t)pElement->nc;
	 ulSize += sizeof( *pElement->x ) * (size_t)usNumberOfPoints;
	 ulSize += sizeof( *pElement->y ) * (size_t)usNumberOfPoints;
	 ulSize += sizeof( *pElement->onCurve ) * (size_t)usNumberOfPoints;

	 return( ulSize );
}

FS_PUBLIC void  scl_DumpContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline)
{
	 uint16 usNumberOfPoints;

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 *((int16 *)*ppbyOutline) = pElement->nc;
	 *ppbyOutline += sizeof( pElement->nc   );

	 MEMCPY(*ppbyOutline, pElement->sp, (size_t)pElement->nc * sizeof( *pElement->sp ));
	 *ppbyOutline += (size_t)pElement->nc * sizeof( *pElement->sp );

	 MEMCPY(*ppbyOutline, pElement->ep, (size_t)pElement->nc * sizeof( *pElement->ep ));
	 *ppbyOutline += (size_t)pElement->nc * sizeof( *pElement->sp );

	 MEMCPY(*ppbyOutline, pElement->x, (size_t)usNumberOfPoints * sizeof(*pElement->x));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->x );

	 MEMCPY(*ppbyOutline, pElement->y, (size_t)usNumberOfPoints * sizeof(*pElement->y));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->y );

	 MEMCPY(*ppbyOutline, pElement->onCurve, (size_t)usNumberOfPoints * sizeof(*pElement->onCurve));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->onCurve );

}

FS_PUBLIC void  scl_RestoreContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline)
{
	 uint16 usNumberOfPoints;

	 pElement->nc = *((int16 *)(*ppbyOutline));
	 *ppbyOutline += sizeof( int16 );

	 pElement->sp = (int16 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)pElement->nc * sizeof( int16 );

	 pElement->ep = (int16 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)pElement->nc * sizeof( int16 );

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 pElement->x = (F26Dot6 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( F26Dot6 );

	 pElement->y = (F26Dot6 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( F26Dot6 );

	 pElement->onCurve = (uint8 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( uint8 );
}

FS_PUBLIC void  scl_ScaleAdvanceWidth (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceWidth,
	uint16          usNonScaledAW,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans)

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	 if ( bPositiveSquare )
	{
		AdvanceWidth->x = (Fixed)ShortMulDiv( (int32)globalGS->fxMetricScalarX, (int16)usNonScaledAW, (int16)usEmResolution );
        if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
	}
	else
	{
		AdvanceWidth->x = FixRatio( (int16)usNonScaledAW, (int16)usEmResolution );
        if ((globalGS->fxMetricScalarX != ONEFIX) && (globalGS->uBoldSimulHorShift != 0))
        {
            AdvanceWidth->x = FixMul(AdvanceWidth->x, globalGS->fxMetricScalarX);
            if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		        AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
            AdvanceWidth->x = FixDiv(AdvanceWidth->x, globalGS->fxMetricScalarX);
        }
        else
        {
            if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		        AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
        }
		mth_FixXYMul( &AdvanceWidth->x, &AdvanceWidth->y, trans );
	}
}

FS_PUBLIC void  scl_ScaleAdvanceHeight (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceHeight,
	uint16          usNonScaledAH,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans)

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	 if ( bPositiveSquare )
	{
		AdvanceHeight->y = (Fixed)ShortMulDiv( (int32)globalGS->fxMetricScalarY, (int16)usNonScaledAH, (int16)usEmResolution );
        if (AdvanceHeight->y != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceHeight->y += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
	}
	else
	{
		AdvanceHeight->y = FixRatio( (int16)usNonScaledAH, (int16)usEmResolution );
        if (AdvanceHeight->y != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceHeight->y += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
		mth_FixXYMul( &AdvanceHeight->x, &AdvanceHeight->y, trans );
	}
}

FS_PUBLIC void  scl_ScaleVerticalMetrics (
	void *          pvGlobalGS,
	uint16          usNonScaledAH,
	int16           sNonScaledTSB,
	boolean         bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans,
	vectorType *    pvecAdvanceHeight,
	vectorType *    pvecTopSideBearing
)
{
	fnt_GlobalGraphicStateType *    globalGS;

	if ( bPositiveSquare )
	{
	    globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
		pvecAdvanceHeight->y = (Fixed)ShortMulDiv(
		    (int32)globalGS->fxMetricScalarY, 
		    (int16)usNonScaledAH, 
		    (int16)usEmResolution );
		
		pvecTopSideBearing->y = (Fixed)ShortMulDiv(
		    (int32)globalGS->fxMetricScalarY, 
		    sNonScaledTSB, 
		    (int16)usEmResolution );
	}
	else
	{
		pvecAdvanceHeight->y = FixRatio( (int16)usNonScaledAH, (int16)usEmResolution );
		mth_FixXYMul( &pvecAdvanceHeight->x, &pvecAdvanceHeight->y, trans );

		pvecTopSideBearing->y = FixRatio( sNonScaledTSB, (int16)usEmResolution );
		mth_FixXYMul( &pvecTopSideBearing->x, &pvecTopSideBearing->y, trans );
	}
}


FS_PUBLIC void  scl_CalcLSBsAndAdvanceWidths(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceWidth,
	point *             devLeftSideBearing,
	point *             LeftSideBearing,
	point *             devLeftSideBearingLine,
	point *             LeftSideBearingLine)
{
	scl_CalcDevAdvanceWidth(pElement, devAdvanceWidth);

	devLeftSideBearing->x = f26XMin - pElement->x[LSBPOINTNUM(pElement)];
	devLeftSideBearing->y = f26YMax - pElement->y[LSBPOINTNUM(pElement)];

	LeftSideBearing->x = pElement->x[LEFTEDGEPOINTNUM(pElement)];
	LeftSideBearing->x -= pElement->x[ORIGINPOINTNUM(pElement)];
	LeftSideBearing->y = f26YMax - pElement->y[LEFTEDGEPOINTNUM(pElement)];
	LeftSideBearing->y -= pElement->y[ORIGINPOINTNUM(pElement)];

	*devLeftSideBearingLine = *devLeftSideBearing;
	*LeftSideBearingLine = *LeftSideBearing;

}

FS_PUBLIC void  scl_CalcDevAdvanceWidth(
	fnt_ElementType *   pElement,
	point *             devAdvanceWidth)

{
	devAdvanceWidth->x = pElement->x[RSBPOINTNUM(pElement)]; 
	devAdvanceWidth->x -= pElement->x[LSBPOINTNUM(pElement)];
	devAdvanceWidth->y = pElement->y[RSBPOINTNUM(pElement)]; 
	devAdvanceWidth->y -= pElement->y[LSBPOINTNUM(pElement)];
}

FS_PUBLIC void  scl_CalcTSBsAndAdvanceHeights(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceHeight,
	point *             devTopSideBearing,
	point *             TopSideBearing,
	point *             devTopSideBearingLine,
	point *             TopSideBearingLine)
{
	scl_CalcDevAdvanceHeight(pElement, devAdvanceHeight);

	devTopSideBearing->x = f26XMin - pElement->x[TOPSBPOINTNUM(pElement)];
	devTopSideBearing->y = f26YMax - pElement->y[TOPSBPOINTNUM(pElement)];

	TopSideBearing->x = f26XMin - pElement->x[TOPEDGEPOINTNUM(pElement)];
	TopSideBearing->x -= pElement->x[TOPORIGINPOINTNUM(pElement)];
	TopSideBearing->y = pElement->y[TOPEDGEPOINTNUM(pElement)];
	TopSideBearing->y -= pElement->y[TOPORIGINPOINTNUM(pElement)];

	*devTopSideBearingLine = *devTopSideBearing;
	*TopSideBearingLine = *TopSideBearing;

}

FS_PUBLIC void  scl_CalcDevAdvanceHeight(
	fnt_ElementType *   pElement,
	point *             devAdvanceHeight)

{
	devAdvanceHeight->x = pElement->x[TOPSBPOINTNUM(pElement)]; 
	devAdvanceHeight->x -= pElement->x[BOTTOMSBPOINTNUM(pElement)];
	devAdvanceHeight->y = pElement->y[TOPSBPOINTNUM(pElement)]; 
	devAdvanceHeight->y -= pElement->y[BOTTOMSBPOINTNUM(pElement)];
}


FS_PUBLIC void  scl_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pusPPEM = globalGS->pixelsPerEm;
}

/*  Return ppem in X and Y directions for sbits */

FS_PUBLIC void  scl_QueryPPEMXY(
	void *      pvGlobalGS,
	uint16 *    pusPPEMX,
	uint16 *    pusPPEMY)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pusPPEMX = (uint16)ROUNDFIXTOINT(globalGS->interpScalarX);
	*pusPPEMY = (uint16)ROUNDFIXTOINT(globalGS->interpScalarY);
}


FS_PUBLIC void scl_45DegreePhaseShift (
	fnt_ElementType *   pElement)
{
  F26Dot6 * x;
  int16     count;

  x = pElement->x;
  count = (int16)NUMBEROFCHARPOINTS(pElement) - 1;
  for (; count >= 0; --count)
  {
	(*x)++;
	++x;
  }
}

/*
 *  scl_PostTransformGlyph              <3>
 */
FS_PUBLIC void  scl_PostTransformGlyph (
	void *              pvGlobalGS,         /* GlobalGS             */
	fnt_ElementType *   pElement,
	transMatrix *       trans)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bHintAtEmSquare)
	{
		mth_IntelMul (
			(int32)NUMBEROFTOTALPOINTS (pElement),
			pElement->x,
			pElement->y,
			trans,
			globalGS->interpScalarX,
			globalGS->interpScalarY); 
	}
	else
	{
		mth_IntelMul (
			(int32)NUMBEROFTOTALPOINTS (pElement),
			pElement->x,
			pElement->y,
			trans,
	/*        globalGS->interpScalarX,
			globalGS->interpScalarY); */
			globalGS->fxMetricScalarX,
			globalGS->fxMetricScalarY);
	}
}

/*
 *  scl_ApplyTranslation              
 */
FS_PUBLIC void  scl_ApplyTranslation (
	fnt_ElementType *   pElement,
	transMatrix *       trans,
	boolean             bUseHints,
	boolean             bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	,boolean             bSubPixel
#endif // FSCFG_SUBPIXEL
   )
{
	int32 ulPointIndex;
	F26Dot6 xShift, yShift;

	/* transform from 16.16 to 26.6 */
	xShift = (trans->transform[0][2] + 0x200) >> 10;
	yShift = (trans->transform[1][2] + 0x200) >> 10;

#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
	{
		xShift = xShift * RGB_OVERSCALE;
    }
#endif

	/* lsb point should be moved to (0,0) so that we can get correct bitmap bounding box when overscaling */
	xShift -= pElement->x[LSBPOINTNUM(pElement)];
	yShift -= pElement->y[LSBPOINTNUM(pElement)];

	
	if (bUseHints && !bHintAtEmSquare) {
#ifdef FSCFG_SUBPIXEL
		if (bSubPixel) {
			/* We want to round to a virtual pixel boundary when hinted */ 
			xShift += VIRTUAL_PIXELSIZE_RTG/2; 
			xShift &= ~(VIRTUAL_PIXELSIZE_RTG - 1); 
		} else {
#endif
			/* We want to round to a pixel boundary when hinted */ 
			xShift += FNT_PIXELSIZE/2; 
			xShift &= ~(FNT_PIXELSIZE - 1); 
#ifdef FSCFG_SUBPIXEL
		}
#endif
	}

	if (xShift != 0 || yShift != 0)
	{
		for(ulPointIndex = 0;
				ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
				ulPointIndex++)
		{
			pElement->x[ulPointIndex] += xShift;
			pElement->y[ulPointIndex] += yShift;
		}
	}

}
/*
 *      scl_LocalPostTransformGlyph                             <3>
 *
 * (1) Inverts the stretch from the CTM
 * (2) Applies the local transformation passed in in the trans parameter
 * (3) Applies the global stretch from the root CTM
 * (4) Restores oox, ooy, oy, ox, and f.
 */
FS_PUBLIC void  scl_LocalPostTransformGlyph(fnt_ElementType * pElement, transMatrix *trans)
{
	int32 lCount;

	lCount = (int32)NUMBEROFTOTALPOINTS(pElement);

	mth_IntelMul (lCount, pElement->x, pElement->y, trans, ONEFIX, ONEFIX);
}

#ifdef FSCFG_SUBPIXEL

FS_PUBLIC void  scl_ScaleDownFromSubPixelOverscale (
	fnt_ElementType *   pElement)   /* Element  */
{
	int32 ulPointIndex;
	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->ox[ulPointIndex] = ROUND_RGB_OVERSCALE(pElement->x[ulPointIndex]);
	}
}

FS_PUBLIC void  scl_ScaleToCompatibleWidth (
	fnt_ElementType *   pElement,  /* Element  */
    Fixed   fxCompatibleWidthScale)  
{
	int32 ulPointIndex;

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->x[ulPointIndex] = FixMul(pElement->x[ulPointIndex], fxCompatibleWidthScale);
	}
}


FS_PUBLIC void  scl_AdjustCompatibleMetrics (
	fnt_ElementType *   pElement,  /* Element  */
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX)
{
	int32 ulPointIndex;

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFCHARPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->x[ulPointIndex] += horTranslation;
	}
    pElement->x[RSBPOINTNUM(pElement)] = pElement->x[LSBPOINTNUM(pElement)] + newDevAdvanceWidthX;
}


FS_PUBLIC void  scl_CalcDevHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX)
{
	int32 ulPointIndex;
	F26Dot6 fxMaxX;             /* for bounding box left, right */

	*pDevLeftSideBearingX = LONG_MAX;     /* default bounds limits */
	fxMaxX = LONG_MIN;

	*pDevAdvanceWidthX = pElement->x[RSBPOINTNUM(pElement)]; 
	*pDevAdvanceWidthX -= pElement->x[LSBPOINTNUM(pElement)];

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFCHARPOINTS(pElement);
			ulPointIndex++)
	{
		if (pElement->x[ulPointIndex] > fxMaxX)
			fxMaxX = pElement->x[ulPointIndex];
		if (pElement->x[ulPointIndex] < *pDevLeftSideBearingX)
			*pDevLeftSideBearingX = pElement->x[ulPointIndex];
	}

    FS_ASSERT(*pDevLeftSideBearingX != LONG_MAX, "scl_CalcDevHorMetrics called on an empty glyph\n");

    *pDevRightSideBearingX = *pDevAdvanceWidthX - fxMaxX;

}

FS_PUBLIC void  scl_CalcDevNatHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX)
{
	int32 ulPointIndex;

	*pDevLeftSideBearingX = LONG_MAX; *pDevRightSideBearingX = LONG_MIN;
	*pNatLeftSideBearingX = LONG_MAX; *pNatRightSideBearingX = LONG_MIN;
	
	*pDevAdvanceWidthX = pElement->x[RSBPOINTNUM(pElement)]  - pElement->x[LSBPOINTNUM(pElement)];
	*pNatAdvanceWidthX = pElement->ox[RSBPOINTNUM(pElement)] - pElement->ox[LSBPOINTNUM(pElement)];

	for(ulPointIndex = 0; ulPointIndex < NUMBEROFCHARPOINTS(pElement); ulPointIndex++) {
		if (pElement->x[ulPointIndex]  > *pDevRightSideBearingX) *pDevRightSideBearingX = pElement->x[ulPointIndex];
		if (pElement->x[ulPointIndex]  < *pDevLeftSideBearingX)  *pDevLeftSideBearingX  = pElement->x[ulPointIndex];
		if (pElement->ox[ulPointIndex] > *pNatRightSideBearingX) *pNatRightSideBearingX = pElement->ox[ulPointIndex];
		if (pElement->ox[ulPointIndex] < *pNatLeftSideBearingX)  *pNatLeftSideBearingX  = pElement->ox[ulPointIndex];
	}

    FS_ASSERT(*pDevLeftSideBearingX != LONG_MAX, "scl_CalcDevHorMetrics called on an empty glyph\n");

    *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevRightSideBearingX;
    *pNatRightSideBearingX = *pNatAdvanceWidthX - *pNatRightSideBearingX;
} // scl_CalcDevNatHorMetrics

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scbitmap.h ===
/*********************************************************************

	  scbitmap.h -- BitMap Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/19/93 deanb    fsc_CalcGrayRow added
	   6/10/93 deanb    fsc_InitializeBitMasks added
	   4/29/93 deanb    BLTCopy routine added
	   9/15/92 deanb    GetBit returns uint32 
	   8/17/92 deanb    GetBit, SetBit added 
	   7/27/92 deanb    ClearBitMap call added 
	   6/02/92 deanb    Row pointer, integer limits, no descriptor 
	   4/09/92 deanb    New types again 
	   3/16/92 deanb    New types 
	   1/15/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/


FS_PUBLIC void fsc_InitializeBitMasks (
		void
);

FS_PUBLIC int32 fsc_ClearBitMap ( 
		uint32,             /* longs per bmp */
		uint32*             /* bitmap ptr caste long */
);

FS_PUBLIC int32 fsc_BLTHoriz ( 
		int32,              /* x start */
		int32,              /* x stop */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_BLTCopy ( 
		uint32*,            /* source row pointer */
		uint32*,            /* destination row pointer */
		int32               /* long word counter */
);

FS_PUBLIC uint32 fsc_GetBit ( 
		int32,              /* x coordinate */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_SetBit ( 
		int32,              /* x coordinate */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_CalcGrayRow(
		GrayScaleParam*     /* pointer to param block */
);


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scendpt.h ===
/*********************************************************************

	  scendpt.h -- EndPoint Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTP added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetEndpointElemSize returns size_t 
	   9/08/92 deanb    GetEndpointElemSize added 
	   7/24/92 deanb    ContourSave functions deleted 
	   4/09/92 deanb    New types again 
	   3/20/92 deanb    New types, save contour functions 
	   1/14/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupEndPt ( PSTATE0 );

FS_PUBLIC void fsc_BeginContourEndpoint( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* starting point x coordinate */
		F26Dot6             /* starting point y coordinate */
);

FS_PUBLIC int32 fsc_CheckEndPoint( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* x coordinate */
		F26Dot6,            /* y coordinate */
		uint16              /* scan control type */
);

FS_PUBLIC int32 fsc_EndContourEndpoint( 
		PSTATE              /* pointer to state variables */
		uint16              /* scan control type */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scgray.h ===
/*********************************************************************

	  scgray.h -- Gray Scale Parameter Block Definition

	  (c) Copyright 1993  Microsoft Corp.  All rights reserved.

	   8/23/93 deanb    First cut 

**********************************************************************/

#ifndef FSCGRAY_DEFINED
#define FSCGRAY_DEFINED


#include "fscdefs.h"                /* for type definitions */

/*********************************************************************/

/*      Gray scale calculation parameters                            */

/*********************************************************************/

typedef struct
{
	char* pchOver;                  /* pointer to overscaled bitmap */
	char* pchGray;                  /* pointer to gray scale bitmap */
	int16 sGrayCol;                 /* number of gray columns to calc */
	uint16 usOverScale;             /* outline magnification factor */
	uint16 usFirstShift;            /* first byte's shift */
	char* pchOverLo;                /* low limit of overscaled bitmap */
	char* pchOverHi;                /* high limit of overscaled bitmap */
	char* pchGrayLo;                /* low limit of gray scale bitmap */
	char* pchGrayHi;                /* high limit of gray scale bitmap */
}
GrayScaleParam;


/*********************************************************************/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scglobal.h ===
/*********************************************************************

      scglobal.h -- Information shared by all scan converter modules

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       7/09/93 deanb    include fsconfig.h removed (fscdefs does it)
       4/19/93 deanb    banding limits added
       4/12/93 deanb    from old scconst.h + scstate.h

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */

/********************************************************************/

/*      Internal Constant Values                                    */

/********************************************************************/

#define HUGEINT         0x7FFF          /* impossibly large int16 value */
#define HUGEFIX         0x7FFFFFFFL     /* impossibly large fx value */

#define SUBPIX          64L             /* sub pixels per pix */
#define SUBHALF         32L             /* one half of SUBPIX */
#define SUBSHFT         6               /* log base two of SUBPIX */
    
#define ONSCANLINE(y)   ((y) & (SUBPIX - 1L)) == SUBHALF
#define SCANABOVE(y)    ((((y) + SUBHALF) & (-SUBPIX)) + SUBHALF)
#define SCANBELOW(y)    ((((y) - SUBHALF - 1L) & (-SUBPIX)) + SUBHALF)

/*      Math macros      */

#define FXABS(x)  ((x) >= 0L ? (x) : -(x))

/*      Module codes for subpix callbacks   */

#define SC_LINECODE     0
#define SC_SPLINECODE   1
#define SC_ENDPTCODE    2

#define SC_MAXCODES     3               /* number of codes above */
#define SC_CODESHFT     2               /* bits needed to store codes */
#define SC_CODEMASK     0x0003          /* to mask off codes */


/**********************************************************************

    The following structure defines all of the state variables for the 
    scan converter.  This structure is allocated statically for a non-
    reentrant implementation, or as an automatic variable to permit 
    reentrancy.  There are three sets of variables: one for the endpoint 
    module, one for scanlist, and one for memory.  Rules of the game are 
    that each module accesses ONLY its own variables for reading AND 
    writing.  It is possible for one module to read another's variables, 
    BUT IT WOULD BE WRONG.

**********************************************************************/

typedef struct statevar
{

/* endpoint state variables */

    F26Dot6 fxX0, fxY0;             /* point from call before last */
    F26Dot6 fxX1, fxY1;             /* point from previous call */
    F26Dot6 fxX2Save, fxY2Save;     /* for closing the contour */
                 
/* scanlist state variables */

    int32 lBoxLeft;                 /* bounding box xmin */
    int32 lBoxRight;                /* bounding box xmax */
    int32 lBoxTop;                  /* bounding box ymax */
    int32 lBoxBottom;               /* bounding box ymin */
    int32 lRowBytes;                /* bitmap bytes per row */
    int32 lHiScanBand;              /* banding upper scan limit */
    int32 lLoScanBand;              /* banding lower scan limit */
    int32 lHiBitBand;               /* banding upper bitmap limit */
    int32 lLoBitBand;               /* banding lower bitmap limit */
    int32 lLastRowIndex;            /* last row scan line index */
    uint32* pulLastRow;             /* for dropout banding */

    int16 **apsHOnBegin;            /* beginning of on pointers array */
    int16 **apsHOffBegin;           /* beginning of off pointers array */
    int16 **apsHOnEnd;              /* end of on pointers array */
    int16 **apsHOffEnd;             /* end of off pointers array */
    int16 **apsHorizBegin;          /* current pointer array */
    int16 **apsHorizEnd;            /* current pointer array */

    int16 **apsVOnBegin;            /* beginning of on pointers array */
    int16 **apsVOffBegin;           /* beginning of off pointers array */
    int16 **apsVOnEnd;              /* end of on pointers array */
    int16 **apsVOffEnd;             /* end of off pointers array */
    int16 **apsVertBegin;           /* current pointer array */
    int16 **apsVertEnd;             /* current pointer array */
              
#ifdef FSCFG_REENTRANT              /* needed to avoid circular PSTATE */
    void (*pfnAddHoriz)(struct statevar*, int32, int32);
    void (*pfnAddVert)(struct statevar*, int32, int32);
#else
    void (*pfnAddHoriz)(int32, int32);
    void (*pfnAddVert)(int32, int32);
#endif

    F26Dot6 (*pfnHCallBack[SC_MAXCODES])(int32, F26Dot6*, F26Dot6*);
    F26Dot6 (*pfnVCallBack[SC_MAXCODES])(int32, F26Dot6*, F26Dot6*);
        
    F26Dot6 *afxXPoints;            /* x element control points */
    F26Dot6 *afxYPoints;            /* y element control points */
    int32 lElementPoints;           /* estimate of element points */
    int32 lPoint;                   /* index to element control points */
    uint16 usScanTag;               /* stores point index, element code */
    int16 sIxSize;                  /* int16's per intersection */
    int16 sIxShift;                 /* log2 of size */

/* memory state variables */

    char *pchHNextAvailable;        /* horizontal memory pointer */
    char *pchVNextAvailable;        /* vertical memory pointer */
    char *pchHWorkSpaceEnd;         /* horizontal memory overflow */
    char *pchVWorkSpaceEnd;         /* vertical memory overflow */
}
StateVars;

/********************************************************************/

/*              Reentrancy parameters                               */

/********************************************************************/

#ifdef FSCFG_REENTRANT

#define PSTATE      StateVars *pState,
#define PSTATE0     StateVars *pState
#define ASTATE      pState,
#define ASTATE0     pState
#define STATE       (*pState)

#else 

#define PSTATE
#define PSTATE0     void
#define ASTATE
#define ASTATE0
#define STATE       State

extern  StateVars   State;              /* statically alloc'd in NewScan */

#endif 

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\interp.c ===
/*********************************************************************

	  interp.c -- TT Rasterizer Interpreter Module

	  Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				  (c) 1989-1999. Microsoft Corporation, all rights reserved.

	   7/10/99  BeatS	 62 Add support for native SP fonts, vertical RGB
	   4/01/99  BeatS	 61 Implement alternative interpretation of TT instructions for SP
	  10/14/97  claudebe 60 ClaudeBe, allowing a trace function to know if in FontProgram
							access to unitialized data
	  04/29/97  claudebe 59 ClaudeBe, catching illegal recursion and infinite loops
	  02/21/97  claudebe 58 ClaudeBe, scaled component in composite glyphs
	   2/05/96  claudebe 57 compfont for itpr_MD, wrong zone pointer
	   2/05/96  claudebe 56 GetInfo return HintForGray information
	   8/12/94  deanb  55   orphan routine CHECK_STATE deleted
	   2/09/94  deanb  54   RASTERIZER_VERSION defined for GETINFO
	  12/17/93  deanb  53   CHECK_POINT zone corrected in MIRP
	  12/08/93  deanb  52   itrp_SCANTYPE enabled for smart dropout control
	   9/15/93  deanb  51   InnerTraceEx double call fixed; iOpCode -> lOpCode
	   7/29/93  deanb  50   ALIGNPTS, SHE fixed; InnerTraceExecute saves first
	   7/12/93  deanb  49   itrp_IllegalInstruction works
	   6/28/93  deanb  48   gbyPushTable made const
	   2/16/93  deanb  47   fxUnRounded set after check single width
	   2/15/93  deanb  46   fall back to MIRPG when using single width
	   2/15/93  deanb  45   vector defaults for FONTPROGRAM, stat back
	   2/12/93  deanb  44   delete stat code
	   2/12/93  deanb  43   cleanup MSIRP & itrp_Execute
	   2/12/93  deanb  42   branch itrp_IP on MovePoint
	   2/11/93  deanb  41   use c8 register calling convetions
	   2/11/93  deanb  40   switch to Microsoft C ver 8
	   2/09/93  deanb  39   skipPushData inline in itrp_IF
	   2/09/93  deanb  38   do fast MIRP's with if statments
	   2/09/93  deanb  37   remove fast MDRPX and MIRPY routines
	   2/09/93  deanb  36   fast MDRPX and MIRPY routines
	   2/08/93  deanb  35   cleanup MIRPs, combine if statments
	   2/08/93  deanb  34   dual rounding with 6 ptr init values
	   2/08/93  deanb  33   IUP inner loop pointer check
	   2/08/93  deanb  32   repair skipPushData for npushw
	   2/05/93  deanb  31   check for fxHintedDelta = 0
	   2/05/93  deanb  30   use roundFuncPtr in fast MIRP's
	   2/05/93  deanb  29   itrp_SWAP done in place
	   2/05/93  deanb  28   fntMirpFunc defined for MIRPG/X/Y
	   2/05/93  deanb  27   iOpCode passed in to all functions
	   2/05/93  deanb  26   use instr ptr for param and return
	   2/04/93  deanb  25   pull oldRange out of itrp_IP loops
	   2/04/93  deanb  24   movePoint check for proj.x/y = 1
	   2/03/93  deanb  23   table driven skipPushData
	   2/03/93  deanb  22   zero based Unary Operand pointers
	   2/01/93  deanb  21   split out SetRoundState
	   2/01/93  deanb  20   eliminate OpCode assignemnt, registers
	   2/01/93  deanb  19   bump Normalize limit up to 0x20000000L
	   1/29/93  deanb  18   add SuperRound MIRPG fallback
	   1/29/93  deanb  17   fast MIRPX and MIRPY routines
	   1/27/93  deanb  16   single rounding routines restored
	   1/27/93  deanb  15   innerExecute tune up
	   1/27/93  deanb  14   rounding routines for engine/no engine
	   1/27/93  deanb  13   repair itrp_Normalize for BIG vectors
	   1/26/93  deanb  12   split out SPVTCA and SFVTCA
	   1/26/93  deanb  11   clean up itrp_IP
	   1/26/93  deanb  10   return IUP to old start/end calc
	   1/25/93  deanb   9   use pointers in IUP loops
	   1/25/93  deanb   8   major rewrite of itrp_IUP
	   1/25/93  deanb   7   rewrite itrp_Normalize
	   1/22/93  deanb   6   split and do Unary Operands in place
	   1/22/93  deanb   5   do Binary Operands in place
	   1/22/93  deanb   4   split out BinaryOperand
	   1/22/93  deanb   3   split out PUSHB1 and PUSHW1
	   1/22/93  deanb   2   split out PushSomeBytes/Words
	   1/22/93  deanb   1   split out SRP0-2, LLOOP, POP
	   1/22/93  deanb   0   STAT card timing added
	   1/22/93  deanb       dead code/comments moved to history.fnt
 
**********************************************************************/

#define FSCFG_INTERNAL

#include "fscdefs.h"
#include "fontmath.h"
#include "sfnt.h"
#include "fnt.h"
#include "interp.h"
#include "fserror.h"

#include "stat.h"                   /* for STAT card timing only */

#include <stdio.h>

#ifdef SEGMENT_LINK
#pragma segment FNT_C
#endif

/* perfect spot size (Fixed) */
#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

#ifdef FSCFG_SUBPIXEL
#define RASTERIZER_VERSION  37      /* MS reserved values 33 - 64 */
#else
#define RASTERIZER_VERSION  35      /* MS reserved values 33 - 64 */
#endif // FSCFG_SUBPIXEL
									/* 33 = Rasterizer v1.5 */
									/* 34 = Rasterizer v1.6 */
									/* 35 = Rasterizer v1.7 */
									/* 36 = Rasterizer v1.6+, Windows CE, SubPixel */
									/* 37 = Rasterizer v1.8, Windows XP (NT 5.1), SubPixel */

#ifdef FSCFG_SUBPIXEL
	// the following are 9 switches to avoid all kinds of "hinting techniques" that have adverse effects on SubPixel
	// they should be considered "band-aid" solutions, to avoid us the worst of the worst with existing fonts.
	// in the future, fonts that are optimized for SubPixel should be tagged as such.
	// This will permit to switch these switches off again.
	#define RDTGRoundsDownToGrid		// to avoid not aligning control points when Align translates to MDRP with RDTG preceded by SPVTL
	#define NoVirtRoundInPrep			// to avoid PMingLiU vertically misplacing strokes (vectors not set properly in prep for certain calculations)
	#define RoundOffRespectsCvtCutIn	// to avoid Palatino Italic's fractional grey-scale targetted cvts and unrounded MIRP (little r) which bypasses cvt cut-in
	#define MSIRPRespectsCvtCutIn		// to avoid fonts pre-calculating a distance and subsequently MSIRPing it (neither rounding nor cvt cut-in involved in MSIRP)
	#define InlineDeltasOnly			// to avoid all kinds of bumps, blops, or irregular weight gains
	#define BypassDandIStroke			// to avoid collapsing strokes in (partly) auto-hinted fonts using DStroke and IStroke commands
	#define BypassJellesSpacing			// to avoid bloated characters
	#define BypassVacuformRound			// to avoid diamond shaped characters
	#define AssistTomsDiagonal			// to avoid Georgia italic to become upright

	// values derived from the primary values in fscdefs.h
	#define CVT_CUT_IN_OVERSCALE	VIRTUAL_OVERSCALE	// high value to encourage MIRP to fall back on original distance to avoid stroke weight jumps in size ramp
	#define ENGINE_COMP_OVERSCALE	VISUAL_OVERSCALE	// value not particularly relevant as engine compensation is not currently used
	#define MIN_DIST_OVERSCALE		VISUAL_OVERSCALE	// value not terribly important as it basically affects the minimum stroke weight

	#define Tuned4SubPixel(globalGS) ((uint16)((globalGS)->localParBlock.instructControl & TUNED4SPFLAG))
#else
	#define Tuned4SubPixel(globalGS) (false)
#endif

#define MAX_ELEMENTS 2
#define TWILIGHTZONE 0 /* The point storage */
#define GLYPHELEMENT 1 /* The actual glyph */

/* those constant are used as default to catch illegal fonts */
#define INTERP_MAX_JUMPS			10000
#define INTERP_MAX_RECURSIVE_CALLS	100

#define MAXANGLES       20

#define ROTATEDGLYPH        0x0100
#define STRETCHEDGLYPH      0x0200
/* new Apple 1994 */
#define VARIATIONGLYPH      0x0400
#define VERTICALGLYPH       0x0800
/* new Microsoft 1996 */
#define HINTEDFORGRAYGLYPH  0x1000

#define VERSIONINTERPRETERQUERY          0x0001
#define ROTATEDINTERPRETERQUERY          0x0002
#define STRETCHEDINTERPRETERQUERY        0x0004
/* new Apple 1994 */
#define VARIATIONINTERPRETERQUERY        0x0008
#define VERTICALMETRICSINTERPRETERQUERY  0x0010
/* new Microsoft 1996 */
#define HINTFORGRAYINTERPRETERQUERY      0x0020

/* new Microsoft 1998
   moved out of FSCFG_SUBPIXEL to build debug version for non SP environment */
#define HINTFORSUBPIXELINTERPRETERQUERY						0x0040
#define HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY		0x0080
#define HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY	0x0100
#define HINTFORSUBPIXELBGRORDERINTERPRETERQUERY				0x0200

#ifdef FSCFG_SUBPIXEL
/* new Microsoft 1998 */
#define HINTEDFORSUBPIXELGLYPH								0x02000
#define HINTEDFORSUBPIXELCOMPATIBLEWIDTHGLYPH				0x04000
#define HINTEDFORSUBPIXELVERTICALDIRECTIONGLYPH				0x08000
#define HINTEDFORSUBPIXELBGRORDERGLYPH						0x10000
#endif // FSCFG_SUBPIXEL

// this includes all SP specific flags, since we don't want a SP enabled font to break on a non SP enabled rasterizer
#define SELECTOR_FLAGS (VERSIONINTERPRETERQUERY | ROTATEDINTERPRETERQUERY | STRETCHEDINTERPRETERQUERY |					\
						VARIATIONINTERPRETERQUERY | VERTICALMETRICSINTERPRETERQUERY | HINTFORGRAYINTERPRETERQUERY |		\
						HINTFORSUBPIXELINTERPRETERQUERY | HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY |			\
						HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY | HINTFORSUBPIXELBGRORDERINTERPRETERQUERY)

#define MAXBYTE_INSTRUCTIONS 256

#define ONEVECTOR                       ONESHORTFRAC
#define VECTORMUL(value, component)     ShortFracMul((F26Dot6)(value), (ShortFract)(component))
#define VECTORDOT(a,b)                  ShortFracDot((ShortFract)(a),(ShortFract)(b))
#define VECTORDIV(num,denum)            ShortFracDiv((ShortFract)(num),(ShortFract)(denum))
#define VECTORMULDIV(a,b,c)             ShortFracMulDiv((ShortFract)(a),(ShortFract)(b),(ShortFract)(c))
#define VECTOR2FIX(a)                   ((Fixed) (a) << 2)
#define ONESIXTEENTHVECTOR              ((ONEVECTOR) >> 4)

#ifdef FSCFG_REENTRANT
#define GSP0    fnt_LocalGraphicStateType* pLocalGS
#define GSP     fnt_LocalGraphicStateType* pLocalGS,
#define GSA0    pLocalGS
#define GSA     pLocalGS,
#define LocalGS (*pLocalGS)
#else 
#define GSP0    void
#define GSP
#define GSA0
#define GSA
fnt_LocalGraphicStateType LocalGS
 #ifndef FSCFG_NO_INITIALIZED_DATA
  = {0}
 #endif 
;
#endif 


#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )


/* Common Interpreter Function Parameter */

#define IPARAM         GSP uint8 *pbyInst, int32 lOpCode

#define MIRPG          0
#define MIRPX          1
#define MIRPY          2
				  
// color compensation flags in ROUND, MDRP, and MIRP
#define	GREY	0
#define BLACK	1
#define WHITE	2
#define OTHER	3

// flags for UTP, IUP, MovePoint
#define XMOVED 0x01
#define YMOVED 0x02


#define NUM_PHANTOM_PTS   4L

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA // master switch

	#define NumRelationShips(elem) (elem->ep[elem->nc - 1] + 1 + NUM_PHANTOM_PTS)

	// Make an empty data structure (DAG)
	void InitPhaseControl(fnt_ElementType *elem) {
		long i;
		PhaseControlRelation *rel;

		for (i = 0; i < NumRelationShips(elem); i++) {
			rel = &elem->pcr[i];
			rel->parent0 = rel->parent1 = rel->child = -1;
			rel->flags = 0;
			rel->phaseShift = 0;
		}
		elem->phaseControlExecuted = false;
	} // InitPhaseControl

	//	Function to avert circular dependencies, whose traversal would cause endless recursion in
	//	"PhaseShift" further below.
	//
	//	In the trivial case (self dependency), a child would depend on itself. This scenario is ex-
	//	cluded by respective tests in the callers.
	//
	//	In the simplest non-trivial case (direct dependency), before linking from a parent to a child,
	//	we want to determine whether the child links back to the parent:
	//
	//		IndirectlyDependsOn(..., parent, child, ...) ?
	//
	//	If it does, then "self" (the parent) depends on "whom" (the child), and we'd get a circular
	//	dependency, because the child would depend on the parent as a result of "AddDistance":
	//
	//		rel->parent0 == whom ?
	//
	//	noting that "rel" points to self's phase control relation structure.
	//
	//	In the more general case (indirect dependency, which includes direct dependency via zero
	//	indirections), self's parent may depend on the child (and recursively), hence:
	//
	//		rel->parent0 == whom || IndirectlyDependsOn(..., rel->parent0, whom, ...) ?
	//
	//	In the most general case, there may be two parents involved, hence we have to follow both
	//	lines of ancestry:
	//
	//		rel->parent0 == whom || IndirectlyDependsOn(..., rel->parent0, whom, ...) || 
	//		rel->parent1 == whom || IndirectlyDependsOn(..., rel->parent1, whom, ...) ?
	//
	//	Notice that in the actual code the latter is re-arranged for efficiency.
	//	Notice also that we don't have a simple case of tail recursion, which could be replaced by
	//	an iteration easily.

	boolean IndirectlyDependsOn(fnt_ElementType *elem, long self, long whom, long level) {
		PhaseControlRelation *rel;

		level--;
		if (level < 0) return true; // safeguard against stack overflow, probably redundant

	//	here we assume that we're called only from within AddDistance or AddProportion, hence
	//	"self" and "whom" have been range checked initially. Every recursion changes the actual
	//	value of "self", but only to a value obtained from a "pcr", which only gets range checked
	//	values, hence we don't need to range check "self" again. "whom" is invariant anyhow.
	//	Additionally, we also assume that "self" and "whom" are not the same. Since the algorithm
	//	below terminates if "self"'s parent equals "whom", "self" never becomes "whom".

		rel = &elem->pcr[self];
		if (rel->parent0 == -1) // 0 parents (MDAP, MIAP)
			return false; // no dependencies
		else if (rel->parent1 == -1) // 1 parent (MDRP, MIRP, SHP, ALIGNRP, etc.)
			return rel->parent0 == whom || IndirectlyDependsOn(elem,rel->parent0,whom,level-1);
		else // 2 parents (IP)
			return rel->parent0 == whom || rel->parent1 == whom || IndirectlyDependsOn(elem,rel->parent0,whom,level-1) || IndirectlyDependsOn(elem,rel->parent1,whom,level-1);
		return false; // we shouldn't get down here, but the compiler thinks we do...
	} // IndirectlyDependsOn

	// Called from the TT interpreter whenever a MIRP, MDRP, SHP, ALIGNRP (etc.) is executed
	// Add a distance relationship to the DAG
	void AddDistance(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, long from, long to, long color) {
		long parent;

		if (0 <= from && from < NumRelationShips(elem) && 0 <= to && to < NumRelationShips(elem) && from != to) { // prevent endless recursions
			if (IndirectlyDependsOn(elem,from,to,INTERP_MAX_RECURSIVE_CALLS))
				elem->pcr[to].flags |= BADREL;
			else if (elem->pcr[to].parent0 == -1) { // we have no parent for this child
				while ((parent = elem->pcr[from].parent0) != -1 && elem->oox[from] == elem->oox[parent])
					from = parent; // simplify link structure in case of links to "align" vertical edges
				elem->pcr[to].parent0 = (int16)from; // first link wins, bad links may produce suboptimal phase control
				elem->pcr[to].parent1 = -1;
			}
			if (color == BLACK && elem->pcr[from].child == -1 && elem->pcr[to].child != from) { // first black link wins...
				if ((parent = elem->pcr[from].parent0) != -1 && elem->pcr[parent].child == from)
					elem->pcr[to].flags |= BADREL;
				else
					elem->pcr[from].child = (int16)to;
			}
		}
	} // AddDistance
	
	// Called from the TT interpreter when an IP is executed
	// Add a proportion relationship to the DAG
	void AddProportion(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, long from0, long to, long from1) {
		if (0 <= from0 && from0 < NumRelationShips(elem) && 0 <= from1 && from1 < NumRelationShips(elem) && 0 <= to && to < NumRelationShips(elem) && from0 != to && from1 != to && from0 != from1) { // prevent endless recursions
			if (IndirectlyDependsOn(elem,from0,to,INTERP_MAX_RECURSIVE_CALLS) || IndirectlyDependsOn(elem,from1,to,INTERP_MAX_RECURSIVE_CALLS))
				elem->pcr[to].flags |= BADREL;
			else if (elem->pcr[to].parent0 == -1 && elem->pcr[to].parent1 == -1) {
				elem->pcr[to].parent0 = (int16)from0; // first interpolate wins, bad interpolates
				elem->pcr[to].parent1 = (int16)from1; // ...may produce suboptimal phase control
			}
		}
	} // AddProportion
	
	// Calculate the phase shift resulting from a child point that depends on two parent points by proportion (interpolation)
	F26Dot6 CalcAvgXPhaseShift(fnt_ElementType *elem, long parent0, long child, long parent1, F26Dot6 phase0, F26Dot6 phase1) {
		F26Dot6 leftX,childX,rightX,leftPhase,rightPhase;
		
		// the phase of child control points that are interpolated between a pair of parent control points depends on the phase
		// applied to both of these parent control points.
		// If both parents have the same phase, then the child point gets that phase
		if (phase0 == phase1) return phase0; // IPs "within" strokes

		// if the phase is different, we try to calculcate a weighted average.
		// In dubious cases, this may fail (divide-by-zero), in which case we fall back on an unweighted (plain) average.
		if (elem->ox[parent0] < elem->ox[parent1]) {
			leftX = elem->ox[parent0]; rightX = elem->ox[parent1];
			leftPhase = phase0; rightPhase = phase1;
		} else {
			leftX = elem->ox[parent1]; rightX = elem->ox[parent0];
			leftPhase = phase1; rightPhase = phase0;
		}
		childX = elem->ox[child];
		
		return leftX != rightX 
			? ((childX - leftX)*rightPhase + (rightX - childX)*leftPhase)/(rightX - leftX) // weighted average
			: (leftPhase + rightPhase) / 2; // unweighted average
	} // CalcAvgXPhaseShift
	
	// This is the part that (recursively) traverses the data structure to apply the above rules, called from ExecutePhaseControl below
	// Notice that it works much like the early prototype for the compiler that translates VTT's GUI into TMT
	F26Dot6 PhaseShift(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, short anyBadRelation, long child) {
		PhaseControlRelation *rel,*childRel;
		F26Dot6 phase;
		
		if (child == -1) return 0; // nothing, hence no phase shift
		
		rel = &elem->pcr[child];
		
		if (rel->flags & DOING) return 0; // prevent from endless recursion due to circular dependencies; probably redundant
		rel->flags |= DOING;

		if ((rel->flags & DONE) == 0) { // else been there already, know phase
			if (child > elem->ep[elem->nc-1]) { // LSB, RSB
				phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
			} else if (rel->parent0 == -1) { // MDAP, MIAP
				if (anyBadRelation) {
					phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
				} else {
					phase = 0;
				}
			} else if (rel->parent1 == -1) { // MDRP, MIRP, SHP, ALIGNRP, ...
				phase = PhaseShift(localGS,elem,anyBadRelation,rel->parent0);
			} else { // IP
				phase = CalcAvgXPhaseShift(elem,rel->parent0,child,rel->parent1,PhaseShift(localGS,elem,anyBadRelation,rel->parent0),PhaseShift(localGS,elem,anyBadRelation,rel->parent1));
			}
			
			if ((rel->flags & DONE) == 0) { // still not done, after above recursion
				if (rel->child != -1 && ((childRel = &elem->pcr[rel->child])->flags & DONE) == 0) {
					if (rel->parent0 == -1 || rel->parent1 == -1) { // not IP
						phase = LongMulDiv(elem->x[child] + elem->x[rel->child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x20000);
					}
					
					elem->x[child] += phase;
					elem->x[rel->child] += phase;
					
					childRel->phaseShift = phase;
					childRel->flags |= DONE;
				
				// else if we're linked to, and we're not a leaf, such as in a chain of links through a 'v',
				// do the proportional thing, in order not to twist the 'v'
				// additionally, we may want to make the decision, which "stroke" wins, a bit smarter,
				// by giving preference to the one with the lesser |dy|

				} else {
					if (anyBadRelation && rel->parent1 == -1 && (rel->parent0 == -1 || elem->ox[child] != elem->ox[rel->parent0])) {
					//	bad MDRP, MIRP, SHP, ALIGNRP, MDAP, or MIAP, but not in case aligned along vertical edge
						phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
					} // else IP
					if (rel->parent0 != -1) {
						elem->x[child] += phase;
					}
				}
				rel->phaseShift = phase;
				rel->flags |= DONE;
			}
		}

		rel->flags &= ~DOING;
		return rel->phaseShift;
	} // PhaseShift

	// This is a plain old loop
	// It is never to be executed in the twilight zone, hence all the guards upon calling it.
	void ExecutePhaseControl(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem) {
		long i,numRelationShips;
		short anyBadRelation;
		F26Dot6 phase;

		numRelationShips = NumRelationShips(elem);
		for (i = 0; i < numRelationShips && (elem->pcr[i].flags & BADREL) == 0; i++);
		anyBadRelation = i < numRelationShips;
		for (i = 0; i < numRelationShips; i++) {
			phase = PhaseShift(localGS,elem,anyBadRelation,i);
		}
		elem->phaseControlExecuted = true;
	} // ExecutePhaseControl

	// helper function
	long ContNum(fnt_ElementType *elem, long knot) {
		long i;

		for (i = 0; i < elem->nc && knot > elem->ep[i]; i++);
		return i < elem->nc ? i : -1;
	} // ContNum

	// The "concertina algorithm" uses the color flags in the MDRP and MIRP instructions to "determine" the existence
	// of stems. Most of the time, the color flags are set correctly; in fact, if the TT code is generated by the TMT
	// compiler, they should always be correct. However, there is a small number of cases where the flags are erroneous
	// (a black stroke which is not flagged as black) or misleading (the extent of a cross bar, which is a black link
	// as defined in the TMT compiler, but which for the purpose of this algorithm had rather not be flagged as black).
	// Not surprisingly, most of these cases (avoiding to say, all of them) happen on grotesque fonts, with the MDRP
	// or MIRP between two neighbouring points on the outline (cases in which a compiler generating TT code could ar-
	// gueably be undecided). Therefore we make a last ditch effort in this function to correct the colour flags for
	// this special class of problems.
	long DoubleCheckLinkColor(fnt_ElementType *elem, long from, long to, long color) {
		long fromCont,fromStart,fromEnd,fromSucc,fromPred,toCont,toSucc,toPred;
		boolean fromRightTurn,toRightTurn,properlyOriented;

		// first, determine whether we link between a pair of neighbours on one and the same contour
		// one of the knots is not on any contour (LSB, RSB), hence can't be neighbours
		if ((fromCont = ContNum(elem,from)) < 0 || // error
			(toCont   = ContNum(elem,to))   < 0)
			return GREY; // it's not a black stroke
		
		// if they belong to different contours, we don't attempt to improve color flag
		if (fromCont != toCont) return color;
		
		// if they belong to the same contour, but are not neighbours, we don't attempt to improve color flag, either
		fromStart = elem->sp[fromCont];
		fromEnd   = elem->ep[fromCont];
		fromSucc = from == fromEnd ? fromStart : from+1;
		fromPred = from == fromStart ? fromEnd : from-1;
		if (to != fromSucc && to != fromPred) return color;

		// if they are neighbours, but the link is along the arm of a T-junction, we call it a grey link.
		// we determine this by testing whether the link starts at a point where the outline makes a right
		// turn and ends at a point where the outline makes a left turn, or vice versa.
		toSucc = to == fromEnd ? fromStart : to+1;
		toPred = to == fromStart ? fromEnd : to-1;
		fromRightTurn = (elem->oox[from]-elem->oox[fromPred])*(elem->ooy[fromSucc]-elem->ooy[from]) <
						(elem->ooy[from]-elem->ooy[fromPred])*(elem->oox[fromSucc]-elem->oox[from]);
		toRightTurn   = (elem->oox[to]-elem->oox[toPred])*(elem->ooy[toSucc]-elem->ooy[to]) <
						(elem->ooy[to]-elem->ooy[toPred])*(elem->oox[toSucc]-elem->oox[to]);
		if (fromRightTurn != toRightTurn)
			return GREY;

		// a extraneous case encountered, a link along a diagonal stroke
		if (2*MABS(elem->oox[to]-elem->oox[from]) < MABS(elem->ooy[to]-elem->ooy[from]))
			return GREY;

		properlyOriented = (elem->fc[fromCont] & OUTLINE_MISORIENTED) == 0;

		return properlyOriented == fromRightTurn ? BLACK : WHITE;
	} // DoubleCheckLinkColor

	// Determine whether an interpolation is actually an interpolation, as opposed to an extrapolation.
	// For actual interpolations, child points are moved along proportionally to the parent points. For
	// extrapolations child points are shifted along with the parent point(s). Notice that we implement
	// a behaviour similar to IUP (points between extrema are interpolated, the others are shifted along)
	boolean InterAlign(fnt_ElementType *elem, long parent0, long child, long parent1) {
		long parent0x,childx,parent1x,temp;

		parent0x = elem->oox[parent0];
		parent1x = elem->oox[parent1];
		if (parent0x > parent1x) { temp = parent0x; parent0x = parent1x; parent1x = temp; }
		childx = elem->oox[child];
		return parent0x <= childx && childx <= parent1x;
	} // InterAlign

#endif // SUBPIXEL_BC_AW_STEM_CONCERTINA


/* Private function prototypes */

FS_PRIVATE F26Dot6 itrp_RoundToDoubleGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundDownToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundUpToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundToHalfGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundOff(GSP F26Dot6 xin, F26Dot6 engine);

#ifdef FSCFG_SUBPIXEL
	// a duplicate set of rounding functions, with either the b/w (above) or the sp (below) version being installed
	FS_PRIVATE F26Dot6 itrp_RoundToDoubleGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundDownToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundUpToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundToHalfGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundOffSP(GSP F26Dot6 xin, F26Dot6 engine);
#endif

FS_PRIVATE F26Dot6 itrp_SuperRound(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_Super45Round(GSP F26Dot6 xin, F26Dot6 engine);

FS_PRIVATE void itrp_MovePoint  (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE void itrp_XMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE void itrp_YMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE F26Dot6 itrp_Project (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_OldProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_XProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_YProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE Fixed itrp_GetCVTScale (GSP0);
FS_PRIVATE F26Dot6 itrp_GetCVTEntryFast (GSP int32 n);
FS_PRIVATE F26Dot6 itrp_GetCVTEntrySlow (GSP int32 n);
FS_PRIVATE F26Dot6 itrp_GetSingleWidthFast (GSP0);
FS_PRIVATE F26Dot6 itrp_GetSingleWidthSlow (GSP0);
FS_PRIVATE void itrp_ChangeCvtFast (GSP fnt_ElementType *element, int32 number, F26Dot6 delta);
FS_PRIVATE void itrp_ChangeCvtSlow (GSP fnt_ElementType *element, int32 number, F26Dot6 delta);

FS_PRIVATE void itrp_InnerTraceExecute (GSP uint8 *ptr, uint8 *eptr);
FS_PRIVATE void itrp_InnerExecute (GSP uint8 *ptr, uint8 *eptr);
FS_PRIVATE void itrp_Check_PF_Proj (GSP0);
FS_PRIVATE void itrp_ComputeAndCheck_PF_Proj (GSP0);
FS_PRIVATE void itrp_SetRoundValues (GSP int32 arg1, int32 normalRound);
FS_PRIVATE F26Dot6 itrp_CheckSingleWidth (GSP F26Dot6 value);
FS_PRIVATE fnt_instrDef*itrp_FindIDef (GSP uint8 opCode);
FS_PRIVATE uint8* itrp_DeltaEngine (GSP uint8 *pbyInst, FntMoveFunc doIt, int16 base, int16 shift);

/* Actual instructions for the jump table */
FS_PRIVATE uint8* itrp_SVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SFVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SFVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTL (IPARAM);
FS_PRIVATE uint8* itrp_SDPVTL (IPARAM);
FS_PRIVATE uint8* itrp_SFVTL (IPARAM);
FS_PRIVATE uint8* itrp_WPV (IPARAM);
FS_PRIVATE uint8* itrp_WFV (IPARAM);
FS_PRIVATE uint8* itrp_RPV (IPARAM);
FS_PRIVATE uint8* itrp_RFV (IPARAM);
FS_PRIVATE uint8* itrp_SFVTPV (IPARAM);
FS_PRIVATE uint8* itrp_ISECT (IPARAM);
FS_PRIVATE uint8* itrp_SRP0 (IPARAM);
FS_PRIVATE uint8* itrp_SRP1 (IPARAM);
FS_PRIVATE uint8* itrp_SRP2 (IPARAM);
FS_PRIVATE uint8* itrp_SetElementPtr (IPARAM);
FS_PRIVATE uint8* itrp_LLOOP (IPARAM);
FS_PRIVATE uint8* itrp_RTG (IPARAM);
FS_PRIVATE uint8* itrp_RTHG (IPARAM);
FS_PRIVATE uint8* itrp_RTDG (IPARAM);
FS_PRIVATE uint8* itrp_ROFF (IPARAM);
FS_PRIVATE uint8* itrp_RUTG (IPARAM);
FS_PRIVATE uint8* itrp_RDTG (IPARAM);
FS_PRIVATE uint8* itrp_SROUND (IPARAM);
FS_PRIVATE uint8* itrp_S45ROUND (IPARAM);
FS_PRIVATE uint8* itrp_LMD (IPARAM);
FS_PRIVATE uint8* itrp_RAW (IPARAM);
FS_PRIVATE uint8* itrp_LWTCI (IPARAM);
FS_PRIVATE uint8* itrp_LSWCI (IPARAM);
FS_PRIVATE uint8* itrp_LSW (IPARAM);
FS_PRIVATE uint8* itrp_DUP (IPARAM);
FS_PRIVATE uint8* itrp_POP (IPARAM);
FS_PRIVATE uint8* itrp_CLEAR (IPARAM);
FS_PRIVATE uint8* itrp_SWAP (IPARAM);
FS_PRIVATE uint8* itrp_DEPTH (IPARAM);
FS_PRIVATE uint8* itrp_CINDEX (IPARAM);
FS_PRIVATE uint8* itrp_MINDEX (IPARAM);
FS_PRIVATE uint8* itrp_ROTATE (IPARAM);
FS_PRIVATE uint8* itrp_MDAP (IPARAM);
FS_PRIVATE uint8* itrp_MIAP (IPARAM);
FS_PRIVATE uint8* itrp_IUP (IPARAM);
FS_PRIVATE uint8* itrp_SHP (IPARAM);
FS_PRIVATE uint8* itrp_SHC (IPARAM);
FS_PRIVATE uint8* itrp_SHE (IPARAM);
FS_PRIVATE uint8* itrp_SHPIX (IPARAM);
FS_PRIVATE uint8* itrp_IP (IPARAM);
FS_PRIVATE uint8* itrp_MSIRP (IPARAM);
FS_PRIVATE uint8* itrp_ALIGNRP (IPARAM);
FS_PRIVATE uint8* itrp_ALIGNPTS (IPARAM);
FS_PRIVATE uint8* itrp_SANGW (IPARAM);
FS_PRIVATE uint8* itrp_FLIPPT (IPARAM);
FS_PRIVATE uint8* itrp_FLIPRGON (IPARAM);
FS_PRIVATE uint8* itrp_FLIPRGOFF (IPARAM);
FS_PRIVATE uint8* itrp_SCANCTRL (IPARAM);
FS_PRIVATE uint8* itrp_SCANTYPE (IPARAM);
FS_PRIVATE uint8* itrp_INSTCTRL (IPARAM);
FS_PRIVATE uint8* itrp_AA (IPARAM);
FS_PRIVATE uint8* itrp_NPUSHB (IPARAM);
FS_PRIVATE uint8* itrp_NPUSHW (IPARAM);
FS_PRIVATE uint8* itrp_WS (IPARAM);
FS_PRIVATE uint8* itrp_RS (IPARAM);
FS_PRIVATE uint8* itrp_WCVT (IPARAM);
FS_PRIVATE uint8* itrp_WCVTFOD (IPARAM);
FS_PRIVATE uint8* itrp_RCVT (IPARAM);
FS_PRIVATE uint8* itrp_RC (IPARAM);
FS_PRIVATE uint8* itrp_WC (IPARAM);
FS_PRIVATE uint8* itrp_MD (IPARAM);
FS_PRIVATE uint8* itrp_MPPEM (IPARAM);
FS_PRIVATE uint8* itrp_MPS (IPARAM);
FS_PRIVATE uint8* itrp_GETINFO (IPARAM);
FS_PRIVATE uint8* itrp_FLIPON (IPARAM);
FS_PRIVATE uint8* itrp_FLIPOFF (IPARAM);
FS_PRIVATE uint8* itrp_IF (IPARAM);
FS_PRIVATE uint8* itrp_ELSE (IPARAM);
FS_PRIVATE uint8* itrp_EIF (IPARAM);
FS_PRIVATE uint8* itrp_JMPR (IPARAM);
FS_PRIVATE uint8* itrp_JROT (IPARAM);
FS_PRIVATE uint8* itrp_JROF (IPARAM);
FS_PRIVATE uint8* itrp_ROUND (IPARAM);
FS_PRIVATE uint8* itrp_NROUND (IPARAM);
FS_PRIVATE uint8* itrp_PUSHB (IPARAM);
FS_PRIVATE uint8* itrp_PUSHW (IPARAM);
FS_PRIVATE uint8* itrp_MDRP (IPARAM);
FS_PRIVATE uint8* itrp_MIRP (IPARAM);
FS_PRIVATE uint8* itrp_CALL (IPARAM);
FS_PRIVATE uint8* itrp_FDEF (IPARAM);
FS_PRIVATE uint8* itrp_LOOPCALL (IPARAM);
FS_PRIVATE uint8* itrp_IDefPatch (IPARAM);
FS_PRIVATE uint8* itrp_IDEF (IPARAM);
FS_PRIVATE uint8* itrp_UTP (IPARAM);
FS_PRIVATE uint8* itrp_SDB (IPARAM);
FS_PRIVATE uint8* itrp_SDS (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP1 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP2 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP3 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC1 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC2 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC3 (IPARAM);

FS_PRIVATE uint8*  itrp_PUSHB1 (IPARAM);
FS_PRIVATE uint8*  itrp_PUSHW1 (IPARAM);

FS_PRIVATE uint8*  itrp_LT  (IPARAM);
FS_PRIVATE uint8*  itrp_LTEQ (IPARAM);
FS_PRIVATE uint8*  itrp_GT  (IPARAM);
FS_PRIVATE uint8*  itrp_GTEQ (IPARAM);
FS_PRIVATE uint8*  itrp_EQ  (IPARAM);
FS_PRIVATE uint8*  itrp_NEQ (IPARAM);
FS_PRIVATE uint8*  itrp_AND (IPARAM);
FS_PRIVATE uint8*  itrp_OR  (IPARAM);
FS_PRIVATE uint8*  itrp_ADD (IPARAM);
FS_PRIVATE uint8*  itrp_SUB (IPARAM);
FS_PRIVATE uint8*  itrp_DIV (IPARAM);
FS_PRIVATE uint8*  itrp_MUL (IPARAM);
FS_PRIVATE uint8*  itrp_MAX (IPARAM);
FS_PRIVATE uint8*  itrp_MIN (IPARAM);

FS_PRIVATE uint8*  itrp_ODD (IPARAM);
FS_PRIVATE uint8*  itrp_EVEN (IPARAM);
FS_PRIVATE uint8*  itrp_NOT (IPARAM);
FS_PRIVATE uint8*  itrp_ABS (IPARAM);
FS_PRIVATE uint8*  itrp_NEG (IPARAM);
FS_PRIVATE uint8*  itrp_CEILING (IPARAM);
FS_PRIVATE uint8*  itrp_FLOOR (IPARAM);

FS_PRIVATE uint8*  itrp_IllegalInstruction (IPARAM);

FS_PRIVATE fnt_ElementType*itrp_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, int32*point, int32 lOpCode);
FS_PRIVATE uint8* itrp_SHP_Common (GSP uint8 *pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
								   int32 refPoint,
#endif
#ifdef FSCFG_SUBPIXEL							// extra parameter to distinguish between coming from SHPIX, in which case we assume
								   uint8 shpix, // the context is a delta fn and hence we most likely skip the delta, and SHP
#endif
								   F26Dot6 dx, F26Dot6 dy);
FS_PRIVATE uint8* itrp_PushSomeBytes (GSP int32, uint8*);
FS_PRIVATE uint8* itrp_PushSomeWords (GSP int32, uint8*);
FS_PRIVATE uint8* itrp_SkipPushData (GSP uint8*);

#ifndef NOT_ON_THE_MAC
#ifdef FSCFG_DEBUG
FS_PRIVATE void itrp_DDT (int8 c, int32 n);
#endif
#endif
FS_PRIVATE uint8* itrp_DEBUG (IPARAM);

#define MAX(a,b)        ((a) > (b) ? (a) : (b))

FS_PRIVATE ErrorCode   itrp_Execute (
	fnt_ElementType *               pTwilightElement,
	fnt_ElementType *               pGlyphElement,
	uint8 *                         ptr,
	uint8 *                         eptr,
	fnt_GlobalGraphicStateType *    globalGS,
	 FntTraceFunc                           TraceFunc);

/* GLOBAL GS INITIALIZATION */

FS_PUBLIC void          itrp_UpdateGlobalGS(
	void *              pvGlobalGS, /* GlobalGS                             */
	void *              pvCVT,      /* Pointer to control value table       */
	void *              pvStore,    /* Pointer to storage                   */
	void *              pvFuncDef,  /* Pointer to function defintions       */
	void *              pvInstrDef, /* Pointer to instruction definitions   */
	void *              pvStack,    /* Pointer to the stack                 */
	LocalMaxProfile *       maxp,
	uint16              cvtCount,
	uint32              ulLengthFontProgram, /* Length of font program      */
	void *              pvFontProgram, /* Pointer to font program           */
	uint32              ulLengthPreProgram, /* Length of pre program        */
	void *              pvPreProgram,  /* Pointer to pre program            */
	ClientIDType        clientID)     /* User ID Number                     */
{
	fnt_GlobalGraphicStateType *    globalGS;
#ifdef FSCFG_SECURE
    uint16      maxStackElements = maxp->maxStackElements;

#ifdef FSCFG_EUDC_EDITOR_BUG
    if (maxStackElements == 0)
    {
      maxStackElements = 1;
    }

#endif // FSCFG_EUDC_EDITOR_BUG
#endif // FSCFG_SECURE

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->controlValueTable =   (F26Dot6 *)pvCVT;
	globalGS->store =               (F26Dot6 *)pvStore;
	globalGS->funcDef =             (fnt_funcDef *)pvFuncDef;
	globalGS->instrDef =            (fnt_instrDef *)pvInstrDef;
	globalGS->stackBase =           (F26Dot6 *)pvStack;
	globalGS->clientID =            clientID;
#ifdef FSCFG_SECURE
	globalGS->stackMax =             globalGS->stackBase + maxStackElements;
    globalGS->maxPointsIncludePhantom = MAX (maxp->maxPoints,maxp->maxCompositePoints) + NUM_PHANTOM_PTS;
#endif // FSCFG_SECURE

	if(ulLengthFontProgram)
	{
		globalGS->pgmList[FONTPROGRAM].Length = ulLengthFontProgram;
		globalGS->pgmList[FONTPROGRAM].Instruction = (unsigned char *)pvFontProgram;
	}
	else
	{
		globalGS->pgmList[FONTPROGRAM].Length = ulLengthFontProgram;
		globalGS->pgmList[FONTPROGRAM].Instruction = NULL;
	}
	if(ulLengthPreProgram)
	{
		globalGS->pgmList[PREPROGRAM].Length = ulLengthPreProgram;
		globalGS->pgmList[PREPROGRAM].Instruction = (unsigned char *)pvPreProgram;
	}
	else
	{
		globalGS->pgmList[PREPROGRAM].Length = ulLengthPreProgram;
		globalGS->pgmList[PREPROGRAM].Instruction = NULL;
	}

	globalGS->maxp = maxp;
	globalGS->cvtCount = cvtCount;
	globalGS->bCompositeGlyph = FALSE;
	globalGS->bSameTransformAsMaster = TRUE;
	globalGS->bOriginalPointIsInvalid = FALSE;

	globalGS->ulMaxJumpCounter = INTERP_MAX_JUMPS;
	globalGS->ulMaxRecursiveCall = INTERP_MAX_RECURSIVE_CALLS;
}

FS_PUBLIC boolean itrp_bApplyHints(
	void *      pvGlobalGS)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	return (!(globalGS->localParBlock.instructControl & NOGRIDFITFLAG));
}

FS_PUBLIC void  itrp_QueryScanInfo(
	void *      pvGlobalGS,
	uint16 *    pusScanType,
	uint16 *    pusScanControl)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	 *pusScanType =  FS_HIWORD(globalGS->localParBlock.scanControl);
	 *pusScanControl = FS_LOWORD(globalGS->localParBlock.scanControl);
}

FS_PUBLIC void  itrp_SetCompositeFlag(
	void *      pvGlobalGS,
	uint8       bCompositeFlag)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->bCompositeGlyph = bCompositeFlag;

	globalGS->bOriginalPointIsInvalid = globalGS->bCompositeGlyph || !globalGS->bSameTransformAsMaster;
}

FS_PUBLIC void	itrp_SetSameTransformFlag(
	void *      pvGlobalGS,
	boolean		bSameTransformAsMaster)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->bSameTransformAsMaster = (uint8)bSameTransformAsMaster;

	globalGS->bOriginalPointIsInvalid = globalGS->bCompositeGlyph || !globalGS->bSameTransformAsMaster;
}

/*
*  function table
*/

FntFunc function [MAXBYTE_INSTRUCTIONS]
#ifndef FSCFG_NO_INITIALIZED_DATA
=
{
  itrp_SVTCA_0, itrp_SVTCA_1, itrp_SPVTCA_0, itrp_SPVTCA_1, itrp_SFVTCA_0, itrp_SFVTCA_1, itrp_SPVTL, itrp_SPVTL,
  itrp_SFVTL, itrp_SFVTL, itrp_WPV, itrp_WFV, itrp_RPV, itrp_RFV, itrp_SFVTPV, itrp_ISECT,
  itrp_SRP0, itrp_SRP1, itrp_SRP2, itrp_SetElementPtr, itrp_SetElementPtr, itrp_SetElementPtr, itrp_SetElementPtr, itrp_LLOOP,
  itrp_RTG, itrp_RTHG, itrp_LMD, itrp_ELSE, itrp_JMPR, itrp_LWTCI, itrp_LSWCI, itrp_LSW,
  itrp_DUP, itrp_POP, itrp_CLEAR, itrp_SWAP, itrp_DEPTH, itrp_CINDEX, itrp_MINDEX, itrp_ALIGNPTS,
  itrp_RAW, itrp_UTP, itrp_LOOPCALL, itrp_CALL, itrp_FDEF, itrp_IllegalInstruction, itrp_MDAP, itrp_MDAP,
  itrp_IUP, itrp_IUP, itrp_SHP, itrp_SHP, itrp_SHC, itrp_SHC, itrp_SHE, itrp_SHE,
  itrp_SHPIX, itrp_IP, itrp_MSIRP, itrp_MSIRP, itrp_ALIGNRP, itrp_RTDG, itrp_MIAP, itrp_MIAP,
  itrp_NPUSHB, itrp_NPUSHW, itrp_WS, itrp_RS, itrp_WCVT, itrp_RCVT, itrp_RC, itrp_RC,
  itrp_WC, itrp_MD, itrp_MD, itrp_MPPEM, itrp_MPS, itrp_FLIPON, itrp_FLIPOFF, itrp_DEBUG,
  itrp_LT, itrp_LTEQ, itrp_GT, itrp_GTEQ, itrp_EQ, itrp_NEQ, itrp_ODD, itrp_EVEN,
  itrp_IF, itrp_EIF, itrp_AND, itrp_OR, itrp_NOT, itrp_DELTAP1, itrp_SDB, itrp_SDS,
  itrp_ADD, itrp_SUB, itrp_DIV, itrp_MUL, itrp_ABS, itrp_NEG, itrp_FLOOR, itrp_CEILING,
  itrp_ROUND, itrp_ROUND, itrp_ROUND, itrp_ROUND, itrp_NROUND, itrp_NROUND, itrp_NROUND, itrp_NROUND,
  itrp_WCVTFOD, itrp_DELTAP2, itrp_DELTAP3, itrp_DELTAC1, itrp_DELTAC2, itrp_DELTAC3, itrp_SROUND, itrp_S45ROUND,
  itrp_JROT, itrp_JROF, itrp_ROFF, itrp_IllegalInstruction, itrp_RUTG, itrp_RDTG, itrp_SANGW, itrp_AA,

  itrp_FLIPPT, itrp_FLIPRGON, itrp_FLIPRGOFF, itrp_IDefPatch, itrp_IDefPatch, itrp_SCANCTRL, itrp_SDPVTL, itrp_SDPVTL,
  itrp_GETINFO, itrp_IDEF, itrp_ROTATE, itrp_MAX, itrp_MIN, itrp_SCANTYPE, itrp_INSTCTRL, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_PUSHB1, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB,
  itrp_PUSHW1, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP
}
#endif /* FSCFG_NO_INITIALIZED_DATA */
;

/* the old itrp_Init function and tables now live in history.fnt - deanb */


#ifdef  GET_STACKSPACE
  int32 MaxStackSize = 0;

  #define PUSH(p, x) \
	{ \
	  if (p - LocalGS.globalGS->stackBase > MaxStackSize) \
		MaxStackSize = p - LocalGS.globalGS->stackBase; \
	  (*(p)++ = (x)); \
	}

#else
  #define PUSH( p, x ) ( *(p)++ = (x) )
#endif
  #define POP( p )     ( *(--p) )

#define BADCOMPILER

#ifdef BADCOMPILER
#define BOOLEANPUSH( p, x ) PUSH( p, ((x) ? 1 : 0) ) /* MPW 3.0 */
#else
#define BOOLEANPUSH( p, x ) PUSH( p, x )
#endif

#ifdef FSCFG_DEBUG
void CHECK_RANGE (int32 n, int32 min, int32 max);
void CHECK_RANGE (int32 n, int32 min, int32 max)
{
  if (n > max || n < min)
	ERR_REPORT (ERR_RANGE, n, min, max, 0);
}


void CHECK_ASSERTION (int32 expression);
void CHECK_ASSERTION (int32 expression)
{
  if (!expression)
	ERR_REPORT (ERR_ASSERTION, expression, 0, 0, 0);
}


void CHECK_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt);
void CHECK_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt)
{
  int32 cvtCount = (int32)(pGS->globalGS->cvtCount - 1L);

  if ((int32)cvt > cvtCount || (int32)cvt < 0L)
	ERR_REPORT (ERR_CVT, cvt, 0, cvtCount, 0);
}


void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef);
void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef)
{
  int32 maxFdef = (int32)(pGS->globalGS->maxp->maxFunctionDefs - 1L);

  if ((int32)fdef > maxFdef || (int32)fdef < 0L)
	ERR_REPORT (ERR_FDEF, fdef, 0, maxFdef, 0);
}

#define CHECK_PROGRAM(a)

void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, int32 elem);
void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, int32 elem)
{
  int32 maxElem = (int32)(pGS->globalGS->maxp->maxElements - 1L);

/*
  At least 1 maxElements will always be available
*/
  if (!maxElem)
	maxElem++;

  if ((int32)elem > maxElem || (int32)elem < 0L)
	ERR_REPORT (ERR_ELEMENT, elem, 0, maxElem, 0);
}

void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem);
void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem)
{
  if (elem == &pGS->elements[1])
  {
	 int32 maxctrs, maxpts;

	maxctrs = MAX (pGS->globalGS->maxp->maxContours,
				   pGS->globalGS->maxp->maxCompositeContours);
	maxpts  = MAX (pGS->globalGS->maxp->maxPoints,
				   pGS->globalGS->maxp->maxCompositePoints);

	if ((int32)elem->nc > (int32)maxctrs || (int32)elem->nc < 1L)
	  ERR_REPORT (ERR_CONTOUR, elem->nc, 1, maxctrs, 0);

	if ((int32)elem->ep[elem->nc-1] > maxpts - 1L ||
		(int32)elem->ep[elem->nc-1] < 0L)
	  ERR_REPORT (ERR_POINT, elem->ep[elem->nc-1], 0, maxpts - 1L, 0);
  }
  else if (elem != &pGS->elements[0])
	ERR_REPORT (ERR_INDEX, elem, &pGS->elements[0], &pGS->elements[1], 0);
}

void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, int32 index);
void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, int32 index)
{
  int32 maxIndex = (int32)(pGS->globalGS->maxp->maxStorage - 1L);

  if ((int32)index > maxIndex || (int32)index < 0L)
	ERR_REPORT (ERR_STORAGE, index, 0, maxIndex, 0);
}

void CHECK_STACK (fnt_LocalGraphicStateType* pGS);
void CHECK_STACK (fnt_LocalGraphicStateType* pGS)
{
  int32 base = (int32)(pGS->stackPointer - pGS->globalGS->stackBase);
  int32 max = (int32)(pGS->globalGS->maxp->maxStackElements - 1L);

  if (base > max || base < 0L)
	ERR_REPORT (ERR_STACK, base, 0, max, 0);
}

void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt);
void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt)
{
  CHECK_ELEMENTPTR (pGS, elem);
  if (pGS->elements == elem)
  {
	if ((int32)pt > pGS->globalGS->maxp->maxTwilightPoints - 1L ||
		(int32)pt < 0L)
	  ERR_REPORT (ERR_POINT, pt, 0, pGS->globalGS->maxp->maxTwilightPoints - 1L, 0);
  }
  else                                                      /* phantom points */
  {
	if ((int32)pt > elem->ep[elem->nc-1] + 2L || (int32)pt < 0L)
	  ERR_REPORT (ERR_POINT, pt, 0, elem->ep[elem->nc-1] + 2L, 0);
  }
}

void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr);
void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr)
{
  CHECK_ELEMENTPTR (pGS, elem);
  if ((int32)ctr > elem->nc - 1L || (int32)ctr < 0L)
	ERR_REPORT (ERR_CONTOUR, ctr, 0, elem->nc -1L, 0);
}

void CHECK_VECTOR (VECTORTYPE x, VECTORTYPE y);
void CHECK_VECTOR (VECTORTYPE x, VECTORTYPE y)
{
  if ( x == 0 && y == 0 )
	ERR_REPORT (ERR_VECTOR, x, y, 0, 0);
}

void CHECK_LARGER (int32 min, int32 n);
void CHECK_LARGER (int32 min, int32 n)
{
  if ( n <= min )
	ERR_REPORT (ERR_LARGER, min, n, 0, 0);
}

void CHECK_INT8 (int32 n);
void CHECK_INT8 (int32 n)
{
  if ( n & 0xFFFFFF00 )
	ERR_REPORT (ERR_INT8, n, 0, 0, 0);
}

void CHECK_INT16 (int32 n);
void CHECK_INT16 (int32 n)
{
  if ( n & 0xFFFF0000 )
	ERR_REPORT (ERR_INT16, n, 0, 0, 0);
}

void CHECK_SELECTOR (int32 n);
void CHECK_SELECTOR (int32 n)
{
  if ( n & ~((int32)SELECTOR_FLAGS) )
	ERR_REPORT (ERR_SELECTOR, n, 0, 0, 0);
}

void CHECK_SUBSTACK (fnt_LocalGraphicStateType* pGS, F26Dot6* pt);
void CHECK_SUBSTACK (fnt_LocalGraphicStateType* pGS, F26Dot6* pt)
{
  int32 base = (int32)(pt - pGS->globalGS->stackBase);
  int32 max = (int32)(pGS->globalGS->maxp->maxStackElements - 1L);

  if (base > max || base < 0L)
	ERR_REPORT (ERR_STACK, base, 0, max, 0);
}

void POP_CHECK (F26Dot6*);
void POP_CHECK (F26Dot6* stackPtr)
{
  F26Dot6 * base = LocalGS.globalGS->stackBase;
  F26Dot6 * max;

  max = base + LocalGS.globalGS->maxp->maxStackElements - 1L;
  if ( stackPtr <= base)
	ERR_REPORT (ERR_STACK, (stackPtr - base - 1L), 0, (max - base), 0);
  return;
}

void PUSH_CHECK (F26Dot6*);
void PUSH_CHECK (F26Dot6* stackPtr)
{
  F26Dot6 * base = LocalGS.globalGS->stackBase;
  F26Dot6 * max;

  max = base + LocalGS.globalGS->maxp->maxStackElements - 1L;
  if ( stackPtr > max )
	ERR_REPORT (ERR_STACK, (stackPtr - base), 0, (max - base), 0);
  return;
}

#define CHECK_POP(s)                (POP_CHECK(s),POP(s))
#define CHECK_PUSH(s, v)            (PUSH_CHECK(s),PUSH(s, v))

#else
#define CHECK_RANGE(a,b,c)
#define CHECK_ASSERTION(a)
#define CHECK_CVT(pgs,b)
#define CHECK_POINT(pgs,b,c)
#define CHECK_CONTOUR(pgs,b,c)
#define CHECK_FDEF(pgs,b)
#define CHECK_PROGRAM(a)
#define CHECK_ELEMENT(pgs,b)
#define CHECK_ELEMENTPTR(pgs,b)
#define CHECK_STORAGE(pgs,b)
#define CHECK_STACK(pgs)
#define CHECK_VECTOR(a,b)
#define CHECK_LARGER(a,b)
#define CHECK_INT8(a)
#define CHECK_INT16(a)
#define CHECK_SELECTOR(a)
#define CHECK_SUBSTACK(pgs,a)
#define CHECK_POP(s)                POP(s)
#define CHECK_PUSH(s, v)            PUSH(s, v)
#endif

/*@@*/

/* ClaudeBe 4/15/98 new secure rasterizer testing of critical errors */
/* errors originally detected by the fstrace callback trace function */
/* moved inside the rasterizer for performance reason */

#ifdef FSCFG_SECURE

#define SECURE_CHECK_FOR_POP(stackPtr, lNumItems) \
 \
  if (stackPtr - (int32)(lNumItems) < LocalGS.globalGS->stackBase) \
{ \
	LocalGS.ercReturn = SECURE_STACK_UNDERFLOW;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_FOR_PUSH(stackPtr, lNumItems) \
 \
  if (stackPtr + (int32)(lNumItems) > LocalGS.globalGS->stackMax) \
{ \
	LocalGS.ercReturn = SECURE_STACK_OVERFLOW;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_SUBSTACK(stackPtr) \
 \
  if ((stackPtr < LocalGS.globalGS->stackBase) || (stackPtr >= LocalGS.globalGS->stackMax)) \
{ \
	LocalGS.ercReturn = SECURE_INVALID_STACK_ACCESS;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_POINT(elem, pt) \
{ \
    if (LocalGS.elements == elem) \
    { \
	  if ((int32)pt >= LocalGS.globalGS->maxp->maxTwilightPoints || \
		 (int32)pt < 0L) \
      { \
	    LocalGS.ercReturn = SECURE_POINT_OUT_OF_RANGE;  /* error returned to client */ \
	    return LocalGS.pbyEndInst; \
      } \
    } \
    else \
    { \
	  if ((int32)pt >= LocalGS.globalGS->maxPointsIncludePhantom || (int32)pt < 0L) \
      { \
	    LocalGS.ercReturn = SECURE_POINT_OUT_OF_RANGE;  /* error returned to client */ \
	    return LocalGS.pbyEndInst; \
      } \
    } \
}

#define SECURE_CHECK_FDEF(fdef) \
{ \
    if ((int32)fdef >= (LocalGS.globalGS->maxp->maxFunctionDefs) || (int32)fdef < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_FDEF_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_PROGRAM(pgmIndex) \
{ \
    if (pgmIndex >= MAXPREPROGRAMS) \
    { \
	  LocalGS.ercReturn = SECURE_ERR_FUNCTION_NOT_DEFINED;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_ZONE(elem) \
{ /* in theory we should compare with maxp->maxElements but the rasterizer always allocate for MAX_ELEMENTS zones */ \
    if ((int32)elem >= MAX_ELEMENTS || (int32)elem < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_INVALID_ZONE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_FOR_UNITIALIZED_ZONE(elem) \
{ \
	if (LocalGS.globalGS->pgmIndex != GLYPHPROGRAM) \
	/* in the glyph program, both zone (glyph and twilight are initialized */ \
	{ \
	    if (LocalGS.globalGS->pgmIndex != PREPROGRAM || LocalGS.elements != elem ) \
		/* in the pre-program, only the twilight zone is initialized, */ \
		/* in any other zone i.e. font program, none of the zones are initialized */ \
		{ \
	       LocalGS.ercReturn = SECURE_UNITIALIZED_ZONE;  /* error returned to client */ \
	       return LocalGS.pbyEndInst; \
		} \
    } \
}


#define SECURE_CHECK_IDEF_OPCODE(idef) \
{ \
    if ( idef & 0xFFFFFF00 ) \
    { \
	  LocalGS.ercReturn = SECURE_INST_OPCODE_TO_LARGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_IDEF_OVERFLOW() \
{ \
    if (LocalGS.globalGS->instrDefCount >= LocalGS.globalGS->maxp->maxInstructionDefs) \
    { \
	  LocalGS.ercReturn = SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_STORAGE(index) \
{ \
    if ((int32)index >= (LocalGS.globalGS->maxp->maxStorage) || (int32)index < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_STORAGE_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_CONTOUR(elem, ctr) \
{ /* The reason in SECURE_CHECK_CONTOUR that we are checking against elem->nc instead of maxContours */ \
	/* is that we will access CE2->sp[contour] and we may try to access a point out of bounds */ \
    if ((int32)ctr < 0L || (int32)ctr >= (elem)->nc) \
    { \
	  LocalGS.ercReturn = SECURE_CONTOUR_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_CVT(cvt) \
{ \
    if ((int32)cvt >= (LocalGS.globalGS->cvtCount) || (int32)cvt < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_CVT_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#ifdef FSCFG_FONTOGRAPHER_BUG
#define SECURE_CHECK_CVT_READ_SPECIAL(cvt) \
{ \
    if (((int32)cvt >= (LocalGS.globalGS->cvtCount) && cvt > 255) || (int32)cvt < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_CVT_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}
#endif // FSCFG_FONTOGRAPHER_BUG

#else

#define SECURE_CHECK_FOR_POP(stackPtr, lNumItems) 
#define SECURE_CHECK_FOR_PUSH(stackPtr, lNumItems) 
#define SECURE_CHECK_SUBSTACK(stackPtr) 
#define SECURE_CHECK_POINT(elem, pt) 
#define SECURE_CHECK_FDEF(fdef) 
#define SECURE_CHECK_PROGRAM(pgmIndex)
#define SECURE_CHECK_ZONE(elem)
#define SECURE_CHECK_IDEF_OPCODE(idef) 
#define SECURE_CHECK_IDEF_OVERFLOW() 
#define SECURE_CHECK_STORAGE(index) 
#define SECURE_CHECK_CONTOUR(elem, ctr) 
#define SECURE_CHECK_CVT(cvt) 
#define SECURE_CHECK_FOR_UNITIALIZED_ZONE(elem) 

#ifdef FSCFG_FONTOGRAPHER_BUG
#define SECURE_CHECK_CVT_READ_SPECIAL(cvt) 
#endif // FSCFG_FONTOGRAPHER_BUG

#endif


#define BIT0( t ) ( (t) & 0x01 )
#define BIT1( t ) ( (t) & 0x02 )
#define BIT2( t ) ( (t) & 0x04 )
#define BIT3( t ) ( (t) & 0x08 )
#define BIT4( t ) ( (t) & 0x10 )
#define BIT5( t ) ( (t) & 0x20 )
#define BIT6( t ) ( (t) & 0x40 )
#define BIT7( t ) ( (t) & 0x80 )

/****** Element Codes *********/
#define SCE0_CODE       0x13
#define SCE1_CODE       0x14
#define SCE2_CODE       0x15
#define SCES_CODE       0x16

/****** Control Codes *********/
#define IF_CODE         0x58
#define ELSE_CODE       0x1B
#define EIF_CODE        0x59
#define ENDF_CODE       0x2d
#define MD_CODE         0x49

#ifdef FSCFG_SUBPIXEL
	// For SubPixel, rather than deciding within the rounding function whether we're currently
	// running SubPixel at all, and whether we're in the SubPixel-specific direction, we
	// install the appropriate version of the rounding function into the local ParameterBlock.
	// There are two parameters that determine this installation:
	// - a boolean "inSubPixelDirection" in LocalGS, set whenever the pv changes (eg. in SVTCA[X])
	// - an enum "roundState" in localParBlock, set whenever rounding state changes (eg. in RTG[])
	// It is necessary to have variables for these two parameters, because the states they
	// represent change independently, yet the round function depends on both parameters.
	// Whenever any of these two parameters change, we index the matrix "itrp_RoundFunction"
	// below to install the correct rounding function into the local ParameterBlock. 
	// Exception: itrp_RoundDownToGridSP, the SubPixel version of the RDTG function, inspects
	// the pv and actually rounds down to grid if pv == dpv. (cf. comments in itrp_RoundDownToGridSP)
	
	typedef enum { inRtdg = 0, inRdtg, inRutg, inRtg, inRthg, inRoff, inSRnd, inS45Rnd } RoundFunction;
	#ifndef FSCFG_NO_INITIALIZED_DATA
	const
	#endif
		  FntRoundFunc itrp_RoundFunction[2][8]
	#ifndef FSCFG_NO_INITIALIZED_DATA
												=  {{itrp_RoundToDoubleGrid,   itrp_RoundDownToGrid,   itrp_RoundUpToGrid,   itrp_RoundToGrid,   itrp_RoundToHalfGrid,   itrp_RoundOff,   itrp_SuperRound, itrp_Super45Round},
													{itrp_RoundToDoubleGridSP, itrp_RoundDownToGridSP, itrp_RoundUpToGridSP, itrp_RoundToGridSP, itrp_RoundToHalfGridSP, itrp_RoundOffSP, itrp_SuperRound, itrp_Super45Round}}
	#endif
	;
	// Following are two helper macros to update the aforementioned parameters "inSubPixelDirection"
	// and "roundState", along with installing the updated rounding function. The purpose of these
	// macros is to assert correspondence of the two parameters with the rounding function by system,
	// rather than by industriousness. The first helper macro is used whenever the projection vector
	// changes (eg. in SVTCA[X]) which changes whether or not we're in the SubPixel-specific direction.
	// The second helper macro is used whenever the round state changes (eg. in RTG[]).

	// Two versions of the first helper macro to update
	// - localGS.inSubPixelDirection (flag)
	// - localParBlock.RoundValue (func ptr)
	// as a result of a change of the projection vector.
	// We're using two different macros merely because VC wouldn't let us nest an #ifdef within a #define
	#ifdef NoVirtRoundInPrep
		#define UpdateRoundFunctionByProjectionVector(localGS)											\
			{																							\
				fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																										\
				(localGS).inSubPixelDirection = RunningSubPixel((localGS).globalGS) && InSubPixelDirection(localGS);							\
				par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection && (Tuned4SubPixel((localGS).globalGS) || (localGS).globalGS->pgmIndex != PREPROGRAM)][par->roundState];	\
			}
	#else
		#define UpdateRoundFunctionByProjectionVector(localGS)											\
			{																							\
				fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																										\
				(localGS).inSubPixelDirection = RunningSubPixel((localGS).globalGS) && InSubPixelDirection(localGS);							\
				par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection][par->roundState];	\
			}
	#endif

	// Second helper macro to update
	// - localParBlock.roundState (enum)
	// - localParBlock.RoundValue (func ptr)
	// as a result of a change of the round state.
	#define UpdateRoundFunctionByRoundState(localGS,state)											\
		{																							\
			fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																									\
			par->roundState = (state);																\
			par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection][par->roundState];	\
		}

	// Helper macro to used to determine whether or not to skip a delta instruction or function.
	// In backwardscompatibility mode, deltas are skipped if they are in SubPixel direction or
	// if they are applied to an untouched/unmoved point or if they are postIUP. Additionally,
	// deltas are skipped in composites if they are in SubPixel direction for proper centering
	// and vertical positioning of diacritical marks.
	// See also comments in itrp_SHP_Common.
	#ifdef InlineDeltasOnly
		#define AMovedPointInNonSPDirection(localGS,zonePtr,pointNum)							\
			((uint16)(!VerticalSPDirection((localGS).globalGS) ?								\
					  ProjVectInY((localGS)) && ((localGS).globalGS->bCompositeGlyph || ((localGS).zonePtr->f[(pointNum)] & YMOVED && !((localGS).globalGS->subPixelCompatibilityFlags & SPCF_iupyCalled))) :	\
					  ProjVectInX((localGS)) && ((localGS).globalGS->bCompositeGlyph || ((localGS).zonePtr->f[(pointNum)] & XMOVED && !((localGS).globalGS->subPixelCompatibilityFlags & SPCF_iupxCalled)))))
	#endif

#endif // FSCFG_SUBPIXEL

// Macros for rounding to grid etc. The purpose of these macros is to make the code more readable
// in cases such as MIRP, where rounding is performed inline for optimization reasons.
// - All rounding is applied to non-negative numbers only, negative numbers have their sign changed
//   before and after. 
// - Engine compensation is added to the unrounded number. Notice that substituting (literal) 0 for
//   engine will be optimized by the compiler
// - Rounding, in principle, follows the pattern in RTG:
//   - add half the "resolution" (this corresponds to adding 0.5)
//   - mask with the complement of "resolution"-minus-1 (this corresponds to a truncated division by
//	   "resolution", immediately followed by a multiplication by the same amount)
//	   Notice that masking only works with powers of two for the resolution

// for round-to-double-grid, we simply use half the resolution
#define RTDG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution / 4;		\
		x &= ~(resolution / 2 - 1);	\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution / 4;		\
		x &= ~(resolution / 2 - 1);	\
		x = -x;						\
	}

// for round-down-to-grid, we skip the part that adds 0.5
#define RDTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

// for round-up-to-grid, we add "0.9999" instead of 0.5
#define RUTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution - 1;		\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution - 1;		\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

#define RTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution / 2;		\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution / 2;		\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

// for round-to-half-grid, we first round-down-to-grid, then add 0.5
#define RTHG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x += resolution / 2;		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x += resolution / 2;		\
		x = -x;						\
	}

// for round-off, we have to do the engine compensation part only
#define ROFF(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
	} else {						\
		x -= engine;				\
	}


// Macro for testing against cvt cut-in. The purpose of this macro is to make the code more readable
// in cases such as MIRP, where this test is performed in various places in accordance with #defines
// and flags. Notice that substituting (literal) 1 for overscale will be optimized by the compiler.
#define CVTCI(parameterBlock,distance,originalDistance,overscale)													\
	{																												\
		F26Dot6 difference = distance - originalDistance;															\
		difference *= overscale;																					\
		if (difference > parameterBlock->wTCI || difference < -parameterBlock->wTCI) /* not within cvt cut-in? */	\
			distance = originalDistance;																			\
	}

/* Set default values for all variables in globalGraphicsState DefaultParameterBlock
 *      Eventually, we should provide for a Default preprogram that could optionally be 
 *      run at this time to provide a different set of default values.
 */
ErrorCode itrp_SetDefaults (
	void *  pvGlobalGS,
	Fixed   fxPixelDiameter)
{
  fnt_ParameterBlock *par;
  fnt_GlobalGraphicStateType *  globalGS;

  globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

  par = &globalGS->defaultParBlock;

#ifdef FSCFG_SUBPIXEL
  par->roundState = inRtg;
  par->RoundValue = itrp_RoundFunction[RunningSubPixel(globalGS)
#ifdef NoVirtRoundInPrep
	// at this point, globalGS->pgmIndex is not defined. However, we may assume that we're called
	// exclusively from fsg_RunPreProgram, hence we assume that we're about to do the pre-program
	&& Tuned4SubPixel(globalGS)
#endif
	][par->roundState]; // at this point, LocalGS.inSubPixelDirection may not be defined
#else
  par->RoundValue = itrp_RoundToGrid;
#endif
  par->minimumDistance = FNT_PIXELSIZE;
  par->wTCI = FNT_PIXELSIZE * 17 / 16;
  par->sWCI = 0;
  par->sW   = 0;
  par->autoFlip = true;
  par->deltaBase = 9;
  par->deltaShift = 3;
  par->angleWeight = 128;
  par->scanControl = 0;
  par->instructControl = 0;

/* Set up the engine compensation array for the interpreter */
/* This will be indexed into by the booleans in some instructions */
  globalGS->engine[0] = globalGS->engine[3] = 0;                     /* Grey and ? distance */
  globalGS->engine[1] = FIXEDTODOT6 (FIXEDSQRT2 - fxPixelDiameter);  /* Black distance */
  globalGS->engine[2] = -globalGS->engine[1];                        /* White distance */

  return NO_ERR;
}

/************************************************************************/

/*
 * Illegal instruction trap
 */
FS_PRIVATE uint8* itrp_IllegalInstruction (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
	FS_UNUSED_PARAMETER(pbyInst);

	LocalGS.ercReturn = UNDEFINED_INSTRUCTION_ERR;  /* returned to client */
	return LocalGS.pbyEndInst;                      /* stops innerEx loop */
}

/************************************************************************/

/*  Scale vector (x,y) to unit length in 2.14   rewrite - 1/25/93 - deanb */

FS_PUBLIC void itrp_Normalize (F26Dot6 x, F26Dot6 y, VECTOR *pVec)
{
	Fract fLength;
	int32 lSumOfSquares;
	 int32 lShift;

	CHECK_RANGE (x, -32768L << 6, 32767L << 6);
	CHECK_RANGE (y, -32768L << 6, 32767L << 6);


	if ((x == 0L) && (y == 0L))             /* if null vector in */
	{
		pVec->x = ONEVECTOR;                /* default to unit x vector */
		pVec->y = 0;
	}
	else
	{
		if ((x < 32767L) && (x > -32768L) && (y < 32767L) && (y > -32768L))
		{
			lSumOfSquares = (x * x) + (y * y);  
			
				lShift = 8 * sizeof(Fract) - 17; /* to get x and y to 2.30 */
			while (lSumOfSquares < 0x20000000L)
			{
				lSumOfSquares <<= 2;        /* maximize precision */
					 lShift++;
			}
				x <<= lShift;
				y <<= lShift;                         /* keep x and y in step */
		}
		else
		{
			while ((x < 0x20000000L) && (x > -0x20000000L) && (y < 0x20000000L) && (y > -0x20000000L))
			{
				x <<= 1;
				y <<= 1;
			}
			lSumOfSquares = FracMul(x, x) + FracMul(y, y);
		}
		fLength = FracSqrt(lSumOfSquares);
		pVec->x = ROUNDFIXTOINT (FracDiv(x, fLength));
		pVec->y = ROUNDFIXTOINT (FracDiv(y, fLength));
	}
}


/******************** BEGIN Internal Rounding Routines ***************************/

F26Dot6 itrp_RoundToDoubleGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTDG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToDoubleGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToDoubleGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTDG(x,engine,VIRTUAL_PIXELSIZE_RTDG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToDoubleGridSP
#endif


F26Dot6 itrp_RoundDownToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RDTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundDownToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundDownToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
#ifdef RDTGRoundsDownToGrid
	// Historically, if a point to be aligned was away by 1.5 degrees or more from the line to which to align, the TypemanTalk
	// Align has translated to SPVTL, followed by RDTG and MDRP. This has a major problem: The MDRP instruction uses the set pv
	// to measure the original distance on the UNINSTRUCTED outline. This gives us an "original" distance which is more or less
	// wrong, depending on how far the reference point has moved already (notice that it is most likely that the reference point
	// has moved somewhat in x and in y before the alignee gets to be aligned). Subsequently, when MDRP gets to move the point,
	// it uses the same pv again, but this time around on the INSTRUCTED outline, in order to determine how far the point has to
	// be moved in the end. Luckily, this is used in connection with RDTG, which is applied to the "original" distance, and
	// thereby often reduces the "original" distance to 0, which often is closer the the correct original distance than the one
	// obtained by using the pv on the uninstructed outline.
	//   In SubPixel, however, these erroneous "original" distances would be rounded down to the nearest 1/16 of a pixel, and
	// with that become highly visible (a distance of just under 1 pixel, which is what gets rounded down to 0 in b/w, is too
	// large a distance to be ignored in SP). Therefore, we have to make an exception here. The recently introduced TypemanTalk
	// DAlign command, in contrast, uses the DUAL projection vector to measure the original distance on the UNINSTRUCTED outline,
	// which gives us the correct original distance. Therefore the exception is to test whether we're using the PV (in which case
	// we fall back onto the b/w rounding) or not (in which case we're using the SP rounding).
	if (Tuned4SubPixel(LocalGS.globalGS) || LocalGS.OldProject != itrp_Project) { // we're using the dual projection vector
#endif
		F26Dot6 x = xin;

		engine /= ENGINE_COMP_OVERSCALE;
		RDTG(x,engine,VIRTUAL_PIXELSIZE_RDTG);
		if (( (int32) (xin ^ x)) < 0 && xin) {
			x = 0; /* The sign flipped, make zero */
		}
		return x;
#ifdef RDTGRoundsDownToGrid
	} else { // we're using the "normal" projection vector
		return itrp_RoundDownToGrid(GSA xin,engine);
	}
#endif
} // itrp_RoundDownToGridSP
#endif


F26Dot6 itrp_RoundUpToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RUTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundUpToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundUpToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RUTG(x,engine,VIRTUAL_PIXELSIZE_RUTG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundUpToGridSP
#endif


F26Dot6 itrp_RoundToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTG(x,engine,VIRTUAL_PIXELSIZE_RTG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToGridSP
#endif


F26Dot6 itrp_RoundToHalfGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTHG(x,engine,FNT_PIXELSIZE);
	if (((xin ^ x)) < 0 && xin) {
		x = xin > 0 ? FNT_PIXELSIZE / 2 : -FNT_PIXELSIZE / 2; /* The sign flipped, make equal to smallest valid value */
	}
	return x;
} // itrp_RoundToHalfGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToHalfGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTHG(x,engine,VIRTUAL_PIXELSIZE_RTHG);
	if (((xin ^ x)) < 0 && xin) {
		x = xin > 0 ? VIRTUAL_PIXELSIZE_RTHG / 2 : -VIRTUAL_PIXELSIZE_RTHG / 2; /* The sign flipped, make equal to smallest valid value */
	}
	return x;
} // itrp_RoundToHalfGridSP
#endif


/*
 * Internal rounding routine
 */
F26Dot6 itrp_RoundOff (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	ROFF(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundOff

/*
 * Internal rounding routine
 */
#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundOffSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	ROFF(x,engine,VIRTUAL_PIXELSIZE_ROFF);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundOffSP
#endif


/************************************************************************/

/*
 * Internal rounding routine
 */
F26Dot6 itrp_SuperRound (GSP  F26Dot6 xin, F26Dot6 engine) { // B.St. to check
  F26Dot6 x = xin;
  fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0) 
  {
	x += engine;
	x += pb->threshold - pb->phase;
	x &= pb->periodMask;
	x += pb->phase;
  } 
  else 
  {
	x = -x;
	x += engine;
	x += pb->threshold - pb->phase;
	x &= pb->periodMask;
	x += pb->phase;
	x = -x;
  }
  if (( (int32) (xin ^ x)) < 0 && xin) 
  {
	x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 itrp_Super45Round (GSP  F26Dot6 xin, F26Dot6 engine) { // B.St. to check
  F26Dot6 x = xin;
  fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0) 
  {
	x += engine;
	x += pb->threshold - pb->phase;
	x = (F26Dot6) VECTORDIV (x, pb->period45);
	x  &= ~ (FNT_PIXELSIZE - 1);
	x = (F26Dot6) VECTORMUL (x, pb->period45);
	x += pb->phase;
  } 
  else 
  {
	x = -x;
	x += engine;
	x += pb->threshold - pb->phase;
	x = (F26Dot6) VECTORDIV (x, pb->period45);
	x  &= ~ (FNT_PIXELSIZE - 1);
	x = (F26Dot6) VECTORMUL (x, pb->period45);
	x += pb->phase;
	x = -x;
  }
  if (((xin ^ x)) < 0 && xin)
  {
	x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/******************** END Rounding Routines ***************************/


/* 3-versions ************************************************************************/

/*
 * Moves the point in element by delta (measured against the projection vector)
 * along the freedom vector.
 */

FS_PRIVATE void itrp_MovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta)
{
	VECTORTYPE pfProj;
	VECTORTYPE fx;
	VECTORTYPE fy;
	  
	pfProj = LocalGS.pfProj;
	fx = LocalGS.free.x;
	fy = LocalGS.free.y;

	CHECK_POINT (&LocalGS, element, point);

	if (pfProj != ONEVECTOR)
	{
		if (fx) 
		{
			if (pfProj == fx)                   /* if proj.x = 1 */
			{
				element->x[point] += delta;
			}
			else
			{
				element->x[point] += LongMulDiv (delta, (int32)fx, (int32)pfProj);
			}
			element->f[point] |= XMOVED;
		}
		if (fy) 
		{
			if (pfProj == fy)                   /* if proj.y = 1 */
			{
				element->y[point] += delta;
			}
			else
			{
				element->y[point] += LongMulDiv (delta, (int32)fy, (int32)pfProj);
			}
			element->f[point] |= YMOVED;
		}
	}
	else
	{
		if (fx) 
		{
			element->x[point] += VECTORMUL (delta, fx);
			element->f[point] |= XMOVED;
		}
		if (fy) 
		{
			element->y[point] += VECTORMUL (delta, fy);
			element->f[point] |= YMOVED;
		}
	}
}


/*
 * For use when the projection and freedom vectors coincide along the x-axis.
 */

FS_PRIVATE void itrp_XMovePoint (GSP fnt_ElementType*element, int32 point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->x[point] += delta;
  element->f[point] |= XMOVED;
}


/*
 * For use when the projection and freedom vectors coincide along the y-axis.
 */
FS_PRIVATE void itrp_YMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->y[point] += delta;
  element->f[point] |= YMOVED;
}

/*
 * projects x and y into the projection vector.
 */
FS_PRIVATE F26Dot6 itrp_Project (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.proj.x) + VECTORMUL (y, LocalGS.proj.y));
}


/*
 * projects x and y into the old projection vector.
 */
FS_PRIVATE F26Dot6 itrp_OldProject (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.oldProj.x) + VECTORMUL (y, LocalGS.oldProj.y));
}


/*
 * Projects when the projection vector is along the x-axis
 */
F26Dot6 itrp_XProject (GSP F26Dot6 x, F26Dot6 y)
{
  FS_UNUSED_PARAMETER(y);

  return (x);
}


/*
 * Projects when the projection vector is along the y-axis
 */
F26Dot6 itrp_YProject (GSP F26Dot6 x, F26Dot6 y)
{
  FS_UNUSED_PARAMETER(x);

  return (y);
}


/*************************************************************************/

/*** Compensation for Transformations ***/

/*
* Internal support routine, keep this guy FAST!!!!!!!          <3>
*/
FS_PRIVATE Fixed itrp_GetCVTScale (GSP0)
{
  VECTORTYPE pvx, pvy;
  fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
  Fixed sySq, sxSq, strSq;

/* Do as few Math routines as possible to gain speed */

  pvx = LocalGS.proj.x;
  pvy = LocalGS.proj.y;
  if (pvy) 
  {
	if (pvx)
	{
	  if (LocalGS.cvtDiagonalStretch == 0)    /* cache is now invalid */
	  {
		pvy = VECTORDOT (pvy, pvy);
		pvx = VECTORDOT (pvx, pvx);
		sySq = FixMul (globalGS->cvtStretchY, globalGS->cvtStretchY);
		sxSq = FixMul (globalGS->cvtStretchX, globalGS->cvtStretchX);

		strSq = FixMul (VECTOR2FIX(pvx),sxSq) + FixMul (VECTOR2FIX(pvy),sySq);
		if  (strSq > ONEFIX)      /* Never happens! */
		  return ONEFIX;

		/* Convert 16.16 to 2.30, compute square root, round to 16.16 */
		LocalGS.cvtDiagonalStretch = (FracSqrt (strSq<<14) + (1<<13)) >> 14;
	  }
	  return LocalGS.cvtDiagonalStretch;
	}
	else        /* pvy == +1 or -1 */
	  return globalGS->cvtStretchY;
  }
  else  /* pvx == +1 or -1 */
	return globalGS->cvtStretchX;
}


/*      Functions for function pointer in local graphic state
*/

FS_PRIVATE F26Dot6 itrp_GetCVTEntryFast (GSP int32 n)
{
  CHECK_CVT (&LocalGS, n);
  return LocalGS.globalGS->controlValueTable[ n ];
}


FS_PRIVATE F26Dot6 itrp_GetCVTEntrySlow (GSP int32 n)
{
  Fixed scale;

  CHECK_CVT (&LocalGS, n);
  scale = itrp_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->controlValueTable[ n ], scale));
}


FS_PRIVATE F26Dot6 itrp_GetSingleWidthFast (GSP0)
{
  return LocalGS.globalGS->localParBlock.scaledSW;
}


/*
 *
 */
FS_PRIVATE F26Dot6 itrp_GetSingleWidthSlow (GSP0)
{
  Fixed scale;

  scale = itrp_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->localParBlock.scaledSW, scale));
}


/*************************************************************************/

FS_PRIVATE void itrp_ChangeCvtFast (GSP fnt_ElementType*elem, int32 number, F26Dot6 delta)
{
  FS_UNUSED_PARAMETER(elem);
  CHECK_CVT (&LocalGS, number);
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}



/*************************************************************************/

FS_PRIVATE void itrp_ChangeCvtSlow (GSP fnt_ElementType*elem, int32 number, F26Dot6 delta)
{
  FS_UNUSED_PARAMETER(elem);

  CHECK_CVT (&LocalGS, number);

  delta = FixDiv (delta, itrp_GetCVTScale(GSA0));
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}

/*************************************************************************/

/*
 * This is the tracing interpreter.
 */
FS_PRIVATE void itrp_InnerTraceExecute (GSP uint8 *pbyInst, uint8 *pbyEndInst)
{
	int32 lOpCode;

	LocalGS.pbyEndInst = pbyEndInst;                /* for illegal instruction */
	LocalGS.pbyStartInst = pbyInst;                /* to detect jump before the begining */

	if (pbyInst < pbyEndInst)
	{
		ERR_START ();
		while ((pbyInst < pbyEndInst) && (LocalGS.TraceFunc != NULL))
		{
			LocalGS.insPtr = pbyInst;               /* save for client */
			LocalGS.opCode = *pbyInst;              /* save for client */
			ERR_RECORD (*pbyInst);
			LocalGS.TraceFunc (&LocalGS, pbyEndInst);
			if (LocalGS.TraceFunc == NULL)          /* allow client to break out */
			{
				break;
			}
			lOpCode = (int32)*pbyInst;
			pbyInst++;
			pbyInst = function[ lOpCode ] (GSA pbyInst, lOpCode);
			ERR_BREAK ();
		}
		ERR_END ();
	}
}

/*************************************************************************/

/*
 * This is the fast non-tracing interpreter inner loop.
 */

FS_PRIVATE void itrp_InnerExecute (GSP uint8 *pbyInst, uint8 *pbyEndInst)
{
	int32 lOpCode;

	ERR_START ();
	
	LocalGS.pbyEndInst = pbyEndInst;                /* for illegal instruction */
	LocalGS.pbyStartInst = pbyInst;                /* to detect jump before the begining */
	
	while (pbyInst < pbyEndInst)
	{
		ERR_RECORD (*pbyInst);
			  
		lOpCode = (int32)*pbyInst;  /* opCode no longer saved in LocalGS */
		pbyInst++;

		pbyInst = function[ lOpCode ] (GSA pbyInst, lOpCode);
		ERR_BREAK ();
	}
	ERR_END ();
}

/*************************************************************************/


#ifdef FSCFG_DEBUG
FS_PRIVATE F26Dot6 itrp_GetSingleWidthNil (GSP0);
FS_PRIVATE F26Dot6 itrp_GetCVTEntryNil (GSP int32 n);

FS_PRIVATE F26Dot6 itrp_GetSingleWidthNil (GSP0)
{
  ERR_REPORT (ERR_GETSINGLEWIDTHNIL, 0, 0, 0, 0);
  return 0;
}

FS_PRIVATE F26Dot6 itrp_GetCVTEntryNil (GSP int32 n)
{
  ERR_REPORT (ERR_GETCVTENTRYNIL, 0, 0, 0, 0);
  return 0;
}
#endif

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecuteFontPgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc)
{
	fnt_GlobalGraphicStateType *    globalGS;

#ifdef FSCFG_SECURE
	int32 i;
#endif // FSCFG_SECURE

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->instrDefCount = 0;        /* none allocated yet, always do this, even if there's no fontProgram */
	globalGS->init          = TRUE;
	globalGS->pgmIndex = FONTPROGRAM;

	/* To avoid accessing unitialized memory when setting LocalGS.MIRPCode */
    globalGS->engine[0] = globalGS->engine[3] = 0;                     /* Grey and ? distance */
    globalGS->engine[1] = 0;  /* Black distance */
    globalGS->engine[2] = 0;                        /* White distance */

#ifdef FSCFG_SUBPIXEL
		// init since we don't do itrp_SetDefaults prior to executing the fpgm
    globalGS->localParBlock.roundState = inRtg;
    globalGS->localParBlock.RoundValue = itrp_RoundToGrid;

    globalGS->subPixelCompatibilityFlags = 0;
    globalGS->numDeltaFunctionsDetected = 0;
#endif

#ifdef FSCFG_SECURE
	/* initialize globalGS->funcDef[...].pgmIndex with MAXPREPROGRAMS to detect calls to undefined functions */
	for (i = 0; i < globalGS->maxp->maxFunctionDefs; i++)
	{
		globalGS->funcDef[i].pgmIndex = MAXPREPROGRAMS;

	}
#endif // FSCFG_SECURE

	if (globalGS->pgmList[FONTPROGRAM].Instruction)
	{
		return itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			globalGS->pgmList[FONTPROGRAM].Instruction,
			globalGS->pgmList[FONTPROGRAM].Instruction +
				globalGS->pgmList[FONTPROGRAM].Length,
			globalGS,
			TraceFunc);
	}
	return NO_ERR;
}

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecutePrePgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc)
{
	ErrorCode   result;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->init          = TRUE;
	globalGS->localParBlock = globalGS->defaultParBlock;    /* copy gState parameters */

	globalGS->pgmIndex = PREPROGRAM;

	if (globalGS->pgmList[PREPROGRAM].Instruction)
	{
		result = itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			globalGS->pgmList[PREPROGRAM].Instruction,
			globalGS->pgmList[PREPROGRAM].Instruction + globalGS->pgmList[PREPROGRAM].Length,
			globalGS,
			TraceFunc);
	}
	else
	{
		result = NO_ERR;
	}

	if (! (globalGS->localParBlock.instructControl & DEFAULTFLAG))
		globalGS->defaultParBlock = globalGS->localParBlock;    /* change default parameters */

	return result;
}

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecuteGlyphPgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	uint8 *             ptr,
	uint8 *    eptr,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode                       result;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	result = NO_ERR;

	globalGS->init          = FALSE;
	globalGS->pgmIndex		= GLYPHPROGRAM;
	globalGS->localParBlock = globalGS->defaultParBlock;    /* default parameters for glyphs */
	
	if (!(globalGS->localParBlock.instructControl & NOGRIDFITFLAG))
	{
		result = itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			ptr,
			eptr,
			globalGS,
			TraceFunc);
	}
	*pbChangeScanControl = (globalGS->localParBlock.scanControl !=
						   globalGS->defaultParBlock.scanControl);
	 *pusScanControl = FS_LOWORD(globalGS->localParBlock.scanControl);
	 *pusScanType =  FS_HIWORD(globalGS->localParBlock.scanControl);

	return result;
}

/*************************************************************************/

/*
 * Executes the font instructions.
 *
 * Parameter Description
 *
 * elements points to the character elements. Element 0 is always
 * reserved and not used by the actual character.
 *
 * ptr points at the first instruction.
 * eptr points to right after the last instruction
 *
 * globalGS points at the global graphics state
 *
 * TraceFunc is pointer to a callback functioned called with a pointer to the
 *              local graphics state if TraceFunc is not null.
 *
 * Note: The stuff globalGS is pointing at must remain intact
 *       between calls to this function.
 */
FS_PRIVATE ErrorCode itrp_Execute (
	fnt_ElementType *               pTwilightElement,
	fnt_ElementType *               pGlyphElement,
	uint8 *                         ptr,
	uint8 *                         eptr,
	fnt_GlobalGraphicStateType *    globalGS,
	 FntTraceFunc                           TraceFunc)

{
#ifdef FSCFG_REENTRANT
	fnt_LocalGraphicStateType thisLocalGS;
	fnt_LocalGraphicStateType* pLocalGS = &thisLocalGS;
#endif
	fnt_ElementType       aElements[MAX_ELEMENTS];

	MEMCPY((void*)&(aElements[TWILIGHTZONE]), (void*)pTwilightElement, sizeof (fnt_ElementType));
	MEMCPY((void*)&(aElements[GLYPHELEMENT]), (void*)pGlyphElement, sizeof (fnt_ElementType));
	
	STAT_ON_FNTEXEC;                        /* start STAT timer */    
	
	LocalGS.globalGS = globalGS;            /* init Local Graphics State */
	LocalGS.elements = aElements;
	LocalGS.Pt0 = 0; 
	LocalGS.Pt1 = 0; 
	LocalGS.Pt2 = 0;
	LocalGS.CE0 = &aElements[GLYPHELEMENT];
	LocalGS.CE1 = &aElements[GLYPHELEMENT];
	LocalGS.CE2 = &aElements[GLYPHELEMENT];
	LocalGS.free.x = ONEVECTOR;
	LocalGS.proj.x = ONEVECTOR;
	LocalGS.oldProj.x = ONEVECTOR;
	LocalGS.free.y = 0;
	LocalGS.proj.y = 0;
	LocalGS.oldProj.y = 0;
	LocalGS.pfProj = ONEVECTOR;
	LocalGS.MovePoint = itrp_XMovePoint;
	LocalGS.Project = itrp_XProject;
	LocalGS.OldProject = itrp_XProject;
	LocalGS.loop = 0;           /* 1 less than count for faster loops. mrr */

	LocalGS.ulJumpCounter = globalGS->ulMaxJumpCounter;           /* counter used to catch infinite loops */
	LocalGS.ulRecursiveCall = globalGS->ulMaxRecursiveCall;           /* counter used to catch deep recrusion */

	if (globalGS->engine[1] == 0)           /* if engine compenstion turned off */
	{
		LocalGS.MIRPCode = MIRPX;           /* default to fast mirp */
	}
	else
	{
		LocalGS.MIRPCode = MIRPG;           /* fall back to general mirp */
	}

	if (globalGS->pgmIndex == FONTPROGRAM)
	{
#ifdef FSCFG_DEBUG
		LocalGS.GetCVTEntry = itrp_GetCVTEntryNil;
		LocalGS.GetSingleWidth = itrp_GetSingleWidthNil;
#else
		LocalGS.GetCVTEntry = itrp_GetCVTEntryFast;
		LocalGS.GetSingleWidth = itrp_GetSingleWidthFast;
#endif
		LocalGS.ChangeCvt = itrp_ChangeCvtFast;
	}
	else
	{
#ifdef FSCFG_SUBPIXEL
		globalGS->subPixelCompatibilityFlags &= ~(SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound | SPCF_inSkippableDeltaFn);
		// can't do this when doing the font program, would try to access the localParBlock, which is still uninitialized at this point.
		UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif
		if (globalGS->pixelsPerEm <= 1)
			return NO_ERR;
		  
		if (globalGS->bSameStretch)
		{
			LocalGS.GetCVTEntry = itrp_GetCVTEntryFast;
			LocalGS.GetSingleWidth = itrp_GetSingleWidthFast;
			LocalGS.ChangeCvt = itrp_ChangeCvtFast;
		} 
		else 
		{
			LocalGS.GetCVTEntry = itrp_GetCVTEntrySlow;
			LocalGS.GetSingleWidth = itrp_GetSingleWidthSlow;
			LocalGS.ChangeCvt = itrp_ChangeCvtSlow;
			LocalGS.MIRPCode = MIRPG;       /* fall back to general mirp */
		}

		if (globalGS->localParBlock.sW)     /* We need to scale the single width for this size  */
		{
			globalGS->localParBlock.scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)(globalGS->localParBlock.sW));
			LocalGS.MIRPCode = MIRPG;       /* fall back to general mirp */
		}
	}
	
	LocalGS.stackPointer = globalGS->stackBase;
	LocalGS.TraceFunc = TraceFunc;
	LocalGS.ercReturn = NO_ERR;             /* default return value */

	if (TraceFunc != NULL)
	{
		LocalGS.Interpreter = itrp_InnerTraceExecute;
	}
	else
	{
		LocalGS.Interpreter = itrp_InnerExecute;
	}
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(globalGS) && CompatibleWidthSP(globalGS))
			InitPhaseControl(&LocalGS.elements[GLYPHELEMENT]); // beats
#endif

	(*LocalGS.Interpreter) (GSA ptr, eptr);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		!LocalGS.elements[GLYPHELEMENT].phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,&LocalGS.elements[GLYPHELEMENT]); // beats
	//	phaseControlExecuted == true by now
	}
#endif
	STAT_OFF_FNTEXEC;                            /* stop STAT timer */
	
	return LocalGS.ercReturn;               /* NO_ERR unless illegal inst */
}


/*************************************************************************/

/*** 2 internal LocalGS.pfProj computation support routines ***/

/*
 * Only does the check of LocalGS.pfProj
 */
  FS_PRIVATE void itrp_Check_PF_Proj (GSP0)
  {
	VECTORTYPE pfProj = LocalGS.pfProj;

	if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
	{
	  LocalGS.pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
	}
  }


/*
 * Computes LocalGS.pfProj and then does the check
 */
  FS_PRIVATE void itrp_ComputeAndCheck_PF_Proj (GSP0)
  {
	VECTORTYPE pfProj;

	pfProj = (VECTORTYPE)(VECTORDOT (LocalGS.proj.x, LocalGS.free.x) + VECTORDOT (LocalGS.proj.y, LocalGS.free.y));
	if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
	{
	  pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
	}
	LocalGS.pfProj = pfProj;

	LocalGS.cvtDiagonalStretch = 0;      /* invalidate cache */ 
  }

/******************************************/
/******** The Actual Instructions *********/
/******************************************/

/*
 * Set Vectors To Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = LocalGS.proj.x = 0;
	LocalGS.free.y = LocalGS.proj.y = ONEVECTOR;
	LocalGS.MovePoint = itrp_YMovePoint;
	LocalGS.Project = itrp_YProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.OldProject = itrp_YProject;
	LocalGS.pfProj = ONEVECTOR;
	if (LocalGS.MIRPCode != MIRPG)          /* if we haven't fallen back */
	{
		LocalGS.MIRPCode = MIRPY;           /* then use fast mirp */
	}
	return pbyInst;
  }

/*
 * Set Vectors To Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = LocalGS.proj.x = ONEVECTOR;
	LocalGS.free.y = LocalGS.proj.y = 0;
	LocalGS.MovePoint = itrp_XMovePoint;
	LocalGS.Project = itrp_XProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.OldProject = itrp_XProject;
	LocalGS.pfProj = ONEVECTOR;
	if (LocalGS.MIRPCode != MIRPG)          /* if we haven't fallen back */
	{
		LocalGS.MIRPCode = MIRPX;           /* then use fast mirp */
	}
	return pbyInst;
  }

/*
 * Set Projection Vector To Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SPVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.proj.x = 0;
	LocalGS.proj.y = ONEVECTOR;
	LocalGS.Project = itrp_YProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.pfProj = LocalGS.free.y;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Projection Vector To Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SPVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.proj.x = ONEVECTOR;
	LocalGS.proj.y = 0;
	LocalGS.Project = itrp_XProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.pfProj = LocalGS.free.x;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Freedom Vector to Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SFVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = 0;
	LocalGS.free.y = ONEVECTOR;
	LocalGS.pfProj = LocalGS.proj.y;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Freedom Vector to Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SFVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = ONEVECTOR;
	LocalGS.free.y = 0;
	LocalGS.pfProj = LocalGS.proj.x;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Projection Vector To Line
 */
  FS_PRIVATE uint8* itrp_SPVTL (IPARAM)
  {
	int32 arg1, arg2;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

	CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = (int16)arg2; LocalGS.pt1 = (int16)arg1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);
	if (BIT0 (lOpCode)) { // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp = LocalGS.proj.y;
	  LocalGS.proj.y = LocalGS.proj.x;
	  LocalGS.proj.x = (VECTORTYPE)(-tmp);
	}

	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Dual Projection Vector To Line
 */
  FS_PRIVATE uint8* itrp_SDPVTL (IPARAM)
  {
	int32 arg1, arg2;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = (int16)arg2; LocalGS.pt1 = (int16)arg1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

//	Do the current domain
	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);

//	Do the old domain
	itrp_Normalize (LocalGS.CE1->ox[arg1] - LocalGS.CE2->ox[arg2], LocalGS.CE1->oy[arg1] - LocalGS.CE2->oy[arg2], &LocalGS.oldProj);

	if (BIT0 (lOpCode))	{ // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp = LocalGS.proj.y;
	  LocalGS.proj.y = LocalGS.proj.x;
	  LocalGS.proj.x = (VECTORTYPE)(-tmp);

	  tmp = LocalGS.oldProj.y;
	  LocalGS.oldProj.y = LocalGS.oldProj.x;
	  LocalGS.oldProj.x = (VECTORTYPE)(-tmp);
	}
	
	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = itrp_OldProject;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Freedom Vector To Line
 */
  FS_PRIVATE uint8* itrp_SFVTL (IPARAM)
  {
	int32 arg1, arg2;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.free);
	if (BIT0 (lOpCode)) { // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp     = LocalGS.free.y;
	  LocalGS.free.y     = LocalGS.free.x;
	  LocalGS.free.x     = (VECTORTYPE)(-tmp);
	}
	
	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Write Projection Vector
 */
  FS_PRIVATE uint8* itrp_WPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    LocalGS.proj.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
	LocalGS.proj.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	CHECK_VECTOR (LocalGS.proj.x, LocalGS.proj.y);
	itrp_ComputeAndCheck_PF_Proj (GSA0);

	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Write Freedom vector
 */
  FS_PRIVATE uint8* itrp_WFV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    LocalGS.free.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
	LocalGS.free.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

	CHECK_VECTOR (LocalGS.free.x, LocalGS.free.y);
	itrp_ComputeAndCheck_PF_Proj (GSA0);

	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Read Projection Vector
 */
  FS_PRIVATE uint8* itrp_RPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 2);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.x);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.y);
	return pbyInst;
  }

/*
 * Read Freedom Vector
 */
  FS_PRIVATE uint8* itrp_RFV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 2);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.x);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.y);
	return pbyInst;
  }

/*
 * Set Freedom Vector To Projection Vector
 */
  FS_PRIVATE uint8* itrp_SFVTPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free = LocalGS.proj;
	LocalGS.pfProj = ONEVECTOR;
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * itrp_ISECT ()
 *
 * Computes the intersection of two lines without using floating point!!
 *
 * (1) Bx + dBx * t0 = Ax + dAx * t1
 * (2) By + dBy * t0 = Ay + dAy * t1
 *
 *  1  => (t1 = Bx - Ax + dBx * t0) / dAx
 *  +2 =>   By + dBy * t0 = Ay + dAy/dAx * [ Bx - Ax + dBx * t0 ]
 *     => t0 * [dAy/dAx * dBx - dBy] = By - Ay - dAy/dAx* (Bx-Ax)
 *     => t0 (dAy*DBx - dBy*dAx) = dAx (By - Ay) + dAy (Ax-Bx)
 *     => t0 = [dAx (By-Ay) + dAy (Ax-Bx)] / [dAy*dBx - dBy*dAx]
 *     => t0 = [dAx (By-Ay) - dAy (Bx-Ax)] / [dBx*dAy - dBy*dAx]
 *     t0 = N/D
 *     =>
 *          N = (By - Ay) * dAx - (Bx - Ax) * dAy;
 *              D = dBx * dAy - dBy * dAx;
 *      A simple floating point implementation would only need this, and
 *      the check to see if D is zero.
 *              But to gain speed we do some tricks and avoid floating point.
 *
 */
  FS_PRIVATE uint8* itrp_ISECT (IPARAM)
  {
	F26Dot6 N, D;
	int32   arg1, arg2;
	F26Dot6 Bx, By, Ax, Ay;
	F26Dot6 dBx, dBy, dAx, dAy;

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	int32 arg1p, arg2p;
#endif

	{
	  fnt_ElementType*element = LocalGS.CE0;
	  F26Dot6*stack = LocalGS.stackPointer;

	  FS_UNUSED_PARAMETER(lOpCode);

      SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 5);

	  arg2 = (int32)CHECK_POP (stack); /* get one line */
	  arg1 = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE0, arg2);
	  SECURE_CHECK_POINT (LocalGS.CE0, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, arg2);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, arg1);
	  dAx = element->x[arg2] - (Ax = element->x[arg1]);
	  dAy = element->y[arg2] - (Ay = element->y[arg1]);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS)) {
		  arg2p = arg2;
		  arg1p = arg1;
	  }
#endif

	  element = LocalGS.CE1;
	  arg2 = (int32)CHECK_POP (stack); /* get the other line */
	  arg1 = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE1, arg2);
	  SECURE_CHECK_POINT (LocalGS.CE1, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE1, arg2);
	  CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);
	  dBx = element->x[arg2] - (Bx = element->x[arg1]);
	  dBy = element->y[arg2] - (By = element->y[arg1]);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS) && MABS(Mul26Dot6(dBy,dAx)) > MABS(Mul26Dot6(dBx,dAy))) {
		  arg2p = arg2;	// pick the line which is closer to the y-axis
		  arg1p = arg1; // since aligning perpendicular to parent axis
	  }
#endif
	  arg1 = (int32)CHECK_POP (stack); /* get the point number */
	  SECURE_CHECK_POINT (LocalGS.CE2, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE2, arg1);
	  LocalGS.stackPointer = stack;

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  // for our purposes, handle like a proportion (have intersected point follow proportional to parents)
	  // need no fv, pv set for ISECT, hence we don't test against LocalGS.inSubPixelDirection
	  if (LocalGS.CE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS))
		AddProportion(&LocalGS,LocalGS.CE2,arg1p,arg1,arg2p);
#endif
				


	}
	LocalGS.CE2->f[arg1] |= XMOVED | YMOVED;
	{
	  F26Dot6*elementx = LocalGS.CE2->x;
	  F26Dot6*elementy = LocalGS.CE2->y;
	  if (dAy == 0) 
	  {
		if (dBx == 0) 
		{
		  elementx[arg1] = Bx;
		  elementy[arg1] = Ay;
		  return pbyInst;
		}
		N = By - Ay;
		D = -dBy;
	  } 
	  else if (dAx == 0) 
	  {
		if (dBy == 0) 
		{
		  elementx[arg1] = Ax;
		  elementy[arg1] = By;
		  return pbyInst;
		}
		N = Bx - Ax;
		D = -dBx;
	  } 
	  else if (MABS (dAx) >= MABS (dAy))
	  {
/* To prevent out of range problems divide both N and D with the max */
		N = (By - Ay) - MulDiv26Dot6 (Bx - Ax, dAy, dAx);
		D = MulDiv26Dot6 (dBx, dAy, dAx) - dBy;
	  } 
	  else 
	  {
		N = MulDiv26Dot6 (By - Ay, dAx, dAy) - (Bx - Ax);
		D = dBx - MulDiv26Dot6 (dBy, dAx, dAy);
	  }

	  if (D) 
	  {
		elementx[arg1] = Bx + (F26Dot6) MulDiv26Dot6 (dBx, N, D);
		elementy[arg1] = By + (F26Dot6) MulDiv26Dot6 (dBy, N, D);
	  } 
	  else 
	  {
/* degenerate case: parallell lines, put point in the middle */
		elementx[arg1] = (Bx + (dBx >> 1) + Ax + (dAx >> 1)) >> 1;
		elementy[arg1] = (By + (dBy >> 1) + Ay + (dAy >> 1)) >> 1;
	  }
	}
	return pbyInst;
  }

/*
 * Load Minimum Distance
 */
  FS_PRIVATE uint8* itrp_LMD (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.minimumDistance = CHECK_POP (LocalGS.stackPointer);
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.minimumDistance);
	return pbyInst;
  }

/*
 * Load Control Value Table Cut In
 */
  FS_PRIVATE uint8* itrp_LWTCI (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.wTCI = CHECK_POP (LocalGS.stackPointer);
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.wTCI);
	return pbyInst;
  }

/*
 * Load Single Width Cut In
 */
  FS_PRIVATE uint8* itrp_LSWCI (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.sWCI = CHECK_POP (LocalGS.stackPointer);
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.sWCI);
	return pbyInst;
  }

/*
 * Load Single Width , assumes value comes from the original domain, not the cvt or outline
 */
  FS_PRIVATE uint8* itrp_LSW (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	fnt_ParameterBlock *pb = &globalGS->localParBlock;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	pb->sW = (int16)arg;
	CHECK_LARGER (-1L, pb->sW);

	pb->scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)pb->sW); /* measurement should not come from the outline */
	return pbyInst;
  }

/* these functions were split out from itrp_SetLocalGraphicState - deanb */
  
  FS_PRIVATE uint8* itrp_SRP0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt0 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SRP1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt1 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SRP2 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt2 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }
  
  FS_PRIVATE uint8* itrp_LLOOP (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.loop = (int32)(CHECK_POP (LocalGS.stackPointer)) - 1;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_POP (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }


  FS_PRIVATE uint8* itrp_SetElementPtr (IPARAM)
  {
	int32             arg;
	fnt_ElementType * element;

	switch (lOpCode)
	{
	  case SCES_CODE: 
		ERR_OPC ("SCES");
		break;
	  case SCE0_CODE: 
		ERR_OPC ("SCE0");
		break;
	  case SCE1_CODE: 
		ERR_OPC ("SCE1");
		break;
	  case SCE2_CODE: 
		ERR_OPC ("SCE2");
		break;
	  default:
		ERR_OPC ("???");
		break;
	}

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_ZONE(arg);
    CHECK_ELEMENT (&LocalGS, arg);
	element = &LocalGS.elements[ arg ];

	switch (lOpCode)
	{
	  case SCES_CODE: 
		LocalGS.CE2 = element;
		LocalGS.CE1 = element;
	  case SCE0_CODE: 
		LocalGS.CE0 = element;
		break;
	  case SCE1_CODE: 
		LocalGS.CE1 = element;
		break;
	  case SCE2_CODE: 
		LocalGS.CE2 = element;
		break;
#ifdef FSCFG_DEBUG
	  default:
		ERR_REPORT (ERR_INVOPC, lOpCode, 0, 0, 0);
		break;
#endif
	}
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Super Round
 */
  FS_PRIVATE uint8* itrp_SROUND (IPARAM)
  {
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
	int32      arg1;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	arg1 = (int32)arg;
	itrp_SetRoundValues (GSA arg1, true);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inSRnd);
#else
	pb->RoundValue = itrp_SuperRound; // B.St. to check
#endif
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Super Round
 */
  FS_PRIVATE uint8* itrp_S45ROUND (IPARAM)
  {
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
	int32      arg1;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	arg1 = (int32)arg;
	itrp_SetRoundValues (GSA arg1, false);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inS45Rnd);
#else
	pb->RoundValue = itrp_Super45Round; // B.St. to check
#endif
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*********************************************************************/

/*  These routines were split out from SetRoundState  */
/*  They set the current rounding state, and all but  */
/*  RoundToGrid cause MIRP to fall back to MIRPG      */


FS_PRIVATE uint8* itrp_RTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRtg)
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToGrid;
#endif
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RTHG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRthg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToHalfGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RTDG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRtdg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToDoubleGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_ROFF (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRoff);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundOff;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RDTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRdtg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundDownToGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RUTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRutg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundUpToGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

/*********************************************************************/


#define FRACSQRT2DIV2   11591
/*
 * Internal support routine for the super rounding routines
 */
  FS_PRIVATE void itrp_SetRoundValues (GSP int32 arg1, int32 normalRound)
  {
	 int32       tmp;
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

	tmp = arg1 & 0xC0;

	if (normalRound) 
	{
	  switch (tmp) 
	  {
	  case 0x00:
		pb->period = FNT_PIXELSIZE / 2;
		break;
	  case 0x40:
		pb->period = FNT_PIXELSIZE;
		break;
	  case 0x80:
		pb->period = FNT_PIXELSIZE * 2;
		break;
	  default:
		pb->period = 999; /* Illegal */
	  }
	  pb->periodMask = ~ (pb->period - 1);
	} 
	else 
	{
	  pb->period45 = FRACSQRT2DIV2;
	  switch (tmp) 
	  {
	  case 0x00:
		pb->period45 >>= 1;
		break;
	  case 0x40:
		break;
	  case 0x80:
		pb->period45 <<= 1;
		break;
	  default:
		pb->period45 = 999; /* Illegal */
	  }
	  tmp = (sizeof (pb->period45) * 8 - 2 - FNT_PIXELSHIFT);
	  pb->period = (int16) ((pb->period45 + (1L << (tmp - 1))) >> tmp); /*convert from 2.30 to 26.6 */
	}

	tmp = arg1 & 0x30;
	switch (tmp) 
	{
	case 0x00:
	  pb->phase = 0;
	  break;
	case 0x10:
	  pb->phase = (int16)((pb->period + 2) >> 2);
	  break;
	case 0x20:
	  pb->phase = (int16)((pb->period + 1) >> 1);
	  break;
	case 0x30:
	  pb->phase = (int16)((pb->period + pb->period + pb->period + 2) >> 2);
	  break;
	}
	tmp = arg1 & 0x0f;
	if (tmp == 0) 
	{
	  pb->threshold = (int16)(pb->period - 1);
	} 
	else 
	{
	  pb->threshold = (int16)(((tmp - 4) * pb->period + 4) >> 3);
	}
  }

/*
 * Read Advance Width
 */
  FS_PRIVATE uint8* itrp_RAW (IPARAM)
  {
	F26Dot6* ox;
	int32 index;  

	FS_UNUSED_PARAMETER(lOpCode);

	if (LocalGS.globalGS->pgmIndex != GLYPHPROGRAM)
	{
		LocalGS.ercReturn = RAW_NOT_IN_GLYPHPGM_ERR;  /* returned to client, error RAW not in glyph program */
		return LocalGS.pbyEndInst;
	}

	ox = LocalGS.elements[GLYPHELEMENT].ox;
	index = LocalGS.elements[GLYPHELEMENT].ep[LocalGS.elements[GLYPHELEMENT].nc - 1] + 1;      /* lsb point */

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH( LocalGS.stackPointer, ox[index+1] - ox[index] );
	return pbyInst;
  }

/*
 * DUPlicate
 */
  FS_PRIVATE uint8* itrp_DUP (IPARAM)
  {
	F26Dot6 top;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	top = LocalGS.stackPointer[-1];
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, top);
	return pbyInst;
  }

/*
 * CLEAR stack
 */
  FS_PRIVATE uint8* itrp_CLEAR (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.stackPointer = LocalGS.globalGS->stackBase;
	return pbyInst;
  }

/*********************************************************************/

/*
 * SWAP
 */
FS_PRIVATE uint8* itrp_SWAP (IPARAM)
{
	F26Dot6 *pfxStack;
	F26Dot6 fxTemp;
		   
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxTemp = pfxStack[0];
	pfxStack[0] = pfxStack[-1];
	pfxStack[-1] = fxTemp;
	
	return pbyInst;
}

/*********************************************************************/

/*
 * DEPTH
 */
  FS_PRIVATE uint8* itrp_DEPTH (IPARAM)
  {
	F26Dot6 depth = (F26Dot6)(LocalGS.stackPointer - LocalGS.globalGS->stackBase);
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, depth);
	return pbyInst;
  }

/*
 * Copy INDEXed value
 */
  FS_PRIVATE uint8* itrp_CINDEX (IPARAM)
  {
	int32   arg1;
	F26Dot6 tmp, *p;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

	arg1 = (int32)CHECK_POP (stack);

    SECURE_CHECK_FOR_POP (stack, arg1);

	p = stack - arg1;
	CHECK_SUBSTACK (&LocalGS, p);
	SECURE_CHECK_SUBSTACK (p);

	tmp = *p;

	CHECK_PUSH (stack , tmp);
	return pbyInst;
  }

/*
 * Move INDEXed value
 */
  FS_PRIVATE uint8* itrp_MINDEX (IPARAM)
  {
	int32   arg1;
	F26Dot6 tmp, *p;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

	arg1 = (int32)CHECK_POP (stack);

    SECURE_CHECK_FOR_POP (stack, arg1);

	p = stack - arg1;
	CHECK_SUBSTACK (&LocalGS, p);
	SECURE_CHECK_SUBSTACK (p);

	tmp = *p;

	if (arg1 > 0) 
	{
	  do 
	  {
		*p = * (p + 1); 
		p++;
	  } while (--arg1);
	  CHECK_POP (stack);
	}
	CHECK_PUSH (stack, tmp);
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 *      Rotate element 3 to the top of the stack                        <4>
 *      Thanks to Oliver for the obscure code.
 */
  FS_PRIVATE uint8* itrp_ROTATE (IPARAM)
  {
	F26Dot6 *stack = LocalGS.stackPointer;
	F26Dot6 element1;
	F26Dot6 element2;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 3);
	element1 = *--stack;
	element2 = *--stack;

    *stack = element1;
	element1 = *--stack;
	*stack = element2;
	* (stack + 2) = element1;
	return pbyInst;
  }

/*********************************************************************/

/*
 * Move Direct Absolute Point
 */
FS_PRIVATE uint8* itrp_MDAP (IPARAM) {
	F26Dot6 fxProj;
	fnt_ElementType *pCE0;
	fnt_ParameterBlock *pb;
	int32 iPoint;

	pCE0 = LocalGS.CE0;
	pb = &LocalGS.globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPoint);
	CHECK_POINT (&LocalGS, pCE0, iPoint);
	LocalGS.Pt0 = iPoint; 
	LocalGS.Pt1 = iPoint;

	if (BIT0 (lOpCode)) { // round?
		fxProj = (*LocalGS.Project) (GSA pCE0->x[iPoint], pCE0->y[iPoint]);
		fxProj = pb->RoundValue (GSA fxProj, LocalGS.globalGS->engine[0]) - fxProj;
	} else {
		fxProj = 0;         /* mark the point as touched */
	}

	(*LocalGS.MovePoint) (GSA pCE0, iPoint, fxProj);
	return pbyInst;
} // itrp_MDAP

/*********************************************************************/

/*
 * Move Indirect Absolute Point
 */
FS_PRIVATE uint8* itrp_MIAP (IPARAM) {
	int32   iPoint;
	int32   iCVTIndex;
	F26Dot6 fxNewProj;
	F26Dot6 fxOrigProj;
	F26Dot6 fxProjDif;
	fnt_ElementType *pCE0;
	fnt_ParameterBlock *pb;

	pCE0 = LocalGS.CE0;
	pb = &LocalGS.globalGS->localParBlock;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	iCVTIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (iCVTIndex);
	CHECK_CVT (&LocalGS, iCVTIndex);
	fxNewProj = LocalGS.GetCVTEntry (GSA iCVTIndex);

	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPoint);
	CHECK_POINT (&LocalGS, pCE0, iPoint);
	LocalGS.Pt0 = iPoint;
	LocalGS.Pt1 = iPoint;

	if (pCE0 == &LocalGS.elements[TWILIGHTZONE]) {
		pCE0->x[iPoint] = (F26Dot6) VECTORMUL (fxNewProj, LocalGS.proj.x);
		pCE0->ox[iPoint] = pCE0->x[iPoint];
		pCE0->y[iPoint] = (F26Dot6) VECTORMUL (fxNewProj, LocalGS.proj.y);
		pCE0->oy[iPoint] = pCE0->y[iPoint];
	}

	fxOrigProj = (*LocalGS.Project) (GSA pCE0->x[iPoint], pCE0->y[iPoint]);

	if (BIT0 (lOpCode)) { // round?
		fxProjDif = fxNewProj - fxOrigProj;
		if (fxProjDif < 0) {
			fxProjDif = -fxProjDif;
		}
		if (fxProjDif > pb->wTCI) {
			fxNewProj = fxOrigProj;
		}
		fxNewProj = pb->RoundValue (GSA fxNewProj, LocalGS.globalGS->engine[0]);
	}
	// Notice that unlike MIRP, here we don't have a switch that would require the round-off flag MIAP[r] to honour
	// the cvt cut-in. We assume that the context is a stroke placement with coordinates calculated to move a stroke
	// possibly from the origin to the targeted location such as in PMingLiU. See also comments in MSIRP and MIRP.
	
	(*LocalGS.MovePoint) (GSA pCE0, iPoint, fxNewProj - fxOrigProj);
	return pbyInst;
} // itrp_MIAP


/*********************************************************************/

FS_PRIVATE uint8* itrp_IUP (IPARAM)
{
	fnt_ElementType *pCE2;
	
	int32 *alOrig;                          /* original outline array */
	int32 *plOrig;
	int32 *plOrigTouch2;                    /* for loop stop */
	int32 *plOrigEnd;
	int32 lOrig1;                           /* touched point 1 */
	int32 lOrig2;                           /* touched point 2 */
	int32 lOrigMin;                         /* min coord touched point */
	int32 lOrigDelta;
	int32 lOrigCorr;
	
	F26Dot6 *afxScaled;                     /* scaled outline array */
	F26Dot6 *pfxScaled;
	F26Dot6 fxScaledMax;
	F26Dot6 fxScaledMin;
	F26Dot6 fxScaledCoord;
	
	F26Dot6 fxMovedMax;                     /* hint movement of max */
	F26Dot6 fxMovedMin;                     /* hint movement of min */

	F26Dot6 *afxHinted;                     /* hinted outline array */
	F26Dot6 *pfxHinted;
	F26Dot6 fxHintedMax;
	F26Dot6 fxHintedMin;
	F26Dot6 fxHintedDelta;

	uint8 *abyFlags;                        /* point flags array */
	uint8 byMask;
	
	int32 iPt;                         /* current point index */
	int32 iStartPt;                    /* start of contour */
	int32 iEndPt;                      /* end of contour */
	int32 iStopPt;                     /* touched point indicates completion */
	int32 iTouch1;
	int32 iTouch2;
	int32 iMin;
	int32 iMax;
			   
	int32 iContour;

	int32 lTemp;
	Fixed fRatio;

	STAT_ON_IUP;                        /* start STAT timer */    

	pCE2 = LocalGS.CE2;

	SECURE_CHECK_FOR_UNITIALIZED_ZONE(pCE2);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS,pCE2 != &LocalGS.elements[TWILIGHTZONE] && // beats
		LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		VerticalSPDirection(LocalGS.globalGS) != (lOpCode & 0x01) && !pCE2->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,pCE2);
	//	phaseControlExecuted == true by now
	}
#endif
	
	abyFlags = pCE2->f;

	if (lOpCode & 0x01)              /* use x coordinates */
	{
		afxHinted = pCE2->x;
		afxScaled = pCE2->ox;
		if( LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			alOrig = pCE2->ox;
		}
		else
		{
			alOrig = pCE2->oox;
		}
		byMask = XMOVED;
	} 
	else                                    /* use y coordinates */
	{
		afxHinted = pCE2->y;
		afxScaled = pCE2->oy;
		if( LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			alOrig = pCE2->oy;
		}
		else
		{
			alOrig = pCE2->ooy;
		}
		byMask = YMOVED;
	}

	for (iContour = 0; iContour < pCE2->nc; iContour++)
	{
		iStartPt = pCE2->sp[iContour];
		iEndPt = pCE2->ep[iContour];
		plOrigEnd = &alOrig[iEndPt];        /* for limit check */

		iPt = iStartPt;
		while (!(abyFlags[iPt] & byMask) && (iPt <= iEndPt))
		{
			iPt++;
		}
		if (iPt <= iEndPt)                  /* if any points are touched */
		{
			iStopPt = iPt;                  /* save for done condition */
			
			do                              /* for each contour segment */
			{
				do                          /* find next untouched point */
				{
					iTouch1 = iPt;
					iPt++;
					if (iPt > iEndPt)
					{
						iPt = iStartPt;
					}
				} while ((abyFlags[iPt] & byMask) && iPt != iStopPt);

				if (iPt != iStopPt)
				{
					iTouch2 = iPt;
					do                      /* find next touched point */
					{
						iTouch2++;
						if (iTouch2 > iEndPt)
						{
							iTouch2 = iStartPt;
						}
					} while (!(abyFlags[iTouch2] & byMask));

					lOrig1 = alOrig[iTouch1];
					lOrig2 = alOrig[iTouch2];
					if (lOrig1 < lOrig2)
					{
						lOrigMin = lOrig1;
						lOrigDelta = lOrig2 - lOrig1;
						iMin = iTouch1;
						iMax = iTouch2;
					}
					else
					{
						lOrigMin = lOrig2;
						lOrigDelta = lOrig1 - lOrig2;
						iMin = iTouch2;
						iMax = iTouch1;
					}
					
					fxHintedMin = afxHinted[iMin];
					fxScaledMin = afxScaled[iMin];
					fxMovedMin = fxHintedMin - fxScaledMin;

					if (lOrigDelta != 0L)
					{
						fxScaledMax = afxScaled[iMax];
						fxHintedMax = afxHinted[iMax];
						fxMovedMax = fxHintedMax - fxScaledMax;
						fxHintedDelta = fxHintedMax - fxHintedMin;

						if (lOrigDelta < 32768 && fxHintedDelta < 32768)
						{
							plOrig = &alOrig[iPt];          /* set up pointers */
							pfxScaled = &afxScaled[iPt];
							pfxHinted = &afxHinted[iPt];
							lOrigCorr = lOrigDelta >> 1;
							plOrigTouch2 = &alOrig[iTouch2];    /* set limits */
							
							while (plOrig < plOrigTouch2)   /* if not across start/end */
							{
								fxScaledCoord = *pfxScaled;
								if ((fxScaledCoord > fxScaledMin) && (fxScaledCoord < fxScaledMax))
								{
									lTemp = SHORTMUL (*plOrig - lOrigMin, fxHintedDelta);
									lTemp += lOrigCorr;
									lTemp /= lOrigDelta;
									*pfxHinted = (F26Dot6)lTemp + fxHintedMin;
								}
								else if (fxScaledCoord >= fxScaledMax)
								{
									*pfxHinted = fxScaledCoord + fxMovedMax;
								}
								else
								{
									*pfxHinted = fxScaledCoord + fxMovedMin;
								}
								plOrig++;
								pfxScaled++;
								pfxHinted++;
							}                               /* end of time critical loop */
															
							while (plOrig != plOrigTouch2)  /* if points span start/end */
							{
								fxScaledCoord = *pfxScaled;
								if ((fxScaledCoord > fxScaledMin) && (fxScaledCoord < fxScaledMax))
								{
									lTemp = SHORTMUL (*plOrig - lOrigMin, fxHintedDelta);
									lTemp += lOrigCorr;
									lTemp /= lOrigDelta;
									*pfxHinted = (F26Dot6)lTemp + fxHintedMin;
								}
								else if (fxScaledCoord >= fxScaledMax)
								{
									*pfxHinted = fxScaledCoord + fxMovedMax;
								}
								else
								{
									*pfxHinted = fxScaledCoord + fxMovedMin;
								}
								plOrig++;
								pfxScaled++;
								pfxHinted++;
								
								if (plOrig > plOrigEnd)
								{
									plOrig = &alOrig[iStartPt];
									pfxScaled = &afxScaled[iStartPt];
									pfxHinted = &afxHinted[iStartPt];
								}
							}
							iPt = iTouch2;              /* keep in step */
						}
						else                /* if too big for 32 bit product */
						{
							fRatio = FixDiv (fxHintedDelta, lOrigDelta);
							while (iPt != iTouch2)
							{
								lTemp = afxScaled[iPt];
								if (lTemp <= fxScaledMin)
								{
									lTemp += fxMovedMin;
								}
								else if (lTemp >= fxScaledMax)
								{
									lTemp += fxMovedMax;
								}
								else
								{
									lTemp = alOrig[iPt];
									lTemp -= lOrigMin;
									lTemp = FixMul (lTemp, fRatio);
									lTemp += fxHintedMin;
								}
								afxHinted[iPt] = (F26Dot6)lTemp;
								
								if (iPt < iEndPt)
									iPt++;
								else
									iPt = iStartPt;
							}
						}                   /* endif (lOrigDelta < 32768 && fxHintedDelta < 32768) */
					}
					else                    /* if (lOrigDelta == 0L) */
					{
						while (iPt != iTouch2)
						{
							afxHinted[iPt] += fxMovedMin;
							
							if (iPt < iEndPt)
								iPt++;
							else
								iPt = iStartPt;
						}
					}                       /* endif (lOrigDelta != 0L) */
				}                           /* endif (iPt != iStopPt) */
			} while (iPt != iStopPt);       /* until contour is closed */
		}                                   /* endif (iPt <= iEndPt) */
	 }
								  /* next contour */
	STAT_OFF_IUP;                           /* stop STAT timer */    

#ifdef FSCFG_SUBPIXEL
	LocalGS.globalGS->subPixelCompatibilityFlags |= (lOpCode & 0x01 ? SPCF_iupxCalled : SPCF_iupyCalled);
#endif

	return pbyInst;
} // itrp_IUP

/*********************************************************************/

boolean IsSideBearingPoint(fnt_ElementType *element, int32 point);
boolean IsSideBearingPoint(fnt_ElementType *element, int32 point) {
	int32 numPoints = (int32)element->ep[element->nc - 1] + 1;
	return numPoints + LEFTSIDEBEARING <= point && point <= numPoints + RIGHTSIDEBEARING;
} // IsSideBearingPoint

boolean IsSideBearingLink(fnt_ElementType *element, int32 point0, int32 point1);
boolean IsSideBearingLink(fnt_ElementType *element, int32 point0, int32 point1) {
	int32 numPoints = (int32)element->ep[element->nc - 1] + 1;
	return numPoints + LEFTSIDEBEARING <= point0 && point0 <= numPoints + RIGHTSIDEBEARING || numPoints + LEFTSIDEBEARING <= point1 && point1 <= numPoints + RIGHTSIDEBEARING;
} // IsSideBearingLink


  FS_PRIVATE fnt_ElementType* itrp_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, int32*point, int32 lOpCode)
  {
	F26Dot6 proj;
	int32 pt;
	fnt_ElementType * element;

	if (BIT0 (lOpCode))
	{
	  pt = LocalGS.Pt1;
	  element = LocalGS.CE0;
	} 
	else 
	{
	  pt = LocalGS.Pt2;
	  element = LocalGS.CE1;
	}
	proj = (*LocalGS.Project) (GSA element->x[pt] - element->ox[pt], element->y[pt] - element->oy[pt]);

	*dx = *dy = 0; // silence prefix

	if (LocalGS.pfProj != ONEVECTOR)
	{
	  if (LocalGS.free.x)
		*dx = (F26Dot6) LongMulDiv (proj, (int32)LocalGS.free.x, (int32)LocalGS.pfProj);
	  if (LocalGS.free.y)
		*dy = (F26Dot6) LongMulDiv (proj, (int32)LocalGS.free.y, (int32)LocalGS.pfProj);
	}
	else
	{
	  if (LocalGS.free.x)
		*dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
	  if (LocalGS.free.y)
		*dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
	}
	*point = pt;
	return element;
  }

/*********************************************************************/

FS_PRIVATE uint8* itrp_SHP_Common (GSP uint8 *pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
								   int32 refPoint,
#endif
#ifdef FSCFG_SUBPIXEL							// extra parameter to distinguish between coming from SHPIX, in which case we assume
								   uint8 shpix, // the context is a delta fn and hence we most likely skip the delta, and SHP
#endif
								   F26Dot6 dx, F26Dot6 dy)
{
	fnt_ElementType *CE2;
	int32 count;
	int32 point;
	
	CE2 = LocalGS.CE2;
	count = LocalGS.loop + 1;         /* faster for ms c8 */

	while (count != 0)
	{
		point = (int32)CHECK_POP (LocalGS.stackPointer);
		SECURE_CHECK_POINT (LocalGS.CE2, point);
		CHECK_POINT (&LocalGS, LocalGS.CE2, point);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (CE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
			AddDistance(&LocalGS,CE2,refPoint,point,OTHER);
#endif

#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		// here we assume that if we're doing a SHPIX instruction, we're in the context of a function that implements delta instructions
		// for a range of ppem sizes. If such a delta occurs on an untouched point, regardless of whether it's in SP direction or not,
		// it creates a dent in the outline. While for b/w this is intended to flip one or more pixels, it distorts the stroke in SP.
		// If such a delta occurs on a touched point, it moves along the entire outline, such as to place strokes differently. If this
		// happens in SP direction, this distorts the natural spacing of the stroke(s). Therefore we keep only deltas on touched points
		// in non SP direction.
		//   Notice that strictly speaking, we should keep inline deltas (in non SP direction) only. However, since we do not have the
		// tree of instructions at this level, we don't know whether there are any dependant points that have been touched already,
		// prior to applying the delta (in which case it's a pre-IUP delta), or not (in which case it's an inline delta). In cases
		// where a pre-IUP delta was used to cleanup several pixels of the b/w bitmap, the SP result won't be optimal, but not nearly
		// as bad as it would be in grey-scaling. This is due to the oversampling, which in grey-scaling is done in both directions,
		// while only in one direction in SP. As a result, even the oversampled pixels (stripes) are typically "in".
		//   Notice also that we cannot use the fact whether IUP has happened already or not (even though this would be easy to track),
		// since some pre-IUP deltas are erroneously applied to untouched points, the result of which is unreliable in the sense that
		// the delta amount applies to the original (untouched) position of the point, which typically differs from its post-IUP
		// position. While this may lead to the desired result in b/w, in SP point positions likely will differ from those in b/w.
		// This has lead to irregularly spaced (and "angled") glyphs in fonts such as Palatino italic.
		//   Notice, finally, that for composites, the touched/untouched rule does not apply the same way. A point that is flagged as
		// untouched may have been previously touched while executing the code for the respective component. Yet a subsequent SHPIX or
		// possibly delta applied to that point will not create a(nother) dent in the outline, but move the entire outline, instead.
		// This is used in b/w e.g. to re-position diacritics to ensure a minimal distance of 1 pixel between the base character and
		// the diacritic. Hence we also keep deltas in composites.

		if (!shpix || (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_inSkippableDeltaFn) == 0 || AMovedPointInNonSPDirection(LocalGS,CE2,point)) {
#endif // InlineDeltasOnly
#endif // FSCFG_SUBPIXEL
		if (LocalGS.free.x) {
			CE2->x[point] += dx;
			CE2->f[point] |= XMOVED;
		}
		if (LocalGS.free.y) {
			CE2->y[point] += dy;
			CE2->f[point] |= YMOVED;
		}
#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		}
#endif
#endif
		count--;
	}
	LocalGS.loop = 0;
    return pbyInst;
}

/*********************************************************************/

/*
 * SHift Point
 */
  FS_PRIVATE uint8* itrp_SHP (IPARAM)
  {
	F26Dot6 dx, dy;
	int32 point;

#ifdef FSCFG_SECURE
	if (BIT0 (lOpCode))
	{
	  SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	} 
	else 
	{
	  SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	}
#endif 

	itrp_SH_Common (GSA &dx, &dy, &point, lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 1);

    return itrp_SHP_Common (GSA pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		point,
#endif
#ifdef FSCFG_SUBPIXEL
		false, // we don't come from SHPIX
#endif
		dx, dy);
  }

/*
 * SHift Contour
 */
  FS_PRIVATE uint8* itrp_SHC (IPARAM)
  {
	fnt_ElementType *element;
	F26Dot6 dx, dy;
	int32 contour, point;

	{
	  F26Dot6 x, y;
	  int32 pt;

#ifdef FSCFG_SECURE
	  if (BIT0 (lOpCode))
	  {
	    SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	  } 
	  else 
	  {
	    SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	  }
#endif 
	  
	  element = itrp_SH_Common (GSA &x, &y, &pt, lOpCode);
	  point = pt;
	  dx = x;
	  dy = y;
	}
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	contour = (int32)CHECK_POP (LocalGS.stackPointer);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (element != &LocalGS.elements[TWILIGHTZONE] && // beats
		LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		!VerticalSPDirection(LocalGS.globalGS) && !element->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,element);
	//	phaseControlExecuted == true by now
		dx += element->pcr[point].phaseShift;
	}
#endif
	


	SECURE_CHECK_FOR_UNITIALIZED_ZONE(LocalGS.CE2);
	SECURE_CHECK_CONTOUR (LocalGS.CE2, contour);
	CHECK_CONTOUR (&LocalGS, LocalGS.CE2, contour);

	{
	  VECTORTYPE fvx = LocalGS.free.x;
	  VECTORTYPE fvy = LocalGS.free.y;
	  fnt_ElementType*CE2 = LocalGS.CE2;
	  int32 currPt = CE2->sp[contour];
	  int32 count = CE2->ep[contour] - currPt;
	  SECURE_CHECK_POINT (CE2, currPt + count);
	  CHECK_POINT (&LocalGS, CE2, currPt + count);
	  for (; count >= 0; --count)
	  {
		if (currPt != point || element != CE2)
		{
		  if (fvx) 
		  {
			CE2->x[currPt] += dx;
			CE2->f[currPt] |= XMOVED;
		  }
		  if (fvy) 
		  {
			CE2->y[currPt] += dy;
			CE2->f[currPt] |= YMOVED;
		  }
		}
		currPt++;
	  }
	}
	
	return pbyInst;
  }

/*********************************************************************/

/*
 * SHift Element                     rewritten 7/29/93 deanb
 *
 * Flags are no longer set to show touch in x or y direction
 */

FS_PRIVATE uint8* itrp_SHE (IPARAM)
{
	fnt_ElementType *element;
	F26Dot6 fxDX, fxDY;
	int32 lFirstPt, lRefPt, lLastPt, arg1;
	
	F26Dot6 fxSaveX;                    /* for ref point restoration */
	F26Dot6 fxSaveY;
	
	F26Dot6 *pfxX, *pfxStopX;           /* temporary element pointers */
	F26Dot6 *pfxY, *pfxStopY;
	
#ifdef FSCFG_SECURE
	if (BIT0 (lOpCode))
	{
	  SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	} 
	else 
	{
	  SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	}
#endif 

	element = itrp_SH_Common (GSA &fxDX, &fxDY, &lRefPt, lOpCode);
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_ZONE(arg1);
	CHECK_ELEMENT (&LocalGS, arg1);
	SECURE_CHECK_FOR_UNITIALIZED_ZONE(&LocalGS.elements[arg1]);

	lLastPt = LocalGS.elements[arg1].ep[LocalGS.elements[arg1].nc - 1];
	SECURE_CHECK_POINT (&LocalGS.elements[arg1], lLastPt);
	CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lLastPt);
	lFirstPt  = LocalGS.elements[arg1].sp[0];
	SECURE_CHECK_POINT (&LocalGS.elements[arg1], lFirstPt);
	CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lFirstPt);

	if (element == &LocalGS.elements[arg1])     /* if ref pt is in same zone */     
	{
		fxSaveX = LocalGS.elements[arg1].x[lRefPt];
		fxSaveY = LocalGS.elements[arg1].y[lRefPt];
	}
	
	if (LocalGS.free.x != 0) 
	{
		pfxX = &LocalGS.elements[arg1].x[lFirstPt];
		pfxStopX = &LocalGS.elements[arg1].x[lLastPt];

		while (pfxX <= pfxStopX)
		{
			*pfxX += fxDX;                      /* shift each point in x */
			pfxX++;
		}
	}

	if (LocalGS.free.y != 0) 
	{
		pfxY = &LocalGS.elements[arg1].y[lFirstPt];
		pfxStopY = &LocalGS.elements[arg1].y[lLastPt];

		while (pfxY <= pfxStopY)
		{
			*pfxY += fxDY;                      /* shift each point in y */
			pfxY++;
		}
	}
	
	if (element == &LocalGS.elements[arg1])     /* if ref pt is in same zone */     
	{
		LocalGS.elements[arg1].x[lRefPt] = fxSaveX;
		LocalGS.elements[arg1].y[lRefPt] = fxSaveY;
	}

	return pbyInst;
}

/*********************************************************************/

/*
 * SHift point by PIXel amount
 */
  FS_PRIVATE uint8* itrp_SHPIX (IPARAM)
  {
	F26Dot6 proj, dx, dy;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 2);
	proj = CHECK_POP (LocalGS.stackPointer);
	if (LocalGS.free.x)
	  dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
	else
		dx = 0; // silence BC
	if (LocalGS.free.y)
	  dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
	else
		dy = 0; // silence BC

	return itrp_SHP_Common (GSA pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		-1,
#endif
#ifdef FSCFG_SUBPIXEL
		true, // we do come from SHPIX
#endif
		dx, dy);
  }

/*********************************************************************/

/*
 * Interpolate Point
 */

uint8* itrp_IP (IPARAM)
{
	int32 arg1;
	int32 RP1;
	int32 RP2;
	
	int32 cLoop;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_ElementType *pCE2;
	fnt_ElementType *pTwilight;
	
	F26Dot6 x_RP1;
	F26Dot6 ox_RP1;
	F26Dot6 *pCE1_ox;
	F26Dot6 *pCE2_ox;

	F26Dot6 y_RP1;
	F26Dot6 oy_RP1;
	F26Dot6 *pCE1_oy;
	F26Dot6 *pCE2_oy;

	F26Dot6 oldRange;
	F26Dot6 proj;
	F26Dot6 fxDelta;
	
	F26Dot6 *pfxStack;

	FntMoveFunc MovePoint;
	FntProject Project;
	

	FS_UNUSED_PARAMETER(lOpCode);

	cLoop = LocalGS.loop + 1;               /* faster for ms c8 */
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	pCE2 = LocalGS.CE2;
	pTwilight = &LocalGS.elements[TWILIGHTZONE];
	RP1 = LocalGS.Pt1;
	RP2 = LocalGS.Pt2;

	SECURE_CHECK_POINT (pCE0, RP1);
	SECURE_CHECK_POINT (pCE1, RP2);

	pfxStack = LocalGS.stackPointer;

	MovePoint = LocalGS.MovePoint;
	Project = LocalGS.Project;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, cLoop);
    
	if (pCE0 == pTwilight || pCE1 == pTwilight || pCE2 == pTwilight 
		|| LocalGS.globalGS->bOriginalPointIsInvalid)
	{
		ox_RP1 = pCE0->ox[RP1];
		oy_RP1 = pCE0->oy[RP1];
		pCE1_ox = pCE1->ox;
		pCE1_oy = pCE1->oy;
		pCE2_ox = pCE2->ox;
		pCE2_oy = pCE2->oy;
	}
	else
	{
		ox_RP1 = pCE0->oox[RP1];
		oy_RP1 = pCE0->ooy[RP1];
		pCE1_ox = pCE1->oox;
		pCE1_oy = pCE1->ooy;
		pCE2_ox = pCE2->oox;
		pCE2_oy = pCE2->ooy;
	}
	x_RP1 = pCE0->x[RP1];
	y_RP1 = pCE0->y[RP1];
		
	oldRange = LocalGS.OldProject (GSA pCE1_ox[RP2] - ox_RP1, pCE1_oy[RP2] - oy_RP1);
	
	if (oldRange != 0)                      /* this should always happen */
	{
		if (MovePoint == itrp_XMovePoint)   /* so project is also xproject */
		{
			proj = pCE1->x[RP2] - x_RP1;
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = pCE2_ox[arg1] - ox_RP1;
				fxDelta = (F26Dot6)MulDiv26Dot6 (proj, fxDelta, oldRange);
				
				pCE2->x[arg1] = fxDelta + x_RP1;
				pCE2->f[arg1] |= XMOVED;
				cLoop--;
			}
		}
		else if (MovePoint == itrp_YMovePoint)  /* so project is also yproject */
		{
			proj = pCE1->y[RP2] - y_RP1;
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);
				
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = pCE2_oy[arg1] - oy_RP1; 
				fxDelta = (F26Dot6) MulDiv26Dot6(proj, fxDelta, oldRange);
				
				pCE2->y[arg1] = fxDelta + y_RP1;
				pCE2->f[arg1] |= YMOVED;
				cLoop--;
			}
		}
		else    /* if (MovePoint == itrp_MovePoint) */
		{
			proj = Project (GSA pCE1->x[RP2] - x_RP1, pCE1->y[RP2] - y_RP1);
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);
				
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1);
				fxDelta = (F26Dot6) MulDiv26Dot6(proj, fxDelta, oldRange);
				MovePoint (GSA pCE2, arg1, fxDelta - 
					Project (GSA pCE2->x[arg1] - x_RP1, pCE2->y[arg1] - y_RP1) );
				cLoop--;
			}
		}
	}
	else    /* if (oldRange == 0) */  
			/* this should never happen, but for safety's sake... */
	{
		while (cLoop != 0)
		{
			arg1 = (int32)CHECK_POP (pfxStack);
			SECURE_CHECK_POINT (pCE2, arg1);
			CHECK_POINT (&LocalGS, pCE2, arg1);
						
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
			if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
				AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
			fxDelta = Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1);
			MovePoint (GSA pCE2, arg1, fxDelta - 
				Project (GSA pCE2->x[arg1] - x_RP1, pCE2->y[arg1] - y_RP1) );
			cLoop--;
		}
	}       /* endif (oldRange != 0) */
	
	LocalGS.stackPointer = pfxStack;
	LocalGS.loop = 0;
	return pbyInst;
}

/*********************************************************************/

/*
 * Move Stack Indirect Relative Point
 */

uint8* itrp_MSIRP (IPARAM) {
	int32 iPt0;
	int32 iPt2;                            // point #
	F26Dot6 fxDist;                        // distance
#ifdef FSCFG_SUBPIXEL
#ifdef MSIRPRespectsCvtCutIn
	F26Dot6 fxOutlineDist;
	fnt_ParameterBlock *pb;
#endif
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	long color;
#endif
	F26Dot6 fxPosition;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;

	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	iPt0 = LocalGS.Pt0;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    fxDist = CHECK_POP (LocalGS.stackPointer);
	iPt2 = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPt0);
	SECURE_CHECK_POINT (pCE1, iPt2);
	CHECK_POINT (&LocalGS, pCE1, iPt2);
		
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS)) {
		color = DoubleCheckLinkColor(pCE1,iPt0,iPt2,BLACK); // don't really know any better
		AddDistance(&LocalGS,pCE1,iPt0,iPt2,color);
	}
#endif

	if (pCE1 == &LocalGS.elements[TWILIGHTZONE]) {
		pCE1->ox[iPt2] = pCE0->ox[iPt0] + (F26Dot6) VECTORMUL (fxDist, LocalGS.proj.x);
		pCE1->oy[iPt2] = pCE0->oy[iPt0] + (F26Dot6) VECTORMUL (fxDist, LocalGS.proj.y);
		pCE1->x[iPt2] = pCE1->ox[iPt2];
		pCE1->y[iPt2] = pCE1->oy[iPt2];
	}
	
#ifdef FSCFG_SUBPIXEL
#ifdef MSIRPRespectsCvtCutIn
	if (!Tuned4SubPixel(LocalGS.globalGS) && LocalGS.inSubPixelDirection) {
	// similarly to MIRP, here we honour a cvt cut-in in case there is a non-trivial outline distance between the
	// parent (reference) and the child (target) point involved, in which case we assume the context is a stroke weight,
	// else we assume the context is an accent placement function, in which case we use the actual distance as before
		fxOutlineDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPt2] - pCE0->ox[iPt0], pCE1->oy[iPt2] - pCE0->oy[iPt0]);
		if (fxOutlineDist) { // else assume we're positioning accents with a calculated MSIRP, hence no cvt cut-in
			pb = &LocalGS.globalGS->localParBlock;
			// notice that unlike MIRP, we don't do the autoFlip since MSIRP is used with calculated distances that
			// would have the correct sign to begin with.
			CVTCI(pb,fxDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
		}
	}
#endif
#endif

	fxPosition = (*LocalGS.Project) (GSA pCE1->x[iPt2] - pCE0->x[iPt0], pCE1->y[iPt2] - pCE0->y[iPt0]);
	(*LocalGS.MovePoint) (GSA pCE1, iPt2, fxDist - fxPosition);
	
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPt2;
	if (BIT0 (lOpCode)) {
		LocalGS.Pt0 = iPt2; // move the reference point
	}
	return pbyInst;
} // itrp_MSIRP

/*********************************************************************/

/*
 * Align Relative Point
 */

FS_PRIVATE uint8* itrp_ALIGNRP (IPARAM)
  {
	fnt_ElementType*ce1 = LocalGS.CE1;
	F26Dot6 pt0x = LocalGS.CE0->x[LocalGS.Pt0];
	F26Dot6 pt0y = LocalGS.CE0->y[LocalGS.Pt0];

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 1);

	for (; LocalGS.loop >= 0; --LocalGS.loop)
	{
	  int32 ptNum = (int32)CHECK_POP (LocalGS.stackPointer);
	  F26Dot6 proj;

	  SECURE_CHECK_POINT (ce1, ptNum);
	  CHECK_POINT (&LocalGS, ce1, ptNum);
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (ce1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
			// if we are aligning to some diagonal (pt0 and pt1 are set after SPVTL etc.), and if the child is between the parents
			// (InterAlign, cf. also comments there), we handle it as a proportion, else as a distance with non specific color.
			if (LocalGS.pt0 != -1 && LocalGS.pt1 != -1 && InterAlign(LocalGS.CE1,LocalGS.pt0,ptNum,LocalGS.pt1))
				AddProportion(&LocalGS,ce1,LocalGS.pt0,ptNum,LocalGS.pt1);
			else
				AddDistance(&LocalGS,ce1,LocalGS.Pt0,ptNum,OTHER);
#endif
	  proj = -(* LocalGS.Project) (GSA ce1->x[ptNum] - pt0x, ce1->y[ptNum] - pt0y);
	  (*LocalGS.MovePoint) (GSA ce1, ptNum, proj);
	}
	LocalGS.loop = 0;
	return pbyInst;
  }


/*
 * Align Two Points (by moving both of them)
 */
  FS_PRIVATE uint8* itrp_ALIGNPTS (IPARAM)
  {
	int32 pt1, pt2;
	F26Dot6 move1, dist;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pt2  = (int32)CHECK_POP (LocalGS.stackPointer); /* point # 2   */
	pt1  = (int32)CHECK_POP (LocalGS.stackPointer); /* point # 1   */
	SECURE_CHECK_POINT (LocalGS.CE1, pt2);
	SECURE_CHECK_POINT (LocalGS.CE0, pt1);
	CHECK_POINT (&LocalGS, LocalGS.CE1, pt2);
	CHECK_POINT (&LocalGS, LocalGS.CE0, pt1);
/* We do not have to check if we are in character element zero (the twilight zone)
		   since both points already have to have defined values before we execute this instruction */
	dist = LocalGS.CE1->x[pt2] - LocalGS.CE0->x[pt1];
	move1 = LocalGS.CE1->y[pt2] - LocalGS.CE0->y[pt1];
	if (LocalGS.Project != itrp_XProject)
	{
	  if (LocalGS.Project == itrp_YProject)
		dist = move1;
	  else
		dist = (*LocalGS.Project) (GSA dist, move1);
	}

	move1 = dist >> 1;
	(*LocalGS.MovePoint) (GSA LocalGS.CE0, pt1, move1);
	(*LocalGS.MovePoint) (GSA LocalGS.CE1, pt2, move1 - dist);
	return pbyInst;
  }

/*
 * Set Angle Weight
 */
  FS_PRIVATE uint8* itrp_SANGW (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.angleWeight = (int16)arg;
	return pbyInst;
  }

/*
 * Flip Point
 */
  FS_PRIVATE uint8* itrp_FLIPPT (IPARAM)
  {
	uint8 *onCurve = LocalGS.CE0->onCurve;
	F26Dot6*stack = LocalGS.stackPointer;
	int32 count = LocalGS.loop;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, count + 1);

    for (; count >= 0; --count)
	{
	  int32 point = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE0, point);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, point);
	  onCurve[ point ] ^= ONCURVE;
	}
	LocalGS.loop = 0;

	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Flip On a Range
 */
  FS_PRIVATE uint8* itrp_FLIPRGON (IPARAM)
  {
	int32 lo, hi;
	int32 count;
	uint8 *onCurve = LocalGS.CE0->onCurve;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	hi = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, hi);
	CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
	lo = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, lo);
	CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

	onCurve += lo;
	for (count = (int32) (hi - lo); count >= 0; --count)
	  *onCurve++ |= ONCURVE;
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Flip Off a Range
 */
  FS_PRIVATE uint8* itrp_FLIPRGOFF (IPARAM)
  {
	int32 lo, hi;
	int32 count;
	uint8 *onCurve = LocalGS.CE0->onCurve;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	hi = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, hi);
	CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
	lo = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, lo);
	CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

	onCurve += lo;
	for (count = (int32) (hi - lo); count >= 0; --count)
	  *onCurve++ &= ~ONCURVE;
	return pbyInst;
  }

/* 4/22/90 rwb - made more general
 * Sets lower 16 flag bits of ScanControl variable.  Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 *
 * stack: value => -;
 *
 */
  FS_PRIVATE uint8* itrp_SCANCTRL (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	fnt_ParameterBlock *pb = &globalGS->localParBlock;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	pb->scanControl = (pb->scanControl & 0xFFFF0000) | arg;
	return pbyInst;
  }

/* 5/24/90 rwb
 * Sets upper 16 bits of ScanControl variable. Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 */

  FS_PRIVATE uint8* itrp_SCANTYPE (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS;
	fnt_ParameterBlock *pb;
	int32 *scanPtr;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;
	pb = &globalGS->localParBlock;
	scanPtr = (int32*)&(pb->scanControl);
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);

/*  how it was:
	CHECK_SCANMODE (arg);
	if (arg == 0)  
	  *scanPtr &= 0xFFFF;
	else if (arg == 1)        
	  *scanPtr = (*scanPtr & 0xFFFF) | STUBCONTROL;
	else if (arg == 2)        
	  *scanPtr = (*scanPtr & 0xFFFF) | NODOCONTROL;
*/

/*  now any 8 bit value may be passed to the scan converter */
	
	*scanPtr = (*scanPtr & 0xFFFF) | (arg << 16);
	return pbyInst;
  }

/* 6/28/90 rwb
 * Sets instructControl flags in global graphic state.  Only legal in pre program.
 * A selector is used to choose the flag to be set.
 * Bit0 - NOGRIDFITFLAG - if set, then truetype instructions are not executed.
 *              A font may want to use the preprogram to check if the glyph is rotated or
 *              transformed in such a way that it is better to not gridfit the glyphs.
 * Bit1 - DEFAULTFLAG - if set, then changes in localParameterBlock variables in the
 *              globalGraphics state made in the CVT preprogram are not copied back into
 *              the defaultParameterBlock.  So, the original default values are the starting
 *              values for each glyph.
 * Bit2 - TUNED4SPFLAG - if set, a font will be rendered in native SP mode (as opposed to
 *              backwards compatible mode)
 *
 * stack: value, selector => -;
 *
 */
  FS_PRIVATE uint8* itrp_INSTCTRL (IPARAM)  /* <13> */
  {
	fnt_GlobalGraphicStateType *globalGS;
	int32 *ic;
	int32 selector;
	int32 value;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	globalGS = LocalGS.globalGS;
	ic = (int32*)&globalGS->localParBlock.instructControl;
	arg = CHECK_POP (LocalGS.stackPointer);
	value = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	selector = (int32)arg;
	CHECK_SELECTOR (selector);
	if (globalGS->init)
	{
	  if (selector == 1) 
		*ic &= ~NOGRIDFITFLAG;
	  else if (selector == 2) 
		*ic &= ~DEFAULTFLAG;
	  else if (selector == 3)
		*ic &= ~TUNED4SPFLAG;

	  *ic |= value;
	}
	return pbyInst;
  }

/*
 * AdjustAngle         <4>
 */
  FS_PRIVATE uint8* itrp_AA (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

	/* This is a NOP now. However, do pop the argument off the stack -amitc- 9/11/91. */
	/* Discard the popped value. -lenox- 11/11/91 */
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	(void) CHECK_POP (LocalGS.stackPointer);
						 /* old code now lives in history.fnt - deanb */
	return pbyInst;
  }

/*********************************************************************/

/* Called by itrp_PUSHB and itrp_NPUSHB */

/* these functions were split out from itrp_PushSomeStuff - deanb */
  
FS_PRIVATE uint8* itrp_PushSomeBytes (GSP int32 count, uint8* pbyInst)
{
	F26Dot6 *stack;
		
	stack = LocalGS.stackPointer;
    SECURE_CHECK_FOR_PUSH (stack, count);
	while (count != 0)
	{
		CHECK_PUSH (stack, *pbyInst++);
		count--;
	}
	LocalGS.stackPointer = stack;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_PushSomeWords (GSP int32 count, uint8* pbyInst)
{
	F26Dot6 *stack;
	int16 word;
		
	stack = LocalGS.stackPointer;
    SECURE_CHECK_FOR_PUSH (stack, count);
	while (count != 0)
	{
		word = *pbyInst++;
		CHECK_PUSH (stack, (int16) ((word << 8) + *pbyInst++));
		count--;
	}
	LocalGS.stackPointer = stack;
	return pbyInst;
}

/*********************************************************************/

/*
 * PUSH 1 Byte           the most commonly called pushb
 */
FS_PRIVATE uint8* itrp_PUSHB1 (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, *pbyInst++);
	return pbyInst;
}

/*
 * PUSH Bytes
 */
FS_PRIVATE uint8* itrp_PUSHB (IPARAM)
{
	int32 iCount;

	iCount = lOpCode - 0xb0 + 1;
	return itrp_PushSomeBytes (GSA iCount, pbyInst);
}

/*
 * N PUSH Bytes
 */
FS_PRIVATE uint8* itrp_NPUSHB (IPARAM)
{
	int32 iCount;

	FS_UNUSED_PARAMETER(lOpCode);

	iCount = (int32)*pbyInst++;
	return itrp_PushSomeBytes (GSA iCount, pbyInst);
}

/*
 * PUSH 1 Word           the most commonly called pushw
 */
FS_PRIVATE uint8* itrp_PUSHW1 (IPARAM)
{
	int16 word;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	word = *pbyInst++;
	CHECK_PUSH (LocalGS.stackPointer, (int16)((word << 8) + *pbyInst++));
	return pbyInst;
}

/*
 * PUSH Words           <3>
 */
FS_PRIVATE uint8* itrp_PUSHW (IPARAM)
{
	int32 iCount;

	iCount = lOpCode - 0xb8 + 1;
	return itrp_PushSomeWords (GSA iCount, pbyInst);
}

/*
 * N PUSH Words
 */
FS_PRIVATE uint8* itrp_NPUSHW (IPARAM)
{
	int32 iCount;

	FS_UNUSED_PARAMETER(lOpCode);

	iCount = (int32)*pbyInst++;
	return itrp_PushSomeWords (GSA iCount, pbyInst);
}

/*********************************************************************/

/*
 * Write Store
 */
  FS_PRIVATE uint8* itrp_WS (IPARAM)
  {
	F26Dot6 storage;
	int32 storeIndex;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	storage = CHECK_POP (LocalGS.stackPointer);
	storeIndex = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_STORAGE (storeIndex);
	CHECK_STORAGE (&LocalGS,storeIndex);

	LocalGS.globalGS->store[ storeIndex ] = storage;
	return pbyInst;
  }

/*
 * Read Store
 */
  FS_PRIVATE uint8* itrp_RS (IPARAM) {
	int32 storeIndex;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	storeIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_STORAGE (storeIndex);
	CHECK_STORAGE (&LocalGS, storeIndex);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
	if (storeIndex == 8 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedVacuformRound) > 0) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inVacuformRound;
		CHECK_PUSH (LocalGS.stackPointer, 0); // push 0 indicating we don't do vacuforming
	} else {
#endif
#endif
		CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->store[storeIndex]);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
	}
#endif
#endif
	return pbyInst;
  }

/*
 * Write Control Value Table from outLine, assumes the value comes form the outline domain
 */
  FS_PRIVATE uint8* itrp_WCVT (IPARAM)
  {
	int32 cvtIndex;
	F26Dot6 cvtValue;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	cvtValue = CHECK_POP (LocalGS.stackPointer);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_CVT (cvtIndex);
	CHECK_CVT (&LocalGS, cvtIndex);

	if (cvtValue != 0 && LocalGS.GetCVTEntry != itrp_GetCVTEntryFast)
	  cvtValue = FixDiv (cvtValue, itrp_GetCVTScale (GSA0));
	LocalGS.globalGS->controlValueTable[ cvtIndex ] = cvtValue;
	return pbyInst;
  }

/*
 * Write Control Value Table From Original Domain, assumes the value comes from the original domain, not the cvt or outline
 */
  FS_PRIVATE uint8* itrp_WCVTFOD (IPARAM)
  {
	int32 cvtIndex;
	F26Dot6 cvtValue;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	cvtValue = CHECK_POP (LocalGS.stackPointer);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (cvtIndex);
	CHECK_CVT (&LocalGS, cvtIndex);
	globalGS->controlValueTable[ cvtIndex ] = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, cvtValue);
	return pbyInst;
  }



/*
 * Read Control Value Table
 */
  FS_PRIVATE uint8* itrp_RCVT (IPARAM)
  {
	int32 cvtIndex;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);

#ifndef FSCFG_FONTOGRAPHER_BUG
	SECURE_CHECK_CVT (cvtIndex);
#else
	SECURE_CHECK_CVT_READ_SPECIAL (cvtIndex);
#endif // FSCFG_FONTOGRAPHER_BUG

	CHECK_CVT (&LocalGS, cvtIndex);

	LocalGS.GetCVTEntry (GSA cvtIndex);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.GetCVTEntry (GSA cvtIndex));
	return pbyInst;
  }

/*
 * Read Coordinate
 */
  FS_PRIVATE uint8* itrp_RC (IPARAM)
  {
	int32 pt;
	fnt_ElementType * element;
	F26Dot6 proj;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pt = (int32)CHECK_POP (LocalGS.stackPointer);
	element = LocalGS.CE2;
	SECURE_CHECK_POINT (element, pt);
	CHECK_POINT (&LocalGS, element, pt);

	if (BIT0 (lOpCode))
	  proj = (*LocalGS.OldProject) (GSA element->ox[pt], element->oy[pt]);
	else
	  proj = (*LocalGS.Project) (GSA element->x[pt], element->y[pt]);

	CHECK_PUSH (LocalGS.stackPointer, proj);
	return pbyInst;
  }

/*
 * Write Coordinate
 */
  FS_PRIVATE uint8* itrp_WC (IPARAM)
  {
	F26Dot6 proj, coord;
	int32 pt;
	fnt_ElementType *element;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	coord = CHECK_POP (LocalGS.stackPointer);/* value */
	pt = (int32)CHECK_POP (LocalGS.stackPointer);/* point */
	element = LocalGS.CE2;
	SECURE_CHECK_POINT (element, pt);
	CHECK_POINT (&LocalGS, element, pt);

	proj = (*LocalGS.Project) (GSA element->x[pt],  element->y[pt]);
	proj = coord - proj;

	(*LocalGS.MovePoint) (GSA element, pt, proj);

	if (element == &LocalGS.elements[TWILIGHTZONE])
	{
	  element->ox[pt] = element->x[pt];
	  element->oy[pt] = element->y[pt];
	}
	return pbyInst;
  }


/*
 * Measure Distance
 */
  FS_PRIVATE uint8* itrp_MD (IPARAM)
  {
	int32 pt1, pt2;
	F26Dot6 proj, *stack = LocalGS.stackPointer;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pt2 = (int32)CHECK_POP (stack);
	pt1 = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, pt1);
	SECURE_CHECK_POINT (LocalGS.CE1, pt2);
	CHECK_POINT (&LocalGS, LocalGS.CE0, pt1);
	CHECK_POINT (&LocalGS, LocalGS.CE1, pt2);
	if (BIT0 (lOpCode - MD_CODE)) { // MD[O] in original outline
		if (LocalGS.CE0 == &LocalGS.elements[TWILIGHTZONE] || LocalGS.CE1 == &LocalGS.elements[TWILIGHTZONE] 
			|| LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			proj = (*LocalGS.OldProject) (GSA LocalGS.CE1->ox[pt1] - LocalGS.CE0->ox[pt2], LocalGS.CE1->oy[pt1] - LocalGS.CE0->oy[pt2]);
		}
		else if (globalGS->bSameStretch)
		{
			proj = (*LocalGS.OldProject) (GSA LocalGS.CE1->oox[pt1] - LocalGS.CE0->oox[pt2], LocalGS.CE1->ooy[pt1] - LocalGS.CE0->ooy[pt2] );
			proj = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, proj );
		}
		else
		{
			proj = (*LocalGS.OldProject) (GSA 
				globalGS->ScaleFuncX (&globalGS->scaleX, LocalGS.CE1->oox[pt1] - LocalGS.CE0->oox[pt2]), 
				globalGS->ScaleFuncY (&globalGS->scaleY, LocalGS.CE1->ooy[pt1] - LocalGS.CE0->ooy[pt2]) );
		}
	}

	/* old MS code, give different value than Apple :
	 * proj  = (*LocalGS.OldProject) (GSA LocalGS.CE0->ox[pt1] - LocalGS.CE1->ox[pt2], LocalGS.CE0->oy[pt1] - LocalGS.CE1->oy[pt2]);
	*/
	
	else { // MD[N] in grid-fitted outline
		proj  = (*LocalGS.Project) (GSA LocalGS.CE0->x[pt1] - LocalGS.CE1->x[pt2], LocalGS.CE0->y[pt1] - LocalGS.CE1->y[pt2]);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
		if ((LocalGS.globalGS->subPixelCompatibilityFlags & (SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound)) == (SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound) && proj == FNT_PIXELSIZE)
			proj++; // increase by smallest possible amount to throw off type 2 vacuforms which are keyed off a distance being exacly 1 pixel
#endif
#endif
	}
	CHECK_PUSH (stack, proj);
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Measure Pixels Per EM
 */
  FS_PRIVATE uint8* itrp_MPPEM (IPARAM)
  {
	uint16 ppem;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

	FS_UNUSED_PARAMETER(lOpCode);

	ppem = globalGS->pixelsPerEm;
	if (!globalGS->bSameStretch)
		ppem = (uint16)FixMul (ppem, itrp_GetCVTScale (GSA0));

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, ppem);
	return pbyInst;
  }

/*
 * Measure Point Size
 */
  FS_PRIVATE uint8* itrp_MPS (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->pointSize);
	return pbyInst;
  }

/*
 * Get Miscellaneous info: version number, rotated, stretched   <6>
 * Version number is 8 bits.  This is version 0x01 : 5/1/90
 *
 */

  FS_PRIVATE uint8* itrp_GETINFO (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	int32      info = 0;
	int32      selector;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	selector = (int32)arg;
	CHECK_SELECTOR (selector);
	if (selector & VERSIONINTERPRETERQUERY)                            /* version */
	  info |= RASTERIZER_VERSION;
	if ((selector & ROTATEDINTERPRETERQUERY) && (globalGS->non90DegreeTransformation & NON90DEGTRANS_ROTATED))
	  info |= ROTATEDGLYPH;
	if ((selector & STRETCHEDINTERPRETERQUERY) && (globalGS->non90DegreeTransformation & NON90DEGTRANS_STRETCH))
	  info |= STRETCHEDGLYPH;
	if ((selector & HINTFORGRAYINTERPRETERQUERY) && (globalGS->bHintForGray))
	  info |= HINTEDFORGRAYGLYPH;
#ifdef FSCFG_SUBPIXEL
	if ((selector & HINTFORSUBPIXELINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_SUB_PIXEL))
	  info |= HINTEDFORSUBPIXELGLYPH;
	if ((selector & HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_COMPATIBLE_WIDTH))
	  info |= HINTEDFORSUBPIXELCOMPATIBLEWIDTHGLYPH;
	if ((selector & HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_VERTICAL_DIRECTION))
	  info |= HINTEDFORSUBPIXELVERTICALDIRECTIONGLYPH;
	if ((selector & HINTFORSUBPIXELBGRORDERINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_BGR_ORDER))
	  info |= HINTEDFORSUBPIXELBGRORDERGLYPH;
#endif // FSCFG_SUBPIXEL
	CHECK_PUSH (LocalGS.stackPointer, info);
	return pbyInst;
  } // itrp_GETINFO

/*
 * FLIP ON
 */
  FS_PRIVATE uint8* itrp_FLIPON (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.globalGS->localParBlock.autoFlip = true;
	return pbyInst;
  }

/*
 * FLIP OFF
 */
  FS_PRIVATE uint8* itrp_FLIPOFF (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.globalGS->localParBlock.autoFlip = false;
	return pbyInst;
  }

#ifndef NOT_ON_THE_MAC
#ifdef FSCFG_DEBUG
/*
 * DEBUG
 */
  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	int32 arg;
	int8 buffer[24];

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);

	buffer[1] = 'D';
	buffer[2] = 'E';
	buffer[3] = 'B';
	buffer[4] = 'U';
	buffer[5] = 'G';
	buffer[6] = ' ';
	if (arg >= 0) 
	{
	  buffer[7] = '+';
	} 
	else 
	{
	  arg = -arg;
	  buffer[7] = '-';
	}

	buffer[13] = arg % 10 + '0'; 
	arg /= 10;
	buffer[12] = arg % 10 + '0'; 
	arg /= 10;
	buffer[11] = arg % 10 + '0'; 
	arg /= 10;
	buffer[10] = arg % 10 + '0'; 
	arg /= 10;
	buffer[ 9] = arg % 10 + '0'; 
	arg /= 10;
	buffer[ 8] = arg % 10 + '0'; 
	arg /= 10;

	buffer[14] = arg ? '*' : ' ';


	buffer[0] = 14; /* convert to pascal */
	DEBUGSTR (buffer);
	return pbyInst;
  }

#else           /* debug */

  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

#endif          /* debug */
#else

  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

#endif          /* ! not on the mac */


/* these functions were split out from itrp_BinaryOperand - deanb */

  FS_PRIVATE uint8* itrp_LT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] < pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_LTEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] <= pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_GT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] > pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_GTEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] >= pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_EQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] == pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_NEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] != pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_AND (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] && pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_OR (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] || pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_ADD (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] += pfxStack[0];
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SUB (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] -= pfxStack[0];
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_MUL (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] =  Mul26Dot6(pfxStack[-1], pfxStack[0]);
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_DIV (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[0] == 0)
	{
		LocalGS.ercReturn = DIV_BY_0_IN_HINTING_ERR;  /* returned to client, error DIV by zero */
		return LocalGS.pbyEndInst;
	} 
	pfxStack[-1] = (int32)(((long)pfxStack[-1] << 6) / pfxStack[0]);
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_MAX (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[-1] < pfxStack[0])
	{
		pfxStack[-1] = pfxStack[0];
	}
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }
  
  FS_PRIVATE uint8* itrp_MIN (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[-1] > pfxStack[0])
	{
		pfxStack[-1] = pfxStack[0];
	}
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

/**************************************************************************/

/* these functions were split out from itrp_UnaryOperand - deanb */

// for the ODD/EVEN pair, b/w, and no engine compensation case, we could
// essentially look at the two bits before and after the binary point of
// the F26Dot6 number:
//		1.100000 rounds to 2 (even)
//		1.000000 rounds to 1 (odd)
//		0.100000 rounds to 1 (odd)
//		0.000000 rounds to 0 (even)
// If the two bits are equal, then the number is even, else odd
// for engine compensation, we currently call the full itrp_RoundToGrid
// we'll allow tagged SP fonts to inquire about even/odd virtual pixels

  FS_PRIVATE uint8* itrp_ODD (IPARAM) {
	F26Dot6 *pfxStack;
	F26Dot6 fxArg;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxArg = itrp_RoundToGrid (GSA *pfxStack, 0);
	fxArg >>= FNT_PIXELSHIFT;
	*pfxStack = fxArg & 1L;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_EVEN (IPARAM) {
	F26Dot6 *pfxStack;
	F26Dot6 fxArg;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxArg = itrp_RoundToGrid (GSA *pfxStack, 0);
	fxArg >>= FNT_PIXELSHIFT;
	fxArg++;
	*pfxStack = fxArg & 1L;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_NOT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack = !*pfxStack;
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_ABS (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	if (*pfxStack < 0L)
	{
		*pfxStack = -*pfxStack;
	}
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_NEG (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack = -*pfxStack;
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_CEILING (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack += FNT_PIXELSIZE - 1;		// actually, this is not the pixel size, but the number 1 in 26.6
	*pfxStack &= ~(FNT_PIXELSIZE - 1);	// same here
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_FLOOR (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack &= ~(FNT_PIXELSIZE - 1);	// actually, this is not the pixel size, but the number 1 in 26.6
	return pbyInst;
  }
	  

/**************************************************************************/

/* This is called by itrp_IF, itrp_ELSE, itrp_FDEF, and itrp_IDEF         */
/* It is used to find the next TrueType instruction in the instruction    */
/* stream by skipping over push data.  It is table driven for speed.      */

static const uint8 gbyPushTable[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   21,22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 2, 3, 4, 5, 6, 7, 8, 2, 4, 6, 8,10,12,14,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

FS_PRIVATE uint8* itrp_SkipPushData (GSP uint8* pbyInst)
{
	int32 iDataCount;         /* count of data following push instruction */
	
	iDataCount = (int32)gbyPushTable[ pbyInst[-1] ];   /* opcode */
	
	if (iDataCount != 0)                        /* if a push instruction */
	{
		if (iDataCount == 21)                   /* special for npushb */
		{
			iDataCount = (int32)*pbyInst + 1;
		}
		else if (iDataCount == 22)              /* special for npushw */
		{
			iDataCount = ((int32)*pbyInst << 1) + 1;
		}
		pbyInst += iDataCount;

	}
	return pbyInst;
}

/**************************************************************************/

/*
 * IF
 */
FS_PRIVATE uint8* itrp_IF (IPARAM)
{
	int32 iLevel;
	int32 iScanOpCode;
	int32 iDataCount;         /* count of data following push instruction */

	FS_UNUSED_PARAMETER(lOpCode);	
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	if (!CHECK_POP (LocalGS.stackPointer))
	{
		iLevel = 1;
		while ((iLevel != 0) && (pbyInst < LocalGS.pbyEndInst))     /* iLevel = # of IF's minus # of EIF's */
		{
			iScanOpCode = (int32)*pbyInst++;

			if (iScanOpCode == EIF_CODE)
			{
				ERR_IF (-1);
				iLevel--;
			} 
			else if (iScanOpCode == IF_CODE) 
			{
				ERR_IF (1);
				iLevel++;
			} 
			else if (iScanOpCode == ELSE_CODE) 
			{
				if (iLevel == 1) 
					break;
			} 
			else
			{
				iDataCount = (int32)gbyPushTable[iScanOpCode];
				
				if (iDataCount != 0)            /* if a push instruction */
				{
					if (iDataCount == 21)       /* special for npushb */
					{
						iDataCount = (int32)*pbyInst + 1;
					}
					else if (iDataCount == 22)  /* special for npushw */
					{
						iDataCount = ((int32)*pbyInst << 1) + 1;
					}
					pbyInst += iDataCount;
				}
			}
		}

		if ((pbyInst == LocalGS.pbyEndInst) && (iLevel != 0))
		{
			LocalGS.ercReturn = MISSING_EIF_ERR;  /* returned to client, missing EIF */

		}
	}
	return pbyInst;
}

/**************************************************************************/

/*
 *      ELSE for the IF
 */
FS_PRIVATE uint8* itrp_ELSE (IPARAM)
{
	int16 level;
	uint8 opCode;

	FS_UNUSED_PARAMETER(lOpCode);

	level = 1;
	while ((level != 0) && (pbyInst < LocalGS.pbyEndInst))     /* iLevel = # of IF's minus # of EIF's */
	{
		opCode = *pbyInst++;
		
		if (opCode == EIF_CODE)
		{
			ERR_IF (-1);
			level--;
		} 
		else if (opCode == IF_CODE) 
		{
			ERR_IF (1);
			level++;
		} 
		else
		{
			pbyInst = itrp_SkipPushData (GSA pbyInst);
		}
	}

	if (level != 0)
	{
		LocalGS.ercReturn = MISSING_EIF_ERR;  /* returned to client, missing EIF */

	}
	return pbyInst;
}

/**************************************************************************/

/*
 * End IF
 */
FS_PRIVATE uint8* itrp_EIF (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);

	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative
 */
FS_PRIVATE uint8* itrp_JMPR (IPARAM)
{
	int32 offset;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);
	offset--;       /* since the interpreter post-increments the IP */
	pbyInst += offset;
	LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */

	if (LocalGS.ulJumpCounter == 0)
	{
		LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}
    if (pbyInst < LocalGS.pbyStartInst)
	{
		LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
    }
	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative On True
 */
FS_PRIVATE uint8* itrp_JROT (IPARAM)
{
	int32 offset;
	boolean bFlag;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	bFlag = (boolean)CHECK_POP (LocalGS.stackPointer);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);

	if (bFlag)
	{
		pbyInst += offset - 1;    /* interpreter post-increments the IP */
		LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */
		if (LocalGS.ulJumpCounter == 0)
		{
			LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
        if (pbyInst < LocalGS.pbyStartInst)
		{
			LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
	} 
	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative On False
 */
FS_PRIVATE uint8* itrp_JROF (IPARAM)
{
	int32 offset;
	boolean bFlag;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	bFlag = (boolean)CHECK_POP (LocalGS.stackPointer);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);

	if (!bFlag)
	{
		pbyInst += offset - 1;    /* interpreter post-increments the IP */
		LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */
		if (LocalGS.ulJumpCounter == 0)
		{
			LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
        if (pbyInst < LocalGS.pbyStartInst)
	    {
		    LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
		    return LocalGS.pbyEndInst;
        }
	} 
	return pbyInst;
}

/**************************************************************************/

/*
 * ROUND
 */
  FS_PRIVATE uint8* itrp_ROUND (IPARAM)
  {
	F26Dot6 arg1;
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = CHECK_POP (LocalGS.stackPointer);

	CHECK_RANGE (lOpCode, 0x68, 0x6B);

	arg1 = pb->RoundValue (GSA arg1, LocalGS.globalGS->engine[lOpCode - 0x68]);
	
	CHECK_PUSH (LocalGS.stackPointer , arg1);
	return pbyInst;
  }

/*
 * No ROUND
 */
  FS_PRIVATE uint8* itrp_NROUND (IPARAM)
  {
	F26Dot6 arg1;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = CHECK_POP (LocalGS.stackPointer);

	CHECK_RANGE (lOpCode, 0x6C, 0x6F);

	arg1 = itrp_RoundOff (GSA arg1, LocalGS.globalGS->engine[lOpCode - 0x6c]);
	CHECK_PUSH (LocalGS.stackPointer , arg1);
	return pbyInst;
  }

/**************************************************************************/

/*
 * An internal function used by MIRP an MDRP.
 */
  F26Dot6 itrp_CheckSingleWidth (GSP F26Dot6 fxValue) { // Single Width cut-in? B.St. to check
	F26Dot6 fxDelta;
	F26Dot6 fxScaledSW;
	fnt_ParameterBlock *pb;

	pb = &LocalGS.globalGS->localParBlock;
	fxScaledSW = LocalGS.GetSingleWidth (GSA0);

	if (fxValue >= 0) 
	{
		fxDelta = fxValue - fxScaledSW;
		if (fxDelta < 0)    
			fxDelta = -fxDelta;
		if (fxDelta < pb->sWCI)    
			fxValue = fxScaledSW;
	} 
	else 
	{
		fxValue = -fxValue;
		fxDelta = fxValue - fxScaledSW;
		if (fxDelta < 0)    
			fxDelta = -fxDelta;
		if (fxDelta < pb->sWCI)    
			fxValue = fxScaledSW;
		fxValue = -fxValue;
	}
	return fxValue;
}

/**************************************************************************/

/*
 * Move Direct Relative Point
 */
FS_PRIVATE uint8* itrp_MDRP (IPARAM)
{
	int32 iPt0;
	int32 iPt1;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_GlobalGraphicStateType *globalGS;
	fnt_ParameterBlock *pb;
	F26Dot6 fxMoveDist;
	F26Dot6 fxUnRounded;
	F26Dot6 fxMin;
	
	iPt0 = LocalGS.Pt0;
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	globalGS = LocalGS.globalGS;
	pb = &globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iPt1 = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_POINT (pCE0, iPt0);
	SECURE_CHECK_POINT (pCE1, iPt1);
	CHECK_POINT (&LocalGS, pCE0, iPt0);
	CHECK_POINT (&LocalGS, pCE1, iPt1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(globalGS))
		if (LocalGS.pt0 != -1 && LocalGS.pt1 != -1 && InterAlign(LocalGS.CE1,LocalGS.pt0,iPt1,LocalGS.pt1))
			AddProportion(&LocalGS,pCE1,LocalGS.pt0,iPt1,LocalGS.pt1);
		else 
			AddDistance(&LocalGS,pCE1,iPt0,iPt1,OTHER); // strokes are hardly MDRPed, more likely to get black MDRPs that should be grey
#endif

	if (pCE0 == &LocalGS.elements[TWILIGHTZONE] || pCE1 == &LocalGS.elements[TWILIGHTZONE] || LocalGS.globalGS->bOriginalPointIsInvalid) {
		fxMoveDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPt1] - pCE0->ox[iPt0], pCE1->oy[iPt1] - pCE0->oy[iPt0]);
	} else if (globalGS->bSameStretch) {
		fxMoveDist = (*LocalGS.OldProject) (GSA pCE1->oox[iPt1] - pCE0->oox[iPt0], pCE1->ooy[iPt1] - pCE0->ooy[iPt0]);
		fxMoveDist = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, fxMoveDist );
	} else {
		fxMoveDist = (*LocalGS.OldProject) (GSA 
			globalGS->ScaleFuncX (&globalGS->scaleX, pCE1->oox[iPt1] - pCE0->oox[iPt0]), 
			globalGS->ScaleFuncY (&globalGS->scaleY, pCE1->ooy[iPt1] - pCE0->ooy[iPt0]) );
	}

	if (pb->sWCI) { // Single Width cut-in? B.St. to check
		fxMoveDist = itrp_CheckSingleWidth (GSA fxMoveDist);
	}

	fxUnRounded = fxMoveDist;

	if (BIT2 (lOpCode)) { // Round?
		fxMoveDist = pb->RoundValue (GSA fxMoveDist, globalGS->engine[lOpCode & 0x03]);
	} else {
		fxMoveDist = itrp_RoundOff (GSA fxMoveDist, globalGS->engine[lOpCode & 0x03]);
	}
	
	if (BIT3 (lOpCode)) { // Minimum distance?
		fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
		if (fxUnRounded >= 0) {
			if (fxMoveDist < fxMin)
				fxMoveDist = fxMin;
		} else {
			fxMin = -fxMin;
			if (fxMoveDist > fxMin)
				fxMoveDist = fxMin;
		}
	}

	fxMoveDist -= (*LocalGS.Project) (GSA pCE1->x[iPt1] - pCE0->x[iPt0], pCE1->y[iPt1] - pCE0->y[iPt0]);
	(*LocalGS.MovePoint) (GSA pCE1, iPt1, fxMoveDist);
	
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPt1;
	if (BIT4 (lOpCode))
	{
		LocalGS.Pt0 = iPt1;          /* move the reference point */
	}
	return pbyInst;
} // itrp_MDRP


/**************************************************************************/

/*
 * Move Indirect Relative Point     General
 */

/*    
 *  This routine branches to either the general MIRPG, or to the fast MIRPX 
 *  or MIRPY.  The MIRPCode is set to MIRPX at the beginning of each glyph, 
 *  and may be changed to MIRPY or to MIRPX by the SVTCA instructions.  
 *  Any other change in relevant state will cause the function vector to fall 
 *  back to MIRPG.
 *
 *  Conditions for fast MIRPX and MIRPY:
 *      fast cvt (identity transform)
 *      no single width cut in
 *      no twilight zone
 *      round to grid
 *      no engine compensation
 *      LocalGS.MovePoint = itrp_X[or Y]MovePoint;  
 */

FS_PRIVATE uint8* itrp_MIRP (IPARAM)
{
	int32 iPoint;
	int32 iPt0;
	int32 iCVTIndex;
	F26Dot6 fxMoveDist;
	F26Dot6 fxMin;
	F26Dot6 fxOutlineDist;
	F26Dot6 fxPosition;
	F26Dot6 fxEngine;
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	long color;
#endif
	
	fnt_ParameterBlock *pb;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_GlobalGraphicStateType *globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	globalGS = LocalGS.globalGS;                /* common setup */
	pb = &globalGS->localParBlock;      
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	iCVTIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (iCVTIndex);
	CHECK_CVT (&LocalGS, iCVTIndex);
	
	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE1, iPoint);
	CHECK_POINT (&LocalGS, LocalGS.CE1, iPoint);
	
	iPt0 = LocalGS.Pt0;
	SECURE_CHECK_POINT (LocalGS.CE0, iPt0);
	CHECK_POINT (&LocalGS, LocalGS.CE0, iPt0);
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPoint;
	
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(globalGS)) {
		color = DoubleCheckLinkColor(pCE1,iPt0,iPoint,lOpCode & 0x03);
		AddDistance(&LocalGS,pCE1,iPt0,iPoint,color);
	}
#endif

	if (LocalGS.MIRPCode == MIRPG)              /********* MIRPG *********/
	{
		fxMoveDist = LocalGS.GetCVTEntry (GSA iCVTIndex);

		if (pb->sWCI) { // Single Width cut-in? B.St. to check
			fxMoveDist = itrp_CheckSingleWidth (GSA fxMoveDist);
		}

		if (pCE1 == &LocalGS.elements[TWILIGHTZONE]) {
			pCE1->ox[iPoint] = pCE0->ox[iPt0] + (F26Dot6) VECTORMUL (fxMoveDist, LocalGS.proj.x);
			pCE1->x[iPoint] = pCE1->ox[iPoint];
			pCE1->oy[iPoint] = pCE0->oy[iPt0] + (F26Dot6) VECTORMUL (fxMoveDist, LocalGS.proj.y);
			pCE1->y[iPoint] = pCE1->oy[iPoint];
		}

		if (LocalGS.OldProject == itrp_XProject) {
			fxOutlineDist = pCE1->ox[iPoint] - pCE0->ox[iPt0];
		} else if (LocalGS.OldProject == itrp_YProject) {
			fxOutlineDist = pCE1->oy[iPoint] - pCE0->oy[iPt0];
		} else {
			fxOutlineDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPoint] - pCE0->ox[iPt0], pCE1->oy[iPoint] - pCE0->oy[iPt0]);
		}

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

		fxEngine = globalGS->engine[lOpCode & 0x03];

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// here we may honour a cvt cut-in even though the round-off flag would require not to do so. We assume that the
			// context is a stroke weight that has been tweaked for use with grey-scaling, and the only way to force MIRP
			// to use a particular distance is to round the cvt "by hand" and then turn off the rounding flag, which is
			// quite what we don't want to do in SubPixel, ie. to enforce an unnatural weight.
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif // RoundOffRespectsCvtCutIn
				fxMoveDist = pb->RoundValue (GSA fxMoveDist, fxEngine);
			} else { // !Round
				fxMoveDist = itrp_RoundOffSP (GSA fxMoveDist, fxEngine);
			}
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL
			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				fxMoveDist = pb->RoundValue (GSA fxMoveDist, fxEngine);
			} else {
				fxMoveDist = itrp_RoundOff (GSA fxMoveDist, fxEngine);
			}
#ifdef FSCFG_SUBPIXEL
		}
#endif
		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}
		if (LocalGS.Project == itrp_XProject) {
			fxPosition = pCE1->x[iPoint] - pCE0->x[iPt0];
		} else if (LocalGS.Project == itrp_YProject) {
			fxPosition = pCE1->y[iPoint] - pCE0->y[iPt0];
		} else {
			fxPosition = (*LocalGS.Project) (GSA pCE1->x[iPoint] - pCE0->x[iPt0], pCE1->y[iPoint] - pCE0->y[iPt0]);
		}

		(*LocalGS.MovePoint) (GSA pCE1, iPoint, fxMoveDist - fxPosition);
	
	} else if (LocalGS.MIRPCode == MIRPX) {        /********* MIRPX *********/
	
		fxMoveDist = globalGS->controlValueTable[ iCVTIndex ];  /* always fast */

		fxOutlineDist = pCE1->ox[iPoint] - pCE0->ox[iPt0];  /* x direction only */

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// same situation as in general MIRP case above
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else			
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif				
				RTG(fxMoveDist,0,VIRTUAL_PIXELSIZE_RTG);
			} // else no round off since no engine compensation
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL

			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				RTG(fxMoveDist,0,FNT_PIXELSIZE);
			} // else no round off since no engine compensation

#ifdef FSCFG_SUBPIXEL
		}
#endif

		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}

		pCE1->x[iPoint] = fxMoveDist + pCE0->x[iPt0];  /* move point fast */
		pCE1->f[iPoint] |= XMOVED;
	
	} else { /* if (LocalGS.MIRPCode == MIRPY) */  /********* MIRPY *********/
	
		fxMoveDist = globalGS->controlValueTable[ iCVTIndex ];  /* always fast */

		fxOutlineDist = pCE1->oy[iPoint] - pCE0->oy[iPt0];  /* y direction only */

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// same situation as in general MIRP case above
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else			
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif				
				RTG(fxMoveDist,0,VIRTUAL_PIXELSIZE_RTG);
			} // else no round off since no engine compensation
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL

			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				RTG(fxMoveDist,0,FNT_PIXELSIZE);
			} // else no round off since no engine compensation

#ifdef FSCFG_SUBPIXEL
		}
#endif

		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}

		pCE1->y[iPoint] = fxMoveDist + pCE0->y[iPt0];  /* move point fast */
		pCE1->f[iPoint] |= YMOVED;
	}
	
	if (BIT4 (lOpCode)) {
		LocalGS.Pt0 = iPoint;                   /* move the reference point */
	}
	return pbyInst;
} // itrp_MIRP

/**************************************************************************/

/*
 * CALL a function
 */
FS_PRIVATE uint8* itrp_CALL (IPARAM)
{
	fnt_funcDef *funcDef;
	uint8 *pbySubroutine;
	fnt_GlobalGraphicStateType *globalGS;
	int32 arg;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	uint8 patchedStore22 = false;
	F26Dot6 store22;
#endif
#ifdef BypassJellesSpacing
	uint8 patchedStore24 = false;
	F26Dot6 store24;
#endif
#ifdef AssistTomsDiagonal
	uint8 assistTomsDiagonal = false;
	F26Dot6 cvtCI = 0;
#endif
#ifdef InlineDeltasOnly
	uint16 i;
	uint8 inSkippableDeltaFn = false;
#endif
#endif

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);

	CHECK_PROGRAM (funcDef->pgmIndex);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);
	funcDef = &globalGS->funcDef[ arg ];

 	SECURE_CHECK_PROGRAM (funcDef->pgmIndex);

	pbySubroutine = globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

	CHECK_ASSERTION (globalGS->funcDef != 0);
	CHECK_ASSERTION (pbySubroutine != 0);

	pbySubroutine += funcDef->start;
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;        /* save for parent */

#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	// here we're assuming that fns 64 through 66 are support functions for the TMT D/IStroke commands, which may make strokes collapse in SubPixel.
	// To determine whether we've actually run into the context of these fns, we look at the first couple of bytes only, as the exact implementation
	// of these functions may have changed over time, but hopefully, the preamble (to look at storage #22) hasn't. The easiest way to by-pass these
	// fns is to flag storage #22 with 0, indicating not to use D/IStrokes, else we'd have to cleanup the stack.
	// Admittedly a bit of a hack. If anybody can think of a "better bandaid", I'll be happy to consider it.
	//    The reason, by the way, why DStroke doesn't work, is the following. DStroke brings pairs of points to the same y (or x), MIRP[m<rBl] the
	// floating point, and the moves it back to the old y (or x). Now that we re-interpret little r, cvt cut in actually gets to cut in, the original
	// distance gets to apply, just that the original distance is taken prior to bringing points to same y (or x), meaning it's likely to be WAY off.
	// As a result, the diagonal stroke weight (in x) starts to depend heavily on the distance (in y) of the control points involved, which obviously
	// is not what we want. Notice that for non-square aspect ratios, the DStroke is a NOP, therefore was a NOP with 16x SubPixel, and hence we're
	// not doing any major harm by skipping it in SubPixel.
	if (64 <= arg && arg <= 66 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedDandIStroke) > 0) {
		store22 = LocalGS.globalGS->store[22];
		LocalGS.globalGS->store[22] = 0;
		patchedStore22 = true;
	}
#endif
#ifdef BypassJellesSpacing
	// here we're assuming that fns 0, 1, 2, 4, 7, and 8 are support functions for Monotype's Jelle Bosma's spacing functions, which may squish
	// characters or pull them left or right or in both directions at the same time. This has to do amongst other with using the twilight zone.
	// The spacing algorithm is meant to be turned off above a certain size, such as 30 ppem, hence we may argue that with the extra virtual re-
	// solution we should turn it off at a considerably smaller ppem size, or altogether. From there the logic is like bypassing D/IStroke.
	// (1 << arg) & (1 + 2 + 4 + 16 + 128 + 256) != 0
	if ((0 <= arg && arg <= 2 || arg == 4 || 7 <= arg && arg <= 8) && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedJellesSpacing) > 0) {
		store24 = LocalGS.globalGS->store[24];
		LocalGS.globalGS->store[24] = 0;
		patchedStore24 = true;
	}
#endif
#ifdef AssistTomsDiagonal
	if (arg == 58 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedTomsDiagonal) > 0) {
		cvtCI = LocalGS.globalGS->localParBlock.wTCI;
		LocalGS.globalGS->localParBlock.wTCI = 0x7fffffff;
		assistTomsDiagonal = true;
	}
#endif
#ifdef InlineDeltasOnly
	for (i = 0; i < LocalGS.globalGS->numDeltaFunctionsDetected && LocalGS.globalGS->deltaFunction[i] != (uint16)arg; i++);
	if (i < LocalGS.globalGS->numDeltaFunctionsDetected && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS)) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inSkippableDeltaFn;
		inSkippableDeltaFn = true;
	}
#endif
#endif


	LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
	if (LocalGS.ulRecursiveCall == 0)
	{
		LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}
	LocalGS.Interpreter (GSA pbySubroutine, pbySubroutine + funcDef->length);   /* recursion */
	LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */
	

#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
	if (inSkippableDeltaFn) {
		LocalGS.globalGS->subPixelCompatibilityFlags &= ~SPCF_inSkippableDeltaFn;
	}
#endif
#ifdef AssistTomsDiagonal
	if (assistTomsDiagonal) {
		LocalGS.globalGS->localParBlock.wTCI = cvtCI;
	}
#endif
#ifdef BypassJellesSpacing
	if (patchedStore24) {
		LocalGS.globalGS->store[24] = store24;
	}
#endif
#ifdef BypassDandIStroke
	if (patchedStore22) {
		LocalGS.globalGS->store[22] = store22;
	}
#endif
#endif

	LocalGS.pbyEndInst = pbyEndInst;        /* restore for parent */
	LocalGS.pbyStartInst = pbyStartInst;    /* restore for parent */
	if (LocalGS.ercReturn != NO_ERR)        /* if illegal inst has been hit */
	{
		return pbyEndInst;                  /* exit parent's loop */
	}
			
	return pbyInst;
}

/**************************************************************************/

/*
 * Function DEFinition
 */
FS_PRIVATE uint8* itrp_FDEF (IPARAM)
{
	fnt_funcDef *funcDef;
	uint8 * program, *funcStart;
	static const uint8 funcFragment[8][16] ={
								{0x01,0x20,0xB0,0x03,0x25},				// SVTCA[X] DUP[] #PUSH 3 CINDEX[] (DiagEndCtrl)
								{0xB0,0x16,0x43,0x58},					// #PUSH 22 RS[] IF[] (D/IStroke)
								{0x01,0xB0,0x18,0x43,0x58},				// SVTCA[X] #PUSH 24 RS[] IF[] (Jelle's Spacing, version #1)
								{0x01,0x18,0xB0,0x18,0x43,0x58},		// SVTCA[X] RTG[] #PUSH 24 RS[] IF[] (Jelle's Spacing, version #2)
								{0x45,0x23,0x46,0x60,0x20,0xB0,0x26},	// RCVT[] SWAP[] GC[N] ADD[] DUP[] #PUSH 38 (VacuFormRound)
								{0x20,0x20,0xB0,0x01,0x60,0x46,0xB0,0x40,0x23,0x42}, // DUP[] DUP[] #PUSH[] 1 ADD[] GC[N] #PUSH[] 64 SWAP[] WS[] (Tom's Diagonal)
								{0x4B,0x53,0x23,0x4B,0x51,0x5A,0x58,0x38,0x1B,0x21,0x21,0x59,0x2D}, // MPPEM[] GTEQ[] SWAP[] MPPEM[] LTEQ[] AND[] IF[] SHPIX[] ELSE[] POP[] POP[] EIF[] ENDF[] (Range of deltas)
								{0x4B,0x54,0x58,0x38,0x1B,0x21,0x21,0x59,0x2D}}; // MPPEM[] EQ[] IF[] SHPIX[] ELSE[] POP[] POP[] EIF[] ENDF[] (Delta)

	// extend here for two variants of delta fn

	fnt_GlobalGraphicStateType * globalGS;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);

	if (LocalGS.globalGS->pgmIndex >= MAXPREPROGRAMS)
	{
		LocalGS.ercReturn = FDEF_IN_GLYPHPGM_ERR;  /* returned to client, error FDEF in glyph program */
		return LocalGS.pbyEndInst;
	}

	funcDef = &globalGS->funcDef[ arg ];
	program = globalGS->pgmList[ funcDef->pgmIndex = LocalGS.globalGS->pgmIndex ].Instruction;

	CHECK_PROGRAM (funcDef->pgmIndex);
	CHECK_ASSERTION (globalGS->funcDef != 0);
	CHECK_ASSERTION (globalGS->pgmList[funcDef->pgmIndex].Instruction != 0);

	funcDef->start = (int32)(pbyInst - program);

	funcStart = pbyInst;

#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	if (64 <= arg && arg <= 66 && memcmp(funcStart,funcFragment[1],4) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedDandIStroke;
#endif
#ifdef BypassJellesSpacing // (1 << arg) & (1 + 2 + 4 + 16 + 128 + 256) != 0
	if ((0 <= arg && arg <= 2 || arg == 4 || 7 <= arg && arg <= 8) && (memcmp(funcStart,funcFragment[2],5) == 0 || memcmp(funcStart,funcFragment[3],6) == 0))
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedJellesSpacing;
#endif
#ifdef BypassVacuformRound
	if (arg == 0 && memcmp(funcStart,funcFragment[4],7) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedVacuformRound;
#endif
#ifdef AssistTomsDiagonal
	if (arg == 58 && memcmp(funcStart,funcFragment[5],10) == 0) 
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedTomsDiagonal;
#endif
#ifdef InlineDeltasOnly
	if (*funcStart == funcFragment[6][0] && (memcmp(funcStart,funcFragment[7],9) == 0 || memcmp(funcStart,funcFragment[6],13) == 0) && LocalGS.globalGS->numDeltaFunctionsDetected < maxDeltaFunctions)
		LocalGS.globalGS->deltaFunction[LocalGS.globalGS->numDeltaFunctionsDetected++] = (uint16)arg;
	// if we have too many delta fns, we'll end up executing a delta fn; this may not look optimal, but we don't expect to get to this point in the first place.
#endif
#endif
	while ( ((*pbyInst++) != ENDF_CODE)  && (pbyInst < LocalGS.pbyEndInst) )
	{
		pbyInst = itrp_SkipPushData (GSA pbyInst);
	}

	if ((pbyInst == LocalGS.pbyEndInst) &&  (*(pbyInst-1) != ENDF_CODE ))
	{
		LocalGS.ercReturn = MISSING_ENDF_ERR;  /* returned to client, missing ENDF */

	}

	funcDef->length = (uint16)(pbyInst - funcStart - 1); /* don't execute ENDF */
	return pbyInst;
}

/**************************************************************************/

/*
 * LOOP while CALLing a function
 */
FS_PRIVATE uint8* itrp_LOOPCALL (IPARAM)
{
	uint8 *start, *stop;
	InterpreterFunc Interpreter;
	fnt_funcDef *funcDef;
	int32 arg;
	int32 loop;
	uint8 * ins;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);

	funcDef = & (LocalGS.globalGS->funcDef[ arg ]);
	{
		SECURE_CHECK_PROGRAM (funcDef->pgmIndex);
		CHECK_PROGRAM (funcDef->pgmIndex);
		ins = LocalGS.globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

		start = &ins[funcDef->start];
		stop = &ins[funcDef->start + funcDef->length];  /* funcDef->end -> funcDef->length <4> */
	}
	Interpreter = LocalGS.Interpreter;
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	CHECK_LARGER (-1L, arg);
	loop = (int32)arg;
	
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;    /* save for parent */
	LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
	if (LocalGS.ulRecursiveCall == 0)
	{
		LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}

	for (--loop; ((loop >= 0) && (LocalGS.ercReturn == NO_ERR)); --loop)
	{
		Interpreter (GSA start, stop);
	}
	LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */
	LocalGS.pbyEndInst = pbyEndInst;        /* restore for parent */
	LocalGS.pbyStartInst = pbyStartInst;    /* restore for parent */
	
	if (LocalGS.ercReturn != NO_ERR)        /* if illegal inst has been hit */
	{
		return pbyEndInst;                  /* exit parent's loop */
	}
	return pbyInst;
}

/**************************************************************************/

/*
 *      This guy returns the index of the given opCode, or 0 if not found <4>
 */
FS_PRIVATE fnt_instrDef *itrp_FindIDef (GSP uint8 opCode)
{
	fnt_GlobalGraphicStateType *globalGS;
	int32 count;
	fnt_instrDef*instrDef;
	
	globalGS = LocalGS.globalGS;
	count = globalGS->instrDefCount;
	instrDef = globalGS->instrDef;
		
	for (--count; count >= 0; instrDef++, --count)
	{
		if (instrDef->opCode == opCode)
		{
			return instrDef;
		}
	}
	return 0;
}

/**************************************************************************/

/*
 *      This guy gets called for opCodes that has been patch by the font's IDEF <4>
 *      or if they have never been defined.  If there is no corresponding IDEF,
 *      flag it as an illegal instruction.
 */
FS_PRIVATE uint8* itrp_IDefPatch (IPARAM)
{
	fnt_instrDef *instrDef;
	uint8 *program;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
	
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;    /* save for parent */
	
	instrDef = itrp_FindIDef (GSA (uint8)lOpCode);
	if (instrDef == 0)
	{
		return itrp_IllegalInstruction (GSA pbyInst, lOpCode);
	}
	else
	{
		SECURE_CHECK_PROGRAM (instrDef->pgmIndex);
		CHECK_PROGRAM (instrDef->pgmIndex);
		program = LocalGS.globalGS->pgmList[ instrDef->pgmIndex ].Instruction;
		program += instrDef->start;
		
		LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
		if (LocalGS.ulRecursiveCall == 0)
		{
			LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}

		LocalGS.Interpreter (GSA program, program + instrDef->length);
	
		LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */

		LocalGS.pbyEndInst = pbyEndInst;    /* restore for parent */
		LocalGS.pbyStartInst = pbyStartInst;/* restore for parent */
		
		if (LocalGS.ercReturn != NO_ERR)    /* if illegal inst has been hit */
		{
			return pbyEndInst;              /* exit parent's loop */
		}
	}
	return pbyInst;
}

/**************************************************************************/

/*
 * Instruction DEFinition       <4>
 */
FS_PRIVATE uint8* itrp_IDEF (IPARAM)
{
	int32 arg;
	uint8 opCode;
	fnt_instrDef *instrDef;
	int32 pgmIndex;
	uint8 * program;
	uint8 * instrStart;

	FS_UNUSED_PARAMETER(lOpCode);

	pgmIndex = (int32)LocalGS.globalGS->pgmIndex;

	if (pgmIndex >= MAXPREPROGRAMS)
	{
		LocalGS.ercReturn = IDEF_IN_GLYPHPGM_ERR;  /* returned to client, error IDEF in glyph program */
		return LocalGS.pbyEndInst;
	}

	program = LocalGS.globalGS->pgmList[ pgmIndex ].Instruction;
	instrStart = pbyInst;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_IDEF_OPCODE(arg);
    CHECK_INT8 (arg);
	opCode = (uint8)arg;
	CHECK_PROGRAM (pgmIndex);

	instrDef = itrp_FindIDef (GSA opCode);
	if (!instrDef)
	{
        SECURE_CHECK_IDEF_OVERFLOW();
		instrDef = LocalGS.globalGS->instrDef + LocalGS.globalGS->instrDefCount++;
	}

	instrDef->pgmIndex = (uint8) pgmIndex;
	instrDef->opCode = opCode;          /* this may or may not have been set */
	instrDef->start = (int32)(pbyInst - program);

	while (((*pbyInst++) != ENDF_CODE) && (pbyInst < LocalGS.pbyEndInst))
	{
		pbyInst = itrp_SkipPushData (GSA pbyInst);
	}

	if ((pbyInst == LocalGS.pbyEndInst) &&  (*(pbyInst-1) != ENDF_CODE ))
	{
		LocalGS.ercReturn = MISSING_ENDF_ERR;  /* returned to client, missing ENDF */

	}

	instrDef->length = (uint16)(pbyInst - instrStart - 1); /* don't execute ENDF */
	return pbyInst;
}

/**************************************************************************/

/*
 * UnTouch Point
 */
  FS_PRIVATE uint8* itrp_UTP (IPARAM)
  {
	uint8*f = LocalGS.CE0->f;
	int32 point;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	point = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, point);
	CHECK_POINT (&LocalGS, LocalGS.CE0, point);
	if (LocalGS.free.x)
	{
	  f[point] &= ~XMOVED;
	}
	if (LocalGS.free.y)
	{
	  f[point] &= ~YMOVED;
	}
	return pbyInst;
  }

/*
 * Set Delta Base
 */
  FS_PRIVATE uint8* itrp_SDB (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.deltaBase = (int16)arg;
	return pbyInst;
  }

/*
 * Set Delta Shift
 */
  FS_PRIVATE uint8* itrp_SDS (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.deltaShift = (int16)arg;
	return pbyInst;
  }

/**************************************************************************/

/*
 * DeltaEngine, internal support routine
 */
FS_PRIVATE uint8*  itrp_DeltaEngine (GSP uint8 *pbyInst, FntMoveFunc doIt, int16 sBase, int16 sShift)
{
	int32 iRange;
	int32 iAim;
	int32 iHigh;
	int32 iFakePPEM;
	int32 iPPEM;
	F26Dot6 fxDelta;

		/* Find the beginning of data pairs for this particular size */
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iHigh = CHECK_POP (LocalGS.stackPointer) << 1;
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, iHigh);
	LocalGS.stackPointer -= iHigh;              /* -= number of pops required */
	CHECK_STACK (&LocalGS);

	iRange = LocalGS.globalGS->pixelsPerEm;     /* same as itrp_MPPEM () */
	if (!LocalGS.globalGS->bSameStretch)
		iRange = (int32)FixMul(iRange, itrp_GetCVTScale (GSA0));
	iFakePPEM = iRange - (int32)sBase;

	if ((iFakePPEM >= 16) || (iFakePPEM < 0))
	{
		return pbyInst;                                 /* Not within exception range */
	}
	iFakePPEM = iFakePPEM << 4;

	iAim = 0;
	iRange = iHigh >> 1; 
	iRange &= ~1;
	while (iRange > 2)                          /* binary search for first data */
	{
		iPPEM = LocalGS.stackPointer[ iAim + iRange ]; /* [ iPPEM << 4 | exception ] */
		if ((iPPEM & ~0x0f) < iFakePPEM) 
		{
			iAim += iRange;                     /* approach the starting point */
		}
		iRange >>= 1; 
		iRange &= ~1;                           /* iRange must stay even */
	}

	while (iAim < iHigh) 
	{
		iPPEM = LocalGS.stackPointer[ iAim ];   /* [ iPPEM << 4 | exception ] */
		fxDelta = iPPEM & ~0x0f;
		if (fxDelta == iFakePPEM)
		{                                       /* We found an exception, go ahead and apply it */
			fxDelta = iPPEM & 0xf;              /* 0 ... 15 */
			fxDelta -= fxDelta >= 8 ? 7 : 8;    /* -8 ... -1, 1 ... 8 */
			fxDelta <<= FNT_PIXELSHIFT;        /* convert to pixels */
			fxDelta >>= sShift;                 /* scale to right size */
            
#ifdef FSCFG_SECURE
            if (doIt == LocalGS.MovePoint)
            {
                SECURE_CHECK_POINT(LocalGS.CE0,(int32)LocalGS.stackPointer[iAim+1]);
            } else
			{
				FS_ASSERT( (doIt == LocalGS.ChangeCvt), "itrp_DeltaEngine called with wrong doIt.")
                SECURE_CHECK_CVT((int32)LocalGS.stackPointer[iAim+1]);
			}
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		// similar to itrp_SHP_Common above
		// main difference: we don't distinguish between SHPIX and SHP, but between CVT deltas and ordinary deltas
			if (doIt == LocalGS.ChangeCvt || !RunningSubPixel(LocalGS.globalGS) || Tuned4SubPixel(LocalGS.globalGS) || AMovedPointInNonSPDirection(LocalGS,CE0,(int16)LocalGS.stackPointer[iAim+1]))
#endif
#endif
				doIt (GSA LocalGS.CE0, (int32)LocalGS.stackPointer[iAim+1], (F26Dot6) fxDelta);
		} 
		else if (fxDelta > iFakePPEM)
		{
			break;                              /* we passed the data */
		}
		iAim += 2;
	}
    return pbyInst;
}

/**************************************************************************/

/*
 * DELTAP1
 */
  FS_PRIVATE uint8* itrp_DELTAP1 (IPARAM)
  {
	fnt_ParameterBlock *pb;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAP2
 */
  FS_PRIVATE uint8* itrp_DELTAP2 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 16);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, sBase, pb->deltaShift);
  }

/*
 * DELTAP3
 */
  FS_PRIVATE uint8* itrp_DELTAP3 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 32);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, sBase, pb->deltaShift);
  }

/*
 * DELTAC1
 */
  FS_PRIVATE uint8* itrp_DELTAC1 (IPARAM)
  {
	fnt_ParameterBlock *pb;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAC2
 */
  FS_PRIVATE uint8* itrp_DELTAC2 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 16);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, sBase, pb->deltaShift);
  }

/*
 * DELTAC3
 */
  FS_PRIVATE uint8* itrp_DELTAC3 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 32);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, sBase, pb->deltaShift);
  }


#ifdef FSCFG_NO_INITIALIZED_DATA
	
	void itrp_InitializeData (void)
	{
		int32 i;

		/***** 0x00 - 0x0f *****/
		function[0x00] = itrp_SVTCA_0;
		function[0x01] = itrp_SVTCA_1;
		function[0x02] = itrp_SPVTCA_0;
		function[0x03] = itrp_SPVTCA_1;
		function[0x04] = itrp_SFVTCA_0;
		function[0x05] = itrp_SFVTCA_1;
		function[0x06] = itrp_SPVTL;
		function[0x07] = itrp_SPVTL;
		function[0x08] = itrp_SFVTL;
		function[0x09] = itrp_SFVTL;
		function[0x0A] = itrp_WPV;
		function[0x0B] = itrp_WFV;
		function[0x0C] = itrp_RPV;
		function[0x0D] = itrp_RFV;
		function[0x0E] = itrp_SFVTPV;
		function[0x0F] = itrp_ISECT;

		/***** 0x10 - 0x1f *****/
		function[0x10] = itrp_SRP0;
		function[0x11] = itrp_SRP1;
		function[0x12] = itrp_SRP2;
		function[0x13] = itrp_SetElementPtr;
		function[0x14] = itrp_SetElementPtr;
		function[0x15] = itrp_SetElementPtr;
		function[0x16] = itrp_SetElementPtr;
		function[0x17] = itrp_LLOOP;
		function[0x18] = itrp_RTG;
		function[0x19] = itrp_RTHG;
		function[0x1A] = itrp_LMD;
		function[0x1B] = itrp_ELSE;
		function[0x1C] = itrp_JMPR;
		function[0x1D] = itrp_LWTCI;
		function[0x1E] = itrp_LSWCI;
		function[0x1F] = itrp_LSW;

		/***** 0x20 - 0x2f *****/
		function[0x20] = itrp_DUP;
		function[0x21] = itrp_POP;
		function[0x22] = itrp_CLEAR;
		function[0x23] = itrp_SWAP;
		function[0x24] = itrp_DEPTH;
		function[0x25] = itrp_CINDEX;
		function[0x26] = itrp_MINDEX;
		function[0x27] = itrp_ALIGNPTS;
		function[0x28] = itrp_RAW;
		function[0x29] = itrp_UTP;
		function[0x2A] = itrp_LOOPCALL;
		function[0x2B] = itrp_CALL;
		function[0x2C] = itrp_FDEF;
		function[0x2D] = itrp_IllegalInstruction;
		function[0x2E] = itrp_MDAP;
		function[0x2F] = itrp_MDAP;

		/***** 0x30 - 0x3f *****/
		function[0x30] = itrp_IUP;
		function[0x31] = itrp_IUP;
		function[0x32] = itrp_SHP;
		function[0x33] = itrp_SHP;
		function[0x34] = itrp_SHC;
		function[0x35] = itrp_SHC;
		function[0x36] = itrp_SHE;
		function[0x37] = itrp_SHE;
		function[0x38] = itrp_SHPIX;
		function[0x39] = itrp_IP;
		function[0x3A] = itrp_MSIRP;
		function[0x3B] = itrp_MSIRP;
		function[0x3C] = itrp_ALIGNRP;
		function[0x3D] = itrp_RTDG;
		function[0x3E] = itrp_MIAP;
		function[0x3F] = itrp_MIAP;

		/***** 0x40 - 0x4f *****/
		function[0x40] = itrp_NPUSHB;
		function[0x41] = itrp_NPUSHW;
		function[0x42] = itrp_WS;
		function[0x43] = itrp_RS;
		function[0x44] = itrp_WCVT;
		function[0x45] = itrp_RCVT;
		function[0x46] = itrp_RC;
		function[0x47] = itrp_RC;
		function[0x48] = itrp_WC;
		function[0x49] = itrp_MD;
		function[0x4A] = itrp_MD;
		function[0x4B] = itrp_MPPEM;
		function[0x4C] = itrp_MPS;
		function[0x4D] = itrp_FLIPON;
		function[0x4E] = itrp_FLIPOFF;
		function[0x4F] = itrp_DEBUG;

		/***** 0x50 - 0x5f *****/
		function[0x50] = itrp_LT;
		function[0x51] = itrp_LTEQ;
		function[0x52] = itrp_GT;
		function[0x53] = itrp_GTEQ;
		function[0x54] = itrp_EQ;
		function[0x55] = itrp_NEQ;
		function[0x56] = itrp_ODD;
		function[0x57] = itrp_EVEN;
		function[0x58] = itrp_IF;
		function[0x59] = itrp_EIF;
		function[0x5A] = itrp_AND;
		function[0x5B] = itrp_OR;
		function[0x5C] = itrp_NOT;
		function[0x5D] = itrp_DELTAP1;
		function[0x5E] = itrp_SDB;
		function[0x5F] = itrp_SDS;

		/***** 0x60 - 0x6f *****/
		function[0x60] = itrp_ADD;
		function[0x61] = itrp_SUB;
		function[0x62] = itrp_DIV;
		function[0x63] = itrp_MUL;
		function[0x64] = itrp_ABS;
		function[0x65] = itrp_NEG;
		function[0x66] = itrp_FLOOR;
		function[0x67] = itrp_CEILING;
		function[0x68] = itrp_ROUND;
		function[0x69] = itrp_ROUND;
		function[0x6A] = itrp_ROUND;
		function[0x6B] = itrp_ROUND;
		function[0x6C] = itrp_NROUND;
		function[0x6D] = itrp_NROUND;
		function[0x6E] = itrp_NROUND;
		function[0x6F] = itrp_NROUND;

		/***** 0x70 - 0x7f *****/
		function[0x70] = itrp_WCVTFOD;
		function[0x71] = itrp_DELTAP2;
		function[0x72] = itrp_DELTAP3;
		function[0x73] = itrp_DELTAC1;
		function[0x74] = itrp_DELTAC2;
		function[0x75] = itrp_DELTAC3;
		function[0x76] = itrp_SROUND;
		function[0x77] = itrp_S45ROUND;
		function[0x78] = itrp_JROT;
		function[0x79] = itrp_JROF;
		function[0x7A] = itrp_ROFF;
		function[0x7B] = itrp_IllegalInstruction;
		function[0x7C] = itrp_RUTG;
		function[0x7D] = itrp_RDTG;
		function[0x7E] = itrp_SANGW;
		function[0x7F] = itrp_AA;

		/***** 0x80 - 0x8d *****/
		function[0x80] = itrp_FLIPPT;
		function[0x81] = itrp_FLIPRGON;
		function[0x82] = itrp_FLIPRGOFF;
		function[0x83] = itrp_IDefPatch;
		function[0x84] = itrp_IDefPatch;
		function[0x85] = itrp_SCANCTRL;
		function[0x86] = itrp_SDPVTL;
		function[0x87] = itrp_SDPVTL;
		function[0x88] = itrp_GETINFO;
		function[0x89] = itrp_IDEF;
		function[0x8A] = itrp_ROTATE;
		function[0x8B] = itrp_MAX;
		function[0x8C] = itrp_MIN;
		function[0x8D] = itrp_SCANTYPE;
		function[0x8E] = itrp_INSTCTRL;

		/***** 0x8f - 0xaf *****/
		for ( i = 0x8F; i <= 0xAF;  ++i )
			function[i] = itrp_IDefPatch;

		/***** 0xb0 - 0xb7 *****/
		function[0xB0] = itrp_PUSHB1;
		function[0xB1] = itrp_PUSHB;
		function[0xB2] = itrp_PUSHB;
		function[0xB3] = itrp_PUSHB;
		function[0xB4] = itrp_PUSHB;
		function[0xB5] = itrp_PUSHB;
		function[0xB6] = itrp_PUSHB;
		function[0xB7] = itrp_PUSHB;

		/***** 0xb8 - 0xbf *****/
		function[0xB8] = itrp_PUSHW1;
		function[0xB9] = itrp_PUSHW;
		function[0xBA] = itrp_PUSHW;
		function[0xBB] = itrp_PUSHW;
		function[0xBC] = itrp_PUSHW;
		function[0xBD] = itrp_PUSHW;
		function[0xBE] = itrp_PUSHW;
		function[0xBF] = itrp_PUSHW;

		/***** 0xc0 - 0xdf *****/
		for ( i = 0xC0; i <= 0xDF;  i++ )
			function[i] = itrp_MDRP;

		/***** 0xe0 - 0xff *****/
		for ( i = 0xE0; i <= 0xFF;  i++ )
			function[i] = itrp_MIRP;
		
#ifdef FSCFG_SUBPIXEL
		// initialize round function table for SP
		itrp_RoundFunction[0][0] = itrp_RoundToDoubleGrid;
		itrp_RoundFunction[0][1] = itrp_RoundDownToGrid;
		itrp_RoundFunction[0][2] = itrp_RoundUpToGrid;
		itrp_RoundFunction[0][3] = itrp_RoundToGrid;
		itrp_RoundFunction[0][4] = itrp_RoundToHalfGrid;
		itrp_RoundFunction[0][5] = itrp_RoundOff;
		itrp_RoundFunction[0][6] = itrp_SuperRound;
		itrp_RoundFunction[0][7] = itrp_Super45Round;
		itrp_RoundFunction[1][0] = itrp_RoundToDoubleGridSP;
		itrp_RoundFunction[1][1] = itrp_RoundDownToGridSP;
		itrp_RoundFunction[1][2] = itrp_RoundUpToGridSP;
		itrp_RoundFunction[1][3] = itrp_RoundToGridSP;
		itrp_RoundFunction[1][4] = itrp_RoundToHalfGridSP;
		itrp_RoundFunction[1][5] = itrp_RoundOffSP;
		itrp_RoundFunction[1][6] = itrp_SuperRound;
		itrp_RoundFunction[1][7] = itrp_Super45Round;
#endif
	}

#endif /* FSCFG_NO_INITIALIZED_DATA */

/* END OF interp.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scline.h ===
/*********************************************************************

	  scline.h -- Line Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTP added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetLineElemSize returns size_t 
	   8/21/92 deanb    GetLineElemSize added 
	   7/23/92 deanb    Back to x2,y2 again 
	   7/17/92 deanb    Changed from longline to line 
	   4/21/92 deanb    Scan lines and on/off added 
	   4/09/92 deanb    New types 
	   4/01/92 deanb    Back to x2,y2 
	   3/20/92 deanb    Reintroduced 
	   1/14/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupLine ( PSTATE0 );

FS_PUBLIC int32 fsc_CalcLine( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* point 1  x coordinate */
		F26Dot6,            /* point 1  y coordinate */
		F26Dot6,            /* point 2  y coordinate */
		F26Dot6,            /* point 2  y coordinate */
		uint16              /* scan control type */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\scaler\scanlist.c ===
/*********************************************************************

	  scanlist.c -- New Scan Converter ScanList Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/23/93  deanb   gray scale pass through functions
	   6/22/93  deanb   all dropouts confined to bounding box
	   6/10/93  deanb   fsc_InitializeScanlist added, stdio & assert gone
	   4/26/93  deanb   fix pointers now works with segmented memory
	   4/19/93  deanb   banding added
	   4/07/93  deanb   sorting is now done on the fly
	   4/01/93  deanb   intersection arrays replace linked lists
	   3/19/93  deanb   size_t replaced with int32
	  12/22/92  deanb   Rectangle -> Rect
	  10/28/92  deanb   memory requirements reworked
	  10/19/92  deanb   smart dropout tiebreak left & down
	  10/14/92  deanb   delete usScanKind from state
	  10/09/92  deanb   reentrant
	  10/08/92  deanb   reworked for split workspace
	  10/02/92  deanb   correct AddVertDropoutScan assertions
	   9/25/92  deanb   separate nodrop/dropout entry points
	   9/22/92  deanb   smart dropout control
	   9/17/92  deanb   stub control
	   9/15/92  deanb   simple dropout control
	   9/11/92  deanb   setupscan handles scankind
	   9/09/92  deanb   dropout / nodropout begun
	   8/17/92  deanb   include struc.h scconst.h
	   8/07/92  deanb   initial dropout control
	   8/06/92  deanb   assertions reinstated
	   7/27/92  deanb   bitmap clear added
	   7/16/92  deanb   gulBytesRemaining -> gulIntersectRemaining
	   6/18/92  deanb   int x coord for HorizScanAdd
	   6/01/92  deanb   incorporate bitmap functions
	   5/08/92  deanb   reordered includes for precompiled headers
	   5/04/92  deanb   Array tags added
	   4/28/92  deanb   list array sentinels added
	   4/21/92  deanb   single HorizScanAdd routine
	   4/15/92  deanb   calls to BitMap
	   4/13/92  deanb   uiY to iY for HorizScanOn/Off
	   4/09/92  deanb   New types
	   4/03/92  deanb   HorizScan On/Off coded
	   3/31/92  deanb   InitScanArray begun
	   3/25/92  deanb   GetWorkSizes and local types
	   3/23/92  deanb   First cut

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#in