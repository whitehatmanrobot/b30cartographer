flineFolderEnum::EnsureMalloc()
{
    if (NULL == s_pMalloc)
    {
        SHGetMalloc(&s_pMalloc);
    }

    ASSERT(NULL != s_pMalloc);
}


COfflineFolderEnum::~COfflineFolderEnum()
{
    ASSERT(m_cRef == 0);         // we should always have a zero ref count here

    SAFERELEASE(m_pFolder);
    SAFEDELETE(m_pCookies);

    TraceMsg(TF_SUBSFOLDER, "hcfe - ~COfflineFolderEnum() called.");
    DllRelease();
}

HRESULT COfflineFolderEnum::Initialize(COfflineFolder *pFolder)
{
    HRESULT hr = S_OK;

    ASSERT(pFolder);
    
    if (NULL != pFolder)
    {
        m_pFolder = pFolder;
        m_pFolder->AddRef();

        hr = CoInitialize(NULL);

        if (SUCCEEDED(hr))
        {
            ISubscriptionMgr2 *pSubsMgr2;
            hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, 
                                  IID_ISubscriptionMgr2, (void **)&pSubsMgr2);
            if (SUCCEEDED(hr))
            {
                IEnumSubscription *pes;

                hr = pSubsMgr2->EnumSubscriptions(0, &pes);
                if (SUCCEEDED(hr))
                {
                    pes->GetCount(&m_nCount);

                    if (m_nCount > 0)
                    {
                        m_pCookies = new SUBSCRIPTIONCOOKIE[m_nCount];

                        if (NULL != m_pCookies)
                        {
                            hr = pes->Next(m_nCount, m_pCookies, &m_nCount);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    pes->Release();
                }
                pSubsMgr2->Release();
            }

            CoUninitialize();
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    
    return hr;
}

HRESULT COfflineFolderEnum_CreateInstance(DWORD grfFlags, COfflineFolder *pFolder, 
                                          LPENUMIDLIST *ppeidl)
{
    HRESULT hr;

    *ppeidl = NULL;

    COfflineFolderEnum *pOOFE = new COfflineFolderEnum(grfFlags);
    
    if (NULL != pOOFE)
    {
        hr = pOOFE->Initialize(pFolder);

        if (SUCCEEDED(hr))
        {
            *ppeidl = pOOFE;
        }
        else
        {
            pOOFE->Release();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}


//////////////////////////////////
//
// IUnknown Methods...
//

HRESULT COfflineFolderEnum::QueryInterface(REFIID iid,void **ppv)
{
//    TraceMsg(TF_SUBSFOLDER, "COfflineFolderEnum - QI called.");
    
    if ((iid == IID_IEnumIDList) || (iid == IID_IUnknown))
    {
        *ppv = (IEnumIDList *)this;
        AddRef();
        return S_OK;
    }
    
    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG COfflineFolderEnum::AddRef(void)
{
    return ++m_cRef;
}

ULONG COfflineFolderEnum::Release(void)
{
    if (0L != --m_cRef)
        return m_cRef;

    delete this;
    return 0;
}

LPMYPIDL COfflineFolderEnum::NewPidl(DWORD dwSize)
{
    LPMYPIDL pidl;

//  TraceMsg(TF_MEMORY, "NewPidl called");

    EnsureMalloc();

    pidl = _CreateFolderPidl(s_pMalloc, dwSize);

//  TraceMsg(TF_MEMORY, "\tNewPidl returned with 0x%x", pidl);

    return pidl;
}

void COfflineFolderEnum::FreePidl(LPMYPIDL pidl)
{
    ASSERT(NULL != pidl);

//  TraceMsg(TF_MEMORY, "FreePidl on (0x%x) called", pidl);

    EnsureMalloc();

    s_pMalloc->Free(pidl);
}

// IEnumIDList Methods 

HRESULT COfflineFolderEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    ULONG nCopied;
    DWORD dwBuffSize;
    OOEBuf ooeBuf;

    if ((0 == celt) || 
        ((celt > 1) && (NULL == pceltFetched)) ||
        (NULL == rgelt))
    {
        return E_INVALIDARG;
    }

    memset(&ooeBuf, 0, sizeof(ooeBuf));

    for (nCopied = 0; (S_OK == hr) && (m_nCurrent < m_nCount) && (nCopied < celt); 
         m_nCurrent++, nCopied++)
    {
        rgelt[nCopied] = NULL;
        hr = LoadOOEntryInfo(&ooeBuf, &m_pCookies[m_nCurrent], &dwBuffSize);

        if (SUCCEEDED(hr))
        {
            if (IsNativeAgent(ooeBuf.clsidDest))
            {
                CLSID   cookie;
                HRESULT hrTmp = ReadCookieFromInetDB(ooeBuf.m_URL, &cookie);
                if (S_OK != hrTmp)
                {
                    hrTmp = WriteCookieToInetDB(ooeBuf.m_URL,&(ooeBuf.m_Cookie), FALSE);
                    ASSERT(SUCCEEDED(hrTmp));
                }
            }

            LPMYPIDL pooi = NewPidl(dwBuffSize);
            if (pooi)
            {
                CopyToMyPooe(&ooeBuf, &(pooi->ooe));  //  Always succeeds!
                rgelt[nCopied] = (LPITEMIDLIST)pooi;
            }
            else 
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = (celt == nCopied) ? S_OK : S_FALSE;
    }
    else
    {
        for (ULONG i = 0; i < nCopied; i++)
        {
            FreePidl((LPMYPIDL)rgelt[i]);
        }
    }

    if (NULL != pceltFetched)
    {
        *pceltFetched = SUCCEEDED(hr) ? nCopied : 0;
    }
    
    return hr;
}

HRESULT COfflineFolderEnum::Skip(ULONG celt)
{
    HRESULT hr;
    
    m_nCurrent += celt;

    if (m_nCurrent > (m_nCount - 1))
    {
        m_nCurrent = m_nCount;  //  Passed the last one
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }
    
    return hr;
}

HRESULT COfflineFolderEnum::Reset()
{
    m_nCurrent = 0;

    return S_OK;
}

HRESULT COfflineFolderEnum::Clone(IEnumIDList **ppenum)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////////
//
// COfflineFolder Object
//
//////////////////////////////////////////////////////////////////////////////

COfflineFolder::COfflineFolder(void) 
{
    TraceMsg(TF_SUBSFOLDER, "Folder - COfflineFolder() called.");
    _cRef = 1;
    viewMode = 0;
    colInfo = s_AllItems_cols;
    DllAddRef();
}       

COfflineFolder::~COfflineFolder()
{
    Assert(_cRef == 0);                 // should always have zero
    TraceMsg(TF_SUBSFOLDER, "Folder - ~COfflineFolder() called.");

    if (_pidl)
        ILFree(_pidl);
        
    DllRelease();
}    

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT COfflineFolder::QueryInterface(REFIID iid, void **ppvObj)
{
    *ppvObj = NULL;     // null the out param
    
    if (iid == IID_IUnknown) {
         *ppvObj = (void *)this;
    }
    else if (iid == IID_IShellFolder) {
         *ppvObj = (void *)(IShellFolder *)this;
    }
    else if ((iid == IID_IPersistFolder) || (iid == IID_IPersist) || (iid == IID_IPersistFolder2)) {
         *ppvObj = (void *)(IPersistFolder *)this;
    }
    else if (iid == IID_IContextMenu)
    {
         *ppvObj = (void *)(IContextMenu *)this;
    }
    else if (iid == IID_IShellView)
    {
         return OfflineFolderView_CreateInstance(this, _pidl, ppvObj);
    }
    else if (iid == IID_IOfflineObject)
    {
         *ppvObj = (void *)this;
    }
    else if (iid == IID_IDropTarget)
    {
        // APPCOMPAT: Implementation of IDropTarget didn't follow the COM rules.
        //  We create following object by aggregattion but QI on it for IUnknown
        //  won't get us ptr THIS.
        COfflineDropTarget * podt = new COfflineDropTarget(GetDesktopWindow());
        if (podt)
        {
            HRESULT hr = podt->QueryInterface(iid, ppvObj);
            podt->Release();
        }
        else
        {
            return E_OUTOFMEMORY;
        }     
    }

    if (*ppvObj) 
    {
        ((IUnknown *)*ppvObj)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

ULONG COfflineFolder::AddRef()
{
    return ++_cRef;
}

ULONG COfflineFolder::Release()
{
    if (0L != --_cRef)
        return _cRef;

    delete this;
    return 0;   
}

//////////////////////////////////
//
// IShellFolder methods...
//
HRESULT COfflineFolder::ParseDisplayName(HWND hwndOwner, LPBC pbcReserved,
                        LPOLESTR lpszDisplayName, ULONG *pchEaten,
                        LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - ParseDisplayName.");
    *ppidl = NULL;
    return E_FAIL;
}


HRESULT COfflineFolder::EnumObjects(HWND hwndOwner, DWORD grfFlags,
                        LPENUMIDLIST *ppenumIDList)
{
//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - EnumObjects.");
    return COfflineFolderEnum_CreateInstance(grfFlags, this, ppenumIDList);
}


HRESULT COfflineFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
                        REFIID riid, void **ppvOut)
{
//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - BindToObject.");
    *ppvOut = NULL;
    return E_FAIL;
}

HRESULT COfflineFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
                        REFIID riid, void **ppvObj)
{
//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - BindToStorage.");
    *ppvObj = NULL;
    return E_NOTIMPL;
}

HRESULT COfflineFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRet;

//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - CompareIDs(%d).", lParam);

    if (!IS_VALID_MYPIDL(pidl1) || !IS_VALID_MYPIDL(pidl2))
        return E_FAIL;

    switch (lParam) {
        case ICOLC_SHORTNAME:
            iRet = _CompareShortName((LPMYPIDL)pidl1, (LPMYPIDL)pidl2);
            break;
        case ICOLC_URL:
            iRet = _CompareURL((LPMYPIDL)pidl1, (LPMYPIDL)pidl2);
            break;
        case ICOLC_STATUS:
            iRet = _CompareStatus((LPMYPIDL)pidl1, (LPMYPIDL)pidl2);
            break;
        case ICOLC_LAST:
            iRet = _CompareLastUpdate((LPMYPIDL)pidl1, (LPMYPIDL)pidl2);
            break;
        case ICOLC_ACTUALSIZE:
            iRet = (((LPMYPIDL)pidl1)->ooe.m_ActualSize - ((LPMYPIDL)pidl2)->ooe.m_ActualSize);
            break;
        default:
            iRet = -1;
            break;
    }
    return ResultFromShort((SHORT)iRet);
}


HRESULT COfflineFolder::CreateViewObject(HWND hwndOwner, REFIID riid, void **ppvOut)
{
    HRESULT hres;

//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - CreateViewObject() called.");

    if (riid == IID_IShellView)
    {
        hres = OfflineFolderView_CreateInstance(this, _pidl, ppvOut);
    }
    else if (riid == IID_IContextMenu)
    {
        COfflineFolder * pof = new COfflineFolder();

        if (pof)
        {
            hres = pof->Initialize(this->_pidl);
            if (SUCCEEDED(hres))
                hres = pof->QueryInterface(riid, ppvOut);
            pof->Release();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else if (riid == IID_IDropTarget)
    {
        COfflineDropTarget * podt = new COfflineDropTarget(hwndOwner);

        if (podt)
        {
            hres = podt->QueryInterface(riid, ppvOut);
            podt->Release();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else if (riid == IID_IShellDetails)
    {
        COfflineDetails *pod = new COfflineDetails(hwndOwner);
        if (NULL != pod)
        {
            hres = pod->QueryInterface(IID_IShellDetails, ppvOut);
            pod->Release();
        }
        else
        {
            hres = E_OUTOFMEMORY;
        }
    }
    else
    {
        DBGIID("COfflineFolder::CreateViewObject() failed", riid);
        *ppvOut = NULL;         // null the out param
        hres = E_NOINTERFACE;
    }
    
    return hres;    
}

HRESULT COfflineFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                        ULONG * prgfInOut)
{
    // Should we initialize this for each item in here?  In other words,
    // if cidl > 1, then we should initialize each entry in the prgInOut array
    Assert( cidl == 1 );
    
    UINT    attr = SFGAO_CANCOPY | SFGAO_CANDELETE | SFGAO_CANRENAME |
                    SFGAO_HASPROPSHEET;
    *prgfInOut = attr;
    
    return NOERROR;
}

HRESULT COfflineFolder::GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                        REFIID riid, UINT * prgfInOut, void **ppvOut)
{
    HRESULT hres;

//    TraceMsg(TF_SUBSFOLDER, "Folder:ISF - GetUIObjectOf.");
    if ((riid == IID_IContextMenu) || (riid == IID_IDataObject) || 
        (riid == IID_IExtractIcon) || (riid == IID_IQueryInfo))
    {
        hres = COfflineObjectItem_CreateInstance(this, cidl, apidl, riid, ppvOut);
    }
    else if (riid == IID_IDropTarget)
    {
        hres = CreateViewObject(hwndOwner, IID_IDropTarget, ppvOut);
    }
    else 
    {
        *ppvOut = NULL;
        hres = E_FAIL;
        DBGIID("Unsupported interface in COfflineFolder::GetUIObjectOf()", riid);
    }
    return hres;    
}

HRESULT COfflineFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
{
//    TraceMsg(TF_SUBSFOLDER, "Folde:ISF - GetDisplayNameOf.");
    
    if (!IS_VALID_MYPIDL(pidl))
    {
        lpName->uType = 0;
        return E_FAIL;
    }

    lpName->uType = STRRET_CSTR;
    lpName->cStr[0] = '\0';

    PCTSTR pszNameLocal;
    LPTSTR szNameUnaligned = NAME(&(((LPMYPIDL)pidl)->ooe));

    TSTR_ALIGNED_STACK_COPY( &pszNameLocal, szNameUnaligned );

    SHTCharToAnsi( pszNameLocal, lpName->cStr, ARRAYSIZE(lpName->cStr) );

    TraceMsg(TF_ALWAYS, "COfflineFolder::GetDisplayNameOf() - pszNameLocal='%s'", pszNameLocal );

    TraceMsg(TF_ALWAYS, "COfflineFolder::GetDisplayNameOf() - lpName->cStr='%S'", lpName->cStr );

    return NOERROR;    
}

HRESULT COfflineFolder::SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                        LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST * ppidlOut)
{
    OOEBuf  ooeBuf;
    POOEntry    pooe = NULL;
//    TraceMsg(TF_SUBSFOLDER, "Folde:ISF - SetNameOf.");
    
    if (ppidlOut)  {
        *ppidlOut = NULL;               // null the out param
    }

    if (!IS_VALID_MYPIDL(pidl))
        return E_FAIL;

    HRESULT hr;
    WCHAR szTempName[MAX_PATH];

    ASSERT(lpszName);

    StrCpyNW(szTempName, lpszName, ARRAYSIZE(szTempName));

    PathRemoveBlanks(szTempName);

    if (szTempName[0])
    {   
        memset(&ooeBuf, 0, sizeof(ooeBuf));

        pooe = &(((LPMYPIDL)pidl)->ooe);
        CopyToOOEBuf(pooe, &ooeBuf);
        MyOleStrToStrN(ooeBuf.m_Name, MAX_NAME, szTempName);

        ooeBuf.dwFlags = PROP_WEBCRAWL_NAME;
        hr = SaveBufferChange(&ooeBuf, FALSE);
        
        if (ppidlOut)   {
            DWORD   dwSize = BufferSize(&ooeBuf);
            *ppidlOut = (LPITEMIDLIST)COfflineFolderEnum::NewPidl(dwSize);
            if (*ppidlOut)  {
                pooe = &(((LPMYPIDL)(*ppidlOut))->ooe);
                CopyToMyPooe(&ooeBuf, pooe);
            }
        }
    }
    else
    {
        WCMessageBox(hwndOwner, IDS_NONULLNAME, IDS_RENAME, MB_OK | MB_ICONSTOP);
        hr = E_FAIL;
    }
    return hr;    
}

//////////////////////////////////
//
// IPersistFolder Methods...
//
HRESULT COfflineFolder::GetClassID(LPCLSID lpClassID)
{
//    TraceMsg(TF_SUBSFOLDER, "hcf - pf - GetClassID.");
    
    *lpClassID = CLSID_OfflineFolder;
    return S_OK;
}


HRESULT COfflineFolder::Initialize(LPCITEMIDLIST pidlInit)
{
    if (_pidl)
        ILFree(_pidl);

    _pidl = ILClone(pidlInit);

    if (!_pidl)
        return E_OUTOFMEMORY;

    return NOERROR;
}

HRESULT COfflineFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    if (_pidl)
    {
        *ppidl = ILClone(_pidl);
        return *ppidl ? NOERROR : E_OUTOFMEMORY;
    }

    *ppidl = NULL;      
    return S_FALSE; // success but empty
}

//////////////////////////////////
//
// IContextMenu Methods...
//
HRESULT COfflineFolder::QueryContextMenu
(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst,
    UINT idCmdLast, 
    UINT uFlags)
{
    USHORT cItems = 0;

//    TraceMsg(TF_SUBSFOLDER, "Folder:IContextMenu- QueryContextMenu.");
    if (uFlags == CMF_NORMAL)
    {
        HMENU hmenuHist = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(CONTEXT_MENU_OFFLINE));
        if (hmenuHist)
        {
            cItems = (USHORT) MergeMenuHierarchy(hmenu, hmenuHist, idCmdFirst, idCmdLast, TRUE);

            DestroyMenu(hmenuHist);
        }
    }
    
    return ResultFromShort(cItems);    // number of menu items    
}

STDMETHODIMP COfflineFolder::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
//    TraceMsg(TF_SUBSFOLDER, "Folder:IContextMenu - InvokeCommand.");
    
    int idCmd = _GetCmdID(pici->lpVerb);
    
    if (idCmd != RSVIDM_PASTE)
        return OfflineFolderView_Command(pici->hwnd, idCmd);
     
    IDataObject * dataSrc = NULL;
    IDropTarget * pDropTrgt = NULL;
    HRESULT hr;

    hr = OleGetClipboard(&(dataSrc));

    if (SUCCEEDED(hr))
        hr = this->QueryInterface(IID_IDropTarget, (void **) &pDropTrgt);

    if (SUCCEEDED(hr))  {
        DWORD dwPrefEffect = DROPEFFECT_COPY;
        POINTL pt = {0, 0};

        hr = pDropTrgt->DragEnter(dataSrc, 0/*keystate*/, pt, &dwPrefEffect);
        if (SUCCEEDED(hr))  {
            hr = pDropTrgt->Drop(dataSrc, 0, pt, &dwPrefEffect);
        }
    }

    if (dataSrc)
        SAFERELEASE(dataSrc);
    if (pDropTrgt)
        SAFERELEASE(pDropTrgt);

    return hr;
}

STDMETHODIMP COfflineFolder::GetCommandString(UINT_PTR idCmd, UINT uFlags, UINT *pwReserved,
                                LPSTR pszName, UINT cchMax)
{
    HRESULT hres = E_FAIL;

//    TraceMsg(TF_SUBSFOLDER, "Folder:IContextMenu - GetCommandString.");
    if (uFlags == GCS_HELPTEXTA)
    {
        MLLoadStringA((UINT)idCmd + IDS_SB_FIRST, pszName, cchMax);
        hres = NOERROR;
    }
    return hres;
}

COfflineDetails::COfflineDetails(HWND hwndOwner)
{
    ASSERT(NULL != hwndOwner);
    m_hwndOwner = hwndOwner;
    m_cRef = 1;
}

STDMETHODIMP COfflineDetails::QueryInterface(REFIID riid, void **ppv)
{
    if ((IID_IUnknown == riid) || (IID_IShellDetails == riid))
    {
        *ppv = (IShellDetails *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) COfflineDetails::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) COfflineDetails::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP COfflineDetails::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetails)
{
    HRESULT hr;

    if (iColumn > ICOLC_ACTUALSIZE)
        return E_NOTIMPL;

    if (NULL == pDetails)
    {
        return E_INVALIDARG;
    }
    
    if (NULL != pidl)
    {
        DETAILSINFO di = { pidl };
        hr = Generic_GetDetails(&di, colInfo[iColumn].iCol);
        pDetails->fmt = di.fmt;
        pDetails->cxChar = di.cxChar;
        memcpy(&pDetails->str, &di.str, sizeof(di.str));
    }
    else
    {
        pDetails->str.uType = STRRET_CSTR;
        pDetails->str.cStr[0] = '\0';
        MLLoadStringA(colInfo[iColumn].ids, pDetails->str.cStr, sizeof(pDetails->str.cStr));
        pDetails->fmt = colInfo[iColumn].iFmt;
        pDetails->cxChar = colInfo[iColumn].cchCol;
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP COfflineDetails::ColumnClick(UINT iColumn)
{
    ShellFolderView_ReArrange(m_hwndOwner, colInfo[iColumn].iCol);
    return S_OK;
}


LPMYPIDL _CreateFolderPidl(IMalloc *pmalloc, DWORD dwSize)
{
    LPMYPIDL pooi = (LPMYPIDL)pmalloc->Alloc(sizeof(MYPIDL) + dwSize + sizeof(USHORT));
    if (pooi)
    {
        memset(pooi, 0, sizeof(MYPIDL) + dwSize + sizeof(USHORT));
        pooi->cb = (USHORT)(dwSize + sizeof(MYPIDL));
        pooi->usSign = (USHORT)MYPIDL_MAGIC;
//      TraceMsg(TF_MEMORY, "CreatePidl %d", sizeof(MYPIDL) + dwSize);
    }
    return pooi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\downld.h ===
#ifndef __DOWNLD_H
#define __DOWNLD_H

#include <mshtmdid.h>

#define URLDL_WNDCLASS  TEXT("WCUrlDlClass")

class CUrlDownload_BSC;

#define ACCEPT_LANG_MAX     256

// Options for BeginDownloadURL2
typedef enum {
    BDU2_BROWSER,    // always download into the browser
    BDU2_URLMON,     // always download with urlmon only
    BDU2_SMART,      // browser if HTML; aggressive guessing
    BDU2_SNIFF,      // browser if HTML; no guessing (urlmon then browser)
    BDU2_HEADONLY,   // get HEAD info only (including Last-Modified time)
} BDUMethod;

typedef DWORD BDUOptions;

// BDUOptions
#define BDU2_NONE                       0
#define BDU2_NEEDSTREAM                 1   // keep an istream around from bdu2_urlmon download
#define BDU2_DOWNLOADNOTIFY_REQUIRED    2   // require IDownloadNotify callbacks for MSHTML
#define BDU2_FAIL_IF_NOT_HTML           4   // only download if url is html (can't use w/BDU2_BROWSER)

// OnDownloadComplete error codes
#define BDU2_ERROR_NONE         0
#define BDU2_ERROR_GENERAL      1
#define BDU2_ERROR_ABORT        2
#define BDU2_ERROR_MAXSIZE      3
#define BDU2_ERROR_TIMEOUT      4
#define BDU2_ERROR_NOT_HTML     5


// CUrlDowload hosts one browser and can handle one download at a time.
//
// CUrlDownloadSink is defined in private.h
//
// Use of class CUrlDownload:
//
// 1) Create and AddRef it
// 1.5) call put_Flags() to set the bind status callback IBrowseControl::Flags
// 2) Call BeginDownloadURL2 to start a download
// 3) Retrieve notifications through CUrlDownloadSink
// 4) Call BeginDownloadURL2 to start another download, reusing browser
// 5) Call DoneDownloading() when finished
// 6) Release()

// DoneDownloading() MUST be called before Release() or the CUrlDownload instance may
//  continue to receive notifications from the browser and attempt to pass them to
//  the parent. It unhooks itself as soon as OnProgress(-1) is received. But be safe.

// AbortDownload() may cause DownloadComplete(TRUE) notification
//   to be sent to the CUrlDownloadSink

// See webcrawl.h and webcrawl.cpp for example
class CUrlDownload :  public IOleClientSite         // e_notimpl
                    , public IPropertyNotifySink    // for readystate change notifications
                    , public IOleCommandTarget      // for client pull callbacks
                    , public IDispatch              // for ambient properties
                    , public IServiceProvider       // for IAuthenticate and IHlinkFrame
                    , public IAuthenticate          // for Basic and NTLM authentication
                    , public IHlinkFrame            // for catching the post of a form
                    , public IInternetSecurityManager // for allowing the post of a form
                    , public IHttpSecurity          // for OnSecurityProblem
{
    friend CUrlDownload_BSC;
    
private:
    ~CUrlDownload();

public:
    CUrlDownload(CUrlDownloadSink *pParent, UINT iID=0);

    void LeaveMeAlone() { m_pParent=NULL; }

    void SetFormSubmitted(BOOL fFormSubmitted) { m_fFormSubmitted = fFormSubmitted; StartTimer(); }
    BOOL GetFormSubmitted(void) { return m_fFormSubmitted; }

    // An E_ return code from this function may be ignored if desired. The
    //  client's OnDownloadComplete will be called with fAborted==TRUE after this
    //  function returns with an error value.
    HRESULT BeginDownloadURL2(LPCWSTR, BDUMethod, BDUOptions, LPTSTR, DWORD);

    HRESULT SetDLCTL(long lFlags);  // DLCTL flags used for browser control

    HRESULT AbortDownload(int iErrorCode=-1);   // S_OK, S_FALSE, E_FAIL

    HRESULT GetRealURL(LPWSTR *ppwszURL);   // Gets URL accounting for any and all redirections (MemFree)

    HRESULT GetScript(IHTMLWindow2 **pWin);    // Will cache an *additional* reference internally
    void    ReleaseScript() { SAFERELEASE(m_pScript); } // Releases internal reference

    HRESULT GetDocument(IHTMLDocument2 **ppDoc);

    HRESULT GetStream(IStream **ppStm); // Only if BDU2_NEEDSTREAM was specified
    void    ReleaseStream() { SAFERELEASE(m_pStm); } // Release our internal reference

    HRESULT GetLastModified(SYSTEMTIME *pstLastModified);   // Only if BDU2_HEADONLY was used
    HRESULT GetResponseCode(DWORD *pdwResponseCode);

    void    DoneDownloading();  // Call before releasing. Will destroy browser and windows.
    void    DestroyBrowser();   // Destroy hosted browser, leave all else alone

    LPCWSTR GetUserAgent();     // Get our webcrawler user-agent string

    // URL manipulation functions
static HRESULT StripAnchor(LPWSTR lpURL);
static BOOL IsHtmlUrl(LPCWSTR lpURL); // TRUE (yes) or FALSE (don't know)
static BOOL IsNonHtmlUrl(LPCWSTR lpURL); // TRUE (yes) or FALSE (don't know)
static BOOL IsValidURL(LPCWSTR lpURL);  // TRUE (get it) or FALSE (skip it)

    // Should only be called from CUrlDownloadMsgProc
    BOOL HandleMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //      IDispatch (ambient properties)
    STDMETHODIMP         GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP         GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP         GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames,
                                LCID lcid, DISPID *rgdispid);
    STDMETHODIMP         Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                                DISPPARAMS *pdispparams, VARIANT *pvarResult,
                                EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // IOleClientSite
    STDMETHODIMP        SaveObject(void);
    STDMETHODIMP        GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
    STDMETHODIMP        GetContainer(IOleContainer **ppContainer);
    STDMETHODIMP        ShowObject(void);
    STDMETHODIMP        OnShowWindow(BOOL fShow);
    STDMETHODIMP        RequestNewObjectLayout(void);

    // IPropertyNotifySink
    STDMETHODIMP        OnChanged(DISPID dispID);
    STDMETHODIMP        OnRequestEdit(DISPID dispID);

    // IOleCommandTarget
    STDMETHODIMP         QueryStatus(const GUID *pguidCmdGroup,
                                     ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHODIMP         Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                              DWORD nCmdexecopt, VARIANTARG *pvaIn,
                              VARIANTARG *pvaOut);

    // IServiceProvider
    STDMETHODIMP        QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

    // IAuthenticate
    STDMETHODIMP        Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword);
    
    // IHlinkFrame
    STDMETHODIMP        SetBrowseContext(IHlinkBrowseContext *pihlbc);
    STDMETHODIMP        GetBrowseContext(IHlinkBrowseContext **ppihlbc);
    STDMETHODIMP        Navigate(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, IHlink *pihlNavigate);
    STDMETHODIMP        OnNavigate(DWORD grfHLNF, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName, DWORD dwreserved);
    STDMETHODIMP        UpdateHlink(ULONG uHLID, IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName);

    // IInternetSecurityManager
    STDMETHODIMP        SetSecuritySite(IInternetSecurityMgrSite *pSite);
    STDMETHODIMP        GetSecuritySite(IInternetSecurityMgrSite **ppSite);
    STDMETHODIMP        MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags);
    STDMETHODIMP        GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved);
    STDMETHODIMP        ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
    STDMETHODIMP        QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved);
    STDMETHODIMP        SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags);
    STDMETHODIMP        GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags);

    // IHttpSecurity
    STDMETHODIMP        GetWindow(REFGUID rguidReason, HWND *phwnd);
    STDMETHODIMP        OnSecurityProblem(DWORD dwProblem);


protected:
    // main object stuff
    ULONG               m_cRef;
    UINT                m_iID;          // our ID for callbacks
    CUrlDownloadSink    *m_pParent;     // to pass on WebBrowserEvents
    HWND                m_hwndMe;
    UINT                m_nTimeout;     // Max timeout between notifications (seconds)

    // GetBrowser/CleanUpBrowser (browser download data)
    IPersistMoniker     *m_pPersistMk;
    IHTMLDocument2      *m_pDocument;
    IOleCommandTarget   *m_pOleCmdTarget;
    BOOL                m_fWaitingForReadyState;
    BOOL                m_fFormSubmitted;
    IConnectionPoint    *m_pCP;         // connection point for DIID_DWebBrowserEvents
    BOOL                m_fAdviseOn;    // our sink is hooked up? (ConnectionCookie valid)
    DWORD               m_dwConnectionCookie;
    BOOL                m_fBrowserValid;    // Browser pointing to 'current' URL?

    // UrlMon download data
    CUrlDownload_BSC    *m_pCbsc;
    BOOL                m_fbscValid;    // pCbsc alive for 'current' URL?
    IStream             *m_pStm;
    SYSTEMTIME          *m_pstLastModified;     // Last Modified time
    DWORD               m_dwResponseCode;
    WCHAR               m_achLang[ACCEPT_LANG_MAX];
    UINT                m_iLangStatus;  // 0=uninit, 1=init, 2=failed
    HRESULT             m_hrStatus;

    // General download data
    BDUMethod           m_iMethod;
    BDUOptions          m_iOptions;
    UINT_PTR            m_iTimerID;
    LPWSTR              m_pwszURL;      // gives us the current url after redirections
    BOOL                m_fSetResync;   // need RESYNCHRONIZE?
    DWORD               m_dwMaxSize;    // in bytes
    LPWSTR              m_pwszUserAgent;

    // IBrowseControl
    long                m_lBindFlags;

    // allow caching GetScript calls
    IHTMLWindow2        *m_pScript;

    // Client pull
    LPWSTR              m_pwszClientPullURL;
    int                 m_iNumClientPull;

    // methods that our bindstatuscallback calls back
    void        BSC_OnStopBinding(HRESULT hrStatus, IStream *pStm);
    void        BSC_OnStartBinding();
    void        BSC_OnProgress(ULONG ulProgress, ULONG ulProgressMax);
    void        BSC_FoundLastModified(SYSTEMTIME *pstLastModified);
    void        BSC_FoundMimeType(CLIPFORMAT cf);

    // other internal stuff
    HRESULT     CreateMyWindow();
    HRESULT     GetBrowser();   // Get browser and set us on connection point
    void        UnAdviseMe();   // Unhook our advise sink

    void        CleanUpBrowser();
    void        CleanUp();      // Clean up, including releasing browser

    void        StartTimer();    // for 60 second timeout
    void        StopTimer();

    LPCWSTR     GetAcceptLanguages();   // NULL if failed

    HRESULT     BeginDownloadWithUrlMon(LPCWSTR, LPTSTR, IEnumFORMATETC *);
    HRESULT     BeginDownloadWithBrowser(LPCWSTR);

    HRESULT     HandleRefresh(LPWSTR pwszEquivString, LPWSTR pwszContent, BOOL fDone);

    HRESULT     OnDownloadComplete(int iError);     // cancel timeout, send OnDownloadComplete

    HRESULT     ProgressBytes(DWORD dwBytes);       // Will abort if too many
};

class CUrlDownload_BSC :    public IBindStatusCallback,
                            public IHttpNegotiate,        // To set User-Agent
                            public IAuthenticate          // for Basic and NTLM authentication
{
public:
    // IUnknown methods
    STDMETHODIMP    QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; }
    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; }

    // IBindStatusCallback methods
    STDMETHODIMP    OnStartBinding(DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                        STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // IHttpNegotiate methods
    STDMETHODIMP    BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
                        DWORD dwReserved, LPWSTR *pszAdditionalHeaders);
    
    STDMETHODIMP    OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
                        LPCWSTR szRequestHeaders, LPWSTR *pszAdditionalRequestHeaders);
        
    // IAuthenticate methods
    STDMETHODIMP        Authenticate(HWND *phwnd, LPWSTR *pszUsername, LPWSTR *pszPassword);
    


    // constructors/destructors
    CUrlDownload_BSC(BDUMethod, BDUOptions, LPTSTR);
    ~CUrlDownload_BSC();

    // other methods
    HRESULT         Abort();
    void            SetParent(CUrlDownload *pUrlDownload);

    // data members
protected:
    DWORD           m_cRef;
    IBinding*       m_pBinding;
    IStream*        m_pstm;
    LPTSTR          m_pszLocalFileDest;
    LPWSTR          m_pwszLocalFileSrc;
    BDUMethod       m_iMethod;
    BDUOptions      m_iOptions;
    BOOL            m_fSentMimeType;
    CUrlDownload    *m_pParent;
    BOOL            m_fTriedAuthenticate;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\helper.h ===
#ifndef __helper_h
#define __helper_h

#define TrimWhiteSpaceW(psz)        StrTrimW(psz, L" \t")
#define TrimWhiteSpaceA(psz)        StrTrimA(psz, " \t")

#ifdef UNICODE
#define TrimWhiteSpace      TrimWhiteSpaceW
#else
#define TrimWhiteSpace      TrimWhiteSpaceA
#endif

HRESULT LoadWithCookie(LPCTSTR url, POOEBuf pBuf, DWORD * pdwBufferSize, SUBSCRIPTIONCOOKIE * pcookie);
HRESULT GetDefaultOOEBuf(OOEBuf * pBuf, SUBSCRIPTIONTYPE subType);

HICON LoadItemIcon(ISubscriptionItem *psi, BOOL bLarge);

BOOL HandleScheduleNameConflict(TCHAR *pszSchedName, SYNCSCHEDULECOOKIE *pSchedCookie);
HRESULT RemoveItemFromAllSchedules(SUBSCRIPTIONCOOKIE *pCookie);

HRESULT AddRemoveScheduledItem(SYNC_HANDLER_ITEM_INFO *pSyncHandlerItemInfo, // For Add
                               SUBSCRIPTIONCOOKIE *pCookie,                  // For Remove
                               SYNCSCHEDULECOOKIE *pSchedCookie, BOOL bAdd);

inline HRESULT AddScheduledItem(SYNC_HANDLER_ITEM_INFO *pSyncHandlerItemInfo, 
                                SYNCSCHEDULECOOKIE *pSchedCookie)
{
    return AddRemoveScheduledItem(pSyncHandlerItemInfo, NULL, pSchedCookie, TRUE);
}

inline HRESULT RemoveScheduledItem(SUBSCRIPTIONCOOKIE *pCookie, 
                                  SYNCSCHEDULECOOKIE *pSchedCookie)
{
    return AddRemoveScheduledItem(NULL, pCookie, pSchedCookie, FALSE);
}

HRESULT CreateSchedule(LPWSTR pwszScheduleName, DWORD dwSyncScheduleFlags, 
                       SYNCSCHEDULECOOKIE *pSchedCookie, TASK_TRIGGER *pTrigger,
                       BOOL fDupCookieOK);

BOOL IsCookieOnSchedule(ISyncSchedule *pSyncSchedule, SUBSCRIPTIONCOOKIE *pCookie);

typedef BOOL (CALLBACK * SCHEDULEENUMCALLBACK)(ISyncSchedule *pSyncSchedule, 
                                               SYNCSCHEDULECOOKIE *pSchedCookie,
                                               LPARAM lParam);
HRESULT EnumSchedules(SCHEDULEENUMCALLBACK pCallback, LPARAM lParam);

BOOL ScheduleCookieExists(SYNCSCHEDULECOOKIE *pSchedCookie);

void SetPropSheetFlags(POOEBuf pBuf, BOOL bSet, DWORD dwPropSheetFlags);
int KeepSpinNumberInRange(HWND hdlg, int idEdit, int idSpin, int minVal, int maxVal);

HRESULT GetItemSchedule(SUBSCRIPTIONCOOKIE *pSubsCookie, SYNCSCHEDULECOOKIE *pSchedCookie);

enum { CONFLICT_NONE, 
       CONFLICT_RESOLVED_USE_NEW, 
       CONFLICT_RESOLVED_USE_OLD, 
       CONFLICT_UNRESOLVED,
       CONFLICT_EMPTY};

int HandleScheduleNameConflict(/* in  */ TCHAR *pszSchedName, 
                               /* in  */ TASK_TRIGGER *pTrigger,
                               /* in  */ HWND hwndParent,
                               /* out */ SYNCSCHEDULECOOKIE *pSchedCookie);

HRESULT UpdateScheduleTrigger(SYNCSCHEDULECOOKIE *pSchedCookie, TASK_TRIGGER *pTrigger);

HRESULT ScheduleIt(ISubscriptionItem *psi, TCHAR *pszName, TASK_TRIGGER *pTrigger);

void CreatePublisherScheduleNameW(WCHAR *pwszSchedName, int cchSchedName, 
                                  const TCHAR *pszName, const WCHAR *pwszName);

void CreatePublisherScheduleName(TCHAR *pszSchedName, int cchSchedName, 
                                 const TCHAR *pszName, const WCHAR *pwszName);

#ifdef NEWSCHED_AUTONAME
void NewSched_AutoNameHelper(HWND hDlg);
#endif

BOOL NewSched_ResolveNameConflictHelper(HWND hDlg, TASK_TRIGGER *pTrig, 
                                        SYNCSCHEDULECOOKIE *pSchedCookie);
void NewSched_CreateScheduleHelper(HWND hDlg, TASK_TRIGGER *pTrig,
                                   SYNCSCHEDULECOOKIE *pSchedCookie);

void NewSched_OnInitDialogHelper(HWND hDlg);

class CWaitCursor
{
    HCURSOR hPrevCursor;
public:
    CWaitCursor()
    {
        hPrevCursor = SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
    };
    
    ~CWaitCursor()
    {
        if (hPrevCursor)
            SetCursor(hPrevCursor);
    }
};

#endif //__helper_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\helper.cpp ===
#include "private.h"
#include "offl_cpp.h"
#include "subsmgrp.h"
#include "helper.h"

#include <mluisupp.h>

#ifdef DEBUG
void    DumpTaskTrigger(TASK_TRIGGER * pTaskTrigger);
#endif  // DEBUG

// {D994B6F0-DA3C-11d1-857D-00C04FA35C89}
const GUID NOOP_SCHEDULE_COOKIE =
{ 0xd994b6f0, 0xda3c, 0x11d1, { 0x85, 0x7d, 0x0, 0xc0, 0x4f, 0xa3, 0x5c, 0x89
} };

#ifndef TASK_FLAG_RUN_ONLY_IF_LOGGED_ON
#define TASK_FLAG_RUN_ONLY_IF_LOGGED_ON        (0x2000)
#endif

const PROPSPEC c_rgPropRead[] = {
    { PRSPEC_PROPID, PID_INTSITE_SUBSCRIPTION},
    { PRSPEC_PROPID, PID_INTSITE_FLAGS},
    { PRSPEC_PROPID, PID_INTSITE_TRACKING},
    { PRSPEC_PROPID, PID_INTSITE_CODEPAGE},
};

void UpdateTimeFormat(LPTSTR tszTimeFormat, ULONG cchTimeFormat);

HRESULT WriteProperties(POOEntry pooe);
HRESULT ReadProperties(POOEBuf pBuf);

const TCHAR c_szLoadWC[] = TEXT("LoadWC");

void FixupRandomTrigger(TASK_TRIGGER *pTrigger)
{
    if (pTrigger->wRandomMinutesInterval > 0)
    {
        //  We have a random interval so we need to add a random number of minutes to it.
        //  Given the fact that all of the fields need to carry over to the next, the
        //  simplest way to do this is to flatten the start time into FILETIME, add the
        //  random minutes, and then convert back to a TASK_TRIGGER.  This let's us use
        //  Win32 APIs instead of doing all of the calendar and carry over stuff ourselves.

        SYSTEMTIME st;
        CFileTime ft;

        memset(&st, 0, sizeof(SYSTEMTIME));
        st.wYear = pTrigger->wBeginYear;
        st.wMonth = pTrigger->wBeginMonth;
        st.wDay = pTrigger->wBeginDay;
        st.wHour = pTrigger->wStartHour;
        st.wMinute = pTrigger->wStartMinute;

        SystemTimeToFileTime(&st, &ft);

        ft += ONE_MINUTE_IN_FILETIME * (__int64)Random(pTrigger->wRandomMinutesInterval);

        FileTimeToSystemTime(&ft, &st);

        pTrigger->wBeginYear = st.wYear;
        pTrigger->wBeginMonth = st.wMonth;
        pTrigger->wBeginDay = st.wDay;
        pTrigger->wStartHour = st.wHour;
        pTrigger->wStartMinute = st.wMinute;

        pTrigger->wRandomMinutesInterval = 0;
    }
}

//  Come up with a name like "MSN Recommended Schedule"
void CreatePublisherScheduleNameW(WCHAR *pwszSchedName, int cchSchedName,
                                  const TCHAR *pszName, const WCHAR *pwszName)
{
    WCHAR wszFormat[MAX_PATH];
    WCHAR wszPubName[MAX_PATH];
    const WCHAR *pwszPubName;

    ASSERT((NULL != pszName) || (NULL != pwszName));
    ASSERT((NULL != pwszSchedName) && (cchSchedName > 0));

    if (NULL == pwszName)
    {
        ASSERT(NULL != pszName);
        MyStrToOleStrN(wszPubName, ARRAYSIZE(wszPubName), pszName);
        pwszPubName = wszPubName;
    }
    else
    {
        pwszPubName = pwszName;
    }

#ifdef UNICODE
    MLLoadStringW(IDS_RECOMMENDED_SCHEDULE_FORMAT, wszFormat, ARRAYSIZE(wszFormat));
#else
    CHAR szFormat[MAX_PATH];
    MLLoadStringA(IDS_RECOMMENDED_SCHEDULE_FORMAT, szFormat, ARRAYSIZE(szFormat));
    MultiByteToWideChar(CP_ACP, 0, szFormat, -1, wszFormat, ARRAYSIZE(wszFormat));
#endif

    wnsprintfW(pwszSchedName, cchSchedName, wszFormat, pwszPubName);
}

void CreatePublisherScheduleName(TCHAR *pszSchedName, int cchSchedName,
                                 const TCHAR *pszName, const WCHAR *pwszName)
{
    WCHAR wszSchedName[MAX_PATH];

    CreatePublisherScheduleNameW(wszSchedName, ARRAYSIZE(wszSchedName),
                                 pszName, pwszName);

    MyOleStrToStrN(pszSchedName, cchSchedName, wszSchedName);
}

HICON LoadItemIcon(ISubscriptionItem *psi, BOOL bLarge)
{
    HICON hIcon = NULL;
    SUBSCRIPTIONITEMINFO sii;
    SUBSCRIPTIONCOOKIE cookie;
    HRESULT hr;

    sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

    psi->GetCookie(&cookie);

    hr = psi->GetSubscriptionItemInfo(&sii);

    if (SUCCEEDED(hr))
    {
        ISubscriptionAgentShellExt *pSubscriptionAgentShellExt;

        hr = CoCreateInstance(sii.clsidAgent, NULL, CLSCTX_INPROC_SERVER,
                              IID_ISubscriptionAgentShellExt,
                              (void **)&pSubscriptionAgentShellExt);
        if (SUCCEEDED(hr))
        {
            hr = pSubscriptionAgentShellExt->Initialize(&cookie, L"", L"", (SUBSCRIPTIONTYPE)-1);

            if (SUCCEEDED(hr))
            {
                IExtractIcon *pExtractIcon;
                hr = pSubscriptionAgentShellExt->QueryInterface(IID_IExtractIcon,
                                                                (void **)&pExtractIcon);

                if (SUCCEEDED(hr))
                {
                    TCHAR szIconFile[INTERNET_MAX_URL_LENGTH];
                    int iIndex;
                    UINT wFlags;
                    HICON hIconScrap = NULL;
                    HICON *phIconLarge = bLarge ? &hIcon : &hIconScrap;
                    HICON *phIconSmall = bLarge ? &hIconScrap : &hIcon;

                    hr = pExtractIcon->GetIconLocation(0, szIconFile, ARRAYSIZE(szIconFile), &iIndex, &wFlags);

                    if (SUCCEEDED(hr))
                    {
                        hr = pExtractIcon->Extract(szIconFile, iIndex, phIconLarge, phIconSmall,
                                                   MAKELONG(GetSystemMetrics(SM_CXICON),
                                                            GetSystemMetrics(SM_CXSMICON)));

                        if (S_FALSE == hr)
                        {
                            hIcon = ExtractIcon(g_hInst, szIconFile, iIndex);

                            if (NULL == hIcon)
                            {
                                hr = E_FAIL;
                            }
                        }
                        else if ((NULL != hIconScrap) && (hIcon != hIconScrap))
                        {
                            DestroyIcon(hIconScrap);
                        }
                    }
                    pExtractIcon->Release();
                }
            }

            pSubscriptionAgentShellExt->Release();
        }
    }

    if (FAILED(hr))
    {
        DWORD dwChannel = 0;
        DWORD dwDesktop = 0;
        int iSize = bLarge ? GetSystemMetrics(SM_CXICON) : GetSystemMetrics(SM_CXSMICON);
        int id;
        HINSTANCE   hinstSrc;

        ReadDWORD(psi, c_szPropChannel, &dwChannel);
        ReadDWORD(psi, c_szPropDesktopComponent, &dwDesktop);

        if (dwDesktop == 1)
        {
            id = IDI_DESKTOPITEM;
            hinstSrc = MLGetHinst();
        }
        else if (dwChannel == 1)
        {
            id = IDI_CHANNEL;
            hinstSrc = g_hInst;
        }
        else
        {
            id = IDI_WEBDOC;
            hinstSrc = g_hInst;
        }

        hIcon = (HICON)LoadImage(hinstSrc, MAKEINTRESOURCE(id), IMAGE_ICON,
                                 iSize, iSize, LR_DEFAULTCOLOR);

    }

    return hIcon;
}

BOOL ScheduleCookieExists(SYNCSCHEDULECOOKIE *pSchedCookie)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            ISyncSchedule *pSyncSchedule = NULL;

            hr = pSyncScheduleMgr->OpenSchedule(pSchedCookie, 0, &pSyncSchedule);
            if (SUCCEEDED(hr))
            {
                pSyncSchedule->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr == S_OK;
}

BOOL IsScheduleNameInUse(TCHAR *pszSchedName)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            CWaitCursor waitCursor;
            ISyncSchedule *pSyncSchedule = NULL;
            SYNCSCHEDULECOOKIE schedCookie = GUID_NULL;
            WCHAR wszSchedName[MAX_PATH];

            MyStrToOleStrN(wszSchedName, ARRAYSIZE(wszSchedName), pszSchedName);

            hr = pSyncScheduleMgr->CreateSchedule(wszSchedName, 0,
                                                  &schedCookie, &pSyncSchedule);
            if (SUCCEEDED(hr))
            {
                pSyncSchedule->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr == SYNCMGR_E_NAME_IN_USE;
}

struct CONFLICT_DATA
{
    TCHAR szSchedName[MAX_PATH];
    TCHAR szFriendlyTrigger[MAX_PATH];
};

INT_PTR CALLBACK SchedConflictDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bResult = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR szConflictFormat[MAX_PATH];
            TCHAR szConflictMsg[MAX_PATH * 2];
            CONFLICT_DATA *pcd = (CONFLICT_DATA *)lParam;

            ASSERT(NULL != pcd);

            MLLoadString(IDS_SCHED_CONFLICT_FORMAT,
                       szConflictFormat, ARRAYSIZE(szConflictFormat));

            wnsprintf(szConflictMsg, ARRAYSIZE(szConflictMsg),
                      szConflictFormat, pcd->szSchedName);

            SetDlgItemText(hdlg, IDC_SCHEDULE_MESSAGE, szConflictMsg);
            SetDlgItemText(hdlg, IDC_FRIENDLY_SCHEDULE_TEXT, pcd->szFriendlyTrigger);

            bResult = TRUE;
            break;
        }

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                EndDialog(hdlg, LOWORD(wParam));
                bResult = TRUE;
            }
            break;
    }

    return bResult;
}

BOOL CompareTaskTrigger(TASK_TRIGGER *pTrigA, TASK_TRIGGER *pTrigB)
{
    BOOL bDontMatch;    //  TRUE if any elements don't match

    //  Simple memcmp won't work since the start date will be different
    //  when in fact they are effectively the same schedule - at least
    //  from a user perspective.

    //  FEATURE - this is far from complete - we only check for values
    //  which can be set by our wizard.

    bDontMatch  = pTrigA->wStartHour != pTrigB->wStartHour;
    bDontMatch |= pTrigA->wStartMinute != pTrigB->wStartMinute;
    bDontMatch |= pTrigA->TriggerType != pTrigB->TriggerType;
    bDontMatch |= pTrigA->Type.Daily.DaysInterval != pTrigB->Type.Daily.DaysInterval;
    bDontMatch |= pTrigA->MinutesDuration != pTrigB->MinutesDuration;
    bDontMatch |= pTrigA->MinutesInterval != pTrigB->MinutesInterval;
    bDontMatch |= pTrigA->wRandomMinutesInterval != pTrigB->wRandomMinutesInterval;

    return !bDontMatch;
}


//  HandleScheduleNameConflict
//
//  Return values:
//  CONFLICT_NONE               - pSchedCookie will be GUID_NULL and the caller is
//                                free to create a new schedule
//  CONFLICT_RESOLVED_USE_NEW   - pSchedCookie will be the cookie of an existing
//                                schedule which the caller should update with
//                                it's new TASK_TRIGGER
//  CONFLICT_RESOLVED_USE_OLD   - pSchedCookie will be the cookie of an existing
//                                schedule which the caller should use without
//                                modifying anything
//  CONFLICT_UNRESOLVED         - pSchedCookie will be GUID_NULL and the caller
//                                shouldn't do anything until the user has made
//                                up his/her mind
//
int HandleScheduleNameConflict(/* in  */ TCHAR *pszSchedName,
                               /* in  */ TASK_TRIGGER *pTrigger,
                               /* in  */ HWND hwndParent,
                               /* out */ SYNCSCHEDULECOOKIE *pSchedCookie)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;
    int iResult = CONFLICT_NONE;

    *pSchedCookie = GUID_NULL;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            ISyncSchedule *pSyncSchedule = NULL;
            SYNCSCHEDULECOOKIE schedCookie = GUID_NULL;
            WCHAR wszSchedName[MAX_PATH];

            MyStrToOleStrN(wszSchedName, ARRAYSIZE(wszSchedName), pszSchedName);

            {
                CWaitCursor waitCursor;

                hr = pSyncScheduleMgr->CreateSchedule(wszSchedName, 0,
                                                      &schedCookie, &pSyncSchedule);
            }
            if (SUCCEEDED(hr))
            {
                pSyncSchedule->Release();
            }
            else if (SYNCMGR_E_NAME_IN_USE == hr)
            {
                //  schedCookie will have the cookie of the conflicting schedule
                hr = pSyncScheduleMgr->OpenSchedule(&schedCookie, 0, &pSyncSchedule);

                if (SUCCEEDED(hr))
                {
                    ITaskTrigger *pITaskTrigger;

                    hr = pSyncSchedule->GetTrigger(&pITaskTrigger);

                    if (SUCCEEDED(hr))
                    {
                        TASK_TRIGGER existTrigger = { sizeof(TASK_TRIGGER) };

                        hr = pITaskTrigger->GetTrigger(&existTrigger);

                        if (SUCCEEDED(hr))
                        {
                            if (!CompareTaskTrigger(&existTrigger, pTrigger))
                            {
                                CONFLICT_DATA cd;
                                LPWSTR pwszFriendlyTrigger;

                                StrCpyN(cd.szSchedName, pszSchedName, ARRAYSIZE(cd.szSchedName));
                                if (SUCCEEDED(pITaskTrigger->GetTriggerString(&pwszFriendlyTrigger)))
                                {
                                    MyOleStrToStrN(cd.szFriendlyTrigger,
                                                   ARRAYSIZE(cd.szFriendlyTrigger),
                                                   pwszFriendlyTrigger);
                                    CoTaskMemFree(pwszFriendlyTrigger);
                                }
                                else
                                {
                                    cd.szFriendlyTrigger[0] = TEXT('\0');
                                }

                                INT_PTR iRet = DialogBoxParam(MLGetHinst(),
                                                              MAKEINTRESOURCE(IDD_DUPLICATE_SCHEDULE),
                                                              hwndParent,
                                                              SchedConflictDlgProc,
                                                              (LPARAM)&cd);
                                switch (iRet)
                                {
                                    case IDC_NEW_SETTINGS:
                                        iResult = CONFLICT_RESOLVED_USE_NEW;
                                        *pSchedCookie = schedCookie;
                                        break;

                                    case IDC_OLD_SETTINGS:
                                        iResult = CONFLICT_RESOLVED_USE_OLD;
                                        *pSchedCookie = schedCookie;
                                        break;

                                    default:
                                        iResult = CONFLICT_UNRESOLVED;
                                        break;
                                }
                            }
                        }
                        pITaskTrigger->Release();
                    }
                    pSyncSchedule->Release();
                }
            }

            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return iResult;
}

HRESULT UpdateScheduleTrigger(SYNCSCHEDULECOOKIE *pSchedCookie, TASK_TRIGGER *pTrigger)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        CWaitCursor waitCursor;
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            ISyncSchedule *pSyncSchedule;

            hr = pSyncScheduleMgr->OpenSchedule(pSchedCookie, 0, &pSyncSchedule);
            if (SUCCEEDED(hr))
            {
                ITaskTrigger *pITaskTrigger;

                hr = pSyncSchedule->GetTrigger(&pITaskTrigger);
                if (SUCCEEDED(hr))
                {
                    FixupRandomTrigger(pTrigger);

                    hr = pITaskTrigger->SetTrigger(pTrigger);

                    if (SUCCEEDED(hr))
                    {
                        hr = pSyncSchedule->Save();
                    }

                    pITaskTrigger->Release();
                }
                pSyncSchedule->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr;
}

HRESULT RemoveItemFromAllSchedules(SUBSCRIPTIONCOOKIE *pCookie)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        CWaitCursor waitCursor;
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            IEnumSyncSchedules *pEnumSyncSchedules;

            hr = pSyncScheduleMgr->EnumSyncSchedules(&pEnumSyncSchedules);

            if (SUCCEEDED(hr))
            {
                SYNCSCHEDULECOOKIE schedCookie;
                ULONG ulFetched;

                while (S_OK == pEnumSyncSchedules->Next(1, &schedCookie, &ulFetched) &&
                       (0 != ulFetched))    //  this shouldn't be necessary
                {
                    ISyncSchedule *pSyncSchedule;

                    //  If this fails, there ain't much we can do about
                    //  it so just plod along anyhow

                    if (SUCCEEDED(pSyncScheduleMgr->OpenSchedule(&schedCookie, 0, &pSyncSchedule)))
                    {
                        //  Don't care about the return value, it's cheaper
                        //  for us to just delete than to ask if it's there
                        //  and then delete.
                        pSyncSchedule->SetItemCheck(CLSID_WebCheckOfflineSync,
                                                    pCookie,
                                                    SYNCMGRITEMSTATE_UNCHECKED);
                        pSyncSchedule->Save();
                        pSyncSchedule->Release();
                    }
                }
                pEnumSyncSchedules->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr;
}

HRESULT AddRemoveScheduledItem(SYNC_HANDLER_ITEM_INFO *pSyncHandlerItemInfo, // For Add
                               SUBSCRIPTIONCOOKIE *pCookie,                  // For Remove
                               SYNCSCHEDULECOOKIE *pSchedCookie, BOOL bAdd)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    ASSERT((bAdd && (NULL != pSyncHandlerItemInfo)) ||
            (!bAdd && (NULL != pCookie)));

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            ISyncSchedule *pSyncSchedule;

            hr = pSyncScheduleMgr->OpenSchedule(pSchedCookie, 0, &pSyncSchedule);
            if (SUCCEEDED(hr))
            {
                if (bAdd)
                {

                    hr = pSyncSchedule->AddItem(pSyncHandlerItemInfo);
                    hr = pSyncSchedule->SetItemCheck(CLSID_WebCheckOfflineSync,
                                                     &pSyncHandlerItemInfo->itemID,
                                                     SYNCMGRITEMSTATE_CHECKED);
                }
                else
                {

                    hr = pSyncSchedule->SetItemCheck(CLSID_WebCheckOfflineSync,
                                                     pCookie,
                                                     SYNCMGRITEMSTATE_UNCHECKED);
                }
                hr = pSyncSchedule->Save();
                pSyncSchedule->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr;
}

HRESULT SetScheduleValues(ISyncSchedule *pSyncSchedule,
                          TASK_TRIGGER *pTrigger,
                          DWORD dwSyncScheduleFlags)
{
    HRESULT hr;
    ITaskTrigger *pITaskTrigger;

    ASSERT(NULL != pSyncSchedule);
    ASSERT(NULL != pTrigger);

    hr = pSyncSchedule->GetTrigger(&pITaskTrigger);

    ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
    {
        FixupRandomTrigger(pTrigger);
        hr = pITaskTrigger->SetTrigger(pTrigger);
        pITaskTrigger->Release();

        ASSERT(SUCCEEDED(hr));

        if (SUCCEEDED(hr))
        {
            DWORD dwFlags;
            DWORD dwConnectionType = SYNCSCHEDINFO_FLAGS_CONNECTION_LAN;
            WCHAR wszConnectionName[MAX_PATH];

            //  Return code doesn't help us.  This returns the best guess
            //  at connection:
            //      1) LAN
            //      2) currently connected connectoid
            //      3) auto-dial connectoid
            //  This is according to darrenmi, if this changes - kill him.
            InternetGetConnectedStateExW(&dwFlags, wszConnectionName,
                                         ARRAYSIZE(wszConnectionName), 0);

            if (dwFlags & INTERNET_CONNECTION_MODEM)
            {
                dwConnectionType = SYNCSCHEDINFO_FLAGS_CONNECTION_WAN;
            }

            hr = pSyncSchedule->SetConnection(
                (dwConnectionType == SYNCSCHEDINFO_FLAGS_CONNECTION_WAN) ?
                    wszConnectionName : NULL,
                dwConnectionType);

            ASSERT(SUCCEEDED(hr));

            if (SUCCEEDED(hr))
            {
                hr = pSyncSchedule->SetFlags(dwSyncScheduleFlags);

                ASSERT(SUCCEEDED(hr));

                if (SUCCEEDED(hr))
                {
                    hr = pSyncSchedule->Save();

                    ASSERT(SUCCEEDED(hr));
                }
            }
        }
    }

    return hr;
}

HRESULT CreateSchedule(LPWSTR pwszScheduleName, DWORD dwSyncScheduleFlags,
                       SYNCSCHEDULECOOKIE *pSchedCookie, TASK_TRIGGER *pTrigger,
                       BOOL fDupCookieOK)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;
    ISyncSchedule *pSyncSchedule = NULL;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        CWaitCursor waitCursor;
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            hr = pSyncScheduleMgr->CreateSchedule(pwszScheduleName, 0,
                                      pSchedCookie, &pSyncSchedule);

            ASSERT((FAILED(hr) && (NULL == pSyncSchedule)) ||
                   (SUCCEEDED(hr) && (NULL != pSyncSchedule)));

            switch (hr)
            {
                case S_OK:
                    hr = SetScheduleValues(pSyncSchedule, pTrigger, dwSyncScheduleFlags);

                #ifdef DEBUG
                    if (FAILED(hr))
                    {
                        TraceMsg(TF_ALWAYS, "SetScheduleValues failed - hr=0x%08x", hr);
                    }
                #endif

                    break;

                case HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
                    if (fDupCookieOK)
                    {
                        hr = S_OK;
                    }
                    break;
            }

            SAFERELEASE(pSyncSchedule);

            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr;
}

BOOL IsCookieOnSchedule(ISyncSchedule *pSyncSchedule, SUBSCRIPTIONCOOKIE *pCookie)
{
    HRESULT hr;
    DWORD dwCheckState = SYNCMGRITEMSTATE_UNCHECKED;

    hr = pSyncSchedule->GetItemCheck(CLSID_WebCheckOfflineSync,
                                     pCookie,
                                     &dwCheckState);

    return SUCCEEDED(hr) && (SYNCMGRITEMSTATE_CHECKED & dwCheckState);
}

struct GIS_DATA
{
    SUBSCRIPTIONCOOKIE *pSubsCookie;
    SYNCSCHEDULECOOKIE *pSchedCookie;
};

BOOL GetItemScheduleCallback(ISyncSchedule *pSyncSchedule,
                             SYNCSCHEDULECOOKIE *pSchedCookie,
                             LPARAM lParam)
{
    BOOL bContinue = TRUE;
    GIS_DATA *pgd = (GIS_DATA *)lParam;

    if (IsCookieOnSchedule(pSyncSchedule, pgd->pSubsCookie))
    {
        *pgd->pSchedCookie = *pSchedCookie;
        bContinue = FALSE;
    }

    return bContinue;
}


HRESULT GetItemSchedule(SUBSCRIPTIONCOOKIE *pSubsCookie, SYNCSCHEDULECOOKIE *pSchedCookie)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    *pSchedCookie = GUID_NULL;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);
        if (SUCCEEDED(hr))
        {
            ISubscriptionItem *psi;

            //  First let's chech to see if it has a custom schedule
            hr = SubscriptionItemFromCookie(FALSE, pSubsCookie, &psi);

            if (SUCCEEDED(hr))
            {
                SUBSCRIPTIONITEMINFO sii;

                sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

                hr = psi->GetSubscriptionItemInfo(&sii);

                psi->Release();

                if (SUCCEEDED(hr) && (sii.ScheduleGroup != GUID_NULL))
                {
                    *pSchedCookie = sii.ScheduleGroup;
                }
                else
                {
                    GIS_DATA gd;

                    gd.pSubsCookie = pSubsCookie;
                    gd.pSchedCookie = pSchedCookie;
                    EnumSchedules(GetItemScheduleCallback, (LPARAM)&gd);
                }
            }


            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr;
}

HRESULT EnumSchedules(SCHEDULEENUMCALLBACK pCallback, LPARAM lParam)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        CWaitCursor waitCursor;
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {
            IEnumSyncSchedules *pEnumSyncSchedules;

            hr = pSyncScheduleMgr->EnumSyncSchedules(&pEnumSyncSchedules);

            if (SUCCEEDED(hr))
            {
                SYNCSCHEDULECOOKIE schedCookie;
                ULONG ulFetched;

                while (S_OK == pEnumSyncSchedules->Next(1, &schedCookie, &ulFetched)&&
                       (0 != ulFetched))    //  this shouldn't be necessary
                {
                    ISyncSchedule *pSyncSchedule;

                    HRESULT hrTemp = pSyncScheduleMgr->OpenSchedule(&schedCookie, 0, &pSyncSchedule);
                    if (SUCCEEDED(hrTemp) && pSyncSchedule)
                    {
                        BOOL bContinue = pCallback(pSyncSchedule, &schedCookie, lParam);
                        pSyncSchedule->Release();

                        if (!bContinue)
                        {
                            hr = S_FALSE;
                            break;
                        }
                    }
                }
                pEnumSyncSchedules->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }

    return hr;
}

SUBSCRIPTIONTYPE GetItemCategory(BOOL bDesktop, const CLSID& clsidDest)
{
    SUBSCRIPTIONTYPE st;

    if (clsidDest == CLSID_WebCrawlerAgent)
    {
        st = (!bDesktop) ? SUBSTYPE_URL : SUBSTYPE_DESKTOPURL;
    }
    else if (clsidDest == CLSID_ChannelAgent)
    {
        st = (!bDesktop) ? SUBSTYPE_CHANNEL : SUBSTYPE_DESKTOPCHANNEL;
    }
    else
    {
        st = SUBSTYPE_EXTERNAL;
    }

    return st;
}


SUBSCRIPTIONSCHEDULE GetGroup(BOOL bDesktop, const CLSID& clsidDest,
                              DWORD fChannelFlags, const NOTIFICATIONCOOKIE& groupCookie)
{


    SUBSCRIPTIONTYPE category = GetItemCategory(bDesktop, clsidDest);
    if (category == SUBSTYPE_CHANNEL || category == SUBSTYPE_DESKTOPCHANNEL) {
        if ((fChannelFlags & CHANNEL_AGENT_DYNAMIC_SCHEDULE) &&
            (GUID_NULL == groupCookie))
            return SUBSSCHED_AUTO;
    }

    //  We have no idea about the AUTO schedule stuff of unknown types.

    if (groupCookie == NOTFCOOKIE_SCHEDULE_GROUP_DAILY)
            return SUBSSCHED_DAILY;
    else if (groupCookie == NOTFCOOKIE_SCHEDULE_GROUP_WEEKLY)
        return SUBSSCHED_WEEKLY;
    else if (groupCookie == NOTFCOOKIE_SCHEDULE_GROUP_MANUAL)
        return SUBSSCHED_MANUAL;
    else
        return SUBSSCHED_CUSTOM;
}

HRESULT LoadGroupCookie(NOTIFICATIONCOOKIE * pCookie, SUBSCRIPTIONSCHEDULE subGroup)
{
    if (pCookie)    {
        switch (subGroup)   {
        case SUBSSCHED_DAILY:
            *pCookie = NOTFCOOKIE_SCHEDULE_GROUP_DAILY;
            break;
        case SUBSSCHED_WEEKLY:
            *pCookie = NOTFCOOKIE_SCHEDULE_GROUP_WEEKLY;
            break;
        case SUBSSCHED_MANUAL:
            *pCookie = NOTFCOOKIE_SCHEDULE_GROUP_MANUAL;
            break;
        default:
            *pCookie = CLSID_NULL;
            ASSERT(0);
            break;
        }
        return S_OK;
    }

    return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////
//  Subscription helper functions.


HRESULT TSTR2BSTR(VARIANT * pvarBSTR, LPCTSTR srcTSTR)
{
    ASSERT(pvarBSTR);
    ASSERT(srcTSTR);

    BSTR    bstrBuf = NULL;
    LONG    lTSTRLen = 0;

    lTSTRLen = lstrlen(srcTSTR) + 1;
    bstrBuf = SysAllocStringLen(NULL, lTSTRLen);
    if (!bstrBuf)
        return E_OUTOFMEMORY;
    MyStrToOleStrN(bstrBuf, lTSTRLen, srcTSTR);
    pvarBSTR->vt = VT_BSTR;
    pvarBSTR->bstrVal = bstrBuf;
    return S_OK;
}

HRESULT WriteCookieToInetDB(LPCTSTR pszURL, SUBSCRIPTIONCOOKIE *pCookie, BOOL bRemove)
{
    PROPVARIANT propCookie;
    LPOLESTR pclsid = NULL; // init to keep compiler happy

    ASSERT(pszURL);
    if (bRemove)
    {
        propCookie.vt = VT_EMPTY;
    }
    else
    {
        ASSERT(pCookie);

        if (FAILED(StringFromCLSID(*pCookie, &pclsid)))
            return E_FAIL;

        propCookie.vt = VT_LPWSTR;
        propCookie.pwszVal = pclsid;
    }

    HRESULT hr = IntSiteHelper(pszURL, &c_rgPropRead[PROP_SUBSCRIPTION], &propCookie, 1, TRUE);

    if (!bRemove)
        CoTaskMemFree(pclsid);

    return hr;
}

HRESULT WritePropertiesToItem(POOEntry pooe, ISubscriptionItem *psi)
{
    HRESULT hr = S_OK;
    VARIANT var;
    BOOL bHasUNAME = TRUE;

    ASSERT(NULL != psi);

    VariantInit(&var);
    if (pooe->dwFlags & PROP_WEBCRAWL_URL)
    {
        if (FAILED(TSTR2BSTR(&var, URL(pooe))))
            return E_FAIL;
        WriteVariant(psi, c_szPropURL, &var);
        VariantClear(&var);
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_NAME)
    {
        if (FAILED(TSTR2BSTR(&var, NAME(pooe))))
            return E_FAIL;
        WriteVariant(psi, c_szPropName, &var);
        VariantClear(&var);
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_UNAME)
    {
        if(*(UNAME(pooe)))
        {
            if (FAILED(TSTR2BSTR(&var, UNAME(pooe))))
                return E_FAIL;
            WriteVariant(psi, c_szPropCrawlUsername, &var);
            VariantClear(&var);
        }
        else
        {
            WriteEMPTY(psi, c_szPropCrawlUsername);
            bHasUNAME = FALSE;
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_DESKTOP)
    {
        if (pooe->bDesktop)
        {
            WriteDWORD(psi, c_szPropDesktopComponent, 1);
        }
        else
        {
            WriteEMPTY(psi, c_szPropDesktopComponent);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_CHANNEL)
    {
        if (pooe->bChannel)
        {
            WriteDWORD(psi, c_szPropChannel, 1);
        }
        else
        {
            WriteEMPTY(psi, c_szPropChannel);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_GLEAM)
    {
        if (pooe->bGleam)
        {
            WriteDWORD(psi, c_szPropEnableShortcutGleam, 1);
        }
        else
        {
            WriteEMPTY(psi, c_szPropEnableShortcutGleam);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_CHANGESONLY)
    {
        if (pooe->bChangesOnly)
        {
            WriteDWORD(psi, c_szPropCrawlChangesOnly, 1);
        }
        else
        {
            WriteEMPTY(psi, c_szPropCrawlChangesOnly);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_CHANNELFLAGS)
    {
        if (pooe->fChannelFlags)
        {
            WriteDWORD(psi, c_szPropChannelFlags, pooe->fChannelFlags);
        }
        else
        {
            WriteEMPTY(psi, c_szPropChannelFlags);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_EMAILNOTF)
    {
        if (pooe->bMail)
        {
            WriteDWORD(psi, c_szPropEmailNotf, 1);
        }
        else
        {
            WriteEMPTY(psi, c_szPropEmailNotf);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_PSWD)
    {
        if (*(PASSWD(pooe)) && bHasUNAME)
        {
            if (FAILED(TSTR2BSTR(&var, PASSWD(pooe))))
                return E_FAIL;
            WritePassword(psi, var.bstrVal);
            VariantClear(&var);
        }
        else
        {
            WritePassword(psi, NULL);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_LEVEL)
    {
        if(pooe->m_RecurseLevels)
        {
            WriteDWORD(psi, c_szPropCrawlLevels, pooe->m_RecurseLevels);
        }
        else
        {
            // top page only was specified, empty out levels
            WriteEMPTY(psi, c_szPropCrawlLevels);
        }
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_FLAGS)
    {
        WriteDWORD(psi, c_szPropCrawlFlags, pooe->m_RecurseFlags);
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_ACTUALSIZE)
    {
        WriteDWORD(psi, c_szPropCrawlActualSize, pooe->m_ActualSize);
    }

    if (pooe->dwFlags & PROP_WEBCRAWL_SIZE)
    {
        if(pooe->m_SizeLimit)
        {
            // limit was specified
            WriteDWORD(psi, c_szPropCrawlMaxSize, pooe->m_SizeLimit);
        }
        else
        {
            // no limit was specified, empty out limit prop
            WriteEMPTY(psi, c_szPropCrawlMaxSize);
        }
    }

    SUBSCRIPTIONITEMINFO sii;
    sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
    if (SUCCEEDED(psi->GetSubscriptionItemInfo(&sii)))
    {
        sii.dwFlags = pooe->grfTaskTrigger;
        psi->SetSubscriptionItemInfo(&sii);
    }

    //  We don't write Status/Last update.

    // FEATURE: We should fail the subscription if we were unable to write
    // any of the properties into the notification for some reason.


    return hr;
}

HRESULT WriteProperties(POOEntry pooe)
{
    HRESULT hr;
    ISubscriptionItem *psi = NULL;

    ASSERT(NULL != pooe);

    hr = SubscriptionItemFromCookie(FALSE, &pooe->m_Cookie, &psi);

    if (SUCCEEDED(hr))
    {
        hr = WritePropertiesToItem(pooe, psi);
        psi->Release();
    }
    return hr;
}

HRESULT CreatePublisherSchedule()
{
    return S_OK;
}

#define RANDOM_TIME_START       0       // 12am (in minutes)
#define RANDOM_TIME_END         300     // 5am (in minutes)
#define RANDOM_TIME_INC         30      // 30min increment

DWORD GetRandomTime(DWORD StartMins, DWORD EndMins, DWORD Inc)
{
    DWORD Range;
    DWORD nIncrements;

    if (StartMins > EndMins)
    {
        Range = ((1440 - StartMins) + EndMins);
    }
    else
    {
        Range = (EndMins - StartMins);
    }

    nIncrements = ((Range / Inc) + 1);

    return (StartMins + (Random(nIncrements) * Inc));
}

HRESULT CreateDefaultSchedule(SUBSCRIPTIONSCHEDULE subsSchedule,
                              SYNCSCHEDULECOOKIE *pSchedCookie)
{
    HRESULT hr = S_OK;
    TASK_TRIGGER trig;
    int resID;

    memset((void*) &trig, 0x0, sizeof(TASK_TRIGGER));
    *pSchedCookie = GUID_NULL;

    ZeroMemory(&trig, sizeof(trig));

    switch (subsSchedule)
    {
        case SUBSSCHED_DAILY:
            trig.TriggerType = TASK_TIME_TRIGGER_DAILY;
            trig.Type.Daily.DaysInterval = 1;
            resID = IDS_DAILY_GRO;
            *pSchedCookie = NOTFCOOKIE_SCHEDULE_GROUP_DAILY;
            break;

        case SUBSSCHED_WEEKLY:
            trig.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
            trig.Type.Weekly.WeeksInterval = 1;
            trig.Type.Weekly.rgfDaysOfTheWeek = TASK_MONDAY;
            resID = IDS_WEEKLY_GRO;
            *pSchedCookie = NOTFCOOKIE_SCHEDULE_GROUP_WEEKLY;
            break;

        case SUBSSCHED_AUTO:
        case SUBSSCHED_CUSTOM:
        case SUBSSCHED_MANUAL:
        default:
            resID = 0;
            hr = E_FAIL;
            break;
    }

    if (SUCCEEDED(hr))
    {
        if (!ScheduleCookieExists(pSchedCookie))
        {
            WCHAR wszSchedName[MAX_PATH];
            DWORD dwRandTime = GetRandomTime(RANDOM_TIME_START,
                                             RANDOM_TIME_END,
                                             RANDOM_TIME_INC);

            trig.cbTriggerSize = sizeof(TASK_TRIGGER);
            trig.wRandomMinutesInterval = RANDOM_TIME_INC;
            trig.wStartHour = (UINT)(dwRandTime / 60);
            trig.wStartMinute = (UINT)(dwRandTime % 60);
            trig.rgFlags = 0;

            MLLoadStringW(resID, wszSchedName, ARRAYSIZE(wszSchedName));

            hr = CreateSchedule(wszSchedName, 0, pSchedCookie, &trig, TRUE);

            if (hr == SYNCMGR_E_NAME_IN_USE)
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}

HRESULT AddIt(ISubscriptionItem *psi, POOEntry pooe, SUBSCRIPTIONSCHEDULE subGroup)
{
    SYNCSCHEDULECOOKIE schedCookie = GUID_NULL;
    HRESULT hr = E_FAIL;

    switch (subGroup)
    {
        case SUBSSCHED_DAILY:
        case SUBSSCHED_WEEKLY:
            hr = CreateDefaultSchedule(subGroup, &schedCookie);
            break;

        case SUBSSCHED_CUSTOM:
            schedCookie = pooe->groupCookie;
            hr = S_OK;
            break;

        case SUBSSCHED_MANUAL:
	    SUBSCRIPTIONCOOKIE cookie;

	    cookie = pooe->m_Cookie;
            RemoveItemFromAllSchedules(&cookie);
	    pooe->m_Cookie = cookie;
            hr = S_FALSE;
            break;

        case SUBSSCHED_AUTO:
            //  FEATURE - for now, until pub schedules are wired in
            hr = CreateDefaultSchedule(SUBSSCHED_DAILY, &schedCookie);
            break;
    }

    if (hr == S_OK)
    {
        ASSERT(GUID_NULL != schedCookie);

        if (NOOP_SCHEDULE_COOKIE == schedCookie)
        {
            hr = S_FALSE;
        }
        if (GUID_NULL != schedCookie)
        {
            SYNC_HANDLER_ITEM_INFO shii;

            shii.handlerID = CLSID_WebCheckOfflineSync;
            shii.itemID = pooe->m_Cookie;
            shii.hIcon = NULL;
            MyStrToOleStrN(shii.wszItemName, ARRAYSIZE(shii.wszItemName), NAME(pooe));
            shii.dwCheckState = SYNCMGRITEMSTATE_CHECKED;

            hr = AddScheduledItem(&shii, &schedCookie);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return S_OK;
//  return hr;
}

HRESULT ScheduleIt(ISubscriptionItem *psi, TCHAR *pszName, TASK_TRIGGER *pTrigger)
{
    HRESULT hr;
    SUBSCRIPTIONITEMINFO subscriptionItemInfo;

    ASSERT(pTrigger->cbTriggerSize == sizeof(TASK_TRIGGER));

    subscriptionItemInfo.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

#ifdef DEBUG
    DumpTaskTrigger(pTrigger);
#endif

    hr = psi->GetSubscriptionItemInfo(&subscriptionItemInfo);

    if (SUCCEEDED(hr))
    {
        if (GUID_NULL != subscriptionItemInfo.ScheduleGroup)
        {
            hr = UpdateScheduleTrigger(&subscriptionItemInfo.ScheduleGroup, pTrigger);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (FAILED(hr))
    {
        WCHAR wszSchedName[MAX_PATH];

        CreatePublisherScheduleNameW(wszSchedName, ARRAYSIZE(wszSchedName),
                                     pszName, NULL);

        hr = CreateSchedule(wszSchedName, SYNCSCHEDINFO_FLAGS_READONLY,
                            &subscriptionItemInfo.ScheduleGroup, pTrigger, TRUE);

        if (SUCCEEDED(hr) || (hr == SYNCMGR_E_NAME_IN_USE))
        {
            psi->SetSubscriptionItemInfo(&subscriptionItemInfo);
            hr = S_OK;
        }
        else
        {
            TraceMsg(TF_ALWAYS, "Error creating schedule - hr=0x%08x", hr);
        }
    }

    if (SUCCEEDED(hr))
    {
        SYNC_HANDLER_ITEM_INFO shii;

        shii.handlerID = CLSID_WebCheckOfflineSync;
        psi->GetCookie(&shii.itemID);
        shii.hIcon = NULL;
        MyStrToOleStrN(shii.wszItemName, ARRAYSIZE(shii.wszItemName), pszName);

        hr = AddScheduledItem(&shii, &subscriptionItemInfo.ScheduleGroup);
    }

    return S_OK;
//    return hr;
}

HRESULT ReadProperties(POOEBuf pBuf)
{
    VARIANT var;
    HRESULT hr;
    ASSERT(pBuf);
    BOOL    bHasUNAME = TRUE;
    ISubscriptionItem *psi = NULL;

    ASSERT(NULL != pBuf);

    hr = SubscriptionItemFromCookie(FALSE, &pBuf->m_Cookie, &psi);

    if (SUCCEEDED(hr))
    {
        VariantInit(&var);
        if (pBuf->dwFlags & PROP_WEBCRAWL_URL)
        {
            hr = ReadVariant(psi, c_szPropURL, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_BSTR))
            {
                MyOleStrToStrN(pBuf->m_URL, MAX_URL, var.bstrVal);
            }
            else
            {
                pBuf->m_URL[0] = (TCHAR)0;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_NAME)
        {
            hr = ReadVariant(psi, c_szPropName, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_BSTR))
            {
                MyOleStrToStrN(pBuf->m_Name, MAX_NAME, var.bstrVal);
            }
            else
            {
                pBuf->m_Name[0] = (TCHAR)0;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_UNAME)
        {
            hr = ReadVariant(psi, c_szPropCrawlUsername, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_BSTR))
            {
                MyOleStrToStrN(pBuf->username, MAX_USERNAME, var.bstrVal);
            }
            else
            {
                pBuf->username[0] = (TCHAR)0;
                bHasUNAME = FALSE;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_DESKTOP)
        {
            hr = ReadVariant(psi, c_szPropDesktopComponent, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_I4) && (var.lVal == 1))
            {
                pBuf->bDesktop = TRUE;
            }
            else
            {
                pBuf->bDesktop = FALSE;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_CHANNEL)
        {
            hr = ReadVariant(psi, c_szPropChannel, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_I4) && (var.lVal == 1))
            {
                pBuf->bChannel = TRUE;
            }
            else
            {
                pBuf->bChannel = FALSE;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_GLEAM)
        {
            hr = ReadVariant(psi, c_szPropEnableShortcutGleam, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_I4) && (var.lVal == 1))
            {
                pBuf->bGleam = TRUE;
            }
            else
            {
                pBuf->bGleam = FALSE;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_CHANGESONLY)
        {
            hr = ReadVariant(psi, c_szPropCrawlChangesOnly, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_I4) && (var.lVal == 1))
            {
                pBuf->bChangesOnly = TRUE;
            }
            else
            {
                pBuf->bChangesOnly = FALSE;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_CHANNELFLAGS)
        {
            hr = ReadVariant(psi, c_szPropChannelFlags, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_I4))
            {
                pBuf->fChannelFlags = var.lVal;
            }
            else
            {
                pBuf->fChannelFlags = 0;
            }
            VariantClear(&var);
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_EMAILNOTF)
        {
            hr = ReadVariant(psi, c_szPropEmailNotf, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_I4) && (var.lVal == 1))
            {
                pBuf->bMail = TRUE;
            }
            else
            {
                pBuf->bMail = FALSE;
            }
            VariantClear(&var);
        }

        if ((pBuf->dwFlags & PROP_WEBCRAWL_PSWD) && bHasUNAME)
        {
            BSTR bstrVal = NULL;
            hr = ReadPassword(psi, &bstrVal);
            if (SUCCEEDED(hr) && bstrVal)
            {
                MyOleStrToStrN(pBuf->password, MAX_PASSWORD, bstrVal);
            }
            else
            {
                pBuf->password[0] = (TCHAR)0;
            }
            SAFEFREEBSTR(bstrVal);
        }

        if ((pBuf->dwFlags & PROP_WEBCRAWL_PSWD) || (pBuf->dwFlags & PROP_WEBCRAWL_UNAME)) {
            //bNeedPassword isn't stored in the property map... calculate it from the presence
            //of username/password.
            pBuf->bNeedPassword = pBuf->password[0] || pBuf->username[0];
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_STATUS)
        {
            hr = ReadVariant(psi, c_szPropStatusString, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_BSTR))
            {
                MyOleStrToStrN(pBuf->statusStr, MAX_STATUS, var.bstrVal);
            }
            else
            {
                pBuf->statusStr[0] = (TCHAR)0;
            }
            VariantClear(&var);

            hr = ReadSCODE(psi, c_szPropStatusCode, &(pBuf->status));
            //  FEATURE What should we put here if we don't have last status?
            if (FAILED(hr))
            {
                pBuf->status = S_OK;
            }
            VariantClear(&var);
        }

        //
        // Use the CompletionTime property if present and it is greater than
        // value in the NOTIFICATIONITEM structure.
        //

        if (pBuf->dwFlags & PROP_WEBCRAWL_LAST)
        {
            CFileTime ft;
            hr = ReadVariant(psi, c_szPropCompletionTime, &var);
            if (SUCCEEDED(hr) && (var.vt == VT_DATE))
            {
                VariantTimeToFileTime(var.date, ft);

                if (ft > pBuf->m_LastUpdated)
                {
                    pBuf->m_LastUpdated = ft;
                }
            }
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_LEVEL)
        {
            hr = ReadDWORD(psi, c_szPropCrawlLevels, (DWORD *)&(pBuf->m_RecurseLevels));
            if (FAILED(hr))
            {
                pBuf->m_RecurseLevels = 0;
            }
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_FLAGS)
        {
            hr = ReadDWORD(psi, c_szPropCrawlFlags, (DWORD *)&(pBuf->m_RecurseFlags));
            if (FAILED(hr))
            {
                pBuf->m_RecurseFlags = 0;   //  Minimal memory usage.
            }
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_SIZE)
        {
            hr = ReadDWORD(psi, c_szPropCrawlMaxSize, (DWORD *)&(pBuf->m_SizeLimit));
            if (FAILED(hr))
            {
                pBuf->m_SizeLimit = 0;
            }
        }

        if (pBuf->dwFlags & PROP_WEBCRAWL_ACTUALSIZE)
        {
            hr = ReadDWORD(psi, c_szPropCrawlActualSize, (DWORD *)&(pBuf->m_ActualSize));
            if (FAILED(hr))
            {
                pBuf->m_ActualSize = 0;
            }
        }

        SUBSCRIPTIONITEMINFO sii;
        sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
        if (SUCCEEDED(psi->GetSubscriptionItemInfo(&sii)))
        {
            pBuf->grfTaskTrigger = sii.dwFlags;
        }

        psi->Release();
    }

    // FEATURE: Need to support c_szPropEnableShortcutGleam here.

    return S_OK;
}

// If url is NULL, no need to compare.
HRESULT LoadWithCookie(LPCTSTR pszURL, POOEBuf pBuf, DWORD *pdwBufferSize, SUBSCRIPTIONCOOKIE *pCookie)
{
    HRESULT hr = LoadOOEntryInfo(pBuf, pCookie, pdwBufferSize);

    if (SUCCEEDED(hr) && pszURL)
    {
        if (UrlCompare(pBuf->m_URL, pszURL, TRUE))
        {
            TraceMsg(TF_ALWAYS, "Mismatched cookie/URL in LoadWithCookie");
            hr = E_FAIL;      //  Mismatched cookie!
        }
    }

    return hr;
}

HRESULT ReadCookieFromInetDB(LPCTSTR pszURL, SUBSCRIPTIONCOOKIE *pCookie)
{
    ASSERT(pszURL && pCookie);
    PROPVARIANT propCookie;

    PropVariantInit(&propCookie);

    HRESULT hr = FindURLProps(pszURL, &propCookie);

    if (SUCCEEDED(hr) && (propCookie.vt == VT_LPWSTR))
    {
        hr = CLSIDFromString(propCookie.pwszVal, pCookie);
    }
    PropVariantClear(&propCookie);

    //  If we couldn't find it, use a brute force approach
    if (S_OK != hr)
    {
        CEnumSubscription *pes = new CEnumSubscription;

        if (NULL != pes)
        {
            if (SUCCEEDED(pes->Initialize(0)))
            {
                SUBSCRIPTIONCOOKIE cookie;
                BOOL bFound = FALSE;

                while (!bFound && (S_OK == pes->Next(1, &cookie, NULL)))
                {
                    ISubscriptionItem *psi;

                    if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, &cookie, &psi)))
                    {
                        LPTSTR pszCurURL;

                        if (SUCCEEDED(ReadTSTR(psi, c_szPropURL, &pszCurURL)))
                        {
                            bFound = (StrCmpI(pszCurURL, pszURL) == 0);
                            CoTaskMemFree(pszCurURL);
                        }
                        psi->Release();
                    }
                }

                if (bFound)
                {
                    WriteCookieToInetDB(pszURL, &cookie, FALSE);
                    *pCookie = cookie;
                    hr = S_OK;
                }
            }
            pes->Release();
        }
    }

    return hr;
}

HRESULT LoadSubscription(LPCTSTR url, LPMYPIDL *ppidl)
{
    HRESULT hr;

    POOEntry pooe = NULL;
    OOEBuf  ooeBuf;
    DWORD   dwBufferSize;
    SUBSCRIPTIONCOOKIE cookie;

    hr = ReadCookieFromInetDB(url, &cookie);
    if (S_OK == hr)
    {
        hr = LoadWithCookie(url, &ooeBuf, &dwBufferSize, &cookie);
        if (hr == S_OK)
        {
            *ppidl = COfflineFolderEnum::NewPidl(dwBufferSize);
            if (!(*ppidl))
            {
                return E_OUTOFMEMORY;
            }
            pooe = &((*ppidl)->ooe);
            CopyToMyPooe(&ooeBuf, pooe);
        }
        else
        {
            WriteCookieToInetDB(url, NULL, TRUE);
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// KENSY: This needs to work like GetDefaultInfo

HRESULT GetDefaultOOEBuf(OOEBuf * pBuf, SUBSCRIPTIONTYPE subType)
{
    ASSERT(pBuf);
    ASSERT(IS_VALID_SUBSCRIPTIONTYPE(subType));

    memset((void *)pBuf, 0, sizeof(OOEBuf));
    pBuf->dwFlags = PROP_WEBCRAWL_ALL;
    pBuf->m_RecurseLevels = DEFAULTLEVEL;
    pBuf->m_RecurseFlags = DEFAULTFLAGS;
    pBuf->m_Priority = AGENT_PRIORITY_NORMAL;
    if (subType == SUBSTYPE_CHANNEL || subType == SUBSTYPE_DESKTOPCHANNEL)
    {
        pBuf->clsidDest = CLSID_ChannelAgent;
        pBuf->fChannelFlags = CHANNEL_AGENT_PRECACHE_ALL | CHANNEL_AGENT_DYNAMIC_SCHEDULE;
    }
    else
    {
        pBuf->clsidDest = CLSID_WebCrawlerAgent;
    }
    pBuf->bDesktop = (subType == SUBSTYPE_DESKTOPCHANNEL || subType == SUBSTYPE_DESKTOPURL);
    pBuf->bChannel = (subType == SUBSTYPE_CHANNEL || subType == SUBSTYPE_DESKTOPCHANNEL);
    pBuf->bGleam = !(pBuf->bDesktop);
    pBuf->m_LastUpdated = 0;
    pBuf->m_NextUpdate = 0;

    //  APPCOMPAT: Is this what we want?  IE 4 was DAILY.
    //  Default to not changing the schedule settings -- if it's already subscribed
    //  we won't blast anything and if it's not already subscribed then it will
    //  just be manual.
    pBuf->groupCookie = NOOP_SCHEDULE_COOKIE;

    pBuf->grfTaskTrigger = TASK_FLAG_RUN_IF_CONNECTED_TO_INTERNET |     // Default to not autodial
                           TASK_FLAG_START_ONLY_IF_IDLE;               // and to idle time

    return S_OK;
}

HRESULT CreateSubscriptionFromOOEBuf(OOEBuf *pBuf, LPMYPIDL *ppidl)
{
    HRESULT hr;
    DWORD dwBufferSize = BufferSize(pBuf);
    SUBSCRIPTIONCOOKIE cookie;

    *ppidl = COfflineFolderEnum::NewPidl(dwBufferSize);
    if (!(*ppidl))
    {
        return E_OUTOFMEMORY;
    }
    POOEntry pooe = &((*ppidl)->ooe);
    CopyToMyPooe(pBuf, pooe);

    //  See if the caller has already given us a cookie
    if (GUID_NULL == pooe->m_Cookie)
    {
        //  Nope, see if we have one already
	cookie = pooe->m_Cookie;
        ReadCookieFromInetDB(URL(pooe), &cookie);
	pooe->m_Cookie = cookie;

        if (GUID_NULL == pooe->m_Cookie)
        {
            //  Nope, so create one
            CreateCookie(&pooe->m_Cookie);
        }
    }

    cookie = pooe->m_Cookie;
    WriteCookieToInetDB(URL(pooe), &cookie, FALSE);
    pooe->m_Cookie = cookie;

    WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
    SUBSCRIPTIONITEMINFO sii;
    sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
    sii.dwFlags = 0;
    sii.dwPriority = 0;
    sii.ScheduleGroup = CLSID_NULL;
    sii.clsidAgent = pooe->clsidDest;
    MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), URL(pooe));
    hr = AddUpdateSubscription(&(pooe->m_Cookie), &sii, wszURL, 0, NULL, NULL);

    if (SUCCEEDED(hr))
    {
        hr = WriteProperties(pooe);

        if (SUCCEEDED(hr))
        {
            ISubscriptionItem *psi;

            hr = SubscriptionItemFromCookie(TRUE, &pooe->m_Cookie, &psi);

            if (SUCCEEDED(hr))
            {
                SUBSCRIPTIONSCHEDULE subGroup = GetGroup(pooe);
                SUBSCRIPTIONTYPE   subType = GetItemCategory(pooe);

                if (subGroup == SUBSSCHED_AUTO)
                {
                    if (subType != SUBSTYPE_CHANNEL && subType != SUBSTYPE_DESKTOPCHANNEL)
                    {
                        hr = AddIt(psi, pooe, SUBSSCHED_DAILY);
                    }
                    else
                    {
                        if (pooe->m_Trigger.cbTriggerSize == sizeof(TASK_TRIGGER))
                        {
			    TASK_TRIGGER trigger;

			    trigger = pooe->m_Trigger;
                            hr = ScheduleIt(psi, NAME(pooe), &trigger);
			    pooe->m_Trigger = trigger;

                            pooe->groupCookie = CLSID_NULL;
                        }
                        else
                        {
                            hr = AddIt(psi, pooe, SUBSSCHED_DAILY);
                        }
                    }
                }
                else
                {
                    hr = AddIt(psi, pooe, subGroup);
                }

                psi->Release();
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        FireSubscriptionEvent(SUBSNOTF_CREATE, &pooe->m_Cookie);
    }
    else
    {
        TraceMsg(TF_ALWAYS, "Failed to add new subscription");
        TraceMsg(TF_ALWAYS, "\thr = 0x%x", hr);
        COfflineFolderEnum::FreePidl(*ppidl);
        *ppidl = NULL;
    }

    return hr;
}

HRESULT SendUpdateRequests(HWND hwnd, CLSID * arrClsid, UINT count)
{
    ISubscriptionMgr2 *pSubsMgr2;
    HRESULT hr;

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                              IID_ISubscriptionMgr2, (void**)&pSubsMgr2);
        if (SUCCEEDED(hr))
        {
            SUBSCRIPTIONCOOKIE *pCookies = NULL;
            ULONG nItemsToRun = count;

            if (NULL == arrClsid)
            {
                IEnumSubscription *pes;

                hr = pSubsMgr2->EnumSubscriptions(0, &pes);

                if (SUCCEEDED(hr))
                {
                    ASSERT(NULL != pes);

                    pes->GetCount(&nItemsToRun);
                    if (nItemsToRun > 0)
                    {
                        pCookies = new SUBSCRIPTIONCOOKIE[nItemsToRun];

                        if (NULL != pCookies)
                        {
                            hr = pes->Next(nItemsToRun, pCookies, &nItemsToRun);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    pes->Release();
                }
            }
            else
            {
                pCookies = arrClsid;
            }

            if (SUCCEEDED(hr))
            {
                hr = pSubsMgr2->UpdateItems(0, nItemsToRun, pCookies);
            }

            if ((NULL == arrClsid) && (NULL != pCookies))
            {
                delete [] pCookies;
            }

            pSubsMgr2->Release();
        }
        CoUninitialize();
    }

    return hr;
}

HRESULT DoDeleteSubscription(POOEntry pooe)
{
    HRESULT hr;
    ISubscriptionItem *psi;

    ASSERT(NULL != pooe);

    hr = SubscriptionItemFromCookie(FALSE, &pooe->m_Cookie, &psi);

    if (SUCCEEDED(hr))
    {
        WritePassword(psi, NULL);

        hr = DoDeleteSubscriptionItem(&pooe->m_Cookie, TRUE);

        if (SUCCEEDED(hr) && (GetItemCategory(pooe) != SUBSTYPE_EXTERNAL))
        {
            WriteCookieToInetDB(URL(pooe), NULL, TRUE);
        }
    }

    return hr;
}

HRESULT PersistUpdate(POOEntry pooe, BOOL bCreate)
{
    HRESULT hr;
    ISubscriptionItem *psi;

    hr = SubscriptionItemFromCookie(bCreate, &(pooe->m_Cookie), &psi);

    if (SUCCEEDED(hr))
    {
        SUBSCRIPTIONITEMINFO sii = { sizeof(SUBSCRIPTIONITEMINFO) };

        hr = psi->GetSubscriptionItemInfo(&sii);

        if (SUCCEEDED(hr) || bCreate)
        {
            sii.clsidAgent = pooe->clsidDest;
            hr = psi->SetSubscriptionItemInfo(&sii);

            if (SUCCEEDED(hr))
            {
                hr = WritePropertiesToItem(pooe, psi);

                if (SUCCEEDED(hr) && IsNativeAgent(pooe->clsidDest))
                {
		    SUBSCRIPTIONCOOKIE cookie;

		    cookie = pooe->m_Cookie;
                    WriteCookieToInetDB(URL(pooe), &cookie, FALSE);
		    pooe->m_Cookie = cookie;
                }
            }
        }

        // REVIEW: should we delete on failure here?
        psi->Release();
    }

    return hr;
}

#ifdef NEWSCHED_AUTONAME
void NewSched_AutoNameHelper(HWND hDlg)
{
    TCHAR szDays[16];
    TCHAR szTime[128];
    TCHAR szFormat[MAX_PATH];
    TCHAR szSchedName[MAX_PATH];
    LPTSTR lpArguments[2];
    BOOL bTranslate;
    int nDays = GetDlgItemInt(hDlg, IDC_SCHEDULE_DAYS, &bTranslate, FALSE);

    if (MLLoadString((nDays == 1) ? IDS_SCHED_FORMAT_DAILY : IDS_SCHED_FORMAT,
        szFormat, ARRAYSIZE(szFormat)))
    {
        TCHAR szTimeFormat[32];
        SYSTEMTIME st;

        DateTime_GetSystemtime(GetDlgItem(hDlg, IDC_SCHEDULE_TIME), &st);

        UpdateTimeFormat(szTimeFormat, ARRAYSIZE(szTimeFormat));
        GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st,
                      szTimeFormat, szTime, ARRAYSIZE(szTime));
        GetDlgItemText(hDlg, IDC_SCHEDULE_DAYS, szDays, ARRAYSIZE(szDays));

        lpArguments[0] = szDays;
        lpArguments[1] = szTime;

        if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          szFormat, 0, 0, szSchedName, ARRAYSIZE(szSchedName),
                          (va_list *)&lpArguments[0]))
        {
            SetDlgItemText(hDlg, IDC_SCHEDULE_NAME, szSchedName);
        }
    }
}
#endif

BOOL NewSched_ResolveNameConflictHelper(HWND hDlg, TASK_TRIGGER *pTrig,
                                        SYNCSCHEDULECOOKIE *pSchedCookie)
{
    BOOL bResult;

    SYSTEMTIME st;
    TCHAR szSchedName[MAX_PATH];

    GetDlgItemText(hDlg, IDC_SCHEDULE_NAME, szSchedName, ARRAYSIZE(szSchedName));

    TrimWhiteSpace(szSchedName);

    if (szSchedName[0] != 0)
    {
        bResult = TRUE;

        memset(pTrig, 0, sizeof(TASK_TRIGGER));
        pTrig->cbTriggerSize = sizeof(TASK_TRIGGER);

        GetLocalTime(&st);
        pTrig->wBeginYear = st.wYear;
        pTrig->wBeginMonth = st.wMonth;
        pTrig->wBeginDay = st.wDay;

        DateTime_GetSystemtime(GetDlgItem(hDlg, IDC_SCHEDULE_TIME), &st);
        pTrig->wStartHour = st.wHour;
        pTrig->wStartMinute = st.wMinute;

        pTrig->TriggerType = TASK_TIME_TRIGGER_DAILY;

        BOOL bTranslated;
        pTrig->Type.Daily.DaysInterval = (WORD)GetDlgItemInt(hDlg, IDC_SCHEDULE_DAYS, &bTranslated, FALSE);

        int iConflictResult = HandleScheduleNameConflict(szSchedName,
                                                         pTrig,
                                                         hDlg,
                                                         pSchedCookie);
        switch (iConflictResult)
        {
            case CONFLICT_NONE:
                ASSERT(GUID_NULL == *pSchedCookie);
                break;

            case CONFLICT_RESOLVED_USE_NEW:
                ASSERT(GUID_NULL != *pSchedCookie);
                break;

            case CONFLICT_RESOLVED_USE_OLD:
                ASSERT(GUID_NULL == *pSchedCookie);
                pTrig->cbTriggerSize = 0;
                break;

            case CONFLICT_UNRESOLVED:
                bResult = FALSE;
                break;
        }
    }
    else
    {
        SGMessageBox(hDlg, IDS_EMPTY_SCHEDULE_NAME, MB_OK | MB_ICONWARNING);
        bResult = FALSE;
    }

    return bResult;
}

void NewSched_CreateScheduleHelper(HWND hDlg, TASK_TRIGGER *pTrig,
                                   SYNCSCHEDULECOOKIE *pSchedCookie)
{
    HRESULT hr;

    if (GUID_NULL == *pSchedCookie)
    {
        //  Create new schedule
        TCHAR szSchedName[MAX_PATH];
        WCHAR wszSchedName[MAX_PATH];

        DWORD dwSyncScheduleFlags =
            (IsDlgButtonChecked(hDlg, IDC_WIZ_SCHEDULE_AUTOCONNECT) == BST_CHECKED)
                 ? SYNCSCHEDINFO_FLAGS_AUTOCONNECT : 0;

        GetDlgItemText(hDlg, IDC_SCHEDULE_NAME, szSchedName, ARRAYSIZE(szSchedName));
        MyStrToOleStrN(wszSchedName, ARRAYSIZE(wszSchedName), szSchedName);
        hr = CreateSchedule(wszSchedName, dwSyncScheduleFlags, pSchedCookie, pTrig, FALSE);

        ASSERT(SUCCEEDED(hr));
    }
    else if (sizeof(TASK_TRIGGER) == pTrig->cbTriggerSize)
    {
        //  Update existing schedule with new task trigger
        hr = UpdateScheduleTrigger(pSchedCookie, pTrig);
        ASSERT(SUCCEEDED(hr));
    }
    else
    {
        //  Use existing schedule without munging it
    }
}

void NewSched_SetDefaultScheduleName(HWND hDlg)
{
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        ISyncScheduleMgr *pSyncScheduleMgr;

        if (SUCCEEDED(CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL,
                                       IID_ISyncScheduleMgr,
                                       (void **)&pSyncScheduleMgr)))
        {
            SYNCSCHEDULECOOKIE schedCookie;
            ISyncSchedule *pSyncSchedule;

            if (SUCCEEDED(pSyncScheduleMgr->CreateSchedule(L"", 0, &schedCookie, &pSyncSchedule)))
            {
                WCHAR wszSchedName[MAX_PATH];
                DWORD cchSchedName = ARRAYSIZE(wszSchedName);

                if (SUCCEEDED(pSyncSchedule->GetScheduleName(&cchSchedName, wszSchedName)))
                {
                    TCHAR szSchedName[MAX_PATH];

                    MyOleStrToStrN(szSchedName, ARRAYSIZE(szSchedName), wszSchedName);
                    SetDlgItemText(hDlg, IDC_SCHEDULE_NAME, szSchedName);
                }
                pSyncSchedule->Release();
            }
            pSyncScheduleMgr->Release();
        }
        CoUninitialize();
    }
}

void NewSched_OnInitDialogHelper(HWND hDlg)
{
    SYSTEMTIME st;

    GetLocalTime(&st);

    Edit_LimitText(GetDlgItem(hDlg, IDC_SCHEDULE_NAME), MAX_PATH - 1);
    Edit_LimitText(GetDlgItem(hDlg, IDC_SCHEDULE_DAYS), 2);
    SendMessage(GetDlgItem(hDlg, IDC_SCHEDULE_DAYS_SPIN),
                UDM_SETRANGE, 0, MAKELONG(99, 1));
    SendMessage(GetDlgItem(hDlg, IDC_SCHEDULE_DAYS_SPIN), UDM_SETPOS, 0, 1);

    HWND hwndTimePicker = GetDlgItem(hDlg, IDC_SCHEDULE_TIME);
    TCHAR szTimeFormat[32];

    UpdateTimeFormat(szTimeFormat, ARRAYSIZE(szTimeFormat));
    DateTime_SetSystemtime(hwndTimePicker, GDT_VALID, &st);
    DateTime_SetFormat(hwndTimePicker, szTimeFormat);

    NewSched_SetDefaultScheduleName(hDlg);
}

int KeepSpinNumberInRange(HWND hdlg, int idEdit, int idSpin, int minVal, int maxVal)
{
    BOOL bTranslate;
    int val = GetDlgItemInt(hdlg, idEdit, &bTranslate, FALSE);
    if (!bTranslate || (val  < minVal) || (val > maxVal))
    {
        //  We have a problem, query the spin control
        val = LOWORD(SendDlgItemMessage(hdlg, idSpin, UDM_GETPOS, 0, 0));
        val = max(minVal, min(maxVal, val));
        SetDlgItemInt(hdlg, idEdit, val, FALSE);
    }

    return val;
}


void SetPropSheetFlags(POOEBuf pBuf, BOOL bSet, DWORD dwPropSheetFlags)
{
    if (bSet)
    {
        pBuf->m_dwPropSheetFlags |= dwPropSheetFlags;
    }
    else
    {
        pBuf->m_dwPropSheetFlags &= ~dwPropSheetFlags;
    }
}


HRESULT FindURLProps(LPCTSTR m_URL, PROPVARIANT * pVarInfo)
{
    HRESULT hr;

    hr = IntSiteHelper(m_URL, &c_rgPropRead[PROP_SUBSCRIPTION], pVarInfo, 1, FALSE);
    return hr;
}

HRESULT LoadOOEntryInfo(POOEBuf pBuf, SUBSCRIPTIONCOOKIE *pCookie, DWORD *pdwSize)
{
    HRESULT hr;

    if (!pBuf || !pCookie || !pdwSize)
    {
        TraceMsg(TF_ALWAYS, "Invalid ARG (1/2/3) %x %x", pBuf, pCookie, pdwSize);
        return E_INVALIDARG;
    }

    ISubscriptionItem *psi;
    hr = SubscriptionItemFromCookie(FALSE, pCookie, &psi);

    if (SUCCEEDED(hr))
    {
        SUBSCRIPTIONITEMINFO sii;

        sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

        hr = psi->GetSubscriptionItemInfo(&sii);

        if (SUCCEEDED(hr))
        {
            ZeroMemory((void *)pBuf, sizeof(OOEBuf));
            pBuf->m_Cookie = *pCookie;

        //  TODO: resolve scheduling goo!

        //    pBuf->groupCookie = pItem->groupCookie;
        //    pBuf->grfTaskTrigger = pItem->TaskData.dwTaskFlags;
        /*    if (pItem->groupCookie == CLSID_NULL)   {
                pBuf->m_Trigger = pItem->TaskTrigger;
                if (pBuf->m_Trigger.cbTriggerSize != sizeof(TASK_TRIGGER))  {
                    ASSERT(0);
                    return E_INVALIDARG;
                }
            } else  {
                pBuf->m_Trigger.cbTriggerSize = 0;  //  Invalid
            }
        */

            pBuf->clsidDest = sii.clsidAgent;

            if (!IsNativeAgent(sii.clsidAgent))
            {
                pBuf->dwFlags = PROP_WEBCRAWL_EXTERNAL;
            }
            else
            {
                pBuf->dwFlags = PROP_WEBCRAWL_ALL;
            }

            hr = ReadProperties(pBuf);
            *pdwSize = BufferSize(pBuf);
        }
        psi->Release();
    }

    return hr;
}

/////////////////////////////////////////////////
//
//  SaveBufferChange
//      newBuf: [in/out]
/////////////////////////////////////////////////

HRESULT SaveBufferChange(POOEBuf newBuf, BOOL bCreate)
{
    HRESULT hr;
    DWORD   dwSize;
    POOEntry pooe;
    LPMYPIDL newPidl;

    ASSERT (newBuf);
    if (newBuf->dwFlags == 0)
        return S_OK;

    dwSize = BufferSize(newBuf);
    newPidl = COfflineFolderEnum::NewPidl(dwSize);
    if (!newPidl)
        return E_OUTOFMEMORY;

    pooe = &(newPidl->ooe);
    CopyToMyPooe(newBuf, pooe);
    newBuf->dwFlags = 0;
    hr = PersistUpdate(pooe, bCreate);
    if (SUCCEEDED(hr))  {
        SUBSCRIPTIONCOOKIE cookie;

        DWORD dwPropSheetFlags = newBuf->m_dwPropSheetFlags; //  Preserve prop sheet flags

	cookie = pooe->m_Cookie;
        hr = LoadWithCookie(URL(pooe), newBuf, &dwSize, &cookie);
	pooe->m_Cookie = cookie;

        newBuf->m_dwPropSheetFlags = dwPropSheetFlags;  //  restore
        newBuf->dwFlags = 0;
        if (hr == S_OK)  {
            COfflineFolderEnum::FreePidl(newPidl);
            newPidl = COfflineFolderEnum::NewPidl(dwSize);
            if (!(newPidl))  {
                return E_OUTOFMEMORY;
            }
            pooe = &(newPidl->ooe);
            CopyToMyPooe(newBuf, pooe);
        }
        _GenerateEvent(SHCNE_UPDATEITEM, (LPITEMIDLIST)newPidl, NULL);
    }
    COfflineFolderEnum::FreePidl(newPidl);
    return hr;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// IntSiteHelper
//
// pszURL               url to read/write props for
// pPropspec            properties to read or write
// pReadPropvar         where to store or get properties
// uPropVarArraySize    number of properties
// fWrite               read/write flag
//

HRESULT IntSiteHelper(LPCTSTR pszURL, const PROPSPEC *pPropspec,
        PROPVARIANT *pPropvar, UINT uPropVarArraySize, BOOL fWrite)
{
    HRESULT                     hr;
    IUniformResourceLocator *   purl = NULL;
    IPropertySetStorage *       ppropsetstg = NULL; // init to keep compiler happy
    IPropertyStorage *          ppropstg = NULL; // init to keep compiler happy

    hr = SHCoCreateInstance(NULL, &CLSID_InternetShortcut, NULL,
            IID_IUniformResourceLocator, (LPVOID*)&purl);

    if(SUCCEEDED(hr)) {
        hr = purl->SetURL(pszURL, 0);
    }

    if(SUCCEEDED(hr)) {
        hr = purl->QueryInterface(IID_IPropertySetStorage,
                (LPVOID *)&ppropsetstg);
    }

    if(SUCCEEDED(hr)) {
        hr = ppropsetstg->Open(FMTID_InternetSite, STGM_READWRITE, &ppropstg);
        ppropsetstg->Release();
    }

    if(SUCCEEDED(hr)) {
        if(fWrite) {
            hr = ppropstg->WriteMultiple(uPropVarArraySize, pPropspec,
                            pPropvar, 0);
            ppropstg->Commit(STGC_DEFAULT);
        } else {
            hr = ppropstg->ReadMultiple(uPropVarArraySize, pPropspec,
                            pPropvar);
        }
        ppropstg->Release();
    }

    if(purl)
        purl->Release();

    return hr;
}

// CODE FROM SYNCMGR SOURCES.

//
// Local constants
//
// DEFAULT_TIME_FORMAT - what to use if there's a problem getting format
//                       from system.
//
#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))
#define DEFAULT_TIME_FORMAT         TEXT("hh:mm tt")
#define GET_LOCALE_INFO(lcid)                           \
        {                                               \
            cch = GetLocaleInfo(LOCALE_USER_DEFAULT,    \
                                (lcid),                 \
                                tszScratch,             \
                                ARRAYLEN(tszScratch));  \
            if (!cch)                                   \
            {                                           \
                break;                                  \
            }                                           \
        }
//+--------------------------------------------------------------------------
//
//  Function:   UpdateTimeFormat
//
//  Synopsis:   Construct a time format containing hour and minute for use
//              with the date picker control.
//
//  Arguments:  [tszTimeFormat] - buffer to fill with time format
//              [cchTimeFormat] - size in chars of buffer
//
//  Modifies:   *[tszTimeFormat]
//
//  History:    11-18-1996   DavidMun   Created
//
//  Notes:      This is called on initialization and for wininichange
//              processing.
//
//---------------------------------------------------------------------------
void
UpdateTimeFormat(
        LPTSTR tszTimeFormat,
        ULONG  cchTimeFormat)
{
    ULONG cch;
    TCHAR tszScratch[80];
    BOOL  fAmPm = FALSE;
    BOOL  fAmPmPrefixes = FALSE;
    BOOL  fLeadingZero = FALSE;

    do
    {
        GET_LOCALE_INFO(LOCALE_ITIME);
        fAmPm = (*tszScratch == TEXT('0'));

        if (fAmPm)
        {
            GET_LOCALE_INFO(LOCALE_ITIMEMARKPOSN);
            fAmPmPrefixes = (*tszScratch == TEXT('1'));
        }

        GET_LOCALE_INFO(LOCALE_ITLZERO);
        fLeadingZero = (*tszScratch == TEXT('1'));

        GET_LOCALE_INFO(LOCALE_STIME);

        //
        // See if there's enough room in destination string
        //

        cch = 1                     +  // terminating nul
              1                     +  // first hour digit specifier "h"
              2                     +  // minutes specifier "mm"
              (fLeadingZero != 0)   +  // leading hour digit specifier "h"
              lstrlen(tszScratch)   +  // separator string
              (fAmPm ? 3 : 0);         // space and "tt" for AM/PM

        if (cch > cchTimeFormat)
        {
            cch = 0; // signal error
        }
    } while (0);

    //
    // If there was a problem in getting locale info for building time string
    // just use the default and bail.
    //

    if (!cch)
    {
        StrCpy(tszTimeFormat, DEFAULT_TIME_FORMAT);
        return;
    }

    //
    // Build a time string that has hours and minutes but no seconds.
    //

    tszTimeFormat[0] = TEXT('\0');

    if (fAmPm)
    {
        if (fAmPmPrefixes)
        {
            StrCpy(tszTimeFormat, TEXT("tt "));
        }

        StrCat(tszTimeFormat, TEXT("h"));

        if (fLeadingZero)
        {
            StrCat(tszTimeFormat, TEXT("h"));
        }
    }
    else
    {
        StrCat(tszTimeFormat, TEXT("H"));

        if (fLeadingZero)
        {
            StrCat(tszTimeFormat, TEXT("H"));
        }
    }

    StrCat(tszTimeFormat, tszScratch); // separator
    StrCat(tszTimeFormat, TEXT("mm"));

    if (fAmPm && !fAmPmPrefixes)
    {
        StrCat(tszTimeFormat, TEXT(" tt"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\idle.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       idle.cpp
//
//  Contents:   user idle detection
//
//  Classes:
//
//  Functions:
//
//  History:    05-14-1997  darrenmi (Darren Mitchell) Created
//
//----------------------------------------------------------------------------

#include "private.h"
#include "throttle.h"

typedef void (WINAPI* _IDLECALLBACK) (DWORD dwState);
typedef DWORD (WINAPI* _BEGINIDLEDETECTION) (_IDLECALLBACK, DWORD, DWORD);
typedef BOOL (WINAPI* _ENDIDLEDETECTION) (DWORD);

#define TF_THISMODULE TF_WEBCHECKCORE

HINSTANCE           g_hinstMSIDLE = NULL;
_BEGINIDLEDETECTION g_pfnBegin = NULL;
_ENDIDLEDETECTION   g_pfnEnd = NULL;

//
// extra stuff so we don't need msidle.dll on win95
//
BOOL    g_fWin95PerfWin = FALSE;            // using msidle.dll or not?
UINT_PTR g_uIdleTimer = 0;                  // timer handle if not
HANDLE  g_hSageVxd = INVALID_HANDLE_VALUE;  // vxd handle if not
DWORD   g_dwIdleMin = 3;                    // inactivity mins before idle
BOOL    g_fIdle = FALSE;                    // are we idle?
DWORD   g_dwIdleBeginTicks = 0;             // when did idle begin?

VOID CALLBACK OnIdleTimer(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

//
// A little code copied from msidle.dll.  We use this on Win95 with sage.vxd
// so we don't have to load msidle.dll. 
//

//
// SetIdleTimer - decide how often to poll and set the timer appropriately
//
void SetIdleTimer(void)
{
    UINT uInterval = 1000 * 60;

    //
    // If we're idle and looking for busy, check every 2 seconds
    //
    if(g_fIdle) {
        uInterval = 1000 * 4;
    }

    //
    // kill off the old timer
    //
    if(g_uIdleTimer) {
        KillTimer(NULL, g_uIdleTimer);
    }

    //
    // Set the timer
    //
    TraceMsg(TF_THISMODULE,"SetIdleTimer uInterval=%d", uInterval);
    g_uIdleTimer = SetTimer(NULL, 0, uInterval, OnIdleTimer);
}
       
//
// OnIdleTimer - idle timer has gone off
//
VOID CALLBACK OnIdleTimer(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    DWORD dwDiff, dwLastActivityTicks;

    //
    // get last activity ticks from sage
    //
    DeviceIoControl(g_hSageVxd, 2, &dwLastActivityTicks, sizeof(DWORD),
        NULL, 0, NULL, NULL);

    //
    // check to see if we've changed state
    //
    if(g_fIdle) {
        //
        // currently in idle state
        //
        if(dwLastActivityTicks != g_dwIdleBeginTicks) {
            // activity since we became idle - stop being idle!
            g_fIdle = FALSE;

            // set timer
            SetIdleTimer();

            // call back client
            CThrottler::OnIdleStateChange(STATE_USER_IDLE_END);
        }

    } else {
        //
        // currently not in idle state
        //
        dwDiff = GetTickCount() - dwLastActivityTicks;

        if(dwDiff > 1000 * 60 * g_dwIdleMin) {
            // Nothing's happened for our threshold time.  We're now idle.
            g_fIdle = TRUE;

            // save time we became idle
            g_dwIdleBeginTicks = dwLastActivityTicks;

            // set timer
            SetIdleTimer();

            // call back client
            CThrottler::OnIdleStateChange(STATE_USER_IDLE_BEGIN);
        }
    }
}

BOOL LoadSageVxd(void)
{
    int inpVXD[3];

    if(INVALID_HANDLE_VALUE != g_hSageVxd)
        return TRUE;

    g_hSageVxd = CreateFile(TEXT("\\\\.\\sage.vxd"), 0, 0, NULL, 0,
            FILE_FLAG_DELETE_ON_CLOSE, NULL);

    // can't open it?  can't use it
    if(INVALID_HANDLE_VALUE == g_hSageVxd)
        return FALSE;

    // start it monitoring
    inpVXD[0] = -1;         // no window - will query
    inpVXD[1] = 0;          // unused
    inpVXD[2] = 0;          // post delay - not used without a window

    DeviceIoControl(g_hSageVxd, 1, &inpVXD, sizeof(inpVXD), NULL, 0, NULL, NULL);

    return TRUE;
}

BOOL UnloadSageVxd(void)
{
    if(INVALID_HANDLE_VALUE != g_hSageVxd) {
        CloseHandle(g_hSageVxd);
        g_hSageVxd = INVALID_HANDLE_VALUE;
    }

    return TRUE;
}

void IdleBegin(HWND hwndParent)
{
    DWORD dwValue;

    // Override idle minutes with reg value if present
    if(ReadRegValue(HKEY_CURRENT_USER,
            c_szRegKey,
            TEXT("IdleMinutes"),
            &dwValue,
            sizeof(DWORD)) &&
        dwValue) {

        g_dwIdleMin = dwValue;
    }

    if(FALSE == g_fIsWinNT && LoadSageVxd()) {
        // using optimal win95 configuration
        g_fWin95PerfWin = TRUE;
        SetIdleTimer();
        return;
    }

    // Bail out if the DebuggerFriendly registry value is set on NT4.
    OSVERSIONINFOA vi;
    vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    GetVersionExA(&vi);

    if(   vi.dwPlatformId == VER_PLATFORM_WIN32_NT
       && vi.dwMajorVersion == 4
       && ReadRegValue(HKEY_CURRENT_USER, c_szRegKey, TEXT("DebuggerFriendly"), &dwValue, sizeof(DWORD))
       && dwValue)
    {
        return;
    }


    // load msidle.dll
    g_hinstMSIDLE = LoadLibrary(TEXT("msidle.dll"));

    // get begin and end functions
    if(g_hinstMSIDLE) {
        g_pfnBegin = (_BEGINIDLEDETECTION)GetProcAddress(g_hinstMSIDLE, (LPSTR)3);
        g_pfnEnd = (_ENDIDLEDETECTION)GetProcAddress(g_hinstMSIDLE, (LPSTR)4);

        // call start monitoring
        if(g_pfnBegin)
            (g_pfnBegin)(CThrottler::OnIdleStateChange, g_dwIdleMin, 0);
    }
}

void IdleEnd(void)
{
    if(g_fWin95PerfWin) {
        // clean up timer
        KillTimer(NULL, g_uIdleTimer);
        UnloadSageVxd();
    } else {
        // clean up msidle.dll
        if(g_pfnEnd) {
            (g_pfnEnd)(0);
            FreeLibrary(g_hinstMSIDLE);
            g_hinstMSIDLE = NULL;
            g_pfnBegin = NULL;
            g_pfnEnd = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\item.cpp ===
#include "private.h"
#include "offl_cpp.h"

#include <mluisupp.h>

// registered clipboard formats
UINT g_cfFileDescriptor = 0;
UINT g_cfFileContents = 0;
UINT g_cfPrefDropEffect = 0;
UINT g_cfURL = 0;

HICON g_webCrawlerIcon = NULL;
HICON g_channelIcon = NULL;
HICON g_desktopIcon = NULL;

#define MAX_ITEM_OPEN 10

//////////////////////////////////////////////////////////////////////////////
// COfflineObjectItem Object
//////////////////////////////////////////////////////////////////////////////

void LoadDefaultIcons()
{
    if (g_webCrawlerIcon == NULL) 
    {
        g_webCrawlerIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_SUBSCRIBE));
        g_channelIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_CHANNEL));
        g_desktopIcon = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_DESKTOPITEM));
    }
}

COfflineObjectItem::COfflineObjectItem() 
{
    TraceMsg(TF_SUBSFOLDER, "hci - COfflineObjectItem() called.");
    DllAddRef();
    _cRef = 1;
}        

COfflineObjectItem::~COfflineObjectItem()
{
    Assert(_cRef == 0);                 // we should have zero ref count here

    TraceMsg(TF_SUBSFOLDER, "hci - ~COfflineObjectItem() called.");
    
    SAFERELEASE(m_pUIHelper);
    SAFERELEASE(_pOOFolder);

    if (_ppooi)
    {
        for (UINT i = 0; i < _cItems; i++) 
        {
            if (_ppooi[i])
                ILFree((LPITEMIDLIST)_ppooi[i]);
        }
        MemFree((HLOCAL)_ppooi);
    }
    
    DllRelease();
}

HRESULT COfflineObjectItem::Initialize(COfflineFolder *pOOFolder, UINT cidl, LPCITEMIDLIST *ppidl)
{
    _ppooi = (LPMYPIDL *)MemAlloc(LPTR, cidl * sizeof(LPMYPIDL));
    if (!_ppooi)
        return E_OUTOFMEMORY;
    
    _cItems     = cidl;

    for (UINT i = 0; i < cidl; i++)
    {
        // we need to clone the whole array, so if one of them fails, we'll
        // destroy the ones we've already created
        _ppooi[i] = (LPMYPIDL)ILClone(ppidl[i]);
        if (!_ppooi[i]) {
            UINT j = 0;

            for (; j < i; j++)  {
                ILFree((LPITEMIDLIST)_ppooi[j]);
                _ppooi[j] = NULL;
            }

            MemFree((HLOCAL)_ppooi);
            return E_OUTOFMEMORY;
        }
    }   
    
    _pOOFolder = pOOFolder;
    _pOOFolder->AddRef();      // we're going to hold onto this pointer, so
                               // we need to AddRef it.

    //  If there is only one item here, we initialize UI helper.
    if (_cItems == 1)
    {
        ASSERT(!m_pUIHelper);
        POOEntry pooe = &(_ppooi[0]->ooe);

        HRESULT hr = CoInitialize(NULL);

        ASSERT(SUCCEEDED(hr));

        if (SUCCEEDED(hr))
        {
            hr = CoCreateInstance(*(&(pooe->clsidDest)), NULL, CLSCTX_INPROC_SERVER, 
                                  IID_IUnknown, (void **)&m_pUIHelper);

            ASSERT(SUCCEEDED(hr));
            ASSERT(m_pUIHelper);

            if (SUCCEEDED(hr))
            {
                ISubscriptionAgentShellExt *psase;
                
                hr = m_pUIHelper->QueryInterface(IID_ISubscriptionAgentShellExt, (void **)&psase);
                if (SUCCEEDED(hr))
                {
                    WCHAR wszURL[MAX_URL + 1];
                    WCHAR wszName[MAX_NAME + 1];
		    SUBSCRIPTIONCOOKIE alignedCookie;

                    MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), URL(pooe));
                    MyStrToOleStrN(wszName, ARRAYSIZE(wszName), NAME(pooe));

                    alignedCookie = pooe->m_Cookie;
                    psase->Initialize(&alignedCookie, wszURL, wszName, (SUBSCRIPTIONTYPE)-1);
		    pooe->m_Cookie = alignedCookie;

                    psase->Release();
                }
            }
            CoUninitialize();
        }
    }
    return S_OK;
}        

HRESULT COfflineObjectItem_CreateInstance
(
    COfflineFolder *pOOFolder,
    UINT cidl, 
    LPCITEMIDLIST *ppidl, 
    REFIID riid, 
    void **ppvOut
)
{
    COfflineObjectItem *pOOItem;
    HRESULT hr;

    *ppvOut = NULL;                 // null the out param

    if (!_ValidateIDListArray(cidl, ppidl))
        return E_FAIL;

#ifdef UNICODE
    if (((riid == IID_IExtractIconA) || (riid == IID_IExtractIconW)) && (cidl != 1))
#else
    if ((riid == IID_IExtractIcon) && (cidl != 1))
#endif
        return E_FAIL;      //  What do you need this icon for?

    pOOItem = new COfflineObjectItem;
    if (!pOOItem)
        return E_OUTOFMEMORY;

    hr = pOOItem->Initialize(pOOFolder, cidl, ppidl);
    if (SUCCEEDED(hr))
    {
        hr = pOOItem->QueryInterface(riid, ppvOut);
    }
    pOOItem->Release();

    if (g_cfPrefDropEffect == 0)
    {
        g_cfFileDescriptor = RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR); // "FileContents"
        g_cfFileContents = RegisterClipboardFormat(CFSTR_FILECONTENTS);     // "FileDescriptor"
        g_cfPrefDropEffect = RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
        g_cfURL = RegisterClipboardFormat(CFSTR_SHELLURL);
    }
    
    return hr;
}

// IUnknown Methods...

HRESULT COfflineObjectItem::QueryInterface(REFIID iid, LPVOID *ppvObj)
{
//    TraceMsg(TF_ALWAYS, TEXT("hci - QueryInterface() called."));
    
    *ppvObj = NULL;     // null the out param
    
    if (iid == IID_IUnknown) {
        TraceMsg(TF_SUBSFOLDER, "  getting IUnknown");
        *ppvObj = (LPVOID)this;
    }
    else if (iid == IID_IContextMenu) {
        TraceMsg(TF_SUBSFOLDER, "   getting IContextMenu");
        *ppvObj = (LPVOID)(IContextMenu *)this;
    }
    else if (iid == IID_IQueryInfo)  {
        TraceMsg(TF_SUBSFOLDER, "  getting IQueryInfo");
        *ppvObj = (LPVOID)(IQueryInfo *)this;
    }
    else if (iid == IID_IDataObject) {
        TraceMsg(TF_SUBSFOLDER, "  getting IDataObject");
        *ppvObj = (LPVOID)(IDataObject *)this;
    }
#ifdef UNICODE
    else if ((iid == IID_IExtractIconA) || (iid == IID_IExtractIconW)) {
#else
    else if (iid == IID_IExtractIcon) {
#endif
        if (m_pUIHelper)    {
            TraceMsg(TF_SUBSFOLDER, "  getting IExtractIcon from UIHelper");
            if (S_OK == m_pUIHelper->QueryInterface(iid, ppvObj))
                return S_OK;
            else
                TraceMsg(TF_SUBSFOLDER, "  failed to get IExtractIcon from UIHelper");
        } 
        TraceMsg(TF_SUBSFOLDER, "  getting default IExtractIcon");
#ifdef UNICODE
        *ppvObj = iid == IID_IExtractIconA ? 
            (LPVOID)(IExtractIconA *)this :
            (LPVOID)(IExtractIconW *)this;
#else
        *ppvObj = (LPVOID)(IExtractIcon*)this;
#endif
    }
    else if (iid == IID_IOfflineObject) {
        TraceMsg(TF_SUBSFOLDER, "  getting IOfflineObject");
        *ppvObj = (LPVOID)this;
    }        
    
    if (*ppvObj) 
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();
        return S_OK;
    }

    DBGIID("COfflineObjectItem::QueryInterface() failed", iid);
    return E_NOINTERFACE;
}

ULONG COfflineObjectItem::AddRef()
{
    return ++_cRef;
}

ULONG COfflineObjectItem::Release()
{
    if (0L != --_cRef)
        return _cRef;

    delete this;
    return 0;   
}


// IContextMenu Methods

HRESULT COfflineObjectItem::QueryContextMenu
(
    HMENU hmenu, 
    UINT indexMenu, 
    UINT idCmdFirst,
    UINT idCmdLast, 
    UINT uFlags
)
{
    UINT cItems;

    TraceMsg(TF_SUBSFOLDER, "Item::QueryContextMenu() called.");
    
    ///////////////////////////////////////////////////////////
    //  FEATURE: May also need some category specific code here.

#ifdef DEBUG
    int imi = GetMenuItemCount(hmenu);
    while (--imi >= 0)
    {
        MENUITEMINFO mii = {
            sizeof(MENUITEMINFO), MIIM_ID | MIIM_SUBMENU | MIIM_TYPE, 
            0, 0, 0, 0, 0, 0, 0, 0, 0};
        if (GetMenuItemInfo(hmenu, imi, TRUE, &mii)) {
            ;
        }
    }
#endif
    if ((uFlags & CMF_VERBSONLY) || (uFlags & CMF_DVFILE))
        cItems = MergePopupMenu(&hmenu, POPUP_CONTEXT_VERBSONLY, 0, indexMenu, 
                                idCmdFirst - RSVIDM_FIRST, idCmdLast);
    else
    {
        if (_ppooi[0]->ooe.bChannel &&
            SHRestricted2(REST_NoEditingChannels, URL(&(_ppooi[0]->ooe)), 0))
        {
            cItems = MergePopupMenu(&hmenu, POPUP_RESTRICTED_CONTEXT, 0, indexMenu,
                                    idCmdFirst - RSVIDM_FIRST, idCmdLast);
        }
        else
        {
            cItems = MergePopupMenu(&hmenu, POPUP_OFFLINE_CONTEXT, 0, indexMenu,
                                    idCmdFirst - RSVIDM_FIRST, idCmdLast);
        }
        if (_cItems > 1)
            EnableMenuItem(hmenu, RSVIDM_PROPERTIES + idCmdFirst - RSVIDM_FIRST, MF_BYCOMMAND | MF_GRAYED);
    }

    if (SHRestricted2(REST_NoManualUpdates, URL(&(_ppooi[0]->ooe)), 0))
        EnableMenuItem(hmenu, RSVIDM_UPDATE + idCmdFirst - RSVIDM_FIRST, MF_BYCOMMAND | MF_GRAYED); 
    
    SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);

    return ResultFromShort(cItems);    // number of menu items    
}


STDMETHODIMP COfflineObjectItem::InvokeCommand
(
    LPCMINVOKECOMMANDINFO pici
)
{
    UINT i;
    int idCmd = _GetCmdID(pici->lpVerb);
    HRESULT hres = S_OK;
    CLSID   * pClsid = NULL;
    int     updateCount = 0;

    TraceMsg(TF_SUBSFOLDER, "hci - cm - InvokeCommand() called.");

    if (idCmd == RSVIDM_DELETE)
    {
        BOOL fRet = ConfirmDelete(pici->hwnd, _cItems, _ppooi);
        if (!fRet)
            return S_FALSE;
    } else if (idCmd == RSVIDM_UPDATE)  {
        pClsid = (CLSID *)MemAlloc(LPTR, sizeof(CLSID) * _cItems);
        if (!pClsid)
            return E_OUTOFMEMORY;
    }
        
    for (i = 0; i < _cItems; i++)
    {
        if (_ppooi[i]) 
        {
            SUBSCRIPTIONTYPE    subType; 
            switch (idCmd)
            {
            case RSVIDM_OPEN:
                if (i >= MAX_ITEM_OPEN)
                {
                    hres = S_FALSE;
                    goto Done;
                }

                subType = GetItemCategory(&(_ppooi[i]->ooe)); 
                switch (subType)   {
                case SUBSTYPE_URL:
                case SUBSTYPE_CHANNEL:
                case SUBSTYPE_DESKTOPURL:
                case SUBSTYPE_DESKTOPCHANNEL:
                    hres = _LaunchApp(pici->hwnd,URL(&(_ppooi[i]->ooe))); 
                    break;
                default:
                    break;
                }
                break;

            case RSVIDM_COPY:
                OleSetClipboard((IDataObject *)this);
                goto Done;

            case RSVIDM_DELETE:
                hres = DoDeleteSubscription(&(_ppooi[i]->ooe));
                if (SUCCEEDED(hres))
                    _GenerateEvent(SHCNE_DELETE,(LPITEMIDLIST)(_ppooi[i]),NULL);
                break;

            case RSVIDM_PROPERTIES: 
                { 
                    POOEntry pooe = &(_ppooi[i]->ooe);
                    OOEBuf ooeBuf;
                    int iRet;

                    pooe->dwFlags = 0;
                    CopyToOOEBuf(pooe, &ooeBuf);

                    subType = GetItemCategory(&(_ppooi[i]->ooe)); 
                    switch (subType)   {
                    case SUBSTYPE_URL:
                    case SUBSTYPE_CHANNEL:
                    case SUBSTYPE_DESKTOPCHANNEL:
                    case SUBSTYPE_DESKTOPURL:
                    case SUBSTYPE_EXTERNAL:
                        iRet = _CreatePropSheet(pici->hwnd,&ooeBuf);
                        break;
                    default:
                        goto Done;
                    }

                    if (iRet <= 0) 
                        goto Done;

                    LPMYPIDL newPidl = NULL;
                    hres = LoadSubscription(ooeBuf.m_URL, &newPidl);

                    if (FAILED(hres))   {
                        ASSERT(0);
                    } else  {
                        ILFree((LPITEMIDLIST)_ppooi[i]);
                        _ppooi[i] = newPidl;
                    }
                }
                goto Done;

            case RSVIDM_UPDATE: 
                {
                    POOEntry pooe = &(_ppooi[i]->ooe);
                    pClsid[updateCount] = pooe->m_Cookie;
                    updateCount ++;
                } 
                break;

            default:
                hres = E_FAIL;
                break;
            }
        }
    }

    if (idCmd == RSVIDM_UPDATE) {
        hres = SendUpdateRequests(pici->hwnd, pClsid, updateCount);
        MemFree(pClsid);
    }
Done:
    return hres;
}


STDMETHODIMP COfflineObjectItem::GetCommandString(UINT_PTR idCmd, UINT uFlags, UINT *pwReserved,
                                LPSTR pszName, UINT cchMax)
{
    HRESULT hres = E_FAIL;

//    TraceMsg(TF_ALWAYS, TEXT("OOI/IContextMenu - GetCommandString() called."));

    if (uFlags == GCS_VERBA)
    {
        LPCSTR pszSrc = NULL;

        switch(idCmd)
        {
            case RSVIDM_OPEN:
                pszSrc = c_szOpen;
                break;

            case RSVIDM_COPY:
                pszSrc = c_szCopy;
                break;

            case RSVIDM_DELETE:
                pszSrc = c_szDelete;
                break;

            case RSVIDM_PROPERTIES:
                pszSrc = c_szProperties;
                break;
        }
        
        if (pszSrc)
        {
            lstrcpynA(pszName, pszSrc, cchMax);
            hres = NOERROR;
        }
    }
    
    else if (uFlags == GCS_HELPTEXTA)
    {
        switch(idCmd)
        {
            case RSVIDM_OPEN:
            case RSVIDM_RENAME:
            case RSVIDM_UPDATE:
            case RSVIDM_COPY:
            case RSVIDM_DELETE:
            case RSVIDM_PROPERTIES:
                MLLoadStringA((UINT)(IDS_SB_FIRST+idCmd), pszName, cchMax);
                hres = NOERROR;
                break;

            default:
                break;
        }
    }
    return hres;
}

// IQueryInfo Method
HRESULT COfflineObjectItem::GetInfoTip(DWORD dwFlags, WCHAR ** ppwsz)
{
    *ppwsz = NULL;
    int clen = lstrlen(STATUS(&(_ppooi[0]->ooe)))+1;
    *ppwsz = (LPOLESTR)SHAlloc(clen*sizeof(WCHAR)) ;
    if (!(*ppwsz))  {
        return E_OUTOFMEMORY;
    }
    MyStrToOleStrN(*ppwsz, clen, STATUS(&(_ppooi[0]->ooe)));
    return S_OK;
}

HRESULT COfflineObjectItem::GetInfoFlags(DWORD *pdwFlags)
{
    return E_NOTIMPL;
}

// IDataObject Methods...

HRESULT COfflineObjectItem::GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
    HRESULT hres;

#ifdef DEBUG
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wsprintf(szName, TEXT("#%d"), pFEIn->cfFormat);

    TraceMsg(TF_SUBSFOLDER, "COfflineObjectItem - GetData(%s)", szName);
#endif

    pSTM->hGlobal = NULL;
    pSTM->pUnkForRelease = NULL;

    if ((pFEIn->cfFormat == g_cfPrefDropEffect) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreatePrefDropEffect(pSTM);

    else if ((pFEIn->cfFormat == g_cfFileDescriptor) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateFileDescriptor(pSTM);

    else if ((pFEIn->cfFormat == g_cfFileContents) && (pFEIn->tymed & TYMED_ISTREAM))
        hres = _CreateFileContents(pSTM, pFEIn->lindex);

    else if ((pFEIn->cfFormat == g_cfURL || pFEIn->cfFormat == CF_TEXT) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = _CreateURL(pSTM);
  
    else
        hres = DATA_E_FORMATETC;
    
    return hres;

}

HRESULT COfflineObjectItem::GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
//    TraceMsg(TF_ALWAYS, TEXT("COfflineObjectItem - GetDataHere() called."));
    return E_NOTIMPL;
}

HRESULT COfflineObjectItem::QueryGetData(LPFORMATETC pFEIn)
{
#ifdef DEBUG
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wsprintf(szName, TEXT("#%d"), pFEIn->cfFormat);

#endif

    if (pFEIn->cfFormat == g_cfPrefDropEffect   ||
        pFEIn->cfFormat == g_cfFileDescriptor   ||
        pFEIn->cfFormat == g_cfFileContents     ||
        pFEIn->cfFormat == g_cfURL              ||
        pFEIn->cfFormat == CF_TEXT
       )  {
#ifdef DEBUG
        TraceMsg(TF_ALWAYS, "\t%s format supported.", szName);
#endif
        return NOERROR;
    }
    
    return S_FALSE;
}

HRESULT COfflineObjectItem::GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut)
{
//    TraceMsg(TF_ALWAYS, TEXT("COfflineObjectItem - GetCanonicalFormatEtc() called."));
    return DATA_S_SAMEFORMATETC;
}

HRESULT COfflineObjectItem::SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease)
{
    TraceMsg(TF_SUBSFOLDER, "COfflineObjectItem - SetData() called.");
    return E_NOTIMPL;
}

HRESULT COfflineObjectItem::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum)
{
    FORMATETC objectfmte[5] = {
        {(CLIPFORMAT) g_cfFileDescriptor, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {(CLIPFORMAT) g_cfFileContents,   NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM },
        {(CLIPFORMAT) g_cfPrefDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {(CLIPFORMAT) g_cfURL,            NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        {(CLIPFORMAT) CF_TEXT,            NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL }
    };
    HRESULT hres;

    TraceMsg(TF_SUBSFOLDER, "COfflineObjectItem - EnumFormatEtc() called.");

    hres = SHCreateStdEnumFmtEtc(ARRAYSIZE(objectfmte), objectfmte, ppEnum);
    TraceMsg(TF_SUBSFOLDER, "\t- EnumFormatEtc() return %d.", hres);
    return  hres;
}

HRESULT COfflineObjectItem::DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink,
    LPDWORD pdwConnection)
{
    TraceMsg(TF_SUBSFOLDER, "COfflineObjectItem - DAdvise() called.");
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT COfflineObjectItem::DUnadvise(DWORD dwConnection)
{
//    TraceMsg(TF_SUBSFOLDER, TEXT("COfflineObjectItem - DUnAdvise() called."));
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT COfflineObjectItem::EnumDAdvise(LPENUMSTATDATA *ppEnum)
{
//    TraceMsg(TF_ALWAYS, TEXT("COfflineObjectItem - EnumAdvise() called."));
    return OLE_E_ADVISENOTSUPPORTED;
}

//////////////////////////////////////////////////////////////////////////////
//
// Helper Routines
//
//////////////////////////////////////////////////////////////////////////////

    
HRESULT COfflineObjectItem::_CreatePrefDropEffect(LPSTGMEDIUM pSTM)
{    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;

    TraceMsg(TF_SUBSFOLDER, "OOI/CreatePrefDropEffect");
    pSTM->hGlobal = MemAlloc(LPTR, sizeof(DWORD));

    //  FEATURE: Need category specific code.

    DWORD prefEffect = DROPEFFECT_COPY;

    if (pSTM->hGlobal)
    {
        *((LPDWORD)pSTM->hGlobal) = prefEffect;
        return S_OK;
    }

    return E_OUTOFMEMORY;    
}

HRESULT COfflineObjectItem::_CreateURL(LPSTGMEDIUM pSTM)
{
    LPTSTR pszURL = URL(&(((LPMYPIDL)_ppooi[0])->ooe));    
    int cchAlloc = (lstrlen(pszURL) + 1) * 2;
    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    
    pSTM->hGlobal = MemAlloc(LPTR, cchAlloc);

    if (pSTM->hGlobal)
    {
        SHTCharToAnsi(pszURL, (LPSTR)pSTM->hGlobal, cchAlloc);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

HRESULT COfflineObjectItem::_CreateFileContents(LPSTGMEDIUM pSTM, LONG lindex)
{
    HRESULT hr;
    LONG iIndex;
    
    // make sure the index is in a valid range.
    if (lindex == -1)
    {
        if (_cItems == 1)
            lindex = 0;
        else
            return E_FAIL;
    }

    Assert((unsigned)lindex < _cItems);
    Assert(lindex >= 0);

    iIndex = lindex;
    
    pSTM->tymed = TYMED_ISTREAM;
    pSTM->pUnkForRelease = NULL;
    
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pSTM->pstm);
    if (SUCCEEDED(hr))
    {
        LARGE_INTEGER li = {0L, 0L};
        IUniformResourceLocator *purl;

        hr = SHCoCreateInstance(NULL, &CLSID_InternetShortcut, NULL,
            IID_IUniformResourceLocator, (void **)&purl);
        if (SUCCEEDED(hr))
        {
            hr = purl->SetURL(URL(&(_ppooi[iIndex]->ooe)), TRUE);
            if (SUCCEEDED(hr))
            {
                IPersistStream *pps;
                hr = purl->QueryInterface(IID_IPersistStream, (LPVOID *)&pps);
                if (SUCCEEDED(hr))
                {
                    hr = pps->Save(pSTM->pstm, TRUE);
                    pps->Release();
                }
            }
            purl->Release();
        }               
        pSTM->pstm->Seek(li, STREAM_SEEK_SET, NULL);
    }

    return hr;
}

HRESULT COfflineObjectItem::_CreateFileDescriptor(LPSTGMEDIUM pSTM)
{
    FILEGROUPDESCRIPTOR *pfgd;
    
    // render the file descriptor
    // we only allocate for _cItems-1 file descriptors because the filegroup
    // descriptor has already allocated space for 1.
    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    
    pfgd = (FILEGROUPDESCRIPTOR *)MemAlloc(LPTR, sizeof(FILEGROUPDESCRIPTOR) + (_cItems-1) * sizeof(FILEDESCRIPTOR));
    if (pfgd == NULL)
    {
        TraceMsg(TF_ALWAYS, "ooi -   Couldn't alloc file descriptor");
        return E_OUTOFMEMORY;
    }
    pfgd->cItems = _cItems;

    for (UINT i = 0; i < _cItems; i++)
    {
        FILEDESCRIPTOR *pfd = &(pfgd->fgd[i]);
        StrCpyN(pfd->cFileName, NAME(&(_ppooi[i]->ooe)), ARRAYSIZE(pfd->cFileName));
        int len = lstrlen(pfd->cFileName);
        StrCpyN(pfd->cFileName + len, TEXT(".URL"), ARRAYSIZE(pfd->cFileName) - len);
    }

    pSTM->hGlobal = pfgd;
    
    return S_OK;
}

#ifdef UNICODE
// IExtractIconA members
HRESULT COfflineObjectItem::GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    return IExtractIcon_GetIconLocationThunk((IExtractIconW *)this, uFlags, szIconFile, cchMax, piIndex, pwFlags);
}

HRESULT COfflineObjectItem::Extract(LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    return IExtractIcon_ExtractThunk((IExtractIconW *)this, pszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
}
#endif


HRESULT COfflineObjectItem::GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    ASSERT (piIndex && pwFlags);

    StrCpyN(szIconFile, TEXT("not used"), cchMax);

    SUBSCRIPTIONTYPE    subType = GetItemCategory(&(_ppooi[0]->ooe)); 
    switch (subType)   {
    case SUBSTYPE_URL:
        *piIndex = 10;
         break;
    case SUBSTYPE_CHANNEL:
        *piIndex = 11;
        break;
    case SUBSTYPE_DESKTOPCHANNEL:
    case SUBSTYPE_DESKTOPURL:
        *piIndex = 12;
        break;
    default:
        *piIndex = 13;   //  Unknown!
        break;
    }
    *pwFlags |= GIL_NOTFILENAME | GIL_PERINSTANCE | GIL_DONTCACHE;

    return NOERROR;
}

HRESULT COfflineObjectItem::Extract(LPCTSTR szIconFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    * phiconLarge = * phiconSmall = NULL;
    
    LoadDefaultIcons();

    SUBSCRIPTIONTYPE    subType = GetItemCategory(&(_ppooi[0]->ooe)); 
    switch (subType)   {
    case SUBSTYPE_URL:
        * phiconLarge = * phiconSmall = g_webCrawlerIcon;
        break;
    case SUBSTYPE_CHANNEL:
        * phiconLarge = * phiconSmall = g_channelIcon;
        break;
    case SUBSTYPE_DESKTOPURL:
    case SUBSTYPE_DESKTOPCHANNEL:
        * phiconLarge = * phiconSmall = g_desktopIcon;
        break;
    default:
        break;
    }
    if (!(*phiconLarge))   {
        if (_ppooi[0]->ooe.bDesktop)
            * phiconLarge = * phiconSmall = g_desktopIcon;
        else if (_ppooi[0]->ooe.bChannel)
            * phiconLarge = * phiconSmall = g_channelIcon;
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\imnact.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Tue Jun 03 10:53:09 1997
 */
/* Compiler settings for imnact.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imnact_h__
#define __imnact_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IImnAdviseAccount_FWD_DEFINED__
#define __IImnAdviseAccount_FWD_DEFINED__
typedef interface IImnAdviseAccount IImnAdviseAccount;
#endif 	/* __IImnAdviseAccount_FWD_DEFINED__ */


#ifndef __IImnAdviseMigrateServer_FWD_DEFINED__
#define __IImnAdviseMigrateServer_FWD_DEFINED__
typedef interface IImnAdviseMigrateServer IImnAdviseMigrateServer;
#endif 	/* __IImnAdviseMigrateServer_FWD_DEFINED__ */


#ifndef __IImnEnumAccounts_FWD_DEFINED__
#define __IImnEnumAccounts_FWD_DEFINED__
typedef interface IImnEnumAccounts IImnEnumAccounts;
#endif 	/* __IImnEnumAccounts_FWD_DEFINED__ */


#ifndef __IImnAccountManager_FWD_DEFINED__
#define __IImnAccountManager_FWD_DEFINED__
typedef interface IImnAccountManager IImnAccountManager;
#endif 	/* __IImnAccountManager_FWD_DEFINED__ */


#ifndef __IPropertyContainer_FWD_DEFINED__
#define __IPropertyContainer_FWD_DEFINED__
typedef interface IPropertyContainer IPropertyContainer;
#endif 	/* __IPropertyContainer_FWD_DEFINED__ */


#ifndef __IImnAccount_FWD_DEFINED__
#define __IImnAccount_FWD_DEFINED__
typedef interface IImnAccount IImnAccount;
#endif 	/* __IImnAccount_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_imnact_0000
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 



//=--------------------------------------------------------------------------=
// Imnact.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Internet Mail and News Account Manager Interfaces.

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {8D4B04E1-1331-11d0-81B8-00C04FD85AB4}
DEFINE_GUID(CLSID_ImnAccountManager, 0x8d4b04e1, 0x1331, 0x11d0, 0x81, 0xb8, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {FD465484-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IPropertyContainer, 0xfd465484, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465481-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnAccountManager, 0xfd465481, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465482-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnAccount, 0xfd465482, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {FD465483-1384-11d0-ABBD-0020AFDFD10A}
DEFINE_GUID(IID_IImnEnumAccounts, 0xfd465483, 0x1384, 0x11d0, 0xab, 0xbd, 0x0, 0x20, 0xaf, 0xdf, 0xd1, 0xa);

// {8D0AED11-1638-11d0-81B9-00C04FD85AB4}
DEFINE_GUID(IID_IImnAdviseMigrateServer, 0x8d0aed11, 0x1638, 0x11d0, 0x81, 0xb9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// {0A06BD31-166F-11d0-81B9-00C04FD85AB4}
DEFINE_GUID(IID_IImnAdviseAccount, 0xa06bd31, 0x166f, 0x11d0, 0x81, 0xb9, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4);

// --------------------------------------------------------------------------------
// Exported C Functions
// --------------------------------------------------------------------------------
#if !defined(_IMNACCT_)
#define IMNACCTAPI DECLSPEC_IMPORT HRESULT WINAPI
#define IMNACCTAPI_(_type_) DECLSPEC_IMPORT _type_ WINAPI
#else
#define IMNACCTAPI HRESULT WINAPI
#define IMNACCTAPI_(_type_) _type_ WINAPI
#endif
#ifdef __cplusplus
extern "C" {
#endif

IMNACCTAPI HrCreateAccountManager(IImnAccountManager **ppAccountManager);
IMNACCTAPI ValidEmailAddress(LPSTR lpAddress);
IMNACCTAPI CreateAccountsFromFile(LPSTR lpFile, DWORD dwFlags);

#ifdef __cplusplus
}
#endif

// --------------------------------------------------------------------------------
// Errors
// --------------------------------------------------------------------------------
#ifndef FACILITY_INTERNET
#define FACILITY_INTERNET 12
#endif
#ifndef HR_E
#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, n)
#endif
#ifndef HR_S
#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_INTERNET, n)
#endif
#ifndef HR_CODE
#define HR_CODE(hr) (INT)(hr & 0xffff)
#endif

// --------------------------------------------------------------------------------
// General Errors
// --------------------------------------------------------------------------------
#define E_RegCreateKeyFailed         HR_E(0xCD00)
#define E_RegQueryInfoKeyFailed      HR_E(0xCD01)
#define E_UserCancel                 HR_E(0xCD02)
#define E_RegOpenKeyFailed           HR_E(0xCD03)
#define E_RegSetValueFailed          HR_E(0xCD04)
#define E_RegDeleteKeyFailed         HR_E(0xCD05)
#define E_DuplicateAccountName       HR_E(0xCD06)
#define S_NonStandardValue           HR_S(0xCD07)
#define E_InvalidValue               HR_E(0xCD08)

// --------------------------------------------------------------------------------
// IPropertyContainer Errors
// --------------------------------------------------------------------------------
#define E_NoPropData                 HR_E(0xCDA0)
#define E_BufferTooSmall             HR_E(0xCDA1)
#define E_BadPropType                HR_E(0xCDA2)
#define E_BufferSizeMismatch         HR_E(0xCDA3)
#define E_InvalidBooleanValue        HR_E(0xCDA4)
#define E_InvalidMinMaxValue         HR_E(0xCDA5)
#define E_PropNotFound               HR_E(0xCDA6)
#define E_InvalidPropTag             HR_E(0xCDA7)
#define E_InvalidPropertySet         HR_E(0xCDA8)
#define E_EnumFinished               HR_E(0xCDA9)
#define S_NoSaveNeeded               HR_S(0xCDAA)
#define S_PasswordDeleted            HR_S(0xCDAB)
#define S_PasswordNotFound           HR_S(0xCDAC)

// --------------------------------------------------------------------------------
// ImnAccountManager errors
// --------------------------------------------------------------------------------
#define E_NoAccounts                 HR_E(0xCDD0)
#define E_BadFriendlyName            HR_E(0xCDD1)

// --------------------------------------------------------------------------------
// RAS Connection Types
// --------------------------------------------------------------------------------
#define CF_AUTO_CONNECT          FLAG02 // Automatically connect

// --------------------------------------------------------------------------------
// Property Macros
// --------------------------------------------------------------------------------
#define PROPTAG_MASK                 ((ULONG)0x0000FFFF)
#define PROPTAG_TYPE(ulPropTag)	    (PROPTYPE)(((ULONG)(ulPropTag)) & PROPTAG_MASK)
#define PROPTAG_ID(ulPropTag)		(((ULONG)(ulPropTag))>>16)
#define PROPTAG(ulPropType,ulPropID)	((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define MAX_PROPID                   ((ULONG) 0xFFFF)

// --------------------------------------------------------------------------------
// IImnAccount Properties
// --------------------------------------------------------------------------------
#define AP_FIRST                    0X1234
// per account properties
#define AP_ACCOUNT_NAME             PROPTAG(TYPE_STRING,    AP_FIRST+1)
#define AP_ACCOUNT_FIRST            AP_ACCOUNT_NAME
#define AP_TEMP_ACCOUNT             PROPTAG(TYPE_DWORD,     AP_FIRST+3)
#define AP_LAST_UPDATED             PROPTAG(TYPE_FILETIME,  AP_FIRST+4)
#define AP_RAS_CONNECTION_TYPE      PROPTAG(TYPE_DWORD,     AP_FIRST+5)
#define AP_RAS_CONNECTOID           PROPTAG(TYPE_STRING,    AP_FIRST+6)
#define AP_RAS_CONNECTION_FLAGS     PROPTAG(TYPE_DWORD,     AP_FIRST+7)
#define AP_ACCOUNT_ID               PROPTAG(TYPE_STRING,    AP_FIRST+9)
#define AP_ACCOUNT_LAST             AP_ACCOUNT_ID

// IMAP properties
#define AP_IMAP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+100)
#define AP_IMAP_FIRST               AP_IMAP_SERVER
#define AP_IMAP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+101)
#define AP_IMAP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+102)
#define AP_IMAP_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+104)
#define AP_IMAP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+105)
#define AP_IMAP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+106)
#define AP_IMAP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+107)
#define AP_IMAP_ROOT_FOLDER         PROPTAG(TYPE_STRING,    AP_FIRST+108)
#define AP_IMAP_DATA_DIR            PROPTAG(TYPE_STRING,    AP_FIRST+109)
#define AP_IMAP_SKIP                PROPTAG(TYPE_BOOL,      AP_FIRST+110)
#define AP_IMAP_LAST                AP_IMAP_SKIP

// LDAP properties
#define AP_LDAP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+200)
#define AP_LDAP_FIRST               AP_LDAP_SERVER
#define AP_LDAP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+201)
#define AP_LDAP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+202)
#define AP_LDAP_AUTHENTICATION      PROPTAG(TYPE_DWORD,     AP_FIRST+203)
#define AP_LDAP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+204)
#define AP_LDAP_SEARCH_RETURN       PROPTAG(TYPE_DWORD,     AP_FIRST+205)
#define AP_LDAP_SEARCH_BASE         PROPTAG(TYPE_STRING,    AP_FIRST+206)
#define AP_LDAP_SERVER_ID           PROPTAG(TYPE_DWORD,     AP_FIRST+207)
#define AP_LDAP_RESOLVE_FLAG        PROPTAG(TYPE_DWORD,     AP_FIRST+208)
#define AP_LDAP_URL                 PROPTAG(TYPE_STRING,    AP_FIRST+209)
#define AP_LDAP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+210)
#define AP_LDAP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+211)
#define AP_LDAP_LOGO                PROPTAG(TYPE_STRING,    AP_FIRST+212)
#define AP_LDAP_USE_BIND_DN         PROPTAG(TYPE_DWORD,     AP_FIRST+213)
#define AP_LDAP_LAST                AP_LDAP_USE_BIND_DN

// NNTP properties
#define AP_NNTP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+300)
#define AP_NNTP_FIRST               AP_NNTP_SERVER
#define AP_NNTP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+301)
#define AP_NNTP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+302)
#define AP_NNTP_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+304)
#define AP_NNTP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+305)
#define AP_NNTP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+306)
#define AP_NNTP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+307)
#define AP_NNTP_DISPLAY_NAME        PROPTAG(TYPE_STRING,    AP_FIRST+308)
#define AP_NNTP_ORG_NAME            PROPTAG(TYPE_STRING,    AP_FIRST+309)
#define AP_NNTP_EMAIL_ADDRESS       PROPTAG(TYPE_STRING,    AP_FIRST+310)
#define AP_NNTP_REPLY_EMAIL_ADDRESS PROPTAG(TYPE_STRING,    AP_FIRST+311)
#define AP_NNTP_SPLIT_MESSAGES      PROPTAG(TYPE_BOOL,      AP_FIRST+312)
#define AP_NNTP_SPLIT_SIZE          PROPTAG(TYPE_DWORD,     AP_FIRST+313)
#define AP_NNTP_USE_DESCRIPTIONS    PROPTAG(TYPE_BOOL,      AP_FIRST+314)
#define AP_NNTP_DATA_DIR            PROPTAG(TYPE_STRING,    AP_FIRST+315)
#define AP_NNTP_LAST                AP_NNTP_DATA_DIR

// POP3 properties
#define AP_POP3_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+400)
#define AP_POP3_FIRST               AP_POP3_SERVER
#define AP_POP3_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+401)
#define AP_POP3_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+402)
#define AP_POP3_USE_SICILY          PROPTAG(TYPE_BOOL,      AP_FIRST+404)
#define AP_POP3_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+405)
#define AP_POP3_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+406)
#define AP_POP3_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+407)
#define AP_POP3_LEAVE_ON_SERVER     PROPTAG(TYPE_BOOL,      AP_FIRST+408)
#define AP_POP3_REMOVE_DELETED      PROPTAG(TYPE_BOOL,      AP_FIRST+409)
#define AP_POP3_REMOVE_EXPIRED      PROPTAG(TYPE_BOOL,      AP_FIRST+410)
#define AP_POP3_EXPIRE_DAYS         PROPTAG(TYPE_DWORD,     AP_FIRST+411)
#define AP_POP3_SKIP                PROPTAG(TYPE_BOOL,      AP_FIRST+412)
#define AP_POP3_LAST                AP_POP3_SKIP

// SMTP properties
#define AP_SMTP_SERVER              PROPTAG(TYPE_STRING,    AP_FIRST+500)
#define AP_SMTP_FIRST               AP_SMTP_SERVER
#define AP_SMTP_USERNAME            PROPTAG(TYPE_STRING,    AP_FIRST+501)
#define AP_SMTP_PASSWORD            PROPTAG(TYPE_PASS,      AP_FIRST+502)
#define AP_SMTP_USE_SICILY          PROPTAG(TYPE_DWORD,     AP_FIRST+504) // SMTPAUTHTYEP
#define AP_SMTP_PORT                PROPTAG(TYPE_DWORD,     AP_FIRST+505)
#define AP_SMTP_SSL                 PROPTAG(TYPE_BOOL,      AP_FIRST+506)
#define AP_SMTP_TIMEOUT             PROPTAG(TYPE_DWORD,     AP_FIRST+507)
#define AP_SMTP_DISPLAY_NAME        PROPTAG(TYPE_STRING,    AP_FIRST+508)
#define AP_SMTP_ORG_NAME            PROPTAG(TYPE_STRING,    AP_FIRST+509)
#define AP_SMTP_EMAIL_ADDRESS       PROPTAG(TYPE_STRING,    AP_FIRST+510)
#define AP_SMTP_REPLY_EMAIL_ADDRESS PROPTAG(TYPE_STRING,    AP_FIRST+511)
#define AP_SMTP_SPLIT_MESSAGES      PROPTAG(TYPE_BOOL,      AP_FIRST+512)
#define AP_SMTP_SPLIT_SIZE          PROPTAG(TYPE_DWORD,     AP_FIRST+513)
#define AP_SMTP_CERTIFICATE         PROPTAG(TYPE_BINARY,    AP_FIRST+514)
#define AP_SMTP_LAST                AP_SMTP_CERTIFICATE

// --------------------------------------------------------------------------------
// Account Flags
// --------------------------------------------------------------------------------
#define ACCT_FLAG_NEWS           ((DWORD)1)
#define ACCT_FLAG_MAIL           ((DWORD)2)
#define ACCT_FLAG_DIR_SERV       ((DWORD)4)
#define ACCT_FLAG_ALL            (ACCT_FLAG_NEWS | ACCT_FLAG_MAIL | ACCT_FLAG_DIR_SERV)

// --------------------------------------------------------------------------------
// Server Types
// --------------------------------------------------------------------------------
#define SRV_NNTP                 ((DWORD)1)
#define SRV_IMAP                 ((DWORD)2)
#define SRV_POP3                 ((DWORD)4)
#define SRV_SMTP                 ((DWORD)8)
#define SRV_LDAP                 ((DWORD)16)
#define SRV_MAIL                 ((DWORD)(SRV_IMAP | SRV_POP3 | SRV_SMTP))
#define SRV_ALL                  ((DWORD)(SRV_NNTP | SRV_IMAP | SRV_POP3 | SRV_SMTP | SRV_LDAP))

// --------------------------------------------------------------------------------
// LDAP Authentication Types
// --------------------------------------------------------------------------------
#define LDAP_AUTH_ANONYMOUS      ((DWORD)0)
#define LDAP_AUTH_PASSWORD       ((DWORD)1)
#define LDAP_AUTH_MEMBER_SYSTEM  ((DWORD)2)
#define LDAP_AUTH_MAX            ((DWORD)2)

// -----------------------------------------------------------------------------
// Account Manager Notification Types
// -----------------------------------------------------------------------------
#define AN_ACCOUNT_DELETED           WM_USER + 1
#define AN_ACCOUNT_ADDED             WM_USER + 2
#define AN_ACCOUNT_CHANGED           WM_USER + 3
#define AN_DEFAULT_CHANGED           WM_USER + 4
#define AN_SERVERTYPES_CHANGED       WM_USER + 5

// IImnAccountManager::AccountListDialog flags
// IImnAccount::ShowProperties flags
#define ACCTDLG_NO_IMAP          0x0001
#define ACCTDLG_NO_REMOVEDELETE  0x0002
#define ACCTDLG_NO_BREAKMESSAGES 0x0004
#define ACCTDLG_NO_REMOVEAFTER   0x0008
#define ACCTDLG_NO_SENDRECEIVE   0x0010
#define ACCTDLG_ALL              0x001f

// AP_RAS_CONNECTION_TYPE values
#define CONNECTION_TYPE_LAN      0
#define CONNECTION_TYPE_MANUAL   1
#define CONNECTION_TYPE_RAS      2

// IImnAccount::DoWizard flags
#define ACCT_WIZ_MIGRATE         0x0001

typedef 
enum tagSMTPAUTHTYPE
    {	SMTP_AUTH_NONE	= 0,
	SMTP_AUTH_SICILY	= SMTP_AUTH_NONE + 1,
	SMTP_AUTH_USE_POP3ORIMAP_SETTINGS	= SMTP_AUTH_SICILY + 1,
	SMTP_AUTH_USE_SMTP_SETTINGS	= SMTP_AUTH_USE_POP3ORIMAP_SETTINGS + 1
    }	SMTPAUTHTYPE;

#define	CCHMAX_ORG_NAME	( 256 )

#define	CCHMAX_DISPLAY_NAME	( 256 )

#define	CCHMAX_ACCOUNT_NAME	( 256 )

#define	CCHMAX_SERVER_NAME	( 256 )

#define	CCHMAX_PASSWORD	( 256 )

#define	CCHMAX_USERNAME	( 256 )

#define	CCHMAX_EMAIL_ADDRESS	( 256 )

#define	CCHMAX_CONNECTOID	( 256 )

#define	CCHMAX_SEARCH_BASE	( 256 )

#define	CCHMAX_ROOT_FOLDER	( 256 )



extern RPC_IF_HANDLE __MIDL_itf_imnact_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imnact_0000_v0_0_s_ifspec;

#ifndef __IImnAdviseAccount_INTERFACE_DEFINED__
#define __IImnAdviseAccount_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAdviseAccount
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL_IImnAdviseAccount_0001
    {	ACCT_NEWS	= 0,
	ACCT_MAIL	= ACCT_NEWS + 1,
	ACCT_DIR_SERV	= ACCT_MAIL + 1,
	ACCT_LAST	= ACCT_DIR_SERV + 1
    }	ACCTTYPE;

typedef struct  tagAccountContext
    {
    ACCTTYPE AcctType;
    LPSTR pszAccountID;
    LPSTR pszOldName;
    DWORD dwServerType;
    }	ACTX;


EXTERN_C const IID IID_IImnAdviseAccount;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0A06BD31-166F-11d0-81B9-00C04FD85AB4")
    IImnAdviseAccount : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseAccount( 
            /* [in] */ DWORD dwAdviseType,
            /* [in] */ ACTX __RPC_FAR *pAcctCtx) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAdviseAccountVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAdviseAccount __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAdviseAccount __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAdviseAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AdviseAccount )( 
            IImnAdviseAccount __RPC_FAR * This,
            /* [in] */ DWORD dwAdviseType,
            /* [in] */ ACTX __RPC_FAR *pAcctCtx);
        
        END_INTERFACE
    } IImnAdviseAccountVtbl;

    interface IImnAdviseAccount
    {
        CONST_VTBL struct IImnAdviseAccountVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAdviseAccount_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAdviseAccount_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAdviseAccount_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAdviseAccount_AdviseAccount(This,dwAdviseType,pAcctCtx)	\
    (This)->lpVtbl -> AdviseAccount(This,dwAdviseType,pAcctCtx)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAdviseAccount_AdviseAccount_Proxy( 
    IImnAdviseAccount __RPC_FAR * This,
    /* [in] */ DWORD dwAdviseType,
    /* [in] */ ACTX __RPC_FAR *pAcctCtx);


void __RPC_STUB IImnAdviseAccount_AdviseAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAdviseAccount_INTERFACE_DEFINED__ */


#ifndef __IImnAdviseMigrateServer_INTERFACE_DEFINED__
#define __IImnAdviseMigrateServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAdviseMigrateServer
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnAdviseMigrateServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("8D0AED11-1638-11d0-81B9-00C04FD85AB4")
    IImnAdviseMigrateServer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MigrateServer( 
            /* [in] */ DWORD dwSrvType,
            /* [in] */ IImnAccount __RPC_FAR *pAccount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAdviseMigrateServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAdviseMigrateServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAdviseMigrateServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAdviseMigrateServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MigrateServer )( 
            IImnAdviseMigrateServer __RPC_FAR * This,
            /* [in] */ DWORD dwSrvType,
            /* [in] */ IImnAccount __RPC_FAR *pAccount);
        
        END_INTERFACE
    } IImnAdviseMigrateServerVtbl;

    interface IImnAdviseMigrateServer
    {
        CONST_VTBL struct IImnAdviseMigrateServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAdviseMigrateServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAdviseMigrateServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAdviseMigrateServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAdviseMigrateServer_MigrateServer(This,dwSrvType,pAccount)	\
    (This)->lpVtbl -> MigrateServer(This,dwSrvType,pAccount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAdviseMigrateServer_MigrateServer_Proxy( 
    IImnAdviseMigrateServer __RPC_FAR * This,
    /* [in] */ DWORD dwSrvType,
    /* [in] */ IImnAccount __RPC_FAR *pAccount);


void __RPC_STUB IImnAdviseMigrateServer_MigrateServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAdviseMigrateServer_INTERFACE_DEFINED__ */


#ifndef __IImnEnumAccounts_INTERFACE_DEFINED__
#define __IImnEnumAccounts_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnEnumAccounts
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnEnumAccounts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FD465483-1384-11d0-ABBD-0020AFDFD10A")
    IImnEnumAccounts : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SortByAccountName( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnEnumAccountsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SortByAccountName )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IImnEnumAccounts __RPC_FAR * This,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IImnEnumAccounts __RPC_FAR * This);
        
        END_INTERFACE
    } IImnEnumAccountsVtbl;

    interface IImnEnumAccounts
    {
        CONST_VTBL struct IImnEnumAccountsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnEnumAccounts_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnEnumAccounts_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnEnumAccounts_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnEnumAccounts_GetCount(This,pcItems)	\
    (This)->lpVtbl -> GetCount(This,pcItems)

#define IImnEnumAccounts_SortByAccountName(This)	\
    (This)->lpVtbl -> SortByAccountName(This)

#define IImnEnumAccounts_GetNext(This,ppAccount)	\
    (This)->lpVtbl -> GetNext(This,ppAccount)

#define IImnEnumAccounts_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnEnumAccounts_GetCount_Proxy( 
    IImnEnumAccounts __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcItems);


void __RPC_STUB IImnEnumAccounts_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_SortByAccountName_Proxy( 
    IImnEnumAccounts __RPC_FAR * This);


void __RPC_STUB IImnEnumAccounts_SortByAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_GetNext_Proxy( 
    IImnEnumAccounts __RPC_FAR * This,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnEnumAccounts_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnEnumAccounts_Reset_Proxy( 
    IImnEnumAccounts __RPC_FAR * This);


void __RPC_STUB IImnEnumAccounts_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnEnumAccounts_INTERFACE_DEFINED__ */


#ifndef __IImnAccountManager_INTERFACE_DEFINED__
#define __IImnAccountManager_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAccountManager
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef struct  tagACCTLISTINFO
    {
    DWORD cbSize;
    ACCTTYPE AcctTypeInit;
    DWORD dwAcctFlags;
    DWORD dwFlags;
    }	ACCTLISTINFO;


EXTERN_C const IID IID_IImnAccountManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FD465481-1384-11d0-ABBD-0020AFDFD10A")
    IImnAccountManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAccountObject( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enumerate( 
            /* [in] */ DWORD dwSrvTypes,
            /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccountCount( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ ULONG __RPC_FAR *pcServers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindAccount( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPCTSTR pszSearchData,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAccount( 
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAccountName( 
            /* [in] */ ACCTTYPE AcctType,
            /* [ref][in] */ LPTSTR pszAccount,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessNotification( 
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateDefaultSendAccount( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AccountListDialog( 
            /* [in] */ HWND hwnd,
            /* [in] */ ACCTLISTINFO __RPC_FAR *pinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount,
            /* [out] */ DWORD __RPC_FAR *pdwConnection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwConnection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAccountManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAccountManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAccountManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateAccountObject )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enumerate )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwSrvTypes,
            /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountCount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ ULONG __RPC_FAR *pcServers);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindAccount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPCTSTR pszSearchData,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultAccount )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultAccountName )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ ACCTTYPE AcctType,
            /* [ref][in] */ LPTSTR pszAccount,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessNotification )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateDefaultSendAccount )( 
            IImnAccountManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AccountListDialog )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ ACCTLISTINFO __RPC_FAR *pinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Advise )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount,
            /* [out] */ DWORD __RPC_FAR *pdwConnection);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unadvise )( 
            IImnAccountManager __RPC_FAR * This,
            /* [in] */ DWORD dwConnection);
        
        END_INTERFACE
    } IImnAccountManagerVtbl;

    interface IImnAccountManager
    {
        CONST_VTBL struct IImnAccountManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAccountManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAccountManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAccountManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAccountManager_Init(This,pAdviseMigrateServer)	\
    (This)->lpVtbl -> Init(This,pAdviseMigrateServer)

#define IImnAccountManager_CreateAccountObject(This,AcctType,ppAccount)	\
    (This)->lpVtbl -> CreateAccountObject(This,AcctType,ppAccount)

#define IImnAccountManager_Enumerate(This,dwSrvTypes,ppEnumAccounts)	\
    (This)->lpVtbl -> Enumerate(This,dwSrvTypes,ppEnumAccounts)

#define IImnAccountManager_GetAccountCount(This,AcctType,pcServers)	\
    (This)->lpVtbl -> GetAccountCount(This,AcctType,pcServers)

#define IImnAccountManager_FindAccount(This,dwPropTag,pszSearchData,ppAccount)	\
    (This)->lpVtbl -> FindAccount(This,dwPropTag,pszSearchData,ppAccount)

#define IImnAccountManager_GetDefaultAccount(This,AcctType,ppAccount)	\
    (This)->lpVtbl -> GetDefaultAccount(This,AcctType,ppAccount)

#define IImnAccountManager_GetDefaultAccountName(This,AcctType,pszAccount,cchMax)	\
    (This)->lpVtbl -> GetDefaultAccountName(This,AcctType,pszAccount,cchMax)

#define IImnAccountManager_ProcessNotification(This,uMsg,wParam,lParam)	\
    (This)->lpVtbl -> ProcessNotification(This,uMsg,wParam,lParam)

#define IImnAccountManager_ValidateDefaultSendAccount(This)	\
    (This)->lpVtbl -> ValidateDefaultSendAccount(This)

#define IImnAccountManager_AccountListDialog(This,hwnd,pinfo)	\
    (This)->lpVtbl -> AccountListDialog(This,hwnd,pinfo)

#define IImnAccountManager_Advise(This,pAdviseAccount,pdwConnection)	\
    (This)->lpVtbl -> Advise(This,pAdviseAccount,pdwConnection)

#define IImnAccountManager_Unadvise(This,dwConnection)	\
    (This)->lpVtbl -> Unadvise(This,dwConnection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAccountManager_Init_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ IImnAdviseMigrateServer __RPC_FAR *pAdviseMigrateServer);


void __RPC_STUB IImnAccountManager_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_CreateAccountObject_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_CreateAccountObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_Enumerate_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwSrvTypes,
    /* [out] */ IImnEnumAccounts __RPC_FAR *__RPC_FAR *ppEnumAccounts);


void __RPC_STUB IImnAccountManager_Enumerate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetAccountCount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ ULONG __RPC_FAR *pcServers);


void __RPC_STUB IImnAccountManager_GetAccountCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_FindAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ LPCTSTR pszSearchData,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_FindAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetDefaultAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [out] */ IImnAccount __RPC_FAR *__RPC_FAR *ppAccount);


void __RPC_STUB IImnAccountManager_GetDefaultAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_GetDefaultAccountName_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ ACCTTYPE AcctType,
    /* [ref][in] */ LPTSTR pszAccount,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IImnAccountManager_GetDefaultAccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_ProcessNotification_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IImnAccountManager_ProcessNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_ValidateDefaultSendAccount_Proxy( 
    IImnAccountManager __RPC_FAR * This);


void __RPC_STUB IImnAccountManager_ValidateDefaultSendAccount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_AccountListDialog_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ ACCTLISTINFO __RPC_FAR *pinfo);


void __RPC_STUB IImnAccountManager_AccountListDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_Advise_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ IImnAdviseAccount __RPC_FAR *pAdviseAccount,
    /* [out] */ DWORD __RPC_FAR *pdwConnection);


void __RPC_STUB IImnAccountManager_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccountManager_Unadvise_Proxy( 
    IImnAccountManager __RPC_FAR * This,
    /* [in] */ DWORD dwConnection);


void __RPC_STUB IImnAccountManager_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAccountManager_INTERFACE_DEFINED__ */


#ifndef __IPropertyContainer_INTERFACE_DEFINED__
#define __IPropertyContainer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPropertyContainer
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [public] */ 
enum __MIDL_IPropertyContainer_0001
    {	TYPE_ERROR	= 1000,
	TYPE_DWORD	= TYPE_ERROR + 1,
	TYPE_LONG	= TYPE_DWORD + 1,
	TYPE_WORD	= TYPE_LONG + 1,
	TYPE_SHORT	= TYPE_WORD + 1,
	TYPE_BYTE	= TYPE_SHORT + 1,
	TYPE_CHAR	= TYPE_BYTE + 1,
	TYPE_FILETIME	= TYPE_CHAR + 1,
	TYPE_STRING	= TYPE_FILETIME + 1,
	TYPE_BINARY	= TYPE_STRING + 1,
	TYPE_FLAGS	= TYPE_BINARY + 1,
	TYPE_STREAM	= TYPE_FLAGS + 1,
	TYPE_WSTRING	= TYPE_STREAM + 1,
	TYPE_BOOL	= TYPE_WSTRING + 1,
	TYPE_PASS	= TYPE_BOOL + 1,
	TYPE_LAST	= TYPE_PASS + 1
    }	PROPTYPE;


EXTERN_C const IID IID_IPropertyContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FD465484-1384-11d0-ABBD-0020AFDFD10A")
    IPropertyContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProp( 
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropDw( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPropSz( 
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertyContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertyContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropDw )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropSz )( 
            IPropertyContainer __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz);
        
        END_INTERFACE
    } IPropertyContainerVtbl;

    interface IPropertyContainer
    {
        CONST_VTBL struct IPropertyContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyContainer_GetProp(This,dwPropTag,pb,pcb)	\
    (This)->lpVtbl -> GetProp(This,dwPropTag,pb,pcb)

#define IPropertyContainer_GetPropDw(This,dwPropTag,pdw)	\
    (This)->lpVtbl -> GetPropDw(This,dwPropTag,pdw)

#define IPropertyContainer_GetPropSz(This,dwPropTag,psz,cchMax)	\
    (This)->lpVtbl -> GetPropSz(This,dwPropTag,psz,cchMax)

#define IPropertyContainer_SetProp(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> SetProp(This,dwPropTag,pb,cb)

#define IPropertyContainer_SetPropDw(This,dwPropTag,dw)	\
    (This)->lpVtbl -> SetPropDw(This,dwPropTag,dw)

#define IPropertyContainer_SetPropSz(This,dwPropTag,psz)	\
    (This)->lpVtbl -> SetPropSz(This,dwPropTag,psz)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyContainer_GetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IPropertyContainer_GetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_GetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [out] */ DWORD __RPC_FAR *pdw);


void __RPC_STUB IPropertyContainer_GetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_GetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [ref][in] */ LPSTR psz,
    /* [in] */ ULONG cchMax);


void __RPC_STUB IPropertyContainer_GetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetProp_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB IPropertyContainer_SetProp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetPropDw_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ DWORD dw);


void __RPC_STUB IPropertyContainer_SetPropDw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyContainer_SetPropSz_Proxy( 
    IPropertyContainer __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [in] */ LPSTR psz);


void __RPC_STUB IPropertyContainer_SetPropSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyContainer_INTERFACE_DEFINED__ */


#ifndef __IImnAccount_INTERFACE_DEFINED__
#define __IImnAccount_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IImnAccount
 * at Tue Jun 03 10:53:09 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IImnAccount;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("FD465482-1384-11d0-ABBD-0020AFDFD10A")
    IImnAccount : public IPropertyContainer
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Exist( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAsDefault( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAccountType( 
            /* [out] */ ACCTTYPE __RPC_FAR *pAcctType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServerTypes( 
            /* [out] */ DWORD __RPC_FAR *pdwSrvTypes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowProperties( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateProperty( 
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoWizard( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImnAccountVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IImnAccount __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProp )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG __RPC_FAR *pcb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropDw )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropSz )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [ref][in] */ LPSTR psz,
            /* [in] */ ULONG cchMax);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProp )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropDw )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropSz )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [in] */ LPSTR psz);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Exist )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAsDefault )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveChanges )( 
            IImnAccount __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAccountType )( 
            IImnAccount __RPC_FAR * This,
            /* [out] */ ACCTTYPE __RPC_FAR *pAcctType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetServerTypes )( 
            IImnAccount __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSrvTypes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowProperties )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateProperty )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ DWORD dwPropTag,
            /* [size_is][in] */ BYTE __RPC_FAR *pb,
            /* [in] */ ULONG cb);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoWizard )( 
            IImnAccount __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IImnAccountVtbl;

    interface IImnAccount
    {
        CONST_VTBL struct IImnAccountVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImnAccount_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImnAccount_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImnAccount_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImnAccount_GetProp(This,dwPropTag,pb,pcb)	\
    (This)->lpVtbl -> GetProp(This,dwPropTag,pb,pcb)

#define IImnAccount_GetPropDw(This,dwPropTag,pdw)	\
    (This)->lpVtbl -> GetPropDw(This,dwPropTag,pdw)

#define IImnAccount_GetPropSz(This,dwPropTag,psz,cchMax)	\
    (This)->lpVtbl -> GetPropSz(This,dwPropTag,psz,cchMax)

#define IImnAccount_SetProp(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> SetProp(This,dwPropTag,pb,cb)

#define IImnAccount_SetPropDw(This,dwPropTag,dw)	\
    (This)->lpVtbl -> SetPropDw(This,dwPropTag,dw)

#define IImnAccount_SetPropSz(This,dwPropTag,psz)	\
    (This)->lpVtbl -> SetPropSz(This,dwPropTag,psz)


#define IImnAccount_Exist(This)	\
    (This)->lpVtbl -> Exist(This)

#define IImnAccount_SetAsDefault(This)	\
    (This)->lpVtbl -> SetAsDefault(This)

#define IImnAccount_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IImnAccount_SaveChanges(This)	\
    (This)->lpVtbl -> SaveChanges(This)

#define IImnAccount_GetAccountType(This,pAcctType)	\
    (This)->lpVtbl -> GetAccountType(This,pAcctType)

#define IImnAccount_GetServerTypes(This,pdwSrvTypes)	\
    (This)->lpVtbl -> GetServerTypes(This,pdwSrvTypes)

#define IImnAccount_ShowProperties(This,hwnd,dwFlags)	\
    (This)->lpVtbl -> ShowProperties(This,hwnd,dwFlags)

#define IImnAccount_ValidateProperty(This,dwPropTag,pb,cb)	\
    (This)->lpVtbl -> ValidateProperty(This,dwPropTag,pb,cb)

#define IImnAccount_DoWizard(This,hwnd,dwFlags)	\
    (This)->lpVtbl -> DoWizard(This,hwnd,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImnAccount_Exist_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_Exist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_SetAsDefault_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_SetAsDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_Delete_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_SaveChanges_Proxy( 
    IImnAccount __RPC_FAR * This);


void __RPC_STUB IImnAccount_SaveChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_GetAccountType_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [out] */ ACCTTYPE __RPC_FAR *pAcctType);


void __RPC_STUB IImnAccount_GetAccountType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_GetServerTypes_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSrvTypes);


void __RPC_STUB IImnAccount_GetServerTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_ShowProperties_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccount_ShowProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_ValidateProperty_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ DWORD dwPropTag,
    /* [size_is][in] */ BYTE __RPC_FAR *pb,
    /* [in] */ ULONG cb);


void __RPC_STUB IImnAccount_ValidateProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImnAccount_DoWizard_Proxy( 
    IImnAccount __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IImnAccount_DoWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImnAccount_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\iwebck.cpp ===
#include "private.h"
#include <shlguid.h>

#define TF_THISMODULE TF_WEBCHECKCORE

DWORD   g_idSchedThread = 0;

// global containing pointer to instance of CWebcheck.  Needed to control
// externals loading on demand.
CWebCheck *g_pwc = NULL;

//////////////////////////////////////////////////////////////////////////
//
// CWebCheck implementation
//
//////////////////////////////////////////////////////////////////////////

CWebCheck::CWebCheck()
{
    // Maintain global object count
    DllAddRef();

    // Initialize object
    m_cRef = 1;

    // save our instance
    g_pwc = this;
}

CWebCheck::~CWebCheck()
{
    // Maintain global object count
    DllRelease();

    // no longer available
    g_pwc = NULL;
}

//
// IUnknown members
//

STDMETHODIMP_(ULONG) CWebCheck::AddRef(void)
{
//  TraceMsg(TF_THISMODULE, "CWebCheck::AddRef m_cRef=%d", m_cRef+1);

    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CWebCheck::Release(void)
{
//  TraceMsg(TF_THISMODULE, "CWebCheck::Release m_cRef=%d", m_cRef-1);

    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CWebCheck::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = (IUnknown *)this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *ppv = (IOleCommandTarget *)this;
    else
        return E_NOINTERFACE;

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();
    return S_OK;
}

//
// IOleCommandTarget members
// The shell will send notifications to us through this interface.
//

STDMETHODIMP CWebCheck::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                                    OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    if (IsEqualGUID(*pguidCmdGroup, CGID_ShellServiceObject))
    {
        // We like Shell Service Object notifications...
        return S_OK;
    }

    return(OLECMDERR_E_UNKNOWNGROUP);
}

STDMETHODIMP CWebCheck::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                             DWORD nCmdexecopt, VARIANTARG *pvaIn,
                             VARIANTARG *pvaOut)
{
    if (pguidCmdGroup && IsEqualGUID(*pguidCmdGroup, CGID_ShellServiceObject))
    {
        // Handle Shell Service Object notifications here.
        switch (nCmdID)
        {
            case SSOCMDID_OPEN:
                StartService(FALSE);
                break;

            case SSOCMDID_CLOSE:
                StopService();
                break;
        }
        return S_OK;
    }

    return(E_NOTIMPL);
}


//
// IWebCheck members
//

// Starts the webcheck service in a process
STDMETHODIMP CWebCheck::StartService(BOOL fForceExternals)
{
    DBG("CWebCheck::StartService entered");

    // reset offline mode for all platforms except NT5
    if(FALSE == g_fIsWinNT5)
    {
        HMODULE hWininet = GetModuleHandle(TEXT("WININET.DLL"));
        if(hWininet)
        {
            // wininet is loaded - tell it to go online
            INTERNET_CONNECTED_INFO ci;
            memset(&ci, 0, sizeof(ci));
            ci.dwConnectedState = INTERNET_STATE_CONNECTED;
            InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
        }
        else
        {
            // wininet not loaded - blow away offline reg key so we'll
            // be online when it does load
            DWORD dwOffline = 0;        // FALSE => not offline
            WriteRegValue(HKEY_CURRENT_USER, c_szRegPathInternetSettings,
                TEXT("GlobalUserOffline"), &dwOffline, sizeof(DWORD), REG_DWORD);
        }
    }

    // create dialmon window
    DialmonInit();

    // Fire up LCE and sens if necessary
    if(fForceExternals || ShouldLoadExternals())
        LoadExternals();

    //
    // Process the Infodelivery Admin Policies on user login.  (User login coincides
    // with webcheck's StartService() call.)
    //
    ProcessInfodeliveryPolicies();

    DBG("CWebCheck::StartService exiting");
    return S_OK;
}


// Stops Webcheck if running.
STDMETHODIMP CWebCheck::StopService(void)
{
    DBG("CWebCheck::StopService entered");

    // kill dialmon window
    DialmonShutdown();

    // shut down the external bits
    if(FALSE == g_fIsWinNT)
        UnloadExternals();

    DBG("CWebCheck::StopService exiting");
    return S_OK;
}

//
// load behavior: (win9x)
//
// "auto"   Load if on a laptop
// "yes"    Load always
// "no"     Load never
//
static const WCHAR s_szAuto[] = TEXT("auto");
static const WCHAR s_szYes[] = TEXT("yes");
static const WCHAR s_szNo[] = TEXT("no");

BOOL CWebCheck::ShouldLoadExternals(void)
{
    WCHAR   szSens[16], szLce[16];
    DWORD   cbData;

    //
    // don't load on NT
    //
    if(g_fIsWinNT)
    {
        DBG("CWebCheck::ShouldLoadExternals -> NO (NT)");
        return FALSE;
    }

    //
    // read sens/lce user settings - no setting means auto
    //
    cbData = sizeof(szLce);
    if(ERROR_SUCCESS != SHGetValueW(HKEY_LOCAL_MACHINE, c_szRegKey, L"LoadLCE", NULL, szLce, &cbData))
    {
        StrCpyW(szLce, s_szAuto);
    }

    cbData = sizeof(szSens);
    if(ERROR_SUCCESS != SHGetValueW(HKEY_LOCAL_MACHINE, c_szRegKey, L"LoadSens", NULL, szSens, &cbData))
    {
        StrCpyW(szSens, s_szAuto);
    }

    //
    // if either is yes, load
    //
    if(0 == StrCmpIW(szLce, s_szYes) || 0 == StrCmpIW(szSens, s_szYes))
    {
        DBG("CWebCheck::ShouldLoadExternals -> YES (reg = yes)");
        return TRUE;
    }

    //
    // if either is auto, check for laptop
    //
    if(0 == StrCmpIW(szLce, s_szAuto) || 0 == StrCmpIW(szSens, s_szAuto))
    {
        if(SHGetMachineInfo(GMI_LAPTOP))
        {
            // Is a laptop - load
            DBG("CWebCheck::ShouldLoadExternals -> YES (reg = auto, laptop)");
            return TRUE;
        }
    }

    // don't load
    DBG("CWebCheck::ShouldLoadExternals -> NO");
    return FALSE;
}

BOOL CWebCheck::AreExternalsLoaded(void)
{
    return (_hThread != NULL);
}

void CWebCheck::LoadExternals(void)
{
    DWORD dwThreadId;

    DBG("CWebCheck::LoadExternals");

    if(_hThread)
    {
        DBG("CWebCheck::LoadExternals - already loaded");
        return;
    }

    // fire up a thread to do the work
    _hThread = CreateThread(NULL, 4096, ExternalsThread, this, 0, &dwThreadId);
    if(NULL == _hThread) {
        DBG("LoadExternals failed to create externals thread!");
        return;
    }

    // create initializion and termination events

    //
    // [darrenmi 2/7/00] Wininet now tries to find this named mutex instead of querying
    // dialmon.  It's the A version because wininet isn't unicode and OpenEventA can't
    // find events created with CreateEventW.
    //
    // See GetSensLanState in inet\wininet\dll\autodial.cxx.
    //
    _hTerminateEvent = CreateEventA(NULL, TRUE, FALSE, "MS_WebcheckExternalsTerminateEvent");
    if(NULL == _hTerminateEvent) {
        DBG("LoadExternals failed to create termination event");
        return;
    }

    DBG("CWebCheck::LoadExternals exiting");
    return;
}

void CWebCheck::UnloadExternals(void)
{
    if(NULL == _hThread)
    {
        DBG("CWebCheck::UnloadExternals - nothing to unload");
        return;
    }

    // tell externals thread to go away by setting termination event
    SetEvent(_hTerminateEvent);

    // Give thread a 10 second grace period to shut down
    // don't really care if it goes away or not... our process is going away!
    WaitForSingleObject(_hThread, 10000);

    // clean up
    CloseHandle(_hThread);
    CloseHandle(_hTerminateEvent);
    _hThread = NULL;
    _hTerminateEvent = NULL;

    return;
}

DWORD WINAPI ExternalsThread(LPVOID lpData)
{
    CWebCheck * pWebCheck = (CWebCheck *)lpData;
    HINSTANCE hLCE, hSENS = NULL;
    BOOL fLCEStarted = FALSE, fSENSStarted = FALSE;
    DWORD dwRet;
    MSG msg;

    // sleep for 10 seconds before firing off externals
    Sleep(10 * 1000);

    // fire up com
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if(FAILED(hr)) {
        DBG("LoadExternals: Failed to initialize COM");
        return 0;
    }

    // load and start LCE
    hLCE = LoadLibrary(TEXT("estier2.dll"));
    DBGASSERT(hLCE, "LoadExternals: Failed to load estier2.dll");
    if(hLCE) {
        LCESTART startfunc;
        startfunc = (LCESTART)GetProcAddress(hLCE, "LCEStartServer");
        DBGASSERT(startfunc, "LoadExternals: Failed to find LCEStartServer");
        if(startfunc) {
            hr = startfunc();
            if(SUCCEEDED(hr))
                fLCEStarted = TRUE;
            DBGASSERT(fLCEStarted, "LoadExternals: Failed to start LCE");
        }
    }

    // if LCE started sucessfully, load and start SENS
    if(fLCEStarted) {
        hSENS = LoadLibrary(TEXT("sens.dll"));
        DBGASSERT(hSENS, "LoadExternals: Failed to load sens.dll");
        if(hSENS) {
            SENSSTART startfunc;
            startfunc = (SENSSTART)GetProcAddress(hSENS, "SensInitialize");
            DBGASSERT(startfunc, "LoadExternals: Failed to find SensInitialize");
            if(startfunc) {
                if(startfunc())
                    fSENSStarted = TRUE;
                DBGASSERT(fSENSStarted, "LoadExternals: Failed to start SENS");
            }
        }
    }

    // Wait for our shutdown event but pump messages in the mean time
    do {
        dwRet = MsgWaitForMultipleObjects(1, &(pWebCheck->_hTerminateEvent),
                    FALSE, INFINITE, QS_ALLINPUT);
        if(WAIT_OBJECT_0 == dwRet) {
            // got our event, drop out of do loop
            break;
        }

        // empty the message queue...
        while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    } while(TRUE);

    // shut down SENS
    if(fSENSStarted) {
        ASSERT(hSENS);
        SENSSTOP stopfunc;
        stopfunc = (SENSSTOP)GetProcAddress(hSENS, "SensUninitialize");
        if(stopfunc) {
            stopfunc();
        }
    }

    //
    // [darrenmi] beta-1 hack: Sens may have a thread sitting in its code
    // at this point so it's not safe to unload sens.  Since we're in the
    // process of shutting down anyway, just leave it alone and let the
    // system unload it.
    //
    //if(hSENS) {
    //    FreeLibrary(hSENS);
    //}

    // shut down LCE
    if(fLCEStarted) {
        ASSERT(hLCE)
        LCESTOP stopfunc;
        stopfunc = (LCESTOP)GetProcAddress(hLCE, "LCEStopServer");
        if(stopfunc) {
            stopfunc();
        }
    }

    if(hLCE) {
        FreeLibrary(hLCE);
    }

    // clean up com goo
    CoUninitialize();

    return 0;
}

#if 0
//  TODO: need similar functionality in the new world
void SetNotificationMgrRestrictions(INotificationProcessMgr0 *pNotfMgrProcess)
{
    HRESULT hr;
    INotificationProcessMgr0 *pNotProcess = pNotfMgrProcess;

    // get NotificationMgr if it wasn't passed in
    if (!pNotfMgrProcess)
    {
        hr = CoCreateInstance(CLSID_StdNotificationMgr,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_INotificationProcessMgr0,
                          (void**)&pNotProcess);
        DBGASSERT(SUCCEEDED(hr), "SetNotificationMgrRestrictions - failed to create notification mgr");
    }
    // set the restrictions
    if (pNotProcess)
    {
        const TCHAR c_szNoScheduledUpdates[] = TEXT("NoScheduledUpdates");
        THROTTLEITEM ti = {0};
        ti.NotificationType = NOTIFICATIONTYPE_AGENT_START;
        ti.nParallel = 3;

        // Has the user has disabled scheduled subscription updates?
        DWORD dwData;
        DWORD cbData = sizeof(dwData);
        if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szRegKey, c_szNoScheduledUpdates, NULL, &dwData, &cbData))
            && dwData)
        {
            ti.dwFlags |= TF_DONT_DELIVER_SCHEDULED_ITEMS;
        }

        // Has the administrator has disabled scheduled subscription updates?
        if (SHRestricted2W(REST_NoScheduledUpdates, NULL, 0))
        {
            ti.dwFlags |= TF_DONT_DELIVER_SCHEDULED_ITEMS;
        }

        // Has the administrator has excluded scheduled subscription updates
        // from this time range?
        DWORD dwBegin = SHRestricted2W(REST_UpdateExcludeBegin, NULL, 0);
        DWORD dwEnd = SHRestricted2W(REST_UpdateExcludeEnd, NULL, 0);
        if (dwBegin && dwEnd)
        {
            ti.dwFlags |= TF_APPLY_EXCLUDE_RANGE;
            ti.stBegin.wHour = (WORD)(dwBegin / 60);
            ti.stBegin.wMinute = (WORD)(dwBegin % 60);
            ti.stEnd.wHour = (WORD)(dwEnd / 60);
            ti.stEnd.wMinute = (WORD)(dwEnd %60);
        }

        // Has the admin set a minimum interval for scheduled subscription updates?
        dwData = SHRestricted2W(REST_MinUpdateInterval, NULL, 0);
        if (dwData)
        {
            ti.dwFlags |= TF_APPLY_UPDATEINTERVAL;
            ti.dwMinItemUpdateInterval = dwData;
        }

        hr = pNotProcess->RegisterThrottleNotificationType(1, &ti, 0, NULL, 0, 0);
        DBGASSERT(SUCCEEDED(hr), "SetNotificationMgrRestrictions - failed to register throttle type & restrictions");
    }
    // release NotificationMgr if it wasn't passed in
    if (!pNotfMgrProcess)
    {
        SAFERELEASE(pNotProcess);
    }
}

#endif


//
// OLE bypass code
//
// Expose a couple of APIs to call start and stop service so loadwc doesn't
// need to load up OLE at start time.
//

HRESULT
ExtStartService(
    BOOL    fForceExternals
    )
{
    HRESULT hr = E_FAIL;

    // make a webcheck object
    ASSERT(NULL == g_pwc);
    if(NULL == g_pwc)
    {
        g_pwc = new CWebCheck;
        if(g_pwc)
        {
            hr = g_pwc->StartService(fForceExternals);
        }
    }

    return hr;
}

HRESULT
ExtStopService(
    void
    )
{
    HRESULT hr = E_FAIL;

    if(g_pwc)
    {
        hr = g_pwc->StopService();
        SAFERELEASE(g_pwc);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\notfcvt.cpp ===
#include "private.h"
#include "notfcvt.h"
#include "subsmgrp.h"
#include "subitem.h"
#include "chanmgr.h"
#include "chanmgrp.h"
#include "helper.h"
#include "shguidp.h"    // IID_IChannelMgrPriv

#include <mluisupp.h>

#undef TF_THISMODULE
#define TF_THISMODULE   TF_ADMIN

const CHAR c_pszRegKeyNotfMgr[] = "Software\\Microsoft\\Windows\\CurrentVersion\\NotificationMgr";
const CHAR c_pszRegKeyScheduleItems[] = "Software\\Microsoft\\Windows\\CurrentVersion\\NotificationMgr\\SchedItems 0.6";
const CHAR c_pszRegKeyScheduleGroup[] = "Software\\Microsoft\\Windows\\CurrentVersion\\NotificationMgr\\ScheduleGroup 0.6";

const WCHAR c_wszIE4IntlPre[]  = L"http://www.microsoft.com/ie_intl/";
const WCHAR c_wszIE4IntlPre2[] = L"http://www.microsoft.com/windows/ie_intl/";
const WCHAR c_wszIE4IntlPost[] = L"/ie40/download/cdf/ie4updates-";
const WCHAR c_wszIE4English[]  = L"http://www.microsoft.com/ie/ie40/download/cdf/ie4updates-";
const WCHAR c_wszIE4English2[] = L"http://www.microsoft.com/windows/ie/ie40/download/cdf/ie4updates-";

HRESULT ConvertNotfMgrScheduleGroup(NOTIFICATIONCOOKIE *pSchedCookie);

BOOL IsIE4UpdateChannel(LPCWSTR pwszURL)
{
    BOOL bResult = FALSE;
    int len = lstrlenW(pwszURL);

    //  For update channels from the non-international version, simply compare the 
    //  English base name witht the passed in URL.
    //
    //  International update channels look like:
    //      http://www.microsoft.com/ie_intl/XX/ie40/download/cdf/ie4updates-XX.cdf
    //  So we do two compares skipping the middle XX
    
    if (
        (   
            (len > ARRAYSIZE(c_wszIE4English)) && 
            (0 == memcmp(c_wszIE4English, pwszURL, sizeof(c_wszIE4English) - sizeof(WCHAR)))
        )       
        ||
        (   
            (len > ARRAYSIZE(c_wszIE4English2)) && 
            (0 == memcmp(c_wszIE4English2, pwszURL, sizeof(c_wszIE4English2) - sizeof(WCHAR)))
        )       
        ||
        (
            (len > (ARRAYSIZE(c_wszIE4IntlPre) + ARRAYSIZE(c_wszIE4IntlPost) + 4)) &&
            (0 == memcmp(c_wszIE4IntlPre, pwszURL, sizeof(c_wszIE4IntlPre)  - sizeof(WCHAR))) &&
            (0 == memcmp(c_wszIE4IntlPost, pwszURL + ARRAYSIZE(c_wszIE4IntlPre) + 1, 
                         sizeof(c_wszIE4IntlPost) - sizeof(WCHAR)))
        )
        ||
        (
            (len > (ARRAYSIZE(c_wszIE4IntlPre2) + ARRAYSIZE(c_wszIE4IntlPost) + 4)) &&
            (0 == memcmp(c_wszIE4IntlPre2, pwszURL, sizeof(c_wszIE4IntlPre2)  - sizeof(WCHAR))) &&
            (0 == memcmp(c_wszIE4IntlPost, pwszURL + ARRAYSIZE(c_wszIE4IntlPre2) + 1, 
                         sizeof(c_wszIE4IntlPost) - sizeof(WCHAR)))
        )
       )
    {
        bResult = TRUE;
    }

    return bResult;
}

struct NOTFSUBS
{
    NOTIFICATIONITEM        ni;
    NOTIFICATIONITEMEXTRA   nix;
    CLSID                   clsidItem;  //  Ignore
    NOTIFICATIONCOOKIE      notfCookie;
    NOTIFICATIONTYPE        notfType;
    ULONG                   nProps;

    // Variable length data here:
    //SaveSTATPROPMAP       statPropMap;
    //char                  szPropName[];
    //BYTE                  variant property data

    //...

    //SaveSTATPROPMAP       statPropMap;
    //char                  szPropName[];
    //BYTE                  variant property data
};

HRESULT SubscriptionFromNotification(NOTFSUBS *pns, 
                                     LPCWSTR pwszURL,
                                     LPCWSTR pwszName,
                                     const LPWSTR rgwszName[], 
                                     VARIANT rgValue[])
{
    HRESULT hr;

    ASSERT(NULL != pns);
    ASSERT(NULL != rgwszName);
    ASSERT(NULL != rgValue);

    if ((pns->ni.NotificationType == NOTIFICATIONTYPE_AGENT_START) &&
        (pns->nix.PackageFlags & PF_SCHEDULED) &&
        (NULL != pwszURL) &&
        (NULL != pwszName) &&
        (!IsIE4UpdateChannel(pwszURL)))
    {

        SUBSCRIPTIONITEMINFO sii;

        sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
        sii.dwFlags = 0;
        sii.dwPriority = 0;
        sii.ScheduleGroup = CLSID_NULL;
        sii.clsidAgent = pns->ni.clsidDest;

        hr = AddUpdateSubscription(&pns->notfCookie,
                                   &sii,
                                   pwszURL,
                                   pns->nProps,
                                   rgwszName,
                                   rgValue);

        if (SUCCEEDED(hr))
        {
            if (NOTFCOOKIE_SCHEDULE_GROUP_MANUAL != pns->ni.groupCookie)
            {
                ISubscriptionItem *psi;

                hr = SubscriptionItemFromCookie(FALSE, &pns->notfCookie, &psi);

                if (SUCCEEDED(hr))
                {
                    SYNCSCHEDULECOOKIE schedCookie = GUID_NULL;

                    if (GUID_NULL == pns->ni.groupCookie)
                    {
                        WCHAR wszSchedName[MAX_PATH];

                        CreatePublisherScheduleNameW(wszSchedName, ARRAYSIZE(wszSchedName),
                                                     NULL, pwszName);

                        //  Create the schedule
                        hr = CreateSchedule(wszSchedName, SYNCSCHEDINFO_FLAGS_READONLY, 
                                            &schedCookie, &pns->ni.TaskTrigger, FALSE);

                        //  If we created a new one or for some strange reason
                        //  "MSN Recommended Schedule" already exists we go with it
                        if (SUCCEEDED(hr) || (hr == SYNCMGR_E_NAME_IN_USE))
                        {
                            //  sii should have been initialized and set above
                            ASSERT(sizeof(SUBSCRIPTIONITEMINFO) == sii.cbSize);
                            ASSERT(GUID_NULL == sii.ScheduleGroup);

                            sii.ScheduleGroup = schedCookie;
                            hr = psi->SetSubscriptionItemInfo(&sii);
                        }
                    }
                    else
                    {
                        schedCookie = pns->ni.groupCookie;
                        hr = ConvertNotfMgrScheduleGroup(&schedCookie);
                    }

                    if (SUCCEEDED(hr))
                    {
                        SYNC_HANDLER_ITEM_INFO shii;

                        shii.handlerID = CLSID_WebCheckOfflineSync;
                        shii.itemID = pns->notfCookie;
                        shii.hIcon = NULL;
                        StrCpyNW(shii.wszItemName, pwszName, ARRAYSIZE(shii.wszItemName));
                        shii.dwCheckState = SYNCMGRITEMSTATE_CHECKED;

                        //  Not much we can do if this fails other than jump up and down
                        //  and scream like a baby.
                        hr = AddScheduledItem(&shii, &schedCookie);
                    }
                    psi->Release();
                }
            }
        }
    }
    else
    {
        TraceMsgA(TF_THISMODULE, "Not converting Notification subscription %S URL: %S", pwszName, pwszURL);
        hr = S_FALSE;
    }

    return hr;
}

HRESULT ConvertScheduleItem(CHAR *pszSubsName)
{
    HRESULT hr = E_FAIL;
    HKEY hkey;
    CHAR szKeyName[MAX_PATH];

    //  Build path to this notification item
    strcpy(szKeyName, c_pszRegKeyScheduleItems);
    szKeyName[sizeof(c_pszRegKeyScheduleItems) - 1] = '\\';
    strcpy(szKeyName + sizeof(c_pszRegKeyScheduleItems), pszSubsName);

    //  We just enumerated so this should be here!
    if (RegOpenKeyExA(HKEY_CURRENT_USER, szKeyName, 0, KEY_READ, &hkey) 
        == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwSize;

        //  Read the {GUID} value.  We need to alloc a buffer but don't know how big yet.
        //  This gets us the size and type.  If it's not binary or not big enough, bail.
        if ((RegQueryValueExA(hkey, pszSubsName, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS) &&
            (dwType == REG_BINARY) &&
            (dwSize >= sizeof(NOTFSUBS)))
        {
            BYTE *pData = new BYTE[dwSize];

            if (NULL != pData)
            {
                if (RegQueryValueExA(hkey, pszSubsName, NULL, &dwType, pData, &dwSize) == ERROR_SUCCESS)
                {
                    //  Shouldn't have gotten here based on the check above.
                    ASSERT(dwType == REG_BINARY);
                    ASSERT(dwSize >= sizeof(NOTFSUBS));

                    ULONG i;
                    NOTFSUBS *pns = (NOTFSUBS *)pData;

                    //  Point to the repeated variable size block
                    BYTE *pVarData = pData + FIELD_OFFSET(NOTFSUBS, nProps) + sizeof(ULONG);

                    //  Allocate buffers to hold the arrays of property names and values
                    WCHAR **ppwszPropNames = new WCHAR *[pns->nProps];
                    VARIANT *pVars = new VARIANT[pns->nProps];
                    WCHAR *pwszURL = NULL;
                    WCHAR *pwszName = NULL;

                    if ((NULL != ppwszPropNames) && (NULL != pVars))
                    {
                        //  adjust size remaining
                        dwSize -= sizeof(NOTFSUBS);

                        for (i = 0, hr = S_OK; 
                             (i < pns->nProps) && (dwSize >= sizeof(SaveSTATPROPMAP)) &&
                                 SUCCEEDED(hr);
                             i++)
                        {
                            SaveSTATPROPMAP *pspm = (SaveSTATPROPMAP *)pVarData;
                            CHAR *pszPropName = (CHAR *)(pVarData + sizeof(SaveSTATPROPMAP));
                            DWORD cbUsed;

                            ppwszPropNames[i] = new WCHAR[pspm->cbStrLen + 1];
                            if (NULL == ppwszPropNames[i])
                            {
                                hr = E_OUTOFMEMORY;
                                break;
                            }
                            MultiByteToWideChar(CP_ACP, 0, pszPropName, pspm->cbStrLen, 
                                                ppwszPropNames[i], pspm->cbStrLen);

                            //  Point to where the variant blob starts
                            pVarData += sizeof(SaveSTATPROPMAP) + pspm->cbStrLen;

                            //  adjust size remaining
                            dwSize -= sizeof(SaveSTATPROPMAP) + pspm->cbStrLen;
                            
                            hr = BlobToVariant(pVarData, dwSize, &pVars[i], &cbUsed, TRUE);

                            if ((3 == pspm->cbStrLen)
                                && (StrCmpNIA(pszPropName, "URL", 3) == 0))
                            {
                                pwszURL = pVars[i].bstrVal;
                            }
                            else if ((4 == pspm->cbStrLen)
                                && (StrCmpNIA(pszPropName, "Name", 4) == 0))
                            {
                                pwszName = pVars[i].bstrVal; 
                            }

                            //  Point to start of next SaveSTATPROPMAP
                            pVarData += cbUsed;

                            //  adjust size remaining
                            dwSize -= cbUsed;
                        }

                        if (SUCCEEDED(hr))
                        {
                            hr = SubscriptionFromNotification(pns, 
                                                              pwszURL,
                                                              pwszName,
                                                              ppwszPropNames, 
                                                              pVars);
                        }
                        else
                        {
                            TraceMsgA(TF_THISMODULE, "Not converting notification subscription %s", pszSubsName);
                        }

                        for (i = 0; i < pns->nProps; i++)
                        {
                            if (ppwszPropNames[i])
                            {
                                delete [] ppwszPropNames[i];
                            }
                            VariantClear(&pVars[i]);
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    SAFEDELETE(ppwszPropNames);
                    SAFEDELETE(pVars);
                }
                delete [] pData;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

HRESULT ConvertNotfMgrSubscriptions()
{
    HRESULT hr = S_OK;
    HKEY hkey;

    if (RegOpenKeyExA(HKEY_CURRENT_USER, c_pszRegKeyScheduleItems, 0, KEY_READ, &hkey) 
        == ERROR_SUCCESS)
    {
        int i = 0;
        CHAR szSubsName[MAX_PATH];

        TraceMsg(TF_THISMODULE, "Converting Notification Mgr subscriptions");

        while (RegEnumKeyA(hkey, i++, szSubsName, sizeof(szSubsName)) == ERROR_SUCCESS)
        {
            HRESULT hrConvert = ConvertScheduleItem(szSubsName);
            if (FAILED(hrConvert))
            {
                ASSERT(0);
                hr = S_FALSE;
                //  Something failed, should we break or keep on truckin'?
                //  break;
            }
        }
        RegCloseKey(hkey);
    }
    else
    {
        TraceMsg(TF_THISMODULE, "No Notification Mgr subscriptions to convert");
        //  No Notification Manager schedule items key so there's nothing to do...
        hr = S_FALSE;
    }

    return hr;
}

struct NOTFSCHED
{
    SCHEDULEGROUPITEM   sgi;
    DWORD               cchName;
    WCHAR               wszName[1];   //  varies depending on cchName
};

HRESULT ConvertNotfMgrScheduleGroup(NOTIFICATIONCOOKIE *pSchedCookie)
{
    HRESULT hr = S_OK;

    if (!ScheduleCookieExists(pSchedCookie))
    {
        HKEY hkey;
        DWORD dwResult;

        dwResult = RegOpenKeyExA(HKEY_CURRENT_USER, c_pszRegKeyScheduleGroup, 0, KEY_READ, &hkey);

        if (ERROR_SUCCESS == dwResult)
        {
            TCHAR szGuid[GUIDSTR_MAX];
            DWORD dwType;
            DWORD cbSize;
            
            SHStringFromGUID(*pSchedCookie, szGuid, ARRAYSIZE(szGuid));

            dwResult = RegQueryValueEx(hkey, szGuid, NULL, &dwType, NULL, &cbSize);

            if (ERROR_SUCCESS == dwResult)
            {
                BYTE *pData = new BYTE[cbSize];

                if (NULL != pData)
                {
                    dwResult = RegQueryValueEx(hkey, szGuid, NULL, &dwType, pData, &cbSize);
                    
                    if (ERROR_SUCCESS == dwResult)
                    {                          
                        if (dwType == REG_BINARY)
                        {
                            NOTFSCHED *pns = (NOTFSCHED *)pData;

                            hr = CreateSchedule(pns->wszName, 0, &pns->sgi.GroupCookie, 
                                                &pns->sgi.TaskTrigger, TRUE);
                                                 
                            if (SYNCMGR_E_NAME_IN_USE == hr)
                            {
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(dwResult);
                    }

                    delete [] pData;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(dwResult);
            }
            RegCloseKey(hkey);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwResult);
        }
    }
    else
    {
        hr = S_FALSE;
    }
    
    return hr;
}

HRESULT WhackIE4UpdateChannel()
{
    HRESULT hr;
    IChannelMgr *pChannelMgr;

    hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, 
                          IID_IChannelMgr, (void**)&pChannelMgr);

    if (SUCCEEDED(hr))
    {
        IEnumChannels *pEnumChannels;

        hr = pChannelMgr->EnumChannels(CHANENUM_ALLFOLDERS | CHANENUM_PATH | CHANENUM_URL,
                                       NULL, &pEnumChannels);

        if (SUCCEEDED(hr))
        {
            CHANNELENUMINFO cei;

            while (S_OK == pEnumChannels->Next(1, &cei, NULL))
            {
                if (IsIE4UpdateChannel(cei.pszURL))
                {
                    TraceMsgA(TF_THISMODULE, "Whacking IE 4 update channel: %S %S", cei.pszURL, cei.pszPath);
                    hr = pChannelMgr->DeleteChannelShortcut(cei.pszPath);

                    ASSERT(SUCCEEDED(hr));
                }

                CoTaskMemFree(cei.pszURL);
                CoTaskMemFree(cei.pszPath);
            }
            pEnumChannels->Release();
        }
        pChannelMgr->Release();
    }

    return hr;
}

HRESULT FixupChannelScreenSaver()
{
    HRESULT hr;
    IChannelMgrPriv2 *pChannelMgrPriv2;

    hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, 
                          IID_IChannelMgrPriv2, (void**)&pChannelMgrPriv2);

    if (SUCCEEDED(hr))
    {
        TraceMsg(TF_THISMODULE, "Refreshing IE 4 Screen Saver URLs");
        hr = pChannelMgrPriv2->RefreshScreenSaverURLs();
#ifdef DEBUG
        if (FAILED(hr))
        {
            DBG("Error refreshing screen saver urls!");
        }
#endif
        pChannelMgrPriv2->Release();
    }

    return hr;
}

HRESULT ConvertIE4Subscriptions()
{
    HRESULT hr;

    hr = ConvertNotfMgrSubscriptions();
    
    ASSERT(SUCCEEDED(hr));

    hr = WhackIE4UpdateChannel();

    ASSERT(SUCCEEDED(hr));
    
    hr = FixupChannelScreenSaver();

    ASSERT(SUCCEEDED(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\offline.cpp ===
#include "private.h"   // Class Definitions 



BOOL PromptToGoOffline(VOID);
BOOL PromptToGoOnline(VOID);
BOOL CALLBACK GoOfflinePromptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam);
BOOL CALLBACK GoOnlinePromptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam);

// Make sure that Notification Sinks are apartment model and hence are always called back
// on the same thread making it unnecessary to use any critical sections -- APPCOMPAT





// TRUE means that the state now is Online
// FALSE means that the user chose to remain Offline

BOOL
OnConnectedNotification(void)
{
    BOOL fRet = TRUE;
            
    // Check to see if the user is offline and wants to "go online"
    if((IsGlobalOffline()))
    {
        //Ask the user with a dialog
        fRet = PromptToGoOnline();
    }  

    return fRet;
}

// TRUE means that the state now is Offline
// FALSE means that the user chose to remain Online

BOOL
OnDisconnectedNotification(void)
{      
    BOOL fRet = TRUE;
    // Check to see if the user wants to go offline
    if(!(IsGlobalOffline()))
    {
        //Ask the user with a dialog, if the user says yes, then
        // toggle to offline mode by calling wininet
        fRet = PromptToGoOffline();
    }

        
    return fRet;

}
    

BOOL PromptToGoOffline(VOID)
{

    // run the dialog
    BOOL fRet = DialogBoxParam(MLGetHinst(),MAKEINTRESOURCE(IDD_GO_OFFLINE_DLG),
            NULL,GoOfflinePromptDlgProc,(LPARAM) 0);

    return fRet;
}

/*******************************************************************

        NAME:           GoOfflinePromptDlgProc

        SYNOPSIS:       Dialog proc for Go Offline dialog

********************************************************************/
BOOL CALLBACK GoOfflinePromptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam)
{
    switch (uMsg) {
    case WM_INITDIALOG:
        SetWindowPos(hDlg, HWND_TOPMOST, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
        return TRUE;
        break;
    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            SetGlobalOffline(TRUE); 
            EndDialog(hDlg,TRUE);
            return TRUE;
            break;
        case IDCANCEL:            
            EndDialog(hDlg,FALSE);
            return TRUE;
            break;
        default:
            break;
        }
        break;
   default:
        break;
   }

    return FALSE;
}


BOOL PromptToGoOnline(VOID)
{

    // run the dialog
    BOOL fRet = DialogBoxParam(MLGetHinst(),MAKEINTRESOURCE(IDD_GO_ONLINE_DLG),
            NULL,GoOnlinePromptDlgProc,(LPARAM) 0);

    return fRet;
}

/*******************************************************************

        NAME:           GoOnlinePromptDlgProc

        SYNOPSIS:       Dialog proc for Go Online dialog

********************************************************************/
BOOL CALLBACK GoOnlinePromptDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam)
{
    switch (uMsg) {
    case WM_INITDIALOG:
        return TRUE;
        break;
    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            SetGlobalOffline(FALSE); 
            EndDialog(hDlg,TRUE);
            return TRUE;
            break;
        case IDCANCEL: 
            EndDialog(hDlg,FALSE);
            return TRUE;
            break;
         default:
            break;
        }
        break;
    default:
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\offline.h ===
#ifndef OFFLINE_H
#define OFFLINE_H

typedef enum AGENT_PRIORITY {
    AGENT_PRIORITY_NORMAL = 2
} AGENT_PRIORITY;

typedef enum    {_INIT_FROM_URL, _INIT_FROM_INTSHCUT, _INIT_FROM_CHANNEL} INIT_SRC_ENUM;

#define MAX_NAME_QUICKLINK      MAX_PATH
#define MAX_NAME                MAX_NAME_QUICKLINK
#define MAX_URL                 INTERNET_MAX_URL_LENGTH
#define MAX_USERNAME            127
#define MAX_PASSWORD            63
#define MAX_STATUS              127

#define MAX_PROP_PAGES          10
#define MAX_WC_AGENT_PAGES      2

typedef struct {
    int     templateRCID;
    DLGPROC dlgProc;
} PageType, * LPPageType;
typedef const PageType *CLPPageType;

// PIDL format for this folder...
typedef struct OOEntry
{
    DWORD       dwSize;
    DWORD       dwFlags;
    CFileTime   m_LastUpdated;
    CFileTime   m_NextUpdate;
    LONG        m_SizeLimit;
    LONG        m_ActualSize;
    LONG        m_RecurseLevels;
    LONG        m_RecurseFlags;
    AGENT_PRIORITY  m_Priority;
    BOOL        bDesktop;
    BOOL        bChannel;
    BOOL        bMail;
    BOOL        bGleam;
    BOOL        bChangesOnly;
    BOOL        bNeedPassword;
    TASK_TRIGGER    m_Trigger;
    DWORD       fChannelFlags;
    SUBSCRIPTIONCOOKIE m_Cookie;
    SUBSCRIPTIONCOOKIE groupCookie;
    DWORD       grfTaskTrigger;
    CLSID       clsidDest;
    SCODE       status;
    LPTSTR      username;
    LPTSTR      password;
    LPTSTR      m_URL;
    LPTSTR      m_Name;
    LPTSTR      statusStr;
} OOEntry;

typedef UNALIGNED OOEntry * POOEntry;

#define PSF_NO_SCHEDULED_UPDATES    0x00000001
#define PSF_NO_EDITING_SCHEDULES    0x00000002
#define PSF_NO_AUTO_NAME_SCHEDULE   0x00000004
#define PSF_NO_CHECK_SCHED_CONFLICT 0x00000008
#define PSF_IS_ALREADY_SUBSCRIBED   0x00000010

typedef struct
{ 
    DWORD       dwFlags;
    CFileTime   m_LastUpdated;
    CFileTime   m_NextUpdate;
    LONG        m_SizeLimit;
    LONG        m_ActualSize;
    LONG        m_RecurseLevels;
    LONG        m_RecurseFlags;
    AGENT_PRIORITY  m_Priority;
    BOOL        bDesktop;
    BOOL        bChannel;
    BOOL        bMail;
    BOOL        bGleam;
    BOOL        bChangesOnly;
    BOOL        bNeedPassword;
    TASK_TRIGGER    m_Trigger;
    DWORD       fChannelFlags;
    SUBSCRIPTIONCOOKIE m_Cookie;
    SUBSCRIPTIONCOOKIE groupCookie;
    DWORD       grfTaskTrigger;
    CLSID       clsidDest;
    SCODE       status;
    TCHAR       username[MAX_USERNAME + 1];
    TCHAR       password[MAX_PASSWORD + 1];
    TCHAR       m_URL[MAX_URL + 1];
    TCHAR       m_Name[MAX_NAME + 1];
    TCHAR       statusStr[MAX_STATUS +1];
    DWORD       m_dwPropSheetFlags;     // used internally by propsheets and wizard
    HWND        hwndNewSchedDlg;
} OOEBuf, * POOEBuf;

typedef struct
{
    USHORT  cb;
    USHORT  usSign;
    OOEntry ooe;  //  Should point to the place right after itself.
} MYPIDL;

typedef UNALIGNED MYPIDL *LPMYPIDL;

typedef struct _ColInfoType {
    short int iCol;
    short int ids;        // Id of string for title
    short int cchCol;     // Number of characters wide to make column
    short int iFmt;       // The format of the column;
} ColInfoType;

enum {
    ICOLC_SHORTNAME = 0,
    ICOLC_LAST,
    ICOLC_STATUS, 
    ICOLC_URL,
    ICOLC_ACTUALSIZE
};
  
#define MYPIDL_MAGIC       0x7405

#define RETURN_ON_FAILURE(hr)   if (FAILED(hr)) return hr

#define IS_VALID_MYPIDL(pidl)      ((((LPMYPIDL)pidl)->cb > sizeof(MYPIDL)) && \
                                     (((LPMYPIDL)pidl)->usSign == (USHORT)MYPIDL_MAGIC))

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define NAME(pooe)  (LPTSTR)((LPBYTE)(pooe) + (DWORD_PTR)((pooe)->m_Name))
#define URL(pooe)   (LPTSTR)((LPBYTE)(pooe) + (DWORD_PTR)((pooe)->m_URL))
#define UNAME(pooe) (LPTSTR)((LPBYTE)(pooe) + (DWORD_PTR)((pooe)->username))
#define PASSWD(pooe) (LPTSTR)((LPBYTE)(pooe) + (DWORD_PTR)((pooe)->password))
#define STATUS(pooe) (LPTSTR)((LPBYTE)(pooe) + (DWORD_PTR)((pooe)->statusStr))

#ifdef __cplusplus
extern "C" {
#endif
    
extern HINSTANCE g_hInst;
extern const CHAR c_szOpen[];
extern const CHAR c_szUpdate[];
extern const CHAR c_szDelete[];
extern const CHAR c_szProperties[];
extern const CHAR c_szCopy[];

extern const CLSID CLSID_OfflineFolder;
extern const CLSID CLSID_WebcrawlHelper;
extern const CLSID IID_IOfflineObject;

#ifdef __cplusplus
};
#endif

#include "wizards.h"
#include "utils.h"  // NOTE: must come at end to get all the definitions

#endif // OFFLINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\mailagnt.cpp ===
//
// WebCheck Mail Agent
//
// A user specifies that they are to be notified via email when a web checked
// object (usually a page) changes.
//
// When the subscription is the delivery agent will call the mail agent upon completion
//  with a temporary ISubscriptionItem
// 
// Julian Jiggins (julianj), January 8, 1997
//

#include "private.h"
#include "mapi.h"
#include "smtp.h"
#include "mlang.h"

#include <mluisupp.h>

#undef TF_THISMODULE
#define TF_THISMODULE   TF_MAILAGENT

//
// Global strings
// REVIEW move to a better place
//
#define MAIL_HANDLER    TEXT("Software\\Clients\\Mail")
#define MAIL_ATHENA     TEXT("Internet Mail and News")
#define SUBJECT_LINE TEXT("Subscription delivered")
#define MESSAGE_PREFIX TEXT(" \r\nThe website you requested ")
#define MESSAGE_SUFFIX TEXT(" has been delivered")

#define ATHENA_SMTP_SERVER \
    TEXT("Software\\Microsoft\\Internet Mail and News\\Mail\\SMTP")
#define NETSCAPE_SMTP_SERVER \
    TEXT("Software\\Netscape\\netscape Navigator\\Services\\SMTP_Server")
#define EUDORA_COMMANDLINE TEXT("Software\\Qualcomm\\Eudora\\CommandLine")

#define NOTE_TEXT_LENGTH 4096

#define ENCODING_STRLEN 32

//////////////////////////////////////////////////////////////////////////
//
// Email helper functions
//
//////////////////////////////////////////////////////////////////////////

//
// Returns a MemAlloc'd string with HTMLBreak inserted in place of '\d'.
//
void AddHTMLBreakText(LPSTR szText, LPSTR szHTMLBreak, LPSTR *lpHTMLText)
{
    ASSERT(szText);
    ASSERT(szHTMLBreak);
    ASSERT(!*lpHTMLText);

    LPSTR lpTmp = NULL, lpTmp2 = NULL, lpHTMLAbstract = NULL;
    int cbCRs = 0;
    int cbLFs = 0;
    DWORD dwExtra = 0;
    
    //
    // Count number of carriage returns
    //
    for (lpTmp = szText; *lpTmp; lpTmp++)
    {
        if (*lpTmp == 0x0d)
            cbCRs++;
        if (*lpTmp == 0x0a)
            cbLFs++;
    }
    
    dwExtra = lstrlenA(szText) - cbCRs - cbLFs + cbCRs * lstrlenA(szHTMLBreak) + 1;

    //
    // Allocate appropriate size string
    //
    *lpHTMLText = lpHTMLAbstract = (LPSTR)MemAlloc(LPTR, dwExtra);
    if (!lpHTMLAbstract)
        return;

    // 
    // Create new HTML abstract string.
    //
    for (lpTmp = szText; *lpTmp; lpTmp++)
    {
        if (*lpTmp == 0x0d)
        {
            for (lpTmp2 = szHTMLBreak; *lpTmp2; lpTmp2++, lpHTMLAbstract++)
                *lpHTMLAbstract = *lpTmp2;
        }
        else if (*lpTmp != 0x0a)
        {
            *lpHTMLAbstract = *lpTmp;
            lpHTMLAbstract++;
        }
    }

    *lpHTMLAbstract = '\0';

}

#ifdef DEBUG
void DBG_OUTPUT_MAPI_ERROR(ULONG ul)
{
    switch(ul)
    {
    case MAPI_E_LOGON_FAILURE: 
        DBG("MailAgent: MAPI LOGON FAILURE"); break;
    case MAPI_E_FAILURE:
        DBG("MailAgent: MAPI_E_FAILURE"); break;
    default: 
        DBG("MailAgent: Failed to send mail message"); break;
    }
}
#else
#define DBG_OUTPUT_MAPI_ERROR(ul)
#endif

//
// Build an HTML message containing a frameset that effectively inlines
// the requested URL
//
BOOL BuildHTMLMessage(LPSTR szEmailAddress, LPSTR szName, LPSTR szURL, 
                      CHAR **ppHTMLMessage,  LPSTR szTitle, LPSTR szAbstract,
                      LPSTR szSrcCharset)
{
    *ppHTMLMessage = NULL; // clear out parameter
    
    CHAR * lpBuffer = NULL;

    CHAR szWrapper[NOTE_TEXT_LENGTH];
    CHAR szMessageFormat[NOTE_TEXT_LENGTH];
    CHAR szMessageFormat2[NOTE_TEXT_LENGTH];
    CHAR szMessageText[NOTE_TEXT_LENGTH];
    CHAR szMessageHTML[NOTE_TEXT_LENGTH];
    CHAR szTextBreak[10];
    CHAR szHTMLBreak[10];

    //
    // Load the wrapper for the HTML message. This is the header stuff 
    // and multipart MIME and HTML goop
    //
    int iRet = MLLoadStringA(IDS_AGNT_HTMLMESSAGEWRAPPER, szWrapper, NOTE_TEXT_LENGTH);
    ASSERT(iRet > 0);

    if (szTitle != NULL) {

        // NOTE: Size is probably slightly larger than necessary due to %1's.

        LPSTR lpHTMLAbstract = NULL, lpNewAbstract = NULL;
        DWORD dwTotalSize = 0;
        //
        // load string for single HTML line break as well as tag on for custom email
        //

        MLLoadStringA(IDS_AGNT_EMAILMESSAGE, szMessageText, ARRAYSIZE(szMessageText));

        MLLoadStringA(IDS_AGNT_HTMLBREAKSINGLE, szHTMLBreak, ARRAYSIZE(szHTMLBreak));

        // 
        // Create new abstract string (szAbstract + email tagger)
        //
        dwTotalSize = lstrlenA(szAbstract) + lstrlenA(szMessageText) + 1;

        LPSTR szNewAbstract = (LPSTR)MemAlloc(LPTR, dwTotalSize * sizeof(CHAR));
        if (!szNewAbstract)
            return FALSE;

        lstrcpyA(szNewAbstract, szAbstract);
        StrCatA(szNewAbstract, szMessageText);
        
        AddHTMLBreakText(szNewAbstract, szHTMLBreak, &lpHTMLAbstract);
        if (!lpHTMLAbstract) 
        {
            MemFree(szNewAbstract);
            return FALSE;
        }
            
        dwTotalSize = lstrlenA(szWrapper) + lstrlenA(szEmailAddress) + 
                            2*lstrlenA(szTitle) + lstrlenA(szNewAbstract) + lstrlenA(szSrcCharset) +
                            lstrlenA(lpHTMLAbstract) + lstrlenA(szURL) + 1;

        lpBuffer = (CHAR *)MemAlloc(LPTR, dwTotalSize * sizeof(CHAR));
        if (!lpBuffer)
            return FALSE;

        LPSTR lpArguments[6];
        lpArguments[0] = szEmailAddress;
        lpArguments[1] = szTitle;
        lpArguments[2] = szNewAbstract;
        lpArguments[3] = szSrcCharset;    // the charset of the HTML page
        lpArguments[4] = szURL;
        lpArguments[5] = lpHTMLAbstract;

        //
        // Reason for FormatMessage is that wsprintf is limited up to 1024 bytes
        //

        FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                szWrapper, 0, 0, lpBuffer, dwTotalSize, (va_list *)&lpArguments[0]);

        MemFree(szNewAbstract);
        MemFree(lpHTMLAbstract);

    } else {

        //
        // Load line breaks for the plaintext and html messages
        //
        iRet = MLLoadStringA(IDS_AGNT_TEXTBREAK, szTextBreak, ARRAYSIZE(szTextBreak));
        ASSERT(iRet > 0);
        iRet = MLLoadStringA(IDS_AGNT_HTMLBREAK, szHTMLBreak, ARRAYSIZE(szHTMLBreak));
        ASSERT(iRet > 0);

        //
        // Load the actual text message to put sent
        //
        iRet = MLLoadStringA(IDS_AGNT_HTMLMESSAGETEXT, szMessageFormat, NOTE_TEXT_LENGTH);
        ASSERT(iRet > 0);

        iRet = MLLoadStringA(IDS_AGNT_HTMLMESSAGETEXT2, szMessageFormat2, NOTE_TEXT_LENGTH);
        ASSERT(iRet > 0);

        //
        // Insert the text messages into the wrapper. Note two message get
        // Once in the mime section for text/ascii and once in the 
        // noframes section of the text/html frameset. This is a work around
        // for clients (like Outlook) that think they can render HTML
        // but cannot really. 
        // The second message IDS_AGNT_HTMLMESSAGETEXT2 should NOT be localized
        // this is only going to be seen by Exchange users. In the future exchange
        // will handle html mail correct, so it acceptable that for example
        // Japanese Exchange users see english in this message. Most Japanese
        // users will user Outlook Express and so will just see the html message
        //

        // First we format 2 text messages, one for text and one for HTML,
        // since message itself is relatively small we know its < 1024 bytes

        iRet = wnsprintfA(szMessageText, ARRAYSIZE(szMessageText), szMessageFormat, 
                         szName, szTextBreak, szURL, szTextBreak);
        ASSERT(iRet > lstrlenA(szMessageFormat));

        iRet = wnsprintfA(szMessageHTML, ARRAYSIZE(szMessageHTML), szMessageFormat2, 
                         szName, szHTMLBreak, szURL, szHTMLBreak);
        ASSERT(iRet > lstrlenA(szMessageFormat2));

        DWORD dwTotalSize = lstrlenA(szWrapper) + lstrlenA(szEmailAddress) +
                            lstrlenA(szName) + lstrlenA(szMessageText) + lstrlenA(szSrcCharset) +
                            lstrlenA(szMessageHTML) + lstrlenA(szURL) + 1;

        lpBuffer = (CHAR *)MemAlloc(LPTR, dwTotalSize * sizeof(CHAR));
        if (!lpBuffer)
            return FALSE;

        LPSTR lpArguments[6];
        lpArguments[0] = szEmailAddress;  // target email address
        lpArguments[1] = szName;          // the name of the page that goes in the subject line  
        lpArguments[2] = szMessageText;   // the plain text message
        lpArguments[3] = szSrcCharset;    // the charset of the HTML page
        lpArguments[4] = szURL;           // the href of the page that goes in the frame set
        lpArguments[5] = szMessageHTML;   // the plain text message that goes in the 
                                          // noframes part of the frameset

        DWORD dwRet;
        dwRet = FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            szWrapper, 0, 0, lpBuffer, dwTotalSize, (va_list *)&lpArguments[0]);
        ASSERT(dwRet);            
    }

    *ppHTMLMessage = lpBuffer;

    return TRUE;
}

//
// Build the actual text of the message to be sent via SMTP,
// load format string from resource and insert URL and URL's friently name.
//
void BuildSMTPMessage(LPSTR szName, LPSTR szURL, LPSTR *szMessage,
                      LPSTR szTitle, LPSTR szAbstract)
{
    CHAR szFormatText[NOTE_TEXT_LENGTH];
    int i;
    ASSERT(szMessage);
    
    if (!szMessage)
        return;


    *szMessage = NULL;

    if (szTitle != NULL) {
        i = MLLoadStringA(IDS_AGNT_SMTPMESSAGE_OTHER, szFormatText, NOTE_TEXT_LENGTH);
        ASSERT(i != 0);
        
        DWORD dwLen = lstrlenA(szFormatText) + lstrlenA(szTitle) + lstrlenA(szAbstract) + 1;

        *szMessage = (LPSTR) MemAlloc(LPTR, dwLen * sizeof(CHAR));
        if (!*szMessage)
            return;

        LPSTR lpArgs[2];
        lpArgs[0] = szTitle;
        lpArgs[1] = szAbstract;

        FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                szFormatText, 0, 0, *szMessage, dwLen, (va_list *)&lpArgs[0]);

    } else {
        i = MLLoadStringA(IDS_AGNT_SMTPMESSAGE, szFormatText, NOTE_TEXT_LENGTH);
        ASSERT(i != 0);
        
        DWORD dwLen = lstrlenA(szFormatText) + 2*lstrlenA(szName) + lstrlenA(szURL) + 1;

        *szMessage = (LPSTR) MemAlloc(LPTR, dwLen * sizeof(CHAR));
        if (!*szMessage)
            return;

        LPSTR lpArgs[3];
        lpArgs[0] = lpArgs[1] = szName;
        lpArgs[2] = szURL;

        FormatMessageA(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                szFormatText, 0, 0, *szMessage, dwLen, (va_list *)&lpArgs[0]);
    }

}

#if 0
//
// Build MAPI message structure
//

void BuildMAPIMessage(
    LPTSTR lpszName, 
    LPTSTR lpszURL, 
    LPTSTR lpszEmailAddress,
    MapiMessage   * lpMessage,
    MapiRecipDesc * lpRecipient,
    LPTSTR lpszNoteText,                    // [out]
    LPTSTR lpszSubject,                     // [out]
    LPTSTR lpszTitle,                        // [in] title, NULL if not custom
    LPTSTR lpszAbstract)                     // [in] abstract, NULL if not custom
{
    TCHAR szFmtNoteText[NOTE_TEXT_LENGTH];
    TCHAR szFmtSubject[INTERNET_MAX_URL_LENGTH];
    int i;

    //
    // zero out the passed in mapi structures
    //
    ZeroMemory(lpMessage,   sizeof(MapiMessage));
    ZeroMemory(lpRecipient, sizeof(MapiRecipDesc));
#error The wsprintf's below need to be converted to wnsprintf
    //
    // Load the strings containing the bulk of the email message
    //
    if (lpszTitle != NULL) {
        MLLoadString(IDS_AGNT_MAPIMESSAGE_OTHER, szFmtNoteText, NOTE_TEXT_LENGTH);
        MLLoadString(IDS_AGNT_MAPISUBJECT_OTHER, szFmtSubject, INTERNET_MAX_URL_LENGTH);

        i = wsprintf(lpszNoteText, szFmtNoteText, lpszAbstract);
        ASSERT(i < NOTE_TEXT_LENGTH);
        i = wsprintf(lpszSubject, szFmtSubject, lpszTitle);
        ASSERT(i < INTERNET_MAX_URL_LENGTH);

    } else {
        MLLoadString(IDS_AGNT_MAPIMESSAGE, szFmtNoteText, NOTE_TEXT_LENGTH);
        MLLoadString(IDS_AGNT_MAPISUBJECT, szFmtSubject,  INTERNET_MAX_URL_LENGTH);

        i = wsprintf(lpszNoteText, szFmtNoteText, lpszName, lpszURL);
        ASSERT(i < NOTE_TEXT_LENGTH);
        i = wsprintf(lpszSubject,  szFmtSubject, lpszName);
        ASSERT(i < INTERNET_MAX_URL_LENGTH);
    }

    //
    // Build a mapi mail recipient structure
    //
    lpRecipient->ulRecipClass = MAPI_TO;
    lpRecipient->lpszName = lpszEmailAddress;

    //
    // Fill in the message subject line, recipient and note text
    //
    lpMessage->nRecipCount = 1;
    lpMessage->lpRecips = lpRecipient;
    lpMessage->lpszNoteText = lpszNoteText;
    lpMessage->lpszSubject  = lpszSubject;
}
#endif

//
// Use the MLANG apis to translate the string
//
// Returns success if translation occurred, fails otherwise
//
// Note if lpszSrcCharSet is NULL then use CP_ACP as the codepage
//

HRESULT TranslateCharset(
    LPSTR lpszSrcString, LPSTR lpszDstString, UINT uiDstSize,
    LPSTR lpszSrcCharset, LPSTR lpszDstCharset
    )
{
    HRESULT hr = E_FAIL;

    WCHAR wszSrcCharset[ENCODING_STRLEN];
    WCHAR wszDstCharset[ENCODING_STRLEN];

    if (lpszSrcString  == NULL || lpszDstString  == NULL || 
        lpszDstCharset == NULL)
    {
        return E_INVALIDARG;
    }

    SHAnsiToUnicode(lpszDstCharset, wszDstCharset, ARRAYSIZE(wszDstCharset));
    if (lpszSrcCharset)
        SHAnsiToUnicode(lpszSrcCharset, wszSrcCharset, ARRAYSIZE(wszSrcCharset));

    LPMULTILANGUAGE2 pIML2 = NULL;

    //
    // Create the MLANG object
    //
    if (SUCCEEDED(CoCreateInstance (CLSID_CMultiLanguage, NULL,
        CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (void**)&pIML2)))
    {
        UINT srcCodePage = (UINT)-1, dstCodePage;
        MIMECSETINFO mcsi = {0};

        //
        // First get the source code page either from the passed in string
        // name of source Charset or from the default one if null if passed in
        //
        if (lpszSrcCharset == NULL)
        {
            srcCodePage = GetACP();
            hr = S_OK;
        }
        else
        {
            //
            // Use the mlang object to get the codepages
            //
            hr = pIML2->GetCharsetInfo(wszSrcCharset, &mcsi);
            if (SUCCEEDED(hr))
            {
                srcCodePage = mcsi.uiInternetEncoding;
            }
        }
        
        if (SUCCEEDED(hr))
        {
            hr = pIML2->GetCharsetInfo(wszDstCharset, &mcsi);

            if (SUCCEEDED(hr))
            {
                dstCodePage = mcsi.uiInternetEncoding;

                if (srcCodePage != dstCodePage)
                {
                    //
                    // To work around a bug in the Mlang::ConvertString api
                    // have to pass in a ptr to length of the src string
                    //
                    UINT uiSrcSize = lstrlenA(lpszSrcString) + 1;

                    DWORD dwMode = 0;
                    hr = pIML2->ConvertString(
                        &dwMode, 
                        srcCodePage, 
                        dstCodePage,
                        (LPBYTE)lpszSrcString,
                        &uiSrcSize,
                        (LPBYTE)lpszDstString,
                        &uiDstSize);
                }
                else
                {
                    lstrcpynA(lpszDstString, lpszSrcString, uiDstSize);
                }
            }
        }
        pIML2->Release();
    }
    return hr;
}



//////////////////////////////////////////////////////////////////////////
//
// Mail notification implementation
//
//////////////////////////////////////////////////////////////////////////

//
// Notify via email that the pszURL has changed
//
// There are 3 ways to send via email -
//
// Use straight MAPI (IE Exchange or Outlook)
//      Most people don't have Exchange in the real world.
//
// Use Athena's MAPI implementation
//      It's broken and doesn't handle UI'less mode
//
// Use straight SMTP,
//      Need to get the name of an SMTP server
//
HRESULT
NotifyViaEMail(
    LPSTR lpszURL,             // url that was downloaded
    LPSTR lpszEmailAddress,    // email address to send notification to
    LPSTR lpszSMTPServer,      // SMTP server to use to deliver email
    LPSTR &lpszName,           // friendly name of url (probably page title)
    LPSTR lpszTitle,           // optional: NULL if not custom message
    LPSTR lpszAbstract,        // optional: NULL if not custom message
    LPSTR lpszCharSet,         // optional: charset of html page
    BOOL  fSendHTMLEmail )     // TRUE if registry allows it and check mode
                               // supports it.
{
    BOOL b;
    
    LPSTR lpszSMTPMessage;

    //
    // lpszName comes from the title of the web page. If the charset of the page
    // is not the same as the one that this version of IE has been localized to
    // then we need to use the MLANG api's to coerce the string into the correct
    // charset
    //
    CHAR szTargetEncoding[ENCODING_STRLEN];
    MLLoadStringA(IDS_TARGET_CHARSET_EMAIL, szTargetEncoding, ARRAYSIZE(szTargetEncoding));

    //
    // Allocate buffer for new name. This is a conversion from one dbcs charset 
    // to another so size shouldn't but to be safe use *2 multiplier.
    //
    UINT uiSize = lstrlenA(lpszName) * 2;
    LPSTR lpszNewName = (LPSTR) MemAlloc(LMEM_FIXED, uiSize * sizeof(CHAR));

    if (lpszNewName)
    {
        //
        // Note check for S_OK as will return S_FALSE if there is no appropriate
        // translation installed on this machine
        //
        if (S_OK == TranslateCharset(lpszName, lpszNewName, uiSize, lpszCharSet,
                                     szTargetEncoding))
        {
            //
            // if translation occurred alias new name to old name
            //
            SAFELOCALFREE(lpszName);
            lpszName = lpszNewName;
        }
        else
        {
            SAFELOCALFREE(lpszNewName); // don't need newname after all
        }
    }
    
    //
    // If we are requested to HTML mail and we successfully built the html
    //
    if (!(fSendHTMLEmail &&
         BuildHTMLMessage(lpszEmailAddress, lpszName, lpszURL, &lpszSMTPMessage,
                          lpszTitle, lpszAbstract, lpszCharSet)))
    {
        //
        // If sending a simple notification or BuildHTMLMessage failed
        // force fSendHTMLEmail to false and build simple smtp message
        //
        fSendHTMLEmail = FALSE;
        BuildSMTPMessage(lpszName, lpszURL, &lpszSMTPMessage, lpszTitle, lpszAbstract);
    }

    //
    // Disable MAPI for now
    //
    //-----------------------------------------
    //BUG BUG: If this is enabled then wsprintf on message text should be changed to FormatMessage
    //         due to 1KB message limit.
    #if 0
    
    //
    // First try and load a full mapi implementation (exchange or outlook)
    //
    HMODULE hmodMail = LoadNormalMapi();
    if (hmodMail != NULL)
    {
        //
        // Get mapi function entry points
        //
        LPMAPISENDMAIL pfnSendMail;
        LPMAPILOGON pfnLogon;
        MapiMessage   message;
        MapiRecipDesc recipient;

        pfnSendMail = (LPMAPISENDMAIL)GetProcAddress(hmodMail, "MAPISendMail");
        pfnLogon    = (LPMAPILOGON)   GetProcAddress(hmodMail, "MAPILogon");
        if (pfnSendMail != NULL && pfnLogon != NULL)
        {
            //
            // Logon to mapi provider
            //
            LHANDLE hSession = 0;
            LPSTR lpszProfileName = NULL;  // for now logon on with NULL
            LPSTR lpszPassword = NULL;     // credentials
            ULONG ul = pfnLogon(0, lpszProfileName, lpszPassword, 0, 0, &hSession);
            if (ul != SUCCESS_SUCCESS)
            {
                DBG_OUTPUT_MAPI_ERROR(ul);
                //
                // Fall through to try other mail delivery methods
                //
            }
            else
            {
                TCHAR szSubject[INTERNET_MAX_URL_LENGTH];

                //
                // Fill in the text, subject line and recipient in mapi message
                //
                BuildMAPIMessage(lpszName, lpszURL, lpszEmailAddress, 
                                 &message, &recipient,
                                 szSubject, lpszSMTPMessage, szTitle, szAbstract);

                //
                // Actually send the message via MAPI with no UI
                //
                ul = pfnSendMail(0, 0, &message, 0, 0);
                if (ul != SUCCESS_SUCCESS)
                {
                    DBG_OUTPUT_MAPI_ERROR(ul);
                }
                else
                {
                    FreeLibrary(hmodMail);
                    return S_OK;
                }
            }
        }
        FreeLibrary(hmodMail);
    }
    #endif

    //
    // Send message to given address and from given address
    //
    if (lpszSMTPMessage)
    {
        b = SMTPSendMessage(lpszSMTPServer,  lpszEmailAddress, 
                            lpszEmailAddress, lpszSMTPMessage);

        MemFree(lpszSMTPMessage);

    }
    else
    {
        b = FALSE;
    }

    if (b)
        return S_OK;

    return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////
//
// Helper function to send email
//
//////////////////////////////////////////////////////////////////////////
HRESULT SendEmailFromItem(ISubscriptionItem *pItem)
{
    HRESULT hr = E_FAIL;
    LPSTR pszURL = NULL;
    LPSTR pszName = NULL;
    LPSTR pszTitle = NULL;
    LPSTR pszAbstract = NULL;
    LPSTR pszCharSet = NULL;
    
    // Get the Email URL to send.  Fall back to the download URL.
    ReadAnsiSTR(pItem, c_szPropEmailURL, &pszURL);
    if (!pszURL)
        ReadAnsiSTR(pItem, c_szPropURL, &pszURL);
    ASSERT(pszURL);

    // Get the friendly name.  Fall back to the download URL.
    ReadAnsiSTR(pItem, c_szPropName, &pszName);
    ASSERT(pszName);
    if (!pszName)
        ReadAnsiSTR(pItem, c_szPropURL, &pszName);

    // Get Email Title and Abstract if flag is set.
    DWORD dwEmailFlags = 0;
    ReadDWORD(pItem, c_szPropEmailFlags, &dwEmailFlags);
    if (dwEmailFlags & MAILAGENT_FLAG_CUSTOM_MSG)
    {
        ReadAnsiSTR(pItem, c_szPropEmailTitle, &pszTitle);
        ASSERT(pszTitle);
        ReadAnsiSTR(pItem, c_szPropEmailAbstract, &pszAbstract);
        ASSERT(pszAbstract);
    }

    //
    // Get the charset in the notification
    //
    ReadAnsiSTR(pItem, c_szPropCharSet, &pszCharSet);

    // Get Email address and SMTP server
    TCHAR tszBuf[MAX_PATH];
    CHAR szEmailAddress[MAX_PATH];
    CHAR szSMTPServer[MAX_PATH];
    
    ReadDefaultEmail(tszBuf, ARRAYSIZE(tszBuf));
    SHTCharToAnsi(tszBuf, szEmailAddress, ARRAYSIZE(szEmailAddress));
    ReadDefaultSMTPServer(tszBuf, ARRAYSIZE(tszBuf));
    SHTCharToAnsi(tszBuf, szSMTPServer, ARRAYSIZE(szSMTPServer));

    // Send the email
    if (pszURL && pszName)
    {
        //
        // Check if HTML Mail notification is enabled or disabled thru the registry
        //
        BOOL fSendHTMLEmail = FALSE;

        if (!ReadRegValue(HKEY_CURRENT_USER, c_szRegKey,
            TEXT("EnableHTMLMailNotification"),
            &fSendHTMLEmail, sizeof(DWORD)))
        {
            fSendHTMLEmail = TRUE; // default to on if not read from registry
        }

        // Now make sure our crawling mode supports HTML mail. We don't
        // want to send HTML if we're in check-for-change only.
        DWORD dwTemp = 0;
        ReadDWORD(pItem, c_szPropCrawlChangesOnly, &dwTemp);
        if (dwTemp != 0)
        {
            fSendHTMLEmail = FALSE;
        }
        // else, leave fSendHTMLEmail in its reg-based setting.

        hr = NotifyViaEMail(pszURL, szEmailAddress, szSMTPServer, 
                            pszName, pszTitle, pszAbstract, pszCharSet,
                            fSendHTMLEmail );
    }

    // Clean up.
    SAFELOCALFREE(pszURL);
    SAFELOCALFREE(pszName);
    SAFELOCALFREE(pszTitle);
    SAFELOCALFREE(pszAbstract);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\notfcvt.h ===
#ifndef _notfcvt_h
#define _notfcvt_h

typedef enum
{
     PT_NOT_INITIALIZED     = 0   //
    ,PT_NORMAL              = 1
    ,PT_WITHREPLY
    ,PT_REPORT_TO_SENDER
    ,PT_REPORT_TO_DEST
    ,PT_INVALID
    ,PT_GROUPLEADER
    ,PT_GROUPMEMBER

} PACKAGE_TYPE;

// package flags inidicate what the package is doing and is
typedef enum
{
     PF_READY            = 0x00000001
    ,PF_RUNNING          = 0x00000002
    ,PF_WAITING          = 0x00000004
    ,PF_REVOKED          = 0x00000008
    ,PF_SUSPENDED        = 0x00000010
    ,PF_ABORTED          = 0x00000020

    // the pacakge was delivered cross process
    ,PF_CROSSPROCESS     = 0x00010000
    ,PF_SCHEDULED        = 0x00020000
    ,PF_DELIVERED        = 0x00040000
    ,PF_DISPATCHED       = 0x00080000
    
    // idle flags
    ,PF_WAITING_USER_IDLE= 0x00100000
    
} _PACKAGE_FLAGS;
typedef DWORD PACKAGE_FLAGS;

typedef enum _tagPACKAGE_CONTENT_ENUM
{
     PC_EMPTY            = 0x00000000
    ,PC_CLSIDSENDER      = 0x00000001
    ,PC_CLSIDDEST        = 0x00000002
    ,PC_GROUPCOOKIE      = 0x00000004
    ,PC_RUNCOOKIE        = 0x00000008
    ,PC_TASKTRIGGER      = 0x00000010
    ,PC_TASKDATA         = 0x00000020
    ,PC_BASECOOKIE       = 0x00000040

    ,PC_CLSID            = 0x00000100
    ,PC_SINK             = 0x00000200
    ,PC_THREADID         = 0x00000400
} PACKAGE_CONTENT_ENUM;

typedef DWORD PACKAGE_CONTENT;

struct NOTIFICATIONITEMEXTRA
{
    DELIVERMODE             deliverMode;
    FILETIME                dateNextRun;        //  Ignore
    FILETIME                datePrevRun;
    NOTIFICATIONCOOKIE      RunningCookie;      //  Ignore
    NOTIFICATIONCOOKIE      BaseCookie;         //  Ignore
    PACKAGE_TYPE            PackageType;
    PACKAGE_FLAGS           PackageFlags;
    PACKAGE_CONTENT         PackageContent;
    DWORD                   dwThreadIdDestPort; //  Ignore
    HWND                    hWndDestPort;       //  Ignore
};

typedef struct _tagSaveSTATPROPMAP
{
    DWORD           cbSize;
    DWORD           cbStrLen;
    DWORD           dwFlags;
    DWORD           cbVarSizeExtra;
} SaveSTATPROPMAP;

#ifndef __msnotify_h__

EXTERN_C const GUID NOTFCOOKIE_SCHEDULE_GROUP_DAILY;
EXTERN_C const GUID NOTFCOOKIE_SCHEDULE_GROUP_WEEKLY;
EXTERN_C const GUID NOTFCOOKIE_SCHEDULE_GROUP_MONTHLY;
EXTERN_C const GUID NOTFCOOKIE_SCHEDULE_GROUP_MANUAL;

typedef GUID NOTIFICATIONTYPE;
typedef GUID NOTIFICATIONCOOKIE;
typedef DWORD NOTIFICATIONFLAGS;

typedef 
enum _tagDELIVERMODE
    {	DM_DELIVER_PREFERED	= 0x1,
	DM_DELIVER_DELAYED	= 0x2,
	DM_DELIVER_LAST_DELAYED	= 0x4,
	DM_ONLY_IF_RUNNING	= 0x20,
	DM_THROTTLE_MODE	= 0x80,
	DM_NEED_COMPLETIONREPORT	= 0x100,
	DM_NEED_PROGRESSREPORT	= 0x200,
	DM_DELIVER_DEFAULT_THREAD	= 0x400,
	DM_DELIVER_DEFAULT_PROCESS	= 0x800
    }	_DELIVERMODE;

typedef DWORD DELIVERMODE;

typedef struct  _tagTASKDATA
    {
    ULONG cbSize;
    DWORD dwReserved;
    DWORD dwTaskFlags;
    DWORD dwPriority;
    DWORD dwDuration;
    DWORD nParallelTasks;
    }	TASK_DATA;

typedef struct _tagTASKDATA __RPC_FAR *PTASK_DATA;

typedef void *LPNOTIFICATION;
typedef struct  _tagNotificationItem
    {
    ULONG cbSize;
    LPNOTIFICATION pNotification;
    NOTIFICATIONTYPE NotificationType;
    NOTIFICATIONFLAGS NotificationFlags;
    DELIVERMODE DeliverMode;
    NOTIFICATIONCOOKIE NotificationCookie;
    TASK_TRIGGER TaskTrigger;
    TASK_DATA TaskData;
    NOTIFICATIONCOOKIE groupCookie;
    CLSID clsidSender;
    CLSID clsidDest;
    FILETIME dateLastRun;
    FILETIME dateNextRun;
    DWORD dwNotificationState;
    }	NOTIFICATIONITEM;

typedef struct _tagNotificationItem __RPC_FAR *PNOTIFICATIONITEM;

typedef DWORD GROUPMODE;

#endif // __msnotify_h__

typedef enum
{
     GS_Created     = 0
    ,GS_Running     = 1
    ,GS_Initialized = 2


} GROUP_STATE;

typedef enum
{
     GT_NORMAL     = 0x00000001
    ,GT_STATIC     = 0x00000002

} _GROUP_TYPE;

typedef DWORD GROUP_TYPE;

typedef struct _tagSCHEDULEGROUPITEM
{
    ULONG               cbSize;
    ULONG               cElements;     // the # of packages in the group
    NOTIFICATIONCOOKIE  GroupCookie;
    GROUPMODE           grfGroupMode;
    GROUP_STATE         grpState;
    TASK_TRIGGER        TaskTrigger;
    TASK_DATA           TaskData;
    GROUP_TYPE          GroupType;
    GROUPINFO           GroupInfo;
} SCHEDULEGROUPITEM, *PSCHEDULEGROUPITEM;

HRESULT ConvertIE4Subscriptions();

#endif // _notfcvt_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\offsync.cpp ===
#include "private.h"
#include "offsync.h"
#include "throttle.h"
#include "helper.h"
#include "subsmgrp.h"

#include <mluisupp.h>

#define TF_THISMODULE TF_DELAGENT

COfflineSync::COfflineSync()
{
    // Maintain global count of objects
    DllAddRef();

    ASSERT(NULL == m_pThrottler);
    ASSERT(FALSE == m_fCookiesSpecified);

    // Initialize object
    m_cRef = 1;

    DBG("Creating COfflineSync object");
}

COfflineSync::~COfflineSync()
{
    DllRelease();

    Cleanup();

    DBG("Destroying COfflineSync object");

    if (m_pSyncCallback)
    {
        m_pSyncCallback->Release();
    }

    SAFERELEASE(m_pSubsMgr2);
}

void COfflineSync::Cleanup()
{
    if (NULL != m_pThrottler)
    {
        m_pThrottler->Unadvise(this);
        m_pThrottler->Release();
        m_pThrottler = NULL;
    }

    m_hWndParent = NULL;

    if (NULL != m_pSyncCallback)
    {
        m_pSyncCallback->SynchronizeCompleted(m_hrResult);
    }

    m_nItemsToRun = 0;

    SAFEDELETE(m_pItems);
}

//
// IUnknown members
//

STDMETHODIMP_(ULONG) COfflineSync::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) COfflineSync::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP COfflineSync::QueryInterface(REFIID riid, void ** ppv)
{

    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_ISyncMgrSynchronize == riid))
    {
        *ppv = (ISyncMgrSynchronize *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

//
// IOfflineSynchronize members
//
HRESULT COfflineSync::Initialize(DWORD dwReserved, DWORD dwSyncFlags,
                                   DWORD cbCookie, const BYTE *lpCookie)
{
    HRESULT hr = S_OK;

    if (SYNCMGRFLAG_INVOKE == (dwSyncFlags & SYNCMGRFLAG_EVENTMASK) )
    {
        ASSERT((0 == cbCookie) || (0 == cbCookie % sizeof(SUBSCRIPTIONCOOKIE)));

        if ((cbCookie != 0) &&
            ((0 != (cbCookie % sizeof(SUBSCRIPTIONCOOKIE))) || (NULL == lpCookie)))
        {
            return E_INVALIDARG;
        }

        if (cbCookie > 0)
        {
            hr = DupItems(cbCookie / sizeof(SUBSCRIPTIONCOOKIE), (SUBSCRIPTIONCOOKIE *)lpCookie);
            if (SUCCEEDED(hr))
            {
                m_fCookiesSpecified = TRUE;
            }
        }
    }

    m_dwSyncFlags = dwSyncFlags;

    return hr;
}

HRESULT COfflineSync::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{
    HRESULT hr;
    if (NULL == ppSyncMgrHandlerInfo)
    {
        return E_INVALIDARG;
    }

    *ppSyncMgrHandlerInfo = (SYNCMGRHANDLERINFO *)CoTaskMemAlloc(sizeof(SYNCMGRHANDLERINFO));

    if (NULL != *ppSyncMgrHandlerInfo)
    {
        (*ppSyncMgrHandlerInfo)->cbSize = sizeof(SYNCMGRHANDLERINFO);
        (*ppSyncMgrHandlerInfo)->hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_WEBCHECK));
        (*ppSyncMgrHandlerInfo)->SyncMgrHandlerFlags = 0; //SYNCMGRHANDLER_HASPROPERTIES

#ifdef UNICODE
        MLLoadStringW(IDS_SYNCMGR_NAME, 
                    (*ppSyncMgrHandlerInfo)->wszHandlerName, 
                    ARRAYSIZE((*ppSyncMgrHandlerInfo)->wszHandlerName));
#else
        CHAR szHandlerName[sizeof((*ppSyncMgrHandlerInfo)->wszHandlerName)];
        MLLoadStringA(IDS_SYNCMGR_NAME, szHandlerName, sizeof(szHandlerName));
        MultiByteToWideChar(CP_ACP, 0, szHandlerName, -1, 
                    (*ppSyncMgrHandlerInfo)->wszHandlerName, 
                    ARRAYSIZE((*ppSyncMgrHandlerInfo)->wszHandlerName));
#endif
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT COfflineSync::EnumSyncMgrItems(ISyncMgrEnumItems **ppSyncMgrEnumItems)
{
    HRESULT hr;
    
    if (NULL == ppSyncMgrEnumItems)
    {
        return E_INVALIDARG;
    }

    hr = GetSubsMgr2();

    if (SUCCEEDED(hr))
    {   
        COfflineEnum *pEnum = new COfflineEnum();

        if (NULL != pEnum)
        {
            ASSERT(((TRUE == m_fCookiesSpecified) && ((m_nItemsToRun > 0) && (NULL != m_pItems))) ||
                   ((FALSE == m_fCookiesSpecified) && ((m_nItemsToRun == 0) && (NULL == m_pItems))))

            hr = pEnum->Init(m_pSubsMgr2, m_nItemsToRun, m_pItems, ppSyncMgrEnumItems, m_dwSyncFlags);
            pEnum->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT COfflineSync::GetItemObject(REFSYNCMGRITEMID ItemID, REFIID riid, void **ppv)
{
    return E_NOTIMPL;
}

HRESULT COfflineSync::ShowProperties(HWND hWndParent, REFSYNCMGRITEMID ItemID)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp;
    ISubscriptionItem *pSubsItem;

    hrTmp = SubscriptionItemFromCookie(FALSE, &ItemID, &pSubsItem);

    if (SUCCEEDED(hrTmp))
    {
        BSTR bstrURL;

        hrTmp = ReadBSTR(pSubsItem, c_szPropURL, &bstrURL);

        if (SUCCEEDED(hrTmp))
        {
            ISubscriptionMgr2 *pSubsMgr2;

            hrTmp = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                  IID_ISubscriptionMgr2, (void **)&pSubsMgr2);

            if (SUCCEEDED(hrTmp))
            {
                BOOL bIsSubscribed;
                
                hrTmp = pSubsMgr2->ShowSubscriptionProperties(bstrURL, hWndParent);

                if (FAILED(pSubsMgr2->IsSubscribed(bstrURL, &bIsSubscribed)) || !bIsSubscribed)
                {
                    hr = S_SYNCMGR_ITEMDELETED;
                }

                pSubsMgr2->Release();
            }

            SysFreeString(bstrURL);
        }
        
        pSubsItem->Release();
    }

    if (NULL != m_pSyncCallback)
    {
        m_pSyncCallback->ShowPropertiesCompleted(hr);
    }

    return hr;
}

HRESULT COfflineSync::SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack)
{
    SAFERELEASE(m_pSyncCallback);
    m_pSyncCallback = lpCallBack;

    if (m_pSyncCallback)
    {
        m_pSyncCallback->AddRef();
    }

    return S_OK;
}

HRESULT COfflineSync::PrepareForSync(ULONG cbNumItems, SYNCMGRITEMID *pItemIDs,
                                     HWND hWndParent, DWORD dwReserved)
{
    HRESULT hr;

    DBG("PrepareForSync");

    if ((0 == cbNumItems) ||
        (NULL == pItemIDs))
    {
        hr = E_INVALIDARG;
    }

    if (NULL == m_pSyncCallback)
    {
        return E_UNEXPECTED;
    }

    hr = DupItems(cbNumItems, pItemIDs);

    m_pSyncCallback->PrepareForSyncCompleted(hr);
    
    return hr;
}

HRESULT COfflineSync::Synchronize(HWND hWndParent)
{
    HRESULT hr;

    m_hrResult = E_FAIL;
    m_hWndParent = hWndParent;

    hr = CThrottler::GetThrottler(&m_pThrottler);
    if (SUCCEEDED(hr))
    {
        ASSERT(NULL != m_pThrottler);

        hr = m_pThrottler->Advise(this);

        if (SUCCEEDED(hr))
        {
            hr = m_pThrottler->RunCookies(m_nItemsToRun, m_pItems, m_dwSyncFlags);
        }
        //  ************************************************************************
        //  Don't access m_pThrottler after this without checking for NULL since
        //  we could have released it during the call to RunCookies!
        //  ************************************************************************
    }

    if (FAILED(hr))
    {
        Cleanup();
    }
    return hr;
}

HRESULT COfflineSync::SetItemStatus(REFSYNCMGRITEMID ItemID, DWORD dwSyncMgrStatus)
{
    HRESULT hr = S_OK;
    
    if (NULL != m_pThrottler)
    {
        switch (dwSyncMgrStatus)
        {
            case SYNCMGRSTATUS_SKIPPED:
                hr = m_pThrottler->AbortItems(1, &ItemID);
                break;
                
            case SYNCMGRSTATUS_STOPPED:
                hr = m_pThrottler->AbortItems(m_nItemsToRun, m_pItems);
                break;
        }
    }
    else
    {
        ULONG i;
        
        //  This means we are getting called before Synchronize is called
        switch (dwSyncMgrStatus)
        {
            case SYNCMGRSTATUS_SKIPPED:
                for (i = 0; i < m_nItemsToRun; i++)
                {
                    if (ItemID == m_pItems[i])
                    {
                        m_pItems[i] = GUID_NULL;
                    }
                }
                break;
                
            case SYNCMGRSTATUS_STOPPED:
                m_nItemsToRun = 0;
                break;
        }
    }

    return hr;
}

HRESULT COfflineSync::ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID)
{
    return E_NOTIMPL;
}

HRESULT COfflineSync::UpdateBegin(
    const SUBSCRIPTIONCOOKIE *pSubscriptionCookie)
{
    UpdateProgress(pSubscriptionCookie, -1, -1, -1, S_OK, NULL);
    return S_OK;
}

HRESULT COfflineSync::UpdateProgress(
    const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
    long lSizeDownloaded,
    long lProgressCurrent,
    long lProgressMax,
    HRESULT hrStatus,
    LPCWSTR wszStatus)
{
    HRESULT hr;

    ASSERT(NULL != m_pSyncCallback);
    ASSERT(NULL != m_pThrottler);

    if ((FindCookie(pSubscriptionCookie) != -1) &&
        (NULL != m_pSyncCallback))
    {
        int iProgValue;

        switch (hrStatus)
        {
            case WC_INTERNAL_S_PAUSED:
                iProgValue = SYNCMGRSTATUS_PAUSED;
                break;

            case WC_INTERNAL_S_RESUMING:
                iProgValue = SYNCMGRSTATUS_RESUMING;
                break;

            case WC_INTERNAL_S_PENDING:
                iProgValue = SYNCMGRSTATUS_PENDING;
                break;

            default:
                iProgValue = SYNCMGRSTATUS_UPDATING;
                break;
        }
        
        CallSyncMgrProgress(pSubscriptionCookie, wszStatus, iProgValue,
                            lProgressCurrent, lProgressMax);
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT COfflineSync::UpdateEnd(
    const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
    long lSizeDownloaded,
    HRESULT hrResult,
    LPCWSTR wszResult)
{
    HRESULT hr;

    int index = FindCookie(pSubscriptionCookie);
    if (index != -1)
    {
        DWORD dwStatus;

        m_pItems[index] = CLSID_NULL;   //  Forget about it
        m_nItemsCompleted++;
        
        if (SUCCEEDED(hrResult))
        {
            dwStatus = SYNCMGRSTATUS_SUCCEEDED;
        }
        else if (E_ABORT == hrResult)
        {
            dwStatus = SYNCMGRSTATUS_SKIPPED;
        }
        else
        {
            dwStatus = SYNCMGRSTATUS_FAILED;
        }

        CallSyncMgrProgress(pSubscriptionCookie, wszResult, dwStatus, 100, 100);

        AreWeDoneYet();
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

STDMETHODIMP COfflineSync::ReportError(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        HRESULT hrError, 
        LPCWSTR wszError)
{
    HRESULT hr;
    
    if ((FindCookie(pSubscriptionCookie) != -1) &&
        (NULL != m_pSyncCallback))
    {
        DWORD dwErrorLevel; 

        switch (hrError)
        {
            case E_ABORT:
                dwErrorLevel = SYNCMGRLOGLEVEL_INFORMATION;
                break;

            case INET_E_AGENT_MAX_SIZE_EXCEEDED:
            case INET_E_SCHEDULED_UPDATES_DISABLED:
            case INET_E_SCHEDULED_UPDATES_RESTRICTED:
            case INET_E_SCHEDULED_UPDATE_INTERVAL:
            case INET_E_SCHEDULED_EXCLUDE_RANGE:
            case INET_E_AGENT_WARNING:
                dwErrorLevel = SYNCMGRLOGLEVEL_WARNING;
                break;

            default:
                dwErrorLevel = FAILED(hrError) ? SYNCMGRLOGLEVEL_ERROR : SYNCMGRLOGLEVEL_INFORMATION;
                break;
        }

        SYNCMGRLOGERRORINFO errInfo;

        errInfo.cbSize = sizeof(SYNCMGRLOGERRORINFO);
        errInfo.mask = SYNCMGRLOGERROR_ITEMID;
        errInfo.ItemID = *pSubscriptionCookie;

        m_pSyncCallback->LogError(dwErrorLevel, wszError, &errInfo);
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT COfflineSync::CallSyncMgrProgress(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
    const WCHAR *lpcStatusText, DWORD dwStatusType, INT iProgValue, INT iMaxValue)
{
    HRESULT hr = S_OK;
    SYNCMGRPROGRESSITEM smpi;

    ASSERT(NULL != m_pSyncCallback);

    smpi.cbSize = sizeof(SYNCMGRPROGRESSITEM);
    smpi.mask = 0;
  
    if (NULL != lpcStatusText)
    {
        smpi.mask |= SYNCMGRPROGRESSITEM_STATUSTEXT;
        smpi.lpcStatusText = lpcStatusText;
    }

    if ((DWORD)(-1) != dwStatusType)
    {
        smpi.mask |= SYNCMGRPROGRESSITEM_STATUSTYPE;
        smpi.dwStatusType = dwStatusType;
    }

    if (iProgValue >= 0)
    {
        smpi.mask |= SYNCMGRPROGRESSITEM_PROGVALUE;
        smpi.iProgValue = iProgValue;
    }

    if (iMaxValue >= 0)
    {
        smpi.mask |= SYNCMGRPROGRESSITEM_MAXVALUE;
        smpi.iMaxValue = iMaxValue;
    }

    //  We still call progress even if smpi.mask is 0 just in case we should
    //  respond to a cancel.

    HRESULT hrProgress = m_pSyncCallback->Progress(*pSubscriptionCookie, &smpi);
    
    switch(hrProgress)
    {
        case S_SYNCMGR_CANCELITEM:
            m_pThrottler->AbortItems(1, pSubscriptionCookie);
            break;
            
        case S_SYNCMGR_CANCELALL:
            m_pThrottler->AbortAll();
            break;
    }

    return hr;
}

HRESULT COfflineSync::UpdateSyncMgrStatus(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
    LPCWSTR wszStatusMsg, DWORD dwStatus)
{
    HRESULT hr;

    if ((FindCookie(pSubscriptionCookie) != -1) &&
        (NULL != m_pSyncCallback))
    {
        CallSyncMgrProgress(pSubscriptionCookie, wszStatusMsg, dwStatus, -1, -1);

        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}

HRESULT COfflineSync::DupItems(ULONG cbNumItems, SUBSCRIPTIONCOOKIE *pItemIDs)
{
    HRESULT hr;
    
    ASSERT(0 != cbNumItems);
    ASSERT(NULL != pItemIDs);
    ASSERT((0 == m_nItemsToRun) || (TRUE == m_fCookiesSpecified));

    if (NULL != m_pItems)
    {
        delete [] m_pItems;
    }

    m_pItems = new SUBSCRIPTIONCOOKIE[cbNumItems];

    if (NULL != m_pItems)
    {
        memcpy(m_pItems, pItemIDs, cbNumItems * sizeof(SUBSCRIPTIONCOOKIE));
        m_nItemsToRun = cbNumItems;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

BOOL COfflineSync::AreWeDoneYet()
{
    BOOL rc;

    if (m_nItemsCompleted != m_nItemsToRun)
    {
        rc = FALSE;
    }
    else
    {
        Cleanup();
        rc = TRUE;
    }

    return rc;
}

HRESULT COfflineSync::GetSubsMgr2()
{
    HRESULT hr = S_FALSE;

    if (NULL == m_pSubsMgr2)
    {
        hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                IID_ISubscriptionMgr2, (void**)&m_pSubsMgr2);

        if (FAILED(hr))
        {
            DBG_WARN("Failed to allocate subscription store (aborting)");
        }
    }

    return hr;
}

//  returns index into m_pItems on success, -1 on failure
int COfflineSync::FindCookie(const SUBSCRIPTIONCOOKIE *pCookie)
{
    int index = -1;

    if (NULL != m_pItems)
    {
        for (ULONG i = 0; i < m_nItemsToRun; i++)
        {
            if (m_pItems[i] == *pCookie)
            {
                index = i;
                break;
            }
        }
    }

    return index;
}

COfflineEnum::COfflineEnum()
{
    ASSERT(NULL == m_pItems);
    ASSERT(0 == m_iNumItems);

    // Maintain global count of objects
    DllAddRef();

    // Initialize object
    m_cRef = 1;
}

COfflineEnum::~COfflineEnum()
{
    DllRelease();

    SAFELOCALFREE(m_pItems);
}

HRESULT COfflineEnum::LoadItem(ISubscriptionMgr2 *pSubsMgr2, 
    const SUBSCRIPTIONCOOKIE *pCookie, SYNCMGRITEM *pItem, DWORD dwItemState)
{
    HRESULT hr;
    ISubscriptionItem *pSubItem;

    ASSERT(NULL != pSubsMgr2);

    hr = pSubsMgr2->GetItemFromCookie(pCookie, &pSubItem);
    if (SUCCEEDED(hr))
    {
        BSTR bstrName;
       
        pItem->cbSize = sizeof(SYNCMGRITEM);
        pItem->dwFlags = SYNCMGRITEM_HASPROPERTIES;
        pItem->ItemID = *pCookie;
        pItem->dwItemState = dwItemState;

        DATE dt;
        
        if (SUCCEEDED(ReadDATE(pSubItem, c_szPropCompletionTime, &dt)))
        {
            FILETIME ft;
            pItem->dwFlags |= SYNCMGRITEM_LASTUPDATETIME;

            VariantTimeToFileTime(dt, ft);
            LocalFileTimeToFileTime(&ft, &pItem->ftLastUpdate);
        }

        ReadBSTR(pSubItem, c_szPropName, &bstrName);

        if (NULL != bstrName)
        {
            StrCpyNW(pItem->wszItemName, bstrName, ARRAYSIZE(pItem->wszItemName));

            SysFreeString(bstrName);
        }
        else
        {
            ASSERT(L'\0' == pItem->wszItemName[0]);
        }

        pItem->hIcon = LoadItemIcon(pSubItem, FALSE);

        pSubItem->Release();
    }

    return hr;
}

HRESULT COfflineEnum::Init(ISubscriptionMgr2 *pSubsMgr2, ULONG nItems, 
    SUBSCRIPTIONCOOKIE *pInitCookies, ISyncMgrEnumItems **ppenum, DWORD dwSyncFlags)
{
    HRESULT hr = E_FAIL;
    DWORD dwCheckState;

    ASSERT(NULL != ppenum);

    if ((NULL == pSubsMgr2) || 
        (NULL == ppenum) ||
        ((nItems > 0) && (pInitCookies == NULL)))
    {
        return E_UNEXPECTED;
    }

    switch (dwSyncFlags & SYNCMGRFLAG_EVENTMASK)
    {
        case SYNCMGRFLAG_CONNECT:           // Sync was invoked by a network connect
        case SYNCMGRFLAG_PENDINGDISCONNECT: // Sync was invoked by a pending network disconnect
        case SYNCMGRFLAG_MANUAL:            // Sync was invoked manually
        case SYNCMGRFLAG_IDLE:              // Sync was programmatically invokd
        case SYNCMGRFLAG_INVOKE:            // Sync was programmatically invokd
        case SYNCMGRFLAG_SCHEDULED:         // Sync was invoked by a scheduled update
            dwCheckState = SYNCMGRITEMSTATE_CHECKED;
            break;
            
        default:
            dwCheckState = SYNCMGRITEMSTATE_UNCHECKED;
            break;
    }

    // Enumerate cookies
    m_iEnumPtr = 0;

    if (0 == nItems)
    {
        IEnumSubscription *pEnumSubscriptions;

        hr = pSubsMgr2->EnumSubscriptions(0, &pEnumSubscriptions);

        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pEnumSubscriptions);

            pEnumSubscriptions->GetCount(&m_iNumItems);

            SUBSCRIPTIONCOOKIE *pCookies = (SUBSCRIPTIONCOOKIE *)MemAlloc(LMEM_FIXED, 
                m_iNumItems * sizeof(SUBSCRIPTIONCOOKIE));

            m_pItems = (SYNCMGRITEM *)MemAlloc(LMEM_FIXED, m_iNumItems * sizeof(SYNCMGRITEM));

            if ((NULL != m_pItems) && (NULL != pCookies))
            {
                hr = pEnumSubscriptions->Next(m_iNumItems, pCookies, &m_iNumItems);

                SYNCMGRITEM *pItem = m_pItems;

                for (ULONG i = 0; i < m_iNumItems; i++, pItem++)
                {
                    hr = LoadItem(pSubsMgr2, &pCookies[i], pItem, 
                                  dwCheckState);

                    if (FAILED(hr))
                    {
                        break;
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            SAFELOCALFREE(pCookies);

            pEnumSubscriptions->Release();
        }
    }
    else
    {
        m_pItems = (SYNCMGRITEM *)MemAlloc(LMEM_FIXED, nItems * sizeof(SYNCMGRITEM));
        if (NULL != m_pItems)
        {
            SYNCMGRITEM *pItem = m_pItems;
            SUBSCRIPTIONCOOKIE *pCurCookie = pInitCookies;

            m_iNumItems = nItems;

            for (ULONG i = 0; i < m_iNumItems; i++, pCurCookie++, pItem++)
            {
                hr = LoadItem(pSubsMgr2, pCurCookie, pItem, dwCheckState);
                if (FAILED(hr))
                {
                    break;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
   }

    if (SUCCEEDED(hr))
    {
        //  If we were invoked programatically, then tell syncmgr to leave
        //  item preferences alone.
        hr = (nItems == 0) ? S_OK : S_OK; // TODO: S_SYNCMGR_MISSINGITEMS;
        *ppenum = this;
        AddRef();
    }

    return hr;
}

//
// IUnknown members
//

STDMETHODIMP_(ULONG) COfflineEnum::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) COfflineEnum::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP COfflineEnum::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_ISyncMgrEnumItems == riid))
    {
        *ppv = (ISyncMgrEnumItems *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

// IEnumOfflineItems members
STDMETHODIMP COfflineEnum::Next(ULONG celt, LPSYNCMGRITEM rgelt, ULONG *pceltFetched)
{
    if ((0 == celt) || 
        ((celt > 1) && (NULL == pceltFetched)) ||
        (NULL == rgelt))
    {
        return E_INVALIDARG;
    }

    if (!m_pItems)
    {
        return E_FAIL;
    }

    *pceltFetched = 0;
    ULONG ul;

    for (ul=0; (ul<celt) && (m_iEnumPtr<m_iNumItems); m_iEnumPtr++)
    {
        *rgelt = m_pItems[m_iEnumPtr];
        rgelt ++; ul++;
    }

    *pceltFetched = ul;

    return (ul == celt) ? S_OK : S_FALSE;
}

STDMETHODIMP COfflineEnum::Skip(ULONG celt)
{
    m_iEnumPtr += celt;
    if (m_iEnumPtr > m_iNumItems)
    {
        m_iEnumPtr = m_iNumItems;
        return S_FALSE;
    }
    return S_OK;
}

STDMETHODIMP COfflineEnum::Reset(void)
{
    m_iEnumPtr = 0;
    return S_OK;
}

STDMETHODIMP COfflineEnum::Clone(ISyncMgrEnumItems **ppenum)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\offsync.h ===
//
// OneStop Offline Synch handler
//

#ifndef _OFFSYNC_H
#define _OFFSYNC_H

class CThrottler;

class COfflineSync : public ISyncMgrSynchronize,
                     public ISubscriptionAgentEvents
{
private:
    ~COfflineSync();
    ULONG           m_cRef;

    ISyncMgrSynchronizeCallback *m_pSyncCallback;
    ISubscriptionMgr2           *m_pSubsMgr2;

    DWORD               m_dwSyncFlags;
    HWND                m_hWndParent;
    CThrottler          *m_pThrottler;
    HRESULT             m_hrResult;

    ULONG               m_nItemsToRun;
    ULONG               m_nItemsCompleted;

    BOOL                m_fCookiesSpecified;
    
    SUBSCRIPTIONCOOKIE  *m_pItems;

    void Cleanup();
    BOOL AreWeDoneYet();
    HRESULT GetSubsMgr2();
    int FindCookie(const SUBSCRIPTIONCOOKIE *pCookie);
    HRESULT DupItems(ULONG cbNumItems, SUBSCRIPTIONCOOKIE *pItemIDs);

    HRESULT CallSyncMgrProgress(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        const WCHAR *lpcStatusText, DWORD dwStatusType, INT iProgValue, INT iMaxValue);

public:
    COfflineSync();

    HWND GetParentWindow() { return m_hWndParent; }

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ISyncMgrSynchronize members
    STDMETHODIMP Initialize( 
        /* [in] */ DWORD dwReserved,
        /* [in] */ DWORD dwSyncMgrFlags,
        /* [in] */ DWORD cbCookie,
        /* [in] */ const BYTE *lpCookie);
    
    STDMETHODIMP GetHandlerInfo( 
        /* [out] */ LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
    
    STDMETHODIMP EnumSyncMgrItems( 
        /* [out] */ ISyncMgrEnumItems **ppSyncMgrEnumItems);
    
    STDMETHODIMP GetItemObject( 
        /* [in] */ REFSYNCMGRITEMID ItemID,
        /* [in] */ REFIID riid,
        /* [out] */ void **ppv);
    
    STDMETHODIMP ShowProperties( 
        /* [in] */ HWND hWndParent,
        /* [in] */ REFSYNCMGRITEMID ItemID);
    
    STDMETHODIMP SetProgressCallback( 
        /* [in] */ ISyncMgrSynchronizeCallback *lpCallBack);
    
    STDMETHODIMP PrepareForSync( 
        /* [in] */ ULONG cbNumItems,
        /* [in] */ SYNCMGRITEMID *pItemIDs,
        /* [in] */ HWND hWndParent,
        /* [in] */ DWORD dwReserved);
    
    STDMETHODIMP Synchronize( 
        /* [in] */ HWND hWndParent);
    
    STDMETHODIMP SetItemStatus( 
        /* [in] */ REFSYNCMGRITEMID ItemID,
        /* [in] */ DWORD dwSyncMgrStatus);
    
    STDMETHODIMP ShowError( 
        /* [in]  */ HWND hWndParent,
        /* [in]  */ REFSYNCMGRERRORID ErrorID);

    // ISubscriptionAgentEvents members
    STDMETHODIMP UpdateBegin(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie);

    STDMETHODIMP UpdateProgress(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        long lSizeDownloaded,
        long lProgressCurrent,
        long lProgressMax,
        HRESULT hrStatus,
        LPCWSTR wszStatus);

    STDMETHODIMP UpdateEnd(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        long lSizeDownloaded,
        HRESULT hrResult,
        LPCWSTR wszResult);

    STDMETHODIMP ReportError(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        HRESULT hrError, 
        LPCWSTR wszError);

    HRESULT UpdateSyncMgrStatus(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        LPCWSTR wszStatusMsg, DWORD dwStatus);

};

class COfflineEnum : public ISyncMgrEnumItems
{
private:
    ~COfflineEnum();
    ULONG           m_cRef;

    SYNCMGRITEM    *m_pItems;
    ULONG           m_iNumItems;
    ULONG           m_iEnumPtr;

    HRESULT LoadItem(ISubscriptionMgr2 *pSubsMgr2, 
        const SUBSCRIPTIONCOOKIE *pCookie, SYNCMGRITEM *pItem, DWORD dwItemState);

public:
    COfflineEnum();

    HRESULT Init(ISubscriptionMgr2 *pSubsMgr2, ULONG nItems, 
            SUBSCRIPTIONCOOKIE *pInitCookies, ISyncMgrEnumItems **ppenum, DWORD dwSyncFlags);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumOfflineItems members
    STDMETHODIMP Next( 
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ LPSYNCMGRITEM rgelt,
        /* [out] */ ULONG *pceltFetched);
    
    STDMETHODIMP Skip( 
        /* [in] */ ULONG celt);
    
    STDMETHODIMP Reset( void);
    
    STDMETHODIMP Clone( 
        /* [out] */ ISyncMgrEnumItems **ppenum);
};

#include "throttle.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\offl_cpp.h ===
#ifndef OFFLINE_CPP_H
#define OFFLINE_CPP_H

#ifdef __cplusplus

//  #include <debug.h>
//  #include <crtfree.h>

// Forward class declarations
class COfflineFolderEnum;
class COfflineFolder;
class COfflineObjectItem;
class COfflineDropTarget;

#define PROP_WEBCRAWL_SIZE      0x00000001
#define PROP_WEBCRAWL_FLAGS     0x00000002
#define PROP_WEBCRAWL_LEVEL     0x00000004
#define PROP_WEBCRAWL_ACTUALSIZE    0x00000008
#define PROP_WEBCRAWL_URL       0x00000010
#define PROP_WEBCRAWL_NAME      0x00000020
#define PROP_WEBCRAWL_EMAILNOTF 0x00000040
#define PROP_WEBCRAWL_PSWD      0x00000080
#define PROP_WEBCRAWL_UNAME     0x00000100
#define PROP_WEBCRAWL_DESKTOP   0x00000200
#define PROP_WEBCRAWL_RESCH     0x00000400
#define PROP_WEBCRAWL_COOKIE    0x00000800
#define PROP_WEBCRAWL_LAST      0x00001000
#define PROP_WEBCRAWL_STATUS    0x00002000
#define PROP_WEBCRAWL_CHANNEL   0x00004000
#define PROP_WEBCRAWL_PRIORITY  0x00008000
#define PROP_WEBCRAWL_GLEAM     0x00010000
#define PROP_WEBCRAWL_CHANGESONLY   0x00020000
#define PROP_WEBCRAWL_CHANNELFLAGS  0x00040000
#define PROP_WEBCRAWL_ALL       0x0007FFFF
#define PROP_WEBCRAWL_EXTERNAL  PROP_WEBCRAWL_ACTUALSIZE | PROP_WEBCRAWL_URL | \
                                PROP_WEBCRAWL_NAME | PROP_WEBCRAWL_EMAILNOTF | \
                                PROP_WEBCRAWL_RESCH | PROP_WEBCRAWL_LAST | \
                                PROP_WEBCRAWL_DESKTOP | PROP_WEBCRAWL_CHANNEL |\
                                PROP_WEBCRAWL_STATUS | PROP_WEBCRAWL_PRIORITY

#define PROP_GENERAL_MASK       PROP_WEBCRAWL_PSWD | PROP_WEBCRAWL_UNAME
#define PROP_RECEIVING_MASK     PROP_WEBCRAWL_SIZE | PROP_WEBCRAWL_FLAGS | \
                                PROP_WEBCRAWL_CHANGESONLY | PROP_WEBCRAWL_EMAILNOTF \
                                PROP_WEBCRAWL_PRIORITY | PROP_WEBCRAWL_LEVEL | \
                                PROP_WEBCRAWL_CHANNELFLAGS
#define PROP_SCHEDULE_MASK      PROP_WEBCRAWL_CHANNELFLAGS | PROP_WEBCRAWL_RESCH

// Forwawd declarations for create instance functions 
HRESULT COfflineObjectItem_CreateInstance(COfflineFolder *pOOFolder, UINT cidl, LPCITEMIDLIST *ppidl, REFIID riid, void **ppvOut);
HRESULT DoDeleteSubscription(POOEntry);
HRESULT FindURLProps(LPCTSTR, PROPVARIANT *);

SUBSCRIPTIONSCHEDULE GetGroup(BOOL bDesktop, const CLSID& clsidDest, 
                              DWORD fChannelFlags, const NOTIFICATIONCOOKIE& groupCookie);
inline SUBSCRIPTIONSCHEDULE GetGroup(POOEBuf pBuf)
{
    ASSERT(pBuf);
    return GetGroup(pBuf->bDesktop, pBuf->clsidDest, pBuf->fChannelFlags, pBuf->groupCookie);
}
inline SUBSCRIPTIONSCHEDULE GetGroup(POOEntry pooe)
{
    ASSERT(pooe);
    return GetGroup(pooe->bDesktop, pooe->clsidDest, pooe->fChannelFlags, pooe->groupCookie);
}

SUBSCRIPTIONTYPE GetItemCategory(BOOL bDesktop, const CLSID& clsidDest);
inline SUBSCRIPTIONTYPE GetItemCategory(POOEBuf pBuf)
{
    ASSERT(pBuf);
    return GetItemCategory(pBuf->bDesktop, pBuf->clsidDest);
}

inline SUBSCRIPTIONTYPE GetItemCategory(POOEntry pEntry)
{
    ASSERT(pEntry);
    return GetItemCategory(pEntry->bDesktop, pEntry->clsidDest);
}

//////////////////////////////////////////////////////////////////////////////
//
// COfflineFolderEnum Object
//
//////////////////////////////////////////////////////////////////////////////

class COfflineFolderEnum : public IEnumIDList
{
public:
    COfflineFolderEnum(DWORD grfFlags);
    
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList Methods 
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(LPENUMIDLIST *ppenum);

    // Helper functions

    static LPMYPIDL NewPidl(DWORD);
    static void FreePidl(LPMYPIDL);
    static void EnsureMalloc();
    static IMalloc *s_pMalloc;

    HRESULT Initialize(COfflineFolder *pFolder);

protected:
    ~COfflineFolderEnum();

    UINT                m_cRef;      // ref count
    UINT                m_grfFlags;  // enumeration flags 

private:
    ULONG               m_nCount;
    ULONG               m_nCurrent;
    SUBSCRIPTIONCOOKIE  *m_pCookies;
    COfflineFolder      *m_pFolder;
};

//////////////////////////////////////////////////////////////////////////////
//
// COfflineFolder Object
//
//////////////////////////////////////////////////////////////////////////////

class COfflineFolder : public IShellFolder, 
                       public IPersistFolder2,
                       public IContextMenu
{
    // COfflineFolder interfaces
    friend COfflineObjectItem;
    friend COfflineDropTarget;
    friend COfflineFolderEnum;
    friend HRESULT OfflineFolderView_CreateInstance(COfflineFolder *pOOFolder, LPCITEMIDLIST pidl, void **ppvOut);
    friend HRESULT OfflineFolderView_DidDragDrop(HWND, IDataObject *pdo, DWORD dwEffect);
    friend LPMYPIDL ScheduleDefault(LPCTSTR, LPCTSTR, COfflineFolder *);
        
public:
    COfflineFolder(void);

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
   
    // IShellFolder methods
    STDMETHODIMP ParseDisplayName(HWND hwndOwner, LPBC pbcReserved,
            LPOLESTR lpszDisplayName, ULONG *pchEaten,
            LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwndOwner, DWORD grfFlags,
            LPENUMIDLIST *ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
            REFIID riid, void **ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
            REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwndOwner, REFIID riid, void **ppvOut);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
            ULONG * rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
            REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
            LPCOLESTR lpszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IPersist Methods 
    STDMETHODIMP GetClassID(LPCLSID lpClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IContextMenu Methods -- This handles the background context menus
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                                  UINT idCmdLast, UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType,UINT *pwReserved,
                                  LPSTR pszName, UINT cchMax);

protected:
    ~COfflineFolder();

    UINT            _cRef;
    LPITEMIDLIST    _pidl;      //  Clone;
#define VIEWMODE_WEBCRAWLONLY   1
    UINT            viewMode;

};


class COfflineDetails : public IShellDetails
{
public:
    COfflineDetails(HWND hwndOwner);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellDetails Methods
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetails);
    STDMETHODIMP ColumnClick(UINT iColumn);

private:
    ~COfflineDetails() {}

    HWND    m_hwndOwner;
    ULONG   m_cRef;
};

////////////////////////////////////////////////////////////////////////////
//
// COfflineObjectItem Object
//
////////////////////////////////////////////////////////////////////////////

class COfflineObjectItem : public IContextMenu, 
                    #ifdef UNICODE
                           public IExtractIconA,
                    #endif
                           public IExtractIcon,
                           public IDataObject,
                           public IQueryInfo
{
    // COfflineObjectItem interfaces
    friend HRESULT OfflineFolderView_DidDragDrop(HWND, IDataObject *pdo, DWORD dwEffect);

public:
    COfflineObjectItem();
    HRESULT Initialize(COfflineFolder *pOOFolder, UINT cidl, LPCITEMIDLIST *ppidl);

    // IUnknown Methods
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID,void **);
    
    // IContextMenu Methods
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                                  UINT idCmdLast, UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType,UINT *pwReserved,
                                  LPSTR pszName, UINT cchMax);

    // IDataObject Methods...
    STDMETHODIMP GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
    STDMETHODIMP GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut);
    STDMETHODIMP SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
    STDMETHODIMP DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink,
                            LPDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppEnum);
    
    // IDataObject helper functions
    HRESULT _CreateHDROP(STGMEDIUM *pmedium);
    HRESULT _CreateNameMap(STGMEDIUM *pmedium);
    HRESULT _CreateFileDescriptor(STGMEDIUM *pSTM);
    HRESULT _CreateFileContents(STGMEDIUM *pSTM, LONG lindex);
    HRESULT _CreateURL(STGMEDIUM *pSTM);
    HRESULT _CreatePrefDropEffect(STGMEDIUM *pSTM);

#ifdef UNICODE
    //  IExtractIconA
    STDMETHODIMP    GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags);
    STDMETHODIMP    Extract(LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize);
#endif

    // IExtractIconT Methods
    STDMETHODIMP GetIconLocation(UINT, LPTSTR, UINT, int *, UINT *);
    STDMETHODIMP Extract(LPCTSTR, UINT, HICON *, HICON *, UINT);
   
    // IQueryInfo Methods
    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR ** ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);

protected:

    ~COfflineObjectItem();

    UINT	                _cRef;       // reference count
    COfflineFolder*         _pOOFolder;   // back pointer to our shell folder
    
    UINT                    _cItems;     // number of items we represent
    LPMYPIDL*               _ppooi;      // variable size array of items
    IUnknown                *m_pUIHelper;  // UI helper. For 1 item only.
    
        
};

class COfflineDropTarget : public IDropTarget
{
private:

    LPDATAOBJECT        m_pDataObj;
    ULONG               m_cRefs;
    DWORD               m_grfKeyStateLast;
    BOOL                m_fHasHDROP;
    BOOL                m_fHasSHELLURL;
    BOOL                m_fHasTEXT;
    DWORD               m_dwEffectLastReturned;
    HWND                m_hwndParent;

public:
    
    COfflineDropTarget(HWND hwndParent);
    ~COfflineDropTarget();

    STDMETHODIMP            QueryInterface      (REFIID riid,LPVOID FAR *ppv);
    STDMETHODIMP_(ULONG)    AddRef              ();
    STDMETHODIMP_(ULONG)    Release             ();
    STDMETHODIMP            DragEnter           (LPDATAOBJECT pDataObj, 
                                                 DWORD        grfKeyState,
                                                 POINTL       pt, 
                                                 LPDWORD      pdwEffect);
    STDMETHODIMP            DragOver            (DWORD        grfKeyState, 
                                                 POINTL       pt, 
                                                 LPDWORD      pdwEffect);
    STDMETHODIMP            DragLeave           ();
    STDMETHODIMP            Drop                (LPDATAOBJECT pDataObj,
                                                 DWORD        grfKeyState, 
                                                 POINTL       pt, 
                                                 LPDWORD      pdwEffect);
    DWORD                   GetDropEffect       (LPDWORD      pdwEffect);

};

#endif  // __cplusplus

#endif  // OFFLINE_CPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\postagnt.h ===
// 
// Pei-Hwa Lin (peiwhal), Feb 3, 1997
//

#ifndef POSTAGNT_H_
#define POSTAGNT_H_

#define MAX_CONTENT_LENGTH 2048

#define WEBCRAWL_POST_BEGIN 2
#define WEBCRAWL_POST_END   0


class CTrackingStg;

//////////////////////////////////////////////////////////////////////////
//
// Actual Post Agent objects
//
//////////////////////////////////////////////////////////////////////////

class CWCPostAgent : public CDeliveryAgent
{
private:
    ~CWCPostAgent(void);

public:
    CWCPostAgent(void);

    //
    // CDeliveryAgent
    //
    HRESULT     StartOperation();
    HRESULT     StartDownload();
    
    HRESULT     AgentAbort(DWORD dwFlags);

//    void CALLBACK PostCallback(HINTERNET hInternet, DWORD dwContext, 
//                               DWORD dwInternetStatus, LPVOID lpvStatusInfo,
//                               DWORD dwInfoLen);

    void        CleanUp();

protected:
    HRESULT     DoPost();
    HRESULT     DoFileUpload();
    BOOL        GetTmpLogFileName();

    HRESULT     InitRequest(LPCSTR lpszVerb);
    HRESULT     SendRequest(LPCSTR lpszHeaders, LPDWORD lpdwHeadersLength,
                            LPCSTR lpszOption, LPDWORD lpdwOptionLength);
    HRESULT     CloseRequest(void);
  
    HRESULT     OnPostSuccess();
    HRESULT     OnPostFailed();
    void        MergeGroupOldToNew();

    ISubscriptionMgr2 *GetSubscriptionMgr();
    HRESULT     FindCDFStartItem();
    //HRESULT     ScheduleMe(INotificationMgr* pNotMgr, INotification *pNot);


private:

    // for wininet
    HINTERNET   _hSession;
    HINTERNET   _hHttpSession;
    HINTERNET   _hHttpRequest;

    CTrackingStg*   _pUploadStream;
    LPSTR       _pszPostStream;
    LPSTR       _lpLogFile;
    LPWSTR      _pwszEncoding;

    ISubscriptionItem* _pCDFItem;
};

class CTrackingStg
{

public:
    CTrackingStg();
    ~CTrackingStg();

    BOOL        IsExpired(ISubscriptionItem* pItem); 

    // data retrieving
    HRESULT     RetrieveAllLogStream(ISubscriptionItem* pItem, LPCSTR lpFile);
    HRESULT     RetrieveLogData(ISubscriptionItem* pItem);
    HRESULT     Enumeration(LONGLONG logId);
    void        AppendLogUrlField(LPINTERNET_CACHE_ENTRY_INFOA lpce);
    void        AppendLogEntries(LPINTERNET_CACHE_ENTRY_INFOA lpce);
    DWORD       ReadLogFile(LPCSTR lpFile, LPSTR* lplpBuf);
    
    HRESULT     EmptyCacheEntry(GROUPID enumId);
    HRESULT     RemoveCacheEntry(GROUPID enumId);

    HANDLE      OpenItemLogFile(LPCSTR lpFile);
    HRESULT     CloseLogFile()
                {
                    CloseHandle(_hLogFile);
                    _hLogFile = NULL;
                    return S_OK;
                }
    
    LPWSTR      _pwszURL;
    GROUPID     _groupId;
    DWORD       _dwRetry;
    LPSTR       _lpPfx;

private:
    HANDLE      _hLogFile;
};

#endif POSTAGNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\propshts.h ===
#ifndef __propshts_h
#define __propshts_h

INT_PTR CALLBACK SummaryPropDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SchedulePropDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DownloadPropDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AdvancedDownloadDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LoginOptionDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NewScheduleDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif //__propshts_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\private.h ===
#define INC_OLE2
#define _SHDOCVW_
#ifdef UNICODE
#define POST_IE5_BETA
#include <w95wraps.h>
#endif
#include <windows.h>
#include <windowsx.h>
#include <ccstock.h>
#include <ole2.h>
#include <ole2ver.h>
#include <oleauto.h>
#include <docobj.h>
#include <shlwapi.h>
#include <wininet.h>   // INTERNET_MAX_URL_LENGTH.  Must be before shlobjp.h!
#include <winineti.h>
#include <shlobj.h>
#include <inetsdk.h>
#include <intshcut.h>
#include <mshtml.h>
#include <notftn.h>
#include <webcheck.h>
#include <exdisp.h>
#include <inetreg.h>
#include <advpub.h>
#include <htiframe.h>
#include <ieguidp.h>
#include <lmcons.h>         // for UNLEN/PWLEN
#include <ipexport.h>       // for ping
#include <icmpapi.h>        // for ping
#include <mobsync.h>
#include <mobsyncp.h>
#undef MAX_STATUS   // goofy
#include "debug.h"
#include "resource.h"
#include "rsrchdr.h"
#include "shfusion.h"

#include "pstore.h"
#include <shdocvw.h> // to get SHRestricted2*
#include <dwnnot.h> // IDownloadNotify
#include <malloc.h> // TSTR_ALIGNED_STACK_COPY

#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4706)   // assignment w/i conditional expression
#pragma warning(3:4709)   // command operator w/o index expression

// How user of CUrlDownload receives notifications from it.
class CUrlDownloadSink
{
public:
    virtual HRESULT OnDownloadComplete(UINT iID, int iError) = 0;
    virtual HRESULT OnAuthenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
                        { return E_NOTIMPL; }
    virtual HRESULT OnClientPull(UINT iID, LPCWSTR pwszOldURL, LPCWSTR pwszNewURL)
                        { return S_OK; }
    virtual HRESULT OnOleCommandTargetExec(const GUID *pguidCmdGroup, DWORD nCmdID,
                                DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                                VARIANTARG *pvarargOut)
                        { return OLECMDERR_E_NOTSUPPORTED; }

    // returns free threaded callback interface
    // If you use this, make your implementation of IDownloadNotify fast
    virtual HRESULT GetDownloadNotify(IDownloadNotify **ppOut)
                        { return E_NOTIMPL; }
};

class CUrlDownload;

#include "filetime.h"
#include "offline.h"
#include "utils.h"
#include "delagent.h"
#include "cdfagent.h"
#include "webcrawl.h"
#include "trkcache.h"
#include "postagnt.h"
#include "cdlagent.h"

// Note: dialmon.h changes winver to 0x400
#include "dialmon.h"

#ifndef GUIDSTR_MAX
// GUIDSTR_MAX is 39 and includes the terminating zero.
// == Copied from OLE source code =================================
// format for string form of GUID is (leading identifier ????)
// ????{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)
// ================================================================
#endif

// Trace and debug flags
#define TF_WEBCHECKCORE 0x00001000
//#define TF_SCHEDULER    0x00002000
#define TF_WEBCRAWL     0x00004000
#define TF_SEPROX       0x00008000
#define TF_CDFAGENT     0x00010000
#define TF_STRINGLIST   0x00020000
#define TF_URLDOWNLOAD  0x00040000
#define TF_DOWNLD       0x00080000
#define TF_DIALMON      0x00100000
#define TF_MAILAGENT    0x00200000
//#define TF_TRAYAGENT    0x00400000
#define TF_SUBSFOLDER   0x00800000
#define TF_MEMORY       0x01000000
#define TF_UPDATEAGENT  0x02000000
#define TF_POSTAGENT    0x04000000
#define TF_DELAGENT     0x08000000
#define TF_TRACKCACHE   0x10000000
#define TF_SYNCMGR      0x20000000
#define TF_THROTTLER    0x40000000
#define TF_ADMIN        0x80000000  //  Admin and IE upgrade

#define PSM_QUERYSIBLINGS_WPARAM_RESCHEDULE 0XF000

#undef DBG
#define DBG(sz)             TraceMsg(TF_THISMODULE, sz)
#define DBG2(sz1, sz2)      TraceMsg(TF_THISMODULE, sz1, sz2)
#define DBG_WARN(sz)        TraceMsg(TF_WARNING, sz)
#define DBG_WARN2(sz1, sz2) TraceMsg(TF_WARNING, sz1, sz2)

#ifdef DEBUG
#define DBGASSERT(expr,sz)  do { if (!(expr)) TraceMsg(TF_WARNING, (sz)); } while (0)
#define DBGIID(sz,iid)      DumpIID(sz,iid)
#else
#define DBGASSERT(expr,sz)  ((void)0)
#define DBGIID(sz,iid)      ((void)0)
#endif

// shorthand
#ifndef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; } else
#endif
#ifndef ATOMICRELEASE
#define ATOMICRELEASET(p,type) { type* punkT=p; p=NULL; punkT->Release(); }
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#endif
#ifndef SAFEFREEBSTR
#define SAFEFREEBSTR(p) if ((p) != NULL) { SysFreeString(p); (p) = NULL; } else
#endif
#ifndef SAFEFREEOLESTR
#define SAFEFREEOLESTR(p) if ((p) != NULL) { CoTaskMemFree(p); (p) = NULL; } else
#endif
#ifndef SAFELOCALFREE
#define SAFELOCALFREE(p) if ((p) != NULL) { MemFree(p); (p) = NULL; } else
#endif
#ifndef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { delete (p); (p) = NULL; } else
#endif

// MAX_WEBCRAWL_LEVELS is the max crawl depth for site subscriptions
// MAX_CDF_CRAWL_LEVELS is the max crawl depth for the "LEVEL" attrib value for CDFs
#define MAX_WEBCRAWL_LEVELS 3
#define MAX_CDF_CRAWL_LEVELS 3

#define MY_MAX_CACHE_ENTRY_INFO 6144

//
// Define the location of the webcheck registry key.
//
#define WEBCHECK_REGKEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Webcheck")
#define WEBCHECK_REGKEY_NOTF TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Webcheck\\Notification Handlers")
#define WEBCHECK_REGKEY_STORE (WEBCHECK_REGKEY TEXT("\\Store.1"))



//
// Registry Keys
//
extern const TCHAR c_szRegKey[];                // registry key for webcheck stuff
extern const TCHAR c_szRegKeyUsernames[];       // registry key for webcheck stuff
extern const TCHAR c_szRegKeyPasswords[];       // registry key for webcheck stuff
extern const TCHAR c_szRegKeyStore[];
extern const TCHAR c_szRegPathInternetSettings[];
// extern const TCHAR c_szRegKeyRestrictions[];    // HKCU\Policies\...\Infodelivery\Restrictions
// extern const TCHAR c_szRegKeyModifications[];   // HKCU\Policies\...\Infodelivery\Modification
// extern const TCHAR c_szRegKeyCompletedMods[];   // HKCU\Policies\...\Infodelivery\CompletedModifications

//
// Registry Values
//
extern const TCHAR c_szNoChannelLogging[];

//
// Globals
//
extern HINSTANCE    g_hInst;                // dll instance
extern ULONG        g_cLock;                // outstanding locks
extern ULONG        g_cObj;                 // outstanding objects
extern BOOL         g_fIsWinNT;             // are we on winNT? Always initialized.
extern BOOL         g_fIsWinNT5;            // are we on winNT5? Always initialized.
extern BOOL         g_fIsMillennium;        // are we on Millennium?
extern const TCHAR c_szEnable[];            // enable unattended dialup

extern const TCHAR  c_szStrEmpty[];

inline ULONG DllLock()     { return ++g_cLock; }
inline ULONG DllUnlock()   { return --g_cLock; }
inline ULONG DllGetLock()  { return g_cLock; }

inline ULONG DllAddRef()   { return ++g_cObj; }
inline ULONG DllRelease()  { return --g_cObj; }
inline ULONG DllGetRef()   { return g_cObj; }

//
// Subscription property names; webcheck.cpp
//
// Agent Start
extern const WCHAR  c_szPropURL[];          // BSTR
extern const WCHAR  c_szPropName[];         // BSTR; friendly name
extern const WCHAR  c_szPropAgentFlags[];   // I4
extern const WCHAR  c_szPropCrawlLevels[];  // I4; webcrawler
extern const WCHAR  c_szPropCrawlFlags[];   // I4; webcrawler
extern const WCHAR  c_szPropCrawlMaxSize[]; // I4; webcrawler (in KB)
extern const WCHAR  c_szPropCrawlChangesOnly[];  // BOOL
extern const WCHAR  c_szPropChangeCode[];   // I4 or CY
extern const WCHAR  c_szPropEmailNotf[];    // BOOL;
extern const WCHAR  c_szPropCrawlUsername[];  // BSTR
extern const WCHAR  c_szPropCrawlLocalDest[]; // BSTR
extern const WCHAR  c_szPropEnableShortcutGleam[]; // I4
extern const WCHAR  c_szPropChannelFlags[];     // I4; channel agent specific flags
extern const WCHAR  c_szPropChannel[];          // I4; indicates a channel
extern const WCHAR  c_szPropDesktopComponent[]; // I4; indicates a desktop component
// set by agents in Agent Start
extern const WCHAR  c_szPropCrawlGroupID[];  // cache group ID
extern const WCHAR  c_szPropCrawlNewGroupID[]; // ID for new (existing) cache group
extern const WCHAR  c_szPropCrawlActualSize[];  // in KB
extern const WCHAR  c_szPropActualProgressMax[]; // Progress Max at end of last update
extern const WCHAR  c_szStartCookie[];      // The cookie of Start Notification.
extern const WCHAR  c_szPropStatusCode[];       // SCODE
extern const WCHAR  c_szPropStatusString[];     // BSTR (sentence)
extern const WCHAR  c_szPropCompletionTime[];   // DATE
extern const WCHAR  c_szPropPassword[];   // BSTR
// End Report
extern const WCHAR  c_szPropEmailURL[];         // BSTR
extern const WCHAR  c_szPropEmailFlags[];       // I4
extern const WCHAR  c_szPropEmailTitle[];       // BSTR
extern const WCHAR  c_szPropEmailAbstract[];    // BSTR
extern const WCHAR  c_szPropCharSet[];          // BSTR

// Tray Agent Properties
extern const WCHAR  c_szPropGuidsArr[];     // SAFEARRAY for a list of GUIDs

// Initial cookie used in AGENT_INIT notification.
extern const WCHAR  c_szInitCookie[];      // The cookie of Start Notification.
// Tracking
extern const WCHAR  c_szTrackingCookie[];   // Channel identity
extern const WCHAR  c_szTrackingPostURL[];  // tracking post url
extern const WCHAR  c_szPostingRetry[];     //
extern const WCHAR  c_szPostHeader[];       // specify encoding method of postdata
extern const WCHAR  c_szPostPurgeTime[];    // DATE

//
// Mail agent flags for the c_szPropEmailFlags property
//
enum MAILAGENT_FLAGS {
    MAILAGENT_FLAG_CUSTOM_MSG = 0x1
};

//
// Mail functions
//
HRESULT SendEmailFromItem(ISubscriptionItem *pItem);
HRESULT MimeOleEncodeStreamQP(IStream *pstmIn, IStream *pstmOut);
void ReadDefaultSMTPServer(LPTSTR pszBuf, UINT cch);
void ReadDefaultEmail(LPTSTR pszBuf, UINT cch);

// utils.cpp
interface IChannelMgrPriv;
HRESULT GetChannelPath(LPCTSTR pszURL, LPTSTR pszPath, int cch, IChannelMgrPriv** ppIChannelMgrPriv);

//
// Timer id's for scheduler and dialmon
//
#define TIMER_ID_DIALMON_IDLE   2       // every minute while connected
#define TIMER_ID_DIALMON_SEC    3       // every second for 30 seconds
#define TIMER_ID_DBL_CLICK      4       // did the user single or double click
#define TIMER_ID_USER_IDLE      5       // used to detect user idle on system

// Custom schedule dialog proc
BOOL CALLBACK CustomDlg(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
int SGMessageBox(HWND, UINT, UINT);

//
// Dialmon messages - send to scheduler window by various pieces of the system
// to tell us when dialup related stuff happens
//
#define WM_DIALMON_FIRST        WM_USER+100
#define WM_WINSOCK_ACTIVITY     WM_DIALMON_FIRST + 0
#define WM_REFRESH_SETTINGS     WM_DIALMON_FIRST + 1
#define WM_SET_CONNECTOID_NAME  WM_DIALMON_FIRST + 2
#define WM_IEXPLORER_EXITING    WM_DIALMON_FIRST + 3

// new set of Dialmon messages to support timeout for Mars + any other apps.
#define WM_DIALMON_HOOK         WM_DIALMON_FIRST + 4
#define WM_DIALMON_UNHOOK       WM_DIALMON_FIRST + 5
#define WM_CANHANGUP            WM_DIALMON_FIRST + 6
#define WM_CONFIRM_HANGUP       WM_DIALMON_FIRST + 7
#define WM_DENY_HANGUP          WM_DIALMON_FIRST + 8
#define WM_HANGING_UP           WM_DIALMON_FIRST + 9

// maximum number of application processes using dialmon at the same time.
#define MAX_DIALMON_HANDLES     10

// message used to report user mouse or kbd activity
// Note: sage.vxd uses this value and we can't change it.
#define WM_USER_ACTIVITY        WM_USER+5

// message sent by loadwc requesting a dynaload of sens/lce.
#define WM_LOAD_SENSLCE         WM_USER+200
#define WM_IS_SENSLCE_LOADED    WM_USER+201

//
// Random subscription defaults
//
#define DEFAULTLEVEL    0
#define DEFAULTFLAGS  (WEBCRAWL_GET_IMAGES | WEBCRAWL_LINKS_ELSEWHERE | WEBCRAWL_GET_CONTROLS)

#define IsNativeAgent(CLSIDAGENT)       (((CLSIDAGENT) == CLSID_WebCrawlerAgent) || ((CLSIDAGENT) == CLSID_ChannelAgent))
#define IS_VALID_SUBSCRIPTIONTYPE(st)   ((st == SUBSTYPE_URL) || (st == SUBSTYPE_CHANNEL) || (st == SUBSTYPE_DESKTOPCHANNEL) || (st == SUBSTYPE_DESKTOPURL))

//
// Useful functions
//
int MyOleStrToStrN(LPTSTR psz, int cchMultiByte, LPCOLESTR pwsz);
int MyStrToOleStrN(LPOLESTR pwsz, int cchWideChar, LPCTSTR psz);
void DumpIID(LPCSTR psz, REFIID riid);

// String comparison routines ; assume 8-bit characters. Return 0 or nonzero.
// Will work correctly if one or both strings are entirely 8-bit characters.
int MyAsciiCmpW(LPCWSTR pwsz1, LPCWSTR pwsz2);
int MyAsciiCmpNIW(LPCWSTR pwsz1, LPCWSTR pwsz2, int iLen);
inline
 int MyAsciiCmpNW(LPCWSTR pwsz1, LPCWSTR pwsz2, int iLen)
 { return memcmp(pwsz1, pwsz2, iLen*sizeof(WCHAR)); }

// Implementation in CDFagent.cpp
HRESULT XMLScheduleElementToTaskTrigger(IXMLElement *pRootEle, TASK_TRIGGER *ptt);
HRESULT ScheduleToTaskTrigger(TASK_TRIGGER *ptt, SYSTEMTIME *pstStartDate, SYSTEMTIME *pstEndDate,
                              long lInterval, long lEarliest, long lLatest, int iZone=9999);

// Admin related functions
HRESULT ProcessInfodeliveryPolicies(void);

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#endif

//  IE 5 versions - sans notfmgr support
HRESULT ReadDWORD       (ISubscriptionItem *pItem, LPCWSTR szName, DWORD *pdwRet);
HRESULT ReadLONGLONG    (ISubscriptionItem *pItem, LPCWSTR szName, LONGLONG *pllRet);
HRESULT ReadGUID        (ISubscriptionItem *pItem, LPCWSTR szName, GUID *);
HRESULT ReadDATE        (ISubscriptionItem *pItem, LPCWSTR szName, DATE *dtVal);
HRESULT ReadBool        (ISubscriptionItem *pItem, LPCWSTR szName, VARIANT_BOOL *pBoolRet);
HRESULT ReadBSTR        (ISubscriptionItem *pItem, LPCWSTR szName, BSTR *bstrRet);
HRESULT ReadOLESTR      (ISubscriptionItem *pItem, LPCWSTR szName, LPWSTR *pszRet);
HRESULT ReadAnsiSTR     (ISubscriptionItem *pItem, LPCWSTR szName, LPSTR *ppszRet);
HRESULT ReadSCODE       (ISubscriptionItem *pItem, LPCWSTR szName, SCODE *pscRet);
HRESULT ReadVariant     (ISubscriptionItem *pItem, LPCWSTR szName, VARIANT *pvarRet);

HRESULT WriteDWORD      (ISubscriptionItem *pItem, LPCWSTR szName, DWORD dwVal);
HRESULT WriteLONGLONG   (ISubscriptionItem *pItem, LPCWSTR szName, LONGLONG llVal);
HRESULT WriteGUID       (ISubscriptionItem *pItem, LPCWSTR szName, GUID *);
HRESULT WriteDATE       (ISubscriptionItem *pItem, LPCWSTR szName, DATE *dtVal);
HRESULT WriteOLESTR     (ISubscriptionItem *pItem, LPCWSTR szName, LPCWSTR szVal);
HRESULT WriteResSTR     (ISubscriptionItem *pItem, LPCWSTR szName, UINT uID);
HRESULT WriteAnsiSTR    (ISubscriptionItem *pItem, LPCWSTR szName, LPCSTR szVal);
HRESULT WriteSCODE      (ISubscriptionItem *pItem, LPCWSTR szName, SCODE scVal);
HRESULT WriteEMPTY      (ISubscriptionItem *pItem, LPCWSTR szName);
HRESULT WriteVariant    (ISubscriptionItem *pItem, LPCWSTR szName, VARIANT *pvarVal);

#ifdef UNICODE
#define ReadTSTR        ReadOLESTR
#define WriteTSTR       WriteOLESTR
#else
#define ReadTSTR        ReadAnsiSTR
#define WriteTSTR       WriteAnsiSTR
#endif


HRESULT WritePassword   (ISubscriptionItem *pItem, BSTR szPassword);
HRESULT ReadPassword    (ISubscriptionItem *pItem, BSTR *ppszPassword);

// WEBCRAWL.CPP helper functions

// Do cool stuff to a single URL in the cache. Make sticky, get size, put in group...
// Returns E_OUTOFMEMORY if make sticky fails
HRESULT GetUrlInfoAndMakeSticky(
            LPCTSTR pszBaseUrl,         // Base URL. May be NULL if pszThisUrl is absolute
            LPCTSTR pszThisUrl,         // Absolute or relative url
            LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,       // Required
            DWORD   dwBufSize,          // Size of *lpCacheEntryInfo
            GROUPID llCacheGroupID);    // Group ID ; may be 0

// PreCheckUrlForChange and PostCheckUrlForChange are documented in webcrawl.cpp
HRESULT PreCheckUrlForChange(LPCTSTR lpURL, VARIANT *pvarChange, BOOL *pfGetContent);
HRESULT PostCheckUrlForChange(VARIANT *pvarChange,
                              LPINTERNET_CACHE_ENTRY_INFO lpInfo, FILETIME ftNewLastModified);

HRESULT WriteCookieToInetDB(LPCTSTR pszURL, SUBSCRIPTIONCOOKIE *pCookie, BOOL bRemove);
HRESULT ReadCookieFromInetDB(LPCTSTR pszURL, SUBSCRIPTIONCOOKIE *pCookie);

#define MAX_RES_STRING_LEN 128      // max resource string len for WriteStringRes

// IntSite helper function
HRESULT IntSiteHelper(LPCTSTR pszURL, const PROPSPEC *pReadPropspec,
        PROPVARIANT *pReadPropvar, UINT uPropVarArraySize, BOOL fWrite);
extern const PROPSPEC c_rgPropRead[];
#define PROP_SUBSCRIPTION   0
#define PROP_FLAGS          1
#define PROP_TRACKING       2
#define PROP_CODEPAGE       3

//=============================================================================
// Helper class for aggregation. Inherit from this like another interface, then
//  implement InnerQI and include IMPLEMENT_DELEGATE_UNKNOWN in your class declaration
class CInnerUnknown
{
public:
    CInnerUnknown() { m_cRef = 1; m_punkOuter=(IUnknown *)(CInnerUnknown *)this; }

    void InitAggregation(IUnknown *punkOuter, IUnknown **punkInner)
    {
        if (punkOuter)
        {
            m_punkOuter = punkOuter;
            *punkInner = (IUnknown *)(CInnerUnknown *)this;
        }
    }

    virtual HRESULT STDMETHODCALLTYPE InnerQI(REFIID riid, void **ppunk) = 0;
    virtual ULONG STDMETHODCALLTYPE InnerAddRef() { return ++m_cRef; }
    virtual ULONG STDMETHODCALLTYPE InnerRelease() = 0;

protected:
    long     m_cRef;
    IUnknown *m_punkOuter;
};

#define IMPLEMENT_DELEGATE_UNKNOWN() \
STDMETHODIMP         QueryInterface(REFIID riid, void **ppunk) \
    { return m_punkOuter->QueryInterface(riid, ppunk); } \
STDMETHODIMP_(ULONG) AddRef() { return m_punkOuter->AddRef(); } \
STDMETHODIMP_(ULONG) Release() { return m_punkOuter->Release(); } \
STDMETHODIMP_(ULONG) InnerRelease() { \
        if (0L != --m_cRef) return m_cRef; \
        delete this; \
        return 0L; }
// end aggregation helpers
//=============================================================================



// Registry helper functions
BOOL ReadRegValue(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue,
                   void *pData, DWORD dwBytes);
BOOL WriteRegValue(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue,
                    void *pData, DWORD dwBytes, DWORD dwType);

DWORD ReadRegDWORD(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue);

// Event logging function
DWORD __cdecl LogEvent(LPTSTR pszEvent, ...);

// Thread proc for firing up sens and lce
DWORD WINAPI ExternalsThread(LPVOID lpData);

// Used to set syncmgr "warning" level
#define INET_E_AGENT_WARNING 0x800C0FFE
//
// Main WebCheck class
//
class CWebCheck : public IOleCommandTarget
{
protected:
    ULONG           m_cRef;

public:
    CWebCheck(void);
    ~CWebCheck(void);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IWebCheck members
    STDMETHODIMP         StartService(BOOL fForceExternals);
    STDMETHODIMP         StopService(void);

    // IOleCommandTarget members
    STDMETHODIMP         QueryStatus(const GUID *pguidCmdGroup,
                                     ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHODIMP         Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                              DWORD nCmdexecopt, VARIANTARG *pvaIn,
                              VARIANTARG *pvaOut);

    // External handling members
    BOOL                 ShouldLoadExternals(void);
    BOOL                 AreExternalsLoaded(void);
    void                 LoadExternals(void);
    void                 UnloadExternals(void);

    // thread for handling external bits
    HANDLE               _hThread;

    // events to synchronize with external thread
    HANDLE               _hTerminateEvent;
};

//
// CMemStream class
//
class CMemStream
{
protected:
    IStream *   m_pstm;
    BOOL        m_fDirty;
    BOOL        m_fError;

public:
    BOOL        m_fNewStream;

public:
    CMemStream(BOOL fNewStream=TRUE);
    ~CMemStream();

    BOOL        IsError() { return m_fError; }

    HRESULT     Read(void *pv, ULONG cb, ULONG *cbRead);
    HRESULT     Write(void *pv, ULONG cb, ULONG *cbWritten);
    HRESULT     Seek(long lMove, DWORD dwOrigin, DWORD *dwNewPos);
    HRESULT     SaveToStream(IUnknown *punk);
    HRESULT     LoadFromStream(IUnknown **ppunk);

    HRESULT     CopyToStream(IStream *pStm);
};



extern BOOL IsGlobalOffline(void);
extern void SetGlobalOffline(BOOL fOffline);

extern BOOL IsADScreenSaverActive();
extern HRESULT MakeADScreenSaverActive();


#define MemAlloc LocalAlloc
#define MemFree LocalFree
#define MemReAlloc LocalReAlloc

typedef HRESULT (* CREATEPROC)(IUnknown *, IUnknown **);

// Helper functions to read and write passwords to an encrypted store.

STDAPI ReadNotificationPassword(LPCWSTR wszUrl, BSTR * pbstrPassword);
STDAPI WriteNotificationPassword(LPCWSTR wszUrl, BSTR  bstrPassword);

// dialmon functions
BOOL DialmonInit(void);
void DialmonShutdown(void);

// LCE dynaload entry points
typedef HRESULT (* LCEREGISTER)(HMODULE);
typedef HRESULT (* LCEUNREGISTER)(HMODULE);
typedef HRESULT (* LCESTART)(void);
typedef HRESULT (* LCESTOP)(void);

// SENS dynaload entry points
typedef HRESULT (* SENSREGISTER)(void);
typedef BOOL (* SENSSTART)(void);
typedef BOOL (* SENSSTOP)(void);

// event dispatching
DWORD DispatchEvent(DWORD dwEvent, LPWSTR pwsEventDesc, DWORD dwEventData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\propshts.cpp ===
#include "private.h"
#include "offl_cpp.h"
#include "propshts.h"
#include "subsmgrp.h"
#include <iehelpid.h>

#include <mluisupp.h>

#define INITGUID
#include <initguid.h>
#include "imnact.h"
#include "helper.h"

void WriteDefaultEmail(LPTSTR szBuf);
void WriteDefaultSMTPServer(LPTSTR szBuf);

const TCHAR c_szDefEmail[] = TEXT("DefaultEmail");
const TCHAR c_szDefServer[] = TEXT("DefaultSMTPServer");
TCHAR c_szHelpFile[] = TEXT("iexplore.hlp");

struct NEWSCHED_DATA
{
    SYNCSCHEDULECOOKIE SchedCookie;
    TCHAR szSchedName[MAX_PATH];
};

#define MIN_DOWNLOAD_K  50
#define MAX_DOWNLOAD_K  UD_MAXVAL
#define DEF_DOWNLOAD_K  500

DWORD aHelpIDs[] = {

//  Schedule page
    IDC_SCHEDULE_TEXT,              IDH_GROUPBOX,
    IDC_MANUAL_SYNC,                IDH_SUBPROPS_SCHEDTAB_MANUAL_SCHEDULE,
    IDC_SCHEDULED_SYNC,             IDH_SUBPROPS_SCHEDTAB_CUSTOM_SCHEDULE,
    IDC_SCHEDULE_LIST,              IDH_SUBPROPS_SCHEDTAB_SCHEDDESC,
    IDC_SCHEDULE_NEW,               IDH_NEW_OFFLINE_SCHED,
    IDC_SCHEDULE_EDIT,              IDH_EDIT_OFFLINE_SCHED,
    IDC_SCHEDULE_REMOVE,            IDH_REMOVE_OFFLINE_SCHED,
//    IDC_IDLE_ONLY,                  IDH_SUBPROPS_SCHED_DONTUPDATE,

//  Download page
    IDC_CONTENT_GROUPBOX,           IDH_GROUPBOX,
    IDC_DOWNLOAD_PAGES_LABEL1,      IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_PAGES_DEEP,
    IDC_LEVELS,                     IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_PAGES_DEEP,
    IDC_LEVELS_SPIN,                IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_PAGES_DEEP,
    IDC_DOWNLOAD_PAGES_LABEL2,      IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_PAGES_DEEP,
    IDC_FOLLOW_LINKS,               IDH_SUBPROPS_RECTAB_ADVOPTS_FOLLOW_LINKS,
    IDC_LIMIT_SPACE_CHECK,          IDH_SUBPROPS_RECTAB_ADVOPTS_MAX_DOWNLOAD,
    IDC_LIMIT_SPACE_EDIT,           IDH_SUBPROPS_RECTAB_ADVOPTS_MAX_DOWNLOAD,
    IDC_LIMIT_SPACE_SPIN,           IDH_SUBPROPS_RECTAB_ADVOPTS_MAX_DOWNLOAD,
    IDC_LIMIT_SPACE_TEXT,           IDH_SUBPROPS_RECTAB_ADVOPTS_MAX_DOWNLOAD,   
    IDC_ADVANCED,                   IDH_SUBPROPS_RECTAB_ADVANCED,
    IDC_EMAIL_GROUPBOX,             IDH_SUBPROPS_RECTAB_EMAIL_NOTIFICATION,
    IDC_EMAIL_NOTIFY,               IDH_SUBPROPS_RECTAB_EMAIL_NOTIFICATION,
    IDC_EMAIL_ADDRESS_TEXT,         IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_ADDRESS,
    IDC_EMAIL_ADDRESS,              IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_ADDRESS,
    IDC_EMAIL_SERVER_TEXT,          IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_SERVER,
    IDC_EMAIL_SERVER,               IDH_SUBPROPS_RECTAB_MAILOPTS_EMAIL_SERVER,
    IDC_LOGIN_LABEL,                IDH_SUBPROPS_RECTAB_CHANNEL_LOGIN,
    IDC_LOGIN,                      IDH_SUBPROPS_RECTAB_CHANNEL_LOGIN,
    IDC_DOWNLOAD_ALL,               IDH_CHANNEL_DOWNLOAD_ALL,
    IDC_DOWNLOAD_MIN,               IDH_CHANNEL_DOWNLOAD_COVER_N_TOC,

    //  Advanced popup
    IDC_ADVANCED_GROUPBOX,          IDH_GROUPBOX,
    IDC_DOWNLOAD_IMAGES,            IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_IMAGES,
    IDC_DOWNLOAD_MEDIA,             IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_SOUND,
    IDC_DOWNLOAD_APPLETS,           IDH_SUBPROPS_RECTAB_ADVOPTS_DOWNLOAD_ACTIVEX,
    IDC_DOWNLOAD_ONLY_HTML_LINKS,   IDH_SUBPROPS_RECTAB_ADVOPTS_ONLY_HTML_LINKS,

    //  Login popup
    IDC_USERNAME_LABEL,             IDH_SUBPROPS_RECTAB_LOGINOPTS_USER_ID,
    IDC_USERNAME,                   IDH_SUBPROPS_RECTAB_LOGINOPTS_USER_ID,
    IDC_PASSWORD_LABEL,             IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD,
    IDC_PASSWORD,                   IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD,
    IDC_PASSWORDCONFIRM_LABEL,      IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD_CONFIRM,
    IDC_PASSWORDCONFIRM,            IDH_SUBPROPS_RECTAB_LOGINOPTS_PASSWORD_CONFIRM,

    //  New schedule popup
    IDC_SCHEDULE_LABEL1,            IDH_NEWSCHED_EVERY_AT_TIME,
    IDC_SCHEDULE_DAYS,              IDH_NEWSCHED_EVERY_AT_TIME,
    IDC_SCHEDULE_DAYS_SPIN,         IDH_NEWSCHED_EVERY_AT_TIME,
    IDC_SCHEDULE_LABEL2,            IDH_NEWSCHED_EVERY_AT_TIME,
    IDC_SCHEDULE_TIME,              IDH_NEWSCHED_EVERY_AT_TIME,
    IDC_SCHEDULE_NAME_TEXT,         IDH_NEWSCHED_NAME,
    IDC_SCHEDULE_NAME,              IDH_NEWSCHED_NAME,
    IDC_SCHEDULE_LABEL3,            IDH_NEWSCHED_EVERY_AT_TIME,
    IDC_WIZ_SCHEDULE_AUTOCONNECT,   IDH_SUBPROPS_NEW_SCHEDULE_AUTOCONNECT,

    //  Summary page
    IDC_NAME,                   IDH_SUBPROPS_SUBTAB_SUBSCRIBED_NAME,
    IDC_URL_TEXT,               IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL,
    IDC_URL,                    IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL,
    IDC_VISITS_TEXT,            IDH_WEBDOC_VISITS,
    IDC_VISITS,                 IDH_WEBDOC_VISITS,
    IDC_MAKE_OFFLINE,           IDH_MAKE_AVAIL_OFFLINE,
    IDC_SUMMARY,                IDH_GROUPBOX,
    IDC_LAST_SYNC_TEXT,         IDH_SUBPROPS_SUBTAB_LAST,
    IDC_LAST_SYNC,              IDH_SUBPROPS_SUBTAB_LAST,
    IDC_DOWNLOAD_SIZE_TEXT,     IDH_SUBPROPS_DLSIZE,
    IDC_DOWNLOAD_SIZE,          IDH_SUBPROPS_DLSIZE,
    IDC_DOWNLOAD_RESULT_TEXT,   IDH_SUBPROPS_SUBTAB_RESULT,
    IDC_DOWNLOAD_RESULT,        IDH_SUBPROPS_SUBTAB_RESULT,

    //  dah end
    0,                              0
};



/********************************************************************************
    Property sheet helpers
*********************************************************************************/

inline POOEBuf GetBuf(HWND hdlg)
{
    POOEBuf pBuf = (POOEBuf) GetWindowLongPtr(hdlg, DWLP_USER);

    return pBuf;
}

void EnableControls(HWND hdlg, const int *pIDs, int nIDs, BOOL bEnable)
{
    for (int i = 0; i < nIDs; i++)
    {
        EnableWindow(GetDlgItem(hdlg, *pIDs++), bEnable);
    }
}

/********************************************************************************
    Summary property sheet code
*********************************************************************************/
inline POOEBuf Summary_GetBuf(HWND hdlg)
{
    CSubscriptionMgr *pSubsMgr = (CSubscriptionMgr*) GetWindowLongPtr(hdlg, DWLP_USER);

    ASSERT(NULL != pSubsMgr);

    return (NULL != pSubsMgr) ? pSubsMgr->m_pBuf : NULL;
}

void Summary_ShowOfflineSummary(HWND hdlg, POOEBuf pBuf, BOOL bShow)
{
    static const int offSumIDs[] =
    {
        IDC_SUMMARY,
        IDC_LAST_SYNC_TEXT,
        IDC_LAST_SYNC,
        IDC_DOWNLOAD_SIZE_TEXT,
        IDC_DOWNLOAD_SIZE,
        IDC_DOWNLOAD_RESULT,
        IDC_DOWNLOAD_RESULT_TEXT,
        IDC_FREESPACE_TEXT
    };

    if (bShow)
    {
        TCHAR szLastSync[128];
        TCHAR szDownloadSize[128];
        TCHAR szDownloadResult[128];

        MLLoadString(IDS_VALUE_UNKNOWN, szLastSync, ARRAYSIZE(szLastSync));
        StrCpyN(szDownloadSize, szLastSync, ARRAYSIZE(szDownloadSize));
        StrCpyN(szDownloadResult, szLastSync, ARRAYSIZE(szDownloadResult));

        ISubscriptionItem *psi;
            
        if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, &pBuf->m_Cookie, &psi)))
        {
            enum { spLastSync, spDownloadSize, spDownloadResult };

            static const LPCWSTR pProps[] =
            { 
                c_szPropCompletionTime,
                c_szPropCrawlActualSize,
                c_szPropStatusString
            };
            VARIANT vars[ARRAYSIZE(pProps)];

            if (SUCCEEDED(psi->ReadProperties(ARRAYSIZE(pProps), pProps, vars)))
            {
                if (VT_DATE == vars[spLastSync].vt)
                {
                    FILETIME ft, ft2;
                    DWORD dwFlags = FDTF_DEFAULT;
                    
                    VariantTimeToFileTime(vars[spLastSync].date, ft);
                    LocalFileTimeToFileTime(&ft, &ft2);
                    SHFormatDateTime(&ft2, &dwFlags, szLastSync, ARRAYSIZE(szLastSync));
                }

                if (VT_I4 == vars[spDownloadSize].vt)
                {
                    StrFormatByteSize(vars[spDownloadSize].lVal * 1024, 
                                      szDownloadSize, ARRAYSIZE(szDownloadSize));
                }

                if (VT_BSTR == vars[spDownloadResult].vt)
                {
                #ifdef UNICODE
                    wnsprintf(szDownloadResult, ARRAYSIZE(szDownloadResult),
                              TEXT("%s"), vars[spDownloadResult].bstrVal);
                #else
                    wnsprintf(szDownloadResult, ARRAYSIZE(szDownloadResult),
                              TEXT("%S"), vars[spDownloadResult].bstrVal);
                #endif
                }

                for (int i = 0; i < ARRAYSIZE(pProps); i++)
                {
                    VariantClear(&vars[i]);
                }
            }
            psi->Release();
        }

        SetDlgItemText(hdlg, IDC_LAST_SYNC, szLastSync);
        SetDlgItemText(hdlg, IDC_DOWNLOAD_SIZE, szDownloadSize);
        SetDlgItemText(hdlg, IDC_DOWNLOAD_RESULT, szDownloadResult);
    }

    for (int i = 0; i < ARRAYSIZE(offSumIDs); i++)
    {
        ShowWindow(GetDlgItem(hdlg, offSumIDs[i]), bShow ? SW_SHOW : SW_HIDE);
    }
}

BOOL Summary_AddPageCallback(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    return PropSheet_AddPage((HWND)lParam, hpage) ? TRUE : FALSE;
}


BOOL Summary_OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bResult = FALSE;
    BOOL bChanged = FALSE;
    POOEBuf pBuf = Summary_GetBuf(hdlg);

    switch (wID)
    {
        case IDC_MAKE_OFFLINE:
            if (BN_CLICKED == wNotifyCode)
            {
                CSubscriptionMgr *pSubsMgr = (CSubscriptionMgr*) GetWindowLongPtr(hdlg, DWLP_USER);

                BOOL bShow = IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE);

                Summary_ShowOfflineSummary(hdlg, pBuf, bShow);
                
                if (NULL != pSubsMgr)
                {
                    if (bShow)
                    {
                        pSubsMgr->AddPages(Summary_AddPageCallback, (LPARAM)GetParent(hdlg));
                    }
                    else
                    {
                        pSubsMgr->RemovePages(GetParent(hdlg));
                    }
                }
                bChanged = TRUE;
            }
            bResult = TRUE;
            break;
    }

    if (bChanged)
    {
        PropSheet_Changed(GetParent(hdlg), hdlg);        
    }

    return bResult;
}

BOOL Summary_OnNotify(HWND hdlg, int idCtrl, LPNMHDR pnmh)
{
    BOOL bResult = TRUE;

    switch (pnmh->code)
    {
        case PSN_APPLY:
        {
            CSubscriptionMgr *pSubsMgr = (CSubscriptionMgr*) GetWindowLongPtr(hdlg, DWLP_USER);
            POOEBuf pBuf = Summary_GetBuf(hdlg);

            ASSERT(NULL != pSubsMgr);
            ASSERT(NULL != pBuf);
            
            if ((NULL != pSubsMgr) && (NULL != pBuf))
            {
                if (IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE))
                {
                    pBuf->dwFlags = PROP_WEBCRAWL_ALL;
                    SaveBufferChange(pBuf, TRUE);
                }
                else
                {                
                    WCHAR wszURL[INTERNET_MAX_URL_LENGTH];

                    MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), pBuf->m_URL);
                    pSubsMgr->DeleteSubscription(wszURL, NULL); 
                }
            }
            break;
        }
            
        default:
            bResult = FALSE;
            break;
    }
    return bResult;
}

BOOL Summary_OnInitDialog(HWND hdlg, HWND hwndFocus, LPARAM lParam)
{
    ASSERT(NULL != ((LPPROPSHEETPAGE)lParam));
    ASSERT(NULL != ((LPPROPSHEETPAGE)lParam)->lParam);

    SetWindowLongPtr(hdlg, DWLP_USER, ((LPPROPSHEETPAGE)lParam)->lParam);

    //  Now read in values and populate the dialog
    POOEBuf pBuf = Summary_GetBuf(hdlg);
    ISubscriptionItem *psi;
    HICON hicon;
    BOOL bSubscribed;

    HRESULT hr = SubscriptionItemFromCookie(FALSE, &pBuf->m_Cookie, &psi);

    if (SUCCEEDED(hr))
    {
        bSubscribed = TRUE;
        hicon = LoadItemIcon(psi, TRUE);
        psi->Release();
    }
    else
    {
        bSubscribed = FALSE;
        hicon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_WEBDOC));
    }

    SendDlgItemMessage(hdlg, IDC_ICONEX2, STM_SETICON, (WPARAM)hicon, 0);

    if ((!IsHTTPPrefixed(pBuf->m_URL)) ||
        (bSubscribed && SHRestricted2(REST_NoRemovingSubscriptions, pBuf->m_URL, 0)) ||
        (!bSubscribed && SHRestricted2(REST_NoAddingSubscriptions, pBuf->m_URL, 0)))
    {
        EnableWindow(GetDlgItem(hdlg, IDC_MAKE_OFFLINE), FALSE);
    }
        
    SetDlgItemText(hdlg, IDC_NAME, pBuf->m_Name);
    SetDlgItemText(hdlg, IDC_URL, pBuf->m_URL);

    CheckDlgButton(hdlg, IDC_MAKE_OFFLINE, bSubscribed);

    TCHAR szVisits[256];

    BYTE cei[MY_MAX_CACHE_ENTRY_INFO];
    LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)cei;
    DWORD cbcei = sizeof(cei);

    if (GetUrlCacheEntryInfo(pBuf->m_URL, pcei, &cbcei))
    {
        wnsprintf(szVisits, ARRAYSIZE(szVisits), TEXT("%d"), 
                  pcei->dwHitRate);
    }
    else
    {
        MLLoadString(IDS_VALUE_UNKNOWN, szVisits, 
                   ARRAYSIZE(szVisits));
    }
    SetDlgItemText(hdlg, IDC_VISITS, szVisits);


    Summary_ShowOfflineSummary(hdlg, pBuf, bSubscribed);

    return TRUE;
}

void Summary_OnDestroy(HWND hdlg)
{
    POOEBuf pBuf = Summary_GetBuf(hdlg);

    if (NULL != pBuf && !(pBuf->m_dwPropSheetFlags & PSF_IS_ALREADY_SUBSCRIBED) && 
        IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE))
    {
        SendUpdateRequests(NULL, &pBuf->m_Cookie, 1);
    }
}

INT_PTR CALLBACK SummaryPropDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            bHandled = Summary_OnInitDialog(hdlg, (HWND)wParam, lParam);
            break;

        case WM_COMMAND:
            bHandled = Summary_OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

        case WM_DESTROY:
            Summary_OnDestroy(hdlg);
            break;
            
        case WM_NOTIFY:
            bHandled = Summary_OnNotify(hdlg, (int)wParam, (LPNMHDR)lParam);
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;
    }
    
    return bHandled;
}


/********************************************************************************
    Schedule property sheet code
*********************************************************************************/

void Sched_EnableScheduleButtons(HWND hdlg)
{
    POOEBuf pBuf = GetBuf(hdlg);
    ASSERT(pBuf);

    BOOL bEditAllowed = !(pBuf->m_dwPropSheetFlags & 
                            (PSF_NO_EDITING_SCHEDULES | PSF_NO_SCHEDULED_UPDATES));
    BOOL bEnable = (bEditAllowed) &&
                   ListView_GetSelectedCount(GetDlgItem(hdlg, IDC_SCHEDULE_LIST));

    EnableWindow(GetDlgItem(hdlg, IDC_SCHEDULE_NEW), bEditAllowed);
    EnableWindow(GetDlgItem(hdlg, IDC_SCHEDULE_EDIT), bEnable);

    //  TODO: Don't enable remove for publisher's schedule
    EnableWindow(GetDlgItem(hdlg, IDC_SCHEDULE_REMOVE), bEnable);
}

struct SCHED_ENUM_DATA
{
    HWND hwndSchedList;
    POOEBuf pBuf;
    SYNCSCHEDULECOOKIE customSchedule;
    BOOL bHasAtLeastOneSchedule;
};

struct SCHED_LIST_DATA
{
    SYNCSCHEDULECOOKIE SchedCookie;
    BOOL bChecked;
    BOOL bStartChecked;
};

inline int SchedList_GetIndex(HWND hwndSchedList, int index)
{
    return (index != -1) ? index :
           ListView_GetNextItem(hwndSchedList, -1, LVNI_ALL | LVNI_SELECTED);
}

void SchedList_GetName(HWND hwndSchedList, int index, TCHAR *pszSchedName, int cchSchedName)
{
    LV_ITEM lvi = {0};

    lvi.iItem = SchedList_GetIndex(hwndSchedList, index);

    if (lvi.iItem != -1)
    {
        lvi.mask = LVIF_TEXT;
        lvi.pszText = pszSchedName;
        lvi.cchTextMax = cchSchedName;
        ListView_GetItem(hwndSchedList, &lvi);
    }
}

void SchedList_SetName(HWND hwndSchedList, int index, LPTSTR pszSchedName)
{
    LV_ITEM lvi = {0};

    lvi.iItem = SchedList_GetIndex(hwndSchedList, index);

    if (lvi.iItem != -1)
    {
        lvi.mask = LVIF_TEXT;
        lvi.pszText = pszSchedName;
        ListView_SetItem(hwndSchedList, &lvi);
    }
}

SCHED_LIST_DATA *SchedList_GetData(HWND hwndSchedList, int index)
{
    SCHED_LIST_DATA *psld = NULL;
    LV_ITEM lvi = {0};

    lvi.iItem = SchedList_GetIndex(hwndSchedList, index);

    if (lvi.iItem != -1)
    {
        lvi.mask = LVIF_PARAM;
        if (ListView_GetItem(hwndSchedList, &lvi))
        {
            psld = (SCHED_LIST_DATA *)lvi.lParam;
        }
    }

    return psld;
}

void SchedList_UncheckAll(HWND hwndSchedList)
{
    int count = ListView_GetItemCount(hwndSchedList);
    
    for (int i = 0; i < count; i++)
    {
        SCHED_LIST_DATA *psld = SchedList_GetData(hwndSchedList, i);

        if (NULL != psld)
        {
            psld->bChecked = 0;
            ListView_SetItemState(hwndSchedList, i, COMP_UNCHECKED, LVIS_STATEIMAGEMASK);
        }
    }
}

void SchedList_Select(HWND hwndSchedList, int index)
{
    int curIndex = ListView_GetNextItem(hwndSchedList, -1, LVNI_ALL | LVNI_SELECTED);

    if (curIndex != index)
    {
        ListView_SetItemState(hwndSchedList, curIndex, 0, LVIS_SELECTED | LVIS_FOCUSED);
        ListView_SetItemState(hwndSchedList, index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    }
}

void SchedList_DeleteData(HWND hwndSchedList, int index, BOOL bDeleteItem)
{
    LV_ITEM lvi = {0};

    lvi.iItem = SchedList_GetIndex(hwndSchedList, index);

    if (lvi.iItem != -1)
    {

        SCHED_LIST_DATA *psld = SchedList_GetData(hwndSchedList, lvi.iItem);

        lvi.mask = LVIF_PARAM;
        lvi.lParam = NULL;

        if ((NULL != psld) && ListView_SetItem(hwndSchedList, &lvi))
        {
            delete psld;
        }

        if (bDeleteItem)
        {
            ListView_DeleteItem(hwndSchedList, lvi.iItem);
        }
    }
}

void SchedList_DeleteAllData(HWND hwndSchedList)
{
    int count = ListView_GetItemCount(hwndSchedList);
    
    for (int i = 0; i < count; i++)
    {
        SchedList_DeleteData(hwndSchedList, i, FALSE);
    }
}

BOOL Sched_EnumCallback(ISyncSchedule *pSyncSchedule, 
                        SYNCSCHEDULECOOKIE *pSchedCookie,
                        LPARAM lParam)
{
    BOOL bAdded = FALSE;
    SCHED_ENUM_DATA *psed = (SCHED_ENUM_DATA *)lParam;
    DWORD dwSyncScheduleFlags;
    SCHED_LIST_DATA *psld = NULL;

    if (SUCCEEDED(pSyncSchedule->GetFlags(&dwSyncScheduleFlags)))
    {
        //  This checks to make sure we only add a publisher's schedule to the
        //  list if it belongs to this item.
        if ((!(dwSyncScheduleFlags & SYNCSCHEDINFO_FLAGS_READONLY)) ||
            (*pSchedCookie == psed->customSchedule))
        {
            psld = new SCHED_LIST_DATA;

            if (NULL != psld)
            {
                WCHAR wszName[MAX_PATH];
                DWORD cchName = ARRAYSIZE(wszName);

                if (SUCCEEDED(pSyncSchedule->GetScheduleName(&cchName, wszName)))
                {
                    TCHAR szName[MAX_PATH];

                    MyOleStrToStrN(szName, ARRAYSIZE(szName), wszName);

                    psld->SchedCookie = *pSchedCookie;
                    psld->bStartChecked = IsCookieOnSchedule(pSyncSchedule, &psed->pBuf->m_Cookie);
                    psld->bChecked = psld->bStartChecked;

                    if (psld->bStartChecked)
                    {
                        psed->bHasAtLeastOneSchedule = TRUE;
                    }

                    LV_ITEM lvItem = { 0 };

                    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
                    lvItem.iItem = (*pSchedCookie == psed->customSchedule) ? 0 : 0x7FFFFFFF;
                    lvItem.lParam = (LPARAM)psld;
                    lvItem.pszText = szName;

                    int index = ListView_InsertItem(psed->hwndSchedList, &lvItem);

                    if (index != -1)
                    {
                            
                        ListView_SetItemState(psed->hwndSchedList, index, 
                                              psld->bStartChecked ? COMP_CHECKED : COMP_UNCHECKED, 
                                              LVIS_STATEIMAGEMASK);
                        ListView_SetColumnWidth(psed->hwndSchedList, 0, LVSCW_AUTOSIZE);
                        bAdded = TRUE;
                    }
                }
            }
        }
    }

    if (!bAdded)
    {
        SAFEDELETE(psld);
    }
    
    return TRUE;
}

BOOL Sched_FillScheduleList(HWND hdlg, POOEBuf pBuf)
{
    SCHED_ENUM_DATA sed;

    sed.hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);
    sed.pBuf = pBuf;

    sed.customSchedule = GUID_NULL;
    
    ISubscriptionItem *psi;
    if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, &pBuf->m_Cookie, &psi)))
    {
        SUBSCRIPTIONITEMINFO sii;

        sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

        if (SUCCEEDED(psi->GetSubscriptionItemInfo(&sii)))
        {
            sed.customSchedule = sii.ScheduleGroup;
        }
        psi->Release();
    }
    sed.bHasAtLeastOneSchedule = FALSE;

    EnumSchedules(Sched_EnumCallback, (LPARAM)&sed);

    return sed.bHasAtLeastOneSchedule;
}

BOOL Sched_NewSchedule(HWND hdlg)
{
    NEWSCHED_DATA nsd;

    INT_PTR nResult = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_NEW_SCHEDULE),
                                 hdlg, NewScheduleDlgProc, (LPARAM)&nsd);

    if (IDOK == nResult)
    {
        SCHED_LIST_DATA *psld;
        LV_FINDINFO lvfi = { 0 };
        HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);

        lvfi.flags = LVFI_STRING;
        lvfi.psz = nsd.szSchedName;

        int index = ListView_FindItem(hwndSchedList, -1, &lvfi);

        if (index == -1)
        {

            psld = new SCHED_LIST_DATA;           
            
            if (NULL != psld)
            {
                psld->SchedCookie = nsd.SchedCookie;
                psld->bChecked = TRUE;
                psld->bStartChecked = FALSE;

                LV_ITEM lvItem = { 0 };

                lvItem.mask = LVIF_TEXT | LVIF_PARAM;
                lvItem.iItem = 0;
                lvItem.lParam = (LPARAM)psld;
                lvItem.pszText = nsd.szSchedName;

                index = ListView_InsertItem(hwndSchedList, &lvItem);
            }
        }
        else
        {
            psld = SchedList_GetData(hwndSchedList, index);
            if (NULL != psld)
            {
                psld->bChecked = TRUE;
            }
        }

        if (index != -1)
        {
            ListView_SetItemState(hwndSchedList, index, COMP_CHECKED, LVIS_STATEIMAGEMASK);
            ListView_SetColumnWidth(hwndSchedList, 0, LVSCW_AUTOSIZE);
            CheckRadioButton(hdlg, IDC_MANUAL_SYNC, IDC_SCHEDULED_SYNC, 
                             IDC_SCHEDULED_SYNC);
            SchedList_Select(hwndSchedList, index);
            Sched_EnableScheduleButtons(hdlg);
        }

    }

    SendMessage(hdlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hdlg, IDC_SCHEDULE_LIST), TRUE);

    return nResult == IDOK;
}

BOOL Sched_EditSchedule(HWND hdlg, POOEBuf pBuf)
{
    HRESULT hr;
    ISyncScheduleMgr *pSyncScheduleMgr;

    ASSERT(NULL != pBuf);

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {

        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL, 
                              IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

        if (SUCCEEDED(hr))
        {   
            HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);
            int index = ListView_GetNextItem(hwndSchedList, -1, LVNI_ALL | LVNI_SELECTED);
            SCHED_LIST_DATA *psld = SchedList_GetData(hwndSchedList, index);

            if (NULL != psld)
            {
                ISyncSchedule *pSyncSchedule;

                hr = pSyncScheduleMgr->OpenSchedule(&psld->SchedCookie, 0, &pSyncSchedule);

                if (SUCCEEDED(hr))
                {
                    if (psld->bChecked)
                    {
                        hr = pSyncSchedule->SetItemCheck(CLSID_WebCheckOfflineSync,
                                                         &pBuf->m_Cookie,
                                                         SYNCMGRITEMSTATE_CHECKED);
                    }
                    
                    hr = pSyncSchedule->EditSyncSchedule(hdlg, 0);

                    if (S_OK == hr)
                    {
                        psld->bChecked = IsCookieOnSchedule(pSyncSchedule, &pBuf->m_Cookie);

                        if (psld->bChecked)
                        {
                            CheckRadioButton(hdlg, IDC_MANUAL_SYNC, IDC_SCHEDULED_SYNC, 
                                             IDC_SCHEDULED_SYNC);
                        }

                        ListView_SetItemState(hwndSchedList, index, 
                                              psld->bChecked ? COMP_CHECKED : COMP_UNCHECKED, 
                                              LVIS_STATEIMAGEMASK);
                    }

                    WCHAR wszScheduleName[MAX_PATH];
                    DWORD cchScheduleName = ARRAYSIZE(wszScheduleName);

                    if (SUCCEEDED(pSyncSchedule->GetScheduleName(&cchScheduleName, wszScheduleName)))
                    {

                    #ifdef UNICODE
                        SchedList_SetName(hwndSchedList, index, wszScheduleName);
                    #else
                        char szScheduleName[MAX_PATH];

                        SHUnicodeToAnsi(wszScheduleName, szScheduleName, ARRAYSIZE(szScheduleName));
                        SchedList_SetName(hwndSchedList, index, wszScheduleName);
                    #endif

                        ListView_SetColumnWidth(hwndSchedList, 0, LVSCW_AUTOSIZE);
                    }


                    SendMessage(hdlg, WM_NEXTDLGCTL, (WPARAM)hwndSchedList, TRUE);

                    pSyncSchedule->Release();
                }
                pSyncScheduleMgr->Release();
            }
        }
        CoUninitialize();
    }

    //  This is not undoable by hitting cancel so don't say we changed.
    return FALSE;
}

BOOL Sched_RemoveSchedule(HWND hdlg)
{
    HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);
    int index = ListView_GetNextItem(hwndSchedList, -1, LVNI_ALL | LVNI_SELECTED);

    if (index >= 0)
    {
        SCHED_LIST_DATA *psld = SchedList_GetData(GetDlgItem(hdlg, IDC_SCHEDULE_LIST), index);

        if (NULL != psld)
        {
            TCHAR szSchedName[MAX_PATH];

            SchedList_GetName(hwndSchedList, index, szSchedName, ARRAYSIZE(szSchedName));

            if (WCMessageBox(hdlg, IDS_CONFIRM_SCHEDULE_DELETE,
                            IDS_SCHEDULE_DELETE_CAPTION, MB_YESNO | MB_ICONQUESTION,
                            szSchedName) == IDYES)
            {
                HRESULT hr = CoInitialize(NULL);
                if (SUCCEEDED(hr))
                {
                    ISyncScheduleMgr *pSyncScheduleMgr;
                    hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL, 
                                          IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

                    if (SUCCEEDED(hr))
                    {                
                        hr = pSyncScheduleMgr->RemoveSchedule(&psld->SchedCookie);

                        ASSERT(SUCCEEDED(hr));

                        if (SUCCEEDED(hr))
                        {
                            SchedList_DeleteData(hwndSchedList, -1, TRUE);
                            SchedList_Select(hwndSchedList, 0);
                        }

                        pSyncScheduleMgr->Release();
                    }
                    CoUninitialize();
                }
            }

            SendMessage(hdlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hdlg, IDC_SCHEDULE_LIST), TRUE);
        }
    }
    //  This is not undoable by hitting cancel so don't say we changed.
    return FALSE;
}

BOOL Sched_OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bHandled = TRUE;
    BOOL bChanged = FALSE;
    POOEBuf pBuf = GetBuf(hdlg);

    if (NULL != pBuf)
    {

        switch (wID)
        {
            case IDC_MANUAL_SYNC:
            case IDC_SCHEDULED_SYNC:
//            case IDC_IDLE_ONLY:
                if (wNotifyCode == BN_CLICKED)
                {
                    bChanged = TRUE;
                }
                break;
            
            case IDC_SCHEDULE_NEW:
                if (wNotifyCode == BN_CLICKED)
                {
                    bChanged = Sched_NewSchedule(hdlg);
                }
                break;

            case IDC_SCHEDULE_EDIT:
                if (wNotifyCode == BN_CLICKED)
                {
                    bChanged = Sched_EditSchedule(hdlg, pBuf);
                }
                break;

            case IDC_SCHEDULE_REMOVE:
                if (wNotifyCode == BN_CLICKED)
                {
                    bChanged = Sched_RemoveSchedule(hdlg);
                }
                break;

            default:
                bHandled = FALSE;
                break;
        }
    }

    if (bChanged)
    {
        PropSheet_Changed(GetParent(hdlg), hdlg);        
    }

    return bHandled;
}

BOOL Sched_Validate(HWND hdlg, POOEBuf pBuf)
{
/*
    if (IsDlgButtonChecked(hdlg, IDC_IDLE_ONLY))
    {
        pBuf->grfTaskTrigger |= TASK_FLAG_START_ONLY_IF_IDLE;
    }
    else
    {
        pBuf->grfTaskTrigger &= ~TASK_FLAG_START_ONLY_IF_IDLE;
    }
*/

    if (IsDlgButtonChecked(hdlg, IDC_SCHEDULED_SYNC))
    {
        HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);
        int count = ListView_GetItemCount(hwndSchedList);

        BOOL bHaveASchedule = FALSE;
        
        for (int i = 0; i < count; i++)
        {
            SCHED_LIST_DATA *psld = SchedList_GetData(hwndSchedList, i);

            if (NULL != psld && psld->bChecked)
            {
                bHaveASchedule = TRUE;
                break;
            }
        }

        if (!bHaveASchedule)
        {
            CheckRadioButton(hdlg, IDC_MANUAL_SYNC, IDC_SCHEDULED_SYNC, 
                             IDC_MANUAL_SYNC);
        }
    }

    return TRUE;
}

BOOL Sched_ApplyProps(HWND hdlg, POOEBuf pBuf)
{
    BOOL bResult;
    HRESULT hr;

    pBuf->dwFlags = PROP_WEBCRAWL_ALL;

    bResult = SUCCEEDED(SaveBufferChange(pBuf, TRUE));

    if (bResult)
    {
        
        if (IsDlgButtonChecked(hdlg, IDC_MANUAL_SYNC))
        {
            SchedList_UncheckAll(GetDlgItem(hdlg, IDC_SCHEDULE_LIST));
            hr = RemoveItemFromAllSchedules(&pBuf->m_Cookie);

            ASSERT(SUCCEEDED(hr));
        }
        else
        {
            HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);
            int count = ListView_GetItemCount(hwndSchedList);
            
            for (int i = 0; i < count; i++)
            {
                SCHED_LIST_DATA *psld = SchedList_GetData(hwndSchedList, i);

                ASSERT(NULL != psld);

                if (NULL != psld)
                {
                    if (psld->bChecked != psld->bStartChecked)
                    {
                        if (psld->bChecked)
                        {
                            ISubscriptionItem *psi;

                            if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, 
                                                                     &pBuf->m_Cookie,
                                                                     &psi)))
                            {
                                SYNC_HANDLER_ITEM_INFO shii;

                                shii.handlerID = CLSID_WebCheckOfflineSync;
                                shii.itemID = pBuf->m_Cookie;
                                shii.hIcon = NULL;
                                MyStrToOleStrN(shii.wszItemName, 
                                               ARRAYSIZE(shii.wszItemName),
                                               pBuf->m_Name);
                                shii.dwCheckState = SYNCMGRITEMSTATE_CHECKED;

                                AddScheduledItem(&shii, &psld->SchedCookie);
                            }
                        }
                        else
                        {
                            RemoveScheduledItem(&pBuf->m_Cookie, &psld->SchedCookie);
                        }
                        psld->bStartChecked = psld->bChecked;
                    }
                }
            }
        }
    }

    return bResult;
}

BOOL Sched_OnNotify(HWND hdlg, int idCtrl, LPNMHDR pnmh)
{
    BOOL bHandled = TRUE;
    POOEBuf pBuf = GetBuf(hdlg);
    ASSERT(pBuf);
    
    switch (pnmh->code)
    {
        case PSN_KILLACTIVE:
            if (!Sched_Validate(hdlg, pBuf))
            {
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);
            }
            break;

        case PSN_APPLY:
            Sched_ApplyProps(hdlg, pBuf);
            break;

        case NM_DBLCLK:
            if (IDC_SCHEDULE_LIST == pnmh->idFrom)
            {
                Sched_EditSchedule(hdlg, pBuf);
            }
            break;
            
        case LVN_ITEMCHANGED:
        {
            NM_LISTVIEW *pnmlv = (NM_LISTVIEW *)pnmh;
            if ((pnmlv->iItem != -1) && 
                (pnmlv->uChanged & LVIF_STATE) &&
                ((pnmlv->uNewState ^ pnmlv->uOldState) & COMP_CHECKED))

            {
                SCHED_LIST_DATA *psld = SchedList_GetData(pnmh->hwndFrom, pnmlv->iItem);

                if (NULL != psld)
                {
                    psld->bChecked = (pnmlv->uNewState & COMP_CHECKED) ? TRUE : FALSE;

                    if (psld->bChecked)
                    {
                        CheckRadioButton(hdlg, IDC_MANUAL_SYNC, IDC_SCHEDULED_SYNC, 
                                         IDC_SCHEDULED_SYNC);
                    }
                    PropSheet_Changed(GetParent(hdlg), hdlg);
                }
            }

            if ((pnmlv->uChanged & LVIF_STATE) &&
                ((pnmlv->uNewState ^ pnmlv->uOldState) & LVIS_SELECTED))
            {
                Sched_EnableScheduleButtons(hdlg);
            }
            break;
        }

        default:
            bHandled = FALSE;
            break;
    }

    return bHandled;
}

void Sched_OnDestroy(HWND hdlg)
{
    HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);

    SchedList_DeleteAllData(hwndSchedList);
}

BOOL Sched_OnInitDialog(HWND hdlg, HWND hwndFocus, LPARAM lParam)
{
    ASSERT(NULL != ((LPPROPSHEETPAGE)lParam));
    ASSERT(NULL != ((LPPROPSHEETPAGE)lParam)->lParam);

    SetWindowLongPtr(hdlg, DWLP_USER, ((LPPROPSHEETPAGE)lParam)->lParam);

    //  Now read in values and populate the dialog
    POOEBuf pBuf = (POOEBuf)((LPPROPSHEETPAGE)lParam)->lParam;

/*    CheckDlgButton(hdlg, IDC_IDLE_ONLY, 
                   pBuf->grfTaskTrigger & TASK_FLAG_START_ONLY_IF_IDLE ?
                   1 : 0);
*/

    HWND hwndSchedList = GetDlgItem(hdlg, IDC_SCHEDULE_LIST);
    ListView_SetExtendedListViewStyle(hwndSchedList, LVS_EX_CHECKBOXES);

    LV_COLUMN lvc;
    lvc.mask = LVCF_FMT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.iSubItem = 0;
    ListView_InsertColumn(hwndSchedList, 0, &lvc);

    //  Now handle restrictions
    SetPropSheetFlags(pBuf, SHRestricted2W(REST_NoScheduledUpdates, NULL, 0), PSF_NO_SCHEDULED_UPDATES);
    SetPropSheetFlags(pBuf, SHRestricted2W(REST_NoEditingScheduleGroups, NULL, 0), PSF_NO_EDITING_SCHEDULES);

    BOOL bHasSchedules = Sched_FillScheduleList(hdlg, pBuf);
    
    if (pBuf->m_dwPropSheetFlags & PSF_NO_SCHEDULED_UPDATES)
    {
        EnableWindow(GetDlgItem(hdlg, IDC_SCHEDULE_LIST), FALSE);
        EnableWindow(GetDlgItem(hdlg, IDC_SCHEDULED_SYNC), FALSE);
        CheckRadioButton(hdlg, IDC_MANUAL_SYNC, IDC_SCHEDULED_SYNC, IDC_MANUAL_SYNC);
    }
    else
    {
        CheckRadioButton(hdlg, IDC_MANUAL_SYNC, IDC_SCHEDULED_SYNC, 
                         bHasSchedules ? IDC_SCHEDULED_SYNC : IDC_MANUAL_SYNC);
    }

    SchedList_Select(hwndSchedList, 0);

    //  Finally, do the enable/disable controls thing...
    Sched_EnableScheduleButtons(hdlg);

    return TRUE;
}

INT_PTR CALLBACK SchedulePropDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            bHandled = Sched_OnInitDialog(hdlg, (HWND)wParam, lParam);
            break;

        case WM_COMMAND:
            bHandled = Sched_OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

        case WM_NOTIFY:
            bHandled = Sched_OnNotify(hdlg, (int)wParam, (LPNMHDR)lParam);
            break;

        case WM_DESTROY:
            Sched_OnDestroy(hdlg);
            //  return 0
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;
    }
    
    return bHandled;
}

/********************************************************************************
    Download property sheet code
*********************************************************************************/

void Download_EnableFollowLinks(HWND hdlg)
{
    BOOL bTranslate;
    int i = GetDlgItemInt(hdlg, IDC_LEVELS, &bTranslate, FALSE);

    EnableWindow(GetDlgItem(hdlg, IDC_FOLLOW_LINKS), (bTranslate && i));
}

void Download_EnableLimitSpaceControls(HWND hdlg)
{
    static const int IDs[] = { IDC_LIMIT_SPACE_EDIT, IDC_LIMIT_SPACE_SPIN, IDC_LIMIT_SPACE_TEXT };
    EnableControls(hdlg, IDs, ARRAYSIZE(IDs), IsDlgButtonChecked(hdlg, IDC_LIMIT_SPACE_CHECK));
}

void Download_EnableEmailControls(HWND hdlg)
{
    static const int IDs[] = { IDC_EMAIL_ADDRESS_TEXT, IDC_EMAIL_ADDRESS, 
                               IDC_EMAIL_SERVER_TEXT, IDC_EMAIL_SERVER };
    EnableControls(hdlg, IDs, ARRAYSIZE(IDs), IsDlgButtonChecked(hdlg, IDC_EMAIL_NOTIFY));
}

BOOL Download_OnInitDialog(HWND hdlg, HWND hwndFocus, LPARAM lParam)
{
    POOEBuf pBuf;

    ASSERT(NULL != ((LPPROPSHEETPAGE)lParam));
    ASSERT(NULL != ((LPPROPSHEETPAGE)lParam)->lParam);

    SetWindowLongPtr(hdlg, DWLP_USER, ((LPPROPSHEETPAGE)lParam)->lParam);

    //  First do basic control setup
    HWND hwndLimitSpin = GetDlgItem(hdlg, IDC_LIMIT_SPACE_SPIN);
    SendMessage(hwndLimitSpin, UDM_SETRANGE, 0, 
                MAKELONG(MAX_DOWNLOAD_K, MIN_DOWNLOAD_K));

    UDACCEL ua[] = { {0, 1}, {1, 10}, {2, 100}, {3, 1000} };
    SendMessage(hwndLimitSpin, UDM_SETACCEL, ARRAYSIZE(ua), (LPARAM)ua);

    Edit_LimitText(GetDlgItem(hdlg, IDC_LIMIT_SPACE_EDIT), 5);

    //  Now read in values and populate the dialog
    pBuf = (POOEBuf)((LPPROPSHEETPAGE)lParam)->lParam;

    SUBSCRIPTIONTYPE subType = GetItemCategory(pBuf);
    switch (subType)
    {
        case SUBSTYPE_CHANNEL:
        case SUBSTYPE_DESKTOPCHANNEL:
            CheckRadioButton(hdlg, IDC_DOWNLOAD_ALL, IDC_DOWNLOAD_MIN,
                             pBuf->fChannelFlags & CHANNEL_AGENT_PRECACHE_ALL ? 
                             IDC_DOWNLOAD_ALL : IDC_DOWNLOAD_MIN);
            break;

        case SUBSTYPE_URL:
        case SUBSTYPE_DESKTOPURL:
        case SUBSTYPE_EXTERNAL:
        {
            HWND hwndLevelsSpin = GetDlgItem(hdlg, IDC_LEVELS_SPIN);
            SendMessage(hwndLevelsSpin, UDM_SETRANGE, 0, MAKELONG(MAX_WEBCRAWL_LEVELS, 0));
            SendMessage(hwndLevelsSpin, UDM_SETPOS, 0, pBuf->m_RecurseLevels);
            CheckDlgButton(hdlg, IDC_FOLLOW_LINKS, 
                           (pBuf->m_RecurseFlags & WEBCRAWL_LINKS_ELSEWHERE) || (0 == pBuf->m_RecurseLevels)
                           ? 1 : 0);
            Download_EnableFollowLinks(hdlg);
            break;
        }
    }

    SendMessage(hwndLimitSpin, UDM_SETPOS, 0, pBuf->m_SizeLimit ? pBuf->m_SizeLimit : DEF_DOWNLOAD_K);
    CheckDlgButton(hdlg, IDC_LIMIT_SPACE_CHECK, pBuf->m_SizeLimit ? 1 : 0);

    CheckDlgButton(hdlg, IDC_EMAIL_NOTIFY, pBuf->bMail ? 1 : 0);

    TCHAR szText[MAX_PATH];

    ReadDefaultEmail(szText, ARRAYSIZE(szText));
    Edit_LimitText(GetDlgItem(hdlg, IDC_EMAIL_ADDRESS), MAX_PATH - 1);
    SetDlgItemText(hdlg, IDC_EMAIL_ADDRESS, szText);

    ReadDefaultSMTPServer(szText, ARRAYSIZE(szText));
    Edit_LimitText(GetDlgItem(hdlg, IDC_EMAIL_SERVER), MAX_PATH - 1);
    SetDlgItemText(hdlg, IDC_EMAIL_SERVER, szText);

    //  Now handle restrictions
    if (SHRestricted2W(REST_NoSubscriptionPasswords, NULL, 0))
    {
        EnableWindow(GetDlgItem(hdlg, IDC_LOGIN), FALSE);
    }

    //  Finally, do the enable/disable controls thing...
    Download_EnableLimitSpaceControls(hdlg);
    Download_EnableEmailControls(hdlg);

    return TRUE;
}

BOOL Download_OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bHandled = TRUE;
    BOOL bChanged = FALSE;
    POOEBuf pBuf = GetBuf(hdlg);

    if (NULL != pBuf)
    {
        switch (wID)
        {
            case IDC_LIMIT_SPACE_EDIT:
                if (wNotifyCode == EN_CHANGE)
                {
                    if (pBuf->m_SizeLimit != 
                        LOWORD(SendDlgItemMessage(hdlg, IDC_LIMIT_SPACE_SPIN, UDM_GETPOS, 0, 0)))
                    {
                        bChanged = TRUE;
                    }
                }
                else if (wNotifyCode == EN_KILLFOCUS)
                {
                    KeepSpinNumberInRange(hdlg, IDC_LIMIT_SPACE_EDIT, 
                                          IDC_LIMIT_SPACE_SPIN, 
                                          MIN_DOWNLOAD_K, MAX_DOWNLOAD_K);
                }
                break;
            
            case IDC_LEVELS:
                if (wNotifyCode == EN_UPDATE)
                {
                    int levels = KeepSpinNumberInRange(hdlg, IDC_LEVELS, 
                                    IDC_LEVELS_SPIN, 0, MAX_WEBCRAWL_LEVELS);

                    if (pBuf->m_RecurseLevels != levels)
                    {
                        bChanged = TRUE;
                    }
                    Download_EnableFollowLinks(hdlg);
                }
                break;

            case IDC_LIMIT_SPACE_CHECK:
                if (wNotifyCode == BN_CLICKED)
                {
                    Download_EnableLimitSpaceControls(hdlg);
                    bChanged = TRUE;
                }
                break;
                
            case IDC_FOLLOW_LINKS:
                if (wNotifyCode == BN_CLICKED)
                {
                    bChanged = TRUE;
                }
                break;

            case IDC_EMAIL_NOTIFY:
                if (wNotifyCode == BN_CLICKED)
                {
                    Download_EnableEmailControls(hdlg);
                    bChanged = TRUE;
                }
                break;
                
            case IDC_EMAIL_ADDRESS:
            case IDC_EMAIL_SERVER:
                if (wNotifyCode == EN_CHANGE)
                {
                    bChanged = TRUE;
                }
                break;

            case IDC_LOGIN:
                if ((wNotifyCode == BN_CLICKED) &&
                    (DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SUBSPROPS_LOGIN),
                                    hdlg, LoginOptionDlgProc, (LPARAM)pBuf) == IDOK))
                {
                    bChanged = TRUE;
                }
                break;

            case IDC_ADVANCED:
                if ((wNotifyCode == BN_CLICKED) &&
                    (DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SUBSPROPS_ADVANCED),
                                    hdlg, AdvancedDownloadDlgProc, (LPARAM)pBuf) == IDOK))
                {
                    bChanged = TRUE;
                }
                break;

            default:
                bHandled = FALSE;
                break;
        }
    }

    if (bChanged)
    {
        PropSheet_Changed(GetParent(hdlg), hdlg);        
    }

    return bHandled;
}

BOOL Download_Validate(HWND hdlg, POOEBuf pBuf)
{
    pBuf->bMail = IsDlgButtonChecked(hdlg, IDC_EMAIL_NOTIFY);

    if (pBuf->bMail)
    {
        TCHAR szEmail[MAX_PATH];
        TCHAR szServer[MAX_PATH];

        GetDlgItemText(hdlg, IDC_EMAIL_ADDRESS, szEmail, ARRAYSIZE(szEmail));
        GetDlgItemText(hdlg, IDC_EMAIL_SERVER, szServer, ARRAYSIZE(szServer));

        if (!szEmail[0] || !szServer[0])
        {
            SGMessageBox(hdlg, IDS_EMAIL_INCOMPLETE, MB_ICONWARNING);
            return FALSE;
        }
    }

    SUBSCRIPTIONTYPE subType = GetItemCategory(pBuf);
    switch (subType)
    {
        case SUBSTYPE_CHANNEL:
        case SUBSTYPE_DESKTOPCHANNEL:
            pBuf->fChannelFlags &= ~(CHANNEL_AGENT_PRECACHE_SOME | CHANNEL_AGENT_PRECACHE_ALL);
            if (IsDlgButtonChecked(hdlg, IDC_DOWNLOAD_ALL))
            {
                pBuf->fChannelFlags |= CHANNEL_AGENT_PRECACHE_ALL;
            }
            else
            {
                pBuf->fChannelFlags |= CHANNEL_AGENT_PRECACHE_SOME;
            }
            break;

        case SUBSTYPE_URL:
        case SUBSTYPE_DESKTOPURL:
        case SUBSTYPE_EXTERNAL:
        {
            if (IsDlgButtonChecked(hdlg, IDC_FOLLOW_LINKS))
            {
                pBuf->m_RecurseFlags |= WEBCRAWL_LINKS_ELSEWHERE;
            }
            else
            {
                pBuf->m_RecurseFlags &= ~WEBCRAWL_LINKS_ELSEWHERE;
            }

            pBuf->m_RecurseLevels = LOWORD(SendDlgItemMessage(hdlg, 
                                           IDC_LEVELS_SPIN, UDM_GETPOS, 0, 0));

            ASSERT((pBuf->m_RecurseLevels >= 0) &&
                   (pBuf->m_RecurseLevels <= MAX_WEBCRAWL_LEVELS));
        }
    }

    pBuf->m_SizeLimit = IsDlgButtonChecked(hdlg, IDC_LIMIT_SPACE_CHECK) ? 
                        (LONG)SendDlgItemMessage(hdlg, IDC_LIMIT_SPACE_SPIN,
                                           UDM_GETPOS, 0, 0) : 
                        0;
    ASSERT((0 == pBuf->m_SizeLimit) ||
           ((pBuf->m_SizeLimit >= MIN_DOWNLOAD_K) && 
            (pBuf->m_SizeLimit <= MAX_DOWNLOAD_K)));

    return TRUE;
}

BOOL Download_ApplyProps(HWND hdlg, POOEBuf pBuf)
{
    pBuf->dwFlags = PROP_WEBCRAWL_ALL;

    if (IsDlgButtonChecked(hdlg, IDC_EMAIL_NOTIFY))
    {
        TCHAR szText[MAX_PATH];

        GetDlgItemText(hdlg, IDC_EMAIL_ADDRESS, szText, ARRAYSIZE(szText));
        WriteDefaultEmail(szText);
        GetDlgItemText(hdlg, IDC_EMAIL_SERVER, szText, ARRAYSIZE(szText));
        WriteDefaultSMTPServer(szText);
    }

    if (pBuf->bChannel)
    {
        pBuf->dwFlags |= PROP_WEBCRAWL_CHANNELFLAGS;
    }

    return SUCCEEDED(SaveBufferChange(pBuf, TRUE));
}

BOOL Download_OnNotify(HWND hdlg, int idCtrl, LPNMHDR pnmh)
{
    BOOL bHandled = TRUE;
    POOEBuf pBuf = GetBuf(hdlg);
    ASSERT(pBuf);
    
    switch (pnmh->code)
    {
        case PSN_KILLACTIVE:
            if (!Download_Validate(hdlg, pBuf))
            {
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);
            }
            break;

        case PSN_APPLY:
            Download_ApplyProps(hdlg, pBuf);
            break;

        default:
            bHandled = FALSE;
            break;
    }

    return bHandled;
}

INT_PTR CALLBACK DownloadPropDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            bHandled = Download_OnInitDialog(hdlg, (HWND)wParam, lParam);
            break;

        case WM_COMMAND:
            bHandled = Download_OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

        case WM_NOTIFY:
            bHandled = Download_OnNotify(hdlg, (int)wParam, (LPNMHDR)lParam);
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;
    }
    
    return bHandled;
}

/********************************************************************************
    New schedule popup code
*********************************************************************************/

BOOL NewSched_OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bHandled = FALSE;
    
    switch (wID)
    {
        case IDC_SCHEDULE_DAYS:
            if (wNotifyCode == EN_UPDATE)
            {
                KeepSpinNumberInRange(hdlg, IDC_SCHEDULE_DAYS, 
                                      IDC_SCHEDULE_DAYS_SPIN, 1, 99);
            }
#ifdef NEWSCHED_AUTONAME
            else if (wNotifyCode == EN_CHANGE)
            {
                NewSched_AutoNameHelper(hdlg);
            }
#endif
            bHandled = TRUE;
            break;

        case IDOK:
        {
            TASK_TRIGGER trig;
            NEWSCHED_DATA *pnsd = (NEWSCHED_DATA*) GetWindowLongPtr(hdlg, DWLP_USER);

            ASSERT(NULL != pnsd);
            
            if (NewSched_ResolveNameConflictHelper(hdlg, &trig, &pnsd->SchedCookie))
            {
                NewSched_CreateScheduleHelper(hdlg, &trig, &pnsd->SchedCookie);

                GetDlgItemText(hdlg, IDC_SCHEDULE_NAME, 
                               pnsd->szSchedName, ARRAYSIZE(pnsd->szSchedName));
                EndDialog(hdlg, IDOK);
            }
            break;
        }


        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        default:
            break;
    }

    return bHandled;
}

#ifdef NEWSCHED_AUTONAME
BOOL NewSched_OnNotify(HWND hdlg, int idCtrl, LPNMHDR pnmh)
{
    BOOL bHandled = TRUE;

    switch (pnmh->code)
    {
        case DTN_DATETIMECHANGE:
            NewSched_AutoNameHelper(hdlg);
            break;
            
        default:
            bHandled = FALSE;
            break;
    }

    return bHandled;
}
#endif

INT_PTR CALLBACK NewScheduleDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hdlg, DWLP_USER, lParam);
            NewSched_OnInitDialogHelper(hdlg);
            bHandled = TRUE;
            break;
        }

        case WM_COMMAND:
            bHandled = NewSched_OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

#ifdef NEWSCHED_AUTONAME
        case WM_NOTIFY:
            bHandled = NewSched_OnNotify(hdlg, wParam, (LPNMHDR)lParam);
            break;            
#endif

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;
    }

    return bHandled;
}


/********************************************************************************
    Advanced properties code
*********************************************************************************/

BOOL Advanced_OnInitDialog(HWND hdlg, HWND hwndFocus, LPARAM lParam)
{
    POOEBuf pBuf;

    ASSERT(NULL != (POOEBuf)lParam);

    SetWindowLongPtr(hdlg, DWLP_USER, lParam);

    pBuf = (POOEBuf)lParam;

    UINT flags = pBuf->m_RecurseFlags;
    CheckDlgButton(hdlg, IDC_DOWNLOAD_IMAGES, flags & WEBCRAWL_GET_IMAGES);
    CheckDlgButton(hdlg, IDC_DOWNLOAD_APPLETS, flags & WEBCRAWL_GET_CONTROLS);
    CheckDlgButton(hdlg, IDC_DOWNLOAD_MEDIA, 
                   flags & (WEBCRAWL_GET_BGSOUNDS | WEBCRAWL_GET_VIDEOS));

    CheckDlgButton(hdlg, IDC_DOWNLOAD_ONLY_HTML_LINKS, flags & WEBCRAWL_ONLY_LINKS_TO_HTML);

    return TRUE;
}

void Advanced_SetFlag(HWND hdlg, POOEBuf pBuf, int ID, LONG flags)
{
    if (IsDlgButtonChecked(hdlg, ID))
    {
        pBuf->m_RecurseFlags |= flags;
    }
    else
    {
        pBuf->m_RecurseFlags &= ~flags;
    }
}

BOOL Advanced_OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bHandled = TRUE;
    POOEBuf pBuf = GetBuf(hdlg);
    ASSERT(pBuf);

    switch (wID)
    {
        case IDOK:
            Advanced_SetFlag(hdlg, pBuf, IDC_DOWNLOAD_IMAGES, WEBCRAWL_GET_IMAGES);
            Advanced_SetFlag(hdlg, pBuf, IDC_DOWNLOAD_APPLETS, WEBCRAWL_GET_CONTROLS);
            Advanced_SetFlag(hdlg, pBuf, IDC_DOWNLOAD_MEDIA, 
                             WEBCRAWL_GET_BGSOUNDS | WEBCRAWL_GET_VIDEOS);
            Advanced_SetFlag(hdlg, pBuf, IDC_DOWNLOAD_ONLY_HTML_LINKS, WEBCRAWL_ONLY_LINKS_TO_HTML);
            EndDialog(hdlg, IDOK);
            break;

        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        case IDC_DOWNLOAD_IMAGES:
        case IDC_DOWNLOAD_APPLETS:
        case IDC_DOWNLOAD_MEDIA:
        case IDC_DOWNLOAD_ONLY_HTML_LINKS:
            break;

        default:
            bHandled = FALSE;
            break;
    }

    return bHandled;
}

INT_PTR CALLBACK AdvancedDownloadDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = FALSE;

    switch (message)
    {

        case WM_INITDIALOG:
            bHandled = Advanced_OnInitDialog(hdlg, (HWND)wParam, lParam);
            break;

        case WM_COMMAND:
            bHandled = Advanced_OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;
            
        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;
    }
    
    return bHandled;
}

/********************************************************************************
    Login properties code
*********************************************************************************/

BOOL Login_OnInitDialog(HWND hdlg, HWND hwndFocus, LPARAM lParam)
{
    POOEBuf pBuf;

    ASSERT(NULL != (POOEBuf)lParam);

    SetWindowLongPtr(hdlg, DWLP_USER, lParam);

    pBuf = (POOEBuf)lParam;

    Edit_LimitText(GetDlgItem(hdlg, IDC_USERNAME), ARRAYSIZE(pBuf->username) - 1);
    SetDlgItemText(hdlg, IDC_USERNAME, pBuf->username);

    Edit_LimitText(GetDlgItem(hdlg, IDC_PASSWORD), ARRAYSIZE(pBuf->password) - 1);
    SetDlgItemText(hdlg, IDC_PASSWORD, pBuf->password);

    Edit_LimitText(GetDlgItem(hdlg, IDC_PASSWORDCONFIRM), ARRAYSIZE(pBuf->password) - 1);
    SetDlgItemText(hdlg, IDC_PASSWORDCONFIRM, pBuf->password);

    return TRUE;
}

BOOL Login_OnCommand(HWND hdlg, WORD wNotifyCode, WORD wID, HWND hwndCtl)
{
    BOOL bHandled = TRUE;
    POOEBuf pBuf = GetBuf(hdlg);
    ASSERT(pBuf);

    switch (wID)
    {
        case IDOK:
        {
            TCHAR szUsername[ARRAYSIZE(pBuf->username) + 1];
            TCHAR szPassword[ARRAYSIZE(pBuf->password) + 1];
            TCHAR szPasswordConfirm[ARRAYSIZE(pBuf->password) + 1];

            GetDlgItemText(hdlg, IDC_USERNAME, szUsername, ARRAYSIZE(szUsername));
            GetDlgItemText(hdlg, IDC_PASSWORD, szPassword, ARRAYSIZE(szPassword));
            GetDlgItemText(hdlg, IDC_PASSWORDCONFIRM, szPasswordConfirm, ARRAYSIZE(szPasswordConfirm));

            if (!szUsername[0] && (szPassword[0] || szPasswordConfirm[0]))
            {
                SGMessageBox(hdlg, 
                            (pBuf->bChannel ? IDS_NEEDCHANNELUSERNAME : IDS_NEEDUSERNAME), 
                            MB_ICONWARNING);
            }
            else if (szUsername[0] && !szPassword[0])
            {
                SGMessageBox(hdlg, 
                            (pBuf->bChannel ? IDS_NEEDCHANNELPASSWORD : IDS_NEEDPASSWORD), 
                            MB_ICONWARNING);
            }
            else if (StrCmp(szPassword, szPasswordConfirm) != 0)
            {
                SGMessageBox(hdlg, IDS_MISMATCHED_PASSWORDS, MB_ICONWARNING);
            }
            else
            {
                StrCpyN(pBuf->username, szUsername, ARRAYSIZE(pBuf->username));
                StrCpyN(pBuf->password, szPassword, ARRAYSIZE(pBuf->password));
                pBuf->dwFlags |= (PROP_WEBCRAWL_UNAME | PROP_WEBCRAWL_PSWD);
                EndDialog(hdlg, IDOK);
            }
            break;
        }
 
        case IDCANCEL:
            EndDialog(hdlg, IDCANCEL);
            break;

        default:
            bHandled = FALSE;
            break;
    }

    return bHandled;
}

INT_PTR CALLBACK LoginOptionDlgProc(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bHandled = FALSE;

    switch (message)
    {

        case WM_INITDIALOG:
            bHandled = Login_OnInitDialog(hdlg, (HWND)wParam, lParam);
            break;

        case WM_COMMAND:
            bHandled = Login_OnCommand(hdlg, HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, c_szHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)aHelpIDs);
            bHandled = TRUE;
            break;
    }
    
    return bHandled;
}

//
// Read the users default email address and smtp from the Athena Account Mgr
//
// Expects lpszEmailAddress and lpszSMTPServer to pt to char buffers of 
// CCHMAX_EMAIL_ADDRESS and CCHMAX_SERVER_NAME size, resp.
//
BOOL ReadAthenaMailSettings(LPSTR lpszEmailAddress, LPSTR lpszSMTPServer)
{
    //
    // This api gets called from threads that haven't used COM before so wrap
    // in CoInitialize/CoUninitialize
    //
    HRESULT hr = CoInitialize(NULL);
    ASSERT(SUCCEEDED(hr));

    //
    // Create an Internet Mail and News Account Manager
    //
    IImnAccountManager * pAccountManager;
    hr = CoCreateInstance(
        CLSID_ImnAccountManager,
        NULL,                       // no aggregation
        CLSCTX_INPROC_SERVER,       // inproc server implemented in webcheck.dll
        IID_IImnAccountManager,     //
        (void **)&pAccountManager);

    if (SUCCEEDED(hr)) {
        hr = pAccountManager->Init(NULL);

        if (SUCCEEDED(hr)) {
            //
            // Get the default SMTP account
            //
            IImnAccount * pAccount;
            hr = pAccountManager->GetDefaultAccount(ACCT_MAIL, &pAccount);

            if (hr == S_OK) {               
                //
                // Get the SMTP_SERVER name for this account
                //
                if (NULL != lpszSMTPServer)
                {
                    hr = pAccount->GetPropSz(
                        AP_SMTP_SERVER, 
                        lpszSMTPServer,
                        CCHMAX_SERVER_NAME);
                }
                
                //
                // Get the Users email address for this account
                //

                if (NULL != lpszEmailAddress)
                {
                    hr |= pAccount->GetPropSz(
                        AP_SMTP_EMAIL_ADDRESS, 
                        lpszEmailAddress,
                        CCHMAX_EMAIL_ADDRESS);
                }

                pAccount->Release();    // done with IImnAccount
            }
        }
        pAccountManager->Release();     // done with IImnAccountManager
    }

    //
    // This api gets called from threads that haven't used COM before so wrap
    // in CoInitialize/CoUninitialize
    //
    CoUninitialize();

    if (hr == S_OK)
        return TRUE;
    else
        return FALSE;
}

void ReadDefaultEmail(LPTSTR szBuf, UINT cch)
{
    ASSERT(szBuf);

    szBuf[0] = (TCHAR)0;
    if(ReadRegValue(HKEY_CURRENT_USER, c_szRegKey, c_szDefEmail, szBuf, cch * sizeof(TCHAR)))
        return;

    //  TODO: Look for eudora/netscape as well
    CHAR szEmailAddress[CCHMAX_EMAIL_ADDRESS];
    if (ReadAthenaMailSettings(szEmailAddress, NULL))
    {
        SHAnsiToTChar(szEmailAddress, szBuf, cch);
    }
}

void WriteDefaultEmail(LPTSTR szBuf)
{
    ASSERT(szBuf);
    WriteRegValue(HKEY_CURRENT_USER, c_szRegKey, c_szDefEmail, szBuf, (lstrlen(szBuf) + 1) * sizeof(TCHAR), REG_SZ);
}

void ReadDefaultSMTPServer(LPTSTR szBuf, UINT cch)
{
    ASSERT(szBuf);

    szBuf[0] = (TCHAR)0;
    if(ReadRegValue(HKEY_CURRENT_USER, c_szRegKey, c_szDefServer, szBuf, cch * sizeof(TCHAR)))
        return;

    //  TODO: Look for eudora/netscape as well
    CHAR szSMTPServer[CCHMAX_SERVER_NAME];
    if (ReadAthenaMailSettings(NULL, szSMTPServer))
    {
        SHAnsiToTChar(szSMTPServer, szBuf, cch);
    }
}

void WriteDefaultSMTPServer(LPTSTR szBuf)
{
    ASSERT(szBuf);
    WriteRegValue(HKEY_CURRENT_USER, c_szRegKey, c_szDefServer, szBuf, (lstrlen(szBuf) + 1) * sizeof(TCHAR), REG_SZ);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wc.rc
//

#define CONTEXT_MENU_OFFLINE            2001

#define IDA_DOWNLOAD                    113

#define IDB_IDLE                        1000
#define IDB_SUBSCRIBE                   1001
#define IDB_SUBSCRIPTION_WIZARD         1002
#define IDB_SUMCHAN                     1003
#define IDB_TB_SMALL                    1004
#define IDB_UNSUBSCRIBE                 1005

#define IDCMD_ABORT                     3000
#define IDCMD_DETAILS                   3001
#define IDCMD_HIDE                      3002
#define IDCMD_SKIP                      3003

#define IDC_ADVANCED                    2000
#define IDC_AGENTSTATUS                 2001
#define IDC_CUSTOM_DAILY                2002
#define IDC_CUSTOM_DAILY_EVERYNDAYS     2003
#define IDC_CUSTOM_DAILY_EVERYNDAYS_EDIT 2004
#define IDC_CUSTOM_DAILY_EVERYNDAYS_SPIN 2005
#define IDC_CUSTOM_DAILY_EVERYWEEKDAY   2006
#define IDC_CUSTOM_DAILY_STATIC1        2007
#define IDC_CUSTOM_GROUP_DAILY          2008
#define IDC_CUSTOM_GROUP_DEST           2009
#define IDC_CUSTOM_GROUP_EDIT           2010
#define IDC_CUSTOM_GROUP_LIST           2011
#define IDC_CUSTOM_GROUP_MONTHLY        2012
#define IDC_CUSTOM_GROUP_WEEKLY         2013
#define IDC_CUSTOM_MINIMIZENETUSE       2014
#define IDC_CUSTOM_MONTHLY              2015
#define IDC_CUSTOM_MONTHLY_DAYOFMONTH   2016
#define IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_EDIT 2017
#define IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_SPIN 2018
#define IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_EDIT 2019
#define IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_SPIN 2020
#define IDC_CUSTOM_MONTHLY_PERIODIC     2021
#define IDC_CUSTOM_MONTHLY_PERIODIC_EDIT 2022
#define IDC_CUSTOM_MONTHLY_PERIODIC_LIST1 2023
#define IDC_CUSTOM_MONTHLY_PERIODIC_LIST2 2024
#define IDC_CUSTOM_MONTHLY_PERIODIC_SPIN 2025
#define IDC_CUSTOM_MONTHLY_STATIC1      2026
#define IDC_CUSTOM_MONTHLY_STATIC2      2027
#define IDC_CUSTOM_MONTHLY_STATIC3      2028
#define IDC_CUSTOM_MONTHLY_STATIC4      2029
#define IDC_CUSTOM_NEWGROUP             2030
#define IDC_CUSTOM_NEXTUPDATE           2031
#define IDC_CUSTOM_REMOVEGROUP          2032
#define IDC_CUSTOM_TIME_REPEATBETWEEN   2033
#define IDC_CUSTOM_TIME_REPEATBETWEEN_END_TIME 2034
#define IDC_CUSTOM_TIME_REPEATBETWEEN_START_TIME 2035
#define IDC_CUSTOM_TIME_REPEATEVERY     2036
#define IDC_CUSTOM_TIME_REPEATEVERY_EDIT 2037
#define IDC_CUSTOM_TIME_REPEATEVERY_SPIN 2038
#define IDC_CUSTOM_TIME_UPDATEAT        2039
#define IDC_CUSTOM_TIME_UPDATEAT_TIME   2040
#define IDC_CUSTOM_WEEKLY               2041
#define IDC_CUSTOM_WEEKLY_DAY1          2042
#define IDC_CUSTOM_WEEKLY_DAY2          2043
#define IDC_CUSTOM_WEEKLY_DAY3          2044
#define IDC_CUSTOM_WEEKLY_DAY4          2045
#define IDC_CUSTOM_WEEKLY_DAY5          2046
#define IDC_CUSTOM_WEEKLY_DAY6          2047
#define IDC_CUSTOM_WEEKLY_DAY7          2048
#define IDC_CUSTOM_WEEKLY_REPEATWEEKS_EDIT 2049
#define IDC_CUSTOM_WEEKLY_REPEATWEEKS_SPIN 2050
#define IDC_CUSTOM_WEEKLY_STATIC1       2051
#define IDC_CUSTOM_WEEKLY_STATIC2       2052
#define IDC_DESKTOP_SUMMARY_TEXT        2053
#define IDC_DISABLE_AUTODISCONNECT      2054
#define IDC_DONTASKAGAIN                2055
#define IDC_DOWNLOAD_APPLETS            2056
#define IDC_DOWNLOAD_EXTERNALLINKS      2057
#define IDC_DOWNLOAD_IMAGES             2058
#define IDC_DOWNLOAD_MAXSIZE            2059
#define IDC_DOWNLOAD_MEDIA              2060
#define IDC_DRTRUNNING                  2061
#define IDC_DRTSTATUS                   2062
#define IDC_EMAIL_ADDRESS               2063
#define IDC_EMAIL_ADDRESS_TEXT          2064
#define IDC_EMAIL_NOTIFY                2065
#define IDC_EMAIL_SERVER                2066
#define IDC_EMAIL_SERVER_TEXT           2067
#define IDC_FOLLOW_LINKS                2068
#define IDC_GENERAL_PROMPT              2069
#define IDC_GENPROP_SCHED               2070
#define IDC_GENPROP_SUBSTYPE            2071
#define IDC_GENPROP_TYPEST              2072
#define IDC_GENPROP_UPDATEST            2073
#define IDC_GRP                         2074
//#define IDC_IDLE_ONLY                   2075
#define IDC_LAST                        2076
#define IDC_LAST_HEADING                2077
#define IDC_LEVELS                      2078
#define IDC_LEVELS_SPIN                 2079
#define IDC_LIMITSIZE                   2080
#define IDC_LIMIT_SPACE_CHECK           2081
#define IDC_LIMIT_SPACE_EDIT            2082
#define IDC_LIMIT_SPACE_SPIN            2083
#define IDC_LIMIT_SPACE_TEXT            2084
#define IDC_LOCATION                    2085
#define IDC_LOCSTATIC                   2086
#define IDC_LOGIN                       2087
#define IDC_LOGIN_PROMPT                2088
#define IDC_MANUAL_SYNC                 2089
#define IDC_MINBORDER                   2090
#define IDC_NAME                        2091
#define IDC_NAMESTATIC                  2092
#define IDC_NEXT                        2093
#define IDC_NEXT_HEADING                2094
#define IDC_PASSWORD                    2096
#define IDC_PROMPT_SUBSCRIBEME          2097
#define IDC_RESULT                      2098
#define IDC_RESULT_HEADING              2099
#define IDC_SCHEDULED_SYNC              2100
#define IDC_SCHEDULESUMMARY             2101
#define IDC_SCHEDULE_DAYS               2102
#define IDC_SCHEDULE_DAYS_SPIN          2103
#define IDC_SCHEDULE_EDIT               2104
#define IDC_SCHEDULE_LIST               2105
#define IDC_SCHEDULE_NAME               2106
#define IDC_SCHEDULE_NEW                2107
#define IDC_SCHEDULE_REMOVE             2108
#define IDC_SCHEDULE_TIME               2109
#define IDC_SIZENODETAILS               2110
#define IDC_STATISTICS                  2111
#define IDC_SUBSCRIBE_ADI_NAME          2112
#define IDC_SUBSCRIBE_ADI_URL           2113
#define IDC_SUBSCRIBE_CUSTOMIZE         2114
#define IDC_SUBSCRIBE_LINKDEPTH         2115
#define IDC_SUBSCRIBE_LINKDEPTH_SPIN    2116
#define IDC_TIME_REMAINING              2117
#define IDC_TX1                         2118
#define IDC_TX2                         2119
#define IDC_TX3                         2120
#define IDC_URL                         2121
#define IDC_USERNAME                    2122
#define IDC_WARNING1                    2123
#define IDC_WARNING2                    2124
#define IDC_WIZ_DONT_SHOW_INTRO         2125
#define IDC_WIZ_GET_LINKS_TEXT          2126
#define IDC_WIZ_INTRO_DETAILS_TEXT      2127
#define IDC_WIZ_INTRO_NEXT_TEXT         2128
#define IDC_WIZ_LINKS_YES               2129
#define IDC_WIZ_LINKS_NO                2130
#define IDC_WIZ_MADE_OFFLINE_TEXT       2131
#define IDC_WIZ_SCHEDULE_NONE           2132
#define IDC_WIZ_SCHEDULE_NEW            2133
#define IDC_WIZ_SCHEDULE_EXISTING       2134
#define IDC_WIZ_SCHEDULE_LIST           2135
#define IDC_WIZ_SCHED_DETAILS_TEXT      2136
#define IDC_WIZ_SCHED_QUESTION_TEXT     2137
#define IDC_WIZ_WHEN_TO_SYNC_TEXT       2138
#define IDC_DOWNLOAD_ALL                2139
#define IDC_DOWNLOAD_MIN                2140
#define IDC_PASSWORDCONFIRM             2141
#define IDC_USENEW                      2142
#define IDC_USEOLD                      2143
#define IDC_RENAME                      2144
#define IDC_SCHEDULE_MESSAGE            2145
#define IDC_FRIENDLY_SCHEDULE_TEXT      2146
#define IDC_NEW_SETTINGS                2147
#define IDC_OLD_SETTINGS                2148
#define IDC_CONTENT_GROUPBOX            2149
#define IDC_DOWNLOAD_PAGES_LABEL1       2150
#define IDC_DOWNLOAD_PAGES_LABEL2       2151
#define IDC_EMAIL_GROUPBOX              2152
#define IDC_LOGIN_LABEL                 2153
#define IDC_USERNAME_LABEL              2154
#define IDC_PASSWORD_LABEL              2155
#define IDC_SCHEDULE_LABEL1             2156
#define IDC_SCHEDULE_LABEL2             2157
#define IDC_SCHEDULE_NAME_TEXT          2158
#define IDC_SCHEDULE_TEXT               2159
#define IDC_ADVANCED_GROUPBOX           2160
#define IDC_ICONEX2                     2161
#define IDC_URL_TEXT                    2162
#define IDC_VISITS_TEXT                 2163
#define IDC_VISITS                      2164
#define IDC_MAKE_OFFLINE                2165
#define IDC_SUMMARY                     2166
#define IDC_LAST_SYNC_TEXT              2167
#define IDC_LAST_SYNC                   2168
#define IDC_DOWNLOAD_SIZE_TEXT          2169
#define IDC_DOWNLOAD_SIZE               2170
#define IDC_DOWNLOAD_RESULT_TEXT        2171
#define IDC_DOWNLOAD_RESULT             2172
#define IDC_PASSWORD_NO                 2174
#define IDC_PASSWORD_YES                2175
#define IDC_LOGIN_PROMPT_CHANNEL        2176
#define IDC_LOGIN_PROMPT_URL            2177
#define IDC_PASSWORDCONFIRM_LABEL       2178
#define IDC_DOWNLOAD_ONLY_HTML_LINKS    2179
//#define IDC_CACHE_LIMIT_MESSAGE         2180
//#define IDI_CACHE_LIMIT_REACHED         2181
//#define IDC_CACHE_LIMIT_NOASK           2182
#define IDC_FREESPACE_TEXT              2183
#define IDC_WIZ_LINKSDEEP_STATIC1       2184
#define IDC_WIZ_LINKSDEEP_STATIC2       2185
#define IDC_WIZ_LINKSDEEP_EDIT          2186
#define IDC_WIZ_LINKSDEEP_SPIN          2187
#define IDC_WIZ_SCHEDULE_AUTOCONNECT    2188
#define IDC_SCHEDULE_LABEL3             2189

#define IDD_ANIMATE                     110

#define IDD_APP_EXIT_PROMPT             6000
#define IDD_DESKTOP_SUBSCRIPTION_SUMMARY 6002
#define IDD_DISCONNECT_PROMPT           6003
#define IDD_OBJECTDEL_WARNING           6007
#define IDD_PROBAR                      6008
#define IDD_SPLITTER                    6010
#define IDD_SUBSCRIPTION_ENABLECHANNELSAVER 6011
#define IDD_SUBSPROPS_ADVANCED          6013
#define IDD_SUBSPROPS_LOGIN             6014
#define IDD_SUBSPROPS_DOWNLOAD_CHANNEL  6015
#define IDD_SUBSPROPS_DOWNLOAD_URL      6016
#define IDD_SUBSPROPS_SCHEDULE          6017
#define IDD_WIZARD0                     6018
#define IDD_WIZARD1                     6019
#define IDD_WIZARD2                     6020
#define IDD_WIZARD3                     6021
#define IDD_WIZARD4                     6022
#define IDD_DUPLICATE_SCHEDULE          6024
#define IDD_NEW_SCHEDULE                6025
#define IDD_SUBSPROPS_SUMMARY           6026
//#define IDD_CACHE_LIMIT_REACHED         6028

#define IDI_WEBCHECK                    114
#define IDI_STAT_SUCCEEDED              115
#define IDI_STAT_FAILED                 116
#define IDI_STAT_UPDATING               117
#define IDI_DISCONNECT                  118
#define IDI_STAT_PENDING                119
#define IDI_STAT_SKIPPED                120
#define IDI_CHANNEL                     121
#define IDI_GLEAMED                     122
#define IDI_SCHEDULE                    123
#define IDI_DESKTOPITEM                 160
#define IDI_IDLE                        162
#define IDI_BUSY                        163
#define IDI_NOTIFICATION                197
#define IDI_DOWNLOAD                    198
#define IDI_ICON                        400
#define IDI_WEBDOC                      400
#define IDI_OFFLINEICON                 401
#define IDI_OBJECTDELETED               402
#define IDI_TRAYICON                    403
#define IDI_SCREENSAVER                 407
#define IDI_GROUP                       251

#define IDL_SUBSCRIPTION                1171

#define IDS_ABORTING                    8000
#define IDS_AGNT_EMAILMESSAGE           8001
#define IDS_AGNT_HTMLBREAK              8002
#define IDS_AGNT_HTMLBREAKSINGLE        8003
#define IDS_AGNT_HTMLMESSAGETEXT        8004
#define IDS_AGNT_HTMLMESSAGETEXT2       8005
#define IDS_AGNT_HTMLMESSAGEWRAPPER     8006
#define IDS_AGNT_MAPIMESSAGE            8007
#define IDS_AGNT_MAPIMESSAGE_OTHER      8008
#define IDS_AGNT_MAPISUBJECT            8009
#define IDS_AGNT_MAPISUBJECT_OTHER      8010
#define IDS_AGNT_SMTPMESSAGE            8011
#define IDS_AGNT_SMTPMESSAGE_OTHER      8012
#define IDS_AGNT_STATUS_CACHELIMIT      8013
#define IDS_AGNT_STATUS_SIZELIMIT       8014
#define IDS_AGNT_TEXTBREAK              8015
#define IDS_APP_EXIT_TEXT               8016
#define IDS_BEEN_DISCONNECTED           8018
#define IDS_CANCELDL                    8019
#define IDS_CAPTION_ERROR_CONNECTING    8020
#define IDS_CAPTION_NOTHING_TO_UPDATE   8021
#define IDS_CDLAGENT_ERROR_EMAIL        8022
#define IDS_CDLAGENT_FAILURE            8023
#define IDS_CDLAGENT_SUCCESS            8024
#define IDS_CDLAGENT_TRUST_ERROR        8025
#define IDS_CHANNEL_FOLDER              8030
#define IDS_CRAWL_STATUS_MOSTLYOK       8032
#define IDS_CRAWL_STATUS_NOT_OK         8033
#define IDS_CRAWL_STATUS_OK             8034
#define IDS_CRAWL_STATUS_UNCHANGED      8035
//#define IDS_CUSTOM_ERROR_NAMEEXISTS     8036
//#define IDS_CUSTOM_ERROR_NAMEREQUIRED   8037
//#define IDS_CUSTOM_ERROR_NAMETOOLONG    8038
#define IDS_DAILY_GRO                   8044
#define IDS_DEL_MULTIPLE_FMT            8046
#define IDS_DESKTOPCHANNEL_SUMMARY_NOPW 8047
#define IDS_DESKTOPCHANNEL_SUMMARY_TEXT 8048
#define IDS_DETAILS                     8049
#define IDS_DETAIL_COL                  8050
#define IDS_DIAL_ALREADY_CONNECTED      8051
#define IDS_DIAL_DIRECT                 8052
#define IDS_DIAL_FAILURE                8053
#define IDS_DIAL_PROXY                  8054
#define IDS_DIAL_SUCCESS                8055
#define IDS_DISCONNECT_DLG_TEXT         8056
//#define IDS_DOWNLOAD_ABORT_WARNING      8060
#define IDS_GROUP_COL                   8076
#define IDS_HIGH_PRI                    8077
#define IDS_HTTPONLY                    8078

//#define IDS_ITEM_STAT_UPDATING_URL      8089

#define IDS_LAST_COL                    8090
#define IDS_LEVELLIMIT                  8091
#define IDS_LOGINTEXT1                  8092
#define IDS_LOGINTEXT2                  8093
#define IDS_LOW_PRI                     8095
#define IDS_NAME_COL                    8103
#define IDS_NEEDCHANNELPASSWORD         8104
#define IDS_NEEDCHANNELUSERNAME         8105
#define IDS_NEEDEMAILINFO               8106
#define IDS_NEEDPASSWORD                8107
#define IDS_NEEDUNATTENDEDINFO          8108
#define IDS_NEEDUSERNAME                8109
#define IDS_NEXT_COL                    8111
#define IDS_NODETAILS                   8112
#define IDS_NONE                        8113
#define IDS_NORMAL_PRI                  8114
#define IDS_NO_SUBSCRIPTIONS            8116
#define IDS_PRI_FIRST                   8121
#define IDS_RESTRICTED                  8124
#define IDS_RNADLL_FILENAME             8125
#define IDS_SCREENSAVEREXE              8137
#define IDS_SESSIONEND                  8138
#define IDS_SHOWPROG                    8139
#define IDS_SIZELIMIT                   8143
#define IDS_SIZE_COL                    8144
#define IDS_SIZE_KB                     8145
#define IDS_SOFTWAREUPDATE_FOLDER       8146
#define IDS_STATISTICS                  8147
#define IDS_STATUS_ABORTED              8148
#define IDS_STATUS_AUTHFAILED           8149
#define IDS_STATUS_BAD_URL              8150
#define IDS_STATUS_COL                  8151
#define IDS_STATUS_DIAL_FAIL            8152
#define IDS_STATUS_NOT_OK               8153
#define IDS_STATUS_OK                   8154
#define IDS_STATUS_OUTOFMEMORY          8155
#define IDS_STATUS_UNCHANGED            8156
#define IDS_STRING_E_CONFIG             8157
#define IDS_STRING_E_FAILURE            8158
#define IDS_STRING_E_SECURITYCHECK      8159
#define IDS_STRING_NOTHING_TO_UPDATE    8160
#define IDS_SUMMARY_MANUAL              8177
#define IDS_SYNCMGR_NAME                8190
#define IDS_TARGET_CHARSET_EMAIL        8191
#define IDS_TRAY_TOOLTIP                8192
#define IDS_UNKNOWN                     8195
#define IDS_UPDATE_SUBS                 8197
#define IDS_URL_COL                     8198
#define IDS_URL_STATUS_NOT_OK           8199
#define IDS_URL_STATUS_OK               8200
#define IDS_URL_STATUS_UNCHANGED        8201
#define IDS_VIEW_SUBS                   8203
#define IDS_WEEK1                       8205
#define IDS_WEEK2                       8206
#define IDS_WEEK3                       8207
#define IDS_WEEK4                       8208
#define IDS_WEEK5                       8209
#define IDS_WEEKLY_GRO                  8210
#define IDS_WIZ_GET_LINKS_CHANNEL       8214
#define IDS_WIZ_GET_LINKS_URL           8215
#define IDS_WIZ_INTRO_DETAILS_CHANNEL   8216
#define IDS_WIZ_INTRO_DETAILS_URL       8217
#define IDS_WIZ_INTRO_NEXT_CHANNEL      8218
#define IDS_WIZ_INTRO_NEXT_URL          8219
#define IDS_WIZ_MADE_OFFLINE_CHANNEL    8220
#define IDS_WIZ_MADE_OFFLINE_URL        8221
#define IDS_WIZ_SCHED_DETAILS_CHANNEL   8222
#define IDS_WIZ_SCHED_DETAILS_URL       8223
#define IDS_WIZ_SCHED_QUESTION_CHANNEL  8224
#define IDS_WIZ_SCHED_QUESTION_URL      8225
#define IDS_WIZ_WHEN_TO_SYNC_CHANNEL    8226
#define IDS_WIZ_WHEN_TO_SYNC_URL        8227
#define IDS_EMAIL_INCOMPLETE            8228
#define IDS_RECOMMENDED_SCHEDULE_FORMAT 8229
#define IDS_CONFIRM_SCHEDULE_DELETE     8230
#define IDS_MISMATCHED_PASSWORDS        8231
#define IDS_SCHED_FORMAT                8232
#define IDS_SCHED_CONFLICT_FORMAT       8233
#define IDS_NO_SCHEDULE_SELECTED        8234
#define IDS_SCHED_FORMAT_DAILY          8236
#define IDS_DEFAULT_MSG_CAPTION         8237
#define IDS_SCHEDULE_DELETE_CAPTION     8239
#define IDS_VALUE_UNKNOWN               8240
#define IDS_DELETE_CAPTION              8241
#define IDS_UPDATE_PAUSED               8244
#define IDS_UPDATE_RESUMING             8245
#define IDS_EMPTY_SCHEDULE_NAME         8246
#define IDS_NONULLNAME                  8247
#define IDS_RENAME                      8248
#define IDS_CACHELIMIT_TITLE            8249
#define IDS_CACHELIMIT_MESSAGE          8250
#define IDS_CRAWL_ROBOTS_TXT_WARNING    8251

#define IDS_SCHEDULED_UPDATES_DISABLED      8300
#define IDS_SCHEDULED_UPDATES_RESTRICTED    8301
#define IDS_SCHEDULED_UPDATE_INTERVAL       8302
#define IDS_SCHEDULED_EXCLUDE_RANGE         8303

#define IDS_SB_FIRST                    8600
#define IDS_SB_OPEN                     IDS_SB_FIRST + RSVIDM_OPEN
#define IDS_SB_UPDATE                   IDS_SB_FIRST + RSVIDM_UPDATE
#define IDS_SB_RENAME                   IDS_SB_FIRST + RSVIDM_RENAME
#define IDS_SB_COPY                     IDS_SB_FIRST + RSVIDM_COPY
#define IDS_SB_DELETE                   IDS_SB_FIRST + RSVIDM_DELETE
#define IDS_SB_PROPERTIES               IDS_SB_FIRST + RSVIDM_PROPERTIES
#define IDS_SB_WORKOFFLINE              IDS_SB_FIRST + RSVIDM_WORKOFFLINE
#define IDS_SB_UPDATEALL                IDS_SB_FIRST + RSVIDM_UPDATEALL
#define IDS_SB_SORTBYNAME               IDS_SB_FIRST + RSVIDM_SORTBYNAME
#define IDS_SB_HELP                     IDS_SB_FIRST + RSVIDM_HELP

#define MENU_OFFLINE_BRONLY             2003
#define MENU_OFFLINE_TOP                2000

#define POPUP_CONTEXT_VERBSONLY         301
#define POPUP_OFFLINE_CONTEXT           300
#define POPUP_RESTRICTED_CONTEXT        302

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         40000
#define _APS_NEXT_CONTROL_VALUE         1030
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\rsrchdr.h ===
// This file contains resource contants that would get munged by MSDEV. 

#define RSVIDM_FIRST                    0
#define RSVIDM_OPEN                     RSVIDM_FIRST+0
#define RSVIDM_UPDATE                   RSVIDM_FIRST+1
#define RSVIDM_RENAME                   RSVIDM_FIRST+2
#define RSVIDM_COPY                     RSVIDM_FIRST+3
#define RSVIDM_DELETE                   RSVIDM_FIRST+4
#define RSVIDM_PROPERTIES               RSVIDM_FIRST+5
#define RSVIDM_WORKOFFLINE              RSVIDM_FIRST+7
#define RSVIDM_UPDATEALL                RSVIDM_FIRST+8
#define RSVIDM_PASTE                    RSVIDM_FIRST+9
#define RSVIDM_SORTBYNAME               RSVIDM_FIRST+10
#define RSVIDM_HELP                     RSVIDM_FIRST+20

#define IDI_SUBSCRIBE			IDI_TRAYICON
#define IDI_SITE			IDI_TRAYICON
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\postagnt.cpp ===
// 
// Pei-Hwa Lin (peiwhal), Feb 3, 1997
//

#include "private.h"
#include "downld.h"
#include "urlmon.h"

#undef TF_THISMODULE
#define TF_THISMODULE   TF_POSTAGENT

// Advanced inetcpl setting to disable channel logging
const TCHAR c_szNoChannelLogging[] = TEXT("NoChannelLogging");

const char c_szHeaders[] = "Content-Type: application/x-www-form-urlencoded\r\n";
#define c_ccHearders  (ARRAYSIZE(c_szHeaders) - 1)

#define ENCODE_LOG
#ifdef ENCODE_LOG
const char c_szEncodeHeader[] = "Content-Transfer-Encoding: x-";
#define c_ccEncodeHeader (ARRAYSIZE(c_szEncodeHeader) - 1)
#endif  //ENCODE_LOG

// *** W3C extended log format *** //
// text strings definitions
const char c_szUrlFields[] = "#Fields: s-URI";
#define c_ccUrlFields  (ARRAYSIZE(c_szUrlFields) - 1)

const char c_szLogFields[] = "#Fields: x-context x-cache x-date x-time x-duration x-meta";
#define c_ccLogFields  (ARRAYSIZE(c_szLogFields) - 1);
// *** W3C extended log format *** //

const TCHAR c_szPostRetryReg[] = TEXT("PostRetry");
const TCHAR c_szUserAgent[] = TEXT("User Agent");
extern TCHAR szInternetSettings[];

//-----------------------------------------------------------------------------
//
// CTrackingStg implementation
//
//-----------------------------------------------------------------------------

// this will empty log contents without removing the entry
//
HRESULT	CTrackingStg::EmptyCacheEntry(GROUPID enumId)
{
    HANDLE      hEnum, hFile;
    LPINTERNET_CACHE_ENTRY_INFOA lpCE = NULL;
    DWORD       cbSize;
    HRESULT     hr = S_OK;

    ASSERT(enumId);

    lpCE = (LPINTERNET_CACHE_ENTRY_INFOA)MemAlloc(LPTR, MY_MAX_CACHE_ENTRY_INFO);
    if (!lpCE)
        return E_OUTOFMEMORY;

    cbSize = MY_MAX_CACHE_ENTRY_INFO;
    hEnum = FindFirstUrlCacheEntryExA(_lpPfx,
                                     0,              //dwFlags
                                     URLCACHE_FIND_DEFAULT_FILTER,  //dwFilters,
                                     0,             //enumId, IE50:wininet change, not support group in extensible cache
                                     lpCE,
                                     &cbSize,
                                     NULL, NULL, NULL);

    if (hEnum)
    {
        FILETIME    ftModified;

        ftModified.dwHighDateTime = (DWORD)(enumId >> 32);
        ftModified.dwLowDateTime = (DWORD)(0x00000000ffffffff & enumId);
        for(;;)
        {
            if (lpCE->LastModifiedTime.dwLowDateTime == ftModified.dwLowDateTime &&
                lpCE->LastModifiedTime.dwHighDateTime == ftModified.dwHighDateTime)
            {
                hFile = OpenItemLogFile(lpCE->lpszLocalFileName);
                if (hFile != INVALID_HANDLE_VALUE)
                {
                    CloseHandle(hFile);
                    DeleteFileA(lpCE->lpszLocalFileName);

                    DeleteUrlCacheEntryA(lpCE->lpszSourceUrlName);
                    
                    TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];
                    SHAnsiToTChar(lpCE->lpszSourceUrlName, szUrl, ARRAYSIZE(szUrl));
                    CreateLogCacheEntry(szUrl, lpCE->ExpireTime,
                                         ftModified, lpCE->CacheEntryType);
                }

            }
            
            // reuse lpCE
            if (!FindNextUrlCacheEntryExA(hEnum, lpCE, &cbSize, NULL, NULL, NULL))
            {
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
                    break;
            }
        }

        FindCloseUrlCache(hEnum);
    }

    SAFELOCALFREE(lpCE);
    return hr;
}

// this will delete url cache entries 
// and delete url cache group
HRESULT	CTrackingStg::RemoveCacheEntry(GROUPID enumId)
{
    HANDLE      hEnum;
    LPINTERNET_CACHE_ENTRY_INFOA lpCE = NULL;
    DWORD       cbSize;
    PROPVARIANT vProp = {0};
    HRESULT     hr = S_OK;

    ASSERT(enumId);

    lpCE = (LPINTERNET_CACHE_ENTRY_INFOA)MemAlloc(LPTR, MY_MAX_CACHE_ENTRY_INFO);
    if (!lpCE)
        return E_OUTOFMEMORY;

    cbSize = MY_MAX_CACHE_ENTRY_INFO;
    hEnum = FindFirstUrlCacheEntryExA(_lpPfx,
                                     0,              //dwFlags
                                     URLCACHE_FIND_DEFAULT_FILTER,   //dwFilters,
                                     0,              //enumId, IE50: wininet change
                                     lpCE,
                                     &cbSize,
                                     NULL, NULL, NULL);

    if (hEnum)
    {
        FILETIME    ftModified;

        ftModified.dwHighDateTime = (DWORD)(enumId >> 32);
        ftModified.dwLowDateTime = (DWORD)(0x00000000ffffffff & enumId);
        for(;;)
        {
            if (lpCE->LastModifiedTime.dwLowDateTime == ftModified.dwLowDateTime &&
                lpCE->LastModifiedTime.dwHighDateTime == ftModified.dwHighDateTime)
            {
                DeleteUrlCacheEntryA(lpCE->lpszSourceUrlName);
                vProp.vt = VT_UI4;
                vProp.ulVal = 0;            // clear tracking flag

                TCHAR szUrl[INTERNET_MAX_URL_LENGTH];
                SHAnsiToTChar(lpCE->lpszSourceUrlName+lstrlenA(_lpPfx), szUrl, ARRAYSIZE(szUrl));
                hr = IntSiteHelper(szUrl,
                                   &c_rgPropRead[PROP_TRACKING], &vProp, 1, TRUE);
                PropVariantClear( &vProp );        
            }
            
            // reuse lpCE
            if (!FindNextUrlCacheEntryExA(hEnum, lpCE, &cbSize, NULL, NULL, NULL))
            {
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
                    break;
            }
        }

        FindCloseUrlCache(hEnum);
    }

    SAFELOCALFREE(lpCE);
    return hr;
}

HANDLE CTrackingStg::OpenItemLogFile(LPCSTR lpFile)
{
   HANDLE   hFile = NULL;

    hFile = CreateFileA(lpFile, 
                GENERIC_READ | GENERIC_WRITE,
                0,                              //no sharing
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

    return hFile;
}

DWORD CTrackingStg::ReadLogFile(LPCSTR lpFile, LPSTR* lplpbuf)
{
    HANDLE  hFile = NULL;
    DWORD   cbFile = 0;
    DWORD   cbRead;

    hFile = OpenItemLogFile(lpFile);
    if (hFile == INVALID_HANDLE_VALUE) 
        return 0;

    cbFile = GetFileSize(hFile, NULL);
    if (cbFile == 0xFFFFFFFF)
    {
        CloseHandle(hFile);
        return 0;
    }
        
    *lplpbuf = (LPSTR)MemAlloc(LPTR, (cbFile + 2) * sizeof(CHAR));
    cbRead = 0;
    if (!ReadFile(hFile, *lplpbuf, cbFile, &cbRead, NULL))
    {
        cbRead = 0;
    }    
        
    ASSERT((cbRead == cbFile));
    CloseHandle(hFile);
    return cbRead;
}


void CTrackingStg::AppendLogEntries(LPINTERNET_CACHE_ENTRY_INFOA lpce)
{
    LPSTR  lpbuf = NULL;
    DWORD   cbsize, cbWritten;
    
    cbsize = ReadLogFile(lpce->lpszLocalFileName, &lpbuf);
    cbWritten = 0;
    if (lpbuf && (cbsize > c_ccEmptyLog))   //change this threshold if modify
    {                                       //CreatePrefixedCacheEntry in trkcache.cpp
        AppendLogUrlField(lpce);            
        WriteFile(_hLogFile, lpbuf, cbsize, &cbWritten, NULL);
        ASSERT((cbsize == cbWritten));
    }

    SAFELOCALFREE(lpbuf);
    
    return;

}

void CTrackingStg::AppendLogUrlField(LPINTERNET_CACHE_ENTRY_INFOA lpce)
{
    DWORD dwWritten = 0;
    LPSTR lpbuf = NULL;
    DWORD cb;

    // lpce->lpszSourcesUrlName contains prefixed string
    DWORD cchAlloc = lstrlenA(lpce->lpszSourceUrlName) - lstrlenA(_lpPfx) + c_ccUrlFields 
                        + c_ccLogFields;
    cb = (cchAlloc + 7) * sizeof(CHAR);
    lpbuf = (LPSTR)MemAlloc(LPTR, cb);
    if (lpbuf)
    {
        wnsprintfA(lpbuf, cb, "%s\r\n%s\r\n%s\r\n", c_szUrlFields, 
                 lpce->lpszSourceUrlName+lstrlenA(_lpPfx), c_szLogFields);
        WriteFile(_hLogFile, lpbuf, lstrlenA(lpbuf), &dwWritten, NULL);
    }
    
    SAFELOCALFREE(lpbuf);
    return;
}

HRESULT CTrackingStg::Enumeration(LONGLONG enumId)
{
    HRESULT hr = E_FAIL;
    HANDLE  hEnum;
    LPINTERNET_CACHE_ENTRY_INFOA lpCE = NULL;

    lpCE = (LPINTERNET_CACHE_ENTRY_INFOA)MemAlloc(LPTR, MY_MAX_CACHE_ENTRY_INFO);
    if (!lpCE)
        return E_OUTOFMEMORY;

    DWORD   cbSize = MY_MAX_CACHE_ENTRY_INFO;
    hEnum = FindFirstUrlCacheEntryExA(_lpPfx,
                                    0,              //dwFlags
                                    URLCACHE_FIND_DEFAULT_FILTER,              //dwFilters,
                                    0,              //enumId, IE50: wininet change, not support group in extensible cache
                                    lpCE,
                                    &cbSize,
                                    NULL, NULL, NULL);

    if (hEnum)
    {
        FILETIME    ftModified;
    
        ftModified.dwHighDateTime = (DWORD)(enumId >> 32);
        ftModified.dwLowDateTime = (DWORD)(0x00000000ffffffff & enumId);
        for(;;)
        {
            if (!StrCmpNIA(lpCE->lpszSourceUrlName, _lpPfx, lstrlenA(_lpPfx))
                && lpCE->LastModifiedTime.dwLowDateTime == ftModified.dwLowDateTime 
                && lpCE->LastModifiedTime.dwHighDateTime == ftModified.dwHighDateTime)
            {    
                AppendLogEntries(lpCE);
            }
            
            // reuse lpCE
            cbSize = MY_MAX_CACHE_ENTRY_INFO;
            if (!FindNextUrlCacheEntryExA(hEnum, lpCE, &cbSize, NULL, NULL, NULL))
            {
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
                    break;
            }
        }

        FindCloseUrlCache(hEnum);
        hr = S_OK;
    }

    SAFELOCALFREE(lpCE);
    return hr;
}

HRESULT CTrackingStg::RetrieveLogData(ISubscriptionItem* pCDFItem)
{
    HRESULT hr = E_FAIL;

    // heck: wininet does not support multiple groups to same URL
    // have to enumerate new and old groups to cover
    GROUPID newId;

    ReadLONGLONG(pCDFItem, c_szTrackingCookie, &newId);
    if (newId)
    {
        hr = Enumeration(newId);
    }
    // heck: end

    hr = Enumeration(_groupId);

    CloseLogFile();
    return hr;
}

HRESULT CTrackingStg::RetrieveAllLogStream(ISubscriptionItem* pCDFItem, LPCSTR lpFile)
{
    HRESULT hr = E_FAIL;
    LPTSTR  lpPfx = ReadTrackingPrefix();

#ifdef UNICODE
    if (lpPfx)
    {
        int len = lstrlenW(lpPfx) + 1;
        
        _lpPfx = (LPSTR)MemAlloc(LPTR, len * sizeof(CHAR));

        if (_lpPfx)
        {
            SHUnicodeToAnsi(lpPfx, _lpPfx, len);
        }

        MemFree(lpPfx);
    }
#else
    _lpPfx = lpPfx;
#endif

    _hLogFile = CreateFileA(lpFile, 
                GENERIC_WRITE,
                0,                              //no sharing
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

    if (_hLogFile == INVALID_HANDLE_VALUE)      //turn-around is read into a buffer.
        return hr;

    hr = RetrieveLogData(pCDFItem);

    return S_OK;    
}

//  
//  Validate the Posting by
//  1. attempt to post this log does not exceed limits set in registry
//  2. the log itself is valid
//
BOOL CTrackingStg::IsExpired(ISubscriptionItem* pItem)
{
    BOOL    bret;
    DWORD   regRetry = 3;   // Intelligent default so we don't need the registry value set.
        
    ReadRegValue(HKEY_LOCAL_MACHINE, MY_WEBCHECK_POST_REG,
                     c_szPostRetryReg, (void *)&regRetry, sizeof(regRetry));
                     
    bret = (_dwRetry < regRetry) ? FALSE : TRUE;

    if (bret) return bret;

    // read the purgetime from subscription property bag
    DATE        dt = 0.0;

    if (SUCCEEDED(ReadDATE(pItem, c_szPostPurgeTime, &dt)) && dt != 0)
    {
        SYSTEMTIME  st, expiredst;
        FILETIME    ft, expiredft;

        VariantTimeToSystemTime(dt, &expiredst);
        SystemTimeToFileTime(&expiredst, &expiredft);

        GetLocalTime(&st);
        SystemTimeToFileTime(&st, &ft);

        bret = (CompareFileTime(&ft, &expiredft) > 0) ? TRUE : FALSE;
    }

    return bret;
}


CTrackingStg::CTrackingStg
(
)
{
    _pwszURL = NULL;
    _groupId = 0;
    _dwRetry = 0;
    _lpPfx = NULL;
}

CTrackingStg::~CTrackingStg()
{
    //
    // Release/delete any resources
    //
    DBG("CTrackingStg d'tor");

    SAFEFREEOLESTR(_pwszURL);
    SAFELOCALFREE(_lpPfx);
    
    if (_hLogFile)
        CloseHandle(_hLogFile);

}


//------------------------------------------------------------
//
// Private member functions
//
//------------------------------------------------------------

#if 0
void CALLBACK CWCPostAgent::PostCallback
(
    HINTERNET hInternet,
    DWORD     dwContext,
    DWORD     dwInternetStatus,
    LPVOID    lpvStatusInfo,
    DWORD     dwInfoLen
)
{
    DWORD dwLen;

    TraceMsg(TF_THISMODULE, "PostAgent Callback: of %d (looking for 31)", dwContext);
    if ( (dwInternetStatus == INTERNET_STATUS_REQUEST_SENT) && 
         (dwLen == (DWORD)lpvStatusInfo) )
    {
        OnUploadComplete();
    }
    else
        UpdateStatus();
}

#endif
//------------------------------------------------------------
//
//  CWCPostAgent implementation
//
//------------------------------------------------------------

//------------------------------------------------------------
// virtual functions overriding CDeliveryAgent
//------------------------------------------------------------

ISubscriptionMgr2 *
CWCPostAgent::GetSubscriptionMgr()
{
    ISubscriptionMgr2* pSubsMgr=NULL;

    CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                    IID_ISubscriptionMgr2, (void**)&pSubsMgr);

    return pSubsMgr;
}

//
// Re-stamp a set of tracking URLs from old group to new group
// without losing logging data
//
void
CWCPostAgent :: MergeGroupOldToNew()
{
    GROUPID newId;
    HANDLE  hEnum;
    LPINTERNET_CACHE_ENTRY_INFO lpCE = NULL;
    DWORD   cbSize;
    LPTSTR  lpPfx = NULL;

    newId = 0;
    ReadLONGLONG(_pCDFItem, c_szTrackingCookie, &newId);

    if (!newId && !_pUploadStream->_groupId)
        return;
    
    ASSERT(newId);

    lpCE = (LPINTERNET_CACHE_ENTRY_INFO)MemAlloc(LPTR, MY_MAX_CACHE_ENTRY_INFO);
    if (!lpCE)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return;
    }

    lpPfx = ReadTrackingPrefix();
    if (!lpPfx)
    {
        MemFree(lpCE);
        return;
    }

    cbSize = MY_MAX_CACHE_ENTRY_INFO;
    hEnum = FindFirstUrlCacheEntryEx(lpPfx,
                                    0,              //dwFlags
                                    URLCACHE_FIND_DEFAULT_FILTER,              //dwFilters,
                                    0,              //_pUploadStream->_groupId, IE50 changed
                                    lpCE,
                                    &cbSize,
                                    NULL, NULL, NULL);

    if (hEnum)
    {
        FILETIME    ftModified, ftOld;

        ftModified.dwHighDateTime = (DWORD)(newId >> 32);
        ftModified.dwLowDateTime = (DWORD)(0x00000000ffffffff & newId);
        ftOld.dwHighDateTime = (DWORD)(_pUploadStream->_groupId >> 32);
        ftOld.dwLowDateTime = (DWORD)(0x00000000ffffffff & _pUploadStream->_groupId);

        for(;;)
        {
            if (!StrCmpNI(lpCE->lpszSourceUrlName, lpPfx, lstrlen(lpPfx))
                && lpCE->LastModifiedTime.dwLowDateTime == ftOld.dwLowDateTime 
                && lpCE->LastModifiedTime.dwHighDateTime == ftOld.dwHighDateTime)
            {
                // commit changes to url cache
                lpCE->LastModifiedTime.dwHighDateTime = ftModified.dwHighDateTime;
                lpCE->LastModifiedTime.dwLowDateTime = ftModified.dwLowDateTime;
                
                SetUrlCacheEntryInfo(lpCE->lpszSourceUrlName, lpCE, CACHE_ENTRY_MODTIME_FC);
            }

            // reuse lpCE
            cbSize = MY_MAX_CACHE_ENTRY_INFO;
            if (!FindNextUrlCacheEntryEx(hEnum, lpCE, &cbSize, NULL, NULL, NULL))
            {
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
                    break;
            }
        }

        FindCloseUrlCache(hEnum);
    }

    SAFELOCALFREE(lpCE);
    return;
}

HRESULT CWCPostAgent::InitRequest
(
    LPCSTR lpszVerb
)
{
    char    hostName[INTERNET_MAX_HOST_NAME_LENGTH+1];
    char    userName[INTERNET_MAX_USER_NAME_LENGTH+1];
    char    password[INTERNET_MAX_PASSWORD_LENGTH+1];
    char    urlPath[INTERNET_MAX_PATH_LENGTH+1];
    URL_COMPONENTSA     uc;
    BOOL    bRet;
    LPSTR   pszPostURL;
    int     iLen;
    TCHAR   pszUA[128];
    HRESULT hr = E_FAIL;

    if ( !_pUploadStream->_pwszURL )
        return S_OK;             //do nothing if post url doesn't exist

    iLen = lstrlenW(_pUploadStream->_pwszURL) + 1;
    pszPostURL = new CHAR[iLen];
    if (!pszPostURL)
        return E_OUTOFMEMORY;

    SHUnicodeToAnsi(_pUploadStream->_pwszURL, pszPostURL, iLen);

    memset(&uc, 0, sizeof(URL_COMPONENTS));
    uc.dwStructSize = sizeof(URL_COMPONENTS);
    uc.lpszHostName = hostName;
    uc.dwHostNameLength = sizeof(hostName);
    uc.nPort = INTERNET_INVALID_PORT_NUMBER;
    uc.lpszUserName = userName;
    uc.dwUserNameLength = sizeof(userName);
    uc.lpszPassword = password;
    uc.dwPasswordLength = sizeof(password);
    uc.lpszUrlPath = urlPath;
    uc.dwUrlPathLength = sizeof(urlPath);
    
    bRet = InternetCrackUrlA(pszPostURL, lstrlenA(pszPostURL), 
                            ICU_DECODE, &uc);
    if (!bRet)
    {
        DBG("InternetCrackUrl failed");
        goto _exitInit;
    }

    // read User Agent string
    if (!ReadRegValue(HKEY_CURRENT_USER, szInternetSettings, c_szUserAgent, pszUA, sizeof(pszUA)))
        StrCpy(pszUA, TEXT("PostAgent"));

    _hSession = InternetOpen(pszUA,                  // used in User-Agent: header 
                            INTERNET_OPEN_TYPE_PRECONFIG,  //INTERNET_OPEN_TYPE_DIRECT, 
                            NULL,
                            NULL, 
                            //INTERNET_FLAG_ASYNC);  
                            0);         //synchronous operation

    if ( !_hSession )
    {
        DBG("!_hSession");
        goto _exitInit;
    }

    _hHttpSession = InternetConnectA(_hSession, 
                                    uc.lpszHostName,    //"peihwalap", 
                                    uc.nPort,           //INTERNET_INVALID_PORT_NUMBER,
                                    uc.lpszUserName,    //NULL, 
                                    uc.lpszPassword,    //NULL, 
                                    INTERNET_SERVICE_HTTP, 
                                    INTERNET_FLAG_KEEP_CONNECTION, 
                                    0); 
                                    //(DWORD)this); //dwContext.

//    InternetSetStatusCallback(m_hSession, CWCPostAgent::PostCallback);
                                
    if ( !_hHttpSession )
    {
        DBG( "!_hHttpSession");
        CloseRequest();
        goto _exitInit;
    }                                    
    

    // ignore security problem

    _hHttpRequest = HttpOpenRequestA(_hHttpSession, lpszVerb, 
                                    uc.lpszUrlPath,
                                    HTTP_VERSIONA, 
                                    NULL,                             //lpszReferer
                                    NULL,                             //lpszAcceptTyypes
                                    //INTERNET_FLAG_IGNORE_CERT_CN_INVALID |
                                    //INTERNET_FLAG_IGNORE_CERT_DATE_INVALID |
                                    //INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS |
                                    //INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP |
                                    INTERNET_FLAG_NO_COOKIES, 
                                    0);
                                    //(DWORD)this);	//dwContext
                            

    if ( !_hHttpRequest )
    {
        DBG_WARN("Post Agent: !_hHttpRequest");
        CloseRequest();
        goto _exitInit;
    }
    else
        hr = S_OK;


_exitInit:

    delete [] pszPostURL;
    return hr;
    
}                                                                
    
HRESULT CWCPostAgent::SendRequest
(
    LPCSTR     lpszHeaders,
    LPDWORD    lpdwHeadersLength,
    LPCSTR     lpszOption,
    LPDWORD    lpdwOptionLength
)
{
    BOOL bRet=FALSE;

    HttpAddRequestHeadersA(_hHttpRequest, 
                           (LPCSTR)c_szHeaders, 
                           (DWORD)-1L, 
                           HTTP_ADDREQ_FLAG_ADD);

    if (lpszHeaders && *lpszHeaders)        // don't bother if it's empty
        bRet = HttpAddRequestHeadersA(_hHttpRequest, 
                          (LPCSTR)lpszHeaders, 
                          *lpdwHeadersLength, 
                          HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE);
/*
    bRet = HttpSendRequest(_hHttpRequest, 
                          (LPCTSTR)lpszHeaders,           //HEADER_ENCTYPE, 
                          *lpdwHeadersLength,              //sizeof(HEADER_ENCTYPE), 
                          (LPVOID)lpszOption, 
                          *lpdwOptionLength);
*/
    bRet = HttpSendRequest(_hHttpRequest, 
                          NULL,                            //HEADER_ENCTYPE, 
                          0,                               //sizeof(HEADER_ENCTYPE), 
                          (LPVOID)lpszOption, 
                          *lpdwOptionLength);

    if ( !bRet )
    {
        DWORD dwLastError = GetLastError();

        TraceMsg(TF_ERROR, "HttpSendRequest failed: Error = %lx", dwLastError);
        DBG_WARN("Post Agent: HttpSendRequest failed");
        return E_FAIL;
    }

    DWORD dwBuffLen;
    TCHAR buff[1024];

    dwBuffLen = sizeof(buff);

    bRet = HttpQueryInfo(_hHttpRequest,
                        //HTTP_QUERY_CONTENT_TYPE,  //HTTP_QUERY_REQUEST_METHOD,
                        HTTP_QUERY_STATUS_CODE,   //HTTP_QUERY_RAW_HEADERS,
                        buff,
                        &dwBuffLen,
                        NULL);
 
    if ( !bRet )
    {
        DWORD dwLastError = GetLastError();

        TraceMsg(TF_ERROR, "HttpQueryInfo failed: Error = %lx", dwLastError);
        DBG_WARN("Post Agent: HttpQueryInfo failed");
    }
    else
    {
        int iretcode = StrToInt(buff);
        if (iretcode == 200)   // || iretcode == 100)   //HTTP_STATUS_OK
            return S_OK;             //100: too many semaphors
                                     //501: required not supported
                                     //502: bad gateway
    }

    return E_FAIL;    
}                                                                

HRESULT CWCPostAgent::CloseRequest
(
    void
)
{
    InternetCloseHandle(_hSession);
    _hSession = _hHttpSession = _hHttpRequest = 0;
    return S_OK;
}

// Called if upload failed
//   just increase retry number
HRESULT CWCPostAgent::OnPostFailed()
{
    WriteDWORD(_pCDFItem, c_szPostingRetry, _pUploadStream->_dwRetry+1);

    MergeGroupOldToNew();

    return S_OK;
}

// Called if upload succeeded
//   1) remove PostUrl from item
//   2) delete tracking cache entry  (Doh!)
HRESULT CWCPostAgent::OnPostSuccess()
{
    GROUPID newId = 0;

    if (!_pCDFItem)
        return E_INVALIDARG;

    ReadLONGLONG(_pCDFItem, c_szTrackingCookie, &newId);
    _pUploadStream->RemoveCacheEntry(_pUploadStream->_groupId);

    if (newId == _pUploadStream->_groupId)
    {
        BSTR  bstrURL = NULL;
        ReadBSTR(_pCDFItem, c_szTrackingPostURL, &bstrURL);
        if (!StrCmpIW(bstrURL, _pUploadStream->_pwszURL))
        {
            WriteOLESTR(_pCDFItem, c_szTrackingPostURL, bstrURL);
        }

        SAFEFREEBSTR(bstrURL);

    }
    else
        _pUploadStream->EmptyCacheEntry(newId);

    return S_OK;
}

HRESULT
CWCPostAgent::FindCDFStartItem()
{
    IServiceProvider    *pSP;
    
    if (_pCDFItem)
        return S_OK;
    
    if (SUCCEEDED(m_pAgentEvents->QueryInterface(IID_IServiceProvider, (void **)&pSP)) && pSP)
    {
        pSP->QueryService(CLSID_ChannelAgent, IID_ISubscriptionItem, (void **)&_pCDFItem);
        pSP->Release();
    }

    if (NULL == _pCDFItem)
    {
        TraceMsg(TF_THISMODULE, "PostAgent : FindCDFStartItem failed");
    }

    return (_pCDFItem) ? S_OK : E_NOINTERFACE;
}

HRESULT CWCPostAgent::DoFileUpload()
{
    HRESULT hr;
    DWORD   dwLen, dwHdr;

    SAFELOCALFREE(_pszPostStream);
    dwLen = _pUploadStream->ReadLogFile(_lpLogFile, &_pszPostStream);
    if (dwLen == 0)
    {
        // no log to post, should clean up cache entries for this group.
        OnPostSuccess();
        return S_OK;
    }
  
    if (FAILED(hr = InitRequest("POST")))
        return hr;

#ifdef ENCODE_LOG
    CHAR   lpEncodeHdr[c_ccEncodeHeader+MAX_PATH];

    lpEncodeHdr[0] = '\0';
    if (SUCCEEDED(ReadBSTR(m_pSubscriptionItem, c_szPostHeader, &_pwszEncoding)))
    {
        if (_pwszEncoding && *_pwszEncoding)
        {
            IEncodingFilterFactory* pEflt = NULL;
            IDataFilter*    pDF = NULL;
                 
            CoCreateInstance(CLSID_StdEncodingFilterFac, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IEncodingFilterFactory, (void**)&pEflt);

            if (pEflt)
            {
                pEflt->GetDefaultFilter(_pwszEncoding, L"text", &pDF);
                if (pDF)
                {
                    LONG lInUsed = 0;
                    LONG lOutUsed = 0;
                    LPSTR  pInBuf = _pszPostStream;
                    LPSTR  pOutBuf = NULL;
                    HRESULT hrCode = NOERROR;

                    pOutBuf = (LPSTR)MemAlloc(LPTR, dwLen);
                    if (pOutBuf == NULL)
                        goto do_upload;

                    hrCode = pDF->DoEncode(
                                            0,
                                            dwLen,
                                            (BYTE *)pInBuf, 
                                            dwLen,
                                            (BYTE *)pOutBuf, 
                                            dwLen,
                                            &lInUsed,
                                            &lOutUsed,
                                            0);

                    if (SUCCEEDED(hrCode))
                    {
                        // add encoding header information, e.g.
                        // "Content-Transfer-Encoding: x-gzip\r\n"
                        wnsprintfA(lpEncodeHdr, ARRAYSIZE(lpEncodeHdr), "%s%S\r\n", 
                                   c_szEncodeHeader, _pwszEncoding);
                        
                        SAFELOCALFREE(_pszPostStream);
                        _pszPostStream = (LPSTR)MemAlloc(LPTR, lOutUsed+2);
                        if (_pszPostStream)
                        {
                            memcpy(_pszPostStream, pOutBuf, lOutUsed);  //do I need to append CR?
                            dwLen = (DWORD)lOutUsed;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    pDF->Release();
                    SAFELOCALFREE(pOutBuf);
                }
                pEflt->Release();
            }
        }   // if (_pwszEncoding && *_pwszEncoding)

    }   //ReadBSTR


do_upload:
    dwHdr = lstrlenA(lpEncodeHdr);
    hr = SendRequest(lpEncodeHdr, &dwHdr, _pszPostStream, &dwLen);
#else
    dwHdr = lstrlenA("");
    hr = SendRequest(NULL, &dwHdr, _pszPostStream, &dwLen);
#endif  //ENCODE_LOG

    CloseRequest();

    if (FAILED(hr))
    {
        TraceMsg(TF_THISMODULE, "PostAgent failed to SendRequest");
        OnPostFailed();
    }
    else
    {
        TraceMsg(TF_THISMODULE, "PostAgent Posted data");
        OnPostSuccess();
    }


    return hr;
}

BOOL CWCPostAgent::GetTmpLogFileName()
{
    char   szPath[MAX_PATH];
    
    if (GetTempPathA(MAX_PATH, szPath) > 0)
    {
        _lpLogFile = (LPSTR)MemAlloc(LPTR, MAX_PATH+1);
        if (GetTempFileNameA(szPath, "trk", 0, _lpLogFile))
        {
            return TRUE;
        }
    }

    return FALSE;
}
    
HRESULT CWCPostAgent::DoPost()
{
    HRESULT hr = E_FAIL;
    
    _pUploadStream->_groupId = 0L;
    if (FAILED(ReadLONGLONG(m_pSubscriptionItem, c_szTrackingCookie, &_pUploadStream->_groupId)))
        return hr;

    if (FAILED(ReadDWORD(m_pSubscriptionItem, c_szPostingRetry, &_pUploadStream->_dwRetry)))
        _pUploadStream->_dwRetry = 0;

    if (_pUploadStream->IsExpired(m_pSubscriptionItem))
    {
        // post is expired, clean up log cache entries
        OnPostSuccess();
        return hr;
    }

    if (!GetTmpLogFileName())
    {
        if (NULL != _lpLogFile)
        {
            MemFree(_lpLogFile);
        }
        _lpLogFile = (LPSTR)MemAlloc(LPTR, (MAX_PATH + 1) * sizeof(CHAR));
        if (_lpLogFile)
        {
            lstrcpyA(_lpLogFile, "trkad.tmp");
        }
    }
        
    if (FAILED(hr = _pUploadStream->RetrieveAllLogStream(_pCDFItem, _lpLogFile)))
        return hr;

    hr = DoFileUpload();

    if (_lpLogFile)
        DeleteFileA(_lpLogFile);
    
    return hr;
}

// OnInetOnline
HRESULT CWCPostAgent::StartDownload()
{
    HRESULT hr;
    ASSERT(_pUploadStream && _pUploadStream->_pwszURL);

    hr = FindCDFStartItem();

    if (SUCCEEDED(hr))
    {
        BSTR bstrChannelURL = NULL;
        hr = ReadBSTR(m_pSubscriptionItem, c_szPropURL, &bstrChannelURL);
        ASSERT(SUCCEEDED(hr) && *bstrChannelURL);
        if (SUCCEEDED(hr) && !SHRestricted2W(REST_NoChannelLogging, bstrChannelURL, 0)
            && !ReadRegDWORD(HKEY_CURRENT_USER, c_szRegKey, c_szNoChannelLogging))
        {
            hr = DoPost();
        }
        else
        {
            OnPostSuccess();                // log is off, clean up log cache entries
        }
        SAFEFREEBSTR(bstrChannelURL);
    }
    SAFERELEASE(_pCDFItem);

    SetEndStatus(S_OK);

    CleanUp();

    return S_OK;
}

// OnAgentStart
HRESULT CWCPostAgent::StartOperation()
{
    if (_pUploadStream)
    {
        DBG_WARN("Agent busy, returning failure");
        SetEndStatus(E_FAIL);
        SendUpdateNone();
        return E_FAIL;
    }

    _pUploadStream = NULL;
    _pUploadStream = new CTrackingStg();
    if (!_pUploadStream)
    {
        DBG("failed to allocate CTrackStg");
        SetEndStatus(E_OUTOFMEMORY);
        SendUpdateNone();
        return E_OUTOFMEMORY;
    }

    SAFEFREEOLESTR(_pUploadStream->_pwszURL);
    if (FAILED(ReadOLESTR(m_pSubscriptionItem, c_szTrackingPostURL, &_pUploadStream->_pwszURL)) ||
        !CUrlDownload::IsValidURL(_pUploadStream->_pwszURL))
    {
        DBG_WARN("Couldn't get valid URL from start item (aborting)");
        SetEndStatus(E_INVALIDARG);
        SendUpdateNone();
        return E_INVALIDARG;
    }

    // After calling this, we'll reenter either in "StartDownload" or in 
    // "AbortUpdate" with m_scEndStatus = E_ACCESSDENIED
    return CDeliveryAgent::StartOperation();
}

//------------------------------------------------------------
//
// override CDeliveryAgent virtual functions
//
//------------------------------------------------------------

// OnInetOffline
// Forcibly abort current operation
HRESULT CWCPostAgent::AgentAbort(DWORD dwFlags)
{
    DBG("CWCPostAgent::AbortUpdate");

    if (_pUploadStream)
    {
        if (SUCCEEDED(FindCDFStartItem()))
        {
            OnPostFailed();
        }
    }

    return CDeliveryAgent::AgentAbort(dwFlags);
}

void CWCPostAgent::CleanUp()
{
    SAFEDELETE(_pUploadStream);

    if (_lpLogFile)
        DeleteFileA(_lpLogFile);

    SAFEFREEBSTR(_pwszEncoding);

    SAFELOCALFREE(_lpLogFile);
    SAFELOCALFREE(_pszPostStream);
    
    CDeliveryAgent::CleanUp();
}

//------------------------------------------------------------
//
// CWCPostAgent Constructor/D'Constr
//
//------------------------------------------------------------

CWCPostAgent::CWCPostAgent()
{
    DBG("Creating CWCPostAgent object");

    //
    // Maintain global count of objects in webcheck.dll
    //
    DllAddRef();

    //
    // Initialize object member variables
    //
    _pUploadStream = NULL;
    _pwszEncoding = NULL;
    _pszPostStream = NULL;
    _lpLogFile = NULL;
    _hSession = _hHttpSession = _hHttpRequest = 0;
}

CWCPostAgent::~CWCPostAgent()
{
    SAFERELEASE(_pCDFItem);

    //
    // Maintain global count of objects
    //
    DllRelease();

    //
    // Release/delete any resources
    //
    DBG("Destroyed CWCPostAgent object");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\regstm.cpp ===
#include "private.h"

#define TF_THISMODULE TF_WEBCHECKCORE

//////////////////////////////////////////////////////////////////////////
//
// CMemStream implementation
//
//////////////////////////////////////////////////////////////////////////

CMemStream::CMemStream(BOOL fNewStream)
{
    // We don't start dirty
    m_fDirty = FALSE;
    m_pstm = NULL;
    m_fNewStream = fNewStream;
    m_fError = FALSE;

    if (fNewStream)
    {
        // Create new stream
        if (FAILED(CreateStreamOnHGlobal(NULL, TRUE, &m_pstm)))
        {
            m_pstm = NULL;
            m_fError = TRUE;
            DBG_WARN("CMemStream CreateStream fail");
        }
    }
}

CMemStream::~CMemStream()
{
    DWORD   dwSize = 0;

    // Free up stream
    if (m_pstm)
    {
        m_pstm->Release();
    }

#ifdef DEBUG
    if (m_fDirty)
        DBG_WARN("CMemStream destructor with dirty data");
    if (m_fError)
        DBG_WARN("CMemStream encountered read/write error");
#endif
}

HRESULT CMemStream::CopyToStream(IStream *pStm)
{
    char *  pData;
    DWORD   dwSize = 0;
    HLOCAL hGlobal=NULL;

    if (m_pstm)
    {
        // get global handle from stream
        GetHGlobalFromStream(m_pstm, &hGlobal);

        // find how much data we have
        STATSTG stats;
        m_pstm->Stat( &stats, STATFLAG_NONAME );
        dwSize = stats.cbSize.LowPart;

        // write out data
        ASSERT(hGlobal);

        pData = (char *)GlobalLock(hGlobal);
        if (pData)
            pStm->Write(pData, dwSize, NULL);

        GlobalUnlock(hGlobal);

        m_fDirty = FALSE;
    }

    return NOERROR;
}


HRESULT CMemStream::Read(void *pv, ULONG cb, ULONG *cbRead)
{
    HRESULT hr;

    // make sure we have a stream
    if(NULL == m_pstm)
        return ResultFromScode(E_OUTOFMEMORY);

    hr = m_pstm->Read(pv, cb, cbRead);
    if (FAILED(hr) || *cbRead!=cb)
        m_fError=TRUE;

    return hr;
}

HRESULT CMemStream::Write(void *pv, ULONG cb, ULONG *cbWritten)
{
    HRESULT hr;

    // make sure we have a stream
    if(NULL == m_pstm)
        return ResultFromScode(E_OUTOFMEMORY);

    m_fDirty = TRUE;

    hr = m_pstm->Write(pv, cb, cbWritten);
    if (FAILED(hr) || *cbWritten != cb)
        m_fError=TRUE;

    return hr;
}

HRESULT CMemStream::SaveToStream(IUnknown *punk)
{
    IPersistStream *    pips;
    HRESULT             hr;

    // make sure we have a stream
    if(NULL == m_pstm)
        return ResultFromScode(E_OUTOFMEMORY);

    // Get IPersistStream interface and save!
    hr = punk->QueryInterface(IID_IPersistStream, (void **)&pips);
    if(SUCCEEDED(hr))
        hr = OleSaveToStream(pips, m_pstm);

    if(pips)
        pips->Release();

    if (FAILED(hr))
        m_fError=TRUE;

    return hr;
}

HRESULT CMemStream::LoadFromStream(IUnknown **ppunk)
{
    HRESULT hr;

    // make sure we have a stream
    if(NULL == m_pstm)
        return ResultFromScode(E_OUTOFMEMORY);

    hr = OleLoadFromStream(m_pstm, IID_IUnknown, (void **)ppunk);

    if (FAILED(hr))
        m_fError=TRUE;

    return hr;
}

HRESULT CMemStream::Seek(long lMove, DWORD dwOrigin, DWORD *dwNewPos)
{
    LARGE_INTEGER   liDist;
    ULARGE_INTEGER  uliNew;
    HRESULT         hr;

    LISet32(liDist, lMove);
    hr = m_pstm->Seek(liDist, dwOrigin, &uliNew);
    if(dwNewPos)
        *dwNewPos = uliNew.LowPart;

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// CRegStream implementation
//
//////////////////////////////////////////////////////////////////////////

CRegStream::CRegStream(HKEY hBaseKey, LPCTSTR pszRegKey, LPCTSTR pszSubKey, BOOL fForceNewStream) :
                CMemStream(fForceNewStream)
{
    long    lRes;
    DWORD   dwDisposition, dwType, dwSize;
    char *  pData;
    HLOCAL hGlobal;

    m_hKey = NULL;

    lstrcpyn(m_pszSubKey, pszSubKey, ARRAYSIZE(m_pszSubKey));

    lRes = RegCreateKeyEx(
                    hBaseKey,
                    pszRegKey,
                    0,
                    NULL,
                    0,
                    KEY_QUERY_VALUE | KEY_SET_VALUE,
                    NULL,
                    &m_hKey,
                    &dwDisposition
                    );

    if(lRes != ERROR_SUCCESS)
        return;

    if (!fForceNewStream)
    {
        // Initialize our stream from the registry
        m_fError=TRUE;  // assume failure

        // Find reg data size
        lRes = RegQueryValueEx(m_hKey, m_pszSubKey, NULL, &dwType, NULL, &dwSize);

        if(lRes != ERROR_SUCCESS) {
            // nothing in there at the moment - create new stream
            DBG("CRegStream creating new stream");
            m_fNewStream = TRUE;
            if(FAILED(CreateStreamOnHGlobal(NULL, TRUE, &m_pstm)))
            {
                m_pstm = NULL;
            }
            else
                m_fError=FALSE;
        }
        else
        {
            // Get global handle to data
            hGlobal = MemAlloc(LMEM_MOVEABLE, dwSize);
            if(NULL == hGlobal)
            {
                return;
            }

            pData = (char *)GlobalLock(hGlobal);

            lRes = RegQueryValueEx(m_hKey, m_pszSubKey, NULL, &dwType,
                        (BYTE *)pData, &dwSize);
            GlobalUnlock(hGlobal);

            if (lRes != ERROR_SUCCESS)
            {
                MemFree(hGlobal);
                return;
            }

            // make stream on global handle
            if (FAILED(CreateStreamOnHGlobal(hGlobal, TRUE, &m_pstm)))
            {
                m_pstm = NULL;
                MemFree(hGlobal);
            }
            else
                m_fError=FALSE;
        }
    }
}

CRegStream::~CRegStream()
{
    char *  pData;
    DWORD   dwSize = 0;
    HLOCAL hGlobal=NULL;

    // Save stream to registry if it's changed
    if (m_pstm && m_fDirty)
    {
        GetHGlobalFromStream(m_pstm, &hGlobal);

        STATSTG stats;
        m_pstm->Stat( &stats, STATFLAG_NONAME );
        dwSize = stats.cbSize.LowPart;

        pData = (char *)GlobalLock(hGlobal);
        if(pData)
            RegSetValueEx(m_hKey, m_pszSubKey, NULL, REG_BINARY,
                          (const BYTE *)pData, dwSize);
        GlobalUnlock(hGlobal);
        m_fDirty = FALSE;
    }

    // clean up
    if(m_hKey)
        RegCloseKey(m_hKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\smtp.h ===
//
// SMTP - Simple Mail Transfer Protocol 
//
// Julian Jiggins, January 13th 1997
//

//
// SMTPSendMessage -
//		loads winsock, 
//		connects to the specified server on the SMTP port 25
//		sends the szMessage to the szAddress
//
BOOL SMTPSendMessage(
	char * szServer, 
	char * szToAddress, 
	char * szFromAddress, 
	char * szMessage);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\schedui.h ===
#ifndef __SCHEDUI_H__
#define __SCHEDUI_H__

/////////////////////////////////////////////////////////////////////////////
// External functions
/////////////////////////////////////////////////////////////////////////////
HRESULT GetRunTimes(TASK_TRIGGER & jt, TASK_DATA * ptd, LPSYSTEMTIME pstBracketBegin, LPSYSTEMTIME pstBracketEnd, WORD * pCount, FILETIME * pRunList);
typedef HRESULT (* GRTFUNCTION)(TASK_TRIGGER & jt, TASK_DATA * ptd, LPSYSTEMTIME pstBracketBegin, LPSYSTEMTIME pstBracketEnd, WORD * pCount, FILETIME * pRunList);

/////////////////////////////////////////////////////////////////////////////
// Structs
/////////////////////////////////////////////////////////////////////////////
struct SSUIDLGINFO
{
    // Set outside ShowScheduleUIDlgProc
    DWORD               dwFlags;

    // Used inside ShowScheduleUIDlgProc
    BOOL                bScheduleChanged;
    BOOL                bScheduleNameChanged;
    BOOL                bDataChanged;
    BOOL                bInitializing;
    TASK_TRIGGER        ttTaskTrigger;
    PNOTIFICATIONCOOKIE pGroupCookie;

    HINSTANCE           hinstURLMON;
    GRTFUNCTION         pfnGetRunTimes;

    DWORD               dwRepeatHrsAreMins;
};

struct CTLGRPITEM
{
    int idContainer;
    int idFirst;
    int idLast;
};

/////////////////////////////////////////////////////////////////////////////
// Functions
/////////////////////////////////////////////////////////////////////////////
HRESULT ScheduleSummaryFromGroup(
    /* [in] */      PNOTIFICATIONCOOKIE pGroupCookie,
    /* [in][out] */ LPTSTR              pszSummary,
    /* [in] */      UINT                cchSummary);

HRESULT ScheduleSummaryFromTaskTrigger(
    /* [in] */      TASK_TRIGGER *  pTaskTrigger,
    /* [in][out] */ LPTSTR          pszSummary,
    /* [in] */      UINT            cchSummary);

#define SSUI_CREATENEWSCHEDULE      0x0001
#define SSUI_EDITSCHEDULE           0x0002
#define SSUI_INFLAGMASK             0x00FF

#define SSUI_SCHEDULECREATED        0x1000
#define SSUI_SCHEDULECHANGED        0x2000
#define SSUI_SCHEDULEREMOVED        0x3000
#define SSUI_SCHEDULELISTUPDATED    (SSUI_SCHEDULECREATED | SSUI_SCHEDULECHANGED | SSUI_SCHEDULEREMOVED)
#define SSUI_OUTFLAG_MASK           0xFF00

HRESULT ShowScheduleUI(
    /* [in] */      HWND                hwndParent,
    /* [in][out] */ PNOTIFICATIONCOOKIE pGroupCookie,
    /* [in][out] */ DWORD *             pdwFlags);

HRESULT CreateScheduleGroup(
    /* [in] */  PTASK_TRIGGER       pTaskTrigger,
    /* [in] */  PTASK_DATA          pTaskData,
    /* [in] */  PGROUPINFO          pGroupInfo,
    /* [in] */  GROUPMODE           grfGroupMode,
    /* [out] */ PNOTIFICATIONCOOKIE pGroupCookie);

HRESULT ModifyScheduleGroup(
    /* [in] */  PNOTIFICATIONCOOKIE pGroupCookie,
    /* [in] */  PTASK_TRIGGER       pTaskTrigger,
    /* [in] */  PTASK_DATA          pTaskData,
    /* [in] */  PGROUPINFO          pGroupInfo,
    /* [in] */  GROUPMODE           grfGroupMode);

HRESULT DeleteScheduleGroup(
    /* [in] */  PNOTIFICATIONCOOKIE pGroupCookie);

BOOL ScheduleGroupExists(
    /* [in] */  LPCTSTR pszGroupName);

/////////////////////////////////////////////////////////////////////////////
// Schedule group combo box helpers
/////////////////////////////////////////////////////////////////////////////
HRESULT SchedGroupComboBox_Fill(HWND hwndCombo);
HRESULT SchedGroupComboBox_Clear(HWND hwndCombo);
HRESULT SchedGroupComboBox_AddGroup(HWND hwndCombo, LPCTSTR pszGroupName, PNOTIFICATIONCOOKIE pGroupCookie);
HRESULT SchedGroupComboBox_RemoveGroup(HWND hwndCombo, PNOTIFICATIONCOOKIE pGroupCookie);
HRESULT SchedGroupComboBox_SetCurGroup(HWND hwndCombo, PNOTIFICATIONCOOKIE pGroupCookie);
HRESULT SchedGroupComboBox_GetCurGroup(HWND hwndCombo, PNOTIFICATIONCOOKIE pGroupCookie);

//wrappers for SchedGrupComboBox functions (fill and setcurgroup) that need to peek at the OOEBuf
HRESULT FillScheduleList (HWND hwndCombo, POOEBuf pBuf);
HRESULT SetScheduleGroup (HWND hwndCombo, CLSID* pGroupCookie, POOEBuf pBuf);

/////////////////////////////////////////////////////////////////////////////
// Helper macros
/////////////////////////////////////////////////////////////////////////////
#define UpDown_GetRange(hwndCtl)                    ((DWORD)SendMessage((hwndCtl), UDM_GETRANGE, 0, 0))
#define UpDown_SetRange(hwndCtl, posMin, posMax)    ((int)(DWORD)SendMessage((hwndCtl), UDM_SETRANGE, 0, MAKELPARAM((posMax), (posMin))))
#define UpDown_GetBuddy(hwndCtl)                    ((HWND)SendMessage((hwndCtl), UDM_GETBUDDY, 0, 0))
#define UpDown_SetBuddy(hwndCtl, hwndBuddy)         ((HWND)SendMessage((hwndCtl), UDM_SETBUDDY, (WPARAM)(hwndBuddy), 0))
#define UpDown_SetAccel(hwndCtl, nAccels, aAccels)  ((BOOL)SendMessage((hwndCtl), UDM_SETACCEL, nAccels, (LPARAM)(aAccels)))

#endif  // __SCHEDUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\schedui.cpp ===
#include "private.h"
#include "schedui.h"
#include "offl_cpp.h"
#include "dialmon.h"    // For WAITCURSOR
#include "shellids.h"   // For Help IDs

//xnotfmgr - can probably nuke most of this file

#define TF_DLGCTL                   TF_ALWAYS
#define TF_DUMPTRIGGER              0

#define MAX_GROUPNAME_LEN           40
#define MAX_LOADSTRING_LEN          64
#define MAX_SHORTTIMEFORMAT_LEN     80
#define MAX_TIMESEP_LEN             8

/////////////////////////////////////////////////////////////////////////////
// Design constants
/////////////////////////////////////////////////////////////////////////////
#define TASK_ALLDAYS                    (TASK_SUNDAY | TASK_MONDAY | TASK_TUESDAY | TASK_WEDNESDAY | TASK_THURSDAY | TASK_FRIDAY | TASK_SATURDAY)
#define TASK_WEEKDAYS                   (TASK_MONDAY | TASK_TUESDAY | TASK_WEDNESDAY | TASK_THURSDAY | TASK_FRIDAY)
#define TASK_WEEKENDDAYS                (TASK_SUNDAY | TASK_SATURDAY)
#define TASK_ALLMONTHS                  (TASK_JANUARY | TASK_FEBRUARY | TASK_MARCH | TASK_APRIL | TASK_MAY | TASK_JUNE | TASK_JULY | TASK_AUGUST | TASK_SEPTEMBER | TASK_OCTOBER | TASK_NOVEMBER | TASK_DECEMBER)

#define DEFAULT_DAILY_EVERYNDAYS        1
#define DEFAULT_DAILY_EVERYNDAYS_MIN    1
#define DEFAULT_DAILY_EVERYNDAYS_MAX    999
#define DEFAULT_WEEKLY_REPEATWEEKS      1
#define DEFAULT_WEEKLY_REPEATWEEKS_MIN  1
#define DEFAULT_WEEKLY_REPEATWEEKS_MAX  99
#define DEFAULT_MONTHLY_DAY_MIN         1
#define DEFAULT_MONTHLY_DAY_MAX         31
#define DEFAULT_MONTHLY_MONTHS          1
#define DEFAULT_MONTHLY_MONTHS_MIN      1
#define DEFAULT_MONTHLY_MONTHS_MAX      6
#define DEFAULT_UPDATETIME_HRS          0   // 12:00am
#define DEFAULT_UPDATETIME_MINS         0
#define DEFAULT_REPEATUPDATE_HRS        1
#define DEFAULT_REPEATUPDATE_HRS_MIN    1
#define DEFAULT_REPEATUPDATE_HRS_MAX    99
#define DEFAULT_REPEAT_START_HRS        9   // 9:00am
#define DEFAULT_REPEAT_START_MINS       0
#define DEFAULT_REPEAT_END_HRS          17  // 5:00pm
#define DEFAULT_REPEAT_END_MINS         0

#define DEFAULT_RANDOM_MINUTES_INTERVAL 30

// NOTE: These #defines have a dependency on the numeric order of the
// controls in the dialog resource! Make sure they are contiguious
// in RESOURCE.H! [jaym]
#define IDC_TYPE_GROUP_FIRST        IDC_CUSTOM_DAILY
#define IDC_TYPE_GROUP_LAST         IDC_CUSTOM_MONTHLY
    // Group type radio buttons

#define IDC_DAILY_GROUP_FIRST       IDC_CUSTOM_DAILY_EVERYNDAYS
#define IDC_DAILY_GROUP_LAST        IDC_CUSTOM_DAILY_EVERYWEEKDAY
    // Daily group type radio buttons

#define IDC_MONTHLY_GROUP_FIRST     IDC_CUSTOM_MONTHLY_DAYOFMONTH
#define IDC_MONTHLY_GROUP_LAST      IDC_CUSTOM_MONTHLY_PERIODIC
    // Monthly group type radio buttons

#define IDC_TIME_GROUP_FIRST        IDC_CUSTOM_TIME_UPDATEAT
#define IDC_TIME_GROUP_LAST         IDC_CUSTOM_TIME_REPEATEVERY
    // Time radio buttons

#define IDC_CUSTOM_DAILY_FIRST      IDC_CUSTOM_DAILY_EVERYNDAYS
#define IDC_CUSTOM_DAILY_LAST       IDC_CUSTOM_DAILY_STATIC1
#define IDC_CUSTOM_WEEKLY_FIRST     IDC_CUSTOM_WEEKLY_STATIC1
#define IDC_CUSTOM_WEEKLY_LAST      IDC_CUSTOM_WEEKLY_DAY7
#define IDC_CUSTOM_MONTHLY_FIRST    IDC_CUSTOM_MONTHLY_DAYOFMONTH
#define IDC_CUSTOM_MONTHLY_LAST     IDC_CUSTOM_MONTHLY_STATIC4
    // Group type controls

#define IDS_MONTHLY_LIST1_FIRST     IDS_WEEK1
#define IDS_MONTHLY_LIST1_LAST      IDS_WEEK5
    // Combo box items.

#define CX_DIALOG_GUTTER            10
#define CY_DIALOG_GUTTER            10

/////////////////////////////////////////////////////////////////////////////
// Module variables
/////////////////////////////////////////////////////////////////////////////
static const TCHAR s_szRepeatHrsAreMins[] = TEXT("RepeatHrsAreMins");

static const CTLGRPITEM c_rgnCtlGroups[] = 
{
    // 'Container' control                  First item in control       Last item in control
    //-------------------------             --------------------------- ----------------------
    { IDC_CUSTOM_GROUP_DAILY,               IDC_CUSTOM_DAILY_FIRST,     IDC_CUSTOM_DAILY_LAST },
    { IDC_CUSTOM_GROUP_WEEKLY,              IDC_CUSTOM_WEEKLY_FIRST,    IDC_CUSTOM_WEEKLY_LAST },
    { IDC_CUSTOM_GROUP_MONTHLY,             IDC_CUSTOM_MONTHLY_FIRST,   IDC_CUSTOM_MONTHLY_LAST },
};

static const CTLGRPITEM c_rgnCtlItems[] = 
{
    // 'Container' control                  First item in control       Last item in control
    //-------------------------             --------------------------- ----------------------
    { IDC_CUSTOM_MONTHLY_PERIODIC_LIST1,    IDS_MONTHLY_LIST1_FIRST,    IDS_MONTHLY_LIST1_LAST },
};

static const WORD c_rgwMonthMaps[] =
{
    0x0FFF,         // every month       111111111111b
    0x0AAA,         // every other month 101010101010b
    0x0924,         // every 3 months    100100100100b
    0x0888,         // every 4 months    100010001000b
    0x0842,         // every 5 months    100001000010b
    0x0820          // every 6 months    100000100000b
};

#define NUM_CUSTOM_DAYSOFTHEWEEK    3
static WORD s_rgwDaysOfTheWeek[NUM_CUSTOM_DAYSOFTHEWEEK+7] = 
{
    TASK_ALLDAYS,
    TASK_WEEKDAYS,
    TASK_WEEKENDDAYS,

    // ...
};
    // NOTE: These should be kept in line with IDS_DAY1 to IDS_DAY3

extern TCHAR c_szHelpFile[];
DWORD aCustomDlgHelpIDs[] =
{
    IDD_CUSTOM_SCHEDULE,                        IDH_CUSTOM_SCHEDULE,

    IDC_CUSTOM_NEWGROUP,                        IDH_SCHEDULE_NEW,
    IDC_CUSTOM_REMOVEGROUP,                     IDH_SCHEDULE_REMOVE,

    IDC_CUSTOM_GROUP_LIST,                      IDH_NEW_NAME,
    IDC_CUSTOM_GROUP_EDIT,                      IDH_NEW_NAME,

    IDC_CUSTOM_DAILY,                           IDH_SCHED_DAYS,
    IDC_CUSTOM_WEEKLY,                          IDH_SCHED_DAYS,
    IDC_CUSTOM_MONTHLY,                         IDH_SCHED_DAYS,

    IDC_CUSTOM_DAILY_EVERYNDAYS,                IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_DAILY_EVERYNDAYS_EDIT,           IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_DAILY_STATIC1,                   IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_DAILY_EVERYWEEKDAY,              IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_WEEKLY_STATIC1,                  IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_WEEKLY_REPEATWEEKS_EDIT,         IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_WEEKLY_STATIC2,                  IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_WEEKLY_DAY1,                     IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_WEEKLY_DAY2,                     IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_WEEKLY_DAY3,                     IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_WEEKLY_DAY4,                     IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_WEEKLY_DAY5,                     IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_WEEKLY_DAY6,                     IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_WEEKLY_DAY7,                     IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_MONTHLY_DAYOFMONTH,              IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_MONTHLY_STATIC3,                 IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_EDIT,   IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_MONTHLY_STATIC4,                 IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_MONTHLY_PERIODIC,                IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_MONTHLY_PERIODIC_LIST1,          IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_MONTHLY_PERIODIC_LIST2,          IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_MONTHLY_STATIC1,                 IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_MONTHLY_PERIODIC_EDIT,           IDH_SCHED_FREQUENCY,
    IDC_CUSTOM_MONTHLY_STATIC2,                 IDH_SCHED_FREQUENCY,

    IDC_CUSTOM_TIME_UPDATEAT,                   IDH_SCHED_TIME,
    IDC_CUSTOM_TIME_UPDATEAT_TIME,              IDH_SCHED_TIME,

    IDC_CUSTOM_TIME_REPEATEVERY,                IDH_SCHED_REPEAT,
    IDC_CUSTOM_TIME_REPEATEVERY_EDIT,           IDH_SCHED_REPEAT,
    IDC_CUSTOM_TIME_REPEATBETWEEN,              IDH_SCHED_REPEAT,
    IDC_CUSTOM_TIME_REPEATBETWEEN_START_TIME,   IDH_SCHED_REPEAT,
    IDC_CUSTOM_TIME_REPEATBETWEEN_END_TIME,     IDH_SCHED_REPEAT,

    IDC_CUSTOM_MINIMIZENETUSE,                  IDH_VARY_START
};
    // Help IDs

/////////////////////////////////////////////////////////////////////////////
// Local functions
/////////////////////////////////////////////////////////////////////////////
void InitDlgCtls(HWND hwndDlg, SSUIDLGINFO * pDlgInfo);
void PositionDlgCtls(HWND hwndDlg);
void InitDlgDefaults(HWND hwndDlg, SSUIDLGINFO * pDlgInfo);
void InitDlgInfo(HWND hwndDlg, SSUIDLGINFO * pDlgInfo);

BOOL HandleDlgButtonClick(HWND hwndDlg, WPARAM wParam, SSUIDLGINFO * pDlgInfo);
BOOL HandleButtonClick(HWND hwndDlg, WPARAM wParam);
BOOL HandleGroupChange(HWND hwndDlg, SSUIDLGINFO * pDlgInfo);

void SetDlgCustomType(HWND hwndDlg, int iType);
void SetDlgWeekDays(HWND hwndDlg, WORD rgfDaysOfTheWeek);
WORD GetDlgWeekDays(HWND hwndDlg);
void SetTaskTriggerToDefaults(TASK_TRIGGER * pTaskTrigger);
void SetTaskTriggerFromDlg(HWND hwndDlg, SSUIDLGINFO * pDlgInfo);

HRESULT CreateScheduleGroupFromDlg(HWND hwndDlg, SSUIDLGINFO * pDlgInfo);

void    OnDataChanged(HWND hwndDlg, SSUIDLGINFO * pDlgInfo);
HRESULT ApplyDlgChanges(HWND hwndDlg, SSUIDLGINFO * pDlgInfo);
BOOL    ValidateDlgFields(HWND hwndDlg, SSUIDLGINFO * pDlgInfo);

UINT    GetDlgGroupName(HWND hwndDlg, LPTSTR pszGroupName, int cchGroupNameLen);
int     GetDlgGroupNameLength(HWND hwndDlg);
BOOL    SetDlgItemMonth(HWND hwndDlg, int idCtl, WORD rgfMonths);
WORD    GetDlgItemMonth(HWND hwndDlg, int idCtl);
void    SetDlgItemNextUpdate(HWND hwndDlg, int idCtl, SSUIDLGINFO * pDlgInfo);

HRESULT GetSchedGroupTaskTrigger(PNOTIFICATIONCOOKIE pGroupCookie,TASK_TRIGGER * pTaskTrigger);
BOOL CALLBACK ShowScheduleUIDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

DWORD   IncTime(DWORD dwTime, int iIncHours, int iIncMinutes);
int     DayFromDaysFlags(DWORD rgfDays);
int     MonthCountFromMonthsFlags(WORD rgfMonths);
int     DayIndexFromDaysOfTheWeekFlags(WORD rgfDaysOfTheWeek);
HRESULT GetDaysOfWeekString(WORD rgfDaysOfTheWeek, LPTSTR ptszBuf, UINT cchBuf);
HRESULT GetMonthsString(WORD rgfMonths, LPTSTR ptszBuf, UINT cchBuf);
void    RestrictDlgItemRange(HWND hwndDlg, int idCtl, SSUIDLGINFO * pDlgInfo);
void    RestrictTimeRepeatEvery(HWND hwndDlg);

int     SGMessageBox(HWND hwndParent, UINT idStringRes, UINT uType);

#ifdef DEBUG
void    DumpTaskTrigger(TASK_TRIGGER * pTaskTrigger);
#endif  // DEBUG

/////////////////////////////////////////////////////////////////////////////
// ScheduleSummaryFromGroup
/////////////////////////////////////////////////////////////////////////////
HRESULT ScheduleSummaryFromGroup
(
    /* [in] */      PNOTIFICATIONCOOKIE pGroupCookie,
    /* [in][out] */ LPTSTR              pszSummary,
    /* [in] */      UINT                cchSummary
)
{
//xnotfmgr

    HRESULT hrResult;

    ASSERT((pszSummary != NULL) && (cchSummary > 0));

    for (;;)
    {
         *pszSummary = TEXT('\0');
 
        TASK_TRIGGER    tt;
        if (FAILED(hrResult = GetSchedGroupTaskTrigger(pGroupCookie, &tt)))
            break;

        if (FAILED(hrResult = ScheduleSummaryFromTaskTrigger(&tt, pszSummary, cchSummary)))
            break;

        hrResult = S_OK;
        break;
    }

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// ScheduleSummaryFromTaskTrigger
/////////////////////////////////////////////////////////////////////////////
HRESULT ScheduleSummaryFromTaskTrigger
(
    TASK_TRIGGER *  pTT,
    LPTSTR          pszSummary,
    UINT            cchSummary
)
{
    TCHAR   szLineOut[128];
    TCHAR   szFormat[128];
    HRESULT hrResult;

    if (!MLLoadString(IDS_SUMMARY_UPDATE, szLineOut, ARRAYSIZE(szLineOut)))
    {
        hrResult = HRESULT_FROM_WIN32(GetLastError());
        return hrResult;
    }

    StrNCpy(pszSummary, szLineOut, cchSummary);

    switch (pTT->TriggerType)
    {
        case TASK_TIME_TRIGGER_DAILY:
        {
            if (pTT->Type.Daily.DaysInterval == 1)
            {
                // Daily -- every day
                if (!MLLoadString(IDS_SUMMARY_EVERY_DAY, szLineOut, ARRAYSIZE(szLineOut)))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }
            }
            else
            {
                // Daily -- every %d days
                if (!MLLoadString(IDS_SUMMARY_DAILY_FORMAT, szFormat, ARRAYSIZE(szFormat)))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }

                wnsprintf(szLineOut, ARRAYSIZE(szLineOut), szFormat, 
                          pTT->Type.Daily.DaysInterval);
            }

            lstrcatn(pszSummary, szLineOut, cchSummary);
            break;
        }

        case TASK_TIME_TRIGGER_WEEKLY:
        {
            TCHAR szDOW[128];

            if (FAILED(hrResult = GetDaysOfWeekString(  pTT->Type.Weekly.rgfDaysOfTheWeek,
                                                        szDOW,
                                                        ARRAYSIZE(szDOW))))
            {
                return hrResult;
            }

            if (pTT->Type.Weekly.WeeksInterval == 1)
            {
                // Daily -- every weekday
                if (pTT->Type.Weekly.rgfDaysOfTheWeek == TASK_WEEKDAYS)
                {
                    if (!MLLoadString(IDS_SUMMARY_EVERY_WEEKDAY, szLineOut, ARRAYSIZE(szLineOut)))
                    {
                        hrResult = HRESULT_FROM_WIN32(GetLastError());
                        return hrResult;
                    }
                }
                else
                {
                    // Weekly -- every %s of every week
                    if (!MLLoadString(IDS_SUMMARY_EVERY_WEEK_FORMAT, szFormat, ARRAYSIZE(szFormat)))
                    {
                        hrResult = HRESULT_FROM_WIN32(GetLastError());
                        return hrResult;
                    }

                    wnsprintf(szLineOut, ARRAYSIZE(szLineOut), szFormat, szDOW);
                }
            }
            else
            {
                TCHAR szWeeks[16];

                // Weekly -- every %s of every %s weeks
                if (!MLLoadString(IDS_SUMMARY_WEEKLY_FORMAT, szFormat, ARRAYSIZE(szFormat)))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }

                wnsprintf(szWeeks, ARRAYSIZE(szWeeks), "%d", pTT->Type.Weekly.WeeksInterval);

                TCHAR * rgpsz[2] = { szDOW, szWeeks };
                if (!FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                    szFormat,
                                    0,
                                    0,
                                    szLineOut, 
                                    ARRAYSIZE(szLineOut),
                                    (va_list*)rgpsz))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }
            }

            lstrcatn(pszSummary, szLineOut, cchSummary);
            break;
        }

        case TASK_TIME_TRIGGER_MONTHLYDATE:
        {
            if (pTT->Type.MonthlyDate.rgfMonths == TASK_ALLMONTHS)
            {
                // Monthly -- on day %d of every month
                if (!MLLoadString(
                                IDS_SUMMARY_EVERY_MONTHLYDATE_FORMAT,
                                szFormat,
                                ARRAYSIZE(szFormat)))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }

                wnsprintf(szLineOut, ARRAYSIZE(szLineOut), szFormat, 
                          DayFromDaysFlags(pTT->Type.MonthlyDate.rgfDays));
            }
            else
            {
                // Monthly -- on day %d of %s
                if (!MLLoadString(
                                IDS_SUMMARY_MONTHLYDATE_FORMAT,
                                szFormat,
                                ARRAYSIZE(szFormat)))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }

                TCHAR szMonths[128];
                if (FAILED(hrResult = GetMonthsString(  pTT->Type.MonthlyDate.rgfMonths,
                                                        szMonths,
                                                        ARRAYSIZE(szMonths))))
                {
                    return hrResult;
                }

                TCHAR szDay[16];
                wnsprintf(szDay, ARRAYSIZE(szDay), "%d", 
                          DayFromDaysFlags(pTT->Type.MonthlyDate.rgfDays));

                TCHAR * rgpsz[2] = { szDay, szMonths };
                if (!FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                    szFormat,
                                    0,
                                    0,
                                    szLineOut, 
                                    ARRAYSIZE(szLineOut),
                                    (va_list*)rgpsz))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }
            }

            lstrcatn(pszSummary, szLineOut, cchSummary);
            break;
        }

        case TASK_TIME_TRIGGER_MONTHLYDOW:
        {
            ASSERT((pTT->Type.MonthlyDOW.wWhichWeek >= TASK_FIRST_WEEK));
            ASSERT((pTT->Type.MonthlyDOW.wWhichWeek <= TASK_LAST_WEEK));

            TCHAR szWeek[32];
            if (!MLLoadString(
                            IDS_MONTHLY_LIST1_FIRST + pTT->Type.MonthlyDOW.wWhichWeek - 1,
                            szWeek,
                            ARRAYSIZE(szWeek)))
            {
                hrResult = HRESULT_FROM_WIN32(GetLastError());
                return hrResult;
            }

            TCHAR szDOW[128];
            if (FAILED(hrResult = GetDaysOfWeekString(  pTT->Type.MonthlyDOW.rgfDaysOfTheWeek,
                                                        szDOW,
                                                        ARRAYSIZE(szDOW))))
            {
                return hrResult;
            }

            if (pTT->Type.MonthlyDate.rgfMonths == TASK_ALLMONTHS)
            {
                // Monthly -- on the %s %s of every month
                if (!MLLoadString(
                                IDS_SUMMARY_EVERY_MONTHLYDOW_FORMAT,
                                szFormat,
                                ARRAYSIZE(szFormat)))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }

                TCHAR * rgpsz[2] = { szWeek, szDOW };
                if (!FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                    szFormat,
                                    0,
                                    0,
                                    szLineOut, 
                                    ARRAYSIZE(szLineOut),
                                    (va_list*)rgpsz))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }
            }
            else
            {
                TCHAR szMonths[128];
                if (FAILED(hrResult = GetMonthsString(  pTT->Type.MonthlyDOW.rgfMonths,
                                                        szMonths,
                                                        ARRAYSIZE(szMonths))))
                {
                    return hrResult;
                }

                // Monthly -- on the %s %s of %s
                if (!MLLoadString(
                                IDS_SUMMARY_MONTHLYDOW_FORMAT,
                                szFormat,
                                ARRAYSIZE(szFormat)))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }

                TCHAR * rgpsz[3] = { szWeek, szDOW, szMonths };
                if (!FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                        | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                    szFormat,
                                    0,
                                    0,
                                    szLineOut, 
                                    ARRAYSIZE(szLineOut),
                                    (va_list*)rgpsz))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }
            }

            lstrcatn(pszSummary, szLineOut, cchSummary);
            break;
        }

        default:
        {
            ASSERT(FALSE);
            return E_FAIL;
        }
    }

    TCHAR       szStartTime[MAX_SHORTTIMEFORMAT_LEN];
    SYSTEMTIME  st = { 0 };
    st.wHour    = pTT->wStartHour;
    st.wMinute  = pTT->wStartMinute;

    EVAL(GetTimeFormat( LOCALE_USER_DEFAULT,
                        TIME_NOSECONDS,
                        &st,
                        NULL,
                        szStartTime,
                        ARRAYSIZE(szStartTime)) > 0);

    // Handle the 'Time' settings.
    if (pTT->MinutesInterval == 0)
    {
        // at %s
        if (!MLLoadString(
                        IDS_SUMMARY_ONCE_DAY_FORMAT,
                        szFormat,
                        ARRAYSIZE(szFormat)))
        {
            hrResult = HRESULT_FROM_WIN32(GetLastError());
            return hrResult;
        }

        wnsprintf(szLineOut, ARRAYSIZE(szLineOut), szFormat, szStartTime);
        lstrcatn(pszSummary, szLineOut, cchSummary);
    }
    else
    {
        if ((pTT->MinutesInterval % 60) == 0)   //repeating on the hour
        {
            if ((pTT->MinutesInterval / 60) == 1)
            {
                // every hour
                if (!MLLoadString(
                                IDS_SUMMARY_REPEAT_EVERY_HOUR,
                                szLineOut,
                                ARRAYSIZE(szLineOut)))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }
            }
            else
            {
                // every %d hours
                if (!MLLoadString(
                                IDS_SUMMARY_REPEAT_HOURLY_FORMAT,
                                szFormat,
                                ARRAYSIZE(szFormat)))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }

                wnsprintf(szLineOut, ARRAYSIZE(szLineOut), szFormat, 
                         (pTT->MinutesInterval / 60));
            }
        }
        else        //not integral hours, use minutes
        {
            if (pTT->MinutesInterval == 1)
            {
                // every minute
                if (!MLLoadString(
                                IDS_SUMMARY_REPEAT_EVERY_MIN,
                                szLineOut,
                                ARRAYSIZE(szLineOut)))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }
            }
            else
            {
                // every %d minutes
                if (!MLLoadString(
                                IDS_SUMMARY_REPEAT_MINUTELY_FORMAT,
                                szFormat,
                                ARRAYSIZE(szFormat)))
                {
                    hrResult = HRESULT_FROM_WIN32(GetLastError());
                    return hrResult;
                }

                wnsprintf(szLineOut, ARRAYSIZE(szLineOut), szFormat, 
                         pTT->MinutesInterval);
            }
        }

        lstrcatn(pszSummary, szLineOut, cchSummary);

        // between %s and %s
        if (pTT->MinutesDuration != (24 * 60))
        {
            if (!MLLoadString(
                            IDS_SUMMARY_REPEAT_BETWEEN_FORMAT,
                            szFormat,
                            ARRAYSIZE(szFormat)))
            {
                hrResult = HRESULT_FROM_WIN32(GetLastError());
                return hrResult;
            }

            DWORD dwEndTime = IncTime(  MAKELONG(pTT->wStartHour, pTT->wStartMinute),
                                        (pTT->MinutesDuration / 60),
                                        (pTT->MinutesDuration % 60));

            ZeroMemory(&st, SIZEOF(SYSTEMTIME));
            st.wHour    = LOWORD(dwEndTime);
            st.wMinute  = HIWORD(dwEndTime);

            TCHAR szEndTime[MAX_SHORTTIMEFORMAT_LEN];
            EVAL(GetTimeFormat( LOCALE_USER_DEFAULT,
                                TIME_NOSECONDS,
                                &st,
                                NULL,
                                szEndTime,
                                ARRAYSIZE(szEndTime)) > 0);

            TCHAR * rgpsz[2] = { szStartTime, szEndTime };
            if (!FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                    | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                szFormat,
                                0,
                                0,
                                szLineOut, 
                                ARRAYSIZE(szLineOut),
                                (va_list*)rgpsz))
            {
                hrResult = HRESULT_FROM_WIN32(GetLastError());
                return hrResult;
            }

            lstrcatn(pszSummary, szLineOut, cchSummary);
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// GetDaysOfWeekString
/////////////////////////////////////////////////////////////////////////////
HRESULT GetDaysOfWeekString
(
    WORD    rgfDaysOfTheWeek,
    LPTSTR  ptszBuf,
    UINT    cchBuf
)
{
    if (rgfDaysOfTheWeek == 0)
        return E_INVALIDARG;

    int     cch;
    TCHAR   tszSep[8];
    BOOL    fMoreThanOne = FALSE;
    HRESULT hrResult;


    // REVIEW: Could probably make this simpler by creating a table [jaym]
    // TASK_* -> LOCALE_SABBREVDAYNAME?
    // REARCHITECT: Needs a re-write, hard to understand code

    if (!MLLoadString(IDS_SUMMARY_LIST_SEP, tszSep, ARRAYSIZE(tszSep)))
    {
        hrResult = HRESULT_FROM_WIN32(GetLastError());
        return hrResult;
    }

    *ptszBuf = TEXT('\0');

    if (rgfDaysOfTheWeek & TASK_MONDAY)
    {
        if (!GetLocaleInfo( LOCALE_USER_DEFAULT,
                            LOCALE_SABBREVDAYNAME1,
                            ptszBuf,
                            cchBuf))
        {
            hrResult = HRESULT_FROM_WIN32(GetLastError());
            return hrResult;
        }

        fMoreThanOne = TRUE;
    }

    if (rgfDaysOfTheWeek & TASK_TUESDAY)
    {
        if (fMoreThanOne)
            lstrcat(ptszBuf, tszSep);
        
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo( LOCALE_USER_DEFAULT,
                            LOCALE_SABBREVDAYNAME2,
                            ptszBuf + cch,
                            cchBuf - cch))
        {
            hrResult = HRESULT_FROM_WIN32(GetLastError());
            return hrResult;
        }

        fMoreThanOne = TRUE;
    }

    if (rgfDaysOfTheWeek & TASK_WEDNESDAY)
    {
        if (fMoreThanOne)
            lstrcat(ptszBuf, tszSep);
        
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo( LOCALE_USER_DEFAULT,
                            LOCALE_SABBREVDAYNAME3,
                            ptszBuf + cch,
                            cchBuf - cch))
        {
            hrResult = HRESULT_FROM_WIN32(GetLastError());
            return hrResult;
        }

        fMoreThanOne = TRUE;
    }

    if (rgfDaysOfTheWeek & TASK_THURSDAY)
    {
        if (fMoreThanOne)
            lstrcat(ptszBuf, tszSep);
        
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo( LOCALE_USER_DEFAULT,
                            LOCALE_SABBREVDAYNAME4,
                            ptszBuf + cch,
                            cchBuf - cch))
        {
            hrResult = HRESULT_FROM_WIN32(GetLastError());
            return hrResult;
        }
        
        fMoreThanOne = TRUE;
    }

    if (rgfDaysOfTheWeek & TASK_FRIDAY)
    {
        if (fMoreThanOne)
            lstrcat(ptszBuf, tszSep);

        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo( LOCALE_USER_DEFAULT,
                            LOCALE_SABBREVDAYNAME5,
                            ptszBuf + cch,
                            cchBuf - cch))
        {
            hrResult = HRESULT_FROM_WIN32(GetLastError());
            return hrResult;
        }

        fMoreThanOne = TRUE;
    }

    if (rgfDaysOfTheWeek & TASK_SATURDAY)
    {
        if (fMoreThanOne)
            lstrcat(ptszBuf, tszSep);

        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo( LOCALE_USER_DEFAULT,
                            LOCALE_SABBREVDAYNAME6,
                            ptszBuf + cch,
                            cchBuf - cch))
        {
            hrResult = HRESULT_FROM_WIN32(GetLastError());
            return hrResult;
        }

        fMoreThanOne = TRUE;
    }

    if (rgfDaysOfTheWeek & TASK_SUNDAY)
    {
        if (fMoreThanOne)
            lstrcat(ptszBuf, tszSep);

        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo( LOCALE_USER_DEFAULT,
                            LOCALE_SABBREVDAYNAME7,
                            ptszBuf + cch,
                            cchBuf - cch))
        {
            hrResult = HRESULT_FROM_WIN32(GetLastError());
            return hrResult;
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// GetMonthsString
/////////////////////////////////////////////////////////////////////////////
HRESULT GetMonthsString
(
    WORD    rgfMonths,
    LPTSTR  ptszBuf,
    UINT    cchBuf
)
{
    if (rgfMonths == 0)
        return E_INVALIDARG;

    int     cch;
    TCHAR   tszSep[8];
    BOOL    fMoreThanOne = FALSE;
    HRESULT hr;

    if (!MLLoadString(IDS_SUMMARY_LIST_SEP, tszSep, ARRAYSIZE(tszSep)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    *ptszBuf = TEXT('\0');

    for (WORD i = 0; i < 12; i++)
    {
        if ((rgfMonths >> i) & 0x1)
        {
            if (fMoreThanOne)
                lstrcat(ptszBuf, tszSep);

            cch = lstrlen(ptszBuf);
            if (!GetLocaleInfo( LOCALE_USER_DEFAULT,
                                LOCALE_SABBREVMONTHNAME1 + i,
                                ptszBuf + cch,
                                cchBuf - cch))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
            }

            fMoreThanOne = TRUE;
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// ShowScheduleUI
/////////////////////////////////////////////////////////////////////////////
HRESULT ShowScheduleUI
(
    /* [in] */      HWND                hwndParent,
    /* [in][out] */ PNOTIFICATIONCOOKIE pGroupCookie,
    /* [in][out] */ DWORD *             pdwFlags
)
{
//xnotfmgr

    SSUIDLGINFO ssuiDlgInfo = { 0 };
    HRESULT     hrResult;

    // Initialize the custom time edit control class.
    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icc.dwICC = ICC_DATE_CLASSES;
    EVAL(SUCCEEDED(InitCommonControlsEx(&icc)));

    for (;;)
    {
        // REVIEW: Check for invalid/conflicting dwFlags. [jaym]
        if  (
            (pGroupCookie == NULL)
            ||
            (pdwFlags == NULL)
            )
        {
            return E_INVALIDARG;
        }

        ssuiDlgInfo.dwFlags         = *pdwFlags;
        ssuiDlgInfo.pGroupCookie    = pGroupCookie;

        // Get the GetRunTimes function entry point from URLMON.
        if ((ssuiDlgInfo.hinstURLMON = LoadLibrary(TEXT("URLMON.DLL"))) != NULL)
        {
            EVAL((ssuiDlgInfo.pfnGetRunTimes = (GRTFUNCTION)GetProcAddress( ssuiDlgInfo.hinstURLMON,
                                                                            TEXT("GetRunTimes"))) != NULL);
        }
        else
            TraceMsg(TF_ERROR, "Unable to LoadLibrary(URLMON.DLL)");

        // Setup the TASK_TRIGGER with default or sched. group info.
        if (ssuiDlgInfo.dwFlags & SSUI_CREATENEWSCHEDULE)
        {
            *(ssuiDlgInfo.pGroupCookie) = GUID_NULL;
            SetTaskTriggerToDefaults(&ssuiDlgInfo.ttTaskTrigger);
        }
        else
        {
            ASSERT(ssuiDlgInfo.dwFlags & SSUI_EDITSCHEDULE);

            if (FAILED(hrResult = GetSchedGroupTaskTrigger( ssuiDlgInfo.pGroupCookie,
                                                            &ssuiDlgInfo.ttTaskTrigger)))
            {
                hrResult = E_INVALIDARG;
                break;
            }
        }

        // See if we want to specify schedule hours in minutes.
        ReadRegValue(   HKEY_CURRENT_USER,
                        WEBCHECK_REGKEY,
                        s_szRepeatHrsAreMins,
                        &ssuiDlgInfo.dwRepeatHrsAreMins,
                        SIZEOF(&ssuiDlgInfo.dwRepeatHrsAreMins));

#ifdef DEBUG
        if (ssuiDlgInfo.dwRepeatHrsAreMins)
            TraceMsg(TF_ALWAYS, "!!! WARNING! Treating Repeat Hours as Minutes !!!");
#endif  // DEBUG

        // Show the dialog.
        int iResult;
        if ((iResult = DialogBoxParam(  MLGetHinst(),
                                        MAKEINTRESOURCE(IDD_CUSTOM_SCHEDULE),
                                        hwndParent,
                                        ShowScheduleUIDlgProc,
                                        (LPARAM)&ssuiDlgInfo)) < 0)
        {
            TraceMsg(TF_ERROR, "SSUI: DialogBoxParam failed");

            hrResult = E_FAIL;
            break;
        }

        switch (iResult)
        {
            case IDCANCEL:
            {
                if (!(ssuiDlgInfo.dwFlags & SSUI_EDITSCHEDULE))
                    break;

                // FALL THROUGH!!!
            }

            case IDOK:
            {
                *pdwFlags = ssuiDlgInfo.dwFlags;

                if (ssuiDlgInfo.dwFlags & SSUI_SCHEDULELISTUPDATED)
                {
                    ASSERT(ssuiDlgInfo.pGroupCookie != NULL);
                    ASSERT(*(ssuiDlgInfo.pGroupCookie) != GUID_NULL);

                    pGroupCookie = ssuiDlgInfo.pGroupCookie;
                }

                break;
            }

            default:
            {
                ASSERT(FALSE);
                break;
            }
        }

        hrResult = S_OK;
        break;
    }

    if (ssuiDlgInfo.hinstURLMON != NULL)
        FreeLibrary(ssuiDlgInfo.hinstURLMON);

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// ShowScheduleUIDlgProc
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK ShowScheduleUIDlgProc
(
    HWND    hwndDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    SSUIDLGINFO * pDlgInfo = (SSUIDLGINFO *)GetWindowLong(hwndDlg, DWL_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            SSUIDLGINFO * pDlgInfo = (SSUIDLGINFO *)lParam;
            ASSERT(pDlgInfo != NULL);

            SetWindowLong(hwndDlg, DWL_USER, lParam);

            // Resize the dialog -- controls are to the right in RC.
            RECT rectCancel;
            GetWindowRect(GetDlgItem(hwndDlg, IDCANCEL), &rectCancel);
            MapWindowPoints(HWND_DESKTOP, hwndDlg, (POINT *)&rectCancel, 2);

            SetWindowPos(   hwndDlg,
                            NULL,
                            0,
                            0,
                            rectCancel.right
                                + (GetSystemMetrics(SM_CXDLGFRAME) * 2)
                                + CX_DIALOG_GUTTER,
                            rectCancel.bottom
                                + (GetSystemMetrics(SM_CYDLGFRAME) * 2)
                                + GetSystemMetrics(SM_CYCAPTION)
                                + CY_DIALOG_GUTTER,
                            SWP_NOMOVE
                                | SWP_NOACTIVATE
                                | SWP_NOZORDER
                                | SWP_NOOWNERZORDER);

            // Initialize the initial dialog settings and content.
            InitDlgCtls(hwndDlg, pDlgInfo);
            InitDlgInfo(hwndDlg, pDlgInfo);

            break;
        }

        case WM_HELP:
        {
            MLWinHelpWrap((HWND)((LPHELPINFO) lParam)->hItemHandle,
                    c_szHelpFile,
                    HELP_WM_HELP,
                    (DWORD)aCustomDlgHelpIDs);
            break;
        }

        case WM_CONTEXTMENU:
        {
            MLWinHelpWrap((HWND)wParam,
                    c_szHelpFile,
                    HELP_CONTEXTMENU,
                    (DWORD)aCustomDlgHelpIDs);
            break;
        }

        case WM_COMMAND:
        {
            if (pDlgInfo == NULL)
                return FALSE;

            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    if  (
                        pDlgInfo->bDataChanged
                        &&
                        FAILED(ApplyDlgChanges(hwndDlg, pDlgInfo))
                        )
                    {
                        break;
                    }

                    if (pDlgInfo->bScheduleChanged)
                        pDlgInfo->dwFlags |= SSUI_SCHEDULECHANGED;

                    // FALL THROUGH!!!
                }

                case IDCANCEL:
                {
                    EVAL(SUCCEEDED(SchedGroupComboBox_Clear(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST))));
                    EndDialog(hwndDlg, wParam);
                    break;
                }

                case IDC_CUSTOM_GROUP_EDIT:
                {
                    switch (HIWORD(wParam))
                    {
                        case EN_CHANGE:
                        {
                            pDlgInfo->bDataChanged = TRUE;
                            pDlgInfo->bScheduleNameChanged = TRUE;
                            break;
                        }

                        default:
                            break;
                    }

                    break;
                }

                case IDC_CUSTOM_GROUP_LIST:
                {
                    switch (HIWORD(wParam))
                    {
                        case CBN_EDITCHANGE:
                        {
                            pDlgInfo->bDataChanged = TRUE;
                            pDlgInfo->bScheduleNameChanged = TRUE;
                            break;
                        }

                        case CBN_SELCHANGE:
                        {
                            HandleGroupChange(hwndDlg, pDlgInfo);
                            break;
                        }

                        default:
                            break;
                    }

                    break;
                }

                case IDC_CUSTOM_MONTHLY_PERIODIC_LIST1:
                case IDC_CUSTOM_MONTHLY_PERIODIC_LIST2:
                {
                    switch (HIWORD(wParam))
                    {
                        case CBN_SELCHANGE:
                        {
                            OnDataChanged(hwndDlg, pDlgInfo);
                            break;
                        }

                        default:
                            break;
                    }

                    break;
                }

                case IDC_CUSTOM_TIME_REPEATEVERY_EDIT:
                case IDC_CUSTOM_DAILY_EVERYNDAYS_EDIT:
                case IDC_CUSTOM_WEEKLY_REPEATWEEKS_EDIT:
                case IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_EDIT:
                case IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_EDIT:
                case IDC_CUSTOM_MONTHLY_PERIODIC_EDIT:
                {
                    switch (HIWORD(wParam))
                    {
                        case EN_CHANGE:
                        {
                            OnDataChanged(hwndDlg, pDlgInfo);
                            break;
                        }

                        case EN_KILLFOCUS:
                        {
                            RestrictDlgItemRange(hwndDlg, LOWORD(wParam), pDlgInfo);
                            break;
                        }

                        default:
                            break;
                    }

                    break;
                }

                default:
                {
                    if (HandleDlgButtonClick(hwndDlg, wParam, pDlgInfo))
                        OnDataChanged(hwndDlg, pDlgInfo);

                    break;
                }
            }

            break;
        }

        case WM_NOTIFY:
        {
            switch (wParam)
            {
                case IDC_CUSTOM_TIME_UPDATEAT_TIME:
                case IDC_CUSTOM_TIME_REPEATBETWEEN_START_TIME:
                case IDC_CUSTOM_TIME_REPEATBETWEEN_END_TIME:
                {
                    switch (((NMHDR *)lParam)->code)
                    {
                        case DTN_DATETIMECHANGE:
                        {
                            OnDataChanged(hwndDlg, pDlgInfo);
                            RestrictTimeRepeatEvery(hwndDlg);
                            break;
                        }

                        default:
                            break;
                    }

                    break;
                }

                default:
                    break;
            }

            break;
        }

        default:
            return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// HandleDlgButtonClick
/////////////////////////////////////////////////////////////////////////////
BOOL HandleDlgButtonClick
(
    HWND            hwndDlg,
    WPARAM          wParam,
    SSUIDLGINFO *   pDlgInfo
)
{
    switch (LOWORD(wParam))
    {
        case IDC_CUSTOM_NEWGROUP:
        {
            ASSERT(pDlgInfo != NULL);

            int iReply = IDNO;

            if (pDlgInfo->bDataChanged)
            {
                // Ask user if they want to save changes.
                iReply = SGMessageBox(  hwndDlg,
                                        IDS_CUSTOM_INFO_SAVECHANGES,
                                        MB_YESNOCANCEL | MB_ICONQUESTION);

            }

            switch (iReply)
            {
                case IDYES:
                {
                    // Apply changes
                    if (FAILED(ApplyDlgChanges(hwndDlg, pDlgInfo)))
                        break;

                    // FALL THROUGH!!!
                }

                case IDNO:
                {
                    pDlgInfo->dwFlags |= SSUI_CREATENEWSCHEDULE;
                    *(pDlgInfo->pGroupCookie) = GUID_NULL;

                    SetTaskTriggerToDefaults(&pDlgInfo->ttTaskTrigger);

                    InitDlgInfo(hwndDlg, pDlgInfo);
                    break;
                }

                case IDCANCEL:
                    break;
            }

            break;
        }

        case IDC_CUSTOM_REMOVEGROUP:
        {
            // REVIEW: Can we check to see if the group is really in use. [jaym]

            // Tell user that they are removing a group that may be in use.
            if (SGMessageBox(   hwndDlg,
                                IDS_CUSTOM_INFO_REMOVEGROUP,
                                MB_YESNO | MB_ICONWARNING) == IDYES)
            {
                NOTIFICATIONCOOKIE  groupCookie;
                HWND                hwndCombo = GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST);

                if  (
                    SUCCEEDED(SchedGroupComboBox_GetCurGroup(   hwndCombo,
                                                                &groupCookie))
                    &&
                    SUCCEEDED(DeleteScheduleGroup(&groupCookie))
                    )
                {
                    // Reset the list and select the first group
                    EVAL(SUCCEEDED(SchedGroupComboBox_Fill(hwndCombo)));
                    ComboBox_SetCurSel(hwndCombo, 0);

                    pDlgInfo->dwFlags |= SSUI_SCHEDULEREMOVED;

                    // Make sure we don't ask the user to save changes.
                    pDlgInfo->bDataChanged = FALSE;

                    HandleGroupChange(hwndDlg, pDlgInfo);
                }
                else
                {
                    SGMessageBox(   hwndDlg,
                                    IDS_CUSTOM_ERROR_REMOVEGROUP,
                                    MB_OK | MB_ICONWARNING);
                    break;
                }
            }

            break;
        }

        case IDC_CUSTOM_WEEKLY_DAY1:
        case IDC_CUSTOM_WEEKLY_DAY2:
        case IDC_CUSTOM_WEEKLY_DAY3:
        case IDC_CUSTOM_WEEKLY_DAY4:
        case IDC_CUSTOM_WEEKLY_DAY5:
        case IDC_CUSTOM_WEEKLY_DAY6:
        case IDC_CUSTOM_WEEKLY_DAY7:
        case IDC_CUSTOM_MINIMIZENETUSE:
        {
            return TRUE;
        }

        default:
            return HandleButtonClick(hwndDlg, wParam);
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// HandleButtonClick
/////////////////////////////////////////////////////////////////////////////
BOOL HandleButtonClick
(
    HWND    hwndDlg,
    WPARAM  wParam
)
{
    BOOL bEnable = (IsDlgButtonChecked(hwndDlg, LOWORD(wParam)) == BST_CHECKED);

    switch (LOWORD(wParam))
    {
        case IDC_CUSTOM_DAILY:
        case IDC_CUSTOM_WEEKLY:
        case IDC_CUSTOM_MONTHLY:
        {
            SetDlgCustomType(hwndDlg, LOWORD(wParam));
            break;
        }

        case IDC_CUSTOM_DAILY_EVERYNDAYS:
        {
            Edit_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_DAILY_EVERYNDAYS_EDIT), bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_DAILY_EVERYNDAYS_SPIN), bEnable);
            break;
        }

        case IDC_CUSTOM_DAILY_EVERYWEEKDAY:
        {
            Edit_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_DAILY_EVERYNDAYS_EDIT), !bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_DAILY_EVERYNDAYS_SPIN), !bEnable);
            break;
        }

        case IDC_CUSTOM_MONTHLY_DAYOFMONTH:
        {
            Edit_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_EDIT), bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_SPIN), bEnable);
            Edit_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_EDIT), bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_SPIN), bEnable);

            ListBox_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_LIST1), !bEnable);
            ListBox_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_LIST2), !bEnable);
            Edit_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_EDIT), !bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_SPIN), !bEnable);
            break;
        }

        case IDC_CUSTOM_MONTHLY_PERIODIC:
        {
            ListBox_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_LIST1), bEnable);
            ListBox_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_LIST2), bEnable);
            Edit_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_EDIT), bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_SPIN), bEnable);

            Edit_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_EDIT), !bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_SPIN), !bEnable);
            Edit_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_EDIT), !bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_SPIN), !bEnable);
            break;
        }

        case IDC_CUSTOM_TIME_UPDATEAT:
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_UPDATEAT_TIME), bEnable);
            Edit_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATEVERY_EDIT), !bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATEVERY_SPIN), !bEnable);

            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN), !bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN_START_TIME), !bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN_END_TIME), !bEnable);
            break;
        }

        case IDC_CUSTOM_TIME_REPEATEVERY:
        {
            Edit_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATEVERY_EDIT), bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATEVERY_SPIN), bEnable);

            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN), bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_UPDATEAT_TIME), !bEnable);

            bEnable = (IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN) == BST_CHECKED);

            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN_START_TIME), bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN_END_TIME), bEnable);

            break;
        }

        case IDC_CUSTOM_TIME_REPEATBETWEEN:
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN_START_TIME), bEnable);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN_END_TIME), bEnable);

            // Restrict 'repeat between' to time range - 1hr
            if (bEnable)
                RestrictTimeRepeatEvery(hwndDlg);
            else
            {
                UpDown_SetRange(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATEVERY_SPIN),
                                DEFAULT_REPEATUPDATE_HRS_MIN, DEFAULT_REPEATUPDATE_HRS_MAX);
            }

            break;
        }

        default:
            return FALSE;
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// HandleGroupChange
/////////////////////////////////////////////////////////////////////////////
BOOL HandleGroupChange
(
    HWND            hwndDlg,
    SSUIDLGINFO *   pDlgInfo
)
{
    int     iReply = IDNO;
    BOOL    bChanged = FALSE;

    if (pDlgInfo->bDataChanged)
    {
        // Ask user if they want to save changes.
        iReply = SGMessageBox(  hwndDlg,
                                IDS_CUSTOM_INFO_SAVECHANGES,
                                MB_YESNO | MB_ICONQUESTION);
    }

    switch (iReply)
    {
        case IDYES:
        {
            // Apply changes
            if (FAILED(ApplyDlgChanges(hwndDlg, pDlgInfo)))
                break;

            // FALL THROUGH!!!
        }

        case IDNO:
        {
            // No longer creating new schedule, the
            // user has selected an existing schedule.
            pDlgInfo->dwFlags &= ~SSUI_CREATENEWSCHEDULE;

            EVAL(SUCCEEDED(SchedGroupComboBox_GetCurGroup(  GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST),
                                                            pDlgInfo->pGroupCookie)));

            EVAL(SUCCEEDED(GetSchedGroupTaskTrigger( pDlgInfo->pGroupCookie,
                                                     &pDlgInfo->ttTaskTrigger)));

            InitDlgInfo(hwndDlg, pDlgInfo);

            pDlgInfo->bScheduleChanged = TRUE;
            bChanged = TRUE;

            break;
        }

        default:
        {
            ASSERT(FALSE);
            break;
        }
    }

    return bChanged;
}

/////////////////////////////////////////////////////////////////////////////
// InitDlgCtls
/////////////////////////////////////////////////////////////////////////////
void InitDlgCtls
(
    HWND            hwndDlg,
    SSUIDLGINFO *   pDlgInfo
)
{
    DWORD i;

    // Reposition the dialog controls.
    PositionDlgCtls(hwndDlg);

    // Load the common combo box values.
    for (i = 0; i < ARRAYSIZE(c_rgnCtlItems); i++)
    {
        HWND hwndCtl = GetDlgItem(hwndDlg, c_rgnCtlItems[i].idContainer);
        
        ASSERT(hwndCtl != NULL);

        for (int j = c_rgnCtlItems[i].idFirst; j <= c_rgnCtlItems[i].idLast; j++)
        {
            TCHAR szString[MAX_LOADSTRING_LEN];
            EVAL(MLLoadString(j, szString, MAX_LOADSTRING_LEN) != 0);
            EVAL(ComboBox_AddString(hwndCtl, szString) != CB_ERR);
        }
    }

    DWORD dwFirstDay = 0;
    EVAL(GetLocaleInfo( LOCALE_USER_DEFAULT,
                        LOCALE_IFIRSTDAYOFWEEK,
                        (char *)&dwFirstDay,
                        SIZEOF(DWORD)));
    dwFirstDay = LOCALE_SDAYNAME1 + (dwFirstDay - TEXT('0'));

    // Load check and combo boxes with the days of the weeks
    int     iDay;
    HWND    hwndCombo = GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_LIST2);
    TCHAR   szDayName[32];

    for (i = dwFirstDay; i < dwFirstDay+7; i++)
    {
        iDay = ((i <= LOCALE_SDAYNAME7) ? i : (LOCALE_SDAYNAME1 + (i - LOCALE_SDAYNAME7 - 1)));

        EVAL(GetLocaleInfo( LOCALE_USER_DEFAULT,
                            iDay,
                            szDayName,
                            ARRAYSIZE(szDayName)));

        SetDlgItemText( hwndDlg,
                        IDC_CUSTOM_WEEKLY_DAY1 + (i - dwFirstDay),
                        szDayName);

        int iIndex = ComboBox_AddString(hwndCombo, szDayName);

        // Initialize the lookup table for the combobox as we go.
        if (iDay == LOCALE_SDAYNAME1)
            s_rgwDaysOfTheWeek[iIndex] = TASK_MONDAY;
        else if (iDay == LOCALE_SDAYNAME2)
            s_rgwDaysOfTheWeek[iIndex] = TASK_TUESDAY;
        else if (iDay == LOCALE_SDAYNAME3)
            s_rgwDaysOfTheWeek[iIndex] = TASK_WEDNESDAY;
        else if (iDay == LOCALE_SDAYNAME4)
            s_rgwDaysOfTheWeek[iIndex] = TASK_THURSDAY;
        else if (iDay == LOCALE_SDAYNAME5)
            s_rgwDaysOfTheWeek[iIndex] = TASK_FRIDAY;
        else if (iDay == LOCALE_SDAYNAME6)
            s_rgwDaysOfTheWeek[iIndex] = TASK_SATURDAY;
        else if (iDay == LOCALE_SDAYNAME7)
            s_rgwDaysOfTheWeek[iIndex] = TASK_SUNDAY;
        else    
            ASSERT(FALSE);
   }

    // Show/Hide controls based on dialog type.
    if (pDlgInfo->dwFlags & SSUI_CREATENEWSCHEDULE)
    {
        // Hide the 'New' and 'Remove' buttons if
        // we are creating a new schedule group.
        ShowWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_NEWGROUP), SW_HIDE);
        ShowWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_REMOVEGROUP), SW_HIDE);

        // Hide the dropdown schedule group list.
        ShowWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST), SW_HIDE);
        ShowWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_EDIT), SW_SHOW);
    }
    else if (pDlgInfo->dwFlags & SSUI_EDITSCHEDULE)
    {
        // Hide the schedule group name edit.
        ShowWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_EDIT), SW_HIDE);
        ShowWindow(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST), SW_SHOW);

        EVAL(SUCCEEDED(SchedGroupComboBox_Fill(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST))));
        EVAL(SUCCEEDED(SchedGroupComboBox_SetCurGroup(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST), pDlgInfo->pGroupCookie)));
    }
    else
        ASSERT(FALSE);

    // Setup spinner ranges.
    UpDown_SetRange(GetDlgItem(hwndDlg, IDC_CUSTOM_DAILY_EVERYNDAYS_SPIN),
                    DEFAULT_DAILY_EVERYNDAYS_MIN, DEFAULT_DAILY_EVERYNDAYS_MAX);
    UpDown_SetRange(GetDlgItem(hwndDlg, IDC_CUSTOM_WEEKLY_REPEATWEEKS_SPIN),
                    DEFAULT_WEEKLY_REPEATWEEKS_MIN, DEFAULT_WEEKLY_REPEATWEEKS_MAX);
    UpDown_SetRange(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_SPIN),
                    DEFAULT_MONTHLY_DAY_MIN, DEFAULT_MONTHLY_DAY_MAX);
    UpDown_SetRange(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_SPIN),
                    DEFAULT_MONTHLY_MONTHS_MIN, DEFAULT_MONTHLY_MONTHS_MAX);
    UpDown_SetRange(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_SPIN),
                    DEFAULT_MONTHLY_MONTHS_MIN, DEFAULT_MONTHLY_MONTHS_MAX);
    UpDown_SetRange(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATEVERY_SPIN),
                    DEFAULT_REPEATUPDATE_HRS_MIN, DEFAULT_REPEATUPDATE_HRS_MAX);

    // Setup the time picker controls to use a short time format with no seconds.
    TCHAR szTimeFormat[MAX_SHORTTIMEFORMAT_LEN];
    LPTSTR pszTimeFormat = szTimeFormat;
    EVAL(GetLocaleInfo( LOCALE_USER_DEFAULT,
                        LOCALE_STIMEFORMAT,
                        szTimeFormat,
                        ARRAYSIZE(szTimeFormat)));

    TCHAR szTimeSep[MAX_TIMESEP_LEN];
    EVAL(GetLocaleInfo( LOCALE_USER_DEFAULT,
                        LOCALE_STIME,
                        szTimeSep,
                        ARRAYSIZE(szTimeSep)));
    int cchTimeSep = lstrlen(szTimeSep);

    TCHAR szShortTimeFormat[MAX_SHORTTIMEFORMAT_LEN];
    LPTSTR pszShortTimeFormat = szShortTimeFormat;

    // Remove the seconds format string and preceeding separator.
    while (*pszTimeFormat)
    {
        if ((*pszTimeFormat != TEXT('s')) && (*pszTimeFormat != TEXT('S')))
            *pszShortTimeFormat++ = *pszTimeFormat;
        else
        {
            *pszShortTimeFormat = TEXT('\0');

            StrTrim(szShortTimeFormat, TEXT(" "));
            StrTrim(szShortTimeFormat, szTimeSep);

            pszShortTimeFormat = szShortTimeFormat + lstrlen(szShortTimeFormat);
        }

        pszTimeFormat++;
    }

    *pszShortTimeFormat = TEXT('\0');

    // Set the format for the time picker controls.
    DateTime_SetFormat(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_UPDATEAT_TIME), szShortTimeFormat);
    DateTime_SetFormat(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN_START_TIME), szShortTimeFormat);
    DateTime_SetFormat(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN_END_TIME), szShortTimeFormat);
}

/////////////////////////////////////////////////////////////////////////////
// PositionDlgCtls
/////////////////////////////////////////////////////////////////////////////
void PositionDlgCtls
(
    HWND hwndDlg
)
{
    RECT rectDestGroup;
    GetWindowRect(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_DEST), &rectDestGroup);
    MapWindowPoints(HWND_DESKTOP, hwndDlg, (POINT *)&rectDestGroup, 2);

    for (int i = 0; i < ARRAYSIZE(c_rgnCtlGroups); i++)
    {
        HWND hwndGroup = GetDlgItem(hwndDlg, c_rgnCtlGroups[i].idContainer);
        
        ASSERT(hwndGroup != NULL);

        RECT rectSrcGroup;
        GetWindowRect(hwndGroup, &rectSrcGroup);
        MapWindowPoints(HWND_DESKTOP, hwndDlg, (POINT *)&rectSrcGroup, 2);

        for (int j = c_rgnCtlGroups[i].idFirst; j <= c_rgnCtlGroups[i].idLast; j++)
        {
            HWND hwndItem = GetDlgItem(hwndDlg, j);

            RECT rectItem;
            GetWindowRect(hwndItem, &rectItem);
            MapWindowPoints(HWND_DESKTOP, hwndDlg, (POINT *)&rectItem, 2);

            MoveWindow( hwndItem,
                        rectDestGroup.left + (rectItem.left - rectSrcGroup.left),
                        rectDestGroup.top + (rectItem.top - rectSrcGroup.top),
                        (rectItem.right - rectItem.left),
                        (rectItem.bottom - rectItem.top),
                        FALSE);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// InitDlgDefaults
/////////////////////////////////////////////////////////////////////////////
void InitDlgDefaults
(
    HWND            hwndDlg,
    SSUIDLGINFO *   pDlgInfo
)
{
    TCHAR szDefaultName[MAX_GROUPNAME_LEN];

    // Init control defaults for new schedule group.
    MLLoadString(IDS_CUSTOM_NEWSCHEDDEFNAME, szDefaultName, ARRAYSIZE(szDefaultName));

    if (pDlgInfo->dwFlags & SSUI_CREATENEWSCHEDULE)
    {
        SetDlgItemText(hwndDlg, IDC_CUSTOM_GROUP_EDIT, szDefaultName);
        SetDlgItemText(hwndDlg, IDC_CUSTOM_GROUP_LIST, szDefaultName);
        pDlgInfo->bDataChanged = FALSE;
    }

    // If we are creating a new schedule, everything needs to be saved.
    pDlgInfo->bDataChanged = ((pDlgInfo->dwFlags & SSUI_CREATENEWSCHEDULE) ? TRUE : FALSE);

    // Daily group
    CheckRadioButton(hwndDlg, IDC_TYPE_GROUP_FIRST, IDC_TYPE_GROUP_LAST, IDC_CUSTOM_DAILY);

    // Daily group properties
    CheckRadioButton(hwndDlg, IDC_DAILY_GROUP_FIRST, IDC_DAILY_GROUP_LAST, IDC_CUSTOM_DAILY_EVERYNDAYS);
    HandleDlgButtonClick(hwndDlg, IDC_CUSTOM_DAILY_EVERYNDAYS, NULL);

    SetDlgItemInt(hwndDlg, IDC_CUSTOM_DAILY_EVERYNDAYS_EDIT, DEFAULT_DAILY_EVERYNDAYS, FALSE);

    // Weekly group properties
    SetDlgItemInt(hwndDlg, IDC_CUSTOM_WEEKLY_REPEATWEEKS_EDIT, DEFAULT_WEEKLY_REPEATWEEKS, FALSE);

    SYSTEMTIME stLocal;
    GetLocalTime(&stLocal);

    WORD rgfDaysOfTheWeek = (1 << stLocal.wDayOfWeek);
    SetDlgWeekDays(hwndDlg, rgfDaysOfTheWeek);

    // Monthly group properties
    CheckRadioButton(hwndDlg, IDC_MONTHLY_GROUP_FIRST, IDC_MONTHLY_GROUP_LAST, IDC_CUSTOM_MONTHLY_DAYOFMONTH);
    HandleDlgButtonClick(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH, NULL);

    SetDlgItemInt(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_EDIT, stLocal.wDay, FALSE);
    SetDlgItemInt(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_EDIT, DEFAULT_MONTHLY_MONTHS, FALSE);

    // REVIEW: Create code to figure out item to select for current date. [jaym]
    ComboBox_SetCurSel(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_LIST1), 0);
    ComboBox_SetCurSel( GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_LIST2),
                        DayIndexFromDaysOfTheWeekFlags(rgfDaysOfTheWeek));

    SetDlgItemInt(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_EDIT, DEFAULT_MONTHLY_MONTHS, FALSE);

    // Time properties
    CheckRadioButton(hwndDlg, IDC_TIME_GROUP_FIRST, IDC_TIME_GROUP_LAST, IDC_CUSTOM_TIME_UPDATEAT);
    HandleDlgButtonClick(hwndDlg, IDC_CUSTOM_TIME_UPDATEAT, NULL);

    SYSTEMTIME st = { 0 };
    GetLocalTime(&st);
    st.wHour    = DEFAULT_UPDATETIME_HRS;
    st.wMinute  = DEFAULT_UPDATETIME_MINS;
    DateTime_SetSystemtime(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_UPDATEAT_TIME), GDT_VALID, &st);

    SetDlgItemInt(hwndDlg, IDC_CUSTOM_TIME_REPEATEVERY_EDIT, DEFAULT_REPEATUPDATE_HRS, FALSE);

    st.wHour    = DEFAULT_REPEAT_START_HRS;
    st.wMinute  = DEFAULT_REPEAT_START_MINS;
    DateTime_SetSystemtime(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN_START_TIME), GDT_VALID, &st);

    st.wHour    = DEFAULT_REPEAT_END_HRS;
    st.wMinute  = DEFAULT_REPEAT_END_MINS;
    DateTime_SetSystemtime(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN_END_TIME), GDT_VALID, &st);

    // Disable some controls if we are a predefined group.
    HWND hwndGroupList = GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST);
    HWND hwndGroupEdit = FindWindowEx(  hwndGroupList,
                                        NULL,
                                        TEXT("Edit"),
                                        NULL);

    if (*(pDlgInfo->pGroupCookie) == NOTFCOOKIE_SCHEDULE_GROUP_DAILY)
    {
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_DAILY), TRUE);
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_WEEKLY), FALSE);
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY), FALSE);
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_REMOVEGROUP), FALSE);
        Edit_SetReadOnly(hwndGroupEdit, TRUE);
    }
    else if (*(pDlgInfo->pGroupCookie) == NOTFCOOKIE_SCHEDULE_GROUP_WEEKLY)
    {
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_DAILY), FALSE);
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_WEEKLY), TRUE);
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY), FALSE);
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_REMOVEGROUP), FALSE);
        Edit_SetReadOnly(hwndGroupEdit, TRUE);
    }
    else if (*(pDlgInfo->pGroupCookie) == NOTFCOOKIE_SCHEDULE_GROUP_MONTHLY)
    {
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_DAILY), FALSE);
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_WEEKLY), FALSE);
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY), TRUE);
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_REMOVEGROUP), FALSE);
        Edit_SetReadOnly(hwndGroupEdit, TRUE);
    }
    else
    {
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_DAILY), TRUE);
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_WEEKLY), TRUE);
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY), TRUE);
        Button_Enable(GetDlgItem(hwndDlg, IDC_CUSTOM_REMOVEGROUP), TRUE);
        Edit_SetReadOnly(hwndGroupEdit, FALSE);
    }

    // Make sure the combo redraws so the enable
    // or disable of the edit control looks good.
    RedrawWindow(hwndGroupList, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);

    // Vary start of next update
    CheckDlgButton(hwndDlg, IDC_CUSTOM_MINIMIZENETUSE, BST_CHECKED);
}

/////////////////////////////////////////////////////////////////////////////
// SetDlgCustomType
/////////////////////////////////////////////////////////////////////////////
void SetDlgCustomType
(
    HWND    hwndDlg,
    int     iType
)
{
    int i;

    for (i = IDC_CUSTOM_DAILY_FIRST; i <= IDC_CUSTOM_DAILY_LAST; i++)
        ShowWindow(GetDlgItem(hwndDlg, i), ((iType == IDC_CUSTOM_DAILY) ? SW_SHOW : SW_HIDE));

    for (i = IDC_CUSTOM_WEEKLY_FIRST; i <= IDC_CUSTOM_WEEKLY_LAST; i++)
        ShowWindow(GetDlgItem(hwndDlg, i), ((iType == IDC_CUSTOM_WEEKLY) ? SW_SHOW : SW_HIDE));

    for (i = IDC_CUSTOM_MONTHLY_FIRST; i <= IDC_CUSTOM_MONTHLY_LAST; i++)
        ShowWindow(GetDlgItem(hwndDlg, i), ((iType == IDC_CUSTOM_MONTHLY) ? SW_SHOW : SW_HIDE));
}

/////////////////////////////////////////////////////////////////////////////
// InitDlgInfo
/////////////////////////////////////////////////////////////////////////////
void InitDlgInfo
(
    HWND            hwndDlg,
    SSUIDLGINFO *   pDlgInfo
)
{
    int             nIDTriggerType;
    TASK_TRIGGER *  pTT = &(pDlgInfo->ttTaskTrigger);

#ifdef DEBUG
    DumpTaskTrigger(pTT);
#endif  // DEBUG

    pDlgInfo->bInitializing = TRUE;

    // Initialize defaults for dialog controls.
    InitDlgDefaults(hwndDlg, pDlgInfo);

    CheckDlgButton( hwndDlg,
                    IDC_CUSTOM_MINIMIZENETUSE,
                    ((pTT->wRandomMinutesInterval == 0) ? BST_UNCHECKED : BST_CHECKED));

    // Initialize the 'Time' settings.
    if (pTT->MinutesInterval == 0)
    {
        // Update at N
        CheckRadioButton(hwndDlg, IDC_TIME_GROUP_FIRST, IDC_TIME_GROUP_LAST, IDC_CUSTOM_TIME_UPDATEAT);
        HandleDlgButtonClick(hwndDlg, IDC_CUSTOM_TIME_UPDATEAT, NULL);

        SYSTEMTIME st = { 0 };
        GetLocalTime(&st);
        st.wHour    = pTT->wStartHour;
        st.wMinute  = pTT->wStartMinute;
        DateTime_SetSystemtime(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_UPDATEAT_TIME), GDT_VALID, &st);
    }
    else
    {
        // Repeat every N hour(s)
        CheckRadioButton(hwndDlg, IDC_TIME_GROUP_FIRST, IDC_TIME_GROUP_LAST, IDC_CUSTOM_TIME_REPEATEVERY);
        HandleDlgButtonClick(hwndDlg, IDC_CUSTOM_TIME_REPEATEVERY, NULL);

        SetDlgItemInt(  hwndDlg,
                        IDC_CUSTOM_TIME_REPEATEVERY_EDIT,
                        ((pDlgInfo->dwRepeatHrsAreMins)
                            ? pTT->MinutesInterval
                            : (pTT->MinutesInterval / 60)),
                        FALSE);

        // Between X and Y
        if (pTT->MinutesDuration != (24 * 60))
        {
            CheckDlgButton(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN, BST_CHECKED);
            HandleDlgButtonClick(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN, NULL);

            SYSTEMTIME st = { 0 };
            GetLocalTime(&st);
            st.wHour    = pTT->wStartHour;
            st.wMinute  = pTT->wStartMinute;
            DateTime_SetSystemtime(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN_START_TIME), GDT_VALID, &st);

            DWORD dwEndTime = IncTime(  MAKELONG(pTT->wStartHour, pTT->wStartMinute),
                                        (pTT->MinutesDuration / 60),
                                        (pTT->MinutesDuration % 60));

            st.wHour = LOWORD(dwEndTime);
            st.wMinute = HIWORD(dwEndTime);
            DateTime_SetSystemtime(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN_END_TIME), GDT_VALID, &st);
        }
    }

    // Initialize the 'Days' settings.
    switch (pTT->TriggerType)
    {
        case TASK_TIME_TRIGGER_DAILY:
        {
            nIDTriggerType = IDC_CUSTOM_DAILY;

            // Every N day(s)
            CheckRadioButton(hwndDlg, IDC_DAILY_GROUP_FIRST, IDC_DAILY_GROUP_LAST, IDC_CUSTOM_DAILY_EVERYNDAYS);
            HandleDlgButtonClick(hwndDlg, IDC_CUSTOM_DAILY_EVERYNDAYS, NULL);

            SetDlgItemInt(hwndDlg, IDC_CUSTOM_DAILY_EVERYNDAYS_EDIT, pTT->Type.Daily.DaysInterval, FALSE);
            break;
        }

        case TASK_TIME_TRIGGER_WEEKLY:
        {
            // Special case for Weekly repeating every 1 week
            if  (
                (pTT->Type.Weekly.WeeksInterval == 1)
                &&
                (pTT->Type.Weekly.rgfDaysOfTheWeek == TASK_WEEKDAYS)
                )
            {
                if (*(pDlgInfo->pGroupCookie) == NOTFCOOKIE_SCHEDULE_GROUP_WEEKLY)
                {
                    nIDTriggerType = IDC_CUSTOM_WEEKLY;

                    // Weekly -- Every 1 week on MTWTF
                    SetDlgItemInt(hwndDlg, IDC_CUSTOM_WEEKLY_REPEATWEEKS_EDIT, 1, FALSE);
                    SetDlgWeekDays(hwndDlg, TASK_WEEKDAYS);
                }
                else
                {
                    nIDTriggerType = IDC_CUSTOM_DAILY;

                    // Daily -- Every weekday
                    CheckRadioButton(hwndDlg, IDC_DAILY_GROUP_FIRST, IDC_DAILY_GROUP_LAST, IDC_CUSTOM_DAILY_EVERYWEEKDAY);
                    HandleDlgButtonClick(hwndDlg, IDC_CUSTOM_DAILY_EVERYWEEKDAY, NULL);
                }
            }
            else
            {
                nIDTriggerType = IDC_CUSTOM_WEEKLY;

                // Weekly -- Every N weeks on SMTWTFS
                 
                // Every N weeks
                SetDlgItemInt(hwndDlg, IDC_CUSTOM_WEEKLY_REPEATWEEKS_EDIT, pTT->Type.Weekly.WeeksInterval, FALSE);

                // on SMTWTFS
                SetDlgWeekDays(hwndDlg, pTT->Type.Weekly.rgfDaysOfTheWeek);
            }
            break;
        }

        case TASK_TIME_TRIGGER_MONTHLYDATE:
        {
            nIDTriggerType = IDC_CUSTOM_MONTHLY;

            // Monthly -- Day X of every Y month(s)
            CheckRadioButton(hwndDlg, IDC_MONTHLY_GROUP_FIRST, IDC_MONTHLY_GROUP_LAST, IDC_CUSTOM_MONTHLY_DAYOFMONTH);
            HandleDlgButtonClick(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH, NULL);

            // Day X
            SetDlgItemInt(  hwndDlg,
                            IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_EDIT,
                            DayFromDaysFlags(pTT->Type.MonthlyDate.rgfDays),
                            FALSE);

            // of every Y month(s)
            SetDlgItemMonth(hwndDlg,
                            IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_EDIT,
                            pTT->Type.MonthlyDate.rgfMonths);
            break;
        }

        case TASK_TIME_TRIGGER_MONTHLYDOW:
        {
            nIDTriggerType = IDC_CUSTOM_MONTHLY;

            // Monthly -- The X Y of every Z month(s)
            CheckRadioButton(hwndDlg, IDC_MONTHLY_GROUP_FIRST, IDC_MONTHLY_GROUP_LAST, IDC_CUSTOM_MONTHLY_PERIODIC);
            HandleDlgButtonClick(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC, NULL);

            // The X
            ComboBox_SetCurSel( GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_LIST1),
                                pTT->Type.MonthlyDOW.wWhichWeek-1);

            // Y
            ComboBox_SetCurSel( GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_LIST2),
                                DayIndexFromDaysOfTheWeekFlags(pTT->Type.MonthlyDOW.rgfDaysOfTheWeek));

            // of every Z month(s)
            SetDlgItemMonth(hwndDlg,
                            IDC_CUSTOM_MONTHLY_PERIODIC_EDIT,
                            pTT->Type.MonthlyDOW.rgfMonths);
            break;
        }

        default:
        {
            ASSERT(FALSE);
            break;
        }
    }

    CheckRadioButton(hwndDlg, IDC_TYPE_GROUP_FIRST, IDC_TYPE_GROUP_LAST, nIDTriggerType);
    HandleDlgButtonClick(hwndDlg, nIDTriggerType, NULL);

    SetTaskTriggerFromDlg(hwndDlg, pDlgInfo);
    SetDlgItemNextUpdate(hwndDlg, IDC_CUSTOM_NEXTUPDATE, pDlgInfo);

    // Set focus to the group name control.
    if (IsWindowVisible(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_EDIT)))
        SetFocus(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_EDIT));
    else
        SetFocus(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST));

    // Make sure we get asked to save for new groups.
    pDlgInfo->bDataChanged = ((pDlgInfo->dwFlags & SSUI_CREATENEWSCHEDULE) ? TRUE : FALSE);

    pDlgInfo->bScheduleNameChanged = FALSE;

    pDlgInfo->bInitializing = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// SetDlgWeekDays
/////////////////////////////////////////////////////////////////////////////
void SetDlgWeekDays
(
    HWND hwndDlg,
    WORD rgfDaysOfTheWeek
)
{
    // If it doesn't have any days, stick one in arbitrarily.
    if (rgfDaysOfTheWeek == 0)
        rgfDaysOfTheWeek = TASK_SUNDAY;

    DWORD dwFirstDay = 0;
    EVAL(GetLocaleInfo( LOCALE_USER_DEFAULT,
                        LOCALE_IFIRSTDAYOFWEEK,
                        (char *)&dwFirstDay,
                        SIZEOF(DWORD)));

    dwFirstDay = LOCALE_SDAYNAME1 + (dwFirstDay - TEXT('0'));

    for (DWORD i = dwFirstDay; i <= dwFirstDay+7; i++)
    {
        BOOL    bCheck; 
        int     iDay = ((i <= LOCALE_SDAYNAME7) ? i
                                                : (LOCALE_SDAYNAME1 + (i - LOCALE_SDAYNAME7 - 1)));

        if (iDay == LOCALE_SDAYNAME1)
            bCheck = (rgfDaysOfTheWeek & TASK_MONDAY);
        else if (iDay == LOCALE_SDAYNAME2)
            bCheck = (rgfDaysOfTheWeek & TASK_TUESDAY);
        else if (iDay == LOCALE_SDAYNAME3)
            bCheck = (rgfDaysOfTheWeek & TASK_WEDNESDAY);
        else if (iDay == LOCALE_SDAYNAME4)
            bCheck = (rgfDaysOfTheWeek & TASK_THURSDAY);
        else if (iDay == LOCALE_SDAYNAME5)
            bCheck = (rgfDaysOfTheWeek & TASK_FRIDAY);
        else if (iDay == LOCALE_SDAYNAME6)
            bCheck = (rgfDaysOfTheWeek & TASK_SATURDAY);
        else if (iDay == LOCALE_SDAYNAME7)
            bCheck = (rgfDaysOfTheWeek & TASK_SUNDAY);
        else
            ASSERT(FALSE);

        CheckDlgButton( hwndDlg,
                        IDC_CUSTOM_WEEKLY_DAY1 + (i - dwFirstDay),
                        (bCheck ? BST_CHECKED : BST_UNCHECKED));
    }
}

/////////////////////////////////////////////////////////////////////////////
// GetDlgWeekDays
/////////////////////////////////////////////////////////////////////////////
WORD GetDlgWeekDays
(
    HWND hwndDlg
)
{
    WORD wDays = 0;

    DWORD dwFirstDay = 0;
    EVAL(GetLocaleInfo( LOCALE_USER_DEFAULT,
                        LOCALE_IFIRSTDAYOFWEEK,
                        (char *)&dwFirstDay,
                        SIZEOF(DWORD)));

    dwFirstDay = LOCALE_SDAYNAME1 + (dwFirstDay - TEXT('0'));

    for (DWORD i = dwFirstDay; i <= dwFirstDay+7; i++)
    {
        if (IsDlgButtonChecked( hwndDlg,
                                IDC_CUSTOM_WEEKLY_DAY1 + (i - dwFirstDay)) == BST_CHECKED)
        {
            int iDay = ((i <= LOCALE_SDAYNAME7) ? i
                                                : (LOCALE_SDAYNAME1 + (i - LOCALE_SDAYNAME7 - 1)));

            
            if (iDay == LOCALE_SDAYNAME1)
                wDays |= TASK_MONDAY;
            else if (iDay == LOCALE_SDAYNAME2)
                wDays |= TASK_TUESDAY;
            else if (iDay == LOCALE_SDAYNAME3)
                wDays |= TASK_WEDNESDAY;
            else if (iDay == LOCALE_SDAYNAME4)
                wDays |= TASK_THURSDAY;
            else if (iDay == LOCALE_SDAYNAME5)
                wDays |= TASK_FRIDAY;
            else if (iDay == LOCALE_SDAYNAME6)
                wDays |= TASK_SATURDAY;
            else if (iDay == LOCALE_SDAYNAME7)
                wDays |= TASK_SUNDAY;
            else
                ASSERT(FALSE);
        }
    }

    return wDays;
}

/////////////////////////////////////////////////////////////////////////////
// SetTaskTriggerFromDlg
/////////////////////////////////////////////////////////////////////////////
void SetTaskTriggerFromDlg
(
    HWND            hwndDlg,
    SSUIDLGINFO *   pDlgInfo
)
{
    BOOL            bTranslated;
    TASK_TRIGGER *  pTT = &pDlgInfo->ttTaskTrigger;

    ZeroMemory(pTT, SIZEOF(TASK_TRIGGER));
    pTT->cbTriggerSize = SIZEOF(TASK_TRIGGER);

    // Init start date to now.
    SYSTEMTIME st;
    GetLocalTime(&st);
    pTT->wBeginYear    = st.wYear;
    pTT->wBeginMonth   = st.wMonth;
    pTT->wBeginDay     = st.wDay;

    // Vary start of update
    if (IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_MINIMIZENETUSE) == BST_CHECKED)
        pTT->wRandomMinutesInterval = DEFAULT_RANDOM_MINUTES_INTERVAL;
    else
        pTT->wRandomMinutesInterval = 0;

    // Initialize the 'Time' related settings.
    if (IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_TIME_UPDATEAT) == BST_CHECKED)
    {
        // Update at N
        SYSTEMTIME st = { 0 };
        DateTime_GetSystemtime(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_UPDATEAT_TIME), &st);

        pTT->wStartHour    = st.wHour;
        pTT->wStartMinute  = st.wMinute;
    }
    else
    {
        // Repeat every N hours
        ASSERT(IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_TIME_REPEATEVERY) == BST_CHECKED)

        // Between X and Y
        if (IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN) == BST_CHECKED)
        {
            // Between X
            SYSTEMTIME st = { 0 };
            DateTime_GetSystemtime( GetDlgItem( hwndDlg, 
                                                IDC_CUSTOM_TIME_REPEATBETWEEN_START_TIME),
                                    &st);

            pTT->wStartHour    = st.wHour;
            pTT->wStartMinute  = st.wMinute;

            WORD wStartMins = (st.wHour * 60) + st.wMinute;

            DateTime_GetSystemtime( GetDlgItem( hwndDlg,
                                                IDC_CUSTOM_TIME_REPEATBETWEEN_END_TIME),
                                    &st);

            WORD wEndMins = (st.wHour * 60) + st.wMinute;

            // And Y
            if (wStartMins > wEndMins)
                pTT->MinutesDuration = (1440 - wStartMins) + wEndMins;
            else
                pTT->MinutesDuration = wEndMins - wStartMins;
        }
        else
        {
            // If we are not between a hour range, begin update at the start of the day.
            pTT->wStartHour         = 0;    // 12:00am
            pTT->wStartMinute       = 0;
            pTT->MinutesDuration    = (24 * 60);
        }

        // Set the interval.
        int iHours = GetDlgItemInt( hwndDlg,
                                    IDC_CUSTOM_TIME_REPEATEVERY_EDIT,
                                    &bTranslated,
                                    FALSE);

        ASSERT(bTranslated && (iHours > 0));

        if (pDlgInfo->dwRepeatHrsAreMins)
            pTT->MinutesInterval = iHours;
        else
            pTT->MinutesInterval = iHours * 60;
    }

    // Initialize the 'Days' related settings.

    // Daily schedule
    if (IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_DAILY) == BST_CHECKED)
    {
        // Daily -- Every N days
        if (IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_DAILY_EVERYNDAYS) == BST_CHECKED)
        {
            pTT->TriggerType = TASK_TIME_TRIGGER_DAILY;
            pTT->Type.Daily.DaysInterval = GetDlgItemInt(   hwndDlg,
                                                            IDC_CUSTOM_DAILY_EVERYNDAYS_EDIT,
                                                            &bTranslated,
                                                            FALSE);
        }
        else
        {
            // Daily -- Every Weekday
            ASSERT(IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_DAILY_EVERYWEEKDAY));

            pTT->TriggerType = TASK_TIME_TRIGGER_WEEKLY;
            pTT->Type.Weekly.WeeksInterval = 1;
            pTT->Type.Weekly.rgfDaysOfTheWeek = TASK_WEEKDAYS;
                                                        
        }
    }
    // Weekly schedule
    else if (IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_WEEKLY) == BST_CHECKED)
    {
        pTT->TriggerType = TASK_TIME_TRIGGER_WEEKLY;

        // Weekly -- Repeat every N days
        pTT->Type.Weekly.WeeksInterval = GetDlgItemInt( hwndDlg,
                                                        IDC_CUSTOM_WEEKLY_REPEATWEEKS_EDIT,
                                                        &bTranslated,
                                                        FALSE);

        // Weekly -- Days of the week
        pTT->Type.Weekly.rgfDaysOfTheWeek = GetDlgWeekDays(hwndDlg);
    }
    // Monthly schedule
    else
    {
        ASSERT(IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_MONTHLY) == BST_CHECKED);

        // Monthly -- Day X of every Y month(s)
        if (IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH) == BST_CHECKED)
        {
            pTT->TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;

            int iDate = GetDlgItemInt(  hwndDlg,
                                        IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_EDIT,
                                        &bTranslated,
                                        FALSE);

            ASSERT(iDate > 0);

            // Day X
            pTT->Type.MonthlyDate.rgfDays = (1 << (iDate - 1));

            // of every Y month(s)
            pTT->Type.MonthlyDate.rgfMonths = GetDlgItemMonth(hwndDlg, IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_EDIT);
        }
        else
        {
            // Monthly -- The X Y of every Z month(s)
            ASSERT(IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC) == BST_CHECKED);

            pTT->TriggerType = TASK_TIME_TRIGGER_MONTHLYDOW;

            // The X
            int iWeek = ComboBox_GetCurSel(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_LIST1))+1;
            ASSERT((iWeek >= TASK_FIRST_WEEK) && (iWeek <= TASK_LAST_WEEK));
            pTT->Type.MonthlyDOW.wWhichWeek = iWeek;

            // Y
            int iDaysOfWeek = ComboBox_GetCurSel(GetDlgItem(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_LIST2));
            ASSERT((iDaysOfWeek >= 0) && (iDaysOfWeek < ARRAYSIZE(s_rgwDaysOfTheWeek)));
            pTT->Type.MonthlyDOW.rgfDaysOfTheWeek = s_rgwDaysOfTheWeek[iDaysOfWeek];

            // of every Z month(s)
            pTT->Type.MonthlyDOW.rgfMonths = GetDlgItemMonth(hwndDlg, IDC_CUSTOM_MONTHLY_PERIODIC_EDIT);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// SetTaskTriggerToDefaults
/////////////////////////////////////////////////////////////////////////////
void SetTaskTriggerToDefaults
(
    TASK_TRIGGER * pTT
)
{
    ASSERT(pTT != NULL);

    // REVIEW: Make this a const static struct and assign instead of function?
    ZeroMemory(pTT, SIZEOF(TASK_TRIGGER));

    pTT->cbTriggerSize              = SIZEOF(TASK_TRIGGER);
    pTT->wStartHour                 = DEFAULT_UPDATETIME_HRS;
    pTT->wStartMinute               = DEFAULT_UPDATETIME_MINS;
    pTT->TriggerType                = TASK_TIME_TRIGGER_DAILY;
    pTT->Type.Daily.DaysInterval    = DEFAULT_DAILY_EVERYNDAYS;
}

/////////////////////////////////////////////////////////////////////////////
// OnDataChanged
/////////////////////////////////////////////////////////////////////////////
void OnDataChanged
(
    HWND            hwndDlg,
    SSUIDLGINFO *   pDlgInfo
)
{
    // Ignore if we are setting up the dialog control values.
    if (pDlgInfo->bInitializing)
        return;

    // Update the TASK_TRIGGER to new user settings.
    SetTaskTriggerFromDlg(hwndDlg, pDlgInfo);

    // Calc and display next update time.
    SetDlgItemNextUpdate(hwndDlg, IDC_CUSTOM_NEXTUPDATE, pDlgInfo);

    // Data changed
    pDlgInfo->bDataChanged = TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// ApplyDlgChanges
/////////////////////////////////////////////////////////////////////////////
HRESULT ApplyDlgChanges
(
    HWND            hwndDlg,
    SSUIDLGINFO *   pDlgInfo
)
{
    HRESULT hrResult;

    if (ValidateDlgFields(hwndDlg, pDlgInfo))
    {
        HWND hwndCombo = GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST);

        if (pDlgInfo->dwFlags & SSUI_CREATENEWSCHEDULE)
        {
            if (SUCCEEDED(hrResult = CreateScheduleGroupFromDlg(hwndDlg, pDlgInfo)))
            {
                pDlgInfo->dwFlags |= SSUI_SCHEDULECREATED;

                // Update the combobox with the new group, just
                // in case we aren't closing the dialog.
                TCHAR szGroupName[MAX_GROUPNAME_LEN];
                GetDlgGroupName(hwndDlg, szGroupName, ARRAYSIZE(szGroupName));

                EVAL(SUCCEEDED(SchedGroupComboBox_AddGroup( hwndCombo,
                                                            szGroupName,
                                                            pDlgInfo->pGroupCookie)));
            }
            else
            {
                // REVIEW: Error message! [jaym]
                MessageBeep(MB_ICONEXCLAMATION);
            }
        }
        else
        {
            ASSERT(pDlgInfo->dwFlags & SSUI_EDITSCHEDULE);

            TCHAR szGroupName[MAX_GROUPNAME_LEN];
            GetDlgGroupName(hwndDlg, szGroupName, ARRAYSIZE(szGroupName));

            WCHAR wszGroupName[MAX_GROUPNAME_LEN];
            MyStrToOleStrN(wszGroupName, MAX_GROUPNAME_LEN, szGroupName);

            GROUPINFO gi;
            gi.cbSize = SIZEOF(GROUPINFO);
            gi.pwzGroupname = wszGroupName;

            SetTaskTriggerFromDlg(hwndDlg, pDlgInfo);

#ifdef DEBUG
            DumpTaskTrigger(&pDlgInfo->ttTaskTrigger);
#endif  // DEBUG

            if (SUCCEEDED(hrResult = ModifyScheduleGroup(   pDlgInfo->pGroupCookie,
                                                            &pDlgInfo->ttTaskTrigger,
                                                            NULL,
                                                            &gi,
                                                            0)))
            {
                pDlgInfo->dwFlags |= SSUI_SCHEDULECHANGED;
//xnotfmgr

                // Reset combo list entry because name may have changed.
                NOTIFICATIONCOOKIE cookie;
                EVAL(SUCCEEDED(SchedGroupComboBox_GetCurGroup(hwndCombo, &cookie)));

                EVAL(SUCCEEDED(SchedGroupComboBox_RemoveGroup(hwndCombo, pDlgInfo->pGroupCookie)));
                EVAL(SUCCEEDED(SchedGroupComboBox_AddGroup(hwndCombo, szGroupName, pDlgInfo->pGroupCookie)));

                EVAL(SUCCEEDED(SchedGroupComboBox_SetCurGroup(hwndCombo, &cookie)));
            }
            else
            {
                // REVIEW: Error message! [jaym]
                MessageBeep(MB_ICONEXCLAMATION);
            }
        }
    }
    else
        hrResult = E_FAIL;

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// ValidateDlgFields
/////////////////////////////////////////////////////////////////////////////
BOOL ValidateDlgFields
(
    HWND            hwndDlg,
    SSUIDLGINFO *   pDlgInfo
)
{
    BOOL bResult = FALSE;   // Assume the worst.

    TCHAR szGroupName[MAX_GROUPNAME_LEN];
    GetDlgGroupName(hwndDlg, szGroupName, ARRAYSIZE(szGroupName));

    for (;;)
    {
        int cchGroupNameLen = GetDlgGroupNameLength(hwndDlg);

        // Check length of group name. Tell user if too long.
        if (cchGroupNameLen >= MAX_GROUPNAME_LEN)
        {
            SGMessageBox(   hwndDlg,
                            IDS_CUSTOM_ERROR_NAMETOOLONG,
                            MB_OK | MB_ICONEXCLAMATION);
            break;
        }

        // Make sure we have a description
        if (cchGroupNameLen <= 0)
        {
            SGMessageBox(   hwndDlg,
                            IDS_CUSTOM_ERROR_NAMEREQUIRED,
                            MB_OK | MB_ICONEXCLAMATION);
            break;
        }
        
        // Check to see if group name is already in use.
        if  (
            (
                pDlgInfo->bScheduleNameChanged
                ||
                (pDlgInfo->dwFlags & SSUI_CREATENEWSCHEDULE)
            )
            &&
            ScheduleGroupExists(szGroupName)
            )
        {
            SGMessageBox(   hwndDlg,
                            IDS_CUSTOM_ERROR_NAMEEXISTS,
                            MB_OK | MB_ICONEXCLAMATION);

            break;
        }

        // NOTE: Spin ranges are checked in RestrictDlgItemRange()

        bResult = TRUE;
        break;
    }

    if (!bResult)
    {
        // Set focus to the group name control.
        if (IsWindowVisible(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_EDIT)))
            SetFocus(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_EDIT));
        else
            SetFocus(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST));
    }

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// GetDlgGroupName
/////////////////////////////////////////////////////////////////////////////
UINT GetDlgGroupName
(
    HWND    hwndDlg,
    LPTSTR  pszGroupName,
    int     cchGroupNameLen
)
{
    UINT uResult;

    if (IsWindowVisible(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_EDIT)))
    {
        uResult = GetDlgItemText(   hwndDlg,
                                    IDC_CUSTOM_GROUP_EDIT,
                                    pszGroupName,
                                    cchGroupNameLen);
    }
    else if (IsWindowVisible(GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST)))
    {
        uResult = GetDlgItemText(   hwndDlg,
                                    IDC_CUSTOM_GROUP_LIST,
                                    pszGroupName,
                                    cchGroupNameLen);
    }
    else
        uResult = 0;

    return uResult;
}

/////////////////////////////////////////////////////////////////////////////
// GetDlgGroupNameLength
/////////////////////////////////////////////////////////////////////////////
int GetDlgGroupNameLength
(
    HWND hwndDlg
)
{
    HWND hwndCtl;

    if  (
        IsWindowVisible(hwndCtl = GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_EDIT))
        ||
        IsWindowVisible(hwndCtl = GetDlgItem(hwndDlg, IDC_CUSTOM_GROUP_LIST))
        )
    {
        return GetWindowTextLength(hwndCtl);
    }
    else
        return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CreateScheduleGroupFromDlg
/////////////////////////////////////////////////////////////////////////////
HRESULT CreateScheduleGroupFromDlg
(
    HWND          hwndDlg,
    SSUIDLGINFO * pDlgInfo
)
{
    HRESULT hrResult;

    ASSERT(hwndDlg != NULL);
    ASSERT(IsWindow(hwndDlg));
    ASSERT(pDlgInfo != NULL);

    for (;;)
    {
        *(pDlgInfo->pGroupCookie) = GUID_NULL;
        
        // Get the Trigger info from the dialog control states.
        SetTaskTriggerFromDlg(hwndDlg, pDlgInfo);

#ifdef DEBUG
        DumpTaskTrigger(&pDlgInfo->ttTaskTrigger);
#endif  // DEBUG

        TCHAR szGroupName[MAX_GROUPNAME_LEN];
        GetDlgGroupName(hwndDlg, szGroupName, ARRAYSIZE(szGroupName));

        WCHAR wszGroupName[MAX_GROUPNAME_LEN];
        MyStrToOleStrN(wszGroupName, MAX_GROUPNAME_LEN, szGroupName);

        GROUPINFO gi;
        gi.cbSize = SIZEOF(GROUPINFO);
        gi.pwzGroupname = wszGroupName;

        if (FAILED(hrResult = CreateScheduleGroup(  &pDlgInfo->ttTaskTrigger,
                                                    NULL,
                                                    &gi,
                                                    0,
                                                    pDlgInfo->pGroupCookie)))
        {
            TraceMsg(TF_ERROR, "CSGFD: Unable to CreateScheduleGroup");
            break;
        }

        break;
    }

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// RestrictDlgItemRange
/////////////////////////////////////////////////////////////////////////////
void RestrictDlgItemRange
(
    HWND            hwndDlg,
    int             idCtl,
    SSUIDLGINFO *   pDlgInfo
)
{
    // Special case repeat-every, which is based on the
    // time values of other controls in the dialog.
    if  (
        (idCtl == IDC_CUSTOM_TIME_REPEATEVERY_EDIT)
        &&
        (IsDlgButtonChecked(hwndDlg, IDC_CUSTOM_TIME_REPEATBETWEEN) == BST_CHECKED)
        )
    {
        RestrictTimeRepeatEvery(hwndDlg);
    }
    else
    {
        int     nMin;
        int     nMax;
        int     nDefault;
        BOOL    bTranslated;

        // Get predefined range
        switch (idCtl)
        {
            case IDC_CUSTOM_DAILY_EVERYNDAYS_EDIT:
            {
                nMin = DEFAULT_DAILY_EVERYNDAYS_MIN;
                nMax = DEFAULT_DAILY_EVERYNDAYS_MAX;
                nDefault = DEFAULT_DAILY_EVERYNDAYS;
                break;
            }

            case IDC_CUSTOM_WEEKLY_REPEATWEEKS_EDIT:
            {
                nMin = DEFAULT_WEEKLY_REPEATWEEKS_MIN;
                nMax = DEFAULT_WEEKLY_REPEATWEEKS_MAX;
                nDefault = DEFAULT_WEEKLY_REPEATWEEKS;
                break;
            }

            case IDC_CUSTOM_MONTHLY_DAYOFMONTH_DAY_EDIT:
            {
                SYSTEMTIME stLocal;
                GetLocalTime(&stLocal);

                nMin = DEFAULT_MONTHLY_DAY_MIN;
                nMax = DEFAULT_MONTHLY_DAY_MAX;
                nDefault = stLocal.wDay;
                break;
            }

            case IDC_CUSTOM_MONTHLY_DAYOFMONTH_MONTH_EDIT:
            {
                nMin = DEFAULT_MONTHLY_MONTHS_MIN;
                nMax = DEFAULT_MONTHLY_MONTHS_MAX;
                nDefault = DEFAULT_MONTHLY_MONTHS;
                break;
            }

            case IDC_CUSTOM_MONTHLY_PERIODIC_EDIT:
            {
                nMin = DEFAULT_MONTHLY_MONTHS_MIN;
                nMax = DEFAULT_MONTHLY_MONTHS_MAX;
                nDefault = DEFAULT_MONTHLY_MONTHS;
                break;
            }

            case IDC_CUSTOM_TIME_REPEATEVERY_EDIT:
            {
                nMin = DEFAULT_REPEATUPDATE_HRS_MIN;
                nMax = DEFAULT_REPEATUPDATE_HRS_MAX;
                nDefault = DEFAULT_REPEATUPDATE_HRS;
                break;
            }

            default:
            {
                ASSERT(FALSE);
                break;
            }
        }

        // Get current value
        BOOL    bChanged = FALSE;
        int     nCurrent = (int)GetDlgItemInt(hwndDlg, idCtl, &bTranslated, TRUE);

        if (bTranslated)
        {
            int nRestricted = min(nMax, max(nMin, nCurrent));

            if (nRestricted != nCurrent)
                SetDlgItemInt(hwndDlg, idCtl, nRestricted, TRUE);
        }
        else
            SetDlgItemInt(hwndDlg, idCtl, nDefault, TRUE);

    }
}

/////////////////////////////////////////////////////////////////////////////
// RestrictTimeRepeatEvery
/////////////////////////////////////////////////////////////////////////////
void RestrictTimeRepeatEvery
(
    HWND hwndDlg
)
{
    SYSTEMTIME st = { 0 };
    DateTime_GetSystemtime( GetDlgItem( hwndDlg, 
                                        IDC_CUSTOM_TIME_REPEATBETWEEN_START_TIME),
                            &st);
    WORD wStartMins = (st.wHour * 60) + st.wMinute;

    DateTime_GetSystemtime( GetDlgItem( hwndDlg,
                                        IDC_CUSTOM_TIME_REPEATBETWEEN_END_TIME),
                            &st);
    WORD wEndMins = (st.wHour * 60) + st.wMinute;

    WORD nHours;
    if (wStartMins > wEndMins)
        nHours = ((1440 - wStartMins) + wEndMins) / 60;
    else
        nHours = (wEndMins - wStartMins) / 60;

    if (nHours <= 0)
        nHours = DEFAULT_REPEATUPDATE_HRS_MIN;

    UpDown_SetRange(GetDlgItem(hwndDlg, IDC_CUSTOM_TIME_REPEATEVERY_SPIN),
                    DEFAULT_REPEATUPDATE_HRS_MIN, nHours);

    BOOL bTranslated;
    int nRepeatEvery = GetDlgItemInt(   hwndDlg,
                                        IDC_CUSTOM_TIME_REPEATEVERY_EDIT,
                                        &bTranslated,
                                        FALSE);

    int nRestricted = min(nHours, max(1, nRepeatEvery));
    if (nRestricted != nRepeatEvery)
    {
        SetDlgItemInt(  hwndDlg,
                        IDC_CUSTOM_TIME_REPEATEVERY_EDIT,
                        nRestricted,
                        FALSE);
    }
}

/////////////////////////////////////////////////////////////////////////////
// Helper functions
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// GetSchedGroupTaskTrigger
/////////////////////////////////////////////////////////////////////////////
HRESULT GetSchedGroupTaskTrigger
(
    PNOTIFICATIONCOOKIE pGroupCookie,
    TASK_TRIGGER *      pTT
)
{
//xnotfmgr

    INotificationMgr *  pNotificationMgr = NULL;
    IScheduleGroup *    pScheduleGroup = NULL;
    HRESULT             hrResult;

    ASSERT(pGroupCookie != NULL);
    ASSERT(pTT != NULL);
    
    for (;;)
    {
        ZeroMemory(pTT, SIZEOF(TASK_TRIGGER));
        pTT->cbTriggerSize = SIZEOF(TASK_TRIGGER);

        if (FAILED(hrResult = GetNotificationMgr(&pNotificationMgr)))
        {
            TraceMsg(TF_ERROR, "GSGTaskTrigger: Unable to get NotificationMgr");
            break;
        }

        if (FAILED(hrResult = pNotificationMgr->FindScheduleGroup(  pGroupCookie,
                                                                    &pScheduleGroup,
                                                                    0)))
        {
            TraceMsg(TF_ERROR, "GSGTaskTrigger: Unable to locate schedule group");
            break;
        }

        if (FAILED(hrResult = pScheduleGroup->GetAttributes(pTT,
                                                            NULL,
                                                            NULL,
                                                            NULL,
                                                            NULL,
                                                            NULL)))
        {
            TraceMsg(TF_ERROR, "GSGTaskTrigger: Unable to get schedule group attributes");
            break;
        }

        break;
    }

    SAFERELEASE(pScheduleGroup);
    SAFERELEASE(pNotificationMgr);

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// CreateScheduleGroup
/////////////////////////////////////////////////////////////////////////////
HRESULT CreateScheduleGroup
(
    /* [in] */  PTASK_TRIGGER       pTaskTrigger,
    /* [in] */  PTASK_DATA          pTaskData,
    /* [in] */  PGROUPINFO          pGroupInfo,
    /* [in] */  GROUPMODE           grfGroupMode,
    /* [out] */ PNOTIFICATIONCOOKIE pGroupCookie
)
{
//xnotfmgr

    INotificationMgr *  pNotificationMgr = NULL;
    IScheduleGroup *    pScheduleGroup = NULL;
    HRESULT             hrResult;

    for (;;)
    {
        if (pGroupCookie == NULL)
            return E_INVALIDARG;

        if (FAILED(hrResult = GetNotificationMgr(&pNotificationMgr)))
        {
            TraceMsg(TF_ERROR, "CSG: Unable to get NotificationMgr");
            break;
        }

        if (FAILED(hrResult = pNotificationMgr->CreateScheduleGroup(0,
                                                                    &pScheduleGroup,
                                                                    pGroupCookie,
                                                                    0)))
        {
            TraceMsg(TF_ERROR, "CSG: Unable to CreateScheduleGroup");
            break;
        }

        ASSERT(!pTaskData);
        if (FAILED(hrResult = pScheduleGroup->SetAttributes(pTaskTrigger,
                                                            pTaskData,
                                                            pGroupCookie,
                                                            pGroupInfo,
                                                            grfGroupMode)))
        {
            TraceMsg(TF_ERROR, "CSG: Unable to SetAttributes");
            break;
        }

        break;
    }

    SAFERELEASE(pScheduleGroup);
    SAFERELEASE(pNotificationMgr);

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// ModifyScheduleGroup
/////////////////////////////////////////////////////////////////////////////
HRESULT ModifyScheduleGroup
(
    /* [in] */  PNOTIFICATIONCOOKIE pGroupCookie,
    /* [in] */  PTASK_TRIGGER       pTaskTrigger,
    /* [in] */  PTASK_DATA          pTaskData,
    /* [in] */  PGROUPINFO          pGroupInfo,
    /* [in] */  GROUPMODE           grfGroupMode
)
{
//xnotfmgr

    INotificationMgr *  pNotificationMgr = NULL;
    IScheduleGroup *    pScheduleGroup = NULL;
    HRESULT             hrResult;

    // This might take a while.
    WAITCURSOR Hourglass;

    for (;;)
    {
        if  (
            (pGroupCookie == NULL)
            ||
            (*pGroupCookie == GUID_NULL)
            )
        {
            return E_INVALIDARG;
        }

        if (FAILED(hrResult = GetNotificationMgr(&pNotificationMgr)))
        {
            TraceMsg(TF_ERROR, "MSG: Unable to get NotificationMgr");
            break;
        }

        if (FAILED(hrResult = pNotificationMgr->FindScheduleGroup(  pGroupCookie,
                                                                    &pScheduleGroup,
                                                                    0)))
        {
            TraceMsg(TF_ERROR, "MSG: Unable to locate schedule group");
            break;
        }

        ASSERT(!pTaskData);
        if (FAILED(hrResult = pScheduleGroup->SetAttributes(pTaskTrigger,
                                                            pTaskData,
                                                            pGroupCookie,
                                                            pGroupInfo,
                                                            grfGroupMode)))
        {
            TraceMsg(TF_ERROR, "MSG: Unable to SetAttributes");
            break;
        }

        {
            LPENUMNOTIFICATION  pEnum = NULL;
            NOTIFICATIONITEM    item = {0};
            OOEBuf  ooeBuf;
            HRESULT hr;

            if (FAILED(hr = pScheduleGroup->GetEnumNotification(0, &pEnum)))
            {
                TraceMsg(TF_ERROR, "MSG: Unable to GetEnumNotification");
                break;
            }

            memset(&ooeBuf, 0, sizeof(ooeBuf));

            item.cbSize = sizeof(NOTIFICATIONITEM);
            ULONG   cItems = 0;
            DWORD   dwBufSize = 0;

            hr = pEnum->Next(1, &item, &cItems);
            while (SUCCEEDED(hr) && cItems) {
                ASSERT(item.pNotification);
                hr = LoadOOEntryInfo(&ooeBuf, &item, &dwBufSize);
                SAFERELEASE(item.pNotification);
                if (hr == S_OK) {
                    LPMYPIDL pooi = COfflineFolderEnum::NewPidl(dwBufSize);
                    if (pooi)   {
                        CopyToMyPooe(&ooeBuf, &(pooi->ooe));
                        _GenerateEvent( SHCNE_UPDATEITEM,
                                        (LPITEMIDLIST)pooi,
                                        NULL);
                        COfflineFolderEnum::FreePidl(pooi);
                    } else  {
                        hr = E_OUTOFMEMORY;     //  Ignore it?
                    }
                }
                ZeroMemory(&ooeBuf, sizeof(ooeBuf));
                item.cbSize = sizeof(NOTIFICATIONITEM);
                cItems = 0;
                dwBufSize = 0;

                hr = pEnum->Next(1, &item, &cItems);
            }
            SAFERELEASE(item.pNotification);
            SAFERELEASE(pEnum);
        }

        break;
    }

    SAFERELEASE(pScheduleGroup);
    SAFERELEASE(pNotificationMgr);

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// DeleteScheduleGroup
/////////////////////////////////////////////////////////////////////////////
HRESULT DeleteScheduleGroup
(
    /* [in] */  PNOTIFICATIONCOOKIE pGroupCookie
)
{
//xnotfmgr

    INotificationMgr *  pNotificationMgr = NULL;
    HRESULT             hrResult;

    for (;;)
    {
        if  (
            (pGroupCookie == NULL)
            ||
            (*pGroupCookie == GUID_NULL)
            )
        {
            return E_INVALIDARG;
        }

        if (FAILED(hrResult = GetNotificationMgr(&pNotificationMgr)))
        {
            TraceMsg(TF_ERROR, "DSG: Unable to get NotificationMgr");
            break;
        }

        if (FAILED(hrResult = pNotificationMgr->RevokeScheduleGroup(pGroupCookie,
                                                                    NULL,
                                                                    0)))
        {
            TraceMsg(TF_ERROR, "DSG: RevokeScheduleGroup FAILED");
            break;
        }

        break;
    }

    SAFERELEASE(pNotificationMgr);

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// ScheduleGroupExists
/////////////////////////////////////////////////////////////////////////////
BOOL ScheduleGroupExists
(
    LPCTSTR lpszGroupName
)
{
//xnotfmgr
    INotificationMgr *      pNotificationMgr = NULL;
    IEnumScheduleGroup *    pEnumSchedGroup = NULL;
    BOOL                    bResult = FALSE;

    for (;;)
    {
        if (FAILED(GetNotificationMgr(&pNotificationMgr)))
        {
            TraceMsg(TF_ERROR, "SGE: Unable to get NotificationMgr");
            break;
        }

        if (FAILED(pNotificationMgr->GetEnumScheduleGroup(0, &pEnumSchedGroup)))
        {
            TraceMsg(TF_ERROR, "SGE: Unable to GetEnumScheduleGroup");
            break;
        }

        // Iterate through all the schedule groups
        ULONG               celtFetched;
        IScheduleGroup *    pScheduleGroup = NULL;
        while   (
                SUCCEEDED(pEnumSchedGroup->Next(1,
                                                &pScheduleGroup,
                                                &celtFetched))
                &&
                (celtFetched != 0)
                )
        {
            GROUPINFO info = { 0 };

            ASSERT(pScheduleGroup != NULL);

            // Get the schedule group attributes.
            if  (
                SUCCEEDED(pScheduleGroup->GetAttributes(NULL,
                                                        NULL,
                                                        NULL,
                                                        &info,
                                                        NULL,
                                                        NULL))
                )
            {
                ASSERT(info.cbSize == SIZEOF(GROUPINFO));
                ASSERT(info.pwzGroupname != NULL);

                TCHAR szGroupName[MAX_GROUPNAME_LEN];
                MyOleStrToStrN(szGroupName, MAX_GROUPNAME_LEN, info.pwzGroupname);
                SAFEDELETE(info.pwzGroupname);

                // See if this is the schedule group name we are looking for.
                if (StrCmpI(lpszGroupName, szGroupName) == 0)
                {
                    bResult = TRUE;
                    break;
                }
            }
            else
                TraceMsg(TF_ERROR, "SGE: Unable to GetAttributes");

            SAFERELEASE(pScheduleGroup);
        }

        break;
    }

    SAFERELEASE(pEnumSchedGroup);
    SAFERELEASE(pNotificationMgr);

    return bResult;
}

/////////////////////////////////////////////////////////////////////////////
// SetDlgItemMonth
/////////////////////////////////////////////////////////////////////////////
BOOL SetDlgItemMonth
(
    HWND    hwndDlg,
    int     idCtl,
    WORD    rgfMonths
)
{
    return SetDlgItemInt(   hwndDlg,
                            idCtl,
                            MonthCountFromMonthsFlags(rgfMonths),
                            FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// MonthCountFromMonthsFlags
/////////////////////////////////////////////////////////////////////////////
int MonthCountFromMonthsFlags
(
    WORD rgfMonths
)
{
    for (int iMonths = 0; iMonths < ARRAYSIZE(c_rgwMonthMaps); iMonths++)
    {
        if (c_rgwMonthMaps[iMonths] == rgfMonths)
            break;
    }

    // If we didn't find it, assume every month
    if (iMonths == ARRAYSIZE(c_rgwMonthMaps))
        iMonths = 0;

    return iMonths+1;
}

/////////////////////////////////////////////////////////////////////////////
// DayIndexFromDaysOfTheWeekFlags
/////////////////////////////////////////////////////////////////////////////
int DayIndexFromDaysOfTheWeekFlags
(
    WORD rgfDaysOfTheWeek
)
{
    int idxDay;

    for (idxDay = 0; idxDay < ARRAYSIZE(s_rgwDaysOfTheWeek); idxDay++)
    {
        if (s_rgwDaysOfTheWeek[idxDay] == rgfDaysOfTheWeek)
            break;
    }

    if (idxDay == ARRAYSIZE(s_rgwDaysOfTheWeek))
        idxDay = 0;

    return idxDay;
}

/////////////////////////////////////////////////////////////////////////////
// GetDlgItemMonth
/////////////////////////////////////////////////////////////////////////////
WORD GetDlgItemMonth
(
    HWND    hwndDlg,
    int     idCtl
)
{
    BOOL bTranslated;

    int iVal = GetDlgItemInt(   hwndDlg,
                                idCtl,
                                &bTranslated,
                                FALSE);

    if  (
        bTranslated
        &&
        ((iVal > 0) && (iVal <= ARRAYSIZE(c_rgwMonthMaps)))
        )
    {
        return c_rgwMonthMaps[iVal-1];
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// SetDlgItemNextUpdate
/////////////////////////////////////////////////////////////////////////////
void SetDlgItemNextUpdate
(
    HWND            hwndDlg,
    int             idCtl,
    SSUIDLGINFO *   pDlgInfo
)
{
//xnotfmgr

    WORD        cDate = 1;
    FILETIME    dateNextUpdate;
    TCHAR       szNextUpdate[128];

    SYSTEMTIME  stBegin;
    GetLocalTime(&stBegin);

    if  (
        (pDlgInfo->pfnGetRunTimes != NULL)
        &&
        SUCCEEDED(pDlgInfo->pfnGetRunTimes( pDlgInfo->ttTaskTrigger,
                                            NULL,
                                            &stBegin,
                                            NULL,
                                            &cDate,
                                            &dateNextUpdate))
        &&
        (cDate != 0)
        )
    {
        FileTimeToSystemTime(&dateNextUpdate, &stBegin);
    }
    else
        GetLocalTime(&stBegin);

    LPTSTR pszNextUpdate = szNextUpdate;
    GetDateFormat(  LOCALE_USER_DEFAULT,
                    DATE_LONGDATE,
                    &stBegin,
                    NULL,
                    pszNextUpdate,
                    ARRAYSIZE(szNextUpdate) / 2);

    pszNextUpdate += lstrlen(pszNextUpdate); *pszNextUpdate++ = TEXT(' ');

    GetTimeFormat(  LOCALE_USER_DEFAULT,
                    TIME_NOSECONDS,
                    &stBegin,
                    NULL,
                    pszNextUpdate,
                    ARRAYSIZE(szNextUpdate) / 2);

    SetDlgItemText(hwndDlg, idCtl, szNextUpdate);
}

/////////////////////////////////////////////////////////////////////////////
// IncTime
/////////////////////////////////////////////////////////////////////////////
DWORD IncTime
(
    DWORD   dwTime,
    int     iIncHours,
    int     iIncMinutes
)
{
    int iMins = (LOWORD(dwTime) * 60) + HIWORD(dwTime);
    int iIncMins = (iIncHours * 60) + iIncMinutes;
    int iDeltaMins = iMins + iIncMins;

    if (iDeltaMins > ((24 * 60) - 1))
        iDeltaMins = iDeltaMins - (24 * 60);
    else if (iDeltaMins < 0)
        iDeltaMins = ((24 * 60) - 1);

    return MAKELONG((iDeltaMins / 60), (iDeltaMins % 60));
}

/////////////////////////////////////////////////////////////////////////////
// DayFromDaysFlags
/////////////////////////////////////////////////////////////////////////////
int DayFromDaysFlags
(
    DWORD rgfDays
)
{
    DWORD   dwMask = 1;
    int     iDay = 1;

    while (dwMask)
    {
        if (rgfDays & dwMask)
            break;

        dwMask <<= 1;
        iDay++;
    }

    if (iDay > 31)
        iDay = 1;

    return iDay;
}

/////////////////////////////////////////////////////////////////////////////
// Schedule group combo box helper functions
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// SchedGroupComboBox_Fill
/////////////////////////////////////////////////////////////////////////////
HRESULT SchedGroupComboBox_Fill
(
    HWND hwndCombo
)
{
//xnotfmgr
    INotificationMgr *      pNotificationMgr = NULL;
    IEnumScheduleGroup *    pEnumSchedGroup = NULL;
    HRESULT                 hrResult;

    ASSERT(hwndCombo != NULL);
    ASSERT(IsWindow(hwndCombo));

    for (;;)
    {
        SchedGroupComboBox_Clear(hwndCombo);

        if (FAILED(hrResult = GetNotificationMgr(&pNotificationMgr)))
        {
            TraceMsg(TF_ERROR, "FCBSG: Unable to get NotificationMgr");
            break;
        }

        if (FAILED(hrResult = pNotificationMgr->GetEnumScheduleGroup(0, &pEnumSchedGroup)))
        {
            TraceMsg(TF_ERROR, "FCBSG: Unable to GetEnumScheduleGroup");
            break;
        }

        // Iterate through all the schedule gropus
        ULONG               celtFetched;
        IScheduleGroup *    pScheduleGroup = NULL;
        while   (
                SUCCEEDED(hrResult = pEnumSchedGroup->Next( 1,
                                                            &pScheduleGroup,
                                                            &celtFetched))
                &&
                (celtFetched != 0)
                )
        {
            GROUPINFO           info = { 0 };
            NOTIFICATIONCOOKIE  cookie = { 0 };

            ASSERT(pScheduleGroup != NULL);

            // Get the schedule group attributes.
            if  (
                SUCCEEDED(pScheduleGroup->GetAttributes(NULL,
                                                        NULL,
                                                        &cookie,
                                                        &info,
                                                        NULL,
                                                        NULL))
                &&
                (cookie != NOTFCOOKIE_SCHEDULE_GROUP_MANUAL)
                )
            {
                ASSERT(info.cbSize == SIZEOF(GROUPINFO));
                ASSERT(info.pwzGroupname != NULL);

                TCHAR szGroupName[MAX_GROUPNAME_LEN];
                MyOleStrToStrN(szGroupName, MAX_GROUPNAME_LEN, info.pwzGroupname);
                SAFEDELETE(info.pwzGroupname);

                EVAL(SUCCEEDED(SchedGroupComboBox_AddGroup( hwndCombo,
                                                            szGroupName,
                                                            &cookie)));
            }
            else
                TraceMsg(TF_ERROR, "FCBSG: Unable to GetAttributes");

            SAFERELEASE(pScheduleGroup);
        }

        break;
    }

    SAFERELEASE(pEnumSchedGroup);
    SAFERELEASE(pNotificationMgr);

    return hrResult;
}

/////////////////////////////////////////////////////////////////////////////
// SchedGroupComboBox_Clear
/////////////////////////////////////////////////////////////////////////////
HRESULT SchedGroupComboBox_Clear
(
    HWND hwndCombo
)
{
//xnotfmgr
    ASSERT(hwndCombo != NULL);
    ASSERT(IsWindow(hwndCombo));

    for (int i = 0; i < ComboBox_GetCount(hwndCombo); i++)
    {
        PNOTIFICATIONCOOKIE pCookie = (PNOTIFICATIONCOOKIE)ComboBox_GetItemData(hwndCombo, i);

        if ((pCookie != NULL) && ((DWORD)pCookie != CB_ERR))
            MemFree(pCookie);
    }

    ComboBox_ResetContent(hwndCombo);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// SchedGroupComboBox_AddGroup
/////////////////////////////////////////////////////////////////////////////
HRESULT SchedGroupComboBox_AddGroup
(
    HWND                hwndCombo,
    LPCTSTR             pszGroupName,
    PNOTIFICATIONCOOKIE pGroupCookie
)
{
//xnotfmgr
    ASSERT(hwndCombo != NULL);
    ASSERT(IsWindow(hwndCombo));
    ASSERT(pszGroupName != NULL);
    ASSERT(pGroupCookie != NULL);

    // Add the schedule group name to the combobox.
    int iIndex = ComboBox_AddString(hwndCombo, pszGroupName);
    if ((iIndex != CB_ERR) && (iIndex != CB_ERRSPACE))
    {
        // Attach the schedule group cookie to the item data.
        PNOTIFICATIONCOOKIE pCookie = (PNOTIFICATIONCOOKIE)MemAlloc(LPTR,
                                                                    SIZEOF(NOTIFICATIONCOOKIE));
        if (pCookie == NULL)
            return E_OUTOFMEMORY;

        *pCookie = *pGroupCookie;
        ComboBox_SetItemData(hwndCombo, iIndex, (DWORD)pCookie);

        return S_OK;
    }
    else

    ASSERT(FALSE);
    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// SchedGroupComboBox_RemoveGroup
/////////////////////////////////////////////////////////////////////////////
HRESULT SchedGroupComboBox_RemoveGroup
(
    HWND                hwndCombo,
    PNOTIFICATIONCOOKIE pGroupCookie
)
{
//xnotfmgr
    ASSERT(hwndCombo != NULL);
    ASSERT(IsWindow(hwndCombo));
    ASSERT(pGroupCookie != NULL);
    ASSERT(*pGroupCookie != GUID_NULL);

    for (int i = 0 ; i < ComboBox_GetCount(hwndCombo); i++)
    {
        PNOTIFICATIONCOOKIE pCookie = (PNOTIFICATIONCOOKIE)ComboBox_GetItemData(hwndCombo, i);

        ASSERT(pCookie != NULL);

        if (*pCookie == *pGroupCookie)
        {
            MemFree(pCookie);

            EVAL(ComboBox_DeleteString(hwndCombo, i));
            return S_OK;
        }
    }

    ASSERT(FALSE);
    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// SchedGroupComboBox_SetCurGroup
/////////////////////////////////////////////////////////////////////////////
HRESULT SchedGroupComboBox_SetCurGroup
(
    HWND                hwndCombo,
    PNOTIFICATIONCOOKIE pGroupCookie
)
{
//xnotfmgr
    ASSERT(hwndCombo != NULL);
    ASSERT(IsWindow(hwndCombo));
    if (pGroupCookie == NULL || *pGroupCookie == GUID_NULL)
        return E_INVALIDARG;

    for (int i = 0 ; i < ComboBox_GetCount(hwndCombo); i++)
    {
        PNOTIFICATIONCOOKIE pData = (PNOTIFICATIONCOOKIE)ComboBox_GetItemData(hwndCombo, i);

        if (pData && *pData == *pGroupCookie)
        {
            EVAL(ComboBox_SetCurSel(hwndCombo, i) != -1);
            return S_OK;
        }
    }

    ASSERT(FALSE);
    return E_FAIL;
}

/////////////////////////////////////////////////////////////////////////////
// SchedGroupComboBox_GetCurGroup
/////////////////////////////////////////////////////////////////////////////
HRESULT SchedGroupComboBox_GetCurGroup
(
    HWND                hwndCombo,
    PNOTIFICATIONCOOKIE pGroupCookie
)
{
//xnotfmgr
    ASSERT(hwndCombo != NULL);
    ASSERT(IsWindow(hwndCombo));
    ASSERT(pGroupCookie != NULL);

    int iIndex = ComboBox_GetCurSel(hwndCombo);
    if (iIndex != CB_ERR)
    {
        PNOTIFICATIONCOOKIE pCookie = (PNOTIFICATIONCOOKIE)ComboBox_GetItemData(hwndCombo, iIndex);

        if (pCookie == NULL)
            return E_INVALIDARG;

        *pGroupCookie = *pCookie;

        return S_OK;
    }

    ASSERT(FALSE);
    return E_FAIL;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//
// wrappers for schedui combobox functions, to fill list and get current selection,
// that are aware of a NULL itemdata field representing the Publisher's Recommended
// Schedule entry (NULL itemdata means no groupCookie means use task trigger).
// 
////////////////////////////////////////////////////////////////////////////////

HRESULT FillScheduleList (HWND hwndCombo, POOEBuf pBuf)
{
    //first, fill with schedule groups
    HRESULT hr = SchedGroupComboBox_Fill (hwndCombo);

    //then, if channel, add "publisher schedule" to list
    if (pBuf->bChannel)
    {
        TCHAR tcBuf[128];

        MLLoadString(IDS_SCHEDULE_PUBLISHER, tcBuf, ARRAYSIZE(tcBuf));
        ComboBox_AddString (hwndCombo, tcBuf);
        //leave itemdata (cookie ptr) NULL
    }

    return hr;
}

HRESULT SetScheduleGroup (HWND hwndCombo, CLSID* pGroupCookie, POOEBuf pBuf)
{
//xnotfmgr
    HRESULT hr;

    if (pBuf->bChannel && (pBuf->fChannelFlags & CHANNEL_AGENT_DYNAMIC_SCHEDULE))
        hr = E_FAIL;    //force to Publisher's Schedule
    else
        hr = SchedGroupComboBox_SetCurGroup (hwndCombo, pGroupCookie);

    if (FAILED (hr))
    {
        if (pBuf->bChannel)
        {
            //we are a channel; look for Publisher's Schedule (null cookie ptr)
            for (int i = 0; i < ComboBox_GetCount (hwndCombo); i++)
            {
                if (!ComboBox_GetItemData(hwndCombo, i))
                {
                    EVAL(ComboBox_SetCurSel(hwndCombo, i) != -1);
                    return S_OK;
                }
            }
            hr = E_FAIL;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\subitem.cpp ===
#include "private.h"
#include "subitem.h"
#include "subsmgrp.h"

#include "helper.h"
#include "offl_cpp.h"   // Yech. Pidl stuff.

const TCHAR c_szSubscriptionInfoValue[] = TEXT("~SubsInfo");

#ifdef UNICODE
#define c_wszSubscriptionInfoValue c_szSubscriptionInfoValue
#else
const WCHAR c_wszSubscriptionInfoValue[] = L"~SubsInfo";
#endif

//  pragmas are for compatibility with the notification manager
//  registry data structures which were not pack 8

#pragma pack(push, RegVariantBlob, 1)

//#pragma pack(8)
struct NT32PACKAGE
{
    unsigned _int16 vt; /* VARTYPE *//* unsigned short int */
    unsigned _int16 wReserved1; /* WORD *//* unsigned short int */
    unsigned _int16 wReserved2; /* WORD *//* unsigned short int */
    unsigned _int16 wReserved3; /* WORD *//* unsigned short int */

   _int64 llVal; /* LONGLONG *//* __int64 */
};

// Q: What's going on here?
// A: Not a whole lot.
//    We used to store a variant in the registry. Unfortunately, variants are 
//    16 bytes on Win32 (8 byte header + 8 bytes of data)
//    24 bytes on Win64 (8 byte header + 16 bytes of data)

// Unfortunately, Win64 webcheck and Win32 webcheck both read from
// the same registry location, i.e. the same blob, and won't understand one another.
// Thus, boom! At least, for BSTRs that are stored inline

// Fortunately, we care only about only the first 16 bytes on both platforms. 
// Ergo, it's sufficient to store only the top half of the Win64 variant.

struct SimpleVariantBlob
{
#ifdef OLD
    VARIANT var;
#else
    NT32PACKAGE var;
#endif
};

struct BSTRVariantBlob : public SimpleVariantBlob
{
    DWORD   dwSize;
//    WCHAR   wsz[];    //  Variable length string
};

struct OldBSTRVariantBlob
{
    DWORD   dwSize;
    VARIANT var;
};


struct SignatureSimpleBlob
{
    DWORD               dwSignature;
    SimpleVariantBlob   svb;
};

struct SignatureBSTRBlob
{
    DWORD               dwSignature;
    BSTRVariantBlob     bvb;
};

#pragma pack(pop, RegVariantBlob)


#define BLOB_SIGNATURE 0x4b434f4d

// We need fStream to indicate when we're upgrading IE4-style streams-of-blobs. (IE6 24398)
HRESULT BlobToVariant(BYTE *pData, DWORD cbData, VARIANT *pVar, DWORD *pcbUsed, BOOL fStream)
{
    HRESULT hr = S_OK;
    SimpleVariantBlob *pBlob = (SimpleVariantBlob *)pData;

    ASSERT(NULL != pBlob);
    ASSERT(cbData >= sizeof(SimpleVariantBlob));
    ASSERT(NULL != pVar);

    if ((NULL != pBlob) &&
        (cbData >= sizeof(SimpleVariantBlob)) &&
        (NULL != pVar))
    {
#ifdef OLD
        memcpy(pVar, &pBlob->var, sizeof(VARIANT));
#else
        memcpy(pVar, &pBlob->var, sizeof(NT32PACKAGE));
#endif

        switch (pVar->vt)
        {
            case VT_I4:                 // LONG           
            case VT_UI1:                // BYTE           
            case VT_I2:                 // SHORT          
            case VT_R4:                 // FLOAT          
            case VT_R8:                 // DOUBLE         
            case VT_BOOL:               // VARIANT_BOOL   
            case VT_ERROR:              // SCODE          
            case VT_CY:                 // CY             
            case VT_DATE:               // DATE
            case VT_I1:                 // CHAR           
            case VT_UI2:                // USHORT         
            case VT_UI4:                // ULONG          
            case VT_INT:                // INT            
            case VT_UINT:               // UINT           
                if (pcbUsed)
                {
                    *pcbUsed = sizeof(SimpleVariantBlob);
                }
                break;                

            case VT_BSTR:               // BSTR
                hr = E_UNEXPECTED;

                ASSERT(cbData >= sizeof(BSTRVariantBlob));

                if (cbData >= sizeof(BSTRVariantBlob))
                {
                    BSTRVariantBlob *pbstrBlob = (BSTRVariantBlob *)pData;
                    DWORD dwSize = pbstrBlob->dwSize;

#ifdef OLD
                    ASSERT(cbData>=(sizeof(BSTRVariantBlob) + dwSize));

                    if (cbData>=(sizeof(BSTRVariantBlob) + dwSize))
#else
#ifdef WIN64
                    ASSERT((cbData==(sizeof(BSTRVariantBlob) + dwSize)) 
                           || (cbData==(sizeof(OldBSTRVariantBlob) + dwSize)));
#else
                    ASSERT((cbData==(sizeof(BSTRVariantBlob) + dwSize))
                            || (fStream && (cbData>=(sizeof(BSTRVariantBlob) + dwSize))));

#endif
                    if ((cbData==(sizeof(BSTRVariantBlob) + dwSize))
                        || (fStream && (cbData>=(sizeof(BSTRVariantBlob) + dwSize))))
#endif
                    {
                        pVar->bstrVal = SysAllocStringByteLen(NULL, dwSize);

                        if (NULL != pVar->bstrVal)
                        {
                            if (pcbUsed)
                            {
                                *pcbUsed = sizeof(BSTRVariantBlob) + pbstrBlob->dwSize;
                            }
                            memcpy(pVar->bstrVal, 
                                   ((BYTE *)pbstrBlob) + 
                                        (FIELD_OFFSET(BSTRVariantBlob, dwSize) + 
                                        sizeof(dwSize)),
                                   dwSize);
                            hr = S_OK;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
                if (FAILED(hr))
                {
                    pVar->vt = VT_EMPTY;
                }
                break;                

            default:
                hr = E_NOTIMPL;
                break;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT SignatureBlobToVariant(BYTE *pData, DWORD cbData, VARIANT *pVar)
{
    HRESULT hr;
    
    SignatureSimpleBlob *pBlob = (SignatureSimpleBlob *)pData;

    ASSERT(NULL != pBlob);
    ASSERT(cbData >= sizeof(SignatureSimpleBlob));
    ASSERT(NULL != pVar);
    ASSERT(BLOB_SIGNATURE == pBlob->dwSignature);

    if ((NULL != pBlob) &&
        (cbData >= sizeof(SignatureSimpleBlob)) &&
        (NULL != pVar) &&
        (BLOB_SIGNATURE == pBlob->dwSignature))
    {
        hr = BlobToVariant((BYTE *)&pBlob->svb, 
                           cbData - (FIELD_OFFSET(SignatureSimpleBlob, svb)),
                           pVar,
                           NULL);
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT VariantToSignatureBlob(const VARIANT *pVar, BYTE **ppData, DWORD *pdwSize)
{
    HRESULT hr;

    ASSERT(NULL != pVar);
    ASSERT(NULL != ppData);
    ASSERT(NULL != pdwSize);

    if ((NULL != pVar) && (NULL != ppData) && (NULL != pdwSize))
    {
        DWORD dwSize;
        DWORD dwBstrLen = 0;

        hr = S_OK;
     
        switch (pVar->vt)
        {
            case VT_I4:                 // LONG           
            case VT_UI1:                // BYTE           
            case VT_I2:                 // SHORT          
            case VT_R4:                 // FLOAT          
            case VT_R8:                 // DOUBLE         
            case VT_BOOL:               // VARIANT_BOOL   
            case VT_ERROR:              // SCODE          
            case VT_CY:                 // CY             
            case VT_DATE:               // DATE
            case VT_I1:                 // CHAR           
            case VT_UI2:                // USHORT         
            case VT_UI4:                // ULONG          
            case VT_INT:                // INT            
            case VT_UINT:               // UINT           
                dwSize = sizeof(SignatureSimpleBlob);
                break;                

            case VT_BSTR:               // BSTR
                if (NULL != pVar->bstrVal) 
                    dwBstrLen = SysStringByteLen(pVar->bstrVal);
                dwSize = sizeof(SignatureBSTRBlob) + dwBstrLen;
                break;
                        
            default:
                hr = E_NOTIMPL;
                dwSize = 0;
                break;
        }

        if (SUCCEEDED(hr))
        {
            SignatureSimpleBlob *pSignatureBlob = (SignatureSimpleBlob *)new BYTE[dwSize];

            if (NULL != pSignatureBlob)
            {
                *ppData = (BYTE *)pSignatureBlob;
                *pdwSize = dwSize;
                
                pSignatureBlob->dwSignature = BLOB_SIGNATURE;

                switch (pVar->vt)
                {
                    case VT_I4:                 // LONG           
                    case VT_UI1:                // BYTE           
                    case VT_I2:                 // SHORT          
                    case VT_R4:                 // FLOAT          
                    case VT_R8:                 // DOUBLE         
                    case VT_BOOL:               // VARIANT_BOOL   
                    case VT_ERROR:              // SCODE          
                    case VT_CY:                 // CY             
                    case VT_DATE:               // DATE
                    case VT_I1:                 // CHAR           
                    case VT_UI2:                // USHORT         
                    case VT_UI4:                // ULONG          
                    case VT_INT:                // INT            
                    case VT_UINT:               // UINT
                    {
                        SimpleVariantBlob *pBlob = &pSignatureBlob->svb;

#ifdef OLD
                        memcpy(&pBlob->var, pVar, sizeof(VARIANT));
#else
                        memcpy(&pBlob->var, pVar, sizeof(NT32PACKAGE));
#endif
                        break;
                    }

                    case VT_BSTR:               // BSTR
                    {
                        BSTRVariantBlob *pbstrBlob = 
                            &((SignatureBSTRBlob *)pSignatureBlob)->bvb;
                        
#ifdef OLD
                        memcpy(&pbstrBlob->var, pVar, sizeof(VARIANT));
#else
                        memcpy(&pbstrBlob->var, pVar, sizeof(NT32PACKAGE));
#endif
                        pbstrBlob->dwSize = dwBstrLen;
                        memcpy(((BYTE *)pbstrBlob) + 
                                  (FIELD_OFFSET(BSTRVariantBlob, dwSize) + 
                                  sizeof(dwSize)),
                               pVar->bstrVal, 
                               dwBstrLen);
                        break;
                    }
                                
                    default:
                        ASSERT(0);  // Default case should have been eliminated!
                        break;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else        
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

CEnumItemProperties::CEnumItemProperties()
{
    ASSERT(0 == m_nCurrent);
    ASSERT(0 == m_nCount);
    ASSERT(NULL == m_pItemProps);

    m_cRef = 1;

    DllAddRef();    
}

CEnumItemProperties::~CEnumItemProperties()
{
    if (NULL != m_pItemProps)
    {
        for (ULONG i = 0; i < m_nCount; i++)
        {
            VariantClear(&m_pItemProps[i].variantValue);
            if (NULL != m_pItemProps[i].pwszName)
            {
                CoTaskMemFree(m_pItemProps[i].pwszName);
            }
        }
        delete [] m_pItemProps;
    }
    DllRelease();
}

HRESULT CEnumItemProperties::Initialize(const SUBSCRIPTIONCOOKIE *pCookie, ISubscriptionItem *psi)
{
    HRESULT hr = E_FAIL;
    HKEY hkey;

    ASSERT(NULL != pCookie);

    if (OpenItemKey(pCookie, FALSE, KEY_READ, &hkey))
    {
        DWORD dwMaxValNameSize;
        DWORD dwMaxDataSize;
        DWORD dwCount;

        if (RegQueryInfoKey(hkey,
            NULL,   // address of buffer for class string 
            NULL,   // address of size of class string buffer 
            NULL,   // reserved 
            NULL,   // address of buffer for number of subkeys 
            NULL,   // address of buffer for longest subkey name length  
            NULL,   // address of buffer for longest class string length 
            &dwCount,   // address of buffer for number of value entries 
            &dwMaxValNameSize,  // address of buffer for longest value name length 
            &dwMaxDataSize, // address of buffer for longest value data length 
            NULL,   // address of buffer for security descriptor length 
            NULL    // address of buffer for last write time
            ) == ERROR_SUCCESS)
        {
            //  This allocates enough for Password as well
            m_pItemProps = new ITEMPROP[dwCount];

            dwMaxValNameSize++; //  Need room for NULL

            //  alloca candidates:

            TCHAR *pszValName = new TCHAR[dwMaxValNameSize];
#ifndef UNICODE
            WCHAR *pwszValName = new WCHAR[dwMaxValNameSize];
#endif
            BYTE *pData = new BYTE[dwMaxDataSize];  
            
            if ((NULL != m_pItemProps) && (NULL != pData) && 
#ifndef UNICODE
                (NULL != pwszValName) &&
#endif
                (NULL != pszValName) 
               )
            {
                hr = S_OK;

                for (ULONG i = 0; i < dwCount; i++)
                {
                    DWORD dwType;
                    DWORD dwSize = dwMaxDataSize;
                    DWORD dwNameSize = dwMaxValNameSize;

                    if (SHEnumValue(hkey, i, pszValName, &dwNameSize, 
                                    &dwType, pData, &dwSize) != ERROR_SUCCESS)
                    {
                        hr = E_UNEXPECTED;
                        break;
                    }

                    //  Skip the default value and our subscription info structure
                    if ((NULL == *pszValName) ||
                        (0 == StrCmp(pszValName, c_szSubscriptionInfoValue))
                       )
                    {
                        continue;
                    }

                    if (dwType != REG_BINARY)
                    {
                        hr = E_UNEXPECTED;
                        break;
                    }

                    hr = SignatureBlobToVariant(pData, dwSize, &m_pItemProps[m_nCount].variantValue);
                    if (SUCCEEDED(hr))
                    {
                        WCHAR *pwszName;
                    #ifdef UNICODE
                        pwszName = pszValName;
                    #else
                        MultiByteToWideChar(CP_ACP, 0, pszValName, -1, 
                                    pwszValName, dwMaxValNameSize);
                        pwszName = pwszValName;
                    #endif                           
                        ULONG ulSize = (lstrlenW(pwszName) + 1) * sizeof(WCHAR);
                        m_pItemProps[m_nCount].pwszName = (WCHAR *)CoTaskMemAlloc(ulSize);
                        if (NULL != m_pItemProps[m_nCount].pwszName)
                        {
                            StrCpyW(m_pItemProps[m_nCount].pwszName, pwszName);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        m_nCount++;
                    }
                    else
                    {
                        break;
                    }
                }

                if (SUCCEEDED(ReadPassword(psi, &m_pItemProps[m_nCount].variantValue.bstrVal)))
                {
                    m_pItemProps[m_nCount].pwszName = (WCHAR *)CoTaskMemAlloc(sizeof(L"Password"));

                    if (NULL != m_pItemProps[m_nCount].pwszName)
                    {
                        StrCpyW(m_pItemProps[m_nCount].pwszName, L"Password");
                        m_pItemProps[m_nCount].variantValue.vt = VT_BSTR;
                        m_nCount++;
                    }
                    else
                    {
                        SysFreeString(m_pItemProps[m_nCount].variantValue.bstrVal);
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        #ifndef UNICODE
            SAFEDELETE(pwszValName);
        #endif
            SAFEDELETE(pszValName);
            SAFEDELETE(pData);
        }
        RegCloseKey(hkey);
    }
    return hr;
}

// IUnknown members
STDMETHODIMP CEnumItemProperties::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }

    if ((IID_IUnknown == riid) || (IID_IEnumItemProperties == riid))
    {
        *ppv = (IEnumItemProperties *)this;
        AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    return hr;
}

STDMETHODIMP_(ULONG) CEnumItemProperties::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CEnumItemProperties::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CEnumItemProperties::CopyItem(ITEMPROP *pip, WCHAR *pwszName, VARIANT *pVar)
{
    HRESULT hr;

    ASSERT(NULL != pwszName);
    
    if (NULL != pwszName)
    {
        
        ULONG cb = (lstrlenW(pwszName) + 1) * sizeof(WCHAR);

        pip->pwszName = (WCHAR *)CoTaskMemAlloc(cb);
        if (NULL != pip->pwszName)
        {
            StrCpyW(pip->pwszName, pwszName);
            pip->variantValue.vt = VT_EMPTY;    // is this a good idea?
            hr = VariantCopy(&pip->variantValue, pVar);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT CEnumItemProperties::CopyRange(ULONG nStart, ULONG nCount, 
                                       ITEMPROP *ppip, ULONG *pnCopied)
{
    HRESULT hr = S_OK;
    ULONG n = 0;
    ULONG i;

    ASSERT((NULL != ppip) && (NULL != pnCopied));
    
    for (i = nStart; (S_OK == hr) && (i < m_nCount) && (n < nCount); i++, n++)
    {
        hr = CopyItem(&ppip[n], m_pItemProps[i].pwszName, &m_pItemProps[i].variantValue);
    }

    *pnCopied = n;

    if (SUCCEEDED(hr))
    {
        hr = (n == nCount) ? S_OK : S_FALSE;
    }
    
    return hr;
}

// IEnumItemProperties
STDMETHODIMP CEnumItemProperties::Next( 
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ITEMPROP *rgelt,
    /* [out] */ ULONG *pceltFetched)
{
    HRESULT hr;

    if ((0 == celt) || 
        ((celt > 1) && (NULL == pceltFetched)) ||
        (NULL == rgelt))
    {
        return E_INVALIDARG;
    }

    DWORD nFetched;

    hr = CopyRange(m_nCurrent, celt, rgelt, &nFetched);

    m_nCurrent += nFetched;

    if (pceltFetched)
    {
        *pceltFetched = nFetched;
    }

    return hr;
}

STDMETHODIMP CEnumItemProperties::Skip( 
    /* [in] */ ULONG celt)
{
    HRESULT hr;
    
    m_nCurrent += celt;

    if (m_nCurrent > (m_nCount - 1))
    {
        m_nCurrent = m_nCount;  //  Passed the last one
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }
    
    return hr;
}

STDMETHODIMP CEnumItemProperties::Reset()
{
    m_nCurrent = 0;

    return S_OK;
}

STDMETHODIMP CEnumItemProperties::Clone( 
    /* [out] */ IEnumItemProperties **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppenum = NULL;

    CEnumItemProperties *peip = new CEnumItemProperties;

    if (NULL != peip)
    {
        peip->m_pItemProps = new ITEMPROP[m_nCount];

        if (NULL != peip->m_pItemProps)
        {
            ULONG nFetched;

            hr = E_FAIL;

            peip->m_nCount = m_nCount;
            hr = CopyRange(0, m_nCount, peip->m_pItemProps, &nFetched);

            if (SUCCEEDED(hr))
            {
                ASSERT(m_nCount == nFetched);

                if (m_nCount == nFetched)
                {
                    hr = peip->QueryInterface(IID_IEnumItemProperties, (void **)ppenum);
                }
            }
        }
        peip->Release();
    }    
    return hr;
}

STDMETHODIMP CEnumItemProperties::GetCount( 
    /* [out] */ ULONG *pnCount)
{
    if (NULL == pnCount)
    {
        return E_INVALIDARG;
    }

    *pnCount = m_nCount;

    return S_OK;
}


CSubscriptionItem::CSubscriptionItem(const SUBSCRIPTIONCOOKIE *pCookie, HKEY hkey)
{
    ASSERT(NULL != pCookie);
    ASSERT(0 == m_dwFlags);

    m_cRef = 1;

    if (NULL != pCookie)
    {
        m_Cookie = *pCookie;
    }

    SUBSCRIPTIONITEMINFO sii;

    sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

    if ((hkey != NULL) && 
        SUCCEEDED(Read(hkey, c_wszSubscriptionInfoValue, (BYTE *)&sii, sizeof(SUBSCRIPTIONITEMINFO))))

    {
        m_dwFlags = sii.dwFlags;
    }

    DllAddRef();
}

CSubscriptionItem::~CSubscriptionItem()
{
    if (m_dwFlags & SI_TEMPORARY)
    {
        TCHAR szKey[MAX_PATH];

        if (ItemKeyNameFromCookie(&m_Cookie, szKey, ARRAYSIZE(szKey)))
        {
             SHDeleteKey(HKEY_CURRENT_USER, szKey);
        }
    }
    DllRelease();
}

HRESULT CSubscriptionItem::Read(HKEY hkeyIn, const WCHAR *pwszValueName, 
                                BYTE *pData, DWORD dwDataSize)
{
    HRESULT hr = E_FAIL;
    HKEY hkey = hkeyIn;

    ASSERT((NULL != pwszValueName) && (NULL != pData) && (0 != dwDataSize));

    if ((NULL != hkey) || OpenItemKey(&m_Cookie, FALSE, KEY_READ, &hkey))
    {
        DWORD dwType;
        DWORD dwSize = dwDataSize;

#ifdef UNICODE
        if ((RegQueryValueExW(hkey, pwszValueName, NULL, &dwType, pData, &dwSize) == ERROR_SUCCESS) &&
#else
        TCHAR szValueName[MAX_PATH];
        WideCharToMultiByte(CP_ACP, 0, pwszValueName, -1, szValueName, ARRAYSIZE(szValueName), NULL, NULL);
        if ((RegQueryValueExA(hkey, szValueName, NULL, &dwType, pData, &dwSize) == ERROR_SUCCESS) &&
#endif
            (dwSize == dwDataSize) && (REG_BINARY == dwType))
        {
            hr = S_OK;
        }
        if (NULL == hkeyIn)
        {
            RegCloseKey(hkey);
        }
    }
    return hr;
}

HRESULT CSubscriptionItem::ReadWithAlloc(HKEY hkeyIn, const WCHAR *pwszValueName, 
                                         BYTE **ppData, DWORD *pdwDataSize)
{
    HRESULT hr = E_FAIL;
    HKEY hkey = hkeyIn;

    ASSERT((NULL != pwszValueName) && (NULL != ppData) && (NULL != pdwDataSize));

    if ((NULL != hkey) || OpenItemKey(&m_Cookie, FALSE, KEY_READ, &hkey))
    {
        DWORD dwType;
        DWORD dwSize = 0;

#ifdef UNICODE
        if (RegQueryValueExW(hkey, pwszValueName, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS)
#else
        TCHAR szValueName[MAX_PATH];
        WideCharToMultiByte(CP_ACP, 0, pwszValueName, -1, szValueName, ARRAYSIZE(szValueName), NULL, NULL);
        if (RegQueryValueExA(hkey, szValueName, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS)
#endif
        {
            BYTE *pData = new BYTE[dwSize];
            *pdwDataSize = dwSize;

            if (NULL != pData)
            {
#ifdef UNICODE
                if ((RegQueryValueExW(hkey, pwszValueName, NULL, &dwType, pData, pdwDataSize) == ERROR_SUCCESS) &&
#else
                if ((RegQueryValueExA(hkey, szValueName, NULL, &dwType, pData, pdwDataSize) == ERROR_SUCCESS) &&
#endif
                    (dwSize == *pdwDataSize) && (REG_BINARY == dwType))
                {
                    *ppData = pData;
                    hr = S_OK;
                }
                else
                {
                    delete [] pData;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (NULL == hkeyIn)
        {
            RegCloseKey(hkey);
        }
    }
    return hr;
}

HRESULT CSubscriptionItem::Write(HKEY hkeyIn, const WCHAR *pwszValueName, 
                                 BYTE *pData, DWORD dwDataSize)
{
    HRESULT hr = E_FAIL;
    HKEY hkey = hkeyIn;

    ASSERT((NULL != pwszValueName) && (NULL != pData) && (0 != dwDataSize));

    if ((NULL != hkey) || OpenItemKey(&m_Cookie, FALSE, KEY_WRITE, &hkey))
    {
#ifdef UNICODE
        if (RegSetValueExW(hkey, pwszValueName, 0, REG_BINARY, pData, dwDataSize) == ERROR_SUCCESS)
#else
        TCHAR szValueName[MAX_PATH];
        WideCharToMultiByte(CP_ACP, 0, pwszValueName, -1, szValueName, ARRAYSIZE(szValueName), NULL, NULL);
        if (RegSetValueExA(hkey, szValueName, 0, REG_BINARY, pData, dwDataSize) == ERROR_SUCCESS)
#endif
        {
            hr = S_OK;
        }
        if (NULL == hkeyIn)
        {
            RegCloseKey(hkey);
        }
    }
    return hr;
}


STDMETHODIMP CSubscriptionItem::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }

    if ((IID_IUnknown == riid) || (IID_ISubscriptionItem == riid))
    {
        *ppv = (ISubscriptionItem *)this;
        AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    return hr;
}


STDMETHODIMP_(ULONG) CSubscriptionItem::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSubscriptionItem::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSubscriptionItem::GetCookie(SUBSCRIPTIONCOOKIE *pCookie)
{
    if (NULL == pCookie)
    {
        return E_INVALIDARG;
    }

    *pCookie = m_Cookie;

    return S_OK;
}

STDMETHODIMP CSubscriptionItem::GetSubscriptionItemInfo( 
    /* [out] */ SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo)
{
    HRESULT hr;

    if ((NULL == pSubscriptionItemInfo) ||
        (pSubscriptionItemInfo->cbSize < sizeof(SUBSCRIPTIONITEMINFO)))
    {
        return E_INVALIDARG;
    }

    hr = Read(NULL, c_wszSubscriptionInfoValue, (BYTE *)pSubscriptionItemInfo, sizeof(SUBSCRIPTIONITEMINFO));

    ASSERT(sizeof(SUBSCRIPTIONITEMINFO) == pSubscriptionItemInfo->cbSize);
    
    if (SUCCEEDED(hr) &&
        (sizeof(SUBSCRIPTIONITEMINFO) != pSubscriptionItemInfo->cbSize))
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

STDMETHODIMP CSubscriptionItem::SetSubscriptionItemInfo( 
    /* [in] */ const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo)
{
    if ((NULL == pSubscriptionItemInfo) ||
        (pSubscriptionItemInfo->cbSize < sizeof(SUBSCRIPTIONITEMINFO)))
    {
        return E_INVALIDARG;
    }

    m_dwFlags = pSubscriptionItemInfo->dwFlags;
    
    return Write(NULL, c_wszSubscriptionInfoValue, (BYTE *)pSubscriptionItemInfo, sizeof(SUBSCRIPTIONITEMINFO));
}

STDMETHODIMP CSubscriptionItem::ReadProperties( 
    ULONG nCount,
    /* [size_is][in] */ const LPCWSTR rgwszName[],
    /* [size_is][out] */ VARIANT rgValue[])
{
    HRESULT hr = S_OK;
    
    if ((0 == nCount) || (NULL == rgwszName) || (NULL == rgValue))
    {
        return E_INVALIDARG;
    }

    HKEY hkey;

    if (OpenItemKey(&m_Cookie, FALSE, KEY_READ, &hkey))
    {
        for (ULONG i = 0; (i < nCount) && (S_OK == hr); i++)
        {
            BYTE *pData;
            DWORD dwDataSize;

            if (StrCmpIW(rgwszName[i], c_szPropPassword) == 0)
            {
                if (SUCCEEDED(ReadPassword(this, &rgValue[i].bstrVal)))
                {
                    rgValue[i].vt = VT_BSTR;
                }
                else
                {
                    rgValue[i].vt = VT_EMPTY;
                }
            }
            else
            {
                HRESULT hrRead = ReadWithAlloc(hkey, rgwszName[i], &pData, &dwDataSize);

                if (SUCCEEDED(hrRead))
                {
                    hr = SignatureBlobToVariant(pData, dwDataSize, &rgValue[i]);
                    delete [] pData;
                }
                else
                {
                    rgValue[i].vt = VT_EMPTY;
                }
            }
        }
        RegCloseKey(hkey);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CSubscriptionItem::WriteProperties( 
    ULONG nCount,
    /* [size_is][in] */ const LPCWSTR rgwszName[],
    /* [size_is][in] */ const VARIANT rgValue[])
{
    HRESULT hr = S_OK;
    
    if ((0 == nCount) || (NULL == rgwszName) || (NULL == rgValue))
    {
        return E_INVALIDARG;
    }

    HKEY hkey;

    if (OpenItemKey(&m_Cookie, FALSE, KEY_WRITE, &hkey))
    {
        for (ULONG i = 0; (i < nCount) && (S_OK == hr); i++)
        {
            if (rgValue[i].vt == VT_EMPTY)
            {
                //  We don't actually care if this fails since it is
                //  meant to delete the property anyhow
#ifdef UNICODE
                RegDeleteValueW(hkey, rgwszName[i]);
#else
                TCHAR szValueName[MAX_PATH];
                WideCharToMultiByte(CP_ACP, 0, rgwszName[i], -1, szValueName, 
                                    ARRAYSIZE(szValueName), NULL, NULL);
                RegDeleteValueA(hkey, szValueName);
#endif
            }
            else
            {
                BYTE *pData;
                DWORD dwDataSize;

                //  Special case the name property for easy viewing
                if ((VT_BSTR == rgValue[i].vt) && 
                    (StrCmpIW(rgwszName[i], c_szPropName) == 0))
                {   
                #ifdef UNICODE
                    RegSetValueExW(hkey, NULL, 0, REG_SZ, (LPBYTE)rgValue[i].bstrVal, 
                                   (lstrlenW(rgValue[i].bstrVal) + 1) * sizeof(WCHAR));
                #else
                    TCHAR szValueName[MAX_PATH];
                    WideCharToMultiByte(CP_ACP, 0, rgValue[i].bstrVal, -1, szValueName, 
                                        ARRAYSIZE(szValueName), NULL, NULL);
                    RegSetValueExA(hkey, NULL, 0, REG_SZ, (LPBYTE)szValueName, lstrlenA(szValueName) + 1);
                #endif
                }

                if (StrCmpIW(rgwszName[i], c_szPropPassword) == 0)
                {
                    if (VT_BSTR == rgValue[i].vt)
                    {
                        hr = WritePassword(this, rgValue[i].bstrVal);
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    hr = VariantToSignatureBlob(&rgValue[i], &pData, &dwDataSize);

                    if (SUCCEEDED(hr))
                    {
                        hr = Write(hkey, rgwszName[i], pData, dwDataSize);
                        delete [] pData;
                    }
                }
            }
        }
        RegCloseKey(hkey);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CSubscriptionItem::EnumProperties( 
    /* [out] */ IEnumItemProperties **ppEnumItemProperties)
{
    HRESULT hr;

    if (NULL == ppEnumItemProperties)
    {
        return E_INVALIDARG;
    }
    CEnumItemProperties *peip = new CEnumItemProperties;

    *ppEnumItemProperties = NULL;

    if (NULL != peip)
    {
        hr = peip->Initialize(&m_Cookie, this);
        if (SUCCEEDED(hr))
        {
            hr = peip->QueryInterface(IID_IEnumItemProperties, (void **)ppEnumItemProperties);
        }
        peip->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CSubscriptionItem::NotifyChanged()
{
    HRESULT hr;

    // Notify the shell folder of the updated item
    // This is SOMEWHAT inefficient... why do we need 1000 properties for a pidl?
    // Why do we copy them around? Why why why?

    OOEBuf      ooeBuf;
    LPMYPIDL    newPidl = NULL;
    DWORD       dwSize = 0;

    memset(&ooeBuf, 0, sizeof(ooeBuf));

    hr = LoadWithCookie(NULL, &ooeBuf, &dwSize, &m_Cookie);

    if (SUCCEEDED(hr))
    {
        newPidl = COfflineFolderEnum::NewPidl(dwSize);
        if (newPidl)
        {
            CopyToMyPooe(&ooeBuf, &(newPidl->ooe));
            _GenerateEvent(SHCNE_UPDATEITEM, (LPITEMIDLIST)newPidl, NULL);
            COfflineFolderEnum::FreePidl(newPidl);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\strlist.cpp ===
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
#include "private.h"
#include "strlist.h"

#define TF_THISMODULE   TF_STRINGLIST

//----------------------------------------------------------------------------
// CWCStringList

CWCStringList::CWCStringList()
{
    // We may be able to remove this Clear() call if we guarantee that
    //  1) the new operator zero inits
    //  2) we don't use this class on the stack
    Clear();
}

CWCStringList::~CWCStringList()
{
#ifdef DEBUG
    if (m_iNumStrings > 100)
        SpewHashStats(TRUE);
#endif

    CleanUp();
}

// Clean up any allocated memory
void CWCStringList::CleanUp()
{
    // Must free buffers even if not m_fValid, because we may have
    // gotten only partway through Init() before running into a problem.

    if (m_pBuffer)
    {
        MemFree(m_pBuffer);
        m_pBuffer = NULL;
    }

    if (m_psiStrings)
    {
        MemFree(m_psiStrings);
        m_psiStrings = NULL;
    }

    m_fValid = FALSE;
}

// Clear our internal structures to prepare to be initialized. Assumes we
//  have no allocated memory (call CleanUp())
void CWCStringList::Clear()
{
    m_fValid = FALSE;
    m_iBufEnd = m_iBufSize = m_iNumStrings = m_iMaxStrings = 0;
    m_pBuffer = NULL;
    m_psiStrings = NULL;
    ZeroMemory(m_Hash, sizeof(m_Hash));
}

void CWCStringList::Reset()
{
    if (m_fValid || m_pBuffer || m_psiStrings)
    {
        CleanUp();
        Clear();
    }
}

BOOL CWCStringList::Init(int iInitBufSize)
{
    if (m_fValid)
    {
        DBG("WCStringList::Init called when already initialized");
        Reset();
    }

    if (iInitBufSize <= 0)
    {
        iInitBufSize = DEFAULT_INIT_BUF_SIZE;
    }

    m_iMaxStrings = iInitBufSize >> 5;  // this is relatively arbitrary but doesn't matter much

    m_pBuffer = (LPSTR)MemAlloc(LMEM_FIXED, iInitBufSize);
    m_psiStrings = (LPSTRING_INDEX)MemAlloc(LMEM_FIXED, m_iMaxStrings * sizeof(STRING_INDEX));

    if ((NULL == m_psiStrings) ||
        (NULL == m_pBuffer))
    {
        DBG_WARN("Init() memory allocation failed");

        CleanUp();
        return FALSE;
    }

    *m_pBuffer = 0;

    m_iBufSize = iInitBufSize;
    m_iBufEnd = 0;
    m_fValid = TRUE;

    return TRUE;
}


// Sets up our internal data structures (hash and string_index)
// Sets m_iBufEnd.
// We must already be Init()ialized and the data in m_pBuffer
BOOL CWCStringList::InitializeFromBuffer()
{
    LPCWSTR pNext;
    int iLen;

    if (!m_fValid)
        return FALSE;

    pNext = (LPCWSTR)m_pBuffer;

    while (((LPSTR)pNext-m_pBuffer) < m_iBufSize)
    {
        iLen = lstrlenW(pNext);
        InsertToHash(pNext, iLen, FALSE);
        pNext += iLen+1;
    }

    m_iBufEnd = (int)((LPSTR)pNext - m_pBuffer);

    return TRUE;
}


//
// IPersistStream members
//
// We save
// DWORD containing total length in bytes that follows. Will be
//  multiple of four; may have 0-4 extra pad bytes on the end.
// String data.
//
// Smallest data we store is 4 bytes of zeroes. We still end up taking
//  memory when we get restored. Don't instantiate one of these objects
//  until you're going to use it.
STDMETHODIMP CWCStringList::IsDirty(void)
{
    DBG("CWCStringList::IsDirty returning S_OK (true) as always");

    return S_OK;
}

STDMETHODIMP CWCStringList::Load(IStream *pStm)
{
    HRESULT hr;
    ULONG   cbRead;
    DWORD   dwDataSize;

    DBG("CWCStringList::Load");

    if (NULL==pStm)
        return E_POINTER;

    // Clean up our object
    Reset();

    // Load our data
    hr = pStm->Read(&dwDataSize, sizeof(DWORD), &cbRead);
    if (FAILED(hr) || cbRead != sizeof(DWORD))
        return STG_E_READFAULT;

    if (0 == dwDataSize)
    {
        if (!Init(512))     // Start with small buffer since we're empty
            return E_OUTOFMEMORY;
        return S_OK;
    }

    if (!Init(dwDataSize))
        return E_OUTOFMEMORY;

    ASSERT(dwDataSize <= (DWORD)m_iBufSize);

    // Read in the string data
    hr = pStm->Read(m_pBuffer, dwDataSize, &cbRead);
    if (FAILED(hr) || cbRead != dwDataSize)
        return STG_E_READFAULT;

    // Set up hash tables etc.
    InitializeFromBuffer();

    DBG("CWCStringList::Load success");

    return NOERROR;
}

STDMETHODIMP CWCStringList::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr;
    ULONG   cbWritten;
    DWORD   dwDataSize, dwZero=0;
    DWORD   dwZeroPad;

    DBG("CWCStringList::Save");

    if (NULL==pStm)
        return E_POINTER;

    // First write our data
    dwDataSize = (m_iBufEnd+3) & 0xFFFFFFFC; // multiple of four

    if ((0 == m_iBufSize) || (0 == m_iNumStrings))
    {
        dwDataSize = 0;
    }

    hr = pStm->Write(&dwDataSize, sizeof(DWORD), &cbWritten);
    if (FAILED(hr) || sizeof(DWORD) != cbWritten)
        return STG_E_WRITEFAULT;

    if (dwDataSize > 0)
    {
        hr = pStm->Write(m_pBuffer, m_iBufSize, &cbWritten);
        if (FAILED(hr) || sizeof(DWORD) != cbWritten)
            return STG_E_WRITEFAULT;

        dwZeroPad = dwDataSize - m_iBufSize;

        ASSERT(dwZeroPad<4);
        if (dwZeroPad && dwZeroPad<4)
        {
            hr = pStm->Write(&dwZero, dwZeroPad, &cbWritten);
            if (FAILED(hr) || (dwZeroPad != cbWritten))
                return STG_E_WRITEFAULT;
        }
    }

    DBG("CWCStringList::Save success");

    return NOERROR;
}

STDMETHODIMP CWCStringList::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DBG("CWCStringList::GetSizeMax");

    if (NULL==pcbSize)
        return E_POINTER;

    pcbSize->LowPart = 0;
    pcbSize->HighPart = 0;

    pcbSize->LowPart = m_iBufEnd + 8;

    return NOERROR;
}

// Returns a BSTR
BSTR CWCStringList::GetBSTR(int iNum)
{
    LPCWSTR lpStr = GetString(iNum);

    return SysAllocStringLen(lpStr, GetStringLen(iNum));
}

// Returns FALSE if string is not found
// Places string index (for GetString()) in *piNum only if string is found.
BOOL CWCStringList::FindString(LPCWSTR lpwstr, int iLen, int *piNum/*=NULL*/)
{
    int             iHash;
    LPSTRING_INDEX  psi;

    if (!lpwstr)
        return FALSE;

    if (iLen < 0)
        iLen = lstrlenW(lpwstr);

    iHash = Hash(lpwstr, iLen);
    for (psi = m_Hash[iHash]; psi; psi = psi->psiNext)
    {
        if ((psi->iLen == iLen) && memcmp(psi->lpwstr, lpwstr, iLen * sizeof(WCHAR)) == 0)
        {
            if (piNum)
                *piNum = (int) (psi-m_psiStrings);
            return TRUE;        // String is a duplicate
        }
    }

    return FALSE;
}

// returns STRLST_FAIL on failure,
//         STRLST_DUPLICATE if the string already existed, and
//         STRLST_ADDED if it's new
int CWCStringList::AddString(LPCWSTR lpwstr, DWORD_PTR dwData /*=NULL*/, int *piNum /*=NULL*/)
{
    int iSize, iLen;

    if (!lpwstr)
        return STRLST_FAIL;

    iLen = lstrlenW(lpwstr);

    if (!m_fValid || !m_pBuffer)
    {
        DBG_WARN("WCStringList: AddString() called with invalid instance");
        return STRLST_FAIL;
    }

    if (dwData != 0)
        DBG_WARN("Value for dwData passed into CWCStringList::AddString");

    if (FindString(lpwstr, iLen, piNum))
        return STRLST_DUPLICATE;        // String is a duplicate

    // iSize will be size in bytes including null term
    iSize = (iLen+1)*sizeof(WCHAR);

    // Append string to current buffer
    if (iSize >= (m_iBufSize - m_iBufEnd))
    {
        int iOldBufSize = m_iBufSize;

        // Grow buffer.
        m_iBufSize *= 2;     // This way the number of reallocs drops off logarithmically
        if (m_iBufEnd + iSize > m_iBufSize)
        {
            DBG("StringList special growing size");
            m_iBufSize = m_iBufEnd + iSize;
        }

        TraceMsg(TF_THISMODULE,"StringList growing to size %d",m_iBufSize);

        LPSTR pBuf = (LPSTR)MemReAlloc((HLOCAL)m_pBuffer, m_iBufSize, LMEM_MOVEABLE);
        if (!pBuf)
        {
            m_iBufSize = iOldBufSize;
            DBG_WARN("WCStringList: ReAlloc() failure");
            // Realloc failure: our old memory is still present
            return 0;
        }
        // Let's be clever and fix all our pointers instead of getting faults
        if (m_pBuffer != pBuf)
        {
            int i;
            LPSTRING_INDEX psi;
            for (i=0, psi=&m_psiStrings[0]; i<m_iNumStrings; i++, psi++)
            {
                psi->lpwstr = (LPWSTR)(((LPSTR)psi->lpwstr - m_pBuffer) + pBuf);
            }

            m_pBuffer = pBuf;
        }
    }

    if (piNum)
        *piNum = m_iNumStrings;

    LPWSTR pBufEnd = (LPWSTR)(m_pBuffer + m_iBufEnd);

    StrCpyW(pBufEnd, lpwstr);
    if (!InsertToHash(pBufEnd, iLen, TRUE))
        return 0;
    m_iBufEnd += iSize;

    return STRLST_ADDED;           // indicate we added a new string
}


BOOL CWCStringList::InsertToHash(LPCWSTR lpwstr, int iLen, BOOL fAlreadyHashed)
{
    int iHash = fAlreadyHashed ? m_iLastHash : Hash(lpwstr, iLen);

    // grow psiStrings if needed
    ASSERT(m_iNumStrings <= m_iMaxStrings);
    if (m_iNumStrings >= m_iMaxStrings)
    {
        m_iMaxStrings *= 2;
        TraceMsg(TF_THISMODULE, "StringList growing max strings to %d", m_iMaxStrings);
        LPSTRING_INDEX psiBuf = (LPSTRING_INDEX)MemReAlloc((HLOCAL)m_psiStrings,
            m_iMaxStrings * sizeof(STRING_INDEX), LMEM_MOVEABLE);
        if (!psiBuf)
        {
            // Realloc failure: Old memory still present
            DBG_WARN("WCStringList::InsertToHash() ReAlloc failure");
            m_iMaxStrings /= 2;
            return FALSE;
        }
        // More cleverness
        if (m_psiStrings != psiBuf)
        {
            int i;
            LPSTRING_INDEX psi, *ppsi;

            for (i=0, psi=psiBuf; i<m_iNumStrings; i++, psi++)
            {
                if (psi->psiNext)
                    psi->psiNext = (psi->psiNext - m_psiStrings) + psiBuf;
            }
            for (i=0, ppsi=m_Hash; i<STRING_HASH_SIZE; i++, ppsi++)
            {
                if (*ppsi)
                    *ppsi = (*ppsi - m_psiStrings) + psiBuf;
            }

            m_psiStrings = psiBuf;
        }
    }

    m_psiStrings[m_iNumStrings].lpwstr  = lpwstr;
    m_psiStrings[m_iNumStrings].iLen    = iLen;
    m_psiStrings[m_iNumStrings].psiNext = m_Hash[iHash];
    m_Hash[iHash] = &m_psiStrings[m_iNumStrings];
    m_iNumStrings++;
    return TRUE;
}


#ifdef DEBUG
// WARNING: this clobbers the hash
void CWCStringList::SpewHashStats(BOOL fVerbose)
{
/*
    int i;
    for (i = 0; i < STRING_HASH_SIZE; ++i)
    {
        int c = 0;

        for (tagStringIndex *p = m_Hash[i]; p; p = p->psiNext)
            ++c;

        if (c)
            TraceMsg(TF_THISMODULE,"%10d%12d", i, c);
    }
*/

 
    TraceMsg(TF_THISMODULE,"### Hash size: %d       Num. entries:%7d", STRING_HASH_SIZE, m_iNumStrings);
    int i,n;
    if (fVerbose)
    {
        TraceMsg(TF_THISMODULE," # of entries    # of keys with that many");
        for (i=0,n=0; n<STRING_HASH_SIZE; i++)
        {
            int k=0;
            for (int j=0; j<STRING_HASH_SIZE; j++)
            {
                int c=0;
                for (tagStringIndex* p=m_Hash[j]; p; p=p->psiNext)
                    c++;
                if (c == i)
                    k++;
            }
            if (k)
            {
                TraceMsg(TF_THISMODULE,"%10d%12d", i, k);
                n += k;
            }
        }
    }

/*
    int total=0;
    if (fVerbose)
    {
        TraceMsg(TF_THISMODULE," length   # of strings with that length",1);
        for (i=0,n=0; n<m_iNumStrings; i++)
        {
            int k=0;
            for (int j=0; j<m_iNumStrings; j++)
            {
                if (m_psiStrings[j].iLen == i)
                    k++;
            }
            if (k)
            {
                if (fVerbose)
                    TraceMsg(TF_THISMODULE,"%5d%10d", i, k);
                n += k;
                total += k*(k+1)/2;
            }
        }
    }
    TraceMsg(TF_THISMODULE,"### Average compares without hash * 100:%5d", total*100/m_iNumStrings);

    total=0;
    for (i=0; i<STRING_HASH_SIZE; i++)
    {
        for (tagStringIndex* p=m_Hash[i]; p; p=p->psiNext)
        {
            if (p->iLen < 0) continue;
            int n=1;
            for (tagStringIndex* q=p->psiNext; q; q=q->psiNext)
            {
                if (p->iLen == q->iLen)
                {
                    n++;
                    q->iLen = -1;
                }
            }
            total += n*(n+1)/2;
        }
    }
    TraceMsg(TF_THISMODULE,"### Average compares with hash * 100:%8d", total*100/m_iNumStrings);
*/
}
#endif

//----------------------------------------------------------------------------
// CWCDwordStringList
CWCDwordStringList::CWCDwordStringList() : CWCStringList()
{
}

CWCDwordStringList::~CWCDwordStringList()
{
    if (m_pData)
        MemFree((HLOCAL)m_pData);
}

BOOL CWCDwordStringList::Init(int iInitBufSize/*=-1*/)
{
    if (!CWCStringList::Init(iInitBufSize))
        return FALSE;

    m_pData = (DWORD_PTR*)MemAlloc(LMEM_FIXED, m_iMaxStrings * sizeof(DWORD));
    if (NULL == m_pData)
        return FALSE;

    return TRUE;
}

int CWCDwordStringList::AddString(LPCWSTR psz, DWORD_PTR dwData/*=0*/, int* piNum/*=NULL*/)
{
    int iOldMaxStrings = m_iMaxStrings;     // track changes in m_iMaxStrings by this call:
    int iNum;
    int iResult = CWCStringList::AddString(psz, 0, &iNum);

    if (iResult == 0)
        return 0;

    if (iOldMaxStrings != m_iMaxStrings)    // make sure we have enough data space
    {
        DWORD_PTR *pData;
//      TraceMsg(TF_THISMODULE, "DwordStringList expanding dwords to %d", m_iMaxStrings);
        pData = (DWORD_PTR*)MemReAlloc((HLOCAL)m_pData, m_iMaxStrings * sizeof(DWORD),
            LMEM_MOVEABLE);
        ASSERT(pData);
        if (!pData)
        {
            DBG_WARN("Realloc failure in DwordStringList");
            MemFree(m_pData);
            m_pData = NULL;         // This is bad
            return 0;
        }

        m_pData = pData;
    }

    if (iResult == 2)       // only set data value if this is a new string
    {
        m_pData[iNum] = dwData;
    }

    if (piNum)
        *piNum = iNum;
    return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\strlist.h ===
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
#ifndef _STRINGLST_H
#define _STRINGLST_H

// Helper functions to properly create CWCStringList.
class CWCStringList;
CWCStringList *CreateCWCStringList(int iInitBufSize=4096);

// BSTR is DWORD length followed by null-term OLECHAR (WCHAR) data
//
//----------------------------------------------------------------------------
// CWCStringList is used to store array of non-duplicate strings. Used for
//   dependency and link storage.
//
// Limitations:
//  1) Strings can only be added and never removed from list
//  2) No duplicate strings can ever be stored
//
// Stores all strings in one big block of memory
// It's efficient at ensuring there are no duplicate strings.
// Scalable. Uses hash. Expands to the limit of memory.
//
// Usage:
//  Create the class. Call Init() and destroy if it fails.
//  Add the strings with AddString
//  Use NumStrings() and GetString() to iterate through all of the stored strings.
//
//  The state can be saved and restored with IPersistStream operations
//
//  We take up memory when we're loaded. Don't initialize one of these objects
//  until you're going to use it.
//----------------------------------------------------------------------------

const int STRING_HASH_SIZE = 127;      // should be prime

const TCHAR PARSE_STRING_DELIM = TEXT('\n');     // To separate URLs

// We're not an OLE object but support IPersistStream members to make saving
//  & restoring easier
class CWCStringList {
public:
    CWCStringList();
virtual ~CWCStringList();

    // Return from AddString
    enum { STRLST_FAIL=0, STRLST_DUPLICATE=1, STRLST_ADDED=2 };

// iInitBufSize is minimum starting buffer size, or -1 for default
virtual BOOL Init(int iInitBufSize=-1);

virtual int   AddString(LPCWSTR lpwstr, DWORD_PTR dwData = 0, int *piNum = NULL);
virtual DWORD_PTR GetStringData(int iNum) { return 0; }
virtual void  SetStringData(int iNum, DWORD_PTR dw) { return; }

    int     NumStrings() { return m_iNumStrings; }

    // iLen must be length in characters of string, not counting null term.
    // -1 if unknown.
    BOOL    FindString(LPCWSTR lpwstr, int iLen, int *piNum=NULL);

    // Returns const pointer to within stringlist's memory
    LPCWSTR GetString    (int iNum)
                {
                    ASSERT(iNum < m_iNumStrings);
                    return m_psiStrings[iNum].lpwstr;
                }

    // Returns length of string in characters
    int     GetStringLen (int iNum)
                { 
                    ASSERT(iNum < m_iNumStrings);
                    return m_psiStrings[iNum].iLen;
                }

    // Returns new BSTR. Free with SysFreeString when you're done.
    BSTR    GetBSTR     (int iNum);

    // IUnknown members
//  STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
//  STDMETHODIMP_(ULONG) AddRef(void);
//  STDMETHODIMP_(ULONG) Release(void);

    // IPersistStream members
//  STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(void);         // Always returns TRUE
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);

    enum { DEFAULT_INIT_BUF_SIZE = 4096 };

protected:
    void    CleanUp();
    void    Clear();
    void    Reset();

    BOOL    InitializeFromBuffer();

    BOOL    m_fValid;                   // Are our buffers initialized?
    int     m_iNumStrings;              // # of strings so far.
    int     m_iMaxStrings;              // # of elements in m_psiStrings

private:
    typedef struct tagStringIndex {
        LPCWSTR         lpwstr;  // pointer to string text in m_pBuffer
        int             iLen;    // length of this string in characters w/o null term
        tagStringIndex* psiNext; // index of next string with same hash value
    } STRING_INDEX, *PSTRING_INDEX, *LPSTRING_INDEX;

    LPSTR   m_pBuffer;                  // Holds all strings
    int     m_iBufEnd;                  // Last byte used in buffer
    int     m_iBufSize;

    LPSTRING_INDEX  m_psiStrings;               // dynamically allocated array
    LPSTRING_INDEX  m_Hash[STRING_HASH_SIZE];   // hash table (array of ptrs within m_psiStrings)
    int             m_iLastHash;                // used to avoid recalculating hashes

    BOOL InsertToHash(LPCWSTR lpwstr, int iLen, BOOL fAlreadyHashed);
    int Hash(LPCWSTR lpwstr, int iLen)
    {
        unsigned long hash=0;

        while (iLen--)
        {
            hash = (hash<<5) + hash + *lpwstr++;
        }

        return m_iLastHash = (int)(hash % STRING_HASH_SIZE);
    }

#ifdef DEBUG
    void SpewHashStats(BOOL fVerbose);
#endif
};

// Helper macros to create the string lists
inline CWCStringList *CreateCWCStringList(int iInitBufSize)
{
    CWCStringList *pRet = new CWCStringList();
    if (pRet->Init(iInitBufSize))
    {
        return pRet;
    }
    delete pRet;
    return NULL;
}

// CWCDwordStringList stores an extra DWORD of data along with each string.
// This data does not get persisted

class CWCDwordStringList : public CWCStringList {

public:
    CWCDwordStringList();
    ~CWCDwordStringList();

    // these are all virtual
    BOOL    Init(int iInitBufSize=-1);
    int     AddString(LPCWSTR psz, DWORD_PTR dwData = 0, int *piNum = NULL);
    DWORD_PTR GetStringData(int iNum) { return m_pData[iNum]; }
    void    SetStringData(int iNum, DWORD_PTR dw) { m_pData[iNum] = dw; }

private:
    DWORD_PTR *m_pData;      // data our caller wants attached to the strings
};

#endif // _STRINGLST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\subitem.h ===
#ifndef _subitem_h
#define _subitem_h

HRESULT BlobToVariant(BYTE *pData, DWORD cbData, VARIANT *pVar, DWORD *pcbUsed, BOOL fStream = FALSE);

class CEnumItemProperties : public IEnumItemProperties
{
public:
    CEnumItemProperties();
    HRESULT Initialize(const SUBSCRIPTIONCOOKIE *pCookie, ISubscriptionItem *psi);
    HRESULT CopyItem(ITEMPROP *pip, WCHAR *pwszName, VARIANT *pVar);
    HRESULT CopyRange(ULONG nStart, ULONG nCount, ITEMPROP *ppip, ULONG *pnCopied);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumItemProperties
    STDMETHODIMP Next( 
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ ITEMPROP *rgelt,
        /* [out] */ ULONG *pceltFetched);
    
    STDMETHODIMP Skip( 
        /* [in] */ ULONG celt);
    
    STDMETHODIMP Reset( void);
    
    STDMETHODIMP Clone( 
        /* [out] */ IEnumItemProperties **ppenum);
    
    STDMETHODIMP GetCount( 
        /* [out] */ ULONG *pnCount);

private:
    ~CEnumItemProperties();

    ULONG       m_cRef;
    ULONG       m_nCurrent;
    ULONG       m_nCount;

    ITEMPROP    *m_pItemProps;
};

class CSubscriptionItem : public ISubscriptionItem 
{
public:
    CSubscriptionItem(const SUBSCRIPTIONCOOKIE *pCookie, HKEY hkey);
    HRESULT Read(HKEY hkeyIn, const WCHAR *pwszValueName, BYTE *pData, DWORD dwDataSize);
    HRESULT ReadWithAlloc(HKEY hkeyIn, const WCHAR *pwszValueName, BYTE **ppData, DWORD *pdwDataSize);
    HRESULT Write(HKEY hkeyIn, const WCHAR *pwszValueName, BYTE *pData, DWORD dwDataSize);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ISubscriptionItem
    STDMETHODIMP GetCookie(SUBSCRIPTIONCOOKIE *pCookie);
    STDMETHODIMP GetSubscriptionItemInfo( 
        /* [out] */ SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo);
    
    STDMETHODIMP SetSubscriptionItemInfo( 
        /* [in] */ const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo);
    
    STDMETHODIMP ReadProperties( 
        ULONG nCount,
        /* [size_is][in] */ const LPCWSTR rgwszName[],
        /* [size_is][out] */ VARIANT rgValue[]);
    
    STDMETHODIMP WriteProperties( 
        ULONG nCount,
        /* [size_is][in] */ const LPCWSTR rgwszName[],
        /* [size_is][in] */ const VARIANT rgValue[]);
    
    STDMETHODIMP EnumProperties( 
        /* [out] */ IEnumItemProperties **ppEnumItemProperties);

    STDMETHODIMP NotifyChanged();

private:
    ~CSubscriptionItem();
    ULONG               m_cRef;
    SUBSCRIPTIONCOOKIE  m_Cookie;
    DWORD               m_dwFlags;
};

#endif // _subitem_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\smtp.cpp ===
//
// SMTP - Simple Mail Transfer Protocol Code
//
// Implements sends mail using SMTP RFC 821.
// Julian Jiggins, 12 January 1997
//

#include "private.h"
#include <winsock.h>

#define TF_THISMODULE  TF_MAILAGENT

#define IS_DIGIT(ch)    InRange(ch, TEXT('0'), TEXT('9'))

//
// Function prototypes for this module
//
SOCKET Connect(char *host, char *port);

#define READ_BUF_LEN 512

//
// Read all you can from a socket
//
void Read(SOCKET sock, char * readBuffer, int bufLen)
{
    int numRead;
    int totalRead = 0;

    do
    {
        numRead = recv(sock, readBuffer+totalRead, bufLen, 0);
        totalRead += numRead;
    }
    while (0);
    // while (numRead > 0);

    //
    // NULL terminate read string
    //
    readBuffer[totalRead] = 0;
}

//
// Send a string specifying an SMTP command and read in response, returning
// TRUE if it is the one expected.
// Note the SMTP protocol is designed such that only the 1 character of the 
// response need be checked, but we check for the exact response (mostly cause
// I just read that bit in the RFC)
// 
BOOL SendAndExpect(SOCKET sock, char * sendBuffer, char * szExpect)
{
    char readBuffer[READ_BUF_LEN];
    int len;
    int numSent;

    //
    // Send string to socket
    //
    numSent = send(sock, sendBuffer, lstrlenA(sendBuffer), 0);
    if (numSent == SOCKET_ERROR) 
    {
        DBG_WARN("Error on send");
        return FALSE;
    }

    //
    // Now read in response
    //
    Read(sock, readBuffer, READ_BUF_LEN);

    DBG2("Sent: %s", sendBuffer);
    DBG2("Read: %s", readBuffer);

    //
    // Expect beginning of response to contain szExpect string
    //
    len = lstrlenA(szExpect);
    if (CompareStringA(LOCALE_SYSTEM_DEFAULT, 0, 
        readBuffer, len, szExpect, len) == 2)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


#define SMTP_221 "221"
#define SMTP_250 "250"
#define SMTP_354 "354"
#define SMTP_EOM "\r\n.\r\n"

//
// Carry out SMTP negotiation
//
BOOL SMTPSendEmail(SOCKET sock, char * szToAddress, char * szFromAddress, char *szMessage)
{
    char sendBuffer[256];
    char readBuffer[READ_BUF_LEN];
    BOOL b = TRUE;
    int r, len;

    //
    // Read the opening response
    //
    Read(sock, readBuffer, sizeof(readBuffer));
    DBG(readBuffer);

    //
    // say Hello and specify my domain
    //
    b = SendAndExpect(sock, "HELO ActiveDesktop\r\n", SMTP_250);
    if (!b) goto done;

    //
    // First special sender in MAIL command
    //
    wnsprintfA(sendBuffer, ARRAYSIZE(sendBuffer), "MAIL FROM:<%s>\r\n", 
              szFromAddress);
    b = SendAndExpect(sock, sendBuffer, SMTP_250);
    if (!b) goto done;

    //
    // Now specify recipient(s)
    //
    wnsprintfA(sendBuffer, ARRAYSIZE(sendBuffer), "RCPT TO:<%s>\r\n", 
              szToAddress);
    b = SendAndExpect(sock, sendBuffer, SMTP_250);
    if (!b) goto done;

    //
    // Now send DATA command
    //
    b = SendAndExpect(sock, "DATA\r\n", SMTP_354);
    if (!b) goto done;

    //
    // Now send mail message
    //
    len = lstrlenA(szMessage);
    r = send(sock, szMessage, len, 0);
    ASSERT(r != SOCKET_ERROR);
    ASSERT(r == len);

    //
    // Specify end of message with single period.
    //
    b = SendAndExpect(sock, SMTP_EOM, SMTP_250);
    if (!b) goto done;

    //
    // Say goodbye
    //
    b = SendAndExpect(sock, "QUIT\r\n", SMTP_221);
 
done:
    return b;
}

//
// Main entry point - 
//  start winsock dll, 
//  connect to socket,
//  and negotiate transfer
//
SMTPSendMessage(char * szServer, char * szToAddress, char * szFromAddress, char * szMessage)
{
    int err;
    SOCKET sock;
    BOOL b = FALSE;
    WSADATA wsaData;

    //
    // Init the winsock dll specifying which version we want.
    //
    err = WSAStartup((WORD)0x0101, &wsaData);
    if (err)
    {
        DBG_WARN("WinSock startup error");
        return FALSE;
    }
    DBG("WinSock successfully started");

    //
    // Actually form the socket connection to the host on port 25
    //
    sock = Connect(szServer, "25");

    if (sock != 0)
    {
        DBG("Connected");
        b = SMTPSendEmail(sock, szToAddress, szFromAddress, szMessage);
    }

    //
    // Done with winsock dll for now
    //
    WSACleanup();
    return b;
}

#ifdef TEST
int
main(int argc, char * argv[])
{
    char szMessage[1024];
    BOOL b;

    //
    // Build message
    //
    lstrcpy(szMessage, "Subject: Subscription Updated: CNN Interactive\r\n");
    lstrcat(szMessage, "Your subscription to CNN Interactive Subscription has been updated\r\n\r\n");
    lstrcat(szMessage, "To view the subscription offline, just click here: ");
    lstrcat(szMessage, "http://www.cnn.com\r\n");
    lstrcat(szMessage, "\r\nThis message was sent by the IE4.0 Information Delivery Agent\r\n");
    lstrcat(szMessage, "\r\n\r\n\r\nDoes this look okay guys? Julian.");

    b = SMTPSendMessage("saranac", "joepe@microsoft.com", szMessage);
    if (b)
        DBG("Sent mail successfully");
    else
        DBG("Couldn't send email");

    return 0;
}
#endif


SOCKET
Connect(char *host, char *port)
{
    struct sockaddr_in sockaddress;
    DWORD  err;
    SOCKET sock, connectresult;

    //
    // Get the socket address
    //
    if(IS_DIGIT(*host))                            
        sockaddress.sin_addr.s_addr=inet_addr(host);
    else 
    {
        struct hostent *hp;
        if((hp=gethostbyname(host))==NULL) 
        {
            DBG_WARN2("Unknown host %s", host);
            return 0;
        }
        memcpy(&sockaddress.sin_addr, hp->h_addr, sizeof(sockaddress.sin_addr));
    }

    //
    // Get the port address
    //
    if(IS_DIGIT(*port))  
        sockaddress.sin_port=htons((USHORT)StrToIntA(port));      
    else 
    {
        DBG_WARN("The port should be a number");
        return 0;
    }
    sockaddress.sin_family=AF_INET;

    //
    // Create a stream style socket
    //
    if((sock=socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) 
        DBG_WARN("socket error");


    DBG("Trying to connect");

    connectresult=connect(sock,(struct sockaddr *) &sockaddress, sizeof(sockaddress));

    if (connectresult == SOCKET_ERROR) 
    {
        switch(err = WSAGetLastError()) 
        {
        case WSAECONNREFUSED:
            DBG_WARN("ERROR - CONNECTION REFUSED.");
            break;
        case WSAENETUNREACH:
            DBG_WARN("ERROR - THE NETWORK IS NOT REACHABLE FROM THIS HOST.");
            break;
        case WSAEINVAL:
            DBG_WARN("ERROR - The socket is not already bound to an address.");
            break;
        case WSAETIMEDOUT:
            DBG_WARN("ERROR - Connection timed out.");
            break;
        default:
            DBG_WARN2("Couldn't connect %d", err);
            break;
        } 
        closesocket(sock);
        return 0;
    }
    return sock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\subsmgr2.cpp ===
#include "private.h"
#include "subsmgrp.h"
#include "subitem.h"

//  Contains implementations of IEnumSubscription and ISubscriptionMgr2

HRESULT SubscriptionItemFromCookie(BOOL fCreateNew, const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie, 
                                   ISubscriptionItem **ppSubscriptionItem);

HRESULT DoGetItemFromURL(LPCTSTR pszURL, ISubscriptionItem **ppSubscriptionItem)
{
    HRESULT hr;
    SUBSCRIPTIONCOOKIE cookie;

    if ((NULL == pszURL) ||
        (NULL == ppSubscriptionItem))
    {
        return E_INVALIDARG;
    }

    hr = ReadCookieFromInetDB(pszURL, &cookie);
    if (SUCCEEDED(hr))
    {
        hr = SubscriptionItemFromCookie(FALSE, &cookie, ppSubscriptionItem);
    }

    return hr;
}

HRESULT DoGetItemFromURLW(LPCWSTR pwszURL, ISubscriptionItem **ppSubscriptionItem)
{
    TCHAR szURL[INTERNET_MAX_URL_LENGTH];

    if ((NULL == pwszURL) ||
        (NULL == ppSubscriptionItem))
    {
        return E_INVALIDARG;
    }

#ifdef UNICODE
    StrCpyN(szURL, pwszURL, ARRAYSIZE(szURL));
#else
    MyOleStrToStrN(szURL, ARRAYSIZE(szURL), pwszURL);
#endif

    return DoGetItemFromURL(szURL, ppSubscriptionItem);
}


HRESULT DoAbortItems( 
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies)
{
    HRESULT hr;

    if ((0 == dwNumCookies) || (NULL == pCookies))
    {
        return E_INVALIDARG;
    }

    ISubscriptionThrottler *pst;

    hr = CoCreateInstance(CLSID_SubscriptionThrottler, NULL, 
                          CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                          IID_ISubscriptionThrottler, (void **)&pst);

    if (SUCCEEDED(hr))
    {
        hr = pst->AbortItems(dwNumCookies, pCookies);
        pst->Release();
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT DoCreateSubscriptionItem( 
    /* [in] */  const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo,
    /* [out] */ SUBSCRIPTIONCOOKIE *pNewCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem)
{
    HRESULT hr;
    ISubscriptionItem *psi;

    if ((NULL == pSubscriptionItemInfo) ||
        (NULL == pNewCookie) ||
        (NULL == ppSubscriptionItem))
    {
        return E_INVALIDARG;
    }

    *ppSubscriptionItem = NULL;

    CreateCookie(pNewCookie);

    hr = SubscriptionItemFromCookie(TRUE, pNewCookie, &psi);

    if (SUCCEEDED(hr))
    {
        ASSERT(NULL != psi);

        hr = psi->SetSubscriptionItemInfo(pSubscriptionItemInfo);
        if (SUCCEEDED(hr))
        {
            *ppSubscriptionItem = psi;
        }
        else
        {
            //  Don't leak or leave slop hanging around
            psi->Release();
            DoDeleteSubscriptionItem(pNewCookie, FALSE);
        }
    }

    return hr;
}

HRESULT DoCloneSubscriptionItem(
    /* [in] */  ISubscriptionItem *pSubscriptionItem, 
    /* [out] */ SUBSCRIPTIONCOOKIE *pNewCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem)
{
    HRESULT hr;
    SUBSCRIPTIONCOOKIE NewCookie;

    if ((NULL == pSubscriptionItem) ||
        (NULL == ppSubscriptionItem))
    {
        return E_INVALIDARG;
    }

    IEnumItemProperties *peip;
    SUBSCRIPTIONITEMINFO sii;

    *ppSubscriptionItem = NULL;

    //  First get existing subscription details
    sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
    hr = pSubscriptionItem->GetSubscriptionItemInfo(&sii);

    if (SUCCEEDED(hr))
    {
        ISubscriptionItem *psi;

        //  Mark as temp and create a new subscription item
        sii.dwFlags |= SI_TEMPORARY;

        hr = DoCreateSubscriptionItem(&sii, &NewCookie, &psi);

        if (SUCCEEDED(hr))
        {
            if (pNewCookie)
                *pNewCookie = NewCookie;

            //  Get properties from existing item 
            hr = pSubscriptionItem->EnumProperties(&peip);
            if (SUCCEEDED(hr))
            {
                ULONG count;
                
                ASSERT(NULL != peip);

                hr = peip->GetCount(&count);

                if (SUCCEEDED(hr))
                {
                    ITEMPROP *pProps = new ITEMPROP[count];
                    LPWSTR *pNames = new LPWSTR[count];
                    VARIANT *pVars = new VARIANT[count];

                    if ((NULL != pProps) && (NULL != pNames) && (NULL != pVars))
                    {
                        hr = peip->Next(count, pProps, &count);

                        if (SUCCEEDED(hr))
                        {
                            ULONG i;

                            for (i = 0; i < count; i++)
                            {
                                pNames[i] = pProps[i].pwszName;
                                pVars[i] = pProps[i].variantValue;
                            }

                            hr = psi->WriteProperties(count, pNames, pVars);

                            //  clean up from enum
                            for (i = 0; i < count; i++)
                            {
                                if (pProps[i].pwszName)
                                {
                                    CoTaskMemFree(pProps[i].pwszName);
                                }
                                VariantClear(&pProps[i].variantValue);
                            }
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    SAFEDELETE(pProps);
                    SAFEDELETE(pNames);
                    SAFEDELETE(pVars);
                }
                
                peip->Release();
            }

            if (SUCCEEDED(hr))
            {
                *ppSubscriptionItem = psi;
            }
            else
            {
                psi->Release();
            }
        }
    }
    return hr;
}

HRESULT DoDeleteSubscriptionItem(
    /* [in] */ const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie_ua,
    /* [in] */ BOOL fAbortItem)
{
    HRESULT hr;
    TCHAR szKey[MAX_PATH];
    SUBSCRIPTIONCOOKIE cookie_buf;
    SUBSCRIPTIONCOOKIE *pCookie;

    //
    // Make an aligned copy of pCookie_ua and set a pointer to it.
    //

    if (pCookie_ua != NULL) {
        cookie_buf = *pCookie_ua;
        pCookie = &cookie_buf;
    } else {
        pCookie = NULL;
    }

    if (NULL == pCookie)
    {
        return E_INVALIDARG;
    }

    if (fAbortItem)
    {
        DoAbortItems(1, pCookie);
    }

    if (ItemKeyNameFromCookie(pCookie, szKey, ARRAYSIZE(szKey)))
    {
        // Notify the agent that it is about to get deleted.
        ISubscriptionItem *pItem=NULL;
        if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, pCookie, &pItem)))
        {
            SUBSCRIPTIONITEMINFO sii = { sizeof(SUBSCRIPTIONITEMINFO) };

            if (SUCCEEDED(pItem->GetSubscriptionItemInfo(&sii)))
            {
                ASSERT(!(sii.dwFlags & SI_TEMPORARY));

                ISubscriptionAgentControl *psac=NULL;

                if (SUCCEEDED(
                    CoCreateInstance(sii.clsidAgent,
                                      NULL,
                                      CLSCTX_INPROC_SERVER,
                                      IID_ISubscriptionAgentControl,
                                      (void**)&psac)))
                {
                    psac->SubscriptionControl(pItem, SUBSCRIPTION_AGENT_DELETE);
                    psac->Release();
                }

                FireSubscriptionEvent(SUBSNOTF_DELETE, pCookie);

                if (GUID_NULL != sii.ScheduleGroup)
                {
                    ISyncScheduleMgr *pSyncScheduleMgr;
                    hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_ALL, 
                                          IID_ISyncScheduleMgr, (void **)&pSyncScheduleMgr);

                    if (SUCCEEDED(hr))
                    {                
                        pSyncScheduleMgr->RemoveSchedule(&sii.ScheduleGroup);
                        pSyncScheduleMgr->Release();
                    }
                }
            }

            pItem->Release();
        }

        hr = (SHDeleteKey(HKEY_CURRENT_USER, szKey) == ERROR_SUCCESS) ? S_OK : E_FAIL;
    }
    else
    {
        TraceMsg(TF_ALWAYS, "Failed to delete subscription item.");
        hr = E_FAIL;
    }

    return hr;
}

HRESULT AddUpdateSubscription(SUBSCRIPTIONCOOKIE UNALIGNED *pCookie_ua,
                              SUBSCRIPTIONITEMINFO *psii,
                              LPCWSTR pwszURL,
                              ULONG nProps,
                              const LPWSTR rgwszName[], 
                              VARIANT rgValue[])
{
    HRESULT hr = S_OK;
    SUBSCRIPTIONCOOKIE cookie_buf;
    SUBSCRIPTIONCOOKIE *pCookie;

    //
    // Make an aligned copy of pCookie_ua and set a pointer to it.
    //

    cookie_buf = *pCookie_ua;
    pCookie = &cookie_buf;
    
    ASSERT((0 == nProps) || ((NULL != rgwszName) && (NULL != rgValue)));

    TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    ISubscriptionItem *psi = NULL;
    SUBSCRIPTIONCOOKIE cookie;

#ifdef UNICODE
    StrCpyNW(szURL, pwszURL, ARRAYSIZE(szURL));
#else
    MyOleStrToStrN(szURL, ARRAYSIZE(szURL), pwszURL);
#endif

    //  Try and get the cookie from the inet db otherwise 
    //  create a new one.

    if (*pCookie == CLSID_NULL)
    {
        CreateCookie(&cookie);
    }
    else
    {
        cookie = *pCookie;
    }
    //  Update the inet db
    WriteCookieToInetDB(szURL, &cookie, FALSE);
       
    hr = SubscriptionItemFromCookie(TRUE, &cookie, &psi);

    if (SUCCEEDED(hr))
    {
        hr = psi->SetSubscriptionItemInfo(psii);
        if (SUCCEEDED(hr) && (nProps > 0))
        {
            ASSERT(NULL != psi);

            hr = psi->WriteProperties(nProps, rgwszName, rgValue);
        }
        psi->Release();

        if (FAILED(hr))
        {
            DoDeleteSubscriptionItem(&cookie, TRUE);
        }
    }

    *pCookie_ua = cookie_buf;

    return hr;
}

HRESULT SubscriptionItemFromCookie(BOOL fCreateNew, const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie_ua, 
                                   ISubscriptionItem **ppSubscriptionItem)
{
    HRESULT hr;
    SUBSCRIPTIONCOOKIE cookie_buf;
    SUBSCRIPTIONCOOKIE *pCookie;

    //
    // Make an aligned copy of pCookie_ua and set a pointer to it.
    //

    if (pCookie_ua != NULL) {
        cookie_buf = *pCookie_ua;
        pCookie = &cookie_buf;
    } else {
        pCookie = NULL;
    }

    ASSERT((NULL != pCookie) && (NULL != ppSubscriptionItem));

    HKEY hkey;
    
    if (OpenItemKey(pCookie, fCreateNew ? TRUE : FALSE, KEY_READ | KEY_WRITE, &hkey))
    {
        *ppSubscriptionItem = new CSubscriptionItem(pCookie, hkey);
        if (NULL != *ppSubscriptionItem)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        RegCloseKey(hkey);
    }
    else
    {
        *ppSubscriptionItem = NULL;
        hr = E_FAIL;
    }
    return hr;
}

BOOL ItemKeyNameFromCookie(const SUBSCRIPTIONCOOKIE *pCookie, 
    TCHAR *pszKeyName, DWORD cchKeyName)
{
    WCHAR wszGuid[GUIDSTR_MAX];

    ASSERT((NULL != pCookie) && 
           (NULL != pszKeyName) && 
           (cchKeyName >= ARRAYSIZE(WEBCHECK_REGKEY_STORE) + GUIDSTR_MAX));

    if (StringFromGUID2(*pCookie, wszGuid, ARRAYSIZE(wszGuid)))
    {
#ifdef UNICODE
        wnsprintfW(pszKeyName, cchKeyName, L"%s\\%s", c_szRegKeyStore, wszGuid);
#else
        wnsprintfA(pszKeyName, cchKeyName, "%s\\%S", c_szRegKeyStore, wszGuid);
#endif
        return TRUE;
    }

    return FALSE;
}

BOOL OpenItemKey(const SUBSCRIPTIONCOOKIE *pCookie, BOOL fCreateNew, REGSAM samDesired, HKEY *phkey)
{
    TCHAR szKeyName[MAX_PATH];

    ASSERT((NULL != pCookie) && (NULL != phkey));

    if (ItemKeyNameFromCookie(pCookie, szKeyName, ARRAYSIZE(szKeyName)))
    {
        if (fCreateNew)
        {
            DWORD dwDisposition;
            return RegCreateKeyEx(HKEY_CURRENT_USER, szKeyName, 0, NULL, REG_OPTION_NON_VOLATILE,
                                  samDesired, NULL, phkey, &dwDisposition) == ERROR_SUCCESS;
        }
        else
        {
            return RegOpenKeyEx(HKEY_CURRENT_USER, szKeyName, 0, samDesired, phkey) == ERROR_SUCCESS;
        }
    }

    return FALSE;
}

//  ISubscriptionMgr2 members

STDMETHODIMP CSubscriptionMgr::GetItemFromURL( 
    /* [in] */ LPCWSTR pwszURL,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem)
{
    return DoGetItemFromURLW(pwszURL, ppSubscriptionItem);
}

STDMETHODIMP CSubscriptionMgr::GetItemFromCookie( 
    /* [in] */ const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem)
{
    if ((NULL == pSubscriptionCookie) ||
        (NULL == ppSubscriptionItem))
    {
        return E_INVALIDARG;
    }

    return SubscriptionItemFromCookie(FALSE, pSubscriptionCookie, ppSubscriptionItem);
}

STDMETHODIMP CSubscriptionMgr::GetSubscriptionRunState(
    /* [in] */ DWORD dwNumCookies,
    /* [in] */ const SUBSCRIPTIONCOOKIE *pSubscriptionCookies,
    /* [out] */ DWORD *pdwRunState)
{
    HRESULT hr;
    
    if ((0 == dwNumCookies) || 
        (NULL == pSubscriptionCookies) ||
        (NULL == pdwRunState))
    {
        return E_INVALIDARG;
    }

    ISubscriptionThrottler *pst;

    hr = CoCreateInstance(CLSID_SubscriptionThrottler, NULL, 
                          CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                          IID_ISubscriptionThrottler, (void **)&pst);

    if (SUCCEEDED(hr))
    {
        hr = pst->GetSubscriptionRunState(dwNumCookies, pSubscriptionCookies, pdwRunState);
        pst->Release();
    }
    else
    {
        //  Couldn't connect to a running throttler so assume nothing
        //  is running.
        for (DWORD i = 0; i < dwNumCookies; i++)
        {
            *pdwRunState++ = 0;
        }

        hr = S_FALSE;
    }

    return hr;
}

STDMETHODIMP CSubscriptionMgr::EnumSubscriptions( 
    /* [in] */ DWORD dwFlags,
    /* [out] */ IEnumSubscription **ppEnumSubscriptions)
{
    HRESULT hr;

    if ((dwFlags & ~SUBSMGRENUM_MASK) || (NULL == ppEnumSubscriptions))
    {
        return E_INVALIDARG;
    }
    
    CEnumSubscription *pes = new CEnumSubscription;

    *ppEnumSubscriptions = NULL;

    if (NULL != pes)
    {
        hr = pes->Initialize(dwFlags);
        if (SUCCEEDED(hr))
        {
            hr = pes->QueryInterface(IID_IEnumSubscription, (void **)ppEnumSubscriptions);
        }
        pes->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CSubscriptionMgr::UpdateItems(
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies)
{
    HRESULT hr;

    if ((dwFlags & ~SUBSMGRUPDATE_MASK) || (0 == dwNumCookies) || (NULL == pCookies))
    {
        return E_INVALIDARG;
    }

    //
    // Fail if restrictions are in place.  
    // FEATURE: Should we have a flag parameter to override this?
    //
    if (SHRestricted2W(REST_NoManualUpdates, NULL, 0))
    {
        SGMessageBox(NULL, IDS_RESTRICTED, MB_OK);
        return E_ACCESSDENIED;
    }

    ISyncMgrSynchronizeInvoke *pSyncMgrInvoke;
    
    hr = CoCreateInstance(CLSID_SyncMgr, 
                          NULL, 
                          CLSCTX_ALL,
                          IID_ISyncMgrSynchronizeInvoke, 
                          (void **)&pSyncMgrInvoke);

    if (SUCCEEDED(hr))
    {
        DWORD dwInvokeFlags = SYNCMGRINVOKE_STARTSYNC;

        if (dwFlags & SUBSMGRUPDATE_MINIMIZE) 
        {
            dwInvokeFlags |= SYNCMGRINVOKE_MINIMIZED;
        }
        hr = pSyncMgrInvoke->UpdateItems(dwInvokeFlags, CLSID_WebCheckOfflineSync,
                                    dwNumCookies * sizeof(SUBSCRIPTIONCOOKIE),
                                    (const BYTE *)pCookies);
        pSyncMgrInvoke->Release();
    }
    
    return hr;
}

STDMETHODIMP CSubscriptionMgr::AbortItems( 
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies)
{
    return DoAbortItems(dwNumCookies, pCookies);
}

STDMETHODIMP CSubscriptionMgr::AbortAll()
{
    HRESULT hr;

    ISubscriptionThrottler *pst;

    hr = CoCreateInstance(CLSID_SubscriptionThrottler, NULL, 
                          CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                          IID_ISubscriptionThrottler, (void **)&pst);

    if (SUCCEEDED(hr))
    {
        hr = pst->AbortAll();
        pst->Release();
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

// ISubscriptionMgrPriv
STDMETHODIMP CSubscriptionMgr::CreateSubscriptionItem( 
    /* [in] */  const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo,
    /* [out] */ SUBSCRIPTIONCOOKIE *pNewCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem)
{
    return DoCreateSubscriptionItem(pSubscriptionItemInfo, pNewCookie, ppSubscriptionItem);
}

STDMETHODIMP CSubscriptionMgr::CloneSubscriptionItem(
    /* [in] */  ISubscriptionItem *pSubscriptionItem, 
    /* [out] */ SUBSCRIPTIONCOOKIE *pNewCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem)
{
    return DoCloneSubscriptionItem(pSubscriptionItem, pNewCookie, ppSubscriptionItem);
}

STDMETHODIMP CSubscriptionMgr::DeleteSubscriptionItem( 
    /* [in] */ const SUBSCRIPTIONCOOKIE *pCookie)
{
    return DoDeleteSubscriptionItem(pCookie, TRUE);
}

//  ** CEnumSubscription **

CEnumSubscription::CEnumSubscription()
{
    ASSERT(NULL == m_pCookies);
    ASSERT(0 == m_nCurrent);
    ASSERT(0 == m_nCount);

    m_cRef = 1;

    DllAddRef();
}

CEnumSubscription::~CEnumSubscription()
{
    if (NULL != m_pCookies)
    {
        delete [] m_pCookies;
    }

    DllRelease();
}

HRESULT CEnumSubscription::Initialize(DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    HKEY hkey = NULL;
    DWORD dwDisposition;

    ASSERT(0 == m_nCount);

    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegKeyStore, 0, NULL, REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkey, &dwDisposition) == ERROR_SUCCESS)
    {
        DWORD nCount;

        if (RegQueryInfoKey(hkey,
            NULL,   // address of buffer for class string 
            NULL,   // address of size of class string buffer 
            NULL,   // reserved 
            &nCount,    // address of buffer for number of subkeys 
            NULL,   // address of buffer for longest subkey name length  
            NULL,   // address of buffer for longest class string length 
            NULL,   // address of buffer for number of value entries 
            NULL,   // address of buffer for longest value name length 
            NULL,   // address of buffer for longest value data length 
            NULL,   // address of buffer for security descriptor length 
            NULL    // address of buffer for last write time
            ) == ERROR_SUCCESS)
        {
            SUBSCRIPTIONCOOKIE Cookie;
            m_pCookies = new SUBSCRIPTIONCOOKIE[nCount];
                       
            if (NULL != m_pCookies)
            {
                TCHAR szKeyName[GUIDSTR_MAX];

                hr = S_OK;

                for (ULONG i = 0; (i < nCount) && (S_OK == hr); i++)
                {
                    if (RegEnumKey(hkey, i, szKeyName, ARRAYSIZE(szKeyName)) ==
                        ERROR_SUCCESS)
                    {
                        HRESULT hrConvert;
                    #ifdef UNICODE
                        hrConvert = CLSIDFromString(szKeyName, &Cookie);
                    #else
                        WCHAR wszKeyName[GUIDSTR_MAX];
                        MultiByteToWideChar(CP_ACP, 0, szKeyName, -1, 
                            wszKeyName, ARRAYSIZE(wszKeyName));
                        hrConvert = CLSIDFromString(wszKeyName, &Cookie);
                    #endif
                        if (SUCCEEDED(hrConvert))
                        {
                            ISubscriptionItem *psi;

                            m_pCookies[m_nCount] = Cookie;

                            hr = SubscriptionItemFromCookie(FALSE, &Cookie, &psi);
                            
                            if (SUCCEEDED(hr))
                            {
                                SUBSCRIPTIONITEMINFO sii;
                                sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
                                
                                if (SUCCEEDED(psi->GetSubscriptionItemInfo(&sii)))
                                {
                                    //  Only count this if it's not a temporary
                                    //  or the caller asked for temporary items.
                                    if ((!(sii.dwFlags & SI_TEMPORARY)) ||
                                        (dwFlags & SUBSMGRENUM_TEMP))
                                    {
                                        m_nCount++;
                                    }
                                }
                                psi->Release();
                            }
                        }
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        RegCloseKey(hkey);
    }

    return hr;
}

// IUnknown members
STDMETHODIMP CEnumSubscription::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;

    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }

    if ((IID_IUnknown == riid) || (IID_IEnumSubscription == riid))
    {
        *ppv = (IEnumSubscription *)this;
        AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    
    return hr;
}

STDMETHODIMP_(ULONG) CEnumSubscription::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CEnumSubscription::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CEnumSubscription::CopyRange(ULONG nStart, ULONG nCount, 
                                     SUBSCRIPTIONCOOKIE *pCookies, ULONG *pnCopied)
{
    ULONG nCopied = 0;

    ASSERT((NULL != pCookies) && (NULL != pnCopied));

    if (m_nCurrent < m_nCount)
    {
        ULONG nRemaining = m_nCount - m_nCurrent;
        nCopied = min(nRemaining, nCount); 
        memcpy(pCookies, m_pCookies + m_nCurrent, nCopied * sizeof(SUBSCRIPTIONCOOKIE));
    }
    
    *pnCopied = nCopied;

    return (nCopied == nCount) ? S_OK : S_FALSE;
}

// IEnumSubscription
STDMETHODIMP CEnumSubscription::Next(
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ SUBSCRIPTIONCOOKIE *rgelt,
    /* [out] */ ULONG *pceltFetched)
{
    HRESULT hr;

    if ((0 == celt) || 
        ((celt > 1) && (NULL == pceltFetched)) ||
        (NULL == rgelt))
    {
        return E_INVALIDARG;
    }

    DWORD nFetched;

    hr = CopyRange(m_nCurrent, celt, rgelt, &nFetched);

    m_nCurrent += nFetched;

    if (pceltFetched)
    {
        *pceltFetched = nFetched;
    }

    return hr;
}

STDMETHODIMP CEnumSubscription::Skip( 
    /* [in] */ ULONG celt)
{
    HRESULT hr;
    
    m_nCurrent += celt;

    if (m_nCurrent > (m_nCount - 1))
    {
        m_nCurrent = m_nCount;  //  Passed the last one
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }
    
    return hr;
}


STDMETHODIMP CEnumSubscription::Reset()
{
    m_nCurrent = 0;

    return S_OK;
}

STDMETHODIMP CEnumSubscription::Clone( 
    /* [out] */ IEnumSubscription **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppenum = NULL;

    CEnumSubscription *pes = new CEnumSubscription;

    if (NULL != pes)
    {
        pes->m_pCookies = new SUBSCRIPTIONCOOKIE[m_nCount];

        if (NULL != pes->m_pCookies)
        {
            ULONG nFetched;

            hr = E_FAIL;

            pes->m_nCount = m_nCount;
            CopyRange(0, m_nCount, pes->m_pCookies, &nFetched);

            ASSERT(m_nCount == nFetched);

            if (m_nCount == nFetched)
            {
                hr = pes->QueryInterface(IID_IEnumSubscription, (void **)ppenum);
            }
        }
        pes->Release();
    }    
    return hr;
}


STDMETHODIMP CEnumSubscription::GetCount( 
    /* [out] */ ULONG *pnCount)
{
    if (NULL == pnCount)
    {
        return E_INVALIDARG;
    }

    *pnCount = m_nCount;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\subsmgr.cpp ===
#include "private.h"
#include "subsmgrp.h"
#include "offl_cpp.h"
#include "helper.h"
#include "propshts.h"
#include "apithk.h"

#include <mluisupp.h>

#undef TF_THISMODULE
#define TF_THISMODULE TF_WEBCHECKCORE

extern HRESULT LoadSubscription(LPCTSTR url, LPMYPIDL *);
extern TCHAR szInternetSettings[];

extern void PropagateGeneralProp(HWND, POOEBuf);
extern INT_PTR CALLBACK EnableScreenSaverDlgProc(HWND, UINT, WPARAM, LPARAM);
extern HRESULT CreateSubscriptionFromOOEBuf(POOEBuf, LPMYPIDL *);

extern BOOL CALLBACK _AddOnePropSheetPage(HPROPSHEETPAGE, LPARAM);

extern TCHAR g_szDontAskScreenSaver[];    // from WIZARDS.CPP

#define MAX_STR_LENGTH 200

extern DWORD  aHelpIDs[];
extern TCHAR  c_szHelpFile[];

typedef struct
{
    CSubscriptionMgr* pMgr;
    LPCWSTR pwszName;
    LPCWSTR pwszUrl;
    SUBSCRIPTIONINFO* pSubsInfo;
    SUBSCRIPTIONTYPE subsType;
    DWORD dwFlags;
} SUBSCRIBE_ADI_INFO;

static const TCHAR SUBSCRIBEADIPROP[] = TEXT("SADIP");

INT_PTR CALLBACK SummarizeDesktopSubscriptionDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

////////////////////////////////////////////////////////////////////////////////
// Private imports from shdocvw (AddToFavorites API)
//
STDAPI SHAddSubscribeFavorite (HWND hwnd, LPCWSTR pwszURL, LPCWSTR pwszName, DWORD dwFlags,
                               SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO* pInfo);
////////////////////////////////////////////////////////////////////////////////


void UpdateSubsInfoFromOOE (SUBSCRIPTIONINFO* pInfo, POOEBuf pooe);

HRESULT CreateBSTRFromTSTR(BSTR * pBstr, LPCTSTR sz)
{
    int i = lstrlen(sz) + 1;
    *pBstr = SysAllocStringLen(NULL, i);
    if(NULL == *pBstr)
        return E_OUTOFMEMORY;

    MyStrToOleStrN(*pBstr, i, sz);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//
//                        Subsctiption Manager
//
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// constructor / destructor
//
CSubscriptionMgr::CSubscriptionMgr(void)
{
    ASSERT(NULL == _pidl);

    m_cRef = 1;
    m_eInitSrc = _INIT_FROM_URL;    //  Default.
    m_oldType = SUBSTYPE_URL;       //  Default.
    DllAddRef();
}

CSubscriptionMgr::~CSubscriptionMgr()
{
    if (_pidl)
    {
        COfflineFolderEnum::FreePidl(_pidl);
        _pidl = NULL;
    }
    SAFELOCALFREE(m_pBuf);
    SAFERELEASE(m_pUIHelper);
    DllRelease();
}

//
// IUnknown members
//
STDMETHODIMP CSubscriptionMgr::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_ISubscriptionMgr == riid) ||
        (IID_ISubscriptionMgr2 == riid))
    {
        *ppv=(ISubscriptionMgr2 *)this;
    } 
    else if(IID_ISubscriptionMgrPriv == riid)
    {
        *ppv=(ISubscriptionMgrPriv *)this;
    }
    else if(IID_IShellExtInit == riid)
    {
        *ppv=(IShellExtInit *)this;
    }
    else if(IID_IShellPropSheetExt == riid)
    {
        *ppv=(IShellPropSheetExt *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSubscriptionMgr::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CSubscriptionMgr::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}


HRESULT CSubscriptionMgr::RemovePages(HWND hDlg)
{
    HRESULT hr;

    ASSERT(NULL != m_pUIHelper);

    if (NULL == m_pUIHelper)
    {
        return E_UNEXPECTED;
    }

    ISubscriptionAgentShellExt *psase;

    hr = m_pUIHelper->QueryInterface(IID_ISubscriptionAgentShellExt, (void **)&psase);

    if (SUCCEEDED(hr))
    {
        hr = psase->RemovePages(hDlg);
        psase->Release();
    }

    return hr;
}

HRESULT CSubscriptionMgr::SaveSubscription()
{
    HRESULT hr;

    ASSERT(NULL != m_pUIHelper);

    if (NULL == m_pUIHelper)
    {
        return E_UNEXPECTED;
    }

    DWORD dwMaxCount = SHRestricted2W(REST_MaxSubscriptionCount, NULL, 0);
    DWORD dwCount;
    SUBSCRIPTIONTYPE subsType = (m_eInitSrc == _INIT_FROM_INTSHCUT) ? 
                                SUBSTYPE_URL : 
                                SUBSTYPE_CHANNEL;
    
    if ((dwMaxCount > 0) && 
        SUCCEEDED(CountSubscriptions(subsType, &dwCount)) &&
        (dwCount >= dwMaxCount))
    {
        SGMessageBox(GetForegroundWindow(), IDS_RESTRICTED, MB_OK);
        return E_ACCESSDENIED;
    }
    
    ISubscriptionAgentShellExt *psase;

    hr = m_pUIHelper->QueryInterface(IID_ISubscriptionAgentShellExt, (void **)&psase);

    if (SUCCEEDED(hr))
    {
        hr = psase->SaveSubscription();
        psase->Release();
    }

    return hr;
}

HRESULT CSubscriptionMgr::URLChange(LPCWSTR pwszNewURL)
{
    return E_NOTIMPL;
}

HRESULT GetInfoFromDataObject(IDataObject *pido,
                              TCHAR *pszPath, DWORD cchPath,
                              TCHAR *pszFriendlyName, DWORD cchFriendlyName,
                              TCHAR *pszURL, DWORD cchURL,
                              INIT_SRC_ENUM *peInitSrc)
{
    STGMEDIUM stgmed;
    FORMATETC fmtetc = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    HRESULT hr = pido->GetData(&fmtetc, &stgmed);

    if (hr == S_OK)
    {
        TCHAR szTempURL[INTERNET_MAX_URL_LENGTH];
        TCHAR *pszSection;
        TCHAR *pszEntry;
        TCHAR szTempPath[MAX_PATH];
        TCHAR szIniPath[MAX_PATH];

        if (DragQueryFile((HDROP)stgmed.hGlobal, 0, szTempPath, ARRAYSIZE(szTempPath)))
        {
            // save path
            if (NULL != pszPath)
            {
                StrCpyN(pszPath, szTempPath, cchPath);
            }

            StrCpyN(szIniPath, szTempPath, ARRAYSIZE(szIniPath));
            
            // make friendly name from path
            if (NULL != pszFriendlyName)
            {
                PathStripPath(szTempPath);
                PathRemoveExtension(szTempPath);
                StrCpyN(pszFriendlyName, szTempPath, cchFriendlyName);
            }

            if ((NULL != pszURL) || (NULL != peInitSrc))
            {

                if (PathIsDirectory(szIniPath))
                {
                    PathAppend(szIniPath, TEXT("desktop.ini"));
                    pszSection = TEXT("Channel");
                    pszEntry = TEXT("CDFURL");

                    if (NULL != peInitSrc)
                        *peInitSrc = _INIT_FROM_CHANNEL;
                }
                else
                {
                    pszSection = TEXT("InternetShortcut");
                    pszEntry = TEXT("URL");
                    
                    if (NULL != peInitSrc)
                        *peInitSrc = _INIT_FROM_INTSHCUT;
                }

                if (NULL != pszURL)
                {
                    // canonicalize url
                    if (SHGetIniString(pszSection, pszEntry,
                                                szTempURL, 
                                                INTERNET_MAX_URL_LENGTH, 
                                                szIniPath))
                    {
                        if(!InternetCanonicalizeUrl(szTempURL, pszURL, &cchURL, ICU_NO_ENCODE))
                        {
                            // failed - use non-canonical version
                            StrCpyN(pszURL, szTempURL, cchURL);
                        }
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }
        }
        else 
        {
            hr = E_FAIL;
        }

        ReleaseStgMedium(&stgmed);
    }

    return hr;
}

//
// IShellExtInit / IShellPropSheetExt members
//
STDMETHODIMP CSubscriptionMgr::Initialize(LPCITEMIDLIST pcidlFolder, IDataObject * pido, HKEY hkeyProgID)
{
    HRESULT hr;
    ISubscriptionItem *psi;
    CLSID clsid;
    SUBSCRIPTIONCOOKIE cookie;

    hr = GetInfoFromDataObject(pido, m_pszPath, ARRAYSIZE(m_pszPath),
                               m_pszFriendly, ARRAYSIZE(m_pszFriendly),
                               m_pszURL, ARRAYSIZE(m_pszURL),
                               &m_eInitSrc);

    if (SUCCEEDED(hr))
    {
        hr = DoGetItemFromURL(m_pszURL, &psi);
        
        if (SUCCEEDED(hr))
        {
            SUBSCRIPTIONITEMINFO sii;

            sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

            hr = psi->GetSubscriptionItemInfo(&sii);

            if (SUCCEEDED(hr))
            {
                clsid = sii.clsidAgent;
            }

            psi->GetCookie(&cookie);

            psi->Release();
        }

        if (FAILED(hr))
        {
            //  New subscription       
            hr = S_OK;
            CreateCookie(&cookie);

            switch (m_eInitSrc)
            {
                case _INIT_FROM_INTSHCUT:
                    clsid = CLSID_WebCrawlerAgent;
                    break;
                    
                case _INIT_FROM_CHANNEL:
                    clsid = CLSID_ChannelAgent;
                    break;

                default:
                    hr = E_FAIL;
                    break;
            }
        }

        if (SUCCEEDED(hr))
        {
            //  HACKHACK:
            //  We call coinit and uninit and keep an object pointer around.
            //  This ain't cool but will work as long as the agents are in
            //  webcheck.  Need to fix this for multi-cast handler.
            hr = CoInitialize(NULL);

            if (SUCCEEDED(hr))
            {
                hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
                                      IID_IUnknown, (void**)&m_pUIHelper);

                if (SUCCEEDED(hr))
                {
                    ISubscriptionAgentShellExt *psase;

                    hr = m_pUIHelper->QueryInterface(IID_ISubscriptionAgentShellExt, (void **)&psase);
                    if (SUCCEEDED(hr))
                    {
                        WCHAR wszURL[ARRAYSIZE(m_pszURL)];
                        WCHAR wszName[MAX_NAME + 1];

                        MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), m_pszURL);
                        MyStrToOleStrN(wszName, ARRAYSIZE(wszName), m_pszFriendly);
                        
                        hr = psase->Initialize(&cookie, wszURL, wszName,
                                               (clsid == CLSID_ChannelAgent) ?
                                               SUBSTYPE_CHANNEL : SUBSTYPE_URL);
                        psase->Release();
                    }
                }
                CoUninitialize();
            }
        }
    }

    return hr;
}

STDMETHODIMP CSubscriptionMgr::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    HRESULT hr;
    if (SHRestricted2W(REST_NoEditingSubscriptions, NULL, 0))
        return E_FAIL;

    ASSERT(NULL != m_pUIHelper);

    if (NULL == m_pUIHelper)
    {
        return E_UNEXPECTED;
    }

    IShellPropSheetExt *pspse;

    hr = m_pUIHelper->QueryInterface(IID_IShellPropSheetExt, (void **)&pspse);

    if (SUCCEEDED(hr))
    {
        hr = pspse->AddPages(lpfnAddPage, lParam);
        pspse->Release();
    }

    return hr;
}

STDMETHODIMP CSubscriptionMgr::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplacePage, LPARAM lParam)
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// ISubscriptionMgr members
//

STDMETHODIMP CSubscriptionMgr::IsSubscribed(LPCWSTR pURL, BOOL * pFSub)
{
    HRESULT hr;

    ASSERT (pURL && pFSub);
    MyOleStrToStrN(m_pszURL, INTERNET_MAX_URL_LENGTH, pURL);
 
    * pFSub = FALSE;

    if (!_pidl)
    {
        hr = LoadSubscription(m_pszURL, &_pidl);
        if ((hr != S_OK) || (!_pidl))
            return S_OK;
    }
    else if (UrlCompare(URL(&(_pidl->ooe)), m_pszURL, TRUE))
    {
        COfflineFolderEnum::FreePidl(_pidl);
        _pidl = NULL;
        hr = LoadSubscription(m_pszURL, &_pidl);
        if ((hr != S_OK) || (!_pidl))
            return S_OK;
    }

    * pFSub = TRUE;
    return S_OK;
}

STDMETHODIMP CSubscriptionMgr::DeleteSubscription(LPCWSTR pURL, HWND hwnd)
{
    ASSERT(pURL);
    MyOleStrToStrN(m_pszURL, INTERNET_MAX_URL_LENGTH, pURL);

    if (!_pidl)
    {
        HRESULT hr;

        hr = LoadSubscription(m_pszURL, &_pidl);
        if ((hr != S_OK) || (!_pidl))
            return E_FAIL;
    }

    // This is a restricted action.  The restriction
    // is checked in ConfirmDelete.  If you remove this call,
    // you must add the restriction check here.
    if (!ConfirmDelete(hwnd, 1, &_pidl))
        return E_FAIL;

    HRESULT hr = DoDeleteSubscription(&(_pidl->ooe));
    if (SUCCEEDED(hr))
    {
        TraceMsg(TF_ALWAYS, "%s(URL:%s) deleted", NAME(&(_pidl->ooe)), URL(&(_pidl->ooe)));

        _GenerateEvent(SHCNE_DELETE, (LPITEMIDLIST)_pidl, NULL);

        COfflineFolderEnum::FreePidl(_pidl);
        _pidl = NULL;
    }
    return hr;
}

STDMETHODIMP CSubscriptionMgr::ShowSubscriptionProperties(LPCWSTR pURL, HWND hwnd)
{
    HRESULT hr = S_OK;
    LPMYPIDL oldPidl = NULL, newPidl = NULL;

    ASSERT(pURL);
    MyOleStrToStrN(m_pszURL, INTERNET_MAX_URL_LENGTH, pURL);

    if (!m_pBuf)
    {
        m_pBuf = (OOEBuf *)MemAlloc(LPTR, sizeof(OOEBuf));
        if (NULL == m_pBuf)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        GetDefaultOOEBuf(m_pBuf, SUBSTYPE_URL);

        if(SUCCEEDED(LoadSubscription(m_pszURL, &oldPidl)))
        {
            POOEntry pooe = &(oldPidl->ooe);

            StrCpyN(m_pszFriendly, NAME(&(oldPidl->ooe)), ARRAYSIZE(m_pszFriendly));

            CopyToOOEBuf(&(oldPidl->ooe), m_pBuf);

            m_pBuf->m_dwPropSheetFlags = PSF_IS_ALREADY_SUBSCRIBED;
        }
        else
        {
            CreateCookie(&m_pBuf->m_Cookie);
            StrCpyN(m_pszFriendly, m_pszURL, ARRAYSIZE(m_pszFriendly));
            StrCpyN(m_pBuf->m_URL, m_pszURL, ARRAYSIZE(m_pBuf->m_URL));
            StrCpyN(m_pBuf->m_Name, m_pszURL, ARRAYSIZE(m_pBuf->m_Name));
        }

        hr = CoCreateInstance(*(&m_pBuf->clsidDest), NULL, CLSCTX_INPROC_SERVER, 
                              IID_IUnknown, (void **)&m_pUIHelper);

        if (SUCCEEDED(hr))
        {
            ISubscriptionAgentShellExt *psase;
            
            hr = m_pUIHelper->QueryInterface(IID_ISubscriptionAgentShellExt, (void **)&psase);

            if (SUCCEEDED(hr))
            {
                WCHAR wszURL[MAX_URL + 1];
                WCHAR wszName[MAX_NAME + 1];

                MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), m_pBuf->m_URL);
                MyStrToOleStrN(wszName, ARRAYSIZE(wszName), m_pBuf->m_Name);

                hr = psase->Initialize(&m_pBuf->m_Cookie, wszURL, wszName, (SUBSCRIPTIONTYPE)-1);
                psase->Release();
            }

            if (SUCCEEDED(hr))
            {
                PROPSHEETHEADER psh = { 0 } ;
                HPROPSHEETPAGE hPropPage[MAX_PROP_PAGES];

                // initialize propsheet header.
                psh.dwSize      = sizeof(PROPSHEETHEADER);
                psh.dwFlags     = PSH_PROPTITLE;
                psh.hwndParent  = hwnd;
                psh.pszCaption  = m_pszFriendly;
                psh.hInstance   = g_hInst;
                psh.nPages      = 0;
                psh.nStartPage  = 0;
                psh.phpage      = hPropPage;

                PROPSHEETPAGE psp;
                psp.dwSize          = sizeof(PROPSHEETPAGE);
                psp.dwFlags         = PSP_DEFAULT;
                psp.hInstance       = MLGetHinst();
                psp.pszIcon         = NULL;
                psp.pszTitle        = NULL;
                psp.lParam          = (LPARAM)this;

                psp.pszTemplate     = MAKEINTRESOURCE(IDD_SUBSPROPS_SUMMARY);
                psp.pfnDlgProc      = SummaryPropDlgProc;

                psh.phpage[psh.nPages++] = Whistler_CreatePropertySheetPageW(&psp);

                if (NULL != hPropPage[0])
                {
                    if (m_pBuf->m_dwPropSheetFlags & PSF_IS_ALREADY_SUBSCRIBED)
                    {
                        hr = AddPages(_AddOnePropSheetPage, (LPARAM)&psh);
                    }

                    if (SUCCEEDED(hr))
                    {
                        INT_PTR iRet = PropertySheet(&psh);

                        if (iRet < 0)
                        {
                            hr = E_FAIL;
                        }
                        else
                        {
                            hr = LoadSubscription(m_pszURL, &newPidl);
                            if (SUCCEEDED(hr))
                            {
                                if (_pidl)
                                {
                                    COfflineFolderEnum::FreePidl(_pidl);
                                }

                                _pidl = newPidl;
                            }
                        }
                    }
                }
            }
        }

        if (NULL != oldPidl)
        {
            COfflineFolderEnum::FreePidl(oldPidl);
        }
    }

    return hr;
}

//
//
//

void
CSubscriptionMgr::ChangeSubscriptionValues (
    OOEBuf *pCurrent,
    SUBSCRIPTIONINFO *pNew
)
{
    //
    // Channel flags
    //

    if (SUBSINFO_CHANNELFLAGS & pNew->fUpdateFlags)
    {
        pCurrent->fChannelFlags = pNew->fChannelFlags;
    }


    //
    // The subscription schedule.
    //

    if (SUBSINFO_SCHEDULE & pNew->fUpdateFlags)
    {

        switch (pNew->schedule)
        {

            case SUBSSCHED_DAILY:
            case SUBSSCHED_MANUAL:
            case SUBSSCHED_WEEKLY:
                LoadGroupCookie(&pCurrent->groupCookie, pNew->schedule);
                break;

            case SUBSSCHED_CUSTOM:
                pCurrent->groupCookie = pNew->customGroupCookie;
                break;

            case SUBSSCHED_AUTO:
                {
                    //  FEATURE. We should look at subType;
                    memset(&pCurrent->groupCookie, 0, sizeof(pCurrent->groupCookie));  //t-mattgi so it will look at the trigger
                    PTASK_TRIGGER pNewTrigger = ((PTASK_TRIGGER)pNew->pTrigger);
                    if (pNewTrigger && pNewTrigger->cbTriggerSize == sizeof(TASK_TRIGGER))
                    {
                        pCurrent->m_Trigger = *pNewTrigger;
                    }
                    else    //bad trigger; use daily as default
                    {
                        pCurrent->m_Trigger.cbTriggerSize = 0;
                        pCurrent->groupCookie = NOTFCOOKIE_SCHEDULE_GROUP_DAILY;
                    }
                }
                pCurrent->fChannelFlags |= CHANNEL_AGENT_DYNAMIC_SCHEDULE;
                break;

            default:
                ASSERT(FALSE);
                break;
        }
    }

    //
    // Recurse levels.
    //

    if (SUBSINFO_RECURSE & pNew->fUpdateFlags)
       pCurrent->m_RecurseLevels = pNew->dwRecurseLevels;

    //
    // Webcrawler flags.  Note:  The flags are not or'd with the current flags.
    // The caller must set all of the webcrawler flags they want to use.
    //

    if (SUBSINFO_WEBCRAWL & pNew->fUpdateFlags)
        pCurrent->m_RecurseFlags = pNew->fWebcrawlerFlags;

    //
    // Mail notification.
    //

    if (SUBSINFO_MAILNOT & pNew->fUpdateFlags)
        pCurrent->bMail = pNew->bMailNotification;
    else
        pCurrent->bMail = FALSE;

    //
    // Need password.
    //

    if (SUBSINFO_NEEDPASSWORD & pNew->fUpdateFlags)
        pCurrent->bNeedPassword = pNew->bNeedPassword;
    else
        pCurrent->bNeedPassword = FALSE;
    
    //
    // User name.
    //

    if (SUBSINFO_USER & pNew->fUpdateFlags)
    {
        if (pNew->bstrUserName)
        {
            MyOleStrToStrN(pCurrent->username, MAX_USERNAME, pNew->bstrUserName);
        }
        pCurrent->bNeedPassword = pNew->bNeedPassword;
    }
    
    //
    // Password.
    //

    if (SUBSINFO_PASSWORD & pNew->fUpdateFlags)
    {
        if (pNew->bstrPassword)
        {
            MyOleStrToStrN(pCurrent->password, MAX_PASSWORD, pNew->bstrPassword);
        }
        pCurrent->bNeedPassword = pNew->bNeedPassword;
    }

    //
    // Friendly Name.
    //

    if (SUBSINFO_FRIENDLYNAME & pNew->fUpdateFlags)
    {
        if (pNew->bstrFriendlyName)
        {
            MyOleStrToStrN(pCurrent->m_Name, MAX_NAME, pNew->bstrFriendlyName);
        }
    }

    //
    // Gleam
    //

    if (SUBSINFO_GLEAM & pNew->fUpdateFlags)
    {
        pCurrent->bGleam = pNew->bGleam;
    }

    //
    // Changes only (notification only)
    //

    if (SUBSINFO_CHANGESONLY & pNew->fUpdateFlags)
    {
        pCurrent->bChangesOnly = pNew->bChangesOnly;
    }

    //
    // dwMaxSizeKB
    //
    if (SUBSINFO_MAXSIZEKB & pNew->fUpdateFlags)
    {
        pCurrent->m_SizeLimit = pNew->dwMaxSizeKB;
    }

    //
    // Task flags
    //
    if (SUBSINFO_TASKFLAGS & pNew->fUpdateFlags)
    {
        pCurrent->grfTaskTrigger = pNew->fTaskFlags;
    }

    return;
}

//
// CSubscriptionMgr::CountSubscriptions
// FEATURE: We could make this public if other people need it.  An enumerator
// would be more useful though...
//
HRESULT CSubscriptionMgr::CountSubscriptions(SUBSCRIPTIONTYPE subType, PDWORD pdwCount)
{
    HRESULT hr;
    IEnumSubscription *pes;

    ASSERT(NULL != pdwCount);

    *pdwCount = 0;

    hr = EnumSubscriptions(0, &pes);

    if (SUCCEEDED(hr))
    {
        SUBSCRIPTIONCOOKIE cookie;

        while (S_OK == pes->Next(1, &cookie, NULL))
        {
            ISubscriptionItem *psi;
            DWORD dwRet;

            if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, &cookie, &psi)))
            {
                if (SUCCEEDED(ReadDWORD(psi, c_szPropChannel, &dwRet)) && dwRet)
                {
                    if (SUBSTYPE_CHANNEL == subType)
                        (*pdwCount)++;
                }
                else if (SUCCEEDED(ReadDWORD(psi, c_szPropDesktopComponent, &dwRet)) && dwRet)
                {
                    if (SUBSTYPE_DESKTOPURL == subType || SUBSTYPE_DESKTOPCHANNEL == subType)
                        (*pdwCount)++;
                }
                else
                {
                    if (SUBSTYPE_URL == subType)
                        (*pdwCount)++;
                }
                psi->Release();
            }
        }
    }

    return hr;
}

//
// CSubscriptionMgr::IsValidSubscriptionInfo
//

#define SUBSCRIPTIONSCHEDULE_MAX 4

BOOL CSubscriptionMgr::IsValidSubscriptionInfo(SUBSCRIPTIONTYPE subType, SUBSCRIPTIONINFO *pSI)
{
    if (pSI->cbSize != sizeof(SUBSCRIPTIONINFO))
    {
        return FALSE;
    }
    else if (pSI->fUpdateFlags & ~SUBSINFO_ALLFLAGS)
    {
        return FALSE;
    }
    else if (pSI->pTrigger && ((TASK_TRIGGER*)(pSI->pTrigger))->cbTriggerSize &&
        (subType == SUBSTYPE_URL || subType == SUBSTYPE_DESKTOPURL)) // || pSI->schedule != SUBSSCHED_AUTO))
    {
        return FALSE;
    }
    else if (pSI->fUpdateFlags & SUBSINFO_SCHEDULE)
    {
        if (pSI->schedule > SUBSCRIPTIONSCHEDULE_MAX)
        {
            return FALSE;
        }
        if (pSI->schedule == SUBSSCHED_CUSTOM && pSI->customGroupCookie == CLSID_NULL)
        {
            return FALSE;
        }
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
//
// *** RemoveURLMapping ***
//
// Description:
//     Removes the cache and registry settings that wininet uses to map the 
//     given url to a local file.
//
////////////////////////////////////////////////////////////////////////////////

#define PRELOAD_REG_KEY \
    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Preload")

void RemoveURLMapping(LPCWSTR pszURL)
{
    BYTE cei[MY_MAX_CACHE_ENTRY_INFO];
    DWORD cbcei = sizeof(cei);
    LPINTERNET_CACHE_ENTRY_INFOW pcei = (LPINTERNET_CACHE_ENTRY_INFOW)cei;
    
    //
    // Look up the url in the cache
    //
    if (GetUrlCacheEntryInfoExW(pszURL, pcei, &cbcei, NULL, 0, NULL, 0))
    {
        // 
        // see if it has a mapping because it is a preinstalled cache entry
        //
        if (pcei->CacheEntryType & INSTALLED_CACHE_ENTRY)
        {
            //
            // Clear the flag
            //
            pcei->CacheEntryType &= ~INSTALLED_CACHE_ENTRY;
            SetUrlCacheEntryInfoW(pszURL, pcei, CACHE_ENTRY_ATTRIBUTE_FC);

            //
            // Now remove the mapping from the registry
            //
            HKEY hk;
            if (RegOpenKeyEx(HKEY_CURRENT_USER, PRELOAD_REG_KEY, 0, KEY_WRITE, &hk) == ERROR_SUCCESS) 
            {
                RegDeleteValueW(hk, pszURL);
                RegCloseKey(hk);
            }
        }
    }
}

//
// CSubscriptionMgr::CreateSubscription
// entry point for creating a subscription
// flags:
//    CREATESUBS_FROMFAVORITES -- already exists in favorites, use alternate summary dialog
//                         that doesn't do AddToFavorites.  Valid only for channel or url.
//    CREATESUBS_INACTIVEPLATINUM -- when creating a channel subscription, show Activate Channel dialog
//                         valid only for channel subscriptions with CREATESUBS_FROMFAVORITES
//    CREATESUBS_ADDTOFAVORITES -- display summary dialog before wizard
//        default summary: for channel or url, use AddToFavorites from shdocvw
//                         for desktop item, just a confirmation dialog
//                         for other, no summary -- straight to wizard
//    CREATESUBS_NOUI -- totally silent
//    CREATESUBS_NOSAVE -- update subscription in memory buffer, not on disk (pInfo must be non-NULL)
//
STDMETHODIMP
CSubscriptionMgr::CreateSubscription (
    HWND hwnd,
    LPCWSTR pwszURL,
    LPCWSTR pwszFriendlyName,
    DWORD dwFlags,
    SUBSCRIPTIONTYPE subsType,
    SUBSCRIPTIONINFO *pInfo
)
{
    HRESULT hr = E_INVALIDARG;
    BOOL bAlready;

    if (IsFlagSet(dwFlags, CREATESUBS_NOUI) || !IsFlagSet (dwFlags, CREATESUBS_ADDTOFAVORITES))
    {    //no UI, so skip ATF dialog
        hr = CreateSubscriptionNoSummary (hwnd, pwszURL, pwszFriendlyName, dwFlags,
            subsType, pInfo);

        if (hr == S_OK)
        {
            //
            // The user successfully subscribed to this URL so remove
            // mappings used for preinstalled content as this URL is now
            // "Activated"
            //
            RemoveURLMapping(pwszURL);
        }
    }
    else
    {
        switch (subsType)
        {
        case SUBSTYPE_URL:
        case SUBSTYPE_CHANNEL:
            hr = SHAddSubscribeFavorite (hwnd, pwszURL, pwszFriendlyName,
                                         dwFlags, subsType, pInfo);
            break;

        case SUBSTYPE_DESKTOPCHANNEL:
        case SUBSTYPE_DESKTOPURL:
            hr = IsSubscribed (pwszURL, &bAlready);
            if (SUCCEEDED (hr) && bAlready)
                break;  //don't display summary dialog since it has nothing useful for this case
            hr = CreateDesktopSubscription (hwnd, pwszURL, pwszFriendlyName,
                                            dwFlags, subsType, pInfo);
            break;

        default:    //SUBSTYPE_EXTERNAL -- don't know what kind of summary to show
            hr = CreateSubscriptionNoSummary (hwnd, pwszURL, pwszFriendlyName, dwFlags,
                subsType, pInfo);
            break;
        }
    }

    return hr;
}


//
// CSubscriptionMgr::CreateSubscriptionNoSummary
// modify a SUBSCRIPTIONINFO interactively, using the wizard
// persists info to Subscriptions folder, unless SUBSINFO_NOSAVE passed
//
STDMETHODIMP
CSubscriptionMgr::CreateSubscriptionNoSummary (
    HWND hwnd,
    LPCWSTR pwszURL,
    LPCWSTR pwszFriendlyName,
    DWORD dwFlags,
    SUBSCRIPTIONTYPE subType,
    SUBSCRIPTIONINFO *pInfo
)
{
    HRESULT hr = S_OK;
    
    //
    // Validate the parameters.
    //
    if (!IS_VALID_SUBSCRIPTIONTYPE(subType)
        || !pwszURL
        || !pwszFriendlyName
        || (!pInfo && (dwFlags & CREATESUBS_NOSAVE))
        || (pInfo && !IsValidSubscriptionInfo(subType, pInfo)))
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    //
    // Fail if already subscribed and we aren't in no save or no UI mode.
    // Caller is responsible for UI.
    //
    BOOL fAlreadySubscribed;
    if ((FAILED(IsSubscribed(pwszURL, &fAlreadySubscribed)) || fAlreadySubscribed) &&
        (!(dwFlags & (CREATESUBS_NOSAVE | CREATESUBS_NOUI))))
    {
        return E_FAIL;
    }

    //
    // Fail if restrictions are in place.  
    // FEATURE: Currently cdfview is handling channel restrictions for 
    // but we should probably do it here.
    // Should we have a flag parameter to override this?
    //
    if (SUBSTYPE_URL == subType)
    {
        DWORD dwMaxCount = SHRestricted2W(REST_MaxSubscriptionCount, NULL, 0);
        DWORD dwCount;
        if (SHRestricted2W(REST_NoAddingSubscriptions, pwszURL, 0)
            || ((dwMaxCount > 0)
                && SUCCEEDED(CountSubscriptions(subType, &dwCount))
                && (dwCount >= dwMaxCount)))
        {
            if (!IsFlagSet(dwFlags, CREATESUBS_NOUI))
                SGMessageBox(hwnd, IDS_RESTRICTED, MB_OK);
            return E_ACCESSDENIED;
        }
    }
    
    //
    // Get the subscription defaults and merge in the caller's info
    //
    OOEBuf subProps;
    GetDefaultOOEBuf(&subProps, subType);
    
    //this is (intentionally) duplicated below... it needs to be after the ChangeSubscriptionValues()
    //call, but we need to grab the url first to make sure it's subscribable.
    MyOleStrToStrN(subProps.m_URL, INTERNET_MAX_URL_LENGTH, pwszURL);

    // Does this mean we can't support plugin protocols?
    if (/*(subType != SUBSTYPE_EXTERNAL) &&*/ !IsHTTPPrefixed(subProps.m_URL))
    {
        return E_INVALIDARG;
    }

    if (pInfo)
    {
        ChangeSubscriptionValues(&subProps, pInfo);
        if (fAlreadySubscribed)
        {
            ReadCookieFromInetDB(subProps.m_URL, &subProps.m_Cookie);
            subProps.m_dwPropSheetFlags |= PSF_IS_ALREADY_SUBSCRIBED;
        }
    }

    // Disallow password caching if restriction is in place.  This both
    // skips the wizard page and prevents the caller's password from
    // being saved.
    if (SHRestricted2W(REST_NoSubscriptionPasswords, NULL, 0))
    {
        subProps.bNeedPassword = FALSE;
        subProps.username[0] = 0;
        subProps.password[0] = 0;
        subProps.dwFlags &= ~(PROP_WEBCRAWL_UNAME | PROP_WEBCRAWL_PSWD);
    }

    //the passed-in name and url override whatever's in the info buffer
    MyOleStrToStrN(subProps.m_URL, INTERNET_MAX_URL_LENGTH, pwszURL);
    MyOleStrToStrN(subProps.m_Name, MAX_NAME_QUICKLINK, pwszFriendlyName);

    //
    // If we're in UI mode, initialize the wizard
    //
    if (!IsFlagSet(dwFlags, CREATESUBS_NOUI))
    {
        hr = CreateWizard(hwnd, subType, &subProps);

    } // !NOUI

    //
    // If we're not in NOSAVE mode, then create/save the subscription
    //
    if (SUCCEEDED(hr))
    {
        if (!IsFlagSet(dwFlags, CREATESUBS_NOSAVE))
        {
            //hack to let AddToFavorites dialog display the screen-saver-activate dialog -- it
            //needs to pass NOUI, which disables all UI, but if you also pass FROMFAVORITES and not
            //ADDTOFAVORITES then we still let this dialog slip through.  (Shouldn't affect anyone
            //else because FROMFAVORITES is always used with ADDTOFAVORITES.)
            if (!IsFlagSet(dwFlags, CREATESUBS_NOUI) ||
                (IsFlagSet(dwFlags, CREATESUBS_FROMFAVORITES) && !IsFlagSet (dwFlags, CREATESUBS_ADDTOFAVORITES)))
            {
                // See if the user wants to be asked about enabling the screen saver.
                DWORD dwValue = BST_UNCHECKED;
                ReadRegValue(   HKEY_CURRENT_USER,
                                WEBCHECK_REGKEY,
                                g_szDontAskScreenSaver,
                                &dwValue,
                                SIZEOF(dwValue));

                if  (
                    (subProps.fChannelFlags & CHANNEL_AGENT_PRECACHE_SCRNSAVER)
                    &&
                    (dwValue == BST_UNCHECKED)
                    &&
                    !IsADScreenSaverActive()
                    )
                {
                    DialogBoxParam( MLGetHinst(), 
                             MAKEINTRESOURCE(IDD_SUBSCRIPTION_ENABLECHANNELSAVER),
                             hwnd,
                             EnableScreenSaverDlgProc,
                             0L);
                }
            }

            //
            // Create a new pidl with the user specified properties.
            //
            if (_pidl)
            {
                COfflineFolderEnum::FreePidl(_pidl);
                _pidl = NULL;
                SAFERELEASE(m_pUIHelper);
            }
            hr = CreateSubscriptionFromOOEBuf(&subProps, &_pidl);
            if (SUCCEEDED(hr))
            {
                ASSERT(_pidl);
                //
                // Send a notification that a subscription has changed.
                //
                _GenerateEvent(SHCNE_CREATE, (LPITEMIDLIST)_pidl, NULL);
            }
        } //!NOSAVE
        else if (S_OK == hr)
        {
            //in NOSAVE mode, so don't actually create subscription -- save it back
            //to passed-in buffer
            ASSERT (pInfo);
            pInfo->fUpdateFlags = SUBSINFO_ALLFLAGS;    //fill in all possible fields
            UpdateSubsInfoFromOOE (pInfo, &subProps);
        }
    }
    
    return hr;
}


STDMETHODIMP
CSubscriptionMgr::CreateDesktopSubscription (HWND hwnd, LPCWSTR pwszURL, LPCWSTR pwszFriendlyName,
                        DWORD dwFlags, SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO *pInfo)
{
    HRESULT hr;
    SUBSCRIPTIONINFO siTemp = { sizeof(SUBSCRIPTIONINFO), 0 };
    if (!pInfo)
        pInfo = &siTemp;    //make sure we have a valid buffer if caller doesn't give us one

    //make sure adminrestrictions allow this

    if (SHRestricted2W(REST_NoAddingChannels, pwszURL, 0))
        return E_FAIL;

    SUBSCRIBE_ADI_INFO parms = { this, pwszFriendlyName, pwszURL, pInfo, subsType, dwFlags };

    //make sure this url is subscribable; if not, show error dialog
    {
        TCHAR sz[MAX_URL];
        MyOleStrToStrN (sz, ARRAYSIZE(sz), pwszURL);

        if (!IsHTTPPrefixed (sz))
        {
            SGMessageBox(hwnd, IDS_HTTPONLY, MB_ICONINFORMATION | MB_OK);
            return E_INVALIDARG;
        }
    }

    INT_PTR iDlgResult = DialogBoxParam (MLGetHinst(), MAKEINTRESOURCE(IDD_DESKTOP_SUBSCRIPTION_SUMMARY),
                        hwnd, SummarizeDesktopSubscriptionDlgProc, (LPARAM)&parms);

    switch (iDlgResult)
    {
    case -1:
        hr = E_FAIL;
        break;
    case IDCANCEL:
        hr = S_FALSE;
        break;
    default:
        hr = CreateSubscriptionNoSummary (hwnd, pwszURL, pwszFriendlyName,
                CREATESUBS_NOUI | dwFlags, subsType, pInfo);
        break;
    }

    return hr;
}


STDMETHODIMP
CSubscriptionMgr::GetDefaultInfo(
    SUBSCRIPTIONTYPE    subType,
    SUBSCRIPTIONINFO *pInfo
)
{
    //
    // Validate the parameters.
    //
    if (!IS_VALID_SUBSCRIPTIONTYPE(subType)
        || !pInfo 
        || (pInfo->cbSize != sizeof(SUBSCRIPTIONINFO)))
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    memset((void *)pInfo, 0, sizeof(SUBSCRIPTIONINFO));
    pInfo->cbSize = sizeof(SUBSCRIPTIONINFO);

    // Fill in default structure.  Note that lines are commented out
    // below to indicate the field is initialized to 0 without wasting
    // code (memset above already cleared structure out.)
    
    pInfo->fUpdateFlags = SUBSINFO_RECURSE | SUBSINFO_MAILNOT 
                        | SUBSINFO_WEBCRAWL 
                        /*| SUBSINFO_SCHEDULE */ | SUBSINFO_CHANGESONLY
                        | SUBSINFO_CHANNELFLAGS;
    pInfo->dwRecurseLevels = DEFAULTLEVEL;
    pInfo->schedule = SUBSSCHED_AUTO;
    
    switch (subType)
    {
        case SUBSTYPE_URL:
//            pInfo->bChangesOnly = FALSE;
//            pInfo->bMailNotification = FALSE;
//            pInfo->bPasswordNeeded = FALSE;
            pInfo->fWebcrawlerFlags = DEFAULTFLAGS;
            break;

        case SUBSTYPE_CHANNEL:
//            pInfo->bChangesOnly = FALSE;
//            pInfo->bMailNotification = FALSE;
            pInfo->fChannelFlags = CHANNEL_AGENT_PRECACHE_ALL | CHANNEL_AGENT_DYNAMIC_SCHEDULE;
            break;

        case SUBSTYPE_DESKTOPCHANNEL:
//          pInfo->bChangesOnly = FALSE;
//          pInfo->bMailNotification = FALSE;
            pInfo->fChannelFlags = CHANNEL_AGENT_PRECACHE_ALL | CHANNEL_AGENT_DYNAMIC_SCHEDULE;
            break;
            
        case SUBSTYPE_DESKTOPURL:
//          pInfo->bChangesOnly = FALSE;
//          pInfo->bMailNotification = FALSE;
            pInfo->fWebcrawlerFlags = DEFAULTFLAGS;
            break;
            
        default:
            return E_NOTIMPL;
    }
    
    return S_OK;
}

STDMETHODIMP
CSubscriptionMgr::GetSubscriptionInfo(
    LPCWSTR pwszURL,
    SUBSCRIPTIONINFO *pInfo
)
{
    HRESULT hr;

    //
    // Validate the parameters.
    //
    if (!pInfo 
        || !pwszURL
        || (pInfo->cbSize != sizeof(SUBSCRIPTIONINFO)))
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    BOOL    bSubscribe;
    hr = IsSubscribed(pwszURL, &bSubscribe);

    RETURN_ON_FAILURE(hr);
    if (!bSubscribe)
    {
        return E_FAIL;
    }


    // We cannot rely on the caller passing us a clean SUBSCRIPTIONINFO
    // structure.  We need to clean it ourselves.
    DWORD dwFlags = pInfo->fUpdateFlags;
    ZeroMemory(pInfo, sizeof(SUBSCRIPTIONINFO));
    pInfo->cbSize = sizeof(SUBSCRIPTIONINFO);
    pInfo->fUpdateFlags = dwFlags;

    OOEBuf ooeb;    // Alas, we need the code in UpdateSubsInfoFromOOE
    CopyToOOEBuf (&(_pidl->ooe), &ooeb);    //to work once for a buf and once for an entry, and it's
    UpdateSubsInfoFromOOE (pInfo, &ooeb);   //easier to convert entry->buf so we do that here.

    return S_OK;
}


void UpdateSubsInfoFromOOE (SUBSCRIPTIONINFO* pInfo, POOEBuf pooe)
{
    DWORD   dwFlags = pInfo->fUpdateFlags & SUBSINFO_ALLFLAGS;
    SUBSCRIPTIONTYPE subType = GetItemCategory(pooe);

    if (dwFlags & SUBSINFO_USER)
    {
        SAFEFREEBSTR (pInfo->bstrUserName);
        CreateBSTRFromTSTR(&(pInfo->bstrUserName), pooe->username);
    }
    if (dwFlags & SUBSINFO_PASSWORD)
    {
        SAFEFREEBSTR (pInfo->bstrPassword);
        CreateBSTRFromTSTR(&(pInfo->bstrPassword), pooe->password);
    }
    if (dwFlags & SUBSINFO_FRIENDLYNAME)
    {
        SAFEFREEBSTR (pInfo->bstrFriendlyName);
        CreateBSTRFromTSTR(&(pInfo->bstrFriendlyName), pooe->m_Name);
    }
    
    pInfo->fUpdateFlags = dwFlags;
    if (dwFlags & SUBSINFO_SCHEDULE)
    {
        pInfo->schedule = GetGroup(pooe);
        if (pInfo->schedule == SUBSSCHED_CUSTOM)
        {
            if (pooe->groupCookie != GUID_NULL)
            {
                pInfo->customGroupCookie = pooe->groupCookie;
            }
            else
            {
                GetItemSchedule(&pooe->m_Cookie, &pInfo->customGroupCookie);
                if (pInfo->customGroupCookie == GUID_NULL)
                {
                    pInfo->schedule = SUBSSCHED_MANUAL;
                }
            }
        }
    }
    
    if (PTASK_TRIGGER pInfoTrigger = (PTASK_TRIGGER)pInfo->pTrigger)
    {
        if (pInfoTrigger->cbTriggerSize == pooe->m_Trigger.cbTriggerSize)
            *(pInfoTrigger) = pooe->m_Trigger;
        else
            pInfoTrigger->cbTriggerSize = 0;
    }
    //otherwise, it's already null and we can't do anything about it... luckily, we'll never
    //have a trigger that we need to write back to a SUBSCRIPTIONINFO that didn't already have
    //one.

    if (dwFlags & SUBSINFO_RECURSE)
        pInfo->dwRecurseLevels = pooe->m_RecurseLevels;
    if (dwFlags & SUBSINFO_WEBCRAWL)
        pInfo->fWebcrawlerFlags = pooe->m_RecurseFlags;
    if (dwFlags & SUBSINFO_MAILNOT)
        pInfo->bMailNotification = pooe->bMail;
    if (dwFlags & SUBSINFO_GLEAM)
        pInfo->bGleam = pooe->bGleam;
    if (dwFlags & SUBSINFO_CHANGESONLY)
        pInfo->bChangesOnly = pooe->bChangesOnly;
    if (dwFlags & SUBSINFO_NEEDPASSWORD)
        pInfo->bNeedPassword = pooe->bNeedPassword;
    if (dwFlags & SUBSINFO_CHANNELFLAGS)
    {
        if ((subType==SUBSTYPE_CHANNEL)||(subType==SUBSTYPE_DESKTOPCHANNEL))
        {
            pInfo->fChannelFlags = pooe->fChannelFlags;
        }
        else
        {
            pInfo->fChannelFlags = 0;
            pInfo->fUpdateFlags &= (~SUBSINFO_CHANNELFLAGS);
        }
    }
    if (dwFlags & SUBSINFO_MAXSIZEKB)
        pInfo->dwMaxSizeKB = pooe->m_SizeLimit;


    if (dwFlags & SUBSINFO_TYPE)
    {
        pInfo->subType = GetItemCategory(pooe);
        ASSERT(IS_VALID_SUBSCRIPTIONTYPE(pInfo->subType));
    }

    if (dwFlags & SUBSINFO_TASKFLAGS)
    {
        pInfo->fTaskFlags = pooe->grfTaskTrigger;
    }

}


STDMETHODIMP
CSubscriptionMgr::UpdateSubscription(LPCWSTR pwszURL)
{
    ASSERT(pwszURL);
    BOOL    bSubscribe = FALSE;
    HRESULT hr = IsSubscribed(pwszURL, &bSubscribe);
    CLSID clsId;

    RETURN_ON_FAILURE(hr);
    if (!bSubscribe)
    {
        return E_INVALIDARG;
    }

    //
    // Fail if restrictions are in place.  
    // FEATURE: Should we have a flag parameter to override this?
    //
    if (SHRestricted2W(REST_NoManualUpdates, NULL, 0))
    {
        SGMessageBox(NULL, IDS_RESTRICTED, MB_OK);
        return E_ACCESSDENIED;
    }

    clsId = _pidl->ooe.m_Cookie;    
    hr = SendUpdateRequests(NULL, &clsId, 1);
    _pidl->ooe.m_Cookie = clsId;

    return hr;
}

STDMETHODIMP
CSubscriptionMgr::UpdateAll()
{
    //
    // Fail if restrictions are in place.  
    // FEATURE: Should we have a flag parameter to override this?
    //
    if (SHRestricted2W(REST_NoManualUpdates, NULL, 0))
    {
        SGMessageBox(NULL, IDS_RESTRICTED, MB_OK);
        return E_ACCESSDENIED;
    }

    return SendUpdateRequests(NULL, NULL, 0);
}

HRESULT MergeOOEBuf(POOEBuf p1, POOEBuf p2, DWORD fMask)
{
    ASSERT(p1 && p2);
    DWORD   dwMask = p2->dwFlags & fMask;

    if (dwMask == 0)
        return S_OK;

    if (p1->clsidDest != p2->clsidDest)
        return E_INVALIDARG;

    if (dwMask & PROP_WEBCRAWL_COOKIE)
    {
        //  We shouldn't merge cookies.
    }

    if (dwMask & PROP_WEBCRAWL_SIZE)
    {
        p1->m_SizeLimit = p2->m_SizeLimit;
    }
    if (dwMask & PROP_WEBCRAWL_FLAGS)
    {
        p1->m_RecurseFlags = p2->m_RecurseFlags;
    }
    if (dwMask & PROP_WEBCRAWL_LEVEL)
    {
        p1->m_RecurseLevels = p2->m_RecurseLevels;
    }
    if (dwMask & PROP_WEBCRAWL_URL)
    {
        StrCpyN(p1->m_URL, p2->m_URL, MAX_URL);
    }
    if (dwMask & PROP_WEBCRAWL_NAME)
    {
        StrCpyN(p1->m_Name, p2->m_Name, MAX_NAME);
    }

    if (dwMask & PROP_WEBCRAWL_PSWD)
    {
        StrCpyN(p1->password, p2->password, MAX_PASSWORD);
    }
    if (dwMask & PROP_WEBCRAWL_UNAME)
    {
        StrCpyN(p1->username, p2->username, MAX_USERNAME);
    }
    if (dwMask & PROP_WEBCRAWL_DESKTOP)
    {
        p1->bDesktop = p2->bDesktop;
    }
    if (dwMask & PROP_WEBCRAWL_CHANNEL)
    {
        p1->bChannel = p2->bChannel;
    }
    if (dwMask & PROP_WEBCRAWL_EMAILNOTF)
    {
        p1->bMail = p2->bMail;
    }
    if (dwMask & PROP_WEBCRAWL_RESCH)
    {
        p1->grfTaskTrigger = p2->grfTaskTrigger;
        p1->groupCookie = p2->groupCookie;
        p1->fChannelFlags |= (p2->fChannelFlags & CHANNEL_AGENT_DYNAMIC_SCHEDULE);
    }
    if (dwMask & PROP_WEBCRAWL_LAST)
    {
        p1->m_LastUpdated = p2->m_LastUpdated;
    }
    if (dwMask & PROP_WEBCRAWL_STATUS)
    {
        p1->status = p2->status;
    }
    if (dwMask & PROP_WEBCRAWL_PRIORITY)
    {
        p1->m_Priority = p2->m_Priority;
    }
    if (dwMask & PROP_WEBCRAWL_GLEAM)
    {
        p1->bGleam = p2->bGleam;
    }
    if (dwMask & PROP_WEBCRAWL_CHANGESONLY)
    {
        p1->bChangesOnly = p2->bChangesOnly;
    }
    if (dwMask & PROP_WEBCRAWL_CHANNELFLAGS)
    {
        p1->fChannelFlags = p2->fChannelFlags;
    }

    p1->dwFlags |= (p2->dwFlags & fMask & (~PROP_WEBCRAWL_COOKIE));

    return S_OK;
}


INT_PTR CALLBACK SummarizeDesktopSubscriptionDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SUBSCRIBE_ADI_INFO* pInfo = (SUBSCRIBE_ADI_INFO*)GetProp(hDlg,SUBSCRIBEADIPROP);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pInfo = (SUBSCRIBE_ADI_INFO*)lParam;
        ASSERT (pInfo);
        SetProp (hDlg, SUBSCRIBEADIPROP, (HANDLE)pInfo);
        {   //block to declare vars to update captions
            TCHAR sz[MAX_URL];

            if (pInfo->subsType == SUBSTYPE_DESKTOPCHANNEL)
            {
                if(MLLoadString(
                    (pInfo->pSubsInfo->bNeedPassword ? IDS_DESKTOPCHANNEL_SUMMARY_TEXT : IDS_DESKTOPCHANNEL_SUMMARY_NOPW),
                    sz, ARRAYSIZE(sz)))
                {
                    SetDlgItemText(hDlg, IDC_DESKTOP_SUMMARY_TEXT, sz);
                }
            }

            MyOleStrToStrN (sz, ARRAYSIZE(sz), pInfo->pwszName);
            SetListViewToString(GetDlgItem(hDlg, IDC_SUBSCRIBE_ADI_NAME), sz);
            MyOleStrToStrN (sz, ARRAYSIZE(sz), pInfo->pwszUrl);
            SetListViewToString (GetDlgItem (hDlg, IDC_SUBSCRIBE_ADI_URL), sz);
        }
        break;

    case WM_COMMAND:
        ASSERT (pInfo);
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;

        case IDOK:
            //subscription happens in calling function when we return IDOK
            EndDialog(hDlg, IDOK);
            break;

        case IDC_SUBSCRIBE_CUSTOMIZE:
            //run through wizard in NOSAVE mode
            if (pInfo->pMgr &&
                S_OK == pInfo->pMgr->CreateSubscriptionNoSummary (hDlg, pInfo->pwszUrl,
                                        pInfo->pwszName, pInfo->dwFlags | CREATESUBS_NOSAVE,
                                        pInfo->subsType, pInfo->pSubsInfo))
            {
                SendMessage (hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDOK), TRUE);
            }
            break;
        }
        break;

        case WM_NOTIFY:
            if (LOWORD(wParam) == IDC_SUBSCRIBE_ADI_URL)
            {
                NM_LISTVIEW * pnmlv = (NM_LISTVIEW *)lParam;
                if (pnmlv->hdr.code == LVN_GETINFOTIP)
                {
                    TCHAR szURL[MAX_URL];
                    LV_ITEM lvi = {0};
                    lvi.mask = LVIF_TEXT;
                    lvi.pszText = szURL;
                    lvi.cchTextMax = ARRAYSIZE(szURL);
                    if (!ListView_GetItem (GetDlgItem (hDlg, IDC_SUBSCRIBE_ADI_URL), &lvi))
                        return FALSE;

                    NMLVGETINFOTIP  * pTip = (NMLVGETINFOTIP *)pnmlv;
                    ASSERT(pTip);
                    StrCpyN(pTip->pszText, szURL, pTip->cchTextMax);
                    return TRUE;
                }
            }
        break;

    case WM_DESTROY:
        RemoveProp (hDlg, SUBSCRIBEADIPROP);
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\throttle.cpp ===
#include "private.h"
#include "throttle.h"
#include "subsmgrp.h"

#include <mluisupp.h>

#define TF_THISMODULE TF_THROTTLER

const int MAX_AUTOCACHESIZE_ASK = 2;
const int MIN_CACHE_INCREASE = 1024; // in KB

// Strings for cache restrictions
const TCHAR c_szKeyRestrict[] = TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel");
const TCHAR c_szCache[] = TEXT("Cache");         

CThrottler  *CThrottler::s_pThrottler = NULL;

const CFactoryData CThrottler::s_ThrottlerFactoryData = 
{
    &CLSID_SubscriptionThrottler, CreateInstance, 0
};

#ifdef DEBUG
void DUMPITEM(CHAR *pszMsg, const SUBSCRIPTIONCOOKIE *pCookie)
{
    ISubscriptionItem *psi;
    
    if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, pCookie, &psi)))
    {
        BSTR bstrName;
        if (SUCCEEDED(ReadBSTR(psi, c_szPropName, &bstrName)))
        {
            TraceMsgA(TF_THISMODULE, "%s: %S", pszMsg, bstrName);
            SysFreeString(bstrName);
        }
        psi->Release();
    }
}

#else

#define DUMPITEM(pszMsg, pCookie)

#endif

// dwSyncFlags has 8 bits of enum (EVENTMASK) and the rest is flags
inline BOOL IsSyncEvent(DWORD dwSyncFlags, DWORD dwSyncEvent)
{
    return (dwSyncFlags & SYNCMGRFLAG_EVENTMASK) == dwSyncEvent;
}

inline BOOL IsSyncEventFlag(DWORD dwSyncFlags, DWORD dwSyncEvent)
{
    return (dwSyncFlags & dwSyncEvent) != 0;
}

inline BOOL IsIgnoreIdleSyncEvent(DWORD dwSyncFlags)
{
    return !IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_IDLE);
/*
    return IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_CONNECT) ||
           IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_PENDINGDISCONNECT) ||
           IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_MANUAL) ||
           IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_INVOKE);
*/
}

inline BOOL IsScheduleSyncEvent(DWORD dwSyncFlags)
{
    return IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_SCHEDULED) ||
           IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_IDLE);
}

class CThrottlerProxy : public ISubscriptionThrottler
{
  
public:
    CThrottlerProxy(CThrottler *pThrottler)
    {
        m_cRef = 1;
        m_pThrottler = pThrottler;

        m_pThrottler->ExternalAddRef();
    }

    STDMETHODIMP QueryInterface(REFIID riid, void **punk)
    {
        if ((riid == IID_IUnknown) || (riid == IID_ISubscriptionThrottler))
        {
            *punk = (ISubscriptionThrottler *)this;
            AddRef();
            return S_OK;
        }
        else
        {
            *punk = NULL;
            return E_NOINTERFACE;
        }
    }
    
    STDMETHODIMP_(ULONG) AddRef()
    { 
        return ++m_cRef;
    }
    
    STDMETHODIMP_(ULONG) Release()
    {
        if (--m_cRef == 0)
        {
            delete this;
            return 0;
        }

        return m_cRef;
    }

    STDMETHODIMP GetSubscriptionRunState( 
        /* [in] */ DWORD dwNumCookies,
        /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies,
        /* [size_is][out] */ DWORD *pdwRunState)
    {
        return m_pThrottler->GetSubscriptionRunState(dwNumCookies, pCookies, pdwRunState);
    }
    
    STDMETHODIMP AbortItems( 
        /* [in] */ DWORD dwNumCookies,
        /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies)
    {
        return m_pThrottler->AbortItems(dwNumCookies, pCookies);
    }
    
    STDMETHODIMP AbortAll()
    {
        return m_pThrottler->AbortAll();
    }

private:
    ULONG       m_cRef;
    CThrottler  *m_pThrottler;
    
    ~CThrottlerProxy()
    {
        m_pThrottler->ExternalRelease();
    }

};

HRESULT CThrottler::CreateInstance(IUnknown *punkOuter, IUnknown **ppunk)
{
    HRESULT hr;

    ASSERT(NULL == punkOuter);
    ASSERT(NULL != ppunk);

    if (NULL != CThrottler::s_pThrottler)
    {
        *ppunk = new CThrottlerProxy(CThrottler::s_pThrottler);

        if (NULL != *ppunk) 
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        TraceMsg(TF_ALWAYS, "UNEXPECTED ERROR: Failed to attached to throttler in CreateInstance");
        hr = E_UNEXPECTED;
    }

    return hr;
}

CThrottler::CThrottler()
{
    ASSERT(NULL == s_pThrottler);

    ASSERT(NULL == m_pItemsHead);
    ASSERT(NULL == m_pItemsTail);
    ASSERT(NULL == m_updateQueue[0]);

    //  APPCOMPAT - this is only until msidle is multi-client aware.
    IdleEnd();
    //m_fUserIsIdle = TRUE; //  TODO: need to determine this better
    IdleBegin(NULL);

    m_cRef = 1;
}

CThrottler::~CThrottler()
{
    DBG("Destroying Throttler");

    ASSERT(GetCurrentThreadId() == m_dwThreadId);

    IdleEnd();

    // Destroy window
    if (m_hwndThrottler)
    {
        SetWindowLongPtr(m_hwndThrottler, GWLP_USERDATA, 0);
        DestroyWindow(m_hwndThrottler);
        m_hwndThrottler = NULL;
    }

    s_pThrottler = NULL;

    RevokeClassObject();
}

HRESULT CThrottler::RevokeClassObject()
{
    HRESULT hr;
    
    if (m_dwRegister)
    {
        hr = CoRevokeClassObject(m_dwRegister);
        m_dwRegister = 0;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT /* static */ CThrottler::GetThrottler(CThrottler **ppThrottler)
{
    HRESULT hr = S_OK;
    
    ASSERT(NULL != ppThrottler);

    if (NULL != ppThrottler)
    {
        *ppThrottler = NULL;

        //  If there is no throttler create a new one
        if (NULL == s_pThrottler)
        {
            DBG("Creating new throttler in GetThrottler");

            s_pThrottler = new CThrottler;
            if (NULL != s_pThrottler)
            {
                IClassFactory *pcf = new CClassFactory(&s_ThrottlerFactoryData);
                if (NULL != pcf)
                {
                    HRESULT hrRegister = CoRegisterClassObject(CLSID_SubscriptionThrottler, 
                                                               pcf, 
                                                               CLSCTX_LOCAL_SERVER, 
                                                               REGCLS_MULTIPLEUSE, 
                                                               &s_pThrottler->m_dwRegister);
                    if (FAILED(hrRegister))
                    {
                        TraceMsg(TF_ALWAYS, "CoRegisterClassObject failed - other processes can't talk to us!");
                    }
                    pcf->Release();
                }
                *ppThrottler = s_pThrottler;
#ifdef DEBUG
                s_pThrottler->m_dwThreadId = GetCurrentThreadId();
#endif
            }
            else
            {
                DBG("Failed to create Throttler class factory");
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            //  Attach to existing throttler
            ASSERT(GetCurrentThreadId() == s_pThrottler->m_dwThreadId);
            s_pThrottler->AddRef();
            *ppThrottler = s_pThrottler;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

void CThrottler::OnIdleStateChange(DWORD dwState)
{
    if (NULL != s_pThrottler)
    {
        switch(dwState)
        {
            case STATE_USER_IDLE_BEGIN:
                DBG("OnIdleStateChange: Idle Begin");
            #ifdef DEBUG
                LogEvent(TEXT("Idle state begins"));
            #endif

                s_pThrottler->OnIdleBegin();
                break;

            case STATE_USER_IDLE_END:
                DBG("OnIdleStateChange: Idle End");
            #ifdef DEBUG
                LogEvent(TEXT("Idle state ends"));
            #endif

                s_pThrottler->OnIdleEnd();
                break;
        }
    }
}

void CThrottler::OnIdleBegin()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    m_fUserIsIdle = TRUE;
    FillTheQueue();
}

void CThrottler::OnIdleEnd()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    m_fUserIsIdle = FALSE;

    for (int i = 0; i < ARRAYSIZE(m_updateQueue); i++)
    {
        if ((NULL != m_updateQueue[i]) && 
            (m_updateQueue[i]->m_dwRunState & RS_SUSPENDONIDLE))
        {
            DUMPITEM("Suspending in CThrottler::OnIdleEnd", &m_updateQueue[i]->m_cookie);

            ISubscriptionAgentControl *pSubsAgentCtl;
            CUpdateItem *pUpdateItem = m_updateQueue[i];
           
            pSubsAgentCtl = m_updateQueue[i]->m_pSubsAgentCtl;

            m_updateQueue[i]->m_dwRunState &= ~RS_UPDATING;
            m_updateQueue[i]->m_dwRunState |= RS_SUSPENDED;

            m_updateQueue[i] = NULL;

            ASSERT(NULL != pSubsAgentCtl);

            if (SUCCEEDED(pSubsAgentCtl->PauseUpdate(0)))
            {
                WCHAR wszMsg[256];

                MLLoadStringW(IDS_UPDATE_PAUSED, wszMsg, ARRAYSIZE(wszMsg));
                NotifyHandlers(NH_UPDATEPROGRESS, &pUpdateItem->m_cookie, -1,
                               -1, -1, WC_INTERNAL_S_PAUSED, wszMsg);
            }
        }
    }

    FillTheQueue();
}

STDMETHODIMP CThrottler::QueryInterface(REFIID riid, void **ppv)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }

    if ((IID_IUnknown == riid) || (IID_ISubscriptionAgentEvents == riid))
    {
        *ppv = (ISubscriptionAgentEvents *)this;
    }
    else if (IID_ISubscriptionThrottler == riid)
    {
        *ppv = (ISubscriptionThrottler *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}


ULONG CThrottler::ExternalAddRef()
{
    AddRef();
    
    return ++m_cExternalRef;
}

ULONG CThrottler::ExternalRelease()
{
    ULONG cRef = --m_cExternalRef;

    Release();

    return cRef;
}

STDMETHODIMP_(ULONG) CThrottler::AddRef()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CThrottler::Release()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CThrottler::NotifyHandlers(int idCmd, const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, ...)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = S_OK;
    va_list va;
    long lSizeDownloaded = -1;
    long lProgressCurrent = -1;
    long lProgressMax = -1;
    HRESULT hrParam = E_UNEXPECTED;
    LPCWSTR wszParam = NULL;

    va_start(va, pSubscriptionCookie);

    //  First extract args
    switch (idCmd)
    {
        case NH_UPDATEBEGIN:
            //  Nothing to do for now
            break;

        case NH_UPDATEPROGRESS:
            lSizeDownloaded = va_arg(va, long);
            lProgressCurrent = va_arg(va, long);
            lProgressMax = va_arg(va, long);
            hrParam = va_arg(va, HRESULT);
            wszParam = va_arg(va, LPCWSTR);
            break;

        case NH_UPDATEEND:
            lSizeDownloaded = va_arg(va, long);
            hrParam = va_arg(va, HRESULT);
            wszParam = va_arg(va, LPCWSTR);
            break;

        case NH_REPORTERROR:
            hrParam = va_arg(va, HRESULT);
            wszParam = va_arg(va, LPCWSTR);
            break;

        default:
            ASSERT(0);  //  Don't know what to do
            hr = E_UNEXPECTED;
            break;
    }

    //  Now loop
    HRESULT hrTemp = S_OK;
    CSyncMgrNode *pSyncMgrNode = m_pSyncMgrs;

    while (pSyncMgrNode)
    {
        COfflineSync *pOfflineSync = pSyncMgrNode->m_pOfflineSync;
        pSyncMgrNode = pSyncMgrNode->m_pNext;

        switch (idCmd)
        {
            case NH_UPDATEBEGIN:
                hrTemp = pOfflineSync->UpdateBegin(pSubscriptionCookie);
                break;

            case NH_UPDATEPROGRESS:
                hrTemp = pOfflineSync->UpdateProgress(pSubscriptionCookie, 
                                                      lSizeDownloaded, 
                                                      lProgressCurrent, 
                                                      lProgressMax, 
                                                      hrParam, 
                                                      wszParam);

                break;

            case NH_UPDATEEND:
                hrTemp = pOfflineSync->UpdateEnd(pSubscriptionCookie, 
                                                 lSizeDownloaded, 
                                                 hrParam, 
                                                 wszParam);
                break;

            case NH_REPORTERROR:
                hrTemp = pOfflineSync->ReportError(pSubscriptionCookie, 
                                                hrParam, 
                                                wszParam);
                break;
        }

        if (FAILED(hrTemp))
        {
            hr = hrTemp;
        }
    }

    va_end(va);

    return hr;
}

// ISubscriptionAgentEvents members
STDMETHODIMP CThrottler::UpdateBegin(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;
    CUpdateItem *pUpdateItem;

    hr = FindCookie(pSubscriptionCookie, &pUpdateItem);

    ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
    {
        DUMPITEM("CThrottler::UpdateBegin", pSubscriptionCookie);
        pUpdateItem->m_dwRunState &= ~(RS_READY | RS_SUSPENDED);
        pUpdateItem->m_dwRunState |= RS_UPDATING;

        hr = NotifyHandlers(NH_UPDATEBEGIN, pSubscriptionCookie);
    }

    return hr;
}

STDMETHODIMP CThrottler::UpdateProgress(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        long lSizeDownloaded,
        long lProgressCurrent,
        long lProgressMax,
        HRESULT hrStatus,
        LPCWSTR wszStatus)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;

    CUpdateItem *pUpdateItem;

    //  TODO:
    //  Adjust the max to fool syncmgr
    if (SUCCEEDED(FindCookie(pSubscriptionCookie, &pUpdateItem)))
    {
        if ((lProgressMax < 0) || (lProgressMax <= lProgressCurrent))
        {
            if (pUpdateItem->m_nMax <= lProgressCurrent)
            {
                pUpdateItem->m_nMax = (lProgressCurrent * 3) / 2;
            }

            lProgressMax = pUpdateItem->m_nMax;
        }
    }

    hr = NotifyHandlers(NH_UPDATEPROGRESS, pSubscriptionCookie, lSizeDownloaded,
                            lProgressCurrent, lProgressMax, hrStatus, wszStatus);
    return hr;
}

STDMETHODIMP CThrottler::UpdateEnd(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        long lSizeDownloaded,
        HRESULT hrResult,
        LPCWSTR wszResult)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;
    CUpdateItem *pUpdateItem;
    SUBSCRIPTIONCOOKIE cookie = *pSubscriptionCookie;

    hr = FindCookie(pSubscriptionCookie, &pUpdateItem);

    if (SUCCEEDED(hr))
    {
        DUMPITEM("CThrottler::UpdateEnd", pSubscriptionCookie);

        pUpdateItem->m_dwRunState &= ~(RS_READY | RS_SUSPENDED | RS_UPDATING | RS_SUSPENDONIDLE);
        pUpdateItem->m_dwRunState |= RS_COMPLETED;

        RemoveItemFromList(pUpdateItem, TRUE);

        //  ************************************************************************
        //  Don't use anything that could have come from pUpdateItem after this 
        //  including the pSubscriptionCookie above which came from an agent which
        //  probably no longer exists!
        //  (actually, the agent keeps itself alive until this call returns)
        //  ************************************************************************

    }

    hr = NotifyHandlers(NH_UPDATEEND, &cookie,
                        lSizeDownloaded, hrResult, wszResult);

    FireSubscriptionEvent(SUBSNOTF_SYNC_STOP, &cookie);

    FillTheQueue();

    return hr;
}

STDMETHODIMP CThrottler::ReportError(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        HRESULT hrError, 
        LPCWSTR wszError)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;

    if (INET_E_AGENT_EXCEEDING_CACHE_SIZE == hrError)
    {
        // Agent is notifying us that they're about to exceed the cache size.
        hr = AutoCacheSizeRequest(pSubscriptionCookie);
    }
    else
        hr = NotifyHandlers(NH_REPORTERROR, pSubscriptionCookie, hrError, wszError);

    return hr;
}

STDMETHODIMP CThrottler::GetSubscriptionRunState( 
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies,
    /* [size_is][out] */ DWORD *pdwRunState)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
  
    if ((0 == dwNumCookies) ||
        (NULL == pCookies) ||
        (NULL == pdwRunState))
    {
        return E_INVALIDARG;
    }

    for (DWORD i = 0; i < dwNumCookies; i++, pCookies++, pdwRunState++)
    {
        CUpdateItem *pUpdateItem;

        if (SUCCEEDED(FindCookie(pCookies, &pUpdateItem)))
        {
            *pdwRunState = pUpdateItem->m_dwRunState;
        }
        else
        {
            *pdwRunState = 0;
        }
    }

    return S_OK;
}

// DoAbortItem will cause the CThrottler to get released if the last running
//  agent is aborted (Agent notifies it's done, SyncMgr releases throttler,
//   then agent releases throttler)
HRESULT CThrottler::DoAbortItem(CUpdateItem *pUpdateItem)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;

    ASSERT(((pUpdateItem->m_dwRunState & (RS_UPDATING | RS_SUSPENDED)) && 
            (NULL != pUpdateItem->m_pSubsAgentCtl))
           ||
           (NULL == pUpdateItem->m_pSubsAgentCtl));

    if ((pUpdateItem->m_dwRunState & (RS_UPDATING | RS_SUSPENDED)) &&
        (NULL != pUpdateItem->m_pSubsAgentCtl))
    {
        DUMPITEM("CThrottler::DoAbortItem with existing Agent", &pUpdateItem->m_cookie);
        hr = pUpdateItem->m_pSubsAgentCtl->AbortUpdate(0);
    }
    else
    {
        WCHAR wszMsg[256];

        MLLoadStringW(IDS_STATUS_ABORTED, wszMsg, ARRAYSIZE(wszMsg));

        DUMPITEM("CThrottler::DoAbortItem with no Agent", &pUpdateItem->m_cookie);
        
        ReportThrottlerError(&pUpdateItem->m_cookie, E_ABORT, wszMsg);
        hr = UpdateEnd(&pUpdateItem->m_cookie, 0, E_ABORT, wszMsg);
    }

    return hr;
}

STDMETHODIMP CThrottler::AbortItems( 
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;

    if ((0 == dwNumCookies) ||
        (NULL == pCookies))
    {
        return E_INVALIDARG;
    }

    if (FAILED(CreateThrottlerWnd()))
        return E_FAIL;

    hr = S_OK;

    void *pItem = MemAlloc(LMEM_FIXED, dwNumCookies * sizeof(SUBSCRIPTIONCOOKIE));
    if (pItem)
    {

#ifdef DEBUG
        for (DWORD i = 0; i < dwNumCookies; i++)
        {
            DUMPITEM("Aborting in CThrottler::AbortItems", &pCookies[i]);
        }
#endif

        memcpy(pItem, pCookies, dwNumCookies * sizeof(SUBSCRIPTIONCOOKIE));
        PostMessage(m_hwndThrottler, WM_THROTTLER_ABORTITEM, (WPARAM)dwNumCookies, (LPARAM)pItem);
    }
    else
    {
        DBG_WARN("Memory alloc failed in CThrottler::AbortItems");
        hr = S_FALSE;
    }
    return hr;
}
        
STDMETHODIMP CThrottler::ActuallyAbortItems( 
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;

    if ((0 == dwNumCookies) ||
        (NULL == pCookies))
    {
        return E_INVALIDARG;
    }

    hr = S_OK;

    // DoAbortItem will cause the CThrottler to get released if the last
    //  running agent is aborted. Protect against that.
    AddRef();

    for (DWORD i = 0; i < dwNumCookies; i++, pCookies++)
    {
        HRESULT hrItem;
        CUpdateItem *pUpdateItem;

        hrItem = FindCookie(pCookies, &pUpdateItem);
        if (SUCCEEDED(hrItem))
        {
            hrItem = DoAbortItem(pUpdateItem);

            //  ************************************************************************
            //  pUpdateItem is no longer valid!
            //  ************************************************************************
        }

        if (FAILED(hrItem))
        {
            hr = S_FALSE;
        }
    }

    Release();

    return hr;
}

HRESULT CThrottler::CreateThrottlerWnd()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    if (!m_hwndThrottler)
    {
        WNDCLASS wc;

        wc.style = 0;
        wc.lpfnWndProc = CThrottler::ThrottlerWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = g_hInst;
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = (HBRUSH)NULL;
        wc.lpszMenuName = NULL;
        wc.lpszClassName = THROTTLER_WNDCLASS;

        RegisterClass(&wc);

        m_hwndThrottler = CreateWindow(THROTTLER_WNDCLASS, TEXT("YO"), WS_OVERLAPPED,
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    NULL, NULL, g_hInst, (LPVOID)this);

        if (NULL == m_hwndThrottler)
        {
            DBG_WARN("CThrottler CreateWindow failed");
            return E_FAIL;
        }
    }

    return S_OK;
}

LRESULT CThrottler::ThrottlerWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    CThrottler *pThis = (CThrottler*) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    // Validate pThis
#ifdef DEBUG
    if (pThis && IsBadWritePtr(pThis, sizeof(*pThis)))
    {
        TraceMsg(TF_THISMODULE|TF_WARNING,
            "Invalid 'this' in ThrottlerWndProc (0x%08x) - already destroyed?", pThis);
    }
    if (pThis)
    {
        ASSERT(GetCurrentThreadId() == pThis->m_dwThreadId);
        ASSERT(GetCurrentThreadId() == GetWindowThreadProcessId(hWnd, NULL));
    }
#endif

    switch (Msg)
    {
        case WM_CREATE :
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;

            if (!pcs || !(pcs->lpCreateParams))
            {
                DBG_WARN("Invalid param ThrottlerWndProc Create");
                return -1;
            }
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) pcs->lpCreateParams);
            return 0;
        }

        case WM_THROTTLER_ABORTALL:
            if (pThis)
                pThis->ActuallyAbortAll();
            break;

        case WM_THROTTLER_ABORTITEM:
            if (pThis)
                pThis->ActuallyAbortItems((ULONG) wParam, (SUBSCRIPTIONCOOKIE*) lParam);
            MemFree((HLOCAL)lParam);
            break;

        case WM_THROTTLER_AUTOCACHESIZE_ASK:
            if (pThis)
                pThis->AutoCacheSizeAskUser((DWORD)lParam);
            break;

        default:
            return DefWindowProc(hWnd, Msg, wParam, lParam);
    }

    return 0;
}

STDMETHODIMP CThrottler::AbortAll()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    if (FAILED(CreateThrottlerWnd()))
        return E_FAIL;

    DBG("Aborting all items");

    PostMessage(m_hwndThrottler, WM_THROTTLER_ABORTALL, 0, 0);

    return S_OK;
}

STDMETHODIMP CThrottler::ActuallyAbortAll()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = S_OK;
    CUpdateItem *pItem = m_pItemsHead;

    if (FALSE == m_fAbortingAll)
    {
        m_fAbortingAll = TRUE;

        while (pItem)
        {
            CUpdateItem *pUpdateItem = pItem;

            //  Move forward now since this item should get yanked!
            pItem = pItem->m_pNext;

            if (FAILED(DoAbortItem(pUpdateItem)))
            {
                hr = S_FALSE;
            }
        }
        m_fAbortingAll = FALSE;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CThrottler::Advise(COfflineSync *pOfflineSync)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;
    CSyncMgrNode *pSyncMgrNode;

    ASSERT(NULL != pOfflineSync);

#ifdef DEBUG
    pSyncMgrNode = m_pSyncMgrs;

    while (pSyncMgrNode)
    {
        if (pSyncMgrNode->m_pOfflineSync == pOfflineSync)
        {
            ASSERT(0);      //  Shouldn't advise more than once!
        }
        pSyncMgrNode = pSyncMgrNode->m_pNext;
    }
 #endif

    ASSERT(!m_hwndParent || (m_hwndParent == pOfflineSync->GetParentWindow()));

    m_hwndParent = pOfflineSync->GetParentWindow();

    pSyncMgrNode = new CSyncMgrNode(pOfflineSync, m_pSyncMgrs);

    if (NULL != pSyncMgrNode)
    {
        pOfflineSync->AddRef();
        m_pSyncMgrs = pSyncMgrNode;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CThrottler::Unadvise(COfflineSync *pOfflineSync)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = E_FAIL;
    CSyncMgrNode *pSyncMgrNode;
    CSyncMgrNode **ppSyncMgrPrev;

    ASSERT(NULL != pOfflineSync);

    pSyncMgrNode = m_pSyncMgrs;
    ppSyncMgrPrev = &m_pSyncMgrs;

    while (pSyncMgrNode)
    {
        if (pSyncMgrNode->m_pOfflineSync == pOfflineSync)
        {
            *ppSyncMgrPrev = pSyncMgrNode->m_pNext;
            delete pSyncMgrNode;
            hr = S_OK;
            break;
        }
        ppSyncMgrPrev = &pSyncMgrNode->m_pNext;
        pSyncMgrNode = pSyncMgrNode->m_pNext;
    }

    ASSERT(SUCCEEDED(hr));  //  This is internal goo so should not fail!

    if (NULL == m_pSyncMgrs)
    {
        //  Everyone has lost interest in us...
        RevokeClassObject();
        s_pThrottler = NULL;

        while (m_cExternalRef > 0)
        {
            TraceMsg(TF_WARNING, "CThrottle::Unadvise m_cExternalRef = %d", m_cExternalRef);
            MSG msg;
            
            if (PeekMessage(&msg, NULL, 0, 0, TRUE))
            {
                DispatchMessage(&msg);
            }
        }
    }
    
    return hr;
}

int CThrottler::GetCookieIndexInQueue(const SUBSCRIPTIONCOOKIE *pCookie)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    int index = -1;
    
    for (int i = 0; i < ARRAYSIZE(m_updateQueue); i++)
    {
        if ((NULL != m_updateQueue[i]) && (m_updateQueue[i]->m_cookie == *pCookie))
        {   
            index = i;
            break;
        }
    }

    return index;
}

void CThrottler::FailedUpdate(HRESULT hr, const SUBSCRIPTIONCOOKIE *pCookie)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    WCHAR wszMsg[256];
    int resID;

    switch (hr)
    {
        case INET_E_SCHEDULED_UPDATES_DISABLED:
            resID = IDS_SCHEDULED_UPDATES_DISABLED;
            break;
            
        case INET_E_SCHEDULED_UPDATES_RESTRICTED:
            resID = IDS_SCHEDULED_UPDATES_RESTRICTED;
            break;
            
        case INET_E_SCHEDULED_UPDATE_INTERVAL:
            resID = IDS_SCHEDULED_UPDATE_INTERVAL;
            break;
            
        case INET_E_SCHEDULED_EXCLUDE_RANGE:
            resID = IDS_SCHEDULED_EXCLUDE_RANGE;
            break;
            
        default:
            resID = IDS_CRAWL_STATUS_NOT_OK;
            break;
    }

    MLLoadStringW(resID, wszMsg, ARRAYSIZE(wszMsg));
    ReportThrottlerError(pCookie, hr, wszMsg);
    UpdateEnd(pCookie, 0, hr, wszMsg);
}

void CThrottler::RunItem(int queueSlot, CUpdateItem *pUpdateItem)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr; 

    ASSERT(NULL == m_updateQueue[queueSlot]);

    m_updateQueue[queueSlot] = pUpdateItem;

    if (pUpdateItem->m_dwRunState & RS_SUSPENDED)
    {
        DUMPITEM("Resuming suspended item in CThrottler::RunItem", &pUpdateItem->m_cookie);
        ASSERT(NULL != pUpdateItem->m_pSubsAgentCtl);

        pUpdateItem->m_dwRunState |= RS_UPDATING;
        pUpdateItem->m_dwRunState &= ~RS_SUSPENDED;
        hr = pUpdateItem->m_pSubsAgentCtl->ResumeUpdate(0);

        if (SUCCEEDED(hr))
        {
            WCHAR wszMsg[256];

            MLLoadStringW(IDS_UPDATE_RESUMING, wszMsg, ARRAYSIZE(wszMsg));
            NotifyHandlers(NH_UPDATEPROGRESS, &pUpdateItem->m_cookie, -1,
                           -1, -1, WC_INTERNAL_S_RESUMING, wszMsg);
        }
    }
    else
    {
        ISubscriptionItem *psi;

        hr = SubscriptionItemFromCookie(FALSE, &pUpdateItem->m_cookie, &psi);


        if (SUCCEEDED(hr))
        {
            SUBSCRIPTIONITEMINFO sii;
            
            sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
            hr = psi->GetSubscriptionItemInfo(&sii);
            if (SUCCEEDED(hr))
            {
                hr = CoCreateInstance(sii.clsidAgent, 
                                      NULL, 
                                      CLSCTX_INPROC_SERVER, 
                                      IID_ISubscriptionAgentControl, 
                                      (void**)&pUpdateItem->m_pSubsAgentCtl);

                if (SUCCEEDED(hr))
                {
                    DUMPITEM("Running item in CThrottler::RunItem", &pUpdateItem->m_cookie);
                    hr = pUpdateItem->m_pSubsAgentCtl->StartUpdate(psi, 
                                (ISubscriptionAgentEvents *)this);

                    FireSubscriptionEvent(SUBSNOTF_SYNC_START, &pUpdateItem->m_cookie);

                }
                else
                {
                    DBG_WARN("CoCreate Agent FAILED in CThrottler::RunItem");
                }
            }
            psi->Release();
        }
        else
        {
            DBG_WARN("SubscriptionItemFromCookie FAILED in CThrottler::RunItem");
        }
    }

    if (FAILED(hr))
    {
        FailedUpdate(hr, &pUpdateItem->m_cookie);
    }
}

int CThrottler::GetFreeQueueSlot()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    int index = -1;
    
    for (int i = 0; i < ARRAYSIZE(m_updateQueue); i++)
    {
        if (NULL == m_updateQueue[i])
        {   
            index = i;
            break;
        }
    }

    return index;
}

void CThrottler::FillTheQueue()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    if ((FALSE == m_fFillingTheQueue) &&        // avoid re-entrancy
        (FALSE == m_fAbortingAll) &&            // avoid re-entrancy
        (FALSE == m_fAutoCacheSizePending))     // we have a dialog up for the user
    {
        m_fFillingTheQueue = TRUE;

        CUpdateItem *pNextItem = m_pItemsHead;
        CUpdateItem *pItem;

        while (NULL != pNextItem)
        {
            pItem = pNextItem;

            //  Move ahead since this item may not be here 
            //  if we run it and it fails

            pNextItem = pNextItem->m_pNext;

            if (!(pItem->m_dwRunState & (RS_COMPLETED | RS_UPDATING)))
            {
                int freeSlot = GetFreeQueueSlot();

                if ((freeSlot >= 0) &&
                    (m_fUserIsIdle || (!(pItem->m_dwRunState & RS_SUSPENDONIDLE))))
                {
                    RunItem(freeSlot, pItem);
                }
                else 
                {
                    //  If we didn't run it then let's make sure the UI reflects the current
                    //  state properly

                    HRESULT hrStatus;
                    WCHAR wszMsg[256];

                    if ((pItem->m_dwRunState & RS_SUSPENDONIDLE) && (!m_fUserIsIdle))
                    {
                        MLLoadStringW(IDS_UPDATE_PAUSED, wszMsg, ARRAYSIZE(wszMsg));
                        hrStatus = WC_INTERNAL_S_PAUSED;
                    }
                    else
                    {
                        StrCpyW(wszMsg, L" ");  //  Don't say it, I know what you're thinking...
                                                //  ...if we don't do this, then the status
                                                //  text won't change.
                        hrStatus = WC_INTERNAL_S_PENDING;
                    }

                    NotifyHandlers(NH_UPDATEPROGRESS, &pItem->m_cookie, -1,
                                   -1, -1, hrStatus, wszMsg);
                }
            }
        }

        m_fFillingTheQueue = FALSE;
    }
}

HRESULT CThrottler::AddItemToListTail(CUpdateItem *pAddItem)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = S_OK;
    
    ASSERT(NULL != pAddItem);

    if (NULL != pAddItem)
    {
        if (NULL == m_pItemsTail)
        {
            //  Nothing in the list
            ASSERT(NULL == m_pItemsHead);
            m_pItemsHead = pAddItem;
        }
        else
        {
            m_pItemsTail->m_pNext = pAddItem;
        }
        m_pItemsTail = pAddItem;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    ASSERT(NULL != m_pItemsHead);
    ASSERT(NULL != m_pItemsTail);
    ASSERT(NULL == m_pItemsTail->m_pNext);

    ASSERT(SUCCEEDED(hr));

    return hr;
}

HRESULT CThrottler::RemoveItemFromList(CUpdateItem *pRemoveItem, BOOL fDelete)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = E_UNEXPECTED;
    CUpdateItem *pItem = m_pItemsHead;
    CUpdateItem *pPrevItem = NULL;

    ASSERT(NULL != pRemoveItem);
    ASSERT(NULL != m_pItemsHead);
    ASSERT(NULL != m_pItemsTail);

    if (NULL != pRemoveItem)
    {
        int queueIndex = GetCookieIndexInQueue(&pRemoveItem->m_cookie);

        if (queueIndex >= 0)
        {
            m_updateQueue[queueIndex] = NULL;
        }
        
        while (pItem)
        {
            if (pItem == pRemoveItem)
            {
                if (NULL != pPrevItem)
                {
                    //  Removing beyond the head
                    pPrevItem->m_pNext = pItem->m_pNext;
                }
                else
                {
                    //  Removing the head
                    m_pItemsHead = pItem->m_pNext;
                }

                //  Now fix the tail
                if (m_pItemsTail == pRemoveItem)
                {
                    m_pItemsTail = pPrevItem;
                }
                hr = S_OK;
                break;
            }
            pPrevItem = pItem;
            pItem = pItem->m_pNext;
        }
        if (fDelete)
        {
            delete pRemoveItem;
        }
    }

    ASSERT(((NULL != m_pItemsHead) && (NULL != m_pItemsTail) && (NULL == m_pItemsTail->m_pNext)) ||
           ((NULL == m_pItemsHead) && (NULL == m_pItemsTail)));
    ASSERT(SUCCEEDED(hr));

    // If we have just removed our last item from the list, check to see if we forced
    //  global online mode or autodialed and fix up if so.
    if ((NULL == m_pItemsHead) && (m_fForcedGlobalOnline || m_fAutoDialed))
    {
        if (m_fForcedGlobalOnline)
        {
            SetGlobalOffline(TRUE);
            m_fForcedGlobalOnline = FALSE;
            m_fAutoDialed = FALSE;
        }
        else
        {
            ASSERT(m_fAutoDialed);
            InternetAutodialHangup(0);
            m_fAutoDialed=FALSE;
        }
    }

    return hr;
}

HRESULT CThrottler::CanScheduledItemRun(ISubscriptionItem *pSubsItem)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    //  If this item is running as a result of a schedule invocation, then
    //  we need to check time/range restrictions.
    HRESULT hr = S_OK;
    const TCHAR c_szNoScheduledUpdates[] = TEXT("NoScheduledUpdates");
    DWORD dwData;
    DWORD cbData = sizeof(dwData);

    //  First check if the user has disabled scheduled updates in inetcpl.
    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szRegKey, 
        c_szNoScheduledUpdates, NULL, &dwData, &cbData))
        && dwData)
    {
        hr = INET_E_SCHEDULED_UPDATES_DISABLED;
    }

    if (SUCCEEDED(hr))
    {
        //  Check if admin has disabled scheduled updates altogether
        if (SHRestricted2W(REST_NoScheduledUpdates, NULL, 0))
        {
            hr = INET_E_SCHEDULED_UPDATES_RESTRICTED;
        }
    }

    if (SUCCEEDED(hr))
    {
        //  Check if admin has set a minimum update interval.
        DWORD dwMinUpdateInterval = SHRestricted2W(REST_MinUpdateInterval, NULL, 0);

        if (dwMinUpdateInterval > 0)
        {
            DATE dt;

            if (SUCCEEDED(ReadDATE(pSubsItem, c_szPropCompletionTime, &dt)))
            {
                SYSTEMTIME st;
                GetLocalTime(&st);

                CFileTime lastUpdate;
                CFileTime currentTime;

                VariantTimeToFileTime(dt, lastUpdate);
                SystemTimeToFileTime(&st, &currentTime);

                if ((currentTime - lastUpdate) < 
                    ((__int64)dwMinUpdateInterval * ONE_MINUTE_IN_FILETIME))
                {
                    hr = INET_E_SCHEDULED_UPDATE_INTERVAL;
                }
            }
        }
    }
    
    if (SUCCEEDED(hr))
    {
        DWORD dwBegin = SHRestricted2W(REST_UpdateExcludeBegin, NULL, 0);
        DWORD dwEnd = SHRestricted2W(REST_UpdateExcludeEnd, NULL, 0);

        //  Check if admin has specified a blackout time for scheduled updates.
        if (dwBegin && dwEnd)
        {
            SYSTEMTIME st;
            CFileTime ftNow,
                      ftBegin,
                      ftEnd;
            
            GetLocalTime(&st);

            SystemTimeToFileTime(&st, &ftNow);
            
            st.wSecond = 0;
            st.wMilliseconds = 0;
            
            st.wHour   = (WORD)dwBegin / 60;
            st.wMinute = (WORD)dwBegin % 60;
            SystemTimeToFileTime(&st, &ftBegin);
            
            st.wHour   = (WORD)dwEnd / 60;
            st.wMinute = (WORD)dwEnd % 60;
            SystemTimeToFileTime(&st, &ftEnd);

            //  if these values are normalized (ie. begin comes before end)
            if (ftBegin <= ftEnd)
            {
                //  Then just check to see if time now is between begin 
                //  and end.  (ie.  ftEnd >= ftNow >= ftBegin)
                if ((ftNow >= ftBegin) && (ftNow <= ftEnd))
                {
                    hr = INET_E_SCHEDULED_EXCLUDE_RANGE;
                }
            }
            else
            {
                //  Begin and end are not normalized.  So we check to see if
                //  now is before end or now is after begin.

                //  For example:
                //  Assuming begin is 6pm and end is 6am.  If now is 5 pm, the
                //  item should run.  If now is 10pm or 4am, it should not run.

                if ((ftNow <= ftEnd) || (ftNow >= ftBegin))
                {
                    hr = INET_E_SCHEDULED_EXCLUDE_RANGE;
                }
            }

        }
    }

    return hr;
}

HRESULT CThrottler::RunCookies(DWORD dwNumCookies, 
                               const SUBSCRIPTIONCOOKIE *pSubscriptionCookies, 
                               DWORD dwSyncFlags)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = S_OK;
    DWORD i;
    CUpdateItem *pUpdateItem;
    DWORD nValidCookies;

    ASSERT(NULL != m_pSyncMgrs);

    ASSERT(0 != dwNumCookies);
    ASSERT(NULL != pSubscriptionCookies);

    if ((0 == dwNumCookies) || 
        (NULL == pSubscriptionCookies))
    {
        return E_INVALIDARG;
    }

    // Check for global offline mode.
    if (!m_fForcedGlobalOnline && IsGlobalOffline())
    {
        // Force global online mode so that our update will succeed.
        DBG("CThrottler::RunCookies; forcing global online mode");
        SetGlobalOffline(FALSE);
        m_fForcedGlobalOnline = TRUE;
    }

    if (IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_MANUAL) ||
        IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_INVOKE))
    {
        if (!InternetGetConnectedStateEx(NULL, NULL, 0, 0))
        {
            if (!InternetAutodial(INTERNET_AUTODIAL_FORCE_ONLINE, 0))
            {
                // REARCHITECT clean up this extra addref/release/return stuff
                AddRef();

                DBG("CThrottler::RunCookies autodial failed");

                // Uh-oh. The user cancelled the dial after starting a
                //  manual update. Clean up and return.
                if (m_fForcedGlobalOnline)
                {
                    SetGlobalOffline(TRUE);
                    m_fForcedGlobalOnline=FALSE;
                }

                WCHAR wszMsg[256];

                MLLoadStringW(IDS_STATUS_ABORTED, wszMsg, ARRAYSIZE(wszMsg));
        
                for (i=0; i<dwNumCookies; i++)
                {
                    ReportThrottlerError(&pSubscriptionCookies[i], E_ABORT, wszMsg);
                    UpdateEnd(&pSubscriptionCookies[i], 0, E_ABORT, wszMsg);
                }

                Release();

                return S_FALSE; // E_ABORT;
            }

            // Autodial succeeded
            m_fAutoDialed = TRUE;
        }
    }

    SUBSCRIPTIONCOOKIE *pCookies = new SUBSCRIPTIONCOOKIE[dwNumCookies];

    if (NULL != pCookies)
    {
        SUBSCRIPTIONCOOKIE *pCookie = pCookies;

        memcpy(pCookies, pSubscriptionCookies, dwNumCookies * sizeof(SUBSCRIPTIONCOOKIE));
    
        //  ************************************************************************
        //  Don't add any return statements in the loop!  We keep a ref on ourselves
        //  during this call in case we are Released by all of the sync handlers.
        //  ************************************************************************

        AddRef();

        nValidCookies = 0;

        for (i = 0; i < dwNumCookies; i++, pCookie++)
        {
            if (*pCookie == GUID_NULL)
            {
                continue;
            }

            nValidCookies++;

            if (IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_IDLE))
            {
                m_fUserIsIdle = TRUE;
            }

            if (SUCCEEDED(FindCookie(pCookie, &pUpdateItem)))
            {
                if (IsIgnoreIdleSyncEvent(dwSyncFlags))
                {
                    DUMPITEM("Removing RS_SUSPENDONIDLE in CThrottler::RunCookies", pCookie);
                    
                    //  Items updated manually are no longer subject to idle detection.
                    pUpdateItem->m_dwRunState &= ~RS_SUSPENDONIDLE;
                }

                if (IsSyncEventFlag(dwSyncFlags, SYNCMGRFLAG_MAYBOTHERUSER))
                {
                    // We may now bother user for this item
                    pUpdateItem->m_dwRunState |= RS_MAYBOTHERUSER;
                }
            }
            else
            {
                ISubscriptionItem *psi;
                HRESULT hrItem = SubscriptionItemFromCookie(FALSE, pCookie, &psi);

                if (SUCCEEDED(hrItem))
                {
                    SUBSCRIPTIONITEMINFO sii;

                    sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

                    hrItem = psi->GetSubscriptionItemInfo(&sii);

                    if (SUCCEEDED(hrItem))
                    {
                        DWORD dwRunState = RS_READY;

                        if (IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_IDLE))
                        {
                            dwRunState |= RS_SUSPENDONIDLE;
                        }

                        if (IsSyncEventFlag(dwSyncFlags, SYNCMGRFLAG_MAYBOTHERUSER))
                        {
                            dwRunState |= RS_MAYBOTHERUSER;
                        }

                        if (IsScheduleSyncEvent(dwSyncFlags))
                        {
                            hrItem = CanScheduledItemRun(psi);
                        }

                        if (SUCCEEDED(hrItem))
                        {
                        
                            pUpdateItem = new CUpdateItem(*pCookie, dwRunState);

                            if (NULL != pUpdateItem)
                            {
                                AddItemToListTail(pUpdateItem);
                            }
                            else
                            {
                                hrItem = E_OUTOFMEMORY;
                            }
                        }
                    }
                    psi->Release();
                }

                if (FAILED(hrItem))
                {
                    //  If we fail on an item, we will continue to try others, but
                    //  we need to indicate failure for this one.
                    FailedUpdate(hrItem, pCookie);
                    hr = S_FALSE;
                }
            }

            if (NULL == m_pSyncMgrs)
            {
                //  We have been unadvised!
                break;
            }
        }

        //  No point in trying to update if nobody wants to listen
        if (NULL != m_pSyncMgrs)
        {
            FillTheQueue();
        }

        Release();

        delete [] pCookies;

        if (0 == nValidCookies)
        {
            hr = E_FAIL;
        }

        //  ************************************************************************
        //  No member variable access after this since we could be dead!!!!
        //  ************************************************************************
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT CThrottler::FindCookie(
    const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
    CUpdateItem **ppUpdateItem)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = E_FAIL;
    CUpdateItem *pItem = m_pItemsHead;
    
    ASSERT(NULL != ppUpdateItem);

    *ppUpdateItem = NULL;

    while (pItem)
    {
        if (pItem->m_cookie == *pSubscriptionCookie)
        {
            *ppUpdateItem = pItem;
            hr = S_OK;
            break;
        }
        pItem = pItem->m_pNext;
    }

    return hr;
}


//==============================================================================
//
// Auto cache size increase
//
//==============================================================================
// We can return:
//  E_PENDING - agent will pause and wait to be resumed or aborted
//  INET_S_AGENT_INCREASED_CACHE_SIZE - agent will try making stuff sticky again
//  anything else - agent will abort with INET_E_AGENT_CACHE_SIZE_EXCEEDED
HRESULT CThrottler::AutoCacheSizeRequest(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = S_OK;
    DWORD dwCacheSizeKB;
    int queueIndex;

    DWORD dwValue, dwSize = sizeof(dwValue);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szKeyRestrict, c_szCache, NULL, &dwValue, &dwSize)
        && (dwValue != 0))
    {
        // Not allowed to change the cache size.
        hr = E_FAIL;
    }

    queueIndex = GetCookieIndexInQueue(pSubscriptionCookie);

    if (queueIndex >= 0)
    {
        if (!(m_updateQueue[queueIndex]->m_dwRunState & RS_MAYBOTHERUSER))
        {
            // We're not allowed to bother user. Fail.
            hr = E_FAIL;
        }
    }
    else
    {
        DBG_WARN("CThrottler::AutoCacheSizeRequest couldn't find cookie in run queue.");
        hr = E_FAIL;        // Couldn't find this cookie in our queue?!
    }

    if (SUCCEEDED(hr) && m_fAutoCacheSizePending)
    {
        // We're already asking the user to increase the cache size.
        hr = E_PENDING;
    }

    if (SUCCEEDED(hr))
    {
        // Let's try to increase the cache.
        if (SUCCEEDED(IncreaseCacheSize(&dwCacheSizeKB)))
        {
            hr = INET_S_AGENT_INCREASED_CACHE_SIZE;
        }
        else
        {
            // We need to ask the user.
            if ((++ m_nAutoCacheSizeTimesAsked) > MAX_AUTOCACHESIZE_ASK)
            {
                hr = E_ABORT;       // Already bothered them enough.
            }
            else
            {
                // Let's ask the user. We need unwind our call stack now, however.
                // Tell the throttler to ask the user
                if (SUCCEEDED(CreateThrottlerWnd()))
                {
                    PostMessage(m_hwndThrottler, WM_THROTTLER_AUTOCACHESIZE_ASK, 0, dwCacheSizeKB);
                    m_fAutoCacheSizePending = TRUE;
                    hr = E_PENDING;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
    } // !m_fAutoCacheSizePending

    if (hr == E_PENDING)
    {
        // Mark this agent as paused.
        int queueIndex = GetCookieIndexInQueue(pSubscriptionCookie);

        ASSERT(queueIndex >= 0);

        if (queueIndex >= 0)
        {
            m_updateQueue[queueIndex]->m_dwRunState &= ~RS_UPDATING;
            m_updateQueue[queueIndex]->m_dwRunState |= RS_SUSPENDED;
            m_updateQueue[queueIndex] = NULL;
        }
    }

    return hr;
}

HRESULT CThrottler::AutoCacheSizeAskUser(DWORD dwCacheSizeKB)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    ASSERT(m_fAutoCacheSizePending);
    ASSERT(dwCacheSizeKB);
    ASSERT(m_hwndParent);

    HRESULT hr = E_FAIL;

    // Keep-Alive
    AddRef();

    if (IDOK == ShellMessageBox(MLGetHinst(),
                    m_hwndParent,
                    MAKEINTRESOURCE(IDS_CACHELIMIT_MESSAGE), 
                    MAKEINTRESOURCE(IDS_CACHELIMIT_TITLE),
                    MB_OKCANCEL | MB_SETFOREGROUND | MB_ICONQUESTION))
    {
        // Come up with a good cache size increase and resume agents
        m_dwAutoCacheSizeIncrease = dwCacheSizeKB / 4;

        if (m_dwAutoCacheSizeIncrease < MIN_CACHE_INCREASE)
        {
            m_dwAutoCacheSizeIncrease = MIN_CACHE_INCREASE;
        }

        m_dwMaxAutoCacheSize = dwCacheSizeKB + (2 * m_dwAutoCacheSizeIncrease);

        if (SUCCEEDED(IncreaseCacheSize(NULL)))
        {
            hr = S_OK;
        }
    }
    else
    {
        // Abort agents
    }

    m_fAutoCacheSizePending = FALSE;

    if (FAILED(hr))
    {
        // User said no (or we couldn't increase the cache).
        ActuallyAbortAll();
    }
    else
    {
        FillTheQueue();
    }

    Release();

    return hr;
}

// Auto-increase cache size if user previously ok'd it
HRESULT CThrottler::IncreaseCacheSize(DWORD *pdwNewCacheSizeKB)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    LPINTERNET_CACHE_CONFIG_INFOA pCCI=NULL;
    DWORD  dwSizeInKB=0, dwPercent;
    DWORD  dwNewSizeInKB=0;
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(GetCacheInfo(&pCCI, &dwSizeInKB, &dwPercent)))
    {
        if (dwSizeInKB < m_dwMaxAutoCacheSize)
        {
            ASSERT(m_dwAutoCacheSizeIncrease > 1023);   // At least 1 meg
            if (m_dwAutoCacheSizeIncrease)
            {
                // We still have room to increase cache without asking the user. Use it.
                dwNewSizeInKB = dwSizeInKB + m_dwAutoCacheSizeIncrease;

                if (dwNewSizeInKB > m_dwMaxAutoCacheSize)
                {
                    dwNewSizeInKB = m_dwMaxAutoCacheSize;
                }

                if (SUCCEEDED(SetCacheSize(pCCI, dwNewSizeInKB)))
                {
                    hr = S_OK;
                    dwSizeInKB = dwNewSizeInKB;
                    DBG("Throttler just increased TIF cache size");
                }
            }
        }

        MemFree(pCCI);
    }

    if (pdwNewCacheSizeKB)
    {
        *pdwNewCacheSizeKB = dwSizeInKB;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\trayagnt.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       trayagnt.cpp
//
//  Contents:   tray notification agent
//
//  Classes:
//
//  Functions:
//
//  History:    01-14-1997  rayen (Raymond Endres)  Created
//
//----------------------------------------------------------------------------
#include "private.h"
#include "updateui.h"
#include "chanmgr.h"
#include "chanmgrp.h"
#include "shguidp.h"
#include "offline.h"
#include "offl_cpp.h"

//xnotfmgr - can probably nuke most of this file

#undef TF_THISMODULE
#define TF_THISMODULE   TF_TRAYAGENT

extern const TCHAR c_szTrayUI[] = TEXT("BogusClassName");
const TCHAR c_szTrayMenu[] = TEXT("TrayMenu");

#if WANT_REGISTRY_LOG
const TCHAR c_szLog[] = TEXT("\\Log");
const TCHAR c_szLogMaxIndex[] = TEXT("MaxIndex");
#endif

typedef struct _tagCHANNELIMAGEDATA
{
    CHAR             szPath[MAX_PATH];
    CHAR             szHash[MAX_PATH];
    int              iIndex;
    UINT             uFlags;
    int              iImageIndex;
} CHANNELIMAGEDATA, *PCHANNELIMAGEDATA;


CTrayUI *g_pTrayUI;     // TrayUI object (not COM), separate from TrayAgent for now

DWORD WINAPI UpdateRequest(UINT idCmd, INotification *);
HRESULT UpdateNotifyReboot(void);
extern BOOL OnConnectedNotification(void);
extern BOOL OnDisconnectedNotification(void);
extern HRESULT LoadWithCookie(LPCTSTR, OOEBuf *, DWORD *, SUBSCRIPTIONCOOKIE *);
void DoReboot(void);
void IdleBegin(HWND hwnd);
void IdleEnd(void);

// Private message sent by Channel Screen Saver to
// periodically initiate relaunch of the screen saver.
#define WM_LOADSCREENSAVER  (WM_USER+550)
extern BOOL ReloadChannelScreenSaver(); // from SSSEPROX.CPP

#ifdef DEBUG
extern INotificationSink * g_pOfflineTraySink;
HRESULT RunTest()
{
//xnotfmgr

    INotificationMgr * pMgr = NULL;
    INotification   * pNotf = NULL;
    HRESULT             hr;

    hr = GetNotificationMgr(&pMgr);
    if (FAILED(hr) || !pMgr)
        return E_FAIL;

    hr = pMgr->CreateNotification(
            NOTIFICATIONTYPE_AGENT_START,
            0, NULL, &pNotf, 0);

    if (SUCCEEDED(hr) && !pNotf)
        hr = E_FAIL;

    if (SUCCEEDED(hr))
        hr = pMgr->DeliverNotification(pNotf, CLSID_WebCrawlerAgent, 
                DM_DELIVER_DEFAULT_PROCESS |
                DM_THROTTLE_MODE |
                DM_NEED_COMPLETIONREPORT
                ,g_pOfflineTraySink,0,0);

    SAFERELEASE(pNotf);
    SAFERELEASE(pMgr);
    return hr;
}
#endif

HRESULT CancelAllDownloads()
{
//xnotfmgr
    HRESULT hr = S_OK;
    INotificationMgr    * pMgr = NULL;
    IEnumNotification   * pRunEnum = NULL;
    IEnumNotification   * pThrEnum = NULL;

    hr = GetNotificationMgr(&pMgr);
    if (FAILED(hr))  {
        return hr;
    }

    hr = pMgr->GetEnumNotification(EF_NOTIFICATION_INPROGRESS, &pRunEnum);
    if (SUCCEEDED(hr))  {
        hr = pMgr->GetEnumNotification(EF_NOTIFICATION_THROTTLED, &pThrEnum);
    }

    if (FAILED(hr))  {
        SAFERELEASE(pRunEnum);
        SAFERELEASE(pThrEnum);
        SAFERELEASE(pMgr);
        return hr;
    }

    INotification *pNotCancel = NULL;
    hr = pMgr->CreateNotification(NOTIFICATIONTYPE_TASKS_ABORT,
                               (NOTIFICATIONFLAGS)0,
                               NULL,
                               &pNotCancel,
                               0);

    if (FAILED(hr) || !pNotCancel){
        SAFERELEASE(pMgr);
        SAFERELEASE(pRunEnum);
        SAFERELEASE(pThrEnum);
        return E_FAIL;
    }

    NOTIFICATIONITEM    item = {0};
    ULONG               cItems = 0;
    item.cbSize = sizeof(NOTIFICATIONITEM);

    hr = pThrEnum->Next(1, &item, &cItems);
    while ( SUCCEEDED(hr) && cItems )
    {
        CLSID   cookie;
        BOOL    bAbort = FALSE;
        if (item.NotificationType == NOTIFICATIONTYPE_AGENT_START 
            //  REVIEW big hack.
            && item.clsidDest != CLSID_ConnectionAgent)
        {
            bAbort = TRUE;
            cookie = item.NotificationCookie;
        }
        SAFERELEASE(item.pNotification);
        item.cbSize = sizeof(NOTIFICATIONITEM);
        cItems = 0;
        hr = pThrEnum->Next(1, &item, &cItems);

        //  REVIEW. If we put the following statement before
        //  the Next statement, we can delete the package and then break the
        //  enumerator.
        if (bAbort) {
            HRESULT hr1 = pMgr->DeliverReport(pNotCancel, &cookie, 0);
            ASSERT(SUCCEEDED(hr1));
        }
    }

    cItems = 0;
    item.cbSize = sizeof(NOTIFICATIONITEM);

    hr = pRunEnum->Next(1, &item, &cItems);
    while ( SUCCEEDED(hr) && cItems )
    {
        CLSID   cookie;
        BOOL    bAbort = FALSE;
        if (item.NotificationType == NOTIFICATIONTYPE_AGENT_START 
            //  REVIEW big hack.
            && item.clsidDest != CLSID_ConnectionAgent)
        {
            bAbort = TRUE;
            cookie = item.NotificationCookie;
        }
        SAFERELEASE(item.pNotification);
        item.cbSize = sizeof(NOTIFICATIONITEM);
        cItems = 0;
        hr = pRunEnum->Next(1, &item, &cItems);

        //  REVIEW. We don't seem to have the same problem. Just try to be
        //  cautious.
        if (bAbort) {
            HRESULT hr1 = pMgr->DeliverReport(pNotCancel, &cookie, 0);
            ASSERT(SUCCEEDED(hr1));
        }
    }

    SAFERELEASE(pMgr);
    SAFERELEASE(pNotCancel);
    SAFERELEASE(pRunEnum);
    SAFERELEASE(pThrEnum);
    return hr;
}

//
// Get the path of channel containing the given URL.
//

HRESULT GetChannelPath(LPCSTR pszURL, LPTSTR pszPath, int cch,
                       IChannelMgrPriv** ppIChannelMgrPriv)
{
    ASSERT(pszURL);
    ASSERT(pszPath || 0 == cch);
    ASSERT(ppIChannelMgrPriv);

    HRESULT hr;
    BOOL    bCoinit = FALSE;

    hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_IChannelMgrPriv, (void**)ppIChannelMgrPriv);

    if ((hr == CO_E_NOTINITIALIZED || hr == REGDB_E_IIDNOTREG) &&
        SUCCEEDED(CoInitialize(NULL)))
    {
        bCoinit = TRUE;
        hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_IChannelMgrPriv, (void**)ppIChannelMgrPriv);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(*ppIChannelMgrPriv);

        IChannelMgr* pIChannelMgr;

        hr = (*ppIChannelMgrPriv)->QueryInterface(IID_IChannelMgr,
                                                (void**)&pIChannelMgr);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIChannelMgr);

            WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
            MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), pszURL);

            IEnumChannels* pIEnumChannels;

            hr = pIChannelMgr->EnumChannels(CHANENUM_ALLFOLDERS | CHANENUM_PATH,
                                            wszURL, &pIEnumChannels);

            if (SUCCEEDED(hr))
            {
                ASSERT(pIEnumChannels);

                CHANNELENUMINFO ci;

                if (S_OK == pIEnumChannels->Next(1, &ci, NULL))
                {
                    MyOleStrToStrN(pszPath, cch, ci.pszPath);
                    
                    CoTaskMemFree(ci.pszPath);
                }
                else
                {
                    hr = E_FAIL;
                }

                pIEnumChannels->Release();
            }

            pIChannelMgr->Release();
        }

    }

    if (bCoinit)
        CoUninitialize();

    ASSERT((SUCCEEDED(hr) && *ppIChannelMgrPriv) || FAILED(hr));

    return hr;
}

//
// Update channel
//

HRESULT UpdateChannel(IChannelMgrPriv* pIChannelMgrPriv, LPCSTR pszURL)
{
    ASSERT(pIChannelMgrPriv);
    ASSERT(pszURL);

    HRESULT hr;

    IChannelMgr* pIChannelMgr;

    hr = pIChannelMgrPriv->QueryInterface(IID_IChannelMgr,
                                          (void**)&pIChannelMgr);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIChannelMgr);

        WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
        MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), pszURL);

        IEnumChannels* pIEnumChannels;

        hr = pIChannelMgr->EnumChannels(CHANENUM_ALLFOLDERS | CHANENUM_PATH,
                                        wszURL, &pIEnumChannels);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIEnumChannels);

            CHANNELENUMINFO ci;

            //
            // Update all instances of this channel.
            //

            while (S_OK == pIEnumChannels->Next(1, &ci, NULL))
            {
                char szPath[MAX_PATH];
                MyOleStrToStrN(szPath, ARRAYSIZE(szPath), ci.pszPath);

                // Removed to give UPDATEIMAGE (gleams) a better chance.
                //SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, (void*)szPath,
                //               NULL);

                CoTaskMemFree(ci.pszPath);
            }    

            pIEnumChannels->Release();
        }

        pIChannelMgr->Release();
    }    

    return hr;
}

//
// Gather data that will be used to update a channel image.
//

HRESULT PreUpdateChannelImage(IChannelMgrPriv* pIChannelMgrPriv,
                              CHANNELIMAGEDATA* pcid)
{
    ASSERT(pcid); 
    ASSERT(pIChannelMgrPriv);

    return (pIChannelMgrPriv)->PreUpdateChannelImage(pcid->szPath,
                                                     pcid->szHash,
                                                     &pcid->iIndex,
                                                     &pcid->uFlags,
                                                     &pcid->iImageIndex);
}

//
// Update a channel image.
//

HRESULT UpdateChannelImage(IChannelMgrPriv* pIChannelMgrPriv,
                          CHANNELIMAGEDATA* pcid)
{
    ASSERT(pcid);
    ASSERT(pIChannelMgrPriv);

    WCHAR wszHash[MAX_PATH];
    MyStrToOleStrN(wszHash, ARRAYSIZE(wszHash), pcid->szHash);

    return pIChannelMgrPriv->UpdateChannelImage(wszHash, pcid->iIndex,
                                                pcid->uFlags,
                                                pcid->iImageIndex);
}

//----------------------------------------------------------------------------
// Tray Agent object
//----------------------------------------------------------------------------

CTrayAgent::CTrayAgent()
{
    DBG("Creating CTrayAgent object");

    //
    // Maintain global count of objects in webcheck.dll
    //
    DllAddRef();

    //
    // Initialize object member variables
    //
    m_cRef = 1;
#ifdef DEBUG
    m_AptThreadId = GetCurrentThreadId();
#endif
}

CTrayAgent::~CTrayAgent()
{
    //
    // Maintain global count of objects
    //
    DllRelease();

    //
    // Release/delete any resources
    //
    DBG("Destroyed CTrayAgent object");
}

//
// IUnknown members
//

STDMETHODIMP_(ULONG) CTrayAgent::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CTrayAgent::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CTrayAgent::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv = NULL;
//xnotfmgr

    //
    // Currently just support INotificationSink
    //
    if ((IID_IUnknown == riid) ||
        (IID_INotificationSink == riid))
    {
        *ppv = (INotificationSink *)this;
    }

    //
    // Addref through the interface
    //
    if( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


//
// INotificationSink member(s)
//
STDMETHODIMP CTrayAgent::OnNotification(
    LPNOTIFICATION         pNotification,
    LPNOTIFICATIONREPORT   pNotificationReport,
    DWORD                  dwReserved)
{
//xnotfmgr
    DBG("CTrayAgent::OnNotification called");
    ASSERT(pNotification);
    ASSERT(GetCurrentThreadId() == m_AptThreadId);

    //
    // Extract Notification Type.
    //
    HRESULT          hr;
    NOTIFICATIONTYPE notfType;
    hr = pNotification->GetNotificationInfo(&notfType, NULL, NULL, NULL, 0);
    ASSERT(SUCCEEDED(hr));

    if (notfType == NOTIFICATIONTYPE_CONFIG_CHANGED)
    {
        DBG("CTrayAgent::OnNotification - config changed");
        //
        // The global properties have changed and we must respond.
        //
        ASSERT(g_pTrayUI);  // Fault here means NotificationMgr calling me in wrong process
        if (g_pTrayUI)
            g_pTrayUI->ConfigChanged();
        return S_OK;
    }
    else if (notfType == NOTIFICATIONTYPE_BEGIN_REPORT) {
        DBG("CTrayAgent::OnNotification - begin report");
        ASSERT(g_pTrayUI);
        if (g_pTrayUI)
            g_pTrayUI->OnBeginReport(pNotification);
        return S_OK;
    }
    else if (notfType == NOTIFICATIONTYPE_AGENT_START)
    {
        DBG("CTrayAgent::OnNotification - agent start (update now)");
        //
        // The user chose Update Subscriptions Now.
        // Is this the best notification to use for this?
        // Are there any properties we care about?  Like a guid to trigger
        // a specific one?
        //
        ASSERT(g_pTrayUI);  // Fault here means NotificationMgr calling me in wrong process
        if (g_pTrayUI)  
            g_pTrayUI->UpdateNow(pNotification);
        return S_OK;
    }
    else if (notfType == NOTIFICATIONTYPE_END_REPORT)
    {
        DBG("CTrayAgent::OnNotification - end report");
        ASSERT(g_pTrayUI);
        if (g_pTrayUI)
            g_pTrayUI->OnEndReport(pNotification);

        #if WANT_REGISTRY_LOG
        //
        // Log all the End Reports
        //
        BSTR    bstrStatus = NULL;
        CLSID   cookie;

        if (g_pTrayUI &&
            SUCCEEDED(ReadBSTR(pNotification,NULL, c_szPropStatusString, &bstrStatus))
            && SUCCEEDED(ReadGUID(pNotification, NULL, c_szStartCookie, &cookie)))
        {
            g_pTrayUI->AddToLog(bstrStatus, CLSID_NULL, cookie);
        } else  {
            DBG_WARN("CTrayAgent::OnNotification/End Report - Not status str");
        }
        SAFEFREEBSTR(bstrStatus);
        #endif

        //
        // Read the status code from the end report.
        //
        SCODE scEndStatus;
        hr = ReadSCODE(pNotification, NULL, c_szPropStatusCode, &scEndStatus);
        if (SUCCEEDED(hr) && SUCCEEDED(scEndStatus))
        {
            //
            // Special feature for desktop HTML:
            // If we receive an end report with "DesktopComponent=1" in it,
            // let the desktop know that it needs to refresh itself.  We always
            // do this instead of only on "changes detected" because desktop
            // component authors don't want to change their CDFs.
            //
            DWORD dwRet;
            HRESULT hr2 = ReadDWORD(pNotification, NULL, c_szPropDesktopComponent, &dwRet);
            if (SUCCEEDED(hr2) && (dwRet == 1))
            {
                IActiveDesktop *pAD = NULL;
                hr2 = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC_SERVER, IID_IActiveDesktop, (void**)&pAD);
                DBGASSERT(SUCCEEDED(hr2), "Unable to create ActiveDesktop in order to refresh desktop component");
                if (SUCCEEDED(hr2))
                {
                    ASSERT(pAD);
                    pAD->ApplyChanges(AD_APPLY_FORCE | AD_APPLY_REFRESH | AD_APPLY_BUFFERED_REFRESH);
                    pAD->Release();
                }
            }
        }
        
        //
        // If the delivery agent succeeded and changes were detected
        // notify the appropriate code.
        //
        if (SUCCEEDED(hr) && SUCCEEDED(scEndStatus) && (S_FALSE != scEndStatus))
        {
            //
            // Gleam the Internet Shortcut for the URL if requested.  (EnableShortcutGleam=1)
            // NOTE: End Reports without changes (S_FALSE) were filtered above.
            //
            DWORD dwRet;
            hr = ReadDWORD(pNotification, NULL, c_szPropEnableShortcutGleam, &dwRet);
            if (SUCCEEDED(hr) && dwRet)
            {
                LPSTR strURL = NULL;
                hr = ReadAnsiSTR(pNotification, NULL, c_szPropURL, &strURL);
                if (SUCCEEDED(hr))
                {
                    PROPVARIANT propvar;
                    PropVariantInit(&propvar);
                    hr = IntSiteHelper(strURL, &c_rgPropRead[PROP_FLAGS], &propvar, 1, FALSE);
                    if (SUCCEEDED(hr) && (VT_UI4 == propvar.vt))
                    {
                        // Set our flag without disturbing the others.
                        propvar.ulVal |= PIDISF_RECENTLYCHANGED;  
                    }
                    else
                    {
                        // Be sure to clear the variant if it wasn't a DWORD.
                        PropVariantClear(&propvar);
                        propvar.vt = VT_UI4;
                        propvar.ulVal = PIDISF_RECENTLYCHANGED;  
                    }

                    //
                    // Update channels.
                    //

                    hr = ReadDWORD(pNotification, NULL, c_szPropChannel, &dwRet);
                    BOOL bChannel = SUCCEEDED(hr) && dwRet;

                    CHANNELIMAGEDATA   cid = {0};
                    IChannelMgrPriv*   pIChannelMgrPriv = NULL;
                    HRESULT            hr2 = E_FAIL;

                    if (bChannel)
                    {
                        hr2 = GetChannelPath(strURL, cid.szPath,
                                             ARRAYSIZE(cid.szPath),
                                             &pIChannelMgrPriv);
                        if (SUCCEEDED(hr2))
                            hr2 = PreUpdateChannelImage(pIChannelMgrPriv, &cid);
                    }

                    hr = IntSiteHelper(strURL, &c_rgPropRead[PROP_FLAGS], &propvar, 1, TRUE);
                    DBGASSERT(SUCCEEDED(hr), "CTrayAgent::OnNotification - failed to set gleam.");

                    if (bChannel && SUCCEEDED(hr2))
                    {
                        ASSERT(pIChannelMgrPriv);

                        pIChannelMgrPriv->InvalidateCdfCache();
                        UpdateChannelImage(pIChannelMgrPriv, &cid);
                        UpdateChannel(pIChannelMgrPriv, strURL);

                        pIChannelMgrPriv->Release();
                    }
                }
                MemFree(strURL); // Free the string allocated by ReadAnsiSTR().
            }

            //
            // Send Email to notify the user if requested (EmailNotification=1)
            // NOTE: End Reports without changes (S_FALSE) were filtered above.
            //
            hr = ReadDWORD(pNotification, NULL, c_szPropEmailNotf, &dwRet);
            if (SUCCEEDED(hr) && dwRet)
            {
                hr = SendEmailFromNotification(pNotification);
            }
        }
        else
        {
            DBG_WARN("CTrayAgent::OnNotification - unchanged or failed end report");
        }

        return S_OK;
    }
    else if (notfType == NOTIFICATIONTYPE_DISCONNECT_FROM_INTERNET)
    {
        OnDisconnectedNotification();
        return S_OK;
    }
    else if (notfType == NOTIFICATIONTYPE_CONNECT_TO_INTERNET )
    {
        OnConnectedNotification();
        return S_OK;
    }
    else
    {
        //
        // TrayAgent doesn't handle this notification
        //
        DBG("CTrayAgent::OnNotification - unknown notification");
        return S_OK;
    }
}

//----------------------------------------------------------------------------
// TrayUI object (not COM)
//----------------------------------------------------------------------------

LRESULT CALLBACK TrayUI_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
//xnotfmgr
    //
    // We need this annoying global to make single and double left click work nicely.
    // (USER should have a WM_LBUTTONSINGLECLK message.)
    //
    static int iLeftClick = 0;
    static POINT pt;

    switch (uMsg)
    {
        case WM_USER:   // Subscription icon was clicked
            ASSERT(g_pTrayUI);
            switch (lParam)
            {
#ifdef DEBUG
                case WM_RBUTTONUP:
                    if (iLeftClick) {
                        ASSERT(1 == iLeftClick);
                        KillTimer(hwnd, TIMER_ID_DBL_CLICK);
                        iLeftClick = 0;
                    }
                    GetCursorPos(&pt);
                    g_pTrayUI->OpenContextMenu(&pt);
                    break;
                case WM_LBUTTONUP:
                    if (0 == iLeftClick)    // first left click up
                    {
                        UINT uRet;
                        GetCursorPos(&pt);
                        uRet = SetTimer(hwnd, TIMER_ID_DBL_CLICK, GetDoubleClickTime(), NULL);
                        ASSERT(uRet);
                        iLeftClick = 1;
                    }
                    else    // second left click up
                    {
                        ASSERT(1 == iLeftClick);
                        KillTimer(hwnd, TIMER_ID_DBL_CLICK);
                        iLeftClick = 0;
                        g_pTrayUI->OpenSubscriptionFolder();
                    }
                    break;
#endif
                 case UM_NEEDREBOOT:
                    // forward reboot required flag to update agent
                    if (FAILED(UpdateNotifyReboot()))
                        DoReboot();
                    break;
           }
            return 0;

        case WM_TIMER:
            switch(wParam) {
            case TIMER_ID_DBL_CLICK:
                // Timer went off so it was a single click
                KillTimer(hwnd, TIMER_ID_DBL_CLICK);
                if (1 == iLeftClick)    {
                    iLeftClick = 0;
                    g_pTrayUI->OpenContextMenu(&pt);
                }
                break;
            } /* switch */
            break;

        // Process the Infodelivery Admin Policies on WM_WININICHANGE lParam="Policy"
        case WM_WININICHANGE:
            if (lParam && !lstrcmpi((LPCTSTR)lParam, TEXT("policy")))
            {
                ProcessInfodeliveryPolicies();
            }
            // FEATURE: This should be done on Policy and another filter, not for
            // all changes.  (The other filter hasn't been defined yet.)

            //  TODO: handle this in the new architecture!
            //SetNotificationMgrRestrictions(NULL);
            break;

        case WM_LOADSCREENSAVER:
        {
            EVAL(ReloadChannelScreenSaver());
            break;
        }

        default:
            break;
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

CTrayUI::CTrayUI(void)
{
    // There should only be one of these objects
    ASSERT(!g_pTrayUI);
    // Assert that we're zero initialized.
    ASSERT(!m_hwnd);
#if WANT_REGISTRY_LOG
    ASSERT(!m_cLogs);
#endif
    ASSERT(!m_cUpdates);
    ASSERT(!m_fUpdatingTrayIcon);
#ifdef DEBUG
    m_AptThreadId = GetCurrentThreadId();
#endif
}

CTrayUI::~CTrayUI(void)
{
    //
    // Clean up any BSTRs we have around
    //

    //  ZDC Detect ongoing updates?
    ASSERT(m_cUpdates >= 0);
    
#if WANT_REGISTRY_LOG
    ASSERT(m_cLogs >= 0);
    ASSERT(m_cLogs < TRAYUI_CLOGS);
    for (int i = 0; i < m_cLogs; i++)
    {
        SAFEFREEBSTR(m_aLogEntry[i].bstrStatus);
    }
#endif
}

#if WANT_REGISTRY_LOG
#define TRAYLOGVERSION  716

STDMETHODIMP WriteSingleEntry(PLogEntry pLog, LPCTSTR szSubKey, int index)
{

    ASSERT(pLog && szSubKey);
    ASSERT(index >= 0);
    ASSERT(index < TRAYUI_CLOGS);

    //  Check to see if it's a valid log entry.
    if (!(pLog->bstrStatus))    {
        ASSERT(0);
        return E_INVALIDARG;
    }

    TCHAR       szLogName[16];
    wsprintf(szLogName, TEXT("%d"), index);
    
    CRegStream * prLog = new CRegStream(HKEY_CURRENT_USER, szSubKey, szLogName);
    if (prLog)  {
        CLSID       clsidAgent = pLog->clsidAgent;
        CLSID       cookie = pLog->startCookie;
        FILETIME    ftLog = pLog->ftLog;
        int         versionNumber = TRAYLOGVERSION;
        BSTR        bstrStatus = pLog->bstrStatus;
        DWORD       cbWritten;
        int         len;

        prLog->Write(&versionNumber, sizeof(int), &cbWritten);
        ASSERT(sizeof(int) == cbWritten);

        prLog->Write(&clsidAgent, sizeof(CLSID), &cbWritten);
        ASSERT(sizeof(CLSID) == cbWritten);

        prLog->Write(&cookie, sizeof(CLSID), &cbWritten);
        ASSERT(sizeof(CLSID) == cbWritten);

        prLog->Write(&ftLog, sizeof(FILETIME), &cbWritten);
        ASSERT(sizeof(FILETIME) == cbWritten);

        len = lstrlenW(bstrStatus);
        prLog->Write(&len, sizeof(int), &cbWritten);
        ASSERT(sizeof(int) == cbWritten);
        len *= sizeof(WCHAR);
        prLog->Write(bstrStatus, len, &cbWritten);
        ASSERT(len == (int)cbWritten);

        delete prLog;
        return S_OK;
    } else  {
        return E_FAIL;
    }
}

STDMETHODIMP ReadSingleEntry(PLogEntry pLog, LPCTSTR szSubKey, int index)
{
    ASSERT(pLog && szSubKey);
    ASSERT(index >= 0);
    ASSERT(index < TRAYUI_CLOGS);

    //  Check to see if it's a valid log entry.
    if (pLog->bstrStatus)    {
        ASSERT(0);
        SAFEFREEBSTR(pLog->bstrStatus);
    }

    TCHAR       szLogName[16];
    HRESULT     hrLog = E_INVALIDARG;
    wsprintf(szLogName, TEXT("%d"), index);
    
    CRegStream * prLog = new CRegStream(HKEY_CURRENT_USER, szSubKey, szLogName);
    if (prLog && (FALSE == prLog->m_fNewStream)) {
        CLSID       clsidAgent;
        CLSID       cookie;
        FILETIME    ftLog;
        int         versionNumber;
        BSTR        bstrStatus = NULL;
        DWORD       cbWritten;
        int         len;

        if (SUCCEEDED(prLog->Read(&versionNumber, sizeof(int), &cbWritten))
            && (sizeof(int) == cbWritten)
            && (TRAYLOGVERSION == versionNumber))
        {
            hrLog = ERROR_SUCCESS;
        }

        if (ERROR_SUCCESS == hrLog) {
            hrLog = E_INVALIDARG;
            if (SUCCEEDED(prLog->Read(&clsidAgent, sizeof(CLSID), &cbWritten))
                && (sizeof(CLSID) == cbWritten))
            {
                hrLog = ERROR_SUCCESS;
            }
        }

        if (ERROR_SUCCESS == hrLog) {
            hrLog = E_INVALIDARG;
            if (SUCCEEDED(prLog->Read(&cookie, sizeof(CLSID), &cbWritten))
                && (sizeof(CLSID) == cbWritten))
            {
                hrLog = ERROR_SUCCESS;
            }
        }

        if (ERROR_SUCCESS == hrLog) {
            hrLog = E_INVALIDARG;
            if (SUCCEEDED(prLog->Read(&ftLog, sizeof(FILETIME), &cbWritten))
                && (sizeof(FILETIME) == cbWritten))
            {
                hrLog = ERROR_SUCCESS;
            }
        }

        if (ERROR_SUCCESS == hrLog) {
            hrLog = E_INVALIDARG;
            if (SUCCEEDED(prLog->Read(&len, sizeof(int), &cbWritten))
                && (sizeof(int) == cbWritten)
                && (len < INTERNET_MAX_URL_LENGTH)
                && (bstrStatus = SysAllocStringLen(NULL, len))
                && SUCCEEDED(prLog->Read(bstrStatus, len * sizeof(WCHAR), &cbWritten))
                && (len * sizeof(WCHAR) == (int)cbWritten))
            {
                hrLog = ERROR_SUCCESS;
                bstrStatus[len] = 0;
            }
        }

        if (ERROR_SUCCESS == hrLog)  {
            pLog->clsidAgent = clsidAgent;
            pLog->startCookie = cookie;
            pLog->ftLog = ftLog;
            pLog->bstrStatus = bstrStatus;

#ifdef  DEBUG
            WCHAR wszCookie[GUIDSTR_MAX];
            TCHAR tmpTSTR[INTERNET_MAX_URL_LENGTH];

            StringFromGUID2(cookie, wszCookie, ARRAYSIZE(wszCookie));
            MyOleStrToStrN(tmpTSTR, ARRAYSIZE(wszCookie), wszCookie);
            TraceMsg(TF_THISMODULE, TEXT("TrayUI:LoadLog - %s(cookie)"), tmpTSTR);
            MyOleStrToStrN(tmpTSTR, ARRAYSIZE(tmpTSTR), bstrStatus);
            TraceMsg(TF_THISMODULE, TEXT("TrayUI:LoadLog - %s(status)"), tmpTSTR);

            SYSTEMTIME  stLog;
            FileTimeToSystemTime(&ftLog, &stLog);
            GetTimeFormat(LOCALE_SYSTEM_DEFAULT, LOCALE_NOUSEROVERRIDE,
                                &stLog, NULL, tmpTSTR, ARRAYSIZE(tmpTSTR));
            TraceMsg(TF_THISMODULE, TEXT("TrayUI:LoadLog - %s(time)"), tmpTSTR);
#endif
        } else  {
            SAFEFREEBSTR(bstrStatus);                        
        }
    }

    if (prLog)
        delete prLog;

    return hrLog;
}

STDMETHODIMP CTrayUI::SyncLogWithReg(int index, BOOL fWriteMax)
{
    if ((index < 0) || (index >= m_cLogs))
        return S_FALSE;

    TCHAR   szSubKey[1024];

    ASSERT((lstrlen(c_szRegKey) + lstrlen(c_szLog) + 2) < 1024);

#error Potential Buffer overflow:
    lstrcpy(szSubKey, c_szRegKey);
    lstrcat(szSubKey, c_szLog);

    HRESULT hr = E_FAIL;

    hr = WriteSingleEntry(&(m_aLogEntry[index]), szSubKey, index);
    if ((ERROR_SUCCESS == hr) && fWriteMax)    {
        CRegStream * prs = 
            new CRegStream(HKEY_CURRENT_USER, szSubKey, c_szLogMaxIndex);
        DWORD   cbWritten;

        if (prs)   {
            prs->Write(&m_cLogs, sizeof(int), &cbWritten);
            ASSERT(sizeof(int) == cbWritten);
            delete prs;
        } else  {
            hr = E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP CTrayUI::SaveLogToReg(void)
{
    HRESULT hr = S_OK;
    TCHAR   szSubKey[1024];

    ASSERT((lstrlen(c_szRegKey) + lstrlen(c_szLog) + 2) < 1024);

#error Potential Buffer overflow:    
    lstrcpy(szSubKey, c_szRegKey);
    lstrcat(szSubKey, c_szLog);

    int     index = 0;
    int     cIndex = 0;
    ULONG   cbWritten;
    int     maxIndex = m_cLogs;

    for (; index < maxIndex; index ++)  {
        if (SUCCEEDED(
                WriteSingleEntry(&(m_aLogEntry[index]), szSubKey, cIndex)
                     )
            )
        {
            cIndex ++;
        }
    } 

    CRegStream * prs = 
            new CRegStream(HKEY_CURRENT_USER, szSubKey, c_szLogMaxIndex);
    if (prs)   {
        prs->Write(&cIndex, sizeof(int), &cbWritten);
        ASSERT(sizeof(int) == cbWritten);
        delete prs;
    }

    return hr;
}

STDMETHODIMP CTrayUI::LoadLogFromReg(void)
{
    HRESULT hr = S_OK;
    TCHAR   szSubKey[1024];

    ASSERT((lstrlen(c_szRegKey) + lstrlen(c_szLog) + 2) < 1024);

#error Potential Buffer overflow:    
    lstrcpy(szSubKey, c_szRegKey);
    lstrcat(szSubKey, c_szLog);

    m_cLogs = 0;

    int     index = 0;
    ULONG   cbWritten;
    int     len = 0;
    int     maxIndex = 0;
    
    CRegStream * prs = new CRegStream(HKEY_CURRENT_USER, szSubKey, c_szLogMaxIndex);
    
    if (!prs)   {
        hr = E_FAIL;
    } else if (TRUE == prs->m_fNewStream)  {
        hr = E_FAIL;
    } else  {
        if (SUCCEEDED(prs->Read(&maxIndex, sizeof(int), &cbWritten))
                && (sizeof(int) == cbWritten) && (maxIndex >= 0))
        {
            FILETIME    ftFirst;
            SYSTEMTIME  stNow;
    
            if (TRAYUI_CLOGS < maxIndex)    {
                maxIndex = TRAYUI_CLOGS;
            }
    
            m_cLogPtr = -1;
            GetSystemTime(&stNow);
            SystemTimeToFileTime(&stNow, &ftFirst);
    
            for (; index < maxIndex; index ++)  
            {
                PLogEntry pLog = &(m_aLogEntry[m_cLogs]);
                if (SUCCEEDED(ReadSingleEntry(pLog, szSubKey, index)))  {
                   if (-1 == CompareFileTime(&(pLog->ftLog), &ftFirst)) {
                        ftFirst= pLog->ftLog;
                        m_cLogPtr = m_cLogs;
                    }
                    m_cLogs ++;
                }
            } 
    
            //  m_cLogPtr points to the oldest log. If we haven't used up
            //  all log space m_cLogPtr should point to 0. We then adjust
            //  it to the next available log slot.
            if (m_cLogs < TRAYUI_CLOGS) {
                ASSERT(m_cLogPtr == 0);
                m_cLogPtr = m_cLogs;
            }
        }
    }
    if (prs)
        delete prs;

    return hr;
}

STDMETHODIMP CTrayUI::AddToLog(BSTR bstrStatus, CLSID clsidAgent, CLSID startCookie)
{
    ASSERT(bstrStatus);
    BSTR    bstrTmp = NULL;
    bstrTmp = SysAllocString(bstrStatus);

    if (bstrTmp == NULL)
        return E_OUTOFMEMORY;

    PLogEntry   pLog = &(m_aLogEntry[m_cLogPtr]);

    pLog->bstrStatus = bstrTmp;
    pLog->clsidAgent = clsidAgent;
    pLog->startCookie = startCookie;

    SYSTEMTIME  stNow;
    GetSystemTime(&stNow);
    SystemTimeToFileTime(&stNow, &(pLog->ftLog));
    
    if (m_cLogPtr == m_cLogs)    {
        m_cLogs ++;
        SyncLogWithReg(m_cLogPtr, TRUE);
    } else  {
        SyncLogWithReg(m_cLogPtr, FALSE);
    }

    m_cLogPtr ++;
    m_cLogPtr %= TRAYUI_CLOGS;
    return S_OK;
}
#endif // WANT_REGISTRY_LOG

STDMETHODIMP CTrayUI::InitTrayUI(void)
{
    // shouldn't already be initialized
    ASSERT(NULL == m_hwnd);

    // create a hidden window
    WNDCLASS wndclass;

    wndclass.style         = 0;
    wndclass.lpfnWndProc   = TrayUI_WndProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = 0;
    wndclass.hInstance     = g_hInst;
    wndclass.hIcon         = NULL;
    wndclass.hCursor       = NULL;
    wndclass.hbrBackground = NULL;
    wndclass.lpszMenuName  = NULL;
    wndclass.lpszClassName = c_szTrayUI;

    RegisterClass (&wndclass) ;

    m_hwnd = CreateWindow(c_szTrayUI,
                c_szTrayUI,
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                NULL,
                NULL,
                g_hInst,
                NULL);

    DBGASSERT(m_hwnd, "failed to create TrayUI window");
    if (NULL == m_hwnd)
        return ERROR_NOT_ENOUGH_MEMORY;
    ShowWindow(m_hwnd, SW_HIDE);

    //
    // Add an icon to tray after seeing if it's enabled in the registry.
    //
    ASSERT(FALSE == m_fUpdatingTrayIcon);

    // turn on idle monitoring
    IdleBegin(m_hwnd);

    return S_OK;
}

STDMETHODIMP CTrayUI::DestroyTrayUI(void)
{
    // stop idle monitoring
    IdleEnd();

    if (m_hwnd)
    {
        BOOL bRet;
        bRet = DestroyWindow(m_hwnd);
        ASSERT(bRet);
        m_hwnd = NULL;
    }
    return S_OK;
}


STDMETHODIMP CTrayUI::OpenSubscriptionFolder(void)
{
#ifdef DEBUG
    // WARNING: This is copied from shdocvw and it might change post beta 1.
    TCHAR szSubPath[MAX_PATH];
    DWORD dwSize = SIZEOF(szSubPath);

    if (ReadRegValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SUBSCRIPTION,
                       REGSTR_VAL_DIRECTORY, (LPBYTE)szSubPath, dwSize) == FALSE)
    {
        TCHAR szWindows[MAX_PATH];

        GetWindowsDirectory(szWindows, ARRAYSIZE(szWindows));
        PathCombine(szSubPath, szWindows, TEXT("Subscriptions"));
    }

    SHELLEXECUTEINFO shei;
    ZeroMemory(&shei, sizeof(shei));
    shei.cbSize     = sizeof(shei);
    shei.lpFile     = szSubPath;
    shei.nShow      = SW_SHOWNORMAL;
    ShellExecuteEx(&shei);

#endif
    return S_OK;
}

STDMETHODIMP CTrayUI::OpenContextMenu(POINT * pPoint)
{
#ifdef DEBUG
    int     iCmd;
    HMENU   hMenu;
    TCHAR   menuString[MAX_PATH];

    ASSERT(pPoint);
    // SetForegroundWindow(hwnd);
    hMenu = CreatePopupMenu();
    if (!hMenu)
        return E_FAIL;


//    MLLoadString(IDS_SHOWPROG, menuString, MAX_PATH);
//    AppendMenu(hMenu, MF_STRING, IDS_SHOWPROG, menuString);

    MLLoadString(IDS_CANCELDL, menuString, MAX_PATH);
    AppendMenu(hMenu, MF_STRING, IDS_CANCELDL, menuString);

    MLLoadString(IDS_VIEW_SUBS, menuString, MAX_PATH);
    AppendMenu(hMenu, MF_STRING, IDS_VIEW_SUBS, menuString);

    SetMenuDefaultItem(hMenu, IDS_CANCELDL, FALSE);

    if (hMenu)
    {
        //
        // Set the owner window to be foreground as a hack so the
        // popup menu disappears when the user clicks elsewhere.
        //
        BOOL bRet;
        ASSERT(m_hwnd);
        bRet = SetForegroundWindow(m_hwnd);
        ASSERT(bRet);
        iCmd = TrackPopupMenu(hMenu, TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON,
            pPoint->x, pPoint->y, 0, m_hwnd, NULL);
        DestroyMenu(hMenu);

        MSG msgTmp;
        while (PeekMessage(&msgTmp, m_hwnd, WM_LBUTTONDOWN, WM_LBUTTONUP, PM_REMOVE)) {
            DispatchMessage(&msgTmp);
        }
    }

    switch (iCmd)
    {
        case IDS_SHOWPROG:
            RunTest();
            break;
        case IDS_CANCELDL:
            CancelAllDownloads();
            break;
        case IDS_VIEW_SUBS:
            OpenSubscriptionFolder();
            break;
        default:
            break;
    }

#endif
    return S_OK;
}

STDMETHODIMP CTrayUI::UpdateNow(INotification * pNotification)
{
    //
    // Update Subscriptions Now
    // We really don't want to do this on the caller's thread.  We should
    // always get here through a notification on the appartment thread.
    // (No direct calls from other threads are allowed to avoid race
    // conditions at startup.)
    ASSERT(GetCurrentThreadId() == m_AptThreadId);

    // Essentially we do a PostThreadMessage here to the updating thread.
    return UpdateRequest(UM_ONREQUEST, pNotification);
}


STDMETHODIMP CTrayUI::SetTrayIcon(DWORD fUpdating)
{
#ifdef DEBUG
    if (fUpdating == m_fUpdatingTrayIcon)   {
        return S_OK;
    }

    if (fUpdating)
    {
        BOOL bRet;
        NOTIFYICONDATA NotifyIconData;
        NotifyIconData.cbSize = sizeof(NOTIFYICONDATA);
        NotifyIconData.hWnd = m_hwnd;
        NotifyIconData.uID = 0;
        NotifyIconData.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
        NotifyIconData.uCallbackMessage = WM_USER;
        NotifyIconData.hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_TRAYICON));
        ASSERT(NotifyIconData.hIcon);
        bRet = MLLoadString(IDS_TRAY_TOOLTIP, NotifyIconData.szTip, ARRAYSIZE(NotifyIconData.szTip));
        ASSERT(bRet);
        bRet = Shell_NotifyIcon(NIM_ADD, &NotifyIconData);
        ASSERT(bRet);
    }
    else
    {
        // Remove the tray icon
        BOOL bRet;
        NOTIFYICONDATA NotifyIconData;
        NotifyIconData.cbSize = sizeof(NOTIFYICONDATA);
        NotifyIconData.hWnd = m_hwnd;
        NotifyIconData.uID = 0;
        NotifyIconData.uFlags = 0;
        bRet = Shell_NotifyIcon(NIM_DELETE, &NotifyIconData);
        ASSERT(bRet);
    }

    m_fUpdatingTrayIcon = fUpdating;
#endif
    return S_OK;
}

STDMETHODIMP CTrayUI::ConfigChanged(void)
{
    return S_OK;
}

STDMETHODIMP CTrayUI::OnEndReport(INotification * pNot)
{
//xnotfmgr
    ASSERT(pNot);
    CLSID   cookie;

    if (SUCCEEDED(ReadGUID(pNot, NULL, c_szStartCookie, &cookie)))
    {
        DBGIID("TrayAgent::OnEndReport - ", cookie);
        UpdateRequest(UM_ENDREPORT, pNot);
        LONG lTmp = InterlockedDecrement(&m_cUpdates);

        if (!lTmp)
            SetTrayIcon(FALSE);

        OOEBuf      ooeBuf;
        LPMYPIDL    newPidl = NULL;
        DWORD       dwSize = 0;

        ZeroMemory((void *)&ooeBuf, sizeof(OOEBuf));
        HRESULT hr = LoadWithCookie(NULL, &ooeBuf, &dwSize, &cookie);

        if (SUCCEEDED(hr))
        {
            newPidl = COfflineFolderEnum::NewPidl(dwSize);
            if (newPidl)   {
                CopyToMyPooe(&ooeBuf, &(newPidl->ooe));
                _GenerateEvent(SHCNE_UPDATEITEM, (LPITEMIDLIST)newPidl, NULL);
                COfflineFolderEnum::FreePidl(newPidl);
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CTrayUI::OnBeginReport(INotification * pNot)
{
//xnotfmgr
    ASSERT(pNot);
    CLSID   cookie;

    if (SUCCEEDED(ReadGUID(pNot, NULL, c_szStartCookie, &cookie)))
    {
        DBGIID("TrayAgent::OnBeginReport - ", cookie);
        UpdateRequest(UM_BEGINREPORT, pNot);
        InterlockedIncrement(&m_cUpdates);
        SetTrayIcon(TRUE);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\subsmgrp.h ===
#include "offline.h"

HRESULT SubscriptionItemFromCookie(BOOL fCreateNew, const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie, 
                                   ISubscriptionItem **ppSubscriptionItem);

HRESULT AddUpdateSubscription(SUBSCRIPTIONCOOKIE UNALIGNED *pCookie,
                              SUBSCRIPTIONITEMINFO *psii,
                              LPCWSTR pwszURL,
                              ULONG nProps,
                              const LPWSTR rgwszName[], 
                              VARIANT rgValue[]);

BOOL ItemKeyNameFromCookie(const SUBSCRIPTIONCOOKIE *pCookie, 
                           TCHAR *pszKeyName, 
                           DWORD cchKeyName);

BOOL OpenItemKey(const SUBSCRIPTIONCOOKIE *pCookie, BOOL fCreate, REGSAM samDesired, HKEY *phkey);

HRESULT GetInfoFromDataObject(IDataObject *pido,
                              TCHAR *pszPath, DWORD cchPath,
                              TCHAR *pszFriendlyName, DWORD cchFriendlyName,
                              TCHAR *pszURL, DWORD cchURL,
                              INIT_SRC_ENUM *peInitSrc);

HRESULT DoGetItemFromURL(LPCTSTR pszURL, ISubscriptionItem **ppSubscriptionItem);
HRESULT DoGetItemFromURLW(LPCWSTR pwszURL, ISubscriptionItem **ppSubscriptionItem);

HRESULT DoAbortItems( 
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies);

HRESULT DoCreateSubscriptionItem( 
    /* [in] */  const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo,
    /* [out] */ SUBSCRIPTIONCOOKIE *pNewCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem);

HRESULT DoCloneSubscriptionItem(
    /* [in] */  ISubscriptionItem *pSubscriptionItem, 
    /* [out] */ SUBSCRIPTIONCOOKIE *pNewCookie,
    /* [out] */ ISubscriptionItem **ppSubscriptionItem);

HRESULT DoDeleteSubscriptionItem(
    /* [in] */ const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie,
    /* [in] */ BOOL fAbortItem);

//
// Subscription manager
//
class CSubscriptionMgr : public IShellPropSheetExt,
                         public IShellExtInit,
                         public ISubscriptionMgr2,
                         public ISubscriptionMgrPriv
{
friend INT_PTR CALLBACK SummarizeDesktopSubscriptionDlgProc(HWND, UINT, WPARAM, LPARAM);
friend POOEBuf Summary_GetBuf(HWND hdlg);

protected:
    long        m_cRef;       
    LPMYPIDL    _pidl;
    SUBSCRIPTIONCOOKIE  m_cookie;
    TCHAR       m_pszURL[INTERNET_MAX_URL_LENGTH];
    TCHAR       m_pszFriendly[MAX_PATH];
    TCHAR       m_pszPath[MAX_PATH];
    POOEBuf     m_pBuf;
    IUnknown    * m_pUIHelper;
    UINT            m_nPages;
    INIT_SRC_ENUM   m_eInitSrc;
    SUBSCRIPTIONTYPE    m_oldType;

private:
    ~CSubscriptionMgr();

public:
    CSubscriptionMgr();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IShellExtInit members
    STDMETHODIMP         Initialize(LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHODIMP         AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHODIMP         ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplacePage, LPARAM lParam);

    // ISubscriptionMgr
    STDMETHODIMP         DeleteSubscription(LPCWSTR pURL, HWND hwnd);
    STDMETHODIMP         IsSubscribed(LPCWSTR pURL, BOOL *);
    STDMETHODIMP         GetDefaultInfo(SUBSCRIPTIONTYPE subType, SUBSCRIPTIONINFO *pInfo);
    STDMETHODIMP         GetSubscriptionInfo(LPCWSTR    pwszURL,
                                            SUBSCRIPTIONINFO *pInfo);
    STDMETHODIMP         ShowSubscriptionProperties(LPCWSTR pURL, HWND hwnd);
    STDMETHODIMP         CreateSubscription(HWND hwnd,
                                            LPCWSTR pwszURL,
                                            LPCWSTR pwszFriendlyName,
                                            DWORD dwFlags,
                                            SUBSCRIPTIONTYPE subsType,
                                            SUBSCRIPTIONINFO *pInfo);
    STDMETHODIMP         UpdateSubscription(LPCWSTR pwszURL);
    STDMETHODIMP         UpdateAll();

    //  ISubscriptionMgr2
    STDMETHODIMP         GetItemFromURL(LPCWSTR pwszURL,
                                        ISubscriptionItem **ppSubscriptionItem);
    STDMETHODIMP         GetItemFromCookie(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
                                           ISubscriptionItem **ppSubscriptionItem);
    STDMETHODIMP         GetSubscriptionRunState(DWORD dwNumCookies,
                                                 const SUBSCRIPTIONCOOKIE *pCookies,
                                                 DWORD *pdwRunState);
    STDMETHODIMP         EnumSubscriptions(DWORD dwFlags,
                                           IEnumSubscription **ppEnumSubscriptions);
    STDMETHODIMP         UpdateItems(DWORD dwFlags,
                                     DWORD dwNumCookies,
                                     const SUBSCRIPTIONCOOKIE *pCookies);
    STDMETHODIMP         AbortItems(DWORD dwNumCookies,
                                    const SUBSCRIPTIONCOOKIE *pCookies);
    STDMETHODIMP         AbortAll();

    // ISubscriptionMgrPriv
    STDMETHODIMP        CreateSubscriptionItem(const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo,
                                               SUBSCRIPTIONCOOKIE *pNewCookie,
                                               ISubscriptionItem **ppSubscriptionItem);
    STDMETHODIMP        CloneSubscriptionItem(ISubscriptionItem *pSubscriptionItem, 
                                              SUBSCRIPTIONCOOKIE *pNewCookie,
                                              ISubscriptionItem **ppSubscriptionItem);
    STDMETHODIMP        DeleteSubscriptionItem(const SUBSCRIPTIONCOOKIE *pCookie);

    STDMETHODIMP        RemovePages(HWND hdlg);
    STDMETHODIMP        SaveSubscription();
    STDMETHODIMP        URLChange(LPCWSTR pwszNewURL);


    HRESULT              CountSubscriptions(SUBSCRIPTIONTYPE subType, PDWORD pdwCount);

protected:
    void                 ChangeSubscriptionValues(OOEBuf *pCurrent, SUBSCRIPTIONINFO *pNew);
//    HRESULT              ResyncData(HWND);
    BOOL                 IsValidSubscriptionInfo(SUBSCRIPTIONTYPE subType, SUBSCRIPTIONINFO *pSI);

    //helpers for CreateSubscription -- not exported via ISubscriptionMgr
    STDMETHODIMP         CreateSubscriptionNoSummary(HWND hwnd,
                                            LPCWSTR pwszURL,
                                            LPCWSTR pwszFriendlyName,
                                            DWORD dwFlags,
                                            SUBSCRIPTIONTYPE subsType,
                                            SUBSCRIPTIONINFO *pInfo);
    STDMETHODIMP         CreateDesktopSubscription(HWND hwnd,
                                            LPCWSTR pwszURL,
                                            LPCWSTR pwszFriendlyName,
                                            DWORD dwFlags,
                                            SUBSCRIPTIONTYPE subsType,
                                            SUBSCRIPTIONINFO *pInfo);
};

class CEnumSubscription : public IEnumSubscription
{
public:
    CEnumSubscription();
    HRESULT Initialize(DWORD dwFlags);
    HRESULT CopyRange(ULONG nStart, ULONG nCount, SUBSCRIPTIONCOOKIE *pCookies, ULONG *pnCopied);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumSubscription
    STDMETHODIMP Next( 
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ SUBSCRIPTIONCOOKIE *rgelt,
        /* [out] */ ULONG *pceltFetched);
    
    STDMETHODIMP Skip( 
        /* [in] */ ULONG celt);
    
    STDMETHODIMP Reset( void);
    
    STDMETHODIMP Clone( 
        /* [out] */ IEnumSubscription **ppenum);
    
    STDMETHODIMP GetCount( 
        /* [out] */ ULONG *pnCount);

private:
    ~CEnumSubscription();

    ULONG   m_nCurrent;
    ULONG   m_nCount;
    ULONG   m_cRef;

    SUBSCRIPTIONCOOKIE *m_pCookies;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\trayagnt.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       trayagnt.h
//
//  Contents:   tray notification agent
//
//  Classes:
//
//  Functions:
//
//  History:    01-14-1997  rayen (Raymond Endres)  Created
//
//----------------------------------------------------------------------------
#ifndef TRAYAGNT_H_
#define TRAYAGNT_H_

//----------------------------------------------------------------------------
// Tray Agent object
//----------------------------------------------------------------------------
class CTrayAgent : public INotificationSink
{
protected:
    ULONG           m_cRef;         // OLE ref count
    #ifdef DEBUG
    DWORD           m_AptThreadId;  // 
    #endif

private:
    ~CTrayAgent(void);

public:
    CTrayAgent(void);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // INotificationSink member(s)
    //
    STDMETHODIMP         OnNotification(
        LPNOTIFICATION         pNotification,
        LPNOTIFICATIONREPORT   pNotificationReport,
        DWORD                  dwReserved
    );
};

//----------------------------------------------------------------------------
// TrayUI object (not COM object)
//----------------------------------------------------------------------------
#define TRAYUI_CLOGS    128

typedef struct LogEntryType {
    FILETIME    ftLog;
    CLSID       clsidAgent;
    CLSID       startCookie;
    BSTR        bstrStatus;
} * PLogEntry;

class CTrayUI
{
private:
    HWND            m_hwnd;             // hidden window
    DWORD           m_fUpdatingTrayIcon;// Is updating?

#if WANT_REGISTRY_LOG    
    int             m_cLogs;            // count of valid logs;
    int             m_cLogPtr;          // pointer to the replacing candidate.
                                        // Round Robin Algorithm;
    LogEntryType    m_aLogEntry[TRAYUI_CLOGS];
#endif

    LONG    m_cUpdates;                 // count of ongoing updates
    #ifdef DEBUG
    DWORD   m_AptThreadId;              // 
    #endif

private:
    STDMETHODIMP        SetTrayIcon(DWORD fUpdating);
    STDMETHODIMP        SyncLogWithReg(int, BOOL);
    
public:
    CTrayUI(void);
    ~CTrayUI(void);

    STDMETHODIMP        InitTrayUI(void);
    STDMETHODIMP        DestroyTrayUI(void);
    STDMETHODIMP        OpenSubscriptionFolder(void);
    STDMETHODIMP        OpenContextMenu(POINT *);
    STDMETHODIMP        UpdateNow(INotification *);
    STDMETHODIMP        ConfigChanged(void);
    STDMETHODIMP        OnBeginReport(INotification *);
    STDMETHODIMP        OnEndReport(INotification *);
#if WANT_REGISTRY_LOG    
    STDMETHODIMP        AddToLog(BSTR bstrLog, CLSID clsidAgent, CLSID startCookie);
    STDMETHODIMP        LoadLogFromReg(void);
    STDMETHODIMP        SaveLogToReg(void);
#endif
};

#endif TRAYAGNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\trkcache.h ===
// 
// Pei-Hwa Lin (peiwhal), Feb 3, 1997
//
#include "msxml.h"

#ifndef TRACKCACHE_H_
#define TRACKCACHE_H_

#define MAX_CONTENT_LENGTH 2048

#define TRK_BOTH    0x00000000
#define TRK_OFFLINE 0x00000001
#define TRK_ONLINE  0x00000002

// default internet cache entry info size
#define MY_CACHE_FILE_ENTRY_SIZE     2048

#define MY_WEBCHECK_POST_REG \
        WEBCHECK_REGKEY TEXT("\\Log")

const TCHAR c_szEmptyLog[] = TEXT(" ");
#define c_ccEmptyLog (ARRAYSIZE(c_szEmptyLog) - 1)

LPTSTR ReadTrackingPrefix(void);

HRESULT CreateLogCacheEntry(LPCTSTR lpPfxUrl, FILETIME ftExpire, FILETIME ftModified, DWORD dwPurgeTime);

//////////////////////////////////////////////////////////////////////////
//
// Utility Class
//
//////////////////////////////////////////////////////////////////////////
class CChannelAgent;
class CTrackingCacheClassFactory;

class CUrlTrackingCache
{

protected:
    ULONG           m_cRef;         // OLE ref count

public:
     CUrlTrackingCache(ISubscriptionItem* pCDFStartItem,
                       LPCWSTR pwszURL);
    ~CUrlTrackingCache();

    HRESULT              OnProcessDone(void);
    HRESULT              ProcessTrackingInItem(IXMLElement *pTracking, LPCWSTR pwszUrl, BOOL fForceLog);
    HRESULT              ProcessTrackingInLog (IXMLElement *pTracking);

    LPCWSTR              get_PostURL(void) { return _pwszPostUrl; }

protected:
    HRESULT              RunChildElement(IXMLElement* pElement);
    HRESULT              ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem);
    HRESULT              ReadAttribute(IXMLElement* pItem, LPCWSTR pwszAttributeName, LPWSTR* pwszAttributeValue);
    //HRESULT              DoLogEventAttribute(IXMLElement* pItem, LPCWSTR pwszAttributeName);

    void                 Init(LPCWSTR pwszURL);

    void                 DoBaseURL(LPCWSTR pwszURL);
    BOOL                 IsValidURL(LPCTSTR lpszURL);             
    BOOL                 ConvertToPrefixedUrl(LPCTSTR lpszUrl, LPTSTR * lplpPrefixedUrl);
    LPINTERNET_CACHE_ENTRY_INFO  RetrieveUrlCacheEntry(LPCTSTR lpUrl);
    HRESULT              CreatePrefixedCacheEntry(LPCTSTR lpUrl);
    
    HRESULT              AddToTrackingCacheEntry(LPCWSTR pwszUrl);

    HRESULT              SchedulePostAgent(void);

private:
    // channel properties
    //data
    GROUPID                 _groupId;

    LPWSTR                  _pwszPostUrl;
    LPWSTR                  _pwszEncodingMethod;
    LPWSTR                  _pwszPurgeTime;
    BOOL                    _bTrackIt;

    LPTSTR                  _pszChannelUrlSite;
    LPTSTR                  _pszPostUrlSite;
    LPTSTR                  _lpPfx;
    DWORD                   _dwPurgeTime;            // in Day
    DWORD                   _ConnectionScope;

    ISubscriptionItem*      _pCDFStartItem;
};

#endif TRACKCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\throttle.h ===
#ifndef _throttle_h
#define _throttle_h

#include "factory.h"

#define MAX_RUNNING_ITEMS           3

#define STATE_USER_IDLE_BEGIN       1
#define STATE_USER_IDLE_END         2

#define WC_INTERNAL_S_PAUSED        (MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0xF000))
#define WC_INTERNAL_S_RESUMING      (MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0xF001))
#define WC_INTERNAL_S_PENDING       (MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0xF002))


void IdleBegin(HWND hwnd);
void IdleEnd(void);

class COfflineSync;
struct CSyncMgrNode;
struct CUpdateItem;

#define THROTTLER_WNDCLASS  TEXT("WCThrottlerClass")

class CThrottler : public ISubscriptionAgentEvents,
                   public ISubscriptionThrottler
{
public:
    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ISubscriptionAgentEvents members
    STDMETHODIMP UpdateBegin(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie);

    STDMETHODIMP UpdateProgress(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        long lSizeDownloaded,
        long lProgressCurrent,
        long lProgressMax,
        HRESULT hrStatus,
        LPCWSTR wszStatus);

    STDMETHODIMP UpdateEnd(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        long lSizeDownloaded,
        HRESULT hrResult,
        LPCWSTR wszResult);

    STDMETHODIMP ReportError(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        HRESULT hrError, 
        LPCWSTR wszError);

    STDMETHODIMP GetSubscriptionRunState( 
        /* [in] */ DWORD dwNumCookies,
        /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies,
        /* [size_is][out] */ DWORD *pdwRunState);
    
    STDMETHODIMP AbortItems( 
        /* [in] */ DWORD dwNumCookies,
        /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies);
    
    STDMETHODIMP AbortAll();

    static HRESULT GetThrottler(CThrottler **ppThrottler);

    HRESULT RunCookies(
        DWORD dwNumCookies,
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookies, 
        DWORD dwSyncFlags);

    HRESULT Advise(COfflineSync *pOfflineSync);
    HRESULT Unadvise(COfflineSync *pOfflineSync);

    ULONG ExternalAddRef();
    ULONG ExternalRelease();

    static LRESULT ThrottlerWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    static void OnIdleStateChange(DWORD dwState);

private:

    enum { WM_THROTTLER_ABORTALL =WM_USER+99,
           WM_THROTTLER_ABORTITEM=WM_USER+100,
           WM_THROTTLER_AUTOCACHESIZE_ASK=WM_USER+101};

    DWORD               m_dwRegister;
#ifdef DEBUG
    DWORD               m_dwThreadId;
#endif    

    static CThrottler   *s_pThrottler;
    const static CFactoryData s_ThrottlerFactoryData;
  
    static HRESULT CreateInstance(IUnknown *punkOuter, IUnknown **ppunk);

    HRESULT RevokeClassObject();
    inline void ReportThrottlerError(const SUBSCRIPTIONCOOKIE *pCookie, HRESULT hrError, 
                                     LPCWSTR pwszErrMsg)
    {
        ReportError(pCookie, hrError, pwszErrMsg);
    }
    
    HRESULT AutoCacheSizeRequest(const SUBSCRIPTIONCOOKIE *pCookie);
    HRESULT AutoCacheSizeAskUser(DWORD dwCacheSizeKB);
    HRESULT IncreaseCacheSize(DWORD *pdwNewCacheSizeKB);

    CThrottler();
    ~CThrottler();

    ULONG           m_cRef;
    ULONG           m_cExternalRef;

    CSyncMgrNode    *m_pSyncMgrs;
    CUpdateItem     *m_pItemsHead;
    CUpdateItem     *m_pItemsTail;
    CUpdateItem     *m_updateQueue[MAX_RUNNING_ITEMS];
    int             m_nUpdating;
    HWND            m_hwndThrottler;
    HWND            m_hwndParent;

    BOOL            m_fAbortingAll:1;
    BOOL            m_fUserIsIdle:1;
    BOOL            m_fFillingTheQueue:1;
    BOOL            m_fForcedGlobalOnline:1;
    BOOL            m_fAutoDialed:1;
    BOOL            m_fAutoCacheSizePending:1;

    DWORD           m_dwMaxAutoCacheSize;
    DWORD           m_dwAutoCacheSizeIncrease;
    int             m_nAutoCacheSizeTimesAsked;

    typedef enum {NH_UPDATEBEGIN, NH_UPDATEPROGRESS, NH_UPDATEEND, NH_REPORTERROR};

    HRESULT AddItemToListTail(CUpdateItem *pAddItem);
    HRESULT RemoveItemFromList(CUpdateItem *pRemoveItem, BOOL fDelete);

    void OnIdleBegin();
    void OnIdleEnd();

    BOOL IsQueueSlotFree() { return m_nUpdating < ARRAYSIZE(m_updateQueue); }
    int GetFreeQueueSlot();
    int GetCookieIndexInQueue(const SUBSCRIPTIONCOOKIE *pCookie);
    void FillTheQueue();
    
    void FailedUpdate(HRESULT hr, const SUBSCRIPTIONCOOKIE *pCookie);
    void RunItem(int queueSlot, CUpdateItem *pUpdateItem);
    HRESULT CanScheduledItemRun(ISubscriptionItem *pSubsItem);

    STDMETHODIMP ActuallyAbortItems(DWORD dwNumCookies, const SUBSCRIPTIONCOOKIE *pCookies);
    STDMETHODIMP ActuallyAbortAll();

    HRESULT DoAbortItem(CUpdateItem *pUpdateItem);

    HRESULT CreateThrottlerWnd();

    HRESULT NotifyHandlers(int idCmd, const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, ...);
    HRESULT FindCookie(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        CUpdateItem **ppUpdateItem);
};

#include "offsync.h"

struct CSyncMgrNode
{
    CSyncMgrNode(COfflineSync *pOfflineSync, CSyncMgrNode *pNext) :
        m_pOfflineSync(pOfflineSync), 
        m_pNext(pNext) 
    {
        ASSERT(NULL != m_pOfflineSync);
    }

    ~CSyncMgrNode()
    {
        SAFERELEASE(m_pOfflineSync);
    }

    COfflineSync        *m_pOfflineSync;
    CSyncMgrNode        *m_pNext;
};

struct CUpdateItem
{
    CUpdateItem(const SUBSCRIPTIONCOOKIE& cookie,
                DWORD dwRunState) :
        m_cookie(cookie),
        m_dwRunState(dwRunState)
    {
        ASSERT(NULL == m_pNext);
        ASSERT(NULL == m_pSubsAgentCtl);
        ASSERT(CLSID_NULL != m_cookie);
        m_nMax = 128;
    }

    ~CUpdateItem()
    {
        SAFERELEASE(m_pSubsAgentCtl);
    }

    ISubscriptionAgentControl   *m_pSubsAgentCtl;
    SUBSCRIPTIONCOOKIE          m_cookie;
    DWORD                       m_dwRunState;
    CUpdateItem                 *m_pNext;
    LONG                        m_nMax;
};

#endif _throttle_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\update.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       update.cpp
//
//  Contents:   update subscriptions agent
//
//  Classes:
//
//  Functions:
//
//  History:    01-14-1997  rayen (Raymond Endres)  Created
//
//----------------------------------------------------------------------------

//xnotfmgr - darremi owns this

#include "private.h"
#include "offline.h"
#include "offl_cpp.h"

#undef TF_THISMODULE
#define TF_THISMODULE   TF_UPDATEAGENT

const IDMSG_NOTHING         = 100 + IDCANCEL;
const IDMSG_INITFAILED      = 101 + IDCANCEL;
const IDMSG_SESSIONEND      = 102 + IDCANCEL;
const IDMSG_UPDATEBEGIN     = 103 + IDCANCEL;
const IDMSG_UPDATEPROGRESS  = 104 + IDCANCEL;
const IDMSG_ADJUSTPROBAR    = 105 + IDCANCEL;

const TID_UPDATE = 7405;        //  TimerID
const TID_STATISTICS = 1243;    //  TimerID for statistics update

#define SHRESTARTDIALOG_ORDINAL    59       // restart only exported by ordinal
typedef BOOL (WINAPI *SHRESTARTDIALOG)( HWND, LPTSTR, DWORD );

CUpdateAgent    * g_pUpdate = NULL;
BOOL    CUpdateDialog::m_bDetail = FALSE;

CDialHelper::CDialHelper() : m_cRef(1),
                             m_iDialerStatus(DIALER_OFFLINE)
{
    ASSERT(0 == m_cConnection);
    ASSERT(NULL == m_pController);
}

STDMETHODIMP_(ULONG) CDialHelper::AddRef(void)
{
//    DBG("CDialHelper::AddRef");
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CDialHelper::Release(void)
{
//    DBG("CDialHelper::Release");
    if( 0L != --m_cRef )
        return m_cRef;

    DBG("CDialHelper::Release, ref count down to 0");
    ASSERT(!m_cConnection);
    ASSERT(m_iDialerStatus == DIALER_OFFLINE);
    if (m_iDialerStatus != DIALER_OFFLINE) {
        DBG("CDialHelper::Release, send disconnect message(abnormal)");
        NotifyAutoDialer(NOTIFICATIONTYPE_TASKS_COMPLETED);
    }
    SAFERELEASE(m_pNotMgr);

    PostThreadMessage(m_ThreadID, UM_DECREASE, 0, 0);
    delete this;
    return 0L;
}

STDMETHODIMP CDialHelper::QueryInterface(REFIID riid, void ** ppv)
{
//    DBG("CDialHelper::QueryInterface");
    *ppv = NULL;

    if ((IID_IUnknown == riid) ||
        (IID_INotificationSink == riid))
    {
        *ppv = (INotificationSink *)this;
    }

    if( NULL != *ppv ) 
    {
//        DBG("CDialHelper::QueryInterface/AddRef");
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP CDialHelper::OnNotification(
    LPNOTIFICATION         pNotification,
    LPNOTIFICATIONREPORT   pNotificationReport,
    DWORD                  dwReserved)
{
//    DBG("CDialHelper::OnNotification called");
    ASSERT(pNotification);
    
    // Extract Notification Type
    HRESULT          hr;
    NOTIFICATIONTYPE notfType;
    hr = pNotification->GetNotificationInfo(&notfType, NULL, NULL, NULL, 0);
    ASSERT(SUCCEEDED(hr));

    if (NOTIFICATIONTYPE_PROGRESS_REPORT == notfType) {
        // get hresult from notification
        HRESULT hrConnect;
        ReadSCODE(pNotification, NULL, c_szPropStatusCode, &hrConnect);
        if(SUCCEEDED(hrConnect))
            return OnInetOnline(pNotification);
        else
            return OnInetOffline(pNotification);
    } else {
        DBG("CDialHelper::OnNotification - Unknown notification");
        return S_OK;
    }
}

STDMETHODIMP CDialHelper::Init(CUpdateController * pController)
{
    ASSERT(pController);
    m_pController = pController;
    ASSERT(pController->m_pNotMgr);
    m_pNotMgr = pController->m_pNotMgr;
    m_ThreadID = pController->m_ThreadID;
    m_pNotMgr->AddRef();

    return S_OK;
}

STDMETHODIMP CDialHelper::DialOut(void)
{
    HRESULT hr = S_OK;

    if (m_iDialerStatus == DIALER_OFFLINE)  {
        DBG("CDialHelper::DialOut - Dialing Out");
        hr = NotifyAutoDialer(NOTIFICATIONTYPE_AGENT_START);
        if (SUCCEEDED(hr))  {
            m_iDialerStatus = DIALER_CONNECTING;
            m_cConnection ++;
        }
    }


    return hr;
}

STDMETHODIMP CDialHelper::HangUp(void)
{
    m_cConnection --;

    if (!m_cConnection) {
        if (m_iDialerStatus != DIALER_OFFLINE)  {
            DBG("CDialHelper::HangUp - Hanging up");
            m_iDialerStatus = DIALER_OFFLINE;
            NotifyAutoDialer(NOTIFICATIONTYPE_TASKS_COMPLETED);
        }
    }

    return S_OK;
}

STDMETHODIMP CDialHelper::CleanUp()
{
    m_pController = NULL;
    return S_OK;
}

STDMETHODIMP CDialHelper::OnInetOnline(
            INotification          *pNotification)
{
    HRESULT hr=S_OK;

    if (m_iDialerStatus == DIALER_CONNECTING)
    {
        DBG("Dial Helper: CONNECTION SUCCESSFUL, BEGINNING DOWNLOAD");

        m_iDialerStatus = DIALER_ONLINE;
        if (m_pController)
            m_pController->StartService();
        else
            HangUp();
    }

    return hr;
}

STDMETHODIMP CDialHelper::OnInetOffline(
            INotification          *pNotification)
{
    DBG("Dial Helper: received InetOffline, aborting");
    SCODE   eCode = S_OK;
    TCHAR szCaption[128];
    TCHAR szString[1024];
    CONNECT_ERROR   error;

    if (m_iDialerStatus == DIALER_CONNECTING)   {
        error = E_ATTEMPT_FAILED;
    } else  {
        error = E_CONNECTION_LOST;
    }

    if (SUCCEEDED(ReadSCODE(pNotification, NULL, c_szPropStatusCode, & eCode)))   {
        UINT uID;
        if (eCode == E_INVALIDARG)  {
             uID = IDS_STRING_E_CONFIG; 
        } else if (E_ABORT == eCode) {
            uID = IDS_STRING_E_SECURITYCHECK;
        } else {
            uID = IDS_STRING_E_FAILURE;
        }
        MLLoadString(uID, szString , ARRAYSIZE(szString));
        MLLoadString(IDS_CAPTION_ERROR_CONNECTING, szCaption, ARRAYSIZE(szCaption));
        
        MessageBox(NULL, szString, szCaption, MB_ICONWARNING | MB_SYSTEMMODAL);
    }

    if (m_pController)
        m_pController->StopService(error);
    else
        HangUp();

    m_iDialerStatus = DIALER_OFFLINE;

    return S_OK;
}

STDMETHODIMP CDialHelper::NotifyAutoDialer(NOTIFICATIONTYPE pType)
{
    HRESULT hr;
    INotification * pNot = NULL;
    ASSERT(m_pNotMgr);

    hr = m_pNotMgr->CreateNotification(
                pType,
                (NOTIFICATIONFLAGS) 0,
                NULL,
                &pNot,
                0);

    if (pNot)
    {
        INotificationSink *pSink = NULL;

        if (pType == NOTIFICATIONTYPE_AGENT_START)
        {
            DBG("CDialHelper::NotifyAutoDialer AGENT_START");
            pSink = (INotificationSink *)this;

            // HACK HACK [darrenmi] Until DZhang yanks out the umbrella code
            // we need something here - tell conn agent to let this connection
            // slide
            WriteAnsiSTR(pNot, NULL, c_szPropURL, TEXT("<override>"));

            // have not mgr deliver for us
            hr = m_pNotMgr->DeliverNotification(
                        pNot, 
                        CLSID_ConnectionAgent, 
                        DM_NEED_COMPLETIONREPORT | DM_DELIVER_DEFAULT_PROCESS,
                        pSink, &m_pConnAgentReport, 0);

        } else {
            DBG("CDialHelper::NotifyAutoDialer TASKS_COMPLETED");
            if(m_pConnAgentReport) {
                // deliver using the sink we've already got
                hr = m_pConnAgentReport->DeliverUpdate(pNot, 0, 0);
                TraceMsg(TF_THISMODULE, "CDialHelper::NotifyAutoDialer releasing report pointer");
                SAFERELEASE(m_pConnAgentReport);
            }
        }

        SAFERELEASE(pNot);
    }

    return hr;
}

DWORD WINAPI DialogThreadProc(LPVOID pData)
{
    ASSERT(pData);
    CUpdateDialog * pDialog = (CUpdateDialog *)pData;
    MSG     msg;

    pDialog->m_ThreadID = GetCurrentThreadId();

    while (GetMessage(&msg, NULL, 0, 0))    {
        switch (msg.message)    {
        case UM_READY:  
            {
                pDialog->Init(NULL, (CUpdateController *)msg.lParam);
                pDialog->Show(TRUE);
            }
            break;
        default:
            IsDialogMessage(pDialog->m_hDlg, &msg);
            break;
        }
    }
#ifdef DEBUG
    if(g_fInitTable)
        LeakDetFunctionTable.pfnDebugMemLeak(DML_TYPE_THREAD | DML_END, TEXT(__FILE__), __LINE__);
    
#endif 
    DBG("DialogThreadProc returning");
    return 0;
}

// application subscription channels can force a reboot
void DoReboot()
{
    HRESULT hrReboot = S_OK;
    HINSTANCE    hShell32Lib;

    DBG("UpdateThreadProc returning - attempting reboot");
    SHRESTARTDIALOG          pfSHRESTARTDIALOG = NULL;

    if ((hShell32Lib = LoadLibrary("shell32.dll")) != NULL) {

        if (!(pfSHRESTARTDIALOG = (SHRESTARTDIALOG)
            GetProcAddress( hShell32Lib, MAKEINTRESOURCE(SHRESTARTDIALOG_ORDINAL)))) {

            hrReboot = HRESULT_FROM_WIN32(GetLastError());

        } else {
            // FEATURE: What hwnd to use?
            pfSHRESTARTDIALOG(NULL, NULL, EWX_REBOOT);
        }

    } else  {
        hrReboot = HRESULT_FROM_WIN32(GetLastError());
    }

    if (hShell32Lib) {
        FreeLibrary(hShell32Lib);
    }
}

DWORD WINAPI UpdateThreadProc(LPVOID pData)
{
    ASSERT(pData);
    CUpdateController * pController = (CUpdateController *) pData;
    INotification   * pNotification = NULL;
    MSG     msg;
    int     l_cObj;
    BOOL    bNeedReboot = FALSE;

    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr)) {
        DBG("UpdateThreadProc exiting, failed to CoInitialize.");
        return hr;
    }

    while (GetMessage(&msg, NULL, 0, 0))    {
        switch (msg.message)    {
        case UM_ONREQUEST:
            if (!pController->m_fInit)
                break;
            pNotification = (INotification *)msg.lParam;
            //  WARNING. There is a chance we fail in OnRequest (Failed to
            //  send out Notification to dialer agent).
            hr = pController->OnRequest(pNotification);
            if (FAILED(hr))  {
                ASSERT(0);
                if ((!pController->m_count) && pController->m_pDialog)
                {
                    PostMessage(pController->m_pDialog->m_hDlg,
                                        WM_COMMAND, IDMSG_SESSIONEND, 0);
                }
            }
            SAFERELEASE(pNotification);
            break;
        case UM_BACKGROUND:
            if (!pController->m_fInit)
                break;
            break;
        case UM_ONABORT:
            if (!pController->m_fInit)
                break;
#ifdef  DEBUG
            hr =
#endif
            pController->Abort();
#ifdef  DEBUG
            ASSERT(SUCCEEDED(hr));
#endif
            break;
        case UM_ONSKIP:
            if (!pController->m_fInit)
                break;
#ifdef  DEBUG
            hr =
#endif
            pController->Skip();
#ifdef  DEBUG
            ASSERT(SUCCEEDED(hr));
#endif
            break;
        case UM_ONADDSINGLE:
            if (!pController->m_fInit)
                break;
            MemFree((HLOCAL)msg.lParam);
            break;
        case UM_ONSKIPSINGLE:
            if (!pController->m_fInit)
                break;
#ifdef  DEBUG
            hr =
#endif
            pController->SkipSingle((CLSID *)msg.lParam);
            MemFree((HLOCAL)msg.lParam);
#ifdef  DEBUG
            ASSERT(SUCCEEDED(hr));
#endif
            break;
        case UM_CLEANUP:
            pController->CleanUp();
            pController->Release();
            break;
        case UM_READY:
            pController->AddRef();
            if (FAILED(pController->Init((CUpdateDialog *)msg.lParam))) {
                DBG("UpdateThreadProc - failed to init controller");
                CUpdateDialog * pDlg = (CUpdateDialog *)msg.lParam;
                PostMessage(pDlg->m_hDlg, WM_COMMAND, IDMSG_INITFAILED, 0);
            } else  {
                l_cObj = 2;
            }
            break;
        case UM_DECREASE:
            l_cObj --;
            if (!l_cObj)
                goto QUIT;
            break;
        case UM_NEEDREBOOT:
            bNeedReboot = TRUE;
            break;

        default:
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            break;
        }
    }

QUIT:   ;
#ifdef DEBUG
    if(g_fInitTable)
        LeakDetFunctionTable.pfnDebugMemLeak(DML_TYPE_THREAD | DML_END, TEXT(__FILE__), __LINE__);
#endif 
    CoUninitialize();

    // This may need to be moved to a more appropriate location
    if (bNeedReboot)
        DoReboot();

    DBG("UpdateThreadProc returning");
    return 0;
}

STDMETHODIMP CUpdateController::ResyncData()
{
    return S_OK;
}

STDMETHODIMP CUpdateController::StartPending(void)
{
    HRESULT hr;

    DBG("CUpdateController::StartPending - entered");
    ASSERT(GetCurrentThreadId() == m_ThreadID);

    ASSERT(m_pDialer);
    ASSERT(m_pDialer->m_iDialerStatus == DIALER_ONLINE);
    
    for ( UINT ui = 0; ui < m_cReportCount; ui ++)  {
        if (m_aReport[ui].status == ITEM_STAT_PENDING)  {
            hr = DispatchRequest(&(m_aReport[ui]));
            ASSERT(SUCCEEDED(hr));
        }
    }

    return S_OK;
}

STDMETHODIMP CUpdateController::StartService(void)
{
    HRESULT hr = S_OK;

    DBG("CUpdateController: Start Service");
    ASSERT(GetCurrentThreadId() == m_ThreadID);
    ASSERT(!m_cFinished);

    hr = StartPending();

    if (!m_count)   {
        m_fSessionEnded = TRUE;
        m_pDialer->HangUp();
        if (m_pDialog)
            PostMessage(m_pDialog->m_hDlg, WM_COMMAND, IDMSG_SESSIONEND, 0);
    } else if (m_pDialog)
        PostMessage(m_pDialog->m_hDlg, WM_COMMAND, IDMSG_UPDATEBEGIN, 0);
        
    return S_OK;
}

STDMETHODIMP CUpdateController::StopService(CONNECT_ERROR err)
{
    DBG("Update Controller: Stop Service, aborting");
    ASSERT(GetCurrentThreadId() == m_ThreadID);
    HRESULT hr;

    if (!m_count && (err == E_ATTEMPT_FAILED))
    {
        if (m_pDialer)
            m_pDialer->HangUp();
    }

    for ( UINT ui = 0; ui < m_cReportCount; ui ++)  {
        switch (m_aReport[ui].status)   {
        case ITEM_STAT_UPDATING:
        case ITEM_STAT_QUEUED:
            hr = CancelRequest(&(m_aReport[ui]));
            if (FAILED(hr))
                break;
            else
                ;   //  Fall through.
        case ITEM_STAT_PENDING:
            m_aReport[ui].status = ITEM_STAT_ABORTED;
            if (m_pDialog)
                m_pDialog->RefreshStatus(&(m_aReport[ui].startCookie), NULL,  
                                            m_aReport[ui].status);
            break;
        default:
            break;
        }
    }

    if (!m_count)   {
        m_fSessionEnded = TRUE;
        PostMessage(m_pDialog->m_hDlg, WM_COMMAND, IDMSG_SESSIONEND, 0);
    }

    return S_OK;
}

STDMETHODIMP CUpdateController::IncreaseCount()
{
    ASSERT(m_count >= 0);
    InterlockedIncrement(&m_count);

    return S_OK;
}

STDMETHODIMP CUpdateController::DecreaseCount(CLSID * pCookie)
{
    InterlockedDecrement(&m_count);
    ASSERT(m_count >= 0);

    m_cFinished ++;
    // check for growing subscriptions (this could be better)
    if (m_cFinished > m_cTotal)
        m_cTotal = m_cFinished;

    if (m_count == 0)   {
        m_pDialer->HangUp();
    }

    if (m_pDialog)  {
        PostMessage(m_pDialog->m_hDlg, WM_COMMAND, IDMSG_UPDATEPROGRESS, 0);
        if (!m_count)   {
            m_fSessionEnded = TRUE;
            PostMessage(m_pDialog->m_hDlg, WM_COMMAND, IDMSG_SESSIONEND, 0);
        }
    }
    
    return S_OK;
}

STDMETHODIMP CUpdateController::GetItemList(UINT * pNewItem)
{
    DBG("CUpdateController::GetItemList - entered");

    NOTIFICATIONITEM    item;
    item.cbSize = sizeof(NOTIFICATIONITEM);
    ASSERT(m_pNotMgr);

    IEnumNotification * pEnumNot = NULL;
    HRESULT hr;
    ULONG   cItems = 0;
    UINT    count = 0;

    hr = m_pNotMgr->GetEnumNotification(0, &pEnumNot);
    RETURN_ON_FAILURE(hr);

    ASSERT(pEnumNot);

    hr = pEnumNot->Next(1, &item, &cItems);
    while (SUCCEEDED(hr) && cItems)
    {
        ASSERT(item.pNotification);

        if ((NOTIFICATIONTYPE_AGENT_START == item.NotificationType) &&
            (item.pNotification) &&
            (TASK_FLAG_HIDDEN & ~item.TaskData.dwTaskFlags))
        {
            SCODE   scodeLast;
            STATUS  statusLast;

            hr = ReadSCODE(item.pNotification, NULL, c_szPropStatusCode, &scodeLast);
            if (FAILED(scodeLast))  {
                statusLast = ITEM_STAT_FAILED;
            } else  {
                statusLast = ITEM_STAT_SUCCEEDED;
            }

            hr = AddEntry(&item, statusLast);
            if (SUCCEEDED(hr))  {
                count ++;
#ifdef  DEBUG
            } else  {
                DBGIID("CUpdateController::GetItemList - Failed to add entry", item.NotificationCookie);
#endif
            }
        }
        SAFERELEASE(item.pNotification);
        item.cbSize = sizeof(NOTIFICATIONITEM);
        hr = pEnumNot->Next(1, &item, &cItems);
    }

    if (pNewItem)
        *pNewItem = count;

    SAFERELEASE(pEnumNot);
    return hr;
}

STDMETHODIMP CUpdateController::Abort(void)
{
    DBG("CUpdateController::Abort - entered");

    ASSERT(GetCurrentThreadId() == m_ThreadID);
    ASSERT(m_pDialer);

    HRESULT hr = StopService(ITEM_STAT_ABORTED);

    return hr;
}

STDMETHODIMP CUpdateController::SkipSingle(CLSID * pCookie)
{
    ASSERT(pCookie);
    if (!pCookie)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    PReportMap pEntry = FindReportEntry(pCookie);
    if (pEntry) {
        switch (pEntry->status) {
        case ITEM_STAT_UPDATING:
        case ITEM_STAT_QUEUED:
            hr = CancelRequest(pEntry);
            if (FAILED(hr))
                break;
            else
                ;   //  Fall through.
        case ITEM_STAT_PENDING:
            pEntry->status = ITEM_STAT_SKIPPED;
            if (m_pDialog)
            {
                m_pDialog->RefreshStatus(pCookie, NULL, pEntry->status);
                //select first updating item in list, which should be skippable
                m_pDialog->SelectFirstUpdatingSubscription();
            }
            break;
        default:
            break;
        }
    }

    return hr;
}

STDMETHODIMP CUpdateController::Skip(void)
{
    DBG("CUpdateController::Skip - entered");
    HRESULT hr = S_OK;
    
    ASSERT(GetCurrentThreadId() == m_ThreadID);
    ASSERT(m_pDialog);
    UINT selCount = 0;

    hr = m_pDialog->GetSelectionCount(&selCount);
    if (FAILED(hr))
        return hr;

    if (!selCount)
        return S_OK;

    CLSID * pSelCookies = (CLSID *)MemAlloc(LPTR, sizeof(CLSID)*selCount);
    if (!pSelCookies)
        return E_OUTOFMEMORY;

    hr = m_pDialog->GetSelectedCookies(pSelCookies, &selCount);
    if (FAILED(hr)) {
        MemFree(pSelCookies); pSelCookies = NULL;
        return hr;
    }
    
    for (UINT ui = 0; ui < selCount; ui ++) {
        SkipSingle(pSelCookies + ui);
    }

    MemFree(pSelCookies); pSelCookies = NULL;
    return S_OK;
}

const GUIDSTR_LEN  = GUIDSTR_MAX - 1;

STDMETHODIMP CUpdateController::AddSingle(CLSID * pCookie)
{
    ASSERT(pCookie);
    if (!pCookie)
        return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    PReportMap  pEntry = FindReportEntry(pCookie);

    if (!pEntry)    {
        NOTIFICATIONITEM    item;
        item.cbSize = sizeof(NOTIFICATIONITEM);
        ASSERT(m_pNotMgr);

        hr = m_pNotMgr->FindNotification(pCookie, &item, 0);
        if (FAILED(hr))
            return hr;

        ASSERT(item.pNotification);
        hr = E_FAIL;
        if ((NOTIFICATIONTYPE_AGENT_START == item.NotificationType) &&
            (item.pNotification) &&
            (TASK_FLAG_HIDDEN & ~item.TaskData.dwTaskFlags))
        {
            SCODE   scodeLast;
            STATUS  statusLast;

            hr = ReadSCODE(item.pNotification, NULL, c_szPropStatusCode, &scodeLast);
            if (FAILED(scodeLast))  {
                statusLast = ITEM_STAT_FAILED;
            } else  {
                statusLast = ITEM_STAT_SUCCEEDED;
            }

            hr = AddEntry(&item, statusLast);
#ifdef  DEBUG
            if (FAILED(hr))  {
                DBGIID("CUpdateController::AddSingle - Failed to add new entry", item.NotificationCookie);
            }
#endif
        }
        SAFERELEASE(item.pNotification);
        item.cbSize = sizeof(NOTIFICATIONITEM);     // Why is this line here?
        if (FAILED(hr))
            return hr;

        pEntry = FindReportEntry(pCookie);
        ASSERT(pEntry);
    }

    if (pEntry) {
        switch (pEntry->status) {
        case ITEM_STAT_QUEUED:
        case ITEM_STAT_UPDATING:
            hr = S_FALSE;
            break;
#ifdef  DEBUG
        case ITEM_STAT_IDLE:
            ASSERT(0);
            break;
#endif
        default:
            pEntry->status = ITEM_STAT_PENDING;
            if (m_pDialog)
                m_pDialog->RefreshStatus(pCookie,pEntry->name,pEntry->status);
            hr = S_OK;
            break;
        }
    }
    return hr;
}

STDMETHODIMP CUpdateController::Restart(UINT count)
{
    if (!count)
        return S_OK;

    HRESULT hr = S_OK;
    m_cTotal = m_cTotal + count;
    if (m_pDialog)
        PostMessage(m_pDialog->m_hDlg, WM_COMMAND, IDMSG_ADJUSTPROBAR, 0);

    ASSERT(m_pDialer);
    if (m_pDialer->IsOffline())   {
        hr = m_pDialer->DialOut();
    } else if (m_pDialer->IsConnecting()) {
        ;   //  Nothing to do;
    } else  {
        hr = StartPending();
    }

    return hr;
}

STDMETHODIMP CUpdateController::OnRequest(INotification * pNotification)
{
    BOOL    bUpdateAll = TRUE;
    HRESULT hr;
    UINT    count = 0;

    DBG("CUpdateController::OnRequest - entered");
    ASSERT(GetCurrentThreadId() == m_ThreadID);

    //  There is a chance that we are still receiving request even through
    //  we have already ended the session.
    if (m_fSessionEnded)
        return S_FALSE;     //  We don't accept any more requests.
    
    if (pNotification)  {
        VARIANT var;

        VariantInit(&var);

        //      Right now (02/21/97) urlmon can't handle the SAFEARRAY.
        //      We assembly this array of GUIDs as a BSTR in SendUpdateRequest
        //      and disassembly it here.
        
        hr = pNotification->Read(c_szPropGuidsArr, &var);
        if (var.vt == VT_BSTR)    {
            UINT    bstrLen = 0;
            BSTR    bstr = var.bstrVal;
            int     guidCount, i;
            CLSID   cookie;

            ASSERT(bstr);
            DBG("CUpdateController::OnRequest - found cookie list");
            
            bstrLen = lstrlenW(bstr);
            guidCount = bstrLen / GUIDSTR_LEN;

            SYSTEMTIME  stNow;
            DATE        dtNow;
            NOTIFICATIONITEM item;

            GetSystemTime(&stNow);
            SystemTimeToVariantTime(&stNow, &dtNow);
            
            item.cbSize = sizeof(NOTIFICATIONITEM);
            for (i = 0; i < guidCount; i ++) {
                BSTR    bstrCookie = NULL;

                bstrCookie = SysAllocStringLen(bstr+i*GUIDSTR_LEN, GUIDSTR_LEN);
                hr = CLSIDFromString(bstrCookie, &cookie);
#ifdef  DEBUG
                DBGIID(TEXT("On request to update "), cookie);
#endif
                SysFreeString(bstrCookie);
                if (FAILED(hr))
                    continue;
    
                if (S_OK == AddSingle(&cookie))
                    count ++;
            }

            hr = Restart(count);
            VariantClear(&var);
            return hr;
        } else  {
            VariantClear(&var);
        }
    }

    DBG("CUpdateController::OnRequest - Update all");

    for ( UINT ui = 0; ui < m_cReportCount; ui ++)  {
        switch (m_aReport[ui].status)   {
#ifdef  DEBUG
        case ITEM_STAT_IDLE:
            ASSERT(0);
            break;
#endif
        case ITEM_STAT_UPDATING:
        case ITEM_STAT_QUEUED:
            break;
        default:
            m_aReport[ui].status = ITEM_STAT_PENDING;
            if (m_pDialog)
                m_pDialog->RefreshStatus(&(m_aReport[ui].startCookie),
                                            m_aReport[ui].name,
                                            m_aReport[ui].status);
            count ++;
            break;
        }
    }

    hr = Restart(count);
    return hr;
}

CUpdateController::CUpdateController() : m_fInit(FALSE), m_fSessionEnded(FALSE)
{
    m_pNotMgr = NULL;
    m_pDialog = NULL;
    m_pDialer = NULL;
    m_cRef = 1;
}

CUpdateController::~CUpdateController()
{
    ASSERT(0L == m_cRef);
}

STDMETHODIMP_(ULONG) CUpdateController::AddRef(void)
{
//    DBG("CUpdateController::AddRef");
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CUpdateController::Release(void)
{
//    DBG("CUpdateController::Release");
    if( 0L != --m_cRef )
        return m_cRef;

    DBG("Destroying Controller object");
    m_fInit = FALSE;
    PostThreadMessage(m_ThreadID, UM_DECREASE, 0, 0);
    SAFERELEASE(m_pNotMgr);

    if (m_pDialer)  {
        m_pDialer->CleanUp();
        SAFERELEASE(m_pDialer);
    }

    m_pDialog = NULL;
    for (UINT ui = 0; ui < m_cReportCount; ui ++)   {
        SAFELOCALFREE(m_aReport[ui].name);
        SAFELOCALFREE(m_aReport[ui].url);
    }
    SAFELOCALFREE(m_aReport);
    delete this;
    return 0L;
}

STDMETHODIMP CUpdateController::QueryInterface(REFIID riid, void ** ppv)
{
//    DBG("CUpdateController::QueryInterface");
    *ppv = NULL;

    if ((IID_IUnknown == riid) ||
        (IID_INotificationSink == riid))
    {
        *ppv = (INotificationSink *)this;
    }

    if( NULL != *ppv ) 
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP CUpdateController::Init(CUpdateDialog * pDialog)
{
    DBG("CUpdateController::Init");
    ASSERT( !m_pNotMgr );

    ASSERT(pDialog);
    ASSERT(!m_fInit);
    m_pDialog = pDialog;
    m_cReportCount = m_cReportCapacity = 0;

    m_ThreadID = GetCurrentThreadId();
    ASSERT (!m_aReport);

    m_aReport = (PReportMap)MemAlloc(LPTR, sizeof(ReportMapEntry) * CUC_ENTRY_INCRE);
    if (!m_aReport) {
        DBG("CUpdateController::Init - Out of mem");
        return E_OUTOFMEMORY;
    }

    m_cReportCapacity = CUC_ENTRY_INCRE;

    HRESULT hr = CoCreateInstance(CLSID_StdNotificationMgr, NULL, 
        CLSCTX_INPROC_SERVER,  IID_INotificationMgr,(void **)&m_pNotMgr);

    if (SUCCEEDED(hr))  {
        m_pDialer = new CDialHelper;
        if (!m_pDialer) {
            DBG("CUpdateController::Init - Failed to dialer");
            hr = E_OUTOFMEMORY;
        } else    {
            m_pDialer->AddRef();
            hr = m_pDialer->Init(this);
        }
    }

    if (SUCCEEDED(hr))  {
        m_cFinished = m_cTotal = 0;
        m_count = 0;
        m_fInit = TRUE;
        GetItemList(NULL);
        if ((!m_cReportCount) && (m_pDialog))   {   //  Didn't find nothing.
            PostMessage(m_pDialog->m_hDlg, WM_COMMAND, IDMSG_NOTHING, 0);
        }
    } else  {
        SAFERELEASE(m_pNotMgr);
        SAFERELEASE(m_pDialer);
    }

    return hr;
}

//  REARCHITECT: Copied from NotificationMgr code (notifctn.hxx)
#define WZ_COOKIE  L"Notification_COOKIE"

//
// INotificationSink member(s)
//
STDMETHODIMP CUpdateController::OnNotification(
    LPNOTIFICATION         pNotification,
    LPNOTIFICATIONREPORT   pNotificationReport,
    DWORD                  dwReserved)
{
    DBG("CUpdateController::OnNotification called");
    ASSERT(pNotification);
    
    HRESULT          hr;
    NOTIFICATIONTYPE notfType;
    ASSERT(GetCurrentThreadId() == m_ThreadID);

    //  Extract Notification Type
    hr = pNotification->GetNotificationInfo(&notfType, NULL, NULL, NULL, 0);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr)) {
        return E_INVALIDARG;
    }

    if (notfType == NOTIFICATIONTYPE_END_REPORT)
    {
        //
        //  Except those we fail to DeliverNotification in the first place for
        //  each request we will get an End Report when we finished the current
        //  update or aborted/skipped the current update. 
        //
        DBG("CUpdateController::OnNotification - END REPORT");
        CLSID   cookie;
        PReportMap  pEntry = NULL;

        if (SUCCEEDED(ReadGUID(pNotification, NULL, c_szStartCookie, &cookie)))
        {
            pEntry = FindReportEntry(&cookie);
        }

        if (!pEntry)    {
            DBGIID("CUpdateController::OnNotification(END_REPORT) - invalid cookie", cookie);
            return E_FAIL;
        }

        //update count of total kbytes downloaded with size of this site from end report
        DWORD dwCrawlKBytes;
        if (SUCCEEDED (ReadDWORD (pNotification, NULL, c_szPropCrawlActualSize, &dwCrawlKBytes)))
        {
            if (m_pDialog) {
                DWORD dwKBytesPrevious = m_pDialog->SetSiteDownloadSize (&cookie, dwCrawlKBytes);

                m_pDialog->m_cDlKBytes += dwCrawlKBytes - dwKBytesPrevious;
                SendMessage (m_pDialog->m_hDlg, WM_TIMER, TID_STATISTICS, 0);   //force update
            }
        }

        switch (pEntry->status) {
        case ITEM_STAT_UPDATING :
        {
            SCODE   eCode = S_OK;

            hr = ReadSCODE(pNotification, NULL, c_szPropStatusCode, & eCode);
            ASSERT(SUCCEEDED(hr));
            if (FAILED(eCode))  {
                pEntry->status = ITEM_STAT_FAILED;
            } else  {
                pEntry->status = ITEM_STAT_SUCCEEDED;
            }

            if (m_pDialog)  {
                m_pDialog->RefreshStatus(&cookie, NULL, pEntry->status);
                PostMessage(m_pDialog->m_hDlg, WM_COMMAND,
                                IDMSG_UPDATEPROGRESS, 100 - pEntry->progress);
            }
            pEntry->progress = 0;
            break;
        }
        case ITEM_STAT_SKIPPED:
        case ITEM_STAT_ABORTED:
            ASSERT(!(pEntry->progress));
            break;
        default:
            ASSERT(0);
            break;
        }
        return S_OK;
    }    
    else if (notfType == NOTIFICATIONTYPE_TASKS_COMPLETED 
            || notfType == NOTIFICATIONTYPE_TASKS_ERROR)
    {
        DBG("CUpdateController::OnNotification - TASKS_ENDED");
        CLSID   cookie;
        PReportMap  pEntry = NULL;

        if (SUCCEEDED(ReadGUID(pNotification, NULL, WZ_COOKIE, &cookie)))
        {
            pEntry = FindReportEntry(&cookie);
        }

        if (!pEntry)    {
            DBGIID("\t(TASKS_ENDED) - invalid cookie ", cookie);
            return E_FAIL;
        } else  {
            DBGIID("\t(TASKS_ENDED) - cookie ", cookie);
        }

        DecreaseCount(&cookie);
        switch (pEntry->status) {
        case ITEM_STAT_UPDATING :
        {
            if (notfType == NOTIFICATIONTYPE_TASKS_ERROR)   {
                pEntry->status = ITEM_STAT_FAILED;
            } else  {
                pEntry->status = ITEM_STAT_SUCCEEDED;
            }

            if (m_pDialog)  {
                m_pDialog->RefreshStatus(&cookie, NULL, pEntry->status);
                PostMessage(m_pDialog->m_hDlg, WM_COMMAND,
                                IDMSG_UPDATEPROGRESS, 100 - pEntry->progress);
            }
            pEntry->progress = 0;
            break;
        }
        case ITEM_STAT_SKIPPED:
        case ITEM_STAT_ABORTED:
            ASSERT(!(pEntry->progress));
            break;
        case ITEM_STAT_QUEUED:
            pEntry->status = ITEM_STAT_ABORTED;
            if (m_pDialog)  {
                m_pDialog->RefreshStatus(&cookie, NULL, pEntry->status);
                PostMessage(m_pDialog->m_hDlg, WM_COMMAND,
                                IDMSG_UPDATEPROGRESS, 100 - pEntry->progress);
            }
            pEntry->progress = 0;
            break;
        default:
            ASSERT(!(pEntry->progress));
            break;
        }
        return S_OK;
    }
    else if (notfType == NOTIFICATIONTYPE_PROGRESS_REPORT)
    {
        DBG("CUpdateController::OnNotification - progress report");
        CLSID   cookie;
        PReportMap  pEntry = NULL;

        if (SUCCEEDED(ReadGUID(pNotification, NULL, c_szStartCookie, &cookie)))
        {
            pEntry = FindReportEntry(&cookie);
        }

        if (!pEntry)    {
            DBGIID("CUpdateController::OnNotification(PROGRESS_REPORT) - invalid cookie", cookie);
            return E_FAIL;
        }

        //start a document dl -- update count and status indicators
        if (m_pDialog)  {
            BSTR bCurrentUrl;
            TCHAR szCurrentUrl[MAX_URL + 1];

            if (SUCCEEDED(ReadBSTR(pNotification, NULL, c_szPropCurrentURL, &bCurrentUrl)))
            {
                //does not appear to be a real BSTR (with length byte) -- just an OLESTR
                MyOleStrToStrN (szCurrentUrl, MAX_URL, bCurrentUrl);
                SAFEFREEBSTR(bCurrentUrl);
                m_pDialog->RefreshStatus(&cookie, NULL, pEntry->status, szCurrentUrl);

                //update size of download
                DWORD dwKBytesCurrent;
                if (SUCCEEDED (ReadDWORD (pNotification, NULL, c_szPropCurrentSize, &dwKBytesCurrent))
                    && (dwKBytesCurrent != -1))
                {
                    DWORD dwKBytesPrevious = m_pDialog->SetSiteDownloadSize (&cookie, dwKBytesCurrent);

                    m_pDialog->m_cDlKBytes += dwKBytesCurrent - dwKBytesPrevious;
                }

                ++m_pDialog->m_cDlDocs;     //increase number of docs downloaded
                SendMessage (m_pDialog->m_hDlg, WM_TIMER, TID_STATISTICS, 0);   //force update
            }
        }

        DWORD dwProgress;
        DWORD dwProgressMax;
        if (SUCCEEDED(ReadDWORD(pNotification, NULL, c_szPropProgressMax, &dwProgressMax)) && SUCCEEDED(ReadDWORD(pNotification, NULL, c_szPropProgress, &dwProgress)))
        {
            //  (INT)dwProgressMax could be -1!
            if ((((INT)dwProgress) >= 0) && (((INT)dwProgressMax) >= 0))   {
                ASSERT(dwProgress <= dwProgressMax);

                //  The progress report is sent at the beginning of current
                //  download. We should substrat Progress by 1.
                UINT cProgress, cProgressMax, newPercentage;
                cProgress = (dwProgress)?dwProgress - 1:0;
                cProgressMax = dwProgressMax;

                newPercentage = MulDiv(cProgress, 100, cProgressMax);
                if ((newPercentage > pEntry->progress) && m_pDialog)   {
                    PostMessage(m_pDialog->m_hDlg, WM_COMMAND,
                                    IDMSG_UPDATEPROGRESS,
                                    (LPARAM)(newPercentage - pEntry->progress));
                }
                pEntry->progress = newPercentage;
            }
        }
        return S_OK;
    }
    else if (notfType == NOTIFICATIONTYPE_BEGIN_REPORT)
    {
        DBG("CUpdateController::OnNotification - begin report");
        CLSID   cookie;
        PReportMap  pEntry = NULL;

        if (SUCCEEDED(ReadGUID(pNotification, NULL, c_szStartCookie, &cookie)))
        {
            pEntry = FindReportEntry(&cookie);
        }

        if (!pEntry)    {
            DBGIID("CUpdateController::OnNotification(BEGIN_REPORT) - invalid cookie", cookie);
            return E_FAIL;
        }

        if (pEntry->status == ITEM_STAT_UPDATING)
            return S_OK;

        //  Note there is a case that we send out the 'Abort' notification to
        //  the agent, and the agent sends 'begin report' at almost the same
        //  time. In that case we can get begin-report when we think we already
        //  cancelled the update.
        if (pEntry->status != ITEM_STAT_QUEUED) {
            ASSERT((pEntry->status == ITEM_STAT_SKIPPED) ||
                   (pEntry->status == ITEM_STAT_ABORTED));
            return S_OK;    //  We bail out.
        }
        pEntry->status = ITEM_STAT_UPDATING;
        if (m_pDialog)
            m_pDialog->RefreshStatus(&cookie, NULL, ITEM_STAT_UPDATING);

        return S_OK;
    }
    else if (notfType == NOTIFICATIONTYPE_TASKS_STARTED)
    {
        DBG("CUpdateController::OnNotification - TASKS_STARTED");
        CLSID   cookie;
        PReportMap  pEntry = NULL;

        if (SUCCEEDED(ReadGUID(pNotification, NULL, WZ_COOKIE, &cookie)))
        {
            pEntry = FindReportEntry(&cookie);
        }

        if (!pEntry)    {
            DBGIID("\t(TASKS_STARTED) - invalid cookie ", cookie);
            return E_FAIL;
        } else  {
            DBGIID("\t(TASKS_STARTED) - cookie ", cookie);
        }
        ASSERT(pEntry->status == ITEM_STAT_QUEUED);

        if (pEntry->status != ITEM_STAT_QUEUED) {
            ASSERT((pEntry->status == ITEM_STAT_SKIPPED) ||
                   (pEntry->status == ITEM_STAT_ABORTED));
            return S_OK;    //  We bail out.
        }
        pEntry->status = ITEM_STAT_UPDATING;
        if (m_pDialog)
            m_pDialog->RefreshStatus(&cookie, NULL, ITEM_STAT_UPDATING);

        return S_OK;
    }
    else
    {
        DBG("CUpdateController::OnNotification - unknown notification");
        return S_OK;
    }
}

STDMETHODIMP CUpdateController::DispatchRequest(PReportMap pEntry)
{
    DBG("CUpdateController::Dispatch - entered");
    ASSERT(pEntry);
    ASSERT(m_pNotMgr);
    ASSERT(m_pDialog);
    ASSERT(ITEM_STAT_PENDING == pEntry->status);
    
    HRESULT hr;
    NOTIFICATIONITEM item;
    item.cbSize = sizeof(item);

    hr = m_pNotMgr->FindNotification(&(pEntry->startCookie), &item, 0);
    ASSERT(SUCCEEDED(hr));
    if (SUCCEEDED(hr))  {
        hr = m_pNotMgr->DeliverNotification(item.pNotification,
                                            item.clsidDest,
                                            DM_DELIVER_DEFAULT_PROCESS |
                                            DM_NEED_COMPLETIONREPORT |
                                            DM_NEED_PROGRESSREPORT |
                                            DM_THROTTLE_MODE,

                                            (INotificationSink *)this,
                                            NULL,
                                            0);
        SAFERELEASE(item.pNotification);
        if (FAILED(hr)) {
            DBG("CUpdateController::Dispatch - failed to DeliverNotification");
            m_pDialog->RefreshStatus(&(pEntry->startCookie), NULL, ITEM_STAT_FAILED);
        } else  {
            DBG("Increase Count");
            pEntry->status = ITEM_STAT_QUEUED;
            pEntry->progress = 0;
            IncreaseCount();
        }
    }
    return hr;
}

//  In CancelRequest() we only attempt to send out the notification of
//  abort. The count on agent side will be decreased when we get end report.
//  So matched number of request and end report is crucial.

STDMETHODIMP CUpdateController::CancelRequest(PReportMap pEntry)
{
    ASSERT(pEntry);

    if ((ITEM_STAT_UPDATING != pEntry->status) 
        && (ITEM_STAT_QUEUED != pEntry->status))
            return S_OK;

    ASSERT(m_pNotMgr);

    HRESULT hr = S_OK;
    INotification *pNot = NULL;
    hr = m_pNotMgr->CreateNotification(NOTIFICATIONTYPE_TASKS_ABORT,
                                       (NOTIFICATIONFLAGS)0,
                                       NULL,
                                       &pNot,
                                       0);
    ASSERT(SUCCEEDED(hr));
    if (SUCCEEDED(hr))
    {
        if (SUCCEEDED(hr))
        {
            hr = m_pNotMgr->DeliverReport(pNot,  &(pEntry->startCookie), 0);
            if (SUCCEEDED(hr))  {
                if (m_pDialog)  {
                    PostMessage(m_pDialog->m_hDlg, WM_COMMAND,
                                IDMSG_UPDATEPROGRESS, 100 - pEntry->progress);
                }
                pEntry->progress = 0;
                //  This is the default status afterwards. 
                pEntry->status = ITEM_STAT_ABORTED;
            } else  {
                TraceMsg(TF_THISMODULE, TEXT("CancelRequest:Error:%x"), hr);
            }
        } else  {
            DBG("CUpdateController::Stop failed");
        }
        SAFERELEASE(pNot);
    }

    return hr;
}

PReportMap CUpdateController::FindReportEntry(CLSID * pCookie)
{
    ASSERT(pCookie);

    for (UINT ui = 0; ui < m_cReportCount; ui ++)   {
        if (m_aReport[ui].startCookie == * pCookie) {
            return &(m_aReport[ui]);
        }
    }

    return NULL;
}

STDMETHODIMP CUpdateController::GetLocationOf(CLSID * pCookie, LPTSTR pszText, UINT cchTextMax)
{
    ASSERT(pCookie && pszText);

    PReportMap pEntry = FindReportEntry(pCookie);

    if (pEntry)    {
        lstrcpyn(pszText, pEntry->url, cchTextMax);
    } else  {
        lstrcpyn(pszText, c_szStrEmpty, cchTextMax);
    }

    return S_OK;
}

SUBSCRIPTIONTYPE CUpdateController::GetSubscriptionType(CLSID * pCookie)
{
    ASSERT(pCookie);

    SUBSCRIPTIONTYPE    subType = SUBSTYPE_EXTERNAL;
    PReportMap pEntry = FindReportEntry(pCookie);

    if (pEntry) {
        subType = pEntry->subType;
    }

    return subType;
}

BOOL CUpdateController::IsSkippable(CLSID * pCookie)
{
    ASSERT(pCookie);

    PReportMap pEntry = FindReportEntry(pCookie);

    if (pEntry)
        if (pEntry->status == ITEM_STAT_PENDING ||
            pEntry->status == ITEM_STAT_QUEUED  ||
            pEntry->status == ITEM_STAT_UPDATING)
        {
            return TRUE;
        }
    return FALSE;
}

STDMETHODIMP CUpdateController::AddEntry(NOTIFICATIONITEM *pItem, STATUS status)
{
    ASSERT(pItem);
    ASSERT(m_cReportCount <= m_cReportCapacity);

    if (m_cReportCount == m_cReportCapacity)    {
        UINT    newSize = m_cReportCapacity + CUC_ENTRY_INCRE;
        ASSERT(newSize <= CUC_MAX_ENTRY);
        HLOCAL  newBuf = MemReAlloc(m_aReport, newSize * sizeof(ReportMapEntry), LHND);
        if (!newBuf)    {
            DBG("CUpdateController::AddEntry - Failed to realloc");
            return E_OUTOFMEMORY;
        }

        m_aReport = (PReportMap)(newBuf);
        m_cReportCapacity = newSize;
    }

    m_aReport[m_cReportCount].startCookie = pItem->NotificationCookie;
    m_aReport[m_cReportCount].progress = 0;
    m_aReport[m_cReportCount].status = status;

    OOEBuf  ooeBuf;
    DWORD   dwSize = 0;

    ZeroMemory((void *)&ooeBuf, sizeof(ooeBuf));
    HRESULT hr = LoadOOEntryInfo(&ooeBuf, pItem, &dwSize); 
    if (S_OK != hr)
    {
        if (FAILED(hr))
            return hr;
        else
            return E_FAIL;
    }

    LPTSTR nameStr = NULL, urlStr = NULL;

    nameStr = (LPTSTR)MemAlloc(LPTR, (lstrlen(ooeBuf.m_Name) + 1) * sizeof(TCHAR));
    urlStr = (LPTSTR)MemAlloc(LPTR, (lstrlen(ooeBuf.m_URL) + 1) * sizeof(TCHAR));
    if (!(nameStr && urlStr))   {
        SAFELOCALFREE(nameStr);
        SAFELOCALFREE(urlStr);

        return E_OUTOFMEMORY;
    }

    lstrcpy(nameStr, ooeBuf.m_Name);
    lstrcpy(urlStr, ooeBuf.m_URL);

    m_aReport[m_cReportCount].name = nameStr;
    m_aReport[m_cReportCount].url = urlStr;
    m_aReport[m_cReportCount].subType = GetItemCategory(&ooeBuf);

    m_cReportCount ++;
    return S_OK;
}

STDMETHODIMP CUpdateController::CleanUp()
{
    m_pDialog = NULL;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
//  CUpdateAgent
//
//      The only reason we need this class is that so we can create the
//      dialog in the different thread.

CUpdateAgent::CUpdateAgent()
{
    DBG("Creating CUpdateAgent object");
    ASSERT(!(m_pDialog || m_pController));
}

CUpdateAgent::~CUpdateAgent()
{
    DBG("Destroying CUpdateAgent object");

    if (m_pController)  {
        PostThreadMessage(m_ThreadID, UM_CLEANUP, 0,0);
        m_pController = NULL;
    }

    if (m_pDialog)  {
//        delete m_pDialog;
//              m_pDialog will be destroyed by m_pController in CleanUp.
        m_pDialog = NULL;
    }

    g_pUpdate = NULL;
}

STDMETHODIMP CUpdateAgent::Init(void)
{
    DBG("CUpdateAgent::Init");
    HRESULT hr = S_OK;

    ASSERT(!(m_pDialog || m_pController));

    if (SUCCEEDED(hr))  {
        m_pDialog = new CUpdateDialog;
        if (!m_pDialog) {
            DBG("CUpdateAgent::Init - Failed to create dialog");
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))  {
        m_pController = new CUpdateController;
        if (!m_pController) {
            DBG("CUpdateAgent::Init - Failed to create download controller");
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))  {
        HANDLE  hThread;

        hThread = CreateThread(NULL, 0, DialogThreadProc, 
                                (LPVOID)m_pDialog, 0, &m_DialogThreadID);
        if (!hThread)   {
            DBG("CUpdateAgent::Init - Failed to create dialog thread");
            hr = E_FAIL;
        } else  {
            int i = 0;
            while ( i < 3)  {
                if (PostThreadMessage(m_DialogThreadID, UM_READY, 0, (LPARAM)m_pController))
                    break;
                i ++;
                Sleep(1000);
            }
            //  Is there a safer way to do this?
            if (i >= 3) {
                ASSERT(0);
                hr = E_FAIL;
            }
            CloseHandle(hThread);
        }
    }

    if (SUCCEEDED(hr))  {
        HANDLE  hThread;

        hThread = CreateThread(NULL, 0, UpdateThreadProc, 
                                (LPVOID)m_pController, 0, &m_ThreadID);
        if (!hThread)   {
            DBG("CUpdateAgent::Init - Failed to create thread");
            hr = E_FAIL;
        } else  {
            int i = 0;
            while ( i < 3)  {
                if (PostThreadMessage(m_ThreadID, UM_READY, 0, (LPARAM)m_pDialog))
                    break;
                i ++;
                Sleep(1000);
            }
            //  FEATURE: Is there a safer way to do this?
            if (i >= 3) {
                ASSERT(0);
                hr = E_FAIL;
            }
            SetThreadPriority(hThread, THREAD_PRIORITY_IDLE);
            CloseHandle(hThread);
        }
        if (FAILED(hr)) {
            PostThreadMessage(m_DialogThreadID, WM_QUIT, 0, 0);
        }
    }

    if (FAILED(hr)) {
        if (m_pController)  {
            delete m_pController;
            m_pController = NULL;
        }
        if (m_pDialog)  {
            delete m_pDialog;
            m_pDialog = NULL;
        }
    }
            
    return hr;
}

BOOL ListView_OnNotify(HWND hDlg, NM_LISTVIEW* plvn, CUpdateController * pController)
{
    ASSERT(plvn && pController);
    CUpdateDialog * pDialog = pController->m_pDialog;

    if (!pDialog)
        return FALSE;   //  If m_pDialog is NULL, we haven't call Init
                        //  for pController on second thread yet.

    HRESULT hr;

    switch (plvn->hdr.code)   {
        case LVN_ITEMCHANGED:
        {
            if (!(plvn->uChanged & LVIF_STATE))
                break;

            UINT uOldState = plvn->uOldState & LVIS_SELECTED;
            UINT uNewState = plvn->uNewState & LVIS_SELECTED;

            UINT count = 0;
            hr = pDialog->GetSelectionCount(&count);
            if (FAILED(hr))
                break;

            HWND hButton = GetDlgItem(hDlg, IDCMD_SKIP);
            BOOL fEnable = FALSE;
            if (count)  {

                CLSID cookie;
                int iItem = plvn->iItem;
                
                hr = pDialog->IItem2Cookie(iItem, &cookie);
                if (SUCCEEDED(hr)) {
                    fEnable = pController->IsSkippable(&cookie);
                }
            }

            Button_Enable(hButton, fEnable);
            return TRUE;
        }
        default:
            break;
    }

    return FALSE;
}


void ResizeDialog(HWND hDlg, BOOL bShowDetail)
{
    ASSERT(hDlg);
    RECT    rcDlg, rcChild;
    HWND    hSplitter, hLV;
    TCHAR   szButton[32];

    //calculate margin (upper-left position of IDC_SIZENODETAILS)
    GetWindowRect(GetDlgItem (hDlg, IDC_SIZENODETAILS), &rcChild);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rcChild, 2);
    int iMargin = rcChild.left;

    GetWindowRect(hDlg, &rcDlg);

    if (bShowDetail)  {
        hLV = GetDlgItem(hDlg, IDL_SUBSCRIPTION);
        ASSERT(hLV);
        GetWindowRect(hLV, &rcChild);
        rcDlg.bottom = rcChild.bottom + iMargin + GetSystemMetrics (SM_CXSIZEFRAME);
        rcDlg.right = rcChild.right + iMargin + GetSystemMetrics (SM_CYSIZEFRAME);

        LONG dwStyle = GetWindowLong (hDlg, GWL_STYLE);
        dwStyle = dwStyle | WS_MAXIMIZEBOX | WS_THICKFRAME;
        SetWindowLong (hDlg, GWL_STYLE, dwStyle);

        rcDlg.left -= (GetSystemMetrics (SM_CXSIZEFRAME) - GetSystemMetrics (SM_CXFIXEDFRAME));
        rcDlg.top -= (GetSystemMetrics (SM_CYSIZEFRAME) - GetSystemMetrics (SM_CYFIXEDFRAME));
        MoveWindow(hDlg, rcDlg.left, rcDlg.top,
                    rcDlg.right - rcDlg.left,
                    rcDlg.bottom - rcDlg.top,
                    TRUE);
        MLLoadString(IDS_NODETAILS, szButton, ARRAYSIZE(szButton));
    } else  {
        hSplitter = GetDlgItem(hDlg, IDC_SIZENODETAILS);
        ASSERT(hSplitter);
        GetWindowRect(hSplitter, &rcChild);

        LONG dwStyle = GetWindowLong (hDlg, GWL_STYLE);
        dwStyle = dwStyle & ~WS_MAXIMIZEBOX & ~WS_THICKFRAME;
        SetWindowLong (hDlg, GWL_STYLE, dwStyle);

        MoveWindow(hDlg, rcDlg.left + (GetSystemMetrics (SM_CXSIZEFRAME) - GetSystemMetrics (SM_CXFIXEDFRAME)),
            rcDlg.top + (GetSystemMetrics (SM_CYSIZEFRAME) - GetSystemMetrics (SM_CYFIXEDFRAME)),
                rcChild.right - rcDlg.left,
                rcChild.bottom - rcDlg.top,
                TRUE);
        MLLoadString(IDS_DETAILS, szButton, ARRAYSIZE(szButton));
    }
    SetDlgItemText(hDlg, IDCMD_DETAILS, szButton);
}


void UpdateStatistics (HWND hDlg, int nFiles, int nKBytes, int nSeconds)
{
    TCHAR szStats[128], szFormat[64];

    MLLoadString (IDS_STATISTICS, szFormat, ARRAYSIZE(szFormat));
    wnsprintf (szStats, ARRAYSIZE(szStats), szFormat, 
               nFiles, nKBytes, nSeconds/60, nSeconds%60);
    SetDlgItemText (hDlg, IDC_STATISTICS, szStats);
}


void DrawResizeWidget (HWND hDlg)   //copied from athena's CGroupListDlg::OnPaint
{
    PAINTSTRUCT ps;
    RECT rc;

    GetClientRect(hDlg, &rc);
    rc.left = rc.right - GetSystemMetrics(SM_CXSMICON);
    rc.top = rc.bottom - GetSystemMetrics(SM_CYSMICON);
    BeginPaint(hDlg, &ps);

    if (CUpdateDialog::m_bDetail && !IsZoomed(hDlg))
        DrawFrameControl(ps.hdc, &rc, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);

    CUpdateDialog * pDialog = (CUpdateDialog *)GetWindowLong(hDlg, DWL_USER);
    if (pDialog != NULL)
    {
        pDialog->m_cxWidget = rc.left;
        pDialog->m_cyWidget = rc.top;
    }

    EndPaint(hDlg, &ps);
}


void EraseResizeWidget (HWND hDlg)
{
    CUpdateDialog * pDialog = (CUpdateDialog *)GetWindowLong(hDlg, DWL_USER);
    RECT rWidget;

    if (pDialog != NULL)
    {
        //invalidate resize widget
        rWidget.left = pDialog->m_cxWidget;
        rWidget.top = pDialog->m_cyWidget;
        rWidget.right = pDialog->m_cxWidget + GetSystemMetrics(SM_CXSMICON);
        rWidget.bottom = pDialog->m_cyWidget + GetSystemMetrics(SM_CYSMICON);
        InvalidateRect(hDlg, &rWidget, FALSE);

//        pDialog->m_cxWidget = rWidget.left;
//        pDialog->m_cxWidget = rWidget.top;
    }
}


extern BOOL GetSubscriptionFolderPath(LPTSTR);
//----------------------------------------------------------------------------
// UpdateDlgProc function
//----------------------------------------------------------------------------
BOOL CALLBACK UpdateDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static DWORD dwStartTicks;
    CUpdateDialog * pDialog = (CUpdateDialog *)GetWindowLong(hDlg, DWL_USER);
    CUpdateController * pController = (pDialog)?pDialog->m_pController:NULL;
    
    switch (uMsg)
    {
        case WM_INITDIALOG :
        {
            DBG("DLGBOX: Creating dialog box.");
            ASSERT(lParam);
            ASSERT(GetWindowLong(hDlg, DWL_USER) == 0);
            SetWindowLong(hDlg, DWL_USER, lParam);
            SetForegroundWindow(hDlg);
            TCHAR szString[1024];
            MLLoadString(IDS_CONNECTING, szString, ARRAYSIZE(szString));
            SetDlgItemText(hDlg, IDC_AGENTSTATUS, szString);
            ResizeDialog(hDlg, CUpdateDialog::m_bDetail);

            SetTimer (hDlg, TID_STATISTICS, 1000, NULL);
            dwStartTicks = GetTickCount();

            // Check current keyboard layout is IME or not
            if (((DWORD)GetKeyboardLayout(0) & 0xF0000000L) == 0xE0000000L)
            {
                HWND hwndIME = ImmGetDefaultIMEWnd(hDlg);
                if (hwndIME)
                    SendMessage(hwndIME, WM_IME_NOTIFY, IMN_CLOSESTATUSWINDOW, 0);
            }

            return FALSE;   // keep the focus on the dialog
        }
        case WM_ACTIVATE:
            if (LOWORD(wParam) != WA_INACTIVE)
            {
                // Check current keyboard layout is IME or not
                if (((DWORD)GetKeyboardLayout(0) & 0xF0000000L) == 0xE0000000L)
                {
                    HWND hwndIME = ImmGetDefaultIMEWnd(hDlg);
                    if (hwndIME)
                        SendMessage(hwndIME, WM_IME_NOTIFY, IMN_CLOSESTATUSWINDOW, 0);
                }
            }
            break;
        case WM_NOTIFY :
            switch (LOWORD (wParam))   {
            case IDL_SUBSCRIPTION:
                if (!pController)
                    break;
                return ListView_OnNotify(hDlg, (NM_LISTVIEW *)lParam, pController);
            default:
                return FALSE;
            }
            break;
        case WM_TIMER:
            switch (wParam)
            {
            case TID_UPDATE:
                KillTimer(hDlg, wParam);
                pDialog->CleanUp();
                SetWindowLong(hDlg, DWL_USER, 0);
                delete pDialog;
                return TRUE;
                
            case TID_STATISTICS:
                UpdateStatistics (hDlg, pDialog->m_cDlDocs, pDialog->m_cDlKBytes,
                    (GetTickCount() - dwStartTicks)/1000);
                return TRUE;
            }
            break;
        case WM_GETMINMAXINFO :
            if (CUpdateDialog::m_bDetail)
            {
                LPMINMAXINFO lpmmi = (LPMINMAXINFO)lParam;
                DWORD style = GetWindowLong (hDlg, GWL_STYLE);
                RECT smallest;
                GetWindowRect (GetDlgItem (hDlg, IDC_MINBORDER), &smallest);
                AdjustWindowRect (&smallest, style, FALSE);
                lpmmi->ptMinTrackSize.x = smallest.right - smallest.left;
                lpmmi->ptMinTrackSize.y = smallest.bottom - smallest.top;
                return 0;
            }
            break;
        case WM_PAINT:
            DrawResizeWidget (hDlg);
            break;
        case WM_SIZE:
            if (wParam == SIZE_MAXIMIZED || wParam == SIZE_RESTORED)
            {
                const int CHILDREN[] = { IDCMD_HIDE, IDCMD_ABORT, IDCMD_DETAILS, IDCMD_SKIP };
                int width = LOWORD(lParam), height = HIWORD(lParam);
                RECT rChild;
                int child;

                //calculate margin (upper-left position of IDC_SIZENODETAILS)
                GetWindowRect(GetDlgItem (hDlg, IDC_SIZENODETAILS), &rChild);
                // Use MapWindowPints for mirroring
                MapWindowPoints(NULL, hDlg, (LPPOINT)&rChild, 2);
                int iMargin = rChild.left;

                for (child = 0; child < sizeof(CHILDREN)/sizeof(CHILDREN[0]); child++)
                {
                    GetWindowRect (GetDlgItem (hDlg, CHILDREN[child]), &rChild);
                    MapWindowPoints(NULL, hDlg, (LPPOINT)&rChild, 2);
                    SetWindowPos (GetDlgItem (hDlg, CHILDREN[child]), 0,
                        width - iMargin - (rChild.right - rChild.left), rChild.top,
                        0, 0, SWP_NOSIZE | SWP_NOZORDER);
                }

                if (CUpdateDialog::m_bDetail)   //only apply to bottom half
                {
                    EraseResizeWidget (hDlg);

                    GetWindowRect (GetDlgItem (hDlg, IDD_SPLITTER), &rChild);
                    MapWindowPoints(NULL, hDlg, (LPPOINT)&rChild, 2);                    SetWindowPos (GetDlgItem (hDlg, IDD_SPLITTER), 0,
                        0, 0, width - 2 * rChild.left, rChild.bottom - rChild.top,
                        SWP_NOMOVE | SWP_NOZORDER | SWP_NOCOPYBITS);   //for some reason there's a weird redraw bug on this control -- NOCOPYBITS fixes it
                    
                    GetWindowRect (GetDlgItem (hDlg, IDL_SUBSCRIPTION), &rChild);
                    MapWindowPoints(NULL, hDlg, (LPPOINT)&rChild, 2);                    SetWindowPos (GetDlgItem (hDlg, IDL_SUBSCRIPTION), 0,
                        0, 0, width - rChild.left - iMargin, height - rChild.top - iMargin,
                        SWP_NOMOVE | SWP_NOZORDER);
                }
                return 0;
            }
            break;

        case WM_CLOSE:
            KillTimer (hDlg, TID_STATISTICS);
            break;

        case WM_COMMAND :
        {
            if (!pController)   {
                if (IDCANCEL == LOWORD (wParam))    {
                    KillTimer(hDlg, TID_UPDATE);
                    pDialog->CleanUp();
                    SetWindowLong(hDlg, DWL_USER, 0);
                    delete pDialog;
                    return TRUE;
                } else  {
                    break;
                }
            }

            HWND    hProgress = GetDlgItem(hDlg, IDD_PROBAR);
            HWND    hAnimate = GetDlgItem(hDlg, IDD_ANIMATE);
            TCHAR   szString[1024];

            switch (LOWORD (wParam))
            {
                case IDMSG_SESSIONEND:      //  Stop dialog, session concludes.
                    DBG("UpdateDlgProc - all updates are complete");
                    pController->m_cTotal = pController->m_cFinished = 0;
                    pDialog->m_pController = pController = NULL;
                    delete g_pUpdate;
                    MessageBeep(0xFFFFFFFF);
                    Animate_Close(hAnimate);
                    ShowWindow(hAnimate, SW_HIDE);
                    MLLoadString(IDS_SESSIONEND, szString, ARRAYSIZE(szString));
                    SetDlgItemText(hDlg, IDC_AGENTSTATUS, szString);
                    ShowWindow (GetDlgItem (hDlg, IDC_AGENTSTATUS), SW_SHOW);
                    
                    Button_Enable(GetDlgItem(hDlg, IDCMD_ABORT), FALSE);
                    Button_Enable(GetDlgItem(hDlg, IDCMD_DETAILS), FALSE);
                    SetTimer(hDlg, TID_UPDATE, 3000, NULL);
                    KillTimer (hDlg, TID_STATISTICS);
                    return TRUE;

                case IDMSG_UPDATEBEGIN:
                {
                    DBG("UpdateDlgProc - Start updating");
                    SetForegroundWindow(hDlg);
                    ShowWindow (hAnimate, SW_SHOW);
                    ShowWindow (GetDlgItem (hDlg, IDC_AGENTSTATUS), SW_HIDE);
                    Animate_Open(hAnimate, IDA_DOWNLOAD);
                    Animate_Play(hAnimate, 0, -1, -1);
                    return TRUE;
                }

                case IDMSG_ADJUSTPROBAR:
                {
                    ASSERT(pController->m_cTotal);
                    ASSERT(pController->m_cFinished <= pController->m_cTotal);
                    SendMessage(hProgress, PBM_SETRANGE32,
                            0, pController->m_cTotal * 100);
                    SendMessage(hProgress, PBM_SETPOS,
                            pController->m_cFinished * 100, 0);
                    return TRUE;
                }

                case IDMSG_NOTHING:   //  Nothing to show yet.
                {
                    DBG("UpdateDlgProc - No item found");
                    MLLoadString(IDS_STRING_NOTHING_TO_UPDATE, 
                                    szString , ARRAYSIZE(szString));
                    SetDlgItemText(hDlg, IDC_AGENTSTATUS, szString);
                    pController->m_cTotal = pController->m_cFinished = 0;
                    pDialog->m_pController = pController = NULL;
                    delete g_pUpdate;
                    MessageBeep(0xFFFFFFFF);
                    Button_Enable(GetDlgItem(hDlg, IDCMD_ABORT), FALSE);
                    Button_Enable(GetDlgItem(hDlg, IDCMD_DETAILS), FALSE);
                    SetTimer(hDlg, TID_UPDATE, 3000, NULL);
                    KillTimer (hDlg, TID_STATISTICS);
                    return TRUE;
                }

                case IDMSG_UPDATEPROGRESS:
                    SendMessage(hProgress, PBM_DELTAPOS, lParam, 0);
                    return TRUE;

                case IDMSG_INITFAILED:
                    DBG("UpdateDlgProc - Controller Init Failed.");
                    SetWindowLong(hDlg, DWL_USER, 0);
                    pDialog->m_pController = pController = NULL;
                    delete g_pUpdate;
                    MessageBeep(0xFFFFFFFF);
                    Button_Enable(GetDlgItem(hDlg, IDCMD_ABORT), FALSE);
                    Button_Enable(GetDlgItem(hDlg, IDCMD_DETAILS), FALSE);
                    pDialog->CleanUp();
                    SetWindowLong(hDlg, DWL_USER, 0);
                    delete pDialog;
                    return TRUE;

                case IDCANCEL:
                {
                    int mbRet = SGMessageBox(hDlg, IDS_DOWNLOAD_ABORT_WARNING,
                                                MB_YESNO | MB_ICONQUESTION |
                                                MB_DEFBUTTON2 | MB_APPLMODAL);
                    if (mbRet == IDNO)  {
                        return TRUE;
                    } else  {
                        if (!pDialog->m_pController)
                            return TRUE;
                        ;   //  Fall through.
                    }
                }

                //  Following messages are from the UI and need to be
                //  forward to update thread.

                case IDCMD_ABORT:   //  Abort all updates
                    DBG("UpdateDlgProc - closing, all downloads aborted");
                    ASSERT(pController->m_ThreadID);
                    PostThreadMessage(pController->m_ThreadID, UM_ONABORT, 0,0);
                    MLLoadString(IDS_ABORTING, szString, ARRAYSIZE(szString));
                    SetDlgItemText(hDlg, IDC_AGENTSTATUS, szString);
                    Animate_Close(hAnimate);
                    ShowWindow(hAnimate, SW_HIDE);
                    ShowWindow (GetDlgItem (hDlg, IDC_AGENTSTATUS), SW_SHOW);
                    return TRUE;

                case IDCMD_SKIP:
                    PostThreadMessage(pController->m_ThreadID, UM_ONSKIP, 0,0);
                    return TRUE;

                case IDCMD_DETAILS:
                {
                    CUpdateDialog::m_bDetail = !CUpdateDialog::m_bDetail;
                    ResizeDialog(hDlg, CUpdateDialog::m_bDetail);
                    
                    return TRUE;
                }

                case IDCMD_HIDE:
                    ShowWindow(hDlg, SW_SHOWMINIMIZED);
                    return TRUE;

                default:
                    break;
            }
            break;
        }
    }
    
    return FALSE;
}

HRESULT GetActiveUpdateAgent(CUpdateAgent ** ppUpdate)
{
    ASSERT (ppUpdate);
    //  We are assuming the Update agent is free threaded.
    *ppUpdate = NULL;

    if (g_pUpdate == NULL)  {
        DBG("GetActiveUpdateAgent - Creating new agent");
        g_pUpdate = new CUpdateAgent();
        if (!g_pUpdate) {
            DBG("GetActiveUpdateAgent - Failed to create new agent");
            return E_OUTOFMEMORY;
        }

        HRESULT hr = g_pUpdate->Init();
        if (FAILED(hr)) {
            DBG("GetActiveUpdateAgent - Failed to init new agent");
            return hr;
        }
    }
    *ppUpdate = g_pUpdate;
    return NOERROR;
}

DWORD WINAPI BackgroundUpdate(void)
{
    DBG("BackgroundUpdate entered");

    HRESULT hr;
    CUpdateAgent * pAgent = NULL;

    hr = GetActiveUpdateAgent(&pAgent);
    if (SUCCEEDED(hr))  {
        ASSERT(pAgent);
        ASSERT(pAgent->m_ThreadID);
        //  APPCOMPAT: Even when we succeed here, there are chances that we won't
        //  get updated because CONTROLLER CAN FAIL TO INITIALIZE AND WE DON'T
        //  KNOW IT!
        if (!PostThreadMessage(pAgent->m_ThreadID, UM_BACKGROUND,0,0))
        {
            hr = E_FAIL;
            DBG("Failed to post ONREQUEST message.");
        }
        pAgent = NULL;
    }
    DBG("BackgroundUpdate ended");
    return (DWORD)hr;
}

DWORD WINAPI UpdateRequest(UINT idCmd, INotification *pNot)
{
//    DBG("UpdateRequest entered");

    if (idCmd != UM_ONREQUEST)
        return E_FAIL;

    HRESULT hr;
    CUpdateAgent * pAgent = NULL;

    hr = GetActiveUpdateAgent(&pAgent);
    if (SUCCEEDED(hr))  {
        ASSERT(pAgent);
        ASSERT(pAgent->m_ThreadID);
        if (pNot)
            pNot->AddRef();
        
        //  APPCOMPAT: Even when we succeed here, there are chances that we won't
        //  get updated because CONTROLLER CAN FAIL TO INITIALIZE AND WE DON'T
        //  KNOW IT!
        if (!PostThreadMessage(pAgent->m_ThreadID, UM_ONREQUEST,0,(LPARAM)pNot))
        {
            hr = E_FAIL;
            SAFERELEASE(pNot);
            DBG("Failed to post ONREQUEST message.");
        }
        pAgent = NULL;
    }
//    DBG("UpdateRequest ended");
    return (DWORD)hr;
}

HRESULT UpdateNotifyReboot(void)
{
    DBG("UpdateNotifyReboot entered");

    HRESULT hr;
    CUpdateAgent * pAgent = NULL;

    hr = GetActiveUpdateAgent(&pAgent);
    if (SUCCEEDED(hr))  {
        ASSERT(pAgent);
        ASSERT(pAgent->m_ThreadID);

        hr = PostThreadMessage(pAgent->m_ThreadID, UM_NEEDREBOOT, 0, 0);
    }

    DBG("UpdateNotifyReboot ended");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\trkcache.cpp ===
// 
// Pei-Hwa Lin (peiwhal), Feb 3, 1997
//
//  Notes:
//   Compile switch : NO_FILE_WHEN_CREATE can turn on when wininet cache
//                    would create url cache entry if attached file is empty.
//                    LOG_CACHE_PATH will create log cache at the same level as
//                    content cache.
#include "private.h"

#undef TF_THISMODULE
#define TF_THISMODULE    TF_TRACKCACHE


#define MY_CACHE_FILE_ENTRY_SIZE     2048

const TCHAR c_szExt[] = TEXT("log");

//used for creating tracking container (registry)
const TCHAR c_szLogContainer[] = TEXT("Log");        // if you modify this, modify iedev\inc\inetreg.h REGSTR_PATH_TRACKING too.
const TCHAR c_szLogPrefix[] = TEXT("Log:");

const char  c_szLogContainerA[] = "Log";

// helper function
inline BOOL IsNumber(WCHAR x) { return (x >= L'0' && x <= L'9'); }

/*=============================================================================
 FILEFROMPATH returns the filename of given filename which may include path.
=============================================================================*/
LPTSTR FileFromPath( LPCTSTR lpsz )
{
   LPTSTR lpch;

   /* Strip path/drive specification from name if there is one */
   lpch = CharPrev( lpsz, lpsz + lstrlen(lpsz) );

   // special case for "http://server/domain/channel.cdf/"
   if (*lpch == '/') lpch = CharPrev( lpsz, lpch);

   while (lpch > lpsz)
   {
      if (*lpch == '/') {
         lpch = CharNext(lpch);
         break;
      }
      lpch = CharPrev( lpsz, lpch);
   }
   return(lpch);

} /* end FileFromPath */

// CDF updates, create new group and deal with previous posting information
void
CUrlTrackingCache :: Init(LPCWSTR pwszURL)
{
    DWORD   dwRetry;
    BSTR    bstrEncoding = NULL;

    _groupId = 0;
    _pwszPostUrl = NULL;
    _pszChannelUrlSite = NULL;
    _pszPostUrlSite = NULL;
    _pwszEncodingMethod = NULL;
    
    _groupId = CreateUrlCacheGroup(CACHEGROUP_FLAG_GIDONLY, NULL);

    WriteLONGLONG(_pCDFStartItem, c_szTrackingCookie, _groupId);

    // #54653: remove previous tracking information, if any
    if (SUCCEEDED(ReadBSTR(_pCDFStartItem, c_szPostHeader, &bstrEncoding)))
    {
        WriteEMPTY(_pCDFStartItem, c_szPostHeader);
        SAFEFREEBSTR(bstrEncoding);
    }

    if (SUCCEEDED(ReadDWORD(_pCDFStartItem, c_szPostingRetry, &dwRetry)))
        WriteEMPTY(_pCDFStartItem, c_szPostingRetry);

    DoBaseURL(pwszURL);
    return;
}

void
CUrlTrackingCache :: DoBaseURL(LPCWSTR pwszURL)
{
    DWORD  cbLen;    
    DWORD  useSecurity = 1;

    ASSERT(!_pszChannelUrlSite)

    cbLen = (lstrlenW(pwszURL)+1) * sizeof(WCHAR);
    _pszChannelUrlSite = (LPTSTR)MemAlloc( LPTR, cbLen);


#ifdef DEBUG

    HKEY hkey;

    // provide security switch for debugging
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                        MY_WEBCHECK_POST_REG,
                                        0,
                                        KEY_READ,
                                        &hkey))
    {
        DWORD cbsize = sizeof(DWORD);
        
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, 
                                        TEXT("PostSecurity"), 
                                        NULL, 
                                        NULL, 
                                        (LPBYTE)&useSecurity, 
                                        &cbsize))
        {
            if ((useSecurity == 0) && (NULL != _pszChannelUrlSite))
                StrCpy(_pszChannelUrlSite, TEXT("http://"));
        }
    }

#endif
    
    if ((useSecurity == 1) && (NULL != _pszChannelUrlSite))
    {
        MyOleStrToStrN(_pszChannelUrlSite, cbLen, pwszURL);
        *(FileFromPath( _pszChannelUrlSite )) = 0;
    }
    return;
}

// only track URLs come from the same server of Channel CDF or LogTarget URL
//
BOOL
CUrlTrackingCache :: IsValidURL(LPCTSTR lpszURL)
{
    BOOL    bret;

    if (!_pszChannelUrlSite || !_pszPostUrlSite)
        return FALSE;
       
    if (!StrCmpNI(lpszURL, _pszChannelUrlSite, lstrlen(_pszChannelUrlSite)))
        bret = TRUE;
    else if (!StrCmpNI(lpszURL, _pszPostUrlSite, lstrlen(_pszPostUrlSite)))
        bret = TRUE;
    else
        bret = FALSE;

    return bret;
}

#define LOG_CACHE_PATH
#ifdef LOG_CACHE_PATH
            
LPSTR PathPreviousBackslashA(LPSTR psz)
{
    LPSTR lpch = CharPrevA(psz, psz + lstrlenA(psz));
    for (; *lpch && *lpch != '\\'; lpch=CharPrevA(psz,lpch));
        
    return lpch;
}

//------------------------------------------------------------------------------
// GetCacheLocation
//
// Purpose:     Return the location of the logging cache
//    *****     GetUrlCacheConfigInfoW is yet implemented in wininet
//------------------------------------------------------------------------------
//
HRESULT GetCacheLocation
(
    LPTSTR  pszCacheLocation,
    DWORD   dwSize          // no. of chars in pszCacheLocation
)
{
    HRESULT hr = S_OK;
    DWORD dwLastErr;
    LPINTERNET_CACHE_CONFIG_INFOA lpCCI = NULL;
    DWORD dwCCISize = sizeof(INTERNET_CACHE_CONFIG_INFOA);
    BOOL fOnceErrored = FALSE;

    while (TRUE)
    {
        if ((lpCCI = (LPINTERNET_CACHE_CONFIG_INFOA)MemAlloc(LPTR,
                                                        dwCCISize)) == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        if (!GetUrlCacheConfigInfoA(lpCCI, &dwCCISize,
                                            CACHE_CONFIG_CONTENT_PATHS_FC))
        {
            if ((dwLastErr = GetLastError()) != ERROR_INSUFFICIENT_BUFFER  ||
                fOnceErrored)
            {
                hr = HRESULT_FROM_WIN32(dwLastErr);
                goto cleanup;
            }

            //
            // We have insufficient buffer size; reallocate a buffer with the
            //      new dwCCISize set by GetUrlCacheConfigInfo
            // Set fOnceErrored to TRUE so that we don't loop indefinitely
            //
            fOnceErrored = TRUE;
        }
        else
        {
            // 
            LPSTR pszPath = lpCCI->CachePaths[0].CachePath;
            INT iLen;

            PathRemoveBackslashA(pszPath);
            *(PathPreviousBackslashA(pszPath)) = 0;
            iLen = lstrlenA(pszPath) + sizeof(CHAR);        // + 1 is for the null char

            if ((((DWORD) iLen + ARRAYSIZE(c_szLogContainer) + 1) * sizeof(TCHAR)) < dwSize)
            {
                TCHAR szPathT[MAX_PATH];

                SHAnsiToTChar(pszPath, szPathT, ARRAYSIZE(szPathT));
                wnsprintf(pszCacheLocation, dwSize, TEXT("%s\\%s"), szPathT, c_szLogContainer);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }

            break;
        }

        SAFELOCALFREE(lpCCI);
        lpCCI = NULL;
    }

cleanup:
    if (lpCCI != NULL)
    {
        LocalFree(lpCCI);
    }

    return hr;
}
#endif
//-----------------------------------------------------------------------------
//
// ReadTrackingPrefix
//
// will create tracking container if current profile doesn't have one
// **** FindFirstUrlCacheContainerW is yet implemented in wininet
// **** FindNextUrlCacheContainerW is yet implemented either
//-----------------------------------------------------------------------------
LPTSTR
ReadTrackingPrefix(void)
{
    LPTSTR  lpPfx = NULL;

    DWORD   cbPfx = 0;
    struct {
        INTERNET_CACHE_CONTAINER_INFOA cInfo;
        CHAR  szBuffer[MAX_PATH+INTERNET_MAX_URL_LENGTH+1];
    } ContainerInfo;
    DWORD   dwModified, dwContainer;
    HANDLE  hEnum;
  
    dwContainer = sizeof(ContainerInfo);
    hEnum = FindFirstUrlCacheContainerA(&dwModified,
                                       &ContainerInfo.cInfo,
                                       &dwContainer,
                                       0);

    if (hEnum)
    {

        for (;;)
        {
            if (!StrCmpIA(ContainerInfo.cInfo.lpszName, c_szLogContainerA))
            {
                ASSERT(ContainerInfo.cInfo.lpszCachePrefix[0]);

                CHAR    szPfx[MAX_PATH];
                DWORD   cch = ARRAYSIZE(ContainerInfo.cInfo.lpszCachePrefix)+sizeof(CHAR);
                StrCpyNA(szPfx, ContainerInfo.cInfo.lpszCachePrefix, cch);

                cch *= sizeof(TCHAR);
                lpPfx = (LPTSTR)MemAlloc(LPTR, cch);
                if (!lpPfx)
                    SetLastError(ERROR_OUTOFMEMORY);

                SHAnsiToTChar(szPfx, lpPfx, cch);
                break;
            }

            dwContainer = sizeof(ContainerInfo);
            if (!FindNextUrlCacheContainerA(hEnum, &ContainerInfo.cInfo, &dwContainer))
            {
                if (GetLastError() == ERROR_NO_MORE_ITEMS)
                    break;
            }

        }

        FindCloseUrlCache(hEnum);
    }

    if (!lpPfx)
    {
        LPTSTR pszCachePath = NULL;
#ifdef LOG_CACHE_PATH
        TCHAR szCachePath[MAX_PATH];

        pszCachePath = (SUCCEEDED(GetCacheLocation(szCachePath, MAX_PATH))) ?
                                  szCachePath : NULL;
#endif

        if (CreateUrlCacheContainer(c_szLogContainer, 
                  c_szLogPrefix, 
                  pszCachePath, // wininet bug:if NULL, will create under ..\History\Log //
                  8192,       // dwCacheLimit,
                  INTERNET_CACHE_CONTAINER_NOSUBDIRS,          // dwContainerType,
                  0,          // dwOptions,
                  NULL,       // pvBuffer,
                  0           // cbBuffer
                    ))
        {
            return ReadTrackingPrefix();
        }
        // unable to create Log container, stop.
    }
     
    return lpPfx;
}

//-----------------------------------------------------------------------------
//
// ConvertToPrefixedUrl
//
// caller must release lplpPrefixedUrl
//-----------------------------------------------------------------------------
BOOL
CUrlTrackingCache :: ConvertToPrefixedUrl
(
    IN LPCTSTR lpUrl, 
    IN LPTSTR* lplpPrefixedUrl
)
{
    BOOL    bret = FALSE;

    ASSERT(lpUrl);
    if (!_lpPfx)
        _lpPfx = ReadTrackingPrefix();

    if (_lpPfx)
    {
        int len = lstrlen(lpUrl) + lstrlen(_lpPfx) + 1;
        
        *lplpPrefixedUrl = NULL;
        
        *lplpPrefixedUrl = (LPTSTR)MemAlloc(LPTR, len * sizeof(TCHAR));
        if (*lplpPrefixedUrl)
        {
            wnsprintf(*lplpPrefixedUrl, len, TEXT("%s%s"), _lpPfx, lpUrl);
            bret = TRUE;
        }
        else
            bret = FALSE;
    }

    return bret;
}

//-----------------------------------------------------------------------------
//
// RetrieveUrlCacheEntry
//
// caller must release lpCE
//-----------------------------------------------------------------------------
LPINTERNET_CACHE_ENTRY_INFO 
CUrlTrackingCache :: RetrieveUrlCacheEntry
(
    IN  LPCTSTR     lpUrl
)
{
    LPINTERNET_CACHE_ENTRY_INFO   lpCE = NULL;
    DWORD          cbSize;
    BOOL           bret = FALSE;

    lpCE = (LPINTERNET_CACHE_ENTRY_INFO)MemAlloc(LPTR, MY_MAX_CACHE_ENTRY_INFO);
    if (lpCE)
    {
        cbSize = MY_MAX_CACHE_ENTRY_INFO;
        while ((bret = GetUrlCacheEntryInfo(lpUrl, lpCE, &cbSize)) != TRUE)
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                SAFELOCALFREE(lpCE);

                lpCE = (LPINTERNET_CACHE_ENTRY_INFO)MemAlloc(LPTR, cbSize);
                if (!lpCE)
                   break;
            }
            else
                break;
        }
    }

    if (!bret && lpCE)
    {
        SAFELOCALFREE(lpCE);
        SetLastError(ERROR_FILE_NOT_FOUND);
    }

    return lpCE;
}

#define FILETIME_SEC   100000000
#define SECS_PER_DAY   (60 * 60 * 24)

DWORD WCTOI(LPCWSTR pwstr)
{
    DWORD   dw;
    int     len = lstrlenW(pwstr);

    dw = 0;
    for (int i = 0; i<len; i++)
    {
        if (!IsNumber(pwstr[i]))
            break;

        dw = dw * 10 + (pwstr[i] - L'0');
    }

    if (dw == 0) dw = 24;
    return dw;
}

//-----------------------------------------------------------------------------
//
// CreatePrefixedCacheEntry
//
// Create cache entry in Tracking cache bucket
//-----------------------------------------------------------------------------
#ifdef NO_FILE_WHEN_CREATE
HRESULT CreateLogCacheEntry
(
    LPCTSTR  lpPfxUrl, 
    FILETIME ftExpire, 
    FILETIME ftModified,
    DWORD    CacheEntryType
)
{
    TCHAR   lpFile[MAX_PATH];
    BOOL    bret;
    HRESULT hr = E_FAIL;

    if (CreateUrlCacheEntry(lpPfxUrl, MY_CACHE_FILE_ENTRY_SIZE, c_szExt, lpFile, 0))
    {
        lpFile[0] = '\0';
        bret = CommitUrlCacheEntry(lpPfxUrl,
                                   lpFile, 
                                   ftExpire, 
                                   ftModified, 
                                   CacheEntryType,
                                   NULL,
                                   0,
                                   NULL,
                                   0);

        hr = bret ? S_OK : E_FAIL;
    }

    return hr;
}
#else
HRESULT CreateLogCacheEntry
(
    LPCTSTR  lpPfxUrl, 
    FILETIME ftExpire, 
    FILETIME ftModified,
    DWORD    CacheEntryType
)
{
    TCHAR   lpFile[MAX_PATH];
    HRESULT hr = E_FAIL;
    DWORD      cbSize;

    if (CreateUrlCacheEntry(lpPfxUrl, MY_CACHE_FILE_ENTRY_SIZE, c_szExt, lpFile, 0))
    {
        HANDLE hFile = CreateFile(lpFile,
                                    GENERIC_READ|GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            return hr;
              
        // note: wininet will not create the entry if file size equals to zero
//            WriteFile(hFile, c_szLogFields, g_ccLogFields, &cbSize, NULL);

        WriteFile(hFile, c_szEmptyLog, c_ccEmptyLog, &cbSize, NULL);
        CloseHandle(hFile);

        return (CommitUrlCacheEntry(lpPfxUrl, 
                                   lpFile, 
                                   ftExpire, 
                                   ftModified, 
                                   CacheEntryType,
                                   NULL,
                                   0,
                                   NULL,
                                   0)) ? S_OK : E_FAIL;
    }

    return hr;
}
#endif

HRESULT
CUrlTrackingCache :: CreatePrefixedCacheEntry
(
    IN LPCTSTR lpPfxUrl
)
{
    HRESULT     hr = E_FAIL;
    LPINTERNET_CACHE_ENTRY_INFO    lpCE = NULL;
    FILETIME    ftModified;

    // IE50: due to change to wininet cache group enumeration, now we save our filter
    // information _groupId along with each cache entry itself.  the wininet url cache
    // no longer maintain this for us
    ftModified.dwHighDateTime = (DWORD)(_groupId >> 32);
    ftModified.dwLowDateTime = (DWORD)(0x00000000ffffffff & _groupId);

    lpCE = RetrieveUrlCacheEntry(lpPfxUrl);
    if (lpCE ) 
    {
        // exist in Tracking bucket, set tracking flag
        // IE50: save _groupId info in LastModifiedTime
        lpCE->CacheEntryType |= _ConnectionScope;
        lpCE->LastModifiedTime.dwHighDateTime = ftModified.dwHighDateTime;
        lpCE->LastModifiedTime.dwLowDateTime = ftModified.dwLowDateTime;

        ASSERT(SetUrlCacheEntryInfo(lpCE->lpszSourceUrlName, lpCE, 
                             CACHE_ENTRY_ATTRIBUTE_FC | CACHE_ENTRY_MODTIME_FC) == TRUE);
        hr = S_OK;
    }
    else
    //FILE_NOT_FOUND, create it.
    {
        LONGLONG llExpireHorizon;     
        SYSTEMTIME  st;
        FILETIME ftMod, ftExpire;

        llExpireHorizon = (LONGLONG)(SECS_PER_DAY * _dwPurgeTime / 24);

        GetLocalTime(&st);
        SystemTimeToFileTime(&st, &ftMod);

        llExpireHorizon *= FILETIME_SEC;
        ftExpire.dwLowDateTime = ftMod.dwLowDateTime + (DWORD)(llExpireHorizon % 0xFFFFFFFF);
        ftExpire.dwHighDateTime = ftMod.dwHighDateTime + (DWORD)(llExpireHorizon / 0xFFFFFFFF);

        hr = CreateLogCacheEntry(lpPfxUrl, ftExpire, ftModified, _ConnectionScope);

    }
        
    SAFELOCALFREE(lpCE);

    return hr;
}

HRESULT
CUrlTrackingCache :: AddToTrackingCacheEntry
(
    IN LPCWSTR  pwszUrl
)
{
    HRESULT     hr = E_OUTOFMEMORY;
    TCHAR       szCanonicalUrl[MAX_URL];
    DWORD       dwSize = MAX_URL;
    LPTSTR      lpUrl = NULL;
    LPTSTR      lpPfxUrl = NULL;
    DWORD       cbSize;
    PROPVARIANT vProp = {0};

    if (pwszUrl == NULL)
        return E_INVALIDARG;

    cbSize = lstrlenW(pwszUrl) + 1;
    lpUrl = (LPTSTR)MemAlloc(LPTR, cbSize * sizeof(TCHAR));
    if (!lpUrl)
        return hr;

    SHUnicodeToTChar(pwszUrl, lpUrl, cbSize);
    if (!IsValidURL(lpUrl))
    {
        MemFree(lpUrl);
        return E_INVALIDARG;
    }        

    // canonicalize URL
    InternetCanonicalizeUrl(lpUrl, szCanonicalUrl, &dwSize, ICU_DECODE);
    SAFELOCALFREE(lpUrl);
    ConvertToPrefixedUrl(szCanonicalUrl, &lpPfxUrl);
    if (!lpPfxUrl)
    {
        return hr;
    }

    hr = CreatePrefixedCacheEntry(lpPfxUrl);
    if (SUCCEEDED(hr))
    {
        // exist in Tracking bucket, set tracking flag.
        vProp.vt = VT_UI4;
        vProp.ulVal = _ConnectionScope;
        hr = IntSiteHelper(szCanonicalUrl, &c_rgPropRead[PROP_TRACKING], &vProp, 1, TRUE);
        PropVariantClear( &vProp );        
    }

    SAFELOCALFREE(lpPfxUrl);
    return hr;
}

//-----------------------------------------------------------------------------
//
// SchedulePostAgent
//
//  This routine will schedule post agent to upload tracking data
//-----------------------------------------------------------------------------
HRESULT
CUrlTrackingCache :: SchedulePostAgent(void)
{
    return E_NOTIMPL;
}


//-----------------------------------------------------------------------------
//
// OnProcessDone
//
//-----------------------------------------------------------------------------

// called by CDF agent
// fill information in item that Post agent would need to work
HRESULT
CUrlTrackingCache :: OnProcessDone
(
)
{
    return E_NOTIMPL;
}


//-----------------------------------------------------------------------------
//
// Process log related tags
//
//-----------------------------------------------------------------------------
//
// <LOGTARGET href="http://foo.htm" SCOPE="ALL"/>
//  <HTTP-EQUIV name="Encoding-type" value="gzip" />
//  <PurgeTime HOUR="12" />
// </Logtarget>
//
HRESULT
CUrlTrackingCache :: ProcessTrackingInLog
(
    IXMLElement     *pTracking
)
{

    HRESULT hr;
    LPWSTR  pwszScope = NULL;
    
    if (_pwszPostUrl)
        return S_OK;        // there are more than 1 logtarget, take whatever first was read

    hr = ReadAttribute(pTracking, L"HREF", &_pwszPostUrl);       // must exist to enalbe logging
    if (FAILED(hr))
        return hr;

    // fill it in item for post agent
    WriteOLESTR(_pCDFStartItem, c_szTrackingPostURL, _pwszPostUrl);

    // #41460: add 2nd domain allowing tracking to
    DWORD   cbLen = (lstrlenW(_pwszPostUrl)+1) * sizeof(WCHAR);
    _pszPostUrlSite = (LPTSTR)MemAlloc( LPTR, cbLen);
    MyOleStrToStrN(_pszPostUrlSite, cbLen, _pwszPostUrl);
    *(FileFromPath( _pszPostUrlSite )) = 0;


    _ConnectionScope = TRACK_ONLINE_CACHE_ENTRY | TRACK_OFFLINE_CACHE_ENTRY;
    hr = ReadAttribute(pTracking, L"SCOPE", &pwszScope);
    if (SUCCEEDED(hr))
    {     
        if (!StrCmpIW(pwszScope, L"OFFLINE"))
            _ConnectionScope = TRACK_OFFLINE_CACHE_ENTRY;            
        else if (!StrCmpIW(pwszScope, L"ONLINE"))                    
            _ConnectionScope = TRACK_ONLINE_CACHE_ENTRY;

        SAFELOCALFREE(pwszScope);
    }

    RunChildElement(pTracking);

    // #42687: save purgetime to item and used later by post agent
    if (_pwszPurgeTime)     // if not specify, default is 24 hours
    {
        _dwPurgeTime = WCTOI(_pwszPurgeTime);
    }

    DATE        dt = 0.0;
    SYSTEMTIME  st;

    GetLocalTime(&st);
    SystemTimeToVariantTime(&st, &dt);
    dt += ((DATE)_dwPurgeTime/24);
#ifdef DEBUG
    VariantTimeToSystemTime(dt, &st);
#endif
    WriteDATE(_pCDFStartItem, c_szPostPurgeTime, &dt);

    return S_OK;    
}

//-----------------------------------------------------------------------------
//
// ProcessTrackingItems
//  <Item href="http://foo">
//    <Log value="document:view"/>
//  </Item>
// or <Item>
//    <A href="http://foo" />
//  </Item>
//  This routine will setup tracking cache entries for all URLs which are
//  specified in CDF file to track.  All URLs entries belong to same channel 
//  are created in same cache group
//-----------------------------------------------------------------------------
HRESULT
CUrlTrackingCache :: ProcessTrackingInItem
(
    IXMLElement     *pItem,                 //point to <Item> tag
    LPCWSTR         pwszUrl,                //absolute URL for item
    BOOL            fForceLog               //global log flag
)
{
    HRESULT hr = S_OK;

    _bTrackIt = fForceLog;

    if (!_bTrackIt)
        hr = RunChildElement(pItem);

    if (SUCCEEDED(hr) && _bTrackIt)
        hr = AddToTrackingCacheEntry(pwszUrl);
    
    return (_bTrackIt) ? S_OK : E_FAIL;        // #42604: global logging, report if this item needs logged
}

HRESULT
CUrlTrackingCache :: RunChildElement
(
    IXMLElement* pElement
)
{
    IXMLElementCollection *pCollection;
    long        lIndex = 0;
    long        lMax;
    VARIANT     vIndex, vEmpty;
    IDispatch   *pDisp;
    IXMLElement *pItem;
    BSTR        bstrTagName;
    HRESULT     hr = E_FAIL;

    if (SUCCEEDED(pElement->get_children(&pCollection)) && pCollection)
    {
        if (SUCCEEDED(pCollection->get_length(&lMax)))
        {
            vEmpty.vt = VT_EMPTY;

            for (; lIndex < lMax; lIndex++)
            {
                vIndex.vt = VT_UI4;
                vIndex.lVal = lIndex;

                if (SUCCEEDED(pCollection->item(vIndex, vEmpty, &pDisp)))
                {
                    if (SUCCEEDED(pDisp->QueryInterface(IID_IXMLElement, (void **)&pItem)))
                    {
                        if (SUCCEEDED(pItem->get_tagName(&bstrTagName)) && bstrTagName)
                        {
                            hr = ProcessItemInEnum(bstrTagName, pItem);
                            SysFreeString(bstrTagName);
                        }
                        pItem->Release();
                    }
                    pDisp->Release();
                }
            }

        }
        pCollection->Release();
    }

    return hr;
}

HRESULT
CUrlTrackingCache :: ProcessItemInEnum
(
    LPCWSTR pwszTagName, 
    IXMLElement *pItem
)
{
    HRESULT hr;
    LPWSTR  pwszName = NULL;

    if (!StrCmpIW(pwszTagName, L"HTTP-EQUIV"))
    {
        DBG("CUrlTrackingCache processing HTTP-EQUIV");
        
        hr = ReadAttribute(pItem, L"NAME", &pwszName);
        if (SUCCEEDED(hr) && !StrCmpIW(pwszName, L"ENCODING-TYPE"))
        {
            hr = ReadAttribute(pItem, L"VALUE", &_pwszEncodingMethod);
            if (SUCCEEDED(hr) && *_pwszEncodingMethod)
                WriteOLESTR(_pCDFStartItem, c_szPostHeader, _pwszEncodingMethod);
        }        
        
        SAFELOCALFREE(pwszName);
    }
    else if (!StrCmpIW(pwszTagName, L"PURGETIME"))
    {
        DBG("CUrlTrackingCache processing PurgeTime");

        return ReadAttribute(pItem, L"HOUR", &_pwszPurgeTime);
    }
    else if (!StrCmpIW(pwszTagName, L"LOG"))
    {
        DBG("CUrlTrackingCache processing Log");
        
        hr = ReadAttribute(pItem, L"VALUE", &pwszName);
        if (SUCCEEDED(hr))
            _bTrackIt = (!StrCmpIW(pwszName, L"document:view")) ? TRUE : FALSE;

        SAFELOCALFREE(pwszName);
    }

    return S_OK;
}

HRESULT
CUrlTrackingCache :: ReadAttribute
(
    IN  IXMLElement* pItem,
    IN  LPCWSTR      pwszAttributeName,
    OUT LPWSTR*      pwszAttributeValue
)
{
    VARIANT vProp;
    BSTR    bstrName = NULL;
    HRESULT hr = E_FAIL;
    DWORD   dwLen;

    vProp.vt = VT_EMPTY;
    
    bstrName = SysAllocString(pwszAttributeName);

    if (bstrName && SUCCEEDED(pItem->getAttribute(bstrName, &vProp)))
    {
        if (vProp.vt == VT_BSTR)
        {
            dwLen = sizeof(WCHAR) * (lstrlenW(vProp.bstrVal) + 1);
            *pwszAttributeValue = (LPWSTR)MemAlloc(LPTR, dwLen);
            if (*pwszAttributeValue)
            {
                StrCpyW(*pwszAttributeValue, vProp.bstrVal);
                hr = S_OK;
            }

            VariantClear(&vProp);
        }
    }

    SysFreeString(bstrName);

    return hr;
}


//--------------------------------------------------------------------------
//
// CUrlTrackingCache
//
//--------------------------------------------------------------------------
CUrlTrackingCache::CUrlTrackingCache
(
    ISubscriptionItem *pCDFItem,
    LPCWSTR pwszURL
)
{
    _lpPfx = NULL;
    _dwPurgeTime = 24;
    _pCDFStartItem = pCDFItem;

    ASSERT(_pCDFStartItem);
    _pCDFStartItem->AddRef();

    Init(pwszURL);
        
}

CUrlTrackingCache::~CUrlTrackingCache()
{

    SAFEFREEOLESTR(_pwszPostUrl);
    SAFEFREEOLESTR(_pwszEncodingMethod);
    SAFEFREEOLESTR(_pwszPurgeTime);

    SAFELOCALFREE(_pszChannelUrlSite);
    SAFELOCALFREE(_pszPostUrlSite);
    SAFELOCALFREE(_lpPfx);
         
    SAFERELEASE(_pCDFStartItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\updateui.cpp ===
#include "private.h"
#include "offline.h"
#include "updateui.h"

//xnotfmgr - most of this file can probably get nuked

#define MAX_CAPTION     128

#undef  TF_THISMODULE
#define TF_THISMODULE   TF_UPDATEAGENT

typedef CLSID   COOKIE, *PCOOKIE;

#define SUBITEM_SIZE    4
#define SUBITEM_URL     3
#define SUBITEM_STATUS  2
#define SUBITEM_IMAGE   1

ColInfoType colDlg[] = {
    {0, IDS_NAME_COL,   30, LVCFMT_LEFT},
    {1, 0,              3,  LVCFMT_LEFT}, 
    {2, IDS_STATUS_COL, 10, LVCFMT_LEFT},
    {3, IDS_URL_COL,    40, LVCFMT_LEFT},
    {4, IDS_SIZE_COL,   7,  LVCFMT_RIGHT}
};

#define ILI_SUCCEEDED       0
#define ILI_FAILED          1
#define ILI_UPDATING        2
#define ILI_PENDING         3
#define ILI_SKIPPED         4
#define ILI_SITE            5
#define ILI_CHANNEL         6
#define ILI_DESKTOP         7

const int g_aIconResourceID[] = {
        IDI_STAT_SUCCEEDED,
        IDI_STAT_FAILED, 
        IDI_STAT_UPDATING,
        IDI_STAT_PENDING, 
        IDI_STAT_SKIPPED,
        IDI_WEBDOC,
        IDI_CHANNEL,
        IDI_DESKTOPITEM
};

#define MAX_DLG_COL     ARRAYSIZE(colDlg)

//struct for saving window state in registry
typedef struct _PROG_PERSIST_STATE
{
    short cbSize;
    char bDetails;
    char bAdjustWindowPos;
    RECT rWindow;
    int colOrder [MAX_DLG_COL];
    int colWidth [MAX_DLG_COL];
} PROG_PERSIST_STATE;
extern void ResizeDialog(HWND hDlg, BOOL bShowDetail);  //in update.cpp

const TCHAR c_szProgressWindowSettings[] = TEXT("Progress Preferences");

const UINT CookieSeg = 32;

CCookieItemMap::CCookieItemMap()
{
    _map = NULL;
}

CCookieItemMap::~CCookieItemMap()
{
    SAFELOCALFREE (_map);
}

STDMETHODIMP CCookieItemMap::Init(UINT size)
{
    //  Free old junk.
    SAFELOCALFREE (_map);

    _lParamNext = 0;
    _count = 0;

    if (size == 0)
        _capacity = CookieSeg;
    else
        _capacity = size;


    _map = (CookieItemMapEntry * )MemAlloc(LPTR, sizeof (CookieItemMapEntry) * _capacity);
    if (!_map)  {
        DBG("Failed to allocate memory");
        _capacity = 0;
        return E_OUTOFMEMORY;
    }

    
    return S_OK;
}

STDMETHODIMP CCookieItemMap::ResetMap(void)
{
    _count = 0;
    return S_OK;
}

STDMETHODIMP CCookieItemMap::FindCookie(LPARAM lParam, CLSID * pCookie)
{
    ASSERT(pCookie);

    UINT    i;
    for (i = 0; i < _count; i ++)   {
        if (_map[i]._id == lParam)    {
            * pCookie = _map[i]._cookie;
            return S_OK;
        }
    }

    *pCookie = CLSID_NULL;
    return E_FAIL;
}

STDMETHODIMP CCookieItemMap::FindLParam(CLSID * pCookie, LPARAM * pLParam)
{
    ASSERT(pCookie && pLParam);

    UINT    i;
    for (i = 0; i < _count; i ++)   {
        if (_map[i]._cookie == *pCookie)    {
            * pLParam = _map[i]._id;
            return S_OK;
        }
    }

    *pLParam = (LPARAM)-1;
    return E_FAIL;
}

STDMETHODIMP CCookieItemMap::AddCookie(CLSID * pCookie, LPARAM * pLParam)
{
    HRESULT hr = FindLParam(pCookie, pLParam);
    if (S_OK == hr)
        return S_FALSE;

    ASSERT(_count <= _capacity);
    ASSERT(CookieSeg);

    if (_count == _capacity)   {
        UINT    newSize = CookieSeg + _capacity;
        void * newBuf = MemReAlloc(_map, newSize * sizeof(CookieItemMapEntry), LHND);

        if (!newBuf)    {
            DBG("AddCookie::Failed to reallocate buffer");
            return E_OUTOFMEMORY;
        }

        _map = (CookieItemMapEntry *)newBuf;
        _capacity = newSize;
    }

    _map[_count]._cookie = *pCookie;
    _map[_count]._id = _lParamNext;
    _count ++;

    *pLParam = _lParamNext;
    _lParamNext ++;
    return S_OK;
}

STDMETHODIMP CCookieItemMap::DelCookie(CLSID * pCookie)
{
    ASSERT(pCookie);

    UINT    i;
    for (i = 0; i < _count; i ++)   {
        if (_map[i]._cookie == *pCookie)    {
            if (i == (_count - 1))  {
                _count --;
                return S_OK;
            } else  {
                _count --;
                _map[i]._cookie = _map[_count]._cookie;
                _map[i]._id = _map[_count]._id;
                return S_OK;
            }
        }
    }

    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
// Other members
//

int CALLBACK CUpdateDialog::SortUpdatingToTop  (LPARAM lParam1,
                                                LPARAM lParam2,
                                                LPARAM lParamSort)
{
    //lparams are cookies; lparamsort is source object
    CUpdateDialog * pUpdater = (CUpdateDialog*)lParamSort;
    if (!pUpdater)
        return 0;
    if (!pUpdater->m_pController)
        return 0;

    CLSID cookie;
    pUpdater->cookieMap.FindCookie (lParam1, &cookie);
    PReportMap pEntry1 = pUpdater->m_pController->FindReportEntry (&cookie);
    pUpdater->cookieMap.FindCookie (lParam2, &cookie);
    PReportMap pEntry2 = pUpdater->m_pController->FindReportEntry (&cookie);
    
    //in progress precedes all else
    if (pEntry1->status == ITEM_STAT_UPDATING)
        return (pEntry2->status == ITEM_STAT_UPDATING ? 0 : -1);

    if (pEntry2->status == ITEM_STAT_UPDATING)
        return 1;

    //queued precedes succeeded or skipped
    if (pEntry1->status == ITEM_STAT_QUEUED || pEntry1->status == ITEM_STAT_PENDING)
        return ((pEntry2->status == ITEM_STAT_QUEUED
              || pEntry2->status == ITEM_STAT_PENDING) ? 0 : -1);

    if (pEntry2->status == ITEM_STAT_QUEUED || pEntry2->status == ITEM_STAT_PENDING)
        return 1;

    return 0;   //don't care
}


BOOL CUpdateDialog::SelectFirstUpdatingSubscription()
{
    LV_ITEM lvi = {0};
    lvi.iSubItem = SUBITEM_IMAGE;
    lvi.mask = LVIF_IMAGE;

    int cItems = ListView_GetItemCount (m_hLV);
    for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
    {
        ListView_GetItem (m_hLV, &lvi);
        if (lvi.iImage == ILI_UPDATING)
        {
            ListView_SetItemState (m_hLV, lvi.iItem, LVIS_SELECTED, LVIS_SELECTED);
            return TRUE;
        }
    }

    return FALSE;
}


DWORD CUpdateDialog::SetSiteDownloadSize (PCOOKIE pCookie, DWORD dwNewSize)
{
    //returns previous size, for bookkeeping purposes
    HRESULT             hr;

    TCHAR               szKSuffix[10];
    //  Need enough room for DWORD as string + K suffix
    TCHAR               szBuf[ARRAYSIZE(szKSuffix) + 11];

    if (dwNewSize == -1)            //shouldn't happen anymore but if it does,
        return -1;                  //deal gracefully

    ASSERT(pCookie);
    LPARAM itemParam;
    hr = cookieMap.FindLParam(pCookie, &itemParam);
    if (S_OK != hr)
    {
        return dwNewSize;
    }

    LV_ITEM     lvi = {0};
    LV_FINDINFO lvfi = {0};

    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = itemParam;

    lvi.iItem = ListView_FindItem(m_hLV, -1, &lvfi);
    if (lvi.iItem == -1)
        return dwNewSize;

    lvi.iSubItem = SUBITEM_SIZE;
    lvi.mask = LVIF_TEXT;
    lvi.pszText = szBuf;
    lvi.cchTextMax = sizeof(szBuf);

    ListView_GetItem(m_hLV, &lvi);
    DWORD dwOldSize = StrToInt (szBuf);

    MLLoadString (IDS_SIZE_KB, szKSuffix, ARRAYSIZE(szKSuffix));
    wnsprintf (szBuf, ARRAYSIZE(szBuf), "%d%s", dwNewSize, szKSuffix);
    ListView_SetItem(m_hLV, &lvi);

    return dwOldSize;
}


//  This method is actually called from the second thread(only). So far
//  I haven't found any sync problem yet. We only change the internal state
//  of this object after it's creation in this method, so we won't mess
//  it up. About UI, there is a chance when we try to disable 'Skip'
//  button, we may come across another request from the primary thread. Since
//  these 2 requests are both designated to disable the button, it won't
//  matter anyway.

STDMETHODIMP CUpdateDialog::RefreshStatus(PCOOKIE pCookie, LPTSTR name, STATUS newStat, LPTSTR extraInfo)
{
    HRESULT             hr;
    TCHAR               szBuf[MAX_URL];
    
    ASSERT(pCookie);
    LPARAM itemParam;
    hr = cookieMap.FindLParam(pCookie, &itemParam);
    if (S_OK != hr) {
        if (name)  {
            hr = AddItem(pCookie, name, newStat);
            if (S_OK != hr) {
                return E_FAIL;
            }
            hr = cookieMap.FindLParam(pCookie, &itemParam);
            if (S_OK != hr) {
                ASSERT(0);
                return E_FAIL;
            }
        } else  {
            return hr;
        }
    }

    LV_ITEM     lvi = {0};
    LV_FINDINFO lvfi = {0};

    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = itemParam;

    lvi.iItem = ListView_FindItem(m_hLV, -1, &lvfi);
    if (lvi.iItem == -1)
        return E_FAIL;

    lvi.iSubItem = SUBITEM_STATUS;
    lvi.mask = LVIF_TEXT;
    
    ASSERT ((UINT)newStat <= ITEM_STAT_ABORTED);
    if (newStat == ITEM_STAT_UPDATING && extraInfo != NULL) //url available, use it
    {
        TCHAR szFormat[MAX_URL];
        MLLoadString (IDS_ITEM_STAT_UPDATING_URL, szFormat, ARRAYSIZE(szFormat));
        wnsprintf (szBuf, ARRAYSIZE(szBuf), szFormat, extraInfo);
    }
    else
    {
        MLLoadString(IDS_ITEM_STAT_IDLE + newStat, szBuf, ARRAYSIZE(szBuf));
    }

    lvi.pszText = szBuf;
    ListView_SetItem(m_hLV, &lvi);

    lvi.iSubItem = SUBITEM_IMAGE;
    lvi.mask = LVIF_IMAGE;
    
    switch (newStat)  {
        case ITEM_STAT_QUEUED:
        case ITEM_STAT_PENDING:
            lvi.iImage = ILI_PENDING;
            break;
        case ITEM_STAT_UPDATING:
            lvi.iImage = ILI_UPDATING;
            //move to top of list -- t-mattgi
            //this happens in sort callback function -- just force resort
            //after we update the LV control
            break;
        case ITEM_STAT_SUCCEEDED:
            lvi.iImage = ILI_SUCCEEDED;
            if (ListView_GetItemState(m_hLV, lvi.iItem, LVIS_SELECTED))
                Button_Enable(GetDlgItem(m_hDlg, IDCMD_SKIP), FALSE);
            break;
        case ITEM_STAT_SKIPPED:
            if (ListView_GetItemState(m_hLV, lvi.iItem, LVIS_SELECTED))
                Button_Enable(GetDlgItem(m_hDlg, IDCMD_SKIP), FALSE);
            lvi.iImage = ILI_SKIPPED;
            break;
        default:
            lvi.iImage = ILI_FAILED;
            break;
    }
    ListView_SetItem(m_hLV, &lvi);

    //force resort since item statuses changed
    ListView_SortItems (m_hLV, SortUpdatingToTop, this);

    return hr;
}

CUpdateDialog::CUpdateDialog()
{
    m_bInitialized = FALSE;
}

CUpdateDialog::~CUpdateDialog()
{
}

STDMETHODIMP CUpdateDialog::CleanUp()
{
    if (! m_ThreadID || !m_bInitialized)
        return S_OK;

    if (m_hDlg)
    {
        PersistStateToRegistry (m_hDlg);

        DestroyWindow(m_hDlg);
        m_hDlg = NULL;
    }
    PostThreadMessage(m_ThreadID, WM_QUIT, 0, 0);
    return S_OK;
}

STDMETHODIMP CUpdateDialog::Init(HWND hParent, CUpdateController * pController)
{
    ASSERT(m_ThreadID);
    ASSERT(g_hInst);
    ASSERT(pController);
    if (m_bInitialized) {
        ASSERT(0);
        return S_FALSE;
    }

    if (FAILED(cookieMap.Init()))
        return E_FAIL;

    HWND hDlg, hLV;

    m_pController = pController;
    hDlg = CreateDialogParam(MLGetHinst(), MAKEINTRESOURCE(IDD_PROGRESS), hParent, UpdateDlgProc, (LPARAM)this);
    if (!hDlg)
        return E_FAIL;

    hLV = GetDlgItem(hDlg, IDL_SUBSCRIPTION);
    if (!hLV)   {
        EndDialog(hDlg, FALSE);
        return E_FAIL;
    }

    HIMAGELIST  hImage;
    HICON       hIcon;

    hImage = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                              GetSystemMetrics(SM_CXSMICON),
                              ILC_MASK,    
                              ARRAYSIZE(g_aIconResourceID),
                              0);

    if (hImage == NULL) {
        TraceMsg(TF_ALWAYS, TEXT("CUpdateDialog::Init - Failed to create ImageList"));
        return E_FAIL;
    }

    for (int i = 0; i < ARRAYSIZE(g_aIconResourceID); i ++) {
        if (g_aIconResourceID[i] == IDI_DESKTOPITEM)
        {
            hinstSrc = MLGetHinst();
        }
        else
        {
            hinstSrc = g_hInst;
        }
        
        hIcon = LoadIcon(hinstSrc, MAKEINTRESOURCE(g_aIconResourceID[i]));
        if (hIcon == NULL)  {
            ImageList_Destroy(hImage);
            DBG("CUpdateDialog::Init - Failed to load icon");
            return E_FAIL;
        }
        ImageList_AddIcon(hImage, hIcon);
        DestroyIcon(hIcon);
    }
                            
    ListView_SetImageList(hLV, hImage, LVSIL_SMALL);

    LV_COLUMN   lvc;
    TEXTMETRIC  tm;
    HDC         hdc;

    hdc = GetDC(hDlg);
    if (!hdc)   {
        EndDialog(hDlg, FALSE);
        return E_FAIL;
    }
    GetTextMetrics(hdc, &tm);
    ReleaseDC(hDlg, hdc);

    lvc.mask = LVCF_WIDTH | LVCF_TEXT | LVCF_FMT;

    PROG_PERSIST_STATE state;
    GetPersistentStateFromRegistry(state, tm.tmAveCharWidth);
    
    for (UINT ui = 0; ui < MAX_DLG_COL; ui ++)
    {
        int colIndex;

        TCHAR   szCaption[MAX_CAPTION];
        if (colDlg[ui].ids)
            MLLoadString(colDlg[ui].ids, szCaption, MAX_CAPTION);
        else
            szCaption[0] = (TCHAR)0;

        lvc.pszText = szCaption;
        lvc.cx = state.colWidth[ui];
        lvc.fmt = colDlg[ui].iFmt;
        colIndex = ListView_InsertColumn(hLV, ui, & lvc);
        if ( -1 == colIndex)    {
            ASSERT(0);
            EndDialog(hDlg, FALSE);
            return E_FAIL;
        }
    }

    ListView_SetColumnOrderArray(hLV, MAX_DLG_COL, state.colOrder);

    SendMessage (hLV, LVM_SETEXTENDEDLISTVIEWSTYLE,
        LVS_EX_HEADERDRAGDROP | LVS_EX_SUBITEMIMAGES,
        LVS_EX_HEADERDRAGDROP | LVS_EX_SUBITEMIMAGES);

    SendMessage (hDlg, WM_SETICON, ICON_BIG, (LPARAM)LoadIcon (g_hInst, MAKEINTRESOURCE (IDI_DOWNLOAD)));
    SendMessage (hDlg, WM_SETICON, ICON_SMALL, (LPARAM)LoadIcon (g_hInst, MAKEINTRESOURCE (IDI_DOWNLOAD)));

    if (state.bAdjustWindowPos)
    {
        //adjust size of *details view* to stored state; if we're not in
        //details view, we have to go there temporarily.  (The non-details
        //view will pick up the position from the details view when we switch back.)
        m_bDetail = TRUE;
        ResizeDialog (hDlg, m_bDetail);

        //don't move dialog, just resize it and center it
        //convert right, bottom coordinates to width, height
        state.rWindow.right -= state.rWindow.left;
        state.rWindow.bottom -= state.rWindow.top;
        //calculate left, top to center dialog
        state.rWindow.left = (GetSystemMetrics (SM_CXSCREEN) - state.rWindow.right) / 2;
        state.rWindow.top = (GetSystemMetrics (SM_CYSCREEN) - state.rWindow.bottom) / 2;
        MoveWindow (hDlg, state.rWindow.left, state.rWindow.top,
                    state.rWindow.right, state.rWindow.bottom, TRUE);

        //REVIEW: this centers the details view, then if they don't want details,
        //leaves the small dialog with its upper left where the upper left of the
        //big dialog is when it's centered.  I could center it in whatever view
        //it's really in, but if the details view is resized to a fairly large window
        //and we bring it up centered in non-details, then when they click details
        //the position will be the same and the window will potentially extend offscreen
        //to the right and bottom.

        //set back to non-details view if that was how it was last used
        if (!state.bDetails)
        {
            m_bDetail = state.bDetails;
            ResizeDialog (hDlg, m_bDetail);
        }
    }
    
    m_bInitialized = TRUE;
    m_hDlg = hDlg;
    m_hLV  = hLV;
    m_hParent = hParent;
    m_cDlKBytes = 0;
    m_cDlDocs = 0;

    return S_OK;
}


BOOL CUpdateDialog::PersistStateToRegistry (HWND hDlg)
{
    PROG_PERSIST_STATE state;

    state.cbSize = sizeof(state);
    state.bDetails = m_bDetail;
    state.bAdjustWindowPos = TRUE;
    //save position and size from *details view* -- if we're not there,
    //we'll have to switch temporarily.
    BOOL bTempDetail = m_bDetail;
    if (!bTempDetail)
    {
        ShowWindow (hDlg, SW_HIDE);
        m_bDetail = TRUE;
        ResizeDialog (hDlg, m_bDetail);
    }
    GetWindowRect (hDlg, &state.rWindow);
    if (!bTempDetail)
    {
        m_bDetail = FALSE;
        ResizeDialog (hDlg, m_bDetail);
        ShowWindow (hDlg, SW_SHOW);
    }

    HWND hLV = GetDlgItem (hDlg, IDL_SUBSCRIPTION);
    ListView_GetColumnOrderArray (hLV, MAX_DLG_COL, state.colOrder);
    for (int i=0; i<MAX_DLG_COL; i++)
        state.colWidth[i] = ListView_GetColumnWidth (hLV, i);

    HKEY key;
    DWORD dwDisposition;
    if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_CURRENT_USER, c_szRegKey, 0, NULL, REG_OPTION_NON_VOLATILE,
                                         KEY_WRITE, NULL, &key, &dwDisposition))
        return FALSE;

    RegSetValueEx (key, c_szProgressWindowSettings, 0, REG_BINARY, (LPBYTE)&state, sizeof(state));

    RegCloseKey (key);

    return TRUE;
}

BOOL CUpdateDialog::GetPersistentStateFromRegistry (PROG_PERSIST_STATE& state, int iCharWidth)
{
    HKEY key;
    DWORD dwType;
    DWORD dwSize = sizeof(state);
    RegOpenKeyEx (HKEY_CURRENT_USER, c_szRegKey, 0, KEY_READ, &key);
    
    LONG result = RegQueryValueEx (key, c_szProgressWindowSettings,
            0, &dwType, (LPBYTE)&state, &dwSize);

    if (ERROR_SUCCESS != result || dwType != REG_BINARY || dwSize != sizeof(state))
    {
        state.cbSize = 0;       //flag as error
    }

    if (state.cbSize != sizeof(state))  //error or incorrect registry format/version
    {   //state not saved in registry; use defaults
        int i;

        state.bDetails = FALSE;
        state.bAdjustWindowPos = FALSE;

        state.colOrder[0] = 1;
        state.colOrder[1] = 0;
        for (i=2; i<MAX_DLG_COL; i++)
            state.colOrder[i] = i;

        for (i=0; i<MAX_DLG_COL; i++)
            state.colWidth[i] = colDlg[i].cchCol * iCharWidth;
    }

    RegCloseKey (key);
    return TRUE;
}


STDMETHODIMP CUpdateDialog::Show(BOOL bShow)
{
    if (!m_bInitialized)    {
        ASSERT(0);
        return E_FAIL;
    } 

    ASSERT(m_hDlg);

    ShowWindow(m_hDlg, (bShow)?SW_SHOW:SW_HIDE);
    ShowWindow(m_hLV, (bShow)?SW_SHOW:SW_HIDE);
    return NOERROR;
}

STDMETHODIMP CUpdateDialog::ResetDialog(void)
{
    if (!m_bInitialized)    {
        return S_OK;
    }

    ASSERT(m_hLV);
    ListView_DeleteAllItems(m_hLV);
    cookieMap.ResetMap();
    m_bInitialized = FALSE;

    return S_OK;
}

STDMETHODIMP CUpdateDialog::IItem2Cookie(const int iItem, CLSID * pCookie)
{
    LV_ITEM item = {0};
    HRESULT hr;
    ASSERT(pCookie);

    item.iItem = iItem;
    item.iSubItem = 0;
    item.mask = LVIF_PARAM;

    if (!ListView_GetItem(m_hLV, &item))    {
        return E_FAIL;
    }
    
    hr = cookieMap.FindCookie(item.lParam, pCookie);
    ASSERT(SUCCEEDED(hr));

    return hr;
}

STDMETHODIMP CUpdateDialog::GetSelectedCookies(CLSID * pCookies, UINT * pCount)
{
    if (!m_bInitialized)
        return E_INVALIDARG;
    
    ASSERT(pCookies && pCount);
    int     index = -1;

    *pCount = 0;

    index = ListView_GetNextItem(m_hLV, index, LVNI_ALL | LVNI_SELECTED);
    while (-1 != index) {
        if (FAILED(IItem2Cookie(index, pCookies + *pCount)))    {
            ASSERT(0);
            return S_FALSE;
        }

        index = ListView_GetNextItem(m_hLV, index, LVNI_ALL | LVNI_SELECTED);
        *pCount = *pCount + 1;
    }

    return S_OK;
}

STDMETHODIMP CUpdateDialog::GetSelectionCount(UINT * pCount)
{
    if (!m_bInitialized)
        return E_INVALIDARG;

    ASSERT(pCount);
    * pCount = ListView_GetSelectedCount(m_hLV);

    return S_OK;
}

STDMETHODIMP CUpdateDialog::AddItem(CLSID * pCookie, LPTSTR name, STATUS stat)
{
    HRESULT             hr;
    TCHAR               szBuf[MAX_URL];

    LV_ITEM lvi = {0};
    BOOL    bNew;

    lvi.iSubItem = 0;
    hr = cookieMap.AddCookie(pCookie, &(lvi.lParam));
    if (S_OK == hr) {
        bNew = TRUE;
    } else if (S_FALSE == hr)   {
        bNew = FALSE;
    } else  {
        return hr;
    }

    lvi.pszText = name;
    if (bNew)   {
        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
        switch (m_pController->GetSubscriptionType(pCookie))
        {
        case SUBSTYPE_CHANNEL:
            lvi.iImage = ILI_CHANNEL;
            break;
        case SUBSTYPE_DESKTOPURL:
        case SUBSTYPE_DESKTOPCHANNEL:
            lvi.iImage = ILI_DESKTOP;
            break;
        case SUBSTYPE_URL:
        default:
            lvi.iImage = ILI_SITE;
            break;
        }
        lvi.iItem = ListView_InsertItem(m_hLV, &lvi);
        if (lvi.iItem == -1)
            return E_FAIL;
        if (lvi.iItem == 0) {
            ListView_SetItemState(m_hLV, 0, LVIS_SELECTED, LVIS_SELECTED);
        }
    } else  {
        LV_FINDINFO lvfi = {0};

        lvfi.flags = LVFI_PARAM;
        lvfi.lParam = lvi.lParam;
    
        lvi.iItem = ListView_FindItem(m_hLV, -1, &lvfi);
        if (lvi.iItem == -1)
            return E_FAIL;

        lvi.mask = LVIF_TEXT;
        ListView_SetItem(m_hLV, &lvi);
    }

    //add subitem for status icon
    lvi.mask = LVIF_IMAGE;
    lvi.iSubItem ++;    //  Icon field.
    switch (stat)  {
        case ITEM_STAT_QUEUED:
        case ITEM_STAT_PENDING:
            lvi.iImage = ILI_PENDING;
            break;
        case ITEM_STAT_UPDATING:
            lvi.iImage = ILI_UPDATING;
            break;
        case ITEM_STAT_SUCCEEDED:
            lvi.iImage = ILI_SUCCEEDED;
            if (ListView_GetItemState(m_hLV, lvi.iItem, LVIS_SELECTED))
                Button_Enable(GetDlgItem(m_hDlg, IDCMD_SKIP), FALSE);
            break;
        case ITEM_STAT_SKIPPED:
            lvi.iImage = ILI_SKIPPED;
            if (ListView_GetItemState(m_hLV, lvi.iItem, LVIS_SELECTED))
                Button_Enable(GetDlgItem(m_hDlg, IDCMD_SKIP), FALSE);
        default:
            lvi.iImage = ILI_FAILED;
            break;
    }
    ListView_SetItem(m_hLV, &lvi);

    //add subitem for status text
    lvi.mask = LVIF_TEXT;
    ASSERT ((UINT)stat <= ITEM_STAT_SUCCEEDED);
    MLLoadString(IDS_ITEM_STAT_IDLE + stat, szBuf, ARRAYSIZE(szBuf));
    lvi.pszText = szBuf;
    lvi.iSubItem ++;
    ListView_SetItem(m_hLV, &lvi);

    //add subitem for URL
    PReportMap prm = m_pController->FindReportEntry (pCookie);
    lvi.pszText = prm->url;
    lvi.iSubItem++;
    ListView_SetItem(m_hLV, &lvi);

    //add subitem for size
    lvi.pszText = TEXT("");
    lvi.iSubItem++;
    ListView_SetItem(m_hLV, &lvi);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\utils.cpp ===
#include "private.h"
#include "chanmgr.h"
#include "chanmgrp.h"
#include "shguidp.h"
#include "resource.h"
#define DECL_CRTFREE
#include <crtfree.h>


#include <mluisupp.h>

#define TF_DUMPTRIGGER              0x80000000

#define PtrDifference(x,y)          ((LPBYTE)(x)-(LPBYTE)(y))

// Invoke Command verb strings
const CHAR c_szOpen[]          = "open";
const CHAR c_szDelete[]        = "delete";
const CHAR c_szProperties[]    = "properties";
const CHAR c_szCopy[]          = "copy";
const CHAR c_szRename[]        = "rename";
const CHAR c_szPaste[]         = "paste";

static TCHAR szNone[40] = {0};
static TCHAR szUnknown[40] = {0};

// For each notification handler CLSID in the registry, send a single CommandId and Cookie to each handler.
void FireSubscriptionEvent(int nCmdID, const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie_ua)
{
    HKEY hkey;
    SUBSCRIPTIONCOOKIE cookie_buf;
    SUBSCRIPTIONCOOKIE *pCookie;

    ASSERT( pCookie_ua );

    if ( ! pCookie_ua )
    {
        TraceMsg(TF_ERROR, "FireSubscriptionEvent() - pCookie_ua is NULL!");
        return;
    }

    //
    // Make an aligned copy of pCookie_ua and set a pointer to it.
    //

    cookie_buf = *pCookie_ua;
    pCookie = &cookie_buf;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WEBCHECK_REGKEY_NOTF, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        LPOLESTR pszCookie;

        if (SUCCEEDED(StringFromCLSID(*pCookie, &pszCookie)))
        {
            VARIANT varCookie;

            varCookie.vt = VT_BSTR;
            varCookie.bstrVal = SysAllocString(pszCookie);

            if (varCookie.bstrVal)
            {
                for (int i = 0; ; i++)
                {
                    TCHAR szClsid[GUIDSTR_MAX];
                    DWORD cchClsid = ARRAYSIZE(szClsid);
                    DWORD dwType;
                    DWORD dwData;
                    DWORD cbData = sizeof(dwData);

                    int result = RegEnumValue(hkey, i, szClsid, &cchClsid, NULL, &dwType, (LPBYTE)&dwData, &cbData);

                    if (ERROR_NO_MORE_ITEMS == result)
                    {
                        break;
                    }

                    if ((ERROR_SUCCESS == result) && (dwData & nCmdID))
                    {
                        WCHAR wszClsid[GUIDSTR_MAX];
                        CLSID clsid;

                        SHTCharToUnicode(szClsid, wszClsid, ARRAYSIZE(wszClsid));

                        HRESULT hr = CLSIDFromString(wszClsid, &clsid);

                        if (SUCCEEDED(hr))
                        {
                            IOleCommandTarget *pCmdTarget;

                            hr = CoCreateInstance(*(&clsid), NULL, CLSCTX_ALL, IID_IOleCommandTarget, (void **)&pCmdTarget);
                            if (SUCCEEDED(hr))
                            {
                                pCmdTarget->Exec(&CLSID_SubscriptionMgr, nCmdID, 0, &varCookie, NULL);
                                pCmdTarget->Release();
                            }
                        }
                    }
                }

                VariantClear(&varCookie);
            }

            CoTaskMemFree(pszCookie);
        }

        RegCloseKey( hkey );
    }
}

#ifdef UNICODE
HRESULT IExtractIcon_GetIconLocationThunk(IExtractIconW *peiw, UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    HRESULT hr;
    WCHAR *pwszIconFile = new WCHAR[cchMax];

    if (NULL != pwszIconFile)
    {
        hr = peiw->GetIconLocation(uFlags, pwszIconFile, cchMax, piIndex, pwFlags);

        if (SUCCEEDED(hr))
        {
            WideCharToMultiByte(CP_ACP, 0, pwszIconFile, -1, szIconFile, cchMax, NULL, NULL);
        }

        delete [] pwszIconFile;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT IExtractIcon_ExtractThunk(IExtractIconW *peiw, LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    HRESULT hr;
    int len = lstrlenA(pszFile) + 1;
    WCHAR *pwszFile = new WCHAR[len];

    if (NULL != pwszFile)
    {
        MultiByteToWideChar(CP_ACP, 0, pszFile, len, pwszFile, len);

        hr = peiw->Extract(pwszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);

        delete [] pwszFile;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
#endif

DWORD Random(DWORD nMax)
{
    static DWORD dwSeed = GetTickCount();

    if (nMax)
    {
        return dwSeed = (dwSeed * 214013L + 2531011L) % nMax;
    }
    else
    {
        return 0;
    }
}

void CreateCookie(GUID UNALIGNED *pCookie_ua)
{
    static DWORD dwCount = 0;

    union CUCookie
    {
        GUID guidCookie;
        struct XCookie {
            FILETIME ft;
            DWORD    dwCount;
            DWORD    dwRand;
        } x;
    };

    CUCookie uc;
    GetSystemTimeAsFileTime(&uc.x.ft);
    uc.x.dwCount = dwCount++;
    uc.x.dwRand = Random(0xffffffff);

    *pCookie_ua = uc.guidCookie;
}

void VariantTimeToFileTime(double dt, FILETIME& ft)
{
    SYSTEMTIME st;

    VariantTimeToSystemTime(dt, &st);
    SystemTimeToFileTime(&st, &ft);
}

void FileTimeToVariantTime(FILETIME& ft, double *pdt)
{
    SYSTEMTIME st;

    FileTimeToSystemTime(&ft, &st);
    SystemTimeToVariantTime(&st, pdt);
}


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// Cache helper functions
//

// Caller should MemFree *lpCacheConfigInfo when done. Should pass *lpCacheConfigInfo
//  into SetCacheSize
HRESULT GetCacheInfo(
    LPINTERNET_CACHE_CONFIG_INFOA *lplpCacheConfigInfo,
    DWORD                        *pdwSizeInKB,
    DWORD                        *pdwPercent)
{
    HRESULT hr = S_OK;
    LPINTERNET_CACHE_CONFIG_INFOA lpCCI = NULL;
    DWORD dwSize;

    dwSize = sizeof(INTERNET_CACHE_CONFIG_INFOA);

    lpCCI = (LPINTERNET_CACHE_CONFIG_INFOA)MemAlloc(LPTR, dwSize);

    if (!lpCCI)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    lpCCI->dwStructSize = sizeof(INTERNET_CACHE_CONFIG_INFOA);

    if (!GetUrlCacheConfigInfoA(lpCCI, &dwSize, CACHE_CONFIG_CONTENT_PATHS_FC))
    {
        hr = E_FAIL; // HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    // there should be at least one cache path structure
    if (dwSize < sizeof(INTERNET_CACHE_CONFIG_INFOA) ||
        lpCCI->dwNumCachePaths != 1)
    {
        // something is messed up
        hr = E_FAIL;
        goto cleanup;
    }

    *lplpCacheConfigInfo = lpCCI;
    *pdwSizeInKB = lpCCI->dwQuota;
    *pdwPercent = 10; // good faith estimate

    ASSERT(*pdwSizeInKB);   // Better not be 0...

cleanup:

    if (FAILED(hr))
    {
        SAFELOCALFREE(lpCCI);
    }

    return hr;
}

HRESULT SetCacheSize(
            LPINTERNET_CACHE_CONFIG_INFOA lpCacheConfigInfo,
            DWORD                        dwSizeInKB)
{
//  lpCacheConfigInfo->dwNumCachePaths = 1;
//  lpCacheConfigInfo->CachePaths[0].dwCacheSize = dwSizeInKB;
    lpCacheConfigInfo->dwContainer = 0; // CONTENT;
    lpCacheConfigInfo->dwQuota = dwSizeInKB;

    if (!SetUrlCacheConfigInfoA(lpCacheConfigInfo, CACHE_CONFIG_QUOTA_FC))
    {
        return E_FAIL; // HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// Registry helper functions
//
BOOL ReadRegValue(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue,
                   void *pData, DWORD dwBytes)
{
    long    lResult;
    HKEY    hkey;
    DWORD   dwType;

    lResult = RegOpenKey(hkeyRoot, pszKey, &hkey);
    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }

    lResult = RegQueryValueEx(hkey, pszValue, NULL, &dwType, (BYTE *)pData,
        &dwBytes);
    RegCloseKey(hkey);

    if (lResult != ERROR_SUCCESS)
        return FALSE;

    if(dwType == REG_SZ) {
        // null terminate string
        ((TCHAR *)pData)[dwBytes] = 0;
    }

    return TRUE;
}

BOOL WriteRegValue(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue,
                    void *pData, DWORD dwBytes, DWORD dwType)
{
    HKEY    hkey;
    long    lResult;
    DWORD   dwStatus;

    lResult = RegCreateKeyEx(hkeyRoot, pszKey, 0, NULL,
            REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkey, &dwStatus);
    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }

    lResult = RegSetValueEx(hkey, pszValue, 0, dwType, (BYTE *)pData, dwBytes);
    RegCloseKey(hkey);

    return (lResult == ERROR_SUCCESS) ? TRUE : FALSE;
}

DWORD ReadRegDWORD(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue)
{
    DWORD dwData;
    if (ReadRegValue(hkeyRoot, pszKey, pszValue, &dwData, sizeof(dwData)))
        return dwData;
    else
        return 0;
}

HRESULT CreateShellFolderPath(LPCTSTR pszPath, LPCTSTR pszGUID, BOOL bUICLSID)
{
    if (!PathFileExists(pszPath))
    CreateDirectory(pszPath, NULL);

    // Mark the folder as a system directory
    if (SetFileAttributes(pszPath, FILE_ATTRIBUTE_READONLY))
    {
        TCHAR szDesktopIni[MAX_PATH];
        // Write in the desktop.ini the cache folder class ID
        PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

        // If the desktop.ini already exists, make sure it is writable
        if (PathFileExists(szDesktopIni))
            SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);

        // (First, flush the cache to make sure the desktop.ini
        // file is really created.)
        WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);
        WritePrivateProfileString(TEXT(".ShellClassInfo"), bUICLSID ? TEXT("UICLSID") : TEXT("CLSID"), pszGUID, szDesktopIni);
        WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);

        // Hide the desktop.ini since the shell does not selectively
        // hide it.
        SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_HIDDEN);

        return NOERROR;
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("Cannot make %s a system folder"), pszPath);
        return E_FAIL;
    }
}

void CleanupShellFolder(LPCTSTR pszPath)
{
    if (PathFileExists(pszPath))
    {
        TCHAR szDesktopIni[MAX_PATH];

        // make the history a normal folder
        SetFileAttributes(pszPath, FILE_ATTRIBUTE_NORMAL);
        PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

        // If the desktop.ini already exists, make sure it is writable
        if (PathFileExists(szDesktopIni))
        {
            SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szDesktopIni);
        }

        // remove the history directory
        RemoveDirectory(pszPath);
    }
}

BOOL GetSubscriptionFolderPath(LPTSTR pszPath)
{
    DWORD dwDummy;
    HKEY hk;

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                        REGSTR_PATH_SUBSCRIPTION,
                                        0, TEXT(""),
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ|KEY_WRITE, NULL, &hk, &dwDummy))
    {
        DWORD cbData = MAX_PATH * sizeof(TCHAR);
        if (ERROR_SUCCESS != RegQueryValueEx(hk, REGSTR_VAL_DIRECTORY , NULL, NULL, (LPBYTE)pszPath, &cbData))
        {
            TCHAR szWindows[MAX_PATH];
            GetWindowsDirectory(szWindows, ARRAYSIZE(szWindows));
            PathCombine(pszPath, szWindows, TEXT("Offline Web Pages"));
        }
        RegCloseKey(hk);

        return TRUE;
    }
    return FALSE;
}

HRESULT GetChannelPath(LPCTSTR pszURL, LPTSTR pszPath, int cch,
                       IChannelMgrPriv** ppIChannelMgrPriv)
{
    ASSERT(pszURL);
    ASSERT(pszPath || 0 == cch);
    ASSERT(ppIChannelMgrPriv);

    HRESULT hr;
    BOOL    bCoinit = FALSE;

    hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_IChannelMgrPriv, (void**)ppIChannelMgrPriv);

    if ((hr == CO_E_NOTINITIALIZED || hr == REGDB_E_IIDNOTREG) &&
        SUCCEEDED(CoInitialize(NULL)))
    {
        bCoinit = TRUE;
        hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_IChannelMgrPriv, (void**)ppIChannelMgrPriv);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(*ppIChannelMgrPriv);

        IChannelMgr* pIChannelMgr;

        hr = (*ppIChannelMgrPriv)->QueryInterface(IID_IChannelMgr,
                                                (void**)&pIChannelMgr);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIChannelMgr);

            WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
            MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), pszURL);

            IEnumChannels* pIEnumChannels;

            hr = pIChannelMgr->EnumChannels(CHANENUM_ALLFOLDERS | CHANENUM_PATH,
                                            wszURL, &pIEnumChannels);

            if (SUCCEEDED(hr))
            {
                ASSERT(pIEnumChannels);

                CHANNELENUMINFO ci;

                if (S_OK == pIEnumChannels->Next(1, &ci, NULL))
                {
                    MyOleStrToStrN(pszPath, cch, ci.pszPath);

                    CoTaskMemFree(ci.pszPath);
                }
                else
                {
                    hr = E_FAIL;
                }

                pIEnumChannels->Release();
            }

            pIChannelMgr->Release();
        }

    }

    if (bCoinit)
        CoUninitialize();

    ASSERT((SUCCEEDED(hr) && *ppIChannelMgrPriv) || FAILED(hr));

    return hr;
}


//  Caller is responsible for calling ILFree on *ppidl.
HRESULT ConvertPathToPidl(LPCTSTR path, LPITEMIDLIST * ppidl)
{
    WCHAR wszPath[MAX_PATH];
    IShellFolder * pDesktopFolder;
    HRESULT hr;

    ASSERT(path && ppidl);
    * ppidl = NULL;

    MyStrToOleStrN(wszPath, MAX_PATH, path);
    hr = SHGetDesktopFolder(&pDesktopFolder);
    if (hr != NOERROR)
        return hr;

    ULONG uChEaten;

    hr = pDesktopFolder->ParseDisplayName(NULL, NULL, wszPath,
                                            &uChEaten, ppidl, NULL);
    SAFERELEASE(pDesktopFolder);

    return hr;
}

LPITEMIDLIST    GetSubscriptionFolderPidl(void)
{
    TCHAR szPath[MAX_PATH];
    static LPITEMIDLIST pidlFolder = NULL;  //  We leak here.

    if (!pidlFolder)  {
        if (!(GetSubscriptionFolderPath(szPath)))
            return NULL;
        if (FAILED(ConvertPathToPidl(szPath, &pidlFolder)))
            return NULL;
        ASSERT(pidlFolder);
    }
    return (LPITEMIDLIST)pidlFolder;
}

STDAPI OfflineFolderRegisterServer(void)
{
    TCHAR szOldSubscriptionPath[MAX_PATH];

    GetWindowsDirectory(szOldSubscriptionPath, ARRAYSIZE(szOldSubscriptionPath));
    PathCombine(szOldSubscriptionPath, szOldSubscriptionPath, TEXT("Subscriptions"));
    CleanupShellFolder(szOldSubscriptionPath);

    TCHAR szPath[MAX_PATH];

    if (!(GetSubscriptionFolderPath(szPath)))
        goto CleanUp;

    // we pass FALSE because history folder uses CLSID
    if (FAILED(CreateShellFolderPath(szPath, TEXT("{F5175861-2688-11d0-9C5E-00AA00A45957}"), FALSE)))
        goto CleanUp;

    return NOERROR;

CleanUp:        // cleanup stuff if any of our reg stuff fails

    return E_FAIL;
}

STDAPI OfflineFolderUnregisterServer(void)
{
    TCHAR szPath[MAX_PATH];

    if (!(GetSubscriptionFolderPath(szPath)))
        goto CleanUp;

    // we pass FALSE because history folder uses CLSID
    CleanupShellFolder(szPath);

    return NOERROR;

CleanUp:        // cleanup stuff if any of our reg stuff fails

    return E_FAIL;
}



HMENU LoadPopupMenu(UINT id, UINT uSubOffset)
{
    HMENU hmParent, hmPopup;

    hmParent = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(id));
    if (!hmParent)
        return NULL;

    hmPopup = GetSubMenu(hmParent, uSubOffset);
    RemoveMenu(hmParent, uSubOffset, MF_BYPOSITION);
    DestroyMenu(hmParent);

    return hmPopup;
}

UINT MergePopupMenu(HMENU *phMenu, UINT idResource, UINT uSubOffset, UINT indexMenu,  UINT idCmdFirst, UINT idCmdLast)
{
    HMENU hmMerge;

    if (*phMenu == NULL)
    {
        *phMenu = CreatePopupMenu();
        if (*phMenu == NULL)
            return 0;

        indexMenu = 0;    // at the bottom
    }

    hmMerge = LoadPopupMenu(idResource, uSubOffset);
    if (!hmMerge)
        return 0;

    idCmdLast = Shell_MergeMenus(*phMenu, hmMerge, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);

    DestroyMenu(hmMerge);
    return idCmdLast;
}

HMENU GetMenuFromID(HMENU hmenu, UINT idm)
{
    MENUITEMINFO mii = { sizeof(mii), MIIM_SUBMENU, 0, 0, 0, NULL, NULL, NULL, 0, NULL, 0 };
    GetMenuItemInfo(hmenu, idm, FALSE, &mii);
    return mii.hSubMenu;
}

UINT MergeMenuHierarchy(HMENU hmenuDst, HMENU hmenuSrc, UINT idcMin, UINT idcMax, BOOL bTop)
{
    UINT idcMaxUsed = idcMin;
    int imi = GetMenuItemCount(hmenuSrc);

    while (--imi >= 0)
    {
        MENUITEMINFO mii = {
                sizeof(MENUITEMINFO),
                MIIM_ID | MIIM_SUBMENU,
                0,/* fType */ 0,/* fState */ 0,/*wId*/ NULL,
                NULL, NULL, 0,
                NULL, 0 };

        if (GetMenuItemInfo(hmenuSrc, imi, TRUE, &mii))
        {
            UINT idcT = Shell_MergeMenus(
                            GetMenuFromID(hmenuDst, mii.wID),
                            mii.hSubMenu, (bTop)?0:1024, idcMin, idcMax,
                            MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
            idcMaxUsed = max(idcMaxUsed, idcT);
        }
    }
    return idcMaxUsed;
}

///////////////////////////////////////////////////////////////////////////////
//
// Helper Fuctions for item.cpp and folder.cpp
//
///////////////////////////////////////////////////////////////////////////////

int _CompareURL(LPMYPIDL pooi1, LPMYPIDL pooi2)
{
    return UrlCompare(URL(&(pooi1->ooe)), URL(&(pooi2->ooe)), TRUE);
}

int _CompareShortName(LPMYPIDL pooi1, LPMYPIDL pooi2)
{
    PCTSTR pszNameLocal1;
    PCTSTR pszNameLocal2;

    LPTSTR szNameUnaligned1 = NAME(&(pooi1->ooe));
    LPTSTR szNameUnaligned2 = NAME(&(pooi2->ooe));

    TSTR_ALIGNED_STACK_COPY( &pszNameLocal1, szNameUnaligned1 );
    TSTR_ALIGNED_STACK_COPY( &pszNameLocal2, szNameUnaligned2 );

    return StrCmp( pszNameLocal1, pszNameLocal2 );
}

int _CompareLastUpdate(LPMYPIDL pooi1, LPMYPIDL pooi2)
{
    if (pooi1->ooe.m_LastUpdated - pooi2->ooe.m_LastUpdated > 0)
        return 1;
    return -1;
}

int _CompareCookie(REFCLSID cookie1, REFCLSID cookie2)
{
    return memcmp(&cookie1, &cookie2, sizeof(CLSID));
}

int _CompareStatus(LPMYPIDL pooi1, LPMYPIDL pooi2)
{
    return StrCmp(STATUS(&(pooi1->ooe)), STATUS(&(pooi2->ooe)));
}

int _CompareIdentities(LPMYPIDL pooi1, LPMYPIDL pooi2)
{
    if (pooi1->ooe.clsidDest != pooi2->ooe.clsidDest)
        return -1;

    if (!IsNativeAgent(pooi1->ooe.clsidDest))
        return _CompareCookie(pooi1->ooe.m_Cookie, pooi2->ooe.m_Cookie);

    return _CompareURL(pooi1, pooi2);
}

BOOL _ValidateIDListArray(UINT cidl, LPCITEMIDLIST *ppidl)
{
    UINT i;

    for (i = 0; i < cidl; i++)
    {
        if (!IS_VALID_MYPIDL(ppidl[i]))
            return FALSE;
    }

    return TRUE;
}

int _LaunchApp(HWND hwnd, LPCTSTR pszPath)
{
    SHELLEXECUTEINFO ei = { 0 };

    ei.cbSize           = sizeof(SHELLEXECUTEINFO);
    ei.hwnd             = hwnd;
    ei.lpFile           = pszPath;
    ei.nShow            = SW_SHOWNORMAL;

    return ShellExecuteEx(&ei);
}

void _GenerateEvent(LONG lEventId, LPITEMIDLIST pidlIn, LPITEMIDLIST pidlNewIn, BOOL bRefresh)
{
    LPITEMIDLIST pidlFolder = GetSubscriptionFolderPidl();
    if (!pidlFolder)
        return;

    LPITEMIDLIST pidl = ILCombine(pidlFolder, pidlIn);
    if (pidl)
    {
        if (pidlNewIn)
        {
            LPITEMIDLIST pidlNew = ILCombine(pidlFolder, pidlNewIn);
            if (pidlNew)
            {
                SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, pidlNew);
                ILFree(pidlNew);
            }
        }
        else
        {
            SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, NULL);
        }
        if (bRefresh)
            SHChangeNotifyHandleEvents();
        ILFree(pidl);
    }
}

BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_NATIVEFNTCTL_CLASS | ICC_DATE_CLASSES;
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}

const struct {
    LPCSTR pszVerb;
    UINT idCmd;
} rgcmds[] = {
    { c_szOpen,         RSVIDM_OPEN },
    { c_szCopy,         RSVIDM_COPY },
    { c_szRename,       RSVIDM_RENAME},
    { c_szPaste,        RSVIDM_PASTE},
    { c_szDelete,       RSVIDM_DELETE },
    { c_szProperties,   RSVIDM_PROPERTIES }
};

int _GetCmdID(LPCSTR pszCmd)
{
    if (HIWORD(pszCmd))
    {
        int i;
        for (i = 0; i < ARRAYSIZE(rgcmds); i++)
        {
            if (lstrcmpiA(rgcmds[i].pszVerb, pszCmd) == 0)
            {
                return rgcmds[i].idCmd;
            }
        }

        return -1;  // unknown
    }
    return (int)LOWORD(pszCmd);
}

BOOL CALLBACK _AddOnePropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *) lParam;

    if (ppsh->nPages < MAX_PROP_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }
    return FALSE;
}

HRESULT _CreatePropSheet(HWND hwnd, POOEBuf pBuf)
{
    ASSERT(pBuf);

    ISubscriptionMgr    * pSub= NULL;
    HRESULT hr = CoInitialize(NULL);
    RETURN_ON_FAILURE(hr);

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                IID_ISubscriptionMgr, (void **)&pSub);
    CoUninitialize();
    RETURN_ON_FAILURE(hr);
    ASSERT(pSub);

    BSTR bstrURL = NULL;
    hr = CreateBSTRFromTSTR(&bstrURL, pBuf->m_URL);
    if (S_OK == hr)
        hr = pSub->ShowSubscriptionProperties(bstrURL, hwnd);
    SAFERELEASE(pSub);
    SAFEFREEBSTR(bstrURL);
    return hr;
}

//  Note:
//      We return FALSE on illegal DATE data.

BOOL DATE2DateTimeString(CFileTime& ft, LPTSTR pszText)
{
    SYSTEMTIME st;

    if (ft == 0)    {
        if (szUnknown[0] == 0)
            MLLoadString(IDS_UNKNOWN, szUnknown, ARRAYSIZE(szUnknown));

        StrCpy(pszText, szUnknown);
        return FALSE;
    }

    if (!FileTimeToSystemTime(&ft, &st))
    {
        if (szNone[0] == 0)
            MLLoadString(IDS_NONE, szNone, ARRAYSIZE(szNone));

        StrCpy(pszText, szNone);
        return FALSE;
    }
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, pszText, 64);
    pszText += lstrlen(pszText);
    *pszText++ = ' ';
    GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, pszText, 64);
    return TRUE;
}

BOOL Date2LocalDateString(SYSTEMTIME * st, LPTSTR dtStr, int size)
{
    ASSERT(dtStr);

    return GetDateFormat(LOCALE_USER_DEFAULT, 0, st, NULL, dtStr, size);
}

void CopyToOOEBuf(POOEntry pooe, POOEBuf pBuf)
{
    ASSERT(pooe);
    ASSERT(pBuf);

    pBuf->dwFlags           = pooe->dwFlags;
    pBuf->m_LastUpdated     = pooe->m_LastUpdated;
    pBuf->m_NextUpdate      = pooe->m_NextUpdate;
    pBuf->m_SizeLimit       = pooe->m_SizeLimit;
    pBuf->m_ActualSize      = pooe->m_ActualSize;
    pBuf->m_RecurseLevels   = pooe->m_RecurseLevels;
    pBuf->m_RecurseFlags    = pooe->m_RecurseFlags;
    pBuf->m_Priority        = pooe->m_Priority;
    pBuf->bDesktop          = pooe->bDesktop;
    pBuf->bChannel          = pooe->bChannel;
    pBuf->bMail             = pooe->bMail;
    pBuf->bGleam            = pooe->bGleam;
    pBuf->bChangesOnly      = pooe->bChangesOnly;
    pBuf->fChannelFlags     = pooe->fChannelFlags;
    pBuf->bNeedPassword     = pooe->bNeedPassword;
    pBuf->m_Cookie          = pooe->m_Cookie;
    pBuf->groupCookie       = pooe->groupCookie;
    pBuf->grfTaskTrigger    = pooe->grfTaskTrigger;
    pBuf->m_Trigger         = pooe->m_Trigger;
    pBuf->clsidDest         = pooe->clsidDest;
    pBuf->status            = pooe->status;

    StrCpyN(pBuf->m_URL,       URL(pooe),      MAX_URL);
    StrCpyN(pBuf->m_Name,      NAME(pooe),     MAX_NAME);
    StrCpyN(pBuf->username,    UNAME(pooe),    MAX_USERNAME);
    StrCpyN(pBuf->password,    PASSWD(pooe),   MAX_PASSWORD);
    StrCpyN(pBuf->statusStr,   STATUS(pooe),   MAX_STATUS);
}

void CopyToMyPooe(POOEBuf pBuf, POOEntry pooe)
{
    UINT    offset = sizeof(OOEntry);
    UINT    srcLen = lstrlen(pBuf->m_URL) + 1;

    ASSERT(pooe);
    ASSERT(pBuf);

    pooe->dwFlags           = pBuf->dwFlags;
    pooe->m_LastUpdated     = pBuf->m_LastUpdated;
    pooe->m_NextUpdate      = pBuf->m_NextUpdate;
    pooe->m_SizeLimit       = pBuf->m_SizeLimit;
    pooe->m_ActualSize      = pBuf->m_ActualSize;
    pooe->m_RecurseLevels   = pBuf->m_RecurseLevels;
    pooe->m_Priority        = pBuf->m_Priority;
    pooe->m_RecurseFlags    = pBuf->m_RecurseFlags;
    pooe->bDesktop          = pBuf->bDesktop;
    pooe->bChannel          = pBuf->bChannel;
    pooe->bMail             = pBuf->bMail;
    pooe->bGleam            = pBuf->bGleam;
    pooe->bChangesOnly      = pBuf->bChangesOnly;
    pooe->fChannelFlags     = pBuf->fChannelFlags;
    pooe->bNeedPassword     = pBuf->bNeedPassword;
    pooe->m_Cookie          = pBuf->m_Cookie;
    pooe->groupCookie       = pBuf->groupCookie;
    pooe->m_Trigger         = pBuf->m_Trigger;
    pooe->grfTaskTrigger    = pBuf->grfTaskTrigger;
    pooe->clsidDest         = pBuf->clsidDest;
    pooe->status            = pBuf->status;

    pooe->m_URL = (LPTSTR)((LPBYTE)pooe + offset);
    srcLen = lstrlen(pBuf->m_URL) + 1;
    StrCpyN(pooe->m_URL, pBuf->m_URL, srcLen);
    offset += srcLen * sizeof (TCHAR);
    pooe->m_URL = (LPTSTR) PtrDifference(pooe->m_URL, pooe);

    pooe->m_Name = (LPTSTR)((LPBYTE)pooe + offset);
    srcLen = lstrlen(pBuf->m_Name) + 1;
    StrCpyN(pooe->m_Name, pBuf->m_Name, srcLen);
    offset += srcLen * sizeof (TCHAR);
    pooe->m_Name = (LPTSTR) PtrDifference(pooe->m_Name, pooe);

    pooe->username = (LPTSTR)((LPBYTE)pooe + offset);
    srcLen = lstrlen(pBuf->username) + 1;
    StrCpyN(pooe->username, pBuf->username, srcLen);
    offset += srcLen * sizeof (TCHAR);
    pooe->username = (LPTSTR) PtrDifference(pooe->username, pooe);

    pooe->password = (LPTSTR)((LPBYTE)pooe + offset);
    srcLen = lstrlen(pBuf->password) + 1;
    StrCpyN(pooe->password, pBuf->password, srcLen);
    offset += srcLen * sizeof (TCHAR);
    pooe->password = (LPTSTR) PtrDifference(pooe->password, pooe);

    pooe->statusStr = (LPTSTR)((LPBYTE)pooe + offset);
    srcLen = lstrlen(pBuf->statusStr) + 1;
    StrCpyN(pooe->statusStr, pBuf->statusStr, srcLen);
    offset += srcLen * sizeof (TCHAR);
    pooe->statusStr = (LPTSTR) PtrDifference(pooe->statusStr, pooe);

    pooe->dwSize = offset;
}

UINT BufferSize(POOEBuf pBuf)
{
    UINT strLen = 0;
    ASSERT(pBuf);

    strLen += lstrlen(pBuf->m_URL)      + 1;
    strLen += lstrlen(pBuf->m_Name)     + 1;
    strLen += lstrlen(pBuf->username)   + 1;
    strLen += lstrlen(pBuf->password)   + 1;
    strLen += lstrlen(pBuf->statusStr)  + 1;

    return strLen * sizeof(TCHAR);
}


typedef struct
{
    int cItems;
    LPCTSTR pszName;
    LPCTSTR pszUrl;
} DELETE_CONFIRM_INFO;

INT_PTR CALLBACK ConfirmDeleteDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch(message) {

        case WM_INITDIALOG:
        {
            DELETE_CONFIRM_INFO* pInfo = (DELETE_CONFIRM_INFO*)lParam;
            ASSERT (pInfo);
            ASSERT(pInfo->cItems == 1);

            SetListViewToString (GetDlgItem (hDlg, IDC_NAME), pInfo->pszName);
            SetListViewToString (GetDlgItem (hDlg, IDC_LOCATION), pInfo->pszUrl);
        }
        break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDYES:
                case IDNO:
                case IDCANCEL:
                    EndDialog(hDlg, wParam);
                    break;
            }
            break;

        case WM_NOTIFY:
            if (LOWORD(wParam) == IDC_LOCATION)
            {
                NM_LISTVIEW * pnmlv = (NM_LISTVIEW *)lParam;
                ASSERT(pnmlv);
                if (pnmlv->hdr.code == LVN_GETINFOTIP)
                {
                    TCHAR szURL[MAX_URL];
                    LV_ITEM lvi = {0};
                    lvi.mask = LVIF_TEXT;
                    lvi.pszText = szURL;
                    lvi.cchTextMax = ARRAYSIZE(szURL);
                    if (!ListView_GetItem (GetDlgItem (hDlg, IDC_LOCATION), &lvi))
                        return FALSE;

                    NMLVGETINFOTIP  * pTip = (NMLVGETINFOTIP *)pnmlv;
                    ASSERT(pTip->pszText);
                    StrCpyN(pTip->pszText, szURL, pTip->cchTextMax);
                    return TRUE;
                }
            }
        return FALSE;

        default:
            return FALSE;

    } // end of switch

    return TRUE;
}

BOOL ConfirmDelete(HWND hwnd, UINT cItems, LPMYPIDL * ppidl)
{
    ASSERT(ppidl);
    INT_PTR iRet;

    // Check if the user is restricted from deleting URLs.
    // If they're deleting multiple, we'll fail if any can fail.
    UINT i;
    for (i = 0; i < cItems; i++)
    {
        if (ppidl[i]->ooe.bChannel)
        {
            if (SHRestricted2(REST_NoRemovingChannels, URL(&(ppidl[i]->ooe)), 0))
            {
                if (IsWindow(hwnd))
                    SGMessageBox(hwnd, IDS_RESTRICTED, MB_OK);
                return FALSE;
            }
        }

        if (!ppidl[i]->ooe.bDesktop)
        {
            // FEATURE: What about desktop components?
            if (SHRestricted2(REST_NoRemovingSubscriptions, URL(&(ppidl[i]->ooe)), 0))
            {
                if (IsWindow(hwnd))
                    SGMessageBox(hwnd, IDS_RESTRICTED, MB_OK);
                return FALSE;
            }
        }
    }

    if (IsWindow(hwnd)) {
        DELETE_CONFIRM_INFO dci = {0};
        dci.cItems = cItems;
        if (cItems == 1)
        {
            dci.pszName = NAME(&(ppidl[0]->ooe));
            dci.pszUrl = URL(&(ppidl[0]->ooe));
            iRet = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_OBJECTDEL_WARNING),
                        hwnd, ConfirmDeleteDlgProc, (LPARAM)&dci);
        }
        else
        {

            TCHAR szFormat[200];
            //  Enough room for format string and int as string
            TCHAR szBuf[ARRAYSIZE(szFormat) + 11];

            MLLoadString(IDS_DEL_MULTIPLE_FMT, szFormat, ARRAYSIZE(szFormat));
            wnsprintf(szBuf, ARRAYSIZE(szBuf), szFormat, cItems);

            MLLoadString(IDS_DELETE_CAPTION, szFormat, ARRAYSIZE(szFormat));

            MSGBOXPARAMS mbp;

            mbp.cbSize = sizeof(MSGBOXPARAMS);
            mbp.hwndOwner = hwnd;
            mbp.hInstance = MLGetHinst();
            mbp.lpszText = szBuf;
            mbp.lpszCaption = szFormat;
            mbp.dwStyle = MB_YESNO | MB_USERICON;
            mbp.lpszIcon = MAKEINTRESOURCE(IDI_OBJECTDELETED);
            iRet = MessageBoxIndirect(&mbp);
        }
        if (iRet == IDYES)
            return TRUE;
        return FALSE;
    } else  {
        return TRUE;
    }
}

BOOL IsHTTPPrefixed(LPCTSTR szURL)
{
    TCHAR szCanonicalURL[MAX_URL];
    DWORD dwSize = MAX_URL;
    URL_COMPONENTS uc;

    memset(&uc, 0, sizeof(URL_COMPONENTS));
    uc.dwStructSize = sizeof(URL_COMPONENTS);

    // Note:  We explicitly check for and allow the "about:home" URL to pass through here.  This allows
    // the Active Desktop "My Current Home Page" component to specify that URL when creating and managing
    // it's subscription which is consistent with it's use of that form in the browser.
    if (!InternetCanonicalizeUrl(szURL, szCanonicalURL, &dwSize, ICU_DECODE) ||
        !InternetCrackUrl(szCanonicalURL, 0, 0, &uc) ||
        ((INTERNET_SCHEME_HTTP != uc.nScheme) && (INTERNET_SCHEME_HTTPS != uc.nScheme) && (0 != StrCmpI(TEXT("about:home"), szURL))))
    {
        return FALSE;
    }
    return TRUE;
}

//   Checks if global state is offline

BOOL IsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;
    HANDLE hModuleHandle = LoadLibraryA("wininet.dll");

    if(!hModuleHandle)
        return FALSE;

    if(InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

void SetGlobalOffline(BOOL fOffline)
{
    INTERNET_CONNECTED_INFO ci;

    memset(&ci, 0, sizeof(ci));
    if(fOffline) {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
}


//helper function to create one column in a ListView control, add one item to that column,
//size the column to the width of the control, and color the control like a static...
//basically, like SetWindowText for a ListView.  Because we use a lot of ListViews to display
//urls that would otherwise be truncated... the ListView gives us automatic ellipsis and ToolTip.
void SetListViewToString (HWND hLV, LPCTSTR pszString)
{
    ASSERT(hLV);

    LV_COLUMN   lvc = {0};
    RECT lvRect;
    GetClientRect (hLV, &lvRect);
    lvc.mask = LVCF_WIDTH;
    lvc.cx = lvRect.right - lvRect.left;
    if (-1 == ListView_InsertColumn(hLV, 0, &lvc))   {
        ASSERT(0);
    }

    SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_INFOTIP, LVS_EX_INFOTIP);

    LV_ITEM lvi = {0};
    lvi.iSubItem = 0;
    lvi.pszText = (LPTSTR)pszString;
    lvi.mask = LVIF_TEXT;
    ListView_InsertItem(hLV, &lvi);
    ListView_EnsureVisible(hLV, 0, TRUE);

    ListView_SetBkColor(hLV, GetSysColor(COLOR_BTNFACE));
    ListView_SetTextBkColor(hLV, GetSysColor(COLOR_BTNFACE));
}

int WCMessageBox(HWND hwnd, UINT idTextFmt, UINT idCaption, UINT uType, ...)
{
    TCHAR szCaption[256];
    TCHAR szTextFmt[512];
    LPTSTR pszText;
    int result;
    va_list va;

    va_start(va, uType);

    szCaption[0] = 0;

    MLLoadString(idTextFmt, szTextFmt, ARRAYSIZE(szTextFmt));

    if (idCaption <= 0)
    {
        if (NULL != hwnd)
        {
            GetWindowText(hwnd, szCaption, ARRAYSIZE(szCaption));
        }

        //  This handles GetWindowText failure and a NULL hwnd
        if (0 == szCaption[0])
        {
            #if IDS_DEFAULT_MSG_CAPTION < 1
            #error IDS_DEFAULT_MSG_CAPTION is defined incorrectly
            #endif

            idCaption = IDS_DEFAULT_MSG_CAPTION;
        }
    }

    if (idCaption > 0)
    {
        MLLoadString(idCaption, szCaption, ARRAYSIZE(szCaption));
    }

    ASSERT(0 != szCaption[0]);

    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                  szTextFmt, 0, 0, (LPTSTR)&pszText, 0, &va);

    result = MessageBox(hwnd, pszText, szCaption, uType);

    LocalFree(pszText);

    return result;
}


/////////////////////////////////////////////////////////////////////////////
// SGMessageBox
/////////////////////////////////////////////////////////////////////////////
int SGMessageBox
(
    HWND    hwndParent,
    UINT    idStringRes,
    UINT    uType
)
{
    ASSERT(hwndParent != NULL);
    ASSERT(IsWindow(hwndParent));

    TCHAR szError[512];
    if (!MLLoadString(idStringRes, szError, ARRAYSIZE(szError)))
        return 0;

    TCHAR szTitle[128];
    szTitle[0] = 0;

    if (hwndParent != NULL)
        GetWindowText(hwndParent, szTitle, ARRAYSIZE(szTitle));

    return MessageBox(  hwndParent,
                        szError,
                        ((hwndParent != NULL) ? szTitle : NULL),
                        uType);
}

#ifdef DEBUG
/////////////////////////////////////////////////////////////////////////////
// DumpTaskTrigger
/////////////////////////////////////////////////////////////////////////////
void DumpTaskTrigger
(
    TASK_TRIGGER * pTT
)
{
    TraceMsg(TF_DUMPTRIGGER, "----- BEGIN DumpTaskTrigger -----");

    TraceMsg(TF_DUMPTRIGGER, "cbTriggerSize = %d", pTT->cbTriggerSize);
    TraceMsg(TF_DUMPTRIGGER, "Reserved1 = %d", pTT->Reserved1);
    TraceMsg(TF_DUMPTRIGGER, "wBeginYear = %d", pTT->wBeginYear);
    TraceMsg(TF_DUMPTRIGGER, "wBeginMonth = %d", pTT->wBeginMonth);
    TraceMsg(TF_DUMPTRIGGER, "wBeginDay = %d", pTT->wBeginDay);
    TraceMsg(TF_DUMPTRIGGER, "wEndYear = %d", pTT->wEndYear);
    TraceMsg(TF_DUMPTRIGGER, "wEndMonth = %d", pTT->wEndMonth);
    TraceMsg(TF_DUMPTRIGGER, "wEndDay = %d", pTT->wEndDay);
    TraceMsg(TF_DUMPTRIGGER, "wStartHour = %d", pTT->wStartHour);
    TraceMsg(TF_DUMPTRIGGER, "wStartMinute = %d", pTT->wStartMinute);
    TraceMsg(TF_DUMPTRIGGER, "MinutesDuration = %d", pTT->MinutesDuration);
    TraceMsg(TF_DUMPTRIGGER, "MinutesInterval = %d", pTT->MinutesInterval);
    TraceMsg(TF_DUMPTRIGGER, "rgFlags = %d", pTT->rgFlags);
    TraceMsg(TF_DUMPTRIGGER, "Reserved2 = %d", pTT->Reserved2);
    TraceMsg(TF_DUMPTRIGGER, "wRandomMinutesInterval = %d", pTT->wRandomMinutesInterval);

    switch (pTT->TriggerType)
    {
        case TASK_TIME_TRIGGER_DAILY:
        {
            TraceMsg(TF_DUMPTRIGGER, "DAILY");
            TraceMsg(TF_DUMPTRIGGER, "DaysInterval = %d", pTT->Type.Daily.DaysInterval);
            break;
        }

        case TASK_TIME_TRIGGER_WEEKLY:
        {
            TraceMsg(TF_DUMPTRIGGER, "WEEKLY");
            TraceMsg(TF_DUMPTRIGGER, "WeeksInterval = %d", pTT->Type.Weekly.WeeksInterval);
            TraceMsg(TF_DUMPTRIGGER, "rgfDaysOfTheWeek = %d", pTT->Type.Weekly.rgfDaysOfTheWeek);
            break;
        }

        case TASK_TIME_TRIGGER_MONTHLYDATE:
        {
            TraceMsg(TF_DUMPTRIGGER, "MONTHLY DATE");
            TraceMsg(TF_DUMPTRIGGER, "rgfDays = %d", pTT->Type.MonthlyDate.rgfDays);
            TraceMsg(TF_DUMPTRIGGER, "rgfMonths = %d", pTT->Type.MonthlyDate.rgfMonths);
            break;
        }

        case TASK_TIME_TRIGGER_MONTHLYDOW:
        {
            TraceMsg(TF_DUMPTRIGGER, "MONTHLY DOW");
            TraceMsg(TF_DUMPTRIGGER, "wWhichWeek = %d", pTT->Type.MonthlyDOW.wWhichWeek);
            TraceMsg(TF_DUMPTRIGGER, "rgfDaysOfTheWeek = %d", pTT->Type.MonthlyDOW.rgfDaysOfTheWeek);
            TraceMsg(TF_DUMPTRIGGER, "rgfMonths = %d", pTT->Type.MonthlyDOW.rgfMonths);
            break;
        }

        default:
        {
            ASSERT(FALSE);
            break;
        }
    }

    TraceMsg(TF_DUMPTRIGGER, "-----  END DumpTaskTrigger  -----");
}
#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\updateui.h ===
#define UA_STATUS_IDLE      0
#define UA_STATUS_UPDATEALL 1
#define UA_STATUS_MULTIPLE  2
#define UPDATEALL_PENDING   3
#define MULTIPLE_PENDING    4
#define U_STATUS_ABORTED    5

const UM_ONREQUEST    = WM_USER + 4;
const UM_ONSKIP       = WM_USER + 5;
const UM_ONABORT      = WM_USER + 6;
const UM_ONSKIPSINGLE = WM_USER + 7;
const UM_ONADDSINGLE  = WM_USER + 8;
//  At CleanUp msg we call CleanUp()/Release().
const UM_CLEANUP      = WM_USER + 3;
//  At Ready msg we call AddRef().
//  Who is sending us WM_USER + 9?
const UM_READY        = WM_USER + 10;
const UM_BACKGROUND   = WM_USER + 11;
const UM_DECREASE     = WM_USER + 12;
const UM_BEGINREPORT  = WM_USER + 13;
const UM_ENDREPORT    = WM_USER + 14;
//  Note: This is redefined in urlmon\download
const UM_NEEDREBOOT   = WM_USER + 16;


#define IS_UPDATING(l) (((l)==UA_STATUS_UPDATEALL) || ((l)==UA_STATUS_MULTIPLE))
#define IS_PENDING(l)  (((l)==UPDATEALL_PENDING) || ((l)==MULTIPLE_PENDING))
#define IS_IDLE(l)     ((l)==UA_STATUS_IDLE)

#define DIALER_OFFLINE      0
#define DIALER_ONLINE       1
#define DIALER_CONNECTING   2

#define IDD_START   IDD_RESET

typedef enum    {
    ITEM_STAT_IDLE,
    ITEM_STAT_PENDING,
    ITEM_STAT_SKIPPED,
    ITEM_STAT_FAILED,
    ITEM_STAT_UPDATING,
    ITEM_STAT_SUCCEEDED,
    ITEM_STAT_ABORTED,
    ITEM_STAT_QUEUED,
    E_ATTEMPT_FAILED,
    E_CONNECTION_LOST
} STATUS, CONNECT_ERROR;

#define MAX_COLUMN      16

#define CHECKBOX_NONE   16384
#define CHECKBOX_OFF    4096
#define CHECKBOX_ON     8192

class CDialHelper;
class CUpdateAgent;
class CUpdateController;

struct CookieItemMapEntry   {
    CLSID   _cookie;
    LPARAM  _id;
};

class CCookieItemMap    {
private:
    CookieItemMapEntry* _map;
    UINT                _count;
    UINT                _capacity;
    LPARAM              _lParamNext;
public:
    CCookieItemMap();
    ~CCookieItemMap();
    
    STDMETHODIMP    Init(UINT size = 0);
    STDMETHODIMP    DelCookie(CLSID *);
    STDMETHODIMP    FindLParam(CLSID *, LPARAM *);
    STDMETHODIMP    FindCookie(LPARAM, CLSID *);
    STDMETHODIMP    AddCookie(CLSID *, LPARAM *);
    STDMETHODIMP    ResetMap();
};

extern DWORD WINAPI UpdateThreadProc(LPVOID);
extern BOOL CALLBACK UpdateDlgProc(HWND hDlg, UINT iMsg, WPARAM, LPARAM);
extern BOOL ListView_OnNotify(HWND hDlg, NM_LISTVIEW *, CUpdateController *);

class CUpdateDialog
{
friend BOOL CALLBACK UpdateDlgProc(HWND, UINT, WPARAM, LPARAM);
friend DWORD WINAPI UpdateThreadProc(LPVOID);
public:
    CUpdateDialog();
    ~CUpdateDialog();

    // Helper APIs
    //  Get columns set up.
    STDMETHODIMP        Init(HWND hParent, CUpdateController *);
    //  Show/Hide the page.
    STDMETHODIMP        Show(BOOL);
    //  Change the appearance of item accord to new stat and return old stat
    //  if needed.
    STDMETHODIMP        RefreshStatus(CLSID *, LPTSTR, STATUS, LPTSTR = NULL);
    //  Add new item with the status.
    STDMETHODIMP        AddItem(CLSID *, LPTSTR, STATUS);  
    //  Reset the dialog.
    STDMETHODIMP        ResetDialog(void);
    //  Get a list of cookies that are selected.
    STDMETHODIMP        GetSelectedCookies(CLSID *, UINT *);
    //  Get the count of selected cookies.
    STDMETHODIMP        GetSelectionCount(UINT *);
    //  Get the cookie according to the iItem;
    STDMETHODIMP        IItem2Cookie(const int iItem, CLSID *);
    STDMETHODIMP        CleanUp(void);

    BOOL                SelectFirstUpdatingSubscription();
    DWORD               SetSiteDownloadSize (CLSID *, DWORD);

    HWND    m_hDlg;
    DWORD   m_ThreadID;
    int     colMap[MAX_COLUMN];
    CUpdateController * m_pController;
    static  BOOL    m_bDetail;
    int     m_cDlKBytes;
    int     m_cDlDocs;

    int     m_cxWidget;
    int     m_cyWidget;

private:
    static int CALLBACK SortUpdatingToTop  (LPARAM, LPARAM, LPARAM);
    BOOL    PersistStateToRegistry (HWND hDlg);
    BOOL    GetPersistentStateFromRegistry (struct _PROG_PERSIST_STATE& state, int iCharWidth);

    HWND    m_hLV;
    HWND    m_hParent;
    BOOL    m_bInitialized;
    CCookieItemMap  cookieMap;
};


//----------------------------------------------------------------------------
// Update controller class
//----------------------------------------------------------------------------

typedef struct ReportMapEntry   {
    NOTIFICATIONCOOKIE  startCookie;
    STATUS              status;
    DWORD               progress;
    LPTSTR              name;
    LPTSTR              url;
    SUBSCRIPTIONTYPE    subType;
} * PReportMap;


class CUpdateController : public INotificationSink
{
friend BOOL CALLBACK UpdateDlgProc(HWND, UINT, WPARAM, LPARAM);
friend DWORD WINAPI UpdateThreadProc(LPVOID);
friend BOOL ListView_OnNotify(HWND hDlg, NM_LISTVIEW *, CUpdateController *);
friend class CDialHelper;
private:
    ULONG           m_cRef;         // OLE ref count

    enum            {CUC_ENTRY_INCRE = 32, CUC_MAX_ENTRY = 1024};

    PReportMap      m_aReport;
    UINT            m_cReportCount;
    UINT            m_cReportCapacity;

    INotificationMgr    *m_pNotMgr;
    CUpdateDialog       *m_pDialog;
    CDialHelper         *m_pDialer;

    DWORD           m_ThreadID;     // Update thread ID
    LONG            m_count;        // Current active updates.

    UINT            m_cTotal;
    UINT            m_cFinished;

    BOOL            m_fInit;
    BOOL            m_fSessionEnded;

//  private Helper APIs
    STDMETHODIMP    AddEntry(NOTIFICATIONITEM *, STATUS);
    STDMETHODIMP    DispatchRequest(PReportMap);
    STDMETHODIMP    CancelRequest(PReportMap);
    STDMETHODIMP    IncreaseCount();
    STDMETHODIMP    DecreaseCount(CLSID *);
    STDMETHODIMP    StartPending(void);
    STDMETHODIMP    GetItemList(UINT *);
    STDMETHODIMP    GetLocationOf(CLSID *, LPTSTR, UINT);
    BOOL            IsSkippable(CLSID *);
    STDMETHODIMP    ResyncData();
    STDMETHODIMP    OnBeginReportFromTray(INotification *);
    STDMETHODIMP    OnEndReportFromTray(INotification *);

public:
    CUpdateController();
    ~CUpdateController();

    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // INotificationSink members
    STDMETHODIMP         OnNotification(
        LPNOTIFICATION         pNotification,
        LPNOTIFICATIONREPORT   pNotificationReport,
        DWORD                  dwReserved
    );

    //  Helper APIs:
    STDMETHODIMP    StartService(void);
    STDMETHODIMP    StopService(STATUS);
    STDMETHODIMP    CleanUp();
    STDMETHODIMP    OnRequest(INotification *);
    STDMETHODIMP    Skip(void);
    STDMETHODIMP    SkipSingle(CLSID *);
    STDMETHODIMP    AddSingle(CLSID *);
    STDMETHODIMP    Restart(UINT count);
    STDMETHODIMP    Abort(void);
    STDMETHODIMP    Init(CUpdateDialog *);

    PReportMap      FindReportEntry(CLSID *);
    SUBSCRIPTIONTYPE    GetSubscriptionType(CLSID *);
};

class CUpdateAgent
{
protected:
    CUpdateController   *m_pController;     
    CUpdateDialog       *m_pDialog;
    
public:
    DWORD               m_DialogThreadID;
    DWORD               m_ThreadID;
    CUpdateAgent(void);
    ~CUpdateAgent(void);

    // other functions
    STDMETHODIMP        Init(void);
};

class CDialHelper : public INotificationSink
{
    friend class CUpdateController;
protected:
    ULONG               m_cRef;
    CUpdateController   * m_pController;
    INotificationMgr    * m_pNotMgr;
    INotificationReport * m_pConnAgentReport;
    UINT                m_cConnection;
    DWORD               m_ThreadID;
public:
    INT m_iDialerStatus;

public:
    CDialHelper(void);
    ~CDialHelper(void)  {}

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // INotificationSink members
    STDMETHODIMP         OnNotification(
        LPNOTIFICATION         pNotification,
        LPNOTIFICATIONREPORT   pNotificationReport,
        DWORD                  dwReserved
    );

    STDMETHODIMP        OnInetOnline(INotification *);
    STDMETHODIMP        OnInetOffline(INotification *);
    STDMETHODIMP        NotifyAutoDialer(NOTIFICATIONTYPE);
    STDMETHODIMP        Init(CUpdateController *);
    STDMETHODIMP        CleanUp();
    STDMETHODIMP        HangUp();
    STDMETHODIMP        DialOut();
    BOOL                IsOffline()   {
                            return (DIALER_OFFLINE == m_iDialerStatus);
                        }
    BOOL                IsConnecting()  {
                            return (DIALER_CONNECTING == m_iDialerStatus);
                        }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\wizards.h ===
#ifndef __wizards_h
#define __wizards_h

HRESULT CreateWizard(HWND hwndParent, SUBSCRIPTIONTYPE subType, POOEBuf pOOE);


#endif //__wizards_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\webcrawl.cpp ===
// TODO: Allow trident to download frames (and process new html)
// nuke urlmon code (use trident always)

#include "private.h"
#include "shui.h"
#include "downld.h"
#include "subsmgrp.h"
#include <ocidl.h>

#include <initguid.h>

#include <mluisupp.h>

extern HICON g_webCrawlerIcon;
extern HICON g_channelIcon;
extern HICON g_desktopIcon;

void LoadDefaultIcons();

#undef TF_THISMODULE
#define TF_THISMODULE   TF_WEBCRAWL

#define _ERROR_REPROCESSING -1

// DWORD field of the m_pPages string list
const DWORD DATA_RECURSEMASK = 0x000000FF;  // Levels of recursion from this page
const DWORD DATA_DLSTARTED =   0x80000000;  // Have we started downloading
const DWORD DATA_DLFINISHED =  0x40000000;  // Have we finished this page
const DWORD DATA_DLERROR =     0x20000000;  // An error during download
const DWORD DATA_CODEBASE =    0x10000000;  // Is codebase
const DWORD DATA_LINK =        0x08000000;  // Is link from page (not dependency)

// DWORD field of m_pPendingLinks string list
const DWORD DATA_ROBOTSTXTMASK=0x00000FFF;  // index into m_pRobotsTxt list

// used internally; not actually stored in string list field
const DWORD DATA_ROBOTSTXT =   0x01000000;  // Is robots.txt

// m_pDependencyLinks uses m_pPages values

// DWORD field of m_pRobotsTxt is NULL or (CWCDwordStringList *)

// DWORD field of m_pRobotsTxt referenced string list
const DWORD DATA_ALLOW =        0x80000000;
const DWORD DATA_DISALLOW =     0x40000000;

const WCHAR c_wszRobotsMetaName[] = L"Robots\n";
const int c_iRobotsMetaNameLen = 7;        // string len without nullterm

const WCHAR c_wszRobotsNoFollow[] = L"NoFollow";
const int c_iRobotsNoFollow = 8;

const WCHAR c_wszRobotsTxtURL[] = L"/robots.txt";

const DWORD MAX_ROBOTS_SIZE = 8192;         // Max size of robots.txt file

// tokens for parsing of robots.txt
const CHAR  c_szRobots_UserAgent[] = "User-Agent:";
const CHAR  c_szRobots_OurUserAgent[] = "MSIECrawler";
const CHAR  c_szRobots_Allow[] = "Allow:";
const CHAR  c_szRobots_Disallow[] = "Disallow:";

// This GUID comes from Trident and is a hack for getting PARAM values for APPLET tags.
DEFINE_GUID(CGID_JavaParambagCompatHack, 0x3050F405, 0x98B5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B);

// This GUID is helpfully not defined elsewhere.
DEFINE_GUID(CLSID_JavaVM, 0x08B0E5C0, 0x4FCB, 0x11CF, 0xAA, 0xA5, 0x00, 0x40, 0x1C, 0x60, 0x85, 0x01);

// Get host channel agent's subscription item, if any.
inline HRESULT CWebCrawler::GetChannelItem(ISubscriptionItem **ppChannelItem)
{
    IServiceProvider *pSP;
    HRESULT hr = E_NOINTERFACE;

    if (ppChannelItem)
        *ppChannelItem = NULL;

    if (SUCCEEDED(m_pAgentEvents->QueryInterface(IID_IServiceProvider, (void **)&pSP)) && pSP)
    {
        ISubscriptionItem *pTempChannelItem = NULL;
        pSP->QueryService(CLSID_ChannelAgent, IID_ISubscriptionItem, (void **)&pTempChannelItem);
        pSP->Release();

        if(pTempChannelItem) 
            hr = S_OK;
            
        if(ppChannelItem)
            *ppChannelItem = pTempChannelItem;
        else
        {
            if(pTempChannelItem)
                pTempChannelItem->Release();    
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Helper functions - copied over from urlmon\download\helpers.cxx - Is there
// an equivalent routine or better place for this, webcrawl.cpp?
//
//////////////////////////////////////////////////////////////////////////

// ---------------------------------------------------------------------------
// %%Function: GetVersionFromString
//
//    converts version in text format (a,b,c,d) into two dwords (a,b), (c,d)
//    The printed version number is of format a.b.d (but, we don't care)
// ---------------------------------------------------------------------------
HRESULT
GetVersionFromString(const char *szBuf, LPDWORD pdwFileVersionMS, LPDWORD pdwFileVersionLS)
{
    const char *pch = szBuf;
    char ch;

    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;

    if (!pch)            // default to zero if none provided
        return S_OK;

    if (StrCmpA(pch, "-1,-1,-1,-1") == 0) {
        *pdwFileVersionMS = 0xffffffff;
        *pdwFileVersionLS = 0xffffffff;
    }

    USHORT n = 0;

    USHORT a = 0;
    USHORT b = 0;
    USHORT c = 0;
    USHORT d = 0;

    enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;


    for (ch = *pch++;;ch = *pch++) {

        if ((ch == ',') || (ch == '\0')) {

            switch (have) {

            case HAVE_NONE:
                a = n;
                have = HAVE_A;
                break;

            case HAVE_A:
                b = n;
                have = HAVE_B;
                break;

            case HAVE_B:
                c = n;
                have = HAVE_C;
                break;

            case HAVE_C:
                d = n;
                have = HAVE_D;
                break;

            case HAVE_D:
                return E_INVALIDARG; // invalid arg
            }

            if (ch == '\0') {
                // all done convert a,b,c,d into two dwords of version

                *pdwFileVersionMS = ((a << 16)|b);
                *pdwFileVersionLS = ((c << 16)|d);

                return S_OK;
            }

            n = 0; // reset

        } else if ( (ch < '0') || (ch > '9'))
            return E_INVALIDARG;    // invalid arg
        else
            n = n*10 + (ch - '0');


    } /* end forever */

    // NEVERREACHED
}

/////////////////////////////////////////////////////////////////////////////////////////
// CombineBaseAndRelativeURLs -
//         Three URLs are combined by following rules (this is used for finding the URL
//         to load Applet CABs from.)  Three inputs, the Base URL, the Code Base URL
//         and the file name URL.
//
//         If file name URL is absolute return it.
//         Otherwise if CodeBase URL is absolute combine it with filename and return.
//         Otherwise if Base URL is absolute, combine CodeBase and fileName URL, then
//            combine with Base URL and return it.
////////////////////////////////////////////////////////////////////////////////////////

HRESULT CombineBaseAndRelativeURLs(LPCWSTR szBaseURL, LPCWSTR szRelative1, LPWSTR *szRelative2)
{

    WCHAR wszTemp[INTERNET_MAX_URL_LENGTH];
    DWORD dwLen = ARRAYSIZE(wszTemp);

    ASSERT(szRelative2);                // should never happen.
    if (szRelative2 == NULL)
        return E_FAIL;

    if (IsValidURL(NULL, *szRelative2, 0) == S_OK)
        return S_OK;

    if (szRelative1 && (IsValidURL(NULL, szRelative1, 0) == S_OK))
    {

        if (SUCCEEDED(UrlCombineW((LPCWSTR)szRelative1, (LPCWSTR)*szRelative2, (LPWSTR)wszTemp, &dwLen, 0)))
        {
            BSTR bstrNew = SysAllocString(wszTemp);
            if (bstrNew)
            {
                SAFEFREEBSTR(*szRelative2);
                *szRelative2 = bstrNew;
                return S_OK;
            }
        }
    }

    if (szBaseURL && (IsValidURL(NULL, szBaseURL, 0) == S_OK))
    {
        LPWSTR szNewRel = NULL;
        WCHAR wszCombined[INTERNET_MAX_URL_LENGTH];

        if (szRelative1)
        {
            // NOTE: lstr[cpy|cat]W are macroed to work on Win95.
            DWORD dwLen2 = lstrlenW(*szRelative2);
            StrCpyNW(wszTemp, szRelative1, ARRAYSIZE(wszTemp) - 1); //paranoia
            DWORD dwTempLen = lstrlenW(wszTemp);
            if ((dwLen2 > 0) && ((*szRelative2)[dwLen2-1] == (unsigned short)L'\\') ||
                                ((*szRelative2)[dwLen2-1] == (unsigned short) L'/'))
            {
                StrNCatW(wszTemp, *szRelative2, ARRAYSIZE(wszTemp) - dwTempLen);
            }
            else
            {
                StrNCatW(wszTemp, L"/", ARRAYSIZE(wszTemp) - dwTempLen);
                StrNCatW(wszTemp, *szRelative2, ARRAYSIZE(wszTemp) - dwTempLen - 1);
            }

            szNewRel = wszTemp;
        }
        else
        {
            szNewRel = *szRelative2;
        }

        dwLen = INTERNET_MAX_URL_LENGTH;
        if (SUCCEEDED(UrlCombineW((LPCWSTR)szBaseURL, (LPCWSTR)szNewRel, (LPWSTR)wszCombined, &dwLen, 0)))
        {
            BSTR bstrNew = SysAllocString(wszCombined);
            if (bstrNew)
            {
                SAFEFREEBSTR(*szRelative2);
                *szRelative2 = bstrNew;
                return S_OK;
            }
        }
    }

    // In all likelyhood one of the URL's in bad and nothing good can be done.
    return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////
//
// CWebCrawler implementation
//
//////////////////////////////////////////////////////////////////////////

//
// CWebCrawler Helpers
//

CWebCrawler::CWebCrawler()
{
    DBG("Creating CWebCrawler object");

    InitializeCriticalSection(&m_critDependencies);
}

CWebCrawler::~CWebCrawler()
{
    _CleanUp();

    DeleteCriticalSection(&m_critDependencies);
    DBG("Destroyed CWebCrawler object");
}

void CWebCrawler::CleanUp()
{
    _CleanUp();
    CDeliveryAgent::CleanUp();
}

void CWebCrawler::_CleanUp()
{
    if (m_pCurDownload)
    {
        m_pCurDownload->DoneDownloading();
        m_pCurDownload->Release();
        m_pCurDownload = NULL;
    }

    CRunDeliveryAgent::SafeRelease(m_pRunAgent);

    SAFEFREEBSTR(m_bstrHostName);
    SAFEFREEBSTR(m_bstrBaseURL);
    SAFELOCALFREE(m_pszLocalDest);
    SAFELOCALFREE(m_pBuf);

    EnterCriticalSection(&m_critDependencies);
    SAFEDELETE(m_pDependencies);
    LeaveCriticalSection(&m_critDependencies);
    if (m_pDownloadNotify)
    {
        m_pDownloadNotify->LeaveMeAlone();
        m_pDownloadNotify->Release();
        m_pDownloadNotify=NULL;
    }

    SAFEDELETE(m_pPages);
    SAFEDELETE(m_pPendingLinks);
    SAFEDELETE(m_pDependencyLinks);
    SAFERELEASE(m_pUrlIconHelper);

    FreeRobotsTxt();
    FreeCodeBaseList();
}

// Format of m_pRobotsTxt:
// Array of hostnames for which we have attempted to get Robots.txt
// DWORD for each hostname contains pointer to CDwordStringList of Robots.txt data,
//  or 0 if we couldn't find robots.txt for that host name
// Robots.txt data stored in form: url, flag = allow or disallow
void CWebCrawler::FreeRobotsTxt()
{
    if (m_pRobotsTxt)
    {
        DWORD_PTR dwPtr;
        int iLen = m_pRobotsTxt->NumStrings();
        for (int i=0; i<iLen; i++)
        {
            dwPtr = m_pRobotsTxt->GetStringData(i);
            if (dwPtr)
            {
                delete ((CWCStringList *)dwPtr);
                m_pRobotsTxt->SetStringData(i, 0);
            }
        }

        delete m_pRobotsTxt;
        m_pRobotsTxt = NULL;
    }
}

void CWebCrawler::FreeCodeBaseList()
{
    if (m_pCodeBaseList) {
        CCodeBaseHold *pcbh;
        int iLen = m_pCodeBaseList->NumStrings();
        for (int i=0; i<iLen; i++)
        {
            pcbh = (CCodeBaseHold *)m_pCodeBaseList->GetStringData(i);
            if (pcbh != NULL)
            {
                SAFEFREEBSTR(pcbh->szDistUnit);
                SAFEDELETE(pcbh);
                m_pCodeBaseList->SetStringData(i, 0);
            }
        }

        SAFEDELETE(m_pCodeBaseList);
    }
}

HRESULT CWebCrawler::StartOperation()
{
    ISubscriptionItem *pItem = m_pSubscriptionItem;

    DWORD           dwTemp;

    ASSERT(pItem);

    DBG("CWebCrawler in StartOperation");

    if (m_pCurDownload || GetBusy())
    {
        DBG_WARN("Webcrawl busy, returning failure");
        return E_FAIL;
    }

    SAFEFREEBSTR(m_bstrBaseURL);
    if (FAILED(
        ReadBSTR(pItem, c_szPropURL, &m_bstrBaseURL)) ||
        !m_bstrBaseURL ||
        !CUrlDownload::IsValidURL(m_bstrBaseURL))
    {
        DBG_WARN("Couldn't get valid URL, aborting");
        SetEndStatus(E_INVALIDARG);
        SendUpdateNone();
        return E_INVALIDARG;
    }

    if (SHRestricted2W(REST_NoSubscriptionContent, NULL, 0))
        SetAgentFlag(FLAG_CHANGESONLY);

    if (IsAgentFlagSet(FLAG_CHANGESONLY))
    {
        m_dwRecurseLevels = 0;
        m_dwRecurseFlags = WEBCRAWL_DONT_MAKE_STICKY;
        DBG("Webcrawler is in 'changes only' mode.");
    }
    else
    {
/*
        BSTR bstrLocalDest=NULL;
        SAFELOCALFREE(m_pszLocalDest);
        ReadBSTR(c_szPropCrawlLocalDest, &bstrLocalDest);
        if (bstrLocalDest && bstrLocalDest[0])
        {
            int iLen = SysStringByteLen(bstrLocalDest)+1;
            m_pszLocalDest = (LPTSTR) MemAlloc(LMEM_FIXED, iLen);
            if (m_pszLocalDest)
            {
                MyOleStrToStrN(m_pszLocalDest, iLen, bstrLocalDest);
            }
        }
        SAFEFREEBSTR(bstrLocalDest);
*/

        m_dwRecurseLevels=0;
        ReadDWORD(pItem, c_szPropCrawlLevels, &m_dwRecurseLevels);

        if (!IsAgentFlagSet(DELIVERY_AGENT_FLAG_NO_RESTRICTIONS))
        {
            // Note: MaxWebcrawlLevels is stored as N+1 because 0
            // disables the restriction
            dwTemp = SHRestricted2W(REST_MaxWebcrawlLevels, NULL, 0);
            if (dwTemp && m_dwRecurseLevels >= dwTemp)
                m_dwRecurseLevels = dwTemp - 1;
        }

        m_dwRecurseFlags=0;
        ReadDWORD(pItem, c_szPropCrawlFlags, &m_dwRecurseFlags);

        // Read max size in cache in KB
        m_dwMaxSize=0;
        ReadDWORD(pItem, c_szPropCrawlMaxSize, &m_dwMaxSize);
        if (!IsAgentFlagSet(DELIVERY_AGENT_FLAG_NO_RESTRICTIONS))
        {
            dwTemp = SHRestricted2W(REST_MaxSubscriptionSize, NULL, 0);
            if (dwTemp && (!m_dwMaxSize || m_dwMaxSize > dwTemp))
                m_dwMaxSize = dwTemp;
        }

        if (IsRecurseFlagSet(WEBCRAWL_DONT_MAKE_STICKY))
            dwTemp = 0;

        // Read old group ID
        ReadLONGLONG(pItem, c_szPropCrawlGroupID, &m_llOldCacheGroupID);

        // Read new ID if present
        m_llCacheGroupID = 0;
        ReadLONGLONG(pItem, c_szPropCrawlNewGroupID, &m_llCacheGroupID);
        if (m_llCacheGroupID)
        {
            DBG("Adding to existing cache group");
        }
    } // !ChangesOnly

    // finish initializing new operation
    m_iDownloadErrors = 0;
    m_dwCurSize = 0;
    m_lMaxNumUrls = (m_dwRecurseLevels) ? -1 : 1;
    SAFEFREEBSTR(m_bstrHostName);

    m_dwCurSize = NULL;
    m_pPages = NULL;
    m_pDependencies = NULL;

    // After calling this, we'll reenter either in "StartDownload" (connection successful)
    //  or in "AbortUpdate" with GetEndStatus() == INET_E_AGENT_CONNECTION_FAILED
    return CDeliveryAgent::StartOperation();
}

HRESULT CWebCrawler::AgentPause(DWORD dwFlags)
{
    DBG("CWebCrawler::AgentPause");

    // Abort our current url
    if (m_pRunAgent)
    {
        m_pRunAgent->AgentPause(dwFlags);
    }

    if (m_pCurDownload)
    {
        m_pCurDownload->AbortDownload();
        m_pCurDownload->DestroyBrowser();
    }

    return CDeliveryAgent::AgentPause(dwFlags);
}

HRESULT CWebCrawler::AgentResume(DWORD dwFlags)
{
    DBG("CWebCrawler::AgentResume");

    if (m_pRunAgent)
    {
        m_pRunAgent->AgentResume(dwFlags);
    }
    else
    {
        // If we just increased our cache size, reprocess same url
        if (SUBSCRIPTION_AGENT_RESUME_INCREASED_CACHE & dwFlags)
        {
            DBG("CWebCrawler reprocessing same url after cache size increase");
            OnDownloadComplete(0, _ERROR_REPROCESSING);
        }
        else
        {
            // If we're not still downloading, restart our same url
            if (0 == m_iNumPagesDownloading)
            {
                if (FAILED(ActuallyStartDownload(m_pCurDownloadStringList, m_iCurDownloadStringIndex, TRUE)))
                {
                    ASSERT_MSG(0, "CWebCrawler::AgentResume"); // this should never happen
                    SetEndStatus(E_FAIL);
                    CleanUp();
                }
            }
        }
    }

    return CDeliveryAgent::AgentResume(dwFlags);
}

// Forcibly abort current operation
HRESULT CWebCrawler::AgentAbort(DWORD dwFlags)
{
    DBG("CWebCrawler::AgentAbort");

    if (m_pCurDownload)
    {
        m_pCurDownload->DoneDownloading();
    }

    if (m_pRunAgent)
    {
        m_pRunAgent->AgentAbort(dwFlags);
    }

    return CDeliveryAgent::AgentAbort(dwFlags);
}

//---------------------------------------------------------------
//

HRESULT CWebCrawler::StartDownload()
{
    ASSERT(!m_pCurDownload);

    m_iPagesStarted = 0;
    m_iRobotsStarted = 0;
    m_iDependencyStarted = 0;
    m_iDependenciesProcessed = 0;
    m_iTotalStarted = 0;
    m_iCodeBaseStarted = 0;
    m_iNumPagesDownloading = 0;

    // Create new cache group
    if (IsAgentFlagSet(FLAG_CHANGESONLY))
    {
        m_llCacheGroupID = 0;
    }
    else
    {
        if (!m_llCacheGroupID)
        {
            m_llCacheGroupID = CreateUrlCacheGroup(
                (IsRecurseFlagSet(WEBCRAWL_DONT_MAKE_STICKY) ? 0 : CACHEGROUP_FLAG_NONPURGEABLE), 0);

            ASSERT_MSG(m_llCacheGroupID != 0, "Create cache group failed");
        }
    }

    // Create string lists
    m_pPages = new CWCDwordStringList;
    if (m_pPages)
        m_pPages->Init(m_dwRecurseLevels ? -1 : 512);
    else
        SetEndStatus(E_FAIL);

    if (m_dwRecurseLevels && !IsRecurseFlagSet(WEBCRAWL_IGNORE_ROBOTSTXT))
    {
        m_pRobotsTxt = new CWCDwordStringList;
        if (m_pRobotsTxt)
            m_pRobotsTxt->Init(512);
        else
            SetEndStatus(E_FAIL);
    }

    // FEATURE : Shouldn't allocate this memory in changes only mode
    m_pCodeBaseList = new CWCDwordStringList;
    if (m_pCodeBaseList)
        m_pCodeBaseList->Init(512);
    else
        SetEndStatus(E_FAIL);

    // Avoid duplicate processing of dependencies
    if (!IsAgentFlagSet(FLAG_CHANGESONLY))
    {
        m_pDependencies = new CWCDwordStringList;
        if (m_pDependencies)
            m_pDependencies->Init();
        else
            SetEndStatus(E_FAIL);
    }

    if (GetEndStatus() == E_FAIL)
        return E_FAIL;

    m_pCurDownload = new CUrlDownload(this, 0);
    if (!m_pCurDownload)
        return E_OUTOFMEMORY;

    // Add first URL to string list, then start it
    if ((CWCStringList::STRLST_ADDED == m_pPages->AddString(m_bstrBaseURL, m_dwRecurseLevels)) &&
        m_pPages->NumStrings() == 1)
    {
        return StartNextDownload();
    }

    SetEndStatus(E_FAIL);
    return E_FAIL;
}

// Attempts to begin the next download
HRESULT CWebCrawler::StartNextDownload()
{
    if (!m_pPages || m_iNumPagesDownloading)
        return E_FAIL;

    CWCStringList *pslUrls = NULL;
    int iIndex = 0;

    // See if we have any more URLs to download.
    // Check dependency links first
    if (m_pDependencyLinks)
    {
        ProcessDependencyLinks(&pslUrls, &iIndex);
#ifdef DEBUG
        if (pslUrls) DBG("Downloading dependency link (frame):");
#endif
    }

    if (!pslUrls)
    {
        // Check robots.txt
        if (m_pRobotsTxt && (m_iRobotsStarted < m_pRobotsTxt->NumStrings()))
        {
            pslUrls = m_pRobotsTxt;
            iIndex = m_iRobotsStarted ++;
        }
        else if (m_pPendingLinks)   // add pending links to pages list
        {
            // Pending links to process and we've retrieved all robots.txt
            // Process pending links (validate & add to download list)
            ProcessPendingLinks();
        }

        if (!pslUrls && (m_iPagesStarted < m_pPages->NumStrings()))
        {
            DWORD_PTR dwTmp;
            ASSERT(!m_pDependencyLinks);// should be downloaded already
            ASSERT(!m_pPendingLinks);   // should be validated already
            // Skip any pages we've started
            while (m_iPagesStarted < m_pPages->NumStrings())
            {
                dwTmp = m_pPages->GetStringData(m_iPagesStarted);
                if (IsFlagSet(dwTmp, DATA_DLSTARTED))
                    m_iPagesStarted++;
                else
                    break;
            }
            if (m_iPagesStarted < m_pPages->NumStrings())
            {
                pslUrls = m_pPages;
                iIndex = m_iPagesStarted ++;
            }
        }

        if (!pslUrls && (m_iCodeBaseStarted < m_pCodeBaseList->NumStrings()))
        {
            // Nothing else pull, do code bases last.

            while (m_iCodeBaseStarted < m_pCodeBaseList->NumStrings())
            {
                CCodeBaseHold *pcbh = (CCodeBaseHold *)
                                    m_pCodeBaseList->GetStringData(m_iCodeBaseStarted);
                if (IsFlagSet(pcbh->dwFlags, DATA_DLSTARTED))
                    m_iCodeBaseStarted++;
                else
                    break;
            }
            while (m_iCodeBaseStarted < m_pCodeBaseList->NumStrings())
            {
                // We have some codebases to download.
                // We return if the download is async and simply
                // start the next one if it finishes synchronously
                iIndex = m_iCodeBaseStarted;
                m_iCodeBaseStarted++; // increment so that next download is not repeated

                // Init the cur download infor for resume if paused
                m_iCurDownloadStringIndex = iIndex;
                m_pCurDownloadStringList = m_pCodeBaseList;
                
               if(ActuallyDownloadCodeBase(m_pCodeBaseList, iIndex, FALSE) == E_PENDING)
                    return S_OK; // We break out of the while and try next download in OnAgentEnd()

            }
        }
    }

    if (pslUrls)
    {
        m_iCurDownloadStringIndex = iIndex;
        m_pCurDownloadStringList = pslUrls;

        return ActuallyStartDownload(pslUrls, iIndex);
    }

    DBG("WebCrawler: StartNextDownload failing, nothing more to download.");
    return E_FAIL;
}

HRESULT CWebCrawler::ActuallyStartDownload(CWCStringList *pslUrls, int iIndex, BOOL fReStart /* = FALSE */)
{
    // We have urls to download. Do it.
    DWORD_PTR dwData;
    LPCWSTR pwszURL;
    DWORD   dwBrowseFlags;
    BDUMethod method;
    BDUOptions options;

    if(pslUrls == m_pCodeBaseList)
    {
        ASSERT(fReStart); // Should happen only with resume
        HRESULT hr = ActuallyDownloadCodeBase(m_pCodeBaseList, iIndex, fReStart);
        if(E_PENDING == hr)
            return S_OK;
        return E_FAIL; // hackhack - since we don't handle synchronous downloads well - we hang if 
                       // resumed download is synchronous
    }

    if (pslUrls != m_pRobotsTxt)
    {
        dwData = pslUrls->GetStringData(iIndex);
#ifdef DEBUG
        if (fReStart)
            if (~(dwData & DATA_DLSTARTED)) DBG_WARN("WebCrawler: Trying to restart one we haven't started yet!");
        else
            if ((dwData & DATA_DLSTARTED)) DBG_WARN("WebCrawler: Trying to download one we've already started?");
#endif
        pslUrls->SetStringData(iIndex, DATA_DLSTARTED | dwData);
    }
    else
        dwData = DATA_ROBOTSTXT;

    pwszURL = pslUrls->GetString(iIndex);

    ASSERT(iIndex < pslUrls->NumStrings());

#ifdef DEBUG
    int iMax = m_lMaxNumUrls;
    if (iMax<0)
        iMax = m_pPages->NumStrings() + ((m_pRobotsTxt) ? m_pRobotsTxt->NumStrings() : 0);
    TraceMsgA(TF_THISMODULE, "WebCrawler GET_URL (%d of %c%d) Recurse %d : %ws",
        m_iTotalStarted+1, ((m_lMaxNumUrls>0) ? ' ' : '?'), iMax,
        pslUrls->GetStringData(iIndex) & DATA_RECURSEMASK, pwszURL);
#endif

    dwBrowseFlags = DLCTL_DOWNLOADONLY |
        DLCTL_NO_FRAMEDOWNLOAD | DLCTL_NO_SCRIPTS | DLCTL_NO_JAVA |
        DLCTL_NO_RUNACTIVEXCTLS;

    if (IsRecurseFlagSet(WEBCRAWL_GET_IMAGES))      dwBrowseFlags |= DLCTL_DLIMAGES;
    if (IsRecurseFlagSet(WEBCRAWL_GET_VIDEOS))      dwBrowseFlags |= DLCTL_VIDEOS;
    if (IsRecurseFlagSet(WEBCRAWL_GET_BGSOUNDS))    dwBrowseFlags |= DLCTL_BGSOUNDS;
    if (!IsRecurseFlagSet(WEBCRAWL_GET_CONTROLS))   dwBrowseFlags |= DLCTL_NO_DLACTIVEXCTLS;
    if (IsRecurseFlagSet(WEBCRAWL_PRIV_OFFLINE_MODE))
    {
        dwBrowseFlags |= DLCTL_FORCEOFFLINE;
        dwBrowseFlags &= ~(DLCTL_DLIMAGES | DLCTL_VIDEOS | DLCTL_BGSOUNDS);
        DBG("GET is OFFLINE");
    }

    m_pCurDownload->SetDLCTL(dwBrowseFlags);

#ifdef DEBUG
    if (fReStart)
    {
        ASSERT(m_iCurDownloadStringIndex == iIndex);
        ASSERT(m_pCurDownloadStringList == pslUrls);
    }
#endif

    if (!fReStart)
    {
        // Get the info for change detection, unless we already know it's changed
        if (!IsAgentFlagSet(FLAG_CRAWLCHANGED) && !(dwData & DATA_ROBOTSTXT))
        {
            TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];

            m_varChange.vt = VT_EMPTY;

            if (IsAgentFlagSet(FLAG_CHANGESONLY))
            {
                // "Changes Only" mode, we have persisted a change detection code
                ASSERT(m_iTotalStarted == 0);
                LPCWSTR pPropChange = c_szPropChangeCode;
                m_pSubscriptionItem->ReadProperties(1, &pPropChange, &m_varChange);
            }

            BOOL fMustGET = TRUE;

            MyOleStrToStrN(szUrl, INTERNET_MAX_URL_LENGTH, pwszURL);
            PreCheckUrlForChange(szUrl, &m_varChange, &fMustGET);

            if (IsAgentFlagSet(FLAG_CHANGESONLY) && !fMustGET)
                SetAgentFlag(FLAG_HEADONLY);
        }

        m_iTotalStarted ++;
    }

    if (IsPaused())
    {
        DBG("WebCrawler paused, not starting another download");
        if (m_pCurDownload)
            m_pCurDownload->DestroyBrowser(); // free browser until resumed
        return E_PENDING;
    }

    m_iNumPagesDownloading ++;

    // Send our update progress with the url we're about to download
    SendUpdateProgress(pwszURL, m_iTotalStarted, m_lMaxNumUrls, (m_dwCurSize >> 10));

    if (IsAgentFlagSet(FLAG_HEADONLY))
    {
        ASSERT(m_iTotalStarted == 1);
        method = BDU2_HEADONLY;                 // Only get HEAD info with Urlmon
    }
    else if (IsAgentFlagSet(FLAG_CHANGESONLY)   // Only want HTML, or
        || m_pszLocalDest                       // We're going to move this one file, or
        || (dwData & DATA_ROBOTSTXT))           // This is a robots.txt, so
    {
        method = BDU2_URLMON;                   // Get with Urlmon
    }
    else if (m_iTotalStarted == 1)              // First file, we need status code, so
    {
        ISubscriptionItem *pCDFItem;
        method = BDU2_SNIFF;                    // Get with Urlmon then MSHTML (if HTML)

        // Find out if we're hosted by channel agent
        if (SUCCEEDED(GetChannelItem(&pCDFItem)))
        {
            // If we're hosted by channel agent, use its original hostname
            BSTR bstrBaseUrl;
            if (SUCCEEDED(ReadBSTR(pCDFItem, c_szPropURL, &bstrBaseUrl)))
            {
                GetHostName(bstrBaseUrl, &m_bstrHostName);
                SysFreeString(bstrBaseUrl);
            }
#ifdef DEBUG
            if (m_bstrHostName)
                TraceMsg(TF_THISMODULE, "Got host name from channel agent: %ws", m_bstrHostName);
#endif
            pCDFItem->Release();

            DBG("Using 'smart' mode for first url in webcrawl; spawned from channel crawl");
            method = BDU2_SMART;                // Use 'smart' mode for first url if channel crawl
            SetAgentFlag(FLAG_HOSTED);
        }
    }
    else
        method = BDU2_SMART;                    // Get with Urlmon or MSHTML as appropriate

    if (dwData & DATA_ROBOTSTXT)
        options = BDU2_NEEDSTREAM;              // Need IStream to parse robots.txt
    else
        options = BDU2_NONE;

    options |= BDU2_DOWNLOADNOTIFY_REQUIRED;    // Always get download notify callbacks

    if (IsRecurseFlagSet(WEBCRAWL_ONLY_LINKS_TO_HTML) && (dwData & DATA_LINK))
    {
        // Don't follow any links unless they are to html pages.
        options |= BDU2_FAIL_IF_NOT_HTML;
    }

    if (FAILED(m_pCurDownload->BeginDownloadURL2(pwszURL,
            method, options, m_pszLocalDest, 
            m_dwMaxSize ? (m_dwMaxSize<<10)-m_dwCurSize : 0)))
    {
        DBG("BeginDownloadURL2 failed (ignoring & waiting for OnDownloadComplete call)");
    }

    return S_OK;
}

HRESULT CWebCrawler::ActuallyDownloadCodeBase(CWCStringList *pslUrls, int iIndex, BOOL fReStart)
{
    CCodeBaseHold *pcbh;
    LPCWSTR pwszURL;
    HRESULT hr = S_OK;

    if (pslUrls != m_pCodeBaseList)
    {
        ASSERT(0);
        DBG_WARN("WebCrawler: Wrong URLs being processed as CodeBase.");
        hr = E_FAIL;
        goto Exit;
    }

    pcbh = (CCodeBaseHold *)pslUrls->GetStringData(iIndex);

#ifdef DEBUG
    if (fReStart)
        if (~(pcbh->dwFlags & DATA_DLSTARTED)) DBG_WARN("WebCrawler: Trying to restart CodeBase D/L we haven't started yet!");
    else
        if ((pcbh->dwFlags & DATA_DLSTARTED)) DBG_WARN("WebCrawler: Trying to download CodeBase D/L we've already started?");
#endif
    pcbh->dwFlags |= DATA_DLSTARTED;

    pwszURL = pslUrls->GetString(iIndex);

    ASSERT(iIndex < pslUrls->NumStrings());

    if (!fReStart)
        m_iTotalStarted ++;

    if (IsPaused())
    {
        DBG("WebCrawler paused, not starting another download");
        if (m_pCurDownload)
            m_pCurDownload->DestroyBrowser(); // free browser until resumed
        return S_FALSE;
    }

    m_iNumPagesDownloading ++;

    // Send our update progress with the CODEBASE we're about to download
    SendUpdateProgress(pwszURL, m_iTotalStarted, m_lMaxNumUrls);

    if (m_pRunAgent)
    {
        ASSERT(0);
        DBG_WARN("WebCrawler: Attempting to download next CODEBASE when not done last one.");
        hr = E_FAIL;
        goto Exit;
    }
    else
    {
        // create subscription item for CDL agent.

        ISubscriptionItem *pItem = NULL;

        if (m_dwMaxSize && ((m_dwCurSize>>10) >= m_dwMaxSize))
        {
            // We've exceeded our maximum download KB limit and can't continue.
            DBG_WARN("WebCrawler: Exceeded Maximum KB download limit with CodeBase download.");
            SetEndStatus(hr = INET_E_AGENT_MAX_SIZE_EXCEEDED);
            goto Exit;
        }

        if (!m_pSubscriptionItem ||
            FAILED(hr = DoCloneSubscriptionItem(m_pSubscriptionItem, NULL, &pItem)))
        {
            goto Exit;
        }
        ASSERT(pItem != NULL);

        WriteOLESTR(pItem, c_szPropURL, pwszURL);
        WriteOLESTR(pItem, L"DistUnit", pcbh->szDistUnit);
        WriteDWORD(pItem, L"VersionMS", pcbh->dwVersionMS);
        WriteDWORD(pItem, L"VersionLS", pcbh->dwVersionLS);
        if (m_dwMaxSize)
            WriteDWORD(pItem, c_szPropCrawlMaxSize, m_dwMaxSize - (m_dwCurSize>>10));    // KB limit for us to pull.

        m_pRunAgent = new CRunDeliveryAgent();
        if (m_pRunAgent)
            hr = m_pRunAgent->Init((CRunDeliveryAgentSink *)this, pItem, CLSID_CDLAgent);
        pItem->Release();

        if (m_pRunAgent && SUCCEEDED(hr))
        {
            hr = m_pRunAgent->StartAgent();
            //if (hr == E_PENDING)
            //{
                //hr = S_OK;
            //}
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

Exit:
    return hr;

}

HRESULT CWebCrawler::ProcessDependencyLinks(CWCStringList **ppslUrls, int *piStarted)
{
    ASSERT(ppslUrls && !*ppslUrls && piStarted);

    int iIndex;
    DWORD_PTR dwData;

    if (!m_pDependencyLinks)
        return S_FALSE;

    // See if we have any more dependency links to download
    while (m_iDependencyStarted < m_pDependencyLinks->NumStrings())
    {
        if (!m_pPages->FindString(m_pDependencyLinks->GetString(m_iDependencyStarted),
                               m_pDependencyLinks->GetStringLen(m_iDependencyStarted), &iIndex))
        {
            ASSERT(0);  // find string failed?!? We added it above!
            return E_FAIL;
        }

        ASSERT(iIndex>=0 && iIndex<m_pPages->NumStrings());

        m_iDependencyStarted ++;

        // See if we've downloaded this yet.
        dwData = m_pPages->GetStringData(iIndex);
        if (!(dwData & DATA_DLSTARTED))
        {
            // Nope. Start download.
            *ppslUrls = m_pPages;
            *piStarted = iIndex;
            return S_OK;
        }

        // We have already downloaded this page. Go to next dependency link.
    }

    // Done processing. Clear for next page.
    SAFEDELETE(m_pDependencyLinks);

    return S_FALSE;
}

HRESULT CWebCrawler::ProcessPendingLinks()
{
    int         iNumLinks, iAddCode, i, iAddIndex, iRobotsIndex;
    LPCWSTR     pwszUrl;
    BOOL        fAllow;

    if (!m_pPendingLinks)
        return S_FALSE;

    ASSERT(m_lMaxNumUrls<0);
    ASSERT(0 == (m_dwPendingRecurseLevel & ~DATA_RECURSEMASK));

    iNumLinks = m_pPendingLinks->NumStrings();

    TraceMsg(TF_THISMODULE, "Processing %d pending links from %ws",
        iNumLinks, m_pPages->GetString(m_iPagesStarted-1));

    // Add the links to our global page list
    for (i=0; i<iNumLinks; i++)
    {
        // Validate with robots.txt if appropriate
        pwszUrl = m_pPendingLinks->GetString(i);
        iRobotsIndex = (int)(m_pPendingLinks->GetStringData(i) & DATA_ROBOTSTXTMASK);
        ValidateWithRobotsTxt(pwszUrl, iRobotsIndex, &fAllow);

        if (fAllow)
        {
/*
As long as we retrieve pages in decreasing-recursion order (top to bottom), we don't
have to worry about bumping pages to a higher recurse level (except for frames).
*/
            iAddCode = m_pPages->AddString(pwszUrl,
                        DATA_LINK | m_dwPendingRecurseLevel,
                        &iAddIndex);
            if (iAddCode == CWCStringList::STRLST_FAIL)
                break;
        }
    }
    SAFEDELETE(m_pPendingLinks);

    return S_OK;
}


// Combine with our base url to get full url
// We use this for frames, but also for <Link> tags, since the processing is identical
HRESULT CWebCrawler::CheckFrame(IUnknown *punkItem, BSTR *pbstrItem, DWORD_PTR dwBaseUrl, DWORD *pdwStringData)
{
    WCHAR   wszCombined[INTERNET_MAX_URL_LENGTH];
    DWORD   dwLen = ARRAYSIZE(wszCombined);

    ASSERT(pbstrItem && *pbstrItem && punkItem && dwBaseUrl);
    if (!pbstrItem || !*pbstrItem || !punkItem || !dwBaseUrl)
        return E_FAIL;      // bogus

    if (SUCCEEDED(UrlCombineW((LPCWSTR)dwBaseUrl, *pbstrItem, wszCombined, &dwLen, 0)))
    {
        BSTR bstrNew = SysAllocString(wszCombined);

        if (bstrNew)
        {
            SysFreeString(*pbstrItem);
            *pbstrItem = bstrNew;
            return S_OK;
        }
    }

    TraceMsg(TF_WARNING, "CWebCrawler::CheckFrame failing. Not getting frame or <link> url=%ws.", *pbstrItem);
    return E_FAIL;  // Couldn't combine url; don't add
}

// See if we should follow this link. Clears pbstrItem if not.
// Accepts either pLink or pArea
HRESULT CWebCrawler::CheckLink(IUnknown *punkItem, BSTR *pbstrItem, DWORD_PTR dwThis, DWORD *pdwStringData)
{
    HRESULT         hrRet = S_OK;
    CWebCrawler    *pThis = (CWebCrawler *)dwThis;

    ASSERT(pbstrItem && *pbstrItem && punkItem && dwThis);
    if (!pbstrItem || !*pbstrItem || !punkItem || !dwThis)
        return E_FAIL;      // bogus

    // First see if it's 'valid'
    // We only add the link if it's HTTP (or https)
    // (we don't want to get mailto: links, for example)
    if (CUrlDownload::IsValidURL(*pbstrItem))
    {
        // Strip off any anchor
        CUrlDownload::StripAnchor(*pbstrItem);
    }
    else
    {
        // Skip this link
        SysFreeString(*pbstrItem);
        *pbstrItem = NULL;
        return S_FALSE;
    }

    if (pThis->IsRecurseFlagSet(WEBCRAWL_ONLY_LINKS_TO_HTML))
    {
        // See if we can tell that this is not an HTML link
        if (CUrlDownload::IsNonHtmlUrl(*pbstrItem))
        {
            // Skip this link
            SysFreeString(*pbstrItem);
            *pbstrItem = NULL;
            return S_FALSE;
        }
    }

    if (!(pThis->IsRecurseFlagSet(WEBCRAWL_LINKS_ELSEWHERE)))
    {
        BSTR bstrHost=NULL;
        IHTMLAnchorElement *pLink=NULL;
        IHTMLAreaElement *pArea=NULL;

        // Check to see if the host names match
        punkItem->QueryInterface(IID_IHTMLAnchorElement, (void **)&pLink);

        if (pLink)
        {
            pLink->get_hostname(&bstrHost);
            pLink->Release();
        }
        else
        {
            punkItem->QueryInterface(IID_IHTMLAreaElement, (void **)&pArea);

            if (pArea)
            {
                pArea->get_hostname(&bstrHost);
                pArea->Release();
            }
            else
            {
                DBG_WARN("CWebCrawler::CheckLink Unable to get Area or Anchor interface!");
                return E_FAIL;      // Bad element
            }
        }

        if (!bstrHost || !*bstrHost)
        {
            DBG_WARN("CWebCrawler::CheckLink : (pLink|pArea)->get_hostname() failed");
            hrRet = S_OK;      // always accept if get_hostname fails
        }
        else
        {
            if (pThis->m_bstrHostName && MyAsciiCmpW(bstrHost, pThis->m_bstrHostName))
            {
                // Skip url; different host name.
                SAFEFREEBSTR(*pbstrItem);
                hrRet = S_FALSE;
            }
        }

        SAFEFREEBSTR(bstrHost);
    }

    if (*pbstrItem && pdwStringData)
    {
        pThis->GetRobotsTxtIndex(*pbstrItem, TRUE, pdwStringData);
        *pdwStringData &= DATA_ROBOTSTXTMASK;
    }
    else if (pdwStringData)
        *pdwStringData = 0;

    return hrRet;
}

// S_OK    : Already retrieved this robots.txt info
// S_FALSE : Haven't yet retrieved this robots.txt info
// E_*     : Bad
HRESULT CWebCrawler::GetRobotsTxtIndex(LPCWSTR pwszUrl, BOOL fAddToList, DWORD *pdwRobotsTxtIndex)
{
    HRESULT hr=S_OK;
    int    iIndex=-1;

    if (m_pRobotsTxt)
    {
        // See which robots.txt file we should use to validate this link
        // If not yet available, add it to the list to be downloaded
        DWORD  dwBufLen = lstrlenW(pwszUrl) + ARRAYSIZE(c_wszRobotsTxtURL); //This get's us a terminating NULL
        LPWSTR pwszRobots = (LPWSTR)MemAlloc(LMEM_FIXED, dwBufLen * sizeof(WCHAR));
        int    iAddCode;

        if (pwszRobots)
        {
            // PERF: do the internetcombine in startnextdownload
            if (SUCCEEDED(UrlCombineW(pwszUrl, c_wszRobotsTxtURL, pwszRobots, &dwBufLen, 0))
                && !memcmp(pwszRobots, L"http", 4 * sizeof(WCHAR)))
            {
                if (fAddToList)
                {
                    iAddCode = m_pRobotsTxt->AddString(pwszRobots, 0, &iIndex);
                }
                else
                {
                    if (m_pRobotsTxt->FindString(pwszRobots, -1, &iIndex))
                    {
                        iAddCode = CWCStringList::STRLST_DUPLICATE;
                    }
                    else
                    {
                        iIndex=-1;
                        iAddCode = CWCStringList::STRLST_FAIL;
                    }
                }

                if (CWCStringList::STRLST_FAIL == iAddCode)
                    hr = E_FAIL;    // bad news
                else if (CWCStringList::STRLST_ADDED == iAddCode)
                    hr = S_FALSE;   // haven't gotten it yet
                else
                    hr = S_OK;      // already got it
            }
            MemFree(pwszRobots);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = E_FAIL;    // too many robots.txt files???
    }

    *pdwRobotsTxtIndex = iIndex;

    return hr;
}

// iRobotsIndex : Index into robots.txt, -1 if unavailable
HRESULT CWebCrawler::ValidateWithRobotsTxt(LPCWSTR pwszUrl, int iRobotsIndex, BOOL *pfAllow)
{
    int iNumDirectives, i;
    CWCStringList *pslThisRobotsTxt=NULL;

    *pfAllow = TRUE;

    if (!m_pRobotsTxt)
        return S_OK;

    if (iRobotsIndex == -1)
    {
        DWORD dwIndex;

        if (S_OK != GetRobotsTxtIndex(pwszUrl, FALSE, &dwIndex))
            return E_FAIL;

        iRobotsIndex = (int)dwIndex;
    }

    if ((iRobotsIndex >= 0) && iRobotsIndex<m_pRobotsTxt->NumStrings())
    {
        pslThisRobotsTxt = (CWCStringList *)(m_pRobotsTxt->GetStringData(iRobotsIndex));

        if (pslThisRobotsTxt)
        {
            iNumDirectives = pslThisRobotsTxt->NumStrings();

            for (i=0; i<iNumDirectives; i++)
            {
                // See if this url starts with the same thing as the directive
                if (!MyAsciiCmpNIW(pwszUrl, pslThisRobotsTxt->GetString(i), pslThisRobotsTxt->GetStringLen(i)))
                {
                    // hit! see if this is "allow" or "disallow"
                    if (!(pslThisRobotsTxt->GetStringData(i) & DATA_ALLOW))
                    {
                        TraceMsg(TF_THISMODULE, "ValidateWithRobotsTxt disallowing: (%ws) (%ws)",
                            pslThisRobotsTxt->GetString(i), pwszUrl);
                        *pfAllow = FALSE;
                        m_iSkippedByRobotsTxt ++;
                    }
                    break;
                }
            }
        }
        return S_OK;
    }

    return E_FAIL;
}

typedef struct
{
    LPCWSTR         pwszThisUrl;
    CWCStringList   *pslGlobal;
    BOOL            fDiskFull;
    DWORD           dwSize;
    GROUPID         llGroupID;
}
ENUMDEPENDENCIES;

// Doesn't process it if we already have it in the global dependency list
HRESULT CWebCrawler::CheckImageOrLink(IUnknown *punkItem, BSTR *pbstrItem, DWORD_PTR dwEnumDep, DWORD *pdwStringData)
{
    if (!dwEnumDep)
        return E_FAIL;

    ENUMDEPENDENCIES *pEnumDep = (ENUMDEPENDENCIES *) dwEnumDep;

    WCHAR   wszCombinedUrl[INTERNET_MAX_URL_LENGTH];
    DWORD   dwLen = ARRAYSIZE(wszCombinedUrl);

    HRESULT hr;

    if (pEnumDep->fDiskFull)
        return E_ABORT;     // Abort enumeration

    if (SUCCEEDED(UrlCombineW(pEnumDep->pwszThisUrl, *pbstrItem, wszCombinedUrl, &dwLen, 0)))
    {
        TCHAR   szCombinedUrl[INTERNET_MAX_URL_LENGTH];
        BYTE    chBuf[MY_MAX_CACHE_ENTRY_INFO];

        if (pEnumDep->pslGlobal != NULL)
        {
            int iCode = pEnumDep->pslGlobal->AddString(*pbstrItem, 0);

            if (CWCStringList::STRLST_ADDED != iCode)
            {
                // The string already existed (or Add failed). Don't process this.
                return S_OK;
            }
        }

        // Process this url.
        MyOleStrToStrN(szCombinedUrl, INTERNET_MAX_URL_LENGTH, wszCombinedUrl);

        hr = GetUrlInfoAndMakeSticky(NULL, szCombinedUrl,
                (LPINTERNET_CACHE_ENTRY_INFO)chBuf, sizeof(chBuf),
                pEnumDep->llGroupID);

        if (E_OUTOFMEMORY == hr)
        {
            pEnumDep->fDiskFull = TRUE;
            return E_ABORT;     // Skip rest of enumeration
        }

        if (SUCCEEDED(hr))
            pEnumDep->dwSize += ((LPINTERNET_CACHE_ENTRY_INFO)chBuf)->dwSizeLow;
    }

    return S_OK;
}

HRESULT CWebCrawler::MatchNames(BSTR bstrName, BOOL fPassword)
{
    static const WCHAR c_szPassword1[] = L"password";
    static const WCHAR c_szUsername1[] = L"user";
    static const WCHAR c_szUsername2[] = L"username";

    HRESULT hr = E_FAIL;
    LPCTSTR pszKey = c_szRegKeyPasswords;

    // See if the name matches our preset options.
    // Should these be localized?  I don't think so or subscribing to
    // US sites will fail in international versions of the browser.
    if (fPassword)
    {
        if (StrCmpIW(bstrName, c_szPassword1) == 0)
        {
            hr = S_OK;
        }
    }
    else
    {
        if ((StrCmpIW(bstrName, c_szUsername1) == 0) ||
            (StrCmpIW(bstrName, c_szUsername2) == 0))
        {
            hr = S_OK;
        }
        else
        {
            pszKey = c_szRegKeyUsernames;
        }
    }

    // Try the registry for custom form names if the presets didn't match.
    if (FAILED(hr))
    {
        LONG lRes;
        HKEY hKey;
        DWORD cValues;
        DWORD i;
        lRes = RegOpenKeyEx(HKEY_CURRENT_USER, pszKey, 0, KEY_READ, &hKey);
        if (ERROR_SUCCESS == lRes)
        {
            lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &cValues, NULL, NULL, NULL, NULL);
            if (ERROR_SUCCESS == lRes)
            {
                for (i = 0; i < cValues; i++)
                {
                    TCHAR szValueName[MAX_PATH];
                    DWORD cchValueName = ARRAYSIZE(szValueName);

                    lRes = SHEnumValue(hKey, i, szValueName, &cchValueName, NULL, NULL, NULL);
                    if (ERROR_SUCCESS == lRes)
                    {
                        WCHAR wszValueName[MAX_PATH];
                        MyStrToOleStrN(wszValueName, ARRAYSIZE(wszValueName), szValueName);
                        if (StrCmpIW(bstrName, wszValueName) == 0)
                        {
                            hr = S_OK;
                            break;
                        }
                    }
                }
            }
            lRes = RegCloseKey(hKey);
            ASSERT(ERROR_SUCCESS == lRes);
        }
    }

    return hr;
}

HRESULT CWebCrawler::FindAndSubmitForm(void)
{
    // FindAndSubmitForm - If there is a user name and password in
    // the start item, this will attempt to fill in and submit
    // a form.  It should only be called on the top level page of a
    // webcrawl. We still need to check the host name in case we were
    // spawned from a channel crawl.
    //
    // return values: S_OK      successfully found and submitted a form -> restart webcrawl
    //                S_FALSE   no username, no form, or unrecognized form ->continue webcrawl
    //                E_FAIL    submit failed -> abort webcrawl
    //
    HRESULT hrReturn = S_FALSE;
    HRESULT hr = S_OK;
    BSTR bstrUsername = NULL;
    BSTR bstrPassword = NULL;
    BSTR bstrInputType= NULL;

    static const WCHAR c_szInputTextType[]=L"text";

    // If our host name doesn't match the root host name, don't return auth
    // information.
    if (m_bstrHostName)
    {
        LPWSTR pwszUrl, bstrHostName=NULL;

        m_pCurDownload->GetRealURL(&pwszUrl);   // may re-enter Trident

        if (pwszUrl)
        {
            GetHostName(pwszUrl, &bstrHostName);
            LocalFree(pwszUrl);
        }

        if (bstrHostName)
        {
            if (MyAsciiCmpW(bstrHostName, m_bstrHostName))
            {
                hr = E_FAIL;
            }
            SysFreeString(bstrHostName);
        }
    }

    if (SUCCEEDED(hr))
        hr = ReadBSTR(m_pSubscriptionItem, c_szPropCrawlUsername, &bstrUsername);

    if (SUCCEEDED(hr) && bstrUsername && bstrUsername[0])
    {
        // NOTE: We don't allow NULL passwords.
        hr = ReadPassword(m_pSubscriptionItem, &bstrPassword);
        if (SUCCEEDED(hr) && bstrPassword && bstrPassword[0])
        {
            IHTMLDocument2 *pDoc = NULL;
            hr = m_pCurDownload->GetDocument(&pDoc);
            if (SUCCEEDED(hr) && pDoc)
            {
                IHTMLElementCollection *pFormsCollection = NULL;
                hr = pDoc->get_forms(&pFormsCollection);
                if (SUCCEEDED(hr) && pFormsCollection)
                {
                    long length;
                    hr = pFormsCollection->get_length(&length);
                    TraceMsg(TF_THISMODULE, "**** FOUND USER NAME, PASSWORD, & %d FORMS ****", (int)length);
                    if (SUCCEEDED(hr) && length > 0)
                    {
                        // We only check the first form for a user name and password.
                        // Why do we pass an index to IHTMLElementCollection when
                        // the interface prototype says it takes a name?
                        IDispatch *pDispForm = NULL;
                        VARIANT vIndex, vEmpty;
                        VariantInit(&vIndex);
                        VariantInit(&vEmpty);
                        vIndex.vt = VT_I4;
                        vIndex.lVal = 0;
                        hr = pFormsCollection->item(vIndex, vEmpty, &pDispForm);
                        if (SUCCEEDED(hr) && pDispForm)
                        {
                            IHTMLFormElement *pForm = NULL;
                            hr = pDispForm->QueryInterface(IID_IHTMLFormElement, (void **)&pForm);
                            if (SUCCEEDED(hr) && pForm)
                            {
                                // Enum form elements looking for the input types we care about.
                                // Would it be faster to use tags()?
                                hr = pForm->get_length(&length);
                                if (SUCCEEDED(hr) && length >= 2)
                                {
                                    // TraceMsg(TF_THISMODULE, "**** FORM ELEMENTS (%d) ****", (int)length);
                                    BOOL fUsernameSet = FALSE;
                                    BOOL fPasswordSet = FALSE;
                                    IDispatch *pDispItem = NULL;
                                    long i;
                                    for (i = 0; i < length; i++)
                                    {
                                        vIndex.lVal = i;    // re-use vIndex above
                                        hr = pForm->item(vIndex, vEmpty, &pDispItem);
                                        if (SUCCEEDED(hr) && pDispItem)
                                        {
                                            IHTMLInputTextElement *pInput = NULL;
                                            // QI was the easiest way to tell them apart...
                                            // InputText is derived from InputPassword
                                            hr = pDispItem->QueryInterface(IID_IHTMLInputTextElement, (void **)&pInput);
                                            SAFERELEASE(pDispItem);
                                            if (SUCCEEDED(hr) && pInput)
                                            {
                                                hr = pInput->get_type(&bstrInputType);
                                                ASSERT(SUCCEEDED(hr) && bstrInputType);
                                                BSTR bstrName = NULL;
                                                if (StrCmpIW(bstrInputType, c_szInputTextType) == 0)
                                                {
                                                    // We found an INPUT element with attribute TYPE="text".
                                                    // Set it if the NAME attribute matches.
                                                    // Only setting the first matching input.
                                                    // Do we care about max length or does put_value handle it?
                                                    // TraceMsg(TF_THISMODULE, "**** FORM ELEMENT INPUT (%d) ****", (int)i);
                                                    if (!fUsernameSet)
                                                    {
                                                        hr = pInput->get_name(&bstrName);
                                                        ASSERT(SUCCEEDED(hr) && bstrName);
                                                        if (SUCCEEDED(hr) && bstrName && SUCCEEDED(MatchNames(bstrName, FALSE)))
                                                        {
                                                            hr = pInput->put_value(bstrUsername);
                                                            if (SUCCEEDED(hr))
                                                                fUsernameSet = TRUE;
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    // We found an INPUT element with attribute TYPE="password"
                                                    // Set it if the name attribute matches.
                                                    // Only setting the first matching input.
                                                    // Do we care about max length or does put_value handle it?
                                                    // TraceMsg(TF_THISMODULE, "**** FORM ELEMENT PASSWORD (%d) ****", (int)i);
                                                    if (!fPasswordSet)
                                                    {
                                                        hr = pInput->get_name(&bstrName);
                                                        ASSERT(SUCCEEDED(hr) && bstrName);
                                                        if (SUCCEEDED(hr) && bstrName  && SUCCEEDED(MatchNames(bstrName, TRUE)))
                                                        {
                                                            hr = pInput->put_value(bstrPassword);
                                                            if (SUCCEEDED(hr))
                                                                fPasswordSet = TRUE;
                                                        }
                                                    }
                                                }
                                                SAFEFREEBSTR(bstrName);
                                                SAFERELEASE(pInput);
                                            }
                                        }
                                    }
                                    // Submit the form is everything was set.
                                    if (fUsernameSet && fPasswordSet)
                                    {
                                        ASSERT(!m_pCurDownload->GetFormSubmitted());
                                        m_pCurDownload->SetFormSubmitted(TRUE);
                                        hr = pForm->submit();
                                        if (SUCCEEDED(hr))
                                        {
                                            m_iNumPagesDownloading ++;
                                            TraceMsg(TF_THISMODULE, "**** FORM SUBMIT WORKED ****");
                                            hrReturn = S_OK;
                                        }
                                        else
                                        {
                                            TraceMsg(TF_THISMODULE, "**** FORM SUBMIT FAILED ****");
                                            hrReturn = E_FAIL;
                                        }
                                    }
                                }
                                SAFERELEASE(pForm);
                            }
                            SAFERELEASE(pDispForm);
                        }
                        // only length
                    }
                    SAFERELEASE(pFormsCollection);
                }
                SAFERELEASE(pDoc);
            }
            // free bstr below because we check for empty bstrs
        }
        SAFEFREEBSTR(bstrPassword);
    }
    SAFEFREEBSTR(bstrUsername);
    return hrReturn;
}

// Make page and dependencies sticky and get total size
HRESULT CWebCrawler::MakePageStickyAndGetSize(LPCWSTR pwszURL, DWORD *pdwSize, BOOL *pfDiskFull)
{
    ASSERT(m_pDependencies || IsRecurseFlagSet(WEBCRAWL_DONT_MAKE_STICKY));

    HRESULT hr;
    TCHAR   szThisUrl[INTERNET_MAX_URL_LENGTH]; // use ansi internally
    BYTE    chBuf[MY_MAX_CACHE_ENTRY_INFO];

    LPINTERNET_CACHE_ENTRY_INFO lpInfo = (LPINTERNET_CACHE_ENTRY_INFO) chBuf;

    DWORD   dwBufSize = sizeof(chBuf);

    *pdwSize = 0;

    // First we make our base url sticky and check it for changes

    MyOleStrToStrN(szThisUrl, INTERNET_MAX_URL_LENGTH, pwszURL);

    hr = GetUrlInfoAndMakeSticky(NULL, szThisUrl, lpInfo, dwBufSize, m_llCacheGroupID);

    if (E_OUTOFMEMORY != hr)
    {
        if (SUCCEEDED(hr))
            *pdwSize += lpInfo->dwSizeLow;

        if (!IsAgentFlagSet(FLAG_CRAWLCHANGED) && SUCCEEDED(hr))
        {
            hr = PostCheckUrlForChange(&m_varChange, lpInfo, lpInfo->LastModifiedTime);
            // If we FAILED, we mark it as changed.
            if (hr == S_OK || FAILED(hr))
            {
                SetAgentFlag(FLAG_CRAWLCHANGED);
                DBG("URL has changed; will flag webcrawl as changed");
            }

            // "Changes Only" mode, persist change detection code
            if (IsAgentFlagSet(FLAG_CHANGESONLY))
            {
                ASSERT(m_iTotalStarted == 1);
                WriteVariant(m_pSubscriptionItem, c_szPropChangeCode, &m_varChange);
                return S_OK;    // We know there are no dependencies
            }

            hr = S_OK;
        }
    }
    else
    {
        *pfDiskFull = TRUE;
    }

    // Now we make all the new dependencies we downloaded for this page sticky
    if (!*pfDiskFull && m_pDependencies)
    {
        EnterCriticalSection(&m_critDependencies);

        for (; m_iDependenciesProcessed < m_pDependencies->NumStrings(); m_iDependenciesProcessed ++)
        {
            MyOleStrToStrN(szThisUrl, INTERNET_MAX_URL_LENGTH, m_pDependencies->GetString(m_iDependenciesProcessed));

            hr = GetUrlInfoAndMakeSticky(NULL, szThisUrl, lpInfo, dwBufSize, m_llCacheGroupID);

            if (E_OUTOFMEMORY == hr)
            {
                *pfDiskFull = TRUE;
                break;
            }

            if (SUCCEEDED(hr))
                *pdwSize += lpInfo->dwSizeLow;
        }

        LeaveCriticalSection(&m_critDependencies);
    }

    if (*pfDiskFull)
    {
        DBG_WARN("Webcrawler: UrlCache full trying to make sticky");
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

// true if found token & made null-term
LPSTR GetToken(LPSTR pszBuf, /*inout*/int *piBufPtr, /*out*/int *piLen)
{
static const CHAR szWhitespace[] = " \t\n\r";

    int iPtr = *piBufPtr;
    int iLen;

    while (1)
    {
        // skip leading whitespace
        iPtr += StrSpnA(pszBuf+iPtr, szWhitespace);

        if (!pszBuf[iPtr])
            return NULL;

        if (pszBuf[iPtr] == '#')
        {
            // comment; skip line
            while (pszBuf[iPtr] && pszBuf[iPtr]!='\r' && pszBuf[iPtr]!='\n') iPtr++;

            if (!pszBuf[iPtr])
                return NULL;

            continue;
        }

        // skip to next whitespace
        iLen = StrCSpnA(pszBuf+iPtr, szWhitespace);

        if (iLen == 0)
            return NULL;        // shoudln't happen

        *piBufPtr = iLen + iPtr;

        if (piLen)
            *piLen = iLen;

        if (pszBuf[iLen+iPtr])
        {
            pszBuf[iLen+iPtr] = NULL;
            ++ *piBufPtr;
        }

        break;
    }

//  TraceMsgA(TF_THISMODULE, "GetToken returning \"%s\"", (LPSTR)(pszBuf+iPtr));
    return pszBuf + iPtr;
}


// === Support functions for OnDownloadComplete

// ParseRobotsTxt gets the stream from CUrlDownload, parses it, and fills in parsed
//  info to *ppslRet
HRESULT CWebCrawler::ParseRobotsTxt(LPCWSTR pwszRobotsTxtURL, CWCStringList **ppslRet)
{
    // Given a robots.txt file (from CUrlDownload), it
    //  parses the file and fills in a string list with appropriate
    //  info.
    *ppslRet = FALSE;

    CHAR    szRobotsTxt[MAX_ROBOTS_SIZE];
    HRESULT hr=S_OK;
    LPSTR   pszToken;
    IStream *pstm=NULL;
    DWORD_PTR dwData;

    hr = m_pCurDownload->GetStream(&pstm);

    if (SUCCEEDED(hr))
    {
        STATSTG st;
        DWORD   dwSize;

        DBG("CWebCrawler parsing robots.txt file");

        pstm->Stat(&st, STATFLAG_NONAME);

        dwSize = st.cbSize.LowPart;

        if (st.cbSize.HighPart || dwSize >= MAX_ROBOTS_SIZE)
        {
            szRobotsTxt[0] = 0;
            DBG("CWebCrawler: Robots.Txt too big; ignoring");
            hr = E_FAIL;
        }
        else
        {
            hr = pstm->Read(szRobotsTxt, dwSize, NULL);
            szRobotsTxt[dwSize] = 0;
        }

        pstm->Release();
        pstm=NULL;

        if ((szRobotsTxt[0] == 0xff) && (szRobotsTxt[1] == 0xfe))
        {
            DBG_WARN("Unicode robots.txt! Ignoring ...");
            hr = E_FAIL;
        }
    }

    if (FAILED(hr))
        return hr;

    int iPtr = 0;
    WCHAR wchBuf2[256];
    WCHAR wchBuf[INTERNET_MAX_URL_LENGTH];
    DWORD dwBufSize;

    // Find the first "user-agent" which matches
    while ((pszToken = GetToken(szRobotsTxt, &iPtr, NULL)) != NULL)
    {
        if (lstrcmpiA(pszToken, c_szRobots_UserAgent))
            continue;

        pszToken = GetToken(szRobotsTxt, &iPtr, NULL);
        if (!pszToken)
            break;

        if ((*pszToken == '*') ||
            (!lstrcmpiA(pszToken, c_szRobots_OurUserAgent)))
        {
            TraceMsgA(TF_THISMODULE, "Using user agent segment: \"%s\"", pszToken);
            break;
        }
    }

    if (!pszToken)
        return E_FAIL;

    CWCStringList *psl = new CWCDwordStringList;
    if (psl)
    {
        psl->Init(2048);

        // Look for Allow: or Disallow: sections
        while ((pszToken = GetToken(szRobotsTxt, &iPtr, NULL)) != NULL)
        {
            if (!lstrcmpiA(pszToken, c_szRobots_UserAgent))
                break;  // end of our 'user-agent' section

            dwData = 0;

            if (!lstrcmpiA(pszToken, c_szRobots_Allow))     dwData = DATA_ALLOW;
            if (!lstrcmpiA(pszToken, c_szRobots_Disallow))  dwData = DATA_DISALLOW;

            if (!dwData)
                continue;   // look for next token

            pszToken = GetToken(szRobotsTxt, &iPtr, NULL);
            if (!pszToken)
                break;

            // Ensure that they don't have blank entries; we'll abort if so
            if (!lstrcmpiA(pszToken, c_szRobots_UserAgent) ||
                !lstrcmpiA(pszToken, c_szRobots_Allow) ||
                !lstrcmpiA(pszToken, c_szRobots_Disallow))
            {
                break;
            }

            // Combine this url with the base for this site.
            dwBufSize = ARRAYSIZE(wchBuf);
            if (SHAnsiToUnicode(pszToken, wchBuf2, ARRAYSIZE(wchBuf2)) &&
                SUCCEEDED(UrlCombineW(pwszRobotsTxtURL, wchBuf2, wchBuf, &dwBufSize, 0)))
            {
                TraceMsgA(TF_THISMODULE, "Robots.txt will %s urls with %s (%ws)",
                    ((dwData==DATA_ALLOW) ? c_szRobots_Allow : c_szRobots_Disallow),
                    pszToken, wchBuf);

                // if this is a duplicate url we effectively ignore this directive
                //  thanks to CWCStringList removing duplicates for us

                psl->AddString(wchBuf, dwData);
            }
        }
    }

    if (psl && (psl->NumStrings() > 0))
    {
        *ppslRet = psl;
        return S_OK;
    }

    if (psl)
        delete psl;

    return E_FAIL;
}

HRESULT CWebCrawler::GetRealUrl(int iPageIndex, LPWSTR *ppwszThisUrl)
{
    m_pCurDownload->GetRealURL(ppwszThisUrl);

    if (*ppwszThisUrl)
    {
        return S_OK;
    }

    DBG_WARN("m_pCurDownload->GetRealURL failed!!!");

    // Get url from string list
    LPCWSTR pwszUrl=NULL;

    pwszUrl = m_pPages->GetString(iPageIndex);

    if (pwszUrl)
    {
        *ppwszThisUrl = StrDupW(pwszUrl);
    }

    return (*ppwszThisUrl) ? S_OK : E_OUTOFMEMORY;
}

// Allocates BSTR for host name.
HRESULT CWebCrawler::GetHostName(LPCWSTR pwszThisUrl, BSTR *pbstrHostName)
{
    if (pwszThisUrl)
    {
        URL_COMPONENTSA comp;
        LPSTR           pszUrl;
        int             iLen;

//      InternetCrackUrlW(pszUrl, 0, 0, &comp)  // this is even slower than converting it ourselves...

        // convert to ansi
        iLen = lstrlenW(pwszThisUrl) + 1;
        pszUrl = (LPSTR)MemAlloc(LMEM_FIXED, iLen);
        if (pszUrl)
        {
            SHUnicodeToAnsi(pwszThisUrl, pszUrl, iLen);

            // crack out the host name
            ZeroMemory(&comp, sizeof(comp));
            comp.dwStructSize = sizeof(comp);
            comp.dwHostNameLength = 1;  // indicate that we want the host name

            if (InternetCrackUrlA(pszUrl, 0, 0, &comp))
            {
                *pbstrHostName = SysAllocStringLen(NULL, comp.dwHostNameLength);
                if (*pbstrHostName)
                {
                    comp.lpszHostName[comp.dwHostNameLength] = 0; // avoid debug rip
                    SHAnsiToUnicode(comp.lpszHostName, *pbstrHostName, comp.dwHostNameLength + 1);
                    ASSERT((*pbstrHostName)[comp.dwHostNameLength] == 0);
                }
            }

            MemFree((HLOCAL)pszUrl);
        }
    }

    return S_OK;
}

// Gets partly validated (CUrlDownload::IsValidUrl and hostname validation)
//  string lists and leaves in m_pPendingLinks
// Remaining validation is robots.txt if any
HRESULT CWebCrawler::GetLinksFromPage()
{
    // Get links from this page that we want to follow.
    CWCStringList *pslLinks=NULL, slMeta;

    IHTMLDocument2  *pDoc;
    BOOL            fFollowLinks = TRUE;
    int             i;

    slMeta.Init(2048);

    m_pCurDownload->GetDocument(&pDoc);
    if (pDoc)
    {
        // See if there is a META tag telling us not to follow
        CHelperOM::GetCollection(pDoc, &slMeta, CHelperOM::CTYPE_META, NULL, 0);
        for (i=0; i<slMeta.NumStrings(); i++)
        {
            if (!StrCmpNIW(slMeta.GetString(i), c_wszRobotsMetaName, c_iRobotsMetaNameLen))
            {
                LPCWSTR pwszContent = slMeta.GetString(i) + c_iRobotsMetaNameLen;
                TraceMsg(TF_THISMODULE, "Found 'robots' meta tag; content=%ws", pwszContent);

                while (pwszContent && *pwszContent)
                {
                    if (!StrCmpNIW(pwszContent, c_wszRobotsNoFollow, c_iRobotsNoFollow))
                    {
                        DBG("Not following links from this page.");
                        fFollowLinks = FALSE;
                        break;
                    }
                    pwszContent = StrChrW(pwszContent+1, L',');
                    if (pwszContent && *pwszContent)
                        pwszContent ++;
                }
                break;
            }
        }
        if (fFollowLinks)
        {
            if (m_pPendingLinks)
                pslLinks = m_pPendingLinks;
            else
            {
                pslLinks = new CWCDwordStringList;
                if (pslLinks)
                    pslLinks->Init();
                else
                    return E_OUTOFMEMORY;
            }

            CHelperOM::GetCollection(pDoc, pslLinks, CHelperOM::CTYPE_LINKS, &CheckLink, (DWORD_PTR)this);
            CHelperOM::GetCollection(pDoc, pslLinks, CHelperOM::CTYPE_MAPS, &CheckLink, (DWORD_PTR)this);
        }
        pDoc->Release();
        pDoc=NULL;
    }

    m_pPendingLinks = pslLinks;

    return S_OK;
}

// Gets 'dependency links' such as frames from a page
HRESULT CWebCrawler::GetDependencyLinksFromPage(LPCWSTR pwszThisUrl, DWORD dwRecurse)
{
    CWCStringList *psl=NULL;
    IHTMLDocument2 *pDoc;
    int i, iAdd, iIndex, iOldMax;
    DWORD_PTR dwData;

    if (m_pDependencyLinks)
        psl = m_pDependencyLinks;
    else
    {
        m_iDependencyStarted = 0;
        psl = new CWCStringList;
        if (psl)
            psl->Init(2048);
        else
            return E_OUTOFMEMORY;
    }

    iOldMax = psl->NumStrings();

    m_pCurDownload->GetDocument(&pDoc);
    if (pDoc)
    {
        // Add Frames ("Frame" and "IFrame" tags) if present
        CHelperOM::GetCollection(pDoc, psl, CHelperOM::CTYPE_FRAMES, CheckFrame, (DWORD_PTR)pwszThisUrl);
    }

    SAFERELEASE(pDoc);

    m_pDependencyLinks = psl;

    // Add the new urls to the main page list
    for (i = iOldMax; i<psl->NumStrings(); i++)
    {
        iAdd = m_pPages->AddString(m_pDependencyLinks->GetString(i),
                        dwRecurse,
                        &iIndex);

        if (m_lMaxNumUrls > 0 && iAdd==CWCStringList::STRLST_ADDED)
            m_lMaxNumUrls ++;

        if (iAdd == CWCStringList::STRLST_FAIL)
            return E_OUTOFMEMORY;

        if (iAdd == CWCStringList::STRLST_DUPLICATE)
        {
            // bump up recursion level of old page if necessary
            // See if we've downloaded this yet.
            dwData = m_pPages->GetStringData(iIndex);
            if (!(dwData & DATA_DLSTARTED))
            {
                // Haven't downloaded it yet.
                // Update the recurse levels if necessary.
                if ((dwData & DATA_RECURSEMASK) < dwRecurse)
                {
                    dwData = (dwData & ~DATA_RECURSEMASK) | dwRecurse;
                }

                // Turn off the "link" bit
                dwData &= ~DATA_LINK;

                m_pPages->SetStringData(iIndex, dwData);
            }
#ifdef DEBUG
            // Shouldn't happen; this frame already dl'd with lower recurse level
            else
                ASSERT((dwData & DATA_RECURSEMASK) >= dwRecurse);
#endif
        }
    }

    return S_OK;
}

//-------------------------------------
// OnDownloadComplete
//
// Called when a url is finished downloading, it processes the url
//  and kicks off the next download
//
HRESULT CWebCrawler::OnDownloadComplete(UINT iID, int iError)
{
    int         iPageIndex = m_iCurDownloadStringIndex;
    BOOL        fOperationComplete = FALSE;
    BOOL        fDiskFull = FALSE;
    BSTR        bstrCDFURL = NULL; //  CDF URL if there is one
    LPWSTR      pwszThisUrl=NULL;

    HRESULT     hr;

    TraceMsg(TF_THISMODULE, "WebCrawler: OnDownloadComplete(%d)", iError);
    ASSERT(m_pPages);
    ASSERT(iPageIndex < m_pCurDownloadStringList->NumStrings());

    if (_ERROR_REPROCESSING != iError)
    {
        m_iNumPagesDownloading --;
        ASSERT(m_iNumPagesDownloading == 0);
    }

    if (m_pCurDownloadStringList == m_pRobotsTxt)
    {
        CWCStringList *pslNew=NULL;

        // Process robots.txt file
        if (SUCCEEDED(ParseRobotsTxt(m_pRobotsTxt->GetString(iPageIndex), &pslNew)))
        {
            m_pRobotsTxt->SetStringData(iPageIndex, (DWORD_PTR)(pslNew));
        }
    }
    else
    {
        // Process normal file
        ASSERT(m_pCurDownloadStringList == m_pPages);

        DWORD dwData, dwRecurseLevelsFromThisPage;

        dwData = (DWORD)m_pPages->GetStringData(iPageIndex);
        dwRecurseLevelsFromThisPage = dwData & DATA_RECURSEMASK;

        dwData |= DATA_DLFINISHED;
        if (iError > 0)
            dwData |= DATA_DLERROR;

        // mark as downloaded
        m_pCurDownloadStringList->SetStringData(iPageIndex, dwData);

        // Is this the first page?
        if (m_iTotalStarted == 1)
        {
            // Check the HTTP response code
            DWORD dwResponseCode;

            hr = m_pCurDownload->GetResponseCode(&dwResponseCode);

            if (SUCCEEDED(hr))
            {
                hr = CheckResponseCode(dwResponseCode);
                if (FAILED(hr))
                    fOperationComplete = TRUE;
            }
            else
                DBG("CWebCrawler failed to GetResponseCode");

            // Get the Charset
            BSTR bstrCharSet=NULL;
            IHTMLDocument2 *pDoc=NULL;


            // -> Bharats --------
            // Find a link tag and store it away the cdf by copying it (if it points to a cdf.)
            // do url combine of this cdf 
            if (SUCCEEDED(m_pCurDownload->GetDocument(&pDoc)) && pDoc &&
                SUCCEEDED(pDoc->get_charset(&bstrCharSet)) && bstrCharSet)
            {
                WriteOLESTR(m_pSubscriptionItem, c_szPropCharSet, bstrCharSet);
                TraceMsg(TF_THISMODULE, "Charset = \"%ws\"", bstrCharSet);
                SysFreeString(bstrCharSet);        
            }
            else
                WriteEMPTY(m_pSubscriptionItem, c_szPropCharSet);

            if(pDoc)
            {
                if(FAILED(GetChannelItem(NULL)))   // A Doc exists and this download is not from a channel itself
                {
                    IHTMLLinkElement *pLink = NULL;
                    hr = SearchForElementInHead(pDoc, OLESTR("REL"), OLESTR("OFFLINE"), 
                                            IID_IHTMLLinkElement, (IUnknown **)&pLink);
                    if(S_OK == hr)
                    {
                        hr = pLink->get_href(&bstrCDFURL);
                        pLink->Release();
                    }
                }   
                pDoc->Release();
                pDoc = NULL;
            }
        }

        if ((iError != _ERROR_REPROCESSING) && (iError != BDU2_ERROR_NONE))
        {
            if (iError != BDU2_ERROR_NOT_HTML)
                m_iDownloadErrors ++;

            if (iError == BDU2_ERROR_MAXSIZE)
            {
                SetEndStatus(INET_E_AGENT_MAX_SIZE_EXCEEDED);
                fOperationComplete = TRUE;
            }
        }
        else
        {
            // Don't process this url if we already have set fOperationComplete
            if (!fOperationComplete)
            {
                // Did we get *just* the HEAD info?
                if (IsAgentFlagSet(FLAG_HEADONLY))
                {
                    SYSTEMTIME stLastModified;
                    FILETIME   ftLastModified;

                    if (SUCCEEDED(m_pCurDownload->GetLastModified(&stLastModified)) &&
                                  SystemTimeToFileTime(&stLastModified, &ftLastModified))
                    {
                        DBG("Retrieved 'HEAD' info; change detection based on Last Modified");

                        hr = PostCheckUrlForChange(&m_varChange, NULL, ftLastModified);
                        // If we FAILED, we mark it as changed.
                        if (hr == S_OK || FAILED(hr))
                        {
                            SetAgentFlag(FLAG_CRAWLCHANGED);
                            DBG("URL has changed; will flag webcrawl as changed");
                        }

                        // "Changes Only" mode, persist change detection code
                        ASSERT(IsAgentFlagSet(FLAG_CHANGESONLY));
                        ASSERT(m_iTotalStarted == 1);
                        WriteVariant(m_pSubscriptionItem, c_szPropChangeCode, &m_varChange);
                    }
                }
                else
                {
                    // Get real URL in case we were redirected
                    if (FAILED(GetRealUrl(iPageIndex, &pwszThisUrl)))
                    {
                        fOperationComplete = TRUE;        // bad
                    }
                    else
                    {
                        ASSERT(pwszThisUrl);

                        // Get host name from first page if necessary
                        if ((iPageIndex==0) &&
                            (m_dwRecurseLevels>0) &&
                            !IsRecurseFlagSet(WEBCRAWL_LINKS_ELSEWHERE) &&
                            !m_bstrHostName)
                        {
                            GetHostName(pwszThisUrl, &m_bstrHostName);
#ifdef DEBUG
                            if (m_bstrHostName)
                                TraceMsg(TF_THISMODULE, "Just got first host name: %ws", m_bstrHostName);
                            else
                                DBG_WARN("Get first host name failed!!!");
#endif
                        }

                        DWORD dwCurSize = 0, dwRepeat = 0;

                        HRESULT hr1;

                        do
                        {
                            hr1 = S_OK;

                            // Make page and dependencies sticky and get their total size
                            fDiskFull = FALSE;
                            MakePageStickyAndGetSize(pwszThisUrl, &dwCurSize, &fDiskFull);

                            if (fDiskFull && (dwRepeat < 2))
                            {
                                // If we couldn't make stuff sticky, ask host to make cache bigger
                                hr1 = m_pAgentEvents->ReportError(&m_SubscriptionCookie,
                                            INET_E_AGENT_EXCEEDING_CACHE_SIZE, NULL);

                                if (hr1 == E_PENDING)
                                {
                                    // Host is going to ask the user to increase the cache size.
                                    // Host should either abort or resume us later.
                                    SetAgentFlag(FLAG_WAITING_FOR_INCREASED_CACHE);
                                    goto done;
                                }
                                else if (hr1 == INET_S_AGENT_INCREASED_CACHE_SIZE)
                                {
                                    // Host just increased the cache size. Try it again.
                                }
                                else
                                {
                                    // Not gonna do it. Abort.
                                }
                            }
                        }
                        while ((hr1 == INET_S_AGENT_INCREASED_CACHE_SIZE) && (++dwRepeat <= 2));

                        m_dwCurSize += dwCurSize;

                        // Is there form based authentication that we need to handle
                        // on the top page of this subscription?
                        if (!fDiskFull && (0 == iPageIndex) && !m_pCurDownload->GetFormSubmitted())
                        {
                            hr = FindAndSubmitForm();
                            if (S_OK == hr)
                            {
                                // Successfully submitted form.  Bail and wait for the next OnDownloadComplete() call.
                                // FEATURE: Should we make the form URL and dependencies sticky?
                                return S_OK;
                            }
                            else if (FAILED(hr))
                            {
                                // We failed trying to submit the form.  Bail.
                                // FEATURE: Should we set a better error string?
                                SetEndStatus(E_FAIL);
                                CleanUp();
                                return S_OK;
                            }
                            // else no form - fall through
                        }

                        TraceMsg(TF_THISMODULE, "WebCrawler up to %d kb", (int)(m_dwCurSize>>10));

                        if ((m_lMaxNumUrls < 0) &&
                            !dwRecurseLevelsFromThisPage &&
                            !(dwData & DATA_CODEBASE))
                        {
                            m_lMaxNumUrls = m_pPages->NumStrings() + ((m_pRobotsTxt) ? m_pRobotsTxt->NumStrings() : 0);
                        }
                    }  // SUCCEEDED(GetRealUrl)
                }  // !FLAG_HEADONLY
            } // !fOperationComplete

            // If we're in "Changes Only" mode, we're done.
            if (IsAgentFlagSet(FLAG_CHANGESONLY))
                fOperationComplete = TRUE;

            // Check to see if we're past our max size
            if (!fOperationComplete && fDiskFull || (m_dwMaxSize && (m_dwCurSize >= (m_dwMaxSize<<10))))
            {
        #ifdef DEBUG
                if (fDiskFull)
                    DBG_WARN("Disk/cache full; aborting.");
                else
                    TraceMsg(TF_WARNING, "Past maximum size; aborting. (%d kb of %d kb)", (int)(m_dwCurSize>>10), (int)m_dwMaxSize);
        #endif
                // abort operation
                fOperationComplete = TRUE;

                if (fDiskFull)
                {
                    SetEndStatus(INET_E_AGENT_CACHE_SIZE_EXCEEDED);
                }
                else
                {
                    SetEndStatus(INET_E_AGENT_MAX_SIZE_EXCEEDED);
                }
            }

            if (!fOperationComplete)
            {
                // Get any links from page
                // Get "dependency links" from page - frames, etc.

                // we do this even if a CDF file is specified
                // Essentially, since the user has no clue about the CDF
                // file - we do not want to confuse the user
                GetDependencyLinksFromPage(pwszThisUrl, dwRecurseLevelsFromThisPage);

                if (dwRecurseLevelsFromThisPage)
                {
                    // Get links from this page that we want to follow.
                    GetLinksFromPage();

                    if (m_pPendingLinks)
                        TraceMsg(TF_THISMODULE,
                            "Total of %d unique valid links found", m_pPendingLinks->NumStrings());

                    m_dwPendingRecurseLevel = dwRecurseLevelsFromThisPage - 1;
                }

            }
        }   // !iError
    } // !robots.txt

    if(!fOperationComplete)
        StartCDFDownload(bstrCDFURL, pwszThisUrl);
        
    if(!m_fCDFDownloadInProgress)
    {
        // Don't try code downloads or any of the rest until you're done with
        // the cdf download
        // See if we have any more URLs to download.
        if (!fOperationComplete && FAILED(StartNextDownload()))
            fOperationComplete = TRUE;  // No, we're done!
    }

    CheckOperationComplete(fOperationComplete);

done:
    if (pwszThisUrl)
        MemFree(pwszThisUrl);

    SAFEFREEBSTR(bstrCDFURL);
            

    return S_OK;
}



HRESULT CWebCrawler::StartCDFDownload(WCHAR *pwszCDFURL, WCHAR *pwszBaseUrl)
{
    HRESULT hr = E_FAIL;
    m_fCDFDownloadInProgress = FALSE;
    if(pwszCDFURL)
    {
        // We have a CDF File - begin download of it
    
        if (m_pRunAgent)
        {
            ASSERT(0);
            DBG_WARN("WebCrawler: Attempting to download next CDF when nother CDF exists.");
            hr = E_FAIL;
            goto Exit;
        }
        else
        {
             // create subscription item for CDL agent.

            ISubscriptionItem *pItem = NULL;
            
            
            if (m_dwMaxSize && ((m_dwCurSize>>10) >= m_dwMaxSize))
            {
                // We've exceeded our maximum download KB limit and can't continue.
                DBG_WARN("WebCrawler: Exceeded Maximum KB download limit with CodeBase download.");
                SetEndStatus(hr = INET_E_AGENT_MAX_SIZE_EXCEEDED);
                goto Exit;
            }

            if (!m_pSubscriptionItem ||
                FAILED(hr = DoCloneSubscriptionItem(m_pSubscriptionItem, NULL, &pItem)))
            {
                goto Exit;
            }
            ASSERT(pItem != NULL);
            ASSERT(pwszCDFURL != NULL);
            WCHAR   wszCombined[INTERNET_MAX_URL_LENGTH];
            DWORD dwBufSize = ARRAYSIZE(wszCombined);
            
            if (SUCCEEDED(UrlCombineW(pwszBaseUrl, pwszCDFURL, wszCombined, &dwBufSize, 0)))
            {
            
                WriteOLESTR(pItem, c_szPropURL, wszCombined);
            
                WriteEMPTY(pItem, c_szPropCrawlGroupID); // clear the old cache group id - don't want 
                                                         // children to know of it 
                // The crawler already has a cache group id that we simply use as the new ID
                WriteLONGLONG(pItem, c_szPropCrawlNewGroupID, m_llCacheGroupID);
                WriteDWORD(pItem, c_szPropChannelFlags, CHANNEL_AGENT_PRECACHE_ALL);
                // Finally - since we know that this is for offline use, we just set the flags to precache all
            
                m_pRunAgent = new CRunDeliveryAgent();
                if (m_pRunAgent)
                    hr = m_pRunAgent->Init((CRunDeliveryAgentSink *)this, pItem, CLSID_ChannelAgent);
                pItem->Release();

                if (m_pRunAgent && SUCCEEDED(hr))
                {
                    hr = m_pRunAgent->StartAgent(); 
                    if (hr == E_PENDING)
                    {
                        hr = S_OK;
                        m_fCDFDownloadInProgress = TRUE;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
Exit:
    if((S_OK != hr) && m_pRunAgent)
    {
        CRunDeliveryAgent::SafeRelease(m_pRunAgent);
    }
    return hr;

}

// CRunDeliveryAgentSink call back method to signal the end of a codebase download.

HRESULT CWebCrawler::OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                               long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                               BOOL fSynchronous)
{
    ASSERT(m_pRunAgent != NULL);
    BOOL        fOperationComplete = FALSE;
    CRunDeliveryAgent::SafeRelease(m_pRunAgent);



    if(m_fCDFDownloadInProgress)
    {
        m_fCDFDownloadInProgress = FALSE; 
    }
    else
    {
        int         iPageIndex = m_iCurDownloadStringIndex;
        BOOL        fDiskFull = FALSE;
        CCodeBaseHold *pcbh = NULL;
        BOOL        fError;
        LPCWSTR     pwszThisURL=NULL;

        TraceMsg(TF_THISMODULE, "WebCrawler: OnAgentEnd of CRunDeliveryAgentSink");
        ASSERT(m_pCodeBaseList);
        ASSERT(iPageIndex < m_pCurDownloadStringList->NumStrings());
        ASSERT(m_pCurDownloadStringList == m_pCodeBaseList);

        m_iNumPagesDownloading --;
        ASSERT(m_iNumPagesDownloading == 0);

        pcbh = (CCodeBaseHold *)m_pCodeBaseList->GetStringData(iPageIndex);
        pwszThisURL = m_pCodeBaseList->GetString(iPageIndex);
        ASSERT(pwszThisURL);

        pcbh->dwFlags |= DATA_DLFINISHED;

        fError = FAILED(hrResult);
        if (fSynchronous)
        {
            fError = TRUE;
            ASSERT(FAILED(hrResult));       // we can't succeed synchronously...
        }

        //NOTE: The CDL agent will abort if it finds the file exceeds the MaxSizeKB.  In this case the file is not
        //      counted and there may be other smaller CAB's that can be downloaded, so we continue to proceed.

        if (fError)
        {
            pcbh->dwFlags |= DATA_DLERROR;
            m_iDownloadErrors ++;
            SetEndStatus(hrResult);
        }
        else
        {
            BYTE chBuf[MY_MAX_CACHE_ENTRY_INFO];
            LPINTERNET_CACHE_ENTRY_INFO lpInfo = (LPINTERNET_CACHE_ENTRY_INFO) chBuf;
            TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];

            MyOleStrToStrN(szUrl, INTERNET_MAX_URL_LENGTH, pwszThisURL);

            if (FAILED(GetUrlInfoAndMakeSticky(NULL, szUrl,
                                 lpInfo, sizeof(chBuf), m_llCacheGroupID)))
            {
                //REVIEW: Do something here?  Unlikely to occur in practice.
                fOperationComplete = TRUE;
                ASSERT(0);
            }
            else
            {
                m_dwCurSize += lpInfo->dwSizeLow;
            }

            TraceMsg(TF_THISMODULE, "WebCrawler up to %d kb", (int)(m_dwCurSize>>10));

            if (m_dwMaxSize && ((m_dwCurSize>>10)>m_dwMaxSize))
            {

                // abort operation
                fOperationComplete = TRUE;
                if (fDiskFull)
                    SetEndStatus(INET_E_AGENT_CACHE_SIZE_EXCEEDED);
                else
                    SetEndStatus(INET_E_AGENT_MAX_SIZE_EXCEEDED);
            }

        } // !fError
    }
    // See if we have any more URLs to download.
    if (!fOperationComplete && FAILED(StartNextDownload()))
        fOperationComplete = TRUE;  // No, we're done!

    if(!fSynchronous)
        CheckOperationComplete(fOperationComplete);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
// CheckCompleteOperation :: If parameter is TRUE, then all downloads are
//                           complete, the appropriate STATUS_CODE is set
//                           and clean up initiated.
//
//////////////////////////////////////////////////////////////////////////
void CWebCrawler::CheckOperationComplete(BOOL fOperationComplete)
{
    if (fOperationComplete)
    {
        DBG("WebCrawler complete. Shutting down.");
        if (INET_S_AGENT_BASIC_SUCCESS == GetEndStatus())
        {
            // Set end status appropriately
            if (m_iDownloadErrors)
            {
                if (m_iPagesStarted<=1)
                {
                    DBG("Webcrawl failed - first URL failed.");
                    SetEndStatus(E_INVALIDARG);
                }
                else
                {
                    DBG("Webcrawl succeeded - some URLs failed.");
                    SetEndStatus(INET_S_AGENT_PART_FAIL);
                }
            }
            else
            {
                DBG("Webcrawl succeeded");
                if (!IsAgentFlagSet(FLAG_CRAWLCHANGED))
                {
                    SetEndStatus(S_FALSE);
                    DBG("No changes were detected");
                }
                else
                {
                    DBG("Webcrawl succeeded");
                    SetEndStatus(S_OK);
                }
            }
        }

        if (m_llOldCacheGroupID)
        {
            DBG("Nuking old cache group.");
            if (!DeleteUrlCacheGroup(m_llOldCacheGroupID, 0, 0))
            {
                DBG_WARN("Failed to delete old cache group!");
            }
        }

        WriteLONGLONG(m_pSubscriptionItem, c_szPropCrawlGroupID, m_llCacheGroupID);

        m_lSizeDownloadedKB = ((m_dwCurSize+511)>>10);

        WriteDWORD(m_pSubscriptionItem, c_szPropCrawlActualSize, m_lSizeDownloadedKB);

        if (m_lMaxNumUrls >= 0)
        {
            WriteDWORD(m_pSubscriptionItem, c_szPropActualProgressMax, m_lMaxNumUrls);
        }

        // Send a robots.txt warning to the user if we ended up not downloading stuff
        //  because of the server's robots.txt file
        if (m_iSkippedByRobotsTxt != 0)
        {
            HRESULT hr = S_OK;      // Make it an "information" message
            WCHAR wszMessage[200];

            if (m_iPagesStarted==1)
            {
                hr = INET_E_AGENT_WARNING;  // Unless we're missing almost everything
            }

            if (MLLoadStringW(IDS_CRAWL_ROBOTS_TXT_WARNING, wszMessage, ARRAYSIZE(wszMessage)))
            {
                m_pAgentEvents->ReportError(&m_SubscriptionCookie, hr, wszMessage);
            }
        }

        // Will call "UpdateEnd"
        CleanUp();
    }
}

HRESULT CWebCrawler::ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes)
{
    // Customize our end status string
    switch (GetEndStatus())
    {
        case INET_E_AGENT_MAX_SIZE_EXCEEDED :
                              *puiRes = IDS_AGNT_STATUS_SIZELIMIT; break;
        case INET_E_AGENT_CACHE_SIZE_EXCEEDED :
                              *puiRes = IDS_AGNT_STATUS_CACHELIMIT; break;
        case E_FAIL         : *puiRes = IDS_CRAWL_STATUS_NOT_OK; break;
        case S_OK           :
            if (!IsAgentFlagSet(FLAG_CHANGESONLY))
                *puiRes = IDS_CRAWL_STATUS_OK;
            else
                *puiRes = IDS_URL_STATUS_OK;
            break;
        case S_FALSE        :
            if (!IsAgentFlagSet(FLAG_CHANGESONLY))
                *puiRes = IDS_CRAWL_STATUS_UNCHANGED;
            else
                *puiRes = IDS_URL_STATUS_UNCHANGED;
            break;
        case INET_S_AGENT_PART_FAIL : *puiRes = IDS_CRAWL_STATUS_MOSTLYOK; break;
    }

    return CDeliveryAgent::ModifyUpdateEnd(pEndItem, puiRes);
}

HRESULT CWebCrawler::DownloadStart(LPCWSTR pchUrl, DWORD dwDownloadId, DWORD dwType, DWORD dwReserved)
{
    HRESULT hr = S_OK, hr2;

    // free threaded
    EnterCriticalSection(&m_critDependencies);

    if (NULL == pchUrl)
    {
        DBG_WARN("CWebCrawler::DownloadStart pchUrl=NULL");
    }
    else
    {
        // Check to see if this is already in our dependencies list and abort if so
        if (CWCStringList::STRLST_ADDED != m_pDependencies->AddString(pchUrl, 0))
        {
            hr = E_ABORT;       // Don't download this thing.
            TraceMsg(TF_THISMODULE, "Aborting mshtml url (already added): %ws", pchUrl);
        }

        if (SUCCEEDED(hr))
        {
            // Check to see if this fails the robots.txt and abort if so
            // Note, this will only work if we happen to have already gotten this robots.txt
            // Need to abort here if we haven't gotten it, then get it, then get just this dep. Yuck.
            // Also shouldn't do the check if this is the first page downloaded
            DWORD dwIndex;
            hr2 = GetRobotsTxtIndex(pchUrl, FALSE, &dwIndex);
            if (SUCCEEDED(hr2))
            {
                BOOL fAllow;
                if (SUCCEEDED(ValidateWithRobotsTxt(pchUrl, dwIndex, &fAllow)))
                {
                    if (!fAllow)
                        hr = E_ABORT;   // ooh, failed the test.
                }
            }
        }
    }

    LeaveCriticalSection(&m_critDependencies);

    return hr;
}

HRESULT CWebCrawler::DownloadComplete(DWORD dwDownloadId, HRESULT hrNotify, DWORD dwReserved)
{
    // free threaded
    // Do nothing. We may wish to post message to make sticky here. We may wish to
    //  mark as downloaded in string list here.
//  EnterCriticalSection(&m_critDependencies);
//  LeaveCriticalSection(&m_critDependencies);
    return S_OK;
}


/* 41927 (IE5 4491)
HRESULT CWebCrawler::OnGetReferer(LPCWSTR *ppwszReferer)
{
    if (m_iPagesStarted <= 1)
    {
        *ppwszReferer = NULL;
        return S_FALSE;
    }

    if (m_pCurDownloadStringList == m_pRobotsTxt)
    {
        // Referer is last page from main list to be downloaded
        *ppwszReferer = m_pPages->GetString(m_iPagesStarted-1);
        return S_OK;
    }

    if (m_pCurDownloadStringList == m_pPages)
    {
        // Referer is stored in string list data
        *ppwszReferer = m_pPages->GetString(
            ((m_pPages->GetStringData(m_iCurDownloadStringIndex) & DATA_REFERERMASK) >> DATA_REFERERSHIFT));
        return S_OK;
    }

    // We don't return a referer for code bases
    ASSERT(m_pCurDownloadStringList == m_pCodeBaseList);

    return S_FALSE;
}
*/

HRESULT CWebCrawler::OnAuthenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
{
    HRESULT hr, hrRet=E_FAIL;
    ASSERT(phwnd && ppszUsername && ppszPassword);
    ASSERT((HWND)-1 == *phwnd && NULL == *ppszUsername && NULL == *ppszPassword);

    // If our host name doesn't match the root host name, don't return auth
    // information.

    LPWSTR pwszUrl, bstrHostName=NULL;

    m_pCurDownload->GetRealURL(&pwszUrl);   // may re-enter Trident

    if (pwszUrl)
    {
        GetHostName(pwszUrl, &bstrHostName);
        LocalFree(pwszUrl);
    }

    if (bstrHostName)
    {
        if (!m_bstrHostName || !MyAsciiCmpW(bstrHostName, m_bstrHostName))
        {
            // Host names match. Return auth information.
            // If we're hosted by channel agent, use its auth information
            ISubscriptionItem *pChannel=NULL;
            ISubscriptionItem *pItem=m_pSubscriptionItem;
            
            if (SUCCEEDED(GetChannelItem(&pChannel)))
            {
                pItem = pChannel;
            }
            
            hr = ReadOLESTR(pItem, c_szPropCrawlUsername, ppszUsername);
            if (SUCCEEDED(hr))
            {
                BSTR bstrPassword = NULL;
                hr = ReadPassword(pItem, &bstrPassword);
                if (SUCCEEDED(hr))
                {
                    int len = (lstrlenW(bstrPassword) + 1) * sizeof(WCHAR);
                    *ppszPassword = (LPWSTR) CoTaskMemAlloc(len);
                    if (*ppszPassword)
                    {
                        CopyMemory(*ppszPassword, bstrPassword, len);
                    }
                    SAFEFREEBSTR(bstrPassword);
                    if (*ppszPassword)
                    {
                        hrRet = S_OK;
                    }
                }
            }

            if (FAILED(hrRet))
            {
                SAFEFREEOLESTR(*ppszUsername);
                SAFEFREEOLESTR(*ppszPassword);
            }

            SAFERELEASE(pChannel);
        }

        SysFreeString(bstrHostName);
    }
    return hrRet;
}

HRESULT CWebCrawler::OnClientPull(UINT iID, LPCWSTR pwszOldURL, LPCWSTR pwszNewURL)
{
    // CUrlDownload is informing us it's about to do a client pull.

    // Let's send out a progress report for the new url
    SendUpdateProgress(pwszNewURL, m_iTotalStarted, m_lMaxNumUrls);

    // Now we need to process the current url: make it and dependencies sticky
    DWORD dwCurSize=0;
    BOOL fDiskFull=FALSE;
    MakePageStickyAndGetSize(pwszOldURL, &dwCurSize, &fDiskFull);
    m_dwCurSize += dwCurSize;
    TraceMsg(TF_THISMODULE, "WebCrawler processed page prior to client pull - now up to %d kb", (int)(m_dwCurSize>>10));

    // Tell CUrlDownload to go ahead and download the new url
    return S_OK;
}

HRESULT CWebCrawler::OnOleCommandTargetExec(const GUID *pguidCmdGroup, DWORD nCmdID,
                                DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                                VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;
    IPropertyBag2 *pPropBag = NULL;
    int i;

    //REVIEW: CLSID for this not yet defined.
    if (    pguidCmdGroup 
        && (*pguidCmdGroup == CGID_JavaParambagCompatHack) 
        && (nCmdID == 0) 
        && (nCmdexecopt == MSOCMDEXECOPT_DONTPROMPTUSER))
    {
        if (!IsRecurseFlagSet(WEBCRAWL_GET_CONTROLS))
        {
            goto Exit;
        }

        uCLSSPEC ucs;
        QUERYCONTEXT qc = { 0 };

        ucs.tyspec = TYSPEC_CLSID;
        ucs.tagged_union.clsid = CLSID_JavaVM;

        // Check to see if Java VM is installed. Don't try to get applets if not.
        if (!SUCCEEDED(FaultInIEFeature(NULL, &ucs, &qc, FIEF_FLAG_PEEK)))
        {
            goto Exit;
        }

        ULONG enIndex;
        const DWORD enMax = 7, enMin = 0;
        PROPBAG2 pb[enMax];
        VARIANT vaProps[enMax];
        HRESULT hrResult[enMax];
        enum { enCodeBase = 0, enCabBase, enCabinets, enArchive, enUsesLib, enLibrary, enUsesVer };
        LPWSTR pwszThisURL = NULL;
        int chLen;

        //REVIEW: This will need to be reviewed later when matching trident code is available
        //        and details worked out.

        if ((pvarargIn->vt != VT_UNKNOWN) || 
            (FAILED(pvarargIn->punkVal->QueryInterface(IID_IPropertyBag2, (void **)&pPropBag))))
        {
             goto Exit;
        }

        if (FAILED(GetRealUrl(m_iCurDownloadStringIndex, &pwszThisURL)))
        {
            pwszThisURL = StrDupW(L"");
        }

        // PROPBAG2 structure for data retrieval
        for (i=enMin; i<enMax; i++)
        {
            pb[i].dwType = PROPBAG2_TYPE_DATA;
            pb[i].vt = VT_BSTR;
            pb[i].cfType = NULL;                   // CLIPFORMAT
            pb[i].dwHint = 0;                      // ????
            pb[i].pstrName = NULL;
            pb[i].clsid = CLSID_NULL;              // ????
            vaProps[i].vt = VT_EMPTY;
            vaProps[i].bstrVal = NULL;
            hrResult[i] = E_FAIL;
        }

        if (((pb[enCodeBase].pstrName = SysAllocString(L"CODEBASE")) != NULL) &&
            ((pb[enCabBase].pstrName = SysAllocString(L"CABBASE")) != NULL) &&
            ((pb[enCabinets].pstrName = SysAllocString(L"CABINETS")) != NULL) &&
            ((pb[enArchive].pstrName = SysAllocString(L"ARCHIVE")) != NULL) &&
            ((pb[enUsesLib].pstrName = SysAllocString(L"USESLIBRARY")) != NULL) &&
            ((pb[enLibrary].pstrName = SysAllocString(L"USESLIBRARYCODEBASE")) != NULL) &&
            ((pb[enUsesVer].pstrName = SysAllocString(L"USESLIBRARYVERSION")) != NULL))
        {

            //Read returns E_FAIL even if it read some of the properties.
            //Since we check hrResult's below this isn't a big deal.

            hr = pPropBag->Read(enMax, &pb[0], NULL, &vaProps[0], &hrResult[0]);

            {
                BSTR szCodeBase = NULL;

                // check for CODEBASE
                if (SUCCEEDED(hrResult[enCodeBase]) && (vaProps[enCodeBase].vt == VT_BSTR))
                {
                    szCodeBase = vaProps[enCodeBase].bstrVal;
                }

                // add a trailing slash if not already present
                chLen = lstrlenW(szCodeBase);
                if (chLen && szCodeBase[chLen-1] != '/')
                {
                    LPWSTR szNewCodeBase = 0;
                    szNewCodeBase = (LPWSTR) LocalAlloc(0,sizeof(WCHAR)*(chLen+2));
                    if (szNewCodeBase)
                    {
                        StrCpyW(szNewCodeBase, szCodeBase);
                        StrCatW(szNewCodeBase, L"/");
                        SAFEFREEBSTR(szCodeBase);
                        szCodeBase = vaProps[enCodeBase].bstrVal = SysAllocString(szNewCodeBase);
                        LocalFree(szNewCodeBase);     
                    }
                }

                // check for CABBASE
                if (SUCCEEDED(hrResult[enCabBase]) && (vaProps[enCabBase].vt == VT_BSTR))
                {
                    BSTR szCabBase = vaProps[enCabBase].bstrVal;

                    // Add CABBASE URL to list of CABs to pull.
                    if (SUCCEEDED(CombineBaseAndRelativeURLs(pwszThisURL, szCodeBase, &szCabBase)))
                    {
                        m_pPages->AddString(szCabBase, 0);
                    }
                }

                // check for CABINETS
                for (enIndex = enCabinets; enIndex<(enArchive+1); enIndex++)
                {
                    if (SUCCEEDED(hrResult[enIndex]) && (vaProps[enIndex].vt == VT_BSTR))
                    {
                        BSTR szCur = vaProps[enIndex].bstrVal, szPrev = NULL;
                        while (szCur)
                        {
                            WCHAR wcCur = *szCur;

                            if ((wcCur == L'+') || (wcCur == L',') || (wcCur == L'\0'))
                            {
                                BSTR szLast = szPrev, szCabBase = NULL;
                                BOOL bLastFile = FALSE;
                                if (!szPrev)
                                {
                                    szLast = vaProps[enIndex].bstrVal;
                                }
                                szPrev = szCur; szPrev++;

                                if (*szCur == L'\0')
                                {
                                    bLastFile = TRUE;
                                }
                                *szCur = (unsigned short)L'\0';

                                // szLast points to current CabBase.
                                szCabBase = SysAllocString(szLast);
                                if (SUCCEEDED(CombineBaseAndRelativeURLs(pwszThisURL, szCodeBase, &szCabBase)))
                                {
                                    int iAdd=m_pPages->AddString(szCabBase, DATA_CODEBASE);
                                    if (m_lMaxNumUrls > 0 && iAdd==CWCStringList::STRLST_ADDED)
                                        m_lMaxNumUrls ++;
                                }
                                SAFEFREEBSTR(szCabBase);

                                if (bLastFile)
                                {
                                    szCur = NULL;
                                    break;
                                }
                            }
                            szCur++;
                        }  // while (szCur)
                    }  // cabinets
                }

                // check for USESLIBRARY* parameters.
                CCodeBaseHold *pcbh = NULL;
                if (SUCCEEDED(hrResult[enUsesLib]) && (vaProps[enUsesLib].vt == VT_BSTR) &&
                    SUCCEEDED(hrResult[enLibrary]) && (vaProps[enLibrary].vt == VT_BSTR))
                {
                    BSTR szThisLibCAB = NULL;
                    pcbh = new CCodeBaseHold();
                    if (pcbh)
                    {
                        pcbh->szDistUnit = SysAllocString(vaProps[enUsesLib].bstrVal);
                        pcbh->dwVersionMS = pcbh->dwVersionLS = -1;
                        pcbh->dwFlags = 0;
                        szThisLibCAB = SysAllocString(vaProps[enLibrary].bstrVal);
                        if (FAILED(CombineBaseAndRelativeURLs(pwszThisURL, szCodeBase, &szThisLibCAB)) ||
                            m_pCodeBaseList->AddString(szThisLibCAB, (DWORD_PTR)pcbh) != CWCStringList::STRLST_ADDED)
                        {
                            SAFEFREEBSTR(pcbh->szDistUnit);
                            SAFEDELETE(pcbh);
                        }
                        SAFEFREEBSTR(szThisLibCAB);
                    }
                }

                // Check for USESLIBRARYVERSION (optional)
                if (pcbh && SUCCEEDED(hrResult[enUsesVer]) && (vaProps[enUsesVer].vt == VT_BSTR))
                {
                    int iLen = SysStringByteLen(vaProps[enUsesVer].bstrVal)+1;
                    CHAR *szVerStr = (LPSTR)MemAlloc(LMEM_FIXED, iLen);

                    if (szVerStr)
                    {
                        SHUnicodeToAnsi(vaProps[enUsesVer].bstrVal, szVerStr, iLen);

                        if (FAILED(GetVersionFromString(szVerStr,
                                     &pcbh->dwVersionMS, &pcbh->dwVersionLS)))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                            MemFree(szVerStr);
                            SAFEFREEBSTR(pcbh->szDistUnit);
                            SAFEDELETE(pcbh);
                        }
                        MemFree(szVerStr);
                    }
                }
            }
        } // Read properties

        for (i=enMin; i<enMax; i++)
        {
            SAFEFREEBSTR(pb[i].pstrName);
        }

        if (pwszThisURL)
            LocalFree(pwszThisURL);

        hr = S_OK;
    }

Exit:
    SAFERELEASE(pPropBag);
    return hr;
}

HRESULT CWebCrawler::GetDownloadNotify(IDownloadNotify **ppOut)
{
    HRESULT hr=S_OK;

    if (m_pDownloadNotify)
    {
        m_pDownloadNotify->LeaveMeAlone();
        m_pDownloadNotify->Release();
        m_pDownloadNotify=NULL;
    }

    m_pDownloadNotify = new CDownloadNotify(this);

    if (m_pDownloadNotify)
    {
        *ppOut = m_pDownloadNotify;
        m_pDownloadNotify->AddRef();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppOut = NULL;
    }

    return hr;
}

//---------------------------------------------------------------
// CWebCrawler::CDownloadNotify class
//---------------------------------------------------------------
CWebCrawler::CDownloadNotify::CDownloadNotify(CWebCrawler *pParent)
{
    ASSERT(pParent);

    m_cRef = 1;

    m_pParent = pParent;
    pParent->AddRef();

    InitializeCriticalSection(&m_critParent);
}

CWebCrawler::CDownloadNotify::~CDownloadNotify()
{
    DBG("Destroying CWebCrawler::CDownloadNotify");

    ASSERT(!m_pParent);
    SAFERELEASE(m_pParent);
    DeleteCriticalSection(&m_critParent);
}

void CWebCrawler::CDownloadNotify::LeaveMeAlone()
{
    if (m_pParent)
    {
        EnterCriticalSection(&m_critParent);
        SAFERELEASE(m_pParent);
        LeaveCriticalSection(&m_critParent);
    }
}

// IUnknown members
HRESULT CWebCrawler::CDownloadNotify::QueryInterface(REFIID riid, void **ppv)
{
    if ((IID_IUnknown == riid) ||
        (IID_IDownloadNotify == riid))
    {
        *ppv = (IDownloadNotify *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

ULONG CWebCrawler::CDownloadNotify::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CWebCrawler::CDownloadNotify::Release(void)
{
    if (0L != InterlockedDecrement(&m_cRef))
        return 1L;

    delete this;
    return 0L;
}

// IDownloadNotify
HRESULT CWebCrawler::CDownloadNotify::DownloadStart(LPCWSTR pchUrl, DWORD dwDownloadId, DWORD dwType, DWORD dwReserved)
{
    HRESULT hr = E_ABORT;   // abort it if we have nobody listening

    TraceMsg(TF_THISMODULE, "DownloadStart id=%d url=%ws", dwDownloadId, pchUrl ? pchUrl : L"(null)");

    EnterCriticalSection(&m_critParent);
    if (m_pParent)
        hr = m_pParent->DownloadStart(pchUrl, dwDownloadId, dwType, dwReserved);
    LeaveCriticalSection(&m_critParent);

    return hr;
}

HRESULT CWebCrawler::CDownloadNotify::DownloadComplete(DWORD dwDownloadId, HRESULT hrNotify, DWORD dwReserved)
{
    HRESULT hr = S_OK;

//  TraceMsg(TF_THISMODULE, "DownloadComplete id=%d hr=%x", dwDownloadId, hrNotify);

    EnterCriticalSection(&m_critParent);
    if (m_pParent)
        hr = m_pParent->DownloadComplete(dwDownloadId, hrNotify, dwReserved);
    LeaveCriticalSection(&m_critParent);

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Other functions
//
//////////////////////////////////////////////////////////////////////////
// Make a single absolute or relative url sticky and get size
HRESULT GetUrlInfoAndMakeSticky(
            LPCTSTR                     pszBaseUrl,
            LPCTSTR                     pszThisUrl,
            LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,
            DWORD                       dwBufSize,
            GROUPID                     llCacheGroupID)
{
    DWORD   dwSize;
    TCHAR   szCombined[INTERNET_MAX_URL_LENGTH];

#if 0   // Make lpCacheEntryInfo optional
    BYTE    chBuf[MY_MAX_CACHE_ENTRY_INFO];
    if (!lpCacheEntryInfo)
    {
        lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)chBuf;
        dwBufSize = sizeof(chBuf);
    }
#else
    ASSERT(lpCacheEntryInfo);
#endif

    // Combine urls if necessary
    if (pszBaseUrl)
    {
        dwSize = ARRAYSIZE(szCombined);
        if (SUCCEEDED(UrlCombine(pszBaseUrl, pszThisUrl,
                szCombined, &dwSize, 0)))
        {
            pszThisUrl = szCombined;
        }
        else
            DBG_WARN("UrlCombine failed!");
    }

    // Add the size of this URL
    lpCacheEntryInfo->dwStructSize = dwBufSize;
    if (!GetUrlCacheEntryInfo(pszThisUrl, lpCacheEntryInfo, &dwBufSize))
    {
#ifdef DEBUG
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            DBG_WARN("Failed GetUrlCacheEntryInfo, insufficient buffer");
        else
            TraceMsgA(llCacheGroupID ? TF_WARNING : TF_THISMODULE,
                "Failed GetUrlCacheEntryInfo (not in cache) URL=%ws", pszThisUrl);
#endif
        return E_FAIL;
    }

    // Add to new group
    if (llCacheGroupID != 0)
    {
        if (!SetUrlCacheEntryGroup(pszThisUrl, INTERNET_CACHE_GROUP_ADD,
            llCacheGroupID, NULL, 0, NULL))
        {
            switch (GetLastError())
            {
                case ERROR_FILE_NOT_FOUND:  //  Huh? Must not have been able to add the index entry?
                case ERROR_DISK_FULL:
                    return E_OUTOFMEMORY;

                case ERROR_NOT_ENOUGH_QUOTA:
                    return S_OK;            //  We do our own quota handling.

                default:
                    TraceMsgA(TF_WARNING | TF_THISMODULE, "GetUrlInfoAndMakeSticky: Got unexpected error from SetUrlCacheEntryGroup() - GLE = 0x%08x", GetLastError());
                    return E_FAIL;
            }
        }
    }

    return S_OK;
}

// GenerateCode will generate a DWORD code from a file.

#define ELEMENT_PER_READ        256
#define ELEMENT_SIZE            sizeof(DWORD)

HRESULT GenerateCode(LPCTSTR lpszLocalFileName, DWORD *pdwRet)
{
    DWORD dwCode=0;
    DWORD dwData[ELEMENT_PER_READ], i, dwRead;
    HRESULT hr = S_OK;
    HANDLE  hFile;

    hFile = CreateFile(lpszLocalFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
            0, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        do
        {
            dwRead = 0;
            if (ReadFile(hFile, dwData, ELEMENT_PER_READ * ELEMENT_SIZE, &dwRead, NULL))
            {
                for (i=0; i<dwRead / ELEMENT_SIZE; i++)
                {
                    dwCode = (dwCode << 31) | (dwCode >> 1) + dwData[i];
//                  dwCode += dwData[i];
                }
            }   
        }
        while (ELEMENT_PER_READ * ELEMENT_SIZE == dwRead);

        CloseHandle(hFile);
    }
    else
    {
        hr = E_FAIL;
        TraceMsg(TF_THISMODULE|TF_WARNING,"GenerateCode: Unable to open cache file, Error=%x", GetLastError());
    }

    *pdwRet = dwCode;

    return hr;
}

// S_OK : We retrieved a good last modified or content code to use
// S_FALSE : We fell back to using the one passed into pvarChange
// E_FAIL : We failed miserably.
// E_INVALIDARG : Get a clue
// *pfGetContent : TRUE if we need a GET for PostCheckUrlForChange to work right
HRESULT PreCheckUrlForChange(LPCTSTR lpURL, VARIANT *pvarChange, BOOL *pfGetContent)
{
    BYTE    chBuf[MY_MAX_CACHE_ENTRY_INFO];

    LPINTERNET_CACHE_ENTRY_INFO lpInfo = (LPINTERNET_CACHE_ENTRY_INFO) chBuf;

    if (pvarChange->vt != VT_EMPTY && pvarChange->vt != VT_I4 && pvarChange->vt != VT_CY)
        return E_INVALIDARG;

    if (SUCCEEDED(GetUrlInfoAndMakeSticky(NULL, lpURL, lpInfo, sizeof(chBuf), 0)))
    {
        FILETIME ftOldLastModified = *((FILETIME *) &pvarChange->cyVal);

        if (lpInfo->LastModifiedTime.dwHighDateTime || lpInfo->LastModifiedTime.dwLowDateTime)
        {
            // We have a last modified time. Use it or the persisted one.

            if (pfGetContent)
                *pfGetContent = FALSE;

            if ((pvarChange->vt != VT_CY)
             || (lpInfo->LastModifiedTime.dwHighDateTime > ftOldLastModified.dwHighDateTime)
             || ((lpInfo->LastModifiedTime.dwHighDateTime == ftOldLastModified.dwHighDateTime)
                && (lpInfo->LastModifiedTime.dwLowDateTime > ftOldLastModified.dwLowDateTime)))
            {
                // Cache Last Modified is newer than saved Last Modified. Use cache's.
                pvarChange->vt = VT_CY;
                pvarChange->cyVal = *((CY *)&(lpInfo->LastModifiedTime));

                return S_OK;
            }

            ASSERT(pvarChange->vt == VT_CY);

            // Persisted Last Modified time is most recent. Use it.
            return S_OK;
        }

        DWORD dwCode;

        if (SUCCEEDED(GenerateCode(lpInfo->lpszLocalFileName, &dwCode)))
        {
            pvarChange->vt = VT_I4;
            pvarChange->lVal = (LONG) dwCode;

            if (pfGetContent)
                *pfGetContent = TRUE;

            return S_OK;
        }

        // Failed GenerateCode. Weird. Fall through.
    }

    if (pvarChange->vt != VT_EMPTY)
    {
        if (pfGetContent)
            *pfGetContent = (pvarChange->vt == VT_I4);

        return S_FALSE;
    }

    // We don't have old change detection, we don't have cache content, better GET
    if (pfGetContent)
        *pfGetContent = TRUE;

    return E_FAIL;  // Couldn't get anything. pvarChange->vt==VT_EMPTY
}

// S_FALSE : no change
// S_OK    : changed
// E_      : failure of some sort

// pvarChange from PreCheckUrlForChange. We return a new one.
// lpInfo  : must be valid if *pfGetContent was TRUE
// ftNewLastModified : must be filled in if *pfGetContent was FALSE
HRESULT PostCheckUrlForChange(VARIANT                    *pvarChange,
                              LPINTERNET_CACHE_ENTRY_INFO lpInfo,
                              FILETIME                    ftNewLastModified)
{
    HRESULT hr = S_FALSE;
    VARIANT varChangeNew;

    DWORD   dwNewCode = 0;

    if (!pvarChange || (pvarChange->vt != VT_I4 && pvarChange->vt != VT_CY && pvarChange->vt != VT_EMPTY))
        return E_INVALIDARG;

    varChangeNew.vt = VT_EMPTY;

    if (ftNewLastModified.dwHighDateTime || ftNewLastModified.dwLowDateTime)
    {
        varChangeNew.vt = VT_CY;
        varChangeNew.cyVal = *((CY *) &ftNewLastModified);
    }
    else
    {
        if (lpInfo &&
            SUCCEEDED(GenerateCode(lpInfo->lpszLocalFileName, &dwNewCode)))
        {
            varChangeNew.vt = VT_I4;
            varChangeNew.lVal = dwNewCode;
        }
    }

    if (pvarChange->vt == VT_CY)
    {
        // We have an old last modified time. Use that to determine change.
        FILETIME ftOldLastModified = *((FILETIME *) &(pvarChange->cyVal));

        if ((!ftNewLastModified.dwHighDateTime && !ftNewLastModified.dwLowDateTime)
            || (ftNewLastModified.dwHighDateTime > ftOldLastModified.dwHighDateTime)
            || ((ftNewLastModified.dwHighDateTime == ftOldLastModified.dwHighDateTime)
                && (ftNewLastModified.dwLowDateTime > ftOldLastModified.dwLowDateTime)))
        {
            // NewLastModified > OldLastModified (or we don't have a NewLastModified)
            DBG("PostCheckUrlForChange change detected via Last Modified");
            hr = S_OK;      // We have changed
        }
    }
    else if (pvarChange->vt == VT_I4)
    {
        // We have an old code. Use that to determine change.
        DWORD dwOldCode = (DWORD) (pvarChange->lVal);

        if ((dwOldCode != dwNewCode) ||
            !dwNewCode)
        {
            DBG("PostCheckUrlForChange change detected via content code");
            hr = S_OK;  // We have changed
        }
    }
    else
        hr = E_FAIL;    // No old code.

    *pvarChange = varChangeNew;

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// CHelperOM implementation
//
//////////////////////////////////////////////////////////////////////////

CHelperOM::CHelperOM(IHTMLDocument2 *pDoc)
{
    ASSERT(pDoc);
    m_pDoc = pDoc;
    if (pDoc)
        pDoc->AddRef();
}

CHelperOM::~CHelperOM()
{
    SAFERELEASE(m_pDoc);
}

HRESULT CHelperOM::GetTagCollection(
                        IHTMLDocument2          *pDoc,
                        LPCWSTR                  wszTagName,
                        IHTMLElementCollection **ppCollection)
{
    IHTMLElementCollection *pAll=NULL;
    IDispatch              *pDisp=NULL;
    VARIANT                 TagName;
    HRESULT                 hr;

    // We have to get "all", then sub-collection
    hr = pDoc->get_all(&pAll);
    if (pAll)
    {
        TagName.vt = VT_BSTR;
        TagName.bstrVal = SysAllocString(wszTagName);
        if (NULL == TagName.bstrVal)
            hr = E_OUTOFMEMORY;
        else
        {
            hr = pAll->tags(TagName, &pDisp);
            SysFreeString(TagName.bstrVal);
        }
        pAll->Release();
    }
    if (pDisp)
    {
        hr = pDisp->QueryInterface(IID_IHTMLElementCollection,
                                        (void **)ppCollection);
        pDisp->Release();
    }
    if (FAILED(hr)) DBG("GetSubCollection failed");

    return hr;
}


// Collections we get:
//
// IHTMLWindow2->get_document
//  IHTMLDocument2  ->get_links
//  IHTMLElementCollection->item
//                          ->get_hostname
//                          ->get_href
//                  ->get_all
//                      ->tags("map")
//  IHTMLElementCollection  ->item
//                              ->get_areas
//  IHTMLElementCollection          ->item
//  IHTMLAreaElement                    ->get_href
//                  ->get_all
//                      ->tags("meta")
//  IHTMLElementCollection  ->item
//                  ->get_all
//                      ->tags("frame")
//  IHTMLElementCollection  ->item
//                  ->get_all
//                      ->tags("iframe")
//  IHTMLElementCollection  ->item

// We recurse EnumCollection to get the maps (since
//      it's a collection of collections)


// hideous hack: IHTMLElementCollection can actually be IHTMLAreasCollection
//  the interface used to be derived from the other. It still has identical
//  methods. We typecast just in case that changes. Hopefully they will fix
//  so that Areas is derived from Element again.
HRESULT CHelperOM::EnumCollection(
            IHTMLElementCollection *pCollection,
            CWCStringList          *pStringList,
            CollectionType          Type,
            PFN_CB                  pfnCB,
            DWORD_PTR               dwCBData)
{
    IHTMLAnchorElement *pLink;
    IHTMLMapElement  *pMap;
    IHTMLAreaElement *pArea;
    IHTMLMetaElement *pMeta;
    IHTMLElement     *pEle;
    IDispatch        *pDispItem = NULL;

    HRESULT hr;
    BSTR    bstrItem=NULL;
    long    l, lCount;
    VARIANT vIndex, vEmpty, vData;
    BSTR    bstrTmp1, bstrTmp2;
    DWORD   dwStringData;

    VariantInit(&vEmpty);
    VariantInit(&vIndex);
    VariantInit(&vData);

    if (Type==CTYPE_MAP)
        hr = ((IHTMLAreasCollection *)pCollection)->get_length(&lCount);
    else
        hr = pCollection->get_length(&lCount);

    if (FAILED(hr))
        lCount = 0;

#ifdef DEBUG
    LPSTR lpDSTR[]={"Links","Maps","Areas (links) In Map", "Meta", "Frames"};
    TraceMsgA(TF_THISMODULE, "CWebCrawler::GetCollection, %d %s found", lCount, lpDSTR[(int)Type]);
#endif

    for (l=0; l<lCount; l++)
    {
        vIndex.vt = VT_I4;
        vIndex.lVal = l;
        dwStringData = 0;

        if (Type==CTYPE_MAP)
            hr = ((IHTMLAreasCollection *)pCollection)->item(vIndex, vEmpty, &pDispItem);
        else
            hr = pCollection->item(vIndex, vEmpty, &pDispItem);

        if (SUCCEEDED(hr))
        {
            ASSERT(vData.vt == VT_EMPTY);
            ASSERT(!bstrItem);

            if (pDispItem)
            {
                // Get the URL from the IDispatch
                switch(Type)
                {
                    case CTYPE_LINKS:       // get href from <a>
                        hr = pDispItem->QueryInterface(IID_IHTMLAnchorElement, (void **)&pLink);

                        if (SUCCEEDED(hr) && pLink)
                        {
                            hr = pLink->get_href(&bstrItem);
                            pLink->Release();
                        }
                        break;

                    case CTYPE_MAPS:    // enumeration areas for this map
                        hr = pDispItem->QueryInterface(IID_IHTMLMapElement, (void **)&pMap);

                        if (SUCCEEDED(hr) && pMap)
                        {
                            IHTMLAreasCollection *pNewCollection=NULL;
                            // This gives us another collection. Enumerate it
                            //  for the strings.
                            hr = pMap->get_areas(&pNewCollection);
                            if (pNewCollection)
                            {
                                hr = EnumCollection((IHTMLElementCollection *)pNewCollection, pStringList, CTYPE_MAP, pfnCB, dwCBData);
                                pNewCollection->Release();
                            }
                            pMap->Release();
                        }
                        break;

                    case CTYPE_MAP:     // get href for this area
                        hr = pDispItem->QueryInterface(IID_IHTMLAreaElement, (void **)&pArea);

                        if (SUCCEEDED(hr) && pArea)
                        {
                            hr = pArea->get_href(&bstrItem);
                            pArea->Release();
                        }
                        break;

                    case CTYPE_META:    // get meta name and content as single string
                        hr = pDispItem->QueryInterface(IID_IHTMLMetaElement, (void **)&pMeta);

                        if (SUCCEEDED(hr) && pMeta)
                        {
                            pMeta->get_name(&bstrTmp1);
                            pMeta->get_content(&bstrTmp2);
                            if (bstrTmp1 && bstrTmp2 && *bstrTmp1 && *bstrTmp2)
                            {
                                bstrItem = SysAllocStringLen(NULL, lstrlenW(bstrTmp1) +
                                                                   lstrlenW(bstrTmp2) + 1);

                                StrCpyW(bstrItem, bstrTmp1);
                                StrCatW(bstrItem, L"\n");
                                StrCatW(bstrItem, bstrTmp2);
                            }
                            SysFreeString(bstrTmp1);
                            SysFreeString(bstrTmp2);
                            pMeta->Release();
                        }
                        break;

                    case CTYPE_FRAMES:      // get "src" attribute
                        hr = pDispItem->QueryInterface(IID_IHTMLElement, (void **)&pEle);

                        if (SUCCEEDED(hr) && pEle)
                        {
                            bstrTmp1 = SysAllocString(L"SRC");

                            if (bstrTmp1)
                            {
                                hr = pEle->getAttribute(bstrTmp1, VARIANT_FALSE, &vData);
                                if (SUCCEEDED(hr) && vData.vt == VT_BSTR)
                                {
                                    bstrItem = vData.bstrVal;
                                    vData.vt = VT_EMPTY;
                                }
                                else
                                    VariantClear(&vData);

                                SysFreeString(bstrTmp1);
                            }
                            else
                            {
                                hr = E_FAIL;
                            }

                            pEle->Release();
                        }
                        break;

                    default:
                        ASSERT(0);
                        // bug in calling code
                }

                if (SUCCEEDED(hr) && bstrItem)
                {
                    // Verify we want to add this item to string list & get data
                    if (pfnCB)
                        hr = pfnCB(pDispItem, &bstrItem, dwCBData, &dwStringData);

                    if (SUCCEEDED(hr) && bstrItem && pStringList)
                        pStringList->AddString(bstrItem, dwStringData);
                }
                SAFERELEASE(pDispItem);
                SAFEFREEBSTR(bstrItem);
            }
        }
        if (E_ABORT == hr)
        {
            DBG_WARN("Aborting enumeration in CHelperOM::EnumCollection at callback's request.");
            break;
        }
    }

    return hr;
}


// Gets all urls from a collection, recursing through frames
HRESULT CHelperOM::GetCollection(
    IHTMLDocument2 *pDoc,
    CWCStringList  *pStringList,
    CollectionType  Type,
    PFN_CB          pfnCB,
    DWORD_PTR       dwCBData)
{
    HRESULT         hr;

    // Get the collection from the document
    ASSERT(pDoc);
    ASSERT(pStringList || pfnCB);

    hr = _GetCollection(pDoc, pStringList, Type, pfnCB, dwCBData);

#if 0
    // we enumerate for the top-level interface, then for subframes if any
    long lLen=0, lIndex;
    VARIANT vIndex, vResult;
    vResult.vt = VT_EMPTY;
    IHTMLWindow2 *pWin2=NULL;

    if (SUCCEEDED(pWin->get_length(&lLen)) && lLen>0)
    {
        TraceMsg(TF_THISMODULE, "Also enumerating for %d subframes", (int)lLen);
        for (lIndex=0; lIndex<lLen; lIndex++)
        {
            vIndex.vt = VT_I4;
            vIndex.lVal = lIndex;

            pWin->item(&vIndex, &vResult);

            if (vResult.vt == VT_DISPATCH && vResult.pdispVal)
            {
                if (SUCCEEDED(vResult.pdispVal->QueryInterface(IID_IHTMLWindow2, (void **)&pWin2)) && pWin2)
                {
                    GetCollection(pWin2, pStringList, Type);
                    pWin2->Release();
                    pWin2=NULL;
                }
            }
            VariantClear(&vResult);
        }
    }
#endif

    return hr;
}

// get all urls from a collection
HRESULT CHelperOM::_GetCollection(
    IHTMLDocument2 *pDoc,
    CWCStringList  *pStringList,
    CollectionType  Type,
    PFN_CB          pfnCB,
    DWORD_PTR       dwCBData)
{
    HRESULT         hr;
    IHTMLElementCollection *pCollection=NULL;

    // From IHTMLDocument2 we get IHTMLElementCollection, then enumerate for the urls

    // Get appropriate collection from document
    switch (Type)
    {
        case CTYPE_LINKS:
            hr = pDoc->get_links(&pCollection);
            break;
        case CTYPE_MAPS:
            hr = GetTagCollection(pDoc, L"map", &pCollection);
            break;
        case CTYPE_META:
            hr = GetTagCollection(pDoc, L"meta", &pCollection);
            break;
        case CTYPE_FRAMES:
            hr = GetTagCollection(pDoc, L"frame", &pCollection);
            break;

        default:
            hr = E_FAIL;
    }
    if (!pCollection) hr=E_NOINTERFACE;
#ifdef DEBUG
    if (FAILED(hr)) DBG_WARN("CWebCrawler::_GetCollection:  get_collection failed");
#endif

    if (SUCCEEDED(hr))
    {
        hr = EnumCollection(pCollection, pStringList, Type, pfnCB, dwCBData);

        // If we're getting frames, we need to enum "iframe" tags separately
        if (SUCCEEDED(hr) && (Type == CTYPE_FRAMES))
        {
            SAFERELEASE(pCollection);
            hr = GetTagCollection(pDoc, L"iframe", &pCollection);

            if (SUCCEEDED(hr) && pCollection)
            {
                hr = EnumCollection(pCollection, pStringList, Type, pfnCB, dwCBData);
            }
        }
    }

    if (pCollection)
        pCollection->Release();

    return hr;
}

extern HRESULT LoadWithCookie(LPCTSTR, POOEBuf, DWORD *, SUBSCRIPTIONCOOKIE *);

// IExtractIcon members
STDMETHODIMP CWebCrawler::GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    IUniformResourceLocator* pUrl = NULL;
    IExtractIcon* pUrlIcon = NULL;
    HRESULT hr = S_OK;
    BOOL bCalledCoInit = FALSE;

    if (!szIconFile || !piIndex || !pwFlags)
        return E_INVALIDARG;
    //zero out return values in case one of the COM calls fails...
    *szIconFile = 0;
    *piIndex = -1;

    if (!m_pBuf)    {
        m_pBuf = (POOEBuf)MemAlloc(LPTR, sizeof(OOEBuf));
        if (!m_pBuf)
            return E_OUTOFMEMORY;

        DWORD   dwSize;
        hr = LoadWithCookie(NULL, m_pBuf, &dwSize, &m_SubscriptionCookie);
        RETURN_ON_FAILURE(hr);
    }


    if (m_pBuf->bDesktop)
    {
        StrCpyN(szIconFile, TEXT(":desktop:"), cchMax);
    }
    else
    {
        if (m_pUrlIconHelper)
        {
            hr = m_pUrlIconHelper->GetIconLocation (uFlags, szIconFile, cchMax, piIndex, pwFlags);
        }
        else
        {
            hr = CoCreateInstance (CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IUniformResourceLocator, (void**)&pUrl);
            if ((CO_E_NOTINITIALIZED == hr || REGDB_E_IIDNOTREG == hr) &&
                SUCCEEDED (CoInitialize(NULL)))
            {
                bCalledCoInit = TRUE;
                hr = CoCreateInstance (CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IUniformResourceLocator, (void**)&pUrl);
            }

            if (SUCCEEDED (hr))
            {
                hr = pUrl->SetURL (m_pBuf->m_URL, 1);
                if (SUCCEEDED (hr))
                {
                    hr = pUrl->QueryInterface (IID_IExtractIcon, (void**)&pUrlIcon);
                    if (SUCCEEDED (hr))
                    {
                        hr = pUrlIcon->GetIconLocation (uFlags, szIconFile, cchMax, piIndex, pwFlags);

                        //pUrlIcon->Release();  //released in destructor
                        ASSERT (m_pUrlIconHelper == NULL);
                        m_pUrlIconHelper = pUrlIcon;
                    }
                }
                pUrl->Release();
            }

            //balance CoInit with CoUnit
            //(we still have a pointer to the CLSID_InternetShortcut object, m_pUrlIconHelper,
            //but since that code is in shdocvw there's no danger of it getting unloaded and
            //invalidating our pointer, sez cdturner.)
            if (bCalledCoInit)
                CoUninitialize();
        }
    }

    return hr;
}

STDMETHODIMP CWebCrawler::Extract(LPCTSTR szIconFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    HRESULT hr = S_OK;

    if (!phiconLarge || !phiconSmall)
        return E_INVALIDARG;

    //zero out return values in case one of the COM calls fails...
    *phiconLarge = NULL;
    *phiconSmall = NULL;

    if ((NULL != m_pBuf) && (m_pBuf->bDesktop))
    {
        LoadDefaultIcons();
        *phiconLarge = *phiconSmall = g_desktopIcon;
    }
    else
    {
        if (!m_pUrlIconHelper)
            return E_FAIL;

        hr = m_pUrlIconHelper->Extract (szIconFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\utils.h ===
#ifndef UTILS_H
#define UTILS_H

#include <htmlhelp.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef UNICODE
HRESULT IExtractIcon_GetIconLocationThunk(IExtractIconW *peiw, UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags);
HRESULT IExtractIcon_ExtractThunk(IExtractIconW *peiw, LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize);
#endif

void FireSubscriptionEvent(int nCmdID, const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie);

int WCMessageBox(HWND hwnd, UINT idTextFmt, UINT idCaption, UINT uType, ...);

HRESULT GetCacheInfo(LPINTERNET_CACHE_CONFIG_INFOA *, DWORD *, DWORD *);
HRESULT SetCacheSize(LPINTERNET_CACHE_CONFIG_INFOA, DWORD);

HRESULT _CreatePropSheet(HWND, POOEBuf);
int     _GetCmdID(LPCSTR);
int     _CompareShortName(LPMYPIDL, LPMYPIDL);
int     _CompareURL(LPMYPIDL, LPMYPIDL);
int     _CompareNextUpdate(LPMYPIDL, LPMYPIDL);
int     _CompareLastUpdate(LPMYPIDL, LPMYPIDL);
int     _CompareIdentities(LPMYPIDL, LPMYPIDL);
int     _CompareGroup(LPMYPIDL, LPMYPIDL);
int     _CompareStatus(LPMYPIDL, LPMYPIDL);
int     _ComparePriority(LPMYPIDL, LPMYPIDL);
void    _GenerateEvent(LONG, LPITEMIDLIST, LPITEMIDLIST, BOOL bRefresh = TRUE);
int     _LaunchApp(HWND, LPCTSTR);
BOOL    _ValidateIDListArray(UINT cidl, LPCITEMIDLIST *ppidl);
UINT    BufferSize(POOEBuf);
VOID    CannotSaveProperty(HWND);
BOOL    ConfirmDelete(HWND, UINT, LPMYPIDL *);
void    CopyToMyPooe(POOEBuf, POOEntry);
void    CopyToOOEBuf(POOEntry, POOEBuf);
HRESULT CreateBSTRFromTSTR(BSTR *, LPCTSTR);
BOOL    DATE2DateTimeString(CFileTime&, LPTSTR);
BOOL    Date2LocalDateString(SYSTEMTIME *, LPTSTR, int);
void    VariantTimeToFileTime(double dt, FILETIME& ft);
void    FileTimeToVariantTime(FILETIME& ft, double *pdt);

void SetListViewToString (HWND hLV, LPCTSTR pszString);

void GlobalAutoDial_Enable (BOOL bEnable);
BOOL GlobalAutoDial_IsEnabled (void);
BOOL GlobalAutoDial_ShouldEnable (HWND hParentWnd);

BOOL FailsWin95SecurityCheck (HWND hParentWnd);

BOOL    IsHTTPPrefixed(LPCTSTR szURL);
HRESULT LoadOOEntryInfo(POOEBuf pooeBuf, SUBSCRIPTIONCOOKIE *pCookie, DWORD *pdwSize);
HRESULT LoadSubscription(LPCTSTR, LPMYPIDL *);
UINT    MergeMenuHierarchy(HMENU, HMENU, UINT, UINT, BOOL);
UINT    MergePopupMenu(HMENU *phMenu, UINT idResource, UINT uSubOffset, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast);
HRESULT MergeOOEBuf(OOEBuf *pBuf1, OOEBuf *pBuf2, DWORD fMask);
HRESULT SendUpdateRequests(HWND hwnd, CLSID *, UINT count);

HRESULT PersistUpdate(POOEntry, BOOL bCreate);
HRESULT SaveBufferChange(POOEBuf newBuf, BOOL bCreate);
HRESULT LoadGroupCookie(NOTIFICATIONCOOKIE *, SUBSCRIPTIONSCHEDULE subGroup);

DWORD Random(DWORD nMax);
void CreateCookie(GUID UNALIGNED *pCookie);


BOOL _InitComCtl32();

//REVIEW Do we need the indirect versions?
#undef CreateDialogParam
#undef CreateDialog
#undef DialogBoxParam
#undef DialogBox
#undef PropertySheet

inline HWND CreateDialogParam(HINSTANCE  hInstance, LPCTSTR lpTemplateName,
                              HWND  hWndParent, DLGPROC lpDialogFunc,
                              LPARAM dwInitParam)
{
    _InitComCtl32();
#ifdef UNICODE
    return CreateDialogParamW(hInstance, lpTemplateName, hWndParent, 
                              lpDialogFunc, dwInitParam);
#else
    return CreateDialogParamA(hInstance, lpTemplateName, hWndParent, 
                              lpDialogFunc, dwInitParam);
#endif
}

inline HWND CreateDialog(HINSTANCE  hInstance, LPCTSTR lpTemplateName,
                         HWND  hWndParent, DLGPROC lpDialogFunc)
{
    return CreateDialogParam(hInstance, lpTemplateName, hWndParent, lpDialogFunc, 0L);
}

inline INT_PTR DialogBoxParam(HINSTANCE hInstance, LPCTSTR lpTemplateName, HWND hWndParent,
                          DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    _InitComCtl32();
#ifdef UNICODE
    return DialogBoxParamW(hInstance, lpTemplateName, hWndParent, 
                           lpDialogFunc, dwInitParam);
#else
    return DialogBoxParamA(hInstance, lpTemplateName, hWndParent, 
                           lpDialogFunc, dwInitParam);
#endif
}

inline INT_PTR DialogBox(HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent,
                     DLGPROC lpDialogFunc)
{
    return DialogBoxParam(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L);
}

inline INT_PTR PropertySheet(LPCPROPSHEETHEADER lppsph)
{
    _InitComCtl32();
#ifdef UNICODE
    return PropertySheetW(lppsph);
#else
    return PropertySheetA(lppsph);
#endif
}

#ifdef __cplusplus
};
#endif

#endif  UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\webcheck.cpp ===
#include "private.h"
#include "subsmgrp.h"
#include "offsync.h"
#include "offl_cpp.h"
#include "factory.h"
#include "notfcvt.h"
#define TF_THISMODULE TF_WEBCHECKCORE

#include "resource.h"

#define INITGUIDS
#include <shlguid.h>

#define MLUI_INIT
#include <mluisupp.h>

//  We're going to use our own new and delete so that we can 
//  use shdocvw's leak detection code
//

//
// Subscription property names
//
// Agent Start
extern const WCHAR  c_szPropURL[] = L"URL";
extern const WCHAR  c_szPropName[] = L"Name";
extern const WCHAR  c_szPropAgentFlags[] = L"AgentFlags";
extern const WCHAR  c_szPropCrawlLevels[] = L"RecurseLevels";
extern const WCHAR  c_szPropCrawlFlags[] = L"RecurseFlags";
extern const WCHAR  c_szPropCrawlMaxSize[] = L"MaxSizeKB";
extern const WCHAR  c_szPropCrawlChangesOnly[] = L"CheckChangesOnly";
extern const WCHAR  c_szPropChangeCode[] = L"ChangeCode";
extern const WCHAR  c_szPropCrawlUsername[] = L"Username";
extern const WCHAR  c_szPropEmailNotf[] = L"EmailNotification";
extern const WCHAR  c_szPropCrawlLocalDest[] = L"LocalDest";
extern const WCHAR  c_szPropCrawlGroupID[] = L"GroupID";
extern const WCHAR  c_szPropCrawlNewGroupID[] = L"NewGroupID";
extern const WCHAR  c_szPropActualProgressMax[] = L"ActualProgressMax";
extern const WCHAR  c_szPropCrawlActualSize[] = L"ActualSizeKB";
extern const WCHAR  c_szPropEnableShortcutGleam[] = L"EnableShortcutGleam";
extern const WCHAR  c_szPropChannelFlags[] = L"ChannelFlags";
extern const WCHAR  c_szPropChannel[] = L"Channel";
extern const WCHAR  c_szPropDesktopComponent[] = L"DesktopComponent";
extern const WCHAR  c_szPropStatusCode[] = L"StatusCode";
extern const WCHAR  c_szPropStatusString[] = L"StatusString";
extern const WCHAR  c_szPropCompletionTime[] = L"CompletionTime";
extern const WCHAR  c_szPropPassword[] = L"Password";
// End Report
extern const WCHAR  c_szPropEmailURL[] = L"EmailURL";
extern const WCHAR  c_szPropEmailFlags[] = L"EmailFlags";
extern const WCHAR  c_szPropEmailTitle[] = L"EmailTitle";
extern const WCHAR  c_szPropEmailAbstract[] = L"EmailAbstract";
extern const WCHAR  c_szPropCharSet[] = L"CharSet";

// Tray Agent Properties
extern const WCHAR  c_szPropGuidsArr[] = L"Guids Array";

// Tracking Properties
extern const WCHAR  c_szTrackingCookie[] = L"LogGroupID";
extern const WCHAR  c_szTrackingPostURL[] = L"PostURL";
extern const WCHAR  c_szPostingRetry[] = L"PostFailureRetry";
extern const WCHAR  c_szPostHeader[] = L"PostHeader";
extern const WCHAR  c_szPostPurgeTime[] = L"PostPurgeTime";

// Delivery Agent Properties
extern const WCHAR  c_szStartCookie[] = L"StartCookie";

// Initial cookie in AGENT_INIT
extern const WCHAR  c_szInitCookie[] = L"InitCookie";

STDAPI OfflineFolderRegisterServer();
STDAPI OfflineFolderUnregisterServer();

// Count number of objects and number of locks.
ULONG       g_cObj=0;
ULONG       g_cLock=0;

// DLL Instance handle
HINSTANCE   g_hInst=0;

// other globals
BOOL        g_fIsWinNT;    // Are we on WinNT? Always initialized.
BOOL        g_fIsWinNT5;   // Is it NT5?
BOOL        g_fIsMillennium = FALSE;

// logging globals
BOOL        g_fCheckedForLog = FALSE;       // have we checked registry?
TCHAR *     g_pszLoggingFile = NULL;        // file to write log to

TCHAR szInternetSettings[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings");
TCHAR szProxyEnable[] = TEXT("ProxyEnable");
const TCHAR c_szRegKey[] = WEBCHECK_REGKEY;
const TCHAR c_szRegKeyUsernames[] = WEBCHECK_REGKEY TEXT("\\UserFormFieldNames");
const TCHAR c_szRegKeyPasswords[] = WEBCHECK_REGKEY TEXT("\\PasswordFormFieldNames");
const TCHAR c_szRegKeyStore[] = WEBCHECK_REGKEY_STORE;

// Pstore related variables.
static PST_PROVIDERID s_provID = GUID_NULL;

// {14D96C20-255B-11d1-898F-00C04FB6BFC4}
static const GUID GUID_PStoreType = { 0x14d96c20, 0x255b, 0x11d1, { 0x89, 0x8f, 0x0, 0xc0, 0x4f, 0xb6, 0xbf, 0xc4 } };

static PST_KEY s_Key = PST_KEY_CURRENT_USER;
static WCHAR c_szInfoDel[] = L"InfoDelivery";
static WCHAR c_szSubscriptions[] = L"Subscriptions";

//////////////////////////////////////////////////////////////////////////
//
// DLL entry point
//
//////////////////////////////////////////////////////////////////////////
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{

    switch (ulReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            SHFusionInitializeFromModule((HMODULE)hInstance);
            OSVERSIONINFOA vi;

            DisableThreadLibraryCalls(hInstance);
            g_hInst = hInstance;

            MLLoadResources(g_hInst, TEXT("webchklc.dll"));

            vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            GetVersionExA(&vi);
            if(vi.dwPlatformId == VER_PLATFORM_WIN32_NT) {
                g_fIsWinNT = TRUE;
                if(vi.dwMajorVersion > 4)
                    g_fIsWinNT5 = TRUE;
                else
                    g_fIsWinNT5 = FALSE;
            } else {
                g_fIsWinNT = FALSE;
                g_fIsWinNT5 = FALSE;

                g_fIsMillennium = IsOS(OS_MILLENNIUM);
            }

#ifdef DEBUG
            g_qwTraceFlags = TF_NEVER;    // Default if not overridden from INI
            CcshellGetDebugFlags();
#endif
        }
        break;

        case DLL_PROCESS_DETACH:
        {
            MLFreeResources(g_hInst);
            SHFusionUninitialize();
        }
        break;
    }


    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
// Standard OLE entry points
//
//////////////////////////////////////////////////////////////////////////

//  Class factory -
//  For classes with no special needs these macros should take care of it.
//  If your class needs some special stuff just to get the ball rolling,
//  implement your own CreateInstance method.  (ala, CConnectionAgent)

#define DEFINE_CREATEINSTANCE(cls, iface) \
HRESULT cls##_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk) \
{ \
    ASSERT(NULL == punkOuter); \
    ASSERT(NULL != ppunk); \
    *ppunk = (iface *)new cls; \
    return (NULL != *ppunk) ? S_OK : E_OUTOFMEMORY; \
}

#define DEFINE_AGGREGATED_CREATEINSTANCE(cls, iface) \
HRESULT cls##_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk) \
{ \
    ASSERT(NULL != punkOuter); \
    ASSERT(NULL != ppunk); \
    *ppunk = (iface *)new cls(punkOuter); \
    return (NULL != *ppunk) ? S_OK : E_OUTOFMEMORY; \
}

DEFINE_CREATEINSTANCE(CWebCheck, IOleCommandTarget)
DEFINE_CREATEINSTANCE(CWebCrawler, ISubscriptionAgentControl)
DEFINE_CREATEINSTANCE(CChannelAgent, ISubscriptionAgentControl)
DEFINE_CREATEINSTANCE(COfflineFolder, IShellFolder)
// extern HRESULT CConnectionAgent_CreateInstance(LPUNKNOWN pUnkOuter, IUnknown **ppunk);
DEFINE_CREATEINSTANCE(CSubscriptionMgr, ISubscriptionMgr2);
DEFINE_CREATEINSTANCE(CWCPostAgent, ISubscriptionAgentControl)
DEFINE_CREATEINSTANCE(CCDLAgent, ISubscriptionAgentControl)
DEFINE_CREATEINSTANCE(COfflineSync, ISyncMgrSynchronize)

const CFactoryData g_FactoryData[] = 
{
 {   &CLSID_WebCheck,             CWebCheck_CreateInstance,           0 }
,{   &CLSID_WebCrawlerAgent,      CWebCrawler_CreateInstance,         0 }
,{   &CLSID_ChannelAgent,         CChannelAgent_CreateInstance,       0 }
,{   &CLSID_OfflineFolder,        COfflineFolder_CreateInstance,      0 }
// ,{   &CLSID_ConnectionAgent,      CConnectionAgent_CreateInstance,    0 }
,{   &CLSID_SubscriptionMgr,      CSubscriptionMgr_CreateInstance,    0 }
,{   &CLSID_PostAgent,            CWCPostAgent_CreateInstance,        0 }
,{   &CLSID_CDLAgent,             CCDLAgent_CreateInstance,           0 }
,{   &CLSID_WebCheckOfflineSync,  COfflineSync_CreateInstance,        0 }
};

HRESULT APIENTRY DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;
    IUnknown *punk = NULL;

    *ppv = NULL;
    
    // Validate request
    for (int i = 0; i < ARRAYSIZE(g_FactoryData); i++)
    {
        if (rclsid == *g_FactoryData[i].m_pClsid)
        {
            punk = new CClassFactory(&g_FactoryData[i]);
            break;
        }
    }

    if (ARRAYSIZE(g_FactoryData) <= i)
    {
        ASSERT(NULL == punk);
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }
    else if (NULL == punk)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = punk->QueryInterface(riid, ppv);
        punk->Release();
    } 

    ASSERT((SUCCEEDED(hr) && (NULL != *ppv)) ||
           (FAILED(hr) && (NULL == *ppv)));

    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    // check objects and locks
    return (0L == DllGetRef() && 0L == DllGetLock()) ? S_OK : S_FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
// helper functions
//
//////////////////////////////////////////////////////////////////////////
int MyOleStrToStrN(LPTSTR psz, int cchMultiByte, LPCOLESTR pwsz)
{
    int i;
#ifdef UNICODE
    StrCpyN(psz, pwsz, cchMultiByte);
    i = cchMultiByte;
#else
    i=WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz,
                    cchMultiByte, NULL, NULL);

    if (!i)
    {
        DBG_WARN("MyOleStrToStrN string too long; truncated");
        psz[cchMultiByte - 1]=0;
    }
#ifdef DEBUG
    else
        ZeroMemory(psz+i, sizeof(TCHAR)*(cchMultiByte-i));
#endif
#endif

    return i;
}

int MyStrToOleStrN(LPOLESTR pwsz, int cchWideChar, LPCTSTR psz)
{
    int i;

#ifdef UNICODE
    StrCpyN(pwsz, psz, cchWideChar);
    i = cchWideChar;
#else
    i=MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cchWideChar);
    if (!i)
    {
        DBG_WARN("MyStrToOleStrN string too long; truncated");
        pwsz[cchWideChar-1]=0;
    }
#ifdef DEBUG
    else
        ZeroMemory(pwsz+i, sizeof(OLECHAR)*(cchWideChar-i));
#endif
#endif
    return i;
}

// Convert upper to lower for ASCII wide characters
inline WCHAR MyToLower(WCHAR wch)
{
    return (wch >= 'A' && wch <= 'Z') ? (wch - 'A'+ 'a') : wch;
}

// Optimized for the knowledge that urls are 7-bit characters.
int MyAsciiCmpNIW(LPCWSTR pwsz1, LPCWSTR pwsz2, int iLen)
{
    while (iLen-- && *pwsz1 && *pwsz2)
    {
        ASSERT(*pwsz1 || *pwsz2);

        if (MyToLower(*pwsz1++) != MyToLower(*pwsz2++))
            return 1;
    }

    return 0;
}

int MyAsciiCmpW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    while (*pwsz1)
    {
        if (*pwsz1++ != *pwsz2++)
        {
            return 1;
        }
    }

    if (*pwsz2)
        return 1;

    return 0;
}


#ifdef DEBUG
void DumpIID(LPCSTR psz, REFIID riid)
{
    // Convert the GUID to an ANSI string
    TCHAR pszGUID[GUIDSTR_MAX];
    WCHAR pwszGUID[GUIDSTR_MAX];
    int len = StringFromGUID2(riid, pwszGUID, ARRAYSIZE(pwszGUID));
    ASSERT(GUIDSTR_MAX == len);
    ASSERT(0 == pwszGUID[GUIDSTR_MAX - 1]);
    len = MyOleStrToStrN(pszGUID, GUIDSTR_MAX, pwszGUID);
    ASSERT(GUIDSTR_MAX == len);
    ASSERT(0 == pszGUID[GUIDSTR_MAX - 1]);

    // See if the IID has a string in the registry
    TCHAR pszKey[MAX_PATH];
    TCHAR pszIIDName[MAX_PATH];
    wnsprintf(pszKey, ARRAYSIZE(pszKey), TEXT("Interface\\%s"), pszGUID);
    BOOL fRet;
    fRet = ReadRegValue(HKEY_CLASSES_ROOT, pszKey, NULL, pszIIDName, sizeof(pszIIDName));

    // Print all the strings
    if (fRet)
        TraceMsg(TF_THISMODULE, "%s - %s %s", psz, pszIIDName, pszGUID);
    else
        TraceMsg(TF_THISMODULE, "%s - %s", psz, pszGUID);
}
#endif // DEBUG

//////////////////////////////////////////////////////////////////////////
//
// Autoregistration entry points
//
//////////////////////////////////////////////////////////////////////////

HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (pfnri)
        {
            hr = pfnri(g_hInst, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

STDAPI DllRegisterServer(void)
{
    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
//  CallRegInstall("UnReg");
    CallRegInstall("Reg");
    if (hinstAdvPack)
    {
        FreeLibrary(hinstAdvPack);
    }

    // OfflineFolder registers.
    OfflineFolderRegisterServer();

    // do external setup stuff on non-NT5 platforms
    if(FALSE == g_fIsWinNT5)
    {
        // register LCE
        HINSTANCE hLCE = LoadLibrary(TEXT("estier2.dll"));
        if (hLCE)
        {
            LCEREGISTER regfunc;
            regfunc = (LCEREGISTER)GetProcAddress(hLCE, "LCERegisterServer");
            if (regfunc)
                if (FAILED(regfunc(NULL)))
                    DBG_WARN("LCE register server failed!");

            FreeLibrary(hLCE);
        }

        // create reg key that SENS needs
        DWORD dwValue = 0;
        WriteRegValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Mobile\\Sens"),
                      TEXT("Configured"), &dwValue, sizeof(DWORD), REG_DWORD);

        // if we're on NT4, call SENS configuration api
        if (g_fIsWinNT)
        {
            HINSTANCE hSENS = LoadLibrary(TEXT("senscfg.dll"));

            if(hSENS)
            {
                SENSREGISTER regfunc;
                regfunc = (SENSREGISTER)GetProcAddress(hSENS, "SensRegister");
                if(regfunc)
                    if (FAILED(regfunc()))
                        DBG_WARN("SENS register server failed!");

                FreeLibrary(hSENS);
            }
        }
    }

    return NOERROR;
}

STDAPI
DllUnregisterServer(void)
{
    HRESULT hr;

    hr = OfflineFolderUnregisterServer();
    hr = CallRegInstall("UnReg");

    // do external unregister stuff on non-NT5 platforms
    if(FALSE == g_fIsWinNT5) {

        // unregister SENS on NT4
        if(g_fIsWinNT){
            HINSTANCE hSENS = LoadLibrary(TEXT("senscfg.dll"));
            if(hSENS) {
                SENSREGISTER regfunc;
                regfunc = (SENSREGISTER)GetProcAddress(hSENS, "SensUnregister");
                if(regfunc)
                    regfunc();
                FreeLibrary(hSENS);
            }
        }

        // unregister LCE
        HINSTANCE hLCE = LoadLibrary(TEXT("estier2.dll"));
        if(hLCE) {
            LCEUNREGISTER unregfunc;
            unregfunc = (LCEUNREGISTER)GetProcAddress(hLCE, "LCEUnregisterServer");
            if(unregfunc)
                unregfunc(NULL);
            FreeLibrary(hLCE);
        }

        // Remove Sens key
        SHDeleteKey( HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Mobile\\Sens") );
    }

    return hr;
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;
    typedef enum { InstallNone, InstallPolicies, InstallPerUser } InstallType;
    
    InstallType installType = InstallNone;
    
    if (pszCmdLine && *pszCmdLine)
    {
        //
        // Setup will call DllInstall by running 'regsvr32 /n /i:Policy webcheck.dll'.
        // This tells webcheck to process the Infodelivery Admin Policies.
        //
        if (0 == StrCmpIW(pszCmdLine, TEXTW("policy")))
        {
            installType = InstallPolicies;
        }
        else if (0 == StrCmpIW(pszCmdLine, TEXTW("U")))
        {
            installType = InstallPerUser;
        }
    }

    if (bInstall && (installType != InstallNone))
    {
        hr = CoInitialize(NULL);

        if (SUCCEEDED(hr))
        {
            switch (installType)
            {
                case InstallPolicies:
                    hr = ProcessInfodeliveryPolicies();
                    break;

                case InstallPerUser:
                    hr = ConvertIE4Subscriptions();
                    DBGASSERT(SUCCEEDED(hr), "webcheck DllInstall - Failed to convert notification manager subscriptions");
                    break;
            }
        }

        CoUninitialize();
    }

    return SUCCEEDED(hr) ? S_OK : hr;    
}    


//////////////////////////////////////////////////////////////////////////
//
// Helper functions for Subscription Store
//
//////////////////////////////////////////////////////////////////////////
// Can return S_OK with NULL bstr
HRESULT ReadBSTR(ISubscriptionItem *pItem, LPCWSTR szName, BSTR *bstrRet)
{
    ASSERT(pItem && bstrRet);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) &&
            (Val.vt==VT_BSTR))
    {
        *bstrRet = Val.bstrVal;
        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        *bstrRet = NULL;
        return E_INVALIDARG;
    }
}

// Cannot return S_OK with emptry string
HRESULT ReadOLESTR(ISubscriptionItem *pItem, LPCWSTR szName, LPWSTR *ppszRet)
{
    HRESULT hr;
    BSTR bstrRet = NULL;
    *ppszRet = NULL;
    hr = ReadBSTR(pItem, szName, &bstrRet);
    if (SUCCEEDED(hr) && bstrRet && bstrRet[0])
    {
        int len = (lstrlenW(bstrRet) + 1) * sizeof(WCHAR);
        *ppszRet = (LPWSTR) CoTaskMemAlloc(len);
        if (*ppszRet)
        {
            CopyMemory(*ppszRet, bstrRet, len);
        }
    }
    
    SAFEFREEBSTR(bstrRet);
    if (*ppszRet)
        return S_OK;
    else
        return E_FAIL;
}

HRESULT ReadAnsiSTR(ISubscriptionItem *pItem, LPCWSTR szName, LPSTR *ppszRet)
{
    HRESULT hr;
    BSTR bstrRet = NULL;
    *ppszRet = NULL;
    hr = ReadBSTR(pItem, szName, &bstrRet);
    if (SUCCEEDED(hr) && bstrRet && bstrRet[0])
    {
        // Don't forget to allocate a long string for DBCS.
        int len = (lstrlenW(bstrRet) + 1) * sizeof(CHAR) * 2;
        *ppszRet = (LPSTR) MemAlloc(LMEM_FIXED, len);
        if (*ppszRet)
        {
            SHUnicodeToAnsi(bstrRet, *ppszRet, len);
        }
    }
    
    SAFEFREEBSTR(bstrRet);
    if (*ppszRet)
        return S_OK;
    else
        return E_FAIL;
}

HRESULT ReadBool(ISubscriptionItem *pItem, LPCWSTR szName, VARIANT_BOOL *pBoolRet)
{
    ASSERT(pItem && pBoolRet);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    // accept VT_I4 or VT_BOOL
    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) &&
            (Val.vt==VT_BOOL || Val.vt==VT_I4))
    {
        if (Val.vt==VT_I4)
        {
            if (Val.lVal)
                *pBoolRet = VARIANT_TRUE;
            else
                *pBoolRet = VARIANT_FALSE;
        }
        else
            *pBoolRet = Val.boolVal;
        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        return E_INVALIDARG;
    }
}

HRESULT ReadSCODE(ISubscriptionItem *pItem, LPCWSTR szName, SCODE *pscRet)
{
    ASSERT(pItem && pscRet);

    VARIANT Val;

    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) && Val.vt == VT_ERROR)
    {
        *pscRet = Val.scode;
        return S_OK;
    }
    else
    {
        VariantClear(&Val);
        return E_INVALIDARG;
    }
}

HRESULT WriteEMPTY(ISubscriptionItem *pItem, LPCWSTR szName)
{
    ASSERT(pItem);

    VARIANT Val;

    Val.vt = VT_EMPTY;
    return pItem->WriteProperties(1, &szName, &Val);
}

HRESULT WriteSCODE(ISubscriptionItem *pItem, LPCWSTR szName, SCODE scVal)
{
    ASSERT(pItem);

    VARIANT Val;

    Val.vt = VT_ERROR;
    Val.scode = scVal;

    return pItem->WriteProperties(1, &szName, &Val);
}
    
HRESULT ReadDWORD(ISubscriptionItem *pItem, LPCWSTR szName, DWORD *pdwRet)
{
    ASSERT(pItem && pdwRet);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) &&
            (Val.vt==VT_I4 || Val.vt==VT_I2))
    {
        if (Val.vt==VT_I4)
            *pdwRet = (DWORD) Val.lVal;
        else
            *pdwRet = (DWORD) Val.iVal;

        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        return E_INVALIDARG;
    }
}

HRESULT ReadLONGLONG(ISubscriptionItem *pItem, LPCWSTR szName, LONGLONG *pllRet)
{
    ASSERT(pItem && pllRet);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) &&
            (Val.vt==VT_CY))
    {
        *pllRet = *((LONGLONG *) &(Val.cyVal));

        return S_OK;
    }
    else
    {
        *pllRet = 0;
        VariantClear(&Val); // free any return value of wrong type
        return E_INVALIDARG;
    }
}
    
HRESULT ReadGUID(ISubscriptionItem *pItem, LPCWSTR szName, GUID *pGuid)
{
    ASSERT(pItem && pGuid);

    BSTR    bstrGUID = NULL;
    HRESULT hr = E_INVALIDARG;
    
    if (SUCCEEDED(ReadBSTR(pItem, szName, &bstrGUID)) &&
        SUCCEEDED(CLSIDFromString(bstrGUID, pGuid)))
    {
        hr = NOERROR;
    }
    SAFEFREEBSTR(bstrGUID);

    return hr;
}

HRESULT WriteGUID(ISubscriptionItem *pItem, LPCWSTR szName, GUID *pGuid)
{
    ASSERT(pItem && pGuid);
    
    WCHAR   wszCookie[GUIDSTR_MAX];

#ifdef DEBUG
    int len = 
#endif
    StringFromGUID2(*pGuid, wszCookie, ARRAYSIZE(wszCookie));
    ASSERT(GUIDSTR_MAX == len);
    return WriteOLESTR(pItem, szName, wszCookie);
}

HRESULT WriteLONGLONG(ISubscriptionItem *pItem, LPCWSTR szName, LONGLONG llVal)
{
    VARIANT Val;

    Val.vt = VT_CY;
    Val.cyVal = *((CY *) &llVal);

    return pItem->WriteProperties(1, &szName, &Val);
}

HRESULT WriteDWORD(ISubscriptionItem *pItem, LPCWSTR szName, DWORD dwVal)
{
    VARIANT Val;

    Val.vt = VT_I4;
    Val.lVal = dwVal;

    return pItem->WriteProperties(1, &szName, &Val);
}

HRESULT ReadDATE(ISubscriptionItem *pItem, LPCWSTR szName, DATE *dtVal)
{
    ASSERT(pItem && dtVal);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) && (Val.vt==VT_DATE))
    {
        *dtVal = Val.date;
        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        return E_INVALIDARG;
    }
}

HRESULT WriteDATE(ISubscriptionItem *pItem, LPCWSTR szName, DATE *dtVal)
{
    VARIANT Val;

    Val.vt = VT_DATE;
    Val.date= *dtVal;

    return pItem->WriteProperties(1, &szName, &Val);
}

HRESULT ReadVariant     (ISubscriptionItem *pItem, LPCWSTR szName, VARIANT *pvarRet)
{
    ASSERT(pvarRet->vt == VT_EMPTY);
    return pItem->ReadProperties(1, &szName, pvarRet);
}

HRESULT WriteVariant    (ISubscriptionItem *pItem, LPCWSTR szName, VARIANT *pvarVal)
{
    return pItem->WriteProperties(1, &szName, pvarVal);
}

HRESULT WriteOLESTR(ISubscriptionItem *pItem, LPCWSTR szName, LPCWSTR szVal)
{
    VARIANT Val;

    Val.vt = VT_BSTR;
    Val.bstrVal = SysAllocString(szVal);

    HRESULT hr = pItem->WriteProperties(1, &szName, &Val);

    SysFreeString(Val.bstrVal);

    return hr;
}

HRESULT WriteAnsiSTR(ISubscriptionItem *pItem, LPCWSTR szName, LPCSTR szVal)
{
    VARIANT Val;
    BSTR    bstrVal;
    HRESULT hr;

    bstrVal = SysAllocStringByteLen(szVal, lstrlenA(szVal));
    if (bstrVal)
    {
        Val.vt = VT_BSTR;
        Val.bstrVal = bstrVal;

        hr = pItem->WriteProperties(1, &szName, &Val);

        SysFreeString(bstrVal);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT WriteResSTR(ISubscriptionItem *pItem, LPCWSTR szName, UINT uID)
{
    TCHAR szString[MAX_RES_STRING_LEN];

    if (MLLoadString(uID, szString, ARRAYSIZE(szString)))
    {
        return WriteTSTR(pItem, szName, szString);
    }

    return E_INVALIDARG;
}


DWORD LogEvent(LPTSTR pszFormat, ...)
{

    // check registry if necessary
    if(FALSE == g_fCheckedForLog) {

        TCHAR   pszFilePath[MAX_PATH];

        if(ReadRegValue(HKEY_CURRENT_USER, c_szRegKey, TEXT("LoggingFile"),
                pszFilePath, sizeof(pszFilePath))) {

            g_pszLoggingFile = new TCHAR[lstrlen(pszFilePath) + 1];
            if(g_pszLoggingFile) {
                StrCpy(g_pszLoggingFile, pszFilePath);
            }
        }

        g_fCheckedForLog = TRUE;
    }

    if(g_pszLoggingFile) {

        TCHAR       pszString[MAX_PATH+INTERNET_MAX_URL_LENGTH];
        SYSTEMTIME  st;
        HANDLE      hLog;
        DWORD       dwWritten;
        va_list     va;

        hLog = CreateFile(g_pszLoggingFile, GENERIC_WRITE, 0, NULL,
                OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if(INVALID_HANDLE_VALUE == hLog)
            return GetLastError();

        // seek to end of file
        SetFilePointer(hLog, 0, 0, FILE_END);

        // dump time
        GetLocalTime(&st);
        wnsprintf(pszString, ARRAYSIZE(pszString), TEXT("\r\n%02d:%02d:%02d - "), st.wHour, st.wMinute, st.wSecond);
        WriteFile(hLog, pszString, lstrlen(pszString), &dwWritten, NULL);

        // dump passed in string
        va_start(va, pszFormat);
        wvnsprintf(pszString, ARRAYSIZE(pszString), pszFormat, va);
        va_end(va);
        WriteFile(hLog, pszString, lstrlen(pszString), &dwWritten, NULL);

        // clean up
        CloseHandle(hLog);
    }

    return 0;
}

// Functions related to saving and restoring user passwords from the pstore.


// We have wrappers around Create and Release to allow for future caching of the pstore
// instance within webcheck. 

STDAPI CreatePStore(IPStore **ppIPStore)
{
    HRESULT hr;

    hr = PStoreCreateInstance ( ppIPStore,
                                IsEqualGUID(s_provID, GUID_NULL) ? NULL : &s_provID,
                                NULL,
                                0);
    return hr;
}


STDAPI ReleasePStore(IPStore *pIPStore)
{
    HRESULT hr;

    if (pIPStore)
    {
        pIPStore->Release();
        hr = S_OK;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

// Given a field name this figures out the type and sub-type in the pstore
// that should be queried. Currently these are hard-coded.
STDAPI GetPStoreTypes(LPCWSTR /* wszField */, GUID * pguidType, GUID * pguidSubType)
{
    *pguidType = GUID_PStoreType;
    *pguidSubType = GUID_NULL;

    return S_OK;
}


STDAPI  ReadNotificationPassword(LPCWSTR wszUrl, BSTR *pbstrPassword)
{
    GUID             itemType = GUID_NULL;
    GUID             itemSubtype = GUID_NULL;
    PST_PROMPTINFO   promptInfo = {0};
    IPStore*         pStore = NULL;
    HRESULT          hr ;
     
    if (wszUrl == NULL || pbstrPassword == NULL)
        return E_POINTER;

    // Will return NULL if there is no password entry or we 
    // fail for some reason. 
    *pbstrPassword = NULL;

    promptInfo.cbSize = sizeof(promptInfo);
    promptInfo.szPrompt = NULL;
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp = NULL;
    
    hr = CreatePStore(&pStore);    

    if (SUCCEEDED(hr))
    {
        ASSERT(pStore != NULL);
        hr = GetPStoreTypes(wszUrl, &itemType, &itemSubtype);

        if (SUCCEEDED(hr))
        {
            DWORD   cbData;
            BYTE *  pbData = NULL;

            hr = pStore->ReadItem(
                            s_Key,
                            &itemType,
                            &itemSubtype,
                            wszUrl,
                            &cbData,
                            &pbData,
                            &promptInfo,
                            0);

            if (SUCCEEDED(hr))
            {
                *pbstrPassword = SysAllocString((OLECHAR *)pbData);
                CoTaskMemFree(pbData);
                hr = S_OK;
            }
        }

        ReleasePStore(pStore);
    }

    return hr;
}

STDAPI WriteNotificationPassword(LPCWSTR wszUrl, BSTR bstrPassword)
{
    HRESULT         hr;
    PST_TYPEINFO    typeInfo;
    PST_PROMPTINFO  promptInfo;
    IPStore *       pStore;

    if (wszUrl == NULL)
        return E_POINTER;

    typeInfo.cbSize = sizeof(typeInfo);


    typeInfo.szDisplayName = c_szInfoDel;

    promptInfo.cbSize = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp = NULL;
    promptInfo.szPrompt = NULL;

    hr = CreatePStore(&pStore);

    if (SUCCEEDED(hr))
    {
        GUID itemType = GUID_NULL;
        GUID itemSubtype = GUID_NULL;

        ASSERT(pStore != NULL);

        hr = GetPStoreTypes(wszUrl, &itemType, &itemSubtype);
                
        if (SUCCEEDED(hr))
        {
            hr = pStore->CreateType(s_Key, &itemType, &typeInfo, 0);

            // PST_E_TYPE_EXISTS implies type already exists which is just fine
            // by us.
            if (SUCCEEDED(hr) || hr == PST_E_TYPE_EXISTS)
            {
                typeInfo.szDisplayName = c_szSubscriptions;

                hr = pStore->CreateSubtype(
                                        s_Key,
                                        &itemType,
                                        &itemSubtype,
                                        &typeInfo,
                                        NULL,
                                        0);

                if (SUCCEEDED(hr) || hr == PST_E_TYPE_EXISTS)
                {
                    if (bstrPassword != NULL)
                    {
                        hr = pStore->WriteItem(
                                            s_Key,
                                            &itemType,
                                            &itemSubtype,
                                            wszUrl,
                                            ((lstrlenW(bstrPassword)+1) * sizeof(WCHAR)),
                                            (BYTE *)bstrPassword,
                                            &promptInfo,
                                            PST_CF_NONE,
                                            0);
                    }
                    else
                    {
                        hr = pStore->DeleteItem(
                                            s_Key,
                                            &itemType,
                                            &itemSubtype,
                                            wszUrl,
                                            &promptInfo,
                                            0);
                    }
                }
            }
        }
        
        ReleasePStore(pStore);
    }
    
    return hr;
}                                                                       


HRESULT WritePassword(ISubscriptionItem *pItem, BSTR bstrPassword)
{
    BSTR    bstrURL = NULL;
    HRESULT hr = E_FAIL;

    hr = ReadBSTR(pItem, c_szPropURL, &bstrURL);
    RETURN_ON_FAILURE(hr);

    hr = WriteNotificationPassword(bstrURL, bstrPassword);
    SAFEFREEBSTR(bstrURL);
    return hr;
}

HRESULT ReadPassword(ISubscriptionItem *pItem, BSTR * pBstrPassword)
{
    BSTR    bstrURL = NULL;
    HRESULT hr = E_FAIL;

    hr = ReadBSTR(pItem, c_szPropURL, &bstrURL);
    RETURN_ON_FAILURE(hr);

    ASSERT(pBstrPassword);
    hr = ReadNotificationPassword(bstrURL, pBstrPassword);
    SAFEFREEBSTR(bstrURL);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\webcrawl.h ===
#ifndef _WEBCRAWL_H
#define _WEBCRAWL_H

#include "strlist.h"

//////////////////////////////////////////////////////////////////////////
//
// Webcrawler object
//
//////////////////////////////////////////////////////////////////////////
class CCodeBaseHold 
{
public:
    LPWSTR          szDistUnit;
    DWORD           dwVersionMS;
    DWORD           dwVersionLS;
    DWORD           dwFlags;
};

class CWebCrawler : public CDeliveryAgent,
                    public CUrlDownloadSink,
                    public CRunDeliveryAgentSink
{
protected:
    class  CDownloadNotify;

public:
    // internal flag used to run in offline mode
    enum { WEBCRAWL_PRIV_OFFLINE_MODE = 0x80000000 };
protected:
// properties
    BSTR            m_bstrBaseURL;
    DWORD           m_dwRecurseFlags;
    DWORD           m_dwRecurseLevels;
    DWORD           m_dwMaxSize;            
    LPTSTR          m_pszLocalDest;         // local destination (instead of cache)

// other data
    CWCStringList  *m_pPages;          // always valid during update.
    CWCStringList  *m_pRobotsTxt;      // array of robots.txt arrays, may be NULL
    CWCStringList  *m_pPendingLinks;   // Links from last page to be added to m_pPages
    CWCStringList  *m_pDependencyLinks;// Links from last page to be downloaded now
    CWCStringList  *m_pCodeBaseList;   // List of CodeBase URL's to Crawl
                                       // Dword is ptr to CCodeBaseHold

    CRITICAL_SECTION m_critDependencies;
    CWCStringList  *m_pDependencies;   // all dependencies downloaded
    int             m_iDependenciesProcessed;

    DWORD           m_dwPendingRecurseLevel;   // # to recurse from pending links

    DWORD           m_dwCurSize;    // currently downloaded in BYTES

    GROUPID         m_llCacheGroupID;
    GROUPID         m_llOldCacheGroupID;

    IExtractIcon*   m_pUrlIconHelper;

    int             m_iPagesStarted;    // # m_pPages started
    int             m_iRobotsStarted;   // # m_pRobotsTxt started
    int             m_iDependencyStarted;// # m_pDependencyLinks started
    int             m_iTotalStarted;    // # any toplevel url started
    int             m_iCodeBaseStarted; // # of codebases started

    BSTR            m_bstrHostName;     // host name from first url

    long            m_lMaxNumUrls;      // is -1 until we know total # pages

    int             m_iDownloadErrors;  // have we had any download failures?
    int             m_iSkippedByRobotsTxt; // how many skipped by robots.txt?

    CUrlDownload   *m_pCurDownload;     // current download
    CDownloadNotify     *m_pDownloadNotify; // to get urls downloaded on a page

    int             m_iCurDownloadStringIndex;
    CWCStringList  *m_pCurDownloadStringList;   // can be: m_pRobotsTxt, Pages, CodeBaseList

    int             m_iNumPagesDownloading; // 0 or 1

    BOOL            m_fHasInitCookie;   // One time deal, don't try again.

    // For change detection
    VARIANT         m_varChange;

    CRunDeliveryAgent *m_pRunAgent;      // host CDL/Channel agent
    BOOL            m_fCDFDownloadInProgress;

    // other flags
    enum {
        FLAG_CRAWLCHANGED = 0x80000000, // have we found a change in the crawl?
        FLAG_HEADONLY     = 0x40000000, // should we only get the HEAD data?
    };

// private member functions
    BOOL        IsRecurseFlagSet(DWORD dwFlag) { return dwFlag & m_dwRecurseFlags; }

static HRESULT CheckLink(IUnknown *punkItem, BSTR *pbstrItem, DWORD_PTR dwThis, DWORD *pdwStringData);
static HRESULT CheckFrame(IUnknown *punkItem, BSTR *pbstrItem, DWORD_PTR dwBaseUrl, DWORD *pdwStringData);
static HRESULT CheckImageOrLink(IUnknown *punkItem, BSTR *pbstrItem, DWORD_PTR dwEnumDep, DWORD *pdwStringData);

    HRESULT     MatchNames(BSTR bstrName, BOOL fPassword);
    HRESULT     FindAndSubmitForm(void);

    void        CheckOperationComplete(BOOL fOperationComplete);

    void        FreeRobotsTxt();
    void        FreeCodeBaseList();

private:
    ~CWebCrawler(void);

public:
    CWebCrawler(void);
   
    // CUrlDownloadSink
    HRESULT     OnDownloadComplete(UINT iID, int iError);
    HRESULT     OnClientPull(UINT iID, LPCWSTR pwszOldURL, LPCWSTR pwszNewURL);
    HRESULT     OnAuthenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword);
    HRESULT     OnOleCommandTargetExec(const GUID *pguidCmdGroup, DWORD nCmdID,
                                DWORD nCmdexecopt, VARIANTARG *pvarargIn, 
                                VARIANTARG *pvarargOut);
    HRESULT     GetDownloadNotify(IDownloadNotify **ppOut);

    // virtual functions overriding CDeliveryAgent
    HRESULT     AgentPause(DWORD dwFlags);
    HRESULT     AgentResume(DWORD dwFlags);
    HRESULT     AgentAbort(DWORD dwFlags);
    STDMETHODIMP GetIconLocation(UINT, LPTSTR, UINT, int *, UINT *);
    STDMETHODIMP Extract(LPCTSTR, UINT, HICON *, HICON *, UINT);

    // CRunDeliveryAgentSink
    HRESULT     OnAgentEnd(const SUBSCRIPTIONCOOKIE *, long, HRESULT, LPCWSTR, BOOL);

protected:
    // CDeliveryAgent overrides
    HRESULT     ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes);
    HRESULT     StartOperation();
    HRESULT     StartDownload();
    void        CleanUp();

    void        _CleanUp();

    // members used during download
    HRESULT     GetRealUrl(int iPageIndex, LPWSTR *ppwszThisUrl);
    HRESULT     MakePageStickyAndGetSize(LPCWSTR pwszURL, DWORD *pdwSize, BOOL *pfDiskFull);
    HRESULT     GetLinksFromPage();
    HRESULT     GetDependencyLinksFromPage(LPCWSTR pwszThisUrl, DWORD dwRecurse);
    HRESULT     ProcessDependencyLinks(CWCStringList **ppslUrls, int *piStarted);
    HRESULT     ProcessPendingLinks();
    HRESULT     ParseRobotsTxt(LPCWSTR pwszRobotsTxtURL, CWCStringList **ppslRet);
    HRESULT     GetRobotsTxtIndex(LPCWSTR pwszUrl, BOOL fAddToList, DWORD *pdwRobotsTxtIndex);
    HRESULT     ValidateWithRobotsTxt(LPCWSTR pwszUrl, int iRobotsIndex, BOOL *pfAllow);


    HRESULT     StartNextDownload();
    HRESULT     StartCDFDownload(WCHAR *pwszCDFURL, WCHAR *pwszBaseUrl);
    HRESULT     ActuallyStartDownload(CWCStringList *pslUrls, int iIndex, BOOL fReStart=FALSE);
    HRESULT     ActuallyDownloadCodeBase(CWCStringList *pslUrls, int iIndex, BOOL fReStart=FALSE);

static HRESULT  GetHostName(LPCWSTR pwszThisUrl, BSTR *pbstrHostName);

    inline HRESULT GetChannelItem(ISubscriptionItem **ppChannelItem);

public:
    // Callbacks from CDownloadNotify (free threaded)
    HRESULT DownloadStart(LPCWSTR pchUrl, DWORD dwDownloadId, DWORD dwType, DWORD dwReserved);
    HRESULT DownloadComplete(DWORD dwDownloadId, HRESULT hrNotify, DWORD dwReserved);

protected:
    class CDownloadNotify : public IDownloadNotify
    {
    public:
        CDownloadNotify(CWebCrawler *pParent);
        ~CDownloadNotify();

        void LeaveMeAlone();

    protected:
        long             m_cRef;
        CWebCrawler     *m_pParent; // we keep a reference
        CRITICAL_SECTION m_critParent;

    public:
        // IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, void **ppunk);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IDownloadNotify
        STDMETHODIMP         DownloadStart(LPCWSTR pchUrl, DWORD dwDownloadId, DWORD dwType, DWORD dwReserved);
        STDMETHODIMP         DownloadComplete(DWORD dwDownloadId, HRESULT hrNotify, DWORD dwReserved);
    };
};

//////////////////////////////////////////////////////////////////////////
//
//  CHelperOM
//
// Helps with MSHTML object model
//////////////////////////////////////////////////////////////////////////

class CHelperOM
{
    IHTMLDocument2  *m_pDoc;

public:
    typedef enum {
        CTYPE_LINKS,    // Get all links (<a href>) on a page
        CTYPE_MAPS,     // Get all maps on page
        CTYPE_MAP,      // Get all links within a map
        CTYPE_META,     // Get meta tags (name\ncontent)
        CTYPE_FRAMES,   // Get all frame urls on a page
    } CollectionType;

    typedef HRESULT (*PFNHELPERCALLBACK)(IUnknown *punkItem, /*inout*/BSTR *pbstrURL, DWORD_PTR dwCBData, DWORD *pdwStringData);
    typedef PFNHELPERCALLBACK PFN_CB;

public:
    CHelperOM(IHTMLDocument2 *pDoc);
    ~CHelperOM();

    static HRESULT GetTagCollection(
                        IHTMLDocument2          *pDoc,
                        LPCWSTR                  wszTagName,
                        IHTMLElementCollection **ppCollection);

//  static HRESULT WinFromDoc(IHTMLDocument2 *pDoc, IHTMLWindow2 **ppWin);

    static HRESULT GetCollection (IHTMLDocument2 *pDoc, CWCStringList *psl, CollectionType Type, PFN_CB pfnCB, DWORD_PTR dwData);
    static HRESULT EnumCollection(IHTMLElementCollection *pCollection,
                                  CWCStringList *pStringList, CollectionType Type, PFN_CB pfnCB, DWORD_PTR dwData);

    HRESULT GetTagCollection(LPCWSTR wszTagName, IHTMLElementCollection **ppCollection)
    { return GetTagCollection(m_pDoc, wszTagName, ppCollection); }
    HRESULT	GetCollection(CWCStringList *psl, CollectionType Type, PFN_CB pfnCB, DWORD_PTR dwData)
    { return GetCollection(m_pDoc, psl, Type, pfnCB, dwData); }

protected:
    static HRESULT _GetCollection(IHTMLDocument2 *pDoc, CWCStringList *psl, CollectionType Type, PFN_CB pfnCB, DWORD_PTR dwData);
};

#endif _WEBCRAWL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\dialtest\dialtest.cpp ===
#include <windows.h>
#include <stdio.h>
#include "msnotify.h"
#include "webcheck.h"

GUID CLSID_ConnectionAgent = { 0xE6CC6978,0x6B6E,0x11D0,0xBE,0xCA,0x00,0xC0,0x4F,0xD9,0x40,0xBE };

int iState = 1;


class CDialTest : public INotificationSink
{
public:
    CDialTest();
    ~CDialTest();

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // INotificationSink members
    STDMETHODIMP         OnNotification(
                INotification          *pNotification,
                INotificationReport    *pNotificationReport,
                DWORD                   dwReserved);

    HRESULT Dial(void);
    HRESULT OnConnected(INotificationReport *);
    HRESULT OnDisconnected(void);
    HRESULT SendNotification(NOTIFICATIONTYPE type);

    long    m_cRef;
};

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//
// IUnknown members
//
STDMETHODIMP CDialTest::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_INotificationSink == riid))
    {
        *ppv=(INotificationSink*)this;
    } else {
        return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
}


STDMETHODIMP_(ULONG) CDialTest::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CDialTest::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

// 
// INotificationSink members
//
STDMETHODIMP CDialTest::OnNotification(
                INotification          *pNotification,
                INotificationReport    *pNotReport,
                DWORD                   dwReserved)
{
    // Depending on the notification type, we call our other
    //  existing members.
    NOTIFICATIONTYPE    nt;
    HRESULT     hr;

    hr = pNotification->GetNotificationInfo(&nt, NULL,NULL,NULL,0);

    if (FAILED(hr)) {
        printf("OnNotification failed to get notification type\n");
        return E_INVALIDARG;
    }

    if (IsEqualGUID(nt, NOTIFICATIONTYPE_INET_ONLINE)) {
        printf("OnNotification: INET_ONLINE\n");
        iState = 2;
    } else if (IsEqualGUID(nt, NOTIFICATIONTYPE_INET_OFFLINE)) {
        printf("OnNotification: INET_OFFLINE\n");
    } else if (IsEqualGUID(nt, NOTIFICATIONTYPE_BEGIN_REPORT)) {
        printf("OnNotification: BEGIN_REPORT\n");
    } else if (IsEqualGUID(nt, NOTIFICATIONTYPE_END_REPORT)) {
        printf("OnNotification: END_REPORT\n");
        switch(iState) {
            case 0:
                // trying to exit...
                break;
            case 1:
                // dial failed, we're done
                iState = 0;
                break;
            case 2:
                // connected successfully - now hang up
                printf("Sending hangup notification.\n");
                SendNotification(NOTIFICATIONTYPE_DISCONNECT_FROM_INTERNET);
                iState = 3;
                break;
            case 3:
                // hung up.  We're done.
                iState = 0;
                break;
            default :
                break;
            } /* switch */
    } else printf("OnNotification unknown notification type\n");

    // Avoid bogus assert
    if (SUCCEEDED(hr)) hr = S_OK;
    
    return hr;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//
// Other members
//
HRESULT CDialTest::SendNotification(NOTIFICATIONTYPE type)
{
    HRESULT             hr;
    INotificationMgr    *pNotificationMgr = NULL;
    INotification       *pNotification;

    // get notification manager
    hr = CoCreateInstance(CLSID_StdNotificationMgr, NULL, CLSCTX_INPROC_SERVER,
                            IID_INotificationMgr, (void**)&pNotificationMgr);

    if(SUCCEEDED(hr)) {
        // create a notification
        hr = pNotificationMgr->CreateNotification(
                type,
                (NOTIFICATIONFLAGS)0,
                NULL,
                &pNotification,
                0);
    }

    if(SUCCEEDED(hr)) {
        // deliver it
        hr = pNotificationMgr->DeliverNotification(
                pNotification,
                CLSID_ConnectionAgent,
                DM_NEED_COMPLETIONREPORT,
                (INotificationSink *)this,
                NULL,
                0);
        pNotification->Release();
    }

    if(pNotificationMgr)
        pNotificationMgr->Release();

    return SUCCEEDED(hr);
}

CDialTest::CDialTest()
{
    m_cRef = 0;
}

CDialTest::~CDialTest()
{
}

HRESULT CDialTest::Dial(void)
{
    printf("Sending dial notification.\n");
    return SendNotification(NOTIFICATIONTYPE_CONNECT_TO_INTERNET);
}

int __cdecl main()
{
    BOOL fDone = FALSE;
    DWORD dwRes;
    MSG msg;
    CDialTest s;

    if(FAILED(CoInitialize(NULL)))
        return TRUE;

    s.Dial();

    while(iState && GetMessage(&msg, NULL, 0, 0)) {
        if(msg.hwnd != NULL) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\dll\makefile.inc ===
..\webcheck.rc : $(SDK_LIB_PATH)\webcheck.tlb $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\wizards.cpp ===
#include "private.h"
#include "offl_cpp.h"
#include "helper.h"

#include <mluisupp.h>
#include "apithk.h"

//  REARCHITECT: (tnoonan) This whole file needs some cleanup - starting with a base dialog class.

const TCHAR  c_szStrEmpty[] = TEXT("");

const TCHAR  c_szStrBoot[] = TEXT("boot");
const TCHAR  c_szStrScrnSave[] = TEXT("scrnsave.exe");
const TCHAR  c_szStrSystemIni[] = TEXT("system.ini");
const TCHAR  c_szShowWelcome[] = TEXT("ShowWelcome");

TCHAR g_szDontAskScreenSaver[] = TEXT("DontAskAboutScreenSaver");

extern BOOL CALLBACK MailOptionDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
extern void ReadDefaultEmail(LPTSTR, UINT);
extern BOOL CALLBACK LoginOptionDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
extern void ReadDefaultEmail(LPTSTR szBuf, UINT cch);
extern void ReadDefaultSMTPServer(LPTSTR szBuf, UINT cch);

INT_PTR CALLBACK WelcomeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DownloadDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK PickScheduleDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NewScheduleWizDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LoginDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#define WIZPAGE_NOINTRO         0x0001
#define WIZPAGE_NODOWNLOAD      0x0002
#define WIZPAGE_NOLOGIN         0x0004

struct WizInfo 
{
    SUBSCRIPTIONTYPE    subType;
    POOEBuf             pOOE;
    DWORD               dwExceptFlags;
    BOOL                bShowWelcome;
    BOOL                bIsNewSchedule;
    NOTIFICATIONCOOKIE  newCookie;
};

struct WizPage
{
    int     nResourceID;
    DLGPROC dlgProc;
    DWORD   dwExceptFlags;
};

const WizPage WizPages[] =
{
    { IDD_WIZARD0, WelcomeDlgProc,          WIZPAGE_NOINTRO         },   
    { IDD_WIZARD1, DownloadDlgProc,         WIZPAGE_NODOWNLOAD      },
    { IDD_WIZARD2, PickScheduleDlgProc,     0                       },
    { IDD_WIZARD3, NewScheduleWizDlgProc,   0                       },
    { IDD_WIZARD4, LoginDlgProc,            WIZPAGE_NOLOGIN         }
};

//  Helper functions

inline BOOL IsDesktop(SUBSCRIPTIONTYPE subType)
{
    return (subType == SUBSTYPE_DESKTOPURL) || (subType == SUBSTYPE_DESKTOPCHANNEL);
}

inline BOOL IsChannel(SUBSCRIPTIONTYPE subType)
{
    return (subType == SUBSTYPE_CHANNEL) || (subType == SUBSTYPE_DESKTOPCHANNEL);
}

inline DWORD GetShowWelcomeScreen()
{
    DWORD dwShowWelcome = TRUE;
    
    ReadRegValue(HKEY_CURRENT_USER, c_szRegKey, c_szShowWelcome, &dwShowWelcome, sizeof(DWORD));

    return dwShowWelcome;
}

inline void SetShowWelcomeScreen(DWORD dwShowWelcome)
{
    WriteRegValue(HKEY_CURRENT_USER, c_szRegKey, c_szShowWelcome, &dwShowWelcome, sizeof(DWORD), REG_DWORD);
}

//
//  Explanation of logic for the back/next/finish button
//
//  Wiz0 - welcome
//  Wiz1 - download
//  Wiz2 - pick schedule
//  Wiz3 - create schedule
//  Wiz4 - login
//
// A state machine can be derived to determine the different possibilities.
// The resulting state table is as follows:
//
// Wiz0:    Always has next button
//
// Wiz1:    Show back if Wiz0 was shown
//          Always has next button
//
// Wiz2:    Show back if Wiz0 or Wiz1 was shown
//          Show next if create new schedule or show login, otherwise show finish
//
// Wiz3:    Always has back button
//          Show next if show login, otherwise show finish
//
// Wiz4:    Always has back button
//          Always has finish button
//

void SetWizButtons(HWND hDlg, INT_PTR resID, WizInfo *pwi)
{
    DWORD dwButtons;

    switch (resID)
    {
        case IDD_WIZARD0:
            dwButtons = PSWIZB_NEXT;
            break;
            
        case IDD_WIZARD1:
            dwButtons = PSWIZB_NEXT;
            if (pwi && !(pwi->dwExceptFlags & WIZPAGE_NOINTRO))
            {
                dwButtons |= PSWIZB_BACK;
            }
            break;

        case IDD_WIZARD2:
            if (pwi && ((!(pwi->dwExceptFlags & WIZPAGE_NODOWNLOAD)) ||
                       (!(pwi->dwExceptFlags & WIZPAGE_NOINTRO))))
            {
                dwButtons = PSWIZB_BACK;
            }
            else
            {
                dwButtons = 0;
            }

            dwButtons |= (pwi && (pwi->bIsNewSchedule || (!(pwi->dwExceptFlags & WIZPAGE_NOLOGIN))))
                         ? PSWIZB_NEXT : PSWIZB_FINISH;
            break;

        case IDD_WIZARD3:
            dwButtons = PSWIZB_BACK | 
                        ((pwi && (!(pwi->dwExceptFlags & WIZPAGE_NOLOGIN))) ? PSWIZB_NEXT : PSWIZB_FINISH);
            break;

        case IDD_WIZARD4:
            dwButtons = PSWIZB_BACK | PSWIZB_FINISH;
            break;

        default:
            dwButtons = 0;
            ASSERT(FALSE);
            break;
    }
    
    PropSheet_SetWizButtons(GetParent(hDlg), dwButtons);
}

HRESULT CreateAndAddPage(PROPSHEETHEADER& psh, PROPSHEETPAGE& psp, int nPageIndex, DWORD dwExceptFlags)
{
    HRESULT hr = S_OK;
    
    if (!(WizPages[nPageIndex].dwExceptFlags & dwExceptFlags))
    {
        psp.pszTemplate = MAKEINTRESOURCE(WizPages[nPageIndex].nResourceID);
        psp.pfnDlgProc = WizPages[nPageIndex].dlgProc;

        HPROPSHEETPAGE hpage = Whistler_CreatePropertySheetPageW(&psp);

        if (NULL != hpage)
        {
            psh.phpage[psh.nPages++] = hpage;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CreateWizard(HWND hwndParent, SUBSCRIPTIONTYPE subType, POOEBuf pOOE)
{
    HRESULT hr = S_OK;
    UINT i;
    HPROPSHEETPAGE hPropPage[ARRAYSIZE(WizPages)];
    PROPSHEETPAGE psp = { 0 };
    PROPSHEETHEADER psh = { 0 };
    WizInfo wi;

    ASSERT(NULL != pOOE);
    ASSERT((subType >= SUBSTYPE_URL) && (subType <= SUBSTYPE_DESKTOPCHANNEL));

    wi.subType = subType;
    wi.pOOE = pOOE;
    wi.dwExceptFlags = 0;
    wi.bShowWelcome = GetShowWelcomeScreen();
    wi.bIsNewSchedule = FALSE;

    if (FALSE == wi.bShowWelcome)
    {
        wi.dwExceptFlags |= WIZPAGE_NOINTRO;
    }

    if (IsDesktop(subType))
    {
        wi.dwExceptFlags |= WIZPAGE_NODOWNLOAD;
    }

    if ((pOOE->bChannel && (!pOOE->bNeedPassword)) || 
        SHRestricted2W(REST_NoSubscriptionPasswords, NULL, 0))
    {
        wi.dwExceptFlags |= WIZPAGE_NOLOGIN;
    }

    // initialize propsheet header.
    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_WIZARD;
    psh.hwndParent  = hwndParent;
    psh.pszCaption  = NULL;
    psh.hInstance   = MLGetHinst();
    psh.nPages      = 0;
    psh.nStartPage  = 0;
    psh.phpage      = hPropPage;

    // initialize propsheet page.
    psp.dwSize          = sizeof(PROPSHEETPAGE);
    psp.dwFlags         = PSP_DEFAULT;
    psp.hInstance       = MLGetHinst();
    psp.pszIcon         = NULL;
    psp.pszTitle        = NULL;
    psp.lParam          = (LPARAM)&wi;

    for (i = 0; (i < ARRAYSIZE(WizPages)) && (SUCCEEDED(hr)); i++)
    {
        hr = CreateAndAddPage(psh, psp, i, wi.dwExceptFlags);
    }

    if (SUCCEEDED(hr))
    {
        // invoke the property sheet
        INT_PTR nResult = PropertySheet(&psh);

        if (nResult > 0)
        {
            SetShowWelcomeScreen(wi.bShowWelcome);
            hr = S_OK;
        }
        else if (nResult == 0)
        {
            hr = E_ABORT;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        for (i = 0; i < psh.nPages; i++)
        {
            DestroyPropertySheetPage(hPropPage[i]);
        }
    }

    return hr;
}


//--------------------------------------------------------------------
// Helper functions

BOOL IsADScreenSaverActive()
{
    BOOL bEnabled = FALSE;

    for (;;)
    {
        // NOTE: This is always written as an 8.3 filename
        TCHAR szCurrScrnSavePath[MAX_PATH];
        if (GetPrivateProfileString(c_szStrBoot,
                                    c_szStrScrnSave,
                                    c_szStrEmpty, 
                                    szCurrScrnSavePath,
                                    ARRAYSIZE(szCurrScrnSavePath),
                                    c_szStrSystemIni) == 0)
        {
            break;
        }

        TraceMsg(TF_ALWAYS, "szCurrScrnSavePath = %s", szCurrScrnSavePath);

        // If scrnsave = [none], we will get a null string back!
        if (!(*szCurrScrnSavePath))
            break;
        
        TCHAR szScrnSavePath[MAX_PATH];
        MLLoadString(IDS_SCREENSAVEREXE, szScrnSavePath, 
                   ARRAYSIZE(szScrnSavePath));

        TCHAR szFullScrnSavePath[MAX_PATH];
        TCHAR szWinPath[MAX_PATH];
        
        // Find the full file name and path of the screen saver
        // GetFileAttributes returns 0xFFFFFFFF if there is an error (ie: no file!)
        if (GetWindowsDirectory(szWinPath, ARRAYSIZE(szWinPath)))
        {
            PathCombine(szFullScrnSavePath, szWinPath, szScrnSavePath);
            if (GetFileAttributes(szFullScrnSavePath) == 0xFFFFFFFF)
            {
                TCHAR szSysPath[MAX_PATH];
                if (GetSystemDirectory(szSysPath, ARRAYSIZE(szSysPath)))
                {
                    PathCombine(szFullScrnSavePath, szSysPath, szScrnSavePath);
                    if (GetFileAttributes(szFullScrnSavePath) == 0xFFFFFFFF)
                    {
                        PathCombine(szFullScrnSavePath, szWinPath, TEXT("actsaver.scr"));
                        if (GetFileAttributes(szFullScrnSavePath) == 0xFFFFFFFF)
                        {
                            PathCombine(szFullScrnSavePath, szSysPath, TEXT("actsaver.scr"));
                            if (GetFileAttributes(szFullScrnSavePath) == 0xFFFFFFFF)
                                break;
                        }
                    }
                }
                else
                    break;
            }
        }
        else
            break;
        
        // Convert to 8.3 -- for some reason this is the 
        // only format that the CPL applet recognizes...
        TCHAR szShortScrnSavePath[MAX_PATH];
        if (GetShortPathName(szFullScrnSavePath, szShortScrnSavePath, ARRAYSIZE(szShortScrnSavePath)))
        {
            TraceMsg(TF_ALWAYS, "szCurrScrnSavePath = %s", szCurrScrnSavePath);
            TraceMsg(TF_ALWAYS, "szShortScrnSavePath = %s", szShortScrnSavePath);
                
            bEnabled = (StrCmpI(PathFindFileName(szCurrScrnSavePath),
                                PathFindFileName(szShortScrnSavePath)) == 0);
        }
        break;
    }
         
    return bEnabled;
}

HRESULT MakeADScreenSaverActive()
{
    TCHAR szScrnSavePath[MAX_PATH];
    MLLoadString(IDS_SCREENSAVEREXE, szScrnSavePath, 
               ARRAYSIZE(szScrnSavePath));

    if (PathFindOnPath(szScrnSavePath, NULL))
    {
        // Convert to 8.3 -- for some reason this is the 
        // only format that the CPL applet recognizes...
        TCHAR szShortScrnSavePath[MAX_PATH];
        GetShortPathName(szScrnSavePath, szShortScrnSavePath, ARRAYSIZE(szShortScrnSavePath));

        WritePrivateProfileString(  c_szStrBoot,
                                    c_szStrScrnSave, 
                                    szShortScrnSavePath,
                                    c_szStrSystemIni);

        // Flip the screen saver ON
        SystemParametersInfo(   SPI_SETSCREENSAVEACTIVE,
                                TRUE,
                                NULL, 
                                SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

        return S_OK;
    }
    else
        return E_FAIL;
}

//--------------------------------------------------------------------
// Dialog Procs

INT_PTR CALLBACK WelcomeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet =(LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    WizInfo *pWiz = lpPropSheet ? (WizInfo *)lpPropSheet->lParam : NULL;
    NMHDR FAR *lpnm;
    BOOL result = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            result = TRUE;
            break;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:

                    ASSERT(NULL != lpPropSheet);
                    ASSERT(NULL != pWiz);
                    
                    SetWizButtons(hDlg, (INT_PTR) lpPropSheet->pszTemplate, pWiz);
                    result = TRUE;
                    break;
                    
                case PSN_KILLACTIVE:

                    if (pWiz)
                    {
                        pWiz->bShowWelcome = !IsDlgButtonChecked(hDlg, IDC_WIZ_DONT_SHOW_INTRO);
                        result = TRUE;
                    }
                    break;
            }
            break;
            
    }

    return result;
}

void EnableLevelsDeep(HWND hwndDlg, BOOL fEnable)
{

    ASSERT(hwndDlg != NULL);

    EnableWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_STATIC1), fEnable);
    EnableWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_STATIC2), fEnable);
    EnableWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_EDIT), fEnable);
    EnableWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_SPIN), fEnable);

    return;

}

//
// shows or hides the UI for specifying the number "levels deep" to recurse
//
void ShowLevelsDeep(HWND hwndDlg, BOOL fShow)
{

    INT nCmdShow = fShow ? SW_SHOW: SW_HIDE;
    ASSERT(hwndDlg != NULL);

    ShowWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_STATIC1), nCmdShow);
    ShowWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_STATIC2), nCmdShow);
    ShowWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_EDIT), nCmdShow);
    ShowWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_SPIN), nCmdShow);

    return;

}

//
// enables or disables the UI for specifying the number "levels deep" to recurse
//
INT_PTR CALLBACK DownloadDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet =(LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    WizInfo *pWiz = lpPropSheet ? (WizInfo *)lpPropSheet->lParam : NULL;
    POOEBuf  pBuf = pWiz ? pWiz->pOOE : NULL;
    NMHDR FAR *lpnm;
    BOOL result = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR szBuf[256];
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            pWiz = (WizInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
            pBuf = pWiz ? pWiz->pOOE : NULL;
            
            SetListViewToString(GetDlgItem (hDlg, IDC_NAME), pBuf->m_Name);
            SetListViewToString(GetDlgItem (hDlg, IDC_URL), pBuf->m_URL);

            MLLoadString(
                (pWiz && IsChannel(pWiz->subType)) ? IDS_WIZ_GET_LINKS_CHANNEL : IDS_WIZ_GET_LINKS_URL,
                szBuf, ARRAYSIZE(szBuf));

            SetDlgItemText(hDlg, IDC_WIZ_GET_LINKS_TEXT, szBuf);

            int checked;

            if ((pBuf->bChannel && (pBuf->fChannelFlags & CHANNEL_AGENT_PRECACHE_ALL)) ||
                (!pBuf->bChannel && ((pBuf->m_RecurseLevels) > 0)))
            {
                checked = IDC_WIZ_LINKS_YES;
            }
            else
            {
                checked = IDC_WIZ_LINKS_NO;
            }
            
            CheckRadioButton(hDlg, IDC_WIZ_LINKS_YES, IDC_WIZ_LINKS_NO, checked);

            //
            // Initialize the spin control for "levels deep" UI
            //
            HWND hwndLevelsSpin = GetDlgItem(hDlg,IDC_WIZ_LINKSDEEP_SPIN);
            SendMessage(hwndLevelsSpin, UDM_SETRANGE, 0, MAKELONG(MAX_WEBCRAWL_LEVELS, 1));
            SendMessage(hwndLevelsSpin, UDM_SETPOS, 0, pBuf->m_RecurseLevels);
            ShowLevelsDeep(hDlg,!pBuf->bChannel);
            EnableLevelsDeep(hDlg,!pBuf->bChannel && IDC_WIZ_LINKS_YES==checked);

            result = TRUE;
            break;
        }

        case WM_COMMAND:

            switch (HIWORD(wParam))
            {

            case BN_CLICKED:
                
                if (!pBuf->bChannel)
                    switch (LOWORD(wParam))
                    {

                    case IDC_WIZ_LINKS_YES:
                        EnableLevelsDeep(hDlg,TRUE);
                        break;

                    case IDC_WIZ_LINKS_NO:
                        EnableLevelsDeep(hDlg,FALSE);
                        break;

                    }
                break;

            case EN_KILLFOCUS:

                //
                // This code checks for bogus values in the "levels deep"
                // edit control and replaces them with something valid
                //
                if (LOWORD(wParam)==IDC_WIZ_LINKSDEEP_EDIT)
                {
                    BOOL fTranslated = FALSE;
                    UINT cLevels = GetDlgItemInt(hDlg,IDC_WIZ_LINKSDEEP_EDIT,&fTranslated,FALSE);

                    if (!fTranslated || cLevels < 1)
                    {
                        SetDlgItemInt(hDlg,IDC_WIZ_LINKSDEEP_EDIT,1,FALSE);
                    }
                    else if (cLevels > MAX_WEBCRAWL_LEVELS)
                    {
                        SetDlgItemInt(hDlg,IDC_WIZ_LINKSDEEP_EDIT,MAX_WEBCRAWL_LEVELS,FALSE);
                    }

                }

                break;

            }
            break;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:

                    ASSERT(NULL != lpPropSheet);
                    ASSERT(NULL != pWiz);
                    
                    SetWizButtons(hDlg, (INT_PTR) lpPropSheet->pszTemplate, pWiz);
                    result = TRUE;
                    break;

                case PSN_KILLACTIVE:

                    ASSERT(NULL != pBuf);

                    if (IsDlgButtonChecked(hDlg, IDC_WIZ_LINKS_YES))
                    {
                        if (pWiz && IsChannel(pWiz->subType))
                        {
                            pBuf->fChannelFlags |= CHANNEL_AGENT_PRECACHE_ALL;
                        }
                        else
                        {
                            DWORD dwPos = (DWORD)SendDlgItemMessage(hDlg,IDC_WIZ_LINKSDEEP_SPIN,UDM_GETPOS,0,0);

                            //
                            // Set the m_RecurseLevels field to the given by the
                            // spin control.  HIWORD(dwPos) indicated errror.
                            //
                            if (HIWORD(dwPos))
                                pBuf->m_RecurseLevels = 1;
                            else
                                pBuf->m_RecurseLevels = LOWORD(dwPos);

                            pBuf->m_RecurseFlags |= WEBCRAWL_LINKS_ELSEWHERE;
                        }
                    }
                    else
                    {
                        if (pWiz && IsChannel(pWiz->subType))
                        {
                            pBuf->fChannelFlags &= ~CHANNEL_AGENT_PRECACHE_ALL;
                            pBuf->fChannelFlags |= CHANNEL_AGENT_PRECACHE_SOME;
                        }
                        else
                        {
                            pBuf->m_RecurseLevels = 0;
                            pBuf->m_RecurseFlags &= ~WEBCRAWL_LINKS_ELSEWHERE;
                        }
                    }
                    break;

            }
            break;
            
    }

    return result;
}

void HandleScheduleButtons(HWND hDlg, LPPROPSHEETPAGE lpPropSheet, WizInfo *pWiz)
{
    ASSERT(NULL != lpPropSheet);
    ASSERT(NULL != pWiz);
    
    EnableWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST),
        IsDlgButtonChecked(hDlg, IDC_WIZ_SCHEDULE_EXISTING));

    pWiz->bIsNewSchedule = IsDlgButtonChecked(hDlg, IDC_WIZ_SCHEDULE_NEW);

    SetWizButtons(hDlg, (INT_PTR) lpPropSheet->pszTemplate, pWiz);
}

struct PICKSCHED_LIST_DATA
{
    SYNCSCHEDULECOOKIE SchedCookie;
};

struct PICKSCHED_ENUM_DATA
{
    HWND hwndSchedList;
    POOEBuf pBuf;
    SYNCSCHEDULECOOKIE defSchedule;
    SYNCSCHEDULECOOKIE customSchedule;
    int *pnDefaultSelection;
    BOOL bHasAtLeastOneSchedule:1;
    BOOL bFoundCustomSchedule:1;
};

BOOL PickSched_EnumCallback(ISyncSchedule *pSyncSchedule, 
                            SYNCSCHEDULECOOKIE *pSchedCookie,
                            LPARAM lParam)
{
    BOOL bAdded = FALSE;
    PICKSCHED_ENUM_DATA *psed = (PICKSCHED_ENUM_DATA *)lParam;
    DWORD dwSyncScheduleFlags;
    PICKSCHED_LIST_DATA *psld = NULL;

    ASSERT(NULL != pSyncSchedule);  

    if (SUCCEEDED(pSyncSchedule->GetFlags(&dwSyncScheduleFlags)))
    {
        //  This checks to make sure we only add a publisher's schedule to the
        //  list if it belongs to this item.
        if ((!(dwSyncScheduleFlags & SYNCSCHEDINFO_FLAGS_READONLY)) ||
            (*pSchedCookie == psed->customSchedule))
        {
            psld = new PICKSCHED_LIST_DATA;

            if (NULL != psld)
            {
                WCHAR wszName[MAX_PATH];
                DWORD cchName = ARRAYSIZE(wszName);

                if (SUCCEEDED(pSyncSchedule->GetScheduleName(&cchName, wszName)))
                {
                    TCHAR szName[MAX_PATH];

                    MyOleStrToStrN(szName, ARRAYSIZE(szName), wszName);

                    psed->bHasAtLeastOneSchedule = TRUE;

                    psld->SchedCookie = *pSchedCookie;

                    int index;
                    if (*pSchedCookie == psed->customSchedule)
                    {
                        index = ComboBox_InsertString(psed->hwndSchedList, 0, szName);
                        if ((index >= 0) && (psed->defSchedule == GUID_NULL))
                        {
                            //  Do this always for custom schedules if there
                            //  is no defSchedule set
                            *psed->pnDefaultSelection = index;
                            psed->bFoundCustomSchedule = TRUE;
                        }
                    }
                    else
                    {
                        index = ComboBox_AddString(psed->hwndSchedList, szName);
                    }

                    if (index >= 0)
                    {
                        bAdded = (ComboBox_SetItemData(psed->hwndSchedList, index, psld) != CB_ERR);

                        if ((psed->defSchedule == *pSchedCookie)
                            ||
                            ((-1 == *psed->pnDefaultSelection) &&
                                IsCookieOnSchedule(pSyncSchedule, &psed->pBuf->m_Cookie)))
                        {
                            *psed->pnDefaultSelection = index;
                        }
                    }
                }
            }
        }
    }

    if (!bAdded)
    {
        SAFEDELETE(psld);
    }
    
    return TRUE;

}

BOOL PickSched_FillSchedList(HWND hDlg, POOEBuf pBuf, int *pnDefaultSelection)
{
    PICKSCHED_ENUM_DATA sed;

    sed.hwndSchedList = GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST);
    sed.pBuf = pBuf;
    sed.customSchedule = GUID_NULL;
    sed.pnDefaultSelection = pnDefaultSelection;
    sed.bHasAtLeastOneSchedule = FALSE;
    sed.bFoundCustomSchedule = FALSE;
    sed.defSchedule = pBuf->groupCookie;    //  usually GUID_NULL, but if the user hits
                                            //  customize multiple times, he/she would
                                            //  expect it to be highlighted

    EnumSchedules(PickSched_EnumCallback, (LPARAM)&sed);

    if (!sed.bFoundCustomSchedule && pBuf->bChannel && 
        (sizeof(TASK_TRIGGER) == pBuf->m_Trigger.cbTriggerSize))
    {
        //  This item has a custom schedule but it isn't an existing
        //  schedule (actually, this is the normal case).  We now
        //  have to add a fake entry.
       
        PICKSCHED_LIST_DATA *psld = new PICKSCHED_LIST_DATA;

        if (NULL != psld)
        {
            TCHAR szSchedName[MAX_PATH];
            BOOL bAdded = FALSE;

            CreatePublisherScheduleName(szSchedName, ARRAYSIZE(szSchedName), 
                                        pBuf->m_Name, NULL);

            int index = ComboBox_InsertString(sed.hwndSchedList, 0, szSchedName);

            if (index >= 0)
            {
                bAdded = (ComboBox_SetItemData(sed.hwndSchedList, index, psld) != CB_ERR);
                sed.bHasAtLeastOneSchedule = TRUE;
                *pnDefaultSelection = index;
            }

            if (!bAdded)
            {
                delete psld;
            }
        }
    }

    return sed.bHasAtLeastOneSchedule;    
}

PICKSCHED_LIST_DATA *PickSchedList_GetData(HWND hwndSchedList, int index)
{
    PICKSCHED_LIST_DATA *psld = NULL;

    if (index < 0)
    {
        index = ComboBox_GetCurSel(hwndSchedList);
    }

    if (index >= 0)
    {
        psld = (PICKSCHED_LIST_DATA *)ComboBox_GetItemData(hwndSchedList, index);
        if (psld == (PICKSCHED_LIST_DATA *)CB_ERR)
        {
            psld = NULL;
        }
    }

    return psld;
}

void PickSchedList_FreeAllData(HWND hwndSchedList)
{
    int count = ComboBox_GetCount(hwndSchedList);

    for (int i = 0; i < count; i++)
    {
        PICKSCHED_LIST_DATA *psld = PickSchedList_GetData(hwndSchedList, i);
        if (NULL != psld)
        {
            delete psld;
        }
    }
}

INT_PTR CALLBACK PickScheduleDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet =(LPPROPSHEETPAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    WizInfo *pWiz = lpPropSheet ? (WizInfo *)lpPropSheet->lParam : NULL;
    POOEBuf  pBuf = pWiz ? pWiz->pOOE : NULL;
    NMHDR FAR *lpnm;
    BOOL result = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            lpPropSheet = (LPPROPSHEETPAGE)lParam;
            pWiz = (WizInfo *)lpPropSheet->lParam;

            int nDefaultSelection = -1;
            BOOL bHaveSchedules = PickSched_FillSchedList(hDlg, pWiz->pOOE, 
                                                          &nDefaultSelection);
            BOOL bNoScheduledUpdates = SHRestricted2W(REST_NoScheduledUpdates, NULL, 0);
            int defID = IDC_WIZ_SCHEDULE_NONE;

            if (!bHaveSchedules)
            {
                ShowWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_EXISTING), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST), SW_HIDE);
            }
            else if (!bNoScheduledUpdates)
            {
                if (-1 == nDefaultSelection)
                {
                    //  This item isn't on any schedule yet
                    nDefaultSelection = 0;
                }
                else
                {
                    //  This item is on at least one schedule
                    defID = IDC_WIZ_SCHEDULE_EXISTING;
                }
                
                ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST), 
                                   nDefaultSelection);
            }
            CheckRadioButton(hDlg, IDC_WIZ_SCHEDULE_NONE, IDC_WIZ_SCHEDULE_EXISTING, 
                             defID);

            ASSERT(NULL != lpPropSheet);
            ASSERT(NULL != pWiz);

            if (bNoScheduledUpdates)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_NEW), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_EXISTING), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST), FALSE);
            }
            else if (SHRestricted2(REST_NoEditingScheduleGroups, NULL, 0))
            {
                EnableWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_NEW), FALSE);
            }

            HandleScheduleButtons(hDlg, lpPropSheet, pWiz);
            result = TRUE;
            break;
        }

        case WM_DESTROY:
            PickSchedList_FreeAllData(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST));
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_WIZ_SCHEDULE_EXISTING:
                case IDC_WIZ_SCHEDULE_NEW:
                case IDC_WIZ_SCHEDULE_NONE:

                    ASSERT(NULL != lpPropSheet);
                    ASSERT(NULL != pWiz);

                    HandleScheduleButtons(hDlg, lpPropSheet, pWiz);
                    result = TRUE;
                    break;
            }
            break;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:

                    ASSERT(NULL != lpPropSheet);
                    ASSERT(NULL != pWiz);
                    
                    SetWizButtons(hDlg, (INT_PTR) lpPropSheet->pszTemplate, pWiz);
                    result = TRUE;
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZFINISH:
                    if (IsDlgButtonChecked(hDlg, IDC_WIZ_SCHEDULE_NONE) && NULL != pBuf)
                    {
                        pBuf->groupCookie = NOTFCOOKIE_SCHEDULE_GROUP_MANUAL;
                    }
                    else if (IsDlgButtonChecked(hDlg, IDC_WIZ_SCHEDULE_EXISTING))
                    {
                        PICKSCHED_LIST_DATA *psld = 
                            PickSchedList_GetData(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST), -1);

                        if (NULL != psld && NULL != pBuf)
                        {
                            pBuf->groupCookie = psld->SchedCookie;
                        }
                    }
                    result = TRUE;
                    break;
                    
            }
            break;
            
    }

    return result;
}

#ifdef NEWSCHED_AUTONAME
void NewSchedWiz_AutoName(HWND hDlg, POOEBuf pBuf)
{
    if (!(pBuf->m_dwPropSheetFlags & PSF_NO_AUTO_NAME_SCHEDULE))
    {
        pBuf->m_dwPropSheetFlags &= ~PSF_NO_CHECK_SCHED_CONFLICT;

        NewSched_AutoNameHelper(hDlg);
    }
}
#endif

BOOL NewSchedWiz_ResolveNameConflict(HWND hDlg, POOEBuf pBuf)
{
    BOOL bResult = TRUE;

    if (!(pBuf->m_dwPropSheetFlags & PSF_NO_CHECK_SCHED_CONFLICT))
    {
        bResult = NewSched_ResolveNameConflictHelper(hDlg, &pBuf->m_Trigger, 
                                                     &pBuf->groupCookie);
    }

    if (bResult)
    {
        pBuf->m_dwPropSheetFlags |= PSF_NO_CHECK_SCHED_CONFLICT;
    }

    return bResult;
}

inline void NewSchedWiz_CreateSchedule(HWND hDlg, POOEBuf pBuf)
{
    ASSERT(pBuf->m_dwPropSheetFlags & PSF_NO_CHECK_SCHED_CONFLICT);

    NewSched_CreateScheduleHelper(hDlg, &pBuf->m_Trigger,
                                  &pBuf->groupCookie);
}

INT_PTR CALLBACK NewScheduleWizDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet =(LPPROPSHEETPAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    WizInfo *pWiz = lpPropSheet ? (WizInfo *)lpPropSheet->lParam : NULL;
    POOEBuf  pBuf = pWiz ? pWiz->pOOE : NULL;
    NMHDR *lpnm;
    BOOL result = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            NewSched_OnInitDialogHelper(hDlg);

            pWiz = (WizInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
            pBuf = pWiz->pOOE;

            pBuf->hwndNewSchedDlg = hDlg;

/*
            SUBCLASS_DATA *psd = new SUBCLASS_DATA;

            if (NULL != psd)
            {
                HWND hwndEdit = GetDlgItem(hDlg, IDC_SCHEDULE_NAME);
                psd->pBuf = pBuf;
                psd->lpfnOldWndProc = (WNDPROC)GetWindowLong(hwndEdit, GWL_WNDPROC);
                if (SetProp(hwndEdit, c_szSubClassProp, (HANDLE)psd))
                {
                    SubclassWindow(hwndEdit, EditSubclassProc);
                }
                else
                {
                    delete psd;
                }
            }
*/
            result = TRUE;
            break;
        }

        case WM_COMMAND:
            if (NULL != pBuf)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_SCHEDULE_DAYS:
                        if (HIWORD(wParam) == EN_UPDATE)
                        {
                            if (LOWORD(wParam) == IDC_SCHEDULE_DAYS)
                            {
                                KeepSpinNumberInRange(hDlg, IDC_SCHEDULE_DAYS, 
                                                      IDC_SCHEDULE_DAYS_SPIN, 1, 99);

                                pBuf->m_dwPropSheetFlags &= ~PSF_NO_CHECK_SCHED_CONFLICT;

                                result = TRUE;
                            }
                        }
#ifdef NEWSCHED_AUTONAME
                        else if (HIWORD(wParam) == EN_CHANGE)
                        {
                            NewSchedWiz_AutoName(hDlg, pBuf);
                            result = TRUE;
                        }
#endif
                        break;

                    case IDC_SCHEDULE_NAME:
                        if (HIWORD(wParam) == EN_CHANGE)
                        {
                            pBuf->m_dwPropSheetFlags &= ~PSF_NO_CHECK_SCHED_CONFLICT;
                            result = TRUE;
                        }
                        break;
/*
                    case IDC_SCHEDULE_NAME:
                        if (HIWORD(wParam) == EN_CHANGE)
                        {
                            TCHAR szName[MAX_PATH];
                            GetDlgItemText(hDlg, IDC_SCHEDULE_NAME, szName, ARRAYSIZE(szName));

                            if (lstrlen(szName) == 0)
                            {
                                pBuf->m_dwPropSheetFlags &= ~PSF_NO_AUTO_NAME_SCHEDULE;
                            }
                        }
                        break;
*/
                }
            }
            break;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:

                    ASSERT(NULL != lpPropSheet);
                    ASSERT(NULL != pWiz);
                    if (!pWiz->bIsNewSchedule)
                    {
                        //  If the user didn't pick a new schedule, move on
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    }
                    else
                    {                    
                        SetWizButtons(hDlg, (INT_PTR) lpPropSheet->pszTemplate, pWiz);
                    }
                    result = TRUE;
                    break;

#ifdef NEWSCHED_AUTONAME
                case DTN_DATETIMECHANGE:
                    if (NULL != pBuf)
                    {
                        NewSchedWiz_AutoName(hDlg, pBuf);
                    }
                    break;
#endif

                case PSN_KILLACTIVE:
                    result = TRUE;
                    break;

                case PSN_WIZNEXT:
                    if (!NewSchedWiz_ResolveNameConflict(hDlg, pBuf))
                    {
                        //  Don't proceed
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                    }
                    result = TRUE;
                    break;
                    
                case PSN_WIZFINISH:
                    if (NewSchedWiz_ResolveNameConflict(hDlg, pBuf))
                    {
                        NewSchedWiz_CreateSchedule(hDlg, pBuf);
                    }
                    else
                    {
                        //  Don't proceed
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                    }
                    result = TRUE;
                    break;
            }
            break;            
    }

    return result;
}

void Login_EnableControls(HWND hDlg, BOOL bEnable)
{
    int IDs[] = { 
        IDC_USERNAME_LABEL, 
        IDC_USERNAME,
        IDC_PASSWORD_LABEL,
        IDC_PASSWORD,
        IDC_PASSWORDCONFIRM_LABEL,
        IDC_PASSWORDCONFIRM
    };

    for (int i = 0; i < ARRAYSIZE(IDs); i++)
    {
        EnableWindow(GetDlgItem(hDlg, IDs[i]), bEnable);
    }
}

INT_PTR CALLBACK LoginDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet =(LPPROPSHEETPAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    WizInfo *pWiz = lpPropSheet ? (WizInfo *)lpPropSheet->lParam : NULL;
    POOEBuf  pBuf = pWiz ? pWiz->pOOE : NULL;
    NMHDR FAR *lpnm;
    BOOL result = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            lpPropSheet = (LPPROPSHEETPAGE)lParam;
            pWiz = (WizInfo *)lpPropSheet->lParam;
            pBuf = pWiz->pOOE;

            if (pBuf->bChannel)
            {
                ShowWindow(GetDlgItem(hDlg, IDC_PASSWORD_NO), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_PASSWORD_YES), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_LOGIN_PROMPT_URL), SW_HIDE);
            }
            else
            {
                CheckRadioButton(hDlg, IDC_PASSWORD_NO, IDC_PASSWORD_YES,
                    (((pBuf->username[0] == 0) && (pBuf->password[0] == 0)) ?
                        IDC_PASSWORD_NO : IDC_PASSWORD_YES));

                ShowWindow(GetDlgItem(hDlg, IDC_LOGIN_PROMPT), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_LOGIN_PROMPT_CHANNEL), SW_HIDE);
            }
                       
            Edit_LimitText(GetDlgItem(hDlg, IDC_USERNAME), ARRAYSIZE(pBuf->username) - 1);
            SetDlgItemText(hDlg, IDC_USERNAME, pBuf->username);

            Edit_LimitText(GetDlgItem(hDlg, IDC_PASSWORD), ARRAYSIZE(pBuf->password) - 1);
            SetDlgItemText(hDlg, IDC_PASSWORD, pBuf->password);

            Edit_LimitText(GetDlgItem(hDlg, IDC_PASSWORDCONFIRM), ARRAYSIZE(pBuf->password) - 1);
            SetDlgItemText(hDlg, IDC_PASSWORDCONFIRM, pBuf->password);

            Login_EnableControls(hDlg, (IsDlgButtonChecked(hDlg, IDC_PASSWORD_YES) || pBuf->bChannel));

            result = TRUE;
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_PASSWORD_YES:
                case IDC_PASSWORD_NO:
                    if (BN_CLICKED == HIWORD(wParam))
                    {
                        Login_EnableControls(hDlg, IsDlgButtonChecked(hDlg, IDC_PASSWORD_YES));
                        result = TRUE;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:

                    ASSERT(NULL != lpPropSheet);
                    ASSERT(NULL != pWiz);
                    
                    SetWizButtons(hDlg, (INT_PTR) lpPropSheet->pszTemplate, pWiz);
                    result = TRUE;
                    break;

                case PSN_WIZFINISH:
                {
                    BOOL bFinishOK = TRUE;
                    
                    if (pBuf)
                    {
                        if (pBuf->bChannel || IsDlgButtonChecked(hDlg, IDC_PASSWORD_YES))
                        {
                            TCHAR szUsername[ARRAYSIZE(pBuf->username) + 1];
                            TCHAR szPassword[ARRAYSIZE(pBuf->password) + 1];
                            TCHAR szPasswordConfirm[ARRAYSIZE(pBuf->password) + 1];

                            GetDlgItemText(hDlg, IDC_USERNAME, szUsername, ARRAYSIZE(szUsername));
                            GetDlgItemText(hDlg, IDC_PASSWORD, szPassword, ARRAYSIZE(szPassword));
                            GetDlgItemText(hDlg, IDC_PASSWORDCONFIRM, szPasswordConfirm, ARRAYSIZE(szPasswordConfirm));

                            if (!szUsername[0] && (szPassword[0] || szPasswordConfirm[0]))
                            {
                                SGMessageBox(hDlg, 
                                            (pBuf->bChannel ? IDS_NEEDCHANNELUSERNAME : IDS_NEEDUSERNAME), 
                                            MB_ICONWARNING);
                                bFinishOK = FALSE;
                            }
                            else if (szUsername[0] && !szPassword[0])
                            {
                                SGMessageBox(hDlg, 
                                            (pBuf->bChannel ? IDS_NEEDCHANNELPASSWORD : IDS_NEEDPASSWORD), 
                                            MB_ICONWARNING);
                                bFinishOK = FALSE;
                            }
                            else if (StrCmp(szPassword, szPasswordConfirm) != 0)
                            {
                                SGMessageBox(hDlg, IDS_MISMATCHED_PASSWORDS, MB_ICONWARNING);
                                bFinishOK = FALSE;
                            }
                            else
                            {
                                StrCpyN(pBuf->username, szUsername, ARRAYSIZE(pBuf->username));
                                StrCpyN(pBuf->password, szPassword, ARRAYSIZE(pBuf->password));
                                pBuf->dwFlags |= (PROP_WEBCRAWL_UNAME | PROP_WEBCRAWL_PSWD);
                            }

                        }
                        if (!bFinishOK)
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        }
                        else if (pWiz->bIsNewSchedule)
                        {
                            NewSchedWiz_CreateSchedule(pBuf->hwndNewSchedDlg, pBuf);
                        }

                        result = TRUE;
                    }
                    break;
                }
            }        
    }
    
    return result;
}

INT_PTR CALLBACK EnableScreenSaverDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                {
                    DWORD dwChecked = IsDlgButtonChecked(hDlg, IDC_DONTASKAGAIN);

                    WriteRegValue(  HKEY_CURRENT_USER,
                                    WEBCHECK_REGKEY, 
                                    g_szDontAskScreenSaver,
                                    &dwChecked, 
                                    sizeof(DWORD),
                                    REG_DWORD);

                    if (wParam == IDOK)
                        MakeADScreenSaverActive();                

                    EndDialog(hDlg, wParam);
                    break;
                }

                default:
                    return FALSE;
            }

            break;
        }

        default:
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\test\debug.c ===
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include <windows.h>
#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI     "shellext.ini"
#define SZ_DEBUGSECTION "testapp"
#define SZ_MODULE       "TESTAPP"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\test\autosub\autosub.cpp ===
#include <windows.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shguidp.h>
#include <msnotify.h>
#include <subsmgr.h>
#include <chanmgr.h>
#include <chanmgrp.h>
#include <stdio.h>
#include <stdarg.h>

#define DIM(x)              (sizeof(x) / sizeof(x[0]))

#define INI_FILE            "autosub.ini"

#define KEY_URL             "URL"
#define KEY_NAME            "Name"
#define KEY_AUTODIAL        "AutoDial"
#define KEY_ONLYIFIDLE      "OnlyIfIdle"
#define KEY_EMAILNOTIFY     "EmailNotify"
#define KEY_CHANGESONLY     "ChangesOnly"
#define KEY_DOWNLOADLEVELS  "DownloadLevels"
#define KEY_FOLLOWLINKS     "FollowLinks"
#define KEY_IMAGES          "Images"
#define KEY_SOUNDANDVIDEO   "SoundAndVideo"
#define KEY_CRAPLETS        "Craplets"
#define KEY_MAXDOWNLOADK    "MaxDownloadK"
#define KEY_SCHEDULENAME    "ScheduleName"

char              g_szIniFile[MAX_PATH];
BOOL              g_fComInited = FALSE;
ISubscriptionMgr *g_pSubsMgr = NULL;
IChannelMgr      *g_pChanMgr = NULL;
IChannelMgrPriv  *g_pChanMgrPriv = NULL;
INotificationMgr *g_pNotfMgr = NULL;
HWND              g_hwnd = NULL;
int               g_iAutoDial = 0;
int               g_iOnlyIfIdle = 1;
int               g_iEmailNotify = 0;
int               g_iChangesOnly = 0;
int               g_iDownloadLevels = 0;
int               g_iFollowLinks = 1;
int               g_iImages = 1;
int               g_iSoundAndVideo = 0;
int               g_iCraplets = 1;
int               g_iMaxDownloadK = 0;
char              g_szScheduleName[MAX_PATH] = "Auto";

BOOL SetCustomSchedule(int mins, SUBSCRIPTIONINFO *psi)
{
    BOOL fResult = FALSE;
    IEnumScheduleGroup *pEnumScheduleGroup;
    HRESULT hr;

    //
    //  This isn't very efficient but it's simple
    //
    
    hr = g_pNotfMgr->GetEnumScheduleGroup(0, &pEnumScheduleGroup);
    if (FAILED(hr))
    {
        printf("Couldn't enum schedule groups - hr = %08x\n", hr);
    }
    else
    {
        IScheduleGroup *pScheduleGroup = NULL;
        char szSchedName[64];
        WCHAR wszSchedName[64];
        TASK_TRIGGER tt;
        NOTIFICATIONCOOKIE cookie;
        GROUPINFO gi;
        BOOL fFound = FALSE;

        wsprintf(szSchedName, "%d minutes", mins);
        MultiByteToWideChar(CP_ACP, 0, szSchedName, -1, wszSchedName, DIM(wszSchedName));

        while (!fFound && pEnumScheduleGroup->Next(1, &pScheduleGroup, NULL) == S_OK)
        {
            if (SUCCEEDED(pScheduleGroup->GetAttributes(&tt, NULL, &cookie, &gi, NULL, NULL)))
            {
                int cmp = StrCmpIW(gi.pwzGroupname, wszSchedName);

                CoTaskMemFree(gi.pwzGroupname);

                if (cmp == 0)
                {
                    psi->schedule = SUBSSCHED_CUSTOM;
                    psi->customGroupCookie = cookie;
                    fResult = TRUE;
                    fFound = TRUE;
                }
            }
            pScheduleGroup->Release();
            pScheduleGroup = NULL;
        }
        pEnumScheduleGroup->Release();

        if (!fFound)
        {
            hr = g_pNotfMgr->CreateScheduleGroup(0, &pScheduleGroup, &cookie, 0);
            if (FAILED(hr))
            {
                printf("Couldn't create schedule group - hr = %08x\n", hr);
            }
            tt.cbTriggerSize = sizeof(TASK_TRIGGER);
            tt.wBeginYear = 1997;
            tt.wBeginMonth = 9;
            tt.wBeginDay = 1;
            tt.MinutesDuration = 1440;    //All day
            tt.MinutesInterval = mins;
            tt.TriggerType = TASK_TIME_TRIGGER_DAILY;
            tt.Type.Daily.DaysInterval = 1;
            gi.cbSize = sizeof(GROUPINFO);
            gi.pwzGroupname = wszSchedName;
            if (SUCCEEDED(pScheduleGroup->SetAttributes(&tt, NULL, &cookie, &gi, 0)))
            {
                psi->schedule = SUBSSCHED_CUSTOM;
                psi->customGroupCookie = cookie;
                fResult = TRUE;
            }
            pScheduleGroup->Release();

        }
    }
    return fResult;
}

void SetScheduleGroup(char *pszScheduleName, SUBSCRIPTIONINFO *psi, BOOL fIsChannel)
{
    psi->schedule = SUBSSCHED_AUTO;
    if (lstrcmpi(pszScheduleName, "Manual") == 0)
    {
        psi->schedule = SUBSSCHED_MANUAL;
    }
    else if (lstrcmpi(pszScheduleName, "Auto") == 0)
    {
        if (fIsChannel)
        {
            psi->fChannelFlags |= CHANNEL_AGENT_DYNAMIC_SCHEDULE;
            psi->schedule = SUBSSCHED_AUTO;
        }
        else
        {
            psi->schedule = SUBSSCHED_DAILY;
        }
    }
    else if (lstrcmpi(pszScheduleName, "Weekly") == 0)
    {
        psi->schedule = SUBSSCHED_WEEKLY;
    }
    else 
    {
        int mins = atoi(pszScheduleName);

        if (!mins || !SetCustomSchedule(mins, psi))
        {
            psi->schedule = SUBSSCHED_DAILY;
        }
    }

    if (psi->schedule != SUBSSCHED_AUTO)
    {
        psi->pTrigger = NULL;
    }
}

void CreateSubscription(char *pszSection, BOOL fIsChannel)
{
    char szURL[2048];
    char szName[MAX_PATH];
    WCHAR wszURL[2048];
    WCHAR wszName[MAX_PATH];
    char szScheduleName[MAX_PATH];
    HRESULT hr;
    TASK_TRIGGER     tt = {0};
    SUBSCRIPTIONINFO si = {0};
    BOOL fIsSoftware = FALSE;
    SUBSCRIPTIONTYPE st;

    printf("Processing [%s]...\n", pszSection);
    GetPrivateProfileString(pszSection, KEY_URL, "", szURL, DIM(szURL), g_szIniFile);
    if (!szURL[0])
    {
        printf("No URL specified in %s - moving on...\n", pszSection);
        return;
    }

    MultiByteToWideChar(CP_ACP, 0, szURL, -1, wszURL, DIM(wszURL));

    tt.cbTriggerSize = sizeof(TASK_TRIGGER);
    si.pTrigger = (LPVOID)&tt;

    if (fIsChannel)
    {
        printf("Downloading CDF %s...\n", szURL);

        si.cbSize       = sizeof(SUBSCRIPTIONINFO);
        si.fUpdateFlags = SUBSINFO_SCHEDULE;
        si.schedule     = SUBSSCHED_AUTO;

        hr = g_pChanMgrPriv->DownloadMinCDF(g_hwnd, wszURL, wszName, 
                                            DIM(wszName), &si, &fIsSoftware);

        if (FAILED(hr))
        {
            printf("Error downloading %s hr = %08x - moving on...\n", szURL, hr);
            return;
        }

        CHANNELSHORTCUTINFO csci = {0};
        csci.cbSize = sizeof(CHANNELSHORTCUTINFO);
        csci.pszTitle = wszName;
        csci.pszURL = wszURL;
        csci.bIsSoftware = fIsSoftware;
        hr = g_pChanMgr->AddChannelShortcut(&csci);
        if (FAILED(hr))
        {
            printf("Error adding channel shortcut for %s hr = %08x - moving on...\n", szURL, hr);
            return;
        }
        st = SUBSTYPE_CHANNEL;
    }
    else
    {
        si.cbSize       = sizeof(SUBSCRIPTIONINFO);
        si.fUpdateFlags = SUBSINFO_SCHEDULE;

        GetPrivateProfileString(pszSection, KEY_NAME, szURL, szName, DIM(szName), g_szIniFile);
        MultiByteToWideChar(CP_ACP, 0, szName, -1, wszName, DIM(wszName));
        st = SUBSTYPE_URL;
    }

    if (!GetPrivateProfileInt(pszSection, KEY_AUTODIAL, g_iAutoDial, g_szIniFile))
    {
        si.fTaskFlags |= TASK_FLAG_RUN_IF_CONNECTED_TO_INTERNET;
    }
    
    if (GetPrivateProfileInt(pszSection, KEY_ONLYIFIDLE, g_iOnlyIfIdle, g_szIniFile))
    {
        si.fTaskFlags |= TASK_FLAG_START_ONLY_IF_IDLE;
    }
    if (GetPrivateProfileInt(pszSection, KEY_EMAILNOTIFY, g_iEmailNotify, g_szIniFile))
    {
        si.bMailNotification = TRUE;
    }

    if (GetPrivateProfileInt(pszSection, KEY_CHANGESONLY, g_iChangesOnly, g_szIniFile))
    {
        si.bChangesOnly = TRUE;
    }

    if (!si.bChangesOnly)
    {
        if (fIsChannel)
        {
            si.fChannelFlags |= CHANNEL_AGENT_PRECACHE_ALL;
        }
        else
        {
            si.dwRecurseLevels = 
                GetPrivateProfileInt(pszSection, KEY_DOWNLOADLEVELS, g_iDownloadLevels, g_szIniFile);
        }
    }
    if (GetPrivateProfileInt(pszSection, KEY_FOLLOWLINKS, g_iFollowLinks, g_szIniFile))
    {
        si.fWebcrawlerFlags |= WEBCRAWL_LINKS_ELSEWHERE;
    }
    if (GetPrivateProfileInt(pszSection, KEY_IMAGES, g_iImages, g_szIniFile))
    {
        si.fWebcrawlerFlags |= WEBCRAWL_GET_IMAGES;
    }
    if (GetPrivateProfileInt(pszSection, KEY_SOUNDANDVIDEO, g_iSoundAndVideo, g_szIniFile))
    {
        si.fWebcrawlerFlags |= WEBCRAWL_GET_VIDEOS | WEBCRAWL_GET_BGSOUNDS;
    }
    if (GetPrivateProfileInt(pszSection, KEY_CRAPLETS, g_iCraplets, g_szIniFile))
    {
        si.fWebcrawlerFlags |= WEBCRAWL_GET_CONTROLS;
    }

    si.dwMaxSizeKB = 
        GetPrivateProfileInt(pszSection, KEY_MAXDOWNLOADK, g_iMaxDownloadK, g_szIniFile);

    GetPrivateProfileString(pszSection, KEY_SCHEDULENAME, g_szScheduleName, szScheduleName, DIM(szScheduleName), g_szIniFile);

    si.fUpdateFlags = SUBSINFO_ALLFLAGS;
    SetScheduleGroup(szScheduleName, &si, fIsChannel);

    BOOL fIsSubscribed = FALSE;

    g_pSubsMgr->IsSubscribed(wszURL, &fIsSubscribed);
    if (fIsSubscribed)
    {
        printf("Deleting old subscription to %s...\n", szURL);
        g_pSubsMgr->DeleteSubscription(wszURL, NULL);
    }

    printf("Subscribing to %s...\n", szURL);
    hr = g_pSubsMgr->CreateSubscription(g_hwnd, wszURL, wszName, 
            CREATESUBS_NOUI | CREATESUBS_ADDTOFAVORITES | 
                (fIsSoftware ? CREATESUBS_SOFTWAREUPDATE : 0),
            st, &si);

    if (FAILED(hr))
    {
        printf("Error creating subscription to %s hr = %08x - moving on...\n", szURL, hr);
        return;
    }
}

void ReadDefaults(char *pszSection)
{
    printf("Reading defaults from [%s]...\n", pszSection);
    g_iAutoDial = GetPrivateProfileInt(pszSection, KEY_AUTODIAL, g_iAutoDial, g_szIniFile);
    g_iOnlyIfIdle = GetPrivateProfileInt(pszSection, KEY_ONLYIFIDLE, g_iOnlyIfIdle, g_szIniFile);
    g_iEmailNotify = GetPrivateProfileInt(pszSection, KEY_EMAILNOTIFY, g_iEmailNotify, g_szIniFile);
    g_iChangesOnly = GetPrivateProfileInt(pszSection, KEY_CHANGESONLY, g_iChangesOnly, g_szIniFile);
    g_iDownloadLevels = GetPrivateProfileInt(pszSection, KEY_DOWNLOADLEVELS, g_iDownloadLevels, g_szIniFile);
    g_iFollowLinks = GetPrivateProfileInt(pszSection, KEY_FOLLOWLINKS, g_iFollowLinks, g_szIniFile);
    g_iImages = GetPrivateProfileInt(pszSection, KEY_IMAGES, g_iImages, g_szIniFile);
    g_iSoundAndVideo = GetPrivateProfileInt(pszSection, KEY_SOUNDANDVIDEO, g_iSoundAndVideo, g_szIniFile);
    g_iCraplets = GetPrivateProfileInt(pszSection, KEY_CRAPLETS, g_iCraplets, g_szIniFile);
    g_iMaxDownloadK = GetPrivateProfileInt(pszSection, KEY_MAXDOWNLOADK, g_iMaxDownloadK, g_szIniFile);
    GetPrivateProfileString(pszSection, KEY_SCHEDULENAME, "Auto", g_szScheduleName, DIM(g_szScheduleName), g_szIniFile);
}

void CleanUp()
{
    if (g_pSubsMgr)
    {
        g_pSubsMgr->Release();
        g_pSubsMgr = NULL;
    }

    if (g_pChanMgrPriv)
    {
        g_pChanMgrPriv->Release();
        g_pChanMgrPriv = NULL;
    }

    if (g_pChanMgr)
    {
        g_pChanMgr->Release();
        g_pChanMgr = NULL;
    }

    if (g_pNotfMgr)
    {
        g_pNotfMgr->Release();
        g_pNotfMgr = NULL;
    }

    if (g_fComInited)
    {
        CoUninitialize();
    }

}

void ErrorExit(char *fmt, ...)
{
    va_list va;

    va_start(va, fmt);
    vprintf(fmt, va);

    CleanUp();
    exit(1);
}

int _cdecl main(int argc, char **argv)
{
    char szSections[8192];
    char *pszSection;

    if (argc < 2)
    {
        ErrorExit("Need a file name!\nExample:\nautosub \\\\ohserv\\users\\tnoonan\\autosub.ini\n");
    }

    lstrcpy(g_szIniFile, argv[1]);
    printf("Reading %s...\n", g_szIniFile);

    if (!GetPrivateProfileSectionNames(szSections, DIM(szSections), g_szIniFile))
    {
        ErrorExit("No sections found in %s\n", g_szIniFile);
    }

    printf("Initializing COM...\n");
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        ErrorExit("CoInitialize failed with hr = %08x\n", hr);
    }
    
    g_fComInited = TRUE;

    printf("Creating Channel Manager...\n");
    hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, IID_IChannelMgr, 
                            (void **)&g_pChanMgr);
    if (FAILED(hr))
    {
        ErrorExit("CoCreate failed on channel manager with hr = %08x\n", hr);
    }

    hr = g_pChanMgr->QueryInterface(IID_IChannelMgrPriv, (void **)&g_pChanMgrPriv);
    if (FAILED(hr))
    {
        ErrorExit("QI failed for IID_IChannelMgrPriv with hr = %08x\n", hr);
    }

    printf("Creating Subscription Manager...\n");
    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr, 
                            (void **)&g_pSubsMgr);
    if (FAILED(hr))
    {
        ErrorExit("CoCreate failed on channel manager with hr = %08x\n", hr);
    }

    printf("Creating Notification Manager...\n");
    hr = CoCreateInstance(CLSID_StdNotificationMgr, NULL, CLSCTX_INPROC_SERVER, IID_INotificationMgr, (void**)&g_pNotfMgr);
    if (FAILED(hr))
    {
        ErrorExit("CoCreate failed on notification manager with hr = %08x\n", hr);
    }

    g_hwnd = GetDesktopWindow();
    
    pszSection = szSections;

    ReadDefaults("Defaults");

    while (pszSection && *pszSection)
    {
        BOOL fIsChannel = FALSE;

        switch (toupper(*pszSection))
        {
            case 'C':
                fIsChannel = TRUE;
                //  Fall through
            case 'U':
                CreateSubscription(pszSection, fIsChannel);
                break;

            default:
                if (lstrcmpi(pszSection, "Defaults") != 0)
                {
                    printf("Skipping [%s]\n", pszSection);
                }
                break;
        }
        pszSection += strlen(pszSection) + 1;
    }

    CleanUp();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\test\testapp.cpp ===
#define INC_OLE2
#include <windows.h>
#include <ole2.h>
#include <ole2ver.h>

#define INITGUIDS
#include <shlguid.h>
#include <shlobj.h>
#include <initguid.h>
#include "exdisp.h"
#include <exdispid.h>
#include <hlink.h>
#define INC_CONTROLS
#include <inetsdk.h>
#include "webcheck.h"
#include <downld.h>

#include "downld.h"

// Free us from the tyranny of CRT by defining our own new and delete
#define CPP_FUNCTIONS
#include <crtfree.h>

#undef TF_THISMODULE
#define TF_THISMODULE   TF_TESTAPP


HINSTANCE g_hInst;

int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, LPSTR pszCmdLine, int nCmdShow)
{
    CUrlDownload *pDownload;
    MSG msg;

     if (FAILED(CoInitialize(NULL)))
        return 0;
    
    //BSTR bStr = SysAllocString(L"http://ohserv/testcases/bvt/ocs/scroll/LtoR.htm");
    //BSTR bStr = SysAllocString(L"http://ohserv/testcases/bvt/frame1.htm");
    BSTR bStr = SysAllocString(L"http://www.oz.net/~evad/");
    //BSTR bStr = SysAllocString(L"http://ohserv/testcases/bvt/ocs/ocx1.htm");
    

    g_hInst = hInst;

    pDownload = NewDownloader(0,0);
    pDownload->put_Flags(DLCTL_FLAGS_SET | DLCTL_RUNSILENTACTIVEXCTLS );
    pDownload->BeginDownloadURL(bStr);
    while (1){
        if(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return 0;
}

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPTSTR pszCmdLine = GetCommandLine();

    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : 
SW_SHOWDEFAULT);

    ExitThread(i);  // We only come here when we are not the shell...
    return i;
}

//////////////////////////////////////////////////////////////////////////
//
// Utility functions
//
//////////////////////////////////////////////////////////////////////////
#ifdef DEBUG
void __cdecl _Dbg(LPCSTR pszMsg, ...)
{
    char sz[1024];

    wvsprintf(sz, pszMsg, (va_list)(&pszMsg + 1));
    OutputDebugString(sz);
    OutputDebugString("\r\n");
}
#endif


//////////////////////////////////////////////////////////////////////////
//
// helper functions
//
//////////////////////////////////////////////////////////////////////////
int MyOleStrToStrN(LPTSTR psz, int cchMultiByte, LPCOLESTR pwsz)
{
    return WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz,
                    cchMultiByte, NULL, NULL);
}

int MyStrToOleStrN(LPOLESTR pwsz, int cchWideChar, LPCTSTR psz)
{
    return MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cchWideChar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\perf\webckdn\webckdn.cpp ===
#define _OLEAUT32_      // get DECLSPEC_IMPORT stuff right for oleaut32.h, we are defing these
#define _WINMM_         // get DECLSPEC_IMPORT stuff right for mmsystem.h, we are defing these
#define _INTSHCUT_      // get DECLSPEC_IMPORT stuff right for intshcut.h, we are defing these
#define _WINX32_        // get DECLSPEC_IMPORT stuff right for wininet.h, we are defing these
#define _URLCACHEAPI_   // get DECLSPEC_IMPORT stuff right for wininet.h, we are defing these

#define INC_OLE2
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <ccstock.h>
#include <ole2.h>
#include <ole2ver.h>
#include <oleauto.h>
#include <docobj.h>
#include <shlwapi.h>
#include <wininet.h>   // INTERNET_MAX_URL_LENGTH.  Must be before shlobjp.h!
#include <shlobj.h>
#include <shlobjp.h>
#include <msxml.h>
#include <subsmgr.h>
#include <webcheck.h>
#include "iimgctx.h"

#ifdef _DEBUG
#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK        do { _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#endif

#define ASSERT(exp) \
if(!exp) \
{        \
    printf("ASSERT: %s %s (%s) failed\r\n", __FILE__, __LINE__, TEXT(#exp)); \
    DEBUG_BREAK; \
}        \

#else
#define ASSERT(exp)
#endif

#define DBGOUT(s) printf("%s\r\n", s)

#ifndef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; } else
#endif
#ifndef SAFEFREEBSTR
#define SAFEFREEBSTR(p) if ((p) != NULL) { SysFreeString(p); (p) = NULL; } else
#endif
#ifndef SAFEFREEOLESTR
#define SAFEFREEOLESTR(p) if ((p) != NULL) { CoTaskMemFree(p); (p) = NULL; } else
#endif
#ifndef SAFELOCALFREE
#define SAFELOCALFREE(p) if ((p) != NULL) { LocalFree(p); (p) = NULL; } else
#endif
#ifndef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { delete (p); (p) = NULL; } else
#endif

#define ON_FAILURE_RETURN(HR)   {if(FAILED(HR)) return (HR);}
#define MAX_RES_STRING_LEN 128      // max resource string len for WriteStringRes

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// Notification property names
// Agent Start
extern const WCHAR  c_szPropURL[] = L"URL";
extern const WCHAR  c_szPropBaseURL[] = L"BaseURL";
extern const WCHAR  c_szPropName[] = L"Name";
extern const WCHAR  c_szPropPriority[] = L"Priority";   // FEATURE: remove this soon
extern const WCHAR  c_szPropAgentFlags[] = L"AgentFlags";
extern const WCHAR  c_szPropCrawlLevels[] = L"RecurseLevels";
extern const WCHAR  c_szPropCrawlFlags[] = L"RecurseFlags";
extern const WCHAR  c_szPropCrawlMaxSize[] = L"MaxSizeKB";
extern const WCHAR  c_szPropCrawlChangesOnly[] = L"CheckChangesOnly";
extern const WCHAR  c_szPropCrawlExemptPeriod[] = L"ExemptPeriod";
extern const WCHAR  c_szPropCrawlUsername[] = L"Username";
extern const WCHAR  c_szPropCrawlPassword[] = L"Password";
extern const WCHAR  c_szPropEmailNotf[] = L"EmailNotification";
extern const WCHAR  c_szPropCrawlLocalDest[] = L"LocalDest";
extern const WCHAR  c_szPropCrawlGroupID[] = L"GroupID";
extern const WCHAR  c_szPropCrawlActualSize[] = L"ActualSizeKB";
extern const WCHAR  c_szPropEnableShortcutGleam[] = L"EnableShortcutGleam";
extern const WCHAR  c_szPropCDFStartCookie[] = L"CDFStartCookie";
extern const WCHAR  c_szPropChannelFlags[] = L"ChannelFlags";
extern const WCHAR  c_szPropAuthMethod[] = L"AuthMethod";
extern const WCHAR  c_szPropAuthDomain[] = L"AuthDomain";
extern const WCHAR  c_szPropChannel[] = L"Channel";
extern const WCHAR  c_szPropDesktopComponent[] = L"DesktopComponent";

// Agent Control
extern const WCHAR  c_szPropControlType[] = L"ControlType";
// Progress Report
extern const WCHAR  c_szPropProgress[] = L"Progress";
extern const WCHAR  c_szPropProgressMax[] = L"ProgressMax";
extern const WCHAR  c_szPropCurrentURL[] = L"CurrentURL";
// End Report
extern const WCHAR  c_szPropStatusCode[] = L"StatusCode";
extern const WCHAR  c_szPropStatusString[] = L"StatusString";
extern const WCHAR  c_szPropCompletionTime[] = L"CompletionTime";
extern const WCHAR  c_szPropEmailURL[] = L"EmailURL";

// Tray Agent Properties
extern const WCHAR  c_szPropGuidsArr[] = L"Guids Array";

// Update Agent Properties
extern const WCHAR  c_szTimeStamp[] = L"Update TS";

// Tracking Properties
extern const WCHAR  c_szTrackingCookie[] = L"LogGroupID";
extern const WCHAR  c_szTrackingPostURL[] = L"PostURL";
extern const WCHAR  c_szPostingRetry[] = L"PostFailureRetry";
extern const WCHAR  c_szPostHeader[] = L"PostHeader";

// Delivery Agent Properties
extern const WCHAR  c_szStartCookie[] = L"StartCookie";

// Initial cookie in AGENT_INIT
extern const WCHAR  c_szInitCookie[] = L"InitCookie";

// Helper function protos
int MyOleStrToStrN(LPSTR psz, int cchMultiByte, LPCOLESTR pwsz);
int MyStrToOleStrN(LPOLESTR pwsz, int cchWideChar, LPCSTR psz);
HRESULT ReadBSTR(ISubscriptionItem *pItem, LPCWSTR szName, BSTR *bstrRet);
HRESULT ReadOLESTR(ISubscriptionItem *pItem, LPCWSTR szName, LPWSTR *ppszRet);
HRESULT ReadAnsiSTR(ISubscriptionItem *pItem, LPCWSTR szName, LPSTR *ppszRet);
HRESULT ReadBool(ISubscriptionItem *pItem, LPCWSTR szName, VARIANT_BOOL *pBoolRet);
HRESULT ReadSCODE(ISubscriptionItem *pItem, LPCWSTR szName, SCODE *pscRet);
HRESULT WriteEMPTY(ISubscriptionItem *pItem, LPCWSTR szName);
HRESULT WriteSCODE(ISubscriptionItem *pItem, LPCWSTR szName, SCODE scVal);
HRESULT ReadDWORD(ISubscriptionItem *pItem, LPCWSTR szName, DWORD *pdwRet);
HRESULT ReadLONGLONG(ISubscriptionItem *pItem, LPCWSTR szName, LONGLONG *pllRet);
HRESULT ReadGUID(ISubscriptionItem *pItem, LPCWSTR szName, GUID *pGuid);
HRESULT WriteGUID(ISubscriptionItem *pItem, LPCWSTR szName, GUID *pGuid);
HRESULT WriteLONGLONG(ISubscriptionItem *pItem, LPCWSTR szName, LONGLONG llVal);
HRESULT WriteDWORD(ISubscriptionItem *pItem, LPCWSTR szName, DWORD dwVal);
HRESULT ReadDATE(ISubscriptionItem *pItem, LPCWSTR szName, DATE *dtVal);
HRESULT WriteDATE(ISubscriptionItem *pItem, LPCWSTR szName, DATE *dtVal);
HRESULT ReadVariant(ISubscriptionItem *pItem, LPCWSTR szName, VARIANT *pvarRet);
HRESULT WriteVariant(ISubscriptionItem *pItem, LPCWSTR szName, VARIANT *pvarVal);
HRESULT WriteOLESTR(ISubscriptionItem *pItem, LPCWSTR szName, LPCWSTR szVal);
HRESULT WriteAnsiSTR(ISubscriptionItem *pItem, LPCWSTR szName, LPCSTR szVal);

///////////////////////////////////////////////////////////////////////
// CLASSSES
///////////////////////////////////////////////////////////////////////
#if 0
class CConApp;

//////////////////////////////////////////////////////////////////////////
class CRunDeliveryAgentSink
{
private:
    int m_iActive;
    
public:
    CRunDeliveryAgentSink()
    {
        m_iActive = 0;
    }

    virtual HRESULT OnAgentBegin()
    {
        m_iActive++;
        return S_OK;
    }

    // OnAgentProgress not currently called
    virtual HRESULT OnAgentProgress()
    { 
        return E_NOTIMPL; 
    }
    
    // OnAgentEnd called when agent is complete. fSynchronous means that StartAgent call
    //  has not yet returned; hrResult will be returned from StartAgent
    virtual HRESULT OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
                               long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                               BOOL fSynchronous)
    {
        m_iActive--;
        return S_OK;
    }

    virtual int AgentActive()
    {
        return m_iActive;
    }
};
#endif

//////////////////////////////////////////////////////////////////////////
//
// CRunDeliveryAgent object
// Will run a delivery agent and host it for you
// Create, call Init, then call StartAgent
// Use static function SafeRelease to safely release this class.
//
//////////////////////////////////////////////////////////////////////////
class CConApp;

class CRunDeliveryAgent : public ISubscriptionAgentEvents
{
protected:
    virtual ~CRunDeliveryAgent();

///    CRunDeliveryAgentSink *m_pParent;
    CConApp*    m_pParent;

    ULONG           m_cRef;

    ISubscriptionItem         *m_pItem;
    ISubscriptionAgentControl *m_pAgent;

    HRESULT     m_hrResult;
    BOOL        m_fInStartAgent;

    CLSID       m_clsidDest;
    
    void        CleanUp();

public:
    CRunDeliveryAgent();

    HRESULT Init(CConApp *pParent, ISubscriptionItem *pItem, REFCLSID rclsidDest);

    inline static void SafeRelease(CRunDeliveryAgent * &pThis)
    { 
        if (pThis) 
        { 
            pThis->m_pParent=NULL; pThis->Release(); pThis=NULL; 
        } 
    }

    HRESULT CreateNewItem(ISubscriptionItem **ppItem, REFCLSID rclsidAgent);

    // StartAgent will return E_PENDING if agent is running. Otherwise it will return
    //  synchronous result code from agent.
    HRESULT     StartAgent();

    HRESULT     AgentPause(DWORD dwFlags);
    HRESULT     AgentResume(DWORD dwFlags);
    HRESULT     AgentAbort(DWORD dwFlags);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppunk);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ISubscriptionAgentEvents members
    STDMETHODIMP UpdateBegin(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie);
    STDMETHODIMP UpdateProgress(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                        long lSizeDownloaded, long lProgressCurrent, long lProgressMax,
                        HRESULT hrStatus, LPCWSTR wszStatus);
    STDMETHODIMP UpdateEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                            long lSizeDownloaded,
                            HRESULT hrResult, LPCWSTR wszResult);
    STDMETHODIMP ReportError(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                             HRESULT hrError, LPCWSTR wszError);
};

//---------------------------------------------------------------------
class CConApp
{
private:
    int m_argc;
    char **m_argv;
    char *m_pszURL;
    char *m_pRunStr;
    char *m_pTestName;
    char m_CmdLine[1024];
    int m_iActive;
    DWORD m_dwTime;     // Download time
    DWORD m_dwFlags;
    DWORD m_dwLevels;
    DWORD m_dwChannel;
    DWORD m_dwChannelFlags;
    BOOL m_bVerbose;
    BOOL m_bPreLoad;
    BOOL m_bChannelAgent;
    
public:
    CConApp(int argc, char **argv);
    ~CConApp();
    HRESULT Init();
    HRESULT Download();
    BOOL PrintResults();
    BOOL ParseCommandLine();
    void Display_Usage();
    BOOL Verbose();
    HRESULT MessageLoop();

    // Delivery agent events
    virtual HRESULT OnAgentBegin();
    virtual HRESULT OnAgentProgress();
    virtual HRESULT OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
                           long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                           BOOL fSynchronous);
};


///////////////////////////////////////////////////////////////////////
// HELPER FUNCTIONS
///////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------
int MyOleStrToStrN(LPSTR psz, int cchMultiByte, LPCOLESTR pwsz)
{
    int i;
    i=WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz,
                    cchMultiByte, NULL, NULL);
    if (!i)
    {
        DBGOUT("MyOleStrToStrN string too long; truncated");
        psz[cchMultiByte-1]=0;
    }
#ifdef DEBUG
    else
        ZeroMemory(psz+i, sizeof(TCHAR)*(cchMultiByte-i));
#endif

    return i;
}

//---------------------------------------------------------------------
int MyStrToOleStrN(LPOLESTR pwsz, int cchWideChar, LPCSTR psz)
{
    int i;
    i=MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cchWideChar);
    if (!i)
    {
        DBGOUT("MyStrToOleStrN string too long; truncated");
        pwsz[cchWideChar-1]=0;
    }
#ifdef DEBUG
    else
        ZeroMemory(pwsz+i, sizeof(OLECHAR)*(cchWideChar-i));
#endif

    return i;
}


//---------------------------------------------------------------------
// Can return S_OK with NULL bstr
HRESULT ReadBSTR(ISubscriptionItem *pItem, LPCWSTR szName, BSTR *bstrRet)
{
    ASSERT(pItem && bstrRet);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) &&
            (Val.vt==VT_BSTR))
    {
        *bstrRet = Val.bstrVal;
        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        *bstrRet = NULL;
        return E_INVALIDARG;
    }
}

//---------------------------------------------------------------------
// Cannot return S_OK with emptry string
HRESULT ReadOLESTR(ISubscriptionItem *pItem, LPCWSTR szName, LPWSTR *ppszRet)
{
    HRESULT hr;
    BSTR bstrRet = NULL;
    *ppszRet = NULL;
    hr = ReadBSTR(pItem, szName, &bstrRet);
    if (SUCCEEDED(hr) && bstrRet && bstrRet[0])
    {
        int len = (lstrlenW(bstrRet) + 1) * sizeof(WCHAR);
        *ppszRet = (LPWSTR) CoTaskMemAlloc(len);
        if (*ppszRet)
        {
            CopyMemory(*ppszRet, bstrRet, len);
        }
    }
    
    SAFEFREEBSTR(bstrRet);
    if (*ppszRet)
        return S_OK;
    else
        return E_FAIL;
}

//---------------------------------------------------------------------
HRESULT ReadAnsiSTR(ISubscriptionItem *pItem, LPCWSTR szName, LPSTR *ppszRet)
{
    HRESULT hr;
    BSTR bstrRet = NULL;
    *ppszRet = NULL;
    hr = ReadBSTR(pItem, szName, &bstrRet);
    if (SUCCEEDED(hr) && bstrRet && bstrRet[0])
    {
        // Don't forget to allocate a long string for DBCS.
        int len = (lstrlenW(bstrRet) + 1) * sizeof(CHAR) * 2;
        *ppszRet = (LPSTR) LocalAlloc(NULL, len);
        if (*ppszRet)
        {
            MyOleStrToStrN(*ppszRet, len, bstrRet);
        }
    }
    
    SAFEFREEBSTR(bstrRet);
    if (*ppszRet)
        return S_OK;
    else
        return E_FAIL;
}

//---------------------------------------------------------------------
HRESULT ReadBool(ISubscriptionItem *pItem, LPCWSTR szName, VARIANT_BOOL *pBoolRet)
{
    ASSERT(pItem && pBoolRet);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    // accept VT_I4 or VT_BOOL
    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) &&
            (Val.vt==VT_BOOL || Val.vt==VT_I4))
    {
        if (Val.vt==VT_I4)
        {
            if (Val.lVal)
                *pBoolRet = VARIANT_TRUE;
            else
                *pBoolRet = VARIANT_FALSE;
        }
        else
            *pBoolRet = Val.boolVal;
        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        return E_INVALIDARG;
    }
}

//---------------------------------------------------------------------
HRESULT ReadSCODE(ISubscriptionItem *pItem, LPCWSTR szName, SCODE *pscRet)
{
    ASSERT(pItem && pscRet);

    VARIANT Val;

    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) && Val.vt == VT_ERROR)
    {
        *pscRet = Val.scode;
        return S_OK;
    }
    else
    {
        VariantClear(&Val);
        return E_INVALIDARG;
    }
}

//---------------------------------------------------------------------
HRESULT WriteEMPTY(ISubscriptionItem *pItem, LPCWSTR szName)
{
    ASSERT(pItem);

    VARIANT Val;

    Val.vt = VT_EMPTY;
    return pItem->WriteProperties(1, &szName, &Val);
}

//---------------------------------------------------------------------
HRESULT WriteSCODE(ISubscriptionItem *pItem, LPCWSTR szName, SCODE scVal)
{
    ASSERT(pItem);

    VARIANT Val;

    Val.vt = VT_ERROR;
    Val.scode = scVal;

    return pItem->WriteProperties(1, &szName, &Val);
}
    
//---------------------------------------------------------------------
HRESULT ReadDWORD(ISubscriptionItem *pItem, LPCWSTR szName, DWORD *pdwRet)
{
    ASSERT(pItem && pdwRet);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) &&
            (Val.vt==VT_I4 || Val.vt==VT_I2))
    {
        if (Val.vt==VT_I4)
            *pdwRet = (DWORD) Val.lVal;
        else
            *pdwRet = (DWORD) Val.iVal;

        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        return E_INVALIDARG;
    }
}

//---------------------------------------------------------------------
HRESULT ReadLONGLONG(ISubscriptionItem *pItem, LPCWSTR szName, LONGLONG *pllRet)
{
    ASSERT(pItem && pllRet);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) &&
            (Val.vt==VT_CY))
    {
        *pllRet = *((LONGLONG *) &(Val.cyVal));

        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        return E_INVALIDARG;
    }
}
    
//---------------------------------------------------------------------
HRESULT ReadGUID(ISubscriptionItem *pItem, LPCWSTR szName, GUID *pGuid)
{
    ASSERT(pItem && pGuid);

    BSTR    bstrGUID = NULL;
    HRESULT hr = E_INVALIDARG;
    
    if (SUCCEEDED(ReadBSTR(pItem, szName, &bstrGUID)) &&
        SUCCEEDED(CLSIDFromString(bstrGUID, pGuid)))
    {
        hr = NOERROR;
    }
    SAFEFREEBSTR(bstrGUID);

    return hr;
}

//---------------------------------------------------------------------
HRESULT WriteGUID(ISubscriptionItem *pItem, LPCWSTR szName, GUID *pGuid)
{
    ASSERT(pItem && pGuid);
    
    WCHAR   wszCookie[GUIDSTR_MAX];

#ifdef DEBUG
    int len = 
#endif
    StringFromGUID2(*pGuid, wszCookie, sizeof(wszCookie));
    ASSERT(GUIDSTR_MAX == len);
    return WriteOLESTR(pItem, szName, wszCookie);
}

//---------------------------------------------------------------------
HRESULT WriteLONGLONG(ISubscriptionItem *pItem, LPCWSTR szName, LONGLONG llVal)
{
    VARIANT Val;

    Val.vt = VT_CY;
    Val.cyVal = *((CY *) &llVal);

    return pItem->WriteProperties(1, &szName, &Val);
}

//---------------------------------------------------------------------
HRESULT WriteDWORD(ISubscriptionItem *pItem, LPCWSTR szName, DWORD dwVal)
{
    VARIANT Val;

    Val.vt = VT_I4;
    Val.lVal = dwVal;

    return pItem->WriteProperties(1, &szName, &Val);
}

//---------------------------------------------------------------------
HRESULT ReadDATE(ISubscriptionItem *pItem, LPCWSTR szName, DATE *dtVal)
{
    ASSERT(pItem && dtVal);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) && (Val.vt==VT_DATE))
    {
        *dtVal = Val.date;
        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        return E_INVALIDARG;
    }
}

//---------------------------------------------------------------------
HRESULT WriteDATE(ISubscriptionItem *pItem, LPCWSTR szName, DATE *dtVal)
{
    VARIANT Val;

    Val.vt = VT_DATE;
    Val.date= *dtVal;

    return pItem->WriteProperties(1, &szName, &Val);
}

//---------------------------------------------------------------------
HRESULT ReadVariant(ISubscriptionItem *pItem, LPCWSTR szName, VARIANT *pvarRet)
{
    ASSERT(pvarRet->vt == VT_EMPTY);
    return pItem->ReadProperties(1, &szName, pvarRet);
}

//---------------------------------------------------------------------
HRESULT WriteVariant(ISubscriptionItem *pItem, LPCWSTR szName, VARIANT *pvarVal)
{
    return pItem->WriteProperties(1, &szName, pvarVal);
}

//---------------------------------------------------------------------
HRESULT WriteOLESTR(ISubscriptionItem *pItem, LPCWSTR szName, LPCWSTR szVal)
{
    VARIANT Val;

    Val.vt = VT_BSTR;
    Val.bstrVal = SysAllocString(szVal);

    HRESULT hr = pItem->WriteProperties(1, &szName, &Val);

    SysFreeString(Val.bstrVal);

    return hr;
}

//---------------------------------------------------------------------
HRESULT WriteAnsiSTR(ISubscriptionItem *pItem, LPCWSTR szName, LPCSTR szVal)
{
    VARIANT Val;
    BSTR    bstrVal;
    int     iLen;
    HRESULT hr;

    iLen = lstrlen(szVal);
    bstrVal = SysAllocStringLen(NULL, iLen);
    if (bstrVal)
    {
        MyStrToOleStrN(bstrVal, iLen + 1, szVal);

        Val.vt = VT_BSTR;
        Val.bstrVal = bstrVal;

        hr = pItem->WriteProperties(1, &szName, &Val);

        SysFreeString(bstrVal);
    }

    return hr;
}

//==============================================================================
// CRunDeliveryAgent provides generic support for synchronous operation of a
//   delivery agent
// It is aggregatable so that you can add more interfaces to the callback
//
// Taken from webcheck\cdfagent.cpp
//==============================================================================
CRunDeliveryAgent::CRunDeliveryAgent()
{
    m_cRef = 1;
}

//---------------------------------------------------------------------
HRESULT CRunDeliveryAgent::Init(CConApp* pParent,
                                ISubscriptionItem *pItem,
                                REFCLSID rclsidDest)
{
    ASSERT(pParent && pItem);

    if (m_pParent || m_pItem)
        return E_FAIL;  // already initialized. can't reuse an instance.

    if (!pParent || !pItem)
        return E_FAIL;

    m_pParent = pParent;
    m_clsidDest = rclsidDest;

    m_pItem = pItem;
    pItem->AddRef();

    return S_OK;
}

//---------------------------------------------------------------------
CRunDeliveryAgent::~CRunDeliveryAgent()
{
    CleanUp();
}

//
// IUnknown members
//
//---------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRunDeliveryAgent::AddRef(void)
{
    return ++m_cRef;
}

//---------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRunDeliveryAgent::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

//---------------------------------------------------------------------
STDMETHODIMP CRunDeliveryAgent::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_ISubscriptionAgentEvents == riid))
    {
        *ppv=(ISubscriptionAgentEvents *)this;
    }
    else
        return E_NOINTERFACE;

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

//
// ISubscriptionAgentEvents members
//
//---------------------------------------------------------------------
STDMETHODIMP CRunDeliveryAgent::UpdateBegin(const SUBSCRIPTIONCOOKIE *)
{
    if (m_pParent)
        m_pParent->OnAgentBegin();
    return S_OK;
}

//---------------------------------------------------------------------
STDMETHODIMP CRunDeliveryAgent::UpdateProgress(
                const SUBSCRIPTIONCOOKIE *,
                long lSizeDownloaded,
                long lProgressCurrent,
                long lProgressMax,
                HRESULT hrStatus,
                LPCWSTR wszStatus)
{
    if (m_pParent)
        m_pParent->OnAgentProgress();
    return S_OK;
}

//---------------------------------------------------------------------
#define INET_S_AGENT_BASIC_SUCCESS           _HRESULT_TYPEDEF_(0x000C0F8FL) // From webcheck/delagent.h

STDMETHODIMP CRunDeliveryAgent::UpdateEnd(const SUBSCRIPTIONCOOKIE *pCookie,
                long    lSizeDownloaded,
                HRESULT hrResult,
                LPCWSTR wszResult)
{
    ASSERT((hrResult != INET_S_AGENT_BASIC_SUCCESS) && (hrResult != E_PENDING));

    m_hrResult = hrResult;
    if (hrResult == INET_S_AGENT_BASIC_SUCCESS || hrResult == E_PENDING)
    {
        // Shouldn't happen; let's be robust anyway.
        m_hrResult = S_OK;
    }

    if (m_pParent)
    {
        m_pParent->OnAgentEnd(pCookie, lSizeDownloaded, hrResult, wszResult, m_fInStartAgent);
    }

    CleanUp();

    return S_OK;
}

//---------------------------------------------------------------------
STDMETHODIMP CRunDeliveryAgent::ReportError(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        HRESULT hrError, 
        LPCWSTR wszError)
{
    return S_FALSE;
}

//---------------------------------------------------------------------
HRESULT CRunDeliveryAgent::StartAgent()
{
    HRESULT hr;

    if (!m_pParent || !m_pItem || m_pAgent)
        return E_FAIL;

    AddRef();   // Release before we return from this function
    m_fInStartAgent = TRUE;

    m_hrResult = INET_S_AGENT_BASIC_SUCCESS;

    if(m_pParent->Verbose())
        DBGOUT("Using new interfaces to host agent");

    ASSERT(!m_pAgent);

    hr = CoCreateInstance(m_clsidDest, NULL, CLSCTX_INPROC_SERVER,
                          IID_ISubscriptionAgentControl, (void **)&m_pAgent);

    if (m_pAgent)
    {
        hr = m_pAgent->StartUpdate(m_pItem, (ISubscriptionAgentEvents *)this);
    }

    hr = m_hrResult;

    m_fInStartAgent = FALSE;
    Release();

    if (hr != INET_S_AGENT_BASIC_SUCCESS)
    {
        return hr;
    }

    return E_PENDING;
};

//---------------------------------------------------------------------
HRESULT CRunDeliveryAgent::AgentPause(DWORD dwFlags)
{
    if (m_pAgent)
        return m_pAgent->PauseUpdate(0);

    if(m_pParent->Verbose())
        DBGOUT("CRunDeliveryAgent::AgentPause with no running agent!!");
    return S_FALSE;
}

//---------------------------------------------------------------------
HRESULT CRunDeliveryAgent::AgentResume(DWORD dwFlags)
{
    if (m_pAgent)
        return m_pAgent->ResumeUpdate(0);

    if(m_pParent->Verbose())
        DBGOUT("CRunDeliveryAgent::AgentResume with no running agent!!");

    return E_FAIL;
}

//---------------------------------------------------------------------
HRESULT CRunDeliveryAgent::AgentAbort(DWORD dwFlags)
{
    if (m_pAgent)
        return m_pAgent->AbortUpdate(0);

    if(m_pParent->Verbose())
        DBGOUT("CRunDeliveryAgent::AgentAbort with no running agent!!");
    return S_FALSE;
}

//---------------------------------------------------------------------
void CRunDeliveryAgent::CleanUp()
{
    SAFERELEASE(m_pItem);
    SAFERELEASE(m_pAgent);
    m_pParent = NULL;
}

//---------------------------------------------------------------------
HRESULT CRunDeliveryAgent::CreateNewItem(ISubscriptionItem **ppItem, REFCLSID rclsidAgent)
{
    ISubscriptionMgrPriv *pSubsMgrPriv=NULL;
    SUBSCRIPTIONITEMINFO info;

    *ppItem = NULL;

    HRESULT hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
        IID_ISubscriptionMgrPriv, (void**)&pSubsMgrPriv);

    if (pSubsMgrPriv)
    {
        SUBSCRIPTIONCOOKIE cookie;

        info.cbSize = sizeof(info);
        info.dwFlags = SI_TEMPORARY;
        info.dwPriority = 0;
        info.ScheduleGroup = GUID_NULL;
        info.clsidAgent = rclsidAgent;

        pSubsMgrPriv->CreateSubscriptionItem(&info, &cookie, ppItem);

        pSubsMgrPriv->Release();
    }
    else
    {
        printf("CoCreateInstance IID_ISubscriptionMgrPriv failed. hr=0x%x\r\n", hr);
    }

    return (*ppItem) ? S_OK : E_FAIL;
}

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------
CConApp::CConApp(int argc, char **argv)
{
    m_argc = argc;
    m_argv = argv;
    m_dwTime = 0;
    m_pszURL = NULL;
    m_bVerbose = FALSE;
    m_bPreLoad = FALSE;
    m_bChannelAgent = FALSE;
    m_dwFlags = 3;
    m_dwLevels = 0;
    m_dwChannel = 1;
    m_dwChannelFlags = CHANNEL_AGENT_PRECACHE_ALL;
    m_pRunStr = NULL;
    m_pTestName = NULL;
    m_iActive = 0;
}

//---------------------------------------------------------------------
CConApp::~CConApp()
{
    CoUninitialize();
}

//---------------------------------------------------------------------
HRESULT CConApp::Init()
{
    HRESULT hr = CoInitialize(NULL);
    ON_FAILURE_RETURN(hr);
        
    if(!ParseCommandLine())
        return(E_FAIL);

    return(S_OK);
}

//---------------------------------------------------------------------
HRESULT CConApp::Download()
{
    ISubscriptionItem  *pSubscriptItem = NULL;
    IImgCtx *pImgCtx = NULL;
    IClassFactory *pImageCF = NULL;

    if(m_bVerbose)
    {
        printf("URL=%s\r\n", m_pszURL);
        if(m_bPreLoad)
            printf("Preloading Mshtml\r\n");
        if(m_bChannelAgent)
            printf("ChannelAgent: Channel=%d Flags=0x%x\r\n", m_dwChannel, m_dwChannelFlags);
        else
            printf("WebCrawlerAgent:  Levels=%d Flags=0x%x\r\n", m_dwFlags, m_dwLevels);
    }
    
    HRESULT hr = S_OK;
    CLSID clsid;

    if (m_bChannelAgent)
        clsid = CLSID_ChannelAgent;
    else
        clsid = CLSID_WebCrawlerAgent;

    CRunDeliveryAgent *prda = new CRunDeliveryAgent;
    
    hr = prda->CreateNewItem(&pSubscriptItem, clsid);
    if (FAILED(hr) || !pSubscriptItem)
    {
        printf("prda->CreateNewItem failed.\r\n");
        return E_FAIL;
    }

    if (!prda || FAILED(prda->Init((CConApp *)this, pSubscriptItem, clsid)))
    {
        if (prda) 
            prda->Release();
        else
            printf("new CRunDeliveryAgent failed.\r\n");
        return E_FAIL;
    }

    // Preload mshtml
    if (m_bPreLoad)
    {
        if (FAILED(hr = CoGetClassObject(CLSID_IImgCtx, CLSCTX_SERVER, NULL, IID_IClassFactory, (void **)&pImageCF)))
        {
            printf("CoGetClassObject(CLSID_IImgCtx...) failed hr=%x\r\n", hr);
            return E_FAIL;
        }

        if (FAILED(hr = pImageCF->CreateInstance(NULL, IID_IImgCtx, (void **)&pImgCtx)))
        {
            printf("CreateInstance(IID_IImgCtx...) failed hr=%x\r\n", hr);
            return E_FAIL;
        }
    }

    // Set properties
    if (m_bChannelAgent)
    {
        WriteDWORD(pSubscriptItem, c_szPropChannel, m_dwChannel);
        WriteDWORD(pSubscriptItem, c_szPropChannelFlags, m_dwChannelFlags);
    }
    else
    {
        WriteDWORD(pSubscriptItem, c_szPropCrawlFlags, m_dwFlags);
        WriteDWORD(pSubscriptItem, c_szPropCrawlLevels, m_dwLevels);
    }

    // Set url property and start the download
    WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
    MyStrToOleStrN(wszURL, INTERNET_MAX_URL_LENGTH, m_pszURL);
    WriteOLESTR(pSubscriptItem, c_szPropURL, wszURL);
    
    m_dwTime = GetTickCount();  // Start time

    hr = prda->StartAgent();
    if (hr == E_PENDING)
    {
        hr = S_OK;
        
        if (Verbose()) 
            DBGOUT("CRunDeliveryAgent StartAgent succeeded");
        MessageLoop();
    }

    m_dwTime = GetTickCount() - m_dwTime;   // End time

    // Clean up
    if (pSubscriptItem)
    {
        pSubscriptItem->Release(); 
        pSubscriptItem = NULL;
    }

    if (pImgCtx)
    {
        pImgCtx->Release();
        pImgCtx = NULL;
    }

    if (pImageCF)
    {
        pImageCF->Release();
        pImageCF = NULL;
    }
        
    if (prda) 
    {
        prda->Release();
        prda = NULL;
    }
        
    if (FAILED(hr))
        return E_FAIL;

    return S_OK;
}

//---------------------------------------------------------------------
HRESULT CConApp::MessageLoop()
{
    MSG msg;
    BOOL dw;
    
    // Yield and wait for "UpdateEnd" notification
    while (m_iActive > 0 && (dw = ::GetMessage(&msg, NULL, 0, 0)))
    {
        ::TranslateMessage(&msg);
        ::DispatchMessage(&msg);
    }

    if(dw == 0)
        printf("GetMessage = 0, GLE=%d\r\n", GetLastError());

    return S_OK;
}

//---------------------------------------------------------------------
BOOL CConApp::PrintResults()
{
    printf("%s, %s, %ld, %ld, %ld %s\r\n", 
        m_pTestName ?m_pTestName :(m_bChannelAgent) ?"Webcheck ChannelAgent" :"Webcheck WebCrawlAgent",
        m_pRunStr ?m_pRunStr :"1",
        m_dwTime, 
        0,  // bytes read - future use, matches other tests
        0,  // kb/sec - future use
        m_CmdLine
        );
    return(TRUE);
}

//---------------------------------------------------------------------
BOOL CConApp::ParseCommandLine()
{
    BOOL bRC = TRUE;
    int argc = m_argc;
    char **argv = m_argv;
    DWORD dwLen = 0;

    *m_CmdLine = '\0';

    argv++; argc--;
    while( argc > 0 && argv[0][0] == '-' )  
    {
        switch (argv[0][1]) 
        {
            case 'c':
                m_bChannelAgent = TRUE;
                break;
            case 'f':
                m_dwFlags = atoi(&argv[0][2]);
                break;
            case 'l':
                m_dwLevels = atoi(&argv[0][2]);
                break;
            case 'p':
                m_bPreLoad = TRUE;
                break;
            case 'r':
                m_pRunStr = &argv[0][2];
                break;
            case 't':
                m_pTestName = &argv[0][2];
                break;
            case 'u':
                m_pszURL = &argv[0][2];
                break;
            case 'v':
                m_bVerbose = TRUE;
                break;
            default:
                bRC = FALSE;
                break;
        }
        
        if(bRC)
        {
            dwLen += lstrlen(argv[0]) + 1;   // length of arg and space
            if(dwLen < ((sizeof(m_CmdLine)/sizeof(m_CmdLine[0]))-1))
            {
                lstrcat(m_CmdLine, ",");
                lstrcat(m_CmdLine, argv[0]);
            }
        }
        
        argv++; argc--;
    }

    if(!m_pszURL || (bRC == FALSE))
    {
        Display_Usage();
        bRC = FALSE;
    }

    return(bRC);

}

//---------------------------------------------------------------------
void CConApp::Display_Usage()
{
    printf("Usage: %s -uURL [Options]\r\n\n", m_argv[0]);
    printf("Options:\r\n");
    printf("\t-c    Run ChannelAgent instead of WebCrawl.\r\n");
    printf("\t-f#   Webcrawl agent flags.\r\n");
    printf("\t-l#   Delivery agent levels to crawl.\r\n");
    printf("\t-p    Preload Mshtml.\r\n");
    printf("\t-v    Turn on verbose output.\r\n");
    printf("\t-tStr test name string (used in results output)\n");
    printf("\t-rStr run# string (used in results output)\n");
}

//---------------------------------------------------------------------
inline BOOL CConApp::Verbose()
{
    return(m_bVerbose);
}

//---------------------------------------------------------------------
HRESULT CConApp::OnAgentBegin()
{
    m_iActive++;
    return S_OK;
}

//---------------------------------------------------------------------
// OnAgentProgress not currently called
HRESULT CConApp::OnAgentProgress()
{ 
    return E_NOTIMPL; 
}

//---------------------------------------------------------------------
// OnAgentEnd called when agent is complete. fSynchronous means that StartAgent call
//  has not yet returned; hrResult will be returned from StartAgent
HRESULT CConApp::OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
                           long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                           BOOL fSynchronous)
{
    m_iActive--;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
int __cdecl main(int argc, char **argv)
{
    HRESULT hr = S_OK;
    
    CConApp App(argc, argv);
    hr = App.Init();
    if(!FAILED(hr))
    {
        hr = App.Download();
        App.PrintResults();
    }

    return((int)hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\test\dhcmpmrg\dhcmpmrg.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>

#define DIM(x)              (sizeof(x) / sizeof(x[0]))

FILE *file1 = NULL;
FILE *file2 = NULL;
FILE *fdiff = NULL;
FILE *fmerg = NULL;

char *pszFile1 = NULL;
char *pszFile2 = NULL;

void CleanUp()
{
    if (file1)
    {
        fclose(file1);
    }
    if (file2)
    {
        fclose(file2);
    }
    if (fdiff)
    {
        fclose(fdiff);
    }
    if (fmerg)
    {
        fclose(fmerg);
    }

    if (pszFile1)
    {
        delete [] pszFile1;
    }
    
    if (pszFile2)
    {
        delete [] pszFile2;
    }
}

void ErrorExit(char *fmt, ...)
{
    va_list va;

    va_start(va, fmt);
    vprintf(fmt, va);

    CleanUp();
    exit(1);
}

void ShowHow()
{
    ErrorExit("USAGE:\n\n" \
              "dhcmpmrg <file1> <file2> <diff> <merge>\n"
              );
}

FILE *OpenIt(char *pszName, char *pszMode)
{
    FILE *f = fopen(pszName, pszMode);

    if (!f)
    {
        ErrorExit("Couldn't open %s - mode %s\nError is %s\n", pszName, pszMode,
            strerror(NULL));
    }

    return f;
}

void Merge(char *pszFile, char tok, char *pszFileName)
{
    char szCmp[1024];

    //  Walk the diff file line by line
    while (fgets(szCmp, DIM(szCmp), fdiff) && (szCmp[0] == tok))
    {
        int len = strlen(szCmp);
       
        if (szCmp[len - 1] == '\n')
        {
            szCmp[len - 1] = 0;
        }

        //  Look for a BackTrace the K & R way
        char *pszbt = strstr(szCmp, "BackTrace");

        //  At this point pszbt should point to a string of the form
        //  BackTrace2032

        if (pszbt)
        {
            fprintf(fmerg, "%s\n", szCmp);

            //  Look for the specific back trace 
            char *pStart = strstr(pszFile, pszbt);
            char *pEnd = pStart;

            if (pStart)
            {
                //  Walk backwards to find the start of this line
                while ((pStart != pszFile) && (*pStart != '\n'))
                {
                    pStart--;
                }

                if (*pStart == '\n')
                {
                    pStart++;
                }

                //  Walk forwards to find the end of this stack trace.
                //  We use a blank line as the delimiter here.
                while (*pEnd != 0)
                {
                    //  If we hit a CR we need to look for and eat spaces
                    //  before checking for a second CR or EOF
                    if (*pEnd == '\n')
                    {
                        pEnd++;
                        while ((*pEnd != 0) && (*pEnd != '\n') && isspace(*pEnd))
                            pEnd++;

                        if ((*(pEnd) == '\n') || (*pEnd == 0))
                        {
                            break;
                        }
                    }
                    pEnd++;
                }

                fwrite(pStart, sizeof(char), pEnd - pStart, fmerg);
                fprintf(fmerg, "\n");
            }
            else
            {
                //  Yikes!
                fprintf(fmerg, "Couldn't find %s in %s...\n", pszbt, pszFileName);
                printf("Couldn't find %s in %s...\n", pszbt, pszFileName);
            }
        }
    }
}

long fsize(FILE *f)
{
    long pos = ftell(f);
    long size;

    fseek(f, 0, SEEK_END);

    size = ftell(f);

    fseek(f, pos, SEEK_SET);

    return size;
}

int _cdecl main(int argc, char **argv)
{
    if (argc < 5)
    {
        ShowHow();
    }

    //  This is not what I would call robust...
    
    file1 = OpenIt(argv[1], "r");
    file2 = OpenIt(argv[2], "r");
    fdiff = OpenIt(argv[3], "r");
    fmerg = OpenIt(argv[4], "w");

    long size;

    printf("Reading %s...\n", argv[1]);
    size = fsize(file1);
    pszFile1 = new char[size + 1];
    fread(pszFile1, sizeof(char), size, file1);
    *(pszFile1  + size) = 0;

    printf("Reading %s...\n", argv[2]);
    size = fsize(file2);
    pszFile2 = new char[size + 1];
    fread(pszFile2, sizeof(char), size, file2);
    *(pszFile2  + size) = 0;

    printf("Merging leaks...\n");
    Merge(pszFile2, '+', argv[2]);


    printf("Merging frees...\n");
    Merge(pszFile1, '-', argv[1]);
    
    CleanUp();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\test\notfcvt\notfcvt.cpp ===
#include <windows.h>
#include <subsmgr.h>
#include <stdio.h>
#include <stdarg.h>

void ErrorExit(char *fmt, ...)
{
    va_list va;

    va_start(va, fmt);
    vprintf(fmt, va);

    exit(1);
}


int _cdecl main()
{
    HINSTANCE hinst = LoadLibrary("webcheck.dll");

    if (hinst)
    {
        typedef (*PFCONVERTNOTFMGR)();

        PFCONVERTNOTFMGR ConvertNotfMgrSubscriptions;
        PFCONVERTNOTFMGR ConvertNotfMgrSchedules;

        ConvertNotfMgrSchedules = (PFCONVERTNOTFMGR)GetProcAddress(hinst,  MAKEINTRESOURCE(11));
        if (ConvertNotfMgrSchedules)
        {
            HRESULT hr = ConvertNotfMgrSchedules();

            if (SUCCEEDED(hr))
            {               
                printf("Schedule conversion succeeded - return code: 0x%08x\n", hr);

                ConvertNotfMgrSubscriptions = (PFCONVERTNOTFMGR)GetProcAddress(hinst,  MAKEINTRESOURCE(10));

                if (ConvertNotfMgrSubscriptions)
                {
                    HRESULT hr = ConvertNotfMgrSubscriptions();

                    if (SUCCEEDED(hr))
                    {
                        printf("Subscription conversion succeeded - return code: 0x%08x\n", hr);
                    }
                    else
                    {
                        ErrorExit("Error converting subscriptions - error code: 0x%08x\n", hr);
                    }
                }
                else
                {
                    ErrorExit("Couldn't find procedure 'ConvertNotfMgrSubscriptions' ordinal #10 - error code: %d\n",
                        GetLastError());
                }
            }
            else
            {
                ErrorExit("Error converting schedules - error code: 0x%08x\n", hr);
            }
        }
        else
        {
            ErrorExit("Couldn't find procedure 'ConvertNotfMgrSchedules' ordinal #11 - error code: %d\n",
                GetLastError());
        }
    }
    else
    {
        ErrorExit("Couldn't load webcheck - error code: %d\n", GetLastError());
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\test\schedcdf\schedcdf.h ===
#define ASSERT(x)  if(!(x)) DebugBreak()
#define SAFERELEASE(p) if (p) {(p)->Release(); p = NULL;} else ;

#define SCHEDCDF                101
#define ID_EXIT                 40001
#define ID_UPDATESCOPEALL       40002
#define ID_UPDATESCOPEOFFLINE   40003
#define ID_UPDATESCOPEONLINE    40004
#define ID_UPDATEFRAMESCDF      40005
#define ID_USEOTHERCDF          40006

#define IDD_OTHER               102
#define IDC_CDFNAME             1000

#define IDC_STATIC              -1


#define REGSTR_PATH_SCHEDCDF    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SchedCDF")
#define REGSTR_VAL_CDFURLPATH   TEXT("CDFUrlPath")


#ifndef GUIDSTR_MAX
// GUIDSTR_MAX is 39 and includes the terminating zero.
// == Copied from OLE source code =================================
// format for string form of GUID is (leading identifier ????)
// ????{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)
// ================================================================
#endif

class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : GlobalAlloc(GPTR, cBytes);
        m_fGlobalAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fGlobalAlloc) GlobalFree(m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fGlobalAlloc:1;
};


#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

//
// Note: allocate lstrlenW(widestr) * 2 because its possible for a UNICODE 
// character to map to 2 ansi characters this is a quick guarantee that enough
// space will be allocated.
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\test\ripsubs\ripsubs.cpp ===
/*
  ripsubs.cpp

  Description:  
     1. Enumerates through the scheduled subscriptions in NotificationMgr.
     2. For each, get URL property and then get SUBSCRIPTIONINFO structure
        describing the subscription from the ISubscriptionMgr
     3. Write out subscription information in the autosub.ini format

  History:
     9-12-97          Jasonba          created
*/


#include <windows.h>
#include <msnotify.h>
#include <subsmgr.h>
#include <stdio.h>
#include <stdarg.h>
#include <direct.h>

// Macros:
#define DIM(x)              (sizeof(x) / sizeof(x[0]))

// Keys:
#define KEY_URL             "URL"
#define KEY_NAME            "Name"
#define KEY_AUTODIAL        "AutoDial"
#define KEY_ONLYIFIDLE      "OnlyIfIdle"
#define KEY_EMAILNOTIFY     "EmailNotify"
#define KEY_CHANGESONLY     "ChangesOnly"
#define KEY_DOWNLOADLEVELS  "DownloadLevels"
#define KEY_FOLLOWLINKS     "FollowLinks"
#define KEY_IMAGES          "Images"
#define KEY_SOUNDANDVIDEO   "SoundAndVideo"
#define KEY_CRAPLETS        "Craplets"
#define KEY_MAXDOWNLOADK    "MaxDownloadK"
#define KEY_SCHEDULENAME    "ScheduleName"

// Globals:
char                g_szIniFile[MAX_PATH];
BOOL                g_fComInited            = FALSE;
ISubscriptionMgr    *g_pSubsMgr             = NULL;
INotificationMgr    *g_pNotfMgr             = NULL;
IEnumNotification   *g_pEnumNotfs           = NULL;
IPropertyMap        *g_pPropMap             = NULL;

int                 g_iAutoDial             = 0;
int                 g_iOnlyIfIdle           = 1;
int                 g_iEmailNotify          = 0;
int                 g_iChangesOnly          = 0;
int                 g_iDownloadLevels       = 0;
int                 g_iFollowLinks          = 1;
int                 g_iImages               = 1;
int                 g_iSoundAndVideo        = 0;
int                 g_iCraplets             = 1;
int                 g_iMaxDownloadK         = 0;
char                g_szScheduleName[MAX_PATH] = "Auto";


void CleanUp()
{
    if(g_pPropMap)
    {
        printf("Releasing property map...\n");
        g_pPropMap->Release();
        g_pPropMap = NULL;
    }

    
    if (g_pEnumNotfs)
    {
        printf("Releasing notification enumerator...\n");
        g_pEnumNotfs->Release();
        g_pEnumNotfs=NULL;
    }

    if (g_pSubsMgr)
    {
        printf("Releasing Subscription Manager...\n");
        g_pSubsMgr->Release();
        g_pSubsMgr = NULL;
    }

    if (g_pNotfMgr)
    {
        printf("Releasing Notification Manager...\n");
        g_pNotfMgr->Release();
        g_pNotfMgr = NULL;
    }

    if (g_fComInited)
    {
        CoUninitialize();
    }
}


void ErrorExit(char *fmt, ...)
{
    va_list va;

    va_start(va, fmt);
    vprintf(fmt, va);

    CleanUp();
    exit(1);
}

void ReadDefaults()
{
    printf("Reading defaults from [Defaults]...\n");
    g_iAutoDial = GetPrivateProfileInt("Defaults", KEY_AUTODIAL, g_iAutoDial, g_szIniFile);
    g_iOnlyIfIdle = GetPrivateProfileInt("Defaults", KEY_ONLYIFIDLE, g_iOnlyIfIdle, g_szIniFile);
    g_iEmailNotify = GetPrivateProfileInt("Defaults", KEY_EMAILNOTIFY, g_iEmailNotify, g_szIniFile);
    g_iChangesOnly = GetPrivateProfileInt("Defaults", KEY_CHANGESONLY, g_iChangesOnly, g_szIniFile);
    g_iDownloadLevels = GetPrivateProfileInt("Defaults", KEY_DOWNLOADLEVELS, g_iDownloadLevels, g_szIniFile);
    g_iFollowLinks = GetPrivateProfileInt("Defaults", KEY_FOLLOWLINKS, g_iFollowLinks, g_szIniFile);
    g_iImages = GetPrivateProfileInt("Defaults", KEY_IMAGES, g_iImages, g_szIniFile);
    g_iSoundAndVideo = GetPrivateProfileInt("Defaults", KEY_SOUNDANDVIDEO, g_iSoundAndVideo, g_szIniFile);
    g_iCraplets = GetPrivateProfileInt("Defaults", KEY_CRAPLETS, g_iCraplets, g_szIniFile);
    g_iMaxDownloadK = GetPrivateProfileInt("Defaults", KEY_MAXDOWNLOADK, g_iMaxDownloadK, g_szIniFile);
    GetPrivateProfileString("Defaults", KEY_SCHEDULENAME, "Auto", g_szScheduleName, DIM(g_szScheduleName), g_szIniFile);
}

void WriteDefaults()
{
    char szValue[256];

    printf("Writing defaults to [Defaults]...\n");
    
    sprintf(szValue, "%d", g_iAutoDial);
    WritePrivateProfileString("Defaults", KEY_AUTODIAL, szValue, g_szIniFile);
    
    sprintf(szValue, "%d", g_iOnlyIfIdle);    
    WritePrivateProfileString("Defaults", KEY_ONLYIFIDLE, szValue, g_szIniFile);

    sprintf(szValue, "%d", g_iEmailNotify);    
    WritePrivateProfileString("Defaults", KEY_EMAILNOTIFY, szValue, g_szIniFile);
    
    sprintf(szValue, "%d", g_iChangesOnly);    
    WritePrivateProfileString("Defaults", KEY_CHANGESONLY, szValue, g_szIniFile);

    sprintf(szValue, "%d", g_iDownloadLevels);    
    WritePrivateProfileString("Defaults", KEY_DOWNLOADLEVELS, szValue, g_szIniFile);

    sprintf(szValue, "%d", g_iFollowLinks);    
    WritePrivateProfileString("Defaults", KEY_FOLLOWLINKS, szValue, g_szIniFile);

    sprintf(szValue, "%d", g_iImages);    
    WritePrivateProfileString("Defaults", KEY_IMAGES, szValue, g_szIniFile);

    sprintf(szValue, "%d", g_iSoundAndVideo);    
    WritePrivateProfileString("Defaults", KEY_SOUNDANDVIDEO, szValue, g_szIniFile);

    sprintf(szValue, "%d", g_iCraplets);    
    WritePrivateProfileString("Defaults", KEY_CRAPLETS, szValue, g_szIniFile);

    sprintf(szValue, "%d", g_iMaxDownloadK);    
    WritePrivateProfileString("Defaults", KEY_MAXDOWNLOADK, szValue, g_szIniFile);

    WritePrivateProfileString("Defaults", KEY_SCHEDULENAME, "Auto", g_szIniFile);
}

int _cdecl main(int argc, char** argv)
{
    HRESULT hr                    = NOERROR;
    char    szSection[256];
    char    szURL[1024];
    char    szValue[256];
    char    *pszSection            = NULL;

    if(argc < 2)
    {
        ErrorExit("Usage:  ripsubs filename.ini\n\n");
    }

    // ********************************************************
    // 1. Remember the INI filename passed on the command line:
    // ********************************************************
//    _getcwd(g_szIniFile, MAX_PATH);
//  if(g_szIniFile[strlen(g_szIniFile)-1] != '\\')
//        lstrcat(g_szIniFile, "\\");
//    lstrcat(g_szIniFile, argv[1]);
    lstrcpy(g_szIniFile, argv[1]);
    printf("Dumping to %s...\n", g_szIniFile);


    // ********************************************************
    // 2. Handle defaults
    // ********************************************************

    // Read in defaults if present:
    ReadDefaults();

    // Write back defaults (will create if none existed)
    WriteDefaults();

    // ********************************************************
    // 3. Initialize COM
    // ********************************************************
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        ErrorExit("CoInitialize failed with hr = %08x\n", hr);
    }
    else {
        g_fComInited = TRUE;
    }


    // ********************************************************
    // 4. Get the NotificationMgr
    // ********************************************************
    printf("Creating Notification Manager...\n");
    hr = CoCreateInstance(CLSID_StdNotificationMgr, NULL, CLSCTX_INPROC_SERVER, IID_INotificationMgr, (void**)&g_pNotfMgr);
    if (FAILED(hr))
    {
        ErrorExit("CoCreate failed on notification manager with hr = %08x\n", hr);
    }

    // ********************************************************
    // 5. Get the SubscriptionMgr
    // ********************************************************
    printf("Creating Subscription Manager...\n");
    hr = CoCreateInstance(CLSID_SubscriptionMgr, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_ISubscriptionMgr, 
                          (void **)&g_pSubsMgr);
    if (FAILED(hr))
    {
        ErrorExit("CoCreate failed on subscription manager with hr = %08x\n", hr);
    }


    // ********************************************************
    // 6. Get an enumerator for all notifications:
    // ********************************************************
    printf("Enumerating all notifications...\n");
    hr = g_pNotfMgr->GetEnumNotification(0, &g_pEnumNotfs);
    if (FAILED(hr))
    {
        ErrorExit("Failed to get notification enumerator: hr = %08x\n", hr);
    }


    ULONG                ulNumRet    = -1;
    NOTIFICATIONITEM    ni;
    SUBSCRIPTIONINFO    si;
    VARIANT                varOut;
    FILETIME            ftTime;

    do
    {
        memset(&ni, 0, sizeof(NOTIFICATIONITEM));
        ni.cbSize = sizeof(NOTIFICATIONITEM);

        memset(&si, 0, sizeof(SUBSCRIPTIONINFO));
        si.cbSize = sizeof(SUBSCRIPTIONINFO);

        hr = g_pEnumNotfs->Next(1, &ni, &ulNumRet);

        if(ulNumRet == 0)
            break;

        if(FAILED(hr))
        {
            ErrorExit("Error getting Next notification: hr = %08x", hr);
        }

        // ********************************************************
        // 7. Look into the property map for this notf and get the URL:
        // ********************************************************
        hr = ni.pNotification->QueryInterface(IID_IPropertyMap, (void**) &g_pPropMap);

        if(FAILED(hr))
        {
            ErrorExit("Error QIing for property map: hr = %08x", hr);
        }

        VariantInit(&varOut);
        hr = g_pPropMap->Read(L"URL", &varOut);


        // ********************************************************
        // 8. Get the SUBSCRIPTIONINFO struct for this URL:
        // ********************************************************
        si.fUpdateFlags = 0xffffffff;
        hr = g_pSubsMgr->GetSubscriptionInfo(varOut.bstrVal, &si);
        if(FAILED(hr))
        {
            ErrorExit("Error obtaining subscription info: hr = %08x", hr);
        }


        // ********************************************************
        // 9. Write the section info for this URL to the ini file:
        // ********************************************************
    
        // Grab the system time to build a unique section name:
        GetSystemTimeAsFileTime(&ftTime);

        switch(si.subType)
        {
            case SUBSTYPE_URL:
                    sprintf(szSection, "U%x%x", ftTime.dwHighDateTime, ftTime.dwLowDateTime);
                    break;

            case SUBSTYPE_CHANNEL:
                    sprintf(szSection, "C%x%x", ftTime.dwHighDateTime, ftTime.dwLowDateTime);
                    break;
        };
        sprintf(szURL, "%S", varOut.bstrVal);
        WritePrivateProfileString(
            szSection,
            "URL",
            szURL,
            g_szIniFile);

        // Write the URL name:
        sprintf(szURL, "%S", si.bstrFriendlyName);
        WritePrivateProfileString(
            szSection,
            "Name",
            szURL,
            g_szIniFile);

        switch(si.schedule)
        {
            case SUBSSCHED_DAILY:
                    sprintf(szValue, "Daily");
                    break;

            case SUBSSCHED_WEEKLY:
                    sprintf(szValue, "Weekly");
                    break;

            case SUBSSCHED_MANUAL:
                    sprintf(szValue, "Manual");
                    break;

            default:
                    sprintf(szValue, "Auto");
                    break;
        }
        sprintf(szURL, "%S", varOut.bstrVal);
        WritePrivateProfileString(
            szSection,
            "ScheduleName",
            szValue,
            g_szIniFile);


        // For the rest of the attributes, compare to default values before writing:
        
        BOOL bTemp;
        int i;

        i = (si.fTaskFlags & TASK_FLAG_RUN_IF_CONNECTED_TO_INTERNET) ? 1 : 0;
        if(g_iAutoDial != i)
        {
            sprintf(szValue, "%d", i);
            WritePrivateProfileString(
                szSection,
                "AutoDial",
                "1",
                g_szIniFile);
        }

        i = (si.fTaskFlags & TASK_FLAG_START_ONLY_IF_IDLE) ? 1 : 0;
        if(g_iOnlyIfIdle != i)
        {
            sprintf(szValue, "%d", i);
            WritePrivateProfileString(
                szSection,
                "OnlyIfIdle",
                "1",
                g_szIniFile);
        }

            
        bTemp = (g_iEmailNotify) ? TRUE : FALSE;
        if(bTemp != si.bMailNotification)
        {
            i = si.bMailNotification==TRUE ? 1 : 0;
            sprintf(szValue, "%d", i);
            WritePrivateProfileString(
                szSection,
                "EMailNotify",
                szValue,
                g_szIniFile);
        }

        bTemp = (g_iChangesOnly) ? TRUE : FALSE;
        if(bTemp != si.bChangesOnly)
        {
            i = si.bChangesOnly==TRUE ? 1 : 0;
            sprintf(szValue, "%d", i);
            WritePrivateProfileString(
                szSection,
                "ChangesOnly",
                szValue,
                g_szIniFile);
        }

        if(g_iDownloadLevels != (int) si.dwRecurseLevels)
        {
            sprintf(szValue, "%d", i);
            WritePrivateProfileString(
                szSection,
                "DownloadLevels",
                szValue,
                g_szIniFile);
        }

        i = (si.fWebcrawlerFlags & WEBCRAWL_LINKS_ELSEWHERE) ? 1 : 0;
        if(i != g_iFollowLinks)
        {
            sprintf(szValue, "%d", i);
            WritePrivateProfileString(
                szSection,
                "FollowLinks",
                szValue,
                g_szIniFile);
        }

        i = (si.fWebcrawlerFlags & WEBCRAWL_GET_IMAGES) ? 1 : 0;
        if(i != g_iImages)
        {
            sprintf(szValue, "%d", i);
            WritePrivateProfileString(
                szSection,
                "Images",
                szValue,
                g_szIniFile);
        }

        i = (si.fWebcrawlerFlags & (WEBCRAWL_GET_VIDEOS | WEBCRAWL_GET_BGSOUNDS)) ? 1 : 0;
        if(i != g_iSoundAndVideo)
        {
            sprintf(szValue, "%d", i);
            WritePrivateProfileString(
                szSection,
                "SoundAndVideo",
                szValue,
                g_szIniFile);
        }

        i = (si.fWebcrawlerFlags & WEBCRAWL_GET_CONTROLS) ? 1 : 0;
        if(i != g_iCraplets)
        {
            sprintf(szValue, "%d", i);
            WritePrivateProfileString(
                szSection,
                "Craplets",
                szValue,
                g_szIniFile);
        }

        if(g_iMaxDownloadK != (int) si.dwMaxSizeKB)
        {
            sprintf(szValue, "%d", si.dwMaxSizeKB);
            WritePrivateProfileString(
                szSection,
                "MaxDownloadK",
                szValue,
                g_szIniFile);
        }

        VariantClear(&varOut);
        ni.pNotification->Release();
        
        if(g_pPropMap)
        {
            g_pPropMap->Release();
            g_pPropMap = NULL;
        }
        Sleep(50);
    }
    while(TRUE);

    // ********************************************************
    // 10. Clean Up and exit
    // ********************************************************
    CleanUp();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\test\trackvw\trackvw.h ===
// Include File for ihtest.cpp
#define TRACKMENU                       101
#define ID_EXIT                			40001
#define ID_REFRESH						40002
#define IDC_STATIC                      -1

#define MY_CACHE_ENTRY_INFO_SIZE    2048
#define MY_MAX_STRING_LEN 			512

class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : GlobalAlloc(GPTR, cBytes);
        m_fGlobalAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fGlobalAlloc) GlobalFree(m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fGlobalAlloc:1;
};

#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

//
// Note: allocate lstrlenW(widestr) * 2 because its possible for a UNICODE 
// character to map to 2 ansi characters this is a quick guarantee that enough
// space will be allocated.
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\test\trackvw\trackvw.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <inetreg.h>
#include <stdio.h>
#include <wininet.h>
#include "trackvw.h"

//Helper functions
BOOL ListTreeView(HWND hwnd);
BOOL ListEditView(HWND hwnd, LPSTR lpUrl);

LRESULT CALLBACK WndProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam);

//extern HINSTANCE g_hinst;
static char lpPfx[] = "Log:";

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
    static char szAppName[] = "UrlTrack Cache Viewer";
    HWND hwnd;
    MSG msg;
    WNDCLASSEX wndclass;
    HACCEL hAccel;
    
    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WndProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH) GetStockObject (GRAY_BRUSH);
    wndclass.lpszMenuName = MAKEINTRESOURCE(TRACKMENU);
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

    RegisterClassEx(&wndclass);

    hwnd = CreateWindow(szAppName, szAppName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, NULL, NULL, hInstance, NULL);

    ShowWindow(hwnd, iCmdShow);
    UpdateWindow(hwnd);

    hAccel = LoadAccelerators (hInstance, "TrackVw");

    while(GetMessage(&msg, NULL, 0, 0))
    {
        if(!TranslateAccelerator(hwnd, hAccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return msg.wParam;
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    static HINSTANCE hInstance;
    static HWND hwndTreeView, hwndEdit = NULL;
    RECT rcClientWnd, rcTreeWnd, rcEditWnd = {0};

    switch(iMsg)
    {
        case WM_CREATE:
        {
            OleInitialize(NULL);
            InitCommonControls();
            hInstance = ((LPCREATESTRUCT) lParam)->hInstance;
            GetClientRect(hwnd, &rcClientWnd);
            rcTreeWnd.right = rcClientWnd.right / 2; // Set the right edge for the Tree control to one half the client window space
            rcTreeWnd.bottom = rcClientWnd.bottom;
            rcEditWnd.left = rcTreeWnd.right + 5; // Leave space from the left frame for the resize bar
            rcEditWnd.right = rcClientWnd.right - (rcTreeWnd.right + 5);
            rcEditWnd.bottom = rcClientWnd.bottom;

            hwndTreeView = CreateWindow(WC_TREEVIEW, "", WS_VISIBLE | WS_CHILD 
                | TVS_HASLINES | WS_BORDER | TVS_SHOWSELALWAYS, 0, 0, rcTreeWnd.right, 
                rcTreeWnd.bottom, hwnd, (HMENU) 1, hInstance, NULL);
            if (!hwndTreeView)
                break;
            ShowWindow(hwndTreeView, SW_SHOW);
            
            hwndEdit = CreateWindow("EDIT", NULL, WS_BORDER | WS_VISIBLE | WS_CHILD
                | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE, rcEditWnd.left, 0,
                rcEditWnd.right, rcEditWnd.bottom, hwnd, (HMENU) 2, hInstance, NULL);
            if (!hwndEdit)
                break;
            ShowWindow(hwndEdit, SW_SHOW);

            if (!ListTreeView(hwndTreeView))
                break;

            SetFocus(hwndTreeView);           
            return 0;
        }

        case WM_SIZE:
        {
            GetClientRect(hwnd, &rcClientWnd);
            rcTreeWnd.right = rcClientWnd.right / 2; // Set the right edge for the Tree control to one half the client window space
            rcTreeWnd.bottom = rcClientWnd.bottom;
            rcEditWnd.left = rcTreeWnd.right + 3; // Leave space from the left frame for the resize bar
            rcEditWnd.right = rcClientWnd.right - (rcTreeWnd.right + 5);
            rcEditWnd.bottom = rcClientWnd.bottom;

            SetWindowPos(hwndTreeView, HWND_TOP, 0, 0, rcTreeWnd.right, rcTreeWnd.bottom, 
                SWP_SHOWWINDOW);
            SetWindowPos(hwndEdit, HWND_TOP, rcEditWnd.left, 0, rcEditWnd.right, 
                rcEditWnd.bottom, SWP_SHOWWINDOW);

            break;
        }
        
        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
                case ID_EXIT:
                {
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return 0;
                }
                case ID_REFRESH:
                {
                    TreeView_DeleteAllItems(hwndTreeView);
                    if (!ListTreeView(hwndTreeView))
                        break;
                }
                   
            }
            break;
        }

        case WM_NOTIFY:
        {
            switch (((LPNMHDR)lParam)->code)
            {
                case TVN_SELCHANGED:
                {
                    // Get the Text of the URL which was selected, add our prefix to it
                    // and get the CacheEntryInfo for the URL. Then open the file it points to
                    // and display the contents in the edit window.
                    char lpTempBuf[MY_MAX_STRING_LEN];
                    char lpUrl[MY_MAX_STRING_LEN];

                    ((NM_TREEVIEW *)lParam)->itemNew.mask = TVIF_TEXT;
                    ((NM_TREEVIEW *)lParam)->itemNew.pszText = lpTempBuf;
                    ((NM_TREEVIEW *)lParam)->itemNew.cchTextMax = MY_MAX_STRING_LEN;
                    TreeView_GetItem(hwndTreeView, &((NM_TREEVIEW *)lParam)->itemNew);

                    lstrcpy(lpUrl, lpPfx);
                    lstrcat(lpUrl, ((NM_TREEVIEW *)lParam)->itemNew.pszText);
					ListEditView(hwndEdit, lpUrl);                                        
                    break;

                }   //TVN_SELCHANGED
            }
            
            break;
        }
        case WM_DESTROY:
        {
            OleUninitialize();
            PostQuitMessage(0);
            return 0;
        }
    }
    return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

BOOL ListTreeView(HWND hwnd)
{
    LPSTR                       lpUrl = NULL;
    BYTE                        cei[MY_CACHE_ENTRY_INFO_SIZE];
    LPINTERNET_CACHE_ENTRY_INFO lpCE = (LPINTERNET_CACHE_ENTRY_INFO)cei;
    HTREEITEM                   htItem = NULL;
    DWORD                       cbSize = MY_CACHE_ENTRY_INFO_SIZE;    
    HANDLE                      hCacheEntry = NULL;
    TV_ITEM                     tvi = {0};
    TV_INSERTSTRUCT             tvins = {0};
            
    hCacheEntry = FindFirstUrlCacheEntry(lpPfx, lpCE, &cbSize);

    if (!hCacheEntry)
        return FALSE;

	// sanity check
	char	sztmp[10];
	lstrcpyn(sztmp, lpCE->lpszSourceUrlName, lstrlen(lpPfx)+1);
	if (lstrcmpi(sztmp, lpPfx))
	{
		FindCloseUrlCache(hCacheEntry);
		return TRUE;
	}

    lpUrl = (LPSTR)GlobalAlloc(GPTR, MY_MAX_STRING_LEN);

    // add the length of the cache prefix string to the source url 
    // name to skip the cache prefix .. was the quickest way to strip
    // the prefix from the url.
    lstrcpy(lpUrl, lpCE->lpszSourceUrlName+lstrlen(lpPfx)); 

    tvi.mask = TVIF_HANDLE | TVIF_TEXT;
    tvi.pszText = lpUrl;
    tvi.cchTextMax = lstrlen(lpUrl);
    tvins.item = tvi;
    tvins.hInsertAfter = TVI_FIRST;
    tvins.hParent = TVI_ROOT;

    TreeView_InsertItem(hwnd, &tvins);

    for ( ; ; )
    {
        cbSize = MY_CACHE_ENTRY_INFO_SIZE;
        if (!FindNextUrlCacheEntry(hCacheEntry, lpCE, &cbSize))
            break;
                    
        lstrcpy(lpUrl, lpCE->lpszSourceUrlName+lstrlen(lpPfx));
        tvi.pszText = lpUrl;
        tvi.cchTextMax = lstrlen(lpUrl);
        tvins.item = tvi;
        tvins.hInsertAfter = TVI_LAST;
        TreeView_InsertItem(hwnd, &tvins);
    }

	FindCloseUrlCache(hCacheEntry);
    htItem = TreeView_GetRoot(hwnd);
    TreeView_SelectItem(hwnd, htItem);
    
    if (lpUrl)
    {
        GlobalFree(lpUrl);
        lpUrl = NULL;
    }

    return TRUE;
}

BOOL ListEditView(HWND hwnd, LPSTR lpUrl)
{
    BYTE cei[MY_CACHE_ENTRY_INFO_SIZE];
	LPINTERNET_CACHE_ENTRY_INFO lpCE = (LPINTERNET_CACHE_ENTRY_INFO)cei;
    DWORD cbSize = MY_CACHE_ENTRY_INFO_SIZE;
    HANDLE hFile = NULL;
    DWORD dwFileSize = 0;

    // erase Edit window content 
    Edit_SetText(hwnd, NULL);
	if(!GetUrlCacheEntryInfo(lpUrl, lpCE, &cbSize))
       return FALSE;

	hFile = CreateFile(lpCE->lpszLocalFileName, GENERIC_READ, 
                       FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    
	if (hFile == INVALID_HANDLE_VALUE)
		return FALSE;
		
	dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == 0)
	{
		CloseHandle(hFile);
		return FALSE;
	}

    LPTSTR  lpBuf;
	DWORD dwBytesRead = 0;	

    lpBuf = (LPTSTR)GlobalAlloc(LPTR, dwFileSize);
    if (!lpBuf)
    {
        CloseHandle(hFile);
        return FALSE;
    }

    if (!ReadFile(hFile, lpBuf, dwFileSize, &dwBytesRead, NULL) || dwBytesRead == 0)
    {
        CloseHandle(hFile);
        return FALSE;
    }


    /*
    // First to avoid displaying any leading spaces we'll walk through the file
    // we find the first non space character. When we find it, we'll set the file
    // pointer back 1 so the next time we call ReadFile getting the next byte we'll
    // be at the non-space character.                        
	DWORD dwBytesRead = 0;	
	char ch; 

    do
	{                        
		if (!ReadFile(hFile, &ch, 1, &dwBytesRead, NULL))
		{        
			CloseHandle(hFile);
			return FALSE;
		}           
        
		if (dwBytesRead == 0)	// reach end-of-file, return now.
		{
			CloseHandle(hFile);
			return TRUE;
		}
	}
	while (ch == ' ');
    if (ch != ' ')
        SetFilePointer(hFile, -1, NULL, FILE_CURRENT);
                        
    // Alloc a buffer large enough for the file plus 2 characters per line                    
    LPSTR lpBuffer = NULL;
    lpBuffer = (LPSTR)GlobalAlloc(GPTR, dwFileSize*2);                   
    if (!lpBuffer)
	{
		CloseHandle(hFile);
		return FALSE;
	}

	//lpBuffer = "\0";
	cbSize = 0;
	int	 cch = 0;
	BOOL bIsLeadChar = FALSE;
	BOOL bIsSecondChar = FALSE;
    char tmp[1024];
	LPSTR lpTmp = lpBuffer;
	tmp[0] = '\0';
	// N 1 08-19-1997 15:28:45 00:00:05\r\nN 1 08-19-1997 15:30:25 00:00:01
    for (;;)
	{
		if (!ReadFile(hFile, &ch, 1, &dwBytesRead, NULL))
		{
			// choked here,
			CloseHandle(hFile);
			GlobalFree(lpBuffer);
			return FALSE;
		}

		if (dwBytesRead == 0)		// reach end-of-file
			break;
                                
		switch (ch)
		{
		case '\n':
			wsprintf(tmp, "%c\r\n", ch);
			lstrcat(lpBuffer, tmp);
			break;

		case ' ':
			tmp[cch] = ch;
			cch ++;

			if (bIsLeadChar && bIsSecondChar)
			{
				if (cch == 5)
				{
					lpTmp[cbSize ++] = '\r';
					lpTmp[cbSize ++] = '\n';
					for (int i=1; i<cch; i++)
						lpTmp[cbSize ++] = tmp[i];
					cch = 0;
				}
				bIsLeadChar = FALSE;
				bIsSecondChar = FALSE;
			}

			break;

		case 'N':
		case 'S':
		case 'D':
		case 'T':
		case 'U':
			bIsLeadChar = (bIsSecondChar) ? FALSE : TRUE;

			tmp[cch] = ch;
			cch ++;
			break;

		case '1':
		case '0':
			bIsSecondChar = (bIsLeadChar) ? TRUE : FALSE;

			tmp[cch] = ch;
			cch ++;
			break;

		default:
			tmp[cch] = ch;
			cch ++;
			
			for (int i=0; i<cch; i++)
				lpTmp[cbSize++] = tmp[i];
	
			cch = 0;
			break;
	
        } 
    
	}
	lpTmp[cbSize] = '\0';
*/
    Edit_SetText(hwnd, lpBuf);
                        
    CloseHandle(hFile);
    if (lpBuf)
        GlobalFree(lpBuf);

	return TRUE;
}
/*
            // No need to read the cache prefix from the registry so we'll hard code it Log:
            //lpPfx = (LPSTR)GlobalAlloc(GPTR, lstrlen("Log:")+1);
            //lstrcpy(lpPfx, "Log:");
#if 0
            lret = RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_TRACKING, 0,
                KEY_READ, &hKey);
            if (lret != ERROR_SUCCESS)
            {
                lret = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_TRACKING, 0,
                    KEY_READ, &hKey);
            }

            if (lret == ERROR_SUCCESS)
            {
                lret = RegQueryValueEx(hKey, REGSTR_VAL_CACHEPREFIX, 0, NULL, NULL, &cbPfx);
                
                if (lret == ERROR_SUCCESS)
                {
                    lpPfx = (LPSTR)GlobalAlloc(GPTR, cbPfx+1);
                    if (lpPfx)
                    {
                        lret = RegQueryValueEx(hKey, REGSTR_VAL_CACHEPREFIX, 0, NULL, 
                            (LPBYTE)lpPfx, &cbPfx);
                    }
                }
            }
            if (hKey)
            {
                RegCloseKey(hKey);
                hKey = NULL;
            }
#endif //0
/////////////////////////////////////////////////////////////////////////////
// Function: Hacked ModuleEntry for sources file
/////////////////////////////////////////////////////////////////////////////
HANDLE g_hProcessHeap = NULL;

extern "C" int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPTSTR pszCmdLine;

    pszCmdLine = GetCommandLine();

    g_hProcessHeap = GetProcessHeap();

    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == TEXT('\"') ) {
    //
    // Scan, and skip over, subsequent characters until
    // another double-quote or a null is encountered.
    //
    while ( *++pszCmdLine && (*pszCmdLine
         != TEXT('\"')) );
    //
    // If we stopped on a double-quote (usual case), skip
    // over it.
    //
    if ( *pszCmdLine == TEXT('\"') )
        pszCmdLine++;
    }
    else {
    while (*pszCmdLine > TEXT(' '))
        pszCmdLine++;
    }

    //
    // Skip past any white space preceeding the second token.
    //
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
    pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
           si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    // Since we now have a way for an extension to tell us when it is finished,
    // we will terminate all processes when the main thread goes away.

    ExitProcess(i);

    // DebugMsg(DM_TRACE, TEXT("c.me: Cabinet main thread exiting without ExitProcess."));

    return i;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\test\upnow\upnow.cpp ===
#include <windows.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shguidp.h>
#include <msnotify.h>
#include <subsmgr.h>
#include <chanmgr.h>
#include <chanmgrp.h>
#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <wininet.h>
#include <winineti.h>

#define DIM(x)              (sizeof(x) / sizeof(x[0]))
#define DEFAULT_INTERVAL    15
#define GUIDSTR_MAX         (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

EXTERN_C const CLSID CLSID_OfflineTrayAgent;

BOOL              g_fComInited = FALSE;
INotificationMgr *g_pNotfMgr = NULL;
int               g_Interval = DEFAULT_INTERVAL;
char              g_szCachePath[MAX_PATH] = "";

void CleanUp()
{
    if (g_pNotfMgr)
    {
        g_pNotfMgr->Release();
        g_pNotfMgr = NULL;
    }

    if (g_fComInited)
    {
        CoUninitialize();
    }
}

void ErrorExit(char *fmt, ...)
{
    va_list va;

    va_start(va, fmt);
    vprintf(fmt, va);

    CleanUp();
    exit(1);
}


void UpdateNow()
{
    HRESULT hr;
    INotification *pNotification;
    IEnumNotification *pEnumNotification;
    ULONG count;
    NOTIFICATIONITEM items[1024];

    if (g_szCachePath[0])
    {
        printf("Emptying cache from %s...\n", g_szCachePath);
        FreeUrlCacheSpace(g_szCachePath, 100, 0 /*remove all*/);
    }

    printf("Updating all subscriptions...\n");

    hr = g_pNotfMgr->GetEnumNotification(0/*grfFlags*/, &pEnumNotification);

    if (FAILED(hr))
    {
        ErrorExit("Failed to get notification enumerator - hr = %08x\n", hr);
    }

    hr = pEnumNotification->Next(DIM(items), items, &count);

    if (FAILED(hr))
    {
        ErrorExit("Failed to enumerate notifications - hr = %08x\n", hr);
    }

    if (!count)
    {
        printf("There are no subscriptions to update!\n");
        return;
    }
    
    printf("There are %ld subscriptions to update...\n", count);

    BSTR bstrGuids = SysAllocStringLen(NULL, GUIDSTR_MAX * count);
    if (!bstrGuids)
    {
        ErrorExit("Error allocating bstrGuids\n");
    }

    bstrGuids[0] = L'\0';

    for (ULONG i = 0; i < count; i++)
    {
        WCHAR   wszCookie[GUIDSTR_MAX];
        int l = StringFromGUID2(items[i].NotificationCookie, wszCookie, DIM(wszCookie));

        assert(l == GUIDSTR_MAX);
        StrCatW(bstrGuids, wszCookie);
        
        if (items[i].pNotification)
        {
            items[i].pNotification->Release();
        }
    }
    
    hr = g_pNotfMgr->CreateNotification(NOTIFICATIONTYPE_AGENT_START, 
                                        0,
                                        NULL,
                                        &pNotification,
                                        0);
    if (FAILED(hr))
    {
        ErrorExit("Failed to create notification - hr = %08x\n", hr);
    }

    VARIANT Val;

    Val.vt = VT_BSTR;
    Val.bstrVal = bstrGuids;

    hr = pNotification->Write(L"Guids Array", Val, 0);

    SysFreeString(bstrGuids);

    if (FAILED(hr))
    {
        ErrorExit("Failed to write Guids Array property - hr = %08x\n", hr);
    }

    hr = g_pNotfMgr->DeliverNotification(pNotification, CLSID_OfflineTrayAgent,
                                         0, NULL, NULL, 0);

    pNotification->Release();

    if (FAILED(hr))
    {
        ErrorExit("Failed to deliver notification - hr = %08x\n", hr);
    }
}

void Wait()
{
    #define HASH_AT 5000
    
    DWORD dwNow = GetTickCount();
    DWORD dwNextHash = dwNow + HASH_AT;
    DWORD dwNextMin = dwNow + 1000 * 60;
    DWORD dwStopTick = dwNow + (g_Interval * 1000 * 60);
    int minToGo = g_Interval;

    printf("Waiting %d minutes.", g_Interval);
    do
    {
        //  Not exactly fool proof accuracy but it will do
        if (dwNow > dwNextHash)
        {
            printf(".");
            dwNextHash += HASH_AT;
        }

        if (dwNow > dwNextMin)
        {
            printf("\n%d minutes to go.", --minToGo);
            dwNextMin += 1000 * 60;
        }

        Sleep(1000);

        dwNow = GetTickCount();
    }
    while (dwStopTick > dwNow);
    
    printf("\n");
}

int _cdecl main(int argc, char **argv)
{
    if (argc > 1)
    {
        int interval = atoi(argv[1]);

        if (interval)
        {
            g_Interval = interval;
            printf("Interval is set to %d minutes\n", g_Interval);
        }
        else
        {
            printf("Invalid interval specified on command line - must be integer > 0\n");
            printf("Using default of %d minutes\n", g_Interval);
        }
    }
    else
    {
        printf("No interval specified on command line\n");
        printf("Using default of %d minutes\n", g_Interval);
    }
    
    printf("Initializing COM...\n");
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        ErrorExit("CoInitialize failed with hr = %08x\n", hr);
    }

    printf("Creating Notification Manager...\n");
    hr = CoCreateInstance(CLSID_StdNotificationMgr, NULL, CLSCTX_INPROC_SERVER, IID_INotificationMgr, (void**)&g_pNotfMgr);
    if (FAILED(hr))
    {
        ErrorExit("CoCreate failed on notification manager with hr = %08x\n", hr);
    }

    g_fComInited = TRUE;

    HKEY hkey;

    LONG l = RegOpenKeyEx(HKEY_CURRENT_USER, 
                          "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
                          0,
                          KEY_READ,
                          &hkey);

    if (l == ERROR_SUCCESS)
    {                           
        DWORD dwSize = DIM(g_szCachePath);
        if (RegQueryValueEx(hkey, "Cache", NULL, NULL, (LPBYTE)g_szCachePath, &dwSize) != ERROR_SUCCESS)
        {
            printf("Uh-oh - couldn't get cache path...\n");
        }
        
        RegCloseKey(hkey);
    }

    while (1)
    {
        UpdateNow();
        Wait();
    }
    
    CleanUp();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webfldrs\sources.inc ===
#
# The Office WebFolders shell namespace extension is provided by the 
# office team as a single MSI installer package (WEBFLDRS.MSI).
# There are no binaries to build so we just need to binplace the
# MSI file.  
#
TARGETNAME=webfldrs
TARGETPATH=obj
TARGETTYPE=NOTARGET

SOURCES=

!IF $(386) 
!ifdef WEBFOLDERS_X86
MISCFILES=i386\webfldrs.msi
!endif
!ENDIF

!IF $(AMD64) 
!ifdef WEBFOLDERS_AMD64
MISCFILES=ia64\webfldrs.msi
!endif
!ENDIF

!IF $(IA64) 
!ifdef WEBFOLDERS_IA64
MISCFILES=ia64\webfldrs.msi
!endif
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\atlwraps.h ===
//-------------------------------------------------------------------------//
// atlwraps.h : API Wrap decls
//-------------------------------------------------------------------------//

#ifndef __ATLWRAPS_H__
#define __ATLWRAPS_H__

#define wsprintfW           wsprintfWrapW
#define GetClassInfoExW     GetClassInfoExWrapW

#endif __ATLWRAPS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webcheck\test\schedcdf\schedcdf.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <urlmon.h>
#include <msnotify.h>
#include <webcheck.h>
#include <wininet.h>
#include <mstask.h>
#include <inetreg.h>
#include "schedcdf.h"

LRESULT CALLBACK WndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
// This is where we do most of the actual work
void StartOperation(LPSTR lpCDFName);
// Our Dialog Proc function for the Use Other CDF dialog
BOOL CALLBACK UseOtherCDFDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

// Helper Functions
HRESULT WriteDWORD(IPropertyMap *pPropertyMap, LPWSTR szName, DWORD dwVal);
HRESULT WriteBSTR(IPropertyMap *pPropertyMap, LPWSTR szName, LPWSTR szVal);
HRESULT WriteLONGLONG(IPropertyMap *pPropertyMap, LPCWSTR szName, LONGLONG llVal);
HRESULT ReadBSTR(IPropertyMap *pPropertyMap, LPWSTR szName, BSTR *bstrRet);
void WriteToScreen(LPSTR lpText, HRESULT hr);
void DBGOut(LPSTR psz);

// Functions called by NotificationSink Object
HRESULT OnBeginReport(INotification *pNotification, INotificationReport *pNotificationReport);
HRESULT OnEndReport(INotification  *pNotification);

HANDLE g_hHeap = NULL;
int g_iActive=0;
int g_BufSize=0;
LPSTR lpEditBuffer;
HINSTANCE hInstance;
HWND hwndEdit;

void DBGOut(LPSTR psz)
{
#ifdef DEBUG
    OutputDebugString("SchedCDF: ");
    OutputDebugString(psz);
    OutputDebugString("\n");
#endif //DEBUG
}

class MySink : public INotificationSink
{
    long m_cRef;
public:
    MySink() { m_cRef = 1; }
    ~MySink() {}

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // INotificationSink members
    STDMETHODIMP         OnNotification(
                INotification          *pNotification,
                INotificationReport    *pNotificationReport,
                DWORD                   dwReserved);
};                

STDMETHODIMP_(ULONG) MySink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) MySink::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP MySink::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_INotificationSink == riid))
        *ppv=(INotificationSink *)this;

    // Addref through the interface
    if( NULL != *ppv ) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

// 
// INotificationSink members
//
STDMETHODIMP MySink::OnNotification(
                INotification          *pNotification,
                INotificationReport    *pNotificationReport,
                DWORD                   dwReserved)
{
    NOTIFICATIONTYPE    nt;
    HRESULT             hr=S_OK;

    DBGOut("SchedCDF sink receiving OnNotification");

    hr = pNotification->GetNotificationInfo(&nt, NULL,NULL,NULL,0);

    if (FAILED(hr))
    {
        DBGOut("Failed to get notification type!");
        return E_INVALIDARG;
    }

    if (IsEqualGUID(nt, NOTIFICATIONTYPE_BEGIN_REPORT))
        hr = OnBeginReport(pNotification, pNotificationReport);
    else if (IsEqualGUID(nt, NOTIFICATIONTYPE_END_REPORT))
        hr = OnEndReport(pNotification);
    else DBGOut("NotSend: Unknown notification type received");

    // Avoid bogus assert
    if (SUCCEEDED(hr)) hr = S_OK;
    
    return hr;
}


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)
{
    static char szAppName[] = "CDF Agent Notification Delivery Tool";
    HWND hwnd;
    MSG msg;
    WNDCLASSEX wndclass;
    HACCEL hAccel;
    
    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WndProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH) GetStockObject (GRAY_BRUSH);
    wndclass.lpszMenuName = MAKEINTRESOURCE(SCHEDCDF);
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

    RegisterClassEx(&wndclass);

    hwnd = CreateWindow(szAppName, szAppName, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, NULL, NULL, hInstance, NULL);

    ShowWindow(hwnd, iCmdShow);
    UpdateWindow(hwnd);

    while(GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return msg.wParam;
}


LRESULT CALLBACK WndProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    MySink *pSink = NULL;
    RECT rcClientWnd;
    HRESULT hr;
    INotificationMgr *pNotificationMgr = NULL;
    LPNOTIFICATION pNotification = NULL;
    NOTIFICATIONITEM NotItem;
    NOTIFICATIONCOOKIE ncCookie;
    TASK_TRIGGER tt;
    TASK_DATA td;
    LPSTR lpBuffer = NULL;
    DWORD dwStartTime = 0;
    MSG msg;
    SYSTEMTIME st;
    ZeroMemory(&tt, sizeof(TASK_TRIGGER));
    ZeroMemory(&td, sizeof(TASK_DATA));
    ZeroMemory(&st, sizeof(SYSTEMTIME));

    switch(iMsg)
    {
    case WM_CREATE:
        {
            OleInitialize(NULL);
            hInstance = ((LPCREATESTRUCT) lParam)->hInstance;

            GetClientRect(hwnd, &rcClientWnd);

            hwndEdit = CreateWindow("EDIT", NULL, WS_BORDER | WS_VISIBLE | WS_CHILD
                | WS_HSCROLL | ES_MULTILINE, 0, 0, rcClientWnd.right, rcClientWnd.bottom,
                hwnd, (HMENU) 1, hInstance, NULL);

            ShowWindow(hwndEdit, SW_SHOW);
            
            lpEditBuffer = NULL;
            // Alloc a 4k buffer for the edit window
            lpEditBuffer = (LPSTR)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, 4096); 
            if (lpEditBuffer)
                g_BufSize = 4096;
                      
            return 0;
        }

    case WM_SIZE:
        {
            GetClientRect(hwnd, &rcClientWnd);
            SetWindowPos(hwndEdit, HWND_TOP, 0, 0, rcClientWnd.right, rcClientWnd.bottom,
                SWP_SHOWWINDOW);
            break;
        }            
    case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
            case ID_EXIT:
                {
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return 0;
                }
            case ID_UPDATESCOPEALL:
                {
                    StartOperation("all.cdf");
                    return 0;
                }
            case ID_UPDATESCOPEOFFLINE:
                {
                    StartOperation("offline.cdf");
                    return 0;
                }
            case ID_UPDATESCOPEONLINE:
                {
                    StartOperation("online.cdf");
                    return 0;
                }
            case ID_UPDATEFRAMESCDF:
                {
                    StartOperation("frames.cdf");
                    return 0;
                }
            case ID_USEOTHERCDF:
                {
                    DialogBox(hInstance, MAKEINTRESOURCE(IDD_OTHER), hwnd, UseOtherCDFDialogProc);
                    return 0;
                }
            }
            break;
        }

    case WM_DESTROY:
        {
            if (lpEditBuffer)
            {
                GlobalFree(lpEditBuffer);
                lpEditBuffer = NULL;
            }                
            PostQuitMessage(0);
            return 0;
        }
        break;
    }
    return DefWindowProc(hwnd, iMsg, wParam, lParam);
}

void StartOperation(LPSTR lpszCDFName)
{
    LONG lret = NULL;
    DWORD cbSize = NULL;
    LPSTR lpszTemp = NULL;
    LPSTR lpszCDFUrlPath = NULL;
    LPSTR lpszCookie = NULL;
    HKEY hKey = NULL;
    MySink *pSink = NULL;
    INotificationMgr *pNotificationMgr = NULL;
    LPNOTIFICATION pNotification = NULL;
    NOTIFICATIONITEM NotItem;
    NotItem.pNotification = NULL;
    NOTIFICATIONCOOKIE ncCookie;
    TASK_TRIGGER tt;
    TASK_DATA td;
    MSG msg;
    SYSTEMTIME st;
    HRESULT hr;
    ZeroMemory(&tt, sizeof(TASK_TRIGGER));
    ZeroMemory(&td, sizeof(TASK_DATA));
    ZeroMemory(&st, sizeof(SYSTEMTIME));
// Hack: To workaround fault that happens when urlmon calls InternetCloseHandle after wininet
// has been unloaded we'll call into wininet first which will hopefully cause it to stay
// around until urlmon is gone.
    DWORD cbPfx = 0;
    HANDLE hCacheEntry = NULL;
    LPINTERNET_CACHE_ENTRY_INFO lpCE = NULL;
    LPSTR lpPfx = NULL;
    lpPfx = (LPSTR)GlobalAlloc(GPTR, lstrlen("Log:")+1);
    lstrcpy(lpPfx, "Log:");
    lpCE = (LPINTERNET_CACHE_ENTRY_INFO)GlobalAlloc(GPTR, 2048);
    ASSERT(lpCE);
    cbSize = 2048;
    hCacheEntry = FindFirstUrlCacheEntry("Log:", lpCE, &cbSize);
    if (lpCE)
    {
        GlobalFree(lpCE);
        lpCE = NULL;
    }
    if (lpPfx)
    {
        GlobalFree(lpPfx);
        lpPfx = NULL;
    }
    cbSize = 0;
// End Hack
    lret = RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_SCHEDCDF, 0,
        KEY_READ | KEY_WRITE, &hKey);

    if (ERROR_SUCCESS != lret)
    {
        lret = RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_SCHEDCDF, 0, NULL, 
            REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hKey, NULL);
    }

    if (ERROR_SUCCESS == lret)
    {
        lret = RegQueryValueEx(hKey, REGSTR_VAL_CDFURLPATH, 0, NULL, NULL, &cbSize);

        if (ERROR_SUCCESS == lret)
        {
            lpszTemp = (LPSTR)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, cbSize+1);
            if (lpszTemp)
            {
                lret = RegQueryValueEx(hKey, REGSTR_VAL_CDFURLPATH, 0, NULL, 
                    (LPBYTE)lpszTemp, &cbSize);
            }
        }
        else // No URL Path to the CDF Found.. use default
        {
            lpszTemp = (LPSTR)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, 
                lstrlen("http://ohserv/users/davidhen/")+1);
            if (lpszTemp)
            {
                lstrcpy(lpszTemp, "http://ohserv/users/davidhen/");
            }
        }

        // Add the CDFName to the Path for the final URL
        lpszCDFUrlPath = (LPSTR)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
            (lstrlen(lpszTemp) + lstrlen(lpszCDFName) + 1));

        lstrcpy(lpszCDFUrlPath, lpszTemp);
        lstrcat(lpszCDFUrlPath, lpszCDFName);

        if (lpszTemp)
        {
            GlobalFree(lpszTemp);
            lpszTemp = NULL;
        }
    }

    if (hKey)
    {
        lret = RegQueryValueEx(hKey, lpszCDFName, 0, NULL, NULL, &cbSize);

        if (ERROR_SUCCESS == lret)
        {
            lpszCookie = (LPSTR)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, cbSize+1);
            if (lpszCookie)
            {
                lret = RegQueryValueEx(hKey, lpszCDFName, 0, NULL, (LPBYTE)lpszCookie,
                    &cbSize);
            }
        }
    }

    do
    {
        hr = CoInitialize(NULL);
        ASSERT(SUCCEEDED(hr));
        
        hr = CoCreateInstance(CLSID_StdNotificationMgr, NULL, CLSCTX_INPROC,
            IID_INotificationMgr, (void**)&pNotificationMgr);
        if (FAILED(hr))
        {
            WriteToScreen("Error: Unable to CoCreateInstance NotificationMgr", NULL);
            WriteToScreen("   CoCreateInstance returned:", hr);
            break;
        }

        ASSERT(pNotificationMgr);

        pSink = new MySink;

        if (lpszCookie)
        {
            // MAKE_WIDEPTR_FROMANSI is a macro which will create a wide string from an ansi string.
            // The first parameter isn't defined before calling and it doesn't need to be freed.
            // (handled by the temp buffer class destructor)
            MAKE_WIDEPTR_FROMANSI(lpwszCookie, lpszCookie);
            // Make a valid cookie from the wide string.
            CLSIDFromString(lpwszCookie, &ncCookie);

            NotItem.cbSize = sizeof(NOTIFICATIONITEM);
            hr = pNotificationMgr->FindNotification(&ncCookie, &NotItem, 0);
            if (SUCCEEDED(hr))
            {
                WriteToScreen("Found Scheduled Notification, Delivering Existing Notification", NULL);
                WriteToScreen("   and waiting for End Report...", NULL);
                hr = pNotificationMgr->DeliverNotification(NotItem.pNotification, CLSID_ChannelAgent,
                    (DELIVERMODE)DM_NEED_COMPLETIONREPORT, pSink, NULL, 0);

                if (FAILED(hr))
                {
                    WriteToScreen("Error 1: Unable to Deliver First Notification", NULL);
                    WriteToScreen("    DeliverNotification returned:", hr);
                    break;
                }
                WriteToScreen("First Notification Delivered. Waiting for End Report...", NULL);

                // Delay until End Report recieved
                g_iActive = 1;
                while (g_iActive && GetMessage(&msg, NULL, 0, 0))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
                SAFERELEASE(NotItem.pNotification);
                // For Debugging purposes we'll find the notification again to verify Task Trigger
                // information for Auto Scheduling
                NotItem.cbSize = sizeof (NOTIFICATIONITEM);
                hr = pNotificationMgr->FindNotification(&ncCookie, &NotItem, 0);
                SAFERELEASE(NotItem.pNotification);
                WriteToScreen("Finished Successfully", NULL);
                break;
            }
            else
            {
                WriteToScreen("Warning, Cookie string found in registry but we were unable to find the", NULL);
                WriteToScreen("    scheduled Notification. Creating a new notification instead", NULL);
                // Because the notification couldn't be found we'll go through the same path as creating
                // a new notification. 
            }
        }

        GetSystemTime(&st);
    
        tt.cbTriggerSize = sizeof(TASK_TRIGGER);
        tt.wBeginYear = st.wYear;
        tt.wBeginMonth = st.wMonth;
        tt.wBeginDay = st.wDay;
        tt.wStartHour = st.wHour;
        tt.wStartMinute = st.wMinute;

        tt.MinutesInterval = 10;
        tt.MinutesDuration = 60;
        tt.Type.Daily.DaysInterval = 1;
        tt.TriggerType = TASK_TIME_TRIGGER_DAILY;
        tt.rgFlags = TASK_FLAG_DISABLED;

        td.cbSize = sizeof(TASK_DATA);
        td.dwTaskFlags = TASK_FLAG_START_ONLY_IF_IDLE;

                        
        hr = pNotificationMgr->CreateNotification(NOTIFICATIONTYPE_AGENT_START,
            (NOTIFICATIONFLAGS) 0, NULL, &pNotification, 0);

        if (FAILED(hr))
        {
            WriteToScreen("Error: Unable to CreateNotification", NULL);
            WriteToScreen("    CreateNotification returned:", hr);
            break;
        }

        ASSERT(pNotification);

        MAKE_WIDEPTR_FROMANSI(lpwszCDFUrl, lpszCDFUrlPath);            

        WriteBSTR(pNotification, L"URL", lpwszCDFUrl);
        WriteDWORD(pNotification, L"Priority", 0);
        WriteDWORD(pNotification, L"RecurseLevels", 2);
        WriteDWORD(pNotification, L"RecurseFlags", (DWORD)WEBCRAWL_LINKS_ELSEWHERE);
        WriteDWORD(pNotification, L"ChannelFlags", (DWORD)CHANNEL_AGENT_DYNAMIC_SCHEDULE);

//        WriteBSTR(pNotification, L"PostURL", L"http://ohserv/scripts/davidhen/davidhen.pl");
//        WriteLONGLONG(pNotification, L"LogGroupID", (LONGLONG)0);
//        WriteDWORD(pNotification, L"PostFailureRetry", 0);
        
        hr = pNotificationMgr->ScheduleNotification(pNotification, CLSID_ChannelAgent,
            &tt, &td, (DELIVERMODE)0, NULL, NULL, NULL, &ncCookie, 0);

        if (FAILED(hr))
        {
            WriteToScreen("Error: ScheduleNotification Failed", NULL);
            WriteToScreen("    ScheduleNotification returned:", hr);
            break;
        }

        // Save the cookie to the registry for future updates to this channel
        if (hKey)
        {
            WCHAR wszCookie[GUIDSTR_MAX];
            StringFromGUID2(ncCookie, wszCookie, sizeof(wszCookie));

            MAKE_ANSIPTR_FROMWIDE(szCookie, wszCookie);

            cbSize = lstrlen(szCookie)+1;
            RegSetValueEx(hKey, lpszCDFName, 0, REG_SZ, (LPBYTE)szCookie, cbSize);
        }
            
        SAFERELEASE(pNotification);

        NotItem.cbSize = sizeof (NOTIFICATIONITEM);
        hr = pNotificationMgr->FindNotification(&ncCookie, &NotItem, 0);

        if (FAILED(hr))
        {
            WriteToScreen("Error 1: Unable to Find Scheduled Notification", NULL);
            WriteToScreen("    FindNotification returned:", hr);
            break;
        }

        hr = pNotificationMgr->DeliverNotification(NotItem.pNotification, CLSID_ChannelAgent,
            (DELIVERMODE)DM_NEED_COMPLETIONREPORT, pSink, NULL, 0);

        if (FAILED(hr))
        {
            WriteToScreen("Error 1: Unable to Deliver First Notification", NULL);
            WriteToScreen("    DeliverNotification returned:", hr);
            break;
        }
        WriteToScreen("First Notification Delivered. Waiting for End Report...", NULL);

        // Delay until End Report recieved
        g_iActive = 1;
        while (g_iActive && GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        SAFERELEASE(NotItem.pNotification);
        NotItem.cbSize = sizeof (NOTIFICATIONITEM);
        hr = pNotificationMgr->FindNotification(&ncCookie, &NotItem, 0);
        if (FAILED(hr))
        {
            WriteToScreen("Error 2: Unable to Find Scheduled Notification", NULL);
            WriteToScreen("    FindNotification returned:", hr);
            break;
        }

        hr = pNotificationMgr->DeliverNotification(NotItem.pNotification, CLSID_ChannelAgent,
            (DELIVERMODE)DM_NEED_COMPLETIONREPORT, pSink, NULL, 0);
               
        if (FAILED(hr))
        {
            WriteToScreen("Error 2: Unable to Deliver First Notification", NULL);
            WriteToScreen("    DeliverNotification returned:", hr);
            break;
        }

        WriteToScreen("Second Notification Delivered. Waiting for End Report ...", NULL);

        // Delay until End Report recieved
        g_iActive = 1;
        while (g_iActive && GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        WriteToScreen("Finished Successfully", NULL);
        break;
    }
    while (TRUE);

    SAFERELEASE(NotItem.pNotification);
    SAFERELEASE(pNotification);
    SAFERELEASE(pSink);
    SAFERELEASE(pNotificationMgr);

    if (hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }
      
    return;
}

BOOL CALLBACK UseOtherCDFDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch (iMsg)
    {
    case WM_INITDIALOG:
        {
            HWND hwndEditBox = GetDlgItem(hDlg, IDC_CDFNAME);
            SetFocus(hwndEditBox);
            return TRUE;
        }
    case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
            case IDOK:
                {
                    int iLength = 0;
                    LPSTR lpszCDFName = NULL;
                    HWND hwndEditBox = GetDlgItem(hDlg, IDC_CDFNAME);
                    iLength = GetWindowTextLength(hwndEditBox);

                    if (0 == iLength)
                    {
                        MessageBox(NULL, "No CDF filename Specified.. Enter CDF filename before selecting OK", "Error", MB_OK);
                        break;
                    }

                    EndDialog(hDlg, 0);
                    lpszCDFName = (LPSTR)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, iLength+1);

                    if (lpszCDFName)
                    {
                        GetWindowText(hwndEditBox, lpszCDFName, iLength+1);

                        StartOperation(lpszCDFName);

                        GlobalFree(lpszCDFName);
                        lpszCDFName = NULL;
                    }
                    return TRUE;
                }
                case IDCANCEL:
                {
                    EndDialog(hDlg, 0);
                    return TRUE;
                }
                break;
            }
        }
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//
// Helper Functions
//

HRESULT WriteDWORD(IPropertyMap *pPropertyMap, LPWSTR szName, DWORD dwVal)
{
    VARIANT Val;

    Val.vt = VT_I4;
    Val.lVal = dwVal;

    return pPropertyMap->Write(szName, Val, 0);
}
    
HRESULT WriteBSTR(IPropertyMap *pPropertyMap, LPWSTR szName, LPWSTR szVal)
{
    VARIANT Val;

    Val.vt = VT_BSTR;
    Val.bstrVal = SysAllocString(szVal);

    HRESULT hr = pPropertyMap->Write(szName, Val, 0);

    SysFreeString(Val.bstrVal);

    return hr;
}

HRESULT WriteLONGLONG(IPropertyMap *pPropertyMap, LPCWSTR szName, LONGLONG llVal)
{
    VARIANT Val;

    Val.vt = VT_CY;
    Val.cyVal = *(CY *)&llVal;

    return pPropertyMap->Write(szName, Val, 0);
}

HRESULT ReadBSTR(IPropertyMap *pPropertyMap, LPWSTR szName, BSTR *bstrRet)
{
    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pPropertyMap->Read(szName, &Val)) &&
            (Val.vt==VT_BSTR))
    {
        *bstrRet = Val.bstrVal;
        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        *bstrRet = NULL;
        return E_INVALIDARG;
    }
}

void WriteToScreen(LPSTR lpText, HRESULT hr)
{
    char tmp[150];
    int BufStrLength = 0;
    int NewStrLength = 0;
    LPSTR lpTempBuf = NULL;
    
    if (!lpEditBuffer)
        return;

    if (hr)
    {
        wsprintf(tmp, "%s %x\r\n", lpText, hr);
    }
    else
    {
        wsprintf(tmp, "%s\r\n", lpText);
    }        

    BufStrLength = lstrlen(lpEditBuffer);
    NewStrLength = lstrlen(tmp);

    if ((BufStrLength + NewStrLength) >= g_BufSize)
    {
        lpEditBuffer = (LPSTR)GlobalReAlloc((HGLOBAL)lpEditBuffer, g_BufSize+4096, GMEM_FIXED | GMEM_ZEROINIT);
        g_BufSize += 4096;
    }
    lstrcat(lpEditBuffer, tmp);

    Edit_SetText(hwndEdit, lpEditBuffer);

}

HRESULT OnBeginReport(INotification *pNotification, INotificationReport *pNotificationReport)
{
    DBGOut("BeginReport received");

    return S_OK;
}

HRESULT OnEndReport(INotification  *pNotification)
{
    DBGOut("EndReport received");

    BSTR bstrEndStatus=NULL;

    ReadBSTR(pNotification, L"StatusString", &bstrEndStatus);

    g_iActive = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\debug.cpp ===
// debug.cpp: declares debug info
#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "webvw"
#define SZ_MODULE           "WEBVW"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\dllload.cpp ===
#include "priv.h"

EXTERN_C {

#include "..\inc\dllload.c"

// --------- NETPLWIZ.DLL ---------------

HINSTANCE g_hinstNETPLWIZ = NULL;

DELAY_LOAD_HRESULT(g_hinstNETPLWIZ, NETPLWIZ.DLL, PubWizard,
            (HWND hwnd, BOOL bTutorial, IDataObject *pDataObject),
            (hwnd, bTutorial, pDataObject));

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\dllreg.cpp ===
// dllreg.cpp -- autmatic registration and unregistration
//
#include "priv.h"
#include <advpub.h>

/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

Returns: 
Cond:    --
*/
HRESULT CallRegInstall(HINSTANCE hinstWebvw, HINSTANCE hinstAdvPack, LPSTR szSection)
{
    HRESULT hr = E_FAIL;

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            STRENTRY seReg[] = {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            hr = pfnri(hinstWebvw, szSection, &stReg);
        }
    }

    return hr;
}


STDAPI RegisterStuff(HINSTANCE hinstWebvw)
{
    HRESULT hr;

    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    hr = CallRegInstall(hinstWebvw, hinstAdvPack, "WebViewInstall");

    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\dxmplay.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0235 */
/* at Tue May 18 20:11:22 1999
 */
/* Compiler settings for dxmplay.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxmplay_h__
#define __dxmplay_h__

/* Forward Declarations */ 

#ifndef __IDSPlayerEx_FWD_DEFINED__
#define __IDSPlayerEx_FWD_DEFINED__
typedef interface IDSPlayerEx IDSPlayerEx;
#endif 	/* __IDSPlayerEx_FWD_DEFINED__ */


#ifndef __IMediaPlayer_FWD_DEFINED__
#define __IMediaPlayer_FWD_DEFINED__
typedef interface IMediaPlayer IMediaPlayer;
#endif 	/* __IMediaPlayer_FWD_DEFINED__ */


#ifndef __IMediaPlayer2_FWD_DEFINED__
#define __IMediaPlayer2_FWD_DEFINED__
typedef interface IMediaPlayer2 IMediaPlayer2;
#endif 	/* __IMediaPlayer2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
//#include "enums.h"
//#include "mpdvd.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxmplay_0000 */
/* [local] */ 


#pragma once

typedef /* [public][uuid] */  DECLSPEC_UUID("66504301-BE0F-101A-8BBB-00AA00300CAB") DWORD VB_OLE_COLOR;

typedef /* [public][helpstring] */ 
enum MPDisplayModeConstants
    {	mpTime	= 0,
	mpFrames	= mpTime + 1
    }	MPDisplayModeConstants;

typedef /* [public][helpstring] */ 
enum MPPlayStateConstants
    {	mpStopped	= 0,
	mpPaused	= mpStopped + 1,
	mpPlaying	= mpPaused + 1,
	mpWaiting	= mpPlaying + 1,
	mpScanForward	= mpWaiting + 1,
	mpScanReverse	= mpScanForward + 1,
	mpClosed	= mpScanReverse + 1
    }	MPPlayStateConstants;

typedef /* [public][helpstring] */ 
enum MPfDialogAvailability
    {	mpfFilePropertiesDlg	= 1,
	mpfGotoDlg	= 2
    }	MPfDialogAvailability;

typedef /* [public][helpstring] */ 
enum MPMoreInfoType
    {	mpShowURL	= 0,
	mpClipURL	= mpShowURL + 1,
	mpBannerURL	= mpClipURL + 1
    }	MPMoreInfoType;

typedef /* [public][helpstring] */ 
enum MPMediaInfoType
    {	mpShowFilename	= 0,
	mpShowTitle	= mpShowFilename + 1,
	mpShowAuthor	= mpShowTitle + 1,
	mpShowCopyright	= mpShowAuthor + 1,
	mpShowRating	= mpShowCopyright + 1,
	mpShowDescription	= mpShowRating + 1,
	mpShowLogoIcon	= mpShowDescription + 1,
	mpClipFilename	= mpShowLogoIcon + 1,
	mpClipTitle	= mpClipFilename + 1,
	mpClipAuthor	= mpClipTitle + 1,
	mpClipCopyright	= mpClipAuthor + 1,
	mpClipRating	= mpClipCopyright + 1,
	mpClipDescription	= mpClipRating + 1,
	mpClipLogoIcon	= mpClipDescription + 1,
	mpBannerImage	= mpClipLogoIcon + 1,
	mpBannerMoreInfo	= mpBannerImage + 1,
	mpWatermark	= mpBannerMoreInfo + 1
    }	MPMediaInfoType;

typedef /* [public][helpstring] */ 
enum MPDisplaySizeConstants
    {	mpDefaultSize	= 0,
	mpHalfSize	= mpDefaultSize + 1,
	mpDoubleSize	= mpHalfSize + 1,
	mpFullScreen	= mpDoubleSize + 1,
	mpFitToSize	= mpFullScreen + 1,
	mpOneSixteenthScreen	= mpFitToSize + 1,
	mpOneFourthScreen	= mpOneSixteenthScreen + 1,
	mpOneHalfScreen	= mpOneFourthScreen + 1
    }	MPDisplaySizeConstants;

typedef /* [public][helpstring] */ 
enum MPReadyStateConstants
    {	mpReadyStateUninitialized	= 0,
	mpReadyStateLoading	= mpReadyStateUninitialized + 1,
	mpReadyStateInteractive	= 3,
	mpReadyStateComplete	= mpReadyStateInteractive + 1
    }	MPReadyStateConstants;

typedef /* [public][helpstring] */ 
enum MPShowDialogConstants
    {	mpShowDialogHelp	= 0,
	mpShowDialogStatistics	= mpShowDialogHelp + 1,
	mpShowDialogOptions	= mpShowDialogStatistics + 1,
	mpShowDialogContextMenu	= mpShowDialogOptions + 1
    }	MPShowDialogConstants;

/* [hidden] */ 
enum PlayerCompatibilityType
    {	cmDefault	= 0,
	cmActiveMovie	= cmDefault + 1,
	cmNetShow	= cmActiveMovie + 1
    };


extern RPC_IF_HANDLE __MIDL_itf_dxmplay_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxmplay_0000_v0_0_s_ifspec;

#ifndef __IDSPlayerEx_INTERFACE_DEFINED__
#define __IDSPlayerEx_INTERFACE_DEFINED__

/* interface IDSPlayerEx */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDSPlayerEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("920F0DE0-91C5-11d1-828F-00C04FC99D4C")
    IDSPlayerEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoContextMenu( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DownloadImage( 
            /* [in] */ BSTR pbstrURL,
            /* [out] */ LONG_PTR __RPC_FAR *phBitmap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutStatusTextEx( 
            /* [in] */ BSTR wszText,
            /* [in] */ BOOL fOverwrite,
            /* [out][in] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushStatusBar( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NavigateBrowserToURL( 
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Document( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *__MIDL_0011) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilePropertiesDialog( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StatisticsDialog( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GotoDialog( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Preview( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestartPlaylist( 
            /* [in] */ BOOL fPlay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutPreviewModeHelper( 
            VARIANT_BOOL PreviewMode,
            BOOL fPlayWhenFinished) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateVisual( 
            /* [in] */ BOOL fUpdateVisual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterEmbeddedObjects( 
            DWORD dwClsContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeEmbeddedObjects( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNativeFrameFlag( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetNativeFrameFlag( void) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UserInteraction( 
            /* [in] */ VARIANT_BOOL bVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddToolTip( 
            /* [in] */ RECT __RPC_FAR *prc,
            /* [in] */ LPTSTR lptsr,
            /* [out] */ int __RPC_FAR *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveToolTip( 
            /* [in] */ int ID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateToolTipRect( 
            /* [in] */ RECT __RPC_FAR *prc,
            /* [in] */ int ID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateToolTipText( 
            /* [in] */ LPTSTR lptsr,
            /* [in] */ int ID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveAs( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSave( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPositionInternal( 
            /* [retval][out] */ double __RPC_FAR *pCurrentPosition) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OpenCloseCounter( 
            /* [retval][out] */ long __RPC_FAR *pOpenCloseCounter) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CompatibilityMode( 
            /* [in] */ long lCompatibilityMode) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CompatibilityMode( 
            /* [retval][out] */ long __RPC_FAR *plCompatibilityMode) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_OnOpenOverride( 
            /* [in] */ VARIANT_BOOL bVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OnOpenOverride( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_OnOpenAutoSize( 
            /* [in] */ VARIANT_BOOL bVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OnOpenAutoSize( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_OnOpenDisplaySize( 
            /* [in] */ long lOnOpenDisplaySize) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OnOpenDisplaySize( 
            /* [retval][out] */ long __RPC_FAR *plOnOpenDisplaySize) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AutoSizeAudioWidth( 
            /* [in] */ long lAutoSizeAudioWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MinimumWidth( 
            /* [retval][out] */ long __RPC_FAR *plMinimumWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EffectiveDisplaySize( 
            /* [retval][out] */ long __RPC_FAR *plEffectiveDisplaySize) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DisplaySizeInternal( 
            /* [in] */ long lDisplaySizeInternal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DisplaySizeInternal( 
            /* [retval][out] */ long __RPC_FAR *plDisplaySizeInternal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DurationInternal( 
            /* [retval][out] */ double __RPC_FAR *pDuration) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SegmentSeek( 
            /* [retval][out] */ long __RPC_FAR *plSegmentSeek) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanSkip( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanSkip) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IEVersion( 
            /* [retval][out] */ LPTSTR __RPC_FAR *ppszVersion) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BrowserIsIE4( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanSkip) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR pbstrURL) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterGraph( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppFilterGraph) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_InShow( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_InChannel( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UpdateVisualCounter( 
            /* [retval][out] */ LONG __RPC_FAR *plVal) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DialogAvailability( 
            /* [retval][out] */ long __RPC_FAR *pDialogAvailability) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopInternal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsBannerFixed( 
            BOOL __RPC_FAR *fFixed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAnimation( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LaunchURLInAnyBrowser( 
            HWND hwnd,
            TCHAR __RPC_FAR *pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GoFullScreen( 
            BOOL bFullScreen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompleteClipFilename( 
            BSTR __RPC_FAR *pbstr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSPlayerExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDSPlayerEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoContextMenu )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DownloadImage )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ BSTR pbstrURL,
            /* [out] */ LONG_PTR __RPC_FAR *phBitmap);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutStatusTextEx )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ BSTR wszText,
            /* [in] */ BOOL fOverwrite,
            /* [out][in] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FlushStatusBar )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NavigateBrowserToURL )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Document )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *__MIDL_0011);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilePropertiesDialog )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StatisticsDialog )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GotoDialog )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Preview )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RestartPlaylist )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ BOOL fPlay);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutPreviewModeHelper )( 
            IDSPlayerEx __RPC_FAR * This,
            VARIANT_BOOL PreviewMode,
            BOOL fPlayWhenFinished);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateVisual )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ BOOL fUpdateVisual);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterEmbeddedObjects )( 
            IDSPlayerEx __RPC_FAR * This,
            DWORD dwClsContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RevokeEmbeddedObjects )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNativeFrameFlag )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetNativeFrameFlag )( 
            IDSPlayerEx __RPC_FAR * This);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserInteraction )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddToolTip )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ RECT __RPC_FAR *prc,
            /* [in] */ LPTSTR lptsr,
            /* [out] */ int __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveToolTip )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ int ID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateToolTipRect )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ RECT __RPC_FAR *prc,
            /* [in] */ int ID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateToolTipText )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ LPTSTR lptsr,
            /* [in] */ int ID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveAs )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanSave )( 
            IDSPlayerEx __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentPositionInternal )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pCurrentPosition);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OpenCloseCounter )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pOpenCloseCounter);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CompatibilityMode )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ long lCompatibilityMode);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CompatibilityMode )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCompatibilityMode);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OnOpenOverride )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OnOpenOverride )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OnOpenAutoSize )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OnOpenAutoSize )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OnOpenDisplaySize )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ long lOnOpenDisplaySize);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OnOpenDisplaySize )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plOnOpenDisplaySize);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoSizeAudioWidth )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ long lAutoSizeAudioWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinimumWidth )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plMinimumWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EffectiveDisplaySize )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plEffectiveDisplaySize);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplaySizeInternal )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ long lDisplaySizeInternal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplaySizeInternal )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plDisplaySizeInternal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DurationInternal )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pDuration);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SegmentSeek )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plSegmentSeek);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CanSkip )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanSkip);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IEVersion )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ LPTSTR __RPC_FAR *ppszVersion);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BrowserIsIE4 )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanSkip);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ BSTR pbstrURL);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FilterGraph )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppFilterGraph);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InShow )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InChannel )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UpdateVisualCounter )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plVal);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialogAvailability )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pDialogAvailability);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopInternal )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsBannerFixed )( 
            IDSPlayerEx __RPC_FAR * This,
            BOOL __RPC_FAR *fFixed);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAnimation )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchURLInAnyBrowser )( 
            IDSPlayerEx __RPC_FAR * This,
            HWND hwnd,
            TCHAR __RPC_FAR *pszPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoFullScreen )( 
            IDSPlayerEx __RPC_FAR * This,
            BOOL bFullScreen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompleteClipFilename )( 
            IDSPlayerEx __RPC_FAR * This,
            BSTR __RPC_FAR *pbstr);
        
        END_INTERFACE
    } IDSPlayerExVtbl;

    interface IDSPlayerEx
    {
        CONST_VTBL struct IDSPlayerExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSPlayerEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDSPlayerEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDSPlayerEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDSPlayerEx_DoContextMenu(This)	\
    (This)->lpVtbl -> DoContextMenu(This)

#define IDSPlayerEx_DownloadImage(This,pbstrURL,phBitmap)	\
    (This)->lpVtbl -> DownloadImage(This,pbstrURL,phBitmap)

#define IDSPlayerEx_PutStatusTextEx(This,wszText,fOverwrite,pdwCookie)	\
    (This)->lpVtbl -> PutStatusTextEx(This,wszText,fOverwrite,pdwCookie)

#define IDSPlayerEx_FlushStatusBar(This)	\
    (This)->lpVtbl -> FlushStatusBar(This)

#define IDSPlayerEx_NavigateBrowserToURL(This,bstrURL,bstrFrame)	\
    (This)->lpVtbl -> NavigateBrowserToURL(This,bstrURL,bstrFrame)

#define IDSPlayerEx_get_Document(This,__MIDL_0011)	\
    (This)->lpVtbl -> get_Document(This,__MIDL_0011)

#define IDSPlayerEx_FilePropertiesDialog(This)	\
    (This)->lpVtbl -> FilePropertiesDialog(This)

#define IDSPlayerEx_StatisticsDialog(This)	\
    (This)->lpVtbl -> StatisticsDialog(This)

#define IDSPlayerEx_GotoDialog(This)	\
    (This)->lpVtbl -> GotoDialog(This)

#define IDSPlayerEx_Preview(This)	\
    (This)->lpVtbl -> Preview(This)

#define IDSPlayerEx_RestartPlaylist(This,fPlay)	\
    (This)->lpVtbl -> RestartPlaylist(This,fPlay)

#define IDSPlayerEx_PutPreviewModeHelper(This,PreviewMode,fPlayWhenFinished)	\
    (This)->lpVtbl -> PutPreviewModeHelper(This,PreviewMode,fPlayWhenFinished)

#define IDSPlayerEx_UpdateVisual(This,fUpdateVisual)	\
    (This)->lpVtbl -> UpdateVisual(This,fUpdateVisual)

#define IDSPlayerEx_RegisterEmbeddedObjects(This,dwClsContext)	\
    (This)->lpVtbl -> RegisterEmbeddedObjects(This,dwClsContext)

#define IDSPlayerEx_RevokeEmbeddedObjects(This)	\
    (This)->lpVtbl -> RevokeEmbeddedObjects(This)

#define IDSPlayerEx_SetNativeFrameFlag(This)	\
    (This)->lpVtbl -> SetNativeFrameFlag(This)

#define IDSPlayerEx_ResetNativeFrameFlag(This)	\
    (This)->lpVtbl -> ResetNativeFrameFlag(This)

#define IDSPlayerEx_put_UserInteraction(This,bVal)	\
    (This)->lpVtbl -> put_UserInteraction(This,bVal)

#define IDSPlayerEx_AddToolTip(This,prc,lptsr,pID)	\
    (This)->lpVtbl -> AddToolTip(This,prc,lptsr,pID)

#define IDSPlayerEx_RemoveToolTip(This,ID)	\
    (This)->lpVtbl -> RemoveToolTip(This,ID)

#define IDSPlayerEx_UpdateToolTipRect(This,prc,ID)	\
    (This)->lpVtbl -> UpdateToolTipRect(This,prc,ID)

#define IDSPlayerEx_UpdateToolTipText(This,lptsr,ID)	\
    (This)->lpVtbl -> UpdateToolTipText(This,lptsr,ID)

#define IDSPlayerEx_SaveAs(This)	\
    (This)->lpVtbl -> SaveAs(This)

#define IDSPlayerEx_CanSave(This)	\
    (This)->lpVtbl -> CanSave(This)

#define IDSPlayerEx_get_CurrentPositionInternal(This,pCurrentPosition)	\
    (This)->lpVtbl -> get_CurrentPositionInternal(This,pCurrentPosition)

#define IDSPlayerEx_get_OpenCloseCounter(This,pOpenCloseCounter)	\
    (This)->lpVtbl -> get_OpenCloseCounter(This,pOpenCloseCounter)

#define IDSPlayerEx_put_CompatibilityMode(This,lCompatibilityMode)	\
    (This)->lpVtbl -> put_CompatibilityMode(This,lCompatibilityMode)

#define IDSPlayerEx_get_CompatibilityMode(This,plCompatibilityMode)	\
    (This)->lpVtbl -> get_CompatibilityMode(This,plCompatibilityMode)

#define IDSPlayerEx_put_OnOpenOverride(This,bVal)	\
    (This)->lpVtbl -> put_OnOpenOverride(This,bVal)

#define IDSPlayerEx_get_OnOpenOverride(This,pbVal)	\
    (This)->lpVtbl -> get_OnOpenOverride(This,pbVal)

#define IDSPlayerEx_put_OnOpenAutoSize(This,bVal)	\
    (This)->lpVtbl -> put_OnOpenAutoSize(This,bVal)

#define IDSPlayerEx_get_OnOpenAutoSize(This,pbVal)	\
    (This)->lpVtbl -> get_OnOpenAutoSize(This,pbVal)

#define IDSPlayerEx_put_OnOpenDisplaySize(This,lOnOpenDisplaySize)	\
    (This)->lpVtbl -> put_OnOpenDisplaySize(This,lOnOpenDisplaySize)

#define IDSPlayerEx_get_OnOpenDisplaySize(This,plOnOpenDisplaySize)	\
    (This)->lpVtbl -> get_OnOpenDisplaySize(This,plOnOpenDisplaySize)

#define IDSPlayerEx_put_AutoSizeAudioWidth(This,lAutoSizeAudioWidth)	\
    (This)->lpVtbl -> put_AutoSizeAudioWidth(This,lAutoSizeAudioWidth)

#define IDSPlayerEx_get_MinimumWidth(This,plMinimumWidth)	\
    (This)->lpVtbl -> get_MinimumWidth(This,plMinimumWidth)

#define IDSPlayerEx_get_EffectiveDisplaySize(This,plEffectiveDisplaySize)	\
    (This)->lpVtbl -> get_EffectiveDisplaySize(This,plEffectiveDisplaySize)

#define IDSPlayerEx_put_DisplaySizeInternal(This,lDisplaySizeInternal)	\
    (This)->lpVtbl -> put_DisplaySizeInternal(This,lDisplaySizeInternal)

#define IDSPlayerEx_get_DisplaySizeInternal(This,plDisplaySizeInternal)	\
    (This)->lpVtbl -> get_DisplaySizeInternal(This,plDisplaySizeInternal)

#define IDSPlayerEx_get_DurationInternal(This,pDuration)	\
    (This)->lpVtbl -> get_DurationInternal(This,pDuration)

#define IDSPlayerEx_get_SegmentSeek(This,plSegmentSeek)	\
    (This)->lpVtbl -> get_SegmentSeek(This,plSegmentSeek)

#define IDSPlayerEx_get_CanSkip(This,pbCanSkip)	\
    (This)->lpVtbl -> get_CanSkip(This,pbCanSkip)

#define IDSPlayerEx_get_IEVersion(This,ppszVersion)	\
    (This)->lpVtbl -> get_IEVersion(This,ppszVersion)

#define IDSPlayerEx_get_BrowserIsIE4(This,pbCanSkip)	\
    (This)->lpVtbl -> get_BrowserIsIE4(This,pbCanSkip)

#define IDSPlayerEx_put_URL(This,pbstrURL)	\
    (This)->lpVtbl -> put_URL(This,pbstrURL)

#define IDSPlayerEx_get_FilterGraph(This,ppFilterGraph)	\
    (This)->lpVtbl -> get_FilterGraph(This,ppFilterGraph)

#define IDSPlayerEx_get_InShow(This,pbVal)	\
    (This)->lpVtbl -> get_InShow(This,pbVal)

#define IDSPlayerEx_get_InChannel(This,pbVal)	\
    (This)->lpVtbl -> get_InChannel(This,pbVal)

#define IDSPlayerEx_get_UpdateVisualCounter(This,plVal)	\
    (This)->lpVtbl -> get_UpdateVisualCounter(This,plVal)

#define IDSPlayerEx_get_DialogAvailability(This,pDialogAvailability)	\
    (This)->lpVtbl -> get_DialogAvailability(This,pDialogAvailability)

#define IDSPlayerEx_StopInternal(This)	\
    (This)->lpVtbl -> StopInternal(This)

#define IDSPlayerEx_IsBannerFixed(This,fFixed)	\
    (This)->lpVtbl -> IsBannerFixed(This,fFixed)

#define IDSPlayerEx_StartAnimation(This)	\
    (This)->lpVtbl -> StartAnimation(This)

#define IDSPlayerEx_LaunchURLInAnyBrowser(This,hwnd,pszPath)	\
    (This)->lpVtbl -> LaunchURLInAnyBrowser(This,hwnd,pszPath)

#define IDSPlayerEx_GoFullScreen(This,bFullScreen)	\
    (This)->lpVtbl -> GoFullScreen(This,bFullScreen)

#define IDSPlayerEx_GetCompleteClipFilename(This,pbstr)	\
    (This)->lpVtbl -> GetCompleteClipFilename(This,pbstr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDSPlayerEx_DoContextMenu_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_DoContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_DownloadImage_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ BSTR pbstrURL,
    /* [out] */ LONG_PTR __RPC_FAR *phBitmap);


void __RPC_STUB IDSPlayerEx_DownloadImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_PutStatusTextEx_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ BSTR wszText,
    /* [in] */ BOOL fOverwrite,
    /* [out][in] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IDSPlayerEx_PutStatusTextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_FlushStatusBar_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_FlushStatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_NavigateBrowserToURL_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ BSTR bstrURL,
    /* [in] */ BSTR bstrFrame);


void __RPC_STUB IDSPlayerEx_NavigateBrowserToURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_Document_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *__MIDL_0011);


void __RPC_STUB IDSPlayerEx_get_Document_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_FilePropertiesDialog_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_FilePropertiesDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_StatisticsDialog_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_StatisticsDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_GotoDialog_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_GotoDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_Preview_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_Preview_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_RestartPlaylist_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ BOOL fPlay);


void __RPC_STUB IDSPlayerEx_RestartPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_PutPreviewModeHelper_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    VARIANT_BOOL PreviewMode,
    BOOL fPlayWhenFinished);


void __RPC_STUB IDSPlayerEx_PutPreviewModeHelper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_UpdateVisual_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ BOOL fUpdateVisual);


void __RPC_STUB IDSPlayerEx_UpdateVisual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_RegisterEmbeddedObjects_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    DWORD dwClsContext);


void __RPC_STUB IDSPlayerEx_RegisterEmbeddedObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_RevokeEmbeddedObjects_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_RevokeEmbeddedObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_SetNativeFrameFlag_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_SetNativeFrameFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_ResetNativeFrameFlag_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_ResetNativeFrameFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_UserInteraction_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bVal);


void __RPC_STUB IDSPlayerEx_put_UserInteraction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_AddToolTip_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ RECT __RPC_FAR *prc,
    /* [in] */ LPTSTR lptsr,
    /* [out] */ int __RPC_FAR *pID);


void __RPC_STUB IDSPlayerEx_AddToolTip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_RemoveToolTip_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ int ID);


void __RPC_STUB IDSPlayerEx_RemoveToolTip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_UpdateToolTipRect_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ RECT __RPC_FAR *prc,
    /* [in] */ int ID);


void __RPC_STUB IDSPlayerEx_UpdateToolTipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_UpdateToolTipText_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ LPTSTR lptsr,
    /* [in] */ int ID);


void __RPC_STUB IDSPlayerEx_UpdateToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_SaveAs_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_SaveAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_CanSave_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_CanSave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_CurrentPositionInternal_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pCurrentPosition);


void __RPC_STUB IDSPlayerEx_get_CurrentPositionInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_OpenCloseCounter_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pOpenCloseCounter);


void __RPC_STUB IDSPlayerEx_get_OpenCloseCounter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_CompatibilityMode_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ long lCompatibilityMode);


void __RPC_STUB IDSPlayerEx_put_CompatibilityMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_CompatibilityMode_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCompatibilityMode);


void __RPC_STUB IDSPlayerEx_get_CompatibilityMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_OnOpenOverride_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bVal);


void __RPC_STUB IDSPlayerEx_put_OnOpenOverride_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_OnOpenOverride_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);


void __RPC_STUB IDSPlayerEx_get_OnOpenOverride_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_OnOpenAutoSize_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bVal);


void __RPC_STUB IDSPlayerEx_put_OnOpenAutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_OnOpenAutoSize_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);


void __RPC_STUB IDSPlayerEx_get_OnOpenAutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_OnOpenDisplaySize_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ long lOnOpenDisplaySize);


void __RPC_STUB IDSPlayerEx_put_OnOpenDisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_OnOpenDisplaySize_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plOnOpenDisplaySize);


void __RPC_STUB IDSPlayerEx_get_OnOpenDisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_AutoSizeAudioWidth_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ long lAutoSizeAudioWidth);


void __RPC_STUB IDSPlayerEx_put_AutoSizeAudioWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_MinimumWidth_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plMinimumWidth);


void __RPC_STUB IDSPlayerEx_get_MinimumWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_EffectiveDisplaySize_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plEffectiveDisplaySize);


void __RPC_STUB IDSPlayerEx_get_EffectiveDisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_DisplaySizeInternal_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ long lDisplaySizeInternal);


void __RPC_STUB IDSPlayerEx_put_DisplaySizeInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_DisplaySizeInternal_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plDisplaySizeInternal);


void __RPC_STUB IDSPlayerEx_get_DisplaySizeInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_DurationInternal_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pDuration);


void __RPC_STUB IDSPlayerEx_get_DurationInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_SegmentSeek_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plSegmentSeek);


void __RPC_STUB IDSPlayerEx_get_SegmentSeek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_CanSkip_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanSkip);


void __RPC_STUB IDSPlayerEx_get_CanSkip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_IEVersion_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ LPTSTR __RPC_FAR *ppszVersion);


void __RPC_STUB IDSPlayerEx_get_IEVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_BrowserIsIE4_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanSkip);


void __RPC_STUB IDSPlayerEx_get_BrowserIsIE4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_URL_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ BSTR pbstrURL);


void __RPC_STUB IDSPlayerEx_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_FilterGraph_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppFilterGraph);


void __RPC_STUB IDSPlayerEx_get_FilterGraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_InShow_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);


void __RPC_STUB IDSPlayerEx_get_InShow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_InChannel_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);


void __RPC_STUB IDSPlayerEx_get_InChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_UpdateVisualCounter_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plVal);


void __RPC_STUB IDSPlayerEx_get_UpdateVisualCounter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_DialogAvailability_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pDialogAvailability);


void __RPC_STUB IDSPlayerEx_get_DialogAvailability_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_StopInternal_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_StopInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_IsBannerFixed_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    BOOL __RPC_FAR *fFixed);


void __RPC_STUB IDSPlayerEx_IsBannerFixed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_StartAnimation_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_StartAnimation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_LaunchURLInAnyBrowser_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    HWND hwnd,
    TCHAR __RPC_FAR *pszPath);


void __RPC_STUB IDSPlayerEx_LaunchURLInAnyBrowser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_GoFullScreen_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    BOOL bFullScreen);


void __RPC_STUB IDSPlayerEx_GoFullScreen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_GetCompleteClipFilename_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDSPlayerEx_GetCompleteClipFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDSPlayerEx_INTERFACE_DEFINED__ */


#ifndef __IMediaPlayer_INTERFACE_DEFINED__
#define __IMediaPlayer_INTERFACE_DEFINED__

/* interface IMediaPlayer */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMediaPlayer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22D6F311-B0F6-11D0-94AB-0080C74C7E95")
    IMediaPlayer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentPosition( 
            /* [retval][out] */ double __RPC_FAR *pCurrentPosition) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CurrentPosition( 
            /* [in] */ double CurrentPosition) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ double __RPC_FAR *pDuration) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageSourceWidth( 
            /* [retval][out] */ long __RPC_FAR *pWidth) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageSourceHeight( 
            /* [retval][out] */ long __RPC_FAR *pHeight) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MarkerCount( 
            /* [retval][out] */ long __RPC_FAR *pMarkerCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanScan( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanScan) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanSeek( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanSeek) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanSeekToMarkers( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanSeekToMarkers) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentMarker( 
            /* [retval][out] */ long __RPC_FAR *pCurrentMarker) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CurrentMarker( 
            /* [in] */ long CurrentMarker) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SourceLink( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceLink) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CreationDate( 
            /* [retval][out] */ DATE __RPC_FAR *pCreationDate) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ErrorCorrection( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrErrorCorrection) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Bandwidth( 
            /* [retval][out] */ long __RPC_FAR *pBandwidth) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SourceProtocol( 
            /* [retval][out] */ long __RPC_FAR *pSourceProtocol) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReceivedPackets( 
            /* [retval][out] */ long __RPC_FAR *pReceivedPackets) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RecoveredPackets( 
            /* [retval][out] */ long __RPC_FAR *pRecoveredPackets) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LostPackets( 
            /* [retval][out] */ long __RPC_FAR *pLostPackets) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReceptionQuality( 
            /* [retval][out] */ long __RPC_FAR *pReceptionQuality) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BufferingCount( 
            /* [retval][out] */ long __RPC_FAR *pBufferingCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsBroadcast( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsBroadcast) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BufferingProgress( 
            /* [retval][out] */ long __RPC_FAR *pBufferingProgress) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ChannelName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ChannelDescription( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelDescription) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ChannelURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelURL) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContactAddress) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactPhone( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContactPhone) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactEmail( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContactEmail) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BufferingTime( 
            /* [retval][out] */ double __RPC_FAR *pBufferingTime) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BufferingTime( 
            /* [in] */ double BufferingTime) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoStart( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoStart( 
            /* [in] */ VARIANT_BOOL AutoStart) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoRewind( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoRewind) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoRewind( 
            /* [in] */ VARIANT_BOOL AutoRewind) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [retval][out] */ double __RPC_FAR *pRate) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double Rate) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendKeyboardEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendKeyboardEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendKeyboardEvents( 
            /* [in] */ VARIANT_BOOL SendKeyboardEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendMouseClickEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendMouseClickEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendMouseClickEvents( 
            /* [in] */ VARIANT_BOOL SendMouseClickEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendMouseMoveEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendMouseMoveEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendMouseMoveEvents( 
            /* [in] */ VARIANT_BOOL SendMouseMoveEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PlayCount( 
            /* [retval][out] */ long __RPC_FAR *pPlayCount) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_PlayCount( 
            /* [in] */ long PlayCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClickToPlay( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pClickToPlay) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ClickToPlay( 
            /* [in] */ VARIANT_BOOL ClickToPlay) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowScan( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllowScan) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowScan( 
            /* [in] */ VARIANT_BOOL AllowScan) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableContextMenu( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnableContextMenu) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableContextMenu( 
            /* [in] */ VARIANT_BOOL EnableContextMenu) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CursorType( 
            /* [retval][out] */ long __RPC_FAR *pCursorType) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CursorType( 
            /* [in] */ long CursorType) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CodecCount( 
            /* [retval][out] */ long __RPC_FAR *pCodecCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowChangeDisplaySize( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllowChangeDisplaySize) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowChangeDisplaySize( 
            /* [in] */ VARIANT_BOOL AllowChangeDisplaySize) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsDurationValid( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsDurationValid) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OpenState( 
            /* [retval][out] */ long __RPC_FAR *pOpenState) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendOpenStateChangeEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendOpenStateChangeEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendOpenStateChangeEvents( 
            /* [in] */ VARIANT_BOOL SendOpenStateChangeEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendWarningEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendWarningEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendWarningEvents( 
            /* [in] */ VARIANT_BOOL SendWarningEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendErrorEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendErrorEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendErrorEvents( 
            /* [in] */ VARIANT_BOOL SendErrorEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PlayState( 
            /* [retval][out] */ MPPlayStateConstants __RPC_FAR *pPlayState) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendPlayStateChangeEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendPlayStateChangeEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendPlayStateChangeEvents( 
            /* [in] */ VARIANT_BOOL SendPlayStateChangeEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplaySize( 
            /* [retval][out] */ MPDisplaySizeConstants __RPC_FAR *pDisplaySize) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplaySize( 
            /* [in] */ MPDisplaySizeConstants DisplaySize) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_InvokeURLs( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pInvokeURLs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_InvokeURLs( 
            /* [in] */ VARIANT_BOOL InvokeURLs) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BaseURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrBaseURL) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BaseURL( 
            /* [in] */ BSTR bstrBaseURL) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DefaultFrame( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDefaultFrame) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DefaultFrame( 
            /* [in] */ BSTR bstrDefaultFrame) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HasError( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHasError) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrErrorDescription) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ long __RPC_FAR *pErrorCode) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AnimationAtStart( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAnimationAtStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AnimationAtStart( 
            /* [in] */ VARIANT_BOOL AnimationAtStart) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TransparentAtStart( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pTransparentAtStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_TransparentAtStart( 
            /* [in] */ VARIANT_BOOL TransparentAtStart) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [retval][out] */ long __RPC_FAR *pVolume) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long Volume) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Balance( 
            /* [retval][out] */ long __RPC_FAR *pBalance) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Balance( 
            /* [in] */ long Balance) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadyState( 
            /* [retval][out] */ MPReadyStateConstants __RPC_FAR *pValue) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectionStart( 
            /* [retval][out] */ double __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectionStart( 
            /* [in] */ double Value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectionEnd( 
            /* [retval][out] */ double __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectionEnd( 
            /* [in] */ double Value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowDisplay( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowDisplay( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowControls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowControls( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowPositionControls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowPositionControls( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowTracker( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowTracker( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EnablePositionControls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Enable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnablePositionControls( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableTracker( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Enable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableTracker( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL Enabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayForeColor( 
            /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *ForeColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayForeColor( 
            /* [in] */ VB_OLE_COLOR ForeColor) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayBackColor( 
            /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *BackColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayBackColor( 
            /* [in] */ VB_OLE_COLOR BackColor) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayMode( 
            /* [retval][out] */ MPDisplayModeConstants __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayMode( 
            /* [in] */ MPDisplayModeConstants Value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_VideoBorder3D( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVideoBorderWidth) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_VideoBorder3D( 
            /* [in] */ VARIANT_BOOL VideoBorderWidth) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_VideoBorderWidth( 
            /* [retval][out] */ long __RPC_FAR *pVideoBorderWidth) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_VideoBorderWidth( 
            /* [in] */ long VideoBorderWidth) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_VideoBorderColor( 
            /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *pVideoBorderWidth) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_VideoBorderColor( 
            /* [in] */ VB_OLE_COLOR VideoBorderColor) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowGotoBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowGotoBar( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowStatusBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowStatusBar( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowCaptioning( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowCaptioning( 
            /* [in] */ VARIANT_BOOL pbool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowAudioControls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowAudioControls( 
            /* [in] */ VARIANT_BOOL bBool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CaptioningID( 
            /* [retval][out] */ BSTR __RPC_FAR *pstrText) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CaptioningID( 
            /* [in] */ BSTR strText) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Mute( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Mute( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanPreview( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanPreview) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PreviewMode( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pPreviewMode) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_PreviewMode( 
            /* [in] */ VARIANT_BOOL PreviewMode) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HasMultipleItems( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHasMuliItems) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Language( 
            /* [retval][out] */ long __RPC_FAR *pLanguage) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Language( 
            /* [in] */ long Language) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AudioStream( 
            /* [retval][out] */ long __RPC_FAR *pStream) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AudioStream( 
            /* [in] */ long Stream) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SAMIStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStyle) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SAMIStyle( 
            /* [in] */ BSTR bstrStyle) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SAMILang( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLang) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SAMILang( 
            /* [in] */ BSTR bstrLang) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SAMIFileName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SAMIFileName( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StreamCount( 
            /* [retval][out] */ long __RPC_FAR *pStreamCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientId( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrClientId) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ConnectionSpeed( 
            /* [retval][out] */ long __RPC_FAR *plConnectionSpeed) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoSize( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoSize( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableFullScreenControls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableFullScreenControls( 
            /* [in] */ VARIANT_BOOL bVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActiveMovie( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispatch) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NSPlay( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispatch) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WindowlessVideo( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_WindowlessVideo( 
            /* [in] */ VARIANT_BOOL bool) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Play( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMarkerTime( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double __RPC_FAR *pMarkerTime) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMarkerName( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMarkerName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AboutBox( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCodecInstalled( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCodecInstalled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCodecDescription( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCodecDescription) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCodecURL( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCodecURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMoreInfoURL( 
            /* [in] */ MPMoreInfoType MoreInfoType,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMoreInfoURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMediaInfoString( 
            /* [in] */ MPMediaInfoType MediaInfoType,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMediaInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsSoundCardEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSoundCard) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Next( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Previous( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StreamSelect( 
            /* [in] */ long StreamNum) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FastForward( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FastReverse( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStreamName( 
            /* [in] */ long StreamNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStreamName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStreamGroup( 
            /* [in] */ long StreamNum,
            /* [retval][out] */ long __RPC_FAR *pStreamGroup) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStreamSelected( 
            /* [in] */ long StreamNum,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStreamSelected) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaPlayerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMediaPlayer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMediaPlayer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentPosition )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pCurrentPosition);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CurrentPosition )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ double CurrentPosition);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pDuration);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ImageSourceWidth )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pWidth);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ImageSourceHeight )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pHeight);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MarkerCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pMarkerCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CanScan )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanScan);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CanSeek )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanSeek);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CanSeekToMarkers )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanSeekToMarkers);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentMarker )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCurrentMarker);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CurrentMarker )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long CurrentMarker);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FileName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FileName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceLink )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceLink);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CreationDate )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pCreationDate);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ErrorCorrection )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrErrorCorrection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bandwidth )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pBandwidth);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceProtocol )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pSourceProtocol);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReceivedPackets )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pReceivedPackets);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecoveredPackets )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pRecoveredPackets);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LostPackets )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pLostPackets);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReceptionQuality )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pReceptionQuality);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BufferingCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pBufferingCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsBroadcast )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsBroadcast);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BufferingProgress )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pBufferingProgress);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ChannelName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ChannelDescription )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelDescription);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ChannelURL )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContactAddress )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContactAddress);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContactPhone )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContactPhone);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContactEmail )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContactEmail);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BufferingTime )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pBufferingTime);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BufferingTime )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ double BufferingTime);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL AutoStart);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoRewind )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoRewind);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoRewind )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL AutoRewind);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Rate )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pRate);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Rate )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ double Rate);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendKeyboardEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendKeyboardEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendKeyboardEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendKeyboardEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendMouseClickEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendMouseClickEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendMouseClickEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendMouseClickEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendMouseMoveEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendMouseMoveEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendMouseMoveEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendMouseMoveEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PlayCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pPlayCount);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PlayCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long PlayCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClickToPlay )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pClickToPlay);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ClickToPlay )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL ClickToPlay);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowScan )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllowScan);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllowScan )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL AllowScan);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableContextMenu )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableContextMenu )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL EnableContextMenu);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorType )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCursorType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorType )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long CursorType);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CodecCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCodecCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowChangeDisplaySize )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllowChangeDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllowChangeDisplaySize )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL AllowChangeDisplaySize);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsDurationValid )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsDurationValid);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OpenState )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pOpenState);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendOpenStateChangeEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendOpenStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendOpenStateChangeEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendOpenStateChangeEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendWarningEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendWarningEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendWarningEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendWarningEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendErrorEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendErrorEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendErrorEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendErrorEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PlayState )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ MPPlayStateConstants __RPC_FAR *pPlayState);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendPlayStateChangeEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendPlayStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendPlayStateChangeEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendPlayStateChangeEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplaySize )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ MPDisplaySizeConstants __RPC_FAR *pDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplaySize )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ MPDisplaySizeConstants DisplaySize);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InvokeURLs )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pInvokeURLs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_InvokeURLs )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL InvokeURLs);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BaseURL )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrBaseURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BaseURL )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrBaseURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultFrame )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDefaultFrame);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DefaultFrame )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrDefaultFrame);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasError )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHasError);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ErrorDescription )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrErrorDescription);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ErrorCode )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pErrorCode);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AnimationAtStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAnimationAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AnimationAtStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL AnimationAtStart);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TransparentAtStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pTransparentAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TransparentAtStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL TransparentAtStart);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Volume )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVolume);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Volume )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long Volume);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Balance )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pBalance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Balance )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long Balance);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReadyState )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ MPReadyStateConstants __RPC_FAR *pValue);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SelectionStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SelectionStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ double Value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SelectionEnd )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SelectionEnd )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ double Value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowDisplay )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowDisplay )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowPositionControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowPositionControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowTracker )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowTracker )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnablePositionControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnablePositionControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableTracker )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableTracker )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Enabled )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Enabled )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Enabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayForeColor )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *ForeColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplayForeColor )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VB_OLE_COLOR ForeColor);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayBackColor )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *BackColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplayBackColor )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VB_OLE_COLOR BackColor);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayMode )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ MPDisplayModeConstants __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplayMode )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ MPDisplayModeConstants Value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VideoBorder3D )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVideoBorderWidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VideoBorder3D )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL VideoBorderWidth);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VideoBorderWidth )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVideoBorderWidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VideoBorderWidth )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long VideoBorderWidth);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VideoBorderColor )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *pVideoBorderWidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VideoBorderColor )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VB_OLE_COLOR VideoBorderColor);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowGotoBar )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowGotoBar )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowStatusBar )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowStatusBar )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowCaptioning )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowCaptioning )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL pbool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowAudioControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowAudioControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bBool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CaptioningID )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pstrText);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CaptioningID )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR strText);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mute )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Mute )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CanPreview )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanPreview);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PreviewMode )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pPreviewMode);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PreviewMode )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL PreviewMode);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasMultipleItems )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHasMuliItems);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Language )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pLanguage);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Language )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long Language);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AudioStream )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pStream);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AudioStream )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long Stream);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SAMIStyle )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SAMIStyle )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrStyle);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SAMILang )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLang);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SAMILang )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrLang);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SAMIFileName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SAMIFileName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StreamCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pStreamCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClientId )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrClientId);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionSpeed )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plConnectionSpeed);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoSize )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoSize )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableFullScreenControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableFullScreenControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveMovie )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispatch);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NSPlay )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispatch);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WindowlessVideo )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WindowlessVideo )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bool);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarkerTime )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double __RPC_FAR *pMarkerTime);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarkerName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMarkerName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AboutBox )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInstalled )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCodecInstalled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecDescription )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCodecDescription);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecURL )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCodecURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMoreInfoURL )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ MPMoreInfoType MoreInfoType,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMoreInfoURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaInfoString )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ MPMediaInfoType MediaInfoType,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMediaInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSoundCardEnabled )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSoundCard);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Previous )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StreamSelect )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long StreamNum);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FastForward )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FastReverse )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long StreamNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStreamName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamGroup )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long StreamNum,
            /* [retval][out] */ long __RPC_FAR *pStreamGroup);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long StreamNum,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStreamSelected);
        
        END_INTERFACE
    } IMediaPlayerVtbl;

    interface IMediaPlayer
    {
        CONST_VTBL struct IMediaPlayerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaPlayer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaPlayer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaPlayer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaPlayer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMediaPlayer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMediaPlayer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMediaPlayer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMediaPlayer_get_CurrentPosition(This,pCurrentPosition)	\
    (This)->lpVtbl -> get_CurrentPosition(This,pCurrentPosition)

#define IMediaPlayer_put_CurrentPosition(This,CurrentPosition)	\
    (This)->lpVtbl -> put_CurrentPosition(This,CurrentPosition)

#define IMediaPlayer_get_Duration(This,pDuration)	\
    (This)->lpVtbl -> get_Duration(This,pDuration)

#define IMediaPlayer_get_ImageSourceWidth(This,pWidth)	\
    (This)->lpVtbl -> get_ImageSourceWidth(This,pWidth)

#define IMediaPlayer_get_ImageSourceHeight(This,pHeight)	\
    (This)->lpVtbl -> get_ImageSourceHeight(This,pHeight)

#define IMediaPlayer_get_MarkerCount(This,pMarkerCount)	\
    (This)->lpVtbl -> get_MarkerCount(This,pMarkerCount)

#define IMediaPlayer_get_CanScan(This,pCanScan)	\
    (This)->lpVtbl -> get_CanScan(This,pCanScan)

#define IMediaPlayer_get_CanSeek(This,pCanSeek)	\
    (This)->lpVtbl -> get_CanSeek(This,pCanSeek)

#define IMediaPlayer_get_CanSeekToMarkers(This,pCanSeekToMarkers)	\
    (This)->lpVtbl -> get_CanSeekToMarkers(This,pCanSeekToMarkers)

#define IMediaPlayer_get_CurrentMarker(This,pCurrentMarker)	\
    (This)->lpVtbl -> get_CurrentMarker(This,pCurrentMarker)

#define IMediaPlayer_put_CurrentMarker(This,CurrentMarker)	\
    (This)->lpVtbl -> put_CurrentMarker(This,CurrentMarker)

#define IMediaPlayer_get_FileName(This,pbstrFileName)	\
    (This)->lpVtbl -> get_FileName(This,pbstrFileName)

#define IMediaPlayer_put_FileName(This,bstrFileName)	\
    (This)->lpVtbl -> put_FileName(This,bstrFileName)

#define IMediaPlayer_get_SourceLink(This,pbstrSourceLink)	\
    (This)->lpVtbl -> get_SourceLink(This,pbstrSourceLink)

#define IMediaPlayer_get_CreationDate(This,pCreationDate)	\
    (This)->lpVtbl -> get_CreationDate(This,pCreationDate)

#define IMediaPlayer_get_ErrorCorrection(This,pbstrErrorCorrection)	\
    (This)->lpVtbl -> get_ErrorCorrection(This,pbstrErrorCorrection)

#define IMediaPlayer_get_Bandwidth(This,pBandwidth)	\
    (This)->lpVtbl -> get_Bandwidth(This,pBandwidth)

#define IMediaPlayer_get_SourceProtocol(This,pSourceProtocol)	\
    (This)->lpVtbl -> get_SourceProtocol(This,pSourceProtocol)

#define IMediaPlayer_get_ReceivedPackets(This,pReceivedPackets)	\
    (This)->lpVtbl -> get_ReceivedPackets(This,pReceivedPackets)

#define IMediaPlayer_get_RecoveredPackets(This,pRecoveredPackets)	\
    (This)->lpVtbl -> get_RecoveredPackets(This,pRecoveredPackets)

#define IMediaPlayer_get_LostPackets(This,pLostPackets)	\
    (This)->lpVtbl -> get_LostPackets(This,pLostPackets)

#define IMediaPlayer_get_ReceptionQuality(This,pReceptionQuality)	\
    (This)->lpVtbl -> get_ReceptionQuality(This,pReceptionQuality)

#define IMediaPlayer_get_BufferingCount(This,pBufferingCount)	\
    (This)->lpVtbl -> get_BufferingCount(This,pBufferingCount)

#define IMediaPlayer_get_IsBroadcast(This,pIsBroadcast)	\
    (This)->lpVtbl -> get_IsBroadcast(This,pIsBroadcast)

#define IMediaPlayer_get_BufferingProgress(This,pBufferingProgress)	\
    (This)->lpVtbl -> get_BufferingProgress(This,pBufferingProgress)

#define IMediaPlayer_get_ChannelName(This,pbstrChannelName)	\
    (This)->lpVtbl -> get_ChannelName(This,pbstrChannelName)

#define IMediaPlayer_get_ChannelDescription(This,pbstrChannelDescription)	\
    (This)->lpVtbl -> get_ChannelDescription(This,pbstrChannelDescription)

#define IMediaPlayer_get_ChannelURL(This,pbstrChannelURL)	\
    (This)->lpVtbl -> get_ChannelURL(This,pbstrChannelURL)

#define IMediaPlayer_get_ContactAddress(This,pbstrContactAddress)	\
    (This)->lpVtbl -> get_ContactAddress(This,pbstrContactAddress)

#define IMediaPlayer_get_ContactPhone(This,pbstrContactPhone)	\
    (This)->lpVtbl -> get_ContactPhone(This,pbstrContactPhone)

#define IMediaPlayer_get_ContactEmail(This,pbstrContactEmail)	\
    (This)->lpVtbl -> get_ContactEmail(This,pbstrContactEmail)

#define IMediaPlayer_get_BufferingTime(This,pBufferingTime)	\
    (This)->lpVtbl -> get_BufferingTime(This,pBufferingTime)

#define IMediaPlayer_put_BufferingTime(This,BufferingTime)	\
    (This)->lpVtbl -> put_BufferingTime(This,BufferingTime)

#define IMediaPlayer_get_AutoStart(This,pAutoStart)	\
    (This)->lpVtbl -> get_AutoStart(This,pAutoStart)

#define IMediaPlayer_put_AutoStart(This,AutoStart)	\
    (This)->lpVtbl -> put_AutoStart(This,AutoStart)

#define IMediaPlayer_get_AutoRewind(This,pAutoRewind)	\
    (This)->lpVtbl -> get_AutoRewind(This,pAutoRewind)

#define IMediaPlayer_put_AutoRewind(This,AutoRewind)	\
    (This)->lpVtbl -> put_AutoRewind(This,AutoRewind)

#define IMediaPlayer_get_Rate(This,pRate)	\
    (This)->lpVtbl -> get_Rate(This,pRate)

#define IMediaPlayer_put_Rate(This,Rate)	\
    (This)->lpVtbl -> put_Rate(This,Rate)

#define IMediaPlayer_get_SendKeyboardEvents(This,pSendKeyboardEvents)	\
    (This)->lpVtbl -> get_SendKeyboardEvents(This,pSendKeyboardEvents)

#define IMediaPlayer_put_SendKeyboardEvents(This,SendKeyboardEvents)	\
    (This)->lpVtbl -> put_SendKeyboardEvents(This,SendKeyboardEvents)

#define IMediaPlayer_get_SendMouseClickEvents(This,pSendMouseClickEvents)	\
    (This)->lpVtbl -> get_SendMouseClickEvents(This,pSendMouseClickEvents)

#define IMediaPlayer_put_SendMouseClickEvents(This,SendMouseClickEvents)	\
    (This)->lpVtbl -> put_SendMouseClickEvents(This,SendMouseClickEvents)

#define IMediaPlayer_get_SendMouseMoveEvents(This,pSendMouseMoveEvents)	\
    (This)->lpVtbl -> get_SendMouseMoveEvents(This,pSendMouseMoveEvents)

#define IMediaPlayer_put_SendMouseMoveEvents(This,SendMouseMoveEvents)	\
    (This)->lpVtbl -> put_SendMouseMoveEvents(This,SendMouseMoveEvents)

#define IMediaPlayer_get_PlayCount(This,pPlayCount)	\
    (This)->lpVtbl -> get_PlayCount(This,pPlayCount)

#define IMediaPlayer_put_PlayCount(This,PlayCount)	\
    (This)->lpVtbl -> put_PlayCount(This,PlayCount)

#define IMediaPlayer_get_ClickToPlay(This,pClickToPlay)	\
    (This)->lpVtbl -> get_ClickToPlay(This,pClickToPlay)

#define IMediaPlayer_put_ClickToPlay(This,ClickToPlay)	\
    (This)->lpVtbl -> put_ClickToPlay(This,ClickToPlay)

#define IMediaPlayer_get_AllowScan(This,pAllowScan)	\
    (This)->lpVtbl -> get_AllowScan(This,pAllowScan)

#define IMediaPlayer_put_AllowScan(This,AllowScan)	\
    (This)->lpVtbl -> put_AllowScan(This,AllowScan)

#define IMediaPlayer_get_EnableContextMenu(This,pEnableContextMenu)	\
    (This)->lpVtbl -> get_EnableContextMenu(This,pEnableContextMenu)

#define IMediaPlayer_put_EnableContextMenu(This,EnableContextMenu)	\
    (This)->lpVtbl -> put_EnableContextMenu(This,EnableContextMenu)

#define IMediaPlayer_get_CursorType(This,pCursorType)	\
    (This)->lpVtbl -> get_CursorType(This,pCursorType)

#define IMediaPlayer_put_CursorType(This,CursorType)	\
    (This)->lpVtbl -> put_CursorType(This,CursorType)

#define IMediaPlayer_get_CodecCount(This,pCodecCount)	\
    (This)->lpVtbl -> get_CodecCount(This,pCodecCount)

#define IMediaPlayer_get_AllowChangeDisplaySize(This,pAllowChangeDisplaySize)	\
    (This)->lpVtbl -> get_AllowChangeDisplaySize(This,pAllowChangeDisplaySize)

#define IMediaPlayer_put_AllowChangeDisplaySize(This,AllowChangeDisplaySize)	\
    (This)->lpVtbl -> put_AllowChangeDisplaySize(This,AllowChangeDisplaySize)

#define IMediaPlayer_get_IsDurationValid(This,pIsDurationValid)	\
    (This)->lpVtbl -> get_IsDurationValid(This,pIsDurationValid)

#define IMediaPlayer_get_OpenState(This,pOpenState)	\
    (This)->lpVtbl -> get_OpenState(This,pOpenState)

#define IMediaPlayer_get_SendOpenStateChangeEvents(This,pSendOpenStateChangeEvents)	\
    (This)->lpVtbl -> get_SendOpenStateChangeEvents(This,pSendOpenStateChangeEvents)

#define IMediaPlayer_put_SendOpenStateChangeEvents(This,SendOpenStateChangeEvents)	\
    (This)->lpVtbl -> put_SendOpenStateChangeEvents(This,SendOpenStateChangeEvents)

#define IMediaPlayer_get_SendWarningEvents(This,pSendWarningEvents)	\
    (This)->lpVtbl -> get_SendWarningEvents(This,pSendWarningEvents)

#define IMediaPlayer_put_SendWarningEvents(This,SendWarningEvents)	\
    (This)->lpVtbl -> put_SendWarningEvents(This,SendWarningEvents)

#define IMediaPlayer_get_SendErrorEvents(This,pSendErrorEvents)	\
    (This)->lpVtbl -> get_SendErrorEvents(This,pSendErrorEvents)

#define IMediaPlayer_put_SendErrorEvents(This,SendErrorEvents)	\
    (This)->lpVtbl -> put_SendErrorEvents(This,SendErrorEvents)

#define IMediaPlayer_get_PlayState(This,pPlayState)	\
    (This)->lpVtbl -> get_PlayState(This,pPlayState)

#define IMediaPlayer_get_SendPlayStateChangeEvents(This,pSendPlayStateChangeEvents)	\
    (This)->lpVtbl -> get_SendPlayStateChangeEvents(This,pSendPlayStateChangeEvents)

#define IMediaPlayer_put_SendPlayStateChangeEvents(This,SendPlayStateChangeEvents)	\
    (This)->lpVtbl -> put_SendPlayStateChangeEvents(This,SendPlayStateChangeEvents)

#define IMediaPlayer_get_DisplaySize(This,pDisplaySize)	\
    (This)->lpVtbl -> get_DisplaySize(This,pDisplaySize)

#define IMediaPlayer_put_DisplaySize(This,DisplaySize)	\
    (This)->lpVtbl -> put_DisplaySize(This,DisplaySize)

#define IMediaPlayer_get_InvokeURLs(This,pInvokeURLs)	\
    (This)->lpVtbl -> get_InvokeURLs(This,pInvokeURLs)

#define IMediaPlayer_put_InvokeURLs(This,InvokeURLs)	\
    (This)->lpVtbl -> put_InvokeURLs(This,InvokeURLs)

#define IMediaPlayer_get_BaseURL(This,pbstrBaseURL)	\
    (This)->lpVtbl -> get_BaseURL(This,pbstrBaseURL)

#define IMediaPlayer_put_BaseURL(This,bstrBaseURL)	\
    (This)->lpVtbl -> put_BaseURL(This,bstrBaseURL)

#define IMediaPlayer_get_DefaultFrame(This,pbstrDefaultFrame)	\
    (This)->lpVtbl -> get_DefaultFrame(This,pbstrDefaultFrame)

#define IMediaPlayer_put_DefaultFrame(This,bstrDefaultFrame)	\
    (This)->lpVtbl -> put_DefaultFrame(This,bstrDefaultFrame)

#define IMediaPlayer_get_HasError(This,pHasError)	\
    (This)->lpVtbl -> get_HasError(This,pHasError)

#define IMediaPlayer_get_ErrorDescription(This,pbstrErrorDescription)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pbstrErrorDescription)

#define IMediaPlayer_get_ErrorCode(This,pErrorCode)	\
    (This)->lpVtbl -> get_ErrorCode(This,pErrorCode)

#define IMediaPlayer_get_AnimationAtStart(This,pAnimationAtStart)	\
    (This)->lpVtbl -> get_AnimationAtStart(This,pAnimationAtStart)

#define IMediaPlayer_put_AnimationAtStart(This,AnimationAtStart)	\
    (This)->lpVtbl -> put_AnimationAtStart(This,AnimationAtStart)

#define IMediaPlayer_get_TransparentAtStart(This,pTransparentAtStart)	\
    (This)->lpVtbl -> get_TransparentAtStart(This,pTransparentAtStart)

#define IMediaPlayer_put_TransparentAtStart(This,TransparentAtStart)	\
    (This)->lpVtbl -> put_TransparentAtStart(This,TransparentAtStart)

#define IMediaPlayer_get_Volume(This,pVolume)	\
    (This)->lpVtbl -> get_Volume(This,pVolume)

#define IMediaPlayer_put_Volume(This,Volume)	\
    (This)->lpVtbl -> put_Volume(This,Volume)

#define IMediaPlayer_get_Balance(This,pBalance)	\
    (This)->lpVtbl -> get_Balance(This,pBalance)

#define IMediaPlayer_put_Balance(This,Balance)	\
    (This)->lpVtbl -> put_Balance(This,Balance)

#define IMediaPlayer_get_ReadyState(This,pValue)	\
    (This)->lpVtbl -> get_ReadyState(This,pValue)

#define IMediaPlayer_get_SelectionStart(This,pValue)	\
    (This)->lpVtbl -> get_SelectionStart(This,pValue)

#define IMediaPlayer_put_SelectionStart(This,Value)	\
    (This)->lpVtbl -> put_SelectionStart(This,Value)

#define IMediaPlayer_get_SelectionEnd(This,pValue)	\
    (This)->lpVtbl -> get_SelectionEnd(This,pValue)

#define IMediaPlayer_put_SelectionEnd(This,Value)	\
    (This)->lpVtbl -> put_SelectionEnd(This,Value)

#define IMediaPlayer_get_ShowDisplay(This,Show)	\
    (This)->lpVtbl -> get_ShowDisplay(This,Show)

#define IMediaPlayer_put_ShowDisplay(This,Show)	\
    (This)->lpVtbl -> put_ShowDisplay(This,Show)

#define IMediaPlayer_get_ShowControls(This,Show)	\
    (This)->lpVtbl -> get_ShowControls(This,Show)

#define IMediaPlayer_put_ShowControls(This,Show)	\
    (This)->lpVtbl -> put_ShowControls(This,Show)

#define IMediaPlayer_get_ShowPositionControls(This,Show)	\
    (This)->lpVtbl -> get_ShowPositionControls(This,Show)

#define IMediaPlayer_put_ShowPositionControls(This,Show)	\
    (This)->lpVtbl -> put_ShowPositionControls(This,Show)

#define IMediaPlayer_get_ShowTracker(This,Show)	\
    (This)->lpVtbl -> get_ShowTracker(This,Show)

#define IMediaPlayer_put_ShowTracker(This,Show)	\
    (This)->lpVtbl -> put_ShowTracker(This,Show)

#define IMediaPlayer_get_EnablePositionControls(This,Enable)	\
    (This)->lpVtbl -> get_EnablePositionControls(This,Enable)

#define IMediaPlayer_put_EnablePositionControls(This,Enable)	\
    (This)->lpVtbl -> put_EnablePositionControls(This,Enable)

#define IMediaPlayer_get_EnableTracker(This,Enable)	\
    (This)->lpVtbl -> get_EnableTracker(This,Enable)

#define IMediaPlayer_put_EnableTracker(This,Enable)	\
    (This)->lpVtbl -> put_EnableTracker(This,Enable)

#define IMediaPlayer_get_Enabled(This,pEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pEnabled)

#define IMediaPlayer_put_Enabled(This,Enabled)	\
    (This)->lpVtbl -> put_Enabled(This,Enabled)

#define IMediaPlayer_get_DisplayForeColor(This,ForeColor)	\
    (This)->lpVtbl -> get_DisplayForeColor(This,ForeColor)

#define IMediaPlayer_put_DisplayForeColor(This,ForeColor)	\
    (This)->lpVtbl -> put_DisplayForeColor(This,ForeColor)

#define IMediaPlayer_get_DisplayBackColor(This,BackColor)	\
    (This)->lpVtbl -> get_DisplayBackColor(This,BackColor)

#define IMediaPlayer_put_DisplayBackColor(This,BackColor)	\
    (This)->lpVtbl -> put_DisplayBackColor(This,BackColor)

#define IMediaPlayer_get_DisplayMode(This,pValue)	\
    (This)->lpVtbl -> get_DisplayMode(This,pValue)

#define IMediaPlayer_put_DisplayMode(This,Value)	\
    (This)->lpVtbl -> put_DisplayMode(This,Value)

#define IMediaPlayer_get_VideoBorder3D(This,pVideoBorderWidth)	\
    (This)->lpVtbl -> get_VideoBorder3D(This,pVideoBorderWidth)

#define IMediaPlayer_put_VideoBorder3D(This,VideoBorderWidth)	\
    (This)->lpVtbl -> put_VideoBorder3D(This,VideoBorderWidth)

#define IMediaPlayer_get_VideoBorderWidth(This,pVideoBorderWidth)	\
    (This)->lpVtbl -> get_VideoBorderWidth(This,pVideoBorderWidth)

#define IMediaPlayer_put_VideoBorderWidth(This,VideoBorderWidth)	\
    (This)->lpVtbl -> put_VideoBorderWidth(This,VideoBorderWidth)

#define IMediaPlayer_get_VideoBorderColor(This,pVideoBorderWidth)	\
    (This)->lpVtbl -> get_VideoBorderColor(This,pVideoBorderWidth)

#define IMediaPlayer_put_VideoBorderColor(This,VideoBorderColor)	\
    (This)->lpVtbl -> put_VideoBorderColor(This,VideoBorderColor)

#define IMediaPlayer_get_ShowGotoBar(This,pbool)	\
    (This)->lpVtbl -> get_ShowGotoBar(This,pbool)

#define IMediaPlayer_put_ShowGotoBar(This,vbool)	\
    (This)->lpVtbl -> put_ShowGotoBar(This,vbool)

#define IMediaPlayer_get_ShowStatusBar(This,pbool)	\
    (This)->lpVtbl -> get_ShowStatusBar(This,pbool)

#define IMediaPlayer_put_ShowStatusBar(This,vbool)	\
    (This)->lpVtbl -> put_ShowStatusBar(This,vbool)

#define IMediaPlayer_get_ShowCaptioning(This,pbool)	\
    (This)->lpVtbl -> get_ShowCaptioning(This,pbool)

#define IMediaPlayer_put_ShowCaptioning(This,pbool)	\
    (This)->lpVtbl -> put_ShowCaptioning(This,pbool)

#define IMediaPlayer_get_ShowAudioControls(This,pbool)	\
    (This)->lpVtbl -> get_ShowAudioControls(This,pbool)

#define IMediaPlayer_put_ShowAudioControls(This,bBool)	\
    (This)->lpVtbl -> put_ShowAudioControls(This,bBool)

#define IMediaPlayer_get_CaptioningID(This,pstrText)	\
    (This)->lpVtbl -> get_CaptioningID(This,pstrText)

#define IMediaPlayer_put_CaptioningID(This,strText)	\
    (This)->lpVtbl -> put_CaptioningID(This,strText)

#define IMediaPlayer_get_Mute(This,vbool)	\
    (This)->lpVtbl -> get_Mute(This,vbool)

#define IMediaPlayer_put_Mute(This,vbool)	\
    (This)->lpVtbl -> put_Mute(This,vbool)

#define IMediaPlayer_get_CanPreview(This,pCanPreview)	\
    (This)->lpVtbl -> get_CanPreview(This,pCanPreview)

#define IMediaPlayer_get_PreviewMode(This,pPreviewMode)	\
    (This)->lpVtbl -> get_PreviewMode(This,pPreviewMode)

#define IMediaPlayer_put_PreviewMode(This,PreviewMode)	\
    (This)->lpVtbl -> put_PreviewMode(This,PreviewMode)

#define IMediaPlayer_get_HasMultipleItems(This,pHasMuliItems)	\
    (This)->lpVtbl -> get_HasMultipleItems(This,pHasMuliItems)

#define IMediaPlayer_get_Language(This,pLanguage)	\
    (This)->lpVtbl -> get_Language(This,pLanguage)

#define IMediaPlayer_put_Language(This,Language)	\
    (This)->lpVtbl -> put_Language(This,Language)

#define IMediaPlayer_get_AudioStream(This,pStream)	\
    (This)->lpVtbl -> get_AudioStream(This,pStream)

#define IMediaPlayer_put_AudioStream(This,Stream)	\
    (This)->lpVtbl -> put_AudioStream(This,Stream)

#define IMediaPlayer_get_SAMIStyle(This,pbstrStyle)	\
    (This)->lpVtbl -> get_SAMIStyle(This,pbstrStyle)

#define IMediaPlayer_put_SAMIStyle(This,bstrStyle)	\
    (This)->lpVtbl -> put_SAMIStyle(This,bstrStyle)

#define IMediaPlayer_get_SAMILang(This,pbstrLang)	\
    (This)->lpVtbl -> get_SAMILang(This,pbstrLang)

#define IMediaPlayer_put_SAMILang(This,bstrLang)	\
    (This)->lpVtbl -> put_SAMILang(This,bstrLang)

#define IMediaPlayer_get_SAMIFileName(This,pbstrFileName)	\
    (This)->lpVtbl -> get_SAMIFileName(This,pbstrFileName)

#define IMediaPlayer_put_SAMIFileName(This,bstrFileName)	\
    (This)->lpVtbl -> put_SAMIFileName(This,bstrFileName)

#define IMediaPlayer_get_StreamCount(This,pStreamCount)	\
    (This)->lpVtbl -> get_StreamCount(This,pStreamCount)

#define IMediaPlayer_get_ClientId(This,pbstrClientId)	\
    (This)->lpVtbl -> get_ClientId(This,pbstrClientId)

#define IMediaPlayer_get_ConnectionSpeed(This,plConnectionSpeed)	\
    (This)->lpVtbl -> get_ConnectionSpeed(This,plConnectionSpeed)

#define IMediaPlayer_get_AutoSize(This,pbool)	\
    (This)->lpVtbl -> get_AutoSize(This,pbool)

#define IMediaPlayer_put_AutoSize(This,vbool)	\
    (This)->lpVtbl -> put_AutoSize(This,vbool)

#define IMediaPlayer_get_EnableFullScreenControls(This,pbVal)	\
    (This)->lpVtbl -> get_EnableFullScreenControls(This,pbVal)

#define IMediaPlayer_put_EnableFullScreenControls(This,bVal)	\
    (This)->lpVtbl -> put_EnableFullScreenControls(This,bVal)

#define IMediaPlayer_get_ActiveMovie(This,ppdispatch)	\
    (This)->lpVtbl -> get_ActiveMovie(This,ppdispatch)

#define IMediaPlayer_get_NSPlay(This,ppdispatch)	\
    (This)->lpVtbl -> get_NSPlay(This,ppdispatch)

#define IMediaPlayer_get_WindowlessVideo(This,pbool)	\
    (This)->lpVtbl -> get_WindowlessVideo(This,pbool)

#define IMediaPlayer_put_WindowlessVideo(This,bool)	\
    (This)->lpVtbl -> put_WindowlessVideo(This,bool)

#define IMediaPlayer_Play(This)	\
    (This)->lpVtbl -> Play(This)

#define IMediaPlayer_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IMediaPlayer_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMediaPlayer_GetMarkerTime(This,MarkerNum,pMarkerTime)	\
    (This)->lpVtbl -> GetMarkerTime(This,MarkerNum,pMarkerTime)

#define IMediaPlayer_GetMarkerName(This,MarkerNum,pbstrMarkerName)	\
    (This)->lpVtbl -> GetMarkerName(This,MarkerNum,pbstrMarkerName)

#define IMediaPlayer_AboutBox(This)	\
    (This)->lpVtbl -> AboutBox(This)

#define IMediaPlayer_GetCodecInstalled(This,CodecNum,pCodecInstalled)	\
    (This)->lpVtbl -> GetCodecInstalled(This,CodecNum,pCodecInstalled)

#define IMediaPlayer_GetCodecDescription(This,CodecNum,pbstrCodecDescription)	\
    (This)->lpVtbl -> GetCodecDescription(This,CodecNum,pbstrCodecDescription)

#define IMediaPlayer_GetCodecURL(This,CodecNum,pbstrCodecURL)	\
    (This)->lpVtbl -> GetCodecURL(This,CodecNum,pbstrCodecURL)

#define IMediaPlayer_GetMoreInfoURL(This,MoreInfoType,pbstrMoreInfoURL)	\
    (This)->lpVtbl -> GetMoreInfoURL(This,MoreInfoType,pbstrMoreInfoURL)

#define IMediaPlayer_GetMediaInfoString(This,MediaInfoType,pbstrMediaInfo)	\
    (This)->lpVtbl -> GetMediaInfoString(This,MediaInfoType,pbstrMediaInfo)

#define IMediaPlayer_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#define IMediaPlayer_Open(This,bstrFileName)	\
    (This)->lpVtbl -> Open(This,bstrFileName)

#define IMediaPlayer_IsSoundCardEnabled(This,pbSoundCard)	\
    (This)->lpVtbl -> IsSoundCardEnabled(This,pbSoundCard)

#define IMediaPlayer_Next(This)	\
    (This)->lpVtbl -> Next(This)

#define IMediaPlayer_Previous(This)	\
    (This)->lpVtbl -> Previous(This)

#define IMediaPlayer_StreamSelect(This,StreamNum)	\
    (This)->lpVtbl -> StreamSelect(This,StreamNum)

#define IMediaPlayer_FastForward(This)	\
    (This)->lpVtbl -> FastForward(This)

#define IMediaPlayer_FastReverse(This)	\
    (This)->lpVtbl -> FastReverse(This)

#define IMediaPlayer_GetStreamName(This,StreamNum,pbstrStreamName)	\
    (This)->lpVtbl -> GetStreamName(This,StreamNum,pbstrStreamName)

#define IMediaPlayer_GetStreamGroup(This,StreamNum,pStreamGroup)	\
    (This)->lpVtbl -> GetStreamGroup(This,StreamNum,pStreamGroup)

#define IMediaPlayer_GetStreamSelected(This,StreamNum,pStreamSelected)	\
    (This)->lpVtbl -> GetStreamSelected(This,StreamNum,pStreamSelected)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CurrentPosition_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pCurrentPosition);


void __RPC_STUB IMediaPlayer_get_CurrentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_CurrentPosition_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ double CurrentPosition);


void __RPC_STUB IMediaPlayer_put_CurrentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Duration_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pDuration);


void __RPC_STUB IMediaPlayer_get_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ImageSourceWidth_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pWidth);


void __RPC_STUB IMediaPlayer_get_ImageSourceWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ImageSourceHeight_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pHeight);


void __RPC_STUB IMediaPlayer_get_ImageSourceHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_MarkerCount_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pMarkerCount);


void __RPC_STUB IMediaPlayer_get_MarkerCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CanScan_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanScan);


void __RPC_STUB IMediaPlayer_get_CanScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CanSeek_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanSeek);


void __RPC_STUB IMediaPlayer_get_CanSeek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CanSeekToMarkers_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanSeekToMarkers);


void __RPC_STUB IMediaPlayer_get_CanSeekToMarkers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CurrentMarker_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCurrentMarker);


void __RPC_STUB IMediaPlayer_get_CurrentMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_CurrentMarker_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long CurrentMarker);


void __RPC_STUB IMediaPlayer_put_CurrentMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_FileName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName);


void __RPC_STUB IMediaPlayer_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_FileName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB IMediaPlayer_put_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SourceLink_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceLink);


void __RPC_STUB IMediaPlayer_get_SourceLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CreationDate_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pCreationDate);


void __RPC_STUB IMediaPlayer_get_CreationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ErrorCorrection_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrErrorCorrection);


void __RPC_STUB IMediaPlayer_get_ErrorCorrection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Bandwidth_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pBandwidth);


void __RPC_STUB IMediaPlayer_get_Bandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SourceProtocol_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pSourceProtocol);


void __RPC_STUB IMediaPlayer_get_SourceProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ReceivedPackets_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pReceivedPackets);


void __RPC_STUB IMediaPlayer_get_ReceivedPackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_RecoveredPackets_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pRecoveredPackets);


void __RPC_STUB IMediaPlayer_get_RecoveredPackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_LostPackets_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pLostPackets);


void __RPC_STUB IMediaPlayer_get_LostPackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ReceptionQuality_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pReceptionQuality);


void __RPC_STUB IMediaPlayer_get_ReceptionQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_BufferingCount_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pBufferingCount);


void __RPC_STUB IMediaPlayer_get_BufferingCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_IsBroadcast_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsBroadcast);


void __RPC_STUB IMediaPlayer_get_IsBroadcast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_BufferingProgress_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pBufferingProgress);


void __RPC_STUB IMediaPlayer_get_BufferingProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ChannelName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelName);


void __RPC_STUB IMediaPlayer_get_ChannelName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ChannelDescription_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelDescription);


void __RPC_STUB IMediaPlayer_get_ChannelDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ChannelURL_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelURL);


void __RPC_STUB IMediaPlayer_get_ChannelURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ContactAddress_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContactAddress);


void __RPC_STUB IMediaPlayer_get_ContactAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ContactPhone_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContactPhone);


void __RPC_STUB IMediaPlayer_get_ContactPhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ContactEmail_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContactEmail);


void __RPC_STUB IMediaPlayer_get_ContactEmail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_BufferingTime_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pBufferingTime);


void __RPC_STUB IMediaPlayer_get_BufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_BufferingTime_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ double BufferingTime);


void __RPC_STUB IMediaPlayer_put_BufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AutoStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoStart);


void __RPC_STUB IMediaPlayer_get_AutoStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AutoStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL AutoStart);


void __RPC_STUB IMediaPlayer_put_AutoStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AutoRewind_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoRewind);


void __RPC_STUB IMediaPlayer_get_AutoRewind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AutoRewind_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL AutoRewind);


void __RPC_STUB IMediaPlayer_put_AutoRewind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Rate_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pRate);


void __RPC_STUB IMediaPlayer_get_Rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Rate_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ double Rate);


void __RPC_STUB IMediaPlayer_put_Rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendKeyboardEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendKeyboardEvents);


void __RPC_STUB IMediaPlayer_get_SendKeyboardEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendKeyboardEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendKeyboardEvents);


void __RPC_STUB IMediaPlayer_put_SendKeyboardEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendMouseClickEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendMouseClickEvents);


void __RPC_STUB IMediaPlayer_get_SendMouseClickEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendMouseClickEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendMouseClickEvents);


void __RPC_STUB IMediaPlayer_put_SendMouseClickEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendMouseMoveEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendMouseMoveEvents);


void __RPC_STUB IMediaPlayer_get_SendMouseMoveEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendMouseMoveEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendMouseMoveEvents);


void __RPC_STUB IMediaPlayer_put_SendMouseMoveEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_PlayCount_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pPlayCount);


void __RPC_STUB IMediaPlayer_get_PlayCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_PlayCount_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long PlayCount);


void __RPC_STUB IMediaPlayer_put_PlayCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ClickToPlay_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pClickToPlay);


void __RPC_STUB IMediaPlayer_get_ClickToPlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ClickToPlay_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL ClickToPlay);


void __RPC_STUB IMediaPlayer_put_ClickToPlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AllowScan_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllowScan);


void __RPC_STUB IMediaPlayer_get_AllowScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AllowScan_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL AllowScan);


void __RPC_STUB IMediaPlayer_put_AllowScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_EnableContextMenu_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnableContextMenu);


void __RPC_STUB IMediaPlayer_get_EnableContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_EnableContextMenu_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL EnableContextMenu);


void __RPC_STUB IMediaPlayer_put_EnableContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CursorType_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCursorType);


void __RPC_STUB IMediaPlayer_get_CursorType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_CursorType_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long CursorType);


void __RPC_STUB IMediaPlayer_put_CursorType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CodecCount_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCodecCount);


void __RPC_STUB IMediaPlayer_get_CodecCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AllowChangeDisplaySize_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllowChangeDisplaySize);


void __RPC_STUB IMediaPlayer_get_AllowChangeDisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AllowChangeDisplaySize_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL AllowChangeDisplaySize);


void __RPC_STUB IMediaPlayer_put_AllowChangeDisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_IsDurationValid_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsDurationValid);


void __RPC_STUB IMediaPlayer_get_IsDurationValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_OpenState_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pOpenState);


void __RPC_STUB IMediaPlayer_get_OpenState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendOpenStateChangeEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendOpenStateChangeEvents);


void __RPC_STUB IMediaPlayer_get_SendOpenStateChangeEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendOpenStateChangeEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendOpenStateChangeEvents);


void __RPC_STUB IMediaPlayer_put_SendOpenStateChangeEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendWarningEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendWarningEvents);


void __RPC_STUB IMediaPlayer_get_SendWarningEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendWarningEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendWarningEvents);


void __RPC_STUB IMediaPlayer_put_SendWarningEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendErrorEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendErrorEvents);


void __RPC_STUB IMediaPlayer_get_SendErrorEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendErrorEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendErrorEvents);


void __RPC_STUB IMediaPlayer_put_SendErrorEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_PlayState_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ MPPlayStateConstants __RPC_FAR *pPlayState);


void __RPC_STUB IMediaPlayer_get_PlayState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendPlayStateChangeEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendPlayStateChangeEvents);


void __RPC_STUB IMediaPlayer_get_SendPlayStateChangeEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendPlayStateChangeEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendPlayStateChangeEvents);


void __RPC_STUB IMediaPlayer_put_SendPlayStateChangeEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_DisplaySize_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ MPDisplaySizeConstants __RPC_FAR *pDisplaySize);


void __RPC_STUB IMediaPlayer_get_DisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_DisplaySize_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ MPDisplaySizeConstants DisplaySize);


void __RPC_STUB IMediaPlayer_put_DisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_InvokeURLs_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pInvokeURLs);


void __RPC_STUB IMediaPlayer_get_InvokeURLs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_InvokeURLs_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL InvokeURLs);


void __RPC_STUB IMediaPlayer_put_InvokeURLs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_BaseURL_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrBaseURL);


void __RPC_STUB IMediaPlayer_get_BaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_BaseURL_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrBaseURL);


void __RPC_STUB IMediaPlayer_put_BaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_DefaultFrame_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDefaultFrame);


void __RPC_STUB IMediaPlayer_get_DefaultFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_DefaultFrame_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrDefaultFrame);


void __RPC_STUB IMediaPlayer_put_DefaultFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_HasError_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHasError);


void __RPC_STUB IMediaPlayer_get_HasError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ErrorDescription_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrErrorDescription);


void __RPC_STUB IMediaPlayer_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ErrorCode_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pErrorCode);


void __RPC_STUB IMediaPlayer_get_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AnimationAtStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAnimationAtStart);


void __RPC_STUB IMediaPlayer_get_AnimationAtStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AnimationAtStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL AnimationAtStart);


void __RPC_STUB IMediaPlayer_put_AnimationAtStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_TransparentAtStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pTransparentAtStart);


void __RPC_STUB IMediaPlayer_get_TransparentAtStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_TransparentAtStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL TransparentAtStart);


void __RPC_STUB IMediaPlayer_put_TransparentAtStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Volume_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVolume);


void __RPC_STUB IMediaPlayer_get_Volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Volume_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long Volume);


void __RPC_STUB IMediaPlayer_put_Volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Balance_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pBalance);


void __RPC_STUB IMediaPlayer_get_Balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Balance_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long Balance);


void __RPC_STUB IMediaPlayer_put_Balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ReadyState_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ MPReadyStateConstants __RPC_FAR *pValue);


void __RPC_STUB IMediaPlayer_get_ReadyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SelectionStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pValue);


void __RPC_STUB IMediaPlayer_get_SelectionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SelectionStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ double Value);


void __RPC_STUB IMediaPlayer_put_SelectionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SelectionEnd_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pValue);


void __RPC_STUB IMediaPlayer_get_SelectionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SelectionEnd_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ double Value);


void __RPC_STUB IMediaPlayer_put_SelectionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowDisplay_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);


void __RPC_STUB IMediaPlayer_get_ShowDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowDisplay_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Show);


void __RPC_STUB IMediaPlayer_put_ShowDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);


void __RPC_STUB IMediaPlayer_get_ShowControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Show);


void __RPC_STUB IMediaPlayer_put_ShowControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowPositionControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);


void __RPC_STUB IMediaPlayer_get_ShowPositionControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowPositionControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Show);


void __RPC_STUB IMediaPlayer_put_ShowPositionControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowTracker_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);


void __RPC_STUB IMediaPlayer_get_ShowTracker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowTracker_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Show);


void __RPC_STUB IMediaPlayer_put_ShowTracker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_EnablePositionControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Enable);


void __RPC_STUB IMediaPlayer_get_EnablePositionControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_EnablePositionControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Enable);


void __RPC_STUB IMediaPlayer_put_EnablePositionControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_EnableTracker_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Enable);


void __RPC_STUB IMediaPlayer_get_EnableTracker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_EnableTracker_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Enable);


void __RPC_STUB IMediaPlayer_put_EnableTracker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Enabled_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnabled);


void __RPC_STUB IMediaPlayer_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Enabled_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Enabled);


void __RPC_STUB IMediaPlayer_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_DisplayForeColor_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *ForeColor);


void __RPC_STUB IMediaPlayer_get_DisplayForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_DisplayForeColor_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VB_OLE_COLOR ForeColor);


void __RPC_STUB IMediaPlayer_put_DisplayForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_DisplayBackColor_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *BackColor);


void __RPC_STUB IMediaPlayer_get_DisplayBackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_DisplayBackColor_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VB_OLE_COLOR BackColor);


void __RPC_STUB IMediaPlayer_put_DisplayBackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_DisplayMode_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ MPDisplayModeConstants __RPC_FAR *pValue);


void __RPC_STUB IMediaPlayer_get_DisplayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_DisplayMode_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ MPDisplayModeConstants Value);


void __RPC_STUB IMediaPlayer_put_DisplayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_VideoBorder3D_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVideoBorderWidth);


void __RPC_STUB IMediaPlayer_get_VideoBorder3D_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_VideoBorder3D_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL VideoBorderWidth);


void __RPC_STUB IMediaPlayer_put_VideoBorder3D_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_VideoBorderWidth_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVideoBorderWidth);


void __RPC_STUB IMediaPlayer_get_VideoBorderWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_VideoBorderWidth_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long VideoBorderWidth);


void __RPC_STUB IMediaPlayer_put_VideoBorderWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_VideoBorderColor_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *pVideoBorderWidth);


void __RPC_STUB IMediaPlayer_get_VideoBorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_VideoBorderColor_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VB_OLE_COLOR VideoBorderColor);


void __RPC_STUB IMediaPlayer_put_VideoBorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowGotoBar_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IMediaPlayer_get_ShowGotoBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowGotoBar_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IMediaPlayer_put_ShowGotoBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowStatusBar_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IMediaPlayer_get_ShowStatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowStatusBar_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IMediaPlayer_put_ShowStatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowCaptioning_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IMediaPlayer_get_ShowCaptioning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowCaptioning_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL pbool);


void __RPC_STUB IMediaPlayer_put_ShowCaptioning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowAudioControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IMediaPlayer_get_ShowAudioControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowAudioControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bBool);


void __RPC_STUB IMediaPlayer_put_ShowAudioControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CaptioningID_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pstrText);


void __RPC_STUB IMediaPlayer_get_CaptioningID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_CaptioningID_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR strText);


void __RPC_STUB IMediaPlayer_put_CaptioningID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Mute_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vbool);


void __RPC_STUB IMediaPlayer_get_Mute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Mute_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IMediaPlayer_put_Mute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CanPreview_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanPreview);


void __RPC_STUB IMediaPlayer_get_CanPreview_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_PreviewMode_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pPreviewMode);


void __RPC_STUB IMediaPlayer_get_PreviewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_PreviewMode_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL PreviewMode);


void __RPC_STUB IMediaPlayer_put_PreviewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_HasMultipleItems_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHasMuliItems);


void __RPC_STUB IMediaPlayer_get_HasMultipleItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Language_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pLanguage);


void __RPC_STUB IMediaPlayer_get_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Language_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long Language);


void __RPC_STUB IMediaPlayer_put_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AudioStream_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pStream);


void __RPC_STUB IMediaPlayer_get_AudioStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AudioStream_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long Stream);


void __RPC_STUB IMediaPlayer_put_AudioStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SAMIStyle_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStyle);


void __RPC_STUB IMediaPlayer_get_SAMIStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SAMIStyle_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrStyle);


void __RPC_STUB IMediaPlayer_put_SAMIStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SAMILang_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrLang);


void __RPC_STUB IMediaPlayer_get_SAMILang_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SAMILang_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrLang);


void __RPC_STUB IMediaPlayer_put_SAMILang_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SAMIFileName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName);


void __RPC_STUB IMediaPlayer_get_SAMIFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SAMIFileName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB IMediaPlayer_put_SAMIFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_StreamCount_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pStreamCount);


void __RPC_STUB IMediaPlayer_get_StreamCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ClientId_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrClientId);


void __RPC_STUB IMediaPlayer_get_ClientId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ConnectionSpeed_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plConnectionSpeed);


void __RPC_STUB IMediaPlayer_get_ConnectionSpeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AutoSize_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IMediaPlayer_get_AutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AutoSize_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IMediaPlayer_put_AutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_EnableFullScreenControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);


void __RPC_STUB IMediaPlayer_get_EnableFullScreenControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_EnableFullScreenControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bVal);


void __RPC_STUB IMediaPlayer_put_EnableFullScreenControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ActiveMovie_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispatch);


void __RPC_STUB IMediaPlayer_get_ActiveMovie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_NSPlay_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispatch);


void __RPC_STUB IMediaPlayer_get_NSPlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_WindowlessVideo_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IMediaPlayer_get_WindowlessVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_WindowlessVideo_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bool);


void __RPC_STUB IMediaPlayer_put_WindowlessVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Play_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Stop_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Pause_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetMarkerTime_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long MarkerNum,
    /* [retval][out] */ double __RPC_FAR *pMarkerTime);


void __RPC_STUB IMediaPlayer_GetMarkerTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetMarkerName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long MarkerNum,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMarkerName);


void __RPC_STUB IMediaPlayer_GetMarkerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_AboutBox_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_AboutBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetCodecInstalled_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long CodecNum,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCodecInstalled);


void __RPC_STUB IMediaPlayer_GetCodecInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetCodecDescription_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long CodecNum,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCodecDescription);


void __RPC_STUB IMediaPlayer_GetCodecDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetCodecURL_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long CodecNum,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCodecURL);


void __RPC_STUB IMediaPlayer_GetCodecURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetMoreInfoURL_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ MPMoreInfoType MoreInfoType,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMoreInfoURL);


void __RPC_STUB IMediaPlayer_GetMoreInfoURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetMediaInfoString_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ MPMediaInfoType MediaInfoType,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMediaInfo);


void __RPC_STUB IMediaPlayer_GetMediaInfoString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Cancel_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Open_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB IMediaPlayer_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_IsSoundCardEnabled_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSoundCard);


void __RPC_STUB IMediaPlayer_IsSoundCardEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Next_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Previous_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_StreamSelect_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long StreamNum);


void __RPC_STUB IMediaPlayer_StreamSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_FastForward_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_FastForward_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_FastReverse_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_FastReverse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetStreamName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long StreamNum,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStreamName);


void __RPC_STUB IMediaPlayer_GetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetStreamGroup_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long StreamNum,
    /* [retval][out] */ long __RPC_FAR *pStreamGroup);


void __RPC_STUB IMediaPlayer_GetStreamGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetStreamSelected_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long StreamNum,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStreamSelected);


void __RPC_STUB IMediaPlayer_GetStreamSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaPlayer_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\color.cpp ===
// color.cpp : Implementation of color.h
#include "priv.h"

#include <shlwapi.h>
#include <exdispid.h>
#include <shguidp.h>
#include <hlink.h>
#include <color.h>

COLORREF ColorRefFromHTMLColorStrA(LPCSTR pszColor)
{
    WCHAR wzColor[MAX_COLOR_STR];

    SHAnsiToUnicode(pszColor, wzColor, ARRAYSIZE(wzColor));

    if (wzColor[0] == '#')
        return HashStrToColorRefW(wzColor);

    return ColorRefFromHTMLColorStrW(wzColor);
}

COLORREF ColorRefFromHTMLColorStrW(LPCWSTR pwzColor)    
{
    int min, max, i, cmp;

    if (pwzColor[0] == '#')
        return HashStrToColorRefW(pwzColor);

    // Look for in regular colors
    min = 0;
    max = NUM_HTML_COLORS-1;

    while (min <= max)
    {
        i = (min + max) / 2;
        cmp = StrCmpW(pwzColor, ColorNames[i].pwzColorName);
        if (cmp < 0)
            max = i-1;
        else if (cmp > 0)
            min = i+1;
        else return ColorNames[i].colorRef;
    }

    // Look for in system colors
    min = 0;
    max = NUM_SYS_COLORS-1;

    while (min <= max)
    {
        i = (min + max) / 2;
        cmp = StrCmpW(pwzColor, SysColorNames[i].pwzColorName);
        if (cmp < 0)
            max = i-1;
        else if (cmp > 0)
            min = i+1;
        else return GetSysColor(SysColorNames[i].colorIndex);
    }

    return 0xffffff;        // return white as default color
}

COLORREF HashStrToColorRefW(LPCWSTR pwzHashStr)
{   
    DWORD retColor = 0;
    int   numBytes = lstrlenW(pwzHashStr);
    DWORD thisByte;

    // don't look at the first character because you know its a #

    for (int i=0 ; i < numBytes-1 ; i++)
    {
        thisByte = HexCharToDWORDW(pwzHashStr[numBytes-i-1]);
        retColor |= thisByte << (i*4);
    }
    return (COLORREF)retColor;
}

COLORREF HashStrToColorRefA(LPCSTR pszHashStr)
{
    WCHAR wzHashStr[MAX_COLOR_STR];

    SHAnsiToUnicode(pszHashStr, wzHashStr, ARRAYSIZE(wzHashStr));

    return HashStrToColorRefW(wzHashStr);
}

DWORD HexCharToDWORDW(WCHAR wcHexNum)
{
    if ((wcHexNum >= '0') && (wcHexNum <= '9'))
        return (wcHexNum - '0');

    if ((wcHexNum >= 'a') && (wcHexNum <= 'f'))
        return (wcHexNum - 'a' + 10);

    if ((wcHexNum >= 'A') && (wcHexNum <= 'F'))
        return (wcHexNum - 'A' + 10);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\color.h ===
// color.h: declaration of functions to deal with HTML color

#ifndef __COLOR_H_
#define COLOR_H_

#define MAX_COLOR_STR       30
#define NUM_HTML_COLORS     140 
#define NUM_SYS_COLORS      28
#define MAX_BINARY_STR      40    

struct ColorPair_S {
    WCHAR       *pwzColorName;
    COLORREF    colorRef;
};

struct ColorPair2_S {
    WCHAR       *pwzColorName;
    int         colorIndex;
};

const ColorPair_S ColorNames[] =
{
    { L"aliceblue",             0xfff8f0 },
    { L"antiquewhite",          0xd7ebfa },
    { L"aqua",                  0xffff00 },
    { L"aquamarine",            0xd4ff7f },
    { L"azure",                 0xfffff0 },
    { L"beige",                 0xdcf5f5 },
    { L"bisque",                0xc4e4ff },
    { L"black",                 0x000000 },
    { L"blanchedalmond",        0xcdebff },
    { L"blue",                  0xff0000 },
    { L"blueviolet",            0xe22b8a },
    { L"brown",                 0x2a2aa5 },
    { L"burlywood",             0x87b8de },
    { L"cadetblue",             0xa09e5f },
    { L"chartreuse",            0x00ff7f },
    { L"chocolate",             0x1e69d2 },
    { L"coral",                 0x507fff },
    { L"cornflowerblue",        0xed9564 },
    { L"cornsilk",              0xdcf8ff },
    { L"crimson",               0x3c14dc },
    { L"cyan",                  0xffff00 },
    { L"darkblue",              0x8b0000 },
    { L"darkcyan",              0x8b8b00 },
    { L"darkgoldenrod",         0x0b86b8 },
    { L"darkgray",              0xa9a9a9 },
    { L"darkgreen",             0x006400 },
    { L"darkkhaki",             0x6bb7bd },
    { L"darkmagenta",           0x8b008b },
    { L"darkolivegreen",        0x2f6b55 },
    { L"darkorange",            0x008cff },
    { L"darkorchid",            0xcc3299 },
    { L"darkred",               0x00008b },
    { L"darksalmon",            0x7a96e9 },
    { L"darkseagreen",          0x8fbc8f },
    { L"darkslateblue",         0x8b3d48 },
    { L"darkslategray",         0x4f4f2f },
    { L"darkturquoise",         0xd1ce00 },
    { L"darkviolet",            0xd30094 },
    { L"deeppink",              0x9314ff },
    { L"deepskyblue",           0xffbf00 },
    { L"dimgray",               0x696969 },
    { L"dodgerblue",            0xff901e },
    { L"firebrick",             0x2222b2 },
    { L"floralwhite",           0xf0faff },
    { L"forestgreen",           0x228b22 },
    { L"fuchsia",               0xff00ff },
    { L"gainsboro",             0xdcdcdc },
    { L"ghostwhite",            0xfff8f8 },
    { L"gold",                  0x00d7ff },
    { L"goldenrod",             0x20a5da },
    { L"gray",                  0x808080 },
    { L"green",                 0x008000 },
    { L"greenyellow",           0x2fffad },
    { L"honeydew",              0xf0fff0 },
    { L"hotpink",               0xb469ff },
    { L"indianred",             0x5c5ccd },
    { L"indigo",                0x82004b },
    { L"ivory",                 0xf0ffff },
    { L"khaki",                 0x8ce6f0 },
    { L"lavender",              0xfae6e6 },
    { L"lavenderblush",         0xf5f0ff },
    { L"lawngreen",             0x00fc7c },
    { L"lemonchiffn",           0xcdfaff },
    { L"lightblue",             0xe6d8ad },
    { L"lightcoral",            0x8080f0 },
    { L"lightcyan",             0xffffe0 },
    { L"lightgoldenrodyellow",  0xd2fafa },
    { L"lightgreen",            0x90ee90 },
    { L"lightgrey",             0xd3d3d3 },
    { L"lightpink",             0xc1b6ff },
    { L"lightsalmon",           0x7aa0ff },
    { L"lightseagreen",         0xaab220 },
    { L"lightskyblue",          0xface87 },
    { L"lightslategray",        0x998877 },
    { L"lightsteelblue",        0xdec4b0 },
    { L"lightyellow",           0xe0ffff },
    { L"lime",                  0x00ff00 },
    { L"limegreen",             0x32cd32 },
    { L"linen",                 0xe6f0fa },
    { L"magenta",               0xff00ff },
    { L"maroon",                0x000080 },
    { L"mediumaquamarine",      0xaacd66 },
    { L"mediumblue",            0xcd0000 },
    { L"mediumorchid",          0xd355ba },
    { L"mediumpurple",          0xdb7093 },
    { L"mediumseagreen",        0x71b33c },
    { L"mediumslateblue",       0xee687b },
    { L"mediumspringgreen",     0x9afa00 },
    { L"mediumturquoise",       0xccd148 },
    { L"mediumvioletred",       0x8515c7 },
    { L"midnightblue",          0x701919 },
    { L"mintcream",             0xfafff5 },
    { L"mistyrose",             0xe1e4ff },
    { L"moccasin",              0xb5e4ff },
    { L"navajowhite",           0xaddeff },
    { L"navy",                  0x800000 },
    { L"oldlace",               0xe6f5fd },
    { L"olive",                 0x008080 },
    { L"olivedrab",             0x238e6b },
    { L"orange",                0x00a5ff },
    { L"orangered",             0x0045ff },
    { L"orchid",                0xd670da },
    { L"palegoldenrod",         0xaae8ee },
    { L"palegreen",             0x98fb98 },
    { L"paleturquoise",         0xeeeeaf },
    { L"palevioletred",         0x9370db },
    { L"papayawhip",            0xd5efff },
    { L"peachpuff",             0xb9daff },
    { L"peru",                  0x3f85cd },
    { L"pink",                  0xcbc0ff },
    { L"plum",                  0xdda0dd },
    { L"powderblue",            0xe6e0b0 },
    { L"purple",                0x800080 },
    { L"red",                   0x0000ff },
    { L"rosybrown",             0x8f8fbc },
    { L"royalblue",             0xe16941 },
    { L"saddlebrown",           0x13458b },
    { L"salmon",                0x7280fa },
    { L"sandybrown",            0x60a4f4 },
    { L"seagreen",              0x578b2e },
    { L"seashell",              0xeef5ff },
    { L"sienna",                0x2d52a0 },
    { L"silver",                0xc0c0c0 },
    { L"skyblue",               0xebce87 },
    { L"slateblue",             0xcd5a6a },
    { L"slategray",             0x908070 },
    { L"snow",                  0xfafaff },
    { L"springgreen",           0x7fff00 },
    { L"steelblue",             0xb48246 },
    { L"tan",                   0x8cb4d2 },
    { L"teal",                  0x808000 },
    { L"thistle",               0xd8bfd8 },
    { L"tomato",                0x4763ff },
    { L"turquoise",             0xd0e040 },
    { L"violet",                0xee82ee },
    { L"wheat",                 0xb3def5 },
    { L"white",                 0xffffff },
    { L"whitesmoke",            0xf5f5f5 },
    { L"yellow",                0x00ffff },
    { L"yellowgreen",           0x32cd9a }
};

const ColorPair2_S SysColorNames[] =
{    
    { L"activeborder",          COLOR_ACTIVEBORDER},    // Active window border.
    { L"activecaption",         COLOR_ACTIVECAPTION},   // Active window caption.
    { L"appworkspace",          COLOR_APPWORKSPACE},    // Background color of multiple document interface (MDI) applications.
    { L"background",            COLOR_BACKGROUND},      // Desktop background.
    { L"buttonface",            COLOR_BTNFACE},         // Face color for three-dimensional display elements.
    { L"buttonhighlight",       COLOR_BTNHIGHLIGHT},    // Dark shadow for three-dimensional display elements.
    { L"buttonshadow",          COLOR_BTNSHADOW},       // Shadow color for three-dimensional display elements (for edges facing away from the light source).
    { L"buttontext",            COLOR_BTNTEXT},         // Text on push buttons.
    { L"captiontext",           COLOR_CAPTIONTEXT},     // Text in caption, size box, and scroll bar arrow box.
    { L"graytext",              COLOR_GRAYTEXT},        // Grayed (disabled) text. This color is set to 0 if the current display driver does not support a solid gray color.
    { L"highlight",             COLOR_HIGHLIGHT},       // Item(s) selected in a control.
    { L"highlighttext",         COLOR_HIGHLIGHTTEXT},   // Text of item(s) selected in a control.
    { L"inactiveborder",        COLOR_INACTIVEBORDER},  // Inactive window border.
    { L"inactivecaption",       COLOR_INACTIVECAPTION}, // Inactive window caption.
    { L"inactivecaptiontext",   COLOR_INACTIVECAPTIONTEXT}, // Color of text in an inactive caption.
    { L"infobackground",        COLOR_INFOBK},          // Background color for tooltip controls.
    { L"infotext",              COLOR_INFOTEXT},        // Text color for tooltip controls.
    { L"menu",                  COLOR_MENU},            // Menu background.
    { L"menutext",              COLOR_MENUTEXT},        // Text in menus.
    { L"scrollbar",             COLOR_SCROLLBAR},       // Scroll bar gray area.
    { L"threeddarkshadow",      COLOR_3DDKSHADOW },     // Dark shadow for three-dimensional display elements.
    { L"threedface",            COLOR_3DFACE},
    { L"threedhighlight",       COLOR_3DHIGHLIGHT},     // Highlight color for three-dimensional display elements (for edges facing the light source.)
    { L"threedlightshadow",     COLOR_3DLIGHT},         // Light color for three-dimensional display elements (for edges facing the light source.)
    { L"threedshadow",          COLOR_3DSHADOW},        // Dark shadow for three-dimensional display elements.
    { L"window",                COLOR_WINDOW},          // Window background.
    { L"windowframe",           COLOR_WINDOWFRAME},     // Window frame.
    { L"windowtext",            COLOR_WINDOWTEXT}       // Text in windows.
};

COLORREF ColorRefFromHTMLColorStrA(LPCSTR pszColor);

COLORREF ColorRefFromHTMLColorStrW(LPCWSTR pwzColor); 

COLORREF HashStrToColorRefW(LPCWSTR pwzHashStr); 

COLORREF HashStrToColorRefA(LPCSTR pszHashStr);

DWORD HexCharToDWORDW(WCHAR wcHexNum);

#endif //__COLOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\evtsink.cpp ===
#include "priv.h"
#include "evtsink.h"
#include "mshtml.h"
#include "mshtmdid.h"
#include "dispex.h"

CDispatchEventSink::CDispatchEventSink() : m_cRef(1)
{
}

CDispatchEventSink::~CDispatchEventSink()
{
}

STDMETHODIMP CDispatchEventSink::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IUnknown || riid == IID_IDispatch) {
        *ppv = SAFECAST(this, IDispatch*);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDispatchEventSink::AddRef(void)
{
    m_cRef += 1;
    
    return m_cRef;
}

STDMETHODIMP_(ULONG) CDispatchEventSink::Release(void)
{
    m_cRef -= 1;

    if (m_cRef != 0) {      
        return m_cRef;
    }

    delete this;
    return 0;
}

STDMETHODIMP CDispatchEventSink::GetTypeInfoCount(UINT *pctInfo)
{
    *pctInfo = 0;
    return NOERROR;
}

STDMETHODIMP CDispatchEventSink::GetTypeInfo(UINT iTInfo, LCID lcid, 
                                            ITypeInfo **pptInfo)
{
    *pptInfo = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CDispatchEventSink::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
                             UINT cNames, LCID lcid, DISPID *rgDispId)
{
    if (riid != IID_NULL) {
        return DISP_E_UNKNOWNINTERFACE;
    }

    return DISP_E_UNKNOWNNAME;
}

/////////////////////////////////////////////////////////////////////////////
// Window event sink helpers

HRESULT ConnectHtmlEvents(IDispatch *pdispSink, CComPtr<IOleClientSite> &spClientSite, IDispatch **ppdispWindow,
                          DWORD *pdwCookie) 
{
    HRESULT                      hr;
    CComPtr<IOleContainer>       spContainer;
    CComPtr<IHTMLDocument2>      spHTMLDoc;
    CComPtr<IHTMLWindow2>        spWindow;

    *ppdispWindow = NULL;
    
    //
    // Get the browser window object
    //

    IfFailRet(spClientSite->GetContainer(&spContainer));
    IfFailRet(spContainer->QueryInterface(IID_IHTMLDocument2, (void **)&spHTMLDoc));
    
    IfFailRet(spHTMLDoc->get_parentWindow(&spWindow));

    
    IfFailRet(spWindow->QueryInterface(IID_IDispatch, (void **)ppdispWindow));

    //
    // Connect the event sink
    //

    if (FAILED(AtlAdvise(*ppdispWindow, pdispSink, IID_IDispatch, 
                         pdwCookie)))
       ATOMICRELEASE(*ppdispWindow);

    return S_OK;
}

HRESULT DisconnectHtmlEvents(IDispatch * pdispWindow, DWORD dwCookie) 
{
    HRESULT  hr;
    //
    // Get the browser window object
    //
    if (pdispWindow == NULL) {
        return S_OK; // Nothing to cleanup
    }
    
    //
    // Disconnect the event sink
    //
    hr = AtlUnadvise(pdispWindow, IID_IDispatch, dwCookie);

    //
    // Release the HTML window dispatch
    //
    ATOMICRELEASE(pdispWindow);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\evtsink.h ===
// wvcoord.h : Declaration of the CWebViewCoord

#ifndef __EVTSINK_H_
#define __EVTSINK_H_

/////////////////////////////////////////////////////////////////////////////
// CDispatchEventSink

class CDispatchEventSink : public IDispatch {
  public:
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    // IDispatch methods
    //

    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
    STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR __RPC_FAR *rgszNames,
                             UINT cNames, LCID lcid, DISPID *rgDispId);
    STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr) PURE;

protected:
    virtual ~CDispatchEventSink();
    CDispatchEventSink();

private:
    UINT      m_cRef;                          // IUnknown reference count
};

/////////////////////////////////////////////////////////////////////////////
// WindowEventSink Helpers

HRESULT ConnectHtmlEvents(IDispatch *pdispSink, CComPtr<IOleClientSite> &spClientSite, IDispatch ** ppdispWindow, DWORD *pdwCookie);
HRESULT DisconnectHtmlEvents(IDispatch *pdispWindow, DWORD dwCookie);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\filewrap.cpp ===
// wvcoord.cpp : Implementation of CWebViewCoord

#include "priv.h"
#include "wvcoord.h"
#include "shdispid.h"

/////////////////////////////////////////////////////////////////////////////
// String Constants
/////////////////////////////////////////////////////////////////////////////
#define CSC_PLUSCOLD        L"<img id=CSCBmp align=middle src=pluscold.gif>"
#define CSC_PLUSHOT         L"<img id=CSCBmp align=middle src=plushot.gif>"
#define CSC_MINUSCOLD       L"<img id=CSCBmp align=middle src=mincold.gif>"
#define CSC_MINUSHOT        L"<img id=CSCBmp align=middle src=minhot.gif>"
#define WV_LINKNAME         L"WVLink"

/////////////////////////////////////////////////////////////////////////////
// CFileListWrapper
/////////////////////////////////////////////////////////////////////////////

CFileListWrapper::CFileListWrapper() 
{
    m_pThumbNailWrapper = NULL;
    m_bCSCDisplayed = FALSE;
    m_bExpanded = FALSE;
    m_bHotTracked = FALSE;
    m_dwDateFlags = FDTF_DEFAULT;    // default
    m_bRTLDocument = FALSE;      // default
}

#define MYDOCS_CLSID    L"{450d8fba-ad25-11d0-98a8-0800361b1103}"   // CLSID_MyDocuments

HRESULT GetFolderIDList(int nFolder, LPITEMIDLIST* ppidlFolder)
{
    HRESULT hr = E_FAIL;

    if (nFolder == CSIDL_PERSONAL)
    {
        hr = SHILCreateFromPath(L"::" MYDOCS_CLSID, ppidlFolder, NULL);
    }
    else
    {
        hr = SHGetSpecialFolderLocation(NULL, nFolder, ppidlFolder);
    }
    return hr;
}

HRESULT CFileListWrapper::IsItThisFolder(int nFolder, BOOL& bResult, LPWSTR pwszDisplayName, DWORD cchDisplayName, LPWSTR pwszUrlPath, DWORD cchUrlPath)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlFolder = NULL, pidlLast = NULL;
    CComPtr<IShellFolder> psfParent;
    STRRET strret;
    CComBSTR bstrTemp;
    WCHAR wszPath[MAX_PATH];

    if (SUCCEEDED(GetFolderIDList(nFolder, &pidlFolder))
            && SUCCEEDED(SHBindToIDListParent(pidlFolder, IID_IShellFolder, (void**)&psfParent, (LPCITEMIDLIST*)&pidlLast))
            && SUCCEEDED(psfParent->GetDisplayNameOf(pidlLast, SHGDN_NORMAL, &strret))
            && SUCCEEDED(StrRetToBufW(&strret, pidlFolder, pwszDisplayName, cchDisplayName))
            && SUCCEEDED(psfParent->GetDisplayNameOf(pidlLast, SHGDN_FORPARSING, &strret))
            && SUCCEEDED(StrRetToBufW(&strret, pidlFolder, wszPath, ARRAYSIZE(wszPath)))
            && SUCCEEDED(m_spFolderItem->get_Path(&bstrTemp)) && (bstrTemp.Length() > 0))
    {
        hr = S_OK;
        bResult = (StrCmpIW(bstrTemp, wszPath) == 0);
        if (CSIDL_PERSONAL == nFolder)
        {
            // Change the URL for mydocs (after comparing with the path) so that it
            // is a CLSID URL instead of the file system path
            StrCpyNW(wszPath, L"::" MYDOCS_CLSID, ARRAYSIZE(wszPath));
        }
        UrlCreateFromPathW(wszPath, pwszUrlPath, &cchUrlPath, 0);
    }
    if (pidlFolder)
    {
        ILFree(pidlFolder);
    }
    return hr;
}

HRESULT CFileListWrapper::GetIMediaPlayer(CComPtr<IMediaPlayer>& spIMediaPlayer)
{
// The MediaPlayer objects has too many bugs. So, let's disable it.
#if 0
    if (!m_spIMediaPlayer)
    {
        if (m_spMediaPlayerSpan)
        {
            m_spMediaPlayerSpan->put_innerHTML(OLESTR("<object ID=MediaPlayer classid=\"clsid:22D6F312-B0F6-11D0-94AB-0080C74C7E95\" style=\"display:none; position:absolute; width:176px\"> <param name=\"ShowDisplay\" value=false> <param name=\"AutoPlay\" value=false> </object><br>"));
        }
        
        CComPtr<IHTMLElementCollection> spDocAll;
        CComVariant                     vEmpty;
        CComPtr<IDispatch>              spdispItem;
        if (SUCCEEDED(m_spDocument->get_all(&spDocAll)) && SUCCEEDED(spDocAll->item(CComVariant(OLESTR("MediaPlayer")), vEmpty, &spdispItem)) && spdispItem)
        {
            if (FAILED(FindObjectStyle(spdispItem, m_spMediaPlayerStyle)))
            {
                m_spMediaPlayerStyle = NULL;
            }
            if (FAILED(spdispItem->QueryInterface(IID_IMediaPlayer, (void **)&m_spIMediaPlayer)))
            {
                m_spIMediaPlayer = NULL;
            }
            else
            {
                m_spIMediaPlayer->put_EnableContextMenu(VARIANT_FALSE);
            }
            spdispItem = NULL;
        }
        spDocAll = NULL;
    }
#endif
    spIMediaPlayer = m_spIMediaPlayer;
    return spIMediaPlayer ? S_OK : E_FAIL;
}

HRESULT CFileListWrapper::FormatCrossLink(LPCWSTR pwszDisplayName, LPCWSTR pwszUrlPath, UINT uIDToolTip)
{
    m_bstrCrossLinksHTML += OLESTR("<p class=Half><a href=\"");
    m_bstrCrossLinksHTML += pwszUrlPath;
    m_bstrCrossLinksHTML += OLESTR("\"");

    WCHAR wszToolTip[MAX_PATH];
    wszToolTip[0] = L'\0';
    if (LoadStringW(_Module.GetResourceInstance(), uIDToolTip, wszToolTip, ARRAYSIZE(wszToolTip)) > 0)
    {
        m_bstrCrossLinksHTML += OLESTR(" title=\"");
        m_bstrCrossLinksHTML += wszToolTip;
        m_bstrCrossLinksHTML += OLESTR("\"");
    }
    m_bstrCrossLinksHTML += OLESTR(" name=\"");
    m_bstrCrossLinksHTML += WV_LINKNAME;
    m_bstrCrossLinksHTML += OLESTR("\"");
    m_bstrCrossLinksHTML += OLESTR(">");
    m_bstrCrossLinksHTML += pwszDisplayName;
    m_bstrCrossLinksHTML += OLESTR("</a>");
    return S_OK;
}

HRESULT CFileListWrapper::GetCrossLink(int nFolder, UINT uIDToolTip)
{
    HRESULT hres = E_FAIL;  // Assume error
    // Get the links.
    WCHAR wszDisplayName[MAX_PATH], wszUrlPath[MAX_PATH];
    BOOL bThisFolder;
    if (SUCCEEDED(IsItThisFolder(nFolder, bThisFolder, wszDisplayName, ARRAYSIZE(wszDisplayName), wszUrlPath, ARRAYSIZE(wszUrlPath)))
            && !bThisFolder)
    {
        hres = FormatCrossLink(wszDisplayName, wszUrlPath, uIDToolTip);
    }
    return hres;
}

HRESULT CFileListWrapper::GetCrossLinks()
{
    WCHAR wszSeeAlso[MAX_PATH];
    m_bstrCrossLinksHTML += OLESTR("<p>");
    LoadStringW(_Module.GetResourceInstance(), IDS_SEEALSO, wszSeeAlso, ARRAYSIZE(wszSeeAlso));
    m_bstrCrossLinksHTML += wszSeeAlso;

    GetCrossLink(CSIDL_PERSONAL, IDS_MYDOCSTEXT);
    if (!SHRestricted(REST_NONETHOOD))
    {
        GetCrossLink(CSIDL_NETWORK, IDS_MYNETPLACESTEXT);
    }
    if (FAILED(GetCrossLink(CSIDL_DRIVES, IDS_MYCOMPTEXT)) && !SHRestricted(REST_NONETHOOD))
    {
        // This is the My Computer folder - Add a link to Network and Dial-up Connections folder
        WCHAR wszNDC[MAX_PATH];
        wszNDC[0] = L'\0';
        LoadStringW(_Module.GetResourceInstance(), IDS_NDC, wszNDC, ARRAYSIZE(wszNDC));

        FormatCrossLink(wszNDC, L"shell:ConnectionsFolder", IDS_NDCTEXT);
    }
    
    return S_OK;
}

// The Media Player folks haven't published the IMediaPlayer interface, so I define it here.
// Should strip it out when their declaration makes it to the public headers.
const IID IID_IMediaPlayer = {0x22D6F311,0xB0F6,0x11D0,{0x94,0xAB,0x00,0x80,0xC7,0x4C,0x7E,0x95}};

HRESULT CFileListWrapper::Init(
                    CComPtr<IShellFolderViewDual>  spFileList,
                    CComPtr<IHTMLElement>          spInfo,
                    CComPtr<IHTMLElement>          spLinks,
                    CComPtr<IHTMLStyle>            spPanelStyle,
                    CComPtr<IHTMLElement>          spMediaPlayerSpan,
                    CComPtr<IHTMLElement>          spCSCPlusMin,
                    CComPtr<IHTMLElement>          spCSCText,
                    CComPtr<IHTMLElement>          spCSCDetail,
                    CComPtr<IHTMLElement>          spCSCButton,
                    CComPtr<IHTMLStyle>            spCSCStyle,
                    CComPtr<IHTMLStyle>            spCSCDetailStyle,
                    CComPtr<IHTMLStyle>            spCSCButtonStyle,
                    CComPtr<IHTMLDocument2>        spDocument,
                    CComPtr<IHTMLWindow2>          spWindow,
                    CThumbNailWrapper              *pThumbNailWrapper)
{
    m_spFileList = spFileList;
    m_spInfo = spInfo;
    m_spLinks = spLinks;
    m_spPanelStyle = spPanelStyle;
    m_spMediaPlayerSpan = spMediaPlayerSpan;
    m_spMediaPlayerStyle = NULL;
    m_spIMediaPlayer = NULL;
    m_spCSCPlusMin = spCSCPlusMin;
    m_spCSCText = spCSCText;
    m_spCSCDetail = spCSCDetail;
    m_spCSCButton = spCSCButton;
    m_spCSCStyle = spCSCStyle;
    m_spCSCDetailStyle = spCSCDetailStyle;
    m_spCSCButtonStyle = spCSCButtonStyle;
    m_spDocument = spDocument;
    m_spWindow = spWindow;
    m_pThumbNailWrapper = pThumbNailWrapper;
    if (m_pThumbNailWrapper)
    {
        m_pThumbNailWrapper->AddRef();
    }
    m_bNeverGotPanelInfo = TRUE;

    // Find out if the reading order is from right to left
    m_dwDateFlags = FDTF_DEFAULT;    // default

    m_bRTLDocument = IsRTLDocument(m_spDocument);      // default

    // Get the date format reading order
    LCID locale = GetUserDefaultLCID();
    if ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) || 
        (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW))
    {
        
            if (m_bRTLDocument)
                m_dwDateFlags |= FDTF_RTLDATE;
            else
                m_dwDateFlags |= FDTF_LTRDATE;
    }

    m_bPathIsSlow = FALSE;  // default

    // Make sure that the path is not slow
    CComPtr<Folder>      spFolder;
    CComPtr<Folder2>     spFolder2;
    CComPtr<FolderItem>  spFolderItem;
    CComBSTR bstrPath;
    
    if (m_spFileList && SUCCEEDED(m_spFileList->get_Folder(&spFolder))
                && SUCCEEDED(spFolder->QueryInterface(IID_Folder2, (void **)&spFolder2))
                && SUCCEEDED(spFolder2->get_Self(&spFolderItem))
                && SUCCEEDED(spFolderItem->get_Path(&bstrPath)))
    {
        m_bPathIsSlow = PathIsSlowW(bstrPath, -1);
    }

    return S_OK;
}

CFileListWrapper::~CFileListWrapper()
{
    // Release any objects we are holding references to
    m_spFileList = NULL;
    m_spInfo    = NULL;
    m_spLinks    = NULL;
    m_spPanelStyle = NULL;
    m_spIMediaPlayer = NULL;
    m_spMediaPlayerSpan = NULL;
    m_spMediaPlayerStyle = NULL;
    m_spIMediaPlayer = NULL;
    m_spCSCPlusMin = NULL;
    m_spCSCText = NULL;
    m_spCSCDetail = NULL;
    m_spCSCButton = NULL;
    m_spCSCStyle = NULL;
    m_spCSCDetailStyle = NULL;
    m_spCSCButtonStyle = NULL;
    m_spDocument = NULL;
    m_spWindow = NULL;

    // Release thumbnail wrapper
    if (m_pThumbNailWrapper)
    {
        m_pThumbNailWrapper->Release();
    }
}


STDMETHODIMP CFileListWrapper::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr) 
{
    HRESULT hr = S_OK;

    if (riid != IID_NULL)
    {
        hr = DISP_E_UNKNOWNINTERFACE;
    }
    else if (dispIdMember == DISPID_SELECTIONCHANGED)
    {
        hr = OnSelectionChanged();
    }
    else if (dispIdMember == DISPID_FILELISTENUMDONE)
    {
        hr = SetDefaultPanelDisplay();
    }
    else if (dispIdMember == DISPID_VERBINVOKED ||
             dispIdMember == DISPID_BEGINDRAG)
    {
        hr = StopMediaPlayer();
    }
    else if (dispIdMember == DISPID_HTMLELEMENTEVENTS_ONMOUSEOVER)
    {
        hr = OnWebviewLinkEvent( TRUE );
    }
    else if (dispIdMember == DISPID_HTMLELEMENTEVENTS_ONMOUSEOUT)
    {
        hr = OnWebviewLinkEvent( FALSE );
    }
    else if (dispIdMember == DISPID_HTMLELEMENTEVENTS_ONFOCUS)
    {
        hr = OnWebviewLinkEvent( TRUE );
    }
    else if (dispIdMember == DISPID_HTMLELEMENTEVENTS_ONBLUR)
    {
        hr = OnWebviewLinkEvent( FALSE );
    }
    
    
    return hr;
}

HRESULT CFileListWrapper::ClearThumbNail()
{
    if (m_pThumbNailWrapper)
    {
        m_pThumbNailWrapper->ClearThumbNail();
    }
    return S_OK;
}

HRESULT CFileListWrapper::StopMediaPlayer()
{
    if (m_spIMediaPlayer)
    {
        m_spIMediaPlayer->Stop();
    }
    return S_OK;
}

HRESULT CFileListWrapper::ClearMediaPlayer()
{
    StopMediaPlayer();
    if (m_spMediaPlayerStyle)
    {
        m_spMediaPlayerStyle->put_display(OLESTR("none"));
    }
    return S_OK;
}

HRESULT CFileListWrapper::OnSelectionChanged() 
{
    HRESULT hr = S_OK;

    if (m_spFileList)
    {
        // Erase any visible thumbnail since the selection changed
        ClearThumbNail();
        // Kill any preview
        ClearMediaPlayer();

        long cSelection = 0;
        CComPtr<FolderItems> spFolderItems;
        CComPtr<Folder>      spFolder;
        CComPtr<Folder2>     spFolder2;

        if (SUCCEEDED(m_spFileList->SelectedItems(&spFolderItems))
                && SUCCEEDED(spFolderItems->get_Count(&cSelection))
                && SUCCEEDED(m_spFileList->get_Folder(&spFolder))
                && SUCCEEDED(spFolder->QueryInterface(IID_Folder2, (void **)&spFolder2)))
        {
            m_spFolderItems = spFolderItems;
            m_spFolder2 = spFolder2;

            m_bstrInfoHTML = OLESTR("");
            m_bstrCrossLinksHTML = OLESTR("");

            if (cSelection == 0)
            {
                m_spFolderItems = NULL;
                if (SUCCEEDED(m_spFolder2->Items(&m_spFolderItems)))
                {
                    // Nothing is selected
                    hr = NoneSelected();
                }
            }
            else if (cSelection > 1)
            {
                // More than one item is selected
                hr = MultipleSelected(cSelection);
            }
            else
            {
                CComPtr<FolderItem>  spFolderItem;
                if (SUCCEEDED(m_spFolderItems->Item(CComVariant(0), &spFolderItem)))
                {
                    m_spFolderItem = spFolderItem;
                    m_spFolderItem->QueryInterface(IID_FolderItem2, (void **)&m_spFolderItem2);

                    // A single item has been selected
                    hr = OneSelected();

                    m_spFolderItem2 = NULL;
                    m_spFolderItem = NULL;
                }
            }

            DisplayInfoHTML();
            DisplayCrossLinksHTML();

            m_spFolder2 = NULL;
            m_spFolderItems = NULL;
        }
    }
    return hr;
}

HRESULT CFileListWrapper::SetDefaultPanelDisplay()
{
    CComPtr<Folder>      spFolder;
    CComPtr<Folder2>     spFolder2;
    CComPtr<FolderItems> spFolderItems;

    if (m_spFileList && SUCCEEDED(m_spFileList->get_Folder(&spFolder))
            && SUCCEEDED(spFolder->QueryInterface(IID_Folder2, (void **)&spFolder2))
            && SUCCEEDED(spFolder2->Items(&spFolderItems)))
    {
        m_bstrInfoHTML = OLESTR("");
        m_bstrCrossLinksHTML = OLESTR("");

        m_spFolderItems = spFolderItems;
        m_spFolder2 = spFolder2;

        NoneSelected();
        DisplayInfoHTML();
        DisplayCrossLinksHTML();

        m_spFolder2 = NULL;
        m_spFolderItems = NULL;
    }
    return S_OK;
}

HRESULT CFileListWrapper::DisplayInfoHTML()
{
    HRESULT hr = S_FALSE;
    if (m_spInfo)
    {
        // Replace Info.innerHTML with the new text
        hr = m_spInfo->put_innerHTML(m_bstrInfoHTML);
    }
    return hr;
}

HRESULT CFileListWrapper::DisplayCrossLinksHTML()
{
    HRESULT hr = S_FALSE;
    if (m_spLinks)
    {
        // Break old connections
        AdviseWebviewLinks( FALSE );
        
        // Replace Links.innerHTML with the new text
        hr = m_spLinks->put_innerHTML(m_bstrCrossLinksHTML);

        // Make new connections
        AdviseWebviewLinks( TRUE );
    }
    return hr;
}

BOOL IsExtensionOneOf(LPCWSTR pwszFileName, const LPCWSTR pwszExtList[], int cExtList)
{
    BOOL fRet = FALSE;
    LPCWSTR pwszExt = PathFindExtensionW(pwszFileName);

    if (pwszExt && *pwszExt)
    {
        for (int i = 0; i < cExtList; i++)
        {
            if (StrCmpICW(pwszExtList[i], pwszExt + 1) == 0) // Get pwszExt past "."
            {
                fRet = TRUE;
                break;
            }
        }
    }
    return fRet;
}

const LPCWSTR c_pwszMovieFileExt[] = {L"asf",L"avi",L"wmv",L"wvx",L"m1v",L"mov",L"mp2",L"mpa",L"mpe",L"mpeg",L"mpg",L"mpv2",L"qt",L"asx"};
BOOL IsMovieFile(LPCWSTR pwszFileName)
{
    return IsExtensionOneOf(pwszFileName, c_pwszMovieFileExt, ARRAYSIZE(c_pwszMovieFileExt));
}

const LPCWSTR c_pwszSoundFileExt[] = {L"aif",L"aiff",L"au",L"mid",L"midi",L"rmi",L"snd",L"wav",L"mp3",L"m3u",L"wma"};
BOOL IsSoundFile(LPCWSTR pwszFileName)
{
    return IsExtensionOneOf(pwszFileName, c_pwszSoundFileExt, ARRAYSIZE(c_pwszSoundFileExt));
}

HRESULT CFileListWrapper::DealWithDriveInfo()
{
    CComBSTR bstrPath;
    // Update ThumbNail
    if (m_pThumbNailWrapper && m_spFolderItem && SUCCEEDED(m_spFolderItem->get_Path(&bstrPath)) && (bstrPath.Length() > 0))
    {
        BOOL bRootFolder = PathIsRootW(bstrPath);
        BOOL bHaveThumbnail = FALSE;
        if (!bRootFolder || !PathIsUNCW(bstrPath))
        {
            bHaveThumbnail = m_pThumbNailWrapper->UpdateThumbNail(m_spFolderItem);
        }
        if (bHaveThumbnail)
        {
            if (bRootFolder)
            {
                WCHAR wszTemp[MAX_PATH];
                CComBSTR bstrSpace;

                if (SUCCEEDED(m_pThumbNailWrapper->TotalSpace(bstrSpace)))
                {
                    m_bstrInfoHTML += OLESTR("<p><br>");
                    IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_TOTALSIZE, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
                    m_bstrInfoHTML += wszTemp;
                    m_bstrInfoHTML += bstrSpace;
                    bstrSpace.Empty();
                    m_bstrInfoHTML += OLESTR("<p>");
                }
                if (SUCCEEDED(m_pThumbNailWrapper->UsedSpace(bstrSpace)))
                {
                    m_bstrInfoHTML += OLESTR("<p><table class=Legend width=12 height=12 border=1 align=");
                    if (m_bRTLDocument)
                    {
                        m_bstrInfoHTML += OLESTR("right ");
                    }
                    else
                    {
                        m_bstrInfoHTML += OLESTR("left ");
                    }
                    m_bstrInfoHTML += OLESTR("bgcolor=threedface bordercolordark=black bordercolorlight=black>");
                    m_bstrInfoHTML += OLESTR("<tr><td title=\'");
                    IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_USEDSPACE_DESC, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
                    m_bstrInfoHTML += wszTemp;
                    m_bstrInfoHTML += OLESTR("\'></td></tr></table>&nbsp;");
                    IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_USEDSPACE, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
                    m_bstrInfoHTML += wszTemp;
                    m_bstrInfoHTML += bstrSpace;
                    bstrSpace.Empty();
                }
                if (SUCCEEDED(m_pThumbNailWrapper->FreeSpace(bstrSpace)))
                {
                    m_bstrInfoHTML += OLESTR("<p><table class=Legend width=12 height=12 border=1 align=");
                    if (m_bRTLDocument)
                    {
                        m_bstrInfoHTML += OLESTR("right ");
                    }
                    else
                    {
                        m_bstrInfoHTML += OLESTR("left ");
                    }
                    m_bstrInfoHTML += OLESTR("bgcolor=threedhighlight bordercolordark=black bordercolorlight=black>");
                    m_bstrInfoHTML += OLESTR("<tr><td title=\'");
                    IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_FREESPACE_DESC, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
                    m_bstrInfoHTML += wszTemp;
                    m_bstrInfoHTML += OLESTR("\'></td></tr></table>&nbsp;");
                    IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_FREESPACE, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
                    m_bstrInfoHTML += wszTemp;
                    m_bstrInfoHTML += bstrSpace;
                }
                m_pThumbNailWrapper->SetDisplay(CComBSTR(""));
            }
        }
        else if (!bRootFolder)
        {
            BOOL bDisplayFlag = FALSE;
            BOOL bMovieFile = IsMovieFile(bstrPath);

            if (bMovieFile || IsSoundFile(bstrPath))
            {
                CComPtr<IMediaPlayer> spIMediaPlayer;

                if (SUCCEEDED(GetIMediaPlayer(spIMediaPlayer)))
                {
                    spIMediaPlayer->Open(bstrPath);
                    bDisplayFlag = TRUE;
                }
                spIMediaPlayer = NULL;
            }

            if (m_spMediaPlayerStyle && bDisplayFlag)
            {
                if (bMovieFile)
                {
                    m_spMediaPlayerStyle->put_height(CComVariant(136));
                }
                else
                {
                    m_spMediaPlayerStyle->put_height(CComVariant(46));
                }
                m_spMediaPlayerStyle->put_display(OLESTR(""));
            }
        }
    }
    return S_OK;;
}

HRESULT MakeLink(LPCWSTR pwszLink, LPCWSTR pwszText, CComBSTR& bstrText)
{
    HRESULT hr = E_FAIL;
    if (pwszLink)
    {
        bstrText += OLESTR("<A HREF=\"");
        bstrText += pwszLink;
        bstrText += OLESTR("\">");
        if (pwszText && pwszText[0])
        {
            bstrText += pwszText;
        }
        else    // If pwszText is NULL, use pwszLink itself as text.
        {
            bstrText += pwszLink;
        }
        bstrText += OLESTR("</A>");
        hr = S_OK;
    }
    return hr;
}

HRESULT CFileListWrapper::GetItemNameForDisplay()
{
    HRESULT hr = E_FAIL;
    CComBSTR bstrIgnore, bstrName;

    // Get the name of the item
    if (SUCCEEDED(GetItemInfo(IDS_NAME_COL, L"Name", bstrIgnore, bstrName)) && (bstrName.Length() > 0))
    {
        m_bstrInfoHTML += OLESTR("<b>");   // Begin bold tag
        m_bstrInfoHTML += bstrName;     // Add the name
        m_bstrInfoHTML += OLESTR("</b>"); // End bold tag
        hr = S_OK;
    }
    return hr;
}

HRESULT CFileListWrapper::GetItemType()
{
    CComBSTR bstrIgnore, bstrType;
    HRESULT  hr = GetItemInfo(IDS_TYPE_COL, L"Type", bstrIgnore, bstrType);

    if (SUCCEEDED(hr) && (bstrType.Length() > 0))
    {
        m_bstrInfoHTML += OLESTR("<br>");
        m_bstrInfoHTML += bstrType;
    } 
    return hr;
}

HRESULT CFileListWrapper::GetItemDateTime()
{
    CComBSTR bstrDesc, bstrDateTime;
    HRESULT  hr = GetItemInfo(IDS_MODIFIED_COL, L"Modified", bstrDesc, bstrDateTime);

    if (SUCCEEDED(hr) && (bstrDateTime.Length() > 0))
    {
        m_bstrInfoHTML += OLESTR("<p>");
        m_bstrInfoHTML += bstrDesc;
        m_bstrInfoHTML += OLESTR(": ");
        m_bstrInfoHTML += bstrDateTime;
    } 
    return hr;
}

HRESULT CFileListWrapper::GetItemSize()
{
    WCHAR   wszTemp[MAX_PATH];
    long    lSize = 0;
    HRESULT hr = m_spFolderItem->get_Size(&lSize);

    if (SUCCEEDED(hr))
    {
        if (lSize > 0L)
        {
            m_bstrInfoHTML += OLESTR("<p>");
            IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_SIZE, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
            m_bstrInfoHTML += wszTemp;
            StrFormatByteSizeW(lSize, wszTemp, ARRAYSIZE(wszTemp));
            m_bstrInfoHTML += wszTemp;
        }
    }
    else
    {
        CComBSTR bstrDesc, bstrSize;
        hr = GetItemInfo(IDS_SIZE_COL, L"Size", bstrDesc, bstrSize);
        if (SUCCEEDED(hr) && (bstrSize.Length() > 0))
        {
            m_bstrInfoHTML += OLESTR("<p>");
            m_bstrInfoHTML += bstrDesc;
            m_bstrInfoHTML += OLESTR(": ");
            m_bstrInfoHTML += bstrSize;
        }
    }
    return hr;
}

const WCHAR c_wszAttributeCodes[] = {L"RHSCE"};
const int c_iaAttribStringIDs[] = {IDS_READONLY, IDS_HIDDEN, IDS_SYSTEM,    //IDS_ARCHIVE,
                                   IDS_COMPRESSED, IDS_ENCRYPTED};
HRESULT FormatAttributes(CComBSTR& bstrDetails, CComBSTR& bstrText)
{
    HRESULT hr = S_OK;
    BOOL    bFlag = FALSE;
    WCHAR   wszDelimiter[10], wszTemp[MAX_PATH];

    IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_DELIMITER, wszDelimiter, ARRAYSIZE(wszDelimiter)), E_FAIL);
    for (int i = 0; i < (int)bstrDetails.Length(); i++)
    {
        WCHAR* pwCh;
        if ((pwCh = StrChrIW(c_wszAttributeCodes, bstrDetails[i])))    // Is the value, one of "RHSCE"?
        {
            if (bFlag)
            {
                bstrText += wszDelimiter;
                bstrText += OLESTR(" ");
            }
            else
            {
                bFlag = TRUE;
            }
            int iPos = (int)(pwCh - c_wszAttributeCodes);
            ASSERT((iPos >= 0) && (iPos < ARRAYSIZE(c_iaAttribStringIDs)));
            IfFalseRet(LoadStringW(_Module.GetResourceInstance(), c_iaAttribStringIDs[iPos], wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
            bstrText += wszTemp;
        }
    }
    if (!bFlag)
    {
        IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_NOATTRIBUTES, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
        bstrText += wszTemp;
    }
    return hr;
}

HRESULT CFileListWrapper::GetItemAttributes()
{
    VARIANT_BOOL fIsFolder;
    HRESULT hr = m_spFolderItem->get_IsFolder(&fIsFolder);
    if (SUCCEEDED(hr) && (fIsFolder == VARIANT_FALSE))
    {
        VARIANT_BOOL fIsFileSystem;
        hr = m_spFolderItem->get_IsFileSystem(&fIsFileSystem);
        if (SUCCEEDED(hr) && (fIsFileSystem == VARIANT_TRUE))
        {
            CComBSTR bstrDesc, bstrAttributes;
            hr = GetItemInfo(IDS_ATTRIBUTES_COL, L"Attributes", bstrDesc, bstrAttributes);
            if (SUCCEEDED(hr))  // Go ahead evenif  (bstrAttributes.Length() > 0)
            {
                m_bstrInfoHTML += OLESTR("<p>");
                m_bstrInfoHTML += bstrDesc;
                m_bstrInfoHTML += OLESTR(": ");
                FormatAttributes(bstrAttributes, m_bstrInfoHTML);
            }
        }
    }
    return hr;
}

HRESULT MakeMailLink(LPCWSTR pwszMailee, CComBSTR& bstrText)
{
    HRESULT hr = S_OK;

    bstrText += OLESTR("<A HREF=\'mailto:");
    bstrText += pwszMailee;
    bstrText += OLESTR("\'>");
    bstrText += pwszMailee;
    bstrText += OLESTR("</a>");
    return hr;
}

HRESULT CFileListWrapper::GetItemAuthor()
{
    CComBSTR bstrDesc, bstrAuthor;
    HRESULT  hr = GetItemInfo(IDS_AUTHOR_COL, L"Author", bstrDesc, bstrAuthor);

    if (SUCCEEDED(hr) && (bstrAuthor.Length() > 0))
    {
        m_bstrInfoHTML += OLESTR("<p>");
        m_bstrInfoHTML += bstrDesc;
        m_bstrInfoHTML += OLESTR(": ");
        if (StrChrW(bstrAuthor, L'@'))  // This is most likely to be an e-mail address
        {
            MakeMailLink(bstrAuthor, m_bstrInfoHTML);
        }
        else
        {
            m_bstrInfoHTML += bstrAuthor;
        }
        m_bFoundAuthor = TRUE;
    } 
    return hr;
}

HRESULT MakeLinksHyper(LPCWSTR pwszStr, CComBSTR& bstrText)
{
    HRESULT hr = S_OK;
    LPWSTR pwszBegin;

    if ((pwszBegin = StrStrIW(pwszStr, L"http://"))
            || (pwszBegin = StrStrIW(pwszStr, L"file://")))
    {
        WCHAR wszTemp[INTERNET_MAX_URL_LENGTH];
        int i;

        for (i = 0; &pwszStr[i] != pwszBegin; i++)
        {
            wszTemp[i] = pwszStr[i];
        }
        wszTemp[i] = L'\0';
        bstrText += wszTemp;
        WCHAR* pwChEnd = StrStrW(pwszBegin, L" ");
        if (!pwChEnd)
        {
            pwChEnd = &pwszBegin[lstrlenW(pwszBegin)];
        }
        for (i = 0; &pwszBegin[i] != pwChEnd; i++)  // Seperate out the http://... or file://... string
        {
            wszTemp[i] = pwszBegin[i];
        }
        wszTemp[i] = L'\0';
        MakeLink(wszTemp, wszTemp, bstrText);
        for (i = 0; pwChEnd[i]; i++)    // Copy out the rest, till the end
        {
            wszTemp[i] = pwChEnd[i];
        }
        wszTemp[i] = L'\0';
        bstrText += wszTemp;
    }
    else
    {
        bstrText += pwszStr;
    }
    return hr;
}

HRESULT FormatDetails(LPCWSTR pwszDesc, LPCWSTR pwszDetails, CComBSTR& bstrText)
{
    HRESULT hr = S_OK;

    bstrText += OLESTR("<p>");
    bstrText += pwszDesc;
    bstrText += OLESTR(":");
    if ((lstrlenW(pwszDesc) + lstrlenW(pwszDetails)) > 32)
    {
        bstrText += OLESTR("<br>");
    }
    else
    {
        bstrText += OLESTR(" ");
    }
    MakeLinksHyper(pwszDetails, bstrText);
    return hr;
}

HRESULT CFileListWrapper::GetItemComment()
{
    CComBSTR bstrDesc, bstrComment;
    HRESULT  hr = GetItemInfo(IDS_COMMENT_COL, L"Comment", bstrDesc, bstrComment);

    if (SUCCEEDED(hr) && (bstrComment.Length() > 0))
    {
        m_bstrInfoHTML += OLESTR("<p><div class = Message>");
        m_bstrInfoHTML += bstrComment;
        m_bstrInfoHTML += OLESTR("</div>");
        m_bFoundComment = TRUE;
    } 
    return hr;
}

HRESULT CFileListWrapper::GetItemHTMLInfoTip()
{
    CComBSTR bstrDesc, bstrHTMLInfoTipFile;
    HRESULT  hr = GetItemInfo(0, L"HTMLInfoTipFile", bstrDesc, bstrHTMLInfoTipFile);

    if (SUCCEEDED(hr) && (bstrHTMLInfoTipFile.Length() > 0))
    {
        m_bstrInfoHTML += OLESTR("<br><p><iframe FRAMEBORDER=0 class=Message src=\"");
        m_bstrInfoHTML += bstrHTMLInfoTipFile;
        m_bstrInfoHTML += OLESTR("\"></iframe>");
    }
    return hr;
}

HRESULT CFileListWrapper::GetItemInfo(long lResId, LPWSTR wszInfoDescCanonical, CComBSTR& bstrInfoDesc, CComBSTR& bstrInfo)
{
    HRESULT hr = E_FAIL;
    WCHAR wszInfoDesc[MAX_PATH];

    LoadStringW(_Module.GetResourceInstance(), lResId, wszInfoDesc, ARRAYSIZE(wszInfoDesc));
    bstrInfoDesc = wszInfoDesc;

    if (m_spFolderItem2)
    {
        CComBSTR bstrInfoDescCanonical = wszInfoDescCanonical;
        CComVariant var;
        hr = m_spFolderItem2->ExtendedProperty(bstrInfoDescCanonical, &var);
        if (SUCCEEDED(hr))
        {
            WCHAR wszTemp[80];
            
            if (var.vt == VT_BSTR)
            {
                // Of the three types of data we care about one is dangerous.  The BSTR data that
                // we read from the file could contain HTML code which we would render in WebView.
                // This could cause potential security problems.  To get around this we sanatize
                // the BSTR before we return it.  We need to do the following replacements:
                //
                //  original    replace with
                //      <           &lt;
                //      >           &gt;
                //      "           &quot;      <= this would be paranoid and isn't 100% critical
                //      '           &lsquo;     <= this would be paranoid and isn't 100% critical

                LPWSTR psz = var.bstrVal;
                LPWSTR pszBad;

                if (psz == NULL)
                {
                    // we probably cant depend on hr and the out param matching (since this is 
                    // scriptable and therefore must return success)
                    psz = L"";
                }

                while (pszBad = StrPBrkW(psz, L"<>"))
                {
                    // store the bad character
                    WCHAR chBadChar = *pszBad;

                    // null the string
                    *pszBad = NULL;

                    // add the good part of the string, if there is any
                    if ( *psz )
                        bstrInfo += psz;

                    // based on which bad character we found add the correct HTLM special character code
                    switch ( chBadChar )
                    {
                    case L'<':
                        bstrInfo += L"&lt;";
                        break;

                    case L'>':
                        bstrInfo += L"&gt;";
                        break;
                    }

                    // Advance the psz pointer.  Note it might be an empty string after this.
                    psz = pszBad+1;
                }

                // Add the remaining portion of the good string, even if it's an empty string.
                // bstrInfo is passed in uninitialized so we need to set it to something even
                // if that something is an empty string.
                bstrInfo += psz;
            }
            else if (var.vt == VT_DATE)
            {
                SYSTEMTIME  st;
                FILETIME    ft;

                if (VariantTimeToSystemTime(var.date, &st)
                        && SystemTimeToFileTime(&st, &ft)
                        && SHFormatDateTimeW(&ft, &m_dwDateFlags, wszTemp, ARRAYSIZE(wszTemp)))
                {
                    bstrInfo += wszTemp;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else if (var.vt == VT_UI8 && StrCmpIW(wszInfoDescCanonical, L"size") == 0)
            {
                StrFormatByteSize64(var.ullVal, wszTemp, ARRAYSIZE(wszTemp));
                bstrInfo += wszTemp;
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    return hr;
}

HRESULT CFileListWrapper::NoneSelected()
{
    WCHAR               wszIntro[MAX_PATH];
    CComPtr<FolderItem> spFolderItem;

    if (!m_bCSCDisplayed)
    {
        CSCShowStatusInfo();
        m_bCSCDisplayed = TRUE;
    }
    if (m_spFolderItems->Item(CComVariant(0), &spFolderItem) == S_OK)
    {   // This filelist has atleast one item.
        IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_PROMPT, wszIntro, ARRAYSIZE(wszIntro)), E_FAIL);
    }
    else
    {
        IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_EMPTY, wszIntro, ARRAYSIZE(wszIntro)), E_FAIL);
    }
    m_bstrInfoHTML += wszIntro;
    spFolderItem = NULL;

    if (SUCCEEDED(m_spFolder2->get_Self(&spFolderItem)))
    {
        m_spFolderItem = spFolderItem;
        m_spFolderItem->QueryInterface(IID_FolderItem2, (void **)&m_spFolderItem2);
        m_bFoundAuthor = FALSE;
        m_bFoundComment = FALSE;

        // Get the comment for the item
        GetItemComment();
        GetItemHTMLInfoTip();

        DealWithDriveInfo();

        GetCrossLinks();

        m_spFolderItem2 = NULL;
        m_spFolderItem = NULL;
    }
    return S_OK;
}

#define MAX_SELECTEDFILES_FOR_COMPUTING_SIZE     100
#define MAX_SELECTEDFILES_FOR_DISPLAYING_NAMES   16

HRESULT CFileListWrapper::MultipleSelected(long cSelection)
{
    HRESULT hr = S_FALSE;

    if (cSelection > 1)
    {
        WCHAR    wszTemp[MAX_PATH];

        wnsprintfW(wszTemp, ARRAYSIZE(wszTemp), L"%ld", cSelection);
        m_bstrInfoHTML += wszTemp;
        IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_MULTIPLE, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
        m_bstrInfoHTML += wszTemp;
        if (cSelection <= MAX_SELECTEDFILES_FOR_COMPUTING_SIZE)
        {
            m_bstrInfoHTML += OLESTR("<p>");

            CComPtr<FolderItem> spFolderItem;  
            long lSize = 0;

            for (int i = 0; i < cSelection; i++)
            {
                long lTempSize;
                if (SUCCEEDED(m_spFolderItems->Item(CComVariant(i), &spFolderItem)))
                {
                    if (SUCCEEDED(spFolderItem->get_Size(&lTempSize)))
                    {
                        lSize += lTempSize;
                    }
                    spFolderItem = NULL;
                }
            }
            if (lSize > 0L)
            {
                IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_FILESIZE, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
                m_bstrInfoHTML += wszTemp;
                StrFormatByteSizeW(lSize, wszTemp, ARRAYSIZE(wszTemp));
                m_bstrInfoHTML += wszTemp;
                m_bstrInfoHTML += OLESTR("<p>");
            }
            if (cSelection <= MAX_SELECTEDFILES_FOR_DISPLAYING_NAMES)
            {
                CComBSTR bstrTemp;
                for (int i = 0; i < cSelection; i++)
                {
                    if (SUCCEEDED(m_spFolderItems->Item(CComVariant(i), &spFolderItem)))
                    {
                        if (SUCCEEDED(spFolderItem->get_Name(&bstrTemp)))
                        {
                            m_bstrInfoHTML += "<br>";
                            m_bstrInfoHTML += bstrTemp;
                            bstrTemp.Empty();
                        }
                        spFolderItem = NULL;
                    }
                }
            }
        }
        hr = S_OK;
    }
    return hr;
}

HRESULT CFileListWrapper::OneSelected()
{
    HRESULT hr = E_FAIL;

    m_bFoundAuthor = FALSE;
    m_bFoundComment = FALSE;

    // Get the name of the item, making it a hyper-link if appropriate.
    GetItemNameForDisplay();

    // Get the type of the item
    GetItemType();

    if (!m_bPathIsSlow)
    {
        // Get the comment for the item
        GetItemComment();

        // Get the HTMLInfoTip
        GetItemHTMLInfoTip();

        // Get the date/time stamp on the item
        GetItemDateTime();

        // Get the size of the item
        GetItemSize();

        // Get the attributes (hidden, RO etc.) of the item
        GetItemAttributes();

        // Get the author of the document
        GetItemAuthor();

        DealWithDriveInfo();
    }
    hr = S_OK;
    return hr;
}

HRESULT CFileListWrapper::OnCSCClick()
{
    HRESULT hres = E_FAIL;
    CComPtr<Folder> spFolder;
    CComPtr<Folder2> spFolder2;

    if (m_spFileList && SUCCEEDED(m_spFileList->get_Folder(&spFolder))
            && SUCCEEDED(spFolder->QueryInterface(IID_Folder2, (void **)&spFolder2)))
    {
        m_spFolder2 = spFolder2;
        hres = CSCShowStatus_FoldExpand_Toggle();
        m_spFolder2 = NULL;
    }
    return S_OK;
}

HRESULT CFileListWrapper::OnCSCMouseOnOff(BOOL fOn)
{
    CComPtr<IHTMLStyle> psPlusMin;
    CComPtr<IHTMLStyle> psText;
    HRESULT hres = E_FAIL;

    // If we're already in this state don't do anything
    if (m_bHotTracked == fOn)
        return S_OK;

    // If we receive a 'mouse on' but the element is not one we want to track or if we receive a 'mouse off' but
    // the mouse is over one of our other elements that we want to hot track then don't do anything.
    if (m_spWindow)
    {
        CComPtr<IHTMLEventObj> phtmlevent;
        CComPtr<IHTMLElement> phtmlelement;
        CComBSTR bstrId;

        if (SUCCEEDED(m_spWindow->get_event(&phtmlevent)) && phtmlevent)
        {
            HRESULT hres;

            if (!fOn)
                hres = phtmlevent->get_toElement(&phtmlelement);
            else
                hres = phtmlevent->get_srcElement(&phtmlelement);

            if (SUCCEEDED(hres) && phtmlelement && SUCCEEDED(phtmlelement->get_id(&bstrId)) && (bstrId.Length() > 0))
            {
                BOOL bContainsCSC;
    
                bContainsCSC = (StrStrIW(bstrId, L"CSC") != NULL);
    
                if (bContainsCSC != fOn)
                    return S_OK;
            }
        }
    }

    if (m_spCSCPlusMin && m_spCSCText && SUCCEEDED(hres = m_spCSCPlusMin->get_style(&psPlusMin)) && SUCCEEDED(hres = m_spCSCText->get_style(&psText)))
    {
        CComVariant vcolorBlack (OLESTR("black"));
        CComBSTR bstrCSCPlusMin;
        LPOLESTR pstrCursor = (fOn ? OLESTR("hand") : OLESTR("auto"));
        CComVariant vcolorLink;

        m_bHotTracked = fOn;

        m_spDocument->get_linkColor(&vcolorLink);

        if (m_bExpanded)
            bstrCSCPlusMin = fOn ? CSC_MINUSHOT : CSC_MINUSCOLD;
        else
            bstrCSCPlusMin = fOn ? CSC_PLUSHOT : CSC_PLUSCOLD;
        m_spCSCPlusMin->put_innerHTML(bstrCSCPlusMin);

        psPlusMin->put_cursor(pstrCursor);
        psText->put_color(fOn ? vcolorLink : vcolorBlack);
        psText->put_cursor(pstrCursor);
    }
    return hres;
}

HRESULT CFileListWrapper::CSCSynchronize()
{
    HRESULT hres = E_FAIL;
    CComPtr<Folder> spFolder;
    CComPtr<Folder2> spFolder2;

    if (m_spFileList && SUCCEEDED(m_spFileList->get_Folder(&spFolder))
            && SUCCEEDED(spFolder->QueryInterface(IID_Folder2, (void **)&spFolder2)))
    {
        hres = spFolder2->Synchronize();
    }
    return hres;
}

const UINT c_ids_uiCSCText[] =
        {IDS_CSC_ONLINE, IDS_CSC_OFFLINE, IDS_CSC_SERVERAVAILABLE, IDS_CSC_DIRTYCACHE};
        
HRESULT CFileListWrapper::CSCGetStatusText(LONG lStatus, CComBSTR& bstrCSCText)
{
    WCHAR wszTemp[MAX_PATH];
    if ((lStatus >= 0) && (lStatus < ARRAYSIZE(c_ids_uiCSCText))
            && LoadStringW(_Module.GetResourceInstance(), c_ids_uiCSCText[(int)lStatus], wszTemp, ARRAYSIZE(wszTemp)))
    {
        bstrCSCText += wszTemp;
    }
    return S_OK;
}

const UINT c_ids_uiCSCDetail[] =
        {IDS_CSC_DETAIL_ONLINE, IDS_CSC_DETAIL_OFFLINE, IDS_CSC_DETAIL_SERVERAVAILABLE, IDS_CSC_DETAIL_DIRTYCACHE};

HRESULT CFileListWrapper::CSCGetStatusDetail(LONG lStatus, CComBSTR& bstrCSCDetail)
{
    WCHAR wszTemp[MAX_PATH];
    if ((lStatus >= 0) && (lStatus < ARRAYSIZE(c_ids_uiCSCDetail))
            && LoadStringW(_Module.GetResourceInstance(), c_ids_uiCSCDetail[(int)lStatus], wszTemp, ARRAYSIZE(wszTemp)))
    {
        bstrCSCDetail += wszTemp;
    }
    return S_OK;
}

#define CSC_STATUS_ONLINE           0
#define CSC_STATUS_OFFLINE          1
#define CSC_STATUS_SERVERAVAILABLE  2
#define CSC_STATUS_DIRTYCACHE       3

HRESULT CFileListWrapper::CSCGetStatusButton(LONG lStatus, CComBSTR& bstrCSCButton)
{
    if ((lStatus == CSC_STATUS_SERVERAVAILABLE) || (lStatus == CSC_STATUS_DIRTYCACHE))
    {
        bstrCSCButton += OLESTR("<p class=Button><button onclick=\'WVCoord.CSCSynchronize()\'>");
        WCHAR wszTemp[MAX_PATH];
        LoadStringW(_Module.GetResourceInstance(), IDS_CSC_SYNCHRONIZE, wszTemp, ARRAYSIZE(wszTemp));
        bstrCSCButton += wszTemp;
        bstrCSCButton += OLESTR("</button>");
    }
    return S_OK;
}

HRESULT CFileListWrapper::GetCSCFolderStatus(LONG* plStatus)
{
    return m_spFolder2 ? m_spFolder2->get_OfflineStatus(plStatus) : E_FAIL;
}

HRESULT CFileListWrapper::CSCShowStatusInfo()
{
    LONG lStatus;

    if (m_spCSCText && m_spCSCPlusMin && m_spCSCDetail && m_spCSCButton && m_spCSCStyle
            && m_spCSCDetailStyle && m_spCSCButtonStyle)
    {
        CComBSTR bstrCSC_Display;
        if (SUCCEEDED(GetCSCFolderStatus(&lStatus)) && (lStatus >= 0))
        {
            CComBSTR bstrCSCText;
            CSCGetStatusText(lStatus, bstrCSCText);
            bstrCSCText += OLESTR("<br>");
            
            CComBSTR bstrCSCPlusMin;
            CComBSTR bstrCSCDetail;
            CComBSTR bstrCSCDetail_Display;

            if (m_bExpanded)
            {
                bstrCSCPlusMin = m_bHotTracked ? CSC_MINUSHOT : CSC_MINUSCOLD;
                bstrCSCText += OLESTR("<br>");
                
                CSCGetStatusDetail(lStatus, bstrCSCDetail);
                bstrCSCDetail += OLESTR("<br>");

                bstrCSCDetail_Display = OLESTR("");

                if (m_bRTLDocument)
                {
                    // [msadek]; Life would be easier if the object model has exposed
                    // right offset through get_offsetRight().
                    
                    CComPtr<IHTMLControlElement> spDocBody = NULL;
                    long lOffsetLeft, lOffsetWidth, lClientWidth, lOffsetRight = 0;
                    
                    if (SUCCEEDED(m_spCSCText->QueryInterface(IID_IHTMLControlElement, (void **)&spDocBody))
                        && SUCCEEDED(m_spCSCText->get_offsetLeft(&lOffsetLeft))
                        && SUCCEEDED(m_spCSCText->get_offsetWidth(&lOffsetWidth))
                        && SUCCEEDED(spDocBody->get_clientWidth(&lClientWidth)))
                    {
                        lOffsetRight = lClientWidth - (lOffsetLeft + lOffsetWidth);
                    }
                    m_spCSCDetailStyle->put_marginRight(CComVariant(lOffsetRight - 10L));
                }
                else
                {
                    long lOffsetLeft;
                    if (FAILED(m_spCSCText->get_offsetLeft(&lOffsetLeft)))
                    {
                        lOffsetLeft = 0;
                    }
                    m_spCSCDetailStyle->put_marginLeft(CComVariant(lOffsetLeft - 10L));
                }
            }
            else
            {
                bstrCSCPlusMin = m_bHotTracked ? CSC_PLUSHOT : CSC_PLUSCOLD;
                bstrCSCDetail += OLESTR("");
                bstrCSCDetail_Display = OLESTR("none");
            }
            m_spCSCPlusMin->put_innerHTML(bstrCSCPlusMin);
            m_spCSCText->put_innerHTML(bstrCSCText);
            m_spCSCDetail->put_innerHTML(bstrCSCDetail);
            m_spCSCDetailStyle->put_display(bstrCSCDetail_Display);

            CComBSTR bstrCSCButton_Display;
            CComBSTR bstrCSCButton;
            if (SUCCEEDED(CSCGetStatusButton(lStatus, bstrCSCButton)) && (bstrCSCButton.Length() > 0))
            {
                bstrCSCButton_Display = OLESTR("");
            }
            else
            {
                bstrCSCButton = OLESTR("");
                bstrCSCButton_Display = OLESTR("none");
            }
            m_spCSCButton->put_innerHTML(bstrCSCButton);
            m_spCSCButtonStyle->put_display(bstrCSCButton_Display);
            bstrCSC_Display = OLESTR("");
        }
        else
        {
            bstrCSC_Display = OLESTR("none");
        }
        m_spCSCStyle->put_display(bstrCSC_Display);
    }
    return S_OK;
}

HRESULT CFileListWrapper::CSCShowStatus_FoldExpand_Toggle()
{
    m_bExpanded = !m_bExpanded;
    return  (CSCShowStatusInfo());
}

// fEnter true for mouseover, focus; false for mouseout, blur
HRESULT CFileListWrapper::OnWebviewLinkEvent( BOOL fEnter )
{
    CComPtr<IHTMLEventObj>      spEvent;
    CComPtr<IHTMLElement>       spAnchor;
    HRESULT                     hr;

    // NT# 354743, IHTMLEventObj::get_event() can return S_OK and
    // not set the out param, so we need to protect against that.
    spEvent = NULL;
    hr = m_spWindow->get_event(&spEvent);
    
    // Automation interfaces sometimes return S_FALSE on failures to prevent scripting errors
    if (S_OK == hr)
    {
        // Sometimes Trident will not set the out parameter when it returns S_OK, so
        // we need to make sure it's not NULL.
        if (spEvent)
        {
            hr = GetEventAnchorElement(spEvent, &spAnchor);
        }
        else
            hr = E_FAIL;

        if (S_OK == hr)
        {
            if (fEnter)
            {
                CComBSTR    bstrTitle;
                
                hr = spAnchor->get_title(&bstrTitle);
                if(SUCCEEDED(hr))
                {
                    m_spWindow->put_status(bstrTitle);
                }
                
                spEvent->put_returnValue(CComVariant(true));
            }
            else
            {
                hr = m_spWindow->put_status(OLESTR(""));
            }
        }
    }
    
    return S_OK;
}


// Walks up the component chain from the event source, looking for
// an anchor element. Returns S_OK if successful, some error otherwise.
// On failure *ppElt will be set to null. Note that this gives back
// the IHTMLElement that corresponds to the anchor, not the
// IHTMLAnchorElement, as only IHTMLElement has get_title
HRESULT CFileListWrapper::GetEventAnchorElement( IHTMLEventObj *pEvent,
                                                 IHTMLElement **ppElt )
{
    CComPtr<IHTMLElement>   spElement;

    *ppElt = NULL;
    
    if( SUCCEEDED( pEvent->get_srcElement( &spElement )))
    {
        BOOL    fContinue = TRUE;
        while( fContinue && spElement )
        {
            CComPtr<IHTMLAnchorElement> spAnchor;
            
            if( SUCCEEDED( spElement->QueryInterface( IID_IHTMLAnchorElement,
                                                      reinterpret_cast<void**>( &spAnchor ))))
            {
                fContinue = false;
                *ppElt = spElement;
                reinterpret_cast<IUnknown*>( *ppElt )->AddRef();
            }
            else
            {
                IHTMLElement    *pIElt = NULL;

                if( SUCCEEDED( spElement->get_parentElement( &pIElt )))
                {
                    spElement = pIElt;
                    if (pIElt)
                    {
                        pIElt->Release();
                    }
                }
                else
                {
                    spElement.Release();
                }
            }
        }
    }

    return ( *ppElt ? S_OK : E_FAIL );
}

// Bind to the connection points for each of the link elements
// contained within m_spLinks. The advise cookie for each link
// is stored as an attribute within the link, so we don't need
// to maintain a mapping between links and elements.
// fAdvise -- true to make connections, false to break
HRESULT CFileListWrapper::AdviseWebviewLinks( BOOL fAdvise)
{
    CComPtr<IDispatch>                  spDisp;
    CComPtr<IHTMLElement>               spElement;
    CComPtr<IHTMLElementCollection>     spCollection;
    CComVariant                         vtEmpty;
    CComBSTR                            bstrAttr = WV_LINKNAME;
    long                                cLinks;
    DWORD                               dwCookie;
    HRESULT                             hr;

    IfFailRet( GetWVLinksCollection( &spCollection, &cLinks ));

    for( long i = 0; i < cLinks; i++ )
    {
        hr = spCollection->item( CComVariant( i ), vtEmpty, &spDisp );
        if (!spDisp)
        {
            hr = E_FAIL;
        }

        if( SUCCEEDED( hr ))
        {
            hr = spDisp->QueryInterface( IID_IHTMLElement,
                                         reinterpret_cast<void**>( &spElement ));
            spDisp.Release();
        }

        if( SUCCEEDED( hr ))
        {
            if( fAdvise )
            {
                hr = AtlAdvise( spElement, this, IID_IDispatch, &dwCookie );
                if( SUCCEEDED( hr ))
                {
                    hr = spElement->setAttribute( bstrAttr,
                                                  CComVariant( static_cast<long>( dwCookie )),
                                                  VARIANT_FALSE );

                    if( FAILED( hr ))
                    {
                        AtlUnadvise( spElement, IID_IDispatch, dwCookie );
                    }
                }
            }
            else
            {
                CComVariant vtCookie;
                
                hr = spElement->getAttribute( bstrAttr, FALSE, &vtCookie );
                if( SUCCEEDED( hr ))
                {
                    dwCookie = static_cast<DWORD>( vtCookie.lVal );
                    AtlUnadvise( spElement, IID_IDispatch, dwCookie );
                }                
            }

            spElement.Release();
        }
    }
    
    return S_OK;
}

// Get the IHTMLElementCollection that holds the named links
HRESULT CFileListWrapper::GetWVLinksCollection( IHTMLElementCollection **ppCollection,
                                                long *pcLinks )
{
    CComPtr<IDispatch>                  spDisp;
    CComPtr<IHTMLElementCollection>     spCollection;
    CComVariant                         vtEmpty;
    HRESULT                             hr;

    ASSERT( ppCollection );
    ASSERT( pcLinks );

    *ppCollection = NULL;
    *pcLinks = 0;

    if (!m_spLinks) return E_FAIL;

    // Get the initial element collection from m_spLinks
    IfFailRet( m_spLinks->get_all( &spDisp ));
    IfFailRet( spDisp->QueryInterface( IID_IHTMLElementCollection,
                                       reinterpret_cast<void**>( &spCollection )));
    spDisp.Release();

    // Get the collection of elements with our linkname. If nothing exists, spDisp
    // will be null and item returns S_OK.
    IfFailRet( spCollection->item( CComVariant( WV_LINKNAME ), vtEmpty, &spDisp ));
    if( !spDisp ) return E_FAIL;

    IfFailRet( spDisp->QueryInterface( IID_IHTMLElementCollection,
                                       reinterpret_cast<void**>( ppCollection )));

    return reinterpret_cast<IHTMLElementCollection*>( *ppCollection )->get_length( pcLinks );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\priv.h ===
// priv.h: declarations used throughout webvw
#ifndef __PRIV_H
#define __PRIV_H

#define POST_IE5_BETA
#define NO_W95_TRANSACCEL_WRAPS_TBS
#define NO_W95_GETCLASSINFO_WRAPS
#include <w95wraps.h>

// Some of the string versions are not redirected to the shlwapi versions in w95wraps.
// Use the shlwapi version of the following functions
#ifndef lstrcpyW
#define lstrcpyW       StrCpyW
#endif
#ifndef lstrcatW
#define lstrcatW       StrCatW
#endif
#ifndef lstrcmpW
#define lstrcmpW       StrCmpW
#endif
#ifndef lstrcmpiW
#define lstrcmpiW      StrCmpIW
#endif
#ifndef lstrncmpiW
#define lstrncmpiW     StrCmpNIW
#endif
#ifndef lstrcpynW
#define lstrcpynW      StrCpyNW
#endif

#include <shlobj.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shfusion.h>

EXTERN_C int WINAPIV wsprintfWrapW(
    OUT LPWSTR pwszOut,
    IN LPCWSTR pwszFormat,
    ...);

#include "atlwraps.h"
#include "stdafx.h"
// Keep the above in the same order. Add anything you want to, below this.

#include <wininet.h>
#include <debug.h>
#include <ccstock.h>
#include <ieguidp.h>

#include "resource.h"
#include "wvmacros.h"
#include "webvwid.h"
#include "webvw.h"
#include "util.h"
#include "ThumbCtl.h"

#endif // __PRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\fldricon.cpp ===
// fldricon.cpp : Implementation of CWebViewFolderIcon
#include "priv.h"

#include <shsemip.h>
#include <shellp.h>
#include <mshtml.h>
#include <mshtmdid.h>
#include <dvocx.h>
#include <fldricon.h>
#include <exdispid.h>
#include <shguidp.h>
#include <hlink.h>
#include <shlwapi.h>
#include <windowsx.h>
#include <wchar.h>
#include <shdocvw.h>  // for IEParseDisplayNameW() & IEGetNameAndFlags()
#include <wingdi.h>

#include <varutil.h>

#define UNINITIALIZE_BOOL   5

const CLSID CLSID_WebViewFolderIconOld = {0xe5df9d10,0x3b52,0x11d1,{0x83,0xe8,0x00,0xa0,0xc9,0x0d,0xc8,0x49}}; // retired from service, so made private


//  PERF: Shell allocator, inserted here because SHRealloc 
//  isn't imported into webvw, this module's hosting executable.
//  If we get SHRealloc, the following block can be removed:
#define _EXPL_SHELL_ALLOCATOR_

#ifdef  _EXPL_SHELL_ALLOCATOR_

#define SHRealloc(pv, cb)     shrealloc(pv, cb)

void* shrealloc(void* pv,  size_t cb)
{
    void *pvRet = NULL;
    IMalloc* pMalloc;
    if (SUCCEEDED(SHGetMalloc(&pMalloc)))  
    {
        pvRet = pMalloc->Realloc(pv, cb);
        pMalloc->Release();
    }
    return pvRet;
}

#endif _EXPL_SHELL_ALLOCATOR_

// For registering the window class
const TCHAR * const g_szWindowClassName = TEXT("WebViewFolderIcon view messaging");

DWORD IntSqrt(DWORD dwNum)
{
    // This code came from "drawpie.c"
    DWORD dwSqrt = 0;
    DWORD dwRemain = 0;
    DWORD dwTry = 0;

    for (int i=0; i<16; ++i) 
    {
        dwRemain = (dwRemain<<2) | (dwNum>>30);
        dwSqrt <<= 1;
        dwTry = dwSqrt*2 + 1;

        if (dwRemain >= dwTry) 
        {
            dwRemain -= dwTry;
            dwSqrt |= 0x01;
        }
        dwNum <<= 2;
    }
    return dwSqrt;
}   

// Make sure you don't begin a drag with random clicking
BOOL CheckForDragBegin(HWND hwnd, int x, int y)
{
    RECT rc;
    int dxClickRect = GetSystemMetrics(SM_CXDRAG);
    int dyClickRect = GetSystemMetrics(SM_CYDRAG);

    ASSERT((dxClickRect > 1) && (dyClickRect > 1));

    // See if the user moves a certain number of pixels in any direction
    SetRect(&rc, x - dxClickRect, y - dyClickRect, x + dxClickRect, y + dyClickRect);

    MapWindowRect(hwnd, NULL, &rc);

    SetCapture(hwnd);

    do 
    {
        MSG msg;

        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            // See if the application wants to process the message...
            if (CallMsgFilter(&msg, MSGF_COMMCTRL_BEGINDRAG) != 0)
                continue;

            switch (msg.message) 
            {
            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
                PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
                ReleaseCapture();
                return FALSE;

            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
                ReleaseCapture();
                return FALSE;

            case WM_MOUSEMOVE:
                if (!PtInRect(&rc, msg.pt)) 
                {
                    ReleaseCapture();
                    return TRUE;
                }
                break;

            default:
                if (GetCapture() != hwnd)
                    ReleaseCapture();
                
                TranslateMessage(&msg);
                DispatchMessage(&msg);
                break;
            }
        }
        else WaitMessage();         /* Don't chew 100% CPU */

        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop
    } while (GetCapture() == hwnd);

    return FALSE;
}

///////////////////////////////////
//
//  CWebViewFolderIcon functions
//
///////////////////////////////////

CWebViewFolderIcon::CWebViewFolderIcon() :
    m_pccpDV(NULL),
    m_hIcon(0),
    m_iIconIndex(-1),
    m_hbm(NULL),
    m_pthumb(NULL),
    m_pidl(NULL),
    m_msgHwnd(NULL),
    m_pdispWindow(NULL),
    m_dwThumbnailID(0),
    m_bHilite(FALSE)
{
    m_percentScale = 100;
    m_lImageWidth = 0; 
    m_lImageHeight = 0;
    m_sizLabel.cx = m_sizLabel.cy = 0;
    m_pszDisplayName = NULL;

    m_bHasRect = FALSE;
    m_ViewUser = VIEW_LARGEICON;
    m_ViewCurrent = VIEW_LARGEICON;
    m_clickStyle = 2;                   // Default is double-click
    m_fUseSystemColors = TRUE;
    m_bAdvPropsOn = VARIANT_TRUE;
    m_bRegWndClass = FALSE;
    m_ullFreeSpace = 0;
    m_ullUsedSpace = 0;
    m_ullTotalSpace = 0;
    m_highestIndexSlice = 0;
    m_fTabRecieved = FALSE;
    m_pcm3 = NULL;
    m_pDropTargetCache = NULL;
    m_fIsHostWebView = UNINITIALIZE_BOOL;

    m_hdc = NULL;
    m_fRectAdjusted = 0;
    m_hbmDrag = NULL;

    m_hdsaSlices = DSA_Create(sizeof(PieSlice_S), SLICE_NUM_GROW);

    /*
     *  Listview puts a SM_CXEDGE between the icon and the label,
     *  so we will default to that value.  (Clients can adjust with
     *  labelGap property.)
     */
    m_cxLabelGap = GetSystemMetrics(SM_CXEDGE);

    m_pfont = NULL;
    m_hfAmbient = NULL;

}

CWebViewFolderIcon::~CWebViewFolderIcon()
{
    _ClearLabel();
    _ClearAmbientFont();

    if (m_hIcon) 
    {
        DestroyIcon(m_hIcon);
        m_hIcon = NULL;
    }
    
    if (m_hdc)
    {
        DeleteDC(m_hdc);
        m_hdc = NULL;
    }

    if (m_hbmDrag)
    {
        DeleteObject(m_hbmDrag);
        m_hbmDrag = NULL;
    }
    
    ILFree(m_pidl);

    if (m_hbm)
    {
        DeleteObject(m_hbm);
        m_hbm = NULL;
    }

    if (m_hfAmbient)
    {
        DeleteObject(m_hfAmbient);
        m_hfAmbient = NULL;
    }

    ATOMICRELEASE(m_pDropTargetCache);
    ATOMICRELEASE(m_pthumb);

    DSA_Destroy(m_hdsaSlices);

    if (m_msgHwnd)
        ::DestroyWindow(m_msgHwnd);

    if (m_bRegWndClass)
    {
        UnregisterClass(g_szWindowClassName, _Module.GetModuleInstance());
    }
}

HRESULT CWebViewFolderIcon::_SetupWindow(void)
{
    // On the first time register the messaging window
    if (!m_bRegWndClass)
    {
        // Create Window Class for messaging
        m_msgWc.style = 0;
        m_msgWc.lpfnWndProc = CWebViewFolderIcon::WndProc;
        m_msgWc.cbClsExtra = 0;
        m_msgWc.cbWndExtra = 0;
        m_msgWc.hInstance = _Module.GetModuleInstance();
        m_msgWc.hIcon = NULL;
        m_msgWc.hCursor = NULL;
        m_msgWc.hbrBackground = NULL;
        m_msgWc.lpszMenuName = NULL;
        m_msgWc.lpszClassName = g_szWindowClassName;

        m_bRegWndClass = RegisterClass(&m_msgWc);
    }

    if (!m_msgHwnd)
    {
        m_msgHwnd = CreateWindow(g_szWindowClassName, NULL, WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
                             CW_USEDEFAULT, NULL, NULL, _Module.GetModuleInstance(), this);
    }

    return m_msgHwnd ? S_OK : E_FAIL;
}

// Must be called before using the IThumbnail.  Also sets up the thumbnail message window
HRESULT CWebViewFolderIcon::SetupIThumbnail(void)
{
    HRESULT hr = _SetupWindow();
    if (SUCCEEDED(hr))
    {
        if (m_pthumb)
            hr = S_OK;
        else
        {
            hr = CoCreateInstance(CLSID_Thumbnail, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThumbnail2, &m_pthumb));
            if (SUCCEEDED(hr))
                hr = m_pthumb->Init(m_msgHwnd, WM_HTML_BITMAP);
        }
    }
    return hr;
}

// General functions
HRESULT CWebViewFolderIcon::_InvokeOnThumbnailReady()
{
    // Fire off "OnThumbnailReady" event to our connection points to indicate that
    // either a thumbnail has been computed or we have no thumbnail for this file.
    DISPPARAMS dp = {0, NULL, 0, NULL};     // no parameters

    //Lock();
    for (IUnknown** pp = m_vec.begin(); pp < m_vec.end(); pp++)
    {
        if (pp)
        {
            IDispatch* pDispatch = SAFECAST(*pp, IDispatch*);
            pDispatch->Invoke(DISPID_WEBVIEWFOLDERICON_ONTHUMBNAILREADY, IID_NULL,
                    LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dp, NULL, NULL, NULL);
        }
    }
    //Unlock();

    FireViewChange();

    return S_OK;
}

// The S_FALSE return value indicates that this function has succeeded, but the out pidl is still NULL
HRESULT CWebViewFolderIcon::_GetFullPidl(LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;

    HRESULT hr;
    if (m_pidl)
    {
        hr = SHILClone(m_pidl, ppidl);  // dupe our copy
    }
    else
    {
        // This used to be an EVAL, but it can legitimately fail if the script did not
        // specify a valid path
        // This will fail if we are hosted in a web page instead of the HTML WebView frame in DefView.
        IUnknown *punk;
        hr = IUnknown_QueryService(m_spClientSite, SID_SFolderView, IID_PPV_ARG(IUnknown, &punk));
        if (SUCCEEDED(hr))
        {   
            if (S_OK == SHGetIDListFromUnk(punk, ppidl))
            {
                Pidl_Set(&m_pidl, *ppidl);  // cache a copy of this
            }
            punk->Release();
        }
    }
    return hr;                       
}


HRESULT _GetPidlAndShellFolderFromPidl(LPITEMIDLIST pidl, LPITEMIDLIST *ppidlLast, IShellFolder** ppsfParent)
{
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, ppsfParent), &pidlLast);
    if (SUCCEEDED(hr))
    {
        *ppidlLast = ILClone(pidlLast);
    }
    return hr;
}

// RETURN VALUES:
//      SUCCEEDED() means *ppidlLast and/or *ppsfParent can be NULL.
//      FAILED() means a *ppidlLast *ppsfParent are going to be returned NULL.
HRESULT CWebViewFolderIcon::_GetPidlAndShellFolder(LPITEMIDLIST *ppidlLast, IShellFolder** ppsfParent)
{
    LPITEMIDLIST pidl;
    HRESULT hr = _GetFullPidl(&pidl);
    if (hr == S_OK)
    {
        hr = _GetPidlAndShellFolderFromPidl(pidl, ppidlLast, ppsfParent);
        ILFree(pidl);
    }
    else
    {
        *ppidlLast = NULL;
        *ppsfParent = NULL;
    }

    return hr;
}

// Get Trident's HWND
HRESULT CWebViewFolderIcon::_GetHwnd(HWND* phwnd)
{
    HRESULT hr;

    if (m_spInPlaceSite)
    {
        hr = m_spInPlaceSite->GetWindow(phwnd);
    }
    else
    {
        IOleInPlaceSiteWindowless * poipsw;
        hr = m_spClientSite->QueryInterface(IID_PPV_ARG(IOleInPlaceSiteWindowless, &poipsw));
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = poipsw->GetWindow(phwnd);
            poipsw->Release();
        }
    }
    return hr;
}

HRESULT CWebViewFolderIcon::_GetChildUIObjectOf(REFIID riid, void **ppvObj)
{
    LPITEMIDLIST pidlLast;
    IShellFolder *psfParent;
    HRESULT hr = _GetPidlAndShellFolder(&pidlLast, &psfParent);
    if (hr == S_OK)
    {
        HWND hwnd;
        
        _GetHwnd(&hwnd);
        hr = psfParent->GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST *)&pidlLast, riid, NULL, ppvObj);
        psfParent->Release();
        ILFree(pidlLast);
    }
    else
        hr = E_FAIL;

    return hr;
}

//  Center point of focus rectangle
HRESULT CWebViewFolderIcon::_GetCenterPoint(POINT *pt)
{
    pt->y = ((m_rcPos.top + m_rcPos.bottom)/2);
    pt->x = ((m_rcPos.left + m_rcPos.right)/2);

    return S_OK;
}

HRESULT CWebViewFolderIcon::_ZoneCheck(DWORD dwFlags)
{
    HRESULT hr = E_ACCESSDENIED;
    CComPtr<IDefViewSafety> spDefViewSafety;
    if (SUCCEEDED(IUnknown_QueryService(m_spClientSite, SID_SFolderView,
            IID_PPV_ARG(IDefViewSafety, &spDefViewSafety))))
    {
        hr = spDefViewSafety->IsSafePage();
    }
    return hr;
}

BOOL CWebViewFolderIcon::IsSafeToDefaultVerb(void)
{
    return S_OK == _ZoneCheck(PUAF_WARN_IF_DENIED);
}

//  If the focus rectangle is not in the specified RectState (on or off) change it and reset m_bHasRect
void CWebViewFolderIcon::_FlipFocusRect(BOOL RectState)
{
    if (m_bHasRect != RectState)    // needs flipping
    {
        m_bHasRect = RectState;
        ForceRedraw();
    }
    return;
}

// Extract a ULONGLONG from two VARIANT's
ULONGLONG CWebViewFolderIcon::GetUllMemFromVars(VARIANT *pvarHi, VARIANT *pvarLo)
{
    ULARGE_INTEGER uli;

    uli.HighPart = pvarHi->ulVal;
    uli.LowPart = pvarLo->ulVal;

    return uli.QuadPart;
}

// Returns the integer percent from the string percent.  Returns -1 if the string is invalid;
int CWebViewFolderIcon::GetPercentFromStrW(LPCWSTR pwzPercent)
{
    int percent = -1;
    int numchar = lstrlenW(pwzPercent);

    if (pwzPercent[numchar-1] == '%')
    {
        LPWSTR pwzTempPct = SysAllocString(pwzPercent);

        if (pwzTempPct)
        {
            pwzTempPct[numchar-1] = '\0';

            for (int i=0 ; i < (numchar-2) ; i++)
            {
                if (!((pwzTempPct[i] >= '0') && (pwzTempPct[i] <= '9')))
                {
                    percent = 100;  // 100% is the default to use in error conditions
                    break;
                }
            }

            if ((-1 == percent) && !StrToIntExW(pwzTempPct, STIF_DEFAULT, &percent))
            {
                percent = -1;
            }

            SysFreeString(pwzTempPct);
        }
    }

    return percent;
}

BOOL CWebViewFolderIcon::_WebViewOpen(void)
{
    BOOL Processed = FALSE;

    if (IsSafeToDefaultVerb())
    {   
        Processed = TRUE;
        //
        // if the context menu option does not work, we try a shell execute on the pidl
        //
        if (FAILED(_DoContextMenuCmd(TRUE, 0, 0)))
        {   
            if (m_pidl)
            {
                SHELLEXECUTEINFO sei = { 0 };

                sei.cbSize     = sizeof(sei);
                sei.fMask      = SEE_MASK_INVOKEIDLIST;
                sei.nShow      = SW_SHOWNORMAL;
                sei.lpIDList   = m_pidl;

                if (!ShellExecuteEx(&sei))
                {
                    Processed = FALSE;
                }
            }
        }
    }
    return Processed;
}


void CWebViewFolderIcon::_ClearLabel(void)
{
    if (m_pszDisplayName)
    {
        CoTaskMemFree(m_pszDisplayName);
        m_pszDisplayName = NULL;
        m_sizLabel.cx = m_sizLabel.cy = 0;
    }
}

void  CWebViewFolderIcon::_GetLabel(IShellFolder *psf, LPCITEMIDLIST pidlItem)
{
    if ((m_ViewUser & VIEW_WITHLABEL) && psf)
    {
        STRRET str;
        if (SUCCEEDED(psf->GetDisplayNameOf(pidlItem, SHGDN_INFOLDER, &str)))
        {
            AssertMsg(m_pszDisplayName == NULL, TEXT("CWebViewFolderIcon::_GetLabel - leaking m_pszDisplayName!"));
            StrRetToStr(&str, pidlItem, &m_pszDisplayName);
        }
    }
}

void CWebViewFolderIcon::_ClearAmbientFont(void)
{
    if (m_pfont)            // Font came from container
    {
        if (m_hfAmbient)
            m_pfont->ReleaseHfont(m_hfAmbient);
        m_pfont->Release();
        m_pfont = NULL;

    }
    else                    // Font was created by us
    {
        if (m_hfAmbient)
            DeleteObject(m_hfAmbient);
    }
    m_hfAmbient = NULL;

}

void CWebViewFolderIcon::_GetAmbientFont(void)
{
    if (!m_hfAmbient)
    {
        // Try to get the ambient font from our container
        if (SUCCEEDED(GetAmbientFont(&m_pfont)))
        {
            if (SUCCEEDED(m_pfont->get_hFont(&m_hfAmbient)))
            {
                // Yay, everybody is happy
                m_pfont->AddRefHfont(m_hfAmbient);
            }
            else
            {
                // Darn, couldn't get the font from container
                // Clean up and use the fallback
                _ClearAmbientFont();
                goto fallback;
            }
        }
        else
        {
    fallback:
            // No ambient font -- use the icon title font
            LOGFONT lf;
            SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
            m_hfAmbient = CreateFontIndirect(&lf);
        }
    }
}


HRESULT CWebViewFolderIcon::InitImage(void)
{
    HRESULT hr = E_FAIL;

    // Cancel pending bitmap request if you had a functioning IThumbnail
    // but didn't receive the bitmap
    if (m_pthumb && (m_hbm == NULL))
    {
        m_pthumb->GetBitmap(NULL, 0, 0, 0);
    }

    m_dwThumbnailID++;

    // Initialize the image
    switch (_ViewType(m_ViewUser))
    {
    case VIEW_THUMBVIEW:
        hr = InitThumbnail();
        if (hr != S_OK)
        {   // Default to icon view, but return the previous hr
            InitIcon();
        }
        break;

    case VIEW_PIECHART:
        hr = InitPieGraph();
        if (hr != S_OK)
        {   // Default to icon view, but return the previous hr
            InitIcon();
        }
        break;

    default:
        hr = InitIcon();
        break;
    }

    if (SUCCEEDED(hr))          //  Force a Redraw
        UpdateSize();

    return hr;    
}

HRESULT CWebViewFolderIcon::_GetPathW(LPWSTR psz)
{
    *psz = 0;
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl;
    if (S_OK == _GetFullPidl(&pidl))
    {
        if (SHGetPathFromIDListW(pidl, psz))
            hr = S_OK;
        ILFree(pidl);
    }
    return hr;
}


HRESULT CWebViewFolderIcon::InitPieGraph(void)
{
    HRESULT hr = S_FALSE;
    
    WCHAR wzPath[MAX_PATH];
    if (SUCCEEDED(_GetPathW(wzPath)))
    {
        //  Check to see if it is a root
        if (PathIsRootW(wzPath))
        {
            if (SUCCEEDED(ComputeFreeSpace(wzPath)))
            {
                m_ViewCurrent = VIEW_PIECHART;
                m_lImageHeight = PIEVIEW_DEFAULT;
                m_lImageWidth = PIEVIEW_DEFAULT;
                hr = S_OK;
            }
        }
        else        // not the root, change view to large icon
            m_ViewCurrent = VIEW_LARGEICON;
    }
    return hr;
}

HRESULT CWebViewFolderIcon::InitThumbnail(void)
{
    m_lImageHeight = THUMBVIEW_DEFAULT;
    m_lImageWidth = THUMBVIEW_DEFAULT;

    //  Get thumbnail bitmap from the path
    HRESULT hr = S_FALSE;
    LPITEMIDLIST pidl;
    if (S_OK == _GetFullPidl(&pidl))
    {
        hr = SetupIThumbnail();
        if (SUCCEEDED(hr))
        {
            LONG lWidth = _GetScaledImageWidth();
            LONG lHeight = _GetScaledImageHeight();

            // Sends the WM_HTML_BITMAP message
            hr = m_pthumb->GetBitmapFromIDList(pidl, m_dwThumbnailID, lWidth, lHeight);
            if (SUCCEEDED(hr))
                m_ViewCurrent = VIEW_THUMBVIEW;
            else
                hr = S_FALSE;
        }
        ILFree(pidl);
    }
    return hr;
}

HRESULT CWebViewFolderIcon::_MakeRoomForLabel()
{
    /*
     *  If we got a label, then make room for it.
     */
    if (m_pszDisplayName)
    {
        GETDCSTATE dcs;
        HDC hdc = IUnknown_GetDC(m_spClientSite, &m_rcPos, &dcs);
        _GetAmbientFont();

        HFONT hfPrev = SelectFont(hdc, m_hfAmbient);

        m_sizLabel.cx = m_sizLabel.cy = 0;
        GetTextExtentPoint(hdc, m_pszDisplayName, lstrlen(m_pszDisplayName), &m_sizLabel);
        SelectFont(hdc, hfPrev);

        IUnknown_ReleaseDC(hdc, &dcs);
    }
    return S_OK;
}

HRESULT CWebViewFolderIcon::InitIcon(void)
{
    LPITEMIDLIST            pidlLast;
    CComPtr<IShellFolder>   spsfParent;
    INT                     iIconIndex = II_DESKTOP;  

    _ClearLabel();

    //  Get icon index
    HRESULT hr = _GetPidlAndShellFolder(&pidlLast, &spsfParent);
    if (SUCCEEDED(hr))
    {
        if (m_ViewUser & VIEW_WITHLABEL)
        {
            _GetLabel(spsfParent, pidlLast);
        }

        //  _GetPidlAndShellFolder() may succeed and spsfParent and pidlLast can be NULL.
        //  In this case the icon will default to II_FOLDER

        //  Is it the default folder case?
        if (hr == S_FALSE)
        {
            //  Yes, so just use the default folder icon.
            iIconIndex = II_FOLDER;   
        }
        else if (spsfParent && pidlLast)
        {
            iIconIndex = SHMapPIDLToSystemImageListIndex(spsfParent, pidlLast, NULL);
            if (iIconIndex <= 0)
            {
                iIconIndex = II_FOLDER;
            }
        }
        //  else it defaults to the desktop
        
        //  Extract icon
        hr = E_FAIL;     //  We haven't gotten it yet
       
        if (m_hIcon)
        {
            // If the indexes match, we can use the previous value as a cache, otherwise,
            // we need to free it.  We also need to free the bitmap in this case.
            if (iIconIndex != m_iIconIndex)
            {
                DestroyIcon(m_hIcon);
                m_hIcon = 0;
            }
            else
            {
                hr = S_OK;      //  Use the one we have already
            }
        }

        // We also need to check and free the bitmap
        if (m_hbm)
        {
            DeleteObject(m_hbm);
            m_hbm = 0;
        }

        if (FAILED(hr))         //  Different icon
        {
            HIMAGELIST  himlSysLarge;
            HIMAGELIST  himlSysSmall;
            
            if ((iIconIndex > 0) && Shell_GetImageLists(&himlSysLarge, &himlSysSmall))
            {
                switch (_ViewType(m_ViewUser))  
                {
                case VIEW_SMALLICON:
                    m_hIcon = ImageList_GetIcon(himlSysSmall, iIconIndex, 0);
                    m_ViewCurrent = m_ViewUser;
                    break;

                case VIEW_LARGEICON:
                    m_hIcon = ImageList_GetIcon(himlSysLarge, iIconIndex, 0);     
                    m_ViewCurrent = m_ViewUser;
                    break;

                default:  // Falls here for large icon and default
                    m_hIcon = ImageList_GetIcon(himlSysLarge, iIconIndex, 0);     
                    m_ViewCurrent = VIEW_LARGEICON;
                    break;
                }  // switch
                
                if (m_hIcon)
                {
                    ICONINFO    iconinfo;
                    
                    //  Get icon size
                    if (GetIconInfo(m_hIcon, &iconinfo))
                    {
                        BITMAP  bm;
                        
                        if (GetObject(iconinfo.hbmColor, sizeof(bm), &bm))
                        {
                            m_lImageWidth = bm.bmWidth;
                            m_lImageHeight = bm.bmHeight;

                            // Hold on to the color hbm for use as a drag image.
                            m_hbm = iconinfo.hbmColor;
                            hr = S_OK;
                        }
                        else
                        {
                            DeleteObject(iconinfo.hbmColor);
                        }

                        DeleteObject(iconinfo.hbmMask);
                    }
                }
            }
        }
        
        ILFree(pidlLast);

        _MakeRoomForLabel();
    }

    if (FAILED(hr))
    {
        //  Couldn't get the icon so set the size to something resonable so that the rest
        //  of the page looks normal

        m_lImageWidth =  LARGE_ICON_DEFAULT;
        m_lImageHeight = LARGE_ICON_DEFAULT;
        UpdateSize();       //  Force an update
    }

    return hr;
} 

HRESULT CWebViewFolderIcon::UpdateSize(void)
{
    HRESULT                   hr = E_FAIL;
      
    // Get the IHtmlStyle
    if (m_spClientSite) 
    {
        CComPtr<IOleControlSite>  spControlSite;

        hr = m_spClientSite->QueryInterface(IID_PPV_ARG(IOleControlSite, &spControlSite));
        if (EVAL(SUCCEEDED(hr)))
        {
            CComPtr<IDispatch> spdisp;

            hr = spControlSite->GetExtendedControl(&spdisp);
            if (EVAL(SUCCEEDED(hr)))
            {
                CComPtr<IHTMLElement> spElement;

                hr = spdisp->QueryInterface(IID_PPV_ARG(IHTMLElement, &spElement));
                if (EVAL(SUCCEEDED(hr)))
                {
                    CComPtr<IHTMLStyle> spStyle;
                    
                    hr = spElement->get_style(&spStyle);
                    if (EVAL(SUCCEEDED(hr)))
                    {
                        CComVariant vWidth(_GetControlWidth(), VT_I4);
                        CComVariant vHeight(_GetControlHeight(), VT_I4);
                        
                        // Set the height and width
                        spStyle->put_width(vWidth);
                        spStyle->put_height(vHeight);
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CWebViewFolderIcon::ForceRedraw(void)
{
    IOleInPlaceSiteEx *pins;
   
    // Get the IHtmlStyle
    if (m_spClientSite) 
    {
        if (SUCCEEDED(m_spClientSite->QueryInterface(IID_PPV_ARG(IOleInPlaceSiteEx, &pins)))) 
        {
            HWND hwnd;
            if (SUCCEEDED(pins->GetWindow(&hwnd))) 
            {
                ::InvalidateRgn(hwnd, NULL, TRUE);
            }
            pins->Release();
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IOleInPlaceObject

STDMETHODIMP CWebViewFolderIcon::UIDeactivate(void)
{
    if (m_bAdvPropsOn)
        _FlipFocusRect(FALSE);

    return IOleInPlaceObject_UIDeactivate();
}

// *** IOleInPlaceActiveObject ***
HRESULT CWebViewFolderIcon::TranslateAccelerator(LPMSG pMsg)
{
    HRESULT hr = S_OK;
    if (!m_fTabRecieved)
    {
        hr = IOleInPlaceActiveObjectImpl<CWebViewFolderIcon>::TranslateAccelerator(pMsg);

        // If we did not handle this and if it is a tab (and we are not getting it in a cycle), forward it to trident, if present.
        if (hr != S_OK && pMsg && (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6) && m_spClientSite)
        {
            HWND hwnd;
            if (SUCCEEDED(_GetHwnd(&hwnd)) && (GetFocus() != hwnd))
            {
                ::SetFocus(hwnd);
                hr = S_OK;
            }
            else
            {
                IOleControlSite* pocs = NULL;
                if (SUCCEEDED(m_spClientSite->QueryInterface(IID_PPV_ARG(IOleControlSite, &pocs))))
                {
                    DWORD grfModifiers = 0;
                    if (GetKeyState(VK_SHIFT) & 0x8000)
                    {
                        grfModifiers |= 0x1;    //KEYMOD_SHIFT
                    }
                    if (GetKeyState(VK_CONTROL) & 0x8000)
                    {
                        grfModifiers |= 0x2;    //KEYMOD_CONTROL;
                    }
                    if (GetKeyState(VK_MENU) & 0x8000)
                    {
                        grfModifiers |= 0x4;    //KEYMOD_ALT;
                    }
                    m_fTabRecieved = TRUE;
                    hr = pocs->TranslateAccelerator(pMsg, grfModifiers);
                    m_fTabRecieved = FALSE;
                }
            }
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// ATL

HRESULT CWebViewFolderIcon::DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent)
{
    if (m_bAdvPropsOn)
        _FlipFocusRect(TRUE);

    return IOleObjectImpl<CWebViewFolderIcon>::DoVerbUIActivate(prcPosRect, hwndParent);
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch 

STDMETHODIMP CWebViewFolderIcon::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr)
{
    HRESULT hr;

    //
    // We are overloading this dispatch implementation to be an html window event
    // sink and implement the scale property.  This is safe since the dispid ranges
    // don't overlap.
    // Likewise we overload now for notifications that come from the browser object...
    //

    if (dispidMember == DISPID_HTMLWINDOWEVENTS_ONLOAD) 
    {
        hr = OnWindowLoad();
    } 
    else if (dispidMember == DISPID_HTMLWINDOWEVENTS_ONUNLOAD) 
    {
        hr = OnWindowUnLoad();    
    }
    else
    {
        hr = IDispatchImpl<IWebViewFolderIcon3, &IID_IWebViewFolderIcon3, &LIBID_WEBVWLib>::Invoke(
              dispidMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }

    return hr;  
}


/////////////////////////////////////////////////////////////////////////////
// IViewObjectEx

STDMETHODIMP CWebViewFolderIcon::GetViewStatus(DWORD* pdwStatus)
{
    *pdwStatus = VIEWSTATUS_DVASPECTTRANSPARENT;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IPointerInactive

STDMETHODIMP CWebViewFolderIcon::GetActivationPolicy(DWORD* pdwPolicy)
{
    if (!m_bAdvPropsOn)
        return S_OK;

    *pdwPolicy = POINTERINACTIVE_ACTIVATEONDRAG;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IOleInPlaceObjectWindowless

// To implement Windowless DropTarget
STDMETHODIMP CWebViewFolderIcon::GetDropTarget(IDropTarget **ppDropTarget)
{
    HRESULT hr = S_OK;

    if (ppDropTarget)
        *ppDropTarget = NULL;

    if (m_bAdvPropsOn)
    {
        // Do we need to populate m_pDropTargetCache?
        if (!m_pDropTargetCache)
        {
            // Yes, so try to get it now.
            hr = _GetChildUIObjectOf(IID_PPV_ARG(IDropTarget, &m_pDropTargetCache));
        }

        if (m_pDropTargetCache)
            hr = m_pDropTargetCache->QueryInterface(IID_PPV_ARG(IDropTarget, ppDropTarget));
        else
            hr = E_FAIL;
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IOleObject

STDMETHODIMP CWebViewFolderIcon::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr;

    // Deal with the old client site
    if (pClientSite == NULL && m_spClientSite)
    {
        // We need to unadvise from the defview object now...
        if (m_pccpDV) 
        {
            m_pccpDV->Unadvise(m_dwCookieDV);
            m_pccpDV->Release();
            m_pccpDV = NULL;
        }
        DisconnectHtmlEvents(m_pdispWindow, m_dwHtmlWindowAdviseCookie);
        m_dwHtmlWindowAdviseCookie = 0;
    }

    hr = IOleObjectImpl<CWebViewFolderIcon>::SetClientSite(pClientSite);

    if ((pClientSite != NULL) && SUCCEEDED(hr))
    { 
        ConnectHtmlEvents(this, m_spClientSite, &m_pdispWindow, &m_dwHtmlWindowAdviseCookie);

        // OK now lets register ourself with the Defview to get any events that they may generate...
        IServiceProvider *pspTLB;
        hr = IUnknown_QueryService(m_spClientSite, SID_STopLevelBrowser, IID_PPV_ARG(IServiceProvider, &pspTLB));
        if (SUCCEEDED(hr)) 
        {
            IExpDispSupport *peds;
            hr = pspTLB->QueryService(IID_IExpDispSupport, IID_PPV_ARG(IExpDispSupport, &peds));
            if (SUCCEEDED(hr)) 
            {
                hr = peds->FindCIE4ConnectionPoint(DIID_DWebBrowserEvents2, &m_pccpDV);
                if (SUCCEEDED(hr)) 
                {
                    hr = m_pccpDV->Advise(SAFECAST(this, IDispatch*), &m_dwCookieDV);
                }
                peds->Release();
            }
            pspTLB->Release();
        }
    }

    return hr;
}


UINT g_cfPreferedEffect = 0;

HRESULT _SetPreferedDropEffect(IDataObject *pdtobj, DWORD dwEffect)
{
    if (g_cfPreferedEffect == 0)
        g_cfPreferedEffect = RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);

    HRESULT hr = E_OUTOFMEMORY;
    DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD));
    if (pdw)
    {
        STGMEDIUM medium;
        FORMATETC fmte = {(CLIPFORMAT)g_cfPreferedEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        *pdw = dwEffect;

        medium.tymed = TYMED_HGLOBAL;
        medium.hGlobal = pdw;
        medium.pUnkForRelease = NULL;

        hr = pdtobj->SetData(&fmte, &medium, TRUE);

        if (FAILED(hr))
            GlobalFree((HGLOBAL)pdw);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Event Handlers

HRESULT CWebViewFolderIcon::DragDrop(int iClickXPos, int iClickYPos)
{
    if (!m_bAdvPropsOn)
        return S_OK;

    LPITEMIDLIST pidlLast;
    IShellFolder *psfParent;
    HRESULT hr = _GetPidlAndShellFolder(&pidlLast, &psfParent);

    if (hr == S_OK)
    {
        IDataObject *pdtobj;

        hr = psfParent->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*) &pidlLast, 
                                      IID_PPV_ARG_NULL(IDataObject, &pdtobj));
        if (SUCCEEDED(hr))
        {
            DWORD dwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK;

            psfParent->GetAttributesOf(1, (LPCITEMIDLIST*) &pidlLast, &dwEffect);
            dwEffect &= DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK;
            
            if (dwEffect)
            {
                HRESULT hrOleInit = SHCoInitialize();
                HWND hwnd;
                
                hr = _GetHwnd(&hwnd);
                
                if (SUCCEEDED(hr))
                {
                    DWORD dwEffectOut;
                    
                    _SetPreferedDropEffect(pdtobj, DROPEFFECT_LINK);  
                    
                    // Set the drag image and effect; we don't care if 
                    // it fails, we'll just use the default.
                    _SetDragImage(iClickXPos, iClickYPos, pdtobj);


                    hr = SHDoDragDrop(hwnd, pdtobj, NULL, dwEffect, &dwEffectOut);
                }
                SHCoUninitialize(hrOleInit);
            }
            
            pdtobj->Release();
        }
        psfParent->Release();
        ILFree(pidlLast);
    }

    return hr;
}

// SetDragImage
//
// Sets the drag image to be identical to the icon
HRESULT CWebViewFolderIcon::_SetDragImage(int iClickXPos, int iClickYPos, IDataObject *pdtobj)
{
    // Check things that need to be valid for us to work
    AssertMsg(m_hdc != NULL , TEXT("CWebViewFolderIcon:_SetDragImage() m_hdc is null"));
    AssertMsg(m_hbmDrag != NULL, TEXT("CWebViewFolderIcon:_SetDragImage m_hbmDrag is null"));

    // If the image is a pie chart, it isn't loaded into m_hbm, so we need
    // to do that first
    if (m_ViewCurrent == VIEW_PIECHART)
    {
        _GetPieChartIntoBitmap();
    }

    // Get a dragdrop helper to set our image
    IDragSourceHelper *pdsh;
    HRESULT hr = CoCreateInstance(CLSID_DragDropHelper, NULL, CLSCTX_INPROC_SERVER, 
        IID_PPV_ARG(IDragSourceHelper, &pdsh));
    if (SUCCEEDED(hr))
    {
        BITMAPINFOHEADER bmi = {0};
        BITMAP           bm = {0};
        UINT uBufferOffset = 0;
        
        // This is a screwy procedure to use GetDIBits.  
        // See knowledge base Q80080

        GetObject(m_hbm, sizeof(BITMAP), &bm);

        bmi.biSize          = sizeof(BITMAPINFOHEADER);
        bmi.biWidth         = bm.bmWidth;
        bmi.biHeight        = bm.bmHeight;
        bmi.biPlanes        = 1;
        bmi.biBitCount      = bm.bmPlanes * bm.bmBitsPixel;
        
        // This needs to be one of these 4 values
        if (bmi.biBitCount <= 1)
            bmi.biBitCount = 1;
        else if (bmi.biBitCount <= 4)
            bmi.biBitCount = 4;
        else if (bmi.biBitCount <= 8)
            bmi.biBitCount = 8;
        else
            bmi.biBitCount = 24;
        
        bmi.biCompression   = BI_RGB;

        // Total size of buffer for info struct and color table
        uBufferOffset = sizeof(BITMAPINFOHEADER) + 
            ((bmi.biBitCount == 24) ? 0 : ((1 << bmi.biBitCount) * sizeof(RGBQUAD)));
        
        // Buffer for bitmap bits, so we can copy them.
        BYTE * psBits = (BYTE *) SHAlloc(uBufferOffset);

        if (psBits)
        {
            // Put bmi into the memory block
            CopyMemory(psBits, &bmi, sizeof(BITMAPINFOHEADER));

            // Get the size of the buffer needed for bitmap bits
            if (GetDIBits(m_hdc, m_hbm, 0, 0, NULL, (BITMAPINFO *) psBits, DIB_RGB_COLORS))
            {
                // Realloc our buffer to be big enough
                psBits = (BYTE *) SHRealloc(psBits, uBufferOffset + ((BITMAPINFOHEADER *) psBits)->biSizeImage);

                if (psBits)
                {
                    // Fill the buffer
                    if (GetDIBits(m_hdc, m_hbm, 0, bmi.biHeight, 
                        (void *)(psBits + uBufferOffset), (BITMAPINFO *)psBits, 
                        DIB_RGB_COLORS))
                    {
                        SHDRAGIMAGE shdi;  // Drag images struct
                        
                        shdi.hbmpDragImage = CreateBitmapIndirect(&bm);
                        
                        if (shdi.hbmpDragImage)
                        {
                            // Set the drag image bitmap
                            if (SetDIBits(m_hdc, shdi.hbmpDragImage, 0, m_lImageHeight, 
                                (void *)(psBits + uBufferOffset), (BITMAPINFO *)psBits, 
                                DIB_RGB_COLORS))
                            {
                                // Populate the drag image structure
                                shdi.sizeDragImage.cx = m_lImageWidth;
                                shdi.sizeDragImage.cy = m_lImageHeight;
                                
                                shdi.ptOffset.x = iClickXPos - m_rcPos.left;
                                shdi.ptOffset.y = iClickYPos - m_rcPos.top;
                                
                                shdi.crColorKey = 0;
                                
                                // Set the drag image
                                hr = pdsh->InitializeFromBitmap(&shdi, pdtobj); 
                            }
                            else
                            {
                                hr = E_FAIL;  // Can't SetDIBits
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;  // Can't alloc hbmpDragImage
                        }
                    }
                    else
                    {
                        hr = E_FAIL;  // Can't fill psBits
                    }
                    // Free psBits below...
                }
                else
                {
                    hr = E_OUTOFMEMORY;  // Can't realloc psBits
                    
                    // Free psbits here; it still has the old contents
                    SHFree(psBits);
                    psBits = NULL;
                }
            }
            else
            {
                hr = E_FAIL;  // Can't get image size
            }
            if (psBits)
                SHFree(psBits);
        }
        else
        {
            hr = E_OUTOFMEMORY;  // Can't alloc psBits
        }        
        pdsh->Release();
    }
    
    return hr;
}

HRESULT CWebViewFolderIcon::_GetPieChartIntoBitmap()
{
    BITMAP bm;
    
    // It is possible for m_hbm to be alloced, so check for it.
    if (m_hbm)
    {
        DeleteObject(m_hbm);
    }
    
    // Notice that because we want to draw into a new DC starting
    // from the origin, but our rect contains the coords for the
    // original DC, it is neccessary to adjust the coords so that
    // the rect starts at 0, 0 but still has the same proportions.  
    // Since OnDraw() resets the rect each time, we don't have to
    // preserve it and do have to do this each time.  Finally, since
    // Draw3dPie adjusts the rect dimensions for itself, we only want
    // to fix this once.
    if (!m_fRectAdjusted)
    {
        m_rect.right -= m_rect.left;
        m_rect.left = 0;
        m_rect.bottom -= m_rect.top;
        m_rect.top = 0;
        m_fRectAdjusted = 1;
    }
    
    // Get the bitmap
    GetObject(m_hbmDrag, sizeof(BITMAP), &bm);
    m_hbm = CreateBitmapIndirect(&bm);
    
    if (m_hbm)
    {
        // Select into the new DC, and draw our pie
        HBITMAP hbmOld = (HBITMAP) SelectObject(m_hdc, m_hbm);
        DWORD dwPercent1000 = 0;
        
        if (EVAL((m_ullTotalSpace > 0) && (m_ullFreeSpace <= m_ullTotalSpace)))
        {
            ComputeSlicePct(m_ullUsedSpace, &dwPercent1000);
        }
        
        Draw3dPie(m_hdc, &m_rect, dwPercent1000, m_ChartColors);
        
        SelectObject(m_hdc, hbmOld);
    }
    
    return S_OK;
}


LRESULT CWebViewFolderIcon::OnInitPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (m_pcm3)
        m_pcm3->HandleMenuMsg(uMsg, wParam, lParam);

    return 0;
}


LRESULT CWebViewFolderIcon::OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (!m_bAdvPropsOn)
        return TRUE;

    if ((int)wParam != VK_RETURN && (int) wParam != VK_SPACE)
    {
        return FALSE;
    }
    else
        return _WebViewOpen();
}


LRESULT CWebViewFolderIcon::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (m_bAdvPropsOn)
    {
        _DisplayContextMenu(-1, -1);
    }

    return TRUE;
}


// NOTE: our drag drop code captures the mouse and has to do funky stuff to
// make sure we get this button up message. if you have problems with this check
// the code in CheckForDragBegin()

LRESULT CWebViewFolderIcon::OnButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    BOOL Processed = FALSE;
    
    if (!m_bAdvPropsOn)
        return TRUE; 

    HWND hwnd;
    if (EVAL(SUCCEEDED(_GetHwnd(&hwnd))))
    {
        if (CheckForDragBegin(hwnd, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)))
        {
            IUnknown *punk;
            if (EVAL(SUCCEEDED(IUnknown_QueryService(m_spClientSite, SID_STopLevelBrowser, IID_PPV_ARG(IUnknown, &punk)))))
            {
                if (SUCCEEDED(DragDrop(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))))
                {
                    Processed = TRUE;
                }
            }
        }
    }

    /*
     *  In single-click mode, open on single left click.
     */
    if (!Processed && uMsg == WM_LBUTTONDOWN && m_clickStyle == 1)
        return _WebViewOpen();

    return Processed;
}

//  Only valid for the HTML window case
LRESULT CWebViewFolderIcon::OnLButtonDoubleClick(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (!m_bAdvPropsOn || m_clickStyle != 2)
        return TRUE;

    return _WebViewOpen();
}


LRESULT CWebViewFolderIcon::OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (!m_bAdvPropsOn)
        return TRUE;

    //
    // the first time we get a WM_MOUSEMOVE event, we set m_bHilite to be TRUE and ignore 
    // subsequent WM_MOUSEMOVEs. OnMouseLeave() sets m_bHilite to FALSE in response to 
    // a WM_MOUSELEAVE msg.
    //
    if (!m_bHilite)
    {   
        m_bHilite = TRUE;
        return SUCCEEDED(ForceRedraw());
    }
    else
    {
        return TRUE;
    }
}

LRESULT CWebViewFolderIcon::OnMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (!m_bAdvPropsOn)
        return TRUE;

    m_bHilite = FALSE;
    return SUCCEEDED(ForceRedraw());
}

// The Right Mouse button came up so we want to

LRESULT CWebViewFolderIcon::OnRButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    LRESULT lResult = FALSE;

    if (!m_bAdvPropsOn)
        return TRUE;
    
    HRESULT hr = LocalZoneCheck(m_spClientSite);
    if (S_OK == hr)
    {
        hr = _DisplayContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        if (SUCCEEDED(hr))
        {
            lResult = TRUE;
        }
    }

    return lResult;
}


BOOL CWebViewFolderIcon::_IsHostWebView(void)
{
    if (UNINITIALIZE_BOOL == m_fIsHostWebView)
    {
        CComPtr<IDefViewID> spDefView;

        m_fIsHostWebView = FALSE;
        // This will fail if we are hosted in a web page instead of the HTML WebView frame in DefView.
        if (SUCCEEDED(IUnknown_QueryService(m_spClientSite, SID_SFolderView, IID_PPV_ARG(IDefViewID, &spDefView))))
        {
            m_fIsHostWebView = TRUE;
        }
    }

    return m_fIsHostWebView;
}


BOOL CWebViewFolderIcon::_IsPubWizHosted(void)
{
    IPropertyBag *ppb;
    HRESULT hr = IUnknown_QueryService(m_spClientSite, SID_WebWizardHost, IID_PPV_ARG(IPropertyBag, &ppb));
    if (SUCCEEDED(hr))
    {
        ppb->Release();
    }
    return SUCCEEDED(hr);
}


/****************************************************\
    DESCRIPTION:
        We need a little special
    work on the Context Menu since it points to the
    same folder we are in.  So the "Send To" menu
    needs massaging and the "Open" verb needs to
    be removed.

    TODO: I think we should also do this:
    case WM_MENUCHAR:
        _pcm->HandleMenuMsg2(uMsg, wParam, lParam, &lres);
        break;
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
        _pcm->HandleMenuMsg(uMsg, wParam, lParam);
        break;

    case WM_INITMENUPOPUP:
        _pcm->HandleMenuMsg(WM_INITMENUPOPUP, (WPARAM)hmenuPopup, (LPARAM)MAKELONG(nIndex, fSystemMenu)
        break;
\****************************************************/
HRESULT CWebViewFolderIcon::_DisplayContextMenu(long nXCord, long nYCord)
{    
    if (!m_bAdvPropsOn)
    {
        return S_OK;
    }
    
    // respect system policies
    if (SHRestricted(REST_NOVIEWCONTEXTMENU)) 
    {
        return E_FAIL;
    }        
    return _DoContextMenuCmd(FALSE, nXCord, nYCord);
}


//
// bDefault == TRUE  > Function executes the default context menu verb, ignores the coords
// bDefault == FALSE > Function pops up a menu at the given coords and executes the desired verb
//
HRESULT CWebViewFolderIcon::_DoContextMenuCmd(BOOL bDefault, long nXCord, long nYCord)
{
    IContextMenu *pcm;
    HRESULT hr = _GetChildUIObjectOf(IID_PPV_ARG(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        HMENU hpopup = CreatePopupMenu();            
        if (hpopup)
        {
            // SetSite required if you want in place navigation
            IUnknown_SetSite(pcm, m_spClientSite);
            hr = pcm->QueryContextMenu(hpopup, 0, ID_FIRST, ID_LAST, CMF_NORMAL);
            if (SUCCEEDED(hr))
            {
                HWND hwnd;
                hr = _GetHwnd(&hwnd);
                if (SUCCEEDED(hr))
                {
                    UINT idCmd = -1;
                    if (bDefault) // invoke the default verb
                    {
                        idCmd = GetMenuDefaultItem(hpopup, FALSE, GMDI_GOINTOPOPUPS);
                    }
                    else
                    {
                        //
                        // popup the menu and get the command to be executed
                        //
                        POINT point = {nXCord, nYCord};

                        // NTRAID#106655 05-02-2000 arisha
                        // We need to add support to be able to modify the context menu from script.
                        // Below, we make sure we do not remove the "open" verb from the context
                        // menu if we are displaying it in the VIEW_LARGEICONLABEL mode.
                        if (_IsHostWebView() && (m_ViewCurrent != VIEW_LARGEICONLABEL))
                        {
                            hr = ContextMenu_DeleteCommandByName(pcm, hpopup, ID_FIRST, TEXT("open"));
                        }
                        if ((point.x == -1) && (point.y == -1))
                        {
                            _GetCenterPoint(&point);
                        }
                        ::ClientToScreen(hwnd, &point);

                        pcm->QueryInterface(IID_PPV_ARG(IContextMenu3, &m_pcm3));
                        
                        if (SUCCEEDED(_SetupWindow()))
                        {
                            idCmd = TrackPopupMenu(hpopup, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN, 
                                                       (int)point.x, (int)point.y,
                                                       0, m_msgHwnd, NULL);
                        }
                        if (!IsSafeToDefaultVerb() || 0 == idCmd) // 0 implies user cancelled selection
                        {
                            idCmd = -1;
                        }
                        
                        ATOMICRELEASE(m_pcm3);
                    }    
                    if (idCmd != -1)
                    {
                        CMINVOKECOMMANDINFO cmdInfo = 
                        {
                            sizeof(cmdInfo),
                            0,
                            hwnd,
                            (LPSTR)MAKEINTRESOURCE(idCmd),
                            NULL,
                            NULL,
                            SW_NORMAL
                        };
                        hr = pcm->InvokeCommand(&cmdInfo);                        
                    }
                }                
            }
            IUnknown_SetSite(pcm, NULL);                                
            DestroyMenu(hpopup);            
        }
        pcm->Release();
    }
    return hr;
}


HRESULT CWebViewFolderIcon::OnAmbientPropertyChange(DISPID dispid)
{
    switch (dispid)
    {
    case DISPID_UNKNOWN:
    case DISPID_AMBIENT_FONT:

        // changing the font means we need to recompute our label
        if (m_pszDisplayName)
        {
            CComPtr<IFont> spFont;
            if (SUCCEEDED(GetAmbientFont(&spFont)))
            {
                if (spFont->IsEqual(m_pfont) != S_OK)
                {
                    _ClearAmbientFont();
                    _MakeRoomForLabel();
                }
            }
        }
        // FALL THROUGH

    case DISPID_AMBIENT_BACKCOLOR:
    case DISPID_AMBIENT_FORECOLOR:
        ForceRedraw();
        break;
    }

    return S_OK;
}

COLORREF _TranslateColor(OLE_COLOR oclr)
{
    COLORREF clr;
    if (FAILED(OleTranslateColor(oclr, NULL, &clr)))
        clr = oclr;
    return clr;
}


HRESULT CWebViewFolderIcon::OnDraw(ATL_DRAWINFO& di)
{
    RECT& rc = *(RECT*)di.prcBounds;
    LONG  lImageWidth = _GetScaledImageWidth();
    LONG  lImageHeight = _GetScaledImageHeight();

    // Grab our hdc and rect to be used in _SetDragImage
    if (m_hdc)
    {
        DeleteDC(m_hdc);
    }

    m_hdc = CreateCompatibleDC(di.hdcDraw);

    if (m_hbmDrag)
    {
        DeleteObject(m_hbmDrag);
    }

    m_hbmDrag = CreateCompatibleBitmap(di.hdcDraw, m_lImageWidth, m_lImageHeight);
    m_rect = rc;
    m_fRectAdjusted = 0;

    
    //
    // Draw the folder icon
    //
    if ((m_ViewCurrent == VIEW_THUMBVIEW) || (m_ViewCurrent == VIEW_PIECHART))
    {
        HDC hdc =   di.hdcDraw; 
        HDC         hdcBitmap;
        BITMAP      bm;
        HPALETTE    hpal = NULL;

        ASSERT(hdc);

        // Create pallete appropriate for this HDC
        if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        {
            hpal = SHCreateShellPalette(hdc);
            HPALETTE hpalOld = SelectPalette(hdc, hpal, TRUE);
            RealizePalette(hdc);

            // Old one needs to be selected back in
            SelectPalette(hdc, hpalOld, TRUE);
        }

        hdcBitmap = CreateCompatibleDC(hdc); 

        if (hdcBitmap)
        {
            //  Draw pie chart
            if (m_ViewCurrent == VIEW_PIECHART)
            {
                DWORD dwPercent1000 = 0;

                if (1) // m_fUseSystemColors.  When do we want this off?
                {
                    // system colors can change!
                    m_ChartColors[PIE_USEDCOLOR] = GetSysColor(COLOR_3DFACE);
                    m_ChartColors[PIE_FREECOLOR] = GetSysColor(COLOR_3DHILIGHT);
                    m_ChartColors[PIE_USEDSHADOW] = GetSysColor(COLOR_3DSHADOW);
                    m_ChartColors[PIE_FREESHADOW] = GetSysColor(COLOR_3DFACE);
                }
                else if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
                {
                    // Call GetNearestColor on the colors to make sure they're on the palette
                    // Of course, system colors ARE on the palette (I think)
                    DWORD dw = 0;       // index
                    for (dw = 0; dw < PIE_NUM; dw++)
                    {
                        m_ChartColors[dw] = GetNearestColor(hdc, m_ChartColors[dw]);
                    }
                }

                if (EVAL((m_ullTotalSpace > 0) && (m_ullFreeSpace <= m_ullTotalSpace)))
                {
                    ComputeSlicePct(m_ullUsedSpace, &dwPercent1000);
                }

                Draw3dPie(hdc, &rc, dwPercent1000, m_ChartColors);
            }
            else    // Draw the Bitmap
            {
                SelectObject(hdcBitmap, m_hbm);
                GetObject(m_hbm, sizeof(bm), &bm);

                //  Bitmap exactly fits the rectangle
                if (bm.bmWidth == rc.right - rc.left && bm.bmHeight == rc.bottom - rc.top)
                {
                    BitBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, hdcBitmap, 0, 0, SRCCOPY);
                }
                //  Stretch Bitmap to fit the rectangle
                else
                {
                    SetStretchBltMode(hdc, COLORONCOLOR);
                    StretchBlt(hdc, rc.left, rc.top, lImageWidth, lImageHeight, hdcBitmap, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
                }
            }

            DeleteDC(hdcBitmap);
        }
    }
    else if (m_hIcon) 
    {
        DrawIconEx(di.hdcDraw, rc.left, rc.top, m_hIcon, lImageWidth, lImageHeight, 0, 0, DI_NORMAL);
    }

    // Draw the label (if any)
    if (m_pszDisplayName)
    {
        TEXTMETRIC tm;
        TCHAR szFace[32];
        HFONT hFontHilite = NULL;

        //
        // first get the current font properties, there seems to be no straightforward way
        // to just obtain the LOGFONT structure from an HFONT object, so we have to select it
        // to a DC, then obtain the text metrics and use them to create a new font with or
        // without the underline based on m_bHilite value.
        //
        HFONT hfPrev = SelectFont(di.hdcDraw, m_hfAmbient);
        GetTextFace(di.hdcDraw,ARRAYSIZE(szFace), szFace);        
        if (szFace[0] && GetTextMetrics(di.hdcDraw,&tm))
        {
            hFontHilite = CreateFont(tm.tmHeight,
                                              tm.tmAveCharWidth,
                                              0, //Escapement,
                                              0, //Orientation,
                                              tm.tmWeight,
                                              (DWORD) tm.tmItalic,
                                              (DWORD) m_bHilite, // Hilite is by underlining
                                              tm.tmStruckOut,
                                              tm.tmCharSet,
                                              OUT_DEFAULT_PRECIS,
                                              CLIP_DEFAULT_PRECIS,
                                              DEFAULT_QUALITY,
                                              tm.tmPitchAndFamily,
                                              szFace);
            if (hFontHilite)
            {
                SelectFont(di.hdcDraw, hFontHilite);                                  
            }
        }
        
        OLE_COLOR oclrTxt, oclrBk;
        COLORREF clrTxtPrev, clrBkPrev;
        HRESULT hrTxt, hrBk;

        hrTxt = GetAmbientForeColor(oclrTxt);
        if (SUCCEEDED(hrTxt))
            clrTxtPrev = SetTextColor(di.hdcDraw, _TranslateColor(oclrTxt));

        hrBk = GetAmbientBackColor(oclrBk);
        if (SUCCEEDED(hrBk))
            clrBkPrev = SetBkColor(di.hdcDraw, _TranslateColor(oclrBk));

        TextOut(di.hdcDraw, rc.left + lImageWidth + m_cxLabelGap, rc.top + lImageHeight/2 - m_sizLabel.cy/2,
                m_pszDisplayName, lstrlen(m_pszDisplayName));

        if (m_bHasRect)
        {
            RECT rcFocus;
            rcFocus.top = rc.top + lImageHeight/2 - m_sizLabel.cy/2;
            rcFocus.bottom = rcFocus.top + m_sizLabel.cy;
            rcFocus.left = rc.left + lImageWidth + m_cxLabelGap - 1;
            rcFocus.right = rcFocus.left + m_sizLabel.cx + 1;
            DrawFocusRect(di.hdcDraw, &rcFocus);
        }

        if (SUCCEEDED(hrTxt))
            SetTextColor(di.hdcDraw, clrTxtPrev);

        if (SUCCEEDED(hrBk))
            SetBkColor(di.hdcDraw, clrBkPrev);

        SelectFont(di.hdcDraw, hfPrev);

        if (hFontHilite)
        {
            DeleteObject(hFontHilite);
            hFontHilite = NULL;
        }
    }

    return S_OK;
}

HRESULT CWebViewFolderIcon::OnWindowLoad() 
{
    return InitImage();
}

HRESULT CWebViewFolderIcon::OnImageChanged() 
{
    HRESULT hr = InitImage();

    if (SUCCEEDED(hr))
        ForceRedraw();

    return hr;
}

HRESULT CWebViewFolderIcon::OnWindowUnLoad() 
{
    // nothing here now...
    return S_OK;
}

STDMETHODIMP CWebViewFolderIcon::get_scale(BSTR *pbstrScale)
{
    WCHAR wzScale[MAX_SCALE_STR];

    wnsprintfW(wzScale, ARRAYSIZE(wzScale), L"%d", m_percentScale);

    *pbstrScale = SysAllocString(wzScale);

    return S_OK;
}

STDMETHODIMP CWebViewFolderIcon::put_scale(BSTR bstrScale)
{
    int numchar = lstrlenW(bstrScale);
    int tempScale = 0;

    if (numchar && bstrScale[numchar-1] == '%')
    {
        tempScale = GetPercentFromStrW(bstrScale);
    }
    else 
    {
        // valid number
        for (int i=0 ; i < (numchar-2) ; i++)
        {
            if (!((bstrScale[i] >= '0') && (bstrScale[i] <= '9')))
            {
                tempScale = -1;
                break;
            }
        }

        if ((tempScale != -1) && !StrToIntExW(bstrScale, STIF_DEFAULT, &tempScale))
        {
            tempScale = -1;
        }
    }

    if (tempScale > 0)
    {
        if (m_percentScale != tempScale)
        {
            m_percentScale = tempScale;
            return UpdateSize();
        }
        else
            return S_OK;
    }

    return S_FALSE;
}

STDMETHODIMP CWebViewFolderIcon::get_advproperty(VARIANT_BOOL *pvarbAdvProp)
{
    *pvarbAdvProp = (VARIANT_BOOL)m_bAdvPropsOn;
    
    return S_OK;

}
    
STDMETHODIMP CWebViewFolderIcon::put_advproperty(VARIANT_BOOL varbAdvProp)
{
    if (varbAdvProp != m_bAdvPropsOn)
    {
        m_bAdvPropsOn = varbAdvProp;
        return OnImageChanged();
    }

    return S_OK;
}

STDMETHODIMP CWebViewFolderIcon::get_view(BSTR *pbstrView)
{
    HRESULT hr = S_FALSE;  
    LPCWSTR  pwzTempView;

    switch (m_ViewCurrent)   
    {
        case VIEW_THUMBVIEW:
            {
                pwzTempView = SZ_THUMB_VIEW;
                break;
            }
        case VIEW_PIECHART:
            {
                pwzTempView = SZ_PIE_VIEW;
                break;
            }
        case VIEW_SMALLICON:
            {
                pwzTempView = SZ_SMALL_ICON;
                break;
            }

        case VIEW_SMALLICONLABEL:
            {
                pwzTempView = SZ_SMALL_ICON_LABEL;
                break;
            }

        case VIEW_LARGEICONLABEL:
            {
                pwzTempView = SZ_LARGE_ICON_LABEL;
                break;
            }

        default:        // default and large icon
            {
                pwzTempView = SZ_LARGE_ICON;
                break;
            }
    }

    *pbstrView = SysAllocString(pwzTempView);
    if (*pbstrView)
        hr = S_OK;

    return hr;
}

STDMETHODIMP CWebViewFolderIcon::put_view(BSTR bstrView)
{
    HRESULT hr = S_OK;
    VIEWS View = VIEW_LARGEICON;

    if (StrCmpIW(bstrView, SZ_LARGE_ICON) == 0)
    {
        View = VIEW_LARGEICON;
    }
    else if (StrCmpIW(bstrView, SZ_SMALL_ICON) == 0)
    {
        View = VIEW_SMALLICON;
    }
    else if (StrCmpIW(bstrView, SZ_SMALL_ICON_LABEL) == 0)
    {
        View = VIEW_SMALLICONLABEL;
    }
    else if (StrCmpIW(bstrView, SZ_LARGE_ICON_LABEL) == 0)
    {
        View = VIEW_LARGEICONLABEL;
    }
    else if (StrCmpIW(bstrView, SZ_THUMB_VIEW) == 0)
    {
        View = VIEW_THUMBVIEW;
    }
    else if (StrCmpIW(bstrView, SZ_PIE_VIEW) == 0)
    {
        View = VIEW_PIECHART;
    }
    else
        hr = S_FALSE;
    
    if ((S_OK == hr) && (m_ViewUser != View))
    {
        m_ViewUser = View;

        hr = OnImageChanged();
    }

    return hr;
}


/**************************************************************\
    DESCRIPTION:
        The caller is getting the path of our control.

    SECURITY:
        We only trust callers from the LocalZone.  This method
    secifically worries about untrusted callers using us to
    find out what paths on the file system exists or don't exist.  
\**************************************************************/
STDMETHODIMP CWebViewFolderIcon::get_path(BSTR *pbstrPath)
{
    AssertMsg((NULL != m_spClientSite.p), TEXT("CWebViewFolderIcon::get_path() We need m_spClientSite for our security test and it's NULL. BAD, BAD, BAD!"));
    HRESULT hr = LocalZoneCheck(m_spClientSite);

    if ((S_OK != hr) && !_IsPubWizHosted())
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        hr = E_ACCESSDENIED;
    }
    else
    {
        LPITEMIDLIST pidlFull;

        hr = S_FALSE;
        *pbstrPath = NULL;
        if (S_OK == _GetFullPidl(&pidlFull))
        {
            WCHAR wzPath[INTERNET_MAX_URL_LENGTH];

            if (S_OK == SHGetNameAndFlagsW(pidlFull, SHGDN_FORPARSING, wzPath, ARRAYSIZE(wzPath), NULL))
            {
                *pbstrPath = SysAllocString(wzPath);  
                if (*pbstrPath)
                    hr = S_OK;
            }

            ILFree(pidlFull);
        }
    }
    
    return hr;
}


/**************************************************************\
    DESCRIPTION:
        The caller is setting the path of our control.  Our
    control will render a view of this item, which is often and
    icon.  

    SECURITY:
        We only trust callers from the LocalZone.  This method
    secifically worries about untrusted callers using us to
    find out what paths on the file system exists or don't exist.  
\**************************************************************/
STDMETHODIMP CWebViewFolderIcon::put_path(BSTR bstrPath)
{
    AssertMsg((NULL != m_spClientSite.p), TEXT("CWebViewFolderIcon::put_path() We need m_spClientSite for our security test and it's NULL. BAD, BAD, BAD!"));
    HRESULT hr = LocalZoneCheck(m_spClientSite);

    if ((S_OK != hr) && !_IsPubWizHosted())
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        hr = E_ACCESSDENIED;
    }
    else
    {
        hr = S_FALSE;
        LPITEMIDLIST pidlNew;
    
        hr = IEParseDisplayNameW(CP_ACP, bstrPath, &pidlNew);
        if (SUCCEEDED(hr))
        {
            ATOMICRELEASE(m_pDropTargetCache);      // We will want another IDropTarget for this new pidl.
            ILFree(m_pidl);
            m_pidl = pidlNew;

            hr = OnImageChanged();
            AssertMsg(SUCCEEDED(hr), TEXT("CWebViewFolderIcon::put_path() failed to create the image so the image will be incorrect.  Please find out why."));

            hr = S_OK;
        }
    }
    
    return hr;
}


// Automation methods to get/put FolderItem objects from FolderIcon
STDMETHODIMP CWebViewFolderIcon::get_item(FolderItem ** ppFolderItem)
{   
    HRESULT hr = LocalZoneCheck(m_spClientSite);

    if (S_OK != hr)
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        hr = E_ACCESSDENIED;
    }
    else
    {
        LPITEMIDLIST pidlFull;

        *ppFolderItem = NULL;
        hr = _GetFullPidl(&pidlFull);
        if ((hr == S_OK) && pidlFull)
        {
            IShellDispatch * psd;

            hr = CoCreateInstance(CLSID_Shell, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellDispatch, &psd));
            if (SUCCEEDED(hr))
            {
                IObjectSafety * pos;

                hr = psd->QueryInterface(IID_PPV_ARG(IObjectSafety, &pos));
                if (SUCCEEDED(hr))
                {
                    // Simulate what trident does.
                    hr = pos->SetInterfaceSafetyOptions(IID_IDispatch, INTERFACESAFE_FOR_UNTRUSTED_CALLER, INTERFACESAFE_FOR_UNTRUSTED_CALLER);

                    if (SUCCEEDED(hr))
                    {
                        VARIANT varDir;

                        hr = InitVariantFromIDList(&varDir, pidlFull);
                        if (SUCCEEDED(hr))
                        {
                            IObjectWithSite * pows;

                            hr = psd->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));
                            if (SUCCEEDED(hr))
                            {
                                Folder *psdf;
                            
                                // If we call ::SetSite(), they will display UI to ask the user if they want to allow this.
                                // This is annoying because Trident will always call our get_item() when they load our object
                                // tag.
                                pows->SetSite(m_spClientSite);
                                hr = psd->NameSpace(varDir, &psdf);
                                if (S_OK == hr)
                                {
                                    Folder2 *psdf2;

                                    hr = psdf->QueryInterface(IID_PPV_ARG(Folder2, &psdf2));
                                    if (S_OK == hr)
                                    {
                                        hr = psdf2->get_Self(ppFolderItem);
                                        psdf2->Release();
                                    }

                                    psdf->Release();
                                }

                                pows->SetSite(NULL);
                                pows->Release();
                            }

                            VariantClear(&varDir);
                        }
                    }
                    pos->Release();
                }

                psd->Release();
            }

            ILFree(pidlFull);
        }
        
        // Automation method can't fail or hard script error.  We do want a hard
        // script error on access denied, however.
        if (FAILED(hr) && (hr != E_ACCESSDENIED))
        {
            hr = S_FALSE;
        }
    }
    return hr;
}


STDMETHODIMP CWebViewFolderIcon::put_item(FolderItem * pFolderItem)
{
    HRESULT hr = LocalZoneCheck(m_spClientSite);

    if ((S_OK != hr) && !_IsPubWizHosted())
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        hr = E_ACCESSDENIED;
    }
    else
    {
        hr = S_FALSE;
        
        LPITEMIDLIST pidlNew;
        if (S_OK == SHGetIDListFromUnk(pFolderItem, &pidlNew))
        {
            ATOMICRELEASE(m_pDropTargetCache);      // We will want another IDropTarget for this new pidl.
            ILFree(m_pidl);
            m_pidl = pidlNew;

            hr = OnImageChanged();
            if (FAILED(hr))
            {
                hr = S_FALSE;
            }
        }
    }
    return hr;
}

STDMETHODIMP CWebViewFolderIcon::get_clickStyle(LONG *plClickStyle)
{
    *plClickStyle = m_clickStyle;
    return S_OK;
}

STDMETHODIMP CWebViewFolderIcon::put_clickStyle(LONG lClickStyle)
{
    switch (lClickStyle)
    {
    case 1:         /* oneclick - weblike */
    case 2:         /* twoclick - explorer-like */
        m_clickStyle = lClickStyle;
        break;

    default:        /* Ignore invalid arguments to keep script happy */
        break;

    }

    return S_OK;
}

STDMETHODIMP CWebViewFolderIcon::get_labelGap(LONG *plLabelGap)
{
    *plLabelGap = m_cxLabelGap;
    return S_OK;
}

STDMETHODIMP CWebViewFolderIcon::put_labelGap(LONG lLabelGap)
{
    if (m_cxLabelGap != lLabelGap)
    {
        m_cxLabelGap = lLabelGap;
        UpdateSize();
    }
    return S_OK;
}


STDMETHODIMP CWebViewFolderIcon::setSlice(int index, VARIANT varHiBytes, VARIANT varLoBytes, VARIANT varColorref)
{
    HRESULT     hr = S_FALSE;
    PieSlice_S  pieSlice;

    if ((varHiBytes.vt == VT_I4) && (varLoBytes.vt == VT_I4))
        pieSlice.MemSize = GetUllMemFromVars(&varHiBytes, &varLoBytes);
 
    // Passed a COLORREF
    if (varColorref.vt == VT_I4) 
    {
        pieSlice.Color = (COLORREF)varColorref.lVal;
    }
    // Passed a string
    else if (varColorref.vt == VT_BSTR)
        pieSlice.Color = ColorRefFromHTMLColorStrW(varColorref.bstrVal);
    else
        return hr;

    if (DSA_SetItem(m_hdsaSlices, index, &pieSlice))
    {
        if (index > (m_highestIndexSlice - 1))
            m_highestIndexSlice = (index + 1);
        hr = OnImageChanged();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IObjectSafetyImpl overrides

STDMETHODIMP CWebViewFolderIcon::SetInterfaceSafetyOptions(REFIID riid, 
                                                           DWORD dwOptionSetMask, 
                                                           DWORD dwEnabledOptions)
{
    // If we're being asked to set our safe for scripting option then oblige
    if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag)
    {
        // Store our current safety level to return in GetInterfaceSafetyOptions
        m_dwCurrentSafety = dwEnabledOptions & dwOptionSetMask;
        return S_OK;
    }
    return E_NOINTERFACE;
}


// Handle Window messages for the thumbnail bitmap
LRESULT CALLBACK CWebViewFolderIcon::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CWebViewFolderIcon *ptc = (CWebViewFolderIcon *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_CREATE:
        {
            ptc = (CWebViewFolderIcon *)((CREATESTRUCT *)lParam)->lpCreateParams;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)ptc);
        }
        break;

    // NOTE: do not need to check to see that the bitmap coming through is the one you want since each control has its own
    // message wnd.
    case WM_HTML_BITMAP:
        // check that ptc is still alive and that you have an HBITMAP
        if (ptc && (ptc->m_dwThumbnailID == wParam))
        {
            if (ptc->m_hbm != NULL)
            {
                DeleteObject(ptc->m_hbm);
            }

            ptc->m_hbm = (HBITMAP)lParam;
            ptc->_InvokeOnThumbnailReady();
            ptc->ForceRedraw();
        }
        else if (lParam)
        {
            DeleteObject((HBITMAP)lParam);
        }
        break;

    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_INITMENUPOPUP:
        if (ptc && ptc->m_pcm3)
            ptc->m_pcm3->HandleMenuMsg(uMsg, wParam, lParam);
        break;

    case WM_DESTROY:
        // ignore late messages
        if (ptc)
        {
            MSG msg;

            while(PeekMessage(&msg, hwnd, WM_HTML_BITMAP, WM_HTML_BITMAP, PM_REMOVE))
            {
                if (msg.lParam)
                {
                    DeleteObject((HBITMAP)msg.lParam);
                }
            }
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
        }
        break;
     
    default:
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//  Pie chart functions

HRESULT CWebViewFolderIcon::ComputeFreeSpace(LPCWSTR pszFileName)
{
    return _ComputeFreeSpace(pszFileName, m_ullFreeSpace,
        m_ullUsedSpace, m_ullTotalSpace);
}

// Draw3dPie draws the pie chart with the used slice and the additional slices in m_hdsaSlices
// Look in drawpie.c for the majority of the code (including member functions called within this one)
HRESULT CWebViewFolderIcon::Draw3dPie(HDC hdc, LPRECT lprc, DWORD dwPercent1000, const COLORREF *pColors)
{
    LONG ShadowDepth;

    ASSERT(lprc != NULL && pColors != NULL);

    const LONG c_ShadowScale = 6;       // ratio of shadow depth to height
    const LONG c_AspectRatio = 2;      // ratio of width : height of ellipse

    ScalePieRect(c_ShadowScale, c_AspectRatio, lprc);

    // Compute a shadow depth based on height of the image
    ShadowDepth = (lprc->bottom - lprc->top) / c_ShadowScale;

    // Check dwPercent1000 to ensure within bounds.  Shouldn't be but check anyway.
    // dwPercent1000 is the percentage of used space based out of 1000.
    if (dwPercent1000 > 1000)
        dwPercent1000 = 1000;

    // Now the drawing portion

    RECT rcItem;
    int     cx, cy;             // Center of the pie
    int     rx, ry;             // Center of the rectangle
    int     x, y;               // Radial intersection of the slices
    int     FirstQuadPercent1000;

    // Set up the pie rectangle
    rcItem = *lprc;
    rcItem.left = lprc->left;
    rcItem.top = lprc->top;
    rcItem.right = lprc->right - rcItem.left;
    rcItem.bottom = lprc->bottom - rcItem.top - ShadowDepth;

    SetUpPiePts(&cx, &cy, &rx, &ry, rcItem);

    if ((rx <= 10) || (ry <= 10))
    {
        return S_FALSE;
    }

    // Make the rectangle a little more accurate
    rcItem.right = (2 * rx) + rcItem.left;
    rcItem.bottom = (2 * ry) + rcItem.top;

    // Translate the used percentage to first quadrant
    FirstQuadPercent1000 = (dwPercent1000 % 500) - 250;

    if (FirstQuadPercent1000 < 0)
    {
        FirstQuadPercent1000 = -FirstQuadPercent1000;
    }    

    // Find the slice intersection for the used slice
    CalcSlicePoint(&x, &y, rx, ry, cx, cy, FirstQuadPercent1000, dwPercent1000);

    DrawEllipse(hdc, rcItem, x, y, cx, cy, dwPercent1000, pColors);

    // Used pie slice.
    DrawSlice(hdc, rcItem, dwPercent1000, rx, ry, cx, cy, pColors[COLOR_UP]);

    // Iterate through and draw the slices in m_hdsaSlices.
    PieSlice_S  pieSlice;          
    ULONGLONG   ullMemTotal = 0;    // Keep track of memory in the m_hdsaSlices slices        
    DWORD       dwPercentTotal;     // 1000 Percentage of memory in slices
    for (int i=0; i < m_highestIndexSlice; i++)
    {
        if (DSA_GetItemPtr(m_hdsaSlices, i) != NULL)
        {
            DSA_GetItem(m_hdsaSlices, i, &pieSlice);
            ullMemTotal += pieSlice.MemSize;
        }
    }

    ComputeSlicePct(ullMemTotal, &dwPercentTotal);

    if (m_highestIndexSlice)
    {
        for (i = (m_highestIndexSlice - 1); i >= 0; i--)
        {
            if (DSA_GetItemPtr(m_hdsaSlices, i))
            {
                DSA_GetItem(m_hdsaSlices, i, &pieSlice);
                DrawSlice(hdc, rcItem, dwPercentTotal, rx, ry, cx, cy, pieSlice.Color); 
                ullMemTotal -= pieSlice.MemSize;
                ComputeSlicePct(ullMemTotal, &dwPercentTotal);
            }
        }
    }

    DrawShadowRegions(hdc, rcItem, lprc, x, cy, ShadowDepth, dwPercent1000, pColors);

    DrawPieDepth(hdc, rcItem, x, y, cy, dwPercent1000, ShadowDepth);

    // Redraw the bottom line of the pie because it has been painted over
    Arc(hdc, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
        rcItem.left, cy, rcItem.right, cy);

    return S_OK;    // Everything worked fine
} 


void CWebViewFolderIcon::ScalePieRect(LONG ShadowScale, LONG AspectRatio, LPRECT lprc)
{
    LONG rectHeight;
    LONG rectWidth;
    LONG TargetHeight;
    LONG TargetWidth;

    // We make sure that the aspect ratio of the pie-chart is always preserved 
    // regardless of the shape of the given rectangle

    // Stabilize the aspect ratio
    rectHeight = lprc->bottom - lprc->top;
    rectWidth = lprc->right - lprc->left;
   
    if ((rectHeight * AspectRatio) <= rectWidth)
        TargetHeight = rectHeight;
    else
        TargetHeight = rectWidth / AspectRatio;
    
    TargetWidth = TargetHeight * AspectRatio;

    // Shrink the rectangle to the correct size
    lprc->top += (rectHeight - TargetHeight) / 2;
    lprc->bottom = lprc->top + TargetHeight;
    lprc->left += (rectWidth - TargetWidth) / 2;
    lprc->right = lprc->left + TargetWidth;
}

// Calculate center of rectangle and center of pie points
void CWebViewFolderIcon::SetUpPiePts(int *pcx, int *pcy, int *prx, int *pry, RECT rect)
{
    *prx = rect.right / 2;
    *pcx = rect.left + *prx - 1;
    *pry = rect.bottom / 2;
    *pcy = rect.top + *pry - 1;
}

void CWebViewFolderIcon::DrawShadowRegions(HDC hdc, RECT rect, LPRECT lprc, int UsedArc_x, int center_y,  
                                           LONG ShadowDepth, DWORD dwPercent1000, const COLORREF *pColors) 
{
    HBRUSH  hBrush;

    HRGN hEllipticRgn = CreateEllipticRgnIndirect(&rect);
    HRGN hEllRect = CreateRectRgn(rect.left, center_y, rect.right, center_y + ShadowDepth);
    HRGN hRectRgn = CreateRectRgn(0, 0, 0, 0);

    //  Move the ellipse up so it doesn't run into the shadow
    OffsetRgn(hEllipticRgn, 0, ShadowDepth);

    // Union the Ellipse and the Ellipse rect together into hRectRegn
    CombineRgn(hRectRgn, hEllipticRgn, hEllRect, RGN_OR);
    OffsetRgn(hEllipticRgn, 0, -(int)ShadowDepth);
    CombineRgn(hEllRect, hRectRgn, hEllipticRgn, RGN_DIFF);

    // Always draw the whole area in the free shadow
    hBrush = CreateSolidBrush(pColors[COLOR_DNSHADOW]);
    if (hBrush)
    {
        FillRgn(hdc, hEllRect, hBrush);
        DeleteObject(hBrush);
    }

    // Draw a shadow for the used section only if the disk is at least half used
    hBrush = CreateSolidBrush(pColors[COLOR_UPSHADOW]);
    if ((dwPercent1000 > 500) && hBrush)
    {
        DeleteObject(hRectRgn);
        hRectRgn = CreateRectRgn(UsedArc_x, center_y, rect.right, lprc->bottom);
        CombineRgn(hEllipticRgn, hEllRect, hRectRgn, RGN_AND);
        FillRgn(hdc, hEllipticRgn, hBrush);
        DeleteObject(hBrush);
    }

    DeleteObject(hRectRgn);
    DeleteObject(hEllipticRgn);
    DeleteObject(hEllRect);
}

void CWebViewFolderIcon::CalcSlicePoint(int *x, int *y, int rx, int ry, int cx, int cy, int FirstQuadPercent1000, DWORD dwPercent1000)
{
    // Use a triangle area approximation based on the ellipse's rect to calculate the point since
    // an exact calculation of the area of the slice and percentage of the pie would be costly and
    // a hassle.

    // The approximation is better this way if FirstQuadPercent1000 is in the first half of the quadrant.  Use 120 as the
    // halfway point (instead of 125) because it looks better that way on an ellipse. 

    if (FirstQuadPercent1000 < 120)
    {
        *x = IntSqrt(((DWORD)rx*(DWORD)rx*(DWORD)FirstQuadPercent1000*(DWORD)FirstQuadPercent1000)
            /((DWORD)FirstQuadPercent1000*(DWORD)FirstQuadPercent1000+(250L-(DWORD)FirstQuadPercent1000)
            *(250L-(DWORD)FirstQuadPercent1000)));

        *y = IntSqrt(((DWORD)rx*(DWORD)rx-(DWORD)(*x)*(DWORD)(*x))*(DWORD)ry*(DWORD)ry/((DWORD)rx*(DWORD)rx));
    }
    else
    {
        *y = IntSqrt((DWORD)ry*(DWORD)ry*(250L-(DWORD)FirstQuadPercent1000)*(250L-(DWORD)FirstQuadPercent1000)
            /((DWORD)FirstQuadPercent1000*(DWORD)FirstQuadPercent1000+(250L-(DWORD)FirstQuadPercent1000)
            *(250L-(DWORD)FirstQuadPercent1000)));

        *x = IntSqrt(((DWORD)ry*(DWORD)ry-(DWORD)(*y)*(DWORD)(*y))*(DWORD)rx*(DWORD)rx/((DWORD)ry*(DWORD)ry));
    }

    // Adjust for the actual quadrant (These aren't quadrants like in the real Cartesian coordinate system.
    switch (dwPercent1000 / 250)
    {
    case 1:         // First Quadrant
        *y = -(*y); 
        break;

    case 2:         // Second Quadrant 
        break;

    case 3:         // Third Quadrant
        *x = -(*x);
        break;

    default:        // Fourth Quadrant
        *x = -(*x);
        *y = -(*y);
        break;
    }

    // Now adjust for the center.
    *x += cx;
    *y += cy;
}

void CWebViewFolderIcon::ComputeSlicePct(ULONGLONG ullMemSize, DWORD *pdwPercent1000)
{
    // some special cases require interesting treatment
    if ((ullMemSize == 0) || (m_ullFreeSpace == m_ullTotalSpace))
    {
        *pdwPercent1000 = 0;
    }
    else if (ullMemSize == 0)
    {
        *pdwPercent1000 = 1000;
    }
    else
    {
        // not completely full or empty
        *pdwPercent1000 = (DWORD)(ullMemSize * 1000 / m_ullTotalSpace);

        // if pdwPercent1000 is especially big or small and rounds incorrectly, you still want
        // to see a little slice.
        if (*pdwPercent1000 == 0)
        {
            *pdwPercent1000 = 1;
        }
        else if (*pdwPercent1000 == 1000)
        {
            *pdwPercent1000 = 999;
        }
    }
}

void CWebViewFolderIcon::DrawPieDepth(HDC hdc, RECT rect, int x, int y, int cy, DWORD dwPercent1000, LONG ShadowDepth)
{
    HPEN hPen, hOldPen;

    hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    hOldPen = (HPEN__*) SelectObject(hdc, hPen);

    Arc(hdc, rect.left, rect.top + ShadowDepth, rect.right, rect.bottom + ShadowDepth,
        rect.left, cy + ShadowDepth, rect.right, cy + ShadowDepth - 1);
    MoveToEx(hdc, rect.left, cy, NULL);
    LineTo(hdc, rect.left, cy + ShadowDepth);
    MoveToEx(hdc, rect.right - 1, cy, NULL);
    LineTo(hdc, rect.right - 1, cy + ShadowDepth);

    if ((dwPercent1000 > 500) && (dwPercent1000 < 1000))
    {
        MoveToEx(hdc, x, y, NULL);
        LineTo(hdc, x, y + ShadowDepth);
    }

    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);
}

// Draw a pie slice.  One side is always from the middle of the pie horizontally to the left.  The other
// slice is defined by x and y.
void CWebViewFolderIcon::DrawSlice(HDC hdc, RECT rect, DWORD dwPercent1000, int rx, int ry, int cx, int cy, /*int *px, int *py,*/
                                   COLORREF Color)
{
    HBRUSH  hBrush, hOldBrush;
    HPEN    hPen, hOldPen;
    int     FirstQuadPercent1000;   // slice percentage based out of 1000 in the first quadrant
    int     x, y;                   // intersection with the ellipse

    // Translate to first quadrant
    FirstQuadPercent1000 = (dwPercent1000 % 500) - 250;

    if (FirstQuadPercent1000 < 0)
    {
        FirstQuadPercent1000 = -FirstQuadPercent1000;
    }
    
    CalcSlicePoint(&x, &y, rx, ry, cx, cy, FirstQuadPercent1000, dwPercent1000);

    hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    hOldPen = (HPEN__*) SelectObject(hdc, hPen);

    if ((dwPercent1000 != 0) && (dwPercent1000 != 1000))
    {
        // display small sub-section of ellipse for smaller part
        hBrush = CreateSolidBrush(Color);
        hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

        //  Make sure it colors correctly
        if (cy == y)
        {
            if (dwPercent1000 < 500)
                y--;
            else
                y++;
        }

        Pie(hdc, rect.left, rect.top, rect.right, rect.bottom,
            x, y, rect.left, cy);
        SelectObject(hdc, hOldBrush);
        DeleteObject(hBrush);
    }

    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);
}

void CWebViewFolderIcon::DrawEllipse(HDC hdc, RECT rect, int x, int y, int cx, int cy, DWORD dwPercent1000, const COLORREF *pColors)
{
    HBRUSH  hBrush, hOldBrush;

    HPEN hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    HPEN hOldPen = (HPEN__*) SelectObject(hdc, hPen);

    // In this case the slice is miniscule
    if ((dwPercent1000 < 500) && (y == cy) && (x < cx))
    {
        hBrush = CreateSolidBrush(pColors[COLOR_UP]);
    }
    else
    {
        hBrush = CreateSolidBrush(pColors[COLOR_DN]);
    }

    hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

    Ellipse(hdc, rect.left, rect.top, rect.right, rect.bottom);

    SelectObject(hdc, hOldBrush);
    DeleteObject(hBrush);

    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\fldricon.h ===
#ifndef __FLDRICON_H_
#define __FLDRICON_H_

#include <evtsink.h>
#include <shellp.h>
#include <windef.h>
#include <webvwid.h>
#include <color.h>
#include <cnctnpt.h>

EXTERN_C const CLSID CLSID_WebViewFolderIconOld;  // retired from service

#define ID_FIRST            0               // Context Menu ID's
#define ID_LAST             0x7fff

#define MAX_SCALE_STR       10
#define MAX_VIEW_STR        50

#define LARGE_ICON_DEFAULT  32
#define THUMBVIEW_DEFAULT   120
#define PIEVIEW_DEFAULT     THUMBVIEW_DEFAULT

#define SLICE_NUM_GROW      2

#define SZ_LARGE_ICON           L"Large Icon"
#define SZ_SMALL_ICON           L"Small Icon"
#define SZ_SMALL_ICON_LABEL     L"Small Icon with Label"
#define SZ_LARGE_ICON_LABEL     L"Large Icon with Label"
#define SZ_THUMB_VIEW           L"Thumbview"
#define SZ_PIE_VIEW             L"Pie Graph"

struct PieSlice_S {
    ULONGLONG   MemSize;
    COLORREF    Color;
};

/////////////////////////////////////////////////////////////////////////////
// CWebViewFolderIcon
class ATL_NO_VTABLE CWebViewFolderIcon : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CWebViewFolderIcon, &CLSID_WebViewFolderIcon>,
    public CComControl<CWebViewFolderIcon>,
    public IDispatchImpl<IWebViewFolderIcon3, &IID_IWebViewFolderIcon3, &LIBID_WEBVWLib>,
    public IObjectSafetyImpl<CWebViewFolderIcon, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IQuickActivateImpl<CWebViewFolderIcon>,
    public IOleControlImpl<CWebViewFolderIcon>,
    public IOleObjectImpl<CWebViewFolderIcon>,
    public IOleInPlaceActiveObjectImpl<CWebViewFolderIcon>,
    public IViewObjectExImpl<CWebViewFolderIcon>,
    public IOleInPlaceObjectWindowlessImpl<CWebViewFolderIcon>,
    public IPersistPropertyBagImpl<CWebViewFolderIcon>,
    public IPointerInactiveImpl<CWebViewFolderIcon>,
    public IConnectionPointImpl<CWebViewFolderIcon, &DIID_DWebViewFolderIconEvents>,
    public IConnectionPointContainerImpl<CWebViewFolderIcon>,
    public IProvideClassInfo2Impl<&CLSID_WebViewFolderIcon,
            &DIID_DWebViewFolderIconEvents, &LIBID_WEBVWLib>
{
public:

// Drawing function
    HRESULT OnDraw(ATL_DRAWINFO& di);

DECLARE_REGISTRY_RESOURCEID(IDR_WEBVIEWFOLDERICON)

BEGIN_COM_MAP(CWebViewFolderIcon)
    COM_INTERFACE_ENTRY(IWebViewFolderIcon3)
    COM_INTERFACE_ENTRY_IID(IID_IWebViewFolderIcon, IWebViewFolderIcon3)
    COM_INTERFACE_ENTRY_IID(IID_IWebViewFolderIcon2, IWebViewFolderIcon3)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IPointerInactive)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
END_COM_MAP()

BEGIN_MSG_MAP(CWebViewFolderIcon)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_RBUTTONDOWN, OnButtonDown)
    MESSAGE_HANDLER(WM_LBUTTONDOWN, OnButtonDown)
    MESSAGE_HANDLER(WM_RBUTTONUP, OnRButtonUp)
    MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDoubleClick)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
    MESSAGE_HANDLER(WM_INITMENUPOPUP, OnInitPopup)
    MESSAGE_HANDLER(WM_MOUSELEAVE, OnMouseLeave)
    MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)    
END_MSG_MAP()

BEGIN_PROPERTY_MAP(CWebViewFolderIcon)
    PROP_ENTRY("scale",       DISPID_PROP_WVFOLDERICON_SCALE,       CLSID_WebViewFolderIcon)
    PROP_ENTRY("path",        DISPID_PROP_WVFOLDERICON_PATH,        CLSID_WebViewFolderIcon)
    PROP_ENTRY("view",        DISPID_PROP_WVFOLDERICON_VIEW,        CLSID_WebViewFolderIcon)
    PROP_ENTRY("advproperty", DISPID_PROP_WVFOLDERICON_ADVPROPERTY, CLSID_WebViewFolderIcon)
    PROP_ENTRY("clickStyle",  DISPID_PROP_WVFOLDERICON_CLICKSTYLE,  CLSID_WebViewFolderIcon)
    PROP_ENTRY("labelGap",    DISPID_PROP_WVFOLDERICON_LABELGAP,    CLSID_WebViewFolderIcon)

    // WARNING!  "item" must be last because it can fail (due to security)
    // and ATL stops loading once any property returns failure.
    PROP_ENTRY("item",        DISPID_PROP_WVFOLDERICON_ITEM,        CLSID_WebViewFolderIcon)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(CWebViewFolderIcon)
    CONNECTION_POINT_ENTRY(DIID_DWebViewFolderIconEvents)
END_CONNECTION_POINT_MAP()

    // *** IOleWindow ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd) {return IOleInPlaceActiveObjectImpl<CWebViewFolderIcon>::GetWindow(lphwnd);};
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return IOleInPlaceActiveObjectImpl<CWebViewFolderIcon>::ContextSensitiveHelp(fEnterMode); };

    // *** IOleInPlaceObject ***
    virtual STDMETHODIMP InPlaceDeactivate(void) {return IOleInPlaceObject_InPlaceDeactivate();};
    virtual STDMETHODIMP SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect) {return IOleInPlaceObject_SetObjectRects(lprcPosRect, lprcClipRect);};
    virtual STDMETHODIMP ReactivateAndUndo(void)  { return E_NOTIMPL; };
    virtual STDMETHODIMP UIDeactivate(void);

    // *** IOleInPlaceActiveObject ***
    virtual STDMETHODIMP TranslateAccelerator(LPMSG pMsg);

// IDispatch overrides
    STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr);

// IViewObjectEx overrides
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus);

// IObjectWithSite overrides
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

// IObjectSafety overrides
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, 
                                         DWORD dwEnabledOptions);

// IOleInPlaceObjectWindowless Overrides
    STDMETHOD(GetDropTarget)(IDropTarget **ppDropTarget);

// IPointerInactive Overrides
    STDMETHOD(GetActivationPolicy)(DWORD* pdwPolicy);
    STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways) {return S_FALSE;};   // Ask for default behavior.

// IOleControl overrides
    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);

// ATL overrides
    HRESULT DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent);

// Event Handlers
    STDMETHOD(OnWindowLoad)(VOID);    
    STDMETHOD(OnWindowUnLoad)(VOID);
    STDMETHOD(OnImageChanged)(VOID);

//  Advanced Properties - Context Menu, Default Open, Drag and Drop
    LRESULT OnRButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnLButtonDoubleClick(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnInitPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    
    // *** IWebViewFolder ***
    STDMETHOD(get_scale)(BSTR *pbstrScale); 
    STDMETHOD(put_scale)(BSTR bstrScale);   

    STDMETHOD(get_path)(BSTR *pbstrPath); 
    STDMETHOD(put_path)(BSTR bstrPath);   

    STDMETHOD(get_view)(BSTR *pView); 
    STDMETHOD(put_view)(BSTR view);

    STDMETHOD(get_advproperty)(VARIANT_BOOL *pvarbAdvProp); 
    STDMETHOD(put_advproperty)(VARIANT_BOOL varbAdvProp);

    // *** IWebViewFolderIcon2 ***
    STDMETHOD(setSlice)(INT index, VARIANT varHiBytes, VARIANT varLoBytes, VARIANT varColorref);

    // *** IWebViewFolderIcon3 ***
    STDMETHOD(get_item)(FolderItem ** ppFolderItem);
    STDMETHOD(put_item)(FolderItem * pFolderItem);
    STDMETHOD(get_clickStyle)(/* retval, out */ LONG *plClickStyle);
    STDMETHOD(put_clickStyle)(/* in */ LONG lClickStyle);
    STDMETHOD(get_labelGap)(/* retval, out */ LONG *plLabelGap);
    STDMETHOD(put_labelGap)(/* in */ LONG lLabelGap);

public:
    CWebViewFolderIcon(void);
    ~CWebViewFolderIcon(void);
           
private:
    // Private helpers

    HRESULT     InitImage(void);
    HRESULT     InitIcon(void);
    HRESULT     InitThumbnail(void);
    HRESULT     InitPieGraph(void);
    HRESULT     SetupIThumbnail(void);

    HRESULT     _InvokeOnThumbnailReady();
    
    HRESULT     UpdateSize(void);
    HRESULT     ForceRedraw(void);

    HRESULT     _GetFullPidl(LPITEMIDLIST *ppidl);
    HRESULT     _GetPathW(LPWSTR psz);
    HRESULT     _GetPidlAndShellFolder(LPITEMIDLIST *ppidlLast, IShellFolder** ppsfParent);
    HRESULT     _GetHwnd(HWND* phwnd);
    HRESULT     _GetCenterPoint(POINT *pt);
    HRESULT     _GetChildUIObjectOf(REFIID riid, void ** ppvObj);

    BOOL        _WebViewOpen(void);
    HRESULT     _ZoneCheck(DWORD dwFlags);
    BOOL        IsSafeToDefaultVerb(void);
    void        _FlipFocusRect(BOOL RectState);
    ULONGLONG   GetUllMemFromVars(VARIANT *pvarHi, VARIANT *pvarLo);
    int         GetPercentFromStrW(LPCWSTR pwzPercent);
    HRESULT     DragDrop(int iClickXPos, int iClickYPos);
    HRESULT     _DisplayContextMenu(long nXCord, long nYCord);
    HRESULT     _DoContextMenuCmd(BOOL bDefault, long nXCord, long nYCord);
    BOOL        _IsHostWebView(void);
    BOOL        _IsPubWizHosted(void);

    HRESULT     _SetDragImage(int iClickXPos, int iClickYPos, IDataObject * pdtobj);

    //  3dPie functions
    HRESULT     Draw3dPie(HDC hdc, LPRECT lprc, DWORD dwPercent1000, const COLORREF *lpColors);
    HRESULT     ComputeFreeSpace(LPCWSTR pszFileName);
    void        ScalePieRect(LONG ShadowScale, LONG AspectRatio, LPRECT lprc);
    void        ComputeSlicePct(ULONGLONG ullMemSize, DWORD *pdwPercent1000);
    void        CalcSlicePoint(int *x, int *y, int rx, int ry, int cx, int cy, int FirstQuadPercent1000, DWORD dwPercent1000);
    void        SetUpPiePts(int *pcx, int *pcy, int *prx, int *pry, RECT rect);
    void        DrawPieDepth(HDC hdc, RECT rect, int x, int y, int cy, DWORD dwPercent1000, LONG ShadowDepth);
    void        DrawSlice(HDC hdc, RECT rect, DWORD dwPercent1000, int rx, int ry, int cx, int cy, /*int *px, int *py,*/
                          COLORREF Color);
    void        DrawEllipse(HDC hdc, RECT rect, int x, int y, int cx, int cy, DWORD dwPercent1000, const COLORREF *lpColors);
    void        DrawShadowRegions(HDC hdc, RECT rect, LPRECT lprc, int UsedArc_x, int center_y, LONG ShadowDepth, 
                                  DWORD dwPercent1000, COLORREF const *lpColors); 
    HRESULT     _GetPieChartIntoBitmap();

    HRESULT     _SetupWindow(void);
    HRESULT     _MakeRoomForLabel();

    // Window Procedure for catching and storing bitmap
    static LRESULT CALLBACK WndProc(HWND, UINT uMsg, WPARAM, LPARAM);

    // Managing the bitmap/icon

    LONG        _GetScaledImageWidth(void) { return (m_lImageWidth * m_percentScale)/100; }
    LONG        _GetScaledImageHeight(void) { return (m_lImageHeight * m_percentScale)/100; }

    // Managing the label
    void        _ClearLabel(void);
    void        _GetLabel(IShellFolder *psf, LPCITEMIDLIST pidlItem);

    LONG        _GetControlWidth(void)
                { return _GetScaledImageWidth() +
                          (m_sizLabel.cx ? m_cxLabelGap + m_sizLabel.cx : 0); }
    LONG        _GetControlHeight(void) { return max(_GetScaledImageHeight(), m_sizLabel.cy); }

    void        _GetAmbientFont(void);
    void        _ClearAmbientFont(void);

private:

    // Private message handlers
    HWND                m_msgHwnd;
    WNDCLASS            m_msgWc;
    BOOL                m_bRegWndClass;
    IContextMenu3 *     m_pcm3;             // For Context Menu events
    IDropTarget *       m_pDropTargetCache; // Cache the IDropTarget because MSHTML should but doesn't.
    IDispatch *         m_pdispWindow;      // Cache the HTML window object that we receive events from
    
    // Image information
    HICON                m_hIcon;   
    INT                  m_iIconIndex;

    // Size information
    INT                  m_percentScale;    // image scaling
    UINT                 m_lImageWidth;     // unscaled size of bitmap/icon
    UINT                 m_lImageHeight;
    LONG                 m_cxLabelGap;

    SIZE                 m_sizLabel;        // size of label

    IThumbnail2         *m_pthumb;
    HBITMAP              m_hbm;
    BOOL                 m_fTabRecieved;
    BOOL                 m_fIsHostWebView;  // Are we hosted in WebView?

    HDC                  m_hdc;             // Saved for _SetDragImage()
    RECT                 m_rect;            // Rectangle into which we draw
    BOOL                 m_fRectAdjusted;   // Flag says if we need to modify
                                            // rect for drag image.
    BOOL                 m_fLoaded;                                            
    HBITMAP              m_hbmDrag;
    // Piechart
    enum
    {
        PIE_USEDCOLOR = 0,
        PIE_FREECOLOR,
        PIE_USEDSHADOW,
        PIE_FREESHADOW,
        PIE_NUM     // keep track of number of PIE_ values
    };

    enum
    {
        COLOR_UP = 0,
        COLOR_DN,
        COLOR_UPSHADOW,
        COLOR_DNSHADOW,
        COLOR_NUM       // #of entries
    };

    enum VIEWS
    {
        VIEW_SMALLICON = 0,
        VIEW_LARGEICON,
        VIEW_THUMBVIEW,
        VIEW_PIECHART,

        // Extra flags for views
        VIEW_WITHLABEL = 0x00010000,

        VIEW_SMALLICONLABEL = VIEW_SMALLICON | VIEW_WITHLABEL,
        VIEW_LARGEICONLABEL = VIEW_LARGEICON | VIEW_WITHLABEL,
    };

    // Putzing with the view
    inline static UINT _ViewType(VIEWS vw) { return LOWORD(vw); }

    COLORREF             m_ChartColors[PIE_NUM];
    ULONGLONG            m_ullFreeSpace;
    ULONGLONG            m_ullUsedSpace;
    ULONGLONG            m_ullTotalSpace;

    BOOL                 m_fUseSystemColors;
    HDSA                 m_hdsaSlices;              // added slices to the Used area
    int                  m_highestIndexSlice;        

    // Advise Cookie
    DWORD                m_dwHtmlWindowAdviseCookie;
    DWORD                m_dwCookieDV;
    CIE4ConnectionPoint  *m_pccpDV;

    // path property
    LPITEMIDLIST        m_pidl;

    // view property
    VIEWS               m_ViewUser;         // What user wants.
    VIEWS               m_ViewCurrent;      // What user gets.

    // clickStyle property
    LONG                m_clickStyle;       // 1 = oneclick, 2 = twoclick

    // Activation rectangle flag
    BOOL                m_bHasRect;

    // Advanced properties setting
    // When it is turned off, Context Menu, Drag and Drop, fucus rectangle, and security checking support 
    // (anything to do with mouse clicking or tabbing) is turned off.
    BOOL                m_bAdvPropsOn;

    // Should we also show the display name of the target?
    LPTSTR              m_pszDisplayName;

    // What font should we show the display name in?
    HFONT               m_hfAmbient;
    IFont *             m_pfont;            // Who owns the font?
                                            // (if NULL, then we do)

    // Show hilite effects- underline text, dropshadow for icon etc..
    BOOL                m_bHilite;
    
    DWORD               m_dwThumbnailID;    // ID to identify which bitmap we received
};  

#endif //__WVFOLDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by webvw.rc
//

#define IDR_THUMBCTL                    101
#define IDR_WEBVIEWCOORD                102
#define IDR_WEBVIEWFOLDERICON           103

#define IDS_INTRO                       5001
#define IDS_PROMPT                      5001
#define IDS_MULTIPLE                    5002
#define IDS_SIZE                        5003
#define IDS_FILESIZE                    5004
#define IDS_DELIMITER                   5005
#define IDS_CODES                       5008
#define IDS_READONLY                    5009
#define IDS_HIDDEN                      5010
#define IDS_SYSTEM                      5011
#define IDS_ARCHIVE                     5012
#define IDS_COMPRESSED                  5013
#define IDS_ENCRYPTED                   5014
#define IDS_NOATTRIBUTES                5015
#define IDS_EMPTY                       5016
#define IDS_PROPERTIES                  5017
#define IDS_TODAY                       5018
#define IDS_YESTERDAY                   5019
#define IDS_PREVIEW                     5020
#define IDS_TOTALSIZE                   5021
#define IDS_USEDSPACE                   5022
#define IDS_FREESPACE                   5023
#define IDS_COMMENTS                    5028
#define IDS_SEEALSO                     5029
#define IDS_MYDOCSTEXT                  5031
#define IDS_MYCOMPTEXT                  5033
#define IDS_MYNETPLACESTEXT             5035
#define IDS_INFOTIP_COL                 5037
#define IDS_NAME_COL                    5038
#define IDS_SIZE_COL                    5039
#define IDS_TYPE_COL                    5040
#define IDS_MODIFIED_COL                5041
#define IDS_ATTRIBUTES_COL              5042
#define IDS_AUTHOR_COL                  5043
#define IDS_TITLE_COL                   5044
#define IDS_PAGES_COL                   5045
#define IDS_COMMENT_COL                 5046
#define IDS_CSC_SYNCHRONIZE             5047
#define IDS_CSC_ONLINE                  5048
#define IDS_CSC_OFFLINE                 5049
#define IDS_CSC_SERVERAVAILABLE         5050
#define IDS_CSC_DIRTYCACHE              5051
#define IDS_CSC_DETAIL_ONLINE           5052
#define IDS_CSC_DETAIL_OFFLINE          5053
#define IDS_CSC_DETAIL_SERVERAVAILABLE  5054
#define IDS_CSC_DETAIL_DIRTYCACHE       5055
#define IDS_NDC                         5056
#define IDS_NDCTEXT                     5057
#define IDS_USEDSPACE_DESC              5058
#define IDS_FREESPACE_DESC              5059
#define IDS_THUMBNAIL_LABEL             5060
#define IDS_PHRASESEPERATOR             5061
#define IDS_WALLPAPER_LOCNAME           5062
#define IDS_WALLPAPER_LOCNAME_PER       5063

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\install.cpp ===
#include "priv.h"


HRESULT RegisterActiveDesktopTemplates()
{
    HRESULT hr = E_FAIL;
    TCHAR szPath[MAX_PATH];

    if (GetWindowsDirectory(szPath, ARRAYSIZE(szPath)) &&
        PathAppend(szPath, TEXT("web")))
    {
        // we still register safemode.htt and deskmovr.htt for Active Desktop.

        if (PathAppend(szPath, TEXT("safemode.htt")))
        {
            hr = SHRegisterValidateTemplate(szPath, SHRVT_REGISTER);
        }
        else
        {
            hr = ResultFromLastError();
        }

        if (SUCCEEDED(hr))
        {
            if (PathRemoveFileSpec(szPath) && PathAppend(szPath, TEXT("deskmovr.htt")))
            {
                hr = SHRegisterValidateTemplate(szPath, SHRVT_REGISTER);
            }
            else
            {
                hr = ResultFromLastError();
            }
        }
    }

    return hr;
}


HRESULT FixMyDocsDesktopIni()
{
    HRESULT hr = E_FAIL;
    TCHAR szMyDocsIni[MAX_PATH];

    if ((SHGetFolderPath(NULL, CSIDL_MYPICTURES, NULL, SHGFP_TYPE_CURRENT, szMyDocsIni) == S_OK) &&
        PathAppend(szMyDocsIni, TEXT("desktop.ini")))
    {
        // The default PersistMoniker is automatically determined by the shell.
        // So, lets clear the old settings.
        WritePrivateProfileString(TEXT("{5984FFE0-28D4-11CF-AE66-08002B2E1262}"),
                                  TEXT("WebViewTemplate.NT5"),
                                  NULL,
                                  szMyDocsIni);
        WritePrivateProfileString(TEXT("{5984FFE0-28D4-11CF-AE66-08002B2E1262}"),
                                  TEXT("PersistMoniker"),
                                  NULL,
                                  szMyDocsIni);
        WritePrivateProfileString(TEXT("ExtShellFolderViews"),
                                  TEXT("Default"),
                                  NULL,
                                  szMyDocsIni);
        hr = S_OK;
    }

    return hr;
}


HRESULT SetFileAndFolderAttribs(HINSTANCE hInstResource)
{
    TCHAR szWinPath[MAX_PATH];
    TCHAR szDestPath[MAX_PATH];
    int i;

    const LPCTSTR rgSuperHiddenFiles[] = 
    { 
        TEXT("winnt.bmp"),
        TEXT("winnt256.bmp"),
        TEXT("lanmannt.bmp"),
        TEXT("lanma256.bmp"),
        TEXT("Web"),
        TEXT("Web\\Wallpaper")
    };

    GetWindowsDirectory(szWinPath, ARRAYSIZE(szWinPath));

    // Change the attributes on "Winnt.bmp", "Winnt256.bmp", "lanmannt.bmp", "lanma256.bmp"
    // to super hidden sothat they do not showup in the wallpaper list.
    for (i = 0; i < ARRAYSIZE(rgSuperHiddenFiles); i++)
    {
        lstrcpyn(szDestPath, szWinPath, ARRAYSIZE(szDestPath));
        PathAppend(szDestPath, rgSuperHiddenFiles[i]);
        if (PathIsDirectory(szDestPath))
        {
            PathMakeSystemFolder(szDestPath);
        }
        else
        {
            SetFileAttributes(szDestPath, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
        }
    }

    const int rgSysetemFolders[]  =
    {
       CSIDL_PROGRAM_FILES,
#ifdef _WIN64
       CSIDL_PROGRAM_FILESX86
#endif
    };

    // make the "Program Files" and "Program Files (x86)" system folders
    for (i = 0; i < ARRAYSIZE(rgSysetemFolders); i++)
    {
        if (SHGetFolderPath(NULL, rgSysetemFolders[i], NULL, 0, szDestPath) == S_OK)
        {
            PathMakeSystemFolder(szDestPath);
        }
    }
    
    // Fix up desktop.ini for My Pictures until we completely stop reading from it
    FixMyDocsDesktopIni();

    // register the last two .htt files that Active Desktop still uses
    RegisterActiveDesktopTemplates();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\stdafx.h ===
// stdafx.h : (ATL) include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CB5C1617_EC46_11D0_A1E0_00A0C9034800__INCLUDED_)
#define AFX_STDAFX_H__CB5C1617_EC46_11D0_A1E0_00A0C9034800__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CB5C1617_EC46_11D0_A1E0_00A0C9034800__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\stdafx.cpp ===
// stdafx.cpp : (ATL) source file that includes just the standard includes
#include "priv.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\thumbctl.cpp ===
// ThumbCtl.cpp : Implementation of CThumbCtl
#include "priv.h"
#include "shdguid.h"

const CLSID CLSID_ThumbCtlOld = {0x1d2b4f40,0x1f10,0x11d1,{0x9e,0x88,0x00,0xc0,0x4f,0xdc,0xab,0x92}};  // retired from service, so made private

// global
// for LoadLibrary/GetProcAddress on SHGetDiskFreeSpaceA
typedef BOOL (__stdcall * PFNSHGETDISKFREESPACE)(LPCTSTR pszVolume, ULARGE_INTEGER *pqwFreeCaller, ULARGE_INTEGER *pqwTot, ULARGE_INTEGER *pqwFree);

const TCHAR * const g_szWindowClassName = TEXT("MSIE4.0 Webvw.DLL ThumbCtl");
STDAPI IsSafePage(IUnknown *punkSite)
{
    // Return S_FALSE if we don't have a host site since we have no way of doing a 
    // security check.  This is as far as VB 5.0 apps get.
    if (!punkSite)
        return S_FALSE;

    HRESULT hr = E_ACCESSDENIED;
    WCHAR wszPath[MAX_PATH];
    wszPath[0] = 0;

    // ask the browser, for example we are in a .HTM doc
    IBrowserService* pbs;
    if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_SShellBrowser, 
        IID_PPV_ARG(IBrowserService, &pbs))))
    {
        LPITEMIDLIST pidl;

        if (SUCCEEDED(pbs->GetPidl(&pidl)))
        {
            DWORD dwAttribs = SFGAO_FOLDER;
            if (SUCCEEDED(SHGetNameAndFlagsW(pidl, SHGDN_FORPARSING, wszPath, 
                ARRAYSIZE(wszPath), &dwAttribs))
                    && (dwAttribs & SFGAO_FOLDER))   // This is a folder. So, wszPath should be the path for it's webview template
            {
                // find the template path from webview, for example a .HTT file
                IOleCommandTarget *pct;
                if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_DefView, 
                    IID_PPV_ARG(IOleCommandTarget, &pct))))
                {
                    VARIANT vPath;
                    vPath.vt = VT_EMPTY;
                    if (pct->Exec(&CGID_DefView, DVCMDID_GETTEMPLATEDIRNAME, 0
                        , NULL, &vPath) == S_OK)
                    {
                        if (vPath.vt == VT_BSTR && vPath.bstrVal)
                        {
                            DWORD cchPath = ARRAYSIZE(wszPath);
                            if (S_OK != PathCreateFromUrlW(vPath.bstrVal, 
                                                          wszPath, &cchPath, 0))
                            {
                                // it might not be an URL, in this case it is a file path
                                StrCpyNW(wszPath, vPath.bstrVal, ARRAYSIZE(wszPath));
                            }
                        }
                        VariantClear(&vPath);
                    }
                    pct->Release();
                }
            }
            ILFree(pidl);
        }
        pbs->Release();
    }
    else
    {
        ASSERT(0);      // no browser, where are we?
    }

    if (wszPath[0])
        hr = SHRegisterValidateTemplate(wszPath, SHRVT_VALIDATE | SHRVT_PROMPTUSER | SHRVT_REGISTERIFPROMPTOK);

    return hr;
}

// === INTERFACE ===
// *** IThumbCtl ***
STDMETHODIMP CThumbCtl::displayFile(BSTR bsFileName, VARIANT_BOOL *pfSuccess)
{
    ASSERT(pfSuccess != NULL);
    HRESULT hr = E_FAIL;
    *pfSuccess = VARIANT_FALSE;
    if ((S_OK != LocalZoneCheck(m_spClientSite)) &&  (S_OK != IsSafePage(m_spClientSite)))
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.

        // due to rajeshg's request we return S_FALSE
        // this is because webvw has a customization feature letting people choose 
        // a intranet htt file as their folder.htt, but for security we generally need
        // to block random intranet web pages from calling this method. This will break
        // a case where the customization is done on a NT machine, but the user tries to 
        // view it using Millennium, it will not show any image and pop up error messages 
        // if we return E_ACCESSDENIED.
        hr = S_FALSE;

    }
    else
    {
        // Cancel pending bitmap request if in thumbnail mode && have a functioning IThumbnail
        // && haven't yet received our bitmap
        if(!m_fRootDrive && m_fHaveIThumbnail && m_hbm == NULL)
        {
            m_pthumb->GetBitmap(NULL, 0, 0, 0);
        }

        // change ID to catch late bitmap computed
        ++m_dwThumbnailID;

        // if already displaying something, refresh
        if(m_fRootDrive || m_hbm)
        {
            if(m_hbm)
            {
                DeleteObject(m_hbm);
                m_hbm = NULL;
            }
            FireViewChange();
        }

        // Now work on new thumbnail
        m_fRootDrive = FALSE;

        // check for non-empty file name
        if(bsFileName && bsFileName[0])
        {
            TCHAR szFileName[INTERNET_MAX_URL_LENGTH];
            SHUnicodeToTChar(bsFileName, szFileName, ARRAYSIZE(szFileName));

            DWORD dwAttrs = GetFileAttributes(szFileName);
            // Pie Chart
            if(PathIsRoot(szFileName))
            {
                if(SUCCEEDED(ComputeFreeSpace(szFileName)))
                {
                    m_fRootDrive = TRUE;
                    *pfSuccess = VARIANT_TRUE;
                }
            }
            // Thumbnail
            else if(!(dwAttrs & FILE_ATTRIBUTE_DIRECTORY) && !PathIsSlow(szFileName, dwAttrs))     // should really be calling this from Shell32 private functions
            {
                if(!m_fInitThumb)
                {
                    m_fHaveIThumbnail = SUCCEEDED(SetupIThumbnail());
                    m_fInitThumb = TRUE;
                }
                if(m_fHaveIThumbnail)
                {
                    SIZE size;
                    AtlHiMetricToPixel(&m_sizeExtent, &size);
                    if(EVAL(size.cx > 0 && size.cy > 0))
                    {
                        if(SUCCEEDED(m_pthumb->GetBitmap(bsFileName, m_dwThumbnailID, size.cx, size.cy)))
                        {
                            *pfSuccess = VARIANT_TRUE;
                        }
                    }
                }
            }
        }

        hr = S_OK;
    }
    return hr;
}       // displayFile

STDMETHODIMP CThumbCtl::haveThumbnail(VARIANT_BOOL *pfRes)
{
    HRESULT hr;
    *pfRes = VARIANT_FALSE;
    if ((S_OK != LocalZoneCheck(m_spClientSite)) &&  (S_OK != IsSafePage(m_spClientSite)))
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.

        // due to rajeshg's request we return S_FALSE
        // this is because webvw has a customization feature letting people choose 
        // a intranet htt file as their folder.htt, but for security we generally need
        // to block random intranet web pages from calling this method. This will break
        // a case where the customization is done on a NT machine, but the user tries to 
        // view it using Millennium, it will not show any image and pop up error messages 
        // if we return E_ACCESSDENIED.
        hr = S_FALSE;

    }
    else
    {
        *pfRes = (m_fRootDrive || m_hbm) ? VARIANT_TRUE : VARIANT_FALSE;
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CThumbCtl::get_freeSpace(BSTR *pbs)
{
    HRESULT hr;
    if ((S_OK != LocalZoneCheck(m_spClientSite)) &&  (S_OK != IsSafePage(m_spClientSite)))
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        *pbs = SysAllocString(L"");
        hr = S_FALSE;
    }
    else
    {
        get_GeneralSpace(m_dwlFreeSpace, pbs);
        hr = S_OK;
    }
    return hr;
}       // get_freeSpace


STDMETHODIMP CThumbCtl::get_usedSpace(BSTR *pbs)
{
    HRESULT hr;
    if ((S_OK != LocalZoneCheck(m_spClientSite)) &&  (S_OK != IsSafePage(m_spClientSite)))
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        *pbs = SysAllocString(L"");
        hr = S_FALSE;
    }
    else
    {
        get_GeneralSpace(m_dwlUsedSpace, pbs);
        hr = S_OK;
    }
    return hr;
}       // get_usedSpace

STDMETHODIMP CThumbCtl::get_totalSpace(BSTR *pbs)
{
    HRESULT hr;
    if ((S_OK != LocalZoneCheck(m_spClientSite)) &&  (S_OK != IsSafePage(m_spClientSite)))
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        *pbs = SysAllocString(L"");
        hr = S_FALSE;
    }
    else
    {    
        get_GeneralSpace(m_dwlTotalSpace, pbs);
        hr = S_OK;
    }
    return hr;
}       // get_totalSpace

// *** IObjectSafety ***
STDMETHODIMP CThumbCtl::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions,
                                                  DWORD *pdwEnabledOptions)
{
    ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
        return E_POINTER;
    HRESULT hr = S_OK;
    if (riid == IID_IDispatch)
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER & INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = m_dwCurrentSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER & INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }
    else
    {
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;
        hr = E_NOINTERFACE;
    }
    return hr;
}

// *** ISupportsErrorInfo ***
STDMETHODIMP CThumbCtl::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IThumbCtl,
    };
    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

// *** IViewObjectEx ***
STDMETHODIMP CThumbCtl::GetViewStatus(DWORD* pdwStatus)
{
    ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
    *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
    return S_OK;
}

// *** IOleInPlaceActiveObject ***
HRESULT CThumbCtl::TranslateAccelerator(LPMSG pMsg)
{
    HRESULT hres = S_OK;
    if (!m_fTabRecieved)
    {
        hres = IOleInPlaceActiveObjectImpl<CThumbCtl>::TranslateAccelerator(pMsg);

        // If we did not handle this and if it is a tab (and we are not getting it in a cycle), forward it to trident, if present.
        if (hres != S_OK && pMsg && (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6) && m_spClientSite)
        {
            if (GetFocus() != m_hwnd)
            {
               ::SetFocus(m_hwnd);
                hres = S_OK;
            }
            else
            {
                IOleControlSite* pocs = NULL;
                if (SUCCEEDED(m_spClientSite->QueryInterface(IID_IOleControlSite, (void **)&pocs)))
                {
                    DWORD grfModifiers = 0;
                    if (GetKeyState(VK_SHIFT) & 0x8000)
                    {
                        grfModifiers |= 0x1;    //KEYMOD_SHIFT
                    }
                    if (GetKeyState(VK_CONTROL) & 0x8000)
                    {
                        grfModifiers |= 0x2;    //KEYMOD_CONTROL;
                    }
                    if (GetKeyState(VK_MENU) & 0x8000)
                    {
                        grfModifiers |= 0x4;    //KEYMOD_ALT;
                    }
                    m_fTabRecieved = TRUE;
                    hres = pocs->TranslateAccelerator(pMsg, grfModifiers);
                    m_fTabRecieved = FALSE;
                }
            }
        }
    }
    return hres;
}

// === PUBLIC FUNCTIONS ===
// CONSTRUCTOR/DESTRUCTOR
CThumbCtl::CThumbCtl(void):
    m_fRootDrive(FALSE),
    m_fInitThumb(FALSE),
    m_fHaveIThumbnail(FALSE),
    m_pthumb(NULL),
    m_hwnd(NULL),
    m_hbm(NULL),
    m_dwThumbnailID(0),
    m_dwlFreeSpace(0),
    m_dwlUsedSpace(0),
    m_dwlTotalSpace(0),
    m_dwUsedSpacePer1000(0),
    m_fUseSystemColors(TRUE)
{
    m_fTabRecieved = FALSE;
}

CThumbCtl::~CThumbCtl(void)
{
    if(m_hbm)
    {
        DeleteObject(m_hbm);
        m_hbm = NULL;
    }
    if(m_pthumb)
    {
        m_pthumb->Release();        // will cancel pending bitmap requests
        m_pthumb = NULL;
    }
    if(m_hwnd)
    {
        EVAL(::DestroyWindow(m_hwnd));
        m_hwnd = NULL;
    }
}

// === PRIVATE FUNCTIONS ===
// Thumbnail drawing functions
HRESULT CThumbCtl::SetupIThumbnail(void)
{
    HRESULT hr = E_FAIL;

    // Create Window Class
    WNDCLASS wc;
    if (!::GetClassInfoWrap(_Module.GetModuleInstance(), g_szWindowClassName, &wc))
    {
        wc.style = 0;
        wc.lpfnWndProc = CThumbCtl::WndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = _Module.GetModuleInstance();
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = NULL;
        wc.lpszMenuName = NULL;
        wc.lpszClassName = g_szWindowClassName;

        RegisterClass(&wc);
    }

    m_hwnd = CreateWindow(g_szWindowClassName, NULL, WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, _Module.GetModuleInstance(), this);
    if(m_hwnd)
    {
        if(SUCCEEDED(CoCreateInstance(CLSID_Thumbnail, NULL, CLSCTX_INPROC_SERVER, IID_IThumbnail, (void **)&m_pthumb)))
        {
            if(SUCCEEDED(m_pthumb->Init(m_hwnd, WM_HTML_BITMAP)))
            {
                hr = S_OK;
            }
        }
        if(FAILED(hr))
        {
            EVAL(::DestroyWindow(m_hwnd));
            m_hwnd = NULL;
        }
    }
    return hr;
}

LRESULT CALLBACK CThumbCtl::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CThumbCtl *ptc = (CThumbCtl *)::GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_CREATE:
        {
            ptc = (CThumbCtl *)((CREATESTRUCT *)lParam)->lpCreateParams;
            ::SetWindowLongPtr(hWnd, GWLP_USERDATA, (LPARAM)ptc);
        }
        break;

    case WM_HTML_BITMAP:
        // check that ptc is still alive, bitmap is current using ID
        if(ptc && ptc->m_dwThumbnailID == wParam)
        {
            // ptc->displayFile() should've destroyed old bitmap already, but doesn't hurt to check.
            if(!EVAL(ptc->m_hbm == NULL))
            {
                DeleteObject(ptc->m_hbm);
            }
            ptc->m_hbm = (HBITMAP)lParam;
            ptc->InvokeOnThumbnailReady();
        }
        else if(lParam)
        {
            DeleteObject((HBITMAP)lParam);
        }
        break;

    case WM_DESTROY:
        // ignore late messages
        if(ptc)
        {
            MSG msg;

            while(PeekMessage(&msg, hWnd, WM_HTML_BITMAP, WM_HTML_BITMAP, PM_REMOVE))
            {
                if(msg.lParam)
                {
                    DeleteObject((HBITMAP)msg.lParam);
                }
            }
            ::SetWindowLongPtr(hWnd, GWLP_USERDATA, NULL);
        }
        break;

    default:
        return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}

// Pie Chart functions
HRESULT CThumbCtl::ComputeFreeSpace(LPTSTR pszFileName)
{
    ULARGE_INTEGER qwFreeCaller;        // use this for free space -- this will take into account disk quotas and such on NT
    ULARGE_INTEGER qwTotal;
    ULARGE_INTEGER qwFree;      // unused
    static PFNSHGETDISKFREESPACE pfnSHGetDiskFreeSpace = NULL;

    if (NULL == pfnSHGetDiskFreeSpace)
    {
        HINSTANCE hinstShell32 = LoadLibrary(TEXT("SHELL32.DLL"));

        if (hinstShell32)
        {
#ifdef UNICODE
            pfnSHGetDiskFreeSpace = (PFNSHGETDISKFREESPACE)GetProcAddress(hinstShell32, "SHGetDiskFreeSpaceExW");
#else
            pfnSHGetDiskFreeSpace = (PFNSHGETDISKFREESPACE)GetProcAddress(hinstShell32, "SHGetDiskFreeSpaceExA");
#endif
        }
    }

    // Compute free & total space and check for valid results
    // if have a fn pointer call SHGetDiskFreeSpaceA
    if( pfnSHGetDiskFreeSpace
        && pfnSHGetDiskFreeSpace(pszFileName, &qwFreeCaller, &qwTotal, &qwFree) )
    {
        m_dwlFreeSpace = qwFreeCaller.QuadPart;
        m_dwlTotalSpace = qwTotal.QuadPart;
        m_dwlUsedSpace = m_dwlTotalSpace - m_dwlFreeSpace;

        if ((m_dwlTotalSpace > 0) && (m_dwlFreeSpace <= m_dwlTotalSpace))
        {
            // some special cases require interesting treatment
            if(m_dwlTotalSpace == 0 || m_dwlFreeSpace == m_dwlTotalSpace)
            {
                m_dwUsedSpacePer1000 = 0;
            }
            else if(m_dwlFreeSpace == 0)
            {
                m_dwUsedSpacePer1000 = 1000;
            }
            else
            {
                // not completely full or empty
                m_dwUsedSpacePer1000 = (DWORD)(m_dwlUsedSpace * 1000 / m_dwlTotalSpace);

                // Trick: if user has extremely little free space, the user expects to still see
                // a tiny free slice -- not a full drive.  Similarly for almost free drive.
                if(m_dwUsedSpacePer1000 == 0)
                {
                    m_dwUsedSpacePer1000 = 1;
                }
                else if(m_dwUsedSpacePer1000 == 1000)
                {
                    m_dwUsedSpacePer1000 = 999;
                }
            }
            return S_OK;
        }
    }
    return E_FAIL;
}

// 32 should be plenty
#define STRLENGTH_SPACE 32

HRESULT CThumbCtl::get_GeneralSpace(DWORDLONG dwlSpace, BSTR *pbs)
{
    ASSERT(pbs != NULL);

    WCHAR wszText[STRLENGTH_SPACE];

    if(m_fRootDrive)
    {
        StrFormatByteSizeW(dwlSpace, wszText, ARRAYSIZE(wszText));
        *pbs = SysAllocString(wszText);
    }
    else
    {
        *pbs = SysAllocString(L"");
    }

    return *pbs? S_OK: E_OUTOFMEMORY;
}

HRESULT CThumbCtl::Draw3dPie(HDC hdc, LPRECT lprc, DWORD dwPer1000, const COLORREF *lpColors)
{
    ASSERT(lprc != NULL && lpColors != NULL);

    enum
    {
        COLOR_UP = 0,
        COLOR_DN,
        COLOR_UPSHADOW,
        COLOR_DNSHADOW,
        COLOR_NUM       // #of entries
    };

    // The majority of this code came from "drawpie.c"
    const LONG c_lShadowScale = 6;       // ratio of shadow depth to height
    const LONG c_lAspectRatio = 2;      // ratio of width : height of ellipse

    // We make sure that the aspect ratio of the pie-chart is always preserved 
    // regardless of the shape of the given rectangle
    // Stabilize the aspect ratio now...
    LONG lHeight = lprc->bottom - lprc->top;
    LONG lWidth = lprc->right - lprc->left;
    LONG lTargetHeight = (lHeight * c_lAspectRatio <= lWidth? lHeight: lWidth / c_lAspectRatio);
    LONG lTargetWidth = lTargetHeight * c_lAspectRatio;     // need to adjust because w/c * c isn't always == w

    // Shrink the rectangle on both sides to the correct size
    lprc->top += (lHeight - lTargetHeight) / 2;
    lprc->bottom = lprc->top + lTargetHeight;
    lprc->left += (lWidth - lTargetWidth) / 2;
    lprc->right = lprc->left + lTargetWidth;

    // Compute a shadow depth based on height of the image
    LONG lShadowDepth = lTargetHeight / c_lShadowScale;

    // check dwPer1000 to ensure within bounds
    if(dwPer1000 > 1000)
        dwPer1000 = 1000;

    // Now the drawing function
    int cx, cy, rx, ry, x, y;
    int uQPctX10;
    RECT rcItem;
    HRGN hEllRect, hEllipticRgn, hRectRgn;
    HBRUSH hBrush, hOldBrush;
    HPEN hPen, hOldPen;

    rcItem = *lprc;
    rcItem.left = lprc->left;
    rcItem.top = lprc->top;
    rcItem.right = lprc->right - rcItem.left;
    rcItem.bottom = lprc->bottom - rcItem.top - lShadowDepth;

    rx = rcItem.right / 2;
    cx = rcItem.left + rx - 1;
    ry = rcItem.bottom / 2;
    cy = rcItem.top + ry - 1;
    if (rx<=10 || ry<=10)
    {
        return S_FALSE;
    }

    rcItem.right = rcItem.left+2*rx;
    rcItem.bottom = rcItem.top+2*ry;

    /* Translate to first quadrant of a Cartesian system
    */
    uQPctX10 = (dwPer1000 % 500) - 250;
    if (uQPctX10 < 0)
    {
        uQPctX10 = -uQPctX10;
    }

    /* Calc x and y.  I am trying to make the area be the right percentage.
    ** I don't know how to calculate the area of a pie slice exactly, so I
    ** approximate it by using the triangle area instead.
    */

    // NOTE-- *** in response to the above comment ***
    // Calculating the area of a pie slice exactly is actually very
    // easy by conceptually rescaling into a circle but the complications
    // introduced by having to work in fixed-point arithmetic makes it
    // unworthwhile to code this-- CemP
    
    if (uQPctX10 < 120)
    {
        x = IntSqrt(((DWORD)rx*(DWORD)rx*(DWORD)uQPctX10*(DWORD)uQPctX10)
            /((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

        y = IntSqrt(((DWORD)rx*(DWORD)rx-(DWORD)x*(DWORD)x)*(DWORD)ry*(DWORD)ry/((DWORD)rx*(DWORD)rx));
    }
    else
    {
        y = IntSqrt((DWORD)ry*(DWORD)ry*(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)
            /((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

        x = IntSqrt(((DWORD)ry*(DWORD)ry-(DWORD)y*(DWORD)y)*(DWORD)rx*(DWORD)rx/((DWORD)ry*(DWORD)ry));
    }

    /* Switch on the actual quadrant
    */
    switch (dwPer1000 / 250)
    {
    case 1:
        y = -y;
        break;

    case 2:
        break;

    case 3:
        x = -x;
        break;

    default: // case 0 and case 4
        x = -x;
        y = -y;
        break;
    }

    /* Now adjust for the center.
    */
    x += cx;
    y += cy;

    // Hack to get around bug in NTGDI        
    x = x < 0 ? 0 : x;

    /* Draw the shadows using regions (to reduce flicker).
    */
    hEllipticRgn = CreateEllipticRgnIndirect(&rcItem);
    OffsetRgn(hEllipticRgn, 0, lShadowDepth);
    hEllRect = CreateRectRgn(rcItem.left, cy, rcItem.right, cy+lShadowDepth);
    hRectRgn = CreateRectRgn(0, 0, 0, 0);
    CombineRgn(hRectRgn, hEllipticRgn, hEllRect, RGN_OR);
    OffsetRgn(hEllipticRgn, 0, -(int)lShadowDepth);
    CombineRgn(hEllRect, hRectRgn, hEllipticRgn, RGN_DIFF);

    /* Always draw the whole area in the free shadow/
    */
    hBrush = CreateSolidBrush(lpColors[COLOR_DNSHADOW]);
    if (hBrush)
    {
        FillRgn(hdc, hEllRect, hBrush);
        DeleteObject(hBrush);
    }

    /* Draw the used shadow only if the disk is at least half used.
    */
    if (dwPer1000>500 && (hBrush = CreateSolidBrush(lpColors[COLOR_UPSHADOW]))!=NULL)
    {
        DeleteObject(hRectRgn);
        hRectRgn = CreateRectRgn(x, cy, rcItem.right, lprc->bottom);
        CombineRgn(hEllipticRgn, hEllRect, hRectRgn, RGN_AND);
        FillRgn(hdc, hEllipticRgn, hBrush);
        DeleteObject(hBrush);
    }

    DeleteObject(hRectRgn);
    DeleteObject(hEllipticRgn);
    DeleteObject(hEllRect);

    hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    hOldPen = (HPEN__*) SelectObject(hdc, hPen);

    // if per1000 is 0 or 1000, draw full elipse, otherwise, also draw a pie section.
    // we might have a situation where per1000 isn't 0 or 1000 but y == cy due to approx error,
    // so make sure to draw the ellipse the correct color, and draw a line (with Pie()) to
    // indicate not completely full or empty pie.
    hBrush = CreateSolidBrush(lpColors[dwPer1000 < 500 && y == cy && x < cx? COLOR_DN: COLOR_UP]);
    hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

    Ellipse(hdc, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom);
    SelectObject(hdc, hOldBrush);
    DeleteObject(hBrush);

    if(dwPer1000 != 0 && dwPer1000 != 1000)
    {
        // display small sub-section of ellipse for smaller part
        hBrush = CreateSolidBrush(lpColors[COLOR_DN]);
        hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

        // NTRAID#087993-2000/02/16-aidanl: Pie may malfunction when y approaches cy
        // If y == cy (when the disk is almost full)and if x approaches
        // rcItem.left, on win9x, Pie malfunctions. It draws the larger portion
        // of the pie, instead of the smaller portion. We work around it by
        // adding 1 to y.
        Pie(hdc, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
            rcItem.left, cy, x, (y == cy) ? (y + 1) : y);
        SelectObject(hdc, hOldBrush);
        DeleteObject(hBrush);
    }

    Arc(hdc, rcItem.left, rcItem.top+lShadowDepth, rcItem.right - 1, rcItem.bottom+lShadowDepth - 1,
        rcItem.left, cy+lShadowDepth, rcItem.right, cy+lShadowDepth-1);
    MoveToEx(hdc, rcItem.left, cy, NULL);
    LineTo(hdc, rcItem.left, cy+lShadowDepth);
    MoveToEx(hdc, rcItem.right-1, cy, NULL);
    LineTo(hdc, rcItem.right-1, cy+lShadowDepth);
    if(dwPer1000 > 500 && dwPer1000 < 1000)
    {
        MoveToEx(hdc, x, y, NULL);
        LineTo(hdc, x, y+lShadowDepth);
    }
    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);

    return S_OK;    // Everything worked fine
}   // Draw3dPie

DWORD CThumbCtl::IntSqrt(DWORD dwNum)
{
    // This code came from "drawpie.c"
    DWORD dwSqrt = 0;
    DWORD dwRemain = 0;
    DWORD dwTry = 0;

    for(int i=0; i<16; ++i) {
        dwRemain = (dwRemain<<2) | (dwNum>>30);
        dwSqrt <<= 1;
        dwTry = dwSqrt*2 + 1;

        if (dwRemain >= dwTry) {
            dwRemain -= dwTry;
            dwSqrt |= 0x01;
        }
        dwNum <<= 2;
    }
    return dwSqrt;
}   // IntSqrt

// General functions
void CThumbCtl::InvokeOnThumbnailReady(void)
{
    // Fire off "OnThumbnailReady" event to our connection points to indicate that
    // either a thumbnail has been computed or we have no thumbnail for this file.
    DISPPARAMS dp = {0, NULL, 0, NULL};     // no parameters
    IUnknown **pp = NULL;       // traverses connection points, where it is interpreted as IDispatch*

    Lock();

    for(pp = m_vec.begin(); pp < m_vec.end(); ++pp)
    {
        if(pp)
        {
            ((IDispatch *)*pp)->Invoke(DISPID_ONTHUMBNAILREADY, IID_NULL, LOCALE_USER_DEFAULT,
                DISPATCH_METHOD, &dp, NULL, NULL, NULL);
        }
    }

    Unlock();

    FireViewChange();
}

HRESULT CThumbCtl::OnDraw(ATL_DRAWINFO& di)
{
    HDC hdc = di.hdcDraw;
    RECT rc = *(LPRECT)di.prcBounds;
    HRESULT hr = S_OK;

    if(m_fRootDrive || m_hbm)
    {
        HPALETTE hpal = NULL;

        // Create pallete appropriate for this HDC
        if(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        {
            hpal = SHCreateShellPalette(hdc);
            HPALETTE hpalOld = SelectPalette(hdc, hpal, TRUE);
            RealizePalette(hdc);

            // Old one needs to be selected back in
            SelectPalette(hdc, hpalOld, TRUE);
        }

        if(m_fRootDrive)
        {
            // Draw a pie chart
            if(m_fUseSystemColors)
            {
                // system colors can change!
                m_acrChartColors[PIE_USEDCOLOR] = GetSysColor(COLOR_3DFACE);
                m_acrChartColors[PIE_FREECOLOR] = GetSysColor(COLOR_3DHILIGHT);
                m_acrChartColors[PIE_USEDSHADOW] = GetSysColor(COLOR_3DSHADOW);
                m_acrChartColors[PIE_FREESHADOW] = GetSysColor(COLOR_3DFACE);
            }
            else if(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
            {
                // Call GetNearestColor on the colors to make sure they're on the palette
                // Of course, system colors ARE on the palette (I think)
                DWORD dw = 0;       // index
                for(dw = 0; dw < PIE_NUM; dw++)
                {
                    m_acrChartColors[dw] = GetNearestColor(hdc, m_acrChartColors[dw]);
                }
            }
            hr = Draw3dPie(hdc, &rc, m_dwUsedSpacePer1000, m_acrChartColors);
        }
        else
        {
            // Draw the Thumbnail bitmap
            HDC hdcBitmap = CreateCompatibleDC(hdc);
            if (hdcBitmap)
            {
                BITMAP bm;

                SelectObject(hdcBitmap, m_hbm);
                GetObject(m_hbm, SIZEOF(bm), &bm);

                if(bm.bmWidth == rc.right - rc.left && bm.bmHeight == rc.bottom - rc.top)
                {
                    BitBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
                        hdcBitmap, 0, 0, SRCCOPY);
                }
                else
                {
                    SetStretchBltMode(hdc, COLORONCOLOR);
                    StretchBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
                        hdcBitmap, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
                }
                DeleteDC(hdcBitmap);
            }
        }

        // clean up DC, palette
        if(hpal)
        {
            DeleteObject(hpal);
        }
    }
    else
    {
        SelectObject(hdc, GetStockObject(WHITE_PEN));
        SelectObject(hdc, GetStockObject(WHITE_BRUSH));

        // Just draw a blank rectangle
        Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\util.h ===
//
//  util.cpp
//
typedef struct tagGETDCSTATE {
    IOleInPlaceSiteWindowless *pipsw;   // If we got the DC from an interface
    HWND hwnd;                          // If we got the DC from a window
} GETDCSTATE, *PGETDCSTATE;

STDAPI_(HDC) IUnknown_GetDC(IUnknown *punk, LPCRECT prc, PGETDCSTATE pdcs);
STDAPI_(void) IUnknown_ReleaseDC(HDC hdc, PGETDCSTATE pdcs);

DWORD FormatMessageWrapW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageID, DWORD dwLangID, LPWSTR pwzBuffer, DWORD cchSize, ...);

EXTERN_C int WINAPIV wsprintfWrapW(
    OUT LPWSTR pwszOut,
    IN LPCWSTR pwszFormat,
    ...);
    
//---------------------------------------------------------------------------
// For manipulating BSTRs without using SysAllocString

template<int n> class STATIC_BSTR {
public:
    ULONG _cb;
    WCHAR _wsz[n];
    // Remove const-ness because VARIANTs don't have "const BSTR"
    operator LPWSTR() { return _wsz; }
    void SetSize() { _cb = lstrlenW(_wsz) * sizeof(WCHAR); }
    int inline const MaxSize() { return n; }
};

#define MAKE_CONST_BSTR(name, str) \
    STATIC_BSTR<sizeof(str)/sizeof(WCHAR)> \
                       name = { sizeof(str) - sizeof(WCHAR), str }

#define DECL_CONST_BSTR(name, str) \
    extern STATIC_BSTR<sizeof(str)/sizeof(WCHAR)> name;

extern HRESULT _ComputeFreeSpace(LPCWSTR pszFileName, ULONGLONG& ullFreeSpace,
        ULONGLONG& ullUsedSpace, ULONGLONG& ullTotalSpace);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\thumbctl.h ===
// ThumbCtl.h : Declaration of the CThumbCtl
#ifndef __THUMBCTL_H_
#define __THUMBCTL_H_

#define WM_HTML_BITMAP  (WM_USER + 100)

EXTERN_C const CLSID CLSID_ThumbCtlOld;   // retired from service

/////////////////////////////////////////////////////////////////////////////
// CThumbCtl
class ATL_NO_VTABLE CThumbCtl : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CThumbCtl, &CLSID_ThumbCtl>,
    public CComControl<CThumbCtl>,
    public IDispatchImpl<IThumbCtl, &IID_IThumbCtl, &LIBID_WEBVWLib>,
    public IProvideClassInfo2Impl<&CLSID_ThumbCtl, NULL, &LIBID_WEBVWLib>,
    public IPersistStreamInitImpl<CThumbCtl>,
    public IPersistStorageImpl<CThumbCtl>,
    public IQuickActivateImpl<CThumbCtl>,
    public IOleControlImpl<CThumbCtl>,
    public IOleObjectImpl<CThumbCtl>,
    public IOleInPlaceActiveObjectImpl<CThumbCtl>,
    public IViewObjectExImpl<CThumbCtl>,
    public IOleInPlaceObjectWindowlessImpl<CThumbCtl>,
    public IDataObjectImpl<CThumbCtl>,
    public ISupportErrorInfo,
    public ISpecifyPropertyPagesImpl<CThumbCtl>,
    public IObjectSafetyImpl<CThumbCtl, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IConnectionPointImpl<CThumbCtl, &DIID_DThumbCtlEvents>,
    public IConnectionPointContainerImpl<CThumbCtl>
{
public:
    // === INTERFACE ===
    // *** IThumbCtl ***
    STDMETHOD(displayFile)(BSTR bsFileName, VARIANT_BOOL *);
    STDMETHOD(haveThumbnail)(VARIANT_BOOL *);
    STDMETHOD(get_freeSpace)(BSTR *);
    STDMETHOD(get_usedSpace)(BSTR *);
    STDMETHOD(get_totalSpace)(BSTR *);

// ATL Functions
    // Drawing function
    HRESULT OnDraw(ATL_DRAWINFO& di);

DECLARE_REGISTRY_RESOURCEID(IDR_THUMBCTL)

BEGIN_COM_MAP(CThumbCtl)
    COM_INTERFACE_ENTRY(IThumbCtl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CThumbCtl)
    CONNECTION_POINT_ENTRY(DIID_DThumbCtlEvents)
END_CONNECTION_POINT_MAP()

BEGIN_PROPERTY_MAP(CThumbCtl)
END_PROPERTY_MAP()

BEGIN_MSG_MAP(CThumbCtl)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()

    // *** IObjectSafety ***
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);

    // *** ISupportsErrorInfo ***
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // *** IViewObjectEx ***
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus);

    // *** IOleInPlaceActiveObject ***
    virtual STDMETHODIMP TranslateAccelerator(LPMSG pMsg);

public:
    // === PUBLIC FUNCTIONS ===
    CThumbCtl(void);
    ~CThumbCtl(void);

private:
    // === PRIVATE DATA ===
    BOOL m_fRootDrive;      // Do we have a root drive? (if so, display pie chart)

    BOOL                 m_fTabRecieved;    // To avoid re-entrant calls
    
    // thumbnail
    BOOL m_fInitThumb;      // Have we called the setup IThumbnail yet?
    BOOL m_fHaveIThumbnail;     // success of SetupIThumbnail() (only call it once)
    IThumbnail *m_pthumb;       // File to bitmap convertor interface
    HWND m_hwnd;        // invisible window used to receive WM_HTML_BITMAP message
    HBITMAP m_hbm;      // latest calculated bitmap; NULL if have no bitmap
    DWORD m_dwThumbnailID;      // ID to identify which bitmap we received

    // root drive
    enum
    {
        PIE_USEDCOLOR = 0,
        PIE_FREECOLOR,
        PIE_USEDSHADOW,
        PIE_FREESHADOW,
        PIE_NUM     // keep track of number of PIE_ values
    };
    DWORDLONG m_dwlFreeSpace;
    DWORDLONG m_dwlUsedSpace;
    DWORDLONG m_dwlTotalSpace;
    DWORD m_dwUsedSpacePer1000;     // amount of used space /1000
    COLORREF m_acrChartColors[PIE_NUM];         // color scheme
    BOOL m_fUseSystemColors;        // Use system color scheme?

    // === PRIVATE FUNCTIONS ===
    void InvokeOnThumbnailReady(void);

    // For the pie-chart drawing routines...
    HRESULT ComputeFreeSpace(LPTSTR pszFileName);
    HRESULT get_GeneralSpace(DWORDLONG dwlSpace, BSTR *);
    HRESULT Draw3dPie(HDC, LPRECT, DWORD dwPer1000, const COLORREF *);
    DWORD IntSqrt(DWORD);

    // sets up the thumbnail interface -- must call before use.
    HRESULT SetupIThumbnail(void);
    
    // Window Procedure for catching and storing bitmap
    static LRESULT CALLBACK WndProc(HWND, UINT uMsg, WPARAM, LPARAM);
};

#endif //__THUMBCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\thumbwrap.cpp ===
#include "priv.h"
#include "wvcoord.h"

/////////////////////////////////////////////////////////////////////////////
// CThumbNailWrapper
/////////////////////////////////////////////////////////////////////////////

CThumbNailWrapper::CThumbNailWrapper()
{
    // Do nothing for now
}

CThumbNailWrapper::~CThumbNailWrapper()
{
    m_spThumbNailCtl = NULL;
    m_spThumbNailStyle = NULL;
    m_spThumbnailLabel = NULL;
}

HRESULT CThumbNailWrapper::Init(CComPtr<IThumbCtl> spThumbNailCtl,
        CComPtr<IHTMLElement> spThumbnailLabel)

{   
    m_spThumbNailCtl = spThumbNailCtl;
    m_spThumbnailLabel = spThumbnailLabel;
    HRESULT hr = FindObjectStyle((IThumbCtl *)spThumbNailCtl, m_spThumbNailStyle);
    if (SUCCEEDED(hr))
    {
        m_spThumbNailStyle->put_display(OLESTR("none"));    // Hide the thumbctl initially when nothing is displayed.
    }
    return hr;
}

STDMETHODIMP CThumbNailWrapper::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr)
{
    HRESULT hr;

    if (riid != IID_NULL) {
        return DISP_E_UNKNOWNINTERFACE;
    }

    hr = S_OK;

    if (dispIdMember == DISPID_ONTHUMBNAILREADY) {
        hr = OnThumbNailReady();
    }

    return hr;
}

HRESULT CThumbNailWrapper::OnThumbNailReady(VOID) 
{
    HRESULT hr = S_OK;

    if (m_spThumbNailCtl)
    {
        VARIANT_BOOL bHaveThumbnail;

        if (SUCCEEDED(m_spThumbNailCtl->haveThumbnail(&bHaveThumbnail)) && bHaveThumbnail)
        {
            hr = m_spThumbNailStyle->put_display(OLESTR(""));
        }
        else
        {
            ClearThumbNail();
        }
    }
    return hr;
}

HRESULT CThumbNailWrapper::FreeSpace(CComBSTR &bstrFree)
{
    return m_spThumbNailCtl->get_freeSpace(&bstrFree);
}

HRESULT CThumbNailWrapper::TotalSpace(CComBSTR &bstrTotal)
{
    return m_spThumbNailCtl->get_totalSpace(&bstrTotal);
}

HRESULT CThumbNailWrapper::UsedSpace(CComBSTR &bstrUsed)
{
    return m_spThumbNailCtl->get_usedSpace(&bstrUsed);
}

HRESULT CThumbNailWrapper::SetDisplay(CComBSTR &bstrDisplay) 
{
    return m_spThumbNailStyle->put_display(bstrDisplay);
}

HRESULT CThumbNailWrapper::SetHeight(int iHeight)
{
    return m_spThumbNailStyle->put_height(CComVariant(iHeight));
}

HRESULT CThumbNailWrapper::_SetThumbnailLabel(CComBSTR& bstrLabel)
{
    if (m_spThumbnailLabel)
    {
        m_spThumbnailLabel->put_innerText(bstrLabel);
    }
    return S_OK;
}

BOOL CThumbNailWrapper::UpdateThumbNail(CComPtr<FolderItem> spFolderItem) 
{
    BOOL bRet = FALSE;
    VARIANT_BOOL bDisplayed;
    CComBSTR     bstrPath;

    ClearThumbNail();

    if (SUCCEEDED(spFolderItem->get_Path(&bstrPath)) && (bstrPath.Length() > 0)
            && SUCCEEDED(m_spThumbNailCtl->displayFile(bstrPath, &bDisplayed)) && bDisplayed)
    {
        CComBSTR bstrLabel, bstrFolderItemName;
        WCHAR wszTemp[MAX_PATH];
        if (PathIsRootW(bstrPath))
        {
            CComBSTR bstrSpace;
            if (SUCCEEDED(UsedSpace(bstrSpace)))
            {
                LoadStringW(_Module.GetResourceInstance(), IDS_USEDSPACE, wszTemp, ARRAYSIZE(wszTemp));
                bstrLabel = wszTemp;
                bstrLabel += bstrSpace;
            }
            if (SUCCEEDED(FreeSpace(bstrSpace)))
            {
                if (bstrLabel.Length() > 0)
                {
                    LoadStringW(_Module.GetResourceInstance(), IDS_PHRASESEPERATOR, wszTemp, ARRAYSIZE(wszTemp));
                    bstrLabel += wszTemp;
                }
                LoadStringW(_Module.GetResourceInstance(), IDS_FREESPACE, wszTemp, ARRAYSIZE(wszTemp));
                bstrLabel += wszTemp;
                bstrLabel += bstrSpace;
            }
        }
        else if (SUCCEEDED(spFolderItem->get_Name(&bstrFolderItemName)))
        {
            WCHAR wszName[MAX_PATH];
            StrCpyNW(wszName, bstrFolderItemName, ARRAYSIZE(wszName));

            WCHAR wszTemp2[MAX_PATH * 2];
            LoadStringW(_Module.GetResourceInstance(), IDS_THUMBNAIL_LABEL, wszTemp, ARRAYSIZE(wszTemp));
            wnsprintfW(wszTemp2, ARRAYSIZE(wszTemp2), wszTemp, wszName);
            bstrLabel = wszTemp2;
        }
        _SetThumbnailLabel(bstrLabel);
        bRet = TRUE;
    }
    return bRet;
}

HRESULT CThumbNailWrapper::ClearThumbNail() 
{
    CComBSTR bstrLabel;
    // Optimization to prevent loading mshtmled.dll - we only need to clear the label if text is currently there.
    if (m_spThumbnailLabel && SUCCEEDED(m_spThumbnailLabel->get_innerText(&bstrLabel)) && bstrLabel)
        _SetThumbnailLabel(CComBSTR(""));
    return m_spThumbNailStyle->put_display(OLESTR("none"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\webvw.cpp ===
// webvw.cpp : Main Web View File
// contains implementation of DLL Exports; debug info, etc.
#include "priv.h"
#include "wvcoord.h"
#include "fldricon.h"
#define DECL_CRTFREE
#include <crtfree.h>

STDAPI RegisterStuff(HINSTANCE hinstWebvw);

// from install.cpp
HRESULT SetFileAndFolderAttribs(HINSTANCE hInstResource);

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_WebView,                 CComObject<CWebViewCoord>) // W2K
    OBJECT_ENTRY(CLSID_WebViewOld,              CComObject<CWebViewCoord>) // W2K
    OBJECT_ENTRY(CLSID_ThumbCtl,                CComObject<CThumbCtl>) // W2K
    OBJECT_ENTRY(CLSID_ThumbCtlOld,             CComObject<CThumbCtl>) // W2K
    OBJECT_ENTRY(CLSID_WebViewFolderIcon,       CComObject<CWebViewFolderIcon>) // W2K
    OBJECT_ENTRY(CLSID_WebViewFolderIconOld,    CComObject<CWebViewFolderIcon>) // W2K
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
#ifdef DEBUG
        CcshellGetDebugFlags();
#endif
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        SHFusionInitializeFromModule(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        SHFusionUninitialize();
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

typedef int (* PFNLOADSTRING) (HINSTANCE, UINT, LPTSTR, int);

// This is used so we aren't forced to call MLLoadString
int NonMLLoadString(HINSTANCE hinst, UINT uID, LPTSTR psz, int cch)
{
    static PFNLOADSTRING s_pfn = (PFNLOADSTRING)-1;

    if (s_pfn == (PFNLOADSTRING)-1)
    {
        s_pfn = (PFNLOADSTRING) GetProcAddress(GetModuleHandle(TEXT("USER32.DLL")), "LoadStringW");
    }

    if (s_pfn)
    {
        return s_pfn(hinst, uID, psz, cch);
    }

    return 0;
}

HRESULT ConvertDefaultWallpaper(void)
{
    // We convert the default wallpaper (default.jpg) to a .bmp since user can't handle .jpg's and
    // we don't want to force Active Desktop on.
    TCHAR szPathSrc[MAX_PATH];
    TCHAR szPathDest[MAX_PATH];
    HRESULT hr = E_OUTOFMEMORY;

    if (GetWindowsDirectory(szPathSrc, ARRAYSIZE(szPathSrc)))
    {
        int cchCopied;
        TCHAR szDisplayName[MAX_PATH];

        // we want to call the non-MUI loadstring function here since the wallpaper is a file on disk that is always localized
        // in the system default local, not whatever the current users local is
        if (IsOS(OS_PERSONAL))
        {
            // we have a different wallpaper name on per (Bliss.bmp vs Windows XP.jpg)
            cchCopied = NonMLLoadString(_Module.GetResourceInstance(), IDS_WALLPAPER_LOCNAME_PER, szDisplayName, ARRAYSIZE(szDisplayName));
        }
        else
        {
            cchCopied = NonMLLoadString(_Module.GetResourceInstance(), IDS_WALLPAPER_LOCNAME, szDisplayName, ARRAYSIZE(szDisplayName));
        }

        if (cchCopied)
        {
            PathAppend(szPathSrc, TEXT("Web\\Wallpaper\\"));

            StrCpyN(szPathDest, szPathSrc, ARRAYSIZE(szPathDest));
            PathAppend(szPathSrc, TEXT("default.jpg"));
            PathAppend(szPathDest, szDisplayName);
            StrCatBuff(szPathDest, TEXT(".bmp"), ARRAYSIZE(szPathDest));

            hr = SHConvertGraphicsFile(szPathSrc, szPathDest, SHCGF_REPLACEFILE);
            if (SUCCEEDED(hr))
            {
                DeleteFile(szPathSrc);
            }
        }

    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // setup attribs on system files/folders
    HRESULT hrRet = SetFileAndFolderAttribs(_Module.GetResourceInstance());

    TCHAR szWinPath[MAX_PATH];
    GetWindowsDirectory(szWinPath, ARRAYSIZE(szWinPath));

    struct _ATL_REGMAP_ENTRY regMap[] =
    {
        {OLESTR("windir"), szWinPath}, // subsitute %windir% for registry
        {0, 0}
    };

    HRESULT hr = RegisterStuff(_Module.GetResourceInstance());
    if (SUCCEEDED(hrRet))
    {
        hrRet = hr;
    }

    ConvertDefaultWallpaper();

    // registers object, typelib and all interfaces in typelib
    hr = _Module.RegisterServer(TRUE);

    return SUCCEEDED(hrRet) ? hr : hrRet;
}

STDAPI DllInstall(BOOL fInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = E_FAIL;    

    if (pszCmdLine)
    {
        ASSERTMSG(StrStrIW(pszCmdLine, L"/RES=") == NULL, "webvw!DllInstall : passed old MUI command (no longer supported)");
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\util.cpp ===
#include "priv.h"
#include "wvcoord.h"


HRESULT GetObjectFromContainer(IDispatch *pdispContainer, LPOLESTR poleName, IDispatch **ppdisp)
{
    HRESULT hr = E_FAIL;

    *ppdisp = NULL;
    if (pdispContainer && poleName)
    {
        DISPID dispID;
        // Get the object dispid from the container
        if (SUCCEEDED(pdispContainer->GetIDsOfNames(IID_NULL, &poleName, 1, 0, &dispID)))
        {
            DISPPARAMS dp = {0};
            EXCEPINFO ei = {0};

            VARIANTARG va;       
            if (SUCCEEDED((pdispContainer->Invoke(dispID, IID_NULL, 0, DISPATCH_PROPERTYGET, &dp, &va, &ei, NULL))
                    && va.vt == VT_DISPATCH))
            {
                *ppdisp = va.pdispVal;
                hr = S_OK;
            }
        }
    }
    return hr;
}

// Get punkObject.style property
HRESULT FindObjectStyle(IUnknown *punkObject, CComPtr<IHTMLStyle>& spStyle)
{
    HRESULT hr = E_FAIL;

    CComPtr<IDispatch> spdispObject, spdispObjectOuter, spdispObjectStyle;
    if (SUCCEEDED(punkObject->QueryInterface(IID_PPV_ARG(IDispatch, &spdispObject)))
            && SUCCEEDED(spdispObject->QueryInterface(IID_PPV_ARG(IDispatch, &spdispObjectOuter)))
            && SUCCEEDED(GetObjectFromContainer(spdispObjectOuter, OLESTR("style"), &spdispObjectStyle))
            && SUCCEEDED(spdispObjectStyle->QueryInterface(IID_PPV_ARG(IHTMLStyle, &spStyle))))
    {
        hr = S_OK;
    }
    return hr;
}

BOOL IsRTLDocument(CComPtr<IHTMLDocument2>& spHTMLDocument)
{

    BOOL bRet = FALSE;
    CComPtr<IHTMLDocument3> spHTMLDocument3;
    CComBSTR bstrDir;
    if (spHTMLDocument && SUCCEEDED(spHTMLDocument->QueryInterface(IID_IHTMLDocument3, (void **)&spHTMLDocument3))
            && SUCCEEDED(spHTMLDocument3->get_dir(&bstrDir)) && bstrDir && (StrCmpIW(bstrDir, L"RTL") == 0))
    {
        bRet = TRUE;
    }
    return bRet;
}

//
//  How many ways are there to get a DC?
//
//  1.  If the site supports IOleInPlaceSiteWindowless, we can get the DC
//      via IOleInPlaceSiteWindowless::GetDC and give it back with ReleaseDC.
//
//  2.  If the site supports any of the GetWindow interfaces, we get its
//      window and ask USER for the DC.
//
//  3.  If we can't get any of that stuff, then we just get a screen DC
//      (special case where the associated window is NULL).
//
//  Note!  This function tries really really hard to get the DC.  You
//  should use it only for informational purposes, not for drawing.
//

STDAPI_(HDC) IUnknown_GetDC(IUnknown *punk, LPCRECT prc, PGETDCSTATE pdcs)
{
    HRESULT hr = E_FAIL;
    HDC hdc = NULL;
    ZeroMemory(pdcs, sizeof(PGETDCSTATE));

    if (punk &&
        SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IOleInPlaceSiteWindowless, &pdcs->pipsw))))
    {
        hr = pdcs->pipsw->GetDC(prc, OLEDC_NODRAW, &hdc);
        if (FAILED(hr))
        {
            ATOMICRELEASE(pdcs->pipsw);
        }

    }

    if (FAILED(hr))
    {
        // This will null out the hwnd on failure, which is what we want!
        IUnknown_GetWindow(punk, &pdcs->hwnd);
        hdc = GetDC(pdcs->hwnd);
    }

    return hdc;
}

STDAPI_(void) IUnknown_ReleaseDC(HDC hdc, PGETDCSTATE pdcs)
{
    if (pdcs->pipsw)
    {
        pdcs->pipsw->ReleaseDC(hdc);
        ATOMICRELEASE(pdcs->pipsw);
    }
    else
        ReleaseDC(pdcs->hwnd, hdc);
}

DWORD FormatMessageWrapW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageID, DWORD dwLangID, LPWSTR pwzBuffer, DWORD cchSize, ...)
{
    va_list vaParamList;

    va_start(vaParamList, cchSize);
    DWORD dwResult = FormatMessageW(dwFlags, lpSource, dwMessageID, dwLangID, pwzBuffer, cchSize, &vaParamList);
    va_end(vaParamList);

    return dwResult;
}

// for LoadLibrary/GetProcAddress on SHGetDiskFreeSpaceA
typedef BOOL (__stdcall * PFNSHGETDISKFREESPACEA)(LPCSTR pszVolume, ULARGE_INTEGER *pqwFreeCaller, ULARGE_INTEGER *pqwTot, 
                                                  ULARGE_INTEGER *pqwFree);

HRESULT _ComputeFreeSpace(LPCWSTR pszFileName, ULONGLONG& ullFreeSpace,
        ULONGLONG& ullUsedSpace, ULONGLONG& ullTotalSpace)
{
    ULARGE_INTEGER qwFreeCaller;        // use this for free space -- this will take into account disk quotas and such on NT
    ULARGE_INTEGER qwTotal;
    ULARGE_INTEGER qwFree;      // unused
    CHAR szFileNameA[MAX_PATH];

    static PFNSHGETDISKFREESPACEA pfnSHGetDiskFreeSpaceA = NULL;
    
    SHUnicodeToAnsi(pszFileName, szFileNameA, MAX_PATH);

    // Load the function the first time
    if (pfnSHGetDiskFreeSpaceA == NULL)
    {
        HINSTANCE hinstShell32 = LoadLibrary(TEXT("SHELL32.DLL"));

        if (hinstShell32)
            pfnSHGetDiskFreeSpaceA = (PFNSHGETDISKFREESPACEA)GetProcAddress(hinstShell32, "SHGetDiskFreeSpaceA");
    }

    // Compute free & total space and check for valid results.
    // If you have a function pointer call SHGetDiskFreeSpaceA
    if (pfnSHGetDiskFreeSpaceA && pfnSHGetDiskFreeSpaceA(szFileNameA, &qwFreeCaller, &qwTotal, &qwFree))
    {
        ullFreeSpace = qwFreeCaller.QuadPart;
        ullTotalSpace = qwTotal.QuadPart;
        ullUsedSpace = ullTotalSpace - ullFreeSpace;

        if (EVAL((ullTotalSpace > 0) && (ullFreeSpace <= ullTotalSpace)))
            return S_OK;
    }
    return E_FAIL;
}


//--------------- Win95 Wraps for W versions of functions used by ATL -----// 
//-------------------------------------------------------------------------//
#ifdef wsprintfWrapW
#undef wsprintfWrapW
#endif //wsprintfWrapW
int WINAPIV wsprintfWrapW(OUT LPWSTR pwszOut, IN LPCWSTR pwszFormat, ...)
{
    int     cchRet;
    va_list arglist;
    
    va_start( arglist, pwszFormat );
    cchRet = wvsprintfWrapW( pwszOut, pwszFormat, arglist );
    va_end( arglist );

    return cchRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\webvw.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

USE_STATIC_ATL  = 1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

C_DEFINES       = $(C_DEFINES) -D_USRDLL

!if $(IA64)
# We are hitting a "error C1076: compiler limit : internal heap limit reached" on
# ia64 builds. Are we really using *that* much heap? Dosen't seem right...
MSC_OPTIMIZATION=/Zm200
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\wvguids.cpp ===
// wvguids.cpp : Instantiation of GUIDS used by WebView

#include "priv.h"

#define INITGUID
#include <initguid.h>

#include "wvguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\wvmacros.h ===
#ifndef __WV_MACROS_H_
#define __WV_MACROS_H_

#define IfFailRet(hresult) {hr = (hresult); if (FAILED(hr)) return hr;}
#define IfFailGo(hresult) {hr = (hresult); if (FAILED(hr)) goto done;}

#define IfFalseRet(val, hr) {if ((val) == 0) return (hr);}

#endif // __WV_MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\dll\makefile.inc ===
..\webvw.rc : $(PROJECT_ROOT)\lib\$(O)\webvw.tlb $(SELFREGNAME) $(MISCFILES)

	
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\wvcoord.cpp ===
// wvcoord.cpp : Implementation of CWebViewCoord

#include "priv.h"
#include "wvcoord.h"

const CLSID CLSID_WebViewOld = {0x7a707490,0x260a,0x11d1,{0x83,0xdf,0x00,0xa0,0xc9,0x0d,0xc8,0x49}};    // retired from service, so made private

/////////////////////////////////////////////////////////////////////////////
// CWebViewCoord
/////////////////////////////////////////////////////////////////////////////

CWebViewCoord::CWebViewCoord()
{
    m_pFileListWrapper = NULL;
    m_pThumbNailWrapper = NULL;
    m_pdispWindow = NULL;
    
    m_dwFileListAdviseCookie  = 0;
    m_dwThumbNailAdviseCookie = 0;
    m_dwHtmlWindowAdviseCookie = 0;
    m_dwCSCHotTrackCookie = 0;
}

CWebViewCoord::~CWebViewCoord()
{
    ReleaseFolderObjects();
}

STDMETHODIMP CWebViewCoord::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr)
{
    HRESULT hr = S_OK;

    switch (dispidMember)
    {
        case DISPID_HTMLWINDOWEVENTS_ONLOAD:
            hr = OnWindowLoad();
            break;

        case DISPID_HTMLWINDOWEVENTS_ONUNLOAD:
            hr = OnWindowUnLoad();
            break;

        case DISPID_HTMLWINDOWEVENTS_ONRESIZE:
            hr = OnFixSize();
            break;

        case DISPID_EVMETH_ONMOUSEOVER:
            hr = OnCSCMouseOver();
            break;

        case DISPID_EVMETH_ONMOUSEOUT:
            hr = OnCSCMouseOut();
            break;

        case DISPID_EVMETH_ONKEYPRESS:
        case DISPID_EVMETH_ONCLICK:
            hr = OnCSCClick();
            break;

        default:
            hr = IDispatchImpl<IWebView, &IID_IWebView, &LIBID_WEBVWLib>::
                    Invoke(dispidMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
            break;
    }
    return hr;  
}

STDMETHODIMP CWebViewCoord::OnCSCClick()
{
    HRESULT hres = S_OK;

    if (m_pFileListWrapper)
    {
        hres = m_pFileListWrapper->OnCSCClick();
    }
    return hres;
}

STDMETHODIMP CWebViewCoord::OnCSCMouseOver()
{
    HRESULT hres = S_OK;

    if (m_pFileListWrapper)
    {
        hres = m_pFileListWrapper->OnCSCMouseOnOff(TRUE);
    }
    return hres;

}

STDMETHODIMP CWebViewCoord::OnCSCMouseOut()
{
    HRESULT hres = S_OK;

    if (m_pFileListWrapper)
    {
        hres = m_pFileListWrapper->OnCSCMouseOnOff(FALSE);
    }
    return hres;

}

STDMETHODIMP CWebViewCoord::CSCSynchronize()
{
    HRESULT hres = S_OK;

    if (m_pFileListWrapper)
    {
        hres = m_pFileListWrapper->CSCSynchronize();
    }
    return hres;
}

STDMETHODIMP CWebViewCoord::SetSite(IUnknown *punkSite)
{
    HRESULT hr;

    if (punkSite == NULL && m_pdispWindow)
    {
        DisconnectHtmlEvents(m_pdispWindow, m_dwHtmlWindowAdviseCookie); 
        m_dwHtmlWindowAdviseCookie = 0;
    }        

    hr = IObjectWithSiteImpl<CWebViewCoord>::SetSite(punkSite);

    m_spClientSite = NULL; // Release client site pointer
    ReleaseFolderObjects();

    if (punkSite != NULL && SUCCEEDED(hr))
    {
        hr = punkSite->QueryInterface(IID_IOleClientSite, (void **)&m_spClientSite);
        if (SUCCEEDED(hr))
        {
            hr = ConnectHtmlEvents(this, m_spClientSite, &m_pdispWindow, &m_dwHtmlWindowAdviseCookie);
        }
    } 

    return hr;
}

HRESULT CWebViewCoord::InitFolderObjects() 
{
    HRESULT                             hr;
    CComPtr<IOleContainer>              spContainer;
    CComPtr<IDispatch>                  spdispItem;
    CComVariant                         vEmpty;
    CComPtr<IThumbCtl>                  spThumbNail;
    CComPtr<IHTMLElement>               spElement;
    CComPtr<IHTMLElement>               spInfo;
    CComPtr<IHTMLElement>               spLinks;
    CComPtr<IHTMLElement>               spMediaPlayerSpan;
    CComPtr<IShellFolderViewDual>       spFileList;
    CComPtr<IHTMLElement>               spCSCPlusMin;
    CComPtr<IHTMLElement>               spCSCText;
    CComPtr<IHTMLElement>               spCSCDetail;
    CComPtr<IHTMLElement>               spCSCButton;
    CComPtr<IHTMLStyle>                 spCSCStyle;
    CComPtr<IHTMLStyle>                 spCSCDetailStyle;
    CComPtr<IHTMLStyle>                 spCSCButtonStyle;
    CComPtr<IHTMLWindow2>               spWindow;

    // Get some document level objects

    IfFailRet(m_spClientSite->GetContainer(&spContainer));
    IfFailRet(spContainer->QueryInterface(IID_IHTMLDocument2, (void **)&m_spDocument));
    IfFailRet(IUnknown_QueryService(m_spClientSite, SID_SHTMLWindow, IID_IHTMLWindow2, (LPVOID*)&spWindow));
    IfFailRet(m_spDocument->get_all(&m_spDocAll));

    hr = m_spDocument->get_body(&spElement);
    if (SUCCEEDED(hr))
    {
        spElement->QueryInterface(IID_IHTMLControlElement, (void **)&m_spDocBody);
    }

    //
    // Init Info
    //

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("Info")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spInfo);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("Links")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spLinks);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("MediaPlayerSpan")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spMediaPlayerSpan);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("panel")), vEmpty, &spdispItem)) && spdispItem)
    {
        FindObjectStyle(spdispItem, m_spPanelStyle);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSC")), vEmpty, &spdispItem)) && spdispItem)
    {
        FindObjectStyle(spdispItem, spCSCStyle);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSCHotTrack")), vEmpty, &spdispItem)) && spdispItem)
    {
        //
        // Set up sink for CSC UI notifications to implement hot tracking and expand/collapse
        //
        AtlAdvise(spdispItem, GetUnknown(), IID_IDispatch, &m_dwCSCHotTrackCookie);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSCPlusMin")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spCSCPlusMin);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSCText")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spCSCText);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSCDetail")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spCSCDetail);
        FindObjectStyle(spdispItem, spCSCDetailStyle);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSCButton")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spCSCButton);
        FindObjectStyle(spdispItem, spCSCButtonStyle);
        spdispItem = NULL;
    }

    //
    // Init the thumbnail wrapper object
    //

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("ThumbNail")), vEmpty, &spdispItem)) && spdispItem)
    {
        if (SUCCEEDED(spdispItem->QueryInterface(IID_IThumbCtl, (void **)&spThumbNail)))
        {
            m_pThumbNailWrapper = new CThumbNailWrapper;

            if (m_pThumbNailWrapper == NULL)
            {
                return E_OUTOFMEMORY;
            }

            CComPtr<IDispatch>      spdispItem2;
            CComPtr<IHTMLElement>   spThumbnailLabel;
            if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("ThumbnailLabel")), vEmpty, &spdispItem2)) && spdispItem2)
            {
                spdispItem2->QueryInterface(IID_IHTMLElement, (void **)&spThumbnailLabel);
                spdispItem2 = NULL;
            }

            m_pThumbNailWrapper->Init(spThumbNail, spThumbnailLabel);

            AtlAdvise(spdispItem, m_pThumbNailWrapper, IID_IDispatch, &m_dwThumbNailAdviseCookie);
        }
        spdispItem = NULL;
    }
    
    //
    // Init the file list object
    //

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("Filelist")), vEmpty, &spdispItem)) && spdispItem)
    {
        if (SUCCEEDED(spdispItem->QueryInterface(IID_IShellFolderViewDual, (void **)&spFileList)))
        {
            m_pFileListWrapper = new CFileListWrapper;

            if (m_pFileListWrapper == NULL)
            {
                AtlUnadvise(spdispItem, IID_IDispatch, m_dwThumbNailAdviseCookie);
                m_dwThumbNailAdviseCookie = 0;
                delete m_pThumbNailWrapper;
                return E_OUTOFMEMORY;
            }
            m_pFileListWrapper->Init(spFileList, spInfo, spLinks, m_spPanelStyle, spMediaPlayerSpan,
                    spCSCPlusMin, spCSCText, spCSCDetail, spCSCButton, spCSCStyle,
                    spCSCDetailStyle, spCSCButtonStyle, m_spDocument, spWindow, m_pThumbNailWrapper);

            AtlAdvise(spdispItem, m_pFileListWrapper, IID_IDispatch, 
                      &m_dwFileListAdviseCookie);
        }
        spdispItem = NULL;
    }

    //
    // Init onsize properties
    //

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("Banner")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&m_spHeading);
        FindObjectStyle(spdispItem, m_spHeadingStyle);
        spdispItem = NULL;
    }

    m_bRTLDocument = IsRTLDocument(m_spDocument);

    if (!m_bRTLDocument && m_spPanelStyle)
    {
        m_spPanelStyle->put_overflow(OLESTR("auto"));
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("FileList")), vEmpty, &spdispItem)) && spdispItem)
    {
        FindObjectStyle(spdispItem, m_spFileListStyle);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("rule")), vEmpty, &spdispItem)) && spdispItem)
    {
        FindObjectStyle(spdispItem, m_spRuleStyle);
        spdispItem = NULL;
    }

    return S_OK;
}

HRESULT CWebViewCoord::ReleaseFolderObjects() 
{
    CComPtr<IDispatch> spdisp;

    //
    // Do the unadvise
    //

    if (m_dwCSCHotTrackCookie)
    {
        CComVariant vEmpty;
        if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSCHotTrack")), vEmpty, &spdisp)) && spdisp)
        {
            AtlUnadvise(spdisp, IID_IDispatch, m_dwCSCHotTrackCookie);
            m_dwCSCHotTrackCookie = 0;
            spdisp = NULL;
        }
    }

    if (m_dwFileListAdviseCookie != 0) {
        spdisp = m_pFileListWrapper->Control();
        if (spdisp != NULL) {
            AtlUnadvise(spdisp, IID_IDispatch, m_dwFileListAdviseCookie);
            m_dwFileListAdviseCookie = 0;
            spdisp = NULL;
        }
    }

    if (m_dwThumbNailAdviseCookie != 0) {
        spdisp = (IThumbCtl *)(m_pThumbNailWrapper->Control());
        if (spdisp != NULL) {
            AtlUnadvise(spdisp, IID_IDispatch, m_dwThumbNailAdviseCookie);
            m_dwThumbNailAdviseCookie = 0;
            spdisp = NULL;
        }    
    }

    //
    // Free the file list wrapper
    //

    if (m_pFileListWrapper != NULL) {
        // Need to unadvise from WV links before releasing
        m_pFileListWrapper->AdviseWebviewLinks( FALSE );
        m_pFileListWrapper->Release();
        m_pFileListWrapper = NULL;
    }

    if (m_pThumbNailWrapper != NULL) {
        m_pThumbNailWrapper->Release();
        m_pThumbNailWrapper = NULL;
    }

    //
    // Free any references we may have
    //

    m_spDocAll = NULL;
    m_spDocBody = NULL;
    m_spDocument = NULL;
    m_spFileListStyle = NULL;
    m_spHeading = NULL;
    m_spHeadingStyle = NULL;
    m_spPanelStyle = NULL;
    m_spRuleStyle = NULL;

    return S_OK;
}

HRESULT CWebViewCoord::OnWindowLoad() 
{
    HRESULT hr;

    ReleaseFolderObjects();
    InitFolderObjects();
    hr = OnFixSize();
    return hr;
}

HRESULT CWebViewCoord::OnWindowUnLoad() 
{
    return ReleaseFolderObjects();
}

HRESULT CWebViewCoord::OnFixSize() 
{
    HRESULT hr = S_OK;
    LONG    lClientWidth;

    if (m_spFileListStyle && m_spDocBody && SUCCEEDED(m_spDocBody->get_clientWidth(&lClientWidth)))
    {
        LONG lPanelWidth;
        if (!m_spPanelStyle || FAILED(m_spPanelStyle->get_pixelWidth(&lPanelWidth)))
        {
            lPanelWidth = 0;
        }

        CComBSTR bstrPanelVisibility;
        LONG lFileListLeft, lFileListWidth = -1;
        if (lClientWidth < (lPanelWidth * 2))
        {
            bstrPanelVisibility = OLESTR("hidden");
            lFileListLeft = 0;
        }
        else
        {
            bstrPanelVisibility = OLESTR("visible");
            if (m_bRTLDocument)
            {
                lFileListLeft = 0;
                lFileListWidth = lClientWidth - lPanelWidth;
                if (m_spPanelStyle)
                {
                    m_spPanelStyle->put_pixelLeft(lClientWidth - lPanelWidth);
                }
            }
            else
            {
                lFileListLeft = lPanelWidth;
            }
        }

        if (m_spPanelStyle)
        {
            m_spPanelStyle->put_visibility(bstrPanelVisibility);
        }
        m_spFileListStyle->put_pixelLeft(lFileListLeft);
        m_spFileListStyle->put_pixelWidth((lFileListWidth == -1) ?
                (lClientWidth - lFileListLeft) : lFileListWidth);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\wizhost\resource.h ===
#define IDC_STATIC          -1

#define IDB_BANNER          0x0100

#define IDD_WELCOME         0x1000
#define IDD_DONE            0x1001

#define IDS_WELCOME         0x2000
#define IDS_WELCOME_SUB     0x2001

#define IDS_DONE            0x2100
#define IDS_DONE_SUB        0x2101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\wvguids.h ===
// wvguids.h : Instantiation of GUIDS used by WebView
 
#ifndef __WV_GUIDS_H_
#define __WV_GUIDS_H_

// {7A707490-260A-11D1-83DF-00A0C90DC849}
DEFINE_GUID(CLSID_WebViewCoord, 0x7a707490L, 0x260a, 0x11d1, 0x83, 0xdf, 0x00, 0xa0, 0xc9, 0x0d, 0xc8, 0x49);

#endif // __WV_GUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\debug.cpp ===
// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "MSIEFTP"
#define SZ_MODULE           "MSIEFTP"
#define DECLARE_DEBUG

#include <ccstock.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\webvw\wvcoord.h ===
// wvcoord.h : Declaration of the CWebViewCoord

#ifndef __WEBVIEWCOORD_H_
#define __WEBVIEWCOORD_H_

#include "dxmplay.h"
#include "resource.h"       // main symbols
#include "evtsink.h"
#include "mshtml.h"
#include "mshtmdid.h"

EXTERN_C const CLSID CLSID_WebViewOld;  // retired from service

extern HRESULT FindObjectStyle(IUnknown *punkObject, CComPtr<IHTMLStyle>& spStyle);
extern BOOL IsRTLDocument(CComPtr<IHTMLDocument2>& spHTMLElement);

class CThumbNailWrapper;
class CFileListWrapper;

/////////////////////////////////////////////////////////////////////////////
// CWebViewCoord
class ATL_NO_VTABLE CWebViewCoord :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CWebViewCoord, &CLSID_WebView>,
    public IDispatchImpl<IWebView, &IID_IWebView, &LIBID_WEBVWLib>,
    public IObjectSafetyImpl<CWebViewCoord, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IObjectWithSiteImpl<CWebViewCoord>
{
public:
    CWebViewCoord();
    ~CWebViewCoord();

DECLARE_REGISTRY_RESOURCEID(IDR_WEBVIEWCOORD)

BEGIN_COM_MAP(CWebViewCoord) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IWebView)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
END_COM_MAP()

    // IObjectWithSite overrides
    STDMETHOD(SetSite)(IUnknown *pClientSite);

private:
    //
    // Initialization helpers (including event sinks)
    //

    HRESULT InitFolderObjects(VOID);

    //
    // CDispatchEventSink overrides
    //

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr);

    // IWebView methods
    STDMETHOD(OnCSCClick)();
    STDMETHOD(CSCSynchronize)();
    STDMETHOD(OnCSCMouseOver)();
    STDMETHOD(OnCSCMouseOut)();

    
    //
    // Event handlers
    //

    STDMETHOD(OnWindowLoad)(VOID);
    STDMETHOD(OnWindowUnLoad)(VOID);
    STDMETHOD(OnFixSize)(VOID);

private:    
    HRESULT ReleaseFolderObjects(VOID);

    //
    // Objects in web view
    //
    
    CFileListWrapper  *m_pFileListWrapper;
    CThumbNailWrapper *m_pThumbNailWrapper;


    //
    // Host HTML window Dispatch
    //
    IDispatch * m_pdispWindow;
    
    //
    // Some frequently used interfaces
    //

    CComPtr<IHTMLDocument2>             m_spDocument;
    CComPtr<IHTMLElementCollection>     m_spDocAll;
    CComPtr<IHTMLControlElement>        m_spDocBody;
    CComPtr<IHTMLStyle>                 m_spFileListStyle;
    CComPtr<IHTMLStyle>                 m_spPanelStyle;
    CComPtr<IHTMLStyle>                 m_spRuleStyle;
    CComPtr<IHTMLStyle>                 m_spHeadingStyle;
    CComPtr<IHTMLElement>               m_spHeading;
    CComPtr<IOleClientSite>             m_spClientSite;

    //
    // Event sink advise cookies
    //

    DWORD           m_dwFileListAdviseCookie;   
    DWORD           m_dwThumbNailAdviseCookie;
    DWORD           m_dwHtmlWindowAdviseCookie;
    DWORD           m_dwCSCHotTrackCookie;
    BOOL            m_bRTLDocument;

};


/////////////////////////////////////////////////////////////////////////////
// CThumbNailWrapper

class CThumbNailWrapper : public CDispatchEventSink {
  public:       
    CThumbNailWrapper();
    ~CThumbNailWrapper();

    //
    // Initialization
    //

    HRESULT Init(CComPtr<IThumbCtl>         spThumbNailCtl,
                 CComPtr<IHTMLElement>      spThumbnailLabel);

    //
    // CDispatchEventSink overrides
    //

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr);


    //
    // Event Handlers
    //

    HRESULT OnThumbNailReady(VOID);

    //
    // Cover for properties
    //

    HRESULT UsedSpace(CComBSTR &bstrUsed);
    HRESULT TotalSpace(CComBSTR &bstrTotal);
    HRESULT FreeSpace(CComBSTR &bstrFree);

    CComPtr<IThumbCtl> Control(VOID)  {return m_spThumbNailCtl;};

    //
    // Methods
    //
    
    BOOL UpdateThumbNail(CComPtr<FolderItem> spFolderItems);
    HRESULT SetDisplay(CComBSTR &bstrDisplay);
    HRESULT SetHeight(int iHeight);
    HRESULT ClearThumbNail();

private:
    HRESULT _SetThumbnailLabel(CComBSTR& bstrLabel);

    // Pointer to the control + style
    CComPtr<IThumbCtl>      m_spThumbNailCtl;
    CComPtr<IHTMLElement>   m_spThumbnailLabel;
    CComPtr<IHTMLStyle>     m_spThumbNailStyle;
};

/////////////////////////////////////////////////////////////////////////////
// CFileListWrapper

class CFileListWrapper : public CDispatchEventSink {
public:
    CFileListWrapper();
    ~CFileListWrapper();

    // Initialization
    HRESULT Init(CComPtr<IShellFolderViewDual> spFileList,
                 CComPtr<IHTMLElement>         spInfo,
                 CComPtr<IHTMLElement>         spLinks,
                 CComPtr<IHTMLStyle>           spPanelStyle,
                 CComPtr<IHTMLElement>         spMediaPlayerSpan,
                 CComPtr<IHTMLElement>         spCSCPlusMin,
                 CComPtr<IHTMLElement>         spCSCText,
                 CComPtr<IHTMLElement>         spCSCDetail,
                 CComPtr<IHTMLElement>         spCSCButton,
                 CComPtr<IHTMLStyle>           spCSCStyle,
                 CComPtr<IHTMLStyle>           spCSCDetailStyle,
                 CComPtr<IHTMLStyle>           spCSCButtonStyle,
                 CComPtr<IHTMLDocument2>       spDocument,
                 CComPtr<IHTMLWindow2>         spWindow,
                 CThumbNailWrapper             *pThumbNailWrapper);
    
    // CDispatchEventSink overrides
    STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr);

    // Event Handlers
    HRESULT OnSelectionChanged(VOID);

    // Cover function for properties
    CComPtr<IShellFolderViewDual> Control(VOID) {return m_spFileList;};

    HRESULT SetDefaultPanelDisplay();
    HRESULT OnCSCClick();
    HRESULT CSCSynchronize();
    HRESULT OnCSCMouseOnOff(BOOL fOn);

    // Needs to be called by WVCoord, so public
    HRESULT AdviseWebviewLinks( BOOL fAdvise );

private:
    //
    // Object pointers
    //

    CComPtr<IShellFolderViewDual>     m_spFileList;
    CComPtr<IHTMLElement>             m_spInfo;
    CComPtr<IHTMLElement>             m_spLinks;
    CComPtr<IHTMLStyle>               m_spPanelStyle;
    CComPtr<IMediaPlayer>             m_spIMediaPlayer;
    CComPtr<IHTMLElement>             m_spMediaPlayerSpan;
    CComPtr<IHTMLStyle>               m_spMediaPlayerStyle;
    CComPtr<IHTMLElement>             m_spCSCPlusMin;
    CComPtr<IHTMLElement>             m_spCSCText;
    CComPtr<IHTMLElement>             m_spCSCDetail;
    CComPtr<IHTMLElement>             m_spCSCButton;
    CComPtr<IHTMLStyle>               m_spCSCStyle;
    CComPtr<IHTMLStyle>               m_spCSCDetailStyle;
    CComPtr<IHTMLStyle>               m_spCSCButtonStyle;
    CComPtr<IHTMLDocument2>           m_spDocument;
    CComPtr<IHTMLWindow2>             m_spWindow;
    CThumbNailWrapper                 *m_pThumbNailWrapper;
    CComPtr<Folder2>                  m_spFolder2;
    CComPtr<FolderItem>               m_spFolderItem;
    CComPtr<FolderItem2>              m_spFolderItem2;
    CComPtr<FolderItems>              m_spFolderItems;
    CComBSTR                          m_bstrInfoHTML;
    CComBSTR                          m_bstrCrossLinksHTML;
    BOOL                              m_bFoundAuthor;
    BOOL                              m_bFoundComment;
    BOOL                              m_bCSCDisplayed;
    BOOL                              m_bNeverGotPanelInfo;
    BOOL                              m_bExpanded;
    BOOL                              m_bHotTracked;
    DWORD                             m_dwDateFlags;
    BOOL                              m_bRTLDocument;
    BOOL                              m_bPathIsSlow;

    //
    // Helper functions
    //
    HRESULT ClearThumbNail();
    HRESULT StopMediaPlayer();
    HRESULT ClearMediaPlayer();
    HRESULT NoneSelected();
    HRESULT MultipleSelected(long cSelection);
    HRESULT OneSelected();
    HRESULT GetItemNameForDisplay();
    HRESULT GetItemType();
    HRESULT GetItemDateTime();
    HRESULT GetItemSize();
    HRESULT GetItemAttributes();
    HRESULT GetItemAuthor();
    HRESULT GetItemComment();
    HRESULT GetItemHTMLInfoTip();
    HRESULT GetOtherItemDetails();
    HRESULT GetItemInfoTip();
    HRESULT DealWithDriveInfo();
    HRESULT GetCrossLink(int nFolder, UINT uIDToolTip);
    HRESULT GetCrossLinks();
    HRESULT FormatCrossLink(LPCWSTR pwszDisplayName, LPCWSTR pwszUrlPath, UINT uIDToolTip);
    HRESULT DisplayInfoHTML();
    HRESULT DisplayCrossLinksHTML();
    HRESULT GetItemInfo(long lResId, LPWSTR wszInfoDescCanonical, CComBSTR& bstrInfoDesc, CComBSTR& bstrInfo);
    HRESULT IsItThisFolder(int nFolder, BOOL& bResult, LPWSTR pwszDisplayName, DWORD cchDisplayName, LPWSTR pwszPath, DWORD cchPath);
    HRESULT GetIMediaPlayer(CComPtr<IMediaPlayer>& spIMediaPlayer);
    // CSC functions
    HRESULT CSCGetStatusText(LONG lStatus, CComBSTR& bstrCSCText);
    HRESULT CSCGetStatusDetail(LONG lStatus, CComBSTR& bstrCSCDetail);
    HRESULT CSCGetStatusButton(LONG lStatus, CComBSTR& bstrCSCButton);
    HRESULT GetCSCFolderStatus(LONG* plStatus);
    HRESULT CSCShowStatusInfo();
    HRESULT CSCShowStatus_FoldExpand_Toggle();
    // Event handlers for setting status bar text
    HRESULT OnWebviewLinkEvent( BOOL fEnter );
    HRESULT GetEventAnchorElement(IHTMLEventObj *pEvent, IHTMLElement **ppElt);
    HRESULT GetWVLinksCollection( IHTMLElementCollection **ppCollection, long *pcLinks );
};


#endif //__WEBVIEWCOORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\cowsite.cpp ===
#include "priv.h"
#include "cowsite.h"

#if 0
// no default implementation for now.
// so far all clients do way more than this (e.g. deferred initialization)
// in their SetSite's.
HRESULT CObjectWithSite::SetSite(IUnknown punkSite)
{
    IUnknown_Set(&_punkSite, punkSite);
    return S_OK;
}
#endif

//***
// NOTES
//  iedisp.c!CIEFrameAutoProp::_SetValue calls us
HRESULT CObjectWithSite::GetSite(REFIID riid, void **ppvSite)
{
    // e.g. iedisp.c!CIEFrameAutoProp::_SetValue calls us
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;

#if 0 // here 'tis if we ever decide we need it...
    // e.g. iedisp.c!CIEFrameAutoProp::_SetValue calls us
    TraceMsg(DM_WARNING, "cows.gs: E_NOTIMPL");
    *ppvSite = NULL;
    return E_NOTIMPL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\deskbands.h ===
#ifndef DESKBANDS_H
#define DESKBANDS_H

const CATID * const c_DeskBandClasses[] = 
{
    &CLSID_Zaxxon,
    NULL
};

const CATID * const c_InfoBandClasses[] = 
{
    &CLSID_MegaMan,
    NULL
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\bands.h ===
#ifndef BANDS_H_
#define BANDS_H_

#include "cowsite.h"

// this is a virtual class!
class CToolBand : public IDeskBand, 
                  public CObjectWithSite,
                  public IPersistStream,
                  public IInputObject
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
                                             IUnknown* punkToolbarSite,
                                             BOOL fReserved);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi) PURE;

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);

    // *** IPersistStreamInit methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID) = 0;
    virtual STDMETHODIMP IsDirty(void);
    virtual STDMETHODIMP Load(IStream *pStm) = 0;
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty) = 0;
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);

protected:
    CToolBand();
    virtual ~CToolBand();

    HRESULT _BandInfoChanged();

    int         _cRef;
    HWND        _hwnd;
    HWND        _hwndParent;
    //IUnknown* CObjectWithSite::_punkSite;
    BOOL        _fCanFocus:1;   // we accept focus (see UIActivateIO)
    DWORD       _dwBandID;
};
#endif  // BANDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\bands.cpp ===
#include "priv.h"
#include "bands.h"

ULONG CToolBand::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CToolBand::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CToolBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CToolBand, IDeskBand),         // IID_IDeskBand
        QITABENTMULTI(CToolBand, IOleWindow, IDeskBand),        // IID_IOleWindod
        QITABENTMULTI(CToolBand, IDockingWindow, IDeskBand),    // IID_IDockingWindow
        QITABENT(CToolBand, IInputObject),      // IID_IInputObject
        QITABENT(CToolBand, IObjectWithSite),   // IID_IObjectWithSite
        QITABENT(CToolBand, IPersistStream),    // IID_IPersistStream
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CToolBand::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;

    if (*lphwnd)
        return(S_OK);
    else
        return(E_FAIL);
}

HRESULT CToolBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
    return E_NOTIMPL;
}

HRESULT CToolBand::HasFocusIO()
{
    HRESULT hres;
    HWND hwndFocus = GetFocus();

    hres = SHIsChildOrSelf(_hwnd, hwndFocus);
    return hres;
}

HRESULT CToolBand::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    if (!_fCanFocus) 
    {
        return S_FALSE;
    }

    if (fActivate) 
    {
//        UnkOnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
        SetFocus(_hwnd);
    }
    return S_OK;
}

// }

HRESULT CToolBand::ResizeBorderDW(LPCRECT prcBorder,
                                         IUnknown* punkToolbarSite,
                                         BOOL fReserved)
{
    return S_OK;
}


HRESULT CToolBand::ShowDW(BOOL fShow)
{
    return S_OK;
}

HRESULT CToolBand::SetSite(IUnknown *punkSite)
{
    if (punkSite != _punkSite) 
    {
        IUnknown_Set(&_punkSite, punkSite);
        IUnknown_GetWindow(_punkSite, &_hwndParent);
    }
    return S_OK;
}

HRESULT CToolBand::_BandInfoChanged()
{
    VARIANTARG v = {0};
    VARIANTARG* pv = NULL;
    if (_dwBandID != (DWORD)-1) 
    {
        v.vt = VT_I4;
        v.lVal = _dwBandID;
        pv = &v;
    }
    else 
    {
        // if this fires, fix your band's GetBandInfo to set _dwBandID.
        // o.w. it's a *big* perf loss since we refresh *all* bands rather
        // than just yours.
        // do *not* remove this ASSERT, bad perf *is* a bug.
        ASSERT(_dwBandID != (DWORD)-1);
    }
    return IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_BANDINFOCHANGED, 0, pv, NULL);
}

CToolBand::CToolBand() : _cRef(1)
{
    _dwBandID = (DWORD)-1;
    _hwnd = NULL;
    _hwndParent = NULL;
    _fCanFocus = TRUE;
    _dwBandID = -1;
    _punkSite = NULL;
    DllAddRef();
}

CToolBand::~CToolBand()
{
    DllRelease();
}

HRESULT CToolBand::CloseDW(DWORD dw)
{
    if (_hwnd) 
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
    
    return S_OK;
}

HRESULT CToolBand::IsDirty(void)
{
    return S_FALSE;     // never be dirty
}

HRESULT CToolBand::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\cowsite.h ===
#ifndef _COWSITE_H_
#define _COWSITE_H_

// this is a virtual class
// (since pretty much everyone overrides SetSite)

class CObjectWithSite : public IObjectWithSite
{
public:
    //*** IUnknown ****
    // (client must provide!)

    //*** IObjectWithSite ***
    virtual STDMETHODIMP SetSite(IUnknown *punkSite) = 0;
    virtual STDMETHODIMP GetSite(REFIID riid, void **ppvSite);

protected:
    IUnknown*   _punkSite;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\wizhost\wizhost.cpp ===
#include "windows.h"
#include "shlwapi.h"
#include "shpriv.h"
#include "commctrl.h"
#include "resource.h"
#include "ccstock.h"
#include "shlguid.h"


// globals and classes

HINSTANCE g_hAppInst;           // instance information for the wizard
HWND g_hwndFrame;               // wizard frame (cached on startup)
IWebWizardExtension *g_pwe;        // IWizardExtension (we want to show)


// IWizardSite
// -----------
//
// This object is used by the wizard extension to navigate in and out of the
// main wizard.   When the wizard extension has finished displaying its set
// of pages (and recieves its final PSN_WIZNEXT or PSN_WIZBACK) it is 
// responsible for calling the site to navigate in and out of the 
// stack of pages.

class CWizSite : public IWizardSite, IServiceProvider
{
public:
    CWizSite(IPropertyBag *ppb);
    ~CWizSite();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IWizardSite
    STDMETHODIMP GetPreviousPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetNextPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetCancelledPage(HPROPSHEETPAGE *phPage)
        { return E_NOTIMPL; }

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

private:
    LONG _cRef;
    IPropertyBag *_ppb;
};


// reference counting of the object

ULONG CWizSite::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CWizSite::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CWizSite::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CWizSite, IWizardSite),       // IID_IWizardSite
        QITABENT(CWizSite, IServiceProvider),  // IID_IServiceProvider
        {0},
    };
    return QISearch(this, qit, riid, ppv);
}


// instance creation

CWizSite::CWizSite(IPropertyBag *ppb) :
    _cRef(1),
    _ppb(ppb)
{
    ppb->AddRef();
}

CWizSite::~CWizSite()
{
    ATOMICRELEASE(_ppb);
}

HRESULT CWizSite_CreateInstance(IPropertyBag *ppb, REFIID riid, void **ppv)
{
    CWizSite *pws = new CWizSite(ppb);
    if (!pws)
        return E_OUTOFMEMORY;

    HRESULT hr = pws->QueryInterface(riid, ppv);
    pws->Release();
    return hr;
}


// methods for returning our page range

HRESULT CWizSite::GetPreviousPage(HPROPSHEETPAGE *phPage)
{
    int i = PropSheet_IdToIndex(g_hwndFrame, IDD_WELCOME);
    *phPage = PropSheet_IndexToPage(g_hwndFrame, i);
    return S_OK;
}

HRESULT CWizSite::GetNextPage(HPROPSHEETPAGE *phPage)
{
    int i = PropSheet_IdToIndex(g_hwndFrame, IDD_DONE);
    *phPage = PropSheet_IndexToPage(g_hwndFrame, i);
    return S_OK;
}

// Service provider object

HRESULT CWizSite::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    *ppv = NULL;                // no result yet

    if (guidService == SID_PublishingWizard)
    {
        if (riid == IID_IPropertyBag)
            return _ppb->QueryInterface(riid, ppv);
    }

    return E_FAIL;
}



// Sample dialog proc's for the welcome and done pages (these then call into
// the wizard extension to show their pages).

BOOL _HandleWizNextBack(HWND hwnd, HPROPSHEETPAGE hpage)
{
    PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
    return TRUE;
}

INT_PTR _WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            g_hwndFrame = GetParent(hwnd);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                    PropSheet_SetWizButtons(g_hwndFrame, PSWIZB_NEXT);
                    return TRUE;              

                case PSN_WIZNEXT:
                {
                    HPROPSHEETPAGE hpage;
                    g_pwe->GetFirstPage(&hpage);
                    return _HandleWizNextBack(hwnd, hpage);
                }
            }
            break;
        }
    }

    return FALSE;
}

INT_PTR _DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                    PropSheet_SetWizButtons(g_hwndFrame, PSWIZB_FINISH | PSWIZB_BACK);
                    return TRUE;              

                case PSN_WIZBACK:
                {
                    HPROPSHEETPAGE hpage;
                    g_pwe->GetLastPage(&hpage);
                    return _HandleWizNextBack(hwnd, hpage);
                }
            }
            break;
        }
    }

    return FALSE;
}



// Our Wizard, its very simple.

#define WIZDLG(name, dlgproc, dwFlags)   \
    { MAKEINTRESOURCE(IDD_##name##), dlgproc, MAKEINTRESOURCE(IDS_##name##), MAKEINTRESOURCE(IDS_##name##_SUB), dwFlags }

const struct
{
    LPCWSTR idPage;
    DLGPROC pDlgProc;
    LPCWSTR pHeading;
    LPCWSTR pSubHeading;
    DWORD dwFlags;
}
c_pages[] =
{
    WIZDLG(WELCOME, _WelcomeDlgProc, 0x0),
    WIZDLG(DONE,    _DoneDlgProc,    0x0),
};

HRESULT _InitExtensionSite(IWizardExtension *pwe)
{
    IPropertyBag *ppb;
    HRESULT hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &ppb));
    if (SUCCEEDED(hr))
    {
        IWizardSite *pws;
        hr = CWizSite_CreateInstance(ppb, IID_PPV_ARG(IWizardSite, &pws));
        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(pwe, pws);
            pws->Release();
        }
        ppb->Release();
    }
    return hr;
}

int APIENTRY WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    g_hAppInst = hInstance;

    CoInitialize(NULL);
    InitCommonControls();

    // For our example we will create the Publishing Wizard, it supports IWizardExtension and
    // we will host its pages within ours.

    HRESULT hr = CoCreateInstance(CLSID_WebWizardHost, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IWebWizardExtension, &g_pwe));
    if (SUCCEEDED(hr))
    {
        hr = _InitExtensionSite(g_pwe);
        if (SUCCEEDED(hr))
        {
            // Create our pages, these are placed at the top of the array,
            // the extensions are placed after.

            HPROPSHEETPAGE hpages[10] = { 0 };
            for (int i = 0; i < ARRAYSIZE(c_pages) ; i++ )
            {                           
                PROPSHEETPAGE psp = { 0 };
                psp.dwSize = sizeof(psp);
                psp.hInstance = g_hAppInst;
                psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | 
                              PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE |
                              c_pages[i].dwFlags;

                psp.pszTemplate = c_pages[i].idPage;
                psp.pfnDlgProc = c_pages[i].pDlgProc;
                psp.pszTitle = TEXT("Wizard Hosting Example");
                psp.pszHeaderTitle = c_pages[i].pHeading;
                psp.pszHeaderSubTitle = c_pages[i].pSubHeading;
                hpages[i] = CreatePropertySheetPage(&psp);
            }


            // Fill out the structure for the property sheet, we indicate
            // that we want this to behave like a wizard.
        
            PROPSHEETHEADER psh = { 0 };
            psh.dwSize = sizeof(psh);
            psh.hInstance = g_hAppInst;
            psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_HEADER;
            psh.pszbmHeader = MAKEINTRESOURCE(IDB_BANNER);
            psh.phpage = hpages;
            psh.nPages = i;


            // Let the extension add its pages it will append an array of
            // HPROPSHEETPAGE to the structure, it also return the count.

            UINT nPages;
            hr = g_pwe->AddPages(&hpages[i], ARRAYSIZE(hpages)-i, &nPages);
            if (SUCCEEDED(hr))
            {
                psh.nPages = i+nPages;

                TCHAR szPath[MAX_PATH];
                GetModuleFileName(NULL, szPath, ARRAYSIZE(szPath));
                PathRenameExtension(szPath, TEXT(".htm"));

                WCHAR szURL[128];
                DWORD cch = ARRAYSIZE(szURL);
                UrlCreateFromPath(szPath, szURL, &cch, 0);

                g_pwe->SetInitialURL(szURL);

                PropertySheet(&psh);
            }
        }
        g_pwe->Release();
        g_pwe = NULL;
    }

    CoUninitialize();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\guids.h ===
#ifndef GUIDS_H
#define GUIDS_H

// {65F411C7-F4EE-11d2-9B7D-00C04FB16A21}
DEFINE_GUID(CLSID_Zaxxon,                   0x65f411c7, 0xf4ee, 0x11d2, 0x9b, 0x7d, 0x0, 0xc0, 0x4f, 0xb1, 0x6a, 0x21);

// {F35210F0-F6CC-11d2-9B82-00C04FB16A21}
DEFINE_GUID(CLSID_MegaMan,           0xf35210f0, 0xf6cc, 0x11d2, 0x9b, 0x82, 0x0, 0xc0, 0x4f, 0xb1, 0x6a, 0x21);

// {1644FB22-065B-11d3-9B91-00C04FB16A21}
//DEFINE_GUID(CLSID_ZaxxonPlayer,             0x1644fb22, 0x65b, 0x11d3, 0x9b, 0x91, 0x0, 0xc0, 0x4f, 0xb1, 0x6a, 0x21);

#ifdef INITSCID
#define DEFINE_SCID(name, fmtid, pid) extern "C" const SHCOLUMNID name = { fmtid, pid }
#else
#define DEFINE_SCID(name, fmtid, pid) extern "C" const SHCOLUMNID name
#endif

DEFINE_SCID(SCID_MUSIC_Artist,    PSGUID_MUSIC, PIDSI_ARTIST);
DEFINE_SCID(SCID_MUSIC_Album,     PSGUID_MUSIC, PIDSI_ALBUM);
DEFINE_SCID(SCID_AUDIO_Duration,     PSGUID_AUDIO, PIDASI_TIMELENGTH);
DEFINE_SCID(SCID_Title,         PSGUID_SUMMARYINFORMATION, PIDSI_TITLE);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\resource.h ===
// Resource IDs for FTPFOLDR
//

#define IDS_COMCAT_DESKBANDS            50
#define IDS_COMCAT_INFOBANDS            60
#define IDB_ZAXXONHOT                   100
#define IDB_ZAXXONDEF                   101
#define IDD_ZAXXON                      102
#define IDC_ARTIST                      103
#define IDC_ALBUM                       104
#define IDC_SLIDER                      105
#define IDC_STATIC                      -1
#define IDC_THUMBNAIL                   106
#define IDC_SONG                        107
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\megaman.cpp ===
#include "priv.h"
#include "zaxxon.h"
#include "guids.h"
#include "shlwapip.h"
#include "mmreg.h"
#include "mmstream.h"	// Multimedia stream interfaces
#include "amstream.h"	// DirectShow multimedia stream interfaces
#include "ddstream.h"	// DirectDraw multimedia stream interfaces

#include "bands.h"
#include "sccls.h"
#include "power.h"

class CMegaMan : public CToolBand,
                public IWinEventHandler
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CToolBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CToolBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * phwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL bEnterMode) {return E_NOTIMPL;};

    // *** IDeskBar methods ***
    virtual STDMETHODIMP SetClient(IUnknown* punk) { return E_NOTIMPL; };
    virtual STDMETHODIMP GetClient(IUnknown** ppunkClient) { return E_NOTIMPL; };
    virtual STDMETHODIMP OnPosRectChangeDB (LPRECT prc) { return E_NOTIMPL;};

    // ** IWinEventHandler ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);
    
    // *** IInputObject methods (override) ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);


    CMegaMan();
private:
    virtual ~CMegaMan();

    HWND _CreateWindow(HWND hwndParent);

    friend HRESULT CMegaMan_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
};


CMegaMan::CMegaMan()
{


}

CMegaMan::~CMegaMan()
{

}


HWND CMegaMan::_CreateWindow(HWND hwndParent)
{
    if (_hwnd)
        return _hwnd;


    _hwnd = CreateWindow(TEXT("Button"), TEXT("Sup"),
                             WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT |
                             WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                             0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, NULL);



    return _hwnd;
}


STDMETHODIMP CMegaMan::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMegaMan, IWinEventHandler),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
        hres = CToolBand::QueryInterface(riid, ppvObj);

    return hres;
}

STDMETHODIMP CMegaMan::GetWindow(HWND * phwnd)
{

    *phwnd = _CreateWindow(_hwndParent);

    return *phwnd? S_OK : E_FAIL;
}

STDMETHODIMP CMegaMan::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                       DESKBANDINFO* pdbi)
{

    UINT ucy = 50;
    UINT ucx = 50; 

#if 0
    if (fViewMode & (DBIF_VIEWMODE_FLOATING |DBIF_VIEWMODE_VERTICAL))
    {

    }
    else
    {
    }
#endif

    _dwBandID = dwBandID;

    pdbi->ptMinSize.x = 0;
    pdbi->ptMinSize.y = ucy;

    pdbi->ptMaxSize.y = -1;
    pdbi->ptMaxSize.x = 32000;

    pdbi->ptActual.y = 0;
    pdbi->ptActual.x = 0;

    pdbi->ptIntegral.y = 1;
    pdbi->ptIntegral.x = 1;

    if (pdbi->dwMask & DBIM_TITLE)
    {
        StrCpy(pdbi->wszTitle, TEXT("MegaMan"));
    }

    return S_OK;
}

STDMETHODIMP CMegaMan::ShowDW(BOOL fShow)
{
    return CToolBand::ShowDW(fShow);
}

STDMETHODIMP CMegaMan::CloseDW(DWORD dw)
{
    return CToolBand::CloseDW(dw);
}


STDMETHODIMP CMegaMan::TranslateAcceleratorIO(LPMSG lpMsg)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMegaMan::HasFocusIO()
{
    return E_NOTIMPL;
}

STDMETHODIMP CMegaMan::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    return S_OK;
}


STDMETHODIMP CMegaMan::IsWindowOwner(HWND hwnd)
{
    return (hwnd == _hwnd)? S_OK : S_FALSE;
}

STDMETHODIMP CMegaMan::OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{

    HRESULT hres = S_FALSE;
    return hres;
}


HRESULT CMegaMan_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;
    CMegaMan *pmm = new CMegaMan;
    if (pmm)
    {
        hr = pmm->QueryInterface(riid, ppv);
        pmm->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppv = NULL;
    }
    return hr;
}


STDMETHODIMP CMegaMan::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_MegaMan;

    return S_OK;
}

STDMETHODIMP CMegaMan::Load(IStream *pStm)
{
    return S_OK;
}

STDMETHODIMP CMegaMan::Save(IStream *pStm, BOOL fClearDirty)
{
    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\powertoy.cpp ===
/*****************************************************************************
 *
 *	Powertoy.cpp - Powertoy bookkeeping
 *
 *****************************************************************************/

#include "priv.h"
#define DECL_CRTFREE
#include <crtfree.h>

/*****************************************************************************
 *
 *	Dynamic Globals.  There should be as few of these as possible.
 *
 *	All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef = 0;			/* Global reference count */
CRITICAL_SECTION g_csDll;	/* The shared critical section */
HINSTANCE g_hinst = NULL;

#ifdef DEBUG
DWORD g_TlsMem = 0xffffffff;
#endif // DEBUG

/*****************************************************************************
 *
 *	DllAddRef / DllRelease
 *
 *	Maintain the DLL reference count.
 *
 *****************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *	DllGetClassObject
 *
 *	OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *	The artificial refcount inside DllGetClassObject helps to
 *	avoid the race condition described in DllCanUnloadNow.  It's
 *	not perfect, but it makes the race window much smaller.
 *
 *****************************************************************************/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    DllAddRef();
	hres = CFactory_Create(rclsid, riid, ppvObj);
    DllRelease();
    return hres;
}

/*****************************************************************************
 *
 *	DllCanUnloadNow
 *
 *	OLE entry point.  Fail iff there are outstanding refs.
 *
 *	There is an unavoidable race condition between DllCanUnloadNow
 *	and the creation of a new IClassFactory:  Between the time we
 *	return from DllCanUnloadNow() and the caller inspects the value,
 *	another thread in the same process may decide to call
 *	DllGetClassObject, thus suddenly creating an object in this DLL
 *	when there previously was none.
 *
 *	It is the caller's responsibility to prepare for this possibility;
 *	there is nothing we can do about it.
 *
 *****************************************************************************/

STDMETHODIMP DllCanUnloadNow(void)
{
    HRESULT hres;

    ENTERCRITICAL;

    hres = g_cRef ? S_FALSE : S_OK;

    TraceMsg(TF_LIFE, "DllCanUnloadNow() returning hres=%#08lx. (S_OK means yes)", hres);

    LEAVECRITICAL;

    return hres;
}


/*****************************************************************************
 *
 *	Entry32
 *
 *	DLL entry point.
 *
 *	On a thread detach, must check if the thread owns any
 *	global timeouts.  If so, we must transfer the timeout to another
 *	thread or something.
 *
 *****************************************************************************/
STDAPI_(BOOL) DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    static s_hresOle = E_FAIL;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        InitializeCriticalSection(&g_csDll);
        g_hinst = hinst;
        DisableThreadLibraryCalls(hinst);
        SHFusionInitializeFromModule(hinst);
        break;

    case DLL_PROCESS_DETACH:
        SHFusionUninitialize();
        DeleteCriticalSection(&g_csDll);
        break;
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\powertoycf.cpp ===
/*****************************************************************************
 *
 *	powertoycf.cpp - IClassFactory interface
 *
 *****************************************************************************/

#include "priv.h"
#define INITSCID
#include <initguid.h>
#include "guids.h"
#include "sccls.h"
#include "power.h"
#include "power_i.c"
// Need this so the GUIDs are defined
#include <mmsystem.h>
#include <amstream.h>
#include "dsound.h"

typedef HRESULT (*PFNCREATE)(IUnknown*, REFIID, LPVOID*);
typedef struct
{
    const GUID* pclsid;
    PFNCREATE pfnCreate;
} CLASSFACTORYENTRY;

static const CLASSFACTORYENTRY
g_InProcCreateList[] =  
{
    {&CLSID_Zaxxon,            CZaxxon_CreateInstance},
    {&CLSID_ZaxxonPlayer,      CZaxxonPlayer_CreateInstance},
    {&CLSID_MegaMan,           CMegaMan_CreateInstance},
    {0,0},
};

/*****************************************************************************
 *	IClassFactory::CreateInstance
 *****************************************************************************/

HRESULT CFactory::CreateInstance(IUnknown * punkOuter, REFIID riid, void ** ppv)
{
    HRESULT hres = E_INVALIDARG;

    if (!punkOuter)
    {
        const CLASSFACTORYENTRY* pcf = g_InProcCreateList;
        int i = 0;
        while (pcf[i].pfnCreate)
        {
            if (IsEqualCLSID(_rclsid, *pcf[i].pclsid))
            {
                hres = pcf[i].pfnCreate(punkOuter, riid, ppv);
                break;
            }
            i++;
        }
    }
    else
    {
	    hres = CLASS_E_NOAGGREGATION;
    }

    return hres;
}

/*****************************************************************************
 *
 *	IClassFactory::LockServer
 *
 *	What a stupid function.  Locking the server is identical to
 *	creating an object and not releasing it until you want to unlock
 *	the server.
 *
 *****************************************************************************/

HRESULT CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    
    return S_OK;
}

HRESULT CFactory_Create(REFCLSID rclsid, REFIID riid, void ** ppv)
{
    HRESULT hres;
    
    if (IsEqualCLSID(riid, IID_IClassFactory))
    {
        *ppv = (LPVOID) new CFactory(rclsid);
        hres = (*ppv) ? S_OK : E_OUTOFMEMORY;
    }
    else
        hres = E_NOINTERFACE;
    
    return hres;
}


CFactory::CFactory(REFCLSID rclsid) : _cRef(1)
{
    _rclsid = rclsid;
    DllAddRef();
}

CFactory::~CFactory()
{
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CFactory::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CFactory::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CFactory::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualCLSID(riid, IID_IUnknown) || IsEqualCLSID(riid, IID_IClassFactory))
    {
        *ppv = SAFECAST(this, IClassFactory *);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\dllreg.cpp ===
// dllreg.cpp -- autmatic registration and unregistration
//
#include "priv.h"
#include "guids.h"
//#include "installwv.h"

#include <advpub.h>
#include <comcat.h>
//#include <msieftp.h>

#include "Deskbands.h"



// helper macros

// ADVPACK will return E_UNEXPECTED if you try to uninstall (which does a registry restore)
// on an INF section that was never installed.  We uninstall sections that may never have
// been installed, so this MACRO will quiet these errors.
#define QuietInstallNoOp(hr)   ((E_UNEXPECTED == hr) ? S_OK : hr)


const CHAR  c_szIexploreKey[]         = "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE";

/*----------------------------------------------------------
Purpose: Queries the registry for the location of the path
         of Internet Explorer and returns it in pszBuf.

Returns: TRUE on success
         FALSE if path cannot be determined

Cond:    --
*/
BOOL
GetIEPath(
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf)
{
    BOOL bRet = FALSE;
    HKEY hkey;

    *pszBuf = '\0';

    // Get the path of Internet Explorer 
    if (NO_ERROR != RegOpenKeyA(HKEY_LOCAL_MACHINE, c_szIexploreKey, &hkey))  
    {
    }
    else
    {
        DWORD cbBrowser;
        DWORD dwType;

        lstrcatA(pszBuf, "\"");

        cbBrowser = CbFromCchA(cchBuf - lstrlenA(" -nohome") - 4);
        if (NO_ERROR != RegQueryValueExA(hkey, "", NULL, &dwType, 
                                         (LPBYTE)&pszBuf[1], &cbBrowser))
        {
        }
        else
        {
            bRet = TRUE;
        }

        lstrcatA(pszBuf, "\"");

        RegCloseKey(hkey);
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

Returns: 
Cond:    --
*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szIEPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "MSIEXPLORE", szIEPath },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            // Get the location of iexplore from the registry
            if ( !EVAL(GetIEPath(szIEPath, ARRAYSIZE(szIEPath))) )
            {
                // Failed, just say "iexplore"
                lstrcpyA(szIEPath, "iexplore.exe");
            }

#if 0 //  Disable ---------------------
            if (g_fRunningOnNT)
            {
                // If on NT, we want custom action for %25% %11%
                // so that it uses %SystemRoot% in writing the
                // path to the registry.
                stReg.cEntries += 2;
            }
#endif // 0 

            hr = pfnri(g_hinst, szSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    // (The inf engine doesn't guarantee DelReg/AddReg order, that's
    // why we explicitly unreg and reg here.)
    //
    HINSTANCE hinstFTP = LoadLibrary(TEXT("MSIEFTP.DLL"));
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    hr = CallRegInstall("ShellExtensionInstall");

    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    if (EVAL(hinstFTP))     // We need hinstFTP or we can't install the webview files.
        FreeLibrary(hinstFTP);

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    // UnInstall the registry values
    hr = CallRegInstall("FtpShellExtensionUninstall");

    return hr;
}



void RegisterOneCategory(const CATID *pcatidCat, UINT idResCat, const CATID * const *pcatidImpl, BOOL fRegister)
{
    ICatRegister* pcr;
    HRESULT hres = CoCreateInstance(CLSID_StdComponentCategoriesMgr, NULL,
                                    CLSCTX_INPROC_SERVER, IID_ICatRegister, (LPVOID*)&pcr);
    
    if (pcr) 
    {
        if (fRegister) 
        {
            // register the category
            CATEGORYINFO catinfo = {0};
            catinfo.catid = *pcatidCat;
            catinfo.lcid = LOCALE_USER_DEFAULT;

            LoadString(HINST_THISDLL, idResCat, catinfo.szDescription, ARRAYSIZE(catinfo.szDescription));

            hres = pcr->RegisterCategories(1, &catinfo);
            
            // register the classes that implement categories
            for ( ; *pcatidImpl != NULL; pcatidImpl++) 
            {
                CLSID clsid = **pcatidImpl;
                CATID catid = *pcatidCat;
                hres = pcr->RegisterClassImplCategories(clsid, 1, &catid);
            }
            
        } 

#if 0
        else 
        {
            
            // unregister the classes that implement categories
            for ( ; *pcatidImpl != NULL; pcatidImpl++) 
            {
                CLSID clsid = **pcatidImpl;
                CATID catid = *pcatidCat;

                hres = pcr->UnRegisterClassImplCategories(clsid, 1, &catid);
            }
            
            if (eRegister == CCR_UNREG) {
                // unregister the category
                CATID catid = *pcatidCat;
                hres = pcr->UnRegisterCategories(1, &catid);
            }
            
        }
#endif
        pcr->Release();
    }
}

void RegisterCategories(BOOL fRegister)
{
    RegisterOneCategory(&CATID_DeskBand, IDS_COMCAT_DESKBANDS, c_DeskBandClasses, fRegister);
    RegisterOneCategory(&CATID_InfoBand, IDS_COMCAT_DESKBANDS, c_InfoBandClasses, fRegister);
}



/*----------------------------------------------------------
Purpose: Install/uninstall user settings

Description: Note that this function has special error handling.
             The function will keep hrExternal with the worse error
             but will only stop executing util the internal error (hr)
             gets really bad.  This is because we need the external
             error to catch incorrectly authored INFs but the internal
             error to be robust in attempting to install other INF sections
             even if one doesn't make it.
*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    RegisterCategories(bInstall);
    return S_OK;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\priv.h ===
#ifndef _PRIV_H_
#define _PRIV_H_

// This is a reverse integration test
// Testing the branches.  - lamadio

/*****************************************************************************
 *
 *      Global Includes
 *
 *****************************************************************************/

#define WIN32_LEAN_AND_MEAN
#define NOIME
#define NOSERVICE

#define _OLEAUT32_      // get DECLSPEC_IMPORT stuff right, we are defing these
#define _FSMENU_        // for DECLSPEC_IMPORT
#define _WINMM_         // for DECLSPEC_IMPORT in mmsystem.h
#define _SHDOCVW_       // for DECLSPEC_IMPORT in shlobj.h
#define _WINX32_        // get DECLSPEC_IMPORT stuff right for WININET API

#define _URLCACHEAPI_   // get DECLSPEC_IMPORT stuff right for wininet urlcache
#define STRICT

#define POST_IE5_BETA
//#include <w95wraps.h>

#include <windows.h>

#ifdef  RC_INVOKED              /* Define some tags to speed up rc.exe */
#define __RPCNDR_H__            /* Don't need RPC network data representation */
#define __RPC_H__               /* Don't need RPC */
#include <oleidl.h>             /* Get the DROPEFFECT stuff */
#define _OLE2_H_                /* But none of the rest */
#define _WINDEF_
#define _WINBASE_
#define _WINGDI_
#define NONLS
#define _WINCON_
#define _WINREG_
#define _WINNETWK_
#define _INC_COMMCTRL
#define _INC_SHELLAPI
#define _SHSEMIP_H_             /* _UNDOCUMENTED_: Internal header */
#else // RC_INVOKED
#include <windowsx.h>
#endif // RC_INVOKED


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#include "resource.h"

#define _FIX_ENABLEMODELESS_CONFLICT  // for shlobj.h
//WinInet need to be included BEFORE ShlObjp.h
#include <wininet.h>
#include <urlmon.h>
#include <shlobj.h>
#include <exdisp.h>
#include <objidl.h>

#include <shlwapi.h>
#include <shlwapip.h>

#include <shellapi.h>

#include <shsemip.h>
#include <crtfree.h>

#include <ole2ver.h>
#include <olectl.h>
#include <shellp.h>
#include <shdocvw.h>
#include <shguidp.h>
#include <isguids.h>
#include <shdguid.h>
#include <mimeinfo.h>
#include <hlguids.h>
#include <mshtmdid.h>
#include <dispex.h>     // IDispatchEx
#include <perhist.h>


#include <help.h>
#include <krnlcmn.h>    // GetProcessDword

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <urlhist.h>

#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#define USE_SYSTEM_URL_MONIKER
#include <urlmon.h>
//#include <winineti.h>    // Cache APIs & structures
#include <inetreg.h>

#define _INTSHCUT_    // get DECLSPEC_IMPORT stuff right for INTSHCUT.h
#include <intshcut.h>

#include <propset.h>        // BUGBUG (scotth): remove this once OLE adds an official header

#define HLINK_NO_GUIDS
#include <hlink.h>
#include <hliface.h>
#include <docobj.h>
#include <ccstock.h>
#include <port32.h>

#include <commctrl.h>
#include <comctrlp.h>
#include <shfusion.h>

// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))


#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))


#ifdef DEBUG
#define DEBUG_CODE(x)            x
#else // DEBUG
#define DEBUG_CODE(x)
#endif // DEBUG

extern HINSTANCE g_hinst;
#define HINST_THISDLL g_hinst


void DllAddRef(void);
void DllRelease(void);

#define TF_LIFE                 0x10000000
#define TF_ALLOCCATIONS         0x20000000

HRESULT CFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);


#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\sccls.h ===
#ifndef SCCLS_H
#define SCCLS_H

STDAPI CZaxxon_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
STDAPI CZaxxonPlayer_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
STDAPI CMegaMan_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
/*****************************************************************************
 *
 *	CFactory
 *
 *
 *****************************************************************************/

class CFactory       : public IClassFactory
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    
    // *** IClassFactory ***
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv);
    virtual STDMETHODIMP LockServer(BOOL fLock);

public:
    CFactory(REFCLSID rclsid);

    // Friend Functions
    friend HRESULT CFactory_Create(REFCLSID rclsid, REFIID riid, void ** ppv);

protected:
    ~CFactory(void);
    int                     _cRef;
    CLSID                   _rclsid;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)
PRECOMPILED_CXX = 1

SELFREGNAME     = ..\selfreg.inf

# Generate the selfreg file before compiling the RC file
NTTARGETFILE0  = $(SELFREGNAME)

!include $(CCSHELL_DIR)\common.inc

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

NO_BROWSER_FILE = 1

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
INCLUDES        = $(CCSHELL_DIR)\publish\inc\$(O);$(INCLUDES)

PASS0_HEADERDIR = ..
PASS0_SOURCEDIR = ..

MIDL_UUIDDIR    = .
MIDL_NO_ROBUST  = 1
MIDL_OPTIMIZATION=$(MIDL_OPTIMIZATION:-Oicf=) -Oicf

TARGETNAME      = Zaxxon
TARGETPATH      = obj
TARGETTYPE      = DYNLINK

# make sure shlwapi.lib is before shell32.lib for override.
TARGETLIBS      = $(SDK_LIB_PATH)\gdi32.lib               \
                  $(SDK_LIB_PATH)\user32.lib              \
                  $(SDK_LIB_PATH)\kernel32.lib            \
                  $(SDK_LIB_PATH)\ole32.lib               \
                  $(SDK_LIB_PATH)\oleaut32.lib            \
                  $(SDK_LIB_PATH)\uuid.lib                \
                  $(SHELL_LIB_PATH)\shlwapip.lib	      \
                  $(SHELL_LIB_PATH)\shell32p.lib	      \
                  $(SHELL_LIB_PATH)\shfusion.lib           \
                  $(SDK_LIB_PATH)\advapi32.lib            \
                  $(CCSHELL_DIR)\lib\$(O)\shguid.lib      \
                  $(CCSHELL_DIR)\lib\$(O)\shguidp.lib     \
                  $(SDK_LIB_PATH)\winmm.lib               \
                  $(SDK_LIB_PATH)\amstrmid.lib            \
                  $(SDK_LIB_PATH)\dsound.lib              \
                  $(SDK_LIB_PATH)\uxtheme.lib              \
                  $(CCSHELL_DIR)\lib\$(O)\stock.lib    \

USE_MSVCRT      = 1
DLLENTRY        = _DllMainCRTStartup

DLLDEF          = $(O)\powertoy.def
DLLBASE         = 0x71200000

PRECOMPILED_INCLUDE = ..\priv.h

NTTARGETFILE0   = ..\power.h

SOURCES         = \
                  ..\power.idl            \
                  ..\bands.cpp            \
                  ..\cowsite.cpp          \
                  ..\debug.cpp            \
                  ..\dllreg.cpp           \
                  ..\megaman.cpp          \
                  ..\powertoy.cpp         \
                  ..\powertoycf.cpp       \
                  ..\resource.rc          \
                  ..\zaxxoneditor.cpp     \
                  ..\zaxxon.cpp           \
                  ..\zaxxonpl.cpp

SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=WindowsShell.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\dll\makefile.inc ===
#clean:
#    -del /F /Q $(NTTARGETFILE0)
#    -del /F /Q $(NTTARGETFILES)


# These are the dependencies that the RC file has
#
..\resource.rc: $(SELFREGNAME)


!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\zaxxon.cpp ===
#include "priv.h"
#include "zaxxon.h"
#include "guids.h"
#include "shlwapip.h"
#include "mmreg.h"
#include "mmstream.h"	// Multimedia stream interfaces
#include "amstream.h"	// DirectShow multimedia stream interfaces
#include "ddstream.h"	// DirectDraw multimedia stream interfaces
#include "resource.h"
#include "varutil.h"
#include "runtask.h"

#define COLOR3d  (COLORREF)GetSysColor(COLOR_3DFACE)
#define COLORMASK (COLORREF)RGB( 255, 0, 255 )

#define PREV        0
#define PLAY        1
#define PAUSE       2
#define STOP        3
#define NEXT        4
#define MENU        5


void PlayMP3(LPTSTR pszFilename);

const TCHAR* g_crgstrStrings    =   TEXT("Play\0Pause\0Stop\0Previous\0Next\0Menu\0\0");

const TBBUTTON g_crgButtons[] =
{
    {PLAY,  PLAY,  TBSTATE_ENABLED, BTNS_BUTTON, 0, 0},
    {PREV,  PREV,  TBSTATE_ENABLED, BTNS_BUTTON, 0, 0},
    {NEXT,  NEXT,  TBSTATE_ENABLED, BTNS_BUTTON, 0, 0},
    {MENU,  MENU,  TBSTATE_ENABLED, BTNS_BUTTON, 0, 0},
};


#define WMP_CONTROLS_COUNT 6

int GetButtonsWidth(HWND hwndTB)
{
    LONG lButton = SendMessage(hwndTB, TB_GETBUTTONSIZE, 0, 0L);
    return HIWORD(lButton) * SendMessage(hwndTB, TB_BUTTONCOUNT, 0, 0) + 1;
}

void CenterOnTopOf(BOOL fToolbar, HWND hwnd, HWND hwndOn)
{
    RECT rcParent;
    RECT rcSelf;
    HMONITOR hmon;

    GetWindowRect(hwnd, &rcSelf);
    GetWindowRect(hwndOn, &rcParent);
    if (fToolbar)
        rcParent.right = rcParent.left + GetButtonsWidth(hwndOn);

    int x = rcParent.left + (RECTWIDTH(rcParent) - RECTWIDTH(rcSelf))/2;
    int y = rcParent.top - RECTHEIGHT(rcSelf);

    hmon = MonitorFromWindow(hwndOn, MONITOR_DEFAULTTONEAREST);
    if (hmon)
    {
        MONITORINFO mi;
        mi.cbSize = sizeof(mi);
        if (GetMonitorInfo(hmon, &mi))
        {
            if (x < mi.rcMonitor.left)
                x = mi.rcMonitor.left;

            if (y < mi.rcMonitor.top)
            {
                // Go below
                y = rcParent.bottom;
            }

            if (y + RECTHEIGHT(rcSelf) > mi.rcMonitor.bottom)
                y =  mi.rcMonitor.bottom - RECTHEIGHT(rcSelf);

            if (x + RECTWIDTH(rcSelf) > mi.rcMonitor.right)
                x = mi.rcMonitor.right - RECTWIDTH(rcSelf);
        }
    }

    SetWindowPos(hwnd, NULL, x, y, 0, 0, SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOSIZE);
}

void FillRectClr(HDC hdc, PRECT prc, COLORREF clr)
{
    COLORREF clrSave = SetBkColor(hdc, clr);
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, prc, NULL, 0, NULL);
    SetBkColor(hdc, clrSave);
}

class CMusicExtractionTask : public CRunnableTask
{
public:
    CMusicExtractionTask(CZaxxon* pzaxxon, HWND hwnd, PWSTR pszFile);

    STDMETHODIMP RunInitRT(void);

private:
    virtual ~CMusicExtractionTask();

    TCHAR szFile[MAX_PATH];
    HWND _hwnd;
    CZaxxon* _pzaxxon;

};


CMusicExtractionTask::CMusicExtractionTask(CZaxxon* pzaxxon, HWND hwnd, PWSTR pszFile)
    : CRunnableTask(RTF_DEFAULT), _hwnd(hwnd), _pzaxxon(pzaxxon)
{
    StrCpyN(szFile, pszFile, ARRAYSIZE(szFile));
}

CMusicExtractionTask::~CMusicExtractionTask()
{
}

STDMETHODIMP CMusicExtractionTask::RunInitRT()
{
    BOOL fResetImage = TRUE;
    HRESULT hr = E_OUTOFMEMORY;
    PWSTR psz = StrDup(szFile);
    if (psz)
    {
        LPITEMIDLIST pidl = ILCreateFromPath(szFile);
        if (pidl)
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder2* psf;

            hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder2, &psf), &pidlChild);

            if (SUCCEEDED(hr))
            {
                VARIANT v;
                hr = psf->GetDetailsEx(pidlChild, &SCID_MUSIC_Artist, &v);
                if (SUCCEEDED(hr))
                {
                    TCHAR szValue[MAX_PATH];
                    VariantToStr(&v, szValue, ARRAYSIZE(szValue));
                    SendMessage(_hwnd, WM_SETARTIST, 0, (LPARAM)szValue);
                }

                hr = psf->GetDetailsEx(pidlChild, &SCID_MUSIC_Album, &v);
                if (SUCCEEDED(hr))
                {
                    TCHAR szValue[MAX_PATH];
                    VariantToStr(&v, szValue, ARRAYSIZE(szValue));
                    SendMessage(_hwnd, WM_SETALBUM, 0, (LPARAM)szValue);
                }

                hr = psf->GetDetailsEx(pidlChild, &SCID_Title, &v);
                if (SUCCEEDED(hr))
                {
                    TCHAR szValue[MAX_PATH];
                    VariantToStr(&v, szValue, ARRAYSIZE(szValue));
                    SendMessage(_hwnd, WM_SETSONG, 0, (LPARAM)szValue);
                }

                InvalidateRect(_hwnd, NULL, TRUE);

                psf->Release();
            }

            ILFree(pidl);
        }

        if (PathRemoveFileSpec(psz))
        {
            PathAppend(psz, TEXT("folder.gif"));
            if (!PathFileExists(psz))
            {
                PathRemoveFileSpec(psz);
                PathAppend(psz, TEXT("folder.jpg"));
            }

            if (PathFileExists(psz))
            {
                if (_pzaxxon->_pThumbnail)
                {
                    _pzaxxon->_pThumbnail->Release();
                    _pzaxxon->_pThumbnail = NULL;
                }

                hr = CoCreateInstance(CLSID_Thumbnail, NULL, CLSCTX_INPROC_SERVER, IID_IThumbnail, (void **)&(_pzaxxon->_pThumbnail));

                if (SUCCEEDED(hr))
                {
                    RECT rc;
                    GetWindowRect(_hwnd, &rc);
                    SIZE sz;
                    sz.cy = (3 * RECTHEIGHT(rc)) / 4;
                    sz.cx = sz.cy;
                    _pzaxxon->_pThumbnail->Init(_hwnd, WM_SONGTHUMBDONE);
                    _pzaxxon->_pThumbnail->GetBitmap(psz, 0, sz.cx, sz.cy);
                    fResetImage = FALSE;
                }
            }
        }
        LocalFree(psz);
    }

    if (fResetImage)
        SendMessage(_hwnd, WM_SONGTHUMBDONE, 0, 0);;

    if (_pzaxxon->_bOpacity < 200)
    {
        _pzaxxon->_fHide = FALSE;
        SetTimer(_hwnd, 1, 30, NULL);
    }


    return hr;
}

void RenderTile(HWND hwnd, HDC hdc, CZaxxon* pzax)
{
    BITMAP bm = {0};
    RECT rc;
    GetClientRect(hwnd, &rc);
    MARGINS m = {0};
    MARGINS s = {0};
    RECT rcFrame = {0};
    RECT rcText;
    int y = 10;

    if (pzax->_hbmpAlbumArt)
    {
        GetObject(pzax->_hbmpAlbumArt, sizeof (BITMAP), &bm);
        HDC hdcBitmap = CreateCompatibleDC(hdc);
        HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcBitmap, pzax->_hbmpAlbumArt);
        y = (RECTHEIGHT(rc) - bm.bmHeight) / 2;

        if (pzax->_hTheme)
        {
            GetThemeMargins(pzax->_hTheme, NULL, SPP_USERPICTURE, 0, TMT_SIZINGMARGINS, NULL, &s);

            y = (RECTHEIGHT(rc) - bm.bmHeight - m.cyBottomHeight - m.cyTopHeight - s.cyBottomHeight - s.cyTopHeight) / 2;

            GetThemeMargins(pzax->_hTheme, NULL, SPP_USERPICTURE, 0, TMT_CONTENTMARGINS, NULL, &m);
        
            rcFrame.left     = 10;
            rcFrame.top      = y;
            rcFrame.right    = rcFrame.left + bm.bmWidth + m.cxLeftWidth + m.cxRightWidth;
            rcFrame.bottom   = rcFrame.top + bm.bmHeight + m.cyBottomHeight + m.cyTopHeight;

            DrawThemeBackground(pzax->_hTheme, hdc, SPP_USERPICTURE, 0, &rcFrame, 0);
        }

        BitBlt(hdc, rcFrame.left+m.cxLeftWidth, y + m.cyTopHeight, bm.bmWidth, bm.bmHeight, hdcBitmap, 0, 0, SRCCOPY);
        SelectObject(hdcBitmap, hbmpOld);
        DeleteDC(hdcBitmap);
    }

    SetBkMode(hdc, TRANSPARENT);
    SIZE sz;
    HFONT h = (HFONT)SelectObject(hdc, pzax->_hfont);
    int cch = lstrlen(pzax->_szArtist);
    GetTextExtentPoint32(hdc, pzax->_szArtist, cch, &sz);
    rcText.left = bm.bmWidth + 20 + m.cxLeftWidth + m.cxRightWidth;
    rcText.top = y + m.cyTopHeight;
    rcText.right = rcText.left + sz.cx;
    rcText.bottom = rcText.top + sz.cy;
    DrawShadowText(hdc, pzax->_szArtist, cch, &rcText, DT_NOPREFIX | DT_SINGLELINE | DT_TOP, GetSysColor(COLOR_CAPTIONTEXT), RGB(0,0,0), 2, 2);

    SetTextColor(hdc, GetSysColor(COLOR_CAPTIONTEXT));

    cch = lstrlen(pzax->_szAlbum);
    GetTextExtentPoint32(hdc, pzax->_szAlbum, cch, &sz);
    rcText.top = rcText.bottom;
    rcText.bottom = rcText.top + sz.cy;
    rcText.right = rcText.left + sz.cx;
    DrawText(hdc, pzax->_szAlbum, cch, &rcText, DT_NOPREFIX | DT_SINGLELINE | DT_TOP);

    cch = lstrlen(pzax->_szSong);
    GetTextExtentPoint32(hdc, pzax->_szSong, cch, &sz);
    rcText.top = rcText.bottom;
    rcText.bottom = rcText.top + sz.cy;
    rcText.right = rcText.left + sz.cx;
    DrawText(hdc, pzax->_szSong, cch, &rcText, DT_NOPREFIX | DT_SINGLELINE | DT_TOP);

    SelectObject(hdc, h);
}



LRESULT ZaxxonWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CZaxxon* pzaxxon = (CZaxxon*)GetProp(hwnd, TEXT("Zaxxon"));
    if (!pzaxxon && uMsg != WM_CREATE)
        return DefWindowProc(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_CREATE:
        {
            pzaxxon = (CZaxxon*)((CREATESTRUCT*)lParam)->lpCreateParams;
            SetProp(hwnd, TEXT("Zaxxon"), (HANDLE)pzaxxon);
            pzaxxon->_hTheme = OpenThemeData(NULL, L"StartPanel");

            NONCLIENTMETRICS ncm;
            ncm.cbSize = sizeof(NONCLIENTMETRICS);
            SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);
            pzaxxon->_hfont = CreateFontIndirect(&ncm.lfCaptionFont);

            SIZE sz = {0};
            if (pzaxxon->_hTheme)
                GetThemePartSize(pzaxxon->_hTheme, NULL, SPP_USERPANE, 0, NULL, TS_TRUE, &sz);

            int cy = 3 * GetSystemMetrics(SM_CYCAPTION);
            if (sz.cy < cy)
                sz.cy = cy;

            if (sz.cx < 400)
                sz.cx = 400;

            SetWindowPos(hwnd, NULL, 0, 0, sz.cx, sz.cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
        break;

    case WM_DESTROY:
        {
            if (pzaxxon->_hTheme)
                CloseThemeData(pzaxxon->_hTheme);
        }
        break;
    case WM_ERASEBKGND:
        if (pzaxxon->_hTheme)
        {
            RECT rc;
            HDC hdc = (HDC)wParam;
            GetClientRect(hwnd, &rc);
            FillRectClr(hdc, &rc, RGB(255,0,255));
            DrawThemeBackground(pzaxxon->_hTheme, hdc, SPP_USERPANE, 0, &rc, 0);
            RenderTile(hwnd, hdc, pzaxxon);

            return TRUE;
        }
        break;
    case WM_SETALBUM:
        StrCpy(pzaxxon->_szAlbum, (PTSTR)lParam);
        break;

    case WM_SETARTIST:
        StrCpy(pzaxxon->_szArtist, (PTSTR)lParam);
        break;

    case WM_SETSONG:
        StrCpy(pzaxxon->_szSong, (PTSTR)lParam);
        break;
            

    case WM_SONGTHUMBDONE:
        {
            if (pzaxxon->_hbmpAlbumArt)
                DeleteObject(pzaxxon->_hbmpAlbumArt);

            pzaxxon->_hbmpAlbumArt = (HBITMAP)lParam;

            InvalidateRect(hwnd, NULL, TRUE);

            if (pzaxxon->_pThumbnail)
            {
                pzaxxon->_pThumbnail->Release();
                pzaxxon->_pThumbnail = NULL;
            }
        }
        return TRUE;

    case WM_TIMER:
        if (wParam == 1)
        {
            BYTE bOld = pzaxxon->_bOpacity;
            if (pzaxxon->_fHide)
            {
                if (pzaxxon->_bOpacity < 20)
                {
                    pzaxxon->_bOpacity = 0;
                    ShowWindow(hwnd, SW_HIDE);
                    KillTimer(hwnd, 1);
                }
                else
                    pzaxxon->_bOpacity -= 20;
            }
            else
            {
                if (pzaxxon->_bOpacity > 200)
                {
                    pzaxxon->_bOpacity = 200;
                    KillTimer(hwnd, 1);
                    if (pzaxxon->_fAllowFadeout)
                        SetTimer(hwnd, 2, 1000, NULL);
                }
                else
                    pzaxxon->_bOpacity += 10;
            }

            if (bOld != pzaxxon->_bOpacity)
                SetLayeredWindowAttributes(hwnd, RGB(255,0,255), pzaxxon->_bOpacity, LWA_COLORKEY | LWA_ALPHA);

            BOOL fToolbar = TRUE;
            HWND hwndToPutOnTopOf = pzaxxon->_hwnd;
            if (pzaxxon->_fEditorShown)
            {
                fToolbar = FALSE;
                hwndToPutOnTopOf = pzaxxon->_pEdit->_hwnd;
            }
            CenterOnTopOf(fToolbar, hwnd, hwndToPutOnTopOf);
        }
        else if (wParam == 2)
        {
            KillTimer(hwnd, 2);
            SetTimer(hwnd, 1, 30, NULL);
            pzaxxon->_fHide = TRUE;
        }
        return TRUE;

    case WM_SONGSTOP:
        {
            pzaxxon->SongStop();
            DeleteObject(pzaxxon->_hbmpAlbumArt);
            pzaxxon->_hbmpAlbumArt = NULL;

            pzaxxon->_szArtist[0] = 0;
            pzaxxon->_szSong[0] = 0;
            pzaxxon->_szAlbum[0] = 0;
            InvalidateRect(hwnd, NULL, TRUE);
        }
        return TRUE;

    case WM_SONGCHANGE:
        {
            if (pzaxxon->_pScheduler)
            {
                CMusicExtractionTask* pme = new CMusicExtractionTask(pzaxxon, hwnd, (PWSTR)wParam);

                pzaxxon->_pScheduler->AddTask(pme, CLSID_Zaxxon, 0, ITSAT_DEFAULT_PRIORITY);
                pme->Release();
            }
        }
        return TRUE;

    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


CZaxxon::CZaxxon()
{
    CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC, IID_PPV_ARG(IShellTaskScheduler, &_pScheduler));
    CoCreateInstance(CLSID_ZaxxonPlayer, NULL, CLSCTX_INPROC_SERVER, IID_IZaxxonPlayer, (void**)&_pzax);
    _dwViewMode = NULL;
    _himlHot = NULL;
    _himlDef = NULL;
    _hmenuOpenFolder = NULL;
    _pThumbnail = NULL;
    _bOpacity = 0;
    _fHide = FALSE;
    _fAllowFadeout = TRUE;
    _fPlaying = FALSE;
    _hbr = NULL;
    _szArtist[0] = 0;
    _szSong[0] = 0;
    _szAlbum[0] = 0;
    _hbmpAlbumArt = NULL;
}

CZaxxon::~CZaxxon()
{
    if (_himlHot)
        ImageList_Destroy(_himlHot);
    if (_himlDef)
        ImageList_Destroy(_himlDef);

    if (_pzax)
        _pzax->Release();

    if (_pThumbnail)
        _pThumbnail->Release();

    if (_pScheduler)
        _pScheduler->Release();

    if (_hbr)
        DeleteObject(_hbr);

    if (_hmenuOpenFolder)
        DestroyMenu(_hmenuOpenFolder);
}

HWND CZaxxon::_CreateWindow(HWND hwndParent)
{
    if (_hwnd)
        return _hwnd;

    WNDCLASS wc = {0};
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = TEXT("ZaxxonSongTile");
    wc.lpfnWndProc = ZaxxonWndProc;
    wc.hInstance = HINST_THISDLL;
    wc.hCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
    RegisterClass(&wc);


    _hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                             WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT |
                             WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                             CCS_NODIVIDER | CCS_NOPARENTALIGN |
                             CCS_NORESIZE | TBSTYLE_REGISTERDROP,
                             0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, NULL);

    if (_hwnd)
    {
        // Set the format to ANSI or UNICODE as appropriate.
        ToolBar_SetUnicodeFormat(_hwnd, TRUE);

        SetWindowTheme(_hwnd, L"TaskBar", NULL);

        SendMessage(_hwnd, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(_hwnd, TB_BUTTONSTRUCTSIZE,    SIZEOF(TBBUTTON), 0);
//        SendMessage(_hwnd, TB_ADDSTRING, NULL, (LPARAM)&g_crgstrStrings);
        SendMessage(_hwnd, TB_ADDBUTTONS, ARRAYSIZE(g_crgButtons), (LPARAM)&g_crgButtons);
        ToolBar_SetExtendedStyle(_hwnd, TBSTYLE_EX_DOUBLEBUFFER, TBSTYLE_EX_DOUBLEBUFFER);


        _himlHot = ImageList_LoadImage(HINST_THISDLL,
                                       MAKEINTRESOURCE(IDB_ZAXXONHOT), 16, 0, COLORMASK,
                                       IMAGE_BITMAP, LR_CREATEDIBSECTION);

        SendMessage(_hwnd, TB_SETHOTIMAGELIST, 0, (LPARAM)_himlHot);

        _himlDef = ImageList_LoadImage(HINST_THISDLL,
                                       MAKEINTRESOURCE(IDB_ZAXXONDEF), 16, 0, COLORMASK,
                                       IMAGE_BITMAP, LR_CREATEDIBSECTION);

        SendMessage(_hwnd, TB_SETIMAGELIST, 0, (LPARAM)_himlDef);


        _hwndSongTile = CreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_LAYERED | WS_EX_TOPMOST | WS_EX_TRANSPARENT, TEXT("ZaxxonSongTile"), NULL,
                             WS_POPUP, 0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, this);

        _pEdit = new CZaxxonEditor(this);
        _pEdit->Initialize();

        _pzax->Register(_hwndSongTile);
    }

    return _hwnd;
}

void CZaxxon::SongStop()
{
    _fPlaying = FALSE;
    TBBUTTONINFO bi = {0};
    bi.cbSize = sizeof(bi);
    bi.dwMask = TBIF_IMAGE;
    bi.iImage = PLAY;
    ToolBar_SetButtonInfo(_hwnd, PLAY, &bi);

}

LRESULT CZaxxon::_OnCommand(WORD wNotifyCode, WORD wID, HWND hwnd)
{
    if (!_pzax)
        return 0;

    switch (wNotifyCode)
    {
    case BN_CLICKED:
        switch (wID)
        {
        case PLAY:
            {
                TBBUTTONINFO bi = {0};
                bi.cbSize = sizeof(bi);
                bi.dwMask = TBIF_IMAGE;

                if (_fPlaying)
                {
                    _pzax->Pause();
                    _fPlaying = FALSE;
                    bi.iImage = PLAY;
                }
                else
                {
                    _pzax->Play();
                    _fPlaying = TRUE;
                    bi.iImage = PAUSE;

                }

                ToolBar_SetButtonInfo(_hwnd, PLAY, &bi);
            }
            break;

        case PAUSE:
            _pzax->Pause();
            break;
        
        case STOP:
            _pzax->Stop();
            _fPlaying = FALSE;
            break;

        case NEXT:
            _pzax->NextSong();
            break;

        case PREV:
            _pzax->PrevSong();
            break;

        case MENU:
            {
                _fEditorShown = !_fEditorShown;
                BOOL fToolbar = TRUE;
                HWND hwndToPutOnTopOf = _hwnd;
                if (_fEditorShown)
                {
                    fToolbar = FALSE;
                    hwndToPutOnTopOf = _pEdit->_hwnd;
                }
                _pEdit->Show(_fEditorShown);

                CenterOnTopOf(fToolbar, _hwndSongTile, hwndToPutOnTopOf);
            }
            break;
        }
    }

    return 1;
}

HRESULT CZaxxon::RecurseAddFile(IShellFolder* psf)
{
    LPITEMIDLIST pidlItem;
    IEnumIDList* penum;
    if (SUCCEEDED(psf->EnumObjects(NULL, SHCONTF_NONFOLDERS | SHCONTF_FOLDERS, &penum)))
    {
        ULONG l;
        while(S_OK == penum->Next(1, &pidlItem, &l))
        {

            if ((SHGetAttributes(psf, pidlItem, SFGAO_FOLDER) & SFGAO_FOLDER))
            {
                IShellFolder* psfNext;
                if (SUCCEEDED(SHBindToObjectEx(psf, pidlItem, NULL, IID_PPV_ARG(IShellFolder, &psfNext))))
                {
                    RecurseAddFile(psfNext);

                    psfNext->Release();
                }
            }
            else
            {
                TCHAR sz[MAX_PATH];
                DisplayNameOf(psf, pidlItem, SHGDN_FORPARSING, sz, MAX_PATH);
                PTSTR pszExtension = PathFindExtension(sz);
                if (StrCmpI(pszExtension, TEXT(".mp3")) == 0 || 
                    StrCmpI(pszExtension, TEXT(".wma")) == 0)
                {
                    _pzax->AddSong(sz);
                }
            }

            ILFree(pidlItem);
        }
    }

    return S_OK;
}


HRESULT CZaxxon::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;
    switch (uMsg)
    {

    case SMC_EXEC:
        {
            if (psmd->uId == 1)
            {
                IShellMenu* psm;
                if (SUCCEEDED(psmd->punk->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
                {
                    DWORD dwFlags;
                    IShellFolder* psf;
                    LPITEMIDLIST pidl;
                    if (SUCCEEDED(psm->GetShellFolder(&dwFlags, &pidl, IID_PPV_ARG(IShellFolder, &psf))))
                    {
                        RecurseAddFile(psf);

                        hr = S_OK;
                        psf->Release();
                        ILFree(pidl);
                    }
                    psm->Release();
                }
            }
            else if (psmd->uId == 2)
            {
                _pzax->ClearPlaylist();
            }
        }
        break;
    case SMC_SFEXEC:
        {
            TCHAR sz[MAX_PATH];
            DisplayNameOf(psmd->psf, psmd->pidlItem, SHGDN_FORPARSING, sz, MAX_PATH);
            PTSTR pszExtension = PathFindExtension(sz);
            if (StrCmpI(pszExtension, TEXT(".mp3")) == 0)
            {
                _pzax->AddSong(sz);
            }

            hr = S_OK;
        }
        break;

    case SMC_INITMENU:
        {
            IShellMenu* psm;
            if (SUCCEEDED(psmd->punk->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
            {
                HMENU hmenu;
                DWORD dwFlags = SMSET_BOTTOM;
                if (psmd->uIdParent == 100)
                {
                    hmenu = CreateMenu();
                    AppendMenu(hmenu, MF_SEPARATOR, -1, NULL);
                    AppendMenu(hmenu, MF_STRING, 2, TEXT("Clear Playlist"));
                    AppendMenu(hmenu, MF_STRING, 1, TEXT("Play Folder"));
                }
                else
                {
                    if (_hmenuOpenFolder == NULL)
                    {
                        _hmenuOpenFolder = CreateMenu();
                        AppendMenu(_hmenuOpenFolder, MF_SEPARATOR, -1, NULL);
                        AppendMenu(_hmenuOpenFolder, MF_STRING, 1, TEXT("Play Folder"));
                    }

                    dwFlags |= SMSET_DONTOWN;
                    hmenu = _hmenuOpenFolder;
                }

                psm->SetMenu(hmenu, NULL, dwFlags);
                psm->Release();
            }
            
            return S_OK;
        }
        break;
    }

    return hr;
}


void CZaxxon::_DoMenu()
{
    HRESULT hr;
    LPITEMIDLIST pidl = NULL;
    if (FAILED(SHGetSpecialFolderLocation(_hwnd, CSIDL_MYMUSIC, &pidl)))
        SHGetSpecialFolderLocation(_hwnd, CSIDL_MYDOCUMENTS, &pidl);

    if (pidl)
    {
        IShellFolder* psf;
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, &psf));
        if (SUCCEEDED(hr))
        {
            ITrackShellMenu* ptsm;
            hr = CoCreateInstance(CLSID_TrackShellMenu, NULL, CLSCTX_INPROC_SERVER, IID_ITrackShellMenu, (void**)&ptsm);
            if (SUCCEEDED(hr))
            {
                RECT rc;
                POINTL pt;
                ptsm->Initialize(this, 100, ANCESTORDEFAULT, SMINIT_TOPLEVEL | SMINIT_NOSETSITE | SMINIT_VERTICAL);
                ptsm->SetShellFolder(psf, pidl, NULL, SMSET_TOP | SMSET_USEBKICONEXTRACTION);
                ToolBar_GetRect(_hwnd, MENU, &rc);
                MapWindowPoints(_hwnd, HWND_DESKTOP, (POINT*)&rc, 2);
                pt.x = rc.left;
                pt.y = rc.top;
                ptsm->Popup(_hwnd, &pt, (RECTL*)&rc, MPPF_TOP);
                ptsm->Release();
            }
            psf->Release();
        }

        ILFree(pidl);
    }
}

LRESULT CZaxxon::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;
    switch(pnm->code)
    {

    case TBN_GETOBJECT:
        {
            NMOBJECTNOTIFY*pon = (NMOBJECTNOTIFY*)pnm;
            pon->hResult = QueryInterface(*pon->piid, &pon->pObject);
            lres = 1;
        }
        break;

    case TBN_HOTITEMCHANGE:
        {
            NMTBHOTITEM* phi = (NMTBHOTITEM*)pnm;
            if (phi->dwFlags & HICF_ENTERING)
            {
                _fAllowFadeout = FALSE;
                _fHide = FALSE;

                if (_fPlaying)
                {
                    ShowWindow(_hwndSongTile, SW_SHOW);
                    SetTimer(_hwndSongTile, 1, 30, NULL);
                    KillTimer(_hwndSongTile, 2);
                }
            }
            else if (phi->dwFlags & HICF_LEAVING)
            {
                _fAllowFadeout = TRUE;
                _fHide = TRUE;
                SetTimer(_hwndSongTile, 1, 30, NULL);
                KillTimer(_hwndSongTile, 2);
            }
        }
        break;
    }


    return lres;
}



STDMETHODIMP CZaxxon::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CZaxxon, IWinEventHandler),
        QITABENT(CZaxxon, IDropTarget),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
        hres = CToolBand::QueryInterface(riid, ppvObj);

    return hres;
}

STDMETHODIMP CZaxxon::GetWindow(HWND * phwnd)
{

    *phwnd = _CreateWindow(_hwndParent);

    return *phwnd? S_OK : E_FAIL;
}

STDMETHODIMP CZaxxon::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                       DESKBANDINFO* pdbi)
{

    LONG lButton = SendMessage(_hwnd, TB_GETBUTTONSIZE, 0, 0L);
    UINT ucy;
    UINT ucx; 
    if (fViewMode & (DBIF_VIEWMODE_FLOATING |DBIF_VIEWMODE_VERTICAL))
    {
        ucy = HIWORD(lButton) * SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0) + 1;
        ucx = LOWORD(lButton);
    }
    else
    {
        ucx = HIWORD(lButton) * SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0) + 1;
        ucy = LOWORD(lButton);
    }

    _dwBandID = dwBandID;
    _dwViewMode = fViewMode;

    pdbi->ptMinSize.x = LOWORD(lButton) * 1;
    pdbi->ptMinSize.y = ucy;

    pdbi->ptMaxSize.y = ucy;
    pdbi->ptMaxSize.x = ucx;

    pdbi->ptActual.y = ucy;
    pdbi->ptActual.x = ucx;

    pdbi->ptIntegral.y = 1;
    pdbi->ptIntegral.x = 1;

    if (pdbi->dwMask & DBIM_TITLE)
    {
        StrCpy(pdbi->wszTitle, TEXT("Zaxxon"));
    }

    return S_OK;
}

STDMETHODIMP CZaxxon::ShowDW(BOOL fShow)
{
    return CToolBand::ShowDW(fShow);
}

STDMETHODIMP CZaxxon::CloseDW(DWORD dw)
{
    SendMessage(_hwnd, TB_SETIMAGELIST, 0, NULL);
    SendMessage(_hwnd, TB_SETHOTIMAGELIST, 0, NULL);
    return CToolBand::CloseDW(dw);
}


STDMETHODIMP CZaxxon::TranslateAcceleratorIO(LPMSG lpMsg)
{
    return E_NOTIMPL;
}

STDMETHODIMP CZaxxon::HasFocusIO()
{
    return E_NOTIMPL;
}

STDMETHODIMP CZaxxon::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    return S_OK;
}


STDMETHODIMP CZaxxon::IsWindowOwner(HWND hwnd)
{
    return (hwnd == _hwnd)? S_OK : S_FALSE;
}

STDMETHODIMP CZaxxon::OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{

    HRESULT hres = S_FALSE;
    switch (dwMsg)
    {
    case WM_COMMAND:
        *plres = _OnCommand(HIWORD(wParam), LOWORD(wParam), (HWND)lParam);
        hres = S_OK;
        break;

    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        hres = S_OK;
        break;

    case WM_ENDSESSION:
        _pzax->Stop();
        hres = S_OK;
        break;

    }
    return hres;
}

STDMETHODIMP CZaxxon::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_MOVE;

    return S_OK;
}


STDMETHODIMP CZaxxon::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{

    return S_OK;
}

STDMETHODIMP CZaxxon::DragLeave(void)
{
    return S_OK;    // Yea so?
}


STDMETHODIMP CZaxxon::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (SUCCEEDED(pdtobj->GetData(&fmte, &medium)))
    {
        HDROP hdrop = (HDROP)medium.hGlobal;

        if (hdrop)
        {
            int c = DragQueryFile(hdrop, -1, NULL, 0);
            if (c > 0)
            {
                for (int i=0; i < c;i++)
                {
                    TCHAR szPath[MAX_PATH];
                    DragQueryFile(hdrop, i, szPath, ARRAYSIZE(szPath));

                    _pzax->AddSong(szPath);
                }
            }
        }
    }

    return S_OK;
}

HRESULT CZaxxon_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;
    CZaxxon *pzax = new CZaxxon;
    if (pzax)
    {
        hr = pzax->QueryInterface(riid, ppv);
        pzax->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppv = NULL;
    }
    return hr;
}


STDMETHODIMP CZaxxon::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_Zaxxon;

    return S_OK;
}

STDMETHODIMP CZaxxon::Load(IStream *pStm)
{
    return S_OK;
}

STDMETHODIMP CZaxxon::Save(IStream *pStm, BOOL fClearDirty)
{
    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\daytona.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)   \
              -DFLAT         \
              -DWIN32=100    \
              -D_NT1X_=100   \
              -DINC_OLE2     \
              -DNOEXCEPTIONS \
	      -DNASHVILLE    \
              $(TRACELOG)

!IF "$(ALMOSTRETAIL)"!="" && $(FREEBUILD)
C_DEFINES=    \
              $(C_DEFINES)          \
              -DDBGASSERT=1
!ENDIF

USE_MAPSYM=1

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1
# USE_MSVCRT=1
USE_NOLIBS = 1

MSC_WARNING_LEVEL=/W3 /WX

GPCH_BUILD=daytona
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\zaxxoneditor.cpp ===
#include "priv.h"
#include "zaxxon.h"
#include "guids.h"
#include "shlwapip.h"
#include "resource.h"
#include "commdlg.h"
#include "varutil.h"

#define ID_TOOLBAR      100
#define ID_LISTVIEW     101

#define EDIT_NEW         0
#define EDIT_ADD         1
#define EDIT_REMOVE      2
#define EDIT_LOAD        3
#define EDIT_SAVE        4
#define EDIT_SORT        5


CSong::CSong():_cRef(1)
{

}

void CSong::AddRef()
{
    InterlockedIncrement((LONG*)&_cRef);
}

void CSong::Release()
{
    InterlockedDecrement((LONG*)&_cRef);
    if (_cRef == 0)
        delete this;
}


CZaxxonEditor::CZaxxonEditor(CZaxxon* pz):_pzax(pz)
{
    WNDCLASS wc = {0};
    wc.lpszClassName = TEXT("ZaxxonEditor");
    wc.lpfnWndProc = CZaxxonEditor::s_WndProc;
    wc.hInstance = HINST_THISDLL;
    wc.hbrBackground = HBRUSH(COLOR_ACTIVECAPTION + 1);
    RegisterClass(&wc);

    hSongList = DPA_Create(10);
}

int CALLBACK SongDestroyCallback(void* p, void*)
{
    CSong* psong = (CSong*)p;
    psong->Release();
    return 1;
}

CZaxxonEditor::~CZaxxonEditor()
{
    if (_hwnd)
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }

    DPA_DestroyCallback(hSongList, SongDestroyCallback, NULL);
}


int ReadLineFromStream(IStream* pstm, LPTSTR pszLine, DWORD cch)
{
    // Assume this is an ANSI string
    char szLine[MAX_PATH];
    DWORD dwRead;
    int iLine = 0;
    ULARGE_INTEGER UliStartingFrom;
    LARGE_INTEGER  liSeek = {0};

    pstm->Seek(liSeek, STREAM_SEEK_CUR, &UliStartingFrom);
    pstm->Read(szLine, ARRAYSIZE(szLine), &dwRead);
    if (dwRead > 0)
    {
        // Now convert to String
        SHAnsiToUnicode(szLine, pszLine, dwRead);

        pszLine[MAX_PATH - 1] = '\0'; //Null terminate the string

        // Get the number of characters in the line
        LPTSTR pszNewLine = StrStr(pszLine, TEXT("\r"));

        if (pszNewLine)
        {
            *pszNewLine++ = TEXT('\0'); // Nuke \r
            *pszNewLine = TEXT('\0');   // Nuke \n
        }
        else
        {
            pszNewLine = StrStr(pszLine, TEXT("\n"));
            if (pszNewLine)
                *pszNewLine = TEXT('\0');   // Nuke \n
        }



        iLine = lstrlen(pszLine);

        // Now take that, and set the seek position to 2 more than that (One for the \r and \n
        liSeek.QuadPart = UliStartingFrom.QuadPart + iLine + 1 + 1;
        pstm->Seek(liSeek, STREAM_SEEK_SET, NULL);
    }

    return iLine;
}


void CZaxxonEditor::UpdateSong(CSong* psong)
{

    int i = ListView_MapIDToIndex(_hwndList, psong->_id);
    if (i >= 0)
    {
        TCHAR szTitle[MAX_PATH];
        wsprintf(szTitle, TEXT("%s - %s"), psong->szArtist, psong->szTitle);


        LVITEM lv;
        lv.mask = LVIF_TEXT;
        lv.iItem = i;
        lv.iSubItem = 0;
        lv.pszText = szTitle;
        ListView_SetItem(_hwndList,&lv);

        lv.iSubItem = 1;
        lv.pszText = psong->szDuration;
        ListView_SetItem(_hwndList,&lv);
    }
}

void CZaxxonEditor::LoadPlaylist()
{
    TCHAR sz[MAX_PATH];
    TCHAR szInit[MAX_PATH];
    OPENFILENAME of = {0};
    of.lStructSize = sizeof(of);
    of.hwndOwner = _hwnd;
    of.lpstrFilter = TEXT("Playlist\0*.m3u\0\0");
    of.lpstrFile = sz;
    of.nMaxFile = MAX_PATH;
    of.lpstrDefExt = TEXT(".m3u");
    if (FAILED(SHGetFolderPath(NULL, CSIDL_MYMUSIC, NULL, SHGFP_TYPE_CURRENT, szInit)))
        SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, szInit);

    of.lpstrInitialDir = szInit;
    of.Flags = OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST;

    if (GetOpenFileName(&of))
    {
        ClearPlaylist();
        IStream* pstm;
        if (SUCCEEDED(SHCreateStreamOnFile(sz, STGM_READ, &pstm)))
        {
            do
            {
                TCHAR szFilename[MAX_PATH];
                if (ReadLineFromStream(pstm, szFilename, ARRAYSIZE(szFilename)) > 0)
                {
                    AddFilename(szFilename);
                }
                else
                {
                    break;
                }
            }
            while (1);

            pstm->Release();
        }
    }
}

void CZaxxonEditor::SavePlaylist()
{
    TCHAR sz[MAX_PATH];
    TCHAR szInit[MAX_PATH];
    OPENFILENAME of = {0};
    of.lStructSize = sizeof(of);
    of.hwndOwner = _hwnd;
    of.lpstrFilter = TEXT("Playlist\0*.m3u\0\0");
    of.lpstrFile = sz;
    of.nMaxFile = MAX_PATH;
    of.lpstrDefExt = TEXT(".m3u");
    if (FAILED(SHGetFolderPath(NULL, CSIDL_MYMUSIC, NULL, SHGFP_TYPE_CURRENT, szInit)))
        SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT, szInit);

    of.lpstrInitialDir = szInit;
    of.Flags = OFN_ENABLESIZING | OFN_EXPLORER;

    if (GetSaveFileName(&of))
    {
        IStream* pstm;
        if (SUCCEEDED(SHCreateStreamOnFile(sz, STGM_CREATE | STGM_WRITE, &pstm)))
        {
            char szLine[MAX_PATH];

            int cCount = DPA_GetPtrCount(hSongList);
            for (int i=0; i < cCount; i++)
            {
                CSong* psong = (CSong*)DPA_FastGetPtr(hSongList, i);
                SHUnicodeToAnsi(psong->szSong, szLine, MAX_PATH);
                pstm->Write(szLine, lstrlenA(szLine), NULL);
                pstm->Write("\r\n", 2, NULL);
            }
            pstm->Write("\r\n", 2, NULL);
            pstm->Release();
        }
    }
}

void CZaxxonEditor::RemoveFromPlaylist()
{
    int iItem = ListView_GetNextItem(_hwndList, -1, MAKELPARAM(LVNI_SELECTED, 0));
    if (iItem >= 0 && iItem < DPA_GetPtrCount(hSongList))
    {
        _pzax->_pzax->RemoveSong(iItem);
        ListView_DeleteItem(_hwndList, iItem);
        CSong* psong = (CSong*)DPA_DeletePtr(hSongList, iItem);
        psong->Release();
    }

}

void CZaxxonEditor::ClearPlaylist()
{
    _pzax->_pzax->ClearPlaylist();

    DPA_DestroyCallback(hSongList, SongDestroyCallback, NULL);
    hSongList = DPA_Create(10);
    ListView_DeleteAllItems(_hwndList);
}


void CZaxxonEditor::InsertFilename(int i, PTSTR psz)
{
    CSong* pzs = new CSong;
    if (pzs)
    {
        StrCpy(pzs->szSong, psz);

        int iIndex = DPA_InsertPtr(hSongList, i, pzs);
        if (iIndex != -1)
        {
            LVITEM lv;
            lv.mask = LVIF_TEXT;
            lv.iItem = iIndex;
            lv.iSubItem = 0;
            lv.pszText = PathFindFileName(psz);
            ListView_InsertItem(_hwndList, &lv);

            pzs->_id = ListView_MapIndexToID(_hwndList, iIndex);
        
        
            _pzax->_pzax->AddSong(psz);
            CSongExtractionTask* pset = new CSongExtractionTask(_hwnd, pzs);
            if (pset)
            {
                if (_pzax->_pScheduler)
                    _pzax->_pScheduler->AddTask(pset, CLSID_Zaxxon, 0, ITSAT_MIN_PRIORITY);
                pset->Release();
            }
        }
    }
}

void CZaxxonEditor::AddFilename(PTSTR psz)
{
    InsertFilename(DSA_APPEND, psz);
}

void CZaxxonEditor::AddToPlaylist()
{
    OPENFILENAME of = {0};
    PTSTR psz = (PTSTR)LocalAlloc(LPTR, 4096);
    if (psz)
    {
        of.lStructSize = sizeof(of);
        of.hwndOwner = _hwnd;
        of.lpstrFilter = TEXT("Music\0*.mp3;*.wma\0\0");
        of.lpstrFile = psz;
        of.nMaxFile = 4096;
        of.Flags = OFN_ALLOWMULTISELECT | OFN_ENABLESIZING | OFN_EXPLORER | OFN_FILEMUSTEXIST;

        if (GetOpenFileName(&of))
        {
            TCHAR szName[MAX_PATH];
            PTSTR pszFilename = psz;
            int iLen = lstrlen(pszFilename);
            do
            {
                pszFilename += iLen + 1;    // Skip the last filename
                iLen = lstrlen(pszFilename);

                if (iLen > 0)
                {
                    StrCpy(szName, psz);        // Copy the path;
                    PathAppend(szName, pszFilename);  // Append the new name
                    AddFilename(szName);        // Append to list.
                }
            }
            while (iLen != 0);
            
        }

        LocalFree(psz);
    }
}

int FindSong(void* p1, void* p2, LPARAM lParam)
{
    PTSTR pszSong = (PTSTR)p1;
    CSong* psong = (CSong*)p2;
    return StrCmpI(pszSong, psong->szSong);
}

void CZaxxonEditor::HighlightSong(PTSTR psz)
{
    
    int iItem = DPA_Search(hSongList, psz, 0, FindSong, 0, NULL);
    if (iItem >= 0)
    {
        ListView_SetItemState(_hwndList, iItem, LVIS_SELECTED, LVIS_SELECTED);
    }
}


static const TCHAR* g_EditStrings    =   TEXT("New\0Add\0Delete\0Load\0Save\0Sort\0\0");

static const TBBUTTON g_crgEditButtons[] =
{
    {I_IMAGENONE,  EDIT_NEW,  TBSTATE_ENABLED, BTNS_BUTTON, 0, 0, 0, 0},
    {I_IMAGENONE,  EDIT_ADD,  TBSTATE_ENABLED, BTNS_BUTTON, 0, 0, 0, 1},
    {I_IMAGENONE,  EDIT_REMOVE,  TBSTATE_ENABLED, BTNS_BUTTON, 0, 0, 0, 2},
    {I_IMAGENONE,  EDIT_LOAD,  TBSTATE_ENABLED, BTNS_BUTTON, 0, 0, 0, 3},
    {I_IMAGENONE,  EDIT_SAVE,  TBSTATE_ENABLED, BTNS_BUTTON, 0, 0, 0, 4},
    {I_IMAGENONE,  EDIT_SORT,  TBSTATE_ENABLED, BTNS_BUTTON, 0, 0, 0, 5},
};

BOOL CZaxxonEditor::Initialize()
{
    int cxInitial = 300;
    int cyInitial = 500;
    _hwnd = CreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
        TEXT("ZaxxonEditor"), TEXT("Zaxxon Playlist Editor"),
        WS_CAPTION | WS_POPUPWINDOW | WS_THICKFRAME | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 
        0, 0, 0, 0,
        _pzax->GetHWND(), NULL, HINST_THISDLL, this);
    if (_hwnd)
    {
        _pzax->_pzax->Register(_hwnd);

        _hwndList = CreateWindow(
                TEXT("SysListView32"), TEXT(""),
                WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS, 
                0, 0, 0, 0,
                _hwnd, (HMENU)ID_LISTVIEW, NULL, NULL);

        if (_hwndList)
        {
            RECT rc;
            GetClientRect(_hwnd, &rc);
            LVCOLUMN lvc = {0};
            lvc.mask = LVCF_TEXT | LVCF_WIDTH;
            lvc.cx = 4 * cxInitial / 5 - 10;
            lvc.pszText = TEXT("Song");
            ListView_InsertColumn(_hwndList, 0, &lvc);

            lvc.mask = LVCF_TEXT | LVCF_WIDTH;
            lvc.cx = cxInitial / 5;
            lvc.pszText = TEXT("Length");
            ListView_InsertColumn(_hwndList, 1, &lvc);

            ListView_SetExtendedListViewStyle(_hwndList, LVS_EX_FULLROWSELECT | LVS_EX_DOUBLEBUFFER);
        }

        _hwndToolbar = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                             WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT | TBSTYLE_LIST |
                             WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                             CCS_NODIVIDER | CCS_NOPARENTALIGN |
                             CCS_NORESIZE | TBSTYLE_REGISTERDROP,
                             0, 0, 0, 0, _hwnd, (HMENU) ID_TOOLBAR, HINST_THISDLL, NULL);

        if (_hwndToolbar)
        {
            // Set the format to ANSI or UNICODE as appropriate.
            ToolBar_SetUnicodeFormat(_hwndToolbar, TRUE);
            SetWindowTheme(_hwndToolbar, L"TaskBar", NULL);
            SendMessage(_hwndToolbar, CCM_SETVERSION, COMCTL32_VERSION, 0);
            SendMessage(_hwndToolbar, TB_BUTTONSTRUCTSIZE,    SIZEOF(TBBUTTON), 0);
            SendMessage(_hwndToolbar, TB_ADDSTRING, NULL, (LPARAM)g_EditStrings);
            SendMessage(_hwndToolbar, TB_ADDBUTTONS, ARRAYSIZE(g_crgEditButtons), (LPARAM)&g_crgEditButtons);
            ToolBar_SetExtendedStyle(_hwndToolbar, TBSTYLE_EX_DOUBLEBUFFER, TBSTYLE_EX_DOUBLEBUFFER);
        }


        SetWindowPos(_hwnd, NULL, 0, 0, cxInitial, cyInitial, SWP_NOACTIVATE);

    }

    return _hwnd != NULL;
}

BOOL CZaxxonEditor::Show(BOOL fShow)
{
    ShowWindow(_hwnd, fShow?SW_SHOW:SW_HIDE);
    return TRUE;
}



LRESULT CZaxxonEditor::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_CREATE:
        break;

    case WM_SONGCHANGE:
        {
            _fIgnoreChange = TRUE;
            HighlightSong((PTSTR)wParam);
            _fIgnoreChange = FALSE;
        }
        break;

    case WM_UPDATESONG:
        {
            UpdateSong((CSong*)wParam);
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnm = (LPNMHDR)lParam;
            if (pnm->idFrom == ID_TOOLBAR)
            {
                if (pnm->code == NM_CLICK)
                {
                    {
                        int idCmd = (int)((LPNMCLICK)pnm)->dwItemSpec;
                        switch (idCmd)
                        {
                        case EDIT_NEW:
                            ClearPlaylist();
                            break;
                        case EDIT_ADD:
                            AddToPlaylist();
                            break;

                        case EDIT_REMOVE:
                            RemoveFromPlaylist();
                            break;

                        case EDIT_LOAD:
                            LoadPlaylist();
                            break;

                        case EDIT_SAVE:
                            SavePlaylist();
                            break;

                        case EDIT_SORT:
                            break;
                        }
                    }
                }
            }
            else if (pnm->idFrom == ID_LISTVIEW)
            {
                if (pnm->code == LVN_ITEMCHANGED && !_fIgnoreChange)
                {
                    NMLISTVIEW* pnml = (NMLISTVIEW*)pnm;
                    int iItem = pnml->iItem;
                    if (iItem < DPA_GetPtrCount(hSongList) &&
                        pnml->uNewState != pnml->uOldState &&
                        pnml->uNewState & LVIS_SELECTED)
                    {
                        _pzax->_pzax->SetSong(iItem);
                    }
                }
            }
        }
        break;

    case WM_CLOSE:
        ShowWindow(hwnd, SW_HIDE);
        return 1;

    case WM_SIZE:
        {
            RECT rc;
            GetClientRect(hwnd, &rc);
            LONG lButton = SendMessage(_hwndToolbar, TB_GETBUTTONSIZE, 0, 0L);
            SetWindowPos(_hwndList, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc) - HIWORD(lButton), SWP_NOZORDER | SWP_NOACTIVATE);
            SetWindowPos(_hwndToolbar, NULL, rc.left, RECTHEIGHT(rc) - HIWORD(lButton), RECTWIDTH(rc), HIWORD(lButton), SWP_NOZORDER | SWP_NOACTIVATE);
        }
        break;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


LRESULT CZaxxonEditor::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_CREATE)
    {
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (ULONG_PTR)((CREATESTRUCT*)lParam)->lpCreateParams);
    }

    CZaxxonEditor* pedit = (CZaxxonEditor*)GetWindowLongPtr(hwnd, GWLP_USERDATA);


    if (pedit)
        return pedit->WndProc(hwnd, uMsg, wParam, lParam);

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


CSongExtractionTask::CSongExtractionTask(HWND hwnd, CSong* psong)
    : CRunnableTask(RTF_DEFAULT), _hwnd(hwnd)
{
    _psong = psong;
    _psong->AddRef();
}

CSongExtractionTask::~CSongExtractionTask()
{
    _psong->Release();
}

STDMETHODIMP CSongExtractionTask::RunInitRT()
{
    LPITEMIDLIST pidl = ILCreateFromPath(_psong->szSong);
    if (pidl)
    {
        LPCITEMIDLIST pidlChild;
        IShellFolder2* psf;

        HRESULT hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder2, &psf), &pidlChild);

        if (SUCCEEDED(hr))
        {
            VARIANT v;
            hr = psf->GetDetailsEx(pidlChild, &SCID_MUSIC_Artist, &v);
            if (SUCCEEDED(hr))
            {
                VariantToStr(&v, _psong->szArtist, ARRAYSIZE(_psong->szArtist));
            }

            hr = psf->GetDetailsEx(pidlChild, &SCID_MUSIC_Album, &v);
            if (SUCCEEDED(hr))
            {
                VariantToStr(&v, _psong->szAlbum, ARRAYSIZE(_psong->szAlbum));
            }

            hr = psf->GetDetailsEx(pidlChild, &SCID_Title, &v);
            if (SUCCEEDED(hr))
            {
                VariantToStr(&v, _psong->szTitle, ARRAYSIZE(_psong->szTitle));
            }

            hr = psf->GetDetailsEx(pidlChild, &SCID_AUDIO_Duration, &v);
            if (SUCCEEDED(hr))
            {
                PROPVARIANT pv = *(PROPVARIANT*)&v;
                FILETIME ft = {pv.uhVal.LowPart, pv.uhVal.HighPart};
                SYSTEMTIME st;
                FileTimeToSystemTime(&ft, &st);

                GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT | TIME_NOTIMEMARKER, 
                    &st, NULL, _psong->szDuration, ARRAYSIZE(_psong->szDuration));
            }

            SendMessage(_hwnd, WM_UPDATESONG, (WPARAM)_psong, 0);

            psf->Release();
        }

        ILFree(pidl);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\zaxxon.h ===
#ifndef ZAXXON_H
#define ZAXXON_H

#include "bands.h"
#include "sccls.h"
#include "power.h"
#include "uxtheme.h"
#include "tmschema.h"
#include "runtask.h"

#define WM_SONGTHUMBDONE    WM_USER + 1
#define WM_SONGCHANGE       WM_USER + 2
#define WM_SONGSTOP         WM_USER + 3
#define WM_SETARTIST        WM_USER + 4
#define WM_SETALBUM         WM_USER + 5
#define WM_SETSONG          WM_USER + 6
#define WM_UPDATESONG       WM_USER + 7


class CSongExtractionTask;
class CMusicExtractionTask;
class CZaxxon;

class CSong
{
    int _cRef;
public:
    CSong();
    void AddRef();
    void Release();
    TCHAR szSong[MAX_PATH];
    TCHAR szTitle[MAX_PATH];
    TCHAR szArtist[MAX_PATH];
    TCHAR szAlbum[MAX_PATH];
    TCHAR szDuration[50];
    DWORD _id;
};


class CSongExtractionTask : public CRunnableTask
{
public:
    CSongExtractionTask(HWND hwnd, CSong* psong);

    STDMETHODIMP RunInitRT(void);

private:
    virtual ~CSongExtractionTask();

    HWND _hwnd;

    CSong* _psong;


};



class CZaxxonEditor
{
public:
    CZaxxon* _pzax;
    HWND _hwnd;
    HWND _hwndList;
    HWND _hwndToolbar;

    BOOL _fIgnoreChange;

    HDPA hSongList;

    void UpdateSong(CSong* psong);
    void LoadPlaylist();
    void SavePlaylist();
    void ClearPlaylist();
    void HighlightSong(PTSTR psz);
    void RemoveFromPlaylist();
    void InsertFilename(int i, PTSTR psz);
    void AddFilenameToListview(int i, PTSTR psz);
    void AddFilename(PTSTR psz);
    void AddToPlaylist();
    CZaxxonEditor(CZaxxon* pzax);
    ~CZaxxonEditor();

    BOOL Initialize();

    BOOL Show(BOOL fShow);

    LRESULT WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};


class CZaxxon : public CToolBand,
                public IWinEventHandler,
                public IDropTarget,
                public IShellMenuCallback
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CToolBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CToolBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * phwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL bEnterMode) {return E_NOTIMPL;};

    // *** IDeskBar methods ***
    virtual STDMETHODIMP SetClient(IUnknown* punk) { return E_NOTIMPL; };
    virtual STDMETHODIMP GetClient(IUnknown** ppunkClient) { return E_NOTIMPL; };
    virtual STDMETHODIMP OnPosRectChangeDB (LPRECT prc) { return E_NOTIMPL;};

    // ** IWinEventHandler ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);
    
    // *** IInputObject methods (override) ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** IShellMenuCallback methods ***
    virtual STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam);


    CZaxxon();
    virtual ~CZaxxon();

    HWND GetHWND()  {return _hwnd;}

    HRESULT RecurseAddFile(IShellFolder* psf);
    LRESULT _OnCommand(WORD wNotifyCode, WORD wID, HWND hwnd);
    LRESULT _OnNotify(LPNMHDR pnm);
    void _DoMenu();
    void SongStop();

    CZaxxonEditor* _pEdit;


    DWORD _dwViewMode;
    HTHEME      _hTheme;
    HIMAGELIST  _himlHot;
    HIMAGELIST  _himlDef;
    HFONT       _hfont;
    IZaxxonPlayer* _pzax;
    HWND        _hwndSongTile;
    IThumbnail* _pThumbnail;
    BOOL        _fHide;
    BOOL        _fAllowFadeout;
    BOOL        _fPlaying;
    BOOL        _fEditorShown;
    BYTE        _bOpacity;
    HBRUSH      _hbr;
    IShellTaskScheduler* _pScheduler;
    HMENU       _hmenuOpenFolder;

    TCHAR       _szArtist[MAX_PATH];
    TCHAR       _szSong[MAX_PATH];
    TCHAR       _szAlbum[MAX_PATH];

    HBITMAP     _hbmpAlbumArt;

    HWND _CreateWindow(HWND hwndParent);

    friend class CMusicExtractionTask;
    friend LRESULT ZaxxonWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend HRESULT CZaxxon_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
};

void FillRectClr(HDC hdc, PRECT prc, COLORREF clr);
#define RECTWIDTH(rc)  ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)
void CenterOnTopOf(HWND hwnd, HWND hwndOn);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\zaxxon\zaxxonpl.cpp ===
#include "priv.h"
#include "sccls.h"
#include <mmsystem.h>
#include <amstream.h>
#include "power.h"
#include "dsound.h"
#include "Zaxxon.h"

#ifndef SAFERELEASE
#define SAFERELEASE(x) if (x) { x->Release(); x = NULL; }
#endif

#define AUDIO_MAXBUFFER 64000   

// Which is better?
// 2Megs    causes 25% cpu usage every 5 seconds
// 1meg     causes 15% cpu usage every 2 seconds
// 100k     causes a contant 6% cpu usage 
// 64k?





#define EVENT_NONE          0x0
#define EVENT_PLAY          0x1
#define EVENT_STOP          0x2
#define EVENT_PAUSE         0x3
#define EVENT_FORWARD       0x4
#define EVENT_BACKWARD      0x5
#define EVENT_TERMINATE     0x6
#define EVENT_ADDSONG       0x7
#define EVENT_REMOVESONG    0x8
#define EVENT_NEXTSONG      0x9
#define EVENT_PREVSONG      0xA
#define EVENT_REGISTER      0xB
#define EVENT_DEREGISTER    0xC
#define EVENT_CLEARPLAYLIST 0xD
#define EVENT_SETSONG       0xE

struct ZAXXONEVENT
{
    ZAXXONEVENT():_dwEvent(EVENT_NONE), _pNext(NULL)  { }

    DWORD _dwEvent;
    ZAXXONEVENT* _pNext;

    union
    {
        TCHAR szPath[MAX_PATH];
        UINT szSeconds;
        UINT iIndex;
        HWND hwnd;
    };
};

typedef struct
{
    HANDLE hThread;
    CRITICAL_SECTION crit;
    HANDLE  hEvents;
    ZAXXONEVENT* pEvents;
} ZAXXON_ARG;


class CNotifyList 
{
    HDSA _hdsa;
public:
    CNotifyList()
    {
        _hdsa = DSA_Create(sizeof(HWND), 1);
    }
    ~CNotifyList()
    {
        if (_hdsa)
            DSA_Destroy(_hdsa);
    }

    void AddNotify(HWND hwnd)
    {
        if (_hdsa)
            DSA_AppendItem(_hdsa, &hwnd);
    }

    void RemoveNotify(HWND hwnd)
    {
        //
    }

    void SendNotify(UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        for (int i = 0; i < DSA_GetItemCount(_hdsa); i++)
        {
            DWORD_PTR l;
            HWND hwnd = *(HWND*)DSA_GetItemPtr(_hdsa, i);
            SendMessageTimeout(hwnd, uMsg, wParam, lParam, SMTO_ABORTIFHUNG, 100, &l);
        }
    }
};

class CPlayList
{
    int iIndex;
    HDPA _hdpa;
    static BOOL CALLBACK s_DestroyPlaylist(void* pv, void* pvData)
    {
        PWSTR psz = (PWSTR)pv;
        if (psz)
        {
            Str_SetPtr(&psz, NULL);
        }

        return TRUE;
    }

public:
    int GetIndex() { return iIndex;}
    CPlayList()
    {
        _hdpa = NULL;
        iIndex = -1;
    }

    ~CPlayList()
    {
        Empty();
    }

    BOOL AddSong(PWSTR psz)
    {
        if (!_hdpa)
        {
            _hdpa = DPA_Create(4);
        }

        if (!_hdpa)
            return FALSE;

        TCHAR* pszSet = NULL;
        Str_SetPtr(&pszSet, psz);
        return DPA_AppendPtr(_hdpa, pszSet) != -1;
    }

    BOOL RemoveSong(int i)
    {
        if (!_hdpa)
            return FALSE;

        if (i < iIndex)
            iIndex--;

        TCHAR* pszSet = (TCHAR*)DPA_DeletePtr(_hdpa, i);
        Str_SetPtr(&pszSet, NULL);
        return FALSE;
    }

    BOOL GetSong(int i, PWSTR psz, int cch)
    {
        if (!_hdpa)
            return FALSE;

        PWSTR pszSong = (PWSTR)DPA_FastGetPtr(_hdpa, i);
        if (pszSong)
        {
            iIndex = i;
            StrCpyN(psz, pszSong, cch);
            return TRUE;
        }

        return FALSE;
    }

    BOOL GetNextSong(PWSTR psz, int cch)
    {
        if (!_hdpa)
            return FALSE;

        if (iIndex >= DPA_GetPtrCount(_hdpa) - 1)
            iIndex = -1;
        return GetSong(++iIndex, psz, cch);

    }

    BOOL GetPrevSong(PWSTR psz, int cch)
    {
        if (!_hdpa)
            return FALSE;

        if (iIndex <= 0)
            iIndex = DPA_GetPtrCount(_hdpa);
        return GetSong(--iIndex, psz, cch);
    }

    BOOL Empty()
    {
        if (_hdpa)
        {
            DPA_DestroyCallback(_hdpa, s_DestroyPlaylist, NULL);
        }
        _hdpa = NULL;

        return TRUE;
    }
};

HRESULT CreateBuffer(IDirectSound* pds, WAVEFORMATEX* pwfx, DWORD dwBufferSize, IDirectSoundBuffer** ppdsb)
{
    HRESULT hr = S_OK;
    IDirectSoundBuffer* psbPrimary;
    // Get the primary buffer
    DSBUFFERDESC dsbdesc; 
    ZeroMemory(&dsbdesc, sizeof(DSBUFFERDESC));
    dsbdesc.dwSize = sizeof(DSBUFFERDESC);
    dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER;
    hr = pds->CreateSoundBuffer(&dsbdesc, &psbPrimary, NULL);
    if (SUCCEEDED(hr))
    {
        hr = psbPrimary->SetFormat(pwfx);

        if (SUCCEEDED(hr))
        {
            dsbdesc.dwFlags =   DSBCAPS_GETCURRENTPOSITION2 | 
                                DSBCAPS_GLOBALFOCUS         | 
                                DSBCAPS_CTRLPOSITIONNOTIFY;

            dsbdesc.dwBufferBytes = dwBufferSize;
            dsbdesc.lpwfxFormat = pwfx;

            hr = pds->CreateSoundBuffer(&dsbdesc, ppdsb, NULL);
        }
        psbPrimary->Release();
    }


    return hr;
}

HRESULT CreateDirectSound(IDirectSound** ppds)
{
    IDirectSound* pds = NULL;
    HRESULT hr = CoCreateInstance(CLSID_DirectSound, NULL, CLSCTX_INPROC_SERVER,
                          IID_IDirectSound, (void**)&pds);
    if (SUCCEEDED(hr))
    {
        hr = pds->Initialize(NULL);  // Don't support more than one at the moment.
        if (SUCCEEDED(hr))
        {
            hr = pds->SetCooperativeLevel(GetDesktopWindow(), DSSCL_PRIORITY);
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppds = pds;
        pds->AddRef();
    }

    SAFERELEASE(pds);
    return hr;
}

class CZaxxonPlayingSample
{
public:
    CZaxxonPlayingSample();
    ~CZaxxonPlayingSample();

    HRESULT Open(PWSTR psz);
    HRESULT SetBuffer(PBYTE pBuf, DWORD dwSize);
    HRESULT CopySampleData(PBYTE pBuffer1, DWORD dwBytesForBuffer1,
                           PBYTE pBuffer2, DWORD dwBytesForBuffer2,
                           DWORD* pdwBytesLeft1, DWORD* pdwBytesLeft2);
    HRESULT GetSampleFormat(WAVEFORMATEX* pwfx);

private:
    void CloseOut();
    HRESULT _SetupMediaStream();
    TCHAR _szPath[MAX_PATH];
    IAMMultiMediaStream *_pMMStream;
    IMediaStream *_pStream;
    IAudioStreamSample *_pSample;
    IAudioMediaStream *_pAudioStream;
    IAudioData *_pAudioData;
    WAVEFORMATEX _wfx;
    HANDLE _hRenderEvent;
    PBYTE _pBuffer;
};


CZaxxonPlayingSample::CZaxxonPlayingSample():
            _pMMStream(NULL), 
            _pStream(NULL),
            _pSample(NULL), 
            _pAudioStream(NULL),
            _pAudioData(NULL), 
            _hRenderEvent(NULL),
            _pBuffer(NULL)
{
    ZeroMemory(&_wfx, sizeof(WAVEFORMATEX));
}

CZaxxonPlayingSample::~CZaxxonPlayingSample()
{
    CloseOut();
}

void CZaxxonPlayingSample::CloseOut()
{
    ATOMICRELEASE(_pMMStream);
    ATOMICRELEASE(_pAudioData);
    ATOMICRELEASE(_pSample);
    ATOMICRELEASE(_pStream);
    ATOMICRELEASE(_pAudioStream);
    if (_hRenderEvent)
    {
        CloseHandle(_hRenderEvent);
        _hRenderEvent = NULL;
    }
}

HRESULT CZaxxonPlayingSample::Open(PWSTR psz)
{
    CloseOut();
    lstrcpy(_szPath, psz);
    return _SetupMediaStream();
}


HRESULT CZaxxonPlayingSample::SetBuffer(PBYTE pBuf, DWORD dwSize)
{
    if (_pAudioData && _pAudioStream)
    {
        _pAudioData->SetBuffer(dwSize, pBuf, 0);
        _pAudioData->SetFormat(&_wfx);

        _pBuffer = pBuf;

        return _pAudioStream->CreateSample(_pAudioData, 0, &_pSample);
    }

    return E_FAIL;
}


HRESULT CZaxxonPlayingSample::GetSampleFormat(WAVEFORMATEX* pwfx)
{
    CopyMemory(pwfx, &_wfx, sizeof(_wfx));
    return S_OK;
}

HRESULT CZaxxonPlayingSample::CopySampleData(PBYTE pBuffer1, DWORD dwBytesForBuffer1,
                                             PBYTE pBuffer2, DWORD dwBytesForBuffer2,
                                             DWORD* pdwBytesLeft1, DWORD* pdwBytesLeft2)
{
    if (!_pSample)
        return E_FAIL;

    HRESULT hr = _pSample->Update(0, _hRenderEvent, NULL, 0);
    if (FAILED(hr) || MS_S_ENDOFSTREAM == hr) 
    {
        return hr;
    }

    DWORD dwLength;
    WaitForSingleObject(_hRenderEvent, INFINITE);
    _pAudioData->GetInfo(NULL, NULL, &dwLength);

    *pdwBytesLeft1 = 0;
    *pdwBytesLeft2 = 0;

    // _pBuffer contains the audio data. Copy.
    if (dwLength < dwBytesForBuffer1)
    {
        *pdwBytesLeft2 = dwBytesForBuffer2;
        *pdwBytesLeft1 = dwBytesForBuffer1 - dwLength;

        dwBytesForBuffer1 = dwLength;
        dwBytesForBuffer2 = 0;
    }


    CopyMemory(pBuffer1, _pBuffer, dwBytesForBuffer1);
    dwLength -= dwBytesForBuffer1;

    if (dwBytesForBuffer2 > 0 && dwLength > 0)
    {
        CopyMemory(pBuffer2, _pBuffer + dwBytesForBuffer1, dwLength);
        if (dwLength < dwBytesForBuffer2)
            *pdwBytesLeft2 = dwBytesForBuffer2 - dwLength;
    }

    return hr;
}

HRESULT CZaxxonPlayingSample::_SetupMediaStream()
{
    HRESULT hr = E_INVALIDARG;
    if (_szPath[0] != 0)
    {
        hr = CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
 		         IID_IAMMultiMediaStream, (void **)&_pMMStream);
        if (SUCCEEDED(hr))
        {
            _pMMStream->Initialize(STREAMTYPE_READ, AMMSF_NOGRAPHTHREAD, NULL);
            _pMMStream->AddMediaStream(NULL, &MSPID_PrimaryAudio, 0, NULL);
            hr = _pMMStream->OpenFile(_szPath, AMMSF_RUN);
            if (SUCCEEDED(hr))
            {
                hr = CoCreateInstance(CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER,
                                                IID_IAudioData, (void **)&_pAudioData);

                if (SUCCEEDED(hr))
                {
                    hr = _pMMStream->GetMediaStream(MSPID_PrimaryAudio, &_pStream);
                    if (SUCCEEDED(hr))
                    {
                        hr = _pStream->QueryInterface(IID_IAudioMediaStream, (void **)&_pAudioStream);
                        if (SUCCEEDED(hr))
                        {
                            _pAudioStream->GetFormat(&_wfx);
                            _hRenderEvent = CreateEvent(NULL, NULL, TRUE, NULL);
                            hr = S_OK;

                        }
                    }
                }
            }
        }
    }

    return hr;
}

ZAXXONEVENT* GetZaxxonEvent(ZAXXON_ARG* pza)
{
    ZAXXONEVENT* pz = NULL;
    if (pza->pEvents)
    {
        EnterCriticalSection(&pza->crit);
        if (pza->pEvents)
        {
            pz = pza->pEvents;
            pza->pEvents = pza->pEvents->_pNext;
        }

        LeaveCriticalSection(&pza->crit);
    }

    return pz;
}

HRESULT CopySample(CZaxxonPlayingSample* pzax, IDirectSoundBuffer* pdsb, DWORD dwStart, DWORD dwNumBytes)
{
    HRESULT hr;
    PBYTE pBuffer1;
    PBYTE pBuffer2;
    DWORD dwBytesToCopyToBuffer1;
    DWORD dwBytesToCopyToBuffer2;
    DWORD dwBytesLeft1;
    DWORD dwBytesLeft2;

    if (!pdsb)
        return E_ACCESSDENIED;

    hr = pdsb->Lock(dwStart, dwNumBytes, (void**)&pBuffer1, &dwBytesToCopyToBuffer1,
                        (void**)&pBuffer2, &dwBytesToCopyToBuffer2, 0);
    if (SUCCEEDED(hr))
    {
        hr = pzax->CopySampleData(
                pBuffer1, dwBytesToCopyToBuffer1,
                pBuffer2, dwBytesToCopyToBuffer2,
                &dwBytesLeft1,
                &dwBytesLeft2);

        if (FAILED(hr) || MS_S_ENDOFSTREAM == hr) 
        {
            pdsb->Stop();
        }
        else
        {
            if (dwBytesLeft1 > 0)
            {
                ZeroMemory(pBuffer1 + dwBytesToCopyToBuffer1 - dwBytesLeft1, 
                    dwBytesLeft1);
            }

            if (dwBytesLeft2 > 0)
            {
                ZeroMemory(pBuffer2 + dwBytesToCopyToBuffer2 - dwBytesLeft2, 
                    dwBytesLeft2);
            }
        }

        pdsb->Unlock(pBuffer1, dwBytesToCopyToBuffer1,
                     pBuffer2, dwBytesToCopyToBuffer2);

    }

    return hr;
}

BOOL SetupSample(CZaxxonPlayingSample* pzaxSample, PWSTR psz, PBYTE pBuffer, DSBPOSITIONNOTIFY* rgdsbp, int cdsbpn, IDirectSound* pds, IDirectSoundBuffer** ppdsb)
{
    if (SUCCEEDED(pzaxSample->Open(psz)))
    {
        WAVEFORMATEX wfx;

        pzaxSample->SetBuffer(pBuffer, AUDIO_MAXBUFFER / 2);
        pzaxSample->GetSampleFormat(&wfx);

        if (SUCCEEDED(CreateBuffer(pds, &wfx, AUDIO_MAXBUFFER, ppdsb)))
        {
            IDirectSoundNotify* pdsn;
            if (SUCCEEDED((*ppdsb)->QueryInterface(IID_IDirectSoundNotify, (void**)&pdsn)))
            {
                for (int i = 0; i < cdsbpn; i++)
                {
                    ResetEvent(rgdsbp[i].hEventNotify);
                }

                pdsn->SetNotificationPositions(cdsbpn, rgdsbp);
                pdsn->Release();
            }

            if (SUCCEEDED(CopySample(pzaxSample, *ppdsb, 0, AUDIO_MAXBUFFER / 2)))
            {
                (*ppdsb)->SetCurrentPosition(0);
                (*ppdsb)->Play(0, 0, DSBPLAY_LOOPING);

                return TRUE;
            }
            else
            {
                (*ppdsb)->Release();
                *ppdsb = NULL;
            }
        }
    }

    return FALSE;
}

ULONG CALLBACK AudioRenderThread(LPVOID pvArg)
{
    CPlayList playlist;
    CNotifyList notifylist;
    ZAXXON_ARG* pza = (ZAXXON_ARG*)pvArg;
    HRESULT hr = CoInitialize(NULL);
    PBYTE pBuffer = (PBYTE)LocalAlloc(LMEM_FIXED, AUDIO_MAXBUFFER);
    if (SUCCEEDED(hr) && pBuffer)
    {
        IDirectSound* pds = NULL;
        IDirectSoundBuffer* pdsb = NULL;

        HANDLE rgEvent[] = 
        {
            CreateEvent(NULL, FALSE, FALSE, NULL),
            CreateEvent(NULL, FALSE, FALSE, NULL),
            pza->hEvents,
        };

        DSBPOSITIONNOTIFY rgdsbp[] = 
        {
            {0, rgEvent[0]},
            {AUDIO_MAXBUFFER / 2, rgEvent[1]},
        };

        if (SUCCEEDED(CreateDirectSound(&pds)))
        {
            CZaxxonPlayingSample zaxSample;

            BOOL fPaused = FALSE;
            BOOL fDone = FALSE;
            while (!fDone)
            {
                DWORD dwEvent = WaitForMultipleObjects(ARRAYSIZE(rgEvent), rgEvent, FALSE, INFINITE);
                dwEvent -= WAIT_OBJECT_0;

                if (dwEvent < 2)
                {
                    DWORD dwStartByte;
                    if (dwEvent + 1 >= ARRAYSIZE(rgdsbp))
                        dwStartByte = rgdsbp[0].dwOffset;
                    else
                        dwStartByte = rgdsbp[dwEvent + 1].dwOffset;

                    hr = CopySample(&zaxSample, pdsb, dwStartByte, AUDIO_MAXBUFFER / 2);
                    if (FAILED(hr) || MS_S_ENDOFSTREAM == hr)
                    {
                        TCHAR pszPath[MAX_PATH];
                        if (playlist.GetNextSong(pszPath, MAX_PATH))
                        {
                            ATOMICRELEASE(pdsb);
                            notifylist.SendNotify(WM_SONGCHANGE, (WPARAM)pszPath, 0);
                            SetupSample(&zaxSample, pszPath, pBuffer, rgdsbp, ARRAYSIZE(rgdsbp), pds, &pdsb);
                        }
                    }
                }
                else
                {
                    ZAXXONEVENT* pZaxxonEvent;
                    while ((pZaxxonEvent = GetZaxxonEvent(pza)))
                    {
                        switch (pZaxxonEvent->_dwEvent)
                        {
                        case EVENT_STOP:
                            if (pdsb)
                                pdsb->Stop();
                            notifylist.SendNotify(WM_SONGSTOP, 0, 0);
                            fPaused = FALSE;
                            break;

                        case EVENT_ADDSONG:
                            playlist.AddSong(pZaxxonEvent->szPath);
                            break;

                        case EVENT_REMOVESONG:
                            if (pZaxxonEvent->iIndex == playlist.GetIndex())
                            {
                                fPaused = FALSE;
                                TCHAR pszPath[MAX_PATH];
                                if (playlist.GetNextSong(pszPath, MAX_PATH))
                                {
                                    if (pdsb)
                                        pdsb->Stop();
                                    ATOMICRELEASE(pdsb);
                                    notifylist.SendNotify(WM_SONGCHANGE, (WPARAM)pszPath, 0);
                                    SetupSample(&zaxSample, pszPath, pBuffer, rgdsbp, ARRAYSIZE(rgdsbp), pds, &pdsb);
                                }
                            }

                            playlist.RemoveSong(pZaxxonEvent->iIndex);
                            break;

                        case EVENT_CLEARPLAYLIST:
                            if (pdsb)
                                pdsb->Stop();
                            fPaused = FALSE;
                            notifylist.SendNotify(WM_SONGSTOP, 0, 0);
                            playlist.Empty();
                            break;

                        case EVENT_REGISTER:
                            notifylist.AddNotify(pZaxxonEvent->hwnd);
                            break;
                        case EVENT_DEREGISTER:
                            notifylist.RemoveNotify(pZaxxonEvent->hwnd);
                            break;

                        case EVENT_PLAY:
                            if (fPaused)
                            {
                                if (pdsb)
                                    pdsb->Play(0, 0, DSBPLAY_LOOPING);
                                fPaused = FALSE;
                            }
                            else
                            {
                                fPaused = FALSE;
                                TCHAR pszPath[MAX_PATH];
                                if (playlist.GetNextSong(pszPath, MAX_PATH))
                                {
                                    ATOMICRELEASE(pdsb);
                                    notifylist.SendNotify(WM_SONGCHANGE, (WPARAM)pszPath, 0);
                                    SetupSample(&zaxSample, pszPath, pBuffer, rgdsbp, ARRAYSIZE(rgdsbp), pds, &pdsb);
                                }
                            }
                            break;

                        case EVENT_NEXTSONG:
                            {
                                fPaused = FALSE;
                                TCHAR pszPath[MAX_PATH];
                                if (playlist.GetNextSong(pszPath, MAX_PATH))
                                {
                                    if (pdsb)
                                        pdsb->Stop();
                                    ATOMICRELEASE(pdsb);
                                    notifylist.SendNotify(WM_SONGCHANGE, (WPARAM)pszPath, 0);
                                    SetupSample(&zaxSample, pszPath, pBuffer, rgdsbp, ARRAYSIZE(rgdsbp), pds, &pdsb);
                                }
                            }
                            break;

                        case EVENT_PREVSONG:
                            {
                                fPaused = FALSE;
                                TCHAR pszPath[MAX_PATH];
                                if (playlist.GetPrevSong(pszPath, MAX_PATH))
                                {
                                    if (pdsb)
                                        pdsb->Stop();
                                    ATOMICRELEASE(pdsb);
                                    notifylist.SendNotify(WM_SONGCHANGE, (WPARAM)pszPath, 0);
                                    SetupSample(&zaxSample, pszPath, pBuffer, rgdsbp, ARRAYSIZE(rgdsbp), pds, &pdsb);

                                }
                            }
                            break;

                        case EVENT_SETSONG:
                            {
                                fPaused = FALSE;
                                TCHAR pszPath[MAX_PATH];
                                if (playlist.GetSong(pZaxxonEvent->iIndex, pszPath, MAX_PATH))
                                {
                                    if (pdsb)
                                        pdsb->Stop();
                                    ATOMICRELEASE(pdsb);
                                    notifylist.SendNotify(WM_SONGCHANGE, (WPARAM)pszPath, 0);
                                    SetupSample(&zaxSample, pszPath, pBuffer, rgdsbp, ARRAYSIZE(rgdsbp), pds, &pdsb);

                                }
                            }


                        case EVENT_PAUSE:
                            if (pdsb)
                                pdsb->Stop();
                            fPaused = TRUE;

                            break;

                        case EVENT_TERMINATE:
                            fDone = TRUE;
                            break;
                        }

                        delete pZaxxonEvent;
                    }

                    ResetEvent(pza->hEvents);
                }
            }
        }

        SAFERELEASE(pdsb);
        SAFERELEASE(pds);

        if (rgEvent[0])
            CloseHandle(rgEvent[0]);

        if (rgEvent[1])
            CloseHandle(rgEvent[1]);

        CoUninitialize();
    }

    if (pBuffer)
        LocalFree((HLOCAL)pBuffer);
    return 1;
}

class CZaxxonPlayer : public IZaxxonPlayer
{
    ZAXXON_ARG  _za;
    LPTSTR _pszFile;
    int _cRef;
    HRESULT _LoadTypeLib();
    BOOL    _AddPlayEvent(int i);
    BOOL    _AddRemoveEvent(int i);
    BOOL    _AddSongEvent(int iEvent, PWSTR pszFile);
    BOOL    _AddHWNDEvent(int iEvent, HWND hwnd);
    BOOL    _AddPositionEvent(DWORD dwEvent, UINT uSeconds);
    BOOL    _AddEvent(DWORD dwEvent);
    BOOL    _AddEventToList(ZAXXONEVENT* pzEvent);
public:
    CZaxxonPlayer();
    virtual ~CZaxxonPlayer();

    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP Play();
    STDMETHODIMP Stop();
    STDMETHODIMP NextSong();
    STDMETHODIMP PrevSong();
    STDMETHODIMP SetSong(int i);
    STDMETHODIMP Forward(UINT iSeconds);
    STDMETHODIMP Backward(UINT iSeconds);
    STDMETHODIMP Pause();
    STDMETHODIMP AddSong(LPWSTR pszFile);
    STDMETHODIMP RemoveSong(int i);
    STDMETHODIMP Register(HWND hwnd);
    STDMETHODIMP DeRegister(HWND hwnd);
    STDMETHODIMP ClearPlaylist();
};

BOOL CZaxxonPlayer::_AddRemoveEvent(int i)
{
    ZAXXONEVENT* pze = new ZAXXONEVENT;
    if (pze)
    {
        pze->_dwEvent = EVENT_REMOVESONG;
        pze->iIndex = i;
        return _AddEventToList(pze);
    }
    return FALSE;
}

BOOL CZaxxonPlayer::_AddPlayEvent(int i)
{
    ZAXXONEVENT* pze = new ZAXXONEVENT;
    if (pze)
    {
        pze->_dwEvent = EVENT_SETSONG;
        pze->iIndex = i;
        return _AddEventToList(pze);
    }
    return FALSE;
}

BOOL CZaxxonPlayer::_AddPositionEvent(DWORD dwEvent, UINT uSeconds)
{
    return FALSE;

}

BOOL CZaxxonPlayer::_AddHWNDEvent(int iEvent, HWND hwnd)
{
    ZAXXONEVENT* pze = new ZAXXONEVENT;
    if (pze)
    {
        pze->_dwEvent = iEvent;
        pze->hwnd = hwnd;
        return _AddEventToList(pze);
    }

    return FALSE;
}


BOOL CZaxxonPlayer::_AddSongEvent(int iEvent, PWSTR pszFile)
{
    ZAXXONEVENT* pze = new ZAXXONEVENT;
    if (pze)
    {
        pze->_dwEvent = iEvent;
        StrCpyN(pze->szPath, pszFile, ARRAYSIZE(pze->szPath));
        return _AddEventToList(pze);
    }

    return FALSE;
}


BOOL CZaxxonPlayer::_AddEvent(DWORD dwEvent)
{
    ZAXXONEVENT* pze = new ZAXXONEVENT;
    if (pze)
    {
        pze->_dwEvent = dwEvent;
        return _AddEventToList(pze);
    }
    return FALSE;
}

BOOL CZaxxonPlayer::_AddEventToList(ZAXXONEVENT* pzEvent)
{
    EnterCriticalSection(&_za.crit);
    BOOL fRet = FALSE;
    ZAXXONEVENT** ppza = &_za.pEvents;

    while (*ppza)
    {
        ppza = &(*ppza)->_pNext;
    }

    *ppza = pzEvent;
    SetEvent(_za.hEvents);

    LeaveCriticalSection(&_za.crit);

    return fRet;
}



CZaxxonPlayer::CZaxxonPlayer() : _cRef(1)
{
    ZeroMemory(&_za, sizeof(_za));
    InitializeCriticalSection(&_za.crit);
    _za.hEvents = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (_za.hEvents)
    {
        DWORD thread;
        _za.hThread = CreateThread(NULL, 0, AudioRenderThread, (LPVOID)&_za, 0, &thread);
    }
}

CZaxxonPlayer::~CZaxxonPlayer()
{
    if (_za.hThread)
    {
        _AddEvent(EVENT_TERMINATE);
        WaitForSingleObject(_za.hThread, INFINITE);

        CloseHandle(_za.hThread);
    }

    CloseHandle(_za.hEvents);

    DeleteCriticalSection(&_za.crit);
    for (ZAXXONEVENT* pza = GetZaxxonEvent(&_za); pza; pza = GetZaxxonEvent(&_za))
    {
        delete pza;
    }
}

STDMETHODIMP CZaxxonPlayer::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CZaxxonPlayer, IZaxxonPlayer),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CZaxxonPlayer::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CZaxxonPlayer::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CZaxxonPlayer::Play()
{
    _AddEvent(EVENT_PLAY);
    return S_OK;
}

HRESULT CZaxxonPlayer::Stop()
{
    _AddEvent(EVENT_STOP);
    return E_NOTIMPL;
}

HRESULT CZaxxonPlayer::Forward(UINT iSeconds)
{
    return E_NOTIMPL;
}

HRESULT CZaxxonPlayer::Backward(UINT iSeconds)
{
    return E_NOTIMPL;
}

HRESULT CZaxxonPlayer::Pause()
{
    _AddEvent(EVENT_PAUSE);
    return S_OK;

}

HRESULT CZaxxonPlayer::AddSong(LPWSTR pszFile)
{
    _AddSongEvent(EVENT_ADDSONG, pszFile);

    return S_OK;
}

HRESULT CZaxxonPlayer::RemoveSong(int i)
{
    _AddRemoveEvent(i);

    return S_OK;
}

HRESULT CZaxxonPlayer::NextSong()
{
    _AddEvent(EVENT_NEXTSONG);

    return S_OK;
}

HRESULT CZaxxonPlayer::PrevSong()
{
    _AddEvent(EVENT_PREVSONG);

    return S_OK;
}

HRESULT CZaxxonPlayer::SetSong(int i)
{
    _AddPlayEvent(i);
    return S_OK;
}

HRESULT CZaxxonPlayer::Register(HWND hwnd)
{
    _AddHWNDEvent(EVENT_REGISTER, hwnd);
    return S_OK;

}

HRESULT CZaxxonPlayer::DeRegister(HWND hwnd)
{
    _AddHWNDEvent(EVENT_REGISTER, hwnd);
    return S_OK;
}

HRESULT CZaxxonPlayer::ClearPlaylist()
{
    _AddEvent(EVENT_CLEARPLAYLIST);

    return S_OK;
}



STDAPI CZaxxonPlayer_CreateInstance(IUnknown *punk, REFIID riid, void **ppv)
{
    HRESULT hr;
    CZaxxonPlayer *pzax = new CZaxxonPlayer;
    if (pzax)
    {
        hr = pzax->QueryInterface(riid, ppv);
        pzax->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppv = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\classf.cpp ===
//=--------------------------------------------------------------------------=
// ClassF.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the implementation of the ClassFactory object. we support 
// IClassFactory and IClassFactory2
//
#include "IPServer.H"
#include "LocalSrv.H"

#include "ClassF.H"
#include "Globals.H"
#include "Unknown.H"                    // for CREATEFNOFOBJECT

//=--------------------------------------------------------------------------=
// private module level data
//=--------------------------------------------------------------------------=
//

// ASSERT and FAIL require this
//
SZTHISFILE

// private routines for this file
//
HRESULT   CreateOleObjectFromIndex(IUnknown *, int Index, void **, REFIID);

//=--------------------------------------------------------------------------=
// CClassFactory::CClassFactory
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    int            - [in] index into our global table of objects for this guy
//
// Notes:
//
CClassFactory::CClassFactory
(
    int iIndex
)
: m_iIndex(iIndex)
{
    m_cRefs = 1;
}


//=--------------------------------------------------------------------------=
// CClassFactory::CClassFactory
//=--------------------------------------------------------------------------=
// "Life levels all men.  Death reveals the eminent."
// - George Bernard Shaw (1856 - 1950)
//
// Notes:
//
CClassFactory::~CClassFactory ()
{
    ASSERT(m_cRefs == 0, "Object being deleted with refs!");
    return;
}

//=--------------------------------------------------------------------------=
// CClassFactory::QueryInterface
//=--------------------------------------------------------------------------=
// the user wants another interface.  we won't give 'em. very many.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CClassFactory::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    void *pv;

    CHECK_POINTER(ppvObjOut);

    // we support IUnknown, and the two CF interfaces
    //
    if (DO_GUIDS_MATCH(riid, IID_IClassFactory)) {
        pv = (void *)(IClassFactory *)this;
    } else if (DO_GUIDS_MATCH(riid, IID_IClassFactory2)) {
        pv = (void *)(IClassFactory2 *)this;
    } else if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        pv = (void *)(IUnknown *)this;
    } else {
        *ppvObjOut = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)pv)->AddRef();
    *ppvObjOut = pv;
    return S_OK;
}




//=--------------------------------------------------------------------------=
// CClassFactory::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CClassFactory::AddRef
(
    void
)
{
    return ++m_cRefs;
}

//=--------------------------------------------------------------------------=
// CClassFactory::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CClassFactory::Release
(
    void
)
{
    ASSERT(m_cRefs, "No Refs, and we're being released!");
    if(--m_cRefs)
        return m_cRefs;

    delete this;
    return 0;
}

//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstance
//=--------------------------------------------------------------------------=
// create an instance of some sort of object.
//
// Parameters:
//    IUnknown *        - [in]  controlling IUknonwn for aggregation
//    REFIID            - [in]  interface id for new object
//    void **           - [out] pointer to new interface object.
//
// Output:
//    HRESULT           - S_OK, E_NOINTERFACE, E_UNEXPECTED,
//                        E_OUTOFMEMORY, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstance
(
    IUnknown *pUnkOuter,
    REFIID    riid,
    void    **ppvObjOut
)
{
    // check args
    //
    if (!ppvObjOut)
        return E_INVALIDARG;

    // check to see if we've done our licensing work.  we do this as late
    // as possible that people calling CreateInstanceLic don't suffer from
    // a performance hit here.
    //
    // crit sect this for apartment threading, since it's global
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fCheckedForLicense) {
        g_fMachineHasLicense = CheckForLicense();
        g_fCheckedForLicense = TRUE;
    }
    LeaveCriticalSection(&g_CriticalSection);

    // check to see if they have the appropriate license to create this stuff
    //
    if (!g_fMachineHasLicense)
        return CLASS_E_NOTLICENSED;

    // try to create one of the objects that we support
    //
    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CClassFactory::LockServer
//=--------------------------------------------------------------------------=
// lock the server so we can't unload
//
// Parameters:
//    BOOL        - [in] TRUE means addref, false means release lock count.
//
// Output:
//    HRESULT     - S_OK, E_FAIL, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP CClassFactory::LockServer
(
    BOOL fLock
)
{
    // update the lock count.  crit sect these in case of another thread.
    //
    if (fLock)  
        InterlockedIncrement(&g_cLocks);
    else {
        ASSERT(g_cLocks, "D'oh! Lock Counting Problem");
        InterlockedDecrement(&g_cLocks);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CClassFactory::GetLicInfo
//=--------------------------------------------------------------------------=
// IClassFactory2 GetLicInfo
//
// Parameters:
//    LICINFO *          - unclear
//
// Output:
//    HRESULT            - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::GetLicInfo
(
    LICINFO *pLicInfo
)
{
    CHECK_POINTER(pLicInfo);

    pLicInfo->cbLicInfo = sizeof(LICINFO);

    // This says whether RequestLicKey will work
    //
    pLicInfo->fRuntimeKeyAvail = g_fMachineHasLicense;

    // This says whether the standard CreateInstance will work
    //
    pLicInfo->fLicVerified = g_fMachineHasLicense;

    return S_OK;
}


//=--------------------------------------------------------------------------=
// CClassFactory::RequestLicKey
//=--------------------------------------------------------------------------=
// IClassFactory2 RequestLicKey
//
// Parameters:
//    DWORD             - [in]  reserved
//    BSTR *            - [out] unclear
//
// Output:
//    HRESULT           - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::RequestLicKey
(
    DWORD  dwReserved,
    BSTR  *pbstr
)
{
    // if the machine isn't licensed, then we're not about to give this to them !
    //
    if (!g_fMachineHasLicense)
        return CLASS_E_NOTLICENSED;

    *pbstr = GetLicenseKey();
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
}


//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstanceLic
//=--------------------------------------------------------------------------=
// create a new instance given a licensing key, etc ...
//
// Parameters:
//    IUnknown *        - [in]  controlling IUnknown for aggregation
//    IUnknown *        - [in]  reserved, must be NULL
//    REFIID            - [in]  IID We're looking for.
//    BSTR              - [in]  license key
//    void **           - [out] where to put the new object.
//
// Output:
//    HRESULT           - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstanceLic
(
    IUnknown *pUnkOuter,
    IUnknown *pUnkReserved,
    REFIID    riid,
    BSTR      bstrKey,
    void    **ppvObjOut
)
{
    *ppvObjOut = NULL;

    // go and see if the key they gave us matches.
    //
    if (!CheckLicenseKey(bstrKey))
        return CLASS_E_NOTLICENSED;

    // if it does, then go and create the object.
    //
    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CreateOleObjectFromIndex
//=--------------------------------------------------------------------------=
// given an index in our object table, create an object from it.
//
// Parameters:
//    IUnknown *       - [in]  Controlling Unknown, if any, for aggregation
//    int              - [in]  index into our global table
//    void **          - [out] where to put resulting object.
//    REFIID           - [in]  the interface they want resulting object to be.
//
// Output:
//    HRESULT          - S_OK, E_OUTOFMEMORY, E_NOINTERFACE
//
// Notes:
//
HRESULT CreateOleObjectFromIndex
(
    IUnknown *pUnkOuter,
    int       iIndex,
    void    **ppvObjOut,
    REFIID    riid
)
{
    IUnknown *pUnk = NULL;
    HRESULT   hr;

    // go and create the object
    //
    ASSERT(CREATEFNOFOBJECT(iIndex), "All creatable objects must have creation fn!");
    pUnk = CREATEFNOFOBJECT(iIndex)(pUnkOuter);

    // sanity check and make sure the object actually got allocated.
    //
    RETURN_ON_NULLALLOC(pUnk);

    // make sure we support aggregation here properly -- if they gave us
    // a controlling unknown, then they -must- ask for IUnknown, and we'll
    // give them the private unknown the object gave us.
    //
    if (pUnkOuter) {
        if (!DO_GUIDS_MATCH(riid, IID_IUnknown)) {
            pUnk->Release();
            return E_INVALIDARG;
        }

        *ppvObjOut = (void *)pUnk;
        hr = S_OK;
    } else {

        // QI for whatever the user wants.
        //
        hr = pUnk->QueryInterface(riid, ppvObjOut);
        pUnk->Release();
        RETURN_ON_FAILURE(hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\autoobj.cpp ===
//=--------------------------------------------------------------------------=
// AutoObj.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown, dispatch and
// error info implementations for them.
//
#include "IPServer.H"
#include "LocalSrv.H"

#include "AutoObj.H"
#include "Globals.H"
#include "Util.H"


// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// CAutomationObject::CAutomationObject
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    IUnknown *      - [in] controlling Unknown
//    int             - [in] the object type that we are
//    void *          - [in] the VTable of of the object we really are.
//
// Notes:
//
CAutomationObject::CAutomationObject 
(
    IUnknown *pUnkOuter,
    int   ObjType,
    void *pVTable,
	BOOL fExpandoEnabled
)
: CUnknownObject(pUnkOuter, pVTable), m_ObjectType (ObjType)
{
    m_fLoadedTypeInfo = FALSE;
	m_fExpandoEnabled = (BYTE)fExpandoEnabled;
	m_pexpando = NULL;
}


//=--------------------------------------------------------------------------=
// CAutomationObject::~CAutomationObject
//=--------------------------------------------------------------------------=
// "I have a rendezvous with Death, At some disputed barricade"
// - Alan Seeger (1888-1916)
//
// Notes:
//
CAutomationObject::~CAutomationObject ()
{
    // if we loaded up a type info, release our count on the globally stashed
    // type infos, and release if it becomes zero.
    //
    if (m_fLoadedTypeInfo) {

        // we have to crit sect this since it's possible to have more than
        // one thread partying with this object.
        //
        EnterCriticalSection(&g_CriticalSection);
        ASSERT(CTYPEINFOOFOBJECT(m_ObjectType), "Bogus ref counting on the Type Infos");
        CTYPEINFOOFOBJECT(m_ObjectType)--;

        // if we're the last one, free it!
        //
        if (!CTYPEINFOOFOBJECT(m_ObjectType)) {
            PTYPEINFOOFOBJECT(m_ObjectType)->Release();
            PTYPEINFOOFOBJECT(m_ObjectType) = NULL;
        }
        LeaveCriticalSection(&g_CriticalSection);
    }

	if (m_pexpando)
	{
		delete m_pexpando;
	}
    return;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// the controlling unknown will call this for us in the case where they're
// looking for a specific interface.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CAutomationObject::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    ASSERT(ppvObjOut, "controlling Unknown should be checking this!");

    // start looking for the guids we support, namely IDispatch, and 
    // IDispatchEx

    if (DO_GUIDS_MATCH(riid, IID_IDispatch)) {
		// If expando functionality is enabled, attempt to allocate an
		// expando object and return that for the IDispatch interface.
		// If the allocation fails, we will fall back on using the regular
		// IDispatch from m_pvInterface;
		if (m_fExpandoEnabled)
		{
			if (!m_pexpando)
				m_pexpando = new CExpandoObject(m_pUnkOuter, (IDispatch*) m_pvInterface);  

			if (m_pexpando)
			{
				*ppvObjOut = (void*)(IDispatch*) m_pexpando;
				((IUnknown *)(*ppvObjOut))->AddRef();
				return S_OK;
			}
		}

        *ppvObjOut = (void*) (IDispatch*) m_pvInterface;
        ((IUnknown *)(*ppvObjOut))->AddRef();
        return S_OK;
    }
    else if (DO_GUIDS_MATCH(riid, IID_IDispatchEx) && m_fExpandoEnabled) {
		// Allocate the expando object if it hasn't been allocated already
		if (!m_pexpando)
			m_pexpando = new CExpandoObject(m_pUnkOuter, (IDispatch*) m_pvInterface);  

		// If the allocation succeeded, return the IDispatchEx interface from
		// the expando.  Otherwise fall through to CUnknownObject::InternalQueryInterface,
		// (which will most likely fail)
		if (m_pexpando)
		{
			 *ppvObjOut = (void *)(IDispatchEx *) m_pexpando;
			((IUnknown *)(*ppvObjOut))->AddRef();
			return S_OK;
		}
    }

    // just get our parent class to process it from here on out.
    //
    return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfoCount
//=--------------------------------------------------------------------------=
// returns the number of type information interfaces that the object provides
//
// Parameters:
//    UINT *            - [out] the number of interfaces supported.
//
// Output:
//    HRESULT           - S_OK, E_NOTIMPL, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CAutomationObject::GetTypeInfoCount
(
    UINT *pctinfo
)
{
    // arg checking
    //
    if (!pctinfo)
        return E_INVALIDARG;

    // we support GetTypeInfo, so we need to return the count here.
    //
    *pctinfo = 1;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfo
//=--------------------------------------------------------------------------=
// Retrieves a type information object, which can be used to get the type
// information for an interface.
//
// Parameters:
//    UINT              - [in]  the type information they'll want returned
//    LCID              - [in]  the LCID of the type info we want
//    ITypeInfo **      - [out] the new type info object.
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, etc.
//
// Notes:
//
STDMETHODIMP CAutomationObject::GetTypeInfo
(
    UINT        itinfo,
    LCID        lcid,
    ITypeInfo **ppTypeInfoOut
)
{
    DWORD       dwPathLen;
    char        szDllPath[MAX_PATH];
    HRESULT     hr;
    ITypeLib   *pTypeLib;
    ITypeInfo **ppTypeInfo =NULL;

    // arg checking
    //
    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (!ppTypeInfoOut)
        return E_POINTER;

    *ppTypeInfoOut = NULL;

    // ppTypeInfo will point to our global holder for this particular
    // type info.  if it's null, then we have to load it up. if it's not
    // NULL, then it's already loaded, and we're happy.
    // crit sect this entire nightmare so we're okay with multiple
    // threads trying to use this object.
    //
    EnterCriticalSection(&g_CriticalSection);
    ppTypeInfo = PPTYPEINFOOFOBJECT(m_ObjectType);

    if (*ppTypeInfo == NULL) {

        ITypeInfo *pTypeInfoTmp;
        HREFTYPE   hrefType;

        // we don't have the type info around, so go load it.
        //
        hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 0,
                            LANG_NEUTRAL, &pTypeLib);

        // if, for some reason, we failed to load the type library this
        // way, we're going to try and load the type library directly out of
        // our resources.  this has the advantage of going and re-setting all
        // the registry information again for us.
        //
        if (FAILED(hr)) {

            dwPathLen = GetModuleFileName(g_hInstance, szDllPath, MAX_PATH);
            if (!dwPathLen) {
                hr = E_FAIL;
                goto CleanUp;
            }

            MAKE_WIDEPTR_FROMANSI(pwsz, szDllPath);
            hr = LoadTypeLib(pwsz, &pTypeLib);
            CLEANUP_ON_FAILURE(hr);
        }

        // we've got the Type Library now, so get the type info for the interface
        // we're interested in.
        //
        hr = pTypeLib->GetTypeInfoOfGuid((REFIID)INTERFACEOFOBJECT(m_ObjectType), &pTypeInfoTmp);
        pTypeLib->Release();
        CLEANUP_ON_FAILURE(hr);

        // the following couple of lines of code are to dereference the dual
        // interface stuff and take us right to the dispatch portion of the
        // interfaces.
        //
        hr = pTypeInfoTmp->GetRefTypeOfImplType(0xffffffff, &hrefType);
        if (FAILED(hr)) {
            pTypeInfoTmp->Release();
            goto CleanUp;
        }

        hr = pTypeInfoTmp->GetRefTypeInfo(hrefType, ppTypeInfo);
        pTypeInfoTmp->Release();
        CLEANUP_ON_FAILURE(hr);

        // add an extra reference to this object.  if it ever becomes zero, then
        // we need to release it ourselves.  crit sect this since more than
        // one thread can party on this object.
        //
        CTYPEINFOOFOBJECT(m_ObjectType)++;
        m_fLoadedTypeInfo = TRUE;
    }


    // we still have to go and addref the Type info object, however, so that
    // the people using it can release it.
    //
    (*ppTypeInfo)->AddRef();
    *ppTypeInfoOut = *ppTypeInfo;
    hr = S_OK;

  CleanUp:
    LeaveCriticalSection(&g_CriticalSection);
    return hr;
}



//=--------------------------------------------------------------------------=
// CAutomationObject::GetIDsOfNames
//=--------------------------------------------------------------------------=
// Maps a single member and an optional set of argument names to a
// corresponding set of integer DISPIDs
//
// Parameters:
//    REFIID            - [in]  must be IID_NULL
//    OLECHAR **        - [in]  array of names to map.
//    UINT              - [in]  count of names in the array.
//    LCID              - [in]  LCID on which to operate
//    DISPID *          - [in]  place to put the corresponding DISPIDs.
//
// Output:
//    HRESULT           - S_OK, E_OUTOFMEMORY, DISP_E_UNKNOWNNAME,
//                        DISP_E_UNKNOWNLCID
//
// Notes:
//    - we're just going to use DispGetIDsOfNames to save us a lot of hassle,
//      and to let this superclass handle it.
//
STDMETHODIMP CAutomationObject::GetIDsOfNames
(
    REFIID    riid,
    OLECHAR **rgszNames,
    UINT      cNames,
    LCID      lcid,
    DISPID   *rgdispid
)
{
    HRESULT     hr;
    ITypeInfo  *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get the type info for this dude!
    //
    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    RETURN_ON_FAILURE(hr);

    // use the standard provided routines to do all the work for us.
    //
    hr = pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    pTypeInfo->Release();

    return hr;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::Invoke
//=--------------------------------------------------------------------------=
// provides access to the properties and methods on this object.
//
// Parameters:
//    DISPID            - [in]  identifies the member we're working with.
//    REFIID            - [in]  must be IID_NULL.
//    LCID              - [in]  language we're working under
//    USHORT            - [in]  flags, propput, get, method, etc ...
//    DISPPARAMS *      - [in]  array of arguments.
//    VARIANT *         - [out] where to put result, or NULL if they don't care.
//    EXCEPINFO *       - [out] filled in in case of exception
//    UINT *            - [out] where the first argument with an error is.
//
// Output:
//    HRESULT           - tonnes of them.
//
// Notes:
//    
STDMETHODIMP CAutomationObject::Invoke
(
    DISPID      dispid,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS *pdispparams,
    VARIANT    *pvarResult,
    EXCEPINFO  *pexcepinfo,
    UINT       *puArgErr
)
{
    HRESULT    hr;
    ITypeInfo *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get our typeinfo first!
    //
    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    RETURN_ON_FAILURE(hr);

    // Clear exceptions
    //
    SetErrorInfo(0L, NULL);

    // This is exactly what DispInvoke does--so skip the overhead.
    //
    hr = pTypeInfo->Invoke(m_pvInterface, dispid, wFlags,
                           pdispparams, pvarResult,
                           pexcepinfo, puArgErr);
    pTypeInfo->Release();

	return hr;

}

//=--------------------------------------------------------------------------=
// CAutomationObject::Exception
//=--------------------------------------------------------------------------=
// fills in the rich error info object so that both our vtable bound interfaces
// and calls through ITypeInfo::Invoke get the right error informaiton.
//
// Parameters:
//    HRESULT          - [in] the SCODE that should be associated with this err
//    WORD             - [in] the RESOURCE ID of the error message.
//    DWORD            - [in] helpcontextid for the error
//
// Output:
//    HRESULT          - the HRESULT that was passed in.
//
// Notes:
//
HRESULT CAutomationObject::Exception
(
    HRESULT hrExcep,
    WORD    idException,
    DWORD   dwHelpContextID
)
{
    ICreateErrorInfo *pCreateErrorInfo;
    IErrorInfo *pErrorInfo;
    WCHAR   wszTmp[256];
    char    szTmp[256];
    HRESULT hr;


    // first get the createerrorinfo object.
    //
    hr = CreateErrorInfo(&pCreateErrorInfo);
    if (FAILED(hr)) return hrExcep;

    MAKE_WIDEPTR_FROMANSI(wszHelpFile, HELPFILEOFOBJECT(m_ObjectType));

    // set up some default information on it.
    //
    pCreateErrorInfo->SetGUID((REFIID)INTERFACEOFOBJECT(m_ObjectType));
    pCreateErrorInfo->SetHelpFile(wszHelpFile);
    pCreateErrorInfo->SetHelpContext(dwHelpContextID);

    // load in the actual error string value.  max of 256.
    //
    LoadString(GetResourceHandle(), idException, szTmp, 256);
    MultiByteToWideChar(CP_ACP, 0, szTmp, -1, wszTmp, 256);
    pCreateErrorInfo->SetDescription(wszTmp);

    // load in the source
    //
    MultiByteToWideChar(CP_ACP, 0, NAMEOFOBJECT(m_ObjectType), -1, wszTmp, 256);
    pCreateErrorInfo->SetSource(wszTmp);

    // now set the Error info up with the system
    //
    hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void **)&pErrorInfo);
    CLEANUP_ON_FAILURE(hr);

    SetErrorInfo(0, pErrorInfo);
    pErrorInfo->Release();

  CleanUp:
    pCreateErrorInfo->Release();
    return hrExcep;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
// indicates whether or not the given interface supports rich error information
//
// Parameters:
//    REFIID        - [in] the interface we want the answer for.
//
// Output:
//    HRESULT       - S_OK = Yes, S_FALSE = No.
//
// Notes:
//
HRESULT CAutomationObject::InterfaceSupportsErrorInfo
(
    REFIID riid
)
{
    // see if it's the interface for the type of object that we are.
    //
    if (riid == (REFIID)INTERFACEOFOBJECT(m_ObjectType))
        return S_OK;

    return S_FALSE;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetResourceHandle    [helper]
//=--------------------------------------------------------------------------=
// virtual routine to get the resource handle.  virtual, so that inheriting
// objects, such as COleControl can use theirs instead, which goes and gets
// the Host's version ...
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE CAutomationObject::GetResourceHandle
(
    void
)
{
    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\classf.h ===
//=--------------------------------------------------------------------------=
// ClassF.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// header for the ClassFactory Object.  we support IClassFactory and 
// IClassFactory2
//
#ifndef _CLASSF_H_

#include "olectl.h"

class CClassFactory : public IClassFactory2 {

  public:
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IClassFactory methods
    //
    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppbObjOut);
    STDMETHOD(LockServer)(BOOL fLock);

    // IClassFactory2 methods
    //
    STDMETHOD(GetLicInfo)(LICINFO *pLicInfo);
    STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR *pbstrKey);
    STDMETHOD(CreateInstanceLic)(IUnknown *pUnkOuter, IUnknown *pUnkReserved, REFIID riid, BSTR bstrKey, void **ppvObjOut);

    CClassFactory(int iIndex);
    ~CClassFactory();

  private:
    ULONG m_cRefs;
    int   m_iIndex;
};


// global variable for Locks on our DLL
//
extern LONG g_cLocks;

#define _CLASSF_H_
#endif // _CLASSF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\ctlembed.cpp ===
//=--------------------------------------------------------------------------=
// CtlEmbed.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the interfaces required for inplace activation for
// COleControl
//

#include "IPServer.H"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "Globals.H"
#include "StdEnum.H"
#include "Util.H"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// all controls support the following in-place verbs at an absolute minimum.
//
#define CINPLACEVERBS 4

const VERBINFO rgInPlaceVerbs [] = {
    { OLEIVERB_SHOW,            0, 0, 0},
    { OLEIVERB_HIDE,            0, 0, 0},
    { OLEIVERB_INPLACEACTIVATE, 0, 0, 0},
    { OLEIVERB_PRIMARY,         0, 0, 0}
};

// NOTE: Resource ID for Properties string must be 1000
//
const VERBINFO ovProperties =
    { CTLIVERB_PROPERTIES, 1000, 0, OLEVERBATTRIB_ONCONTAINERMENU };

const VERBINFO ovUIActivate =
    { OLEIVERB_UIACTIVATE, 0, 0, 0};


//=--------------------------------------------------------------------------=
// COleControl::GetControlInfo    (IOleControl)
//=--------------------------------------------------------------------------=
// returns some information on a control, such as an accelerator table, and
// flags.  really used for keyboard handling and mnemonics
//
// Parameters:
//    CONTROLINFO *        - [in]  where to put said information
//
// Output:
//    HRESULT              - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::GetControlInfo
(
    CONTROLINFO *pControlInfo
)
{
    CHECK_POINTER(pControlInfo);

    // certain hosts have a bug in which it doesn't initialize the cb in the
    // CONTROLINFO structure, so we can only assert on that here.
    //
    ASSERT(pControlInfo->cb == sizeof(CONTROLINFO), "Host doesn't initialize CONTROLINFO structure");

    // NOTE: control writers should override this routine if they want to
    // return accelerator information in their control.
    //
    pControlInfo->hAccel = NULL;
    pControlInfo->cAccel = NULL;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnMnemonic    [IOleControl]
//=--------------------------------------------------------------------------=
// the container has decided to pass on a key that the end-user has pressed to
// us.  default implementation will be to just activate the control.  people
// looking for more functionality should override this method.
//
// Parameters:
//    LPMSG                - [in] message for this mnemonic
//
// Output:
//    HRESULT              - S_OK, E_POINTER
//
// Notes:
//
STDMETHODIMP COleControl::OnMnemonic
(
    LPMSG pMsg
)
{
    // OVERRIDE: default implementation is to just activate our control.  
    // user can override if they want more interesting behaviour.
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl:OnAmbientPropertyChange    [IOleControl]
//=--------------------------------------------------------------------------=
// a container calls this whenever it changes an ambient property.
//
// Parameters:
//    DISPID            - [in] dispid of the property that changed.
//
// Output:
//    HRESULT           - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnAmbientPropertyChange
(
    DISPID dispid
)
{
    // if we're being told about a change in mode [design/run] then
    // remember that so our stashing of mode will update itself
    // correctly
    //
    if (dispid == DISPID_AMBIENT_USERMODE || dispid == DISPID_UNKNOWN)
        m_fModeFlagValid = FALSE;

    // just pass this on to the derived control and see if they want
    // to do anything with it.
    //
    AmbientPropertyChanged(dispid);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControL::FreezeEvents    [IOleControl]
//=--------------------------------------------------------------------------=
// allows a container to freeze all of a controls events.  when events are
// frozen, a control will not fire any of them.
//
// Parameters:
//    BOOL            - [in] TRUE means FREEZE, FALSE means THAW
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//    - we maintain an internal count of freezes versus thaws.
//
STDMETHODIMP COleControl::FreezeEvents
(
    BOOL fFreeze
)
{
    // OVERRIDE: by default, we don't care.  user can override if they want to.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetClientSite    [IOleObject]
//=--------------------------------------------------------------------------=
// informs the embedded object [control] of it's client site [display
// location] within it's container
//
// Parameters:
//    IOleClientSite *        - [in] pointer to client site.
//
// Output:
//    HRESULT                 - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::SetClientSite
(
    IOleClientSite *pClientSite
)
{
    RELEASE_OBJECT(m_pClientSite);
    RELEASE_OBJECT(m_pControlSite);
    RELEASE_OBJECT(m_pSimpleFrameSite);

    // store away the new client site
    //
    m_pClientSite = pClientSite;

    // if we've actually got one, then get some other interfaces we want to keep
    // around, and keep a handle on it
    //
    if (m_pClientSite) {
        m_pClientSite->AddRef();
        m_pClientSite->QueryInterface(IID_IOleControlSite, (void **)&m_pControlSite);

        if (OLEMISCFLAGSOFCONTROL(m_ObjectType) & OLEMISC_SIMPLEFRAME)
            m_pClientSite->QueryInterface(IID_ISimpleFrameSite, (void **)&m_pSimpleFrameSite);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClientSite    [IOleObject]
//=--------------------------------------------------------------------------=
// obtains a pointer to the controls client site.
//
// Parameters:
//    IOleClientSite **        - [out]
//
// Output:
//    HRESULT                  - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::GetClientSite
(
    IOleClientSite **ppClientSite
)
{
    CHECK_POINTER(ppClientSite);

    *ppClientSite = m_pClientSite;
    ADDREF_OBJECT(*ppClientSite);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetHostNames    [IOleObject]
//=--------------------------------------------------------------------------=
// Provides the control with the name of its container application and the
// compound document in which it is embedded
//
// Parameters:
//    LPCOLESTR        - [in] name of container application
//    LPCOLESTR        - [in] name of container document
//
// Output:
//    HRESULT          - S_OK
//
// Notes:
//    - we don't care about this
//
STDMETHODIMP COleControl::SetHostNames
(
    LPCOLESTR szContainerApp,
    LPCOLESTR szContainerObject
)
{
    // we don't care about these
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Close    [IOleObject]
//=--------------------------------------------------------------------------=
// Changes the control from the running to the loaded state
//
// Parameters:
//    DWORD             - [in] indicates whether to save the object before closing
//
// Output:
//    HRESULT           - S_OK, OLE_E_PROMPTSAVECANCELLED
//
// Notes:
//
STDMETHODIMP COleControl::Close
(
    DWORD dwSaveOption
)
{
    HRESULT hr;

    if (m_fInPlaceActive) {
        hr = InPlaceDeactivate();
        RETURN_ON_FAILURE(hr);
    }

    // handle the save flag.
    //
    if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY || dwSaveOption == OLECLOSE_PROMPTSAVE) && m_fDirty) {
        if (m_pClientSite) m_pClientSite->SaveObject();
        if (m_pOleAdviseHolder) m_pOleAdviseHolder->SendOnSave();
    }
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetMoniker    [IOleObject]
//=--------------------------------------------------------------------------=
// Notifies an object of its container's moniker, the object's own moniker
// relative to the container, or the object's full moniker
//
// Parameters:
//    DWORD                - [in] which moniker is being set
//    IMoniker *           - [in] the moniker
//
// Output:
//    HRESULT              - S_OK, E_FAIL
//
// Notes:
//    - we don't support monikers.
//
STDMETHODIMP COleControl::SetMoniker
(
    DWORD     dwWhichMoniker,
    IMoniker *pMoniker
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetMoniker    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a embedded object's moniker, which the caller can use to link to
// the object
//
// Parameters:
//    DWORD            - [in]  how it's assigned
//    DWORD            - [in]  which moniker
//    IMoniker **      - [out] duh.
//
// Output:
//    HRESULT          - E_NOTIMPL
//
// Notes:
//    - we don't support monikers
//
STDMETHODIMP COleControl::GetMoniker
(
    DWORD      dwAssign,
    DWORD      dwWhichMoniker,
    IMoniker **ppMonikerOut
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InitFromData    [IOleObject]
//=--------------------------------------------------------------------------=
// Initializes a newly created object with data from a specified data object,
// which can reside either in the same container or on the Clipboard
//
// Parameters:
//    IDataObject*    - [in] data object with the data
//    BOOL            - [in] how object is created
//    DWORD           - reserved
//
// Output:
//    HRESULT         - S_OK, S_FALSE, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//    - we don't have data object support
//
STDMETHODIMP COleControl::InitFromData
(
    IDataObject *pDataObject,
    BOOL         fCreation,
    DWORD        dwReserved
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClipboardData    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves a data object containing the current contents of the control.
// Using the pointer to this data object, it is possible to create a new control
// with the same data as the original
//
// Parameters:
//    DWORD          - reserved
//    IDataObject ** - [out] data object for this control
//
// Output:
//    HREUSLT        - S_OK, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//
STDMETHODIMP COleControl::GetClipboardData
(
    DWORD         dwReserved,
    IDataObject **ppDataObject
)
{
    *ppDataObject = NULL;        // be a good neighbour
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::DoVerb    [IOleObject]
//=--------------------------------------------------------------------------=
// Requests an object to perform an action in response to an end-user's
// action.
//
// Parameters:
//    LONG             - [in]  verb to be performed
//    LPMSG            - [in]  event that invoked the verb
//    IOleClientSite * - [in]  the controls active client site
//    LONG             - [in]  reserved
//    HWND             - [in]  handle of window containing the object.
//    LPCRECT          - [in]  pointer to objects's display rectangle
//
// Output:
//    HRESULT          - S_OK, OLE_E_NOTINPLACEACTIVE, OLE_E_CANT_BINDTOSOURCE,
//                       DV_E_LINK, OLEOBJ_S_CANNOT_DOVERB_NOW, OLEOBJ_S_INVALIDHWND,
//                       OLEOBJ_E_NOVERBS, OLEOBJ_S_INVALIDVERB, MK_E_CONNECT,
//                       OLE_CLASSDIFF, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::DoVerb
(
    LONG            lVerb,
    LPMSG           pMsg,
    IOleClientSite *pActiveSite,
    LONG            lIndex,
    HWND            hwndParent,
    LPCRECT         prcPosRect
)
{
    HRESULT hr;

    switch (lVerb) {
      case OLEIVERB_SHOW:
      case OLEIVERB_INPLACEACTIVATE:
      case OLEIVERB_UIACTIVATE:
        hr = InPlaceActivate(lVerb);
        OnVerb(lVerb);
        return (hr);

      case OLEIVERB_HIDE:
        UIDeactivate();
        if (m_fInPlaceVisible) SetInPlaceVisible(FALSE);
        OnVerb(lVerb);
        return S_OK;

      // we used to have OLEIVERB_PRIMARY InPlaceActivate Ourselves, but it
      // turns out that the CDK and certain hosts expect this to show the
      // properties instead.  Users can change what this verb does at will.
      //
      case OLEIVERB_PRIMARY:
      case CTLIVERB_PROPERTIES:
      case OLEIVERB_PROPERTIES:
        {
        // show the frame ourselves if the hose can't.
        //
        if (m_pControlSite) {
            hr = m_pControlSite->ShowPropertyFrame();
            if (hr != E_NOTIMPL)
                return hr;
        }
        IUnknown *pUnk = (IUnknown *)(IOleObject *)this;
        MAKE_WIDEPTR_FROMANSI(pwsz, NAMEOFOBJECT(m_ObjectType));

        ModalDialog(TRUE);
        hr = OleCreatePropertyFrame(GetActiveWindow(),
                            GetSystemMetrics(SM_CXSCREEN) / 2,
                            GetSystemMetrics(SM_CYSCREEN) / 2,
                            pwsz,
                            1,
                            &pUnk,
                            CPROPPAGESOFCONTROL(m_ObjectType),
                            (LPCLSID)*(PPROPPAGESOFCONTROL(m_ObjectType)),
                            g_lcidLocale,
                            NULL, NULL);
        ModalDialog(FALSE);
        return hr;
        }

      default:
        // if it's a derived-control defined verb, pass it on to them
        //
        if (lVerb > 0) {
            hr = DoCustomVerb(lVerb);

            if (hr == OLEOBJ_S_INVALIDVERB) {
                // unrecognised verb -- just do the primary verb and
                // activate it.
                //
                hr = InPlaceActivate(OLEIVERB_PRIMARY);
                return (FAILED(hr)) ? hr : OLEOBJ_S_INVALIDVERB;
            } else
                return hr;
        } else {
            FAIL("Unrecognized Negative verb in DoVerb().  bad.");
            return E_NOTIMPL;
        }
        break;
    }

    // dead code
    FAIL("this should be dead code!");
}

//=--------------------------------------------------------------------------=
// COleControl::EnumVerbs    [IOleObject]
//=--------------------------------------------------------------------------=
// create an enumerator object for the verbs this object supports.
//
// Parameters:
//    IEnumOleVERB **    - [out] new enumerator.
//
// Output:
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::EnumVerbs
(
    IEnumOLEVERB **ppEnumVerbs
)
{
    int cVerbs;
    OLEVERB *rgVerbs, *pVerb;

    DWORD dw = OLEMISCFLAGSOFCONTROL(m_ObjectType);
    BOOL fCanInPlace = !(dw & OLEMISC_INVISIBLEATRUNTIME) || (dw & OLEMISC_ACTIVATEWHENVISIBLE);
    BOOL fCanUIActivate = !(dw & OLEMISC_NOUIACTIVATE);
    BOOL fHasProperties = (CPROPPAGESOFCONTROL(m_ObjectType) != 0);

    int cVerbExtra = CCUSTOMVERBSOFCONTROL(m_ObjectType);

    // count up all the verbs
    //
    cVerbs = (fCanInPlace ? CINPLACEVERBS : 0) + (fCanUIActivate ? 1 : 0)
             + (fHasProperties ? 1 : 0) + cVerbExtra;

    // if there aren't any, this suddenly gets really easy !
    //
    if (cVerbs == 0)
        return OLEOBJ_E_NOVERBS;

    // HeapAlloc some storage for these dudes so that we can pass them on to
    // the standard enumerator!
    //
    if (! (rgVerbs = (OLEVERB *)HeapAlloc(g_hHeap, 0, cVerbs * sizeof(OLEVERB))))
        return E_OUTOFMEMORY;
  
    // start copying over verbs.  first, the in-place guys
    //
    pVerb = rgVerbs;
    if (fCanInPlace) {
        memcpy(pVerb, rgInPlaceVerbs, CINPLACEVERBS * sizeof(OLEVERB));
        pVerb += CINPLACEVERBS;
      }

    if (fCanUIActivate)
        memcpy(pVerb++, &ovUIActivate, sizeof(OLEVERB));

    // if their control has properties, copy that over now.
    //
    if (fHasProperties) {
        memcpy(pVerb, &ovProperties, sizeof(OLEVERB));
        pVerb++;
    }

    // finally, any custom verbs!
    //
    if (cVerbExtra) {
        memcpy(pVerb, CUSTOMVERBSOFCONTROL(m_ObjectType), sizeof(OLEVERB) * cVerbExtra);
    }

    *ppEnumVerbs = (IEnumOLEVERB *) (IEnumGeneric *) new CStandardEnum(IID_IEnumOLEVERB,
                                     cVerbs, sizeof(OLEVERB), rgVerbs, CopyOleVerb);
    if (!*ppEnumVerbs)
        return E_OUTOFMEMORY;

    // this forces us to go and look for the Localized DLLs.  This is necessary here
    // because the CopyOleVerb will get information from localized resources, but
    // will only use the global GetResourceHandle, which only uses the global value
    // for the LCID.  This turns out to not be a big performance hit, since this
    // function is typically only called in design mode, and we stash this value.
    //
    GetResourceHandle();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Update    [IOleObject]
//=--------------------------------------------------------------------------=
// Updates an object handler's or link object's data or view caches.
//
// Output:
//    HRESULT            - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::Update
(
    void
)
{
    // nothing to do!!!
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::IsUpToDate    [IOleObject]
//=--------------------------------------------------------------------------=
// Checks recursively whether or not an object is up to date.
//
// Output:
//    HRESULT        - S_OK, S_FALSE, OLE_E_UNVAILABLE
//
// Notes:
//
STDMETHODIMP COleControl::IsUpToDate
(
    void
)
{
    // we're always up to date
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserClassID    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns the controls class identifier, the CLSID corresponding to the
// string identifying the object to an end user.
//
// Parameters:
//    CLSID *      - [in] where to put the CLSID
//
// Output:
//    HRESULT      - S_OK, E_FAIL
//
// Notes:
//
STDMETHODIMP COleControl::GetUserClassID
(
    CLSID *pclsid
)
{
    // this is the same as IPersist::GetClassID
    //
    return GetClassID(pclsid);
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserType    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the user-type name of the control for display in user-interface
// elements such as menus, list boxes, and dialog boxes.
//
// Parameters:
//    DWORD        - [in]  specifies the form of the type name.
//    LPOLESTR *   - [out] where to put user type
//
// Output:
//    HRESULT      - S_OK, OLE_S_USEREG, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::GetUserType
(
    DWORD     dwFormOfType,
    LPOLESTR *ppszUserType
)
{
    *ppszUserType = OLESTRFROMANSI(NAMEOFOBJECT(m_ObjectType));
    return (*ppszUserType) ? S_OK : E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// COleControl::SetExtent    [IOleObject]
//=--------------------------------------------------------------------------=
// Informs the control of how much display space its container has assigned it.
//
// Parameters:
//    DWORD            - [in] which form or 'aspect'  is to be displayed.
//    SIZEL *          - [in] size limit for the control.
//
// Output:
//    HRESULT          - S_OK, E_FAIL, OLE_E_NOTRUNNING
//
// Notes:
//
STDMETHODIMP COleControl::SetExtent
(
    DWORD  dwDrawAspect,
    SIZEL *psizel
)
{
    SIZEL sl;
    RECT  rect;
    BOOL  f;

    if (dwDrawAspect & DVASPECT_CONTENT) {

        // change the units to pixels, and resize the control.
        //
        HiMetricToPixel(psizel, &sl);

        // first call the user version.  if they return FALSE, they want
        // to keep their current size
        //
        f = OnSetExtent(&sl);
        if (f)
            HiMetricToPixel(psizel, &m_Size);

        // set things up with our HWND if we've got one.
        //
        if (!m_pInPlaceSiteWndless) {
            if (m_fInPlaceActive) {
    
                // theoretically, one should not need to call OnPosRectChange
                // here, but there appear to be a few host related issues that
                // will make us keep it here.  we won't, however, both with
                // windowless ole controls, since they are all new hosts who
                // should know better
                //
                GetWindowRect(m_hwnd, &rect);
                MapWindowPoints(NULL, m_hwndParent, (LPPOINT)&rect, 2);
                rect.right = rect.left + m_Size.cx;
                rect.bottom = rect.top + m_Size.cy;
                m_pInPlaceSite->OnPosRectChange(&rect);
    
                if (m_hwnd) {
                    // just go and resize
                    //
                    if (m_hwndReflect)
                        SetWindowPos(m_hwndReflect, 0, 0, 0, m_Size.cx, m_Size.cy,
                                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
                    SetWindowPos(m_hwnd, 0, 0, 0, m_Size.cx, m_Size.cy,
                                 SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
                }
            } else if (m_hwnd) {
                SetWindowPos(m_hwnd, NULL, 0, 0, m_Size.cx, m_Size.cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
            } else {
                ViewChanged();
            }
        } else
            if (m_pInPlaceSite) m_pInPlaceSite->OnPosRectChange(&rect);

        // return code depending on whether or not user accepted given
        // size
        //
        return (f) ? S_OK : E_FAIL;

    } else {
        // we don't support any other aspects.
        //
        return DV_E_DVASPECT;
    }

    // dead code
    FAIL("This should be dead code");
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the control's current display size.
//
// Parameters:
//    DWORD            - [in] aspect
//    SIZEL *          - [in] where to put results
//
// Output:
//    S_OK, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP COleControl::GetExtent
(
    DWORD  dwDrawAspect,
    SIZEL *pSizeLOut
)
{

    if (dwDrawAspect & DVASPECT_CONTENT) {
        PixelToHiMetric((const SIZEL *)&m_Size, pSizeLOut);
        return S_OK;
    } else {
        return DV_E_DVASPECT;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::Advise    [IOleObject]
//=--------------------------------------------------------------------------=
// establishes and advisory connection between the control and the container,
// in which the control will notify the container of certain events.
//
// Parameters:
//    IAdviseSink *     - [in]  advise sink of calling object
//    DWORD             - [out] cookie
//
// Output:
//    HRESULT           - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::Advise
(
    IAdviseSink *pAdviseSink,
    DWORD       *pdwConnection
)
{
    HRESULT hr;

    // if we haven't yet created a standard advise holder object, do so
    // now
    //
    if (!m_pOleAdviseHolder) {
        hr = CreateOleAdviseHolder(&m_pOleAdviseHolder);
        RETURN_ON_FAILURE(hr);
    }

    // just get it to do the work for us!
    //
    return m_pOleAdviseHolder->Advise(pAdviseSink, pdwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::Unadvise    [IOleObject]
//=--------------------------------------------------------------------------=
// Deletes a previously established advisory connection.
//
// Parameters:
//    DWORD         - [in] connection cookie
//
// Output:
//    HRESULT       - S_OK, E_FAIL, OLE_E_NOCONNECTION
//
// Notes:
//
STDMETHODIMP COleControl::Unadvise
(
    DWORD dwConnection
)
{
    if (!m_pOleAdviseHolder) {
        FAIL("Somebody called Unadvise on IOleObject without calling Advise!");
        CONNECT_E_NOCONNECTION;
    }

    return m_pOleAdviseHolder->Unadvise(dwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::EnumAdvise    [IOleObject]
//=--------------------------------------------------------------------------=
// Enumerates the advisory connections registered for an object, so a container
// can know what to release prior to closing down.
//
// Parameters:
//    IEnumSTATDATA **    - [out] where to put enumerator
//
// Output:
//    HRESULT             - S_OK, E_FAIL, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::EnumAdvise
(
    IEnumSTATDATA **ppEnumOut
)
{
    if (!m_pOleAdviseHolder) {
        FAIL("Somebody Called EnumAdvise without setting up any connections");
        *ppEnumOut = NULL;
        return E_FAIL;
    }

    return m_pOleAdviseHolder->EnumAdvise(ppEnumOut);
}

//=--------------------------------------------------------------------------=
// COleControl::GetMiscStatus    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a value indicating the status of an object at creation and loading.
//
// Parameters:
//    DWORD         - [in]  aspect desired
//    DWORD *       - [out] where to put the bits.
//
// Output:
//    HRESULT       - S_OK, OLE_S_USEREG, CO_E_CLASSNOTREG, CO_E_READREGDB
//
// Notes:
//
STDMETHODIMP COleControl::GetMiscStatus
(
    DWORD  dwAspect,
    DWORD *pdwStatus
)
{
    CHECK_POINTER(pdwStatus);

    if (dwAspect == DVASPECT_CONTENT) {
        *pdwStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
        return S_OK;
    } else {
        return DV_E_DVASPECT;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::SetColorScheme    [IOleObject]
//=--------------------------------------------------------------------------=
// Specifies the color palette that the object application should use when it
// edits the specified object.
//
// Parameters:
//    LOGPALETTE *     - [in] new palette
//
// Output:
//    HRESULT          - S_OK, E_NOTIMPL, OLE_E_PALETTE, OLE_E_NOTRUNNING
//
// Notes:
//    - we don't care.
//
STDMETHODIMP COleControl::SetColorScheme
(
    LOGPALETTE *pLogpal
)
{
    // OVERRIDE: control writers can use this if they want to
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetWindow    [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Returns the window handle to one of the windows participating in in-place
// activation (frame, document, parent, or in-place object window).
//
// Parameters:
//    HWND *        - [out] where to return window handle.
//
// Output:
//    HRESULT       - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL
//
// Notes:
//    - this routine has slightly different semantics for windowless controls
//
STDMETHODIMP COleControl::GetWindow
(
    HWND *phwnd
)
{
    // if we're windowles, then we want to return E_FAIL for this so hosts
    // know we're windowless
    //
    if (m_pInPlaceSiteWndless)
        return E_FAIL;

    // otherwise, just return our outer window.
    //
    *phwnd = GetOuterWindow();

    return (*phwnd) ? S_OK : E_UNEXPECTED;
}

//=--------------------------------------------------------------------------=
// COleControl::ContextSensitiveHelp    [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Determines whether context-sensitive help mode should be entered during an
// in-place activation session.
//
// Parameters:
//    BOOL            - [in] whether or not to enter help mode.
//
// Output:
//    HRESULT         - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::ContextSensitiveHelp
(
    BOOL fEnterMode
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceActivate
//=--------------------------------------------------------------------------=
// activates the control, and depending on the verb, optionally ui activates
// it as well.
//
// Parameters:
//    LONG         - [in] the verb that caused us to activate
//
// Output:
//    HRESULT
//
// Notes:
//    - this is spaghetti code at it's worst.  effectively, we have to
//      be able to handle three types of site pointers -- IOleInPlaceSIte,
//      IOleInPlaceSiteEx, and IOleInPlaceSiteWindowless.  not terribly
//      pretty.
//
HRESULT COleControl::InPlaceActivate
(
    LONG lVerb
)
{
    BOOL f;
    SIZEL sizel;
    IOleInPlaceSiteEx *pIPSEx = NULL;
    HRESULT hr;
    BOOL    fNoRedraw = FALSE;

    // if we don't have a client site, then there's not much to do.
    //
    if (!m_pClientSite)
        return S_OK;

    // get an InPlace site pointer.
    //
    if (!GetInPlaceSite()) {

        // if they want windowless support, then we want IOleInPlaceSiteWindowless
        //
        if (FCONTROLISWINDOWLESS(m_ObjectType))
            m_pClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_pInPlaceSiteWndless);

        // if we're not able to do windowless siting, then we'll just get an
        // IOleInPlaceSite pointer.
        //
        if (!m_pInPlaceSiteWndless) {
            hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
            RETURN_ON_FAILURE(hr);
        }
    }

    // now, we want an IOleInPlaceSiteEx pointer for windowless and flicker free
    // activation.  if we're windowless, we've already got it, else we need to
    // try and get it
    //
    if (m_pInPlaceSiteWndless) {
        pIPSEx = (IOleInPlaceSiteEx *)m_pInPlaceSiteWndless;
        pIPSEx->AddRef();
    } else
        m_pClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&pIPSEx);

    // if we're not already active, go and do it.
    //
    if (!m_fInPlaceActive) {
        OLEINPLACEFRAMEINFO InPlaceFrameInfo;
        RECT rcPos, rcClip;

        // if we have a windowless site, see if we can go in-place windowless
        // active
        //
        hr = S_FALSE;
        if (m_pInPlaceSiteWndless) {
            hr = m_pInPlaceSiteWndless->CanWindowlessActivate();
            CLEANUP_ON_FAILURE(hr);

            // if they refused windowless, we'll try windowed
            //
            if (S_OK != hr) {
                RELEASE_OBJECT(m_pInPlaceSiteWndless);
                hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
                CLEANUP_ON_FAILURE(hr);
            }
        }

        // just try regular windowed in-place activation
        //
        if (hr != S_OK) {
            hr = m_pInPlaceSite->CanInPlaceActivate();
            if (hr != S_OK) {
                hr = (FAILED(hr)) ? E_FAIL : hr;
                goto CleanUp;
            }
        }

        // if we are here, then we have permission to go in-place active.
        // now, announce our intentions to actually go ahead and do this.
        //
        hr = (pIPSEx) ? pIPSEx->OnInPlaceActivateEx(&fNoRedraw, (m_pInPlaceSiteWndless) ? ACTIVATE_WINDOWLESS : 0)
                       : m_pInPlaceSite->OnInPlaceActivate();
        CLEANUP_ON_FAILURE(hr);

        // if we're here, we're ready to go in-place active.  we just need
        // to set up some flags, and then create the window [if we have
        // one]
        //
        m_fInPlaceActive = TRUE;

        // we need to get some information about our location in the parent
        // window, as well as some information about the parent
        //
        InPlaceFrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
        hr = GetInPlaceSite()->GetWindow(&m_hwndParent);
        if (SUCCEEDED(hr))
            hr = GetInPlaceSite()->GetWindowContext(&m_pInPlaceFrame, &m_pInPlaceUIWindow, &rcPos, &rcClip, &InPlaceFrameInfo);
        CLEANUP_ON_FAILURE(hr);

        // make sure we'll display ourselves in the correct location with the correct size
        //
        sizel.cx = rcPos.right - rcPos.left;
        sizel.cy = rcPos.bottom - rcPos.top;
        f = OnSetExtent(&sizel);
        if (f) m_Size = sizel;
        SetObjectRects(&rcPos, &rcClip);

        // finally, create our window if we have to!
        //
        if (!m_pInPlaceSiteWndless) {
    
            SetInPlaceParent(m_hwndParent);

            // create the window, and display it.  die horribly if we couldnt'
            //
            if (!CreateInPlaceWindow(rcPos.left, rcPos.top, fNoRedraw)) {
                hr = E_FAIL;
                goto CleanUp;
            }
        }
    }

    // don't need this any more
    //
    RELEASE_OBJECT(pIPSEx);

    // if we're not inplace visible yet, do so now.
    //
    if (!m_fInPlaceVisible)
        SetInPlaceVisible(TRUE);

    // if we weren't asked to UIActivate, then we're done.
    //
    if (lVerb != OLEIVERB_PRIMARY && lVerb != OLEIVERB_UIACTIVATE)
        return S_OK;

    // if we're not already UI active, do sow now.
    //
    if (!m_fUIActive) {
        m_fUIActive = TRUE;

        // inform the container of our intent
        //
        GetInPlaceSite()->OnUIActivate();

        // take the focus  [which is what UI Activation is all about !]
        //
        SetFocus(TRUE);

        // set ourselves up in the host.
        //
        m_pInPlaceFrame->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);
        if (m_pInPlaceUIWindow)
            m_pInPlaceUIWindow->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);

        // we have to explicitly say we don't wany any border space.
        //
        m_pInPlaceFrame->SetBorderSpace(NULL);
        if (m_pInPlaceUIWindow)
            m_pInPlaceUIWindow->SetBorderSpace(NULL);
    }

    // be-de-be-de-be-de that's all folks!
    //
    return S_OK;

  CleanUp:
    // something catastrophic happened [or, at least something bad].
    // die a horrible fiery mangled painful death.
    //
    QUICK_RELEASE(pIPSEx);
    m_fInPlaceActive = FALSE;
    return hr;

}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Deactivates an active in-place object and discards the object's undo state.
//
// Output:
//    HRESULT        - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::InPlaceDeactivate
(
    void
)
{
    // if we're not in-place active yet, then this is easy.
    //
    if (!m_fInPlaceActive)
        return S_OK;

    // transition from UIActive back to active
    //
    if (m_fUIActive)
        UIDeactivate();

    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;

    // if we have a window, tell it to go away.
    //
    if (m_hwnd) {
        ASSERT(!m_pInPlaceSiteWndless, "internal state really messed up");

        // so our window proc doesn't crash.
        //
        BeforeDestroyWindow();
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xFFFFFFFF);
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;

        if (m_hwndReflect) {
            SetWindowLongPtr(m_hwndReflect, GWLP_USERDATA, 0);
            DestroyWindow(m_hwndReflect);
            m_hwndReflect = NULL;
        }
    }

    RELEASE_OBJECT(m_pInPlaceFrame);
    RELEASE_OBJECT(m_pInPlaceUIWindow);
    GetInPlaceSite()->OnInPlaceDeactivate();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::UIDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// transitions us from UI Active to merely being active [visible]  for
// a control, this doesn't mean all that much.
//
// Output:
//    HRESULT         - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::UIDeactivate
(
    void
)
{
    // if we're not UIActive, not much to do.
    //
    if (!m_fUIActive)
        return S_OK;

    m_fUIActive = FALSE;

    // notify frame windows, if appropriate, that we're no longer ui-active.
    //
    if (m_pInPlaceUIWindow) m_pInPlaceUIWindow->SetActiveObject(NULL, NULL);
    m_pInPlaceFrame->SetActiveObject(NULL, NULL);

    // we don't need to explicitly release the focus here since somebody
    // else grabbing the focus is what is likely to cause us to get lose it
    //
    GetInPlaceSite()->OnUIDeactivate(FALSE);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetObjectRects    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Indicates how much of the control is visible.
//
// Parameters:
//    LPCRECT        - [in] position of the control.
//    LPCRECT        - [in] clipping rectangle for the control.
//
// Output:
//    HRESULT        - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::SetObjectRects
(
    LPCRECT prcPos,
    LPCRECT prcClip
)
{
    BOOL fRemoveWindowRgn;

    // move our window to the new location and handle clipping. not applicable
    // for windowless controls, since the container will be responsible for all
    // clipping.
    //
    if (m_hwnd) {
        fRemoveWindowRgn = m_fUsingWindowRgn;
        if (prcClip) {
            // the container wants us to clip, so figure out if we really
            // need to
            //
            RECT rcIXect;
            if ( IntersectRect(&rcIXect, prcPos, prcClip) ) {
                if (!EqualRect(&rcIXect, prcPos)) {
                    OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));

                    HRGN tempRgn = CreateRectRgnIndirect(&rcIXect);
                    SetWindowRgn(GetOuterWindow(), tempRgn, TRUE);

                    if (m_hRgn != NULL)
                       DeleteObject(m_hRgn);
                    m_hRgn = tempRgn;

                    m_fUsingWindowRgn = TRUE;
                    fRemoveWindowRgn  = FALSE;
                }
            }
        }

        if (fRemoveWindowRgn) {
            SetWindowRgn(GetOuterWindow(), NULL, TRUE);
            if (m_hRgn != NULL)
            {
               DeleteObject(m_hRgn);
               m_hRgn = NULL;
            }
            m_fUsingWindowRgn = FALSE;
        }

        // set our control's location, but don't change it's size at all
        // [people for whom zooming is important should set that up here]
        //
        DWORD dwFlag;
        OnSetObjectRectsChangingWindowPos(&dwFlag);

        int cx, cy;
        cx = prcPos->right - prcPos->left;
        cy = prcPos->bottom - prcPos->top;
        SetWindowPos(GetOuterWindow(), NULL, prcPos->left, prcPos->top, cx, cy, dwFlag | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    // save out our current location.  windowless controls want this more
    // that windowed ones do, but everybody can have it just in case
    //
    m_rcLocation = *prcPos;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ReactivateAndUndo    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Reactivates a previously deactivated object, undoing the last state of the object.
//
// Output:
//    HRESULT        - S_OK, E_NOTUNDOABLE
//
// Notes:
//
STDMETHODIMP COleControl::ReactivateAndUndo
(
    void
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnWindowMessage    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method lets the container dispatch a message to a windowless OLE
// object.
//
// Parameters:
//    UINT                - [in]  the message
//    WPARAM              - [in]  the messages wparam
//    LPARAM              - [in]  duh.
//    LRESULT *           - [out] the output value
//
// Output:
//    HRESULT             - S_OK
//
// Notes:
//    - people should call m_pInPlaceSiteWndless->OnDefWindowMessage [control
//      writers should just call OcxDefWindowProc(msg, wparam, lparam)];
//
STDMETHODIMP COleControl::OnWindowMessage
(
    UINT     msg,
    WPARAM   wParam,
    LPARAM   lParam,
    LRESULT *plResult
)
{
    // little bit of pre-processing -- we need to handle some cases here
    // before passing the messages on
    //
    switch (msg) {
        // make sure our UI Activation correctly matches the focus
        //
        case WM_KILLFOCUS:
        case WM_SETFOCUS:
            // give the control site focus notification
            //
            if (m_fInPlaceActive && m_pControlSite)
                m_pControlSite->OnFocus(msg == WM_SETFOCUS);
            break;
    }

    // just pass it to the control's window proc.
    //
    *plResult = WindowProc(msg, wParam, lParam);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetDropTarget    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method returns a pointer to the objects IDropTarget interface.  since
// they do not have a window, windowless objects cannot register an IDropTarget
// interface.
//
// Parameters:
//    IDropTarget **        - [out]
//
// Output:
//    HRESULT               - S_OK, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::GetDropTarget
(
    IDropTarget **ppDropTarget
)
{
    // OVERRIDE: if you want to do drag and drop and you're windowless,
    // override me.
    //
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::TranslateAccelerator    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Processes menu accelerator-key messages from the container's message queue.
//
// Parameters:
//    LPMSG            - [in] the message that has the special key in it.
//
// Output:
//    HRESULT          - S_OK, S_FALSE, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::TranslateAccelerator
(
    LPMSG    pmsg
)
{
    // see if we want it or not.
    //
    if (OnSpecialKey(pmsg))
        return S_OK;

    // if not, then we want to forward it back to the site for further processing
    //
    if (m_pControlSite)
        return m_pControlSite->TranslateAccelerator(pmsg, _SpecialKeyState());

    // we didn't want it.
    //
    return S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnFrameWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the control when the container's top-level frame window is
// activated or deactivated.
//
// Parameters:
//    BOOL        - [in] state of containers top level window.
//
// Output:
//    HRESULT     - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnFrameWindowActivate
(
    BOOL fActivate
)
{
    // we're supposed to go UI active in this case
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl::OnDocWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the active control when the container's document window is
// activated or deactivated.
//
// Parameters:
//    BOOL            - state of mdi child window.
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnDocWindowActivate
(
    BOOL fActivate
)
{
    // we're supposed to go UI active in this case
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl::ResizeBorder    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Alerts the control that it needs to resize its border space.
//
// Parameters:
//    LPCRECT               - [in] new outer rectangle for border space
//    IOleInPlaceUIWindow * - [in] the document or frame who's border has changed
//    BOOL                  - [in] true if it was the fram window taht called.
//
// Output:
//    HRESULT               - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::ResizeBorder
(
    LPCRECT              prcBorder,
    IOleInPlaceUIWindow *pInPlaceUIWindow,
    BOOL                 fFrame
)
{
    // this is largely uninteresting to us, since we have no border.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::EnableModeless    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Enables or disables modeless dialog boxes when the container creates or
// destroys a modal dialog box.
//
// Parameters:
//    BOOL            - [in] enable or disable modeless dialogs.
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::EnableModeless
(
    BOOL fEnable
)
{
    // phenomenally uninteresting
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassInfo    [IProvideClassInfo]
//=--------------------------------------------------------------------------=
// returns the TypeInfo for the control's coclass.
//
// Parameters:
//    ITypeInfo **        - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassInfo
(
    ITypeInfo **ppTypeInfo
)
{
    ITypeLib *pTypeLib;
    HRESULT hr;

    CHECK_POINTER(ppTypeInfo);
    *ppTypeInfo = NULL;

    // go and get our type library.
    // CONSIDER: - go to the same sorta scheme that we use for TypeInfo caching.
    // CONSIDER: - consider trying to register our typelib if this fails.
    //
    hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 0,
                        LANGIDFROMLCID(g_lcidLocale), &pTypeLib);
    RETURN_ON_FAILURE(hr);

    // got the typelib.  get typeinfo for our coclass.
    //
    hr = pTypeLib->GetTypeInfoOfGuid((REFIID)CLSIDOFOBJECT(m_ObjectType), ppTypeInfo);
    pTypeLib->Release();
    RETURN_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ViewChange    [callable]
//=-------------------------------------