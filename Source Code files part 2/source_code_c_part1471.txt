                                   1,
                                              L"MQInSeq"));
                ASSERT(0);
                exit(EXIT_FAILURE);  

            }

            DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, TEXT("Log checkpoint: inseq.save: hr=%x"), hr));
            CRASH_POINT(401);

            // Saving the transactions persistant data
            hr = g_pRM->Save();
            if (FAILED(hr))
            {
                REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                              CHECKPOINT_SAVE_ERROR,
                                              1,
                                              L"MQTrans"));
                ASSERT(0);
                exit(EXIT_FAILURE);  
            }

            DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, TEXT("Log checkpoint: rm.save: hr=%x"), hr));
            CRASH_POINT(402);

            // Wait till all sneaking logs are finished: 
            //   logging that started after Flusher took the CS 
            for (int i=0; i<100 && g_lPendingNotifications>0; i++)
            {
                Sleep(100);
            }

            // Writing consolidation record
            //    it will be first read at recovery
            ResetEvent(hConsolidationEvent);
            hr = g_Logger.LogConsolidationRec(g_pInSeqHash->PingNo(), g_pRM->PingNo(), hConsolidationEvent);
            if (FAILED(hr))
            {
                REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                              CHECKPOINT_SAVE_ERROR,
                                              1,
                                              L"LogConsolidationRec"));
                ASSERT(0);
                exit(EXIT_FAILURE);  
            }
            DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, TEXT("Log checkpoint: logger.ConsolidationRecord: hr=%x"), hr));
            CRASH_POINT(403);

            // Wait till consolidation record is notified 
            //    it covers all logging that started before this one
            dwResult = WaitForSingleObject(hConsolidationEvent, MAX_WAIT_FOR_FLUSH_TIME);
            ASSERT(dwResult == WAIT_OBJECT_0);
            if (dwResult != WAIT_OBJECT_0)
            {
		        LogIllegalPoint(s_FN, 211);
                REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                              CHECKPOINT_SAVE_ERROR,
                                              1,
                                              L"No Notification for LogConsolidationRec"));
                exit(EXIT_FAILURE);  
            }
            CRASH_POINT(404);

            // Writing checkpoint (ONLY if everything was saved fine)
            //    it marks where next recovery will start reading
            hr = g_Logger.Checkpoint();
            if (FAILED(hr))
            {
                REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                              CHECKPOINT_SAVE_ERROR,
                                              1,
                                              L"Checkpoint"));
                ASSERT(0);
                exit(EXIT_FAILURE);  
            }

            DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, TEXT("Log checkpoint: logger.checkpoint: hr=%x"), hr));
            CRASH_POINT(405);
        }

        // Signal write checkpoint complete
        //   we need it because Consolidation record once more saw not enough space
        ResetEvent(hFlusherEvent);

        // Inform caller that checkpoint is ready
        g_Logger.SignalCheckpointWriteComplete();

        if(g_Logger.Stoped())
            return 0;
    }
}

/*====================================================
CLogger::TimeToCheckpoint
    Scheduled periodically to make a checkpoint 
=====================================================*/
void WINAPI CLogger::TimeToCheckpoint(CTimer* pTimer)
{
    CLogger* pLogger = CONTAINING_RECORD(pTimer, CLogger, m_CheckpointTimer);
    pLogger->PeriodicFlushing();
}
    
/*====================================================
CLogger::PeriodicFlushing
    Scheduled periodically to make a checkpoint 
=====================================================*/
void CLogger::PeriodicFlushing()
{
    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("Log checkpoint ordered")));

    // Signal for the flusher
    SetEvent(m_hFlusherEvent);

    // schedule next checkpoint time
    ExSetTimer(&m_CheckpointTimer, CTimeDuration::FromMilliSeconds(m_ulCheckpointInterval));
}


inline bool CLogger::Stoped() const
{
    return m_fStop;
}


inline void CLogger::SignalStop()
{
    m_fStop = true;
}


/*====================================================
XactLogWriteCheckpointAndExitThread
    Writes checkpoint and waits for write completion
    and wait for the FlusherThread to exit
=====================================================*/
BOOL XactLogWriteCheckpointAndExitThread()
{
    g_Logger.SignalStop();
    if(!SetEvent(g_Logger.FlusherEvent()))
    {
        return LogBOOL(FALSE, s_FN, 216);
    }


    DWORD dwResult = WaitForSingleObject(g_Logger.FlusherThread(), INFINITE);
    if (dwResult != WAIT_OBJECT_0)
    {
        LogNTStatus(GetLastError(), s_FN, 212);
        ASSERT(dwResult == WAIT_OBJECT_0);
    }

    return TRUE;
}


STATIC void RecoveryFromLogFn(USHORT usRecType, PVOID pData, ULONG cbData)
{
    DBGMSG((DBGMOD_LOG, DBGLVL_INFO, TEXT("Recovery record: %ls (type=%d, len=%d)"),
        g_RecoveryRecords[usRecType], usRecType,cbData));

    switch(usRecType)
    {
    case LOGREC_TYPE_EMPTY :
    case LOGREC_TYPE_CONSOLIDATION :
        break;

    case LOGREC_TYPE_INSEQ :
	case LOGREC_TYPE_INSEQ_SRMP:
        g_pInSeqHash->InSeqRecovery(usRecType, pData, cbData);
        break;

	

    case LOGREC_TYPE_XACT_STATUS :
    case LOGREC_TYPE_XACT_DATA:
    case LOGREC_TYPE_XACT_PREPINFO:
        g_pRM->XactFlagsRecovery(usRecType, pData, cbData);
        break;

    default:
		ASSERT(0);
        break;
    }
}


/*====================================================
CLogger::CompareLRP
    Compares LRP 
=====================================================*/
DWORD CLogger::CompareLRP(LRP lrpLRP1, LRP lrpLRP2)
{
    ASSERT(m_ILogRecordPointer);
    return m_ILogRecordPointer->CompareLRP(lrpLRP1, lrpLRP2);
}


/*====================================================
CLogger::SetCurrent
    Collects highest LRP 
=====================================================*/
void CLogger::SetCurrent(LRP lrpLRP)
{
    CS lock(g_crLogging);  // serializes usage of m_lrpCurrent and prevents races with SetCheckPoint
    ASSERT(m_ILogRecordPointer);

    if (m_ILogRecordPointer->CompareLRP(lrpLRP, m_lrpCurrent) == 2)
    {
        m_lrpCurrent = lrpLRP;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactlog.h ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactLog.h

Abstract:
	Provides interface to the Viper Log Manager

Author:
    AlexDad

--*/

#ifndef __XACTLOG_H__
#define __XACTLOG_H__

// Logger interface include files
#include "ilgstor.h"
#include "ilgread.h"
#include "ilgwrite.h"
#include "ilgwrta.h"
#include "ilrp.h"
#include "ilginit.h"
#include "ilgcrea.h"
#include <limits.h>
#include <tr.h>
#include <ref.h>
#include <strutl.h>

//
// Log record types
//
#define LOGREC_TYPE_EMPTY		    1
#define LOGREC_TYPE_INSEQ		    2
#define	LOGREC_TYPE_XACT_STATUS     3
#define	LOGREC_TYPE_XACT_PREPINFO   4
#define	LOGREC_TYPE_XACT_DATA       5
#define	LOGREC_TYPE_CONSOLIDATION   6
#define LOGREC_TYPE_INSEQ_SRMP	    7


// Function type for recovery
typedef void (*LOG_RECOVERY_ROUTINE)(USHORT usRecType, PVOID pData, ULONG cbData);

// Function writes checkpoint and waits till write complete
extern BOOL XactLogWriteCheckpointAndExitThread();

//--------------------------------------
//
// Empty Log Record
//
//--------------------------------------
typedef struct _EmptyRecord{
	ULONG    ulData;
} EmptyRecord;

//--------------------------------------
//
// Checkpoint Consolidation Log Record
//
//--------------------------------------
typedef struct _ConsolidationRecord{
    ULONG  m_ulInSeqVersion;
    ULONG  m_ulXactVersion;
} ConsolidationRecord;


class CConsolidationRecord 
{
public:
	CConsolidationRecord(
        ULONG ulInseqVersion,
        ULONG ulXactVersion);
	~CConsolidationRecord();

	ConsolidationRecord   m_Data;
};


//--------------------------------------
//
// Incoming Sequence Log Record
//
//--------------------------------------
#define MY_DN_LENGTH   MQ_MAX_Q_NAME_LEN


typedef struct _InSeqRecord{
	GUID          Guid;
    QUEUE_FORMAT  QueueFormat;
    LONGLONG      liSeqID;
    ULONG         ulNextSeqN;
    union {
        GUID        guidDestOrTaSrcQm;
        TA_ADDRESS  taSourceQM;
    };
    time_t        timeLastActive;
    WCHAR         wszDirectName[MY_DN_LENGTH];         // we write only filled part of it
} InSeqRecord;



class CInSeqRecord 
{
public:
	CInSeqRecord(
		const GUID	  *pGuid,
		QUEUE_FORMAT  *pQueueFormat,
        LONGLONG      liSeqID,
		ULONG         ulNextSeqN,
		time_t        timeLastActive,
        const GUID   *pGuidDestOrTaSrcQm);
       
	~CInSeqRecord();

	InSeqRecord   m_Data;
};

struct InSeqRecordSrmp
{
	InSeqRecordSrmp(
		LONGLONG      liSeqID,
		ULONG         ulNextSeqN,
		time_t        timeLastActive)
		:
		m_liSeqID(liSeqID),
		m_ulNextSeqN(ulNextSeqN),
		m_timeLastActive(timeLastActive)
		{}

	InSeqRecordSrmp(){}


	LONGLONG  m_liSeqID;
	LONGLONG  m_ulNextSeqN;
	time_t    m_timeLastActive; 
};




class CInSeqRecordSrmp 
{
public:
	CInSeqRecordSrmp(
		const WCHAR* pDestination,
		const R<CWcsRef>&  StreamId,
        LONGLONG      liSeqID,
		ULONG         ulNextSeqN,
		time_t        timeLastActive,
		const R<CWcsRef>&  HttpOrderAckDestination
        );
    
	CInSeqRecordSrmp(const BYTE* pdata, DWORD len);

	const BYTE* Serialize(DWORD* plen);

	AP<BYTE> m_tofree;
	InSeqRecordSrmp m_StaticData;
	AP<WCHAR>  m_pDestination;
	R<CWcsRef> m_pStreamId;
	R<CWcsRef> m_pHttpOrderAckDestination;
};



//--------------------------------------
//
// Transaction Log Records:
//    Xact status, PrepInfo,  XactData
//
//--------------------------------------

// XactStatusRecord
typedef struct _XactStatusRecord {
	ULONG         m_ulIndex;
    TXACTION      m_taAction;
    ULONG         m_ulFlags;
} XactStatusRecord;


class CXactStatusRecord 
{
public:
	CXactStatusRecord(
          ULONG    ulIndex,
          TXACTION taAction,
          ULONG    ulFlags);
    ~CXactStatusRecord();

	XactStatusRecord   m_Data;
};

// PrepInfoRecord
#pragma warning(disable: 4200)          // zero-sized array in struct/union
typedef struct _PrepInfoRecord {
	ULONG         m_ulIndex;
    ULONG         m_cbPrepInfo;
    UCHAR         m_bPrepInfo[];
} PrepInfoRecord;
#pragma warning(default: 4200)          // zero-sized array in struct/union

class CPrepInfoRecord 
{
public:
	CPrepInfoRecord(
          ULONG    ulIndex,
          ULONG    cbPrepInfo,
          UCHAR    *pbPrepInfo);
    ~CPrepInfoRecord();

	PrepInfoRecord   *m_pData;
};

// XactDataRecord
typedef struct _XactDataRecord {
	ULONG         m_ulIndex;
    ULONG         m_ulSeqNum;  
    BOOL          m_fSinglePhase;
    XACTUOW       m_uow;	
} XactDataRecord;


class CXactDataRecord 
{
public:
	CXactDataRecord(
          ULONG    ulIndex,
          ULONG    ulSeqNum,
          BOOL     fSinglePhase,
          const XACTUOW  *puow
          );
    ~CXactDataRecord();

	XactDataRecord   m_Data;
};

//---------------------------------------------------------
//
//  class CXactStatusFlush : flush notification element 
//
//---------------------------------------------------------
class CXactStatusFlush: public CAsynchSupport
{
public:
     CXactStatusFlush(CTransaction *pCTrans, TXFLUSHCONTEXT tcContext);
    ~CXactStatusFlush();

     VOID AppendCallback(HRESULT hr, LRP lrpAppendLRP);
     VOID ChkPtCallback (HRESULT hr, LRP lrpAppendLRP);
     static void WINAPI TimeToCallback(CTimer* pTimer); 
     VOID AppendCallbackWork();

private:
	CTransaction        *m_pTrans;
    TXFLUSHCONTEXT       m_tcContext;

    HRESULT              m_hr;
    LRP                  m_lrpAppendLRP;
    CTimer               m_Timer;
};

//---------------------------------------------------------
//
//  class CInSeqFlush : flush notification element 
//
//---------------------------------------------------------
class CInSeqFlush: public CAsynchSupport
{
friend class CUnfreezeSorter;

public:
     CInSeqFlush(
         CBaseHeader  *pPktBasePtr,
         CPacket      *pDriverPacket,
         HANDLE        hQueue,    
         OBJECTID     *pMessageId,
         const GUID   *pSrcQMId,
         USHORT        usClass,
         USHORT        usPriority,
         LONGLONG      liSeqID,
         ULONG         ulSeqN,
         ULONG         ulPrevSeqN,
         QUEUE_FORMAT *pqdDestQueue,
		 const R<CWcsRef>&  StreamId);
    ~CInSeqFlush();

     VOID    AppendCallback(HRESULT hr, LRP lrpAppendLRP);
     VOID    ChkPtCallback (HRESULT hr, LRP lrpAppendLRP);
     static void WINAPI TimeToCallback(CTimer* pTimer); 
     VOID AppendCallbackWork();
     HRESULT Unfreeze();

private:
	CBaseHeader *m_pPktBasePtr;
    CPacket     *m_pDriverPacket;
	HANDLE       m_hQueue;
    OBJECTID     m_MessageId;
    GUID         m_SrcQMId;
    USHORT       m_usClass;
    USHORT       m_usPriority;
    LONGLONG     m_liSeqID;
    ULONG        m_ulSeqN;
    ULONG        m_ulPrevSeqN;
    QUEUE_FORMAT m_qdDestQueue;
	R<CWcsRef>    m_StreamId;

    HRESULT              m_hr;
    LRP                  m_lrpAppendLRP;
    CTimer               m_Timer;
};

//---------------------------------------------------------
//
//  class CConsolidationFlush : flush notification element 
//
//---------------------------------------------------------
class CConsolidationFlush: public CAsynchSupport
{
public:
     CConsolidationFlush(HANDLE hEvent);
    ~CConsolidationFlush();

     VOID AppendCallback(HRESULT hr, LRP lrpAppendLRP);
     VOID ChkPtCallback (HRESULT hr, LRP lrpAppendLRP);

private:
	HANDLE   m_hEvent;
};

//---------------------------------------------------------
//
//  class CChkptNotification : checkpoint notification element 
//
//---------------------------------------------------------
class CChkptNotification: public CAsynchSupport
{
public:
     CChkptNotification(HANDLE hEvent);
    ~CChkptNotification();

     VOID AppendCallback(HRESULT hr, LRP lrpAppendLRP);
     VOID ChkPtCallback (HRESULT hr, LRP lrpAppendLRP);

private:
     HANDLE  m_hEvent;    

};

//--------------------------------------
//
// Class CLogger
//
//--------------------------------------
class CLogger {

public:
    CLogger();
    ~CLogger();

    //Initialization
    HRESULT PreInit(
                 BOOL *pfLogExists);
    HRESULT Init(
                 PULONG pulVerInSeq, 
                 PULONG pulVerXact,
                 ULONG  ulNumCheckpointFromTheEnd);
    HRESULT Init_Legacy();
    HRESULT Recover();

    void Activate();
	void Finish();
    bool Stoped() const;
    void SignalStop();

    // Logging: external level
    void    LogXactPhase(                       // Logs the xact life phase
                ULONG ulIndex, 
                TXACTION txAction);

    void    LogXactFlags(CTransaction *pTrans); // Logs the xact flags
    
    void    LogXactFlagsAndWait(                // Logs xact flags and waits
                TXFLUSHCONTEXT tcContext,
                CTransaction   *pCTrans,
                BOOL fFlushNow=FALSE);
    
    void    LogXactPrepareInfo(                 // Logs xact prepare info
                ULONG  ulIndex,
                ULONG  cbPrepareInfo,
                UCHAR *pbPrepareInfo);

    void    LogXactData(                        // Logs xact data (uow, seqnum)
                ULONG    ulIndex,
                ULONG    ulSeqNum,
                BOOL     fSinglePhase,
                const XACTUOW  *puow);

    HRESULT LogInSeqRec(
                BOOL          fFlush,			// flush hint
                CInSeqFlush  *pNotify,			// notification element
				CInSeqRecord *pInSeqRecord);	// log data 

	HRESULT LogInSeqRecSrmp(
            BOOL          fFlush,			// flush hint
            CInSeqFlush  *pNotify,			// notification element
			CInSeqRecordSrmp *pInSeqRecord);  	// log data 

    
    HRESULT LogConsolidationRec(
                ULONG ulInSeq,                      // Version of the InSeq checkpoint file
                ULONG ulXact,                       // Version of the Trans checkpoint file
                HANDLE hEvent);                     // Event to signal on notification

    HRESULT LogEmptyRec(void);

    BOOL      MakeCheckpoint(HANDLE hComplete);   // orders checkpoint; result means only request, not result
    HRESULT Checkpoint();                       // writes checkpoint record
    HANDLE FlusherEvent();                     // Get for the flusher event
    HANDLE FlusherThread();
    BOOL    Dirty();                            // Get for the dirty flag
    void    ClearDirty();                       // Clears away the flag
    void    SignalCheckpointWriteComplete();    // Signals that checkpoint write completed
    BOOL    Active();                           // Is active
    BOOL    InRecovery();                       // In recovery

    static void WINAPI TimeToCheckpoint(CTimer* pTimer); // periodic checkpoint 
    void    PeriodicFlushing();

    DWORD   CompareLRP(LRP lrpLRP1, LRP lrpLRP2);  // 0: equal, 
                                                   // 1:lrp1 older than lrpLRP2
                                                   // 2:lrp2 older than lrpLRP1

    void    SetCurrent(LRP lrpLRP);              // collects highest LRP

private:
    // Initialization
    BOOL    LogExists();
    void    ChooseFileName(WCHAR *wszDefFileName, WCHAR *wszRegKey);
    HRESULT GetLogMgr(void);
    HRESULT InitLog();
    HRESULT CreateLogFile(void);
    HRESULT CreateInitialChkpoints(void);
    HRESULT InitLogRead(void);
    HRESULT InitLogWrite(void);

    // Logging: internal level
    HRESULT LogXactStatusRec(
                BOOL               fFlush,			// flush hint
                CXactStatusFlush  *pNotify,			// notification element
				CXactStatusRecord *pInSeqRecord);	// log data 
    
    HRESULT LogPrepInfoRec(
                BOOL               fFlush,			// flush hint
                CXactStatusFlush  *pNotify,			// notification element
				CPrepInfoRecord   *pPrepInfoRecord);// log data 
    
    HRESULT LogXactDataRec(
                BOOL               fFlush,			// flush hint
                CXactStatusFlush  *pNotify,			// notification element
				CXactDataRecord   *pXactDataRecord);// log data 
    
    // Logging primitives
	LOGREC *CreateLOGREC(
                USHORT usUserType, 
                PVOID pData, 
                ULONG cbData);

    HRESULT Log(
                USHORT          usRecType,      // log record type
                BOOL            fFlush,			// flush hint
                CAsynchSupport *pCAsynchSupport,// notification element
			    VOID           *pData,          // log data 
                ULONG           cbData);

    // Recovery
	HRESULT ReadToEnd(LOG_RECOVERY_ROUTINE pf);
    HRESULT ReadLRP(  LOG_RECOVERY_ROUTINE pf);
    HRESULT ReadNext( LOG_RECOVERY_ROUTINE pf);
    
    // Cleanup
    void ReleaseWriteStream(void);
    void ReleaseReadStream(void);
    void ReleaseLogStorage();
    void ReleaseLogInit();
    void ReleaseLogCF();

private:
	// Log manager interfaces
    IClassFactory		*m_pCF;
    ILogInit			*m_pILogInit;
    ILogStorage			*m_pILogStorage;
    ILogRecordPointer	*m_ILogRecordPointer;
    ILogRead			*m_pILogRead;
    ILogWrite			*m_pILogWrite;
    ILogWriteAsynch		*m_pILogWriteAsynch;

	// Log manager tuning parameters
	UINT                 m_uiTimerInterval;	// msec: logger will check the need  for flush/chkpt each this interval
	UINT				 m_uiFlushInterval; // msec: logger will flush at least at this intervals 
	UINT				 m_uiChkPtInterval; // msec: logger will write his internal chkpts at these intervals 
    UINT                 m_uiSleepAsynch;   // msec: to sleep before repeating AppendAsynch when not enough append threads
    UINT                 m_uiAsynchRepeatLimit;   // msec: repeat limit for AppendAsynch when not enough append threads
	ULONG				 m_ulLogBuffers;
	ULONG				 m_ulLogSize;

	// Logging current data
    CHAR                 m_szFileName[FILE_NAME_MAX_SIZE]; // log storage name
    LRP 				 m_lrpCurrent;              // Current LRP used
    DWORD				 m_dwStreamMode;	        // STRMMODEWRITE or STRMMODEREAD 
    ULONG				 m_ulAvailableSpace;        // Space left after write
    ULONG				 m_ulFileSize;		        // Total possible space in log

    // Checkpointing
    BOOL                 m_fDirty;          // there were changes since last flush
    HANDLE               m_hFlusherEvent;   // Event for flusher coordination
    HANDLE               m_hFlusherThread;  // Flusher thread
    HANDLE               m_hCompleteEvent;  // Event for complete coordination

    // State
    BOOL                 m_fActive;            // set AFTER starting action
    BOOL                 m_fInRecovery;        // set while in recovery stage

    // Checkpoint timer
    ULONG  m_ulCheckpointInterval;
    CTimer m_CheckpointTimer;

    // Checkpoint event
    HANDLE               m_hChkptReadyEvent;    

    bool m_fStop;
};


// Single Global Instance of the logger
extern CLogger    g_Logger;
extern void       IsolateFlushing();  // holds the caller while flushing works



#endif  __XACTLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactout.h ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactOut.h

Abstract:
    Exactly-once sender implementation classes:
        CSeqPacket      - Sequential Packet,
        COutSequence    - Outgoing Sequence,
        COutSeqHash     - Outgoing Sequences Hash table

Author:
    AlexDad

--*/

#ifndef __XACTOUT_H__
#define __XACTOUT_H__

#include <Ex.h>
#include "msgprops.h"

#define ORDER_ACK_TITLE       (L"QM Ordering Ack")

HRESULT QMInitOrderQueue();

BOOL WINAPI ReceiveOrderCommands(CMessageProperty* pmp, QUEUE_FORMAT* pqf);

void SeqPktTimedOut(CBaseHeader * pPktBaseHdr, CPacket * pDriverPacket, BOOL fTimeToBeReceived);

DWORD HashGUID(const GUID &guid);

class COutSeqHash;  // forward declaration

//-------------------------------------
// Ordering ack data format
//-------------------------------------
#pragma pack(push, 1)
typedef struct {
    LONGLONG  m_liSeqID;
    ULONG     m_ulSeqN;
    ULONG     m_ulPrevSeqN;
    OBJECTID  MessageID;
} OrderAckData;
#pragma pack(pop)


//---------------------------------------------------------------------
//
// class CKeyDirection (needed for CMap)
//
//---------------------------------------------------------------------
class CKeyDirection : public QUEUE_FORMAT
{
public:
    CKeyDirection(const QUEUE_FORMAT *pqf);
    CKeyDirection();
    CKeyDirection(const CKeyDirection &key);
    ~CKeyDirection();

    CKeyDirection &operator=(const CKeyDirection &key2 );
};

// CMap helper functions
UINT AFXAPI HashKey(const CKeyDirection& key);

//---------------------------------------------------------
//
//  class CSeqPacket
//
//---------------------------------------------------------

class CSeqPacket {

public:
    CSeqPacket(CQmPacket *);
    ~CSeqPacket();

    // Get / Set for local fields
    inline CQmPacket *Pkt() const;
    void   SetClass(USHORT usClass);
    inline USHORT     GetClass(void);

    // Get for  CQmPacket's fields
    inline LONGLONG   GetSeqID(void) const;
    inline ULONG      GetSeqN(void) const;
    inline LONG       GetHighSeqID(void) const;
    inline DWORD      GetLowSeqID(void) const;

    inline ULONG      GetPrevSeqN(void) const;
    inline void       SetPrevSeqN(ULONG ulPrevSeqN);

    // Driver operations on the packet
    HRESULT           AcFreePacket();
    void              DeletePacket(USHORT usClass);
    HRESULT           Save();

private:

    CQmPacket *m_pQmPkt;              // QM Packet ptr
    USHORT    m_usClass;              // Packet class (status for the journal)

    LONGLONG  m_liSeqID;              // Replicas from the packet
    ULONG     m_ulSeqN;
    ULONG     m_ulPrevSeqN;
};

//---------------------------------------------------------
//
//  class COutSequence
//
//---------------------------------------------------------

class COutSequence {

public:
    COutSequence(LONGLONG       liSeqID,
                 QUEUE_FORMAT   *pqf,
				 HANDLE hQueue);

    ~COutSequence();

    inline LONGLONG SeqID(void)     const;    // Get: Sequence ID
    inline LONG     HighSeqID(void) const;
    inline DWORD    LowSeqID(void)  const;

    void   SetAckSeqN(ULONG SeqN);            // Set/Get: max  acked number
    inline ULONG AckSeqN(void)      const;

    CKeyDirection *KeyDirection(void);        // Get: direction

    inline ULONG ResendIndex(void)  const;    // Current resend index
    inline void  ClearResendIndex(void);	  // Reset the resend index to zero
    void  PlanNextResend(BOOL fImmediate);    // Schedule next resend
    void  StartResendTimer(BOOL fImmediate);  // Schedules first resend

    inline ULONG LastResent(void);            // Returns the number of the last resent packet; INFINITE means no resend state
    inline void  LastResent(ULONG ul);        // Sets it

    inline BOOL  IsEmpty(void) const;         // Indicates there is no Qm-owned packets
    inline BOOL  OnHold(void) const;          // Indicates there the sequence is on hold (blocked by previous sequences)
    inline BOOL  Advanced(void);              // Indicates acking advance; remembers m_ulPrevAckSeqN
                                              // NB - should be called from one place only

    BOOL  Lookup(ULONG ulSeqN,                // Looks for the packet with the given SeqN
                 CSeqPacket **ppSeqPkt);

    void Insert(CQmPacket *pPkt);             // Inserts new QM packet into the sequence

    BOOL  Add(ULONG      ulSeqN,              // Adds the QM packet to the sequence
              CQmPacket  *pPkt,
              CSeqPacket **ppSeqPkt);

    BOOL  PreSendProcess(CQmPacket* pPkt);
    void  PostSendProcess(CQmPacket* pPkt,
                         ULONG ulMaxTTRQ);

    void  RequestDelete();                    // Marks the sequence for deletion and plans resend
    BOOL  Delete(ULONG ulSeqN,                // Deletes the packet from the list, frees memory
                 USHORT usClass);             //     class for NACK/ACK

    void  SeqAckCame(ULONG ulSeqN);           // Modifies everything when SeqAck came
    void  BadDestAckCame(ULONG ulSeqN,        // Resolves all pkts up to pointed as BadDestQueue
                       USHORT usClass);

    void  TreatOutSequence();                 // Periodical treatment of outgoing sequence
    static void WINAPI
          TimeToResendOutSequence(CTimer* pTimer);

    void  ResendSequence();                   // Resends the whole sequence
    BOOL  ResendSeqPkt(CSeqPacket *pSeqPkt);  // Resends the seq packet

    void UpdateOnHoldStatus(CQmPacket* pPkt); // Updates On Hold status of the sequence

    COutSequence  *PrevSeq();                 // Previous sequence in specific direction
    void PrevSeq(COutSequence *p);
    COutSequence  *NextSeq();                 // Next     sequence in specific direction
    void NextSeq(COutSequence *p);
    void GetLastAckForDirection(              // Finds out last ack for the whole direction
           LONGLONG *pliAckSeqID,
           ULONG *pulAckSeqN);


    //
    // Admin Functions
    //
    HRESULT GetUnackedSequence(
        LONGLONG* pliSeqID,
        ULONG* pulSeqN,
        ULONG* pulPrevSeqN,
        BOOL fFirst
        ) const;

    DWORD   GetUnackedCount  (void) const;
    time_t  GetLastAckedTime (void) const;
    DWORD   GetLastAckCount  (void) const;
    DWORD   GetResendInterval(void) const;
    time_t  GetNextResendTime(void) const;
    void    AdminResend      (void);

private:
    LONGLONG   m_liSeqID;               // sequence ID
    BOOL       m_fMarkedForDelete;      // flag of the delete request

    ULONG      m_ulResendCycleIndex;    // index of the current resend cycle
    time_t     m_NextResendTime;        // time of the next resend

    time_t     m_timeLastAck;           // time of creation or last ack coming

    ULONG      m_ulLastAckSeqN;         // Max known acked number
    ULONG      m_ulPrevAckSeqN;         // Max known acked number at the previous resend iteration
    ULONG      m_ulLastAckCount;        // SeqN of duplicate order ack received

    //
    // Key controls for the algorithm
    //
    ULONG      m_ulLastResent;          // SeqN of the last packet that has been resent by ResendSequence
                                        //   We do not send anything bigger
                                        //   INFINITE means NOT ResendInProgress, so send everything

    // List of unacked packets for resend
    CList<CSeqPacket *, CSeqPacket *&>         m_listSeqUnackedPkts;

    // Direction: destination format name
    CKeyDirection m_keyDirection;

    // Links in the double-linked list of sequences per direction
    COutSequence *m_pPrevSeq;
    COutSequence *m_pNextSeq;

    // Resending timer
    CTimer m_ResendTimer;
    BOOL m_fResendScheduled;

	// Queue handle
	HANDLE m_hQueue;

    // Flag of sequence On Hold - if set, messages cannot be sent
    BOOL m_fOnHold;
};

//---------------------------------------------------------
//
//  class COutSeqHash
//
//---------------------------------------------------------

class COutSeqHash  //: public CPersist
{
    public:
        COutSeqHash();
        ~COutSeqHash();

        void LinkSequence(                            // Links the sequence into the SeqID-based and Direction-based structures
                     LONGLONG liSeqID,
                     CKeyDirection *pkeyDirection,
                     COutSequence *pOutSeq);

        void SeqAckCame(                              // Reflects coming of the Seq ACK
                     LONGLONG liSeqID,
                     ULONG ulSeqN,
                     QUEUE_FORMAT* pqf);

        BOOL Consult(                                 // Looks for the sequence (not creating it)
                     LONGLONG liSeqID,
                     COutSequence **ppOutSeq) const;

        COutSequence *ProvideSequence(                // Looks for the sequence or creates it
                     LONGLONG liSeqID,
                     QUEUE_FORMAT *pqf,
                     bool          bInSend);

        void  AckedPacket(                            // Marks acked packet
                     LONGLONG liSeqID,
                     ULONG ulSeqN,
                     CQmPacket* pPkt);

        BOOL  Delete(                                 // Deletes packet
                     LONGLONG liSeqID,
                     ULONG ulSeqN,
                     USHORT usClass);

        void  DeleteSeq(LONGLONG liSeqId);            // Deletes the sequence

        BOOL PreSendProcess(CQmPacket* pPkt,
                            bool       bInSend);     // Preprocesses the message before send

        void PostSendProcess(CQmPacket* pPkt);       // Postprocesses the message after send

        void NonSendProcess(                         // PostProcesses the case of non-sent message
                    CQmPacket* pPkt,
                    USHORT usClass);

        void KeepDelivered(                          // Moves the packet to the list of delivered
                    CSeqPacket *pSeqPkt);

        void ResolveDelivered(
                    OBJECTID* pMsgId,
                    USHORT   usClass);

        BOOL LookupDelivered(                        // Looks up the packet in the delivered map
                    OBJECTID   *pMsgId,
                    CSeqPacket **ppSeqPkt);

        void SeqPktTimedOutEx(                       // Processes TTRQ timeout for non-delivered pkt
                    CQmPacket *pPkt,
                    CBaseHeader* pPktBaseHdr);

        HRESULT TreatOutgoingOrdered();              // For each sequence, recalculates Previous and adds TimedOut records

        //
        // Administration functions
        //
        HRESULT GetLastAck(
             LONGLONG liSeqID,
             ULONG& ulSeqN
             ) const;

        HRESULT GetUnackedSequence(
            LONGLONG liSeqID,
            ULONG* pulSeqN,
            ULONG* pulPrevSeqN,
            BOOL fFirst
            ) const;

        DWORD   GetUnackedCount(LONGLONG liSeqID)     const;
        time_t  GetLastAckedTime(LONGLONG liSeqID)    const;
        DWORD   GetLastAckCount(LONGLONG liSeqID)     const;
        DWORD   GetResendInterval(LONGLONG liSeqID)   const;
        time_t  GetNextResendTime(LONGLONG liSeqID)   const;
        DWORD   GetAckedNoReadCount(LONGLONG liSeqID) const;
        DWORD   GetResendCount(LONGLONG liSeqID)      const;
        DWORD   GetResendIndex(LONGLONG liSeqID)      const;
        void    AdminResend(LONGLONG liSeqID)         const;

    private:
        // Mapping of all current outgoing sequences
        CMap<LONGLONG, LONGLONG &,COutSequence *, COutSequence *&>m_mapOutSeqs;

        // Mapping Msg ID to waiting ack packet
        CMap<DWORD, DWORD, CSeqPacket *, CSeqPacket *&> m_mapWaitAck;

        // Mapping Msg ID to MSG that was acked and have not gotten order ack yet.
        CMap<DWORD, DWORD, USHORT, USHORT> m_mapAckValue;

        // Mapping of all current outgoing directions
        CMap<CKeyDirection, const CKeyDirection &,COutSequence *, COutSequence *&>m_mapDirections;

        // Data for persistency control (via 2 ping-pong files)
        ULONG      m_ulPingNo;                    // Current counter of ping write
        ULONG      m_ulSignature;                 // Saving signature

        ULONG      m_ulMaxTTRQ;                   // last TTRQ absolutee time as learned from the driver
        //
        // Management Function
        //
        enum INFO_TYPE {
            eUnackedCount,
            eLastAckTime,
            eLastAckCount,
            eResendInterval,
            eResendTime,
            eResendIndex,
        };

        DWORD_PTR
        GetOutSequenceInfo(
            LONGLONG liSeqID,
            INFO_TYPE InfoType
            ) const;
};

//---------------------------------------------------------
//
//  Global object (single instance for DLL)
//
//---------------------------------------------------------

extern COutSeqHash       g_OutSeqHash;
extern CCriticalSection  g_critOutSeqHash;

//---------------------------------------------------------
//
//  inline implementations
//
//---------------------------------------------------------

inline USHORT CSeqPacket::GetClass(void)
{
    return m_usClass;
}

inline CQmPacket *CSeqPacket::Pkt(void) const
{
    return(m_pQmPkt);
}

inline LONGLONG CSeqPacket::GetSeqID(void) const
{
    return m_liSeqID;
}

inline ULONG CSeqPacket::GetSeqN(void) const
{
    return m_ulSeqN;
}

inline LONG CSeqPacket::GetHighSeqID(void) const
{
    return ((LARGE_INTEGER*)&m_liSeqID)->HighPart;
}

inline DWORD CSeqPacket::GetLowSeqID(void) const
{
    return ((LARGE_INTEGER*)&m_liSeqID)->LowPart;
}

inline ULONG CSeqPacket::GetPrevSeqN(void) const
{
    return m_pQmPkt->GetPrevSeqN();
}

inline void CSeqPacket::SetPrevSeqN(ULONG ulPrevSeqN)
{
    m_pQmPkt->SetPrevSeqN(ulPrevSeqN);
    m_ulPrevSeqN = ulPrevSeqN;
}

inline LONGLONG COutSequence::SeqID(void) const
{
    return m_liSeqID;
}

inline LONG COutSequence::HighSeqID(void) const
{
    return ((LARGE_INTEGER*)&m_liSeqID)->HighPart;
}

inline DWORD COutSequence::LowSeqID(void) const
{
    return ((LARGE_INTEGER*)&m_liSeqID)->LowPart;
}

inline ULONG COutSequence::AckSeqN(void) const
{
    return m_ulLastAckSeqN;
}

inline ULONG COutSequence::LastResent()
{
    return m_ulLastResent;
}

inline void COutSequence::LastResent(ULONG ul)
{
    m_ulLastResent = ul;
    return;
}

inline ULONG COutSequence::ResendIndex(void) const
{
    return(m_ulResendCycleIndex);
}

inline void COutSequence::ClearResendIndex(void)
{
    m_ulResendCycleIndex = 0;
    return;
}

inline BOOL  COutSequence::Advanced()
{
    BOOL f =  (m_ulLastAckSeqN > m_ulPrevAckSeqN);
    m_ulPrevAckSeqN = m_ulLastAckSeqN;
    return f;
}

inline BOOL COutSequence::IsEmpty(void) const
{
    return (m_listSeqUnackedPkts.IsEmpty());
}

inline BOOL COutSequence::OnHold(void) const
{
    return (m_fOnHold);
}


inline
DWORD
COutSequence::GetUnackedCount(
    void
    ) const
{
    return  m_listSeqUnackedPkts.GetCount();
}

inline
time_t
COutSequence::GetLastAckedTime(
    void
    ) const
{
    return m_timeLastAck;
}

inline
time_t
COutSequence::GetNextResendTime(
    void
    ) const
{
    return m_NextResendTime;
}

inline
DWORD
COutSequence::GetLastAckCount(
    void
    ) const
{
    return m_ulLastAckCount;
}


inline COutSequence *COutSequence::PrevSeq()
{
    return m_pPrevSeq;
}

inline COutSequence *COutSequence::NextSeq()
{
    return m_pNextSeq;
}

inline void COutSequence::PrevSeq(COutSequence *p)
{
    m_pPrevSeq = p;
}

inline void COutSequence::NextSeq(COutSequence *p)
{
    m_pNextSeq = p;
}

inline CKeyDirection *COutSequence::KeyDirection(void)
{
    return &m_keyDirection;
}

inline
DWORD
COutSeqHash::GetUnackedCount(
    LONGLONG liSeqID
    ) const
{
    return DWORD_PTR_TO_DWORD(GetOutSequenceInfo(liSeqID,eUnackedCount));
}

inline
time_t
COutSeqHash::GetLastAckedTime(
    LONGLONG liSeqID
    ) const
{
    return GetOutSequenceInfo(liSeqID,eLastAckTime);
}

inline
DWORD
COutSeqHash::GetLastAckCount(
    LONGLONG liSeqID
    ) const
{
    return DWORD_PTR_TO_DWORD(GetOutSequenceInfo(liSeqID,eLastAckCount));
}

inline
DWORD
COutSeqHash::GetResendInterval(
    LONGLONG liSeqID
    ) const
{
    return DWORD_PTR_TO_DWORD(GetOutSequenceInfo(liSeqID,eResendInterval));
}

inline
time_t
COutSeqHash::GetNextResendTime(
    LONGLONG liSeqID
    ) const
{
    return GetOutSequenceInfo(liSeqID,eResendTime);
}

inline
DWORD
COutSeqHash::GetResendIndex(
    LONGLONG liSeqID
    ) const
{
    return DWORD_PTR_TO_DWORD(GetOutSequenceInfo(liSeqID,eResendIndex));
}

inline LONG HighSeqID(LONGLONG ll)
{
    return ((LARGE_INTEGER*)&ll)->HighPart;
}

inline DWORD LowSeqID(LONGLONG ll)
{
    return ((LARGE_INTEGER*)&ll)->LowPart;
}

#endif __XACTOUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactin.h ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactIn.h

Abstract:
    Exactly-once receiver implementation classes:
        CKeyinSeq           - Incoming Sequence Key
        CInSequence         - Incoming Sequence,
        CInSeqHash          - Incoming Sequences Hash table

    Persistency:  ping-pong + Win32 File writes + logger

Author:
    AlexDad

--*/

#ifndef __XACTIN_H__
#define __XACTIN_H__
#include "xactunfr.h"

#define FILE_NAME_MAX_SIZE     256
enum XactDirectType{dtxNoDirectFlag = 0, 
					dtxDirectFlag = 1, 
					dtxHttpDirectFlag = 2};

//
// This type is persist to disk - it must be integer (4 bytes) long
//
C_ASSERT(sizeof(XactDirectType) == sizeof(int));



//---------------------------------------------------------------------
//
// class CKeyInSeq (needed for CMap)
//
//---------------------------------------------------------------------
class CKeyInSeq
{
public:
    CKeyInSeq(const GUID *pGuid, QUEUE_FORMAT *pqf,const  R<CWcsRef>& StreamId);
    CKeyInSeq();
    
    ~CKeyInSeq();

    // Get methods
    const GUID  *GetQMID()  const;
    const QUEUE_FORMAT  *GetQueueFormat() const;
	const WCHAR* GetStreamId() const;

    CKeyInSeq &operator=(const CKeyInSeq &key2 );

    // Persistency
    BOOL Save(HANDLE hFile);
    BOOL Load(HANDLE hFile);

private:
	CKeyInSeq(const CKeyInSeq &key);
	BOOL SaveNonSrmp(HANDLE hFile);
	BOOL SaveSrmp(HANDLE hFile);
	BOOL LoadNonSrmp(HANDLE hFile);
	BOOL LoadSrmp(HANDLE );
	BOOL LoadQueueFormat(HANDLE hFile);
	BOOL LoadSrmpStream(HANDLE hFile);
 

private:
    GUID         m_Guid;
    QUEUE_FORMAT m_QueueFormat;
	R<CWcsRef>    m_StreamId;
};

// CMap helper functions
UINT AFXAPI HashKey(CKeyInSeq& key);
BOOL operator==(const CKeyInSeq &key1, const CKeyInSeq &key2);

//---------------------------------------------------------
//
//  class CInSequence
//
//---------------------------------------------------------

class CInSequence
{

public:
    CInSequence(const CKeyInSeq &key,
                const LONGLONG liSeqID, 
                const ULONG ulSeqN, 
                XactDirectType DirectType,
                const GUID  *pgTaSrcQm ,
				const R<CWcsRef>&   HttpOrderAckQueue);
    
    CInSequence(const CKeyInSeq &key);
    ~CInSequence();

    // Get methods
    LONGLONG    SeqIDVer() const;       // GET: SeqID verified
    LONGLONG    SeqIDReg() const;       // GET: SeqID registered
    ULONG       SeqNVer() const;        // GET: Last SeqN verified
    ULONG       SeqNReg() const;        // GET: Last SeqN registered
    time_t      LastActive() const;     // GET: Last activity time (last msg verified and passed)
    time_t      LastAccessed() const;   // GET: Last access time (last msg verified, maybe rejected)
    time_t      LastAcked() const;      // GET: Last order ack sent
	
    

	// Set methods
	void        SetSourceQM(const GUID  *pgTaSrcQm);
	void        RenewHttpOrderAckQueue(const R<CWcsRef>& OrderAckQueue);

    // Modify methods
    void      Advance(LONGLONG liSeqID, // Advances SeqID/N Ver
					  ULONG ulSeqN,
					  BOOL fPropagate); 
    
    // Order Acks
    void      RememberActivation();                         // Remembers the time of last activation
    void      PlanOrderAck();                               // Plans sending order ack
    void      SendAdequateOrderAck();                       // Sends the order ack

    // Unfreezing
    void      SortedUnfreeze(CInSeqFlush *pInSeqFlush,
                             const GUID  *pSrcQMId,
                             const QUEUE_FORMAT *pqdDestQueue);     

    // Persistency
    BOOL Save(HANDLE hFile);
    BOOL Load(HANDLE hFile);

    //
    // Management function
    //
    DWORD GetRejectCount(void) const;
	void  UpdateRejectCounter(BOOL b);

    static void WINAPI TimeToSendOrderAck(CTimer* pTimer);





private:
    CKeyInSeq  m_key;                   // Sender QM GUID and  Sequence ID
    LONGLONG   m_liSeqIDVer;            // Current (or last) Sequence ID verified
    ULONG      m_ulLastSeqNVer;         // Last message number verified
    time_t     m_timeLastActive;        // time of creation or last message passing
    time_t     m_timeLastAccess;        // time of the last access to the sequence
    time_t     m_timeLastAck;           // time of the last order ack sending

    CUnfreezeSorter m_Unfreezer;        // Unfreezer object

    XactDirectType     m_DirectType;               // flag of direct addressing
    union {                 
        GUID        m_gDestQmOrTaSrcQm; // for non-direct: GUID of destination QM
        TA_ADDRESS  m_taSourceQM;       // for direct: address of source QM
    };

	R<CWcsRef> m_HttpOrderAckQueue;
    DWORD m_AdminRejectCount;

    CCriticalSection   m_critInSeq;      // critical section for planning
    BOOL m_fSendOrderAckScheduled;
    CTimer m_SendOrderAckTimer;
};

inline
DWORD 
CInSequence::GetRejectCount(
    void
    ) const
{
    return m_AdminRejectCount;
}


//---------------------------------------------------------
//
//  class CInSeqHash
//
//---------------------------------------------------------

class CInSeqHash  : public CPersist {

public:
    CInSeqHash();
    ~CInSeqHash();

    BOOL Lookup(                              // Looks for the InSequence; TRUE = Found
                const GUID     *pQMID,
                QUEUE_FORMAT   *pqf,
				const R<CWcsRef>&  StreamId,
                CInSequence    **ppInSeq);

    BOOL Add(                                 // Looks for / Adds new InSequence to the hash; FALSE=existed before
                const GUID   *pQMID,
                QUEUE_FORMAT *pqf,
                LONGLONG      liSeqID,
                ULONG         ulSeqN,
                BOOL          fPropagate,
                XactDirectType   DirectType,
                const GUID     *pgTaSrcQm,
				const R<CWcsRef>&  pHttpOrderAckQueue,
				const R<CWcsRef>&  pStreamId);

    BOOL Verify(CQmPacket * pPkt);             // Verifies that the packet is valid for ordering
			   

    HRESULT Register(CQmPacket * PktPtrs,     // Registers valid packed as absorbed
                     HANDLE hQueue);


    VOID    CleanupDeadSequences();           // Erases dead sequences

    VOID    Restored(CQmPacket* pPkt);        // Correct info based on this restored packet

    BOOL    Save(HANDLE  hFile);              // Save / Load
    BOOL    Load(HANDLE  hFile);

    HRESULT SaveInFile(                       // Saves in file
                LPWSTR wszFileName, 
                ULONG ulIndex,
                BOOL fCheck);

    HRESULT LoadFromFile(LPWSTR wszFileName); // Loads from file

    BOOL    Check();                          // Verifies the state

    HRESULT Format(ULONG ulPingNo);           // Formats empty instance

    void    Destroy();                        // Destroyes allocated data
    
    ULONG&  PingNo();                         // Gives access to ulPingNo

    HRESULT PreInit(ULONG ulVersion,
                    TypePreInit tpCase);      // PreInitializes (loads data)
                                             
    HRESULT Save();                           // Saves in appropriate file

    CCriticalSection &InSeqCritSection();     // Provides access to the InSeq critical section

	void InSeqRecovery(					      // Recovery function 
				USHORT usRecType,			  //  (will be called for each log record)
				PVOID pData, 
				ULONG cbData);

    //
    // Management Function
    //
    void
    GetInSequenceInformation(
        const QUEUE_FORMAT *pqf,
        LPCWSTR QueueName,
        GUID** ppSenderId,
        ULARGE_INTEGER** ppSeqId,
        DWORD** ppSeqN,
        LPWSTR** ppSendQueueFormatName,
        TIME32** ppLastActiveTime,
        DWORD** ppRejectCount,
        DWORD* pSize
        );


    static void WINAPI TimeToCleanupDeadSequence(CTimer* pTimer);
    static DWORD m_dwIdleAckDelay;
    static DWORD m_dwMaxAckDelay;

private:
	void HandleInSecSrmp(void* pData, ULONG cbData);
	void HandleInSec(void* pData, ULONG cbData);
	

private:
    CCriticalSection   m_critInSeqHash;        // critical section for write

    // Mapping {Sender QMID, FormatName} --> InSequence (= SeqID + SeqN)
    CMap<CKeyInSeq, CKeyInSeq &, CInSequence *, CInSequence *&>m_mapInSeqs;

    // Data for persistency control (via 2 ping-pong files)
    ULONG      m_ulPingNo;                    // Current counter of ping write
    ULONG      m_ulSignature;                 // Saving signature

    #ifndef COMP_TEST
    CPingPong  m_PingPonger;                  // Ping-Pong persistency object
    #endif

    // Non-persistent data
    BOOL       m_bFinishing;                  // set when the object is in state of finishing

    ULONG      m_ulRevisionPeriod;            // period for checking dead sequences
    ULONG      m_ulCleanupPeriod;             // period of inactivity for deleting dead sequences

    BOOL m_fCleanupScheduled;
    CTimer m_CleanupTimer;
};

void AFXAPI DestructElements(CInSequence ** ppInSeqs, int n);

HRESULT SendXactAck(OBJECTID   *pMessageId,
                    bool    fDirect, 
				    const GUID *pSrcQMId,
                    const TA_ADDRESS *pa,
                    USHORT     usClass,
                    USHORT     usPriority,
                    LONGLONG   liSeqID,
                    ULONG      ulSeqN,
                    ULONG      ulPrevSeqN,
                    const QUEUE_FORMAT *pqdDestQueue);






//---------------------------------------------------------
//
//  Global object (single instance for DLL)
//
//---------------------------------------------------------

extern CInSeqHash *g_pInSeqHash;

extern HRESULT QMPreInitInSeqHash(ULONG ulVersion, TypePreInit tpCase);
extern void    QMFinishInSeqHash();


#endif __XACTIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactout.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactOut.cpp

Abstract:
    Current Outgoing Sequences objects implementation

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
#include "acdef.h"
#include "acioctl.h"
#include "acapi.h"
#include "qmpkt.h"
#include "cqmgr.h"
#include "privque.h"
#include "fn.h"
#include "phinfo.h"
#include "phuser.h"
#include "qmutil.h"
#include "xact.h"
#include "xactrm.h"
#include "xactout.h"
#include "xactlog.h"
#include "cqpriv.h"

#include "xactout.tmh"

extern HANDLE      g_hAc;
extern LPTSTR      g_szMachineName;

static WCHAR *s_FN=L"xactout";

// Provides WARNING dbgmsgs on changing send/bypass status
static BOOL s_SendingState = FALSE;

// Exactly-one sequences resend time cycle
ULONG  g_aulSeqResendCycle[] = {
    FALCON_DEFAULT_ORDERED_RESEND13_TIME*1000,  // 1: 30"
    FALCON_DEFAULT_ORDERED_RESEND13_TIME*1000,  // 1: 30"
    FALCON_DEFAULT_ORDERED_RESEND13_TIME*1000,  // 1: 30"
    FALCON_DEFAULT_ORDERED_RESEND46_TIME*1000,  // 1: 5'
    FALCON_DEFAULT_ORDERED_RESEND46_TIME*1000,  // 1: 5'
    FALCON_DEFAULT_ORDERED_RESEND46_TIME*1000,  // 1: 5'
    FALCON_DEFAULT_ORDERED_RESEND79_TIME*1000,  // 1: 30'
    FALCON_DEFAULT_ORDERED_RESEND79_TIME*1000,  // 1: 30'
    FALCON_DEFAULT_ORDERED_RESEND79_TIME*1000,  // 1: 30'
    FALCON_DEFAULT_ORDERED_RESEND10_TIME*1000}; // 1: 6h

// Delay for local timeout of non-received messages
ULONG   g_ulDelayExpire = INFINITE;

//---------------------------------------------------------
//
//  Global object (single instance for DLL)
//
//---------------------------------------------------------
COutSeqHash       g_OutSeqHash;        // Structure keeps all outgoing sequences
CCriticalSection  g_critOutSeqHash;    // Serializes all outgoing hash activity on the highest level

//--------------------------------------
//
// Class  CSeqPacket
//
//--------------------------------------

CSeqPacket::CSeqPacket(CQmPacket *pPkt)
{
    m_pQmPkt     = pPkt;
    m_usClass    = 0;
    m_liSeqID    = m_pQmPkt->GetSeqID();
    m_ulSeqN     = m_pQmPkt->GetSeqN();
}

CSeqPacket::~CSeqPacket()
{
	ASSERT(m_pQmPkt != NULL);
    delete m_pQmPkt;
}

void CSeqPacket::SetClass(USHORT usClass)
{
    //Don't reset the final receive acks
    if (m_usClass == MQMSG_CLASS_ACK_RECEIVE || MQCLASS_NEG_RECEIVE(m_usClass))
    {
        return;
    }

    // Don't reset the final delivery acks
    if ((usClass == MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT) && (m_usClass != 0))
    {
        return;
    }

    // keeping class provides with last known state
    if (usClass)
	{
		m_usClass = usClass;
	}
}

HRESULT CSeqPacket::AcFreePacket()
{
	ASSERT(m_pQmPkt != NULL);
    return LogHR(ACFreePacket(g_hAc, m_pQmPkt->GetPointerToDriverPacket(), m_usClass), s_FN, 10);
}

/*====================================================
CSeqPacket::DeletePacket
    Deletes packet
=====================================================*/
void CSeqPacket::DeletePacket(USHORT usClass)
{
    DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
           _TEXT("Exactly1 send: DeletePacket: SeqN=%d, SeqID=%x / %x, Class %x -> %x"),
            GetSeqN(), GetHighSeqID(), GetLowSeqID(), GetClass(), usClass));

    // Keep the class
    SetClass(usClass);

    // Process deleting
    switch(usClass)
    {
    case MQMSG_CLASS_ACK_REACH_QUEUE:
        // Packet was delivered
        g_OutSeqHash.KeepDelivered(this);   // Move to the delivered list
        break;

    case MQMSG_CLASS_ACK_RECEIVE:
        // Packet was received
        // Do we need ACK here?
        AcFreePacket();                     // Kill the packet
        delete this;
        break;

    case 0:
        // We don't know (e.g. on going down)
        delete this;
        break;

    default:
        //  Send negative acknowledgment for TTRQ and TTBR/local
        ASSERT(MQCLASS_NACK(usClass));
        if((usClass == MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT ||
            usClass == MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER) &&
           MQCLASS_MATCH_ACKNOWLEDGMENT(usClass, Pkt()->GetAckType()))
        {
            Pkt()->CreateAck(usClass);
        }

        // Killing the packet
        AcFreePacket();
        delete this;
        break;
    }
}

// Stores the packet and waits till store finish
HRESULT CSeqPacket::Save()
{
    return LogHR(m_pQmPkt->Save(), s_FN, 20);
}

//--------------------------------------
//
// Class  COutSequence
//
//--------------------------------------


/*====================================================
COutSequence::COutSequence - Constructor
=====================================================*/
COutSequence::COutSequence(LONGLONG liSeqID, QUEUE_FORMAT *pqf, HANDLE hQueue)
  : m_ResendTimer(TimeToResendOutSequence),
    m_keyDirection(CKeyDirection(pqf))
{
    m_liSeqID            = liSeqID;
    m_timeLastAck        = MqSysTime();
    m_pPrevSeq           = NULL;
    m_pNextSeq           = NULL;
    m_ulLastAckSeqN      = 0;
    m_ulPrevAckSeqN      = 0;
    m_ulLastResent       = INFINITE;        // means we are not in the resending state
    m_fMarkedForDelete   = FALSE;
    m_fResendScheduled   = FALSE;
    m_ulResendCycleIndex = 0;
    m_NextResendTime     = 0;
    m_ulLastAckCount     = 0;
    m_hQueue             = hQueue;
    m_fOnHold            = TRUE;

    g_OutSeqHash.LinkSequence(liSeqID, &m_keyDirection, this);
}

/*====================================================
COutSequence::~COutSequence  - Destructor
=====================================================*/
COutSequence::~COutSequence()
{
    ASSERT(!m_ResendTimer.InUse());
}

/*====================================================
COutSequence::SetAckSeqN
    Sets the m_ulLastAckSeqN as max Ack seen so far
=====================================================*/
void COutSequence::SetAckSeqN(ULONG ulSeqN)
{
    if (ulSeqN > m_ulLastAckSeqN)
    {
        m_ulLastAckSeqN = ulSeqN;
        m_ulLastAckCount = 0;
    }

    ++m_ulLastAckCount;
}

/*====================================================
COutSequence::Add
    Adds new CSeqPacket to the Sequence.
    List is sorted by SeqN (increasing order).
    No duplicates allowed (otherwise returns FALSE)
=====================================================*/
BOOL COutSequence::Add(ULONG ulSeqN, CQmPacket *pQmPkt, CSeqPacket **ppSeqPkt)
{
    // Look for the correct place in the list
    BOOL        fAddToHead  = TRUE;

    POSITION posInList  = m_listSeqUnackedPkts.GetTailPosition(),
             posCurrent = NULL;

    while (posInList != NULL)
    {
        posCurrent = posInList;
        CSeqPacket* pSeqPktPrev = m_listSeqUnackedPkts.GetPrev(posInList);

        if (pSeqPktPrev->GetSeqN() == ulSeqN)
        {
            // Duplicate
            *ppSeqPkt = pSeqPktPrev;
            return FALSE;
        }
        else if (pSeqPktPrev->GetSeqN() < ulSeqN)
        {
            // This will be the last packet
            fAddToHead = FALSE;
            break;
        }
   }

   CSeqPacket *pSeqPkt = new CSeqPacket(pQmPkt);
   ASSERT(ulSeqN == pSeqPkt->GetSeqN());

   // return the pointer
   if (ppSeqPkt)
   {
        *ppSeqPkt = pSeqPkt;
   }

   // Add the packet to the list
   if (fAddToHead)
   {
       m_listSeqUnackedPkts.AddHead(pSeqPkt);
   }
   else
   {
       m_listSeqUnackedPkts.InsertAfter(posCurrent, pSeqPkt);
   }

   return TRUE;
}

/*====================================================
COutSequence::Lookup
    Looks for the CSeqPacket by SeqN.
    Returns TRUE  and pointer to the exact packet - if found
    Returns FALSE and pointer to the next packet  - if not found
=====================================================*/
BOOL COutSequence::Lookup(ULONG ulSeqN, CSeqPacket **ppSeqPkt)
{
    CSeqPacket* pPkt = NULL;
    ASSERT(ppSeqPkt);

    POSITION posInList = m_listSeqUnackedPkts.GetHeadPosition();
    while (posInList != NULL)
    {
        pPkt = m_listSeqUnackedPkts.GetNext(posInList);

        if (pPkt->GetSeqN() == ulSeqN)
        {
            *ppSeqPkt = pPkt;
            return TRUE;
        }
        else if (pPkt->GetSeqN() > ulSeqN)
        {
            *ppSeqPkt = pPkt;
            return FALSE;
        }
    }

    *ppSeqPkt = NULL;
    return FALSE;
}

/*====================================================
COutSequence::Insert
    Inserts data to the hash
    Returns sequence pointer if the sequence was added
=====================================================*/
void COutSequence::Insert(CQmPacket *pPkt)
{
    ULONG ulSeqN  = pPkt->GetSeqN();
    CSeqPacket   *pSeqPkt;

    // We will need to know later whether it was empty
    BOOL fEmpty = IsEmpty();

    // Adding packet to the sequence if not exists

    Add(ulSeqN, pPkt, &pSeqPkt);


    if (OnHold() && fEmpty)
    {
        //
        //  Verify whether sequence is still on hold
        //  We can do it only for the first packet, because sequence never gets hold later
        //
        UpdateOnHoldStatus(m_listSeqUnackedPkts.GetHead()->Pkt());
    }

    if (OnHold())
    {
        //
        // Previous sequence is active. don't start timer
        //
        return;
    }

    StartResendTimer(FALSE);

    return;
}


/*====================================================
COutSequence::Delete
    Looks for the CSeqPkt by SeqN and deletes it
    Returns TRUE if found
=====================================================*/
BOOL COutSequence::Delete(ULONG ulSeqN, USHORT usClass)
{
    CSeqPacket *pPkt;
    POSITION posInList = m_listSeqUnackedPkts.GetHeadPosition();

    while (posInList != NULL)
    {
        POSITION posCurrent = posInList;
        pPkt = m_listSeqUnackedPkts.GetNext(posInList);

        if (pPkt->GetSeqN() == ulSeqN)
        {
            m_listSeqUnackedPkts.RemoveAt(posCurrent);
            pPkt->DeletePacket(usClass);
            return TRUE;
        }
        else if (pPkt->GetSeqN() > ulSeqN)
        {
            return FALSE;
        }
   }

   return FALSE;
}

/*====================================================
COutSequence::SeqAckCame
    Treats the case when an order ack came:
      - acks all relevant packets from this and previous sequences
      - AckNo > LastResent means all those resent has came,
        so we are exiting resending state and seting LastResent=INFINITY,
      - if advanced but still there are some non-acked resent packets
            - cancel current ResendTimer and schedule it for 30"
      - if advanced so that all resent packets has been acked
            - cancel current ResendTimer and schedule it immediately
              because unsent packets may have accumulated during resend state)
            - sets LastResent = INFINITE : we are not in resend state anymore
=====================================================*/
void COutSequence::SeqAckCame(ULONG ulSeqN)
{
    // Updating last time order acked was received
    m_timeLastAck = MqSysTime();

    // Keeping max ack number
    SetAckSeqN(ulSeqN);

    COutSequence *pPrev = PrevSeq();
    if (pPrev != NULL)
    {
        pPrev->SeqAckCame(INFINITE);
    }

    // Cleaning packets list
    POSITION posInList = m_listSeqUnackedPkts.GetHeadPosition();

    while (posInList != NULL)
    {
        POSITION posCurrent = posInList;
        CSeqPacket* pPkt = m_listSeqUnackedPkts.GetNext(posInList);

        if (pPkt->GetSeqN() <= AckSeqN())
        {
            // Packet is acked already
            DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
                    _TEXT("Exactly1 send: Acked pkt: SeqID=%x / %x, SeqN=%d, Prev=%d . Moving to delivered list"),
                    HighSeqID(), LowSeqID(), pPkt->GetSeqN(), pPkt->GetPrevSeqN()));

            m_listSeqUnackedPkts.RemoveAt(posCurrent);        // Remove from unacked   list
            g_OutSeqHash.KeepDelivered(pPkt);                 // Move to the delivered list
        }
        else
        {
            break;
        }
   }

   // Did we saw advance since previous order ack?
   if (Advanced())           // NB: it is the only place Advanced is called
   {
        // The sequence advanced from the previous resend time.
        // Plan next resend for 30" or now (to release accumulated pkts).

        // Now we will decide when to resend next time
        BOOL fImmediate = FALSE;

        // Do we have everything resent acked?
        if (ulSeqN >= LastResent())
        {
            DBGMSG((DBGMOD_XACT_SEND,  DBGLVL_INFO,
                    _TEXT("Exactly1 send: SeqAckCame, SeqID=%x / %x - Changing LastReSent from %d to INFINITE"),
                     HighSeqID(), LowSeqID(), LastResent()));

            // We are not in resending state anymore
            LastResent(INFINITE);

            // We may resend immediately so that all pkts that came during resend state will go out
            fImmediate = TRUE;
        }

        // Plan resend: either usually (30") or immediately (if we went out resending state)
        ClearResendIndex();
        PlanNextResend(fImmediate);

        DBGMSG((DBGMOD_XACT_SEND,
                DBGLVL_TRACE,
                _TEXT("Exactly1 send: Advanced, leaving resend state: SeqID=%x / %x - resend, immediately=%d"),
                HighSeqID(), LowSeqID(), fImmediate));
   }

   return;
}

/*====================================================
COutSequence::BadDestAckCame
    Deletes all packets up to pointed, moves them to
    delivered list and resolves them with the given class

    This is a special case because bad destination ack may come as
    random error from the FRS on the way. It does not mean order ack.
=====================================================*/
void COutSequence::BadDestAckCame(ULONG ulSeqN, USHORT usClass)
{
    // Cleaning packets list
    POSITION posInList = m_listSeqUnackedPkts.GetHeadPosition();

    while (posInList != NULL)
    {
        POSITION posCurrent = posInList;
        CSeqPacket* pPkt = m_listSeqUnackedPkts.GetNext(posInList);
        OBJECTID MsgId;
        pPkt->Pkt()->GetMessageId(&MsgId);

        if (pPkt->GetSeqN() == ulSeqN)
        {
            DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
                    _TEXT("Exactly1 send: BadDestAckCame pkt: SeqID=%x / %x, SeqN=%d, Prev=%d . Moving to delivered list"),
                    HighSeqID(), LowSeqID(), pPkt->GetSeqN(), pPkt->GetPrevSeqN()));

            m_listSeqUnackedPkts.RemoveAt(posCurrent);        // Remove from unacked   list
            g_OutSeqHash.KeepDelivered(pPkt);                 // Move to the delivered list
            g_OutSeqHash.ResolveDelivered(&MsgId, usClass);   // Resolve it as bad dest.
            //
            //  NOTE: KeepDelivered() may delete the pkt, don't use
            //        further in the code
            //
            continue;
        }

        if (pPkt->GetSeqN() >= ulSeqN)
        {
            break;
        }
   }

   return;
}

//--------------------------------------
//
// Class  COutSeqHash
//
//--------------------------------------

/*====================================================
COutSeqHash::COutSeqHash  -     Constructor
=====================================================*/
COutSeqHash::COutSeqHash()
{
    DWORD dwDef;
    ASSERT(sizeof(g_aulSeqResendCycle) / sizeof(ULONG) == 10);

    // Get resend intervals
    dwDef = FALCON_DEFAULT_ORDERED_RESEND13_TIME;
    READ_REG_DWORD(g_aulSeqResendCycle[0],
                  FALCON_ORDERED_RESEND13_REGNAME,
                  &dwDef ) ;
    g_aulSeqResendCycle[0]*= 1000;  // sec--> msec
    g_aulSeqResendCycle[1] = g_aulSeqResendCycle[0];
    g_aulSeqResendCycle[2] = g_aulSeqResendCycle[0];


    dwDef = FALCON_DEFAULT_ORDERED_RESEND46_TIME;
    READ_REG_DWORD(g_aulSeqResendCycle[3],
                  FALCON_ORDERED_RESEND46_REGNAME,
                  &dwDef ) ;
    g_aulSeqResendCycle[3]*= 1000;  // sec--> msec
    g_aulSeqResendCycle[4] = g_aulSeqResendCycle[3];
    g_aulSeqResendCycle[5] = g_aulSeqResendCycle[3];


    dwDef = FALCON_DEFAULT_ORDERED_RESEND79_TIME;
    READ_REG_DWORD(g_aulSeqResendCycle[6],
                  FALCON_ORDERED_RESEND79_REGNAME,
                  &dwDef ) ;
    g_aulSeqResendCycle[6]*= 1000;  // sec--> msec
    g_aulSeqResendCycle[7] = g_aulSeqResendCycle[6];
    g_aulSeqResendCycle[8] = g_aulSeqResendCycle[6];

    dwDef = FALCON_DEFAULT_ORDERED_RESEND10_TIME;
    READ_REG_DWORD(g_aulSeqResendCycle[9],
                  FALCON_ORDERED_RESEND10_REGNAME,
                  &dwDef ) ;
    g_aulSeqResendCycle[9]*= 1000;  // sec--> msec

    m_ulMaxTTRQ = 0;

    #ifdef _DEBUG
    // Get xact resend time
    dwDef = 0;
    ULONG  ulTime;
    READ_REG_DWORD(ulTime,
                   FALCON_DBG_RESEND_REGNAME,
                   &dwDef ) ;
    if (ulTime)
    {
        for (int i=0; i<sizeof(g_aulSeqResendCycle) / sizeof(ULONG); i++)
            g_aulSeqResendCycle[i] = ulTime * 1000;
    }
    #endif

    // Get local expiration delay default
    ULONG ulDefault = 0;
    READ_REG_DWORD(g_ulDelayExpire,
                  FALCON_XACT_DELAY_LOCAL_EXPIRE_REGNAME,
                  &ulDefault ) ;
}

/*====================================================
COutSeqHash::~COutSeqHash   -     Destructor
=====================================================*/
COutSeqHash::~COutSeqHash()
{
}

/*====================================================
COutSeqHash::LinkSequence
    Inserts new sequence into the per-SeqID  and per-direction CMAPs
=====================================================*/
void COutSeqHash::LinkSequence(
        LONGLONG liSeqID,
        CKeyDirection *pkeyDirection,
        COutSequence *pOutSeq)
{
    // Adding the sequence to the SeqID-based mapping
    m_mapOutSeqs.SetAt(liSeqID, pOutSeq);

    // Adding the sequence to the direction-based structure

    // Looking for the first sequence for a direction
    COutSequence *pExistingOutSeq;

    if (!m_mapDirections.Lookup(*pkeyDirection, pExistingOutSeq))
    {
        // This starts new direction
        m_mapDirections.SetAt(*pkeyDirection, pOutSeq);
    }
    else
    {
        // Adding the sequence to the sorted list
        COutSequence *pCur = pExistingOutSeq;
        COutSequence *pLastSmaller = NULL;
        ASSERT(pCur);

        while (pCur != NULL && pCur->SeqID() < liSeqID)
        {
            pLastSmaller = pCur;
            pCur = pCur->NextSeq();
        }

        if(pLastSmaller)
        {
            // Inserting after pLastSmaller
            pOutSeq->PrevSeq(pLastSmaller);
            pOutSeq->NextSeq(pLastSmaller->NextSeq());

            if (pLastSmaller->NextSeq())
            {
                (pLastSmaller->NextSeq())->PrevSeq(pOutSeq);
            }
            pLastSmaller->NextSeq(pOutSeq);
        }
        else
        {
            // First element was greater, so inserting as 1st element
            m_mapDirections.SetAt(*pkeyDirection, pOutSeq);

            pOutSeq->PrevSeq(NULL);
            pOutSeq->NextSeq(pExistingOutSeq);

            pExistingOutSeq->PrevSeq(pOutSeq);
        }
    }
}


/*====================================================
COutSeqHash::SeqAckCame
    Processes incoming order ack
=====================================================*/
void COutSeqHash::SeqAckCame(LONGLONG liSeqID, ULONG ulSeqN, QUEUE_FORMAT* pqf)
{
    DBGMSG((DBGMOD_XACT_SEND,
            DBGLVL_INFO,
            _TEXT("Exactly1 send: SeqAckCame: SeqID=%x / %x, SeqN=%d came"),
            HighSeqID(liSeqID), LowSeqID(liSeqID), ulSeqN));

    // Looking for existing or creating new sequence
    COutSequence *pOutSeq = ProvideSequence(liSeqID, pqf, false);
	if(pOutSeq == NULL)
		return;

    // Apply order ack to this sequence
    pOutSeq->SeqAckCame(ulSeqN);
}


/*====================================================
COutSeqHash::AckedPacket
    Treats the acked packet
=====================================================*/
void COutSeqHash::AckedPacket(LONGLONG liSeqID, ULONG ulSeqN, CQmPacket* pPkt)
{
    if (!Delete(liSeqID, ulSeqN, MQMSG_CLASS_ACK_REACH_QUEUE))
    {
        // The packet was not found in the OutSeqHash; maybe it was new
       CSeqPacket   *pSeqPkt = new CSeqPacket(pPkt);
       g_OutSeqHash.KeepDelivered(pSeqPkt);   // Move to the delivered list
    }

    DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
           _TEXT("Exactly1 send: AckedPacket:  SeqID=%x / %x, SeqN=%d pkt is acked"),
           HighSeqID(liSeqID), LowSeqID(liSeqID),  ulSeqN));
}

/*====================================================
COutSeqHash::Delete
    Deletes packet from hash

Returns TRUE if found
=====================================================*/
BOOL COutSeqHash::Delete(LONGLONG liSeqID, ULONG ulSeqN, USHORT usClass)
{
    COutSequence *pOutSeq;

    if (m_mapOutSeqs.Lookup(liSeqID, pOutSeq))
    {
        return pOutSeq->Delete(ulSeqN, usClass);
    }
    return FALSE;
}

/*====================================================
COutSeqHash::Consult
    Looks for the OutSequence by SeqID

Returns TRUE if found and pointer to the OutSeqence
=====================================================*/
BOOL COutSeqHash::Consult(LONGLONG liSeqID,  COutSequence **ppOutSeq) const
{
    COutSequence *pOutSeq;
    ASSERT(ppOutSeq);

    if (m_mapOutSeqs.Lookup(liSeqID, pOutSeq))
    {
        *ppOutSeq = pOutSeq;
        return TRUE;
    }

    *ppOutSeq = NULL;

    return FALSE;
}

/*====================================================
COutSeqHash::ProvideSequence
    Looks for the OutSequence by SeqID; if there is no, creates it
=====================================================*/
COutSequence *COutSeqHash::ProvideSequence( LONGLONG      liSeqID,
                                            QUEUE_FORMAT *pqf,
                                            bool          bInSend)
{
    COutSequence *pOutSeq;

    if (Consult(liSeqID, &pOutSeq))
    {
        return pOutSeq;
    }

	// Get queue handle
	CQueue* pQueue;
    if(!QueueMgr.LookUpQueue(pqf, &pQueue, false, bInSend))
    {
		return NULL;
    }

	HANDLE hQueue = pQueue->GetQueueHandle();
    pQueue->Release();

    // Adding new COutSequence
    pOutSeq = new COutSequence(liSeqID, pqf, hQueue);

    DBGMSG((DBGMOD_XACT_SEND,
            DBGLVL_TRACE,
            _TEXT("Exactly1 send: Creating new sequence: SeqID=%x / %x  "),
            HighSeqID(liSeqID), LowSeqID(liSeqID)));

    return pOutSeq;
}


/*====================================================
COutSeqHash::DeleteSeq
    Deletes sequence from the hash
=====================================================*/
void COutSeqHash::DeleteSeq(LONGLONG liSeqID)
{
    COutSequence *pOutSeq;

    DBGMSG((DBGMOD_XACT_SEND,
            DBGLVL_TRACE,
            _TEXT("Exactly1 send: DeleteSeq: SeqID=%x / %x . Deleting."),
            HighSeqID(liSeqID), LowSeqID(liSeqID)));

    // Nothing to do if the sequence does not exist
    if (!m_mapOutSeqs.Lookup(liSeqID, pOutSeq))
    {
        DBGMSG((DBGMOD_XACT_SEND,
                DBGLVL_TRACE,
                _TEXT("Exactly1 send: DeleteSeq: SeqID=%x / %x . Sequence not found."),
                HighSeqID(liSeqID), LowSeqID(liSeqID)));
        return;
    }

    // We should come here only with zero packets inside (because ReleaseQueue will not be called otherwise)
    ASSERT(pOutSeq->IsEmpty());

    // Exclude the sequence from the SeqID-based CMap
    m_mapOutSeqs.RemoveKey(liSeqID);

    // Delete all previous sequences
    COutSequence *pPrevSeq;
    if ((pPrevSeq = pOutSeq->PrevSeq()) != NULL)
    {
        DeleteSeq(pPrevSeq->SeqID());  //recursion
    }
    else
    {
        // It was first, Close the direction, there is nothing there.
        m_mapDirections.RemoveKey(*(pOutSeq->KeyDirection()));
    }

    // We cannot not delete sequence immediately because TreatOutSequence timer may stand on it.
    // We will delete it from there
    pOutSeq->RequestDelete();

    return;
}

/*====================================================
COutSeqHash::PreSendProcess
    Decides if to send packet

Returns TRUE if the packet should be sent
=====================================================*/

BOOL COutSeqHash::PreSendProcess(CQmPacket* pPkt,
                                 bool       bInSend)
{
    //
    // N.B. Packets may arrive here in the wrong order from the queue.
    //

    ASSERT(pPkt->IsOrdered());

    LONGLONG  liSeqID = pPkt->GetSeqID();
    ULONG     ulSeqN  = pPkt->GetSeqN(),
          ulPrevSeqN  = pPkt->GetPrevSeqN();

	DBG_USED(ulPrevSeqN);
	DBG_USED(ulSeqN);


    ASSERT(liSeqID > 0);  // The packet is ordered.

    // Serialize all outgoing hash activity on the highest level
    CS lock(g_critOutSeqHash);

    //
    // Creating new sequence,
    //    if we don't do it, PreSend on recovery will be unable to stop non-first sequences
    QUEUE_FORMAT qf;
    pPkt->GetDestinationQueue(&qf);

    COutSequence *pOutSeq = ProvideSequence(liSeqID, &qf, bInSend);
	ASSERT(pOutSeq != NULL);

    // Main bulk of processing
    BOOL fSend = pOutSeq->PreSendProcess(pPkt);

    DBGMSG((DBGMOD_XACT_SEND,
            DBGLVL_TRACE,
            _TEXT("Exactly1 send: SeqID=%x / %x, SeqN=%d, Prev=%d . %ls"),
            HighSeqID(liSeqID), LowSeqID(liSeqID), ulSeqN, ulPrevSeqN,
            (fSend ? _TEXT("Sending") : _TEXT("Bypassing"))));
    s_SendingState = fSend;

    return fSend;   // send it or not
}

/*====================================================
COutSequence::PreSendProcess
    Decides if to send packet

Returns TRUE if the packet should be sent
=====================================================*/
BOOL COutSequence::PreSendProcess(CQmPacket* pPkt)
{
    //
    // N.B. Packets may arrive here in the wrong order from the queue.
    //

    ULONG     ulSeqN  = pPkt->GetSeqN(),
          ulPrevSeqN  = pPkt->GetPrevSeqN();

    // Is the packet acked already?
    if (ulSeqN <= AckSeqN())
    {
        DBGMSG((DBGMOD_XACT_SEND,  DBGLVL_INFO,
                _TEXT("Exactly1 send: PreSendProcess: Pkt  SeqID=%x / %x, SeqN=%d, Prev=%d is acked already"),
                HighSeqID(), LowSeqID(), ulSeqN, ulPrevSeqN));

        // PostSend will treat this case
        return FALSE;  // no send
    }

    //
    // Do not send new-comer packet if the sequence is in resend state
    //    Resend state means we are resending just what we had at the moment of resend decision
    //    All new packets coming during resend state are not sent but kept.
    //
    //    Note that LastResend!=INFINITY means exactly resend state
    //
    if (ulSeqN > LastResent())
    {
        DBGMSG((DBGMOD_XACT_SEND,  DBGLVL_INFO,
            _TEXT("Exactly1 send: PreSendProcess: Pkt  SeqID=%x / %x, SeqN=%d: postponed till next resend"),
            HighSeqID(), LowSeqID(), ulSeqN));

        return FALSE;
    }

    //
    // Decide whether the sequence if on hold
    //
    if (ulPrevSeqN == 0 && m_fOnHold)
    {
        //
        //  Verify whether sequence is still on hold
        //
        UpdateOnHoldStatus(pPkt);

        DBGMSG((DBGMOD_XACT_SEND,  DBGLVL_INFO,
            _TEXT("Exactly1 send: PreSendProcess: Sequence SeqID=%x / %x : decided OnHold=%d "),
            HighSeqID(), LowSeqID(), m_fOnHold));

    }

    //
    // Now, we send exactly when sequence is not on hold
    //
    DBGMSG((DBGMOD_XACT_SEND,  DBGLVL_INFO,
        _TEXT("Exactly1 send: PreSendProcess: Pkt  SeqID=%x / %x, SeqN=%d: %ls "),
        HighSeqID(), LowSeqID(), ulSeqN,
        (m_fOnHold ? _TEXT("Holding") : _TEXT("Sending"))));

    return (!m_fOnHold);
}


/*====================================================
COutSequence::UpdateOnHoldStatus
    Verifies On Hold status
=====================================================*/
void COutSequence::UpdateOnHoldStatus(CQmPacket* pPkt)
{
    LONGLONG liAckSeqID;
    ULONG    ulAckSeqN;

    //
    //  Find last ack for the direction
    //
    GetLastAckForDirection(&liAckSeqID, &ulAckSeqN);

    //
    // Set latest acknowledgment information in the queue
    //
    ACSetSequenceAck(m_hQueue, liAckSeqID, ulAckSeqN);
    HRESULT hr = ACIsSequenceOnHold(m_hQueue, pPkt->GetPointerToDriverPacket());
    if (hr == STATUS_INSUFFICIENT_RESOURCES)
    {
        //
        // ISSUE-2000/12/20-shaik Handle ACIsSequenceOnHold failure
        //
        ASSERT(("ISSUE-2000/12/20-shaik Handle ACIsSequenceOnHold failure", 0));
        ASSERT_RELEASE(0);
    }

    m_fOnHold = SUCCEEDED(hr);
}

/*====================================================
COutSeqHash::PostSendProcess
    Inserts packet in the OutgoingSeqences hash
=====================================================*/
void COutSeqHash::PostSendProcess(CQmPacket* pPkt)
{
    //
    // N.B. Packets may NOT arrive here in the right order from the queue.
    // The order is changed if in PreSendProcess we decide not to send a
    // packet after enabling other packets to be sent.
    // The packets that are send arrive here only after session acknowledgment,
    // but those that are not arrive here immediately.
    //

    ASSERT(pPkt->IsOrdered());
    ASSERT(QmpIsLocalMachine(pPkt->GetSrcQMGuid()));

    LONGLONG  liSeqID = pPkt->GetSeqID();
    ULONG     ulSeqN  = pPkt->GetSeqN(),
    ulPrevSeqN  = pPkt->GetPrevSeqN();
	UNREFERENCED_PARAMETER(ulPrevSeqN);
	UNREFERENCED_PARAMETER(ulSeqN);


    // Serialize all outgoing hash activity on the highest level
    CS lock(g_critOutSeqHash);

    // Find the sequence 0 it should exist because PreSend worked already
    COutSequence *pOutSeq;
    BOOL fSequenceExist  = Consult(liSeqID, &pOutSeq);
    ASSERT(fSequenceExist);
    ASSERT(pOutSeq);
	DBG_USED(fSequenceExist);

    // Main bulk of processing
    pOutSeq->PostSendProcess(pPkt, m_ulMaxTTRQ);

    return;
}

/*====================================================
COutSequence::PostSendProcess
    Inserts packet in the OutgoingSeqences hash
=====================================================*/
void COutSequence::PostSendProcess(CQmPacket* pPkt, ULONG ulMaxTTRQ)
{
    LONGLONG  liSeqID = pPkt->GetSeqID();
    ULONG     ulSeqN  = pPkt->GetSeqN(),
          ulPrevSeqN  = pPkt->GetPrevSeqN();

	DBG_USED(ulPrevSeqN);

    //
    // Is the packet acked already?
    //
    if (ulSeqN <= AckSeqN())
    {
        DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
               _TEXT("Exactly1 send: PostSendProcess: Pkt SeqID=%x / %x, SeqN=%d, Prev=%d is acked"),
               HighSeqID(), LowSeqID(), ulSeqN, ulPrevSeqN));

        g_OutSeqHash.AckedPacket(liSeqID, ulSeqN, pPkt);
        return;
    }

    //
    // Catch possibly timed out packet (we want it in XactDeadLetteQueue now and not after 6 hrs)
    //
    CBaseHeader* pcBaseHeader = (CBaseHeader *)(pPkt->GetPointerToPacket());
    if (pcBaseHeader->GetAbsoluteTimeToQueue() < ulMaxTTRQ)
    {
        DBGMSG((DBGMOD_XACT_SEND,  DBGLVL_INFO,
            _TEXT("Exactly1 send: PostSendProcess: Pkt  SeqID=%x / %x, SeqN=%d: pkt timed out, requeued"),
            HighSeqID(), LowSeqID(), ulSeqN));

        // Requeue it back, don't remember
        HRESULT hr = ACPutPacket(m_hQueue, pPkt->GetPointerToDriverPacket());
        if (SUCCEEDED(hr))
        {
            return;
        }
        LogHR(hr, s_FN, 133);
    }

    //
    // Keeping packet in the Sequence for resends.
    //
    Insert(pPkt);

    DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
            _TEXT("Exactly1 send: PostSendProcess: SeqID=%x / %x, SeqN=%d, Prev=%d . Remembering pkt"),
            HighSeqID(), LowSeqID(), ulSeqN, ulPrevSeqN));
    return;
}

/*====================================================
COutSeqHash::NonSendProcess
    Treats the case when the packet was not sent at all
    (e.g., destination machine does not support encryption)
=====================================================*/
void COutSeqHash::NonSendProcess(CQmPacket* pPkt, USHORT usClass)
{
    // Serialize all outgoing hash activity on the highest level
    CS lock(g_critOutSeqHash);

    ASSERT(pPkt->IsOrdered());
    ASSERT(QmpIsLocalMachine(pPkt->GetSrcQMGuid()));

    LONGLONG  liSeqID = pPkt->GetSeqID();
    ULONG     ulSeqN  = pPkt->GetSeqN(),
          ulPrevSeqN  = pPkt->GetPrevSeqN();

	DBG_USED(ulPrevSeqN);

    COutSequence *pOutSeq;
    BOOL fSequenceExist  = Consult(liSeqID, &pOutSeq);
    ASSERT(fSequenceExist);
	DBG_USED(fSequenceExist);

    if (!Delete(liSeqID, ulSeqN, usClass))
    {
        // The packet was not found in the OutSeqHash; maybe it was new
        // ;;; nack...
        HRESULT hr = ACFreePacket(g_hAc, pPkt->GetPointerToDriverPacket(), usClass);
		DBG_USED(hr);
        ASSERT(SUCCEEDED(hr));

        delete pPkt;
    }


    DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
           _TEXT("Exactly1 send: NonSendProcess: Pkt  SeqID=%x / %x, SeqN=%d, Prev=%d, class=%x"),
           HighSeqID(liSeqID), LowSeqID(liSeqID), ulSeqN, ulPrevSeqN, usClass));
    return;
}

/*====================================================
TimeToResendOutSequence
    Scheduled periodically to treat outgoing sequence
    Checks for the timed out, acked packets and kills them;
    Resends packets
=====================================================*/
void WINAPI COutSequence::TimeToResendOutSequence(CTimer* pTimer)
{

    // Serializing all outgoing hash activity on the highest level
    CS lock(g_critOutSeqHash);

    COutSequence* pOutSeq = CONTAINING_RECORD(pTimer, COutSequence, m_ResendTimer);
    pOutSeq->TreatOutSequence();
}

/*====================================================
COutSequence::TreatOutSequence
    Cleans all timed out packets from the sequence
=====================================================*/
void COutSequence::TreatOutSequence()
{
    DBGMSG((DBGMOD_XACT_SEND, DBGLVL_TRACE,
            _TEXT("Exactly1 send: TreatOutSequence SeqID=%x / %x "),
            HighSeqID(), LowSeqID()));

    // We entered into the timer routine, so there is no other timer
    ASSERT(m_fResendScheduled);
    m_fResendScheduled = FALSE;


    // If there was a delete request, delete this sequence
    if (m_fMarkedForDelete)
    {
        // This is the only place where we delete the sequence (via planning next treatment)
        // It is important to avoid races between deleting thread and other ones
        delete this;
        return;
    }

    // Is the sequence empty?
    if (m_listSeqUnackedPkts.IsEmpty())
    {
        DBGMSG((DBGMOD_XACT_SEND, DBGLVL_WARNING,
                _TEXT("Exactly1 send: Resend sequence: SeqID=%x / %x  Empty, no more periods"),
                HighSeqID(), LowSeqID()));

        // Don't plan next resend, no need;  we are not in resend state
        DBGMSG((DBGMOD_XACT_SEND,  DBGLVL_INFO,
                _TEXT("Exactly1 send: TreatOutSequence: Changing LastReSent from %d to INFINITE"),
                 LastResent()));

        LastResent(INFINITE);

        for(COutSequence* pNext = this; (pNext = pNext->NextSeq()) != 0; )
        {
            if(pNext->OnHold())
            {
                pNext->ResendSequence();
            }
        }
    }

    // The sequence did not advance. Resending.
    else
    {
        DBGMSG((DBGMOD_XACT_SEND, DBGLVL_WARNING,
                _TEXT("Exactly1 send: Resend sequence: SeqID=%x / %x  Phase=%d"),
                HighSeqID(), LowSeqID(),
                ResendIndex()));

        // Resend all packets
        ResendSequence();

        // plan next resend
        if(!OnHold())
        {
            PlanNextResend(FALSE);
        }
    }
}


/*====================================================
COutSequence::ResendSequence
    Applies the given routine to all packets in the sequence
=====================================================*/
void COutSequence::ResendSequence()
{

    POSITION posInList = m_listSeqUnackedPkts.GetHeadPosition();
    while (posInList != NULL)
    {
        POSITION posCurrent = posInList;
        CSeqPacket* pSeqPkt = m_listSeqUnackedPkts.GetNext(posInList);

        // Resend the packet
        if (!ResendSeqPkt(pSeqPkt))
            return;

        // Normal case
        DBGMSG((DBGMOD_XACT_SEND,  DBGLVL_INFO,
                _TEXT("Exactly1 send: ResendSequence, SeqID=%x / %x -  Changing LastReSent from %d to %d"),
                 HighSeqID(), LowSeqID(), LastResent(), pSeqPkt->GetSeqN()));

        LastResent(pSeqPkt->GetSeqN());

        // Delete the packet, we don't need it in OutHash
        m_listSeqUnackedPkts.RemoveAt(posCurrent);
        delete pSeqPkt;
    }
}

/*====================================================
COutSequence::ResendSeqPkt
    Resend the given packet
    Returns TRUE if the packet was sent
=====================================================*/
BOOL COutSequence::ResendSeqPkt(CSeqPacket *pSeqPkt)
{
    LONGLONG  liSeqID    = pSeqPkt->GetSeqID();
    ULONG     ulSeqN     = pSeqPkt->GetSeqN();
    ULONG     ulPrevSeqN = pSeqPkt->GetPrevSeqN();
    CQmPacket *pPkt      = pSeqPkt->Pkt();
    BOOL      fSent      = FALSE;

	UNREFERENCED_PARAMETER(ulSeqN);
	UNREFERENCED_PARAMETER(liSeqID);
	UNREFERENCED_PARAMETER(ulPrevSeqN);


    if (pPkt->ConnectorQMIncluded() && QmpIsLocalMachine(pPkt->GetConnectorQM()))
    {
        //
        // If the source machine is the connector machine we don't resend the message.
        // In such a case the message is already on the connector queue and the reason
        // it doesn't ACK is only because the Connector application doesn't commit yet.
        //
        DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
                _TEXT("Exactly1 send: No Resend packet SeqID=%x / %x, SeqN=%d, Prev=%d (deliver to Connector) "),
                pSeqPkt->GetHighSeqID(), pSeqPkt->GetLowSeqID(), pSeqPkt->GetSeqN(), pSeqPkt->GetPrevSeqN()));
    }
    else
    {
        DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
                _TEXT("Exactly1 send: ResendSeqPkt: SeqID=%x / %x, SeqN=%d, Prev=%d packet"),
                pSeqPkt->GetHighSeqID(), pSeqPkt->GetLowSeqID(), pSeqPkt->GetSeqN(), pSeqPkt->GetPrevSeqN()));

        // Requeue packet to the driver
        HRESULT hr = ACPutPacket(m_hQueue, pPkt->GetPointerToDriverPacket());
        if (SUCCEEDED(hr))
        {
            fSent = TRUE;
        }
        else
        {
            LogHR(hr, s_FN, 134);
            DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
                    _TEXT("Exactly1 send: ResendSeqPkt failed, hr=%x, SeqN=%x "),
                    hr, pSeqPkt->GetSeqN()));
        }
    }

    return fSent;
}

/*====================================================
COutSequence::StartResendTimer
    Schedules next resend for the sequence,  if it was not done
=====================================================*/
void COutSequence::StartResendTimer(BOOL fImmediate)
{
    if (!m_fResendScheduled)
    {
        ClearResendIndex();
        PlanNextResend(fImmediate);

        DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
            _TEXT("Exactly1 send StartResendTimer:  SeqID=%x / %x, planning resend"),
            HighSeqID(), LowSeqID()));
    }
}


/*====================================================
COutSequence::PlanNextResend
    Schedules next resend for the sequence
=====================================================*/
void COutSequence::PlanNextResend(BOOL fImmediate)
{
    ULONG len = sizeof(g_aulSeqResendCycle) / sizeof(ULONG);
    ULONG ind = m_ulResendCycleIndex++;
    ind = (ind >= len ? len-1 : ind);
    ULONG ulNextTime = (fImmediate? 1000 : g_aulSeqResendCycle[ind]);

    // Killing potential extra timer

    if (!m_fResendScheduled || ExCancelTimer(&m_ResendTimer))
    {
        ExSetTimer(&m_ResendTimer, CTimeDuration::FromMilliSeconds(ulNextTime));
        m_fResendScheduled = TRUE;
        m_NextResendTime   = MqSysTime() + (ulNextTime/1000);
    }
}


/*====================================================
COutSequence::RequestDelete
    Schedules next resend for the sequence
=====================================================*/
void COutSequence::RequestDelete()
{
    m_fMarkedForDelete = TRUE;
    PlanNextResend(TRUE);
}

/*====================================================
COutSequence::GetLastAckForDirection
    Finds out the last ack for the whole direction
    It happens to be the ackN from the last acked sequence
=====================================================*/
void COutSequence::GetLastAckForDirection(
           LONGLONG *pliAckSeqID,
           ULONG *pulAckSeqN)
{
    // First, go to the last sequence in the direction
    COutSequence *pSeq = this, *p1;

    while ((p1 = pSeq->NextSeq()) != NULL)
    {
        pSeq = p1;
    }

    // Go back to the first (from the end) sequence with non-zero LastAck data
    while (pSeq)
    {
        if (pSeq->AckSeqN() != 0)
        {
            *pliAckSeqID = pSeq->SeqID();
            *pulAckSeqN  = pSeq->AckSeqN();
            return;
        }

        pSeq = pSeq->PrevSeq();
    }

    *pliAckSeqID = 0;
    *pulAckSeqN  = 0;
    return;
}

/*====================================================
COutSeqHash::KeepDelivered
    Adds the delivered CSeqPacket to the list of waiting for
        the final resolution
    No duplicates allowed (otherwise return FALSE)
=====================================================*/
void COutSeqHash::KeepDelivered(CSeqPacket *pSeqPkt)
{
    CS lock(g_critOutSeqHash);
    CQmPacket *pQmPkt = pSeqPkt->Pkt();

    // Mark the fact that the packet was delivered
    pSeqPkt->SetClass(MQMSG_CLASS_ACK_REACH_QUEUE);

    OBJECTID MsgId;
    USHORT   usClass;
    CSeqPacket *pSeq;

    pQmPkt->GetMessageId(&MsgId);
    ASSERT(QmpIsLocalMachine(&MsgId.Lineage));

    {
        // Do we know the final resolution already?
        if (m_mapAckValue.Lookup(MsgId.Uniquifier, usClass))
        {
            DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
                    _TEXT("Exactly1 send: KeepDelivered: Pkt SeqID=%x / %x, SeqN=%d, Acked %x Got order ack, freed"),
                     HighSeqID(pSeqPkt->GetSeqID()), LowSeqID(pSeqPkt->GetSeqID()), pSeqPkt->GetSeqN(), usClass));

            //
            //  Mark the message with the received ack
            //
            pSeqPkt->SetClass(usClass);

            BOOL f = m_mapAckValue.RemoveKey(MsgId.Uniquifier);
            ASSERT(f);
			DBG_USED(f);

            // Free packet
            HRESULT hr = pSeqPkt->AcFreePacket();
            ASSERT(SUCCEEDED(hr));
			DBG_USED(hr);

            delete pSeqPkt;
        }
        else if (!m_mapWaitAck.Lookup(MsgId.Uniquifier,pSeq))
        {
            // Is follow-up canceled?
            if (pQmPkt->GetCancelFollowUp())
            {
                DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
                        _TEXT("Exactly1 send: KeepDelivered: Pkt SeqID=%x / %x, SeqN=%d delivered and freed"),
                         HighSeqID(pSeqPkt->GetSeqID()), LowSeqID(pSeqPkt->GetSeqID()), pSeqPkt->GetSeqN()));

                // Free packet, no follow-up
                HRESULT hr = pSeqPkt->AcFreePacket();
                ASSERT(SUCCEEDED(hr));
				DBG_USED(hr);

                delete pSeqPkt;
            }

            else
            {
                DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
                        _TEXT("Exactly1 send: KeepDelivered: Pkt SeqID=%x / %x, SeqN=%d delivered and kept"),
                         HighSeqID(pSeqPkt->GetSeqID()), LowSeqID(pSeqPkt->GetSeqID()), pSeqPkt->GetSeqN()));

                // Inserting packet into the delivered map for follow-up
                m_mapWaitAck[MsgId.Uniquifier] = pSeqPkt;
            }
        }
    }
}


/*====================================================
COutSeqHash::LookupDelivered
    looks for the delivered CSeqPacket in the list of waiting for
        the final resolution, sets the class and frees the packet
=====================================================*/
BOOL COutSeqHash::LookupDelivered(OBJECTID   *pMsgId,
                                  CSeqPacket **ppSeqPkt)
{
    CSeqPacket *pSeqPkt;

    BOOL f = m_mapWaitAck.Lookup(pMsgId->Uniquifier, pSeqPkt);

    if (f && ppSeqPkt)
    {
        *ppSeqPkt = pSeqPkt;
    }

    return f;
}

/*====================================================
COutSeqHash::ResolveDelivered
    looks for the delivered CSeqPacket in the list of waiting for
        the final resolution, sets the class and frees the packet
=====================================================*/
void COutSeqHash::ResolveDelivered(OBJECTID* pMsgId,
                                   USHORT    usClass)
{
    ASSERT(MQCLASS_NACK(usClass) || (usClass == MQMSG_CLASS_ACK_RECEIVE));

    // Serializing all outgoing hash activity on the highest level
    CS lock(g_critOutSeqHash);
    CSeqPacket *pSeqPkt;

    // Is the packet waiting already in the delivered list?
    if (m_mapWaitAck.Lookup(pMsgId->Uniquifier, pSeqPkt))
    {
        // Remove the packet from delivered map
        m_mapWaitAck.RemoveKey(pMsgId->Uniquifier);

        // Delete packet with Ack/NAck and AcFreePacket if needed
        pSeqPkt->DeletePacket(usClass);

        DBGMSG((DBGMOD_XACT_SEND,
                DBGLVL_INFO,
                _TEXT("Exactly1 send:ResolveDelivered: Msg Id = %d, Ack Value = %x got ack"),pMsgId->Uniquifier, usClass));
    }
    else
    {
        USHORT usValue;
        if(!m_mapAckValue.Lookup(pMsgId->Uniquifier, usValue))
        {
            //
            //  Save the acknowledgment only if we don't know it yet, otherwise
            //  keep the first one that arrived.
            //
            m_mapAckValue[pMsgId->Uniquifier] = usClass;
        }
    }
}


/*====================================================
SeqPktTimedOut
    Called from driver handle routine at packet time-out
=====================================================*/
void SeqPktTimedOut(CBaseHeader * pPktBaseHdr, CPacket *  pDriverPacket, BOOL fTimeToBeReceived)
{
    HRESULT hr;
    OBJECTID MsgId;
    CQmPacket Pkt(pPktBaseHdr, pDriverPacket);
    Pkt.GetMessageId(&MsgId);

    if (fTimeToBeReceived)
    {
        // TTBR
        DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
           _TEXT("Exactly1 send: TTBR TimeOut: Pkt SeqID=%x / %x, SeqN=%d"),
           HighSeqID(Pkt.GetSeqID()), LowSeqID(Pkt.GetSeqID()), Pkt.GetSeqN()));

        USHORT usClass = MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER;

        g_OutSeqHash.ResolveDelivered(&MsgId, usClass);

        hr = ACFreePacket1(g_hAc, pDriverPacket, usClass);
        ASSERT(SUCCEEDED(hr));
    }
    else
    {
        // TTRQ
        DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
           _TEXT("Exactly1 send: TTRQ TimeOut: Pkt SeqID=%x / %x, SeqN=%d"),
           HighSeqID(Pkt.GetSeqID()), LowSeqID(Pkt.GetSeqID()), Pkt.GetSeqN()));

        if (g_OutSeqHash.LookupDelivered(&MsgId, NULL))
        {
            // Packet is in delivered list already, we must ONLY arm the TTBR timer

            // Calculate additional delay for TTBR as min of specified TTRQ,TTBR
            //  or take it from registry if it has been specified there
            ULONG ulDelay = 0;
            if (g_ulDelayExpire != 0)
            {
                ulDelay = g_ulDelayExpire;
            }
            else
            {
                CBaseHeader* pBase = (CBaseHeader *)pPktBaseHdr;
                CUserHeader* pUser = (CUserHeader*) pBase->GetNextSection();

                if (pBase->GetAbsoluteTimeToQueue() > pUser->GetSentTime())
                {
                    ulDelay = pBase->GetAbsoluteTimeToQueue() - pUser->GetSentTime();
                }
            }

            hr = ACArmPacketTimer(g_hAc, pDriverPacket, TRUE, ulDelay);
            LogHR(hr, s_FN, 129);
            if (FAILED(hr))
            {
                //
                // ISSUE-2000/12/20-shaik Handle ACArmPacketTimer failure
                //
                ASSERT(("ISSUE-2000/12/20-shaik Handle ACArmPacketTimer failure", 0));
                ASSERT_RELEASE(0);
            }
        }
        else
        {
            // The packet is not delivered yet

            // Process TTRQ
            g_OutSeqHash.SeqPktTimedOutEx(&Pkt, pPktBaseHdr);

            // Release reference counter
            hr = ACFreePacket1(g_hAc, pDriverPacket, MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT);
            ASSERT(SUCCEEDED(hr));
            LogHR(hr, s_FN, 131);
        }
    }
}


/*====================================================
COutSeqHash::SeqPktTimedOutEx
    Called from driver handle routine at packet TTRQ time-out
=====================================================*/
void COutSeqHash::SeqPktTimedOutEx(CQmPacket *pPkt, CBaseHeader* pPktBaseHdr)
{
    // Serializing all outgoing hash activity on the highest level
    // Entering MsgId into the Recently Timed Out Cache (to prevent sending)

    CS lock(g_critOutSeqHash);

    LONGLONG  liSeqID    = pPkt->GetSeqID();
    ULONG     ulSeqN     = pPkt->GetSeqN();
    ULONG     ulPrevSeqN = pPkt->GetPrevSeqN();
	UNREFERENCED_PARAMETER(ulPrevSeqN);

    DBGMSG((DBGMOD_XACT_SEND, DBGLVL_INFO,
           _TEXT("Exactly1 send: TTRQ TimeOut: Pkt  SeqID=%x / %x, SeqN=%d"),
           HighSeqID(pPkt->GetSeqID()), LowSeqID(pPkt->GetSeqID()), ulSeqN));

    // Remember last shot TTRQ we learned from the driver
    m_ulMaxTTRQ = pPktBaseHdr->GetAbsoluteTimeToQueue();

    // Looking for the Seq packet among outgoing sequences
    COutSequence *pOutSeq;
    Consult(liSeqID, &pOutSeq);

    // Remove pkt from the sequence, generate NACK
    if (pOutSeq && pOutSeq->Delete(ulSeqN, MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT))
        return;

    // The packet was not found in the OutSeqHash; maybe it was new

    //  Send negative acknowledgment
    UCHAR AckType =  pPkt->GetAckType();
    if(MQCLASS_MATCH_ACKNOWLEDGMENT(MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT, AckType))
    {
        pPkt->CreateAck(MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT);
    }
}

static
BOOL
WINAPI ReceiveOrderCommandsInternal(
    CMessageProperty* pmp,
    QUEUE_FORMAT* pqf
	)
{
	if (!pmp->bConnector && (pmp->dwBodySize == sizeof(OrderAckData)))
    {
        // This ack comes from Falcon QM, not from Connector application
        if (pmp->wClass == MQMSG_CLASS_NACK_BAD_DST_Q)
        {
            //
            // Bad Destination or Queue Deleted Ack
            //    may be temporary: the queue may be created/published later
            // We kill it and insert into the holes list
            //

            //
            // Need comments.
            // MQMSG_CLASS_NACK_BAD_DST_Q may arrive not from our intended destiantion machine
            // thus this does not mean that all previous packets are delivered. so DON'T handle
            // this as an Order ACK.
            //
            OrderAckData*  pOrderData = (OrderAckData*)pmp->pBody;

            DBGMSG((DBGMOD_XACT_SEND,
                    DBGLVL_TRACE,
                    _TEXT("Exactly1 send: Order Ack came: SeqID=%x / %x, SeqN=%d, Class=%x "),
                            HighSeqID(pOrderData->m_liSeqID), LowSeqID(pOrderData->m_liSeqID),
                            pOrderData->m_ulSeqN, pmp->wClass));

            // We want to move this specific outgoing msg to resolved/bad_dest.
            COutSequence *pOutSeq;
            if (g_OutSeqHash.Consult(pOrderData->m_liSeqID, &pOutSeq))
            {
                pOutSeq->BadDestAckCame(pOrderData->m_ulSeqN, pmp->wClass);
            }
        }

        if (pmp->wClass == MQMSG_CLASS_ORDER_ACK ||
            pmp->wClass == MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q ||
            pmp->wClass == MQMSG_CLASS_NACK_Q_DELETED)
        {
            //
            // These acks signal that the message reached queue and had right seq n
            // Move this and all preceding msgs from outgoing Q to delivered list
            //
            OrderAckData*  pOrderData = (OrderAckData*)pmp->pBody;

            DBGMSG((DBGMOD_XACT_SEND,
                    DBGLVL_TRACE,
                    _TEXT("Exactly1 send: Order Ack came: SeqID=%x / %x, SeqN=%d, Class=%x "),
                            HighSeqID(pOrderData->m_liSeqID), LowSeqID(pOrderData->m_liSeqID), pOrderData->m_ulSeqN, pmp->wClass));

            g_OutSeqHash.SeqAckCame(pOrderData->m_liSeqID,
                                    pOrderData->m_ulSeqN,
                                    pqf);
        }
    }
    else
    {
        DBGMSG((DBGMOD_XACT_SEND,
                DBGLVL_TRACE,
                _TEXT("Exactly1 send: Non-order Ack came: Class=%x "), pmp->wClass));
    }


    if (pmp->wClass != MQMSG_CLASS_ORDER_ACK)
    {
        // All acks except seq mean final resolution
        g_OutSeqHash.ResolveDelivered((OBJECTID*)pmp->pCorrelationID, pmp->wClass);
    }

    return TRUE;
}



/*====================================================
ReceiveOrderCommands: called for each coming Seq Ack
====================================================*/
BOOL WINAPI ReceiveOrderCommands(
    CMessageProperty* pmp,
    QUEUE_FORMAT* pqf)
{
    CS lock(g_critOutSeqHash);  // Serializes all outgoing hash activity on the highest level
    ASSERT(pmp);

	//
	// SRMP order ack - we put order information in the body and continute
	// as in none srmp
	//
	OrderAckData  OrderData;

	if(pmp->pEodAckStreamId != NULL)
	{
		ASSERT(pmp->dwBodySize == 0);
		ASSERT(pmp->dwAllocBodySize == 0);
		ASSERT(FnIsDirectHttpFormatName(pqf));

	
		OrderData.m_liSeqID = pmp->EodAckSeqId;
		OrderData.m_ulSeqN = numeric_cast<ULONG>(pmp->EodAckSeqNum);
		pmp->pBody = (UCHAR*)&OrderData;
		pmp->dwBodySize = sizeof(OrderData);
	}
	else
	{
		ASSERT(!FnIsDirectHttpFormatName(pqf));
	}
	//
	// None SRMP order ack
	//
	return ReceiveOrderCommandsInternal(pmp, pqf);
}

/*====================================================
GetOrderQueueFormat
    Provides order queue format name
=====================================================*/
STATIC HRESULT GetOrderQueueFormat(QUEUE_FORMAT * pQueueFormat)
{
    HRESULT rc;
    WCHAR wsz[256];

    wcscpy(wsz,g_szMachineName);                  // machine name
    wcscat(wsz, FN_PRIVATE_SEPERATOR);            // '\'
    wcscat(wsz, PRIVATE_QUEUE_PATH_INDICATIOR);   //  'private$\'
    wcscat(wsz, ORDERING_QUEUE_NAME);             //'ORDER_QUEUE$'

    // Building queue format
    rc = g_QPrivate.QMPrivateQueuePathToQueueFormat(wsz, pQueueFormat);

    if (FAILED(rc))
    {
        LogHR(rc, s_FN, 30);        // The ORDER_QUEUE doesn't exist
        return MQ_ERROR;
    }

    ASSERT((pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
           (pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT));

    return(MQ_OK);
}

/*====================================================
QMInitOrderQueue
    Initializes continuous reading from the Ordering Queue
=====================================================*/
HRESULT QMInitOrderQueue()
{
    QUEUE_FORMAT QueueFormat;

    DBGMSG((DBGMOD_QM,DBGLVL_INFO,TEXT("Entering CResourceManager::InitOrderQueue")));

    HRESULT hr = GetOrderQueueFormat( &QueueFormat);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_QM,DBGLVL_ERROR,TEXT("ERROR : CResourceManager::InitOrderQueue -> couldn't get Ordering Queue from registry!!!")));
        return LogHR(hr, s_FN, 40);
    }

    return LogHR(QmpOpenAppsReceiveQueue(&QueueFormat,ReceiveOrderCommands), s_FN, 1321);
}

/*====================================================
AbsorbCommitFailure
    Called in order to keep data about a hole in numeration
=====================================================*/
void AbsorbCommitFailure(LONGLONG liSeqID, ULONG ulSeqN, ULONG ulPrevSeqN)
{
}


HRESULT
COutSeqHash::GetLastAck(
     LONGLONG liSeqID,
     ULONG& ulSeqN
     ) const
{
    //
    // Serialize all outgoing hash activity on the highest level
    //
    CS lock(g_critOutSeqHash);

    COutSequence *pOutSeq;
    BOOL fSequenceExist  = Consult(liSeqID, &pOutSeq);
    if (!fSequenceExist)
    {
        return LogHR(MQ_ERROR, s_FN, 50);
    }

    ulSeqN = pOutSeq->AckSeqN();

    return MQ_OK;


}

HRESULT
COutSequence::GetUnackedSequence(
    LONGLONG* pliSeqID,
    ULONG* pulSeqN,
    ULONG* pulPrevSeqN,
    BOOL fFirst
    ) const
{
    if (m_listSeqUnackedPkts.IsEmpty())
    {
        *pliSeqID = 0;
        *pulSeqN = 0;
        *pulPrevSeqN = 0;
        return LogHR(MQ_ERROR, s_FN, 60);
    }

    CSeqPacket* pSeqPacket;
    if (fFirst)
    {
        pSeqPacket = m_listSeqUnackedPkts.GetHead();
    }
    else
    {
        pSeqPacket = m_listSeqUnackedPkts.GetTail();
    }

    *pliSeqID = pSeqPacket->GetSeqID();
    *pulSeqN = pSeqPacket->GetSeqN();
    *pulPrevSeqN = pSeqPacket->GetPrevSeqN();

    return MQ_OK;
}


DWORD
COutSequence::GetResendInterval(
    void
    )const
{
    ULONG len = sizeof(g_aulSeqResendCycle) / sizeof(ULONG);
    ULONG ind = ResendIndex();
    ind = (ind >= len ? len-1 : ind);

    return g_aulSeqResendCycle[ind];
}


HRESULT
COutSeqHash::GetUnackedSequence(
    LONGLONG liSeqID,
    ULONG* pulSeqN,
    ULONG* pulPrevSeqN,
    BOOL fFirst
    ) const
{
    //
    // Serialize all outgoing hash activity on the highest level
    //
    CS lock(g_critOutSeqHash);

    COutSequence* pOutSeq;
    BOOL fSequenceExist  = Consult(liSeqID, &pOutSeq);
    if (!fSequenceExist)
    {
        return LogHR(MQ_ERROR, s_FN, 70);
    }

    LONGLONG tempSeqId;
    HRESULT hr;
    hr = pOutSeq->GetUnackedSequence(&tempSeqId, pulSeqN, pulPrevSeqN, fFirst);
    ASSERT(FAILED(hr) || (tempSeqId == liSeqID));

    return MQ_OK;
}


DWORD_PTR
COutSeqHash::GetOutSequenceInfo(
    LONGLONG liSeqID,
    INFO_TYPE InfoType
    ) const
{
    //
    // Serialize all outgoing hash activity on the highest level
    //
    CS lock(g_critOutSeqHash);

    //
    // Look for the out sequence in the internal data structure. If not found return 0
    //
    COutSequence* pOutSeq;
    BOOL fSequenceExist  = Consult(liSeqID, &pOutSeq);
    if (!fSequenceExist)
    {
        return 0;
    }

    switch (InfoType)
    {
        case eUnackedCount:
            return pOutSeq->GetUnackedCount();

        case eLastAckTime:
            return pOutSeq->GetLastAckedTime();

        case eLastAckCount:
            return pOutSeq->GetLastAckCount();

        case eResendInterval:
            return pOutSeq->GetResendInterval();

        case eResendTime:
            return pOutSeq->GetNextResendTime();

        case eResendIndex:
            return pOutSeq->ResendIndex();

        default:
            ASSERT(0);
            return 0;
    }

}


DWORD
COutSeqHash::GetAckedNoReadCount(
    LONGLONG liSeqID
    ) const
{
    //
    // Serialize all outgoing hash activity on the highest level
    //
    CS lock(g_critOutSeqHash);

    DWORD count = 0;
    POSITION pos = m_mapWaitAck.GetStartPosition();
    while(pos)
    {
        CSeqPacket* pSeqPacket;
        DWORD Id;
        m_mapWaitAck.GetNextAssoc(pos, Id, pSeqPacket);
        if (pSeqPacket->GetSeqID() == liSeqID)
        {
            ++count;
        }
    }

    return count;
}


void
COutSeqHash::AdminResend(
    LONGLONG liSeqID
    ) const
{
    //
    // Serialize all outgoing hash activity on the highest level
    //
    CS lock(g_critOutSeqHash);

    //
    // Look for the out sequence in the internal data structure. If not found return 0
    //
    COutSequence* pOutSeq;
    BOOL fSequenceExist  = Consult(liSeqID, &pOutSeq);
    if (!fSequenceExist)
    {
        return;
    }

    pOutSeq->AdminResend();
}


void
COutSequence::AdminResend(
    void
    )
{
    DBGMSG((DBGMOD_XACT_SEND,
            DBGLVL_WARNING,
            _TEXT("Exactly1 send: Admin Resend sequence: SeqID=%x / %x"),
                   HighSeqID(), LowSeqID()));

    //
    // Resend all packets
    //
    PlanNextResend(TRUE);
}

//--------------------------------------
//
// Class  CKeyDirection
//
//--------------------------------------
CKeyDirection::CKeyDirection(const QUEUE_FORMAT *pqf)
{
    CopyQueueFormat(*this, *pqf);
}

CKeyDirection::CKeyDirection()
{
}

CKeyDirection::CKeyDirection(const CKeyDirection &key)
{
    CopyQueueFormat(*this, key);
}

CKeyDirection::~CKeyDirection()
{
    DisposeString();
}

/*====================================================
HashKey for CKeyDirection CMap
    Makes ^ of subsequent double words
=====================================================*/
UINT AFXAPI HashKey(const CKeyDirection& key)
{
    DWORD dw2, dw3 = 0, dw4 = 0;

    dw2 = key.GetType();

    switch(key.GetType())
    {
        case QUEUE_FORMAT_TYPE_UNKNOWN:
            break;

        case QUEUE_FORMAT_TYPE_PUBLIC:
            dw3 = HashGUID(key.PublicID());
            break;

        case QUEUE_FORMAT_TYPE_PRIVATE:
            dw3 = HashGUID(key.PrivateID().Lineage);
            dw4 = key.PrivateID().Uniquifier;
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            dw3 = HashKey(key.DirectID());
            break;

        case QUEUE_FORMAT_TYPE_MACHINE:
            dw3 = HashGUID(key.MachineID());
            break;
    }

    return dw2 ^ dw3 ^ dw4;
}

CKeyDirection &CKeyDirection::operator=(const CKeyDirection &key2 )
{
    CopyQueueFormat(*this, key2);
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactping.h ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactPing.h

Abstract:
    Persistency classes for ping-pong scheme:
        CPersist
		CPersistPing

Author:
    AlexDad

--*/

#ifndef __XACTPING_H__
#define __XACTPING_H__

#include "xactstyl.h"

enum TypePreInit {
  piNoData,
  piOldData,
  piNewData
};

//---------------------------------------------------------------------
//
// class CPersist: base class for every ping-pong-persistent class
//
//---------------------------------------------------------------------
class CPersist
{
public:
	CPersist::CPersist()  {};
	CPersist::~CPersist() {};

    virtual HRESULT  SaveInFile(                            // Saves in file
                                LPWSTR wszFileName,         //   Filename
                                ULONG ind,                  //   Index (0 or 1)
								BOOL fCheck) = 0;           //   TRUE in checking pass

    virtual HRESULT  LoadFromFile(LPWSTR wszFileName) = 0;  // Loads from file
                                  
 
    virtual BOOL     Check() = 0;                           // Verifies the state and returns ping no

    virtual HRESULT  Format(ULONG ulPingNo) = 0;            // Formats empty instance

    virtual void     Destroy() = 0;                         // Destroys all allocated data

    virtual ULONG&   PingNo() = 0;                          // Gives access to ulPingNo
};


//---------------------------------------------------------------------
//
// class CPersistPing : implements ping-pong functionality
//
//---------------------------------------------------------------------
class CPingPong
{
public:
	CPingPong::CPingPong(
         CPersist *pPers,                     // the class to be persisted
         LPWSTR    pwszRegKey,                // registry key name for files path
         LPWSTR    pwszDefFileName,           // default filename
         LPWSTR    pwszReportName);           // object name for reporting problems

    CPingPong::~CPingPong();

    HRESULT Init(ULONG ulVersion);            // Intialization
    HRESULT Save();                           // Saving

    HRESULT ChooseFileName();                 // Defines pathnames for the in-seq files

    HRESULT Init_Legacy();

private:
    BOOL    Verify_Legacy(ULONG &ulPingNo);   // Verifies both ping-pong files and finds the latest
                             
private:
    CPersist  *m_pPersistObject;              // The object to be persisted

    WCHAR      m_wszFileNames[2*FILE_NAME_MAX_SIZE+2];    // filenames
    LPWSTR     m_pwszFile[2];

    WCHAR      m_wszRegKey[FILE_NAME_MAX_SIZE];           // Registry key name
    WCHAR      m_wszDefFileName[FILE_NAME_MAX_SIZE];      // File default name
    WCHAR      m_wszReportName[FILE_NAME_MAX_SIZE];       // Name for reporting
};

#endif __XACTPING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactping.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactPing.cpp

Abstract:
    Ping-Pong persistency mechanism implementation

    Any data structure may be made persistent with this mechanism.
    Two files are allocated for keeping the data.
    Each Save writes into the alternate file.
    So we may be sure that we have at least 1 successfull copy.
    Ping-Pong loads from the latest valid copy.

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"

#ifndef COMP_TEST
#include "qmutil.h"
#else
#include <afxwin.h>
#undef DBGMSG
#define DBGMSG(data)
BOOL GetRegistryStoragePath(LPWSTR w1, LPWSTR w2, LPWSTR w3) {  return FALSE; }
#endif

#include "xactping.h"

#include "xactping.tmh"

static WCHAR *s_FN=L"xactping";

/*====================================================
CPingPong::CPingPong
    Constructor
=====================================================*/
CPingPong::CPingPong(
         CPersist *pPers,
         LPWSTR    pwsDefFileName, 
         LPWSTR    pwsRegKey,
         LPWSTR    pwszReportName)
{
    m_pPersistObject = pPers;

    wcscpy(m_wszRegKey,      pwsRegKey);
    wcscpy(m_wszDefFileName, pwsDefFileName);
    wcscpy(m_wszReportName,  pwszReportName);

    m_pwszFile[0]  = &m_wszFileNames[0];
    m_pwszFile[1]  = &m_wszFileNames[FILE_NAME_MAX_SIZE + 1];
}

/*====================================================
CPingPong::~CPingPong
    Destructor
=====================================================*/
CPingPong::~CPingPong()
{
}


/*====================================================
CPingPong::Init
    Inits the InSequences Hash
=====================================================*/
HRESULT CPingPong::Init(ULONG ulVersion)
{
    // Get ping-pong filename from registry or from default
    ChooseFileName();

    // We've found/formatted valid file and know his index
    HRESULT hr = m_pPersistObject->LoadFromFile(m_pwszFile[ulVersion%2]);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR,
                _TEXT("Cannot load %ls: hr=%x"),
                m_wszReportName,  hr));
        LogHR(hr, s_FN, 10);
        return MQ_ERROR_CANNOT_READ_CHECKPOINT_DATA;
    }

    // Is it the right version?
    if (ulVersion != m_pPersistObject->PingNo())
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR,
                _TEXT("Wrong version in checkpoint file %ls"),
                m_wszReportName));
        return LogHR(MQ_ERROR_CANNOT_READ_CHECKPOINT_DATA, s_FN, 20);
    }

    // Checks the contents
    if (!m_pPersistObject->Check())
    {
        DBGMSG((DBGMOD_ALL, DBGLVL_ERROR,
                _TEXT("Wrong data in checkpoint file %ls"),
                m_wszReportName));
        return LogHR(MQ_ERROR_CANNOT_READ_CHECKPOINT_DATA, s_FN, 30);
    }

    // OK, we are ready
    return MQ_OK;
}

/*====================================================
CPingPong::Save
    Saves the correct state of the persistent object
=====================================================*/
HRESULT CPingPong::Save()
{
    HRESULT hr = S_OK;
    m_pPersistObject->PingNo()++;

    int ind = (m_pPersistObject->PingNo())  % 2;

    hr = m_pPersistObject->SaveInFile(m_pwszFile[ind], ind, FALSE);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ALL,
                DBGLVL_ERROR,
                _TEXT("Cannot save %ls: hr=%x"),
                m_wszReportName,
                hr));
    }
    return LogHR(hr, s_FN, 50);
}

/*====================================================
CPingPong::Verify_Legacy
    Verifies both copies and finds the  valid one
=====================================================*/
BOOL CPingPong::Verify_Legacy(ULONG &ulPingNo)
{
    ULONG   ulPing[2];
    BOOL    fOk[2];
    HRESULT hr;

    // Test both copies
    for (int j=0; j<2; j++)
    {
        // Loads data
        hr = m_pPersistObject->LoadFromFile(m_pwszFile[j]);
        if (SUCCEEDED(hr))
        {
            // Checks them
            fOk[j]    = m_pPersistObject->Check();
            ulPing[j] = m_pPersistObject->PingNo();
            m_pPersistObject->Destroy();
        }
        else
        {
             fOk[j] = FALSE;
        }
    }

    if (fOk[0])
    {
        if (fOk[1])
            ulPingNo = (ulPing[0] > ulPing[1] ? 0 : 1); // both OK, take the latest
        else
            ulPingNo = 0;                               // 1th is bad
    }
    else
    {
        if (fOk[1])
            ulPingNo = 1;                               // 0th is bad
        else
            return FALSE;
    }

    return(TRUE);
}


/*====================================================
CPingPong::ChooseFileParams
    Gets from Registry or from defaults file pathname

=====================================================*/
HRESULT CPingPong::ChooseFileName()
{
    // Set initial version and index
    WCHAR  wsz1[1000], wsz2[1000];

    wcscpy(wsz1, L"\\");
    wcscat(wsz1, m_wszDefFileName);
    wcscat(wsz1, L".lg1");

    wcscpy(wsz2, L"\\");
    wcscat(wsz2, m_wszDefFileName);
    wcscat(wsz2, L".lg2");


    // Get pathnames for 2 In Sequences log files
    if((GetRegistryStoragePath(m_wszRegKey, m_pwszFile[0], wsz1) &&
        GetRegistryStoragePath(m_wszRegKey, m_pwszFile[1], wsz2)) == FALSE)
    {
        //DBGMSG((DBGMOD_ALL,DBGLVL_ERROR, TEXT("%ls path is invalid, (registry key %ls)"), m_wszReportName, m_wszRegKey));

        // Prepare defaults for the transaction logfile names
        if ((GetRegistryStoragePath(FALCON_XACTFILE_PATH_REGNAME, m_pwszFile[0], wsz1) &&
             GetRegistryStoragePath(FALCON_XACTFILE_PATH_REGNAME, m_pwszFile[1], wsz2)) == FALSE)
        {
            wcscpy(m_pwszFile[0],L"C:");
            wcscat(m_pwszFile[0],wsz1);

            wcscpy(m_pwszFile[1],L"C:");
            wcscat(m_pwszFile[1],wsz2);
        }
    }

    return MQ_OK;
}

/*====================================================
CPingPong::Init_Legacy
    Inits the InSequences Hash from legacy data
    (works only once after upgrade)
=====================================================*/
HRESULT CPingPong::Init_Legacy()
{
    HRESULT hr = MQ_OK;
    ULONG   ulPingNo;
    // Get ping-pong filename from registry or from default
    ChooseFileName();
    // ignore hr:  if something bad, defaults are guaranteed

    // Verify the files; choose the one to read from
    if (!(Verify_Legacy(ulPingNo)))
    {
        // There is no valid file. Starting from scratch.
        return LogHR(MQ_ERROR_CANNOT_READ_CHECKPOINT_DATA, s_FN, 60);
    }

    // We've found/formatted valid file and know his index
    hr = m_pPersistObject->LoadFromFile(m_pwszFile[ulPingNo]);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ALL,
                DBGLVL_ERROR,
                _TEXT("Cannot load %ls: hr=%x"),
                m_wszReportName,
                hr));
        return LogHR(hr, s_FN, 70);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactrm.h ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    QmXactRm.h

Abstract:
    Transaction Resource Manager general definitions

Author:
    Alexander Dadiomov (AlexDad)

--*/

#ifndef __XACTRM_H__
#define __XACTRM_H__

#include "txdtc.h"
#include "qmrt.h"

// forward declaration
class CTransaction;
class CResourceManager;
class CXactSorter;

inline BOOL operator ==(const XACTUOW& a, const XACTUOW& b)
{
    return (memcmp(&a, &b, sizeof(XACTUOW)) == 0);
}

inline BOOL operator !=(const XACTUOW& a, const XACTUOW& b)
{
	return !(a == b);
}

inline UINT AFXAPI HashKey(const XACTUOW& key)
{
    return (*(UINT*)&key);
}

//---------------------------------------------------------------------
// CIResourceManagerSink: object provides IResourceManagerSink for call by DTC
//---------------------------------------------------------------------

class CIResourceManagerSink: public IResourceManagerSink
{
public:

    CIResourceManagerSink(CResourceManager *pRM);
    ~CIResourceManagerSink(void);

    STDMETHODIMP            QueryInterface(REFIID i_iid, LPVOID FAR* ppv);
    STDMETHODIMP_ (ULONG)   AddRef(void);
    STDMETHODIMP_ (ULONG)   Release(void);

    // IResourceManagerSink interface:
    // Defines the TMDown interface to notify RM when the transaction
    // transaction manager is down.
    //      TMDown          -- callback received when the TM goes down

    STDMETHODIMP            TMDown(void);

private:
    ULONG             m_cRefs;      // reference counter
    CResourceManager *m_pRM;        // backpointer to parent RM
};

//---------------------------------------------------------------------
// CResourceManager object
//---------------------------------------------------------------------
class CResourceManager : public CPersist
{
public:

    // Construction
    CResourceManager();
    ~CResourceManager( void );

    // Initialization
    HRESULT PreInit(ULONG ulVersion, TypePreInit tpCase);
    HRESULT Init(void);
    HRESULT ProvideDtcConnection(void);
    HRESULT ConnectDTC(void);
    void    DisconnectDTC(void);
    HRESULT InitOrderQueue(void);

    // Enlist transaction
    HRESULT EnlistTransaction(
            const XACTUOW* pUow,
            DWORD cbCookie,
            unsigned char *pbCookie);

    HRESULT EnlistInternalTransaction(
            XACTUOW *pUow,
            RPC_INT_XACT_HANDLE *phXact);

    // Forget transaction
    void ForgetTransaction(CTransaction *pTrans);

	//
	// Find transaction by UOW
	//
	CTransaction *FindTransaction(const XACTUOW *pUOW);

	//
	// Recover all transactions
	//
	HRESULT	  RecoverAllTransactions();

	//
	// Release all complete trasnactions
	//
	void      ReleaseAllCompleteTransactions();

    // Numbering and sorting
    ULONG     AssignSeqNumber();                     // assigns next sequential number for the transaction
    void      InsertPrepared(CTransaction *pTrans);  // inserts the prepared xaction into the list of prepared
    void      InsertCommitted(CTransaction *pTrans); // inserts the Commit1-ed xaction into the list
    HRESULT   RemoveAborted(CTransaction *pTrans);   // removes the prepared xaction fromthe list of prepared
    void      SortedCommit(CTransaction *pTrans);    // marks prepared xact as committed and commits what's possible
    void      SortedCommit3(CTransaction *pTrans);   // marks Commit1-ed xact
    CCriticalSection &SorterCritSection();           // provides access to the sorter crit.section
    CCriticalSection &CritSection();                 // provides access to the crit.section

    // Get
    IResourceManager  *GetIResMgr()
                            { return m_pIResMgr; };              // DTC Resource Manager representative


    // Persistency
    HRESULT SaveInFile(                       // Saves in file
                LPWSTR wszFileName,
                ULONG ulIndex,
                BOOL fCheck);

    HRESULT LoadFromFile(LPWSTR wszFileName);      // Loads from file


    BOOL    Save(HANDLE  hFile);              // Save / Load
    BOOL    Load(HANDLE  hFile);
    BOOL    Check();                          // Verifies the state
    HRESULT Format(ULONG ulPingNo);           // Formats empty instance
    void    Destroy();                        // Destroyes allocated data
    ULONG&  PingNo();                         // Gives access to ulPingNo
    HRESULT Save();                           // Saves via ping-ponger

    void XactFlagsRecovery(                   // Data Recovery per log record
                USHORT usRecType,
                PVOID pData,
                ULONG cbData);

	CTransaction	*GetRecoveringTransaction(ULONG ulIndex);
	CTransaction	*NewRecoveringTransaction(ULONG ulIndex);

    // Transaction indexing
    void  StartIndexing();                           // start indexing from zero
    ULONG Index();                                   // provides next unused index

    // Debugging features
    void IncXactCount();
    void DecXactCount();

    // Live data

private:

    // Mapping UOW->Active Transactions
    CMap<XACTUOW, const XACTUOW&, CTransaction *, CTransaction*> m_Xacts;

    // Temp mapping from Index (used during recovery)
    CMap<ULONG,   const ULONG&,   CTransaction *, CTransaction*> m_XactsRecovery;

    BOOL                   m_fEmpty;     // temp keeping
    ULONG                  m_ulXactIndex;// Last known xact index
    GUID                   m_RMGuid;     // RM instance GUID (recoverable)

    // Data for persistency control (via 2 ping-pong files)
    ULONG                  m_ulPingNo;   // Current counter of ping write
    ULONG                  m_ulSignature;// Saving signature
    CPingPong              m_PingPonger; // Ping-Pong persistency object

    // Current pointers
    IUnknown              *m_punkDTC;    // pointer to the local DTC
    ITransactionImport    *m_pTxImport;  // DTC import transaction interface
    IResourceManager      *m_pIResMgr;   // DTC Resource manager interface.
    CIResourceManagerSink  m_RMSink;     // RM Sink object
    CXactSorter           *m_pXactSorter;   // Transactions sorter object
    CXactSorter           *m_pCommitSorter; // Commit2 sorter object
    CCriticalSection       m_critRM;     // critical section for mutual exclusion

	BOOL				   m_fRecoveryComplete;

#ifdef _DEBUG
    LONG                   m_cXacts;     // live transactions counter
#endif
};

//-------------------------------------
// external declarations of globals
//-------------------------------------
extern CResourceManager *g_pRM;          // Global single instance of the RM

extern HRESULT QMPreInitResourceManager(ULONG ulVersion, TypePreInit tpCase);
extern HRESULT QMInitResourceManager();
extern void    QMFinishResourceManager();

UINT AFXAPI HashKey( LONGLONG key);

#endif __XACTRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactrm.cpp ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactRm.cpp

Abstract:
    This module implements QM transactional Resource Manager object

Author:
    Alexander Dadiomov (AlexDad)
--*/

#include "stdh.h"
#include "Xact.h"
#include "xactstyl.h"
#include "mqutil.h"
#include "qmutil.h"
#include "qmpkt.h"
#include "xactout.h"
#include "xactsort.h"
#include "xactlog.h"

#include "xactrm.tmh"

static WCHAR *s_FN=L"xactrm";

//-------------------------------------
// Declaration of global RM instance
//-------------------------------------
CResourceManager *g_pRM;

// Crash order for debugging recovery
ULONG g_ulCrashPoint    = 0;
ULONG g_ulCrashLatency  = 0;
ULONG g_ulXactStub      = 0;

// Xact file signature
#define XACTS_SIGNATURE         0x5678

//-------------------------------------------
// Externals
//-------------------------------------------

extern void CleanXactQueues();

#pragma warning(disable: 4355)  // 'this' : used in base member initializer list
/*====================================================
CResourceManager::CResourceManager
    Constructor
=====================================================*/
CResourceManager::CResourceManager()
    : m_PingPonger(this,
                   FALCON_DEFAULT_XACTFILE_PATH,
                   FALCON_XACTFILE_PATH_REGNAME,
                   FALCON_XACTFILE_REFER_NAME),
      m_RMSink(this)
{
    m_punkDTC     = NULL;
    m_pTxImport   = NULL;
    m_pIResMgr    = NULL;
    m_ulXactIndex = 0;
    m_pXactSorter = NULL;
    m_pXactSorter = new CXactSorter(TS_PREPARE);
    m_pCommitSorter = NULL;
    m_pCommitSorter = new CXactSorter(TS_COMMIT);
    m_RMGuid.Data1= 0;
	m_fRecoveryComplete = FALSE;

#ifdef _DEBUG
    m_cXacts      = 0;
#endif
}
#pragma warning(default: 4355)  //  'this' : used in base member initializer list


/*====================================================
CResourceManager::~CResourceManager
    Destructor
=====================================================*/
CResourceManager::~CResourceManager()
{
    if (m_punkDTC)
    {
        m_punkDTC->Release();
        m_punkDTC = NULL;
    }

    if (m_pTxImport)
	{
        m_pTxImport->Release();
        m_pTxImport = NULL;
    }

    if (m_pIResMgr)
    {
        m_pIResMgr->Release();
        m_pIResMgr = NULL;
    }

    if (m_pXactSorter)
    {
        delete m_pXactSorter;
        m_pXactSorter = NULL;
    }

    if (m_pCommitSorter)
    {
        delete m_pCommitSorter;
        m_pCommitSorter = NULL;
    }

#ifdef _DEBUG
    if (m_cXacts != 0)
    {
       Sleep(60000);  // otherwise assert invisible (window closes)
       ASSERT(m_cXacts==0);
    }
#endif
}

/*====================================================
CResourceManager::ConnectDTC
    ConnectDTC : called in init and after DTC's fail
=====================================================*/
HRESULT CResourceManager::ConnectDTC(void)
{
    HRESULT  hr = MQ_ERROR;
    R<IResourceManagerFactory>  pIRmFactory  = NULL;
    CS lock(m_critRM);

    try
    {
        // Get a pointer to DTC and check that DTC is running
        hr = XactGetDTC(&m_punkDTC, NULL, NULL);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("XactGetDTC 1 failed: %x "), hr));
        }
        CHECK_RETURN_CODE(MQ_ERROR_DTC_CONNECT, 1500);

        // Release m_pTxImport and m_pIResMgr interfaces
        DisconnectDTC();

        // Get the resource manager factory from the IUnknown
        hr = m_punkDTC->QueryInterface(IID_IResourceManagerFactory,(LPVOID *) &pIRmFactory);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("QI IResourceManagerFactory failed: %x "), hr));
        }
        CHECK_RETURN(1600);

        // Prepare client name (ANSI)
        CHAR szClientName[255];

        WCHAR  wszDtcClientName[255] = FALCON_DEFAULT_RM_CLIENT_NAME;
        DWORD  dwSize = sizeof(wszDtcClientName);
        DWORD  dwType = REG_SZ ;

        LONG lRes = GetFalconKeyValue(
                        FALCON_RM_CLIENT_NAME_REGNAME,
                        &dwType,
                        wszDtcClientName,
                        &dwSize,
                        FALCON_DEFAULT_RM_CLIENT_NAME
                        );
        ASSERT(lRes == ERROR_SUCCESS) ;
        ASSERT(dwType == REG_SZ) ;
		DBG_USED(lRes);

        size_t res = wcstombs(szClientName, wszDtcClientName, sizeof(szClientName));
        ASSERT(res != (size_t)(-1));
		DBG_USED(res);

        // Create instance of the resource manager interface.
        hr = pIRmFactory->Create (&m_RMGuid,
                                  szClientName,
                                  (IResourceManagerSink *) &m_RMSink,
                                  &m_pIResMgr );
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("pIRmFactory->Create failed: %x "), hr));
        }
        CHECK_RETURN_CODE(MQ_ERROR_DTC_CONNECT, 1510);

        // Get a pointer to the ITransactionImport interface.
        hr = m_punkDTC->QueryInterface(IID_ITransactionImport,(void **)&m_pTxImport);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("QI IID_ITransactionImport failed: %x "), hr));
        }
        CHECK_RETURN(1610);
    }
    catch(...)
    {
        if (SUCCEEDED(hr))
	{
		hr = MQ_ERROR;
	}	

        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          MSMQ_INTERNAL_ERROR,
                                          1,
                                          L"CResourceManager::ConnectDTC"));
	
    }

    if (SUCCEEDED(hr))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, TEXT("Successfully MSDTC initialization")));
    }
    else
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, TEXT("Could not connect to MSDTC")));
    }

    return LogHR(hr, s_FN, 10);

}

/*====================================================
CResourceManager::ProvideDtcConnection
    Called each time before DTC is needed
=====================================================*/
HRESULT CResourceManager::ProvideDtcConnection(void)
{
	HRESULT hr;

	if(m_pIResMgr)
		return(MQ_OK);
	
	hr = ConnectDTC();
	if (FAILED(hr))
	{
		REPORT_CATEGORY(MSDTC_FAILURE, CATEGORY_KERNEL);
        DBGMSG((DBGMOD_ALL, DBGLVL_INFO,_TEXT("No connection with transaction coordinator")));
        return LogHR(hr, s_FN, 20);
	}

    return LogHR(hr, s_FN, 30);
}

/*====================================================
CResourceManager::DisconnectDTC
    DisconnectDTC : called when DTC fails
=====================================================*/
void CResourceManager::DisconnectDTC(void)
{
    try
    {
        if (m_pTxImport)
        {
            m_pTxImport->Release();
        }

        if (m_pIResMgr)
        {
            m_pIResMgr->Release();
        }

        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, TEXT("MSDTC disconnected")));
    }
    catch(...)
    {
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          MSMQ_INTERNAL_ERROR,
                                          1,
                                          L"CResourceManager::DisconnectDTC"));
        // We may fall here very easily if Disconnect is called after DTC's death
        LogIllegalPoint(s_FN, 190);
    }

    m_pTxImport = NULL;
    m_pIResMgr  = NULL;
}


/*====================================================
CResourceManager::PreInit
    PreInitialization (DTC connection)
    Should be done before RPC Listen
=====================================================*/
HRESULT CResourceManager::PreInit(ULONG ulVersion, TypePreInit tpCase)
{
    HRESULT  hr = MQ_OK;

    switch(tpCase)
    {
    case piNoData:
        m_PingPonger.ChooseFileName();
        Format(0);
        break;
    case piNewData:
        hr = m_PingPonger.Init(ulVersion);
        break;
    case piOldData:
        hr = m_PingPonger.Init_Legacy();
        break;
    default:
        ASSERT(0);
        hr = MQ_ERROR;
        break;
    }

    if (m_RMGuid.Data1 == 0)
    {
        UuidCreate(&m_RMGuid);
    }
    return LogHR(hr, s_FN, 40);
}

/*====================================================
CResourceManager::Init
    Initialization
=====================================================*/
HRESULT CResourceManager::Init(void)
{
    HRESULT hr;
    hr = ProvideDtcConnection();
    if (FAILED(hr))
        return LogHR(hr, s_FN, 50);

    //
    // Report to DTC that all reenlistment is completed
	//
	m_pIResMgr->ReenlistmentComplete();

	m_fRecoveryComplete = TRUE;

	//
    // Start indexing from zero
	//
    StartIndexing();

    return(MQ_OK);
}


HRESULT RMImport(
            ITransactionImport  *pTxImport,
            ULONG cbTransactionCookie,
            BYTE  *rgbTransactionCookie,
            IID   *piid,
            void  **ppvTransaction)
{
    HRESULT hr = pTxImport->Import (
                             cbTransactionCookie,
                             rgbTransactionCookie,
                             piid,
                             ppvTransaction);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("Import failed: %x "), hr));
    }
    return LogHR(hr, s_FN, 60);
} 

HRESULT RMEnlist(
         IResourceManager *pIResMgr,
         ITransaction  *pTransaction,
         ITransactionResourceAsync  *pRes,
         void *pUOW,
         LONG  *pisoLevel,
         ITransactionEnlistmentAsync  ** ppEnlist)
{
    HRESULT hr = pIResMgr->Enlist(
         pTransaction,
         pRes,
         (BOID *)pUOW,
         pisoLevel,
         ppEnlist);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("Enlist failed: %x "), hr));
    }
    return LogHR(hr, s_FN, 70);
}

/*====================================================
CResourceManager::EnlistTransaction
    Enlist the external (DTC) transaction
=====================================================*/
HRESULT CResourceManager::EnlistTransaction(
    const XACTUOW* pUow,
    DWORD cbCookie,
    unsigned char *pbCookie)
{
    R<ITransaction>                pTransIm       = NULL;
    R<CTransaction>                pCTrans        = NULL;
    R<ITransactionResourceAsync>   pTransResAsync = NULL;
    R<ITransactionEnlistmentAsync> pEnlist        = NULL;
    CTransaction    *pCTrans1;
    HRESULT          hr     = MQ_OK;
    LONG             lIsoLevel;
    XACTUOW          uow1;

    DBGMSG((DBGMOD_XACT,
            DBGLVL_INFO,
            TEXT(" CResourceManager::EnlistTransaction")));

    // Look for the transaction between the active ones
    {
        CS lock(m_critRM);
        if (m_Xacts.Lookup(*pUow, pCTrans1))
        {
            // Xaction already exists.
            return S_OK;
        }
        else
        {
            // Not found.  The  transaction is new.
            try
            {
                pCTrans = new CTransaction(this);
            }
            catch(const bad_alloc&)
            {
                return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 80);
            }

            pCTrans->SetUow(pUow);
#ifdef _DEBUG
			CTransaction *p;
#endif
			ASSERT(m_fRecoveryComplete);
			ASSERT(!m_Xacts.Lookup(*pUow, p));
			m_Xacts[*pUow] = pCTrans.get();
        }
    }

    // Creating transaction queue
    hr = pCTrans->CreateTransQueue();
    CHECK_RETURN_CODE(hr, 1520);

    try
    {
        // Provide the RM - DTC connection (it may have been torn down)
        hr = ProvideDtcConnection();
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("ProvideDtcConnection2 failed: %x "), hr));
        }
        CHECK_RETURN(1800);

        pCTrans->SetCookie(cbCookie, pbCookie);  // we may need it for remote read

        // Import the transaction
        hr = RMImport(m_pTxImport,
                      cbCookie,
                      pbCookie,
                      (GUID *) &IID_ITransaction,
                      (void **) &pTransIm);
        CHECK_RETURN_CODE(MQ_ERROR_TRANSACTION_IMPORT, 1530);

        pCTrans->SetState(TX_INITIALIZED);

        // Do we need it to addref pData->m_ptxRmAsync [DTC has now a reference] ??

        // prepare  ITransactionResourceAsync interface pointer
        hr = pCTrans->QueryInterface(IID_ITransactionResourceAsync,(LPVOID *) &pTransResAsync);
        CHECK_RETURN(1810);

        // Enlist on the transaction
        hr = RMEnlist(m_pIResMgr,
                      pTransIm.get(),           // IN
                      pTransResAsync.get(),     // IN
                      &uow1,					// OUT
                      &lIsoLevel,               // OUT: ignoring it
                      &pEnlist.ref());                // OUT
        CHECK_RETURN_CODE(MQ_ERROR_TRANSACTION_ENLIST, 1540);

        pTransResAsync->AddRef();
        pCTrans->SetEnlist(pEnlist.get());
        pEnlist->AddRef();

        // BUGBUG: We now reference DTC, so probably we need Addref to some TM interface here

		//
        // Enlistment on transaction is OK. Set current state to reflect enlistment
		//
        pCTrans->SetState(TX_ENLISTED);

        hr = S_OK;
    }
    catch(...)
    {
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                                          MSMQ_INTERNAL_ERROR,
                                          1,
                                          L"CResourceManager::EnlistTransaction"));
        LogIllegalPoint(s_FN, 195);
        hr = MQ_ERROR;
    }

    return LogHR(hr, s_FN, 90);
}

/*====================================================
CResourceManager::EnlistInternalTransaction
    Enlist the internal MSMQ transaction
=====================================================*/
HRESULT CResourceManager::EnlistInternalTransaction(
  XACTUOW *pUow,
  RPC_INT_XACT_HANDLE *phXact)
{
    R<CTransaction>  pCTrans = NULL;
    HRESULT          hr;

    DBGMSG((DBGMOD_XACT,
            DBGLVL_TRACE,
            TEXT(" CResourceManager::EnlistInternalTransaction")));

    // Look for the transaction between the active ones
    {
        CS lock(m_critRM);
        CTransaction    *pCTransOld;

        if (m_Xacts.Lookup(*pUow, pCTransOld))
        {
            //
            // Transaction with the same ID already exist. We do not allow
            // enlisting the same transaciton twice. (can't give more than one
            // context handle to the same transaction)
            //
            return LogHR(MQ_ERROR_TRANSACTION_SEQUENCE, s_FN, 99);
        }

        // Not found. Create new internal transaction
        try
        {
            pCTrans = new CTransaction(this, 0, TRUE);
        }
        catch(const bad_alloc&)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 100);
        }

        pCTrans->SetUow(pUow);

        // Include transaction in mapping (we need it for saving)
        ASSERT(m_fRecoveryComplete);
        m_Xacts[*pUow] = pCTrans.get();

    }


    // Creating transaction queue
    hr = pCTrans->CreateTransQueue();
    CHECK_RETURN_CODE(hr, 1550);

    // Enlistment on transaction is OK. Set current state to reflect enlistment
    pCTrans->SetState(TX_ENLISTED);

	// set RPC context handle to keep pointer to xact
    *phXact = pCTrans.detach();

    return LogHR(hr, s_FN, 110);
}

/*====================================================
QMDoGetTmWhereabouts
    Returns to the app QM's controlling TM whereabouts
=====================================================*/
HRESULT QMDoGetTmWhereabouts(
    DWORD           cbBufSize,
    unsigned char *pbWhereabouts,
    DWORD         *pcbWhereabouts)
{
    R<IUnknown> pUnk = NULL;
    UCHAR *pw;
    DWORD  dw;

    HRESULT hr = XactGetDTC(&pUnk.ref(), &dw, &pw);

    if (SUCCEEDED(hr))
    {
        *pcbWhereabouts = dw;

        if (dw <= cbBufSize)
        {
            CopyMemory(pbWhereabouts, pw, dw);
        }
        else
        {
            hr = MQ_ERROR_USER_BUFFER_TOO_SMALL;
        }
    }
    return LogHR(hr, s_FN, 120);
}

/*====================================================
QMDoEnlistTransaction
    This is a top level RPC routine, called from the client side
=====================================================*/
HRESULT QMDoEnlistTransaction(
    XACTUOW *pUow,
    DWORD cbCookie,
    unsigned char *pbCookie)
{
    ASSERT(g_pRM);

    if (!(cbCookie == 1 && *pbCookie == 0))
    {
        // We don't need DTC for uncoordinated transaction

        HRESULT hr = g_pRM->ProvideDtcConnection();
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("ProvideDtcConnection1 failed: %x "), 0));
            LogHR(hr, s_FN, 130);
            return MQ_ERROR_DTC_CONNECT;
        }
    }

    return LogHR(g_pRM->EnlistTransaction(pUow, cbCookie, pbCookie), s_FN, 140);
}

/*====================================================
QMDoEnlistInternalTransaction
    This is a top level RPC routine, called from the client side
=====================================================*/
HRESULT QMDoEnlistInternalTransaction(
            XACTUOW *pUow,
            RPC_INT_XACT_HANDLE *phXact)
{
    ASSERT(g_pRM);
    return LogHR(g_pRM->EnlistInternalTransaction(pUow, phXact), s_FN, 150);
}


/*====================================================
QMDoCommitTransaction
    This is a top level RPC routine, called from the client side
=====================================================*/
HRESULT QMDoCommitTransaction(
    RPC_INT_XACT_HANDLE *phXact)
{

    CTransaction *pXact = (CTransaction *)*phXact;
    *phXact = NULL;

    if (pXact == NULL)
    {
        return LogHR(MQ_ERROR, s_FN, 155);
    }

    HRESULT hr = pXact->InternalCommit();
	//
	// pXact is usually released by now.  However, if a severe error occurs
	// during the commit we might have to leak pXact so we never forget it
	// in a checkpoint
	//
	return LogHR(hr, s_FN, 160);
}


/*====================================================
QMDoAbortTransaction
    This is a top level RPC routine, called from the client side
=====================================================*/
HRESULT QMDoAbortTransaction(
    RPC_INT_XACT_HANDLE *phXact)
{
    CTransaction *pXact = (CTransaction *)*phXact;
    *phXact = NULL;

    if (pXact == NULL)
    {
        return LogHR(MQ_ERROR, s_FN, 165);
    }
    return pXact->InternalAbort();
}

/*====================================================
RPC_INT_XACT_HANDLE_rundown
    Called by RPC when client connection is broken
=====================================================*/
void __RPC_USER RPC_INT_XACT_HANDLE_rundown(RPC_INT_XACT_HANDLE hXact)
{
    CTransaction *pXact = (CTransaction *)hXact;

    if (pXact == NULL)
    {
        LogHR(MQ_ERROR, s_FN, 167);
        return;
    }

    pXact->InternalAbort();
}

/*====================================================
CResourceManager::ForgetTransaction
    Forget the transaction - exclude it from the mapping
=====================================================*/
void CResourceManager::ForgetTransaction(CTransaction    *pTrans)
{
    CS lock(m_critRM);

    m_Xacts.RemoveKey(*pTrans->GetUow());
	m_XactsRecovery.RemoveKey(pTrans->GetIndex());
}


/*====================================================
QMInitResourceManager
    Initializes RM
=====================================================*/
HRESULT QMInitResourceManager()
{
    ASSERT(g_pRM);
    return LogHR(g_pRM->Init(), s_FN, 170);
}

/*====================================================
QMPreInitResourceManager
    Pre-initialization of the RM
=====================================================*/
HRESULT QMPreInitResourceManager(ULONG ulVersion, TypePreInit tpCase)
{
    ASSERT(!g_pRM);

    #ifdef _DEBUG
    //
    // Get debugging parameters from registry
    //

    // Get initial crash point for QM transactions recovery debugging
    DWORD dwDef = FALCON_DEFAULT_CRASH_POINT;
    READ_REG_DWORD(g_ulCrashPoint,
                   FALCON_CRASH_POINT_REGNAME,
                   &dwDef ) ;
    if (g_ulCrashPoint)
    {
        DBGMSG((DBGMOD_ALL,DBGLVL_ERROR, TEXT("Crash point %d ordered!"), g_ulCrashPoint));
    }

    // Get crash latency for QM transactions recovery debugging
    dwDef = FALCON_DEFAULT_CRASH_LATENCY;
    READ_REG_DWORD(g_ulCrashLatency,
                   FALCON_CRASH_LATENCY_REGNAME,
                   &dwDef ) ;

    #endif

    //
    // Create and initialize the single copy of resource manager
    //

    g_pRM = new CResourceManager();

    ASSERT(g_pRM);
    return LogHR(g_pRM->PreInit(ulVersion, tpCase), s_FN, 180);
}

/*====================================================
QMFinishResourceManager
    Finishes RM work
=====================================================*/
void QMFinishResourceManager()
{
    if (g_pRM)
    {
        delete g_pRM;
        g_pRM = NULL;
    }
    return;
}

/*====================================================
CResourceManager::IncXactCount
    Increments live transacions counter
=====================================================*/

#ifdef _DEBUG

void CResourceManager::IncXactCount()
{
	InterlockedIncrement(&m_cXacts);
}

#endif

/*====================================================
CResourceManager::DecXactCount
    Decrements live transacions counter
=====================================================*/

#ifdef _DEBUG

void CResourceManager::DecXactCount()
{
    InterlockedDecrement(&m_cXacts);
}

#endif

/*====================================================
CResourceManager::Index
    Returns incremented transacion discriminative index
=====================================================*/
ULONG CResourceManager::Index()
{
    m_ulXactIndex = (m_ulXactIndex == 0xFFFFFFFF ? 0 : m_ulXactIndex+1);
    return m_ulXactIndex;
}

/*====================================================
CResourceManager::StartIndexing
    Starts indexing from zero - must be called after recovery
=====================================================*/
void CResourceManager::StartIndexing()
{
    m_ulXactIndex = 0;
}

/*====================================================
CResourceManager::AssignSeqNumber
    Increments and returns the umber of prepared transactions
=====================================================*/
ULONG CResourceManager::AssignSeqNumber()
{
    return m_pXactSorter->AssignSeqNumber();
}

/*====================================================
CResourceManager::InsertPrepared
    Inserts the prepared xaction into the list of prepared
=====================================================*/
void CResourceManager::InsertPrepared(CTransaction *pTrans)
{
    m_pXactSorter->InsertPrepared(pTrans);
}

/*====================================================
CResourceManager::InsertCommitted
    Inserts the Commit1-ed xaction into the list
=====================================================*/
void CResourceManager::InsertCommitted(CTransaction *pTrans)
{
    m_pCommitSorter->InsertPrepared(pTrans);
}

/*====================================================
CResourceManager::RemoveAborted
    Removes the prepared xaction from the list of prepared
=====================================================*/
HRESULT CResourceManager::RemoveAborted(CTransaction *pTrans)
{
    CS lock(m_critRM);  // To prevent deadlock with Flusher thread
    return m_pXactSorter->RemoveAborted(pTrans);
}

/*====================================================
CResourceManager::SortedCommit
    Marks the prepared transaction as committed and
    commits what is possible
=====================================================*/
void CResourceManager::SortedCommit(CTransaction *pTrans)
{
    CS lock(m_critRM);  // To prevent deadlock with Flusher thread
    m_pXactSorter->SortedCommit(pTrans);
}

/*====================================================
CResourceManager::SortedCommit3
    Marks the Commit1-ed transaction and
    commits what is possible
=====================================================*/
void CResourceManager::SortedCommit3(CTransaction *pTrans)
{
    CS lock(m_critRM);  // Needed to prevent deadlock with Flusher thread
    m_pCommitSorter->SortedCommit(pTrans);
}


/*====================================================
CResourceManager::Save
    Saves in appropriate file
=====================================================*/
HRESULT CResourceManager::Save()
{
    return m_PingPonger.Save();
}

/*====================================================
CResourceManager::PingNo
    Access to the current ping number
=====================================================*/
ULONG &CResourceManager::PingNo()
{
    return m_ulPingNo;
}


/*====================================================
CResourceManager::Save
    Saves transactions in given file
=====================================================*/
BOOL CResourceManager::Save(HANDLE  hFile)
{
    PERSIST_DATA;
    CS lock(m_critRM);

    SAVE_FIELD(m_RMGuid);

    //
    // Keep file format the same as in MSMQ 1.0. The SeqID field in SP4 is
    // obsolete, and is written just for competability.  erezh 31-Aug-98
    //
    LONGLONG Obsolete = 0;
    SAVE_FIELD(Obsolete);

    ULONG cLen = m_Xacts.GetCount();
    SAVE_FIELD(cLen);

    POSITION posInList = m_Xacts.GetStartPosition();
    while (posInList != NULL)
    {
        XACTUOW       uow;
        CTransaction *pTrans;

        m_Xacts.GetNextAssoc(posInList, uow, pTrans);

        if (!pTrans->Save(hFile))
        {
            return FALSE;
        }
    }

    SAVE_FIELD(m_ulPingNo);
    SAVE_FIELD(m_ulSignature);

    return TRUE;
}

/*====================================================
CResourceManager::Load
    Loads transactions from a given file
=====================================================*/
BOOL CResourceManager::Load(HANDLE hFile)
{
    PERSIST_DATA;

    LOAD_FIELD(m_RMGuid);

    //
    // Keep file format the same as in MSMQ 1.0. The SeqID field in SP4 is
    // obsolete, and is read just for competability.  erezh 31-Aug-98
    //
    LONGLONG Obsolete;
    LOAD_FIELD(Obsolete);

    ULONG cLen;
    LOAD_FIELD(cLen);

	CS lock(m_critRM);

    for (ULONG i=0; i<cLen; i++)
    {
        CTransaction *pTrans = new CTransaction(this);

        if (!pTrans->Load(hFile))
        {
            return FALSE;
        }
#ifdef _DEBUG
		CTransaction *p;
#endif
		ASSERT(!m_XactsRecovery.Lookup(pTrans->GetIndex(), p));
        m_XactsRecovery.SetAt(pTrans->GetIndex(), pTrans);
		ASSERT(!m_Xacts.Lookup(*pTrans->GetUow(), p));
        m_Xacts[*pTrans->GetUow()] = pTrans;
    }

    LOAD_FIELD(m_ulPingNo);
    LOAD_FIELD(m_ulSignature);

    return TRUE;
}

/*====================================================
CResourceManager::SaveInFile
    Saves the transaction persistent data in the file
=====================================================*/
HRESULT CResourceManager::SaveInFile(LPWSTR wszFileName, ULONG, BOOL)
{
    HANDLE  hFile = NULL;
    HRESULT hr = MQ_OK;

    hFile = CreateFile(
             wszFileName,                                       // pointer to name of the file
             GENERIC_WRITE,                                     // access mode: write
             0,                                                  // share  mode: exclusive
             NULL,                                              // no security
             OPEN_ALWAYS,                                      // open existing or create new
             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, // file attributes and flags: we need to avoid lazy write
             NULL);                                             // handle to file with attributes to copy


    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = MQ_ERROR;
    }
    else
    {
        hr = (Save(hFile) ? MQ_OK : MQ_ERROR);
    }

    if (hFile)
    {
        CloseHandle(hFile);
    }

    DBGMSG((DBGMOD_XACT, DBGLVL_TRACE,
             _TEXT("Saved Xacts: %ls (ping=%d)"), wszFileName, m_ulPingNo));

    return hr;
}



/*====================================================
CResourceManager::LoadFromFile
    Loads Transactions from the file
=====================================================*/
HRESULT CResourceManager::LoadFromFile(LPWSTR wszFileName)
{
    HANDLE  hFile = NULL;
    HRESULT hr = MQ_OK;
    hFile = CreateFile(
             wszFileName,                       // pointer to name of the file
             GENERIC_READ,                      // access mode: write
             0,                                 // share  mode: exclusive
             NULL,                              // no security
             OPEN_EXISTING,                     // open existing
             FILE_ATTRIBUTE_NORMAL,             // file attributes: we may use Hidden once
             NULL);                             // handle to file with attributes to copy

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = MQ_ERROR;
    }
    else
    {
        hr = (Load(hFile) ? MQ_OK : MQ_ERROR);
    }

    if (hFile)
    {
        CloseHandle(hFile);
    }

    #ifdef _DEBUG
    if (SUCCEEDED(hr))
    {
        DBGMSG((DBGMOD_XACT,
                 DBGLVL_TRACE,
                 _TEXT("Loaded Xacts: %ls (ping=%d)"), wszFileName, m_ulPingNo));
    }
    #endif

    return hr;
}

/*====================================================
CResourceManager::Check
    Verifies the state
=====================================================*/
BOOL CResourceManager::Check()
{
    return (m_ulSignature == XACTS_SIGNATURE);
}


/*====================================================
CResourceManager::Format
    Formats the initial state
=====================================================*/
HRESULT CResourceManager::Format(ULONG ulPingNo)
{
     m_ulPingNo = ulPingNo;
     m_ulSignature = XACTS_SIGNATURE;

     return MQ_OK;
}


/*====================================================
CResourceManager::Destroy
    Destroys everything - on loading stage
=====================================================*/
void CResourceManager::Destroy()
{
	CS lock(m_critRM);

    POSITION posInList = m_XactsRecovery.GetStartPosition();
    while (posInList != NULL)
    {
        ULONG         ulIndex;
        CTransaction *pTrans;

        m_XactsRecovery.GetNextAssoc(posInList, ulIndex, pTrans);

        pTrans->Release();
	}

	ASSERT(m_XactsRecovery.GetCount() == 0);
	ASSERT(m_Xacts.GetCount() == 0);
}

/*====================================================
CResourceManager::NewRecoveringTransaction
    Add transaction to recovery map.
=====================================================*/
CTransaction *CResourceManager::NewRecoveringTransaction(ULONG ulIndex)
{
	CTransaction *pTrans;

	DBGMSG((DBGMOD_LOG, DBGLVL_TRACE, TEXT("Recovery: Xact Creation, Index=%d"), ulIndex));
	pTrans = new CTransaction(this, ulIndex);
#ifdef _DEBUG
	CTransaction *p;
#endif
	CS lock(m_critRM);
	ASSERT(!m_XactsRecovery.Lookup(ulIndex, p));
	m_XactsRecovery[ulIndex] = pTrans;
	return(pTrans);
}

/*====================================================
CResourceManager::GetRecoveringTransaction
    Find the trasnaction in the recovery map. Add it
	if not found.
=====================================================*/
CTransaction *CResourceManager::GetRecoveringTransaction(ULONG ulIndex)
{
	CTransaction *pTrans;

	CS lock(m_critRM);

	if(!m_XactsRecovery.Lookup(ulIndex, pTrans))
	{
		pTrans = NewRecoveringTransaction(ulIndex);
 	}

	return(pTrans);
}


/*====================================================
CResourceManager::XactFlagsRecovery
    Data recovery function: called per each log record
=====================================================*/
void
CResourceManager::XactFlagsRecovery(
	USHORT usRecType,
	PVOID pData,
	ULONG cbData
	)
{
    CTransaction *pTrans;

    switch (usRecType)
    {
    case LOGREC_TYPE_XACT_STATUS:
        ASSERT(cbData == sizeof(XactStatusRecord));
        {
            XactStatusRecord *pRecord = (XactStatusRecord *)pData;

			if (pRecord->m_taAction == TA_STATUS_CHANGE)
            {
				pTrans = GetRecoveringTransaction(pRecord->m_ulIndex);
                pTrans->SetFlags(pRecord->m_ulFlags);
            }

            DBGMSG((DBGMOD_XACT,
                    DBGLVL_INFO,
                    _TEXT("Xact restore: Index %d, Action %d, Flags %d"),
                    pRecord->m_ulIndex, pRecord->m_taAction, pRecord->m_ulFlags));
        }
        break;

    case LOGREC_TYPE_XACT_PREPINFO:
        {
            PrepInfoRecord *pRecord = (PrepInfoRecord *)pData;
			pTrans = GetRecoveringTransaction(pRecord->m_ulIndex);
            pTrans->PrepInfoRecovery(pRecord->m_cbPrepInfo, &pRecord->m_bPrepInfo[0]);

        }
        break;

    case LOGREC_TYPE_XACT_DATA:
        {
			CS lock(m_critRM);

            XactDataRecord *pRecord = (XactDataRecord *)pData;
			pTrans = GetRecoveringTransaction(pRecord->m_ulIndex);

			CTransaction *p;
            if (m_Xacts.Lookup(*pTrans->GetUow(), p))
            {
                // This can occur when the checkpoint started between creation of xact and 1st logging
                ASSERT(pTrans == p);
                break;
            }

            pTrans->XactDataRecovery(
                    pRecord->m_ulSeqNum,
                    pRecord->m_fSinglePhase,
                    &pRecord->m_uow);

            // Make sure we add the transaction to the UOW map
			ASSERT(!m_Xacts.Lookup(*pTrans->GetUow(), p));
            m_Xacts[*pTrans->GetUow()] = pTrans;
		}
        break;

    default:
        ASSERT(0);
        break;
    }
}

/*====================================================
 provides access to the sorter's critical section
=====================================================*/
CCriticalSection &CResourceManager::SorterCritSection()
{
    return m_pXactSorter->SorterCritSection();
}

/*====================================================
 provides access to the RM's critical section
=====================================================*/
CCriticalSection &CResourceManager::CritSection()
{
    return m_critRM;
}


/*====================================================
  Find a transaction by UOW
=====================================================*/
CTransaction *CResourceManager::FindTransaction(const XACTUOW *pUow)
{
    ASSERT(pUow);
    CTransaction *pTrans;

	CS lock(m_critRM);
	
    if (m_Xacts.Lookup(*pUow, pTrans))
        return(pTrans);
    else
        return(0);
}


/*====================================================
  Release all complete transactions
=====================================================*/
void CResourceManager::ReleaseAllCompleteTransactions()
{
	CS lock(m_critRM);
	ASSERT(m_XactsRecovery.GetCount() >= m_Xacts.GetCount());

	POSITION posInList = m_XactsRecovery.GetStartPosition();

    while (posInList != NULL)
    {
		ULONG ulIndex;
        CTransaction *pTrans;

        // get next xact
        m_XactsRecovery.GetNextAssoc(posInList, ulIndex, pTrans);


        // Release transaction if it is complete
		if(pTrans->IsComplete())
		{
			pTrans->Release();
		}
	}
}


/*====================================================
  Recover all transactions
=====================================================*/
HRESULT CResourceManager::RecoverAllTransactions()
{
	POSITION posInList;

	{
		CS lock(m_critRM);
		posInList = m_XactsRecovery.GetStartPosition();
	}

    while (posInList != NULL)
    {
        CTransaction *pTrans;
	    {
			// get next xact
			CS lock(m_critRM);
			ULONG ulIndex;
			m_XactsRecovery.GetNextAssoc(posInList, ulIndex, pTrans);
		}


		//
        // Recover the transaction
		// N.B. You can not hold m_critRM while calling Recover, as Recover completes
		// asynchronously. Calling Recover for multiple transactions will exhust all
		// Worker Threads since Recover needs m_critRM in another thread (to try to
		// remove the transaction from m_Xacts & m_XactsRecovery map).
		//
		HRESULT hr;
        hr = pTrans->Recover();
        if (FAILED(hr))
			return(hr);

		pTrans->Release();
	}

	//
	// No one is using the maps anymore.  Make sure.
	//
	ASSERT(m_Xacts.GetCount() == 0);
	ASSERT(m_XactsRecovery.GetCount() == 0);

	return(S_OK);
}

/*====================================================
Hash function for LongLong
=====================================================*/
UINT AFXAPI HashKey( LONGLONG key)
{
	LARGE_INTEGER li;
	li.QuadPart = key;
    return(li.LowPart + (UINT)li.HighPart);
}

#ifdef _DEBUG
/*====================================================
Stop
    Debugging function called at each problem: to stop on it
=====================================================*/
void Stop()
{
      DBGMSG((DBGMOD_QM, DBGLVL_WARNING, TEXT("Stop")));
}

/*====================================================
DbgCrash
    Routine is called in crash points for debugging purposes
=====================================================*/
void DbgCrash(int num)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("Crashing at point %d"),num)); \
    if (g_ulCrashLatency)
    {
       Sleep(g_ulCrashLatency);
    }

    abort();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactsink.cpp ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactSink.cpp

Abstract:
    This module implements CIResourceManagerSink object

Author:
    Alexander Dadiomov (AlexDad)

--*/
#include "stdh.h"
#include "Xact.h"

#include "xactsink.tmh"

static WCHAR *s_FN=L"xactsink";


//---------------------------------------------------------------------
// CIResourceManagerSink::CIResourceManagerSink
//---------------------------------------------------------------------

CIResourceManagerSink::CIResourceManagerSink(CResourceManager *pRM)
{
	m_cRefs = 0;
    m_pRM   = pRM;
}


//---------------------------------------------------------------------
// CIResourceManagerSink::~CIResourceManagerSink
//---------------------------------------------------------------------
CIResourceManagerSink::~CIResourceManagerSink(void)
{
	// Do nothing.
}



//---------------------------------------------------------------------
// CIResourceManagerSink::QueryInterface
//---------------------------------------------------------------------
STDMETHODIMP CIResourceManagerSink::QueryInterface(REFIID i_iid, LPVOID *ppv)
{
	*ppv = 0;						// Initialize interface pointer.

    if (IID_IUnknown == i_iid || IID_IResourceManagerSink == i_iid)
	{								// IID supported return interface.
		*ppv = this;
	}

	
	if (0 == *ppv)					// Check for null interface pointer.
	{										
		return ResultFromScode (E_NOINTERFACE);
									// Neither IUnknown nor IResourceManagerSink supported--
									// so return no interface.
	}

	((LPUNKNOWN) *ppv)->AddRef();	// Interface is supported. Increment its usage count.
	
	return S_OK;
}


//---------------------------------------------------------------------
// CIResourceManagerSink::AddRef
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CIResourceManagerSink::AddRef(void)
{
    return ++m_cRefs;				// Increment interface usage count.
}


//---------------------------------------------------------------------
// CIResourceManagerSink::Release
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CIResourceManagerSink::Release(void)
{

	--m_cRefs;						// Decrement usage reference count.

	if (0 != m_cRefs)				// Is anyone using the interface?
	{								// The interface is in use.
		return m_cRefs;				// Return the number of references.
	}

	ASSERT((INT)m_cRefs >= 0);  	// No delete, because we use object statically

	return 0;						// Zero references returned.
}


//---------------------------------------------------------------------
// CIResourceManagerSink::TMDown
//---------------------------------------------------------------------
STDMETHODIMP CIResourceManagerSink::TMDown(void)
{
    DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("RM TMDown")));

    m_pRM->DisconnectDTC();        // inform RM of DTC failure

    return S_OK;				
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactsort.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactSort.cpp

Abstract:
    Transactions Sorter Object

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
#include "Xact.h"
#include "XactSort.h"
#include "XactStyl.h"
#include "cs.h"

#include "xactsort.tmh"

static CCriticalSection g_critSorter;       // provides mutual exclusion for the list
static WCHAR *s_FN=L"xactsort";
                                            // Serves both Prepare and Commit sorters

//--------------------------------------
//
// Class  CXactSorter
//
//--------------------------------------

/*====================================================
CXactSorter::CXactSorter
    Constructor 
=====================================================*/
CXactSorter::CXactSorter(TXSORTERTYPE type)
{
    m_type           = type;                   // Prepare or Commit sorter
    m_ulSeqNum       = 0;                      // Initial last used transaction number
}


/*====================================================
CXactSorter::~CXactSorter
    Destructor 
=====================================================*/
CXactSorter::~CXactSorter()
{
    CS lock(g_critSorter);

    // Cycle for all transactions
    POSITION posInList = m_listSorter.GetHeadPosition();
    while (posInList != NULL)
    {
        CSortedTransaction *pSXact = m_listSorter.GetNext(posInList);
        delete pSXact;
    }

    m_listSorter.RemoveAll();     
}

/*====================================================
CXactSorter::InsertPrepared
    Inserts prepared xaction into the list   
=====================================================*/
void CXactSorter::InsertPrepared(CTransaction *pTrans)
{
    CS lock(g_critSorter);
    CSortedTransaction  *pSXact = new CSortedTransaction(pTrans);

    // In the normal work mode - adding to the end (it is the last prepared xact)
    m_listSorter.AddTail(pSXact);
}

/*====================================================
CXactSorter::RemoveAborted
    Removes aborted xact and  commits what's possible    
=====================================================*/
HRESULT CXactSorter::RemoveAborted(CTransaction *pTrans)
{
    CS lock(g_critSorter);
    HRESULT hr = S_OK;

    // Lookup for the pointed xaction; note all previous unmarked
    BOOL     fUnmarkedBefore = FALSE;
    BOOL     fFound          = FALSE;
    POSITION posInList = m_listSorter.GetHeadPosition();
    while (posInList != NULL)
    {
        POSITION posCurrent = posInList;
        CSortedTransaction *pSXact = m_listSorter.GetNext(posInList);
        
        ASSERT(pSXact);
        if (pSXact->IsEqual(pTrans))
        {
            m_listSorter.RemoveAt(posCurrent);
            ASSERT(!fFound);
            fFound = TRUE;
            delete pSXact;
            continue;
        }

        if (!pSXact->IsMarked())  
        {
            fUnmarkedBefore = TRUE; 
            if (fFound)
            {
                break;
            }
        }
        else if (!fUnmarkedBefore)
        {
            DoCommit(pSXact);
            m_listSorter.RemoveAt(posCurrent);
        }
    }
    return LogHR(hr, s_FN, 10);
}

/*====================================================
CXactSorter::SortedCommit
    Marks xaction as committed and commits what's possible    
=====================================================*/
void CXactSorter::SortedCommit(CTransaction *pTrans)
{
    CS lock(g_critSorter);

    // Lookup for the pointed xaction; note all previous unmarked
    BOOL     fUnmarkedBefore = FALSE,
             fFound          = FALSE;

    POSITION posInList = m_listSorter.GetHeadPosition();
    while (posInList != NULL)
    {
        POSITION posCurrent = posInList;
        CSortedTransaction *pSXact = m_listSorter.GetNext(posInList);
        
        ASSERT(pSXact);
        if (pSXact->IsEqual(pTrans))
        {
            fFound = TRUE;
            pSXact->AskToCommit();      
            if (!fUnmarkedBefore)
            {
                DoCommit(pSXact);
                m_listSorter.RemoveAt(posCurrent);
            }
            continue;
        }

        if (!pSXact->IsMarked())  
        {
            fUnmarkedBefore = TRUE; 
            if (fFound)
            {
                break;
            }
        }
        else if (!fUnmarkedBefore)
        {
            DoCommit(pSXact);
            m_listSorter.RemoveAt(posCurrent);
        }
    }
}


/*====================================================
CXactSorter::DoCommit
      Committes the sorted transaction
=====================================================*/
void CXactSorter::DoCommit(CSortedTransaction *pSXact)
{
    pSXact->Commit(m_type);
    delete pSXact;
}

/*====================================================
CXactSorter::Commit
      Committes the sorted transaction
=====================================================*/
void CSortedTransaction::Commit(TXSORTERTYPE type)
{ 
    ASSERT(m_fMarked);

    switch (type)
    {
    case TS_PREPARE:
        m_pTrans->CommitRequest0(); 
        break;

    case TS_COMMIT:
        m_pTrans->CommitRequest3(); 
        break;

    default:
        ASSERT(FALSE);
        break;
    }
}

// provides access to the crit.section
CCriticalSection &CXactSorter::SorterCritSection()
{
    return g_critSorter;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactstyl.h ===
#ifndef __XACTSTYLE_H__
#define __XACTSTYLE_H__

#include "mqreport.h"

extern void Stop();

#ifdef _DEBUG
#define STOP  Stop()
#else
#define STOP
#endif

#define CHECK_RETURN(point)     \
	    if (FAILED(hr))         \
	    {                       \
            LogMsgHR(hr, s_FN, point); \
            return hr;          \
        }

#define CHECK_RETURN_CODE(code, point) \
	    if (FAILED(hr))         \
	    {                       \
            LogMsgHR(hr, s_FN, point); \
            return code;        \
        }

extern ULONG g_ulCrashPoint;
extern ULONG g_ulCrashLatency;
extern void DbgCrash(int num);

#ifdef _DEBUG
#define CRASH_POINT(num)               \
    if (num==g_ulCrashPoint)           \
    {                                  \
		STOP;						   \
        DbgCrash(num);                 \
    }
#else
#define CRASH_POINT(num)
#endif

#define FILE_NAME_MAX_SIZE	   256


//--------------------------------------
//
// Macro for persistency implementation
//
//--------------------------------------

#define PERSIST_DATA  BOOL ret = FALSE;     DWORD dw

inline void xxWriteFileError()
{
    TCHAR szError[24];
    _stprintf (szError, TEXT("%lut"), GetLastError());
	REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, WRITE_FILE_ERROR, 1, szError));
}

#define SAVE_FIELD(data)                                                            \
    if (!WriteFile(hFile, &data, sizeof(data), &dw, NULL) ||  sizeof(data) != dw)   \
	{																				\
		xxWriteFileError();									  	        	        \
        return ret;                                                                 \
    }

#define SAVE_DATA(data, len)                                                        \
    if (!WriteFile(hFile, data, len, &dw, NULL) ||  len != dw)                      \
	{   																            \
		xxWriteFileError();															\
        return ret;                                                                 \
    }


#define LOAD_FIELD(data)                                                            \
if (!ReadFile(hFile, &data, sizeof(data), &dw, NULL) ||  sizeof(data)!= dw)         \
    {                                                                               \
        return ret;                                                                 \
    }

#define LOAD_DATA(data,len)                                                         \
if (!ReadFile(hFile, &data, len, &dw, NULL) ||  len != dw)                          \
    {                                                                               \
        return ret;                                                                 \
    }

#define LOAD_ALLOCATE_DATA(dataptr,len, type)                                       \
dataptr = (type) new UCHAR[len];                                                    \
if (!ReadFile(hFile, dataptr, len, &dw, NULL) ||  len != dw)                        \
    {                                                                               \
        return ret;                                                                 \
    }

#endif __XACTSTYLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\counter.h ===
#ifndef __COUNTER_H__
#define __COUNTER_H__

#include "rpperf.h"

//
// define class for performance counter
//
class CDCounter
{
public:
    CDCounter();
    ~CDCounter();
    void        AddInstance(LPTSTR pszInstanceName);
    BOOL        SetInstanceCounter(LPTSTR pszInstanceName, DWORD dwCounter, DWORD dwValue);
    BOOL        IncrementInstanceCounter(LPTSTR pszInstanceName, DWORD dwCounter);
    void        AddToCounter(DWORD dwCounter, DWORD dwValue);
    void        IncrementCounter(DWORD dwCounter);
    void        RemoveInstance(LPTSTR pszInstanceName);
    pPerfDataObject GetDataObject();
private:
    int            FindInstance(LPTSTR pszInstanceName);
    PerfDataObject m_Data;
};

//+--------------------------------
//
//  Constructor
//
//+--------------------------------
inline CDCounter::CDCounter()
{
    for (UINT i=0; i < eNumPerfCounters; i++)
    {
        m_Data.PerfCounterArray[i] = 0;
    }

    m_Data.dwMasterInstanceNum = 0;
    for (i=0; i < MAX_INSTANCE_NUM; i++)
    {
        m_Data.NT4MasterArray[i].pszMasterName[0] = _T('\0');
        m_Data.NT4MasterArray[i].dwNameLen = 0;
        for (UINT counter = 0; counter < eNumNT4MasterCounter; counter++)
        {
            m_Data.NT4MasterArray[i].NT4MasterCounterArray[counter] = 0;
        }
    }
}

//+--------------------------------
//
//  Destructor
//
//+--------------------------------
inline CDCounter::~CDCounter()
{
}

//+--------------------------------
//
//  void AddInstance()
//
//+--------------------------------
inline void CDCounter::AddInstance(LPTSTR pszInstanceName)
{
    if (m_Data.dwMasterInstanceNum == MAX_INSTANCE_NUM)
    {
        //
        // we cannot add instance, we don't have place for it
        //
        // LogReplication....
        ASSERT(0);
        return;
    }

    DWORD CurInstance = m_Data.dwMasterInstanceNum;
    m_Data.NT4MasterArray[CurInstance].dwNameLen =
                    min(wcslen(pszInstanceName) + 1, INSTANCE_NAME_LEN) * sizeof(WCHAR);

    wcsncpy (   m_Data.NT4MasterArray[CurInstance].pszMasterName,
                pszInstanceName,
                INSTANCE_NAME_LEN - 1);
    m_Data.NT4MasterArray[CurInstance].pszMasterName[INSTANCE_NAME_LEN - 1] = 0;

    //
    // the next free place
    //
    m_Data.dwMasterInstanceNum ++;
}

//+--------------------------------
//
//  int FindInstance()
//  return -1 if Instance is not found otherwise index in array
//+--------------------------------
inline int CDCounter::FindInstance(LPTSTR pszInstanceName)
{
    TCHAR pszName[INSTANCE_NAME_LEN];
    if (wcslen(pszInstanceName) + 1 < INSTANCE_NAME_LEN)
    {
        wcscpy(pszName, pszInstanceName);
    }
    else
    {
        wcsncpy (   pszName,
                    pszInstanceName,
                    INSTANCE_NAME_LEN - 1);
        pszName[INSTANCE_NAME_LEN - 1] = 0;
    }

    for (UINT i=0; i<MAX_INSTANCE_NUM; i++)
    {
        if (!lstrcmpi (m_Data.NT4MasterArray[i].pszMasterName,pszName))
          return i;
    }
    return -1;
}

//+--------------------------------
//
//  HRESULT SetInstanceCounter()
//
//+--------------------------------
inline BOOL CDCounter::SetInstanceCounter(LPTSTR pszInstanceName, DWORD dwCounter, DWORD dwValue)
{
    int iIndex = FindInstance (pszInstanceName);
    if (iIndex == -1)
    {
        //
        // there is no this instance
        //
        ASSERT(0);
        return FALSE;
    }
    m_Data.NT4MasterArray[iIndex].NT4MasterCounterArray[dwCounter] = dwValue;
    return TRUE;
}

//+--------------------------------
//
//  HRESULT IncrementInstanceCounter()
//
//+--------------------------------
inline BOOL CDCounter::IncrementInstanceCounter(LPTSTR pszInstanceName, DWORD dwCounter)
{
    int iIndex = FindInstance (pszInstanceName);
    if (iIndex == -1)
    {
        //
        // there is no instance for this one.
        // At present (July-1999), we don't support counters for write
        // requests from BSCs, so this FALSE is legitimate.
        //
        return FALSE;
    }
    m_Data.NT4MasterArray[iIndex].NT4MasterCounterArray[dwCounter] ++;
    return TRUE;
}

//+--------------------------------
//
//  void AddToCounter()
//
//+--------------------------------
inline void CDCounter::AddToCounter(DWORD dwCounter, DWORD dwValue)
{
    m_Data.PerfCounterArray[dwCounter] += dwValue;
}

//+--------------------------------
//
//  void IncrementCounter()
//
//+--------------------------------
inline void CDCounter::IncrementCounter(DWORD dwCounter)
{
    m_Data.PerfCounterArray[dwCounter] ++;
}

//+--------------------------------
//
//  void RemoveInstance()
//
//+--------------------------------
inline void CDCounter::RemoveInstance(LPTSTR pszInstanceName)
{

}

//+--------------------------------
//
//  pPerfDataObject GetDataObject()
//
//+--------------------------------
inline pPerfDataObject CDCounter::GetDataObject()
{
    return &m_Data;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactsort.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactSort.h

Abstract:
    Transaction sorter object definition

Author:
    Alexander Dadiomov (AlexDad)

--*/

#ifndef __XACTSORT_H__
#define __XACTSORT_H__

#include "xact.h"

//---------------------------------------------------------------------
// CSortedTransaction:  Transaction Sorter List element
//---------------------------------------------------------------------
class CSortedTransaction
{
public:

     CSortedTransaction(CTransaction *pTrans);
    ~CSortedTransaction();

    void            Commit(TXSORTERTYPE type);   // commits really
    void			CommitRestore();// commits really on recovery stage
    ULONG           SortNum();      // returns sort number
    BOOL            IsMarked();     // returns the mark
    
    BOOL            IsEqual(        // compares with the CTransaction
                        CTransaction *pTrans);      

    void            AskToCommit();    // marks for commit

private:                                        
    CTransaction    *m_pTrans;      // transaction itself
    ULONG           m_ulSortNum;    // seq number of the prepare
    BOOL            m_fMarked;      // marked for commit
};


// Constructor
inline CSortedTransaction::CSortedTransaction(CTransaction *pTrans)
{ 
    m_pTrans    = pTrans; 
    m_pTrans->AddRef();

    m_ulSortNum = pTrans->GetSeqNumber();
    m_fMarked   = FALSE;
}


// Destructor
inline CSortedTransaction::~CSortedTransaction()
{
    m_pTrans->Release();
}

// Real commit for recovery stage
inline void CSortedTransaction::CommitRestore()
{ 
    ASSERT(m_fMarked);
    m_pTrans->CommitRestore0(); 
}

// Get for SortNum index
inline ULONG CSortedTransaction::SortNum() 
{
    return m_ulSortNum;
}

// Get for Marked flag
inline BOOL CSortedTransaction::IsMarked()
{
    return m_fMarked;
}

// Mark for commiting, preserve parameters
inline void CSortedTransaction::AskToCommit()
{
    m_fMarked   = TRUE;
}
 
// Compares with the CTransaction
inline BOOL CSortedTransaction::IsEqual(CTransaction *pTrans)
{
    return (pTrans ==  m_pTrans);
}

//---------------------------------------------------------------------
// CXactSorter: Transaction Sorter Object
//---------------------------------------------------------------------
class CXactSorter
{
public:

    // Construction 
    //
    CXactSorter(TXSORTERTYPE type);
    ~CXactSorter();

    // Main operations
    void InsertPrepared(CTransaction *pTrans);   // inserts prepared xaction
    HRESULT RemoveAborted(CTransaction *pTrans);    // removes aborted xaction
    void    SortedCommit(CTransaction *pTrans);     // marks as committed and  commits what's possible 
    ULONG   AssignSeqNumber();
    CCriticalSection &SorterCritSection();          // provides access to the crit.section

private:
    void DoCommit(CSortedTransaction *pSXact);   // Commit/CommitRestore

    // Data
    //
	CList<CSortedTransaction *, CSortedTransaction *&> 
                        m_listSorter;       // List of prepared transactions
    ULONG               m_ulSeqNum;         // Last used transaction number
    TXSORTERTYPE        m_type;             // Sorter type
};


// Assigns next seq number for the prepared xaction
inline ULONG CXactSorter::AssignSeqNumber()
{
    // BUGBUG:  provide wrap-up
    return m_ulSeqNum++;
}

#endif __XACTSORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactunfr.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactUnfr.h

Abstract:
    Transacted packets Unfreezer object definition
    Unfreezes packets (makes them visible to reader) 
      in the strict numeration sequence

Author:
    Alexander Dadiomov (AlexDad)

--*/

#ifndef __XACTUNFR_H__
#define __XACTUNFR_H__

#include "xactlog.h"

// forward declaration
class CInSequence;

//---------------------------------------------------------------------
// CUnfreezeSorter: Unfreezing packets Sorter Object
//---------------------------------------------------------------------
class CUnfreezeSorter
{
public:

    // Construction 
    //
    CUnfreezeSorter(CInSequence  *pInSeq);
    ~CUnfreezeSorter();

    void SortedUnfreeze(CInSeqFlush *pInSeqFlush,
                        const GUID  *pSrcQMId,
                        const QUEUE_FORMAT *pqdDestQueue);     
    // inserts CInSeqFlush which is ready to be unfreezed

    BOOL IsInPlace(CInSeqFlush *pPkt);
    // checks if the packet is in right place

    void Recover(ULONG ulLastSeqN, LONGLONG  liLastSeqID);
    // absorbs recovery data

    inline ULONG      SeqNReg()  const;
    inline LONGLONG   SeqIDReg() const;

private:
	CList<CInSeqFlush *, CInSeqFlush *&>  m_listUnfreeze;    
        // List of CInSeqFlush ready to be unfreezed but out of sequence

    ULONG     m_ulLastSeqN;            // Last unfreezed packet seq number
    LONGLONG  m_liLastSeqID;           // Last unfreezed packet seq ID

    CInSequence  *m_pInSeq;            // Back pointer to the owning InSequence
};


inline void CUnfreezeSorter::Recover(ULONG ulLastSeqN, LONGLONG  liLastSeqID)
{
    if (liLastSeqID >  m_liLastSeqID)
    {
        m_liLastSeqID = liLastSeqID;
        m_ulLastSeqN  = ulLastSeqN;
    }
    else if (liLastSeqID == m_liLastSeqID && 
		     ulLastSeqN   > m_ulLastSeqN)
    {
        m_ulLastSeqN = ulLastSeqN;
    }
}

inline ULONG CUnfreezeSorter::SeqNReg() const
{
    return m_ulLastSeqN;
}

inline LONGLONG CUnfreezeSorter::SeqIDReg() const
{
    return m_liLastSeqID;
}

//---------------------------------------------------------------------
// VerifyPlace
//      The function for verification incoming message place.
//      Used it 2 places (Incoming Verify and Unfreeze) 
//      which SHOULD be equivalent
//---------------------------------------------------------------------
inline BOOL VerifyPlace(
               ULONG ulSeqN,  
               ULONG ulPrevSeqN, 
               LONGLONG liSeqId,
               ULONG ulLastN,                   
               LONGLONG liLastId)
{
    return(
        // Most normal case: next packet of the current sequence
       (liLastId == liSeqId && 
        ulLastN  <  ulSeqN  &&
        ulLastN  >= ulPrevSeqN ) ||

        // First packet of the new sequence
       (liLastId < liSeqId  && 
        ulPrevSeqN == 0));
}

#endif __XACTUNFR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\qm\xactunfr.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactSort.cpp

Abstract:
    Transactions Sorter Object

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
#include "XactStyl.h"
#include "Xact.h"
#include "Xactlog.h"
#include "XactUnfr.h"
#include "XactIn.h"
#include "cs.h"

#include "xactunfr.tmh"

static WCHAR *s_FN=L"xactunfr";

//--------------------------------------
//
// Class  CUnfreezeSorter
//
//--------------------------------------

/*====================================================
CUnfreezeSorter::CUnfreezeSorter
    Constructor 
=====================================================*/
CUnfreezeSorter::CUnfreezeSorter(CInSequence  *pInSeq)
{
    m_ulLastSeqN  = 0;      // Initial state marks readyness 
    m_liLastSeqID = 0;      //     to get #1 of any seqID 
    m_pInSeq      = pInSeq; // Backpointer

}


/*====================================================
CUnfreezeSorter::~CUnfreezeSorter
    Destructor 
=====================================================*/
CUnfreezeSorter::~CUnfreezeSorter()
{
    // Cycle for all transactions
    POSITION posInList = m_listUnfreeze.GetHeadPosition();
    while (posInList != NULL)
    {
        CInSeqFlush *pInSeqFlush = m_listUnfreeze.GetNext(posInList);

        ASSERT(0); // it should not be so
        pInSeqFlush->Unfreeze();
    }

    m_listUnfreeze.RemoveAll();     
}

/*====================================================
CUnfreezeSorter::SortedUnfreeze
   Inserts CInSeqFlush which is ready to be unfreezed
=====================================================*/
void CUnfreezeSorter::SortedUnfreeze(CInSeqFlush *pNewPkt,
                                     const GUID  *pSrcQMId,
                                     const QUEUE_FORMAT *pqdDestQueue)
{
    ULONG    ulSeqN      = pNewPkt->m_ulSeqN;
    ULONG    ulPrevSeqN  = pNewPkt->m_ulPrevSeqN;
    LONGLONG liSeqID     = pNewPkt->m_liSeqID;

	UNREFERENCED_PARAMETER(ulPrevSeqN);

    // Check if the packet is in-place
    BOOL fInPlace = IsInPlace(pNewPkt);

    if (fInPlace)
    {
        // The packet is in its correct place.
        CRASH_POINT(201);

        // Unfreeze it really
        HRESULT hr = pNewPkt->Unfreeze();
        if (FAILED(hr))
        {
            // No propagation for the number

            // BUGBUG:  we should schedule here the retry!
            return;
        }

        CRASH_POINT(202);

        // Remember it
        m_ulLastSeqN  = ulSeqN;
        m_liLastSeqID = liSeqID;

        // Possibly Unfreeze some of waiting in the list
    	POSITION posInList  = m_listUnfreeze.GetHeadPosition();

        while (posInList != NULL)
        {
            POSITION posCurrent = posInList;
            CInSeqFlush* pInSeqFlush = m_listUnfreeze.GetNext(posInList);
    
            if (IsInPlace(pInSeqFlush))
            {
                m_ulLastSeqN  = pInSeqFlush->m_ulSeqN;
                m_liLastSeqID = pInSeqFlush->m_liSeqID;

                hr = pInSeqFlush->Unfreeze();

                m_listUnfreeze.RemoveAt(posCurrent);
            }
        }

        return;
    }

    // No, the packet is not in-time. Insert it in the packet.

    // In the recovery mode - maintainung the list sorted by prepare seq number
	POSITION posInList  = m_listUnfreeze.GetHeadPosition(),
             posCurrent = NULL;
    BOOL     fAddToTail = TRUE;

    while (posInList != NULL)
    {
        posCurrent = posInList;
        CInSeqFlush* pInSeqFlush = m_listUnfreeze.GetNext(posInList);
    
        if (pInSeqFlush->m_liSeqID  > pNewPkt->m_liSeqID ||

            pInSeqFlush->m_liSeqID == pNewPkt->m_liSeqID &&
            pInSeqFlush->m_ulSeqN   > pNewPkt->m_ulSeqN)
        {
            // We'll insert before this one
            fAddToTail = FALSE;
            break;
        }
   }

   // Add the packet to the list
   if (fAddToTail)
   {
       m_listUnfreeze.AddTail(pNewPkt);
   }
   else
   {
       m_listUnfreeze.InsertBefore(posCurrent, pNewPkt);
   }

   return;
}

/*====================================================
CUnfreezeSorter::IsInPlace
   Checks if the packet came in a correct time
=====================================================*/
BOOL CUnfreezeSorter::IsInPlace(CInSeqFlush *pPkt)
{
    return VerifyPlace(
             pPkt->m_ulSeqN, 
             pPkt->m_ulPrevSeqN,  
             pPkt->m_liSeqID,
             m_ulLastSeqN,                        
             m_liLastSeqID);

        // New sequence might be started by the sender only after getting 
        // seq ack on the last packet ofthe previous one, 
        // so new sequence may come here ONLY after previous was finished
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\dstrnspr.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dstrnspr.h

Abstract:

    DS Transport Class implementation

Author:

    Lior Moshaiov (LiorM)


--*/

#include "mq1repl.h"
#include "qmrepl.h"

#include "dstrnspr.tmh"

/*====================================================

RoutineName
    CDSTransport::Init()

Arguments:

Return Value:

Threads:main


=====================================================*/

HRESULT CDSTransport::Init()
{
    HRESULT hr = MQ_OK ;
    return hr ;
}

/*====================================================

RoutineName
    CDSTransport::CreateConnection()

Arguments:

Return Value:

Threads: main

=====================================================*/

void    CDSTransport::CreateConnection(
                                 IN  const LPWSTR   TargetMachineName,
                                 OUT LPWSTR         *pphConnection)
{
    *pphConnection = NULL ;

    DWORD LenMachine = wcslen(TargetMachineName);
    DWORD Length =
            FN_DIRECT_OS_TOKEN_LEN +            // "OS:"
            LenMachine +                        // "machineName"
            STRLEN(MQIS_QUEUE_NAME) + 2;        // "\\queuename\0"

    LPWSTR lpwFormatName = new WCHAR[Length];

    swprintf(
        lpwFormatName,
        FN_DIRECT_OS_TOKEN      // "OS:"
            L"%s\\"             // "machineName\\"
            MQIS_QUEUE_NAME,    // "queuename\0"
        TargetMachineName
        );

    *pphConnection = lpwFormatName ;
    lpwFormatName = NULL ;

    DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO,
             TEXT("CDSTransport::CreateConnection, %ls"), *pphConnection)) ;
}

/*====================================================

RoutineName
    CDSTransport::SendReplication()

Arguments:

Return Value:

Threads: Scheduler

=====================================================*/

HRESULT CDSTransport::SendReplication( IN  LPWSTR          lpwszDestination,
                                       IN  const unsigned char * pBuffer,
                                       IN  DWORD           dwSize,
                                       IN  DWORD           dwTimeout,
                                       IN  unsigned char   bAckMode,
                                       IN  unsigned char   bPriority,
                                       IN  LPWSTR          lpwszAdminResp )
{
    ASSERT(lpwszDestination) ;
    ASSERT(pBuffer) ;
    ASSERT(dwSize) ;

    if (!lpwszAdminResp)
    {
        lpwszAdminResp = TEXT("") ;
    }


    //
    // We send the AdminQ == ResponceQ because the receive (in recvrepl.cpp)
    // function receives only the responce queue. But we actually need the
    // admin and don't mind about the responce queue. So we pass the admin
    // queue as a responce queue and so we get the admin queue in the receive
    // function. The responce queue is important in the ReceiveAck function
    // (also in recvrepl.cpp). There it is important because the responce queue
    // is the destination queue for re-transmitting the message as a responce
    // for the NACK.
    //
    handle_t hBind = NULL;
    HRESULT hr = GetRpcClientHandle(&hBind) ;
    if (FAILED(hr))
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_GET_RPC_HANDLE,
                             hr ) ;
        return hr ;
    }
    ASSERT(hBind) ;

    try
    {
	    hr = QMSendReplMsg( hBind,
                            lpwszDestination,
                            dwSize,
                            pBuffer,
                            dwTimeout,
                            bAckMode,
                            bPriority,
                            lpwszAdminResp ) ;
    }
    catch(...)
    {
        hr = MQSync_E_RPC_QM_NOT_RESPOND ;
    }
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
           "ERROR(::SendReplication), SendReplMsg(%ls) failed, hr- %lxh"),
                                         lpwszDestination, hr)) ;
    }
    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\dsnbor.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dsnbor.cpp

Abstract:

    DS Neighbor Class implementation

Author:

    Lior Moshaiov (LiorM)


--*/

#include "mq1repl.h"

#include "dsnbor.tmh"

/*====================================================

DestructElements of CDSNeighbor*

Arguments:

Return Value:


=====================================================*/
void AFXAPI DestructElements(CDSNeighbor ** ppNeighbor, int n)
{

    int i;
    for (i=0;i<n;i++)
        delete *ppNeighbor++;

}

/*====================================================

AddNeighbor

Arguments:

Return Value:

=====================================================*/

HRESULT CDSNeighborMgr::AddPSCNeighbor(
                            IN LPWSTR       lpwMachineName,
                            IN const GUID * pguidMachineId,
							IN const CSeqNum & snAcked,
							IN const CSeqNum & snAckedPEC)
{
    LPWSTR  phConnection;

    CS lock(m_cs);


    //
    //      Get a transport connection with this neighbor
    //
    g_pTransport->CreateConnection( lpwMachineName, &phConnection );

    //
    //      Init neighbor object
    //
    CPSCNeighbor *   pNeighbor = new CPSCNeighbor( phConnection,
												   pguidMachineId,
												   snAcked,
												   snAckedPEC);
    ASSERT(pNeighbor) ;
    //
    //      Add a timeout for replication and add into neighbors list
    //
	m_MapNeighborPSCs[ lpwMachineName ] = pNeighbor;
    m_mapNameToNeighbor[ lpwMachineName ] = pNeighbor;
	//
	// The PSC's machine object may have not been replicated yet
	//
	if ( pguidMachineId )
	{
		LPWSTR lpwDupMachineName = DuplicateLPWSTR( lpwMachineName);
		m_MapNeighborIdToName[ *pguidMachineId ] = lpwDupMachineName;
	}

    DBGMSG((DBGMOD_REPLSERV, DBGLVL_TRACE,
                 TEXT("::AddPSCNeighbor(%ls, pGuid- %lxh)"),
                                 lpwMachineName, (DWORD) pguidMachineId)) ;
    NOT_YET_IMPLEMENTED(TEXT("QMSetTimer( SendReplicationMsg )"), s_fTimer) ;
    LPWSTR DupMachineName = DuplicateLPWSTR(lpwMachineName);
    DBG_USED(DupMachineName);
/////QMSetTimer( g_dwInterSiteReplicationInterval, SendReplicationMsg, DupMachineName, 1);

#ifdef _DEBUG
    CDSNeighbor *pNeighborTmp;
    ASSERT(LookupNeighbor(DupMachineName, pNeighborTmp)) ;
    ASSERT(pNeighborTmp == pNeighbor) ;
#endif

    return(MQ_OK);
}

/*====================================================

AddNeighbor

Arguments:

Return Value:

=====================================================*/

HRESULT CDSNeighborMgr::AddBSCNeighbor(
                            IN LPWSTR       lpwMachineName,
                            IN const GUID * pguidMachineId,
							IN time_t       lTimeAcked)
{
    LPWSTR   phConnection;

    CS lock(m_cs);


    //
    //      Get a transport connection with this neighbor
    //
    g_pTransport->CreateConnection( lpwMachineName, &phConnection);

    //
    //      Init neighbor object
    //

    CBSCNeighbor *   pNeighbor = new CBSCNeighbor(phConnection,
                                                  pguidMachineId,
												  lTimeAcked);

    //
    //  Add a timeout for replication and add into neighbors list
    //
	m_MapNeighborBSCs[ lpwMachineName ] = pNeighbor;
    ASSERT( pguidMachineId);   // BSC's machine object should be in DB

    LPWSTR lpwDupMachineName = DuplicateLPWSTR( lpwMachineName);
    m_MapNeighborIdToName[ *pguidMachineId] = lpwDupMachineName;

    m_mapNameToNeighbor[ lpwMachineName ] = pNeighbor;

    NOT_YET_IMPLEMENTED(TEXT("QMSetTimer( SendReplicationMsg )"), s_fTimer) ;
/////////QMSetTimer( g_dwIntraSiteReplicationInterval, SendReplicationMsg, DupMachineName, 0);

	return(MQ_OK);
}


/*====================================================

RoutineName: PropagateUpdate

Arguments:

Return Value:

=====================================================*/

void CDSNeighborMgr::PropagateUpdate( IN unsigned char   ucScope,
                                      IN CDSUpdate      *pUpdate,
                                      IN ULONG           uiFlush )
{
    POSITION        pos;
    CDSNeighbor *   pNeighbor;
    LPWSTR          pwcsName;

    CS lock(m_cs);

    //
    //  Update neighbors according to the replication scope of this object
    //
    if ((ucScope == ENTERPRISE_SCOPE) &&
        (uiFlush == DS_FLUSH_TO_ALL_NEIGHBORS))
    {
        //
        //  update neighbor PSCs
        //
        pos = m_MapNeighborPSCs.GetStartPosition();
        while ( pos != NULL)
        {
            m_MapNeighborPSCs.GetNextAssoc(pos,pwcsName,pNeighbor);

            //
            // Add the update to the neighbor's list of updates
            //
            pNeighbor->AddUpdate(pUpdate);
            //
            // The result of this operation is ignored, at this stage
            // we may not roll-back ( some update may have already been
            // been sent to neighbors).
            // This will be solved by the synchronization algorithm.
            //
        }

    }

    //
    //  update this site BSCs
    //
    pos = m_MapNeighborBSCs.GetStartPosition();
    while ( pos != NULL)
    {
        m_MapNeighborBSCs.GetNextAssoc(pos,pwcsName,pNeighbor);
        //
        // Add the update to the neighbor's list of updates
        //
        pNeighbor->AddUpdate(pUpdate);
        //
        // The result of this operation is ignored, at this stage
        // we may not roll-back ( some update may have already been
        // been sent to neighbors).
        // This will be solved by the synchronization algorithm.
        //
    }
}

/*====================================================

RoutineName: Flush

Arguments:

Return Value:

=====================================================*/

HRESULT CDSNeighborMgr::Flush(IN DWORD  dwOption)
{
    HRESULT         hr1,hr;
    POSITION        pos;
    CDSNeighbor*    pNeighbor;
    LPWSTR pwcsName;

    hr = MQ_OK;

    CS lock(m_cs);

    DWORD dwHelloSize = 0;

    if (dwOption == DS_FLUSH_TO_ALL_NEIGHBORS)
    {
        //
        // At present support only hello to other NT4 PSCs.
        //
        P<unsigned char> pHelloBuf;
        g_pMasterMgr->PrepareHello( TRUE,
                                    &dwHelloSize,
                                    &pHelloBuf );

        //
        //  go over all neighbor PSCs
        //
        pos = m_MapNeighborPSCs.GetStartPosition();
        while ( pos != NULL)
        {
            m_MapNeighborPSCs.GetNextAssoc(pos,pwcsName,pNeighbor);
            //
            // Add the update to the neighbor's list of updates
            //

            hr1 = pNeighbor->SendReplication( DS_REPLICATION_MESSAGE_NORMAL,
                                              dwHelloSize,
                                              pHelloBuf );
            if (FAILED(hr1))
            {
                //
                // we failed on this neighbor but we want to send to all the rest
                //
                hr = hr1;
            }
        }
    }

    //
    //  go over all this site BSCs
    //
    P<unsigned char> pHelloBSCBuf;
    g_pMasterMgr->PrepareHello( FALSE,
                                &dwHelloSize,
                                &pHelloBSCBuf );

    pos = m_MapNeighborBSCs.GetStartPosition();
    while ( pos != NULL)
    {
        m_MapNeighborBSCs.GetNextAssoc(pos,pwcsName,pNeighbor);
        //
        // Add the update to the neighbor's list of updates
        //
        hr1 = pNeighbor->SendReplication( DS_REPLICATION_MESSAGE_NORMAL,
                                          dwHelloSize,
                                          pHelloBSCBuf);
        if (FAILED(hr1))
        {
            //
            // we failed on this neighbor but we want to send to all the rest
            //
            hr = hr1;
        }
    }

    return(hr);
}

/*====================================================

RoutineName
    DeleteMachine()

Arguments:

Return Value:

Threads:Receive

=====================================================*/
HRESULT CDSNeighborMgr::DeleteMachine(IN  LPCWSTR       pwszMachineName,
                                      IN  CONST GUID *  pguidIdentifier)
{
    NOT_YET_IMPLEMENTED(TEXT("DeleteMachine"), s_fSync) ;

#if 0
    HRESULT hr = MQSync_OK ;

    DWORD OldCp = 2;
    PROPID  aOldProp[2];
    PROPVARIANT aOldVar[2];

    aOldProp[0] = PROPID_QM_PATHNAME;
    aOldProp[1] = PROPID_QM_SERVICE;
    aOldVar[0].vt = VT_NULL;
    aOldVar[1].vt = VT_NULL;    

    hr = g_DB.GetProps(MQDS_MACHINE,
                       pwszMachineName,
                       pguidIdentifier,
                       OldCp,
                       aOldProp,
                       aOldVar);
    if (FAILED(hr))
    {
        return(hr);
    }

    AP<WCHAR> pwszName = aOldVar[0].pwszVal;
    DWORD   dwOldService = aOldVar[1].ulVal;

    if (dwOldService == SERVICE_BSC)
    {
        //
        // Remove BSC
        //
        RemoveNeighbor(FALSE,pwszName);

	    REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_MQIS,
                                        DS_REMOVE_BSC, 1, pwszName));
    }
#endif

    return(MQ_OK);
}

/*====================================================

RoutineName:         StopAllReplicationBut

Arguments:

Return Value:

=====================================================*/
HRESULT CDSNeighborMgr::StopAllReplicationBut(LPCWSTR pwcsNewPSC)

{
    POSITION pos;
    CDSNeighbor *pNeighbor;
    LPWSTR pwcsName;
    BOOL fFound = FALSE;

    CS lock(m_cs);

    //
    // Stop replication to all PSCs
    //
    m_MapNeighborPSCs.RemoveAll();

    //
    //  go over all this site BSCs and remove all but the candidate to be promoted
    //
    pos = m_MapNeighborBSCs.GetStartPosition();
    while ( pos != NULL)
    {
        m_MapNeighborBSCs.GetNextAssoc(pos,pwcsName,pNeighbor);

        if(CompareElements(const_cast<LPWSTR*>(&pwcsName),const_cast<LPWSTR*>(&pwcsNewPSC)))
        {
            fFound=TRUE;
        }
        else
        {
            m_MapNeighborBSCs.RemoveKey(pwcsName);
        }
    }
    return((fFound) ? MQ_OK : MQDS_ERROR);
}

/*====================================================

RoutineName:         UpdateMachineId

Arguments:

Return Value:

=====================================================*/
HRESULT CDSNeighborMgr::UpdateMachineId (
                                 IN const GUID * pguidMachineId,
                                 IN LPWSTR       pwcsMachineName)
{
    //
    //  PSC's machine object is created/synced
    //

    //
    //  Is there information about the PSC
    //
    CDSNeighbor * pNeighbor;
    if ( m_MapNeighborPSCs.Lookup( pwcsMachineName, pNeighbor))
    {
        pNeighbor->SetMachineId( pguidMachineId);
        LPWSTR pwcsDupMachineName = DuplicateLPWSTR( pwcsMachineName);
        m_MapNeighborIdToName[ *pguidMachineId] = pwcsDupMachineName;
    }
    //
    //  Else ignore, we are not aware of this PSC (according to the site table).
    //  When a new master will be created, both maps will be updated.
    //

    return(MQ_OK);
}

//+----------------------------------------------------
//
//  HRESULT CommitReplication(CDSMaster *pMaster)
//
//  Terminate the replication cycle for that master. While local DS
//  is queried, replication messages are accumulated for that master.
//  When query terminate, it's time to compute the prevSN value for each
//  message and then send them (all messages) to all neighbors.
//  Note that replication cycle is done for each MasterID at a time.
//  The PEC machine can be the master of sevetal sites, so it has several
//  MasterGuid which is handle. Each site is handled separately.
//
//  pMaster is the object representing the site which is replicated now
//  to NT4 MSMQ1.0 server(s).
//
//+----------------------------------------------------

HRESULT CDSNeighborMgr::CommitReplication( CDSMaster      *pMaster,
                                           CDSUpdateList  *pUpdateList,
                                           CDSNeighbor    *pNeighbor,
                                           HEAVY_REQUEST_PARAMS *pSyncRequestParams,
                                           UINT            uiFlush )
{
    CS lock(m_cs);

    CSeqNum sn ;

    CSeqNum *psnPrev = NULL;
    if (pSyncRequestParams)
    {
        psnPrev = &pSyncRequestParams->snFrom;
    }

    HRESULT hr = pUpdateList->ComputePrevAndPropagate( pMaster,
                                                       pNeighbor,
                                                       uiFlush,
                                                       psnPrev,
                                                       &sn ) ;

    if (pNeighbor)
   {
        pSyncRequestParams->snTo = sn;
        // the purged sn known already to the requestor
        pSyncRequestParams->snKnownPurged = pMaster->GetPurgedSN();	
		pSyncRequestParams->bScope = ENTERPRISE_SCOPE_FLAG;

        hr = pNeighbor->SendReplication( DS_REPLICATION_MESSAGE_FLUSH,
                                         0,
                                         NULL,
                                         pSyncRequestParams);
    }
    else
    {
        //
        // Normal replication cycle, not reply to sync request.
        // Save highest seq-num we sent out in this cycle.
        //
        hr = SaveSeqNum( &sn,
                         pMaster,
                         FALSE) ;   //PEC sends this SN to PSCs and its BSCs => flag fInSN=FALSE
        ASSERT(SUCCEEDED(hr)) ;

        //
        // Send !!!
        //
        hr = Flush(uiFlush);
    }

    return hr ;
}

//+----------------------------------------------------
//
//  BOOL AFXAPI CompareElements()
//
//+----------------------------------------------------

BOOL AFXAPI CompareElements( const LPWSTR* ppMapName1,
                             const LPWSTR* ppMapName2 )
{
    return (_wcsicmp(*ppMapName1, *ppMapName2) == 0);
}

UINT AFXAPI HashKey(LPWSTR pName)
{
    DWORD dwHash = 0;

    while (*pName)
    {
        dwHash = (dwHash << 5) +
                 dwHash        +
                 ((DWORD) CharUpper((LPWSTR) *pName++)) ;
    }

    ASSERT(dwHash != 0) ;
    return dwHash;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\dstrnspr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dstrnspr.h

Abstract:

	DS Transport Class definition
		
Author:

	Lior Moshaiov (LiorM)


--*/
#ifndef __DSTRNSPR_H__
#define __DSTRNSPR_H__

class CDSTransport
{
	public:
		CDSTransport();
  		~CDSTransport();

		HRESULT Init();

		void	CreateConnection( IN  const LPWSTR TargetMachineName,
								  OUT LPWSTR      *pphConnection);

		void	CloseConnection( IN  LPWSTR  pwszhConnection ) ;

        HRESULT  SendReplication(  IN  LPWSTR         lpwszDestination,
                                   IN  const unsigned char * pBuffer,
                                   IN  DWORD           dwSize,
                                   IN  DWORD           dwTimeout,
                                   IN  unsigned char   bAckMode,
                                   IN  unsigned char   bPriority,
                                   IN  LPWSTR         lpwszAdminResp ) ;

		HRESULT	SendUpdateRequest(	IN	HANDLE	hConnection,
									IN	unsigned char * pBuffer,
									IN	DWORD dwSize);

	private:
		CDSTransport(const CDSTransport &other);		 		// no definition - to find out unintentionaly copies
		void	operator=(const CDSTransport &other);			// no definition - to find out unintentionaly copies

};

inline CDSTransport::CDSTransport()
{
};

inline	CDSTransport::~CDSTransport()
{
};

inline void CDSTransport::CloseConnection( IN LPWSTR wszConnection )
{
	delete wszConnection ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\dsnbor.h ===
/*++

Copyright (c) 1995-98  Microsoft Corporation

Module Name:

    dsnbor.h

Abstract:

    DS Neighbor Class definition

Author:

    Lior Moshaiov (LiorM)
    Doron Juster  (DoronJ)  - adapt to MSMQ2.0 replication service.

--*/

#ifndef __DSNBOR_H__
#define __DSNBOR_H__

#include "updtlist.h"
#include "dstrnspr.h"

extern UINT AFXAPI HashKey(LPWSTR pName) ;

extern BOOL AFXAPI CompareElements( const LPWSTR* ppMapName1,
                                    const LPWSTR* ppMapName2 ) ;

extern CDSTransport    *g_pTransport ;

class CDSNeighbor
{
    public:

        friend class CDSNeighborMgr;
        friend class CDSUpdateList;

        CDSNeighbor(LPWSTR         phConnection,
                    BOOL           fInterSite,
                    const GUID *   pguidMachineId);
        virtual ~CDSNeighbor();
        const GUID * GetMachineId() const;

    private:

        HRESULT SendReplication(IN unsigned char bFlush,
                                IN DWORD dwHelloSize,
                                IN unsigned char * pHelloBuf,
                                IN HEAVY_REQUEST_PARAMS* pSyncRequestParams = NULL);
        HRESULT AddUpdate(IN CDSUpdate* pUpdate);
        HRESULT SendMsg(IN const unsigned char * pBuf,
                        IN DWORD dwTotalSize,
                        IN DWORD dwTimeOut,
                        IN unsigned char bPriority);

        void SetMachineId( IN const GUID * pguidMachineId);


        WCHAR           *m_phConnection;
        CDSUpdateList    m_UpdateList;
        GUID             m_guidMachineId;

};

inline  CDSNeighbor::CDSNeighbor(LPWSTR         phConnection,
                                 BOOL           fInterSite,
                                 const GUID *   pguidMachineId) :
                              m_phConnection(phConnection),
                              m_UpdateList(fInterSite)
{
     if ( pguidMachineId)
	 {
		m_guidMachineId = *pguidMachineId;
	 }
	 else
	 {
		m_guidMachineId = GUID_NULL;
	 }
};

inline  CDSNeighbor::~CDSNeighbor()
{
};

inline  HRESULT CDSNeighbor::SendReplication(IN unsigned char bFlush,
                                             IN DWORD dwHelloSize,
                                             IN unsigned char * pHelloBuf,
                                             IN HEAVY_REQUEST_PARAMS* pSyncRequestParams)
{
    return (m_UpdateList.Send(m_phConnection, bFlush, dwHelloSize, pHelloBuf, pSyncRequestParams));
};

inline  HRESULT CDSNeighbor::AddUpdate(IN CDSUpdate* pUpdate)
{
    return(m_UpdateList.AddUpdate(pUpdate));
};

inline HRESULT CDSNeighbor::SendMsg( const unsigned char * pBuf, DWORD dwTotalSize, DWORD dwTimeOut, unsigned char bPriority)
{
    ASSERT(g_pTransport) ;
    return( g_pTransport->SendReplication( m_phConnection,
                                           pBuf,
                                           dwTotalSize,
                                           dwTimeOut,
                                           MQMSG_ACKNOWLEDGMENT_NONE,
                                           bPriority,
                                           NULL)) ;
}

inline const GUID * CDSNeighbor::GetMachineId() const
{
    return( &m_guidMachineId);
}

inline void CDSNeighbor::SetMachineId( IN const GUID * pguidMachineId)
{
    m_guidMachineId = *pguidMachineId;
}

class CPSCNeighbor : public CDSNeighbor
{
    public:

        friend class CDSNeighborMgr;

        CPSCNeighbor(LPWSTR         phConnection,
                     const GUID *   pguidMachineId,
					 const CSeqNum & snAcked,
					 const CSeqNum & snAckedPEC);
        ~CPSCNeighbor();


    private:

		void SetAckedSN( IN const CSeqNum & snAcked);
		void SetAckedSNPEC( IN const CSeqNum & snAcked);

		const CSeqNum & GetAckedSN() const;
		const CSeqNum & GetAckedSNPEC() const;

		CSeqNum			m_snAcked;
		CSeqNum			m_snAckedPEC;

};

inline  CPSCNeighbor::CPSCNeighbor(LPWSTR        phConnection,
								   const GUID *  pguidMachineId,
								   const CSeqNum & snAcked,
								   const CSeqNum & snAckedPEC) :
						CDSNeighbor(phConnection, TRUE, pguidMachineId),
                        m_snAcked(snAcked),
                        m_snAckedPEC(snAckedPEC)	
{
};

inline  CPSCNeighbor::~CPSCNeighbor()
{
};

inline void CPSCNeighbor::SetAckedSN( IN const CSeqNum & snAcked)
{
	m_snAcked = snAcked;
}

inline void CPSCNeighbor::SetAckedSNPEC( IN const CSeqNum & snAcked)
{
	m_snAckedPEC = snAcked;
}

inline const CSeqNum & CPSCNeighbor::GetAckedSN() const
{
	return m_snAcked;
}

inline const CSeqNum & CPSCNeighbor::GetAckedSNPEC() const
{
	return m_snAckedPEC;
}

class CBSCNeighbor : public CDSNeighbor
{
    public:

        friend class CDSNeighborMgr;

        CBSCNeighbor(LPWSTR         phConnection,
                     const GUID *   pguidMachineId,
					 time_t         lAckTime);
        ~CBSCNeighbor();


    private:

		void SetAckTime( IN time_t lTime);
		time_t GetAckTime() const;

        time_t	m_lTimeAcked;
};

//
// note: in MSMQ1.0, the second parameter to CDSNeighbor was FALSE.
// In the NT5 (MSMQ2.0) replication service, we change it to TRUE because
// same calculation of prev seq numbers apply to intersite and intrasite
// replication. In both cases we consider it intersite, because there may
// be holes in the seq numbers. Only the "intersite" code (i.e., when TRUE)
// handle this correctly.
// The problem we overcome is the code in mqutil\bupdate.cpp, line 431, the
// call to sn.Decrement. This is not possible in NT5, as there will always
// be holes in the seq-numbers which are always derived from DS usn.
//
inline  CBSCNeighbor::CBSCNeighbor(LPWSTR         phConnection,
                                   const GUID *   pguidMachineId,
								   time_t lTimeAcked) :
                          CDSNeighbor(phConnection, TRUE, pguidMachineId),
                          m_lTimeAcked(lTimeAcked)
{
};

inline  CBSCNeighbor::~CBSCNeighbor()
{
};

inline void CBSCNeighbor::SetAckTime( IN time_t lTime)
{
	m_lTimeAcked = lTime;
}

inline time_t CBSCNeighbor::GetAckTime() const
{
	return m_lTimeAcked;
}

//+--------------------------------
//
//  class CDSNeighborMgr
//
//+--------------------------------

class CDSNeighborMgr
{
    public:
        CDSNeighborMgr();
        ~CDSNeighborMgr();

        HRESULT AddPSCNeighbor(IN LPWSTR       lpwMachineName,
							   IN const GUID * pguidMachineId,
							   IN const CSeqNum & psnAcked,
							   IN const CSeqNum & psnAckedPEC);

        HRESULT AddBSCNeighbor(IN LPWSTR       lpwMachineName,
							   IN const GUID * pguidMachineId,
							   IN time_t		lTimeAck);

        void RemoveNeighbor(BOOL IsPSC,
                               LPWSTR pwszName);

        HRESULT SendMsg(IN LPWSTR pwcsNeighborName,
                        IN const unsigned char * pBuf,
                        IN DWORD dwTotalSize,
                        IN DWORD dwTimeOut,
                        IN unsigned char bPriority);

        void PropagateUpdate(IN unsigned char   ucScope,
                             IN CDSUpdate      *pUpdate,
                             IN ULONG           uiFlash ) ;

        HRESULT Flush(IN DWORD dwOption);

        HRESULT DeleteMachine(  IN  LPCWSTR          pwcsSiteName,
                                IN  CONST GUID *     pguidIdentifier);
        HRESULT StopAllReplicationBut( LPCWSTR  pwcsNewPSC);

        BOOL    IsAlreadyPsc( LPCWSTR  pwcsNewPSC);

        BOOL    IsMQISServer( IN const GUID * pguid);

        HRESULT UpdateMachineId ( IN const GUID * pguidMachineId,
                                  IN LPWSTR       pwcsMachineName);

        void GetPSCAcks(IN  LPWSTR pwszName,
						OUT CSeqNum * psnAcked,
						OUT CSeqNum * psnAckedPEC);

        HRESULT CommitReplication( CDSMaster      *pMaster,
                                   CDSUpdateList  *pUpdateList,
                                   CDSNeighbor    *pNeighbor,
                                   HEAVY_REQUEST_PARAMS *pSyncRequestParams,
                                   UINT           uiFlush = DS_FLUSH_TO_ALL_NEIGHBORS) ;

        BOOL    LookupNeighbor(IN   LPCWSTR pwszName,
                               OUT  CDSNeighbor*&   pNeighbor);

        POSITION GetStartPosition();
        void GetNextNeighbor(   POSITION *ppos,
                                CDSNeighbor **ppNeighbor);

        LPCWSTR  GetName(IN const CDSNeighbor * pNeighbor);

    private:		

        CCriticalSection    m_cs;
        CMap< LPWSTR, LPWSTR, class CDSNeighbor *, class CDSNeighbor * >  m_MapNeighborPSCs;
        CMap< LPWSTR, LPWSTR, class CDSNeighbor *, class CDSNeighbor * >  m_MapNeighborBSCs;
        CMap< GUID, const GUID&, LPCWSTR, LPCWSTR> m_MapNeighborIdToName;
        CMap<LPWSTR, LPWSTR, CDSNeighbor*, CDSNeighbor*&>m_mapNameToNeighbor;
};

inline  CDSNeighborMgr::CDSNeighborMgr()
{
};

inline  CDSNeighborMgr::~CDSNeighborMgr()
{
};

inline  POSITION CDSNeighborMgr::GetStartPosition()
{
    return (m_mapNameToNeighbor.GetStartPosition());
}

inline void CDSNeighborMgr::GetNextNeighbor(   POSITION *ppos,
                                               CDSNeighbor **ppNeighbor)
{
    LPWSTR pwcsName;
    m_mapNameToNeighbor.GetNextAssoc(*ppos, pwcsName, *ppNeighbor);
}

inline  BOOL CDSNeighborMgr::LookupNeighbor(IN   LPCWSTR pwszName,
                               OUT  CDSNeighbor*&   pNeighbor)
{
    CS lock(m_cs);
    if( m_MapNeighborPSCs.Lookup(const_cast<LPWSTR>(pwszName), pNeighbor))
    {
        return(TRUE);
    }
    else
    {
        if( m_MapNeighborBSCs.Lookup(const_cast<LPWSTR>(pwszName), pNeighbor))
        {
            return(TRUE);
        }
    }

    //
    // This is a legitimate case, when sending write-reply to a Windows 2000
    // DS server. Such server are not cached and not kept in the lookup map.
    // See rpwrtreq.cpp, ReceiveWriteReplyMessage()
    //
    return(FALSE);

};

inline BOOL    CDSNeighborMgr::IsAlreadyPsc( LPCWSTR  pwcsNewPSC)
{
    CDSNeighbor*   pNeighbor;

    CS lock(m_cs);
    return( m_MapNeighborPSCs.Lookup(const_cast<LPWSTR>(pwcsNewPSC), pNeighbor));
}

inline  BOOL CDSNeighborMgr::IsMQISServer( const GUID * pguid)
{
    LPWSTR pwcsName;

    CS lock(m_cs);
    return( m_MapNeighborIdToName.Lookup( *pguid, pwcsName));
}

inline HRESULT CDSNeighborMgr::SendMsg( IN LPWSTR pwcsNeighborName,
                                        IN const unsigned char * pBuf,
                                        IN DWORD dwTotalSize,
                                        IN DWORD dwTimeOut,
                                        IN unsigned char bPriority)
{
    CS lock(m_cs);

    CDSNeighbor *pNeighbor;

    if( LookupNeighbor( pwcsNeighborName, pNeighbor))
    {
        return(pNeighbor->SendMsg( pBuf, dwTotalSize, dwTimeOut, bPriority));
    }
    else
    {
        return(MQDS_UNKNOWN_SOURCE);
    }
}

inline void CDSNeighborMgr::RemoveNeighbor(BOOL IsPSC,
                                               LPWSTR pwszName)

{
    CS lock(m_cs);
    CDSNeighbor * pNeighbor;

    //
    //  go over all neighbor PSCs
    //
    if (IsPSC)
    {
        if( m_MapNeighborPSCs.Lookup( pwszName, pNeighbor))
        {
            if ( *pNeighbor->GetMachineId() != GUID_NULL)
            {
                m_MapNeighborIdToName.RemoveKey( *pNeighbor->GetMachineId());
            }
        }
        m_MapNeighborPSCs.RemoveKey(pwszName);
    }
    else
    {
        if ( m_MapNeighborBSCs.Lookup( pwszName, pNeighbor))
        {
            if ( *pNeighbor->GetMachineId() != GUID_NULL)
            {
                m_MapNeighborIdToName.RemoveKey( *pNeighbor->GetMachineId());
            }
        }
        m_MapNeighborBSCs.RemoveKey(pwszName);
    }

}

inline void CDSNeighborMgr::GetPSCAcks(IN  LPWSTR pwszPSCName,
									   OUT CSeqNum * psnAcked,
									   OUT CSeqNum * psnAckedPEC)

{
    CS lock(m_cs);
    CDSNeighbor * pNeighbor;

    //
    //  go over all neighbor PSCs
    //
    if( m_MapNeighborPSCs.Lookup( pwszPSCName, pNeighbor))
    {
		CPSCNeighbor * pPSCNeighbor = (CPSCNeighbor *) pNeighbor;
		*psnAcked = pPSCNeighbor->GetAckedSN();
		*psnAckedPEC = pPSCNeighbor->GetAckedSNPEC();
    }
	else
	{
		//
		// not found - return 0 (no ack yet)
		//
		psnAcked->SetSmallestValue();
		psnAckedPEC->SetSmallestValue();
	}
}

inline	LPCWSTR  CDSNeighborMgr::GetName(IN const CDSNeighbor * pNeighbor)
{
	const GUID * pguidMachineId = pNeighbor->GetMachineId();
	LPCWSTR	pName=NULL;
    m_MapNeighborIdToName.Lookup( *pguidMachineId, pName);
	return(pName);
}

void AFXAPI DestructElements(CDSNeighbor ** ppNeighbor, int n);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\exstub.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    exstub.cpp

Abstract:
    Ex stub function

Author:
    Ilan Herbst (ilanh) 19-July-2000

Environment:
    Platform-independent,

--*/

#include "mq1repl.h"
#include "mqmacro.h"
#include "ex.h"

#include "exstub.tmh"

VOID                             
ExSetTimer(
    CTimer* pTimer,
    const CTimeDuration& Timeout
    )
{
	DBG_USED(pTimer);
	DBG_USED(Timeout);
    ASSERT(("Replication service dont suppose to call ExSetTimer", 0));
    return;
}


BOOL
ExCancelTimer(
    CTimer* pTimer
    )
{
	DBG_USED(pTimer);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\master.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    master.h

Abstract:
    DS master class

    This class includes all the information about another DS master (=PSC)

Author:

    Ronit Hartmann (ronith)
    Doron Juster   (DoronJ) - adapt for NT5 replication service.

--*/

#ifndef __MASTER_H__
#define __MASTER_H__

#include "update.h"
#include "seqnum.h"

extern DWORD  g_dwPurgeBufferSN;

typedef struct 
{ 
    CSeqNum snFrom;
    CSeqNum snTo;
} SYNC_REQUEST_SNS;

//+-----------------------
//
//  class CDSMaster
//
//+-----------------------

class CDSMaster  :public CInterlockedSharedObject
{
public:

    friend class CDSMasterMgr;

    CDSMaster( LPWSTR          pwcsPathName,
               const GUID    * pguidMasterId,
               __int64         i64Delta,
               const CSeqNum & snLSN,
               const CSeqNum & snLSNOut,
               const CSeqNum & snAllowedPurge,
			   PURGESTATE	   Sync0State,
               CACLSID       * pcauuidSiteGates,
               BOOL            fNT4Site);

    ~CDSMaster();

    const CSeqNum & IncrementLSN( CSeqNum *     psnPrevInterSiteLSN,
                                  unsigned char ucScope,
                                  CSeqNum       *pNewValue = NULL ) ;

    void DecrementLSN( IN unsigned char ucScope,
                       IN const CSeqNum & snPreviousInter);

    const CSeqNum & GetLSN();
    const CSeqNum & GetLSNOut();
    const CSeqNum & GetInterSiteLSN();
    const CSeqNum & GetMissingWindowLSN();
        
    SYNC_REQUEST_SNS * GetSyncRequestSNs(IN GUID *pNeighborId);
    
    void SetSyncRequestSNs(IN const GUID *pNeighborId,
                           IN SYNC_REQUEST_SNS *pSyncRequestSNs);

    void RemoveSyncRequestSNs(IN GUID *pNeighborId);
    BOOL IsProcessPreMigSyncRequest (IN const GUID *pNeighborId);

    void  SetNt5PurgeSn() ;

    const GUID *    GetMasterId() const;
    LPWSTR          GetPathName();

    __int64         GetDelta() const ;
    BOOL            GetNT4SiteFlag() const ;
    void            SetNT4SiteFlag(BOOL fNT4SiteFlag);

    const CSeqNum & GetPurgedSN();    
    const PURGESTATE & GetSync0State();

private:

	void    Init( LPWSTR    pwcsPathName,
                  CACLSID * pcauuidSiteGates );

    HRESULT AddUpdate(IN CDSUpdate* pUpdate,
                      IN BOOL   fCheckNeedFlush);

    HRESULT Send(IN const unsigned char *   pBuf,
                 IN DWORD                   dwSize,
                 IN DWORD                   dwTimeOut,
                 IN unsigned char           bAckMode,
                 IN unsigned char           bPriority,
                 IN LPWSTR                  lpwszAdminRespQueue);

    void    Hello(  IN const unsigned char* pName,
                    IN const CSeqNum & snHelloLSN,
                    IN const CSeqNum & snAllowedPurge);

    HRESULT ReceiveSyncReplyMessage(
                                    IN DWORD                dwCount,
                                    IN const CSeqNum &      snUpper,
                                    IN const CSeqNum &      snPurge,
									IN DWORD dwCompleteSync0,
                                    IN const unsigned char *pBuf,
                                    IN DWORD                dwTotalSize);
    HRESULT ReceiveAlreadyPurgedMessage(IN const CSeqNum &      snPurged);
    void    SendSyncRequest();
	void	SendPSCAck(GUID *pGuidMaster);
    void ChangePSC(IN LPWSTR pwszNewPSCName);

    HRESULT HandleInSyncUpdate( IN CDSUpdate *pUpdate,
                                IN BOOL fCheckNeedFlush);
    void    AddToNeighbors( IN CDSUpdate *pUpdate);
    HRESULT CheckWaitingList();
    HRESULT AddOutOfSyncUpdate(CDSUpdate *pUpdate);

    void    ReplaceSiteGates(IN const CACLSID * pcauuidSiteGates);
    void    GetSiteGates( OUT CACLSID * pcauuidSiteGates);
    void    GetSiteIdentifier( OUT GUID * pguidSite);
   
    const CSeqNum & GetAllowedPurgeSN();

    GUID                m_guidMasterId;
    LPWSTR              m_pwcsPathName;
    LPWSTR              m_phConnection;
    CCriticalSection    m_cs;

    //
    // for NT5 sites only m_snLSNOut is changed
    //
    CSeqNum             m_snLSN;        // for NT4 master: it is LSN was received from 
                                        // NT4 master
    
    CSeqNum             m_snLSNOut;     // it is the last SN was sent to BSCs
                                        // of the NT5 masters about this NT4 master
    CSeqNum         m_snInterSiteLSN; // In Use only when I am the owner, and not setup mode
    CSeqNum         m_snMissingWindow;
    BOOL            m_fScheduledSyncReply;
    CList<CDSUpdate *, CDSUpdate *&>    m_UpdateWaitingList;
    CSeqNum         m_snPurged;
    CSeqNum         m_snAllowedPurge;
    CSeqNum         m_snLargestSNEver;
	PURGESTATE		m_Sync0State;
    CACLSID         m_cauuidSiteGates;  // In use only if this server is the PEC ( site-gates consistency)

/*
    CSeqNum         m_snSyncRequestFromSN;  // for NT4 master: is is SN received from NT4 master
                                            // in sync request about pre-migrated objects; FromSN
    CSeqNum         m_snSyncRequestToSN;    // for NT4 master: is is SN received from NT4 master
                                            // in sync request about pre-migrated objects; ToSN
*/    
    CMap< GUID, const GUID&, SYNC_REQUEST_SNS *, SYNC_REQUEST_SNS *>  m_MapNeighborIdToSyncReqSN;    

    __int64         m_i64Delta ;
        //
        // This is a delta between USN numbers used in NT5 DS and seq-numbers
        // used in MQIS. The delta is added to NT5 usn to get the MQIS
        // numbers.
        //

    BOOL            m_fNT4Site;
        //
        // if flag is set, this site is NT4 site
        //
};


//=========================
//
//  MasterCount
//
//=========================

class CDSMasterCount
{
public:
    CDSMasterCount();
    ~CDSMasterCount();
	void Set(CDSMaster * pMaster);

private:
	CDSMaster * m_pMaster;
};

//=====================================================================
//=====================================================================
//
//  MasterMgr
//
//=====================================================================
//=====================================================================

class CDSMasterMgr
{
public:
    CDSMasterMgr();
    ~CDSMasterMgr();

    HRESULT AddPSCMaster(   IN LPWSTR            pwcsPathName,
                            IN const GUID *      pguidMasterId,
                            IN const __int64     i64Delta,
                            IN const CSeqNum &   snMaxLSNIn,
                            IN const CSeqNum &   snMaxLSNOut,
                            IN const CSeqNum &   snAllowedPurge,
							IN PURGESTATE        Sync0State,
                            IN const CSeqNum &   snAcked,
                            IN const CSeqNum &   snAckedPEC,
                            IN CACLSID *         pcauuidSiteGates,
                            IN BOOL              fNT4Site) ;

    HRESULT Send(   IN const GUID * pguidMasterId,
                    IN const unsigned char *    pBuf,
                    IN DWORD         dwSize,
                    IN DWORD         dwTimeOut,
                    IN unsigned char bAckMode,
                    IN unsigned char bPriority,
                    IN LPWSTR        wszAdminQueue);

    HRESULT AddUpdate( IN CDSUpdate* pUpdate,
                       IN BOOL       fCheckNeedFlush );

    HRESULT ReceiveSyncRequestMessage(
                        IN HEAVY_REQUEST_PARAMS * pSyncRequestParams) ;

    HRESULT ReceiveSyncReplyMessage(
                                    IN const GUID * pguidMasterId,
                                    IN DWORD dwCount,
                                    IN const CSeqNum &  snUpper,
                                    IN const CSeqNum &  snPurge,
									IN DWORD dwCompleteSync0,
                                    IN const unsigned char *   pBuf,
                                    IN DWORD           dwTotalSize);

    HRESULT ReceiveAlreadyPurgedMessage(
                                    IN const GUID * pguidMasterId,
                                    IN const CSeqNum &  snPurged);

    void Hello( IN const GUID * pguidMasterId,
                IN const unsigned char* pName,
                IN const CSeqNum & snHelloLSN,
                IN const CSeqNum & snAllowedPurge);

    HRESULT CreateSite(   IN    DWORD                   cp,
                          IN    PROPID                  aProp[],
                          IN    PROPVARIANT             apVar[],
                          IN    const GUID *            pguidSiteId);

    HRESULT SetSyncSite(IN  BOOL        fSync,
                        IN  LPCWSTR     pwcsSiteName,
                        IN  CONST GUID* pguidIdentifier,
                        IN  DWORD       cp,
                        IN  PROPID      aProp[],
                        IN  PROPVARIANT apVar[],
                        OUT BOOL *      pfNeedFlush,
                        OUT   LPWSTR * ppwcsOldPSC);
    HRESULT SetSyncEnterprise(  IN    LPCWSTR       pwszEnterpriseName,
                                IN    CONST GUID*   pguidIdentifier,
                                IN    DWORD         cp,
                                IN    PROPID        aProp[],
                                IN    PROPVARIANT   apVar[],
                                OUT   BOOL *        pfNeedFlush);
    HRESULT DeleteSite(  IN  LPCWSTR                pwcsSiteName,
                          IN    CONST GUID *        pguidIdentifier,
                          IN    BOOL                fMyObject);

    HRESULT GetMasterLSN(IN const GUID & guidMasterId,
						 OUT CSeqNum * psnLSN);

    void    PrepareHello( IN DWORD dwIsInterSite,
                          OUT DWORD* pdwSize,
                          OUT unsigned char ** ppBuf);

    void    ReplaceSiteGates(   IN  const GUID *  pguidMasterId,
                                IN const CACLSID * pcauuidSiteGates);

    void    GetSiteGates(       IN  const GUID * pguidMasterId,

                                OUT CACLSID * pcauuidSiteGates);
    BOOL    IsKnownSite ( IN const GUID * pguidSiteId);

    HRESULT MQISStats(MQISSTAT * * ppStat,LPDWORD pdwStatSize);

	void	TryPurge(IN const GUID & guidMasterId);

    HRESULT GetNT4SiteFlag (  IN const GUID *pguidSiteId,
                              OUT BOOL      *pfNT4SiteFlag);

    HRESULT SetNT4SiteFlag (  IN const GUID * pguidSiteId,
                              IN const BOOL fNT4SiteFlag);

    POSITION GetStartPosition();
    void GetNextMaster(   POSITION *ppos,
                          CDSMaster **ppMaster);

    HRESULT GetPathName (IN const   GUID    *pguidSiteId,
                         OUT        LPWSTR  *ppwcsPathName);

    BOOL IsProcessingPreMigSyncRequest (IN const GUID *guidMasterId,
                                        IN const GUID *pNeighborId);

private:

    CCriticalSection    m_cs;
    CMap<GUID, const GUID&, CDSMaster*, CDSMaster*&>m_mapIdToMaster;
};


extern void AFXAPI DestructElements(CDSMaster ** ppMaster, int n);

#define SCHED_SYNC_REPLY    0
#define MQIS_SCHED_START_SYNC0     1
#define MQIS_SCHED_COMPLETE_SYNC0  2
#define MQIS_SCHED_TRY_PURGE	   3

class CHeavyRequestHandler
{
public:
    CHeavyRequestHandler();
    ~CHeavyRequestHandler();

    void Add(HEAVY_REQUEST_PARAMS* pRequest);
    void Next();

private:

    CCriticalSection    m_cs;
    CList<HEAVY_REQUEST_PARAMS*, HEAVY_REQUEST_PARAMS*>m_HeavyRequestList;
};

//+--------------------------------
//
//  class CDSNativeNT5SiteMgr
//
//+--------------------------------

class CDSNativeNT5SiteMgr
{
    public:
        CDSNativeNT5SiteMgr();
        ~CDSNativeNT5SiteMgr();

        void    AddNT5NativeSite (IN const GUID * pguid, IN const LPCWSTR pwszSiteName );
        BOOL    IsNT5NativeSite( IN const GUID * pguid );
        void    RemoveNT5NativeSite (IN const GUID * pguid);
        POSITION GetStartPosition();
        void    GetNextNT5Site(POSITION *ppos, GUID *pSiteId);
        int     GetCount();

    private:
        CCriticalSection    m_cs;             
        CMap< GUID, const GUID&, LPCWSTR, LPCWSTR> m_MapSiteIdToName;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\mastrmgr.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: mastrmgr.cpp

Abstract: Manager of Master objects.

Author:

    Doron Juster  (DoronJ)   20-Apr-98

--*/

#include "mq1repl.h"

#include "mastrmgr.tmh"

//+---------------------------------------
//
//  ReceiveSyncRequestMessage()
//
//+---------------------------------------

HRESULT CDSMasterMgr::ReceiveSyncRequestMessage(
                        IN HEAVY_REQUEST_PARAMS * pSyncRequestParams)
{
    HRESULT hr = MQSync_OK ;
    CDSNeighbor  *pNeighbor = NULL ;
    if (! g_pNeighborMgr->LookupNeighbor(
                          pSyncRequestParams->pwszRequesterName,
                          pNeighbor ))
    {
        hr = MQSync_E_UNKNOWN_NEIGHBOR ;
        LogReplicationEvent( ReplLog_Error,
                             hr,
                             pSyncRequestParams->pwszRequesterName ) ;
        return hr ;
    }
    ASSERT(pNeighbor) ;

    BOOL    fPec = FALSE ;
    GUID   *pMasterGuid = &pSyncRequestParams->guidSourceMasterId ;

    CDSMaster    * pMaster;
  	CDSMasterCount MasterCount;

    {
        CS lock (m_cs);
        if (memcmp(pMasterGuid, &g_PecGuid, sizeof(GUID)) == 0)
        {
            pMaster = g_pThePecMaster ;
            fPec = TRUE ;
        }
        else if (!m_mapIdToMaster.Lookup( *pMasterGuid, pMaster))
        {
            DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, _T("Received Sync Request message from an unknown source %!guid!"), pMasterGuid));
            return MQSync_E_UNKOWN_SOURCE ;
        }
        MasterCount.Set(pMaster);
    }

    TCHAR tszFromUsn[ SEQ_NUM_BUF_LEN ] ;    
    BOOL fIsPreMig = FALSE;
    SeqNumToUsn( &pSyncRequestParams->snFrom,
                 pMaster->GetDelta(),
                 TRUE,
                 &fIsPreMig,
                 tszFromUsn) ;

    IncrementUsn(tszFromUsn) ;

    TCHAR tszToUsn[ SEQ_NUM_BUF_LEN ] ;
    TCHAR *ptszToUsn = NULL ;
    if (! pSyncRequestParams->snTo.IsInfiniteLsn() )
    {
        SeqNumToUsn( &pSyncRequestParams->snTo,
                     pMaster->GetDelta(),
                     FALSE,
                     &fIsPreMig,
                     tszToUsn) ;
        ptszToUsn = tszToUsn ;
    }

    if (fIsPreMig)
    {
        //
        // it is sync request of pre-migration objects or sync0 request
        //
        SYNC_REQUEST_SNS *pSyncReqSNs = new SYNC_REQUEST_SNS;
        pSyncReqSNs->snFrom = pSyncRequestParams->snFrom;
        pSyncReqSNs->snTo = pSyncRequestParams->snTo;
        pMaster->SetSyncRequestSNs (pNeighbor->GetMachineId(), pSyncReqSNs);
    }

    if (fPec)
    {
        hr = ReplicatePECObjects( tszFromUsn,
                                  ptszToUsn,
                                  pNeighbor,
                                  pSyncRequestParams ) ;
    }
    else
    {
        //
        // replicate objects without the MasterID attribute only if
        // sync request is asked for the PEC site. If BSC ask for sync
        // for another master then replicate only that master objects.
        //
        BOOL fReplicateNoId = (pMaster == g_pMySiteMaster) ;

        hr = ReplicateSitesObjects(   pMaster,
                                      tszFromUsn,
                                      ptszToUsn,
                                      pNeighbor,
                                      pSyncRequestParams,
                                      fReplicateNoId ) ;
    }

    return hr ;
}

/*====================================================

RoutineName
    ReceiveSyncReplyMessage()

Arguments:
    IN unsigned char *pBuf  : stream of sync updates
    IN DWORD        TotalSize: size of stream in bytes

Return Value:

Threads:Receive

=====================================================*/

HRESULT CDSMasterMgr::ReceiveSyncReplyMessage(
                                 IN const GUID          * pguidMasterId,
                                 IN DWORD                 dwCount,
                                 IN const CSeqNum       & snUpper,
                                 IN const CSeqNum       & snPurge,
				    			 IN DWORD                 dwCompleteSync0,
                                 IN const unsigned char * pBuf,
                                 IN DWORD                 dwTotalSize)
{
    //
    //  find the source master object.
    //  The master object tracks sequence numbers, initiaites sync requests
    //  when required, and forwards the update to relevant neighbors
    //

    CDSMaster    * pMaster;
  	CDSMasterCount MasterCount;
    {
        CS lock (m_cs);
        if (!m_mapIdToMaster.Lookup( *pguidMasterId, pMaster))
        {
            DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, _T("Received Sync Reply message from an unknown source %!guid!"), pguidMasterId));
            return MQSync_E_UNKOWN_SOURCE ;
        }
        MasterCount.Set(pMaster);
    }

    return (pMaster->ReceiveSyncReplyMessage( dwCount,
                                              snUpper,
											  snPurge,
											  dwCompleteSync0,
                                              pBuf,
                                              dwTotalSize ));
}

//+-------------------------------------
//
//  HRESULT CDSMasterMgr::Send()
//
//+-------------------------------------

HRESULT CDSMasterMgr::Send( IN const GUID           *pguidMasterId,
                            IN const unsigned char  *pBuf,
                            IN DWORD                 dwSize,
                            IN DWORD                 dwTimeOut,
                            IN unsigned char         bAckMode,
                            IN unsigned char         bPriority,
                            IN LPWSTR                lpwszAdminQueue )
{
    CDSMasterCount  MasterCount;
    CDSMaster      *pMaster=NULL;
    {
        CS lock(m_cs);

        if (!m_mapIdToMaster.Lookup( *pguidMasterId, pMaster))
        {
            DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, _T("Attempt to send to an unknown master %!guid!"), pguidMasterId));
            return MQDS_UNKNOWN_SOURCE ;
        }
        MasterCount.Set(pMaster);
    }

    HRESULT hr = pMaster->Send( pBuf,
                        dwSize,
                        dwTimeOut,
                        bAckMode,
                        bPriority,
                        lpwszAdminQueue ) ;
    return hr ;
}

//+-------------------------------------
//
//  void PrepareHello()
//
//+-------------------------------------

void CDSMasterMgr::PrepareHello( IN DWORD dwToPSC,
                                 OUT DWORD* pdwSize,
                                 OUT unsigned char ** ppBuf)
{
    *pdwSize = 0;
    *ppBuf = NULL;

    unsigned short usCount = 0;
    DWORD dwSize = 0;
    P<unsigned char> pBuf;
    unsigned char* ptr;
    GUID   guidMasterId;
    CSeqNum snLSN;

    if (dwToPSC)
    {
        //
        // maximal allocation: get number of all masters + hello of PEC info + 
        // get number of all native NT5 sites
        //
        P<unsigned char> pAllMastersBuf;
        usCount = numeric_cast<unsigned short> (m_mapIdToMaster.GetCount() + 1 + g_pNativeNT5SiteMgr->GetCount());
        dwSize = (DWORD) (usCount) * (sizeof(GUID) + 2 * snLSN.GetSerializeSize()) +
                    sizeof(unsigned short) + g_dwMachineNameSize;
        pAllMastersBuf = new unsigned char[dwSize];

        ptr = pAllMastersBuf;
        memcpy(ptr,&usCount,sizeof(unsigned short));
        ptr+=sizeof(unsigned short);

        memcpy(ptr,g_pwszMyMachineName,g_dwMachineNameSize);
        ptr+= g_dwMachineNameSize;
        
        //
        //  Make sure we are not in the middle of write operation.
        //  Sequence number may be incremented and then decremented
        //
/////////////////    CS lock(g_csSerializeWriteOperation);
        ASSERT( g_pThePecMaster);
        ASSERT( g_pMySiteMaster);
               
        guidMasterId = PEC_MASTER_ID;
        memcpy(ptr,&guidMasterId,sizeof(GUID));
        ptr+=sizeof(GUID);
        snLSN = g_pThePecMaster->GetLSNOut( );
        ptr += snLSN.Serialize( ptr);
        snLSN = g_pThePecMaster->GetPurgedSN( );
        ptr += snLSN.Serialize( ptr);       

        //
        // loop for each site with fNT4SiteFlag = FALSE
        //   
        POSITION  pos = g_pMasterMgr->GetStartPosition();
        DWORD dwNT5MasterCount = 1;     //the first is PEC info

        while ( pos != NULL)
        {
            CDSMaster *pMaster = NULL;        
            g_pMasterMgr->GetNextMaster(&pos, &pMaster);
            if (pMaster->GetNT4SiteFlag () == FALSE)
            {
                dwNT5MasterCount++;
               
                memcpy(ptr, pMaster->GetMasterId(), sizeof(GUID));
                ptr+=sizeof(GUID);

                snLSN = pMaster->GetInterSiteLSN( );
                ptr += snLSN.Serialize( ptr);

                snLSN = pMaster->GetPurgedSN( );
                ptr += snLSN.Serialize( ptr);                                        
            }            
        }     
        
        //
        // loop for all native NT5 sites
        //
        pos = g_pNativeNT5SiteMgr->GetStartPosition();
        while (pos != NULL)
        {
            GUID guidSite;
            g_pNativeNT5SiteMgr->GetNextNT5Site(&pos, &guidSite);
            dwNT5MasterCount++;
        
            memcpy(ptr, &guidSite, sizeof(GUID));
            ptr+=sizeof(GUID);
            //
            // take all PEC's site master data: we don't have real seq number for
            // native NT5 sites; send something in order to allow purge on NT4 servers
            //            
            snLSN = g_pMySiteMaster->GetInterSiteLSN( );
            ptr += snLSN.Serialize( ptr);

            snLSN = g_pMySiteMaster->GetPurgedSN( );
            ptr += snLSN.Serialize( ptr);    

        }

        //
        // put exact number of NT5 masters
        //
        ptr = pAllMastersBuf;
        memcpy(ptr,&dwNT5MasterCount,sizeof(unsigned short));   
        
        //
        // allocation for NT5 masters only
        //
        dwSize = (DWORD) (dwNT5MasterCount) * (sizeof(GUID) + 2 * snLSN.GetSerializeSize()) +
                    sizeof(unsigned short) + g_dwMachineNameSize;
        pBuf = new unsigned char[dwSize];
        memcpy (pBuf, pAllMastersBuf, dwSize);        
    }
    else
    {
        CList<CDSMaster*, CDSMaster*>   MasterList;

        {

            CS lock (m_cs);
            //
            // usCount is number of all masters in Enterprise + PEC master
            //            
            usCount = numeric_cast<unsigned short> (m_mapIdToMaster.GetCount() + 1);

            dwSize = (DWORD) (usCount) * (sizeof(GUID) + 2 * snLSN.GetSerializeSize()) +
                        sizeof(unsigned short) + g_dwMachineNameSize;
            pBuf = new unsigned char[dwSize];
            ptr = pBuf;

            memcpy(ptr,&usCount,sizeof(unsigned short));
            ptr+=sizeof(unsigned short);

            memcpy(ptr,g_pwszMyMachineName,g_dwMachineNameSize);
            ptr+= g_dwMachineNameSize;

            POSITION pos = m_mapIdToMaster.GetStartPosition();
            CDSMaster * pMaster;
            unsigned short i=0;
            while ( pos != NULL)
            {
                i++;
                ASSERT(i<usCount);

                m_mapIdToMaster.GetNextAssoc(pos, guidMasterId, pMaster);
                pMaster->AddRef();
                MasterList.AddTail(pMaster);
            }
        }

        //
        // add PEC Info to Hello
        //
        guidMasterId = PEC_MASTER_ID;
        memcpy(ptr,&guidMasterId,sizeof(GUID));
        ptr+=sizeof(GUID);
        snLSN = g_pThePecMaster->GetLSNOut( );
        ptr += snLSN.Serialize( ptr);
        snLSN = g_pThePecMaster->GetPurgedSN( );
        ptr += snLSN.Serialize( ptr);       

        //
        // add info of all masters
        //
        POSITION pos = MasterList.GetHeadPosition();
        CDSMaster * pMaster;

        while(pos != NULL)
        {
            pMaster = MasterList.GetNext(pos);

            memcpy(ptr,pMaster->GetMasterId(),sizeof(GUID));
            ptr+=sizeof(GUID);

            snLSN = pMaster->GetLSNOut( );
            ptr += snLSN.Serialize( ptr);
			if (pMaster->GetNT4SiteFlag () == FALSE)
			{
				//
				// I am the NT5 master, I already purged to GetPurgedSN
				//
				snLSN = pMaster->GetPurgedSN( );
			}
			else
			{
				//
				// Propagating Allow purge of other masters
				//
				snLSN = pMaster->GetAllowedPurgeSN( );
			}

            ptr += snLSN.Serialize( ptr);
        }                
    }

    *pdwSize = dwSize;
    *ppBuf = pBuf.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\master.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    master.cpp

Abstract:

    DS master class

    This class includes all the information about another DS master (=PSC)

Author:

    Shai Kariv  (shaik)  05-Apr-2001

--*/

#include "mq1repl.h"
#include "master.h"

#include "master.tmh"

//
// Class CDSMaster
//

CDSMaster::CDSMaster( LPWSTR         pwcsPathName,
                            const GUID    * pguidMasterId,
                            __int64         i64Delta,
                            const CSeqNum & snLSN,
                            const CSeqNum & snLSNOut,
                            const CSeqNum & snAllowedPurge,
			                PURGESTATE	    Sync0State,
							CACLSID *       pcauuidSiteGates,
                            BOOL            fNT4Site)
                            :
                         m_guidMasterId(*pguidMasterId),
                         m_i64Delta(i64Delta),
                         m_snLSN(snLSN),
                         m_snLSNOut(snLSNOut),
                         m_snInterSiteLSN(snLSNOut),
                         m_fScheduledSyncReply(FALSE),
                         m_snAllowedPurge(snAllowedPurge),
                         m_snLargestSNEver(snLSN),
                         m_Sync0State(Sync0State),
                         m_phConnection(NULL),
                         m_fNT4Site(fNT4Site)
{
	Init(pwcsPathName, pcauuidSiteGates);

    //
    // In MSMQ1.0, m_snPurged was initialized from MQIS tables. This field
    // indicated the highest seq-number of each master which was purged on
    // local MQIS database.
    // On NT5, purging is done by DS itself. MSMQ do not have any control
    // on that. So we'll arbitrarily set the "purge" number to equal (sn - PurgeBuffer).
    //
    if (!m_fNT4Site)
    {
        //
        // it is NT5 site, we can init m_snPurged for Hello purposes
        //
        SetNt5PurgeSn();
    }

    //
    // set initial value of SyncRequestSN
    //
    /*
    m_snSyncRequestFromSN.SetInfiniteLSN();
    m_snSyncRequestToSN.SetInfiniteLSN();
    */
}

//+------------------------------
//
//  CDSMaster::SetNt5PurgeSn()
//
//+------------------------------

void  CDSMaster::SetNt5PurgeSn()
{
    ASSERT(!m_fNT4Site) ;

    m_snPurged = m_snInterSiteLSN ;
    m_snPurged -= g_dwPurgeBufferSN ;
}

//+------------------------------
//
//  CDSMaster::IncrementLSN()
//
//+------------------------------

const CSeqNum & CDSMaster::IncrementLSN(
                                      CSeqNum *     psnPrevInterSiteLSN,
                                      unsigned char ucScope,
                                      CSeqNum       *pNewValue )
{
    CS  lock(m_cs);

    if (pNewValue)
    {
        m_snLSNOut = *pNewValue ;
    }
    else
    {
        ASSERT(0) ;
    }

    if (psnPrevInterSiteLSN != NULL)
    {
        *psnPrevInterSiteLSN = m_snInterSiteLSN;
    }
    if (ucScope == ENTERPRISE_SCOPE)
    {
        m_snInterSiteLSN = m_snLSNOut;
    }

    return(m_snLSNOut);
}

void CDSMaster::DecrementLSN( IN unsigned char ucScope,
                                     IN const CSeqNum & snPreviousInter)
{
    CS  lock(m_cs);
    if (ucScope==ENTERPRISE_SCOPE)
    {
        m_snInterSiteLSN = snPreviousInter;
    }
    m_snLSN.Decrement();
}


const CSeqNum & CDSMaster::GetLSN()
{
    CS lock(m_cs);
    return(m_snLSN);
}

const CSeqNum & CDSMaster::GetLSNOut()
{
    CS lock(m_cs);
    return(m_snLSNOut);
}

const CSeqNum &  CDSMaster::GetInterSiteLSN()
{
    CS lock(m_cs);
    return( m_snInterSiteLSN);
}

const CSeqNum &  CDSMaster::GetMissingWindowLSN()
{
    CS lock(m_cs);
    return( m_snMissingWindow);
}

const CSeqNum & CDSMaster::GetPurgedSN()
{
    CS lock(m_cs);
    return(m_snPurged);
}

SYNC_REQUEST_SNS * CDSMaster::GetSyncRequestSNs(IN GUID *pNeighborId)
{
    CS lock(m_cs);

    SYNC_REQUEST_SNS *pSyncReq;
    if (m_MapNeighborIdToSyncReqSN.Lookup( *pNeighborId, pSyncReq))
    {
        return pSyncReq;
    }     
    else
    {
        //
        // the element is not found = it was sync request about post-migrated objects//
        //        
        return NULL;
    }
}

void CDSMaster::SetSyncRequestSNs(IN const GUID *pNeighborId,
                                         IN SYNC_REQUEST_SNS *pSyncRequestSNs)
{
    CS lock(m_cs);
    
    m_MapNeighborIdToSyncReqSN.SetAt( *pNeighborId, pSyncRequestSNs);    
}

void CDSMaster::RemoveSyncRequestSNs (IN GUID *pNeighborId)
{
    CS lock(m_cs);

    SYNC_REQUEST_SNS *pSyncReq;
    if (m_MapNeighborIdToSyncReqSN.Lookup( *pNeighborId, pSyncReq ))
    {
        delete pSyncReq;
        m_MapNeighborIdToSyncReqSN.RemoveKey( *pNeighborId );        
    }
    else
    {
        //
        // the element is not found
        //
        ASSERT(0);
    }    
}

BOOL CDSMaster::IsProcessPreMigSyncRequest (IN const GUID *pNeighborId)
{
    CS lock(m_cs);
    SYNC_REQUEST_SNS *pSyncReq;
    if (m_MapNeighborIdToSyncReqSN.Lookup( *pNeighborId, pSyncReq ))
    {
        return TRUE;       
    }
    else
    {
        return FALSE;
    }    
}

const CSeqNum & CDSMaster::GetAllowedPurgeSN()
{
    CS lock(m_cs);
    return(m_snAllowedPurge);
}

const PURGESTATE & CDSMaster::GetSync0State()
{
    CS lock(m_cs);
    return (m_Sync0State);
}

const GUID * CDSMaster::GetMasterId() const
{
    return(&m_guidMasterId);
}


LPWSTR CDSMaster::GetPathName()
{
    CS lock(m_cs);
    return( m_pwcsPathName);
}

void    CDSMaster::ReplaceSiteGates( IN const CACLSID * pcauuidSiteGates)
{
    CS lock(m_cs);

    delete []  m_cauuidSiteGates.pElems;
    if ( pcauuidSiteGates)
    {
        m_cauuidSiteGates.cElems = pcauuidSiteGates->cElems;
        m_cauuidSiteGates.pElems = pcauuidSiteGates->pElems;
    }
    else
    {
        m_cauuidSiteGates.cElems = 0;
        m_cauuidSiteGates.pElems = NULL;
    }
}

void    CDSMaster::GetSiteGates( OUT CACLSID * pcauuidSiteGates)
{   //
    //  The caller must copy the returned guids, if it is
    //  not gurantied that the master will not be deleted
    //
    CS lock(m_cs);

    *pcauuidSiteGates =  m_cauuidSiteGates;
}

void    CDSMaster::GetSiteIdentifier( OUT GUID * pguidSite)
{
    *pguidSite = m_guidMasterId;
}

__int64  CDSMaster::GetDelta() const
{
    return m_i64Delta ;
}

BOOL     CDSMaster::GetNT4SiteFlag() const
{
    return m_fNT4Site;
}

void     CDSMaster::SetNT4SiteFlag(IN BOOL   fNT4SiteFlag)
{
    m_fNT4Site = fNT4SiteFlag;
}


//
// Class CDSMasterCount
//

CDSMasterCount::CDSMasterCount() : m_pMaster(NULL)
{
}

void CDSMasterCount::Set(IN CDSMaster * pMaster)
{
	m_pMaster = pMaster;
	pMaster->AddRef();
}

CDSMasterCount::~CDSMasterCount()
{
	if(m_pMaster != NULL)
	{
		int ref = m_pMaster->Release();
		if (ref == 0)
		{
			delete m_pMaster;
		}
	}
}


//
// Class CDSMasterMgr
//

CDSMasterMgr::CDSMasterMgr()
{
}

CDSMasterMgr::~CDSMasterMgr()
{
}

HRESULT CDSMasterMgr::AddUpdate(IN CDSUpdate* pUpdate,
                                        IN BOOL fCheckNeedFlush)
{
    CDSMaster * pMaster=NULL;
	CDSMasterCount MasterCount;
    {

        CS lock(m_cs);

        if (!m_mapIdToMaster.Lookup(*pUpdate->GetMasterId(), pMaster))
        {
            DBGMSG((DBGMOD_DS, DBGLVL_WARNING, L"Warning -  receive an update from unknown source %!guid!", pUpdate->GetMasterId()));

            delete pUpdate;
            return(MQDS_UNKNOWN_SOURCE);
        }
        MasterCount.Set(pMaster);
    }
    return(pMaster->AddUpdate(pUpdate,fCheckNeedFlush));
}

void CDSMasterMgr::Hello(const GUID * pguidMasterId,
								 const unsigned char* pName,
								 const CSeqNum & snHelloLSN,
								 const CSeqNum & snAllowedPurge)
{
    CDSMaster * pMaster=NULL;
	CDSMasterCount MasterCount;

    {
        CS lock(m_cs);

        if (!m_mapIdToMaster.Lookup( *pguidMasterId, pMaster))
        {
            
            BOOL fNT4 = ReadDebugIntFlag(TEXT("NT4MQIS"), 0) ;
            if (fNT4)
            {
                GUID nullGuid ;
                memset(&nullGuid, 0, sizeof(GUID)) ;

                if (memcmp(&nullGuid,
                           const_cast<GUID*> (pguidMasterId),
                           sizeof(GUID)) == 0)
                {
                    //
                    // That's OK.
                    // In debug mode on NT4, where we're NOT the PEC,
                    // we'll get hello messages from a PEC, for the PEC
                    // objects (users, CNs). Ignore.
                    //
                    return ;
                }
            }

            DBGMSG((DBGMOD_REPLSERV, DBGLVL_WARNING, L"Warning - Hello from unknown source %!guid!", pguidMasterId));
            
            return;
        }
        MasterCount.Set(pMaster);
    }
    pMaster->Hello(pName, snHelloLSN, snAllowedPurge);
}

void  CDSMasterMgr::ReplaceSiteGates(   IN  const GUID *   pguidMasterId,
                                IN const CACLSID * pcauuidSiteGates)
{
    CDSMaster * pMaster=NULL;
	CDSMasterCount MasterCount;

    {
        CS lock(m_cs);

        if (!m_mapIdToMaster.Lookup( *pguidMasterId, pMaster))
        {
            DBGMSG((DBGMOD_DS,DBGLVL_WARNING,"LWarning - ReplaceSiteGates of unknown master %!guid!", pguidMasterId));
            return;
        }
        MasterCount.Set(pMaster);
    }

    pMaster->ReplaceSiteGates( pcauuidSiteGates);
}

void CDSMasterMgr::GetSiteGates( IN  const GUID * pguidMasterId,
                                        OUT CACLSID * pcauuidSiteGates)
{
    CDSMaster * pMaster=NULL;
	CDSMasterCount MasterCount;

    {
        CS lock(m_cs);

        if (!m_mapIdToMaster.Lookup( *pguidMasterId, pMaster))
        {
            DBGMSG((DBGMOD_DS, DBGLVL_WARNING, L"Warning - GetSiteGates of unknown master %!guid!", pguidMasterId));
            return;
        }
        MasterCount.Set(pMaster);
    }
    pMaster->GetSiteGates( pcauuidSiteGates);
}

HRESULT CDSMasterMgr::GetMasterLSN( IN  const GUID & guidMasterId,
                                           OUT CSeqNum * psnLSN)
{
    CDSMaster * pMaster=NULL;
	CDSMasterCount MasterCount;

    {
        CS lock(m_cs);

        if (!m_mapIdToMaster.Lookup( guidMasterId, pMaster))
        {
            DBGMSG((DBGMOD_DS, DBGLVL_WARNING, L"Warning -  GetSiteGates of unknown master %!guid!", &guidMasterId));
		    return(MQ_ERROR);
        }
        MasterCount.Set(pMaster);
    }

    *psnLSN = pMaster->GetLSN();
	return(MQ_OK);
}

BOOL    CDSMasterMgr::IsKnownSite ( IN const GUID * pguidSiteId)
{
    CDSMaster * pMaster=NULL;

    CS lock(m_cs);

    return(m_mapIdToMaster.Lookup( *pguidSiteId, pMaster));
}

HRESULT  CDSMasterMgr::GetNT4SiteFlag ( IN     const GUID *pguidSiteId,
                                               OUT    BOOL       *pfNT4SiteFlag )
{
    CDSMaster * pMaster=NULL;
    CDSMasterCount MasterCount;
    {
        CS lock(m_cs);

        if (!m_mapIdToMaster.Lookup( *pguidSiteId, pMaster))
        {
            DBGMSG((DBGMOD_DS, DBGLVL_WARNING, L"Warning - GetNT4SiteFlag of unknown site %!guid!", pguidSiteId));
            return MQ_ERROR;
        }
        MasterCount.Set(pMaster);
    }
    *pfNT4SiteFlag = pMaster->GetNT4SiteFlag();
    return MQ_OK;
}

HRESULT  CDSMasterMgr::SetNT4SiteFlag   ( IN     const GUID  *pguidSiteId,
                                                 IN     const BOOL  fNT4SiteFlag )
{
    CDSMaster * pMaster=NULL;
    CDSMasterCount MasterCount;
    {
        CS lock(m_cs);

        if (!m_mapIdToMaster.Lookup( *pguidSiteId, pMaster))
        {
            DBGMSG((DBGMOD_DS, DBGLVL_WARNING, L"Warning - SetNT4SiteFlag of unknown site %!guid!", pguidSiteId));
            return MQ_ERROR;
        }
        MasterCount.Set(pMaster);
    }
    pMaster->SetNT4SiteFlag(fNT4SiteFlag);
    return MQ_OK;
}

POSITION CDSMasterMgr::GetStartPosition()
{
    return (m_mapIdToMaster.GetStartPosition());
}

void CDSMasterMgr::GetNextMaster(POSITION *ppos, CDSMaster **ppMaster)
{
    GUID guidMasterId;
    m_mapIdToMaster.GetNextAssoc(*ppos, guidMasterId, *ppMaster);
}

HRESULT CDSMasterMgr::GetPathName (  IN const   GUID    *pguidSiteId,
                                            OUT        LPWSTR  *ppwcsPathName)
{
    CDSMaster * pMaster=NULL;
    CDSMasterCount MasterCount;
    {
        CS lock(m_cs);

        if (!m_mapIdToMaster.Lookup( *pguidSiteId, pMaster))
        {
            DBGMSG((DBGMOD_DS, DBGLVL_WARNING, L"Warning - GetPathName of unknown site %!guid!", pguidSiteId));
            return MQ_ERROR;
        }
        MasterCount.Set(pMaster);
    }
    *ppwcsPathName = pMaster->GetPathName();
    return MQ_OK;
}

BOOL CDSMasterMgr::IsProcessingPreMigSyncRequest (IN const GUID *pguidMasterId,
                                                         IN const GUID *pNeighborId)
{
    CDSMaster * pMaster=NULL;
    CDSMasterCount MasterCount;
    {
        CS lock(m_cs);

        if (!m_mapIdToMaster.Lookup( *pguidMasterId, pMaster))
        {
            DBGMSG((DBGMOD_DS, DBGLVL_WARNING, L"Warning - IsProcessingPreMigSyncRequest of unknown site %!guid!", pguidMasterId));
            return FALSE;
        }
        MasterCount.Set(pMaster);
    }
    return pMaster->IsProcessPreMigSyncRequest(pNeighborId);    
}


//
// Class CHeavyRequestHandler
//

CHeavyRequestHandler::CHeavyRequestHandler()
{
}

CHeavyRequestHandler::~CHeavyRequestHandler()
{
}

void CHeavyRequestHandler::Add(HEAVY_REQUEST_PARAMS* pRequest)
{
    CS lock(m_cs);
    m_HeavyRequestList.AddTail(pRequest);
}


//
// Class CDSNativeNT5SiteMgr
//

CDSNativeNT5SiteMgr::CDSNativeNT5SiteMgr()
{
};

CDSNativeNT5SiteMgr::~CDSNativeNT5SiteMgr()
{
};

BOOL CDSNativeNT5SiteMgr::IsNT5NativeSite( const GUID * pguid)
{    
    LPWSTR pwcsName;

    CS lock(m_cs);
    return( m_MapSiteIdToName.Lookup( *pguid, pwcsName));    
}

void CDSNativeNT5SiteMgr::AddNT5NativeSite (IN const GUID * pguid, 
                                                    IN const LPCWSTR pwszSiteName)
{   
    CS lock(m_cs);    
    m_MapSiteIdToName[ *pguid ] = pwszSiteName ;
}

void CDSNativeNT5SiteMgr::RemoveNT5NativeSite (IN const GUID * pguid)
{
    CS lock(m_cs);
    m_MapSiteIdToName.RemoveKey( *pguid );
}

POSITION CDSNativeNT5SiteMgr::GetStartPosition()
{
    return (m_MapSiteIdToName.GetStartPosition());
}

void CDSNativeNT5SiteMgr::GetNextNT5Site(   OUT POSITION *ppos,
                                                   OUT GUID  *pSiteId)
{
    LPWSTR pwcsName;
    m_MapSiteIdToName.GetNextAssoc(*ppos, *pSiteId, pwcsName);
}

int CDSNativeNT5SiteMgr::GetCount()
{    
    return m_MapSiteIdToName.GetCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\qmrepl_c_.c ===
#pragma warning(push, 3)
#include <qmrepl_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\mq1repl.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: mq1repl.cpp

Abstract: Entry point for MSMQ replication service.
          This service run on NT5 machines and perform DirSync between
          NT5 DS and MSMQ1.0 MQIS.

Author:

    Doron Juster  (DoronJ)   01-Feb-98

--*/

#include "mq1repl.h"

#include "mq1repl.tmh"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\migrepl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: migrepl.h

Abstract: definitions which are common to the migration tool and the
          replication service.

Author:

    Doron Juster  (DoronJ)   18-Mar-98

--*/

//+-----------------------------------------------
//
// Definitions used in seq numbers ini file.
//
//+-----------------------------------------------

//
// In this file we keep the seq-numbers of other MSMQ1.0 PSCs.
// It is created by the migration tool and used by the replication service.
//
#define SEQ_NUMBERS_FILE_NAME  TEXT("mqseqnum.ini")

//
// In this section we register the seq-numbers most recently received
// from other MSMQ1.0 PSCs. (recieved by replication from other PSCs to us).
// The objects with these numbers are already in NT5 DS, i.e., the
// replication service first update the DS and then update the seq number
// in the ini file.
//
#define RECENT_SEQ_NUM_SECTION_IN  TEXT("MostRecentSeqNumbersIn")

//
// In this section we register the seq-numbers most recently sent by PEC server
// to its BSCs about itself, all other NT5 masterss and MSMQ1.0 PSCs. 
// The objects with these numbers are already in NT5 DS, i.e., the
// replication service first update the DS and then update the seq number
// in the ini file.
//
#define RECENT_SEQ_NUM_SECTION_OUT  TEXT("MostRecentSeqNumbersOut")

//
// In this section we register the highest seq-number of each MSMQ1.0 PSC
// while running the migration tool. This is necessary for replication TO
// MSMQ1.0 PSCs and BSCs.
// Once set by the migration tool, the entries under this section are not
// changed anymore.
//
#define MIGRATION_SEQ_NUM_SECTION  TEXT("HighestMigSeqNumbers")

//
// In this section we register the delta between MQIS seqnumbers and DS
// USN numbers for each MSMQ master. This is necessary for replication to
// NT4 BSCs (where NT5 server replicate objects of other NT4 masters to its
// own NT4 BSCs). The delta values are used to convert from seq-numbers to
// usn and vice-versa.
// The delta is added to the USN to get the seq-num. The delta is subtracted
// from seq-number to get USNs.
//
#define MIGRATION_DELTA_SECTION  TEXT("MigDelta")

//
// In this section we register all CNs of MSMQ1.0
// Once set by the migration tool, the entries under this section are not
// changed anymore.
//
#define MIGRATION_IP_SECTION        TEXT("IP CNs")
#define MIGRATION_IPX_SECTION       TEXT("IPX CNs")
#define MIGRATION_FOREIGN_SECTION   TEXT("Foreign CNs")

#define MIGRATION_CN_KEY            TEXT("CN")

#define MIGRATION_IP_CNNUM_SECTION          TEXT("IP CN Number")
#define MIGRATION_IPX_CNNUM_SECTION         TEXT("IPX CN Number")
#define MIGRATION_FOREIGN_CNNUM_SECTION     TEXT("Foreign CN Number")

#define MIGRATION_CNNUM_KEY     TEXT("CNNumber")

//
// In this section we save all Windows 2000 Site Links
// Entries set by migration tool and after restoring of these site links in DS
// they will be removed from file
//
#define MIGRATION_SITELINKNUM_SECTON	TEXT("SiteLink Number")
#define MIGRATION_SITELINKNUM_KEY		TEXT("SiteLinkNumber")

#define MIGRATION_NONRESTORED_SITELINKNUM_SECTON	TEXT("Non Restored SiteLink Number")

#define MIGRATION_SITELINK_SECTION		TEXT("SiteLink")

#define MIGRATION_SITELINK_PATH_KEY				TEXT("Path")
#define MIGRATION_SITELINK_PATHLENGTH_KEY		TEXT("PathLength")
#define MIGRATION_SITELINK_NEIGHBOR1_KEY		TEXT("Neighbor1")
#define MIGRATION_SITELINK_NEIGHBOR2_KEY		TEXT("Neighbor2")
#define MIGRATION_SITELINK_SITEGATE_KEY			TEXT("SiteGate")
#define MIGRATION_SITELINK_SITEGATENUM_KEY		TEXT("SiteGateNum")
#define MIGRATION_SITELINK_SITEGATELENGTH_KEY	TEXT("SiteGateLength")
#define MIGRATION_SITELINK_COST_KEY				TEXT("Cost")
#define MIGRATION_SITELINK_DESCRIPTION_KEY		TEXT("Description")
#define MIGRATION_SITELINK_DESCRIPTIONLENGTH_KEY	TEXT("DescriptionLength")

//
// For cluser mode: in this section we'll save all PSCs and all PEC's BSCs
//
#define MIGRATION_ALLSERVERS_SECTION			TEXT("All Servers To Update")
#define MIGRATION_ALLSERVERS_NAME_KEY			TEXT("ServerName")

#define MIGRATION_ALLSERVERSNUM_SECTION			TEXT("Server Number")
#define MIGRATION_ALLSERVERSNUM_KEY				TEXT("AllServerNumber")

#define MIGRATION_NONUPDATED_SERVERNUM_SECTION	TEXT("Non Updated Server Number")

//
// To replicate all site with names those were changed by migtool
//
#define MIGRATION_CHANGED_NT4SITE_NUM_SECTION  TEXT("Site Number")
#define MIGRATION_CHANGED_NT4SITE_NUM_KEY      TEXT("SiteNumber")

#define MIGRATION_CHANGED_NT4SITE_SECTION      TEXT("All Sites With Changed Properties")
#define MIGRATION_CHANGED_NT4SITE_KEY          TEXT("Site")

//
// Save new created site link id to add connector machine as site gate later
//
#define MIGRATION_CONNECTOR_FOREIGNCN_NUM_SECTION  TEXT("Foreign CN Number for Connector")
#define MIGRATION_CONNECTOR_FOREIGNCN_NUM_KEY    TEXT("ForeignCNNumber")
#define MIGRATION_CONNECTOR_FOREIGNCN_KEY        TEXT("ForeignCN")

//
// Save all machines with invalid name which were not migrated
//
#define MIGRATION_MACHINE_WITH_INVALID_NAME     TEXT("Non Migrated Machines With Invalid Name")

//
// These registry values keep track of highest USN numbers on local DS.
// FirstHighestUsnMig is the value before migration.
// LastHighestUsnMig is the value just after completing migration.
// This value is necessary when a MSMQ1.0 server ask sync0. Local DS will
// be queried for object with USN above this value.
// HighestUsnRepl is the highest value handled by last replication cycle
// from local replication service to MSMQ1.0 PSCs and BSCs.
//
#define FIRST_HIGHESTUSN_MIG_REG        TEXT("Migration\\FirstHighestUsnMig")
#define LAST_HIGHESTUSN_MIG_REG         TEXT("Migration\\LastHighestUsnMig")
#define HIGHESTUSN_REPL_REG             TEXT("Migration\\HighestUsnRepl")

//
// This flag is set to 1 by the migration tool if it ran in recovery mode.
// The replication service checks it on first time it run and if it was set
// it replicate all PEC's object to NT4 MQIS. 
// Then the replication service delete it.
//
#define AFTER_RECOVERY_MIG_REG          TEXT("Migration\\AfterRecovery")

//
// This flag is set to 1 by the migration tool.
// The replication service uses it on first time it run to replicate all
// existing NT5 sites to NT4 MQIS. then the replication service reset it
// to 0.
//
#define FIRST_TIME_REG    TEXT("Migration\\FirstTime")

//
// This flag is set to 1 by Migration tool after removing
// migration tool from Welcome screen. 
// Migration tool needs this flag to prevent unnecessary warning message box 
// when tool is executed more than once.
//
#define REMOVED_FROM_WELCOME	TEXT("Migration\\RemovedFromWelcome")

//
// In special mode (recovery or cluster) we don't have MasterId key after
// the setup, we create this key in our Migration section
//
#define MIGRATION_MQIS_MASTERID_REGNAME  TEXT("Migration\\MasterId")

//
// In cluster mode we have to save guid of former PEC (PEC on cluster)
//
#define MIGRATION_FORMER_PEC_GUID_REGNAME   TEXT("Migration\\FormerPECGuid")

//
// This is the size of buffers to hold the printable representation of
// a seq-number. in both MQIS and NT5 DS, a seq-number is a 8 bytes bunary
// value.
//
#define  SEQ_NUM_BUF_LEN  32

//---------------------------------
//
// Definitions for LDAP queries
//
//---------------------------------

#define  LDAP_COMMA            (TEXT(","))

#define  LDAP_ROOT             (TEXT("LDAP://"))

#define  CN_CONFIGURATION_W    L"CN=Configuration,"
#define  CN_SERVICES_W         L"CN=Services,"
#define  CN_SITES_W            L"CN=Sites,"
#define  CN_USERS_W            L"CN=Users,"

#ifdef UNICODE
#define  CN_SITES           CN_SITES_W
#define  CN_SERVICES        CN_SERVICES_W
#define  CN_CONFIGURATION   CN_CONFIGURATION_W
#define  CN_USERS           CN_USERS_W
#else
#endif

#define CN_USERS_LEN           (sizeof(CN_USERS) / sizeof(TCHAR))

#define MQUSER_ROOT            L"OU=MSMQ Users,"
#define MQUSER_ROOT_LEN        (sizeof(MQUSER_ROOT) / sizeof(TCHAR))

#define  SITES_ROOT            (CN_SITES CN_CONFIGURATION)
#define  SITE_LINK_ROOT        (CN_SERVICES CN_CONFIGURATION)

#define  SITE_LINK_ROOT_LEN    (sizeof(SITE_LINK_ROOT) / sizeof(TCHAR))

#define  SERVER_DN_PREFIX      (TEXT("CN=MSMQ Settings,CN="))
#define  SERVER_DN_PREFIX_LEN  (sizeof(SERVER_DN_PREFIX) / sizeof(TCHAR))

#define  MACHINE_PATH_PREFIX        (TEXT("CN=msmq,CN="))
#define  MACHINE_PATH_PREFIX_LEN    (sizeof(MACHINE_PATH_PREFIX) / sizeof(TCHAR))


#define  SERVERS_PREFIX        (TEXT("CN=Servers,CN="))
#define  SERVERS_PREFIX_LEN    (sizeof(SERVERS_PREFIX) / sizeof(TCHAR))

#define  CN_PREFIX             (TEXT("CN="))
#define  CN_PREFIX_LEN         (sizeof(CN_PREFIX) / sizeof(TCHAR))

#define  OU_PREFIX             (TEXT("OU="))
#define  OU_PREFIX_LEN         (sizeof(OU_PREFIX) / sizeof(TCHAR))

#define  ISDELETED_FILTER      (TEXT("(IsDeleted=TRUE)"))
#define  ISDELETED_FILTER_LEN  (sizeof(ISDELETED_FILTER))

#define  OBJECTCLASS_FILTER      (TEXT("(objectClass="))
#define  OBJECTCLASS_FILTER_LEN  (sizeof(OBJECTCLASS_FILTER))

#define  DSATTR_SD             (TEXT("nTSecurityDescriptor"))

#define  CONTAINER_OBJECT_CLASS (TEXT("organizationalUnit"))

const WCHAR MQ_U_SIGN_CERT_MIG_ATTRIBUTE[] =    L"mSMQSignCertificatesMig";
const WCHAR MQ_U_DIGEST_MIG_ATTRIBUTE[] =       L"mSMQDigestsMig";
const WCHAR MQ_U_FULL_PATH_ATTRIBUTE[] =        L"distinguishedName"; 
const WCHAR MQ_U_DESCRIPTION_ATTRIBUTE[] =      L"description"; 

const WCHAR MQ_L_SITEGATES_MIG_ATTRIBUTE[] =    L"mSMQSiteGatesMig";

const WCHAR MQ_SET_MIGRATED_ATTRIBUTE[] =       L"mSMQMigrated";

const WCHAR USNCHANGED_ATTRIBUTE[] =            L"uSNChanged";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\mq1reple.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: mq1repl.cpp

Abstract: Entry point for MSMQ replication service.
          This service run on NT5 machines and perform DirSync between
          NT5 DS and MSMQ1.0 MQIS.

Author:

    Doron Juster  (DoronJ)   01-Feb-98

--*/

#include "mq1repl.h"

#include "mq1reple.tmh"

//
// define here global data.
//
HINSTANCE   g_MyModuleHandle = NULL ;

GUID     g_guidMyQMId = {0};
GUID     g_MySiteMasterId = {0} ;
GUID     g_guidEnterpriseId = {0};
GUID     g_PecGuid ;

BOOL     g_IsPSC = TRUE ; // replication service always run on a "psc"
BOOL     g_IsPEC = FALSE ;

CDSMaster     *g_pThePecMaster = NULL ;
CDSMaster     *g_pMySiteMaster = NULL ;
CDSMasterMgr  *g_pMasterMgr = NULL ;

CDSNeighborMgr  *g_pNeighborMgr = NULL ;

CDSTransport    *g_pTransport = NULL ;

CDSNT5ServersMgr *g_pNT5ServersMgr = NULL;

CDSNativeNT5SiteMgr *g_pNativeNT5SiteMgr = NULL;

DWORD  g_dwIntraSiteReplicationInterval = 0; // milliseconds
DWORD  g_dwInterSiteReplicationInterval = 0; // milliseconds
DWORD  g_dwWriteMsgTimeout = DS_WRITE_MSG_TIMEOUT ;

DWORD  g_dwPSCAckFrequencySN = RP_DEFAULT_PSC_ACK_FREQUENCY ;

//
// timeout of replication messages.
//
DWORD  g_dwReplicationMsgTimeout = 0 ;

//
// Interval for hello messages.
//
DWORD  g_dwHelloInterval = RP_DEFAULT_HELLO_INTERVAL ;

//
// Replication Interval.
//
DWORD  g_dwReplicationInterval = RP_DEFAULT_HELLO_INTERVAL * RP_DEFAULT_TIMES_HELLO;

//
// Default replication inteval, if last replication cycle failed
//
DWORD  g_dwFailureReplInterval = RP_DEFAULT_FAIL_REPL_INTERVAL ;

//
// Buffer between current SN and allowed purge SN, used for HelloMsg to NT4 masters
//
DWORD g_dwPurgeBufferSN = RP_DEFAULT_PURGE_BUFFER;

//
// DS query: Number of returned objects per ldap page
//
DWORD g_dwObjectPerLdapPage	= RP_DEFAULT_OBJECT_PER_LDAPPAGE;

//
// Name of ini file.
// At present, ini file is used to keep track of seq numbers.
//
TCHAR  g_wszIniName[ MAX_PATH ] = {TEXT('\0')} ;

//
// Name of my machine.
//
LPWSTR g_pwszMyMachineName = NULL ;
DWORD  g_dwMachineNameSize = 0 ;

//
// CN Info
//
ULONG g_ulIpCount = 0;
ULONG g_ulIpxCount = 0;

GUID *g_pIpCNs = NULL;
GUID *g_pIpxCNs = NULL;

//
// flag is set if BSC exists
//
BOOL g_fBSCExists = FALSE;

//
// flag is set if we are after recovery
//
BOOL g_fAfterRecovery = FALSE;

//
// First and Last Highest Mig USN for pre-migration object replication
//
__int64 g_i64FirstMigHighestUsn = 0;
__int64 g_i64LastMigHighestUsn = 0;

//
// Performance counters
//
CDCounter g_Counters;

//+-------------------------------------------------------------------------
//
//  Function:   RunMSMQ1Replication
//
//  Description:  This is the entry point where all start.
//                This function is the only one exported from the dll
//                and it is called to start the replication service.
//
//  History:    09-Feb-98  DoronJ     Created
//
//--------------------------------------------------------------------------


void  RunMSMQ1Replication( HANDLE  hEvent )
{
    BOOL f = SetEvent(hEvent) ;
    DBG_USED(f);
    ASSERT(f) ;
    Sleep(INFINITE) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  History:    09-Feb-98  DoronJ     Created
//
//--------------------------------------------------------------------------

BOOL WINAPI DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved )
{
    UNREFERENCED_PARAMETER(Reserved);

    switch( Reason )
    {
        case DLL_PROCESS_ATTACH:
        {
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");

            g_MyModuleHandle = (HINSTANCE) DllHandle;
            break;
        }

        case DLL_PROCESS_DETACH:
            WPP_CLEANUP();
            break;
    }

    return TRUE;

} // DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\mq1repl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: mq1repl.h

Abstract: main header file.

Author:

    Doron Juster  (DoronJ)   01-Feb-98

--*/

#include <_Stdh.h>

UINT  ReadDebugIntFlag(WCHAR *pwcsDebugFlag, UINT iDefault) ;

#include <mqtypes.h>
#include <mqsymbls.h>
#include <mqprops.h>
#include <privque.h>
#include <mqutil.h>

#include <mqsec.h>
#include <rt.h>
#include "dscore.h"
#include <seqnum.h>

#include "replldap.h"
#include "rptempl.h"

#include "fntoken.h"
#include "update.h"
#include "mqis.h"
#include "mqispkt.h"
#include "master.h"
#include "dsnbor.h"
#include "rpdsptch.h"
#include "migrepl.h"

#include "rpperf.h"
#include "counter.h"

#include "..\..\setup\msmqocm\service.h"



//---------------------------------
//
//  Structures definitions.
//
//---------------------------------

typedef struct _ThreadData
{
    HANDLE      hEvent ;
    QUEUEHANDLE hQueue ;
    DWORD       dwThreadNum ;
} THREAD_DATA;

//---------------------------------
//
//  Global data.
//
//---------------------------------

extern CDSMaster     *g_pThePecMaster ;
extern CDSMaster     *g_pMySiteMaster ;
extern CDSMasterMgr  *g_pMasterMgr ;

extern CDSNeighborMgr  *g_pNeighborMgr ;

extern CDSTransport    *g_pTransport ;

extern CDSNT5ServersMgr *g_pNT5ServersMgr ;

extern CDSNativeNT5SiteMgr *g_pNativeNT5SiteMgr ;

extern GUID   g_guidMyQMId ;
extern GUID   g_MySiteMasterId ;
extern GUID   g_guidEnterpriseId ;
extern GUID   g_PecGuid ;

extern BOOL     g_IsPSC ;
extern BOOL     g_IsPEC ;

extern DWORD  g_dwIntraSiteReplicationInterval ;
extern DWORD  g_dwInterSiteReplicationInterval ;
extern DWORD  g_dwReplicationMsgTimeout ;
extern DWORD  g_dwWriteMsgTimeout ;
extern DWORD  g_dwHelloInterval ;
extern DWORD  g_dwPurgeBufferSN;
extern DWORD  g_dwReplicationInterval;
extern DWORD  g_dwFailureReplInterval;

extern DWORD  g_dwPSCAckFrequencySN ;
extern DWORD  g_dwTouchObjectPerSecondInDS ;
extern DWORD  g_dwObjectPerLdapPage ;

extern DWORD  g_dwMachineNameSize ;
extern LPWSTR g_pwszMyMachineName ;

extern TCHAR  g_wszIniName[ MAX_PATH ] ;

//
// CNs Info
//
extern ULONG g_ulIpCount;
extern ULONG g_ulIpxCount;

extern GUID *g_pIpCNs;
extern GUID *g_pIpxCNs;

//
// flag is set if BSC exists
//
extern BOOL g_fBSCExists;

//
// flag is set if we are after recovery
//
extern BOOL g_fAfterRecovery;
//
// First and Last Highest Mig USN for pre-migration object replication
//
extern __int64 g_i64FirstMigHighestUsn;
extern __int64 g_i64LastMigHighestUsn;

//
// Performance counters
//
extern CDCounter g_Counters ;

//---------------------------------
//
//  Functions prototypes.
//
//---------------------------------

HRESULT ReplicationCreateObject(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                IN  BOOL                    fAddMasterSeq = FALSE,
				IN	const GUID *			pguidMasterId = NULL,
                IN  CSeqNum *               psn           = NULL,
                IN  unsigned char           ucScope       = ENTERPRISE_SCOPE ) ;

HRESULT ReplicationSetProps(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  CONST GUID *            pguidIdentifier,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                IN  BOOL                    fAddMasterSeq,
				IN	const GUID *			pguidMasterId,
                IN  CSeqNum *               psn,
                IN  CSeqNum *               psnPrevious,
                IN  unsigned char           ucScope,
                IN  BOOL                    fWhileDemotion,
                IN  BOOL                    fMyObject,
                OUT LPWSTR *                ppwcsOldPSC   = NULL ) ;

HRESULT ReplicationDeleteObject(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  CONST GUID *            pguidIdentifier,
                IN  unsigned char           ucScope,
				IN	const GUID *			pguidMasterId,
                IN  CSeqNum *               psn,
                IN  CSeqNum *               psnPrevious,
                IN  BOOL                    fMyObject,
				IN  BOOL					fSync0,
             OUT CList<CDSUpdate *, CDSUpdate *> ** pplistUpdatedMachines) ;

HRESULT  ReplicationSyncObject(
                IN  DWORD                   dwObjectType,
                IN  LPWSTR                  pwcsPathName,
                IN  GUID *                  pguidIdentifier,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
				IN	const GUID *			pguidMasterId,
                IN  CSeqNum *               psn,
                OUT BOOL *                  pfIsObjectCreated);

HRESULT InitQueues( OUT QUEUEHANDLE *phMqisQueue,
                    OUT QUEUEHANDLE *phNT5PecQueue ) ;

HRESULT InitDirSyncService() ;

HRESULT InitEnterpriseID() ;

HRESULT InitBSC( IN LPWSTR          pwcsPathName,
                 IN const GUID *    pBSCMahcineGuid ) ;

HRESULT InitPSC( IN LPWSTR *        ppwcsPathName,
                 IN const GUID *    pguidMasterId,
                 IN CACLSID *       pcauuidSiteGates,
                 IN BOOL            fNT4Site,
                 IN BOOL            fMyPSC = FALSE ) ;

HRESULT GetMQISQueueName( WCHAR **ppwQueueFormatName,
                          BOOL    fDirect,
                          BOOL    fPecQueue = FALSE ) ;
HRESULT GetMQISAdminQueueName(
              WCHAR **ppwQueueFormatName
                              );

HRESULT GetRpcClientHandle(handle_t *phBind) ;

void ReadReplicationTimes() ;
void ReadReplicationIntervals() ;

HRESULT PrepareNeighborsUpdate( IN  unsigned char   bOperationType,
                                IN  DWORD           dwObjectType,
                                IN  LPCWSTR         pwcsPathName,
                                IN  CONST GUID *    pguidIdentifier,
                                IN  DWORD           cp,
                                IN  PROPID          aProp[  ],
                                IN  PROPVARIANT     apVar[  ],
                                IN  const GUID *    pguidMasterId,
                                IN  const CSeqNum & sn,
                                IN  const CSeqNum & snPrevInterSiteLSN,
                                IN  unsigned char   ucScope,
                                IN  BOOL            fNeedFlush,
                                IN  CDSUpdateList  *pReplicationList ) ;

void StringToSeqNum( IN TCHAR    pszSeqNum[],
                     OUT CSeqNum *psn ) ;

HRESULT SaveSeqNum( IN CSeqNum     *psn,
                    IN CDSMaster   *pMaster,
                    IN BOOL         fInSN) ;

void IncrementUsn(TCHAR tszUsn[]) ;

void SeqNumToUsn( IN CSeqNum    *psn,
                  IN __int64    i64Delta,
                  IN BOOL       fIsFromUsn,
                  OUT BOOL      *pfIsPreMig,                  
                  OUT TCHAR     *ptszUsn );

void GetSNForReplication (IN  __int64     i64SeqNum,
                          IN  CDSMaster   *pMaster,
                          IN  GUID        *pNeighborId,  
                          OUT CSeqNum     *psn );

void i64ToSeqNum( IN  __int64 i64SeqNum,
                  OUT CSeqNum *psn ) ;

HRESULT RetrieveSecurityDescriptor( IN  DWORD        dwObjectType,
                                    IN  PLDAP        pLdap,
                                    IN  LDAPMessage *pRes,
                                    OUT DWORD       *pdwLen,
                                    OUT BYTE        **ppBuf ) ;

HRESULT HandleDeletedQueues( IN  TCHAR         *pszDN,
                             IN  TCHAR         *pszFilterIn,
                             IN  CDSMaster     *pMaster,
                             IN  CDSUpdateList *pReplicationList,
                             IN  GUID          *pNeighborId,
                             OUT int           *piCount ) ;

HRESULT HandleDeletedSites( IN  TCHAR         *pszPrevUsn,
                            IN  TCHAR         *pszCurrentUsn,
                            IN  CDSUpdateList *pReplicationList,
                            IN  GUID          *pNeighborId,
                            OUT int           *piCount ) ;

HRESULT HandleSites( IN  TCHAR         *pszPrevUsn,
                     IN  TCHAR         *pszCurrentUsn,
                     IN  CDSUpdateList *pReplicationList,
                     IN  GUID          *pNeighborId,
                     OUT int           *piCount ) ;

HRESULT HandleDeletedMachines(
             IN  TCHAR         *pszDN,
             IN  TCHAR         *pszFilterIn,
             IN  CDSMaster     *pMaster,
             IN  CDSUpdateList *pReplicationList,
             IN  GUID          *pNeighborId,
             OUT int           *piCount
             ) ;

HRESULT HandleDeletedSiteLinks(                
                IN  TCHAR         *pszFilterIn,
                IN  CDSUpdateList *pReplicationList,
                IN  GUID          *pNeighborId,
                OUT int           *piCount
                );

HRESULT CheckMSMQSetting( TCHAR        *tszPrevUsn,
                          TCHAR        *tszCurrentUsn );

HRESULT InitBSCs() ;

HRESULT InitMasters() ;

HRESULT InitNativeNT5Site ();

HRESULT ReplicateQueues( TCHAR          *pszPrevUsn,
                         TCHAR          *pszCurrentUsn,
                         CDSMaster      *pMaster,
                         CDSUpdateList  *pReplicationList,
                         GUID           *pNeighborId,
                         int            *piCount,
                         BOOL            fReplicateNoID ) ;

HRESULT ReplicateMachines(
             TCHAR          *pszPrevUsn,
             TCHAR          *pszCurrentUsn,
             CDSMaster      *pMaster,
             CDSUpdateList  *pReplicationList,
             GUID           *pNeighborId,
             int            *piCount,
             BOOL            fReplicateNoID
             ) ;

HRESULT ReplicateSiteLinks(
            IN  TCHAR         *pszPrevUsn,
            IN  TCHAR         *pszCurrentUsn,
            IN  CDSUpdateList *pReplicationList,
            IN  GUID          *pNeighborId,
            OUT int           *piCount
            ) ;

HRESULT ReplicateUsers(
            IN  BOOL           fMSMQUserContainer,
            IN  TCHAR         *pszPrevUsn,
            IN  TCHAR         *pszCurrentUsn,
            IN  CDSUpdateList *pReplicationList,
            IN  GUID          *pNeighborId,
            OUT int           *piCount
            ) ;

HRESULT ReplicateEnterprise (
            IN  TCHAR         *pszPrevUsn,
            IN  TCHAR         *pszCurrentUsn,
            IN  CDSUpdateList *pReplicationList,
            IN  GUID          *pNeighborId,
            OUT int           *piCount
            );

HRESULT ReplicateCNs (                
            IN  CDSUpdateList *pReplicationList,
            IN  GUID          *pNeighborId,
            OUT int           *piCount
            );

HRESULT HandleACN (
             CDSUpdateList *pReplicationList,
             GUID          *pNeighborId,
             GUID           CNGuid,
             UINT           uiAddressType,
             LPWSTR         pwcsName,
             CSeqNum        *psn, 
             DWORD          dwLenSD,
             BYTE           *pSD
             );

DWORD WINAPI  ReplicationTimerThread(LPVOID lpV) ;

DWORD CalHashKey( IN LPCWSTR pwcsPathName ) ;

HRESULT ReplicateSitesObjects(   IN CDSMaster    *pMaster,
                                 IN TCHAR        *tszPrevUsn,
                                 IN TCHAR        *tszCurrentUsn,
                                 IN CDSNeighbor  *pNeighbor = NULL,
                                 IN HEAVY_REQUEST_PARAMS *pSyncRequestParams = NULL,
                                 IN BOOL          fReplicateNoID = TRUE,
                                 IN UINT          uiFlush = DS_FLUSH_TO_ALL_NEIGHBORS) ;

HRESULT ReplicatePECObjects( IN TCHAR        *tszPrevUsn,
                             IN TCHAR        *tszCurrentUsn,
                             IN CDSNeighbor  *pNeighbor = NULL,
                             IN HEAVY_REQUEST_PARAMS *pSyncRequestParams = NULL ) ;

void  RunMSMQ1Replication( HANDLE       hEvent ) ;

HRESULT  ReceiveWriteReplyMessage( MQMSGPROPS  *psProps,
                                   QUEUEHANDLE  hMyNt5PecQueue ) ;

HRESULT ReceiveWriteRequestMessage( IN  const unsigned char *   pBuf,
                                    IN  DWORD                   TotalSize ) ;

HRESULT  RpSetPrivilege( BOOL fSecurityPrivilege,
                         BOOL fRestorePrivilege,
                         BOOL fForceThread ) ;

void FreeMessageProps( MQMSGPROPS *pProps ) ;

BOOL IsForeignSiteInIniFile(GUID ObjectGuid);
void AddToIniFile (GUID ObjectGuid);

HRESULT InitRPCConnection();

HRESULT QueryDS(
			IN	PLDAP			pLdap,
			IN	TCHAR			*pszDN,
			IN  TCHAR			*pszFilter,
			IN  CDSMaster		*pMaster,
            IN  CDSUpdateList	*pReplicationList,
            IN  GUID			*pNeighborId,
			IN	DWORD			dwObjectType,
            OUT	int				*piCount,
			IN	BOOL			fDeletedObject,
			IN	PLDAPControl	*ppServerControls,
			IN	BOOL            fMSMQUserContainer,
            IN	TCHAR			*pszPrevUsn
			);

HRESULT  HandleAQueue( PLDAP           pLdap,
                       LDAPMessage    *pRes,
                       CDSMaster      *pMaster,
                       CDSUpdateList  *pReplicationList,
                       IN  GUID       *pNeighborId);

HRESULT HandleAMachine(
               PLDAP           pLdap,
               LDAPMessage    *pRes,
               CDSMaster      *pMaster,
               CDSUpdateList  *pReplicationList,
               GUID           *pNeighborId
               );

HRESULT  HandleADeletedObject(
			   DWORD		   dwObjectType,
			   PLDAP           pLdap,
               LDAPMessage    *pRes,
               CDSMaster      *pMaster,
               CDSUpdateList  *pReplicationList,
               GUID           *pNeighborId
			   );

HRESULT HandleAUser(
            BOOL            fMSMQUserContainer,
            TCHAR          *pszPrevUsn,
            PLDAP           pLdap,
            LDAPMessage    *pRes,
            CDSUpdateList  *pReplicationList,
            GUID           *pNeighborId,
            int            *piCount
            );


HRESULT RemoveReplicationService();
BOOL RunProcess(
		IN  const LPTSTR szCommandLine,
		OUT       DWORD  *pdwExitCode  
		);
void DeleteReplicationService();

HRESULT  GetSchemaNamingContext ( TCHAR **ppszSchemaDefName );

//---------------------------------
//
//  Inline utilily functions
//
//---------------------------------

inline LPWSTR DuplicateLPWSTR(IN LPCWSTR pwcsSrc)
{
    if (pwcsSrc == NULL)
    {
        return(NULL);
    }
    DWORD len = wcslen(pwcsSrc);
    LPWSTR dupName = new WCHAR[len+1];
    wcscpy(dupName,pwcsSrc);
    return(dupName);
}

//---------------------------------
//
// Constants Definition
//
//---------------------------------

#define MQIS_QUEUE_NAME    L"private$\\"L_REPLICATION_QUEUE_NAME
#define NT5PEC_QUEUE_NAME  L"private$\\"L_NT5PEC_REPLICATION_QUEUE_NAME

//+------------------
//
//  Logging
//
//+------------------

//
// enum match values of DBGLVL_* in mqreport.h
//
enum ReplLogLevel
{
    ReplLog_Error = 1,
    ReplLog_Warning,
    ReplLog_Trace,
    ReplLog_Info
} ;

void LogReplicationEvent(ReplLogLevel eLevel, DWORD dwMsgId, ...) ;

//---------------------------------
//
//  Definitions for debugging
//
//---------------------------------

#ifdef _DEBUG

#define NOT_YET_IMPLEMENTED(error, flag)
#if 0
                                  \
{                                                                         \
    static BOOL flag = TRUE ;                                             \
    if (flag)                                                             \
    {                                                                     \
        MessageBox(NULL, error, TEXT("MQ1Sync- not implemented yet"), MB_OK) ;  \
        flag = FALSE ;                                                    \
    }                                                                     \
}
#endif

#else
#define NOT_YET_IMPLEMENTED(error, flag)
#endif

//
// The value of lowest MQDS_XXX object-type flag is 1.
// That's the reason for the first 0 in each array.
//

static const PROPID s_aMasterPropid[ MAX_MQIS_TYPES ] =
                                               { 0,
											     PROPID_Q_MASTERID,
                                                 PROPID_QM_MASTERID,
                                                 PROPID_S_MASTERID
                                               } ;

static const PROPID s_aSelfIdPropid[ MAX_MQIS_TYPES ] =
                                               { 0,
											     PROPID_Q_INSTANCE,
                                                 PROPID_QM_MACHINE_ID,
                                                 PROPID_S_SITEID
                                                } ;

static const PROPID s_aPathPropid[ MAX_MQIS_TYPES ] =
                                               { 0,
											     PROPID_Q_PATHNAME,
                                                 PROPID_QM_PATHNAME,
                                                 PROPID_S_PATHNAME
                                               } ;

static const PROPID s_aDoNothingPropid[ MAX_MQIS_TYPES ] =
                                               { 0,
											     PROPID_Q_DONOTHING,
                                                 PROPID_QM_DONOTHING,
                                                 PROPID_S_DONOTHING
                                               } ;

//
// These are the index of properties in the MSGPROPS structure which is used
// in MQReceiveMessage().
//
// Keep the order of properties !
// Keep the connector_type property !
//
// why ?
// Because same properties array (MQMSGPROP) is used when calling MQReceive()
// and when calling MQSend() to return a WRITE_REPLY to the MSMQ service.
// MQSend() won't accept the AUTHENTICATED property (it's available only
// for MQRecieve()) and msg-class is now ack (not normal). That's why we
// need the dummy connector-type. Only if connector-type is specified we
// can pass a non-normal message class to MQSend().
// So when calling MQSend() we just decrement the value of cProp.
//
#define MSG_CLASS_INDEX           0
#define MSG_BODYSIZE_INDEX        1
#define MSG_BODY_INDEX            2
#define MSG_CONNECTOR_TYPE_INDEX  3
#define MSG_RESPLEN_INDEX         4
#define MSG_RESP_INDEX            5
#define MSG_AUTHENTICATED_INDEX   6
#define MSG_SENDERID_TYPE_INDEX   7
#define MSG_SENDERID_LEN_INDEX    8
#define MSG_SENDERID_INDEX        9

#define NUMOF_RECV_MSG_PROPS  (MSG_SENDERID_INDEX + 1)
#define NUMOF_SEND_MSG_PROPS  (MSG_RESP_INDEX + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\mqis.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    mqis.h

Abstract:
    MQIS defines and structures


Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __MQIS_H__
#define __MQIS_H__

#define PEC_MASTER_ID   GUID_NULL


#define DS_FILE_NAME_MAX_SIZE 30

/*----------------------------------------------
    Heavy request time-outs
-----------------------------------------------*/
#define HEAVY_REQUEST_WAIT_TO_HANDLE  5000 /* 5 sec */
#define HEAVY_REQUEST_WAIT_IF_FAILED (10 * 60 * 1000) /* 10 min */

/*----------------------------------------------
    Message transmission timeouts
-----------------------------------------------*/
#define DS_WRITE_MSG_TIMEOUT            10 /* 10 sec */
#define REPLICATION_NACK_RETRY_TIMEOUT  10 /* 10 sec */

#define BSC_ACK_FREQUENCY				(12 * 60 * 60)	/*12 hours */
#define CHECK_BSC_ACK_FREQUENCY			(24 * 60 * 60)	/*24 hours */
#define CHECK_MQIS_DISK_USAGE_FREQUENCY (24 * 60 * 60)  /*24 hours */
#define PURGE_BSC_TIME_WARNING		(4 * 24 * 60 * 60)	/* 4 days  */
#define PURGE_BSC_TIME_BUFFER		(7 * 24 * 60 * 60)	/* 7 days  */

#define PSC_ACK_FREQUENCY_SN  256
#define PURGE_FREQUENCY_SN    256
#define PURGE_BUFFER_SN      1024

#define DS_WRITE_REQ_PRIORITY   ( MQ_MAX_PRIORITY + 1)
#define DS_REPLICATION_PRIORITY  DEFAULT_M_PRIORITY

#define DS_NOTIFICATION_MSG_PRIORITY DEFAULT_M_PRIORITY
#define DS_NOTIFICATION_MSG_TIMEOUT (5 * 60)    /* 5 min */

#define DS_PACKET_VERSION   0

#define MAX_REPL_MSG_SIZE   15000

#define MQIS_NO_OF_FRSS 3

#define MQIS_LENGTH_PREFIX_LEN  2   /* in bytes*/

//
// type of DS message
//
#define DS_REPLICATION_MESSAGE  ((unsigned char ) 0x00)
#define DS_WRITE_REQUEST        ((unsigned char ) 0x01)
#define DS_SYNC_REQUEST         ((unsigned char ) 0x02)
#define DS_SYNC_REPLY           ((unsigned char ) 0x03)
#define DS_WRITE_REPLY          ((unsigned char ) 0x04)
#define DS_ALREADY_PURGED	    ((unsigned char ) 0x05)
#define DS_PSC_ACK		        ((unsigned char ) 0x06)
#define DS_BSC_ACK		        ((unsigned char ) 0x07)


//
// type of replication message
//
#define DS_REPLICATION_MESSAGE_NORMAL   ((unsigned char ) 0x00)
#define DS_REPLICATION_MESSAGE_FLUSH    ((unsigned char ) 0x01)

#define DS_FLUSH_TO_ALL_NEIGHBORS  1
#define DS_FLUSH_TO_BSCS_ONLY      2

/*----------------------------------------------
    Sync request structure
-----------------------------------------------*/
typedef struct
{
	DWORD	dwType;
    GUID    guidSourceMasterId; // The id of the master, that its infromation is being synced
    LPWSTR  pwszRequesterName;  // The PathName of the DS server that initiated the sync process
    CSeqNum snFrom;        //
    CSeqNum snTo;
    CSeqNum snKnownPurged;		// the purged sn known already to the requestor
	union
	{
		unsigned char bIsSync0;		// 1: sync0, 0: normal sync
		unsigned char bRetry;		// 1: Retry, failed before, 0: normal
	};
    unsigned char bScope;       // 1 : enterprise, 0 : all objects
} HEAVY_REQUEST_PARAMS;

/*----------------------------------------------
    values of scope parameter in sync request packet
-----------------------------------------------*/

#define ENTERPRISE_SCOPE_FLAG   ((unsigned char) 1)
#define NO_SCOPE_FLAG           ((unsigned char) 0)

/*--------------------------------------------------
    Definitions for object managers
---------------------------------------------------*/

typedef struct
{
   LPSTR  lpszIndexName;
   LPSTR* lpszColumnName;
   LONG   cColumns;
   BOOL   fUnique;
   BOOL   fClustered;
}   IndexInformation;

//
// Values for VarType of TranslateInfo
//
typedef enum _MQISVARTYPE {
   BLOB_VT,
   LOWCASE_LENSTR_VT,       // lower case, limited length string
   LOWCASE_STR_VT,          // lower case string
   GUID_VT,
   STR_VT,
   LENSTR_VT,               // limited length string
   LONG_VT,
   ULONG_VT,
   SID_VT,
   UCHAR_VT,
   USHORT_VT,
   CA_GUID_VT,              // counted array guid
   SHORT_VT,
   CA_3GUID_VT              // counted array of guid, with a limit of 3
} MQISVARTYPE;
//
// Values for ObjectType of TranslateInfo
//
typedef enum _MQISOBJECTTYPE {
     SIMPLE_PROPERTY,
     ARRAY_PROPERTY,
     MULTIPLE_ENTRY_PROPERTY
} MQISOBJECTTYPE;

typedef struct
{
    unsigned char   ucTableNumber;
    unsigned char   ucIndex;
    PROPID  propid;
    MQISVARTYPE     VarType;
    MQISOBJECTTYPE  ucPrpertyType;
    unsigned char   ucNumberOfAdditionalEntries;  // must follow in the insert columns array
}   TranslateInfo;

//
//  Structure for WRITE request/reply
//
typedef struct
{
    DWORD   dwValidationSeq[4];
    HANDLE  hEvent;
    HRESULT hr;
} WRITE_SYNC_INFO;


//
//  For security utilties
//
#define OBJECT_DELETE 0
#define OBJECT_GET_PROPS 1
#define OBJECT_SET_PROPS 2


typedef enum _PURGESTATE {
     PURGE_STATE_NORMAL,
     PURGE_STATE_STARTSYNC0,
	 PURGE_STATE_SYNC0,
     PURGE_STATE_COMPLETESYNC0
} PURGESTATE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\mqmaster.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: mqmaster.cpp

Abstract:
    Copied from src\mqis\master.cpp and use only relevant code.

Author:

    Doron Juster  (DoronJ)   11-Feb-98

--*/

#include "mq1repl.h"

#include "mqmaster.tmh"

/*====================================================

DestructElements of CDSMaster*

Arguments:

Return Value:

=====================================================*/

void AFXAPI DestructElements(CDSMaster ** ppMaster, int n)
{

    int i,ref;
    for (i=0;i<n;i++)
	{
        ref = (*ppMaster)->Release();
		if (ref == 0)
		{
			delete (*ppMaster);
		}
		ppMaster++;
	}
}

//+--------------------------------
//
//  CDSMaster::~CDSMaster()
//
//+--------------------------------

CDSMaster::~CDSMaster()
{
}

/*====================================================

RoutineName
    CDSMaster::Init()

Arguments:
            IN CDSUpdate    *pUpdate

Return Value:

Threads:Receive, Scheduler

=====================================================*/

void CDSMaster::Init(LPWSTR pwcsPathName,
                     CACLSID * pcauuidSiteGates)
{
	m_pwcsPathName = pwcsPathName;
    m_snMissingWindow.SetInfiniteLSN();

    if ( pcauuidSiteGates )
    {
        m_cauuidSiteGates.cElems = pcauuidSiteGates->cElems;
        m_cauuidSiteGates.pElems = pcauuidSiteGates->pElems;
    }
    else
    {
        m_cauuidSiteGates.cElems = 0;
        m_cauuidSiteGates.pElems = NULL;
    }

	AddRef();
	if(m_Sync0State == PURGE_STATE_STARTSYNC0)
	{
		DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT("Need to StartSync0")));
		HEAVY_REQUEST_PARAMS * pStartSync0Request = new HEAVY_REQUEST_PARAMS;
		pStartSync0Request->dwType = MQIS_SCHED_START_SYNC0;
		pStartSync0Request->guidSourceMasterId = m_guidMasterId;
		pStartSync0Request->snKnownPurged = m_snPurged;
		pStartSync0Request->bRetry = TRUE;

        NOT_YET_IMPLEMENTED(TEXT("QMSetTimer(RetryHeavyOperation)"), s_fTimer) ;
///////////QMSetTimer( 5000L, RetryHeavyOperation,pStartSync0Request, 0);
	}
	else if(m_Sync0State == PURGE_STATE_COMPLETESYNC0)
	{
		DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT("Need to CompleteSync0")));
		HEAVY_REQUEST_PARAMS * pCompleteSync0 = new HEAVY_REQUEST_PARAMS;
		pCompleteSync0->dwType = MQIS_SCHED_COMPLETE_SYNC0;
		pCompleteSync0->guidSourceMasterId = m_guidMasterId;

        NOT_YET_IMPLEMENTED(TEXT("QMSetTimer(RetryHeavyOperation)"), s_fTimer) ;
/////////////QMSetTimer( 5000L, RetryHeavyOperation,pCompleteSync0, 0);
	}
}

//+-----------------------------------------
//
//    CDSMasterMgr::AddPSCMaster()
//
//+-----------------------------------------

HRESULT CDSMasterMgr::AddPSCMaster( IN LPWSTR            pwcsPathName,
                                    IN const GUID *      pguidMasterId,
                                    IN const __int64     i64Delta,
                                    IN const CSeqNum &   snMaxLSNIn,
                                    IN const CSeqNum &   snMaxLSNOut,                                   
				                    IN const CSeqNum &   snAllowedPurge,
									IN PURGESTATE		 Sync0State,
		                            IN const CSeqNum &   snAcked,
				                    IN const CSeqNum &   snAckedPEC,
                                    IN CACLSID *         pcauuidSiteGates,
                                    IN BOOL              fNT4Site)
{
    BOOL fMyPSC = ((g_pMySiteMaster == NULL)  &&
                   (g_MySiteMasterId == *pguidMasterId)) ;

    CDSMaster* pMaster = NULL ;

    if (fMyPSC)
    {
        DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO, TEXT(
          "::AddPSCMaster : Initialize myself, %lut, %lut, %lut, %lut"),
                                  g_dwIntraSiteReplicationInterval,
                                  g_dwInterSiteReplicationInterval,
                                  g_dwReplicationMsgTimeout,
                                  g_dwPSCAckFrequencySN )) ;
    }

    //
    // Generate a master class for this PSC ( to trace LSN, etc.)
    //
    pMaster = new CDSMaster( pwcsPathName,
                             pguidMasterId,
                             i64Delta,
                             snMaxLSNIn,
                             snMaxLSNOut,                     
                             snAllowedPurge,
                             Sync0State,
                             pcauuidSiteGates,
                             fNT4Site);

    if (fMyPSC)
    {
        ASSERT(g_pMySiteMaster == NULL) ;
        g_pMySiteMaster = pMaster;
    }

    //
    // Keep in map
    //
	CDSMasterCount MasterCount;
    {
        CS lock(m_cs);
        m_mapIdToMaster[ *pguidMasterId] = pMaster;
        MasterCount.Set(pMaster);
    }

    if (fNT4Site)
    {
        //
        // add new instance (new NT4 master) to performance counter object
        //
        g_Counters.AddInstance(pwcsPathName);
        //
        // set IN and OUT SN to performance counter
        //
        TCHAR wszSeq[ SEQ_NUM_BUF_LEN ] ;
        __int64 i64Seq = 0 ;

        snMaxLSNIn.GetValueForPrint(wszSeq) ;        
        _stscanf(wszSeq, TEXT("%I64x"), &i64Seq) ;
        BOOL f = g_Counters.SetInstanceCounter(pwcsPathName, eLastSNIn, (DWORD) i64Seq);

        snMaxLSNOut.GetValueForPrint(wszSeq) ;        
        _stscanf(wszSeq, TEXT("%I64x"), &i64Seq) ;
        f = g_Counters.SetInstanceCounter(pwcsPathName, eLastSNOut, (DWORD) i64Seq);    
    }

    if (g_pMySiteMaster != pMaster)
    {
        //
        // Not myself. It's another master in the enterprise.
        //
        // Start asking for syncs
        //
		pMaster->SendSyncRequest();

        //
        // Add this master as a neighbor.
        //

        GUID * pguidMachineId = NULL ;
        //
        //  Get the machine id of the psc
        //
        PROPID      aProp;
        PROPVARIANT aVar;

        aProp = PROPID_QM_MACHINE_ID;
        aVar.vt = VT_NULL;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  

        HRESULT hr = DSCoreGetProps( MQDS_MACHINE,
                                            pwcsPathName,
                                            NULL,
                                            1,
                                            &aProp,
                                            &requestContext,
                                            &aVar);

        if ( FAILED(hr) )
        {
            //
            //  The machine object of the site, maybe have not
            //  been replicated yet.
            //
        }
        else
        {
            pguidMachineId = aVar.puuid;
        }

        //
        // Create a PSC neighbor
        //
        LPWSTR  pwcsDupName = DuplicateLPWSTR(pwcsPathName);
        if (!g_pNeighborMgr)
        {
            g_pNeighborMgr = new  CDSNeighborMgr ;
        }
        hr = g_pNeighborMgr->AddPSCNeighbor( pwcsDupName,
							                 pguidMachineId,
                                             snAcked,
                                             snAckedPEC);
        delete pguidMachineId;

        if (FAILED(hr))
        {
            return(hr);
        }
    }

    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSMaster::Send()

Arguments:
            IN CDSUpdate    *pUpdate

Return Value:

Threads:Receive, Scheduler

=====================================================*/

HRESULT CDSMaster::Send(IN const unsigned char *    pBuf,
                        IN DWORD            dwSize,
                        IN DWORD            dwTimeOut,
                        IN unsigned char    bAckMode,
                        IN unsigned char    bPriority,
                        IN LPWSTR			lpwszAdminQueue)
{
    //
    // actually we have to find the responsible to providing us
    // information about this source
    // assuming star replication - PSCs get it from the master itself
    // BSCs from their PSC
    //
    ASSERT(g_pTransport) ;

    CS lock(m_cs);
    if (m_phConnection == NULL)
    {
        g_pTransport->CreateConnection(m_pwcsPathName, &m_phConnection);
    }
    ASSERT(m_phConnection != NULL);
    HRESULT hr = g_pTransport->SendReplication( m_phConnection,
                                                pBuf,
                                                dwSize,
                                                dwTimeOut,
                                                bAckMode,
                                                bPriority,
                                                lpwszAdminQueue) ;
    return hr ;
}

/*====================================================

RoutineName
    CDSMaster::AddUpdate()

Arguments:
            IN CDSUpdate    *pUpdate

Return Value:

Threads:Receive

=====================================================*/

HRESULT CDSMaster::AddUpdate(IN CDSUpdate   *pUpdate,
                             IN BOOL        fCheckNeedFlush)
{
    CSeqNum snUpdatePrevSeqNum;
    CSeqNum snUpdateSeqNum;
    CSeqNum snUpdatePurgeSeqNum;
    HRESULT hr;

    CS lock(m_cs);

    snUpdatePrevSeqNum = pUpdate->GetPrevSeqNum();
    snUpdateSeqNum = pUpdate->GetSeqNum();
    snUpdatePurgeSeqNum = pUpdate->GetPurgeSeqNum();

    if ( snUpdateSeqNum  <= m_snLSN ) // || snUpdatePurgeSeqNum < m_snPurged)
    {
        //
        // skip it, we already received and handled it
        //
        DBGMSG((DBGMOD_REPLSERV, DBGLVL_TRACE,
            TEXT("CDSMaster::AddUpdate, Receive an old update, skip it"))) ;
        delete pUpdate;
        return(MQ_OK);
    }
    else if ( snUpdatePrevSeqNum <= m_snLSN )
    {
        //
        // Normal case, update arrived in the right order
        //
        hr = HandleInSyncUpdate(pUpdate,fCheckNeedFlush);
        if (FAILED(hr))
        {
            return(hr);
        }

        //
        // Check if it there are updates in waiting list that can be handled now
        //
        hr = CheckWaitingList();
    }
    else
    {
        //
        // We missed some updates, ask for a sync
        //
#ifdef _DEBUG
        WCHAR wU[ 48 ];
        snUpdateSeqNum.GetValueForPrint(wU) ;
        WCHAR wP[ 48 ];
        snUpdatePrevSeqNum.GetValueForPrint(wP) ;

        DBGMSG((DBGMOD_REPLSERV, DBGLVL_TRACE, TEXT(
           "Receive out of sync update, ask Sync, u-%ls, p-%ls"), wU, wP)) ;
#endif

        hr = AddOutOfSyncUpdate(pUpdate);
    }

    return(hr);
}

/*====================================================

RoutineName
    CDSMaster::HandleInSyncUpdate()

Arguments:
            IN CDSUpdate    *pUpdate

Return Value:

Threads:Receive

=====================================================*/

HRESULT CDSMaster::HandleInSyncUpdate(  IN CDSUpdate *pUpdate,
                                        IN BOOL fCheckNeedFlush)
{
	if ( pUpdate->GetPurgeSeqNum() < m_snPurged)
    {
        //
        // skip it, old one, since then the master purged and we asked for sync0
		// of newer purge
        //
        DBGMSG((DBGMOD_REPLSERV, DBGLVL_TRACE, TEXT(
           "CDSMaster::HandleInSyncUpdate, Old update, before its purge, skip it"))) ;
        delete pUpdate;
        return(MQ_OK);
    }

    HRESULT status;
    BOOL    fNeedFlush=FALSE;
    BOOL*   pfNeedFlush = (fCheckNeedFlush) ? &fNeedFlush : NULL;

    status = pUpdate->UpdateDB(m_Sync0State != PURGE_STATE_NORMAL,pfNeedFlush);
    if (IS_ERROR(status))
    {
        LogReplicationEvent(ReplLog_Error, MQSync_E_UPDATEDB, status) ;

        //
        // On MSMQ1.0 (MQIS replication), failure to update the SQL database
        // was consider as MSMQ bug. That's the reason for the return here.
        // On NT5 DS, the DS may reject an update for various reasons
        // (invalid usr, permissions, etc...). We don't want to stop the
        // replication, so update the seq number and continue as usual.
        //
        //  BUGBUG: issue an event.
        //
        //delete pUpdate;
        //return(status);
    }

    //
    // Modify LSN, and save it in ini file.
    //
    m_snLSN = pUpdate->GetSeqNum();

    //
    // Save highest seq-num of this master
    //
    
    HRESULT hr = SaveSeqNum( &m_snLSN,
                             this,
                             TRUE ) ;   //PEC received this SN from NT4 masters => flag fInSN=TRUE
    DBG_USED(hr);
    ASSERT(SUCCEEDED(hr)) ;

    //
    // OK, we're done with pUpdate. If we ever need to call AddToNeighbor
    // (below) then remove this delete.
    //
    delete pUpdate ;

    //
    // time to add the update to destinations
    //

	if (m_Sync0State == PURGE_STATE_NORMAL)
	{
        NOT_YET_IMPLEMENTED(TEXT("AddToNeighbors"), s_fAddToNeighbor) ;
////////////AddToNeighbors(pUpdate);

		if (fNeedFlush)
		{
			g_pNeighborMgr->Flush(DS_FLUSH_TO_BSCS_ONLY);
		}
	}

	//
	// we do not want to send if within sync0 - becasue they were already
    // sent, the original master already purged to m_snPurged. However if
    // we are after m_snPurged and did not complete sync0 yet, we send the
    // ack, becasue it is greater than the ack that the master already
    // received
	//
	if (m_Sync0State == PURGE_STATE_NORMAL || m_snLSN >= m_snPurged)
	{
		//
		// PSCs (only) send ACKs to the master every multiple
        // of MQIS_PSC_ACK_FREQUENCY SN
		//
		if (g_IsPSC && m_snLSN.IsMultipleOf(g_dwPSCAckFrequencySN))
		{
           //
           // PEC has to send PSC ack on behalf of 
           // - itself AND 
           // - all NT5 master migrated from NT4 AND 
           // - all native NT5 sites
           // to allow purge process on NT4 machine of NT4 masters.
           //
           
           //
           // loop for all native NT5 sites
           //
           POSITION pos = g_pNativeNT5SiteMgr->GetStartPosition();
           while (pos != NULL)
           {
                GUID guidSite;
                g_pNativeNT5SiteMgr->GetNextNT5Site(&pos, &guidSite);                
        
                SendPSCAck(&guidSite);
           }

           //
           // loop for all migrated master including PEC itself.
           // It means: loop for each site with fNT4SiteFlag = FALSE
           //    
           pos = g_pMasterMgr->GetStartPosition();
           while ( pos != NULL)
           {
                CDSMaster *pMaster = NULL;        
                g_pMasterMgr->GetNextMaster(&pos, &pMaster);
                if (pMaster->GetNT4SiteFlag () == FALSE)
                {                                          
                    GUID *pGuid = const_cast<GUID*> (pMaster->GetMasterId());
                    SendPSCAck(pGuid);
                }
           }
		}
	}

    return(status);
}

/*====================================================

RoutineName
    CDSMaster::CheckWaitingList()

Arguments:

Return Value:

Threads:Receive

=====================================================*/

HRESULT CDSMaster::CheckWaitingList()
{
    POSITION pos;
    CDSUpdate *pNextUpdate;
    CSeqNum snUpdatePrevSeqNum;
    CSeqNum snUpdateSeqNum;
    CSeqNum snUpdatePurgeSeqNum;

    pos = m_UpdateWaitingList.GetHeadPosition();
    while (pos != NULL)
    {
        pNextUpdate = m_UpdateWaitingList.GetNext(pos);

        snUpdatePrevSeqNum = pNextUpdate->GetPrevSeqNum();
        snUpdateSeqNum = pNextUpdate->GetSeqNum();
        snUpdatePurgeSeqNum = pNextUpdate->GetPurgeSeqNum();

		if (snUpdatePurgeSeqNum < m_snPurged)
		{
	        m_UpdateWaitingList.RemoveHead();
            DBGMSG((DBGMOD_REPLSERV, DBGLVL_TRACE, TEXT(
               "CDSMaster::CheckWaitingList, old (purge) update in waiting list, skip it"))) ;
            delete pNextUpdate;
			continue;
		}

        if ( snUpdatePrevSeqNum > m_snLSN)
        {
            //
            // some updates are missing, check if indicates next missing window
            //
            if ( snUpdateSeqNum > m_snMissingWindow )
            {
                m_snMissingWindow = snUpdateSeqNum;
                SendSyncRequest();
            }
            return(MQ_OK);
        }

        //
        // can take care of first update in waiting list
        //
        m_UpdateWaitingList.RemoveHead();

        if ( snUpdateSeqNum <= m_snLSN)
        {
            //
            // skip it, we already received and handled it
            //
            DBGMSG((DBGMOD_REPLSERV, DBGLVL_TRACE, TEXT(
              "CDSMaster::CheckWaitingList, old update in waiting list, skip it"))) ;
            delete pNextUpdate;
        }
        else //(snUpdatePrevSeqNum == m_snLSN)
        {
            //
            // time has come to handle this update
            //
            HandleInSyncUpdate(pNextUpdate,TRUE);
        }

        pos = m_UpdateWaitingList.GetHeadPosition();
    }

    return MQ_OK ;
}

/*====================================================

RoutineName
    CDSMaster::AddOutOfSyncUpdate()

Arguments:
            IN CDSUpdate    *pUpdate

Return Value:

Threads:Receive

=====================================================*/

HRESULT CDSMaster::AddOutOfSyncUpdate(CDSUpdate *pUpdate)
{
    POSITION    pos;
    const CSeqNum & sn = pUpdate->GetSeqNum();

    //
    // Check if we already have a missing window
    //

    pos = m_UpdateWaitingList.GetHeadPosition();
    if (pos == NULL)
    {
        //
        // empty list of waiting updates
        // put in list and send a request for sync for missing window
        //

        m_UpdateWaitingList.AddHead(pUpdate);

        if ( sn > m_snMissingWindow)
        {
            m_snMissingWindow = sn;
            SendSyncRequest();
        }

        return(MQ_OK);
    }

    //
    //  The size of waiting list is limited to 100.
    //  The reasons are :
    //  1) Not to keep many updates ( memory consumption)
    //  2) In a non-stressed situation, 100 updates should be sufficient.
    //
    if ( m_UpdateWaitingList.GetCount() < 100)
    {
        //
        // Add out of order Update to sorted wait list
        //

        BOOL flag = FALSE;
        CDSUpdate *pIter;
        CSeqNum  snIterSeq;
        POSITION    PrevPos;

        while (pos != NULL)
        {
            PrevPos = pos;
            pIter = m_UpdateWaitingList.GetNext(pos);

            snIterSeq = pIter->GetSeqNum();

            if ( snIterSeq == sn)
            {
                //
                // skip it, already in waiting list
                //
                DBGMSG((DBGMOD_REPLSERV, DBGLVL_TRACE, TEXT(
                    "CDSMaster::AddOutOfSyncUpdate, already in waiting list, skip it")));
                delete pUpdate;
                return(MQ_OK);
            }
            if ( snIterSeq > sn)
            {
                flag = TRUE;
                m_UpdateWaitingList.InsertBefore(PrevPos,pUpdate);
                break;
            }
        }
        if (!flag)
        {
            m_UpdateWaitingList.AddTail(pUpdate);
        }
    }
    else
    {
        //
        // Too many updates in list, ignore
        //
        DBGMSG((DBGMOD_REPLSERV, DBGLVL_TRACE, TEXT(
                            "Too many updates in waiting list, ignore")));
        delete pUpdate;
    }

    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSMaster::SendSyncRequest()

Arguments:

Return Value:

Threads:Receive, Scheduler

=====================================================*/

void CDSMaster::SendSyncRequest()
{
    CS lock(m_cs);

	if ((m_Sync0State != PURGE_STATE_NORMAL) &&
        (m_Sync0State != PURGE_STATE_SYNC0))
	{
		return;
	}

    try
    {
        ULONG ulPacketSize = CSyncRequestHeader::CalcSize( g_dwMachineNameSize);

        AP<unsigned char> pBuffer = new unsigned char[ ulPacketSize];

#ifdef _DEBUG
#undef new
#endif
        CSyncRequestHeader * pSyncRequest = new(pBuffer) CSyncRequestHeader(
                                        DS_PACKET_VERSION,
                                        &g_MySiteMasterId,
                                        DS_SYNC_REQUEST,
                                        &m_guidMasterId,
                                        m_snLSN,
                                        m_snMissingWindow,
										m_snPurged,
										(unsigned char)((m_Sync0State == PURGE_STATE_SYNC0) ? 1 : 0),
                                        (g_IsPSC) ? ENTERPRISE_SCOPE_FLAG : NO_SCOPE_FLAG,
                                        g_dwMachineNameSize,
                                        g_pwszMyMachineName);
        UNREFERENCED_PARAMETER(pSyncRequest);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
        //
        //  Send sync request to the provider of this Master information
        //
        P<WCHAR>  lpwszAdminQueue = NULL ;
        HRESULT hr = GetMQISAdminQueueName(&lpwszAdminQueue) ;
        if (FAILED(hr))
        {
            ASSERT(0);
            return;
        }

#ifdef _DEBUG
        WCHAR wcsFrom[30];
        WCHAR wcsTo[30];
        m_snLSN.GetValueForPrint( wcsFrom);
        m_snMissingWindow.GetValueForPrint( wcsTo);

        DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO, TEXT(
         "SendSyncRequest: To = %!guid!, from %ls to %ls sync0 is %x. MyResp- %ls"),
               &m_guidMasterId, wcsFrom, wcsTo, m_Sync0State, lpwszAdminQueue)) ;
#endif
        
        BOOL f = g_Counters.IncrementInstanceCounter(m_pwcsPathName, eSyncRequestSent);
        UNREFERENCED_PARAMETER(f);

        Send( pBuffer,
              ulPacketSize,
              g_dwReplicationMsgTimeout,
              MQMSG_ACKNOWLEDGMENT_NACK_REACH_QUEUE,
              DS_REPLICATION_PRIORITY,
              lpwszAdminQueue ) ;
    }
    catch(const bad_alloc&)
    {
        //
        //  Not enoght resources; try latter
        //
    }

    //
    //  Schedule a routine to check reply of the sync request
    //
	//GUID * pguidMasterId = new GUID(m_guidMasterId);
    if (!m_fScheduledSyncReply)
    {
        NOT_YET_IMPLEMENTED(TEXT("QMSetTimer(CheckSyncReplMsg)"), s_fTimer) ;
//////// QMSetTimer( (2 * g_dwReplicationMsgTimeout)* 1000  + HEAVY_REQUEST_WAIT_TO_HANDLE, CheckSyncReplMsg,pguidMasterId, 0);
        m_fScheduledSyncReply = TRUE;
    }
}

/*====================================================

RoutineName
    CDSMaster::Hello()

Arguments:
            IN CDSUpdate    *pUpdate

Return Value:

Threads:Receive, Scheduler

=====================================================*/

void CDSMaster::Hello(IN const unsigned char *pName,
					  IN const CSeqNum & snHelloLSN,
					  IN const CSeqNum & snAllowedPurge)
{
    CS lock(m_cs);

	if (snAllowedPurge < m_snPurged)
	{
		//
		// In MSMQ1.0, this meant old hello recevied by local MQIS server.
        //
        // This "if" is from MSMQ1.0 code. We keep it here just for
        // documentation.
        // each hello message contain two sequence numbers. when
        // MasterA send hello to MasterB, the numbers are:
        // 1. The highest seq number of objects created and owned by MasterA.
        //    If MasterB (local machine) missed some replication from
        //    MasterA (highest seqnum of MasterA on local DS is less than
        //    the number in the hello message) then MasterB ask for sync.
        //    this number is checked in the "if" below.
        // 2. The highest seq number of MasterA which MasterB can purge from
        //    its "deleted" table. i.e., MasterB can purge from its local
        //    DS all deleted object owned by MasterA up to this number.
        // On NT5, the DS itself manage its deleted objects and we can't
        // do anything with them. We can't purge anything. So we just ignore
        // this number (2).
		//
	}

    if ( (snHelloLSN <= m_snLSN) || (snHelloLSN < m_snMissingWindow) )
    {
        //
        // We already got a newer update or hello.
        // this is (1), from the description above.
        //
        return;
    }

    if (pName)
    {
        DWORD size = UnalignedWcslen((const unsigned short*)pName) + 1 ;
        LPWSTR pwszNewPathName= new WCHAR[size];
        AP<WCHAR> pPathName= pwszNewPathName;
        memcpy(pwszNewPathName, pName, size*sizeof(WCHAR));

        if (g_IsPSC)
        {
            if (lstrcmpi(pwszNewPathName,m_pwcsPathName))
            {
                //
                // there is a change in the PathName
                //
                pPathName.detach();
                NOT_YET_IMPLEMENTED(TEXT("ChangePSC(pwszNewPathName)"), s_fChangePSC) ;
/////////////////ChangePSC(pwszNewPathName);
            }
        }
        else
        {
            //
            // BSC
            //
            if (lstrcmpi(g_pMySiteMaster->GetPathName(),pwszNewPathName))
            {
                pPathName.detach();
                NOT_YET_IMPLEMENTED(TEXT("->ChangePSC(pwszNewPathName)"), s_fChangePSC) ;
//////////////////g_pMySiteMaster->ChangePSC(pwszNewPathName);
            }
        }
    }

    m_snMissingWindow = snHelloLSN;
    m_snMissingWindow.Increment();

    SendSyncRequest();
}

/*====================================================

RoutineName
    ReceiveSyncReplyMessage()

Arguments:
    IN unsigned char *pBuf  : stream of sync updates
    IN DWORD        TotalSize: size of stream in bytes

Return Value:

Threads:Receive

=====================================================*/

HRESULT CDSMaster::ReceiveSyncReplyMessage( IN DWORD dwCount,
                                            IN const CSeqNum &  snUpper,
                                            IN const CSeqNum &  snPurge,
											IN DWORD dwCompleteSync0,
                                            IN  const unsigned char *   pBuf,
                                            IN  DWORD           dwTotalSize)
{
    {
		CS lock(m_cs);
		if (snPurge < m_snPurged)
		{
			//
			// old skip it
			//
			return MQSync_OK ;
		}
	}

    HRESULT hr;
    const unsigned char *ptr;
    DWORD   dwSum,dwSize;

    ptr = pBuf;
    dwSum = 0;

    while (dwSum < dwTotalSize)
    {
        CDSUpdate *pUpdate = new CDSUpdate;

        hr = pUpdate->Init(ptr, &dwSize, TRUE);
        if (FAILED(hr))
        {
            //
            // We don't want to read junked values
            // Another sync request will be reissued later
            //
            DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
                "ReceiveSyncReplyMessage: Error while parsing an update"))) ;
            delete pUpdate;
            break;
        }
        dwSum += dwSize;
        ptr += dwSize;

        //
        //  Pass the update to that source master object.
        //  The master object tracks sequence numbers, initiaites sync requests
        //  when required, and forwards the update to relevant neighbors
        //
        hr = AddUpdate(pUpdate,TRUE);
        if (FAILED(hr))
        {
            continue;
        }
    }

    CS lock(m_cs);
	ASSERT(!snUpper.IsInfiniteLsn());
	if (m_Sync0State == PURGE_STATE_SYNC0)
	{
        NOT_YET_IMPLEMENTED(TEXT("CDSMaster::ReceiveSyncReplyMessage"),
                                                        s_fReceiveRepl) ;
#if 0
		if (snPurge < m_snPurged)
		{
			//
			// old skip it
			//
			return(MQ_OK);
		}
		if (dwCompleteSync0 == COMPLETE_SYNC0_NOW)
		{
			if (!m_snLSN.IsSmallerByMoreThanOne( snUpper))
			{
				//
				// It indicates that the Sync0 can be completed NOW
				// Schedule a routine to try COMPLETE SYNC0 later (heavy operation)
				//
				HEAVY_REQUEST_PARAMS * pCompleteSync0 = new HEAVY_REQUEST_PARAMS;
				pCompleteSync0->dwType = MQIS_SCHED_COMPLETE_SYNC0;
				pCompleteSync0->guidSourceMasterId = m_guidMasterId;
				g_HeavyRequestHandler.Add(pCompleteSync0);
			}
		}
		else if (dwCompleteSync0 == COMPLETE_SYNC0_SOON)
		{
			//
			// last time we got a big answer, however there where very few additional answers
			// send request now to get a compete comfirmation right away (do not wait for CheckSyncRequest)
			//
			SendSyncRequest();
		}
#endif
	}
	else if (m_Sync0State == PURGE_STATE_NORMAL)
	{

		if ( m_snMissingWindow.IsInfiniteLsn())
		{
			//
			// The first time we ask for a sync in order to start geting
            // replications. Since we got a replication, no need to
            // re-check and ask for sync again.
			//
			m_snMissingWindow.SetSmallestValue();
		}
		else
		{
			if (dwCount == 0)
			{
				//
				// If we get an empty sync reply, it means that nothing
                // is missing any more.
				//
				if (m_snMissingWindow == snUpper)
				{
					m_snMissingWindow.SetSmallestValue();
				}
				if (m_snLSN.IsSmallerByMoreThanOne( snUpper) &&
					 !snUpper.IsInfiniteLsn())
				{
					m_snLSN = snUpper;				
					m_snLSN.Decrement();
				}

				//
				// Check if it there are updates in waiting list that can
                // be handled now
				//
				hr = CheckWaitingList();
				if FAILED(hr)
				{
					return(hr);
				}
			}
		}
	}

    return MQSync_OK ;
}

/*====================================================

RoutineName
    CDSMaster::SendSyncRequest()

Arguments:

Return Value:

Threads:Receive, Scheduler

=====================================================*/

void CDSMaster::SendPSCAck(GUID *pGuidMaster)
{

    try
    {
        ULONG ulPacketSize = CPSCAckHeader::CalcSize(g_dwMachineNameSize);

        AP<unsigned char> pBuffer = new unsigned char[ ulPacketSize];

#ifdef _DEBUG
#undef new
#endif
        CPSCAckHeader * pPSCAck = new(pBuffer) CPSCAckHeader(
                                        DS_PACKET_VERSION,
                                        DS_PSC_ACK,
                                        pGuidMaster, //master that send ack about m_guidMasterId
                                        g_dwMachineNameSize,
                                        g_pwszMyMachineName,
                                        &m_guidMasterId, //master that receive ack
                                        m_snLSN);
        UNREFERENCED_PARAMETER(pPSCAck);
#ifdef _DEBUG
#define new DEBUG_NEW
#endif
        //
        //  Send PSC ACK to the owner of this Master information
        //
        P<WCHAR>  lpwszAdminQueue = NULL ;
        HRESULT hr = GetMQISAdminQueueName(&lpwszAdminQueue) ;
        if (FAILED(hr))
        {
            ASSERT(0);
            return;
        }

#ifdef _DEBUG
        WCHAR wcsLSN[30];
        m_snLSN.GetValueForPrint( wcsLSN);

        DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO, TEXT(
            "SendPSCAck Message: Master = %!guid! about Master = %!guid! LSN ACK %ls, MyResp- %ls"),
                                    pGuidMaster, &m_guidMasterId, wcsLSN, lpwszAdminQueue)) ;
#endif

        Send( pBuffer,
              ulPacketSize,
              g_dwReplicationMsgTimeout,
              MQMSG_ACKNOWLEDGMENT_NACK_REACH_QUEUE,
              DS_REPLICATION_PRIORITY,
              lpwszAdminQueue ) ;

    }
    catch(const bad_alloc&)
    {
        //
        //  Not enoght resources; try latter
        //
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\mqispkt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqispkt.h

Abstract:

    MQIS message header definition

Author:


--*/

#ifndef __MQISPKT_H
#define __MQISPKT_H

size_t  UnalignedWcslen (const wchar_t UNALIGNED * wcs);

//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//
//  struct CBasicMQISHeader
//
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CBasicMQISHeader {
public:
    inline CBasicMQISHeader( const unsigned char ucVersion,
                             const GUID *        pguidSiteId,
                             const unsigned char ucOperation);
    inline CBasicMQISHeader();
    static ULONG CalcSize( void);

    inline const unsigned char GetVersion(void) const;
    inline void GetSiteId(GUID * pguidId) const;
    inline const unsigned char GetOperation( void) const;

private:
//
// BEGIN Network Monitor tag
//

    unsigned char   m_ucVersion;
    GUID            m_guidSiteId;
    unsigned char   m_ucOperation;
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)
/*======================================================================

 Function:     CBasicMQISHeader::CBasicMQISHeader

 Description:  constructor for transmitted message

 =======================================================================*/

inline CBasicMQISHeader::CBasicMQISHeader( const unsigned char ucVersion,
                                           const GUID *        pguidSiteId,
                                           const unsigned char ucOperation) :
                               m_ucVersion( ucVersion),
                               m_ucOperation( ucOperation)
{
    memcpy(&m_guidSiteId, pguidSiteId, sizeof(GUID));

}
/*======================================================================

 Function:     CBasicMQISHeader::CBasicMQISHeader

 Description:  constructor for received messages

 =======================================================================*/

inline CBasicMQISHeader::CBasicMQISHeader( )
{

}
/*======================================================================

 Function:     CBasicMQISHeader::CalcSize

 Description:  calculates message size

 =======================================================================*/
inline ULONG CBasicMQISHeader::CalcSize(  void)
{
    return( sizeof(CBasicMQISHeader));
}
/*======================================================================

 Function:     CBasicMQISHeader::GetVersion

 Description:  returns the version number

 =======================================================================*/
inline const unsigned char CBasicMQISHeader::GetVersion(void) const
{
    return m_ucVersion;
}

/*======================================================================

 Function:     CBasicMQISHeader::GetSiteId

 Description:  returns the version number

 =======================================================================*/
inline void CBasicMQISHeader::GetSiteId(GUID * pguidId) const
{
    memcpy( pguidId, &m_guidSiteId, sizeof(GUID));
}

/*======================================================================

 Function:     CBasicMQISHeader::GetOperation

 Description:  returns the version number

 =======================================================================*/
inline const unsigned char CBasicMQISHeader::GetOperation(void) const
{
    return m_ucOperation;
}


//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//
// struct CSyncRequestHeader
//
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CSyncRequestHeader {
public:

    inline CSyncRequestHeader( const unsigned char ucVersion,
                               const GUID *        pguidSiteId,
                               const unsigned char ucOperation,
                               const GUID *        pguidMasterId,
                               const CSeqNum  &    FromSN,
                               const CSeqNum  &    ToSN,
                               const CSeqNum  &    KnownPurgedSN,
							   const unsigned char ucIsSync0,
                               const unsigned char ucScope,
                               DWORD               dwRequesterNameLength,
                               LPWSTR              pwcsRequesterName);

    inline  CSyncRequestHeader();

    static ULONG CalcSize(  DWORD             dwRequesterNameLength);

    inline const GUID * GetMasterId() const;
    inline const DWORD GetRequesterNameSize() const;
    inline void GetRequesterName( char * pBuf, DWORD size) const;
    inline void GetFromSN( CSeqNum * FromSN) const;
    inline void GetToSN( CSeqNum * ToSN) const;
    inline void GetKnownPurgedSN( CSeqNum * FromSN) const;
    inline const unsigned char IsSync0() const;
    inline const unsigned char GetScope() const;


private:
//
// BEGIN Network Monitor tag
//
    CBasicMQISHeader  m_BasicHeader;
    GUID            m_guidMasterId;
    unsigned char   m_FromSN[ sizeof(_SEQNUM)];
    unsigned char   m_ToSN[ sizeof(_SEQNUM)];
    unsigned char   m_KnownPurgedSN[ sizeof(_SEQNUM)];
	unsigned char	m_ucIsSync0;
    unsigned char   m_ucScope;
    WCHAR           m_RequesterName[0]; //vairable length, must be last
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*======================================================================

 Function:     CSyncRequestHeader::CSyncRequestHeader

 Description:  constructor for transmitted message

 =======================================================================*/

inline CSyncRequestHeader::CSyncRequestHeader( const unsigned char ucVersion,
                               const GUID *        pguidSiteId,
                               const unsigned char ucOperation,
                               const GUID *        pguidMasterId,
                               const CSeqNum  &    FromSN,
                               const CSeqNum  &    ToSN,
                               const CSeqNum  &    KnownPurgedSN,
							   const unsigned char ucIsSync0,
                               const unsigned char ucScope,
                               DWORD               dwRequesterNameLength,
                               LPWSTR              pwcsRequesterName) :
                               m_BasicHeader( ucVersion,  pguidSiteId, ucOperation),
                               m_ucIsSync0( ucIsSync0),
                               m_ucScope( ucScope)
{
    ASSERT( CSeqNum::GetSerializeSize() == sizeof(_SEQNUM));
    memcpy(&m_guidMasterId, pguidMasterId, sizeof(GUID));
    FromSN.Serialize( m_FromSN);
    ToSN.Serialize( m_ToSN);
    KnownPurgedSN.Serialize( m_KnownPurgedSN);
    memcpy(m_RequesterName, pwcsRequesterName, dwRequesterNameLength);
}
/*======================================================================

 Function:     CSyncRequestHeader::CSyncRequestHeader

 Description:  constructor for received message

 =======================================================================*/
inline CSyncRequestHeader::CSyncRequestHeader()
{
}
/*======================================================================

 Function:     CSyncRequestHeader::CalcSize

 Description:  calculates message size

 =======================================================================*/

inline ULONG CSyncRequestHeader::CalcSize(  DWORD             dwRequesterNameLength)
{
    return( dwRequesterNameLength + sizeof(CSyncRequestHeader) );
}
/*======================================================================

 Function:     CSyncRequestHeader::GetMasterId

 Description:  returns the master id

 =======================================================================*/

inline const GUID * CSyncRequestHeader::GetMasterId() const
{
    return(&m_guidMasterId);
}
/*======================================================================

 Function:     CSyncRequestHeader::GetRequesterNameSize

 Description:  returns the requester name size

 =======================================================================*/
inline const DWORD CSyncRequestHeader::GetRequesterNameSize() const
{
    return( (1 + UnalignedWcslen( m_RequesterName)) * sizeof(WCHAR));
}
/*======================================================================

 Function:     CSyncRequestHeader::GetRequesterName

 Description:  returns the requester name

 =======================================================================*/

inline void CSyncRequestHeader::GetRequesterName(  char * pBuf, DWORD size) const
{
    memcpy( pBuf, m_RequesterName, size);
}

/*======================================================================

 Function:     CSyncRequestHeader::GetFromSN

 Description:  returns the "from sn"

 =======================================================================*/
inline void CSyncRequestHeader::GetFromSN(CSeqNum * FromSN) const
{
    FromSN->SetValue(m_FromSN);
}
/*======================================================================

 Function:     CSyncRequestHeader::GetToSN

 Description:  returns the "to sn"

 =======================================================================*/
inline void CSyncRequestHeader::GetToSN( CSeqNum * ToSN) const
{
    ToSN->SetValue( m_ToSN);
}
/*======================================================================

 Function:     CSyncRequestHeader::GetKnownPurgedSN

 Description:  returns requestor known purged sn

 =======================================================================*/
inline void CSyncRequestHeader::GetKnownPurgedSN( CSeqNum * KnownPurgedSN) const
{
    KnownPurgedSN->SetValue( m_KnownPurgedSN);
}

/*======================================================================

 Function:     CSyncRequestHeader::GetScope

 Description:  returns scope

 =======================================================================*/
inline const unsigned char CSyncRequestHeader::GetScope() const
{
    return(m_ucScope);
}

/*======================================================================

 Function:     CSyncRequestHeader::IsSync0

 Description:  returns scope

 =======================================================================*/
inline const unsigned char CSyncRequestHeader::IsSync0() const
{
    return(m_ucIsSync0);
}


//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//
// struct CPSCAckHeader
//
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CPSCAckHeader {
public:

    inline CPSCAckHeader( const unsigned char ucVersion,
                          const unsigned char ucOperation,
                          const GUID *        pguidPSCMasterId,
                          const DWORD         dwPSCNameLength,
                          const LPWSTR        pwcsPSCName,
                          const GUID *        pguidAckedMasterId,
                          const CSeqNum  &    snAcked);

    inline  CPSCAckHeader();

    static ULONG CalcSize(  DWORD dwPSCNameLength);

    inline const GUID * GetPSCMasterId() const;
    inline const DWORD GetPSCNameSize() const;
    inline void GetPSCName( char * pBuf, DWORD size) const;
    inline const GUID * GetAckedMasterId() const;
    inline void GetAckedSN( CSeqNum * psnAcked) const;


private:
//
// BEGIN Network Monitor tag
//
    CBasicMQISHeader  m_BasicHeader;
    GUID            m_guidPSCMasterId;
    GUID            m_guidAckedMasterId;
    unsigned char   m_snAcked[ sizeof(_SEQNUM)];
    WCHAR           m_PSCName[0]; //vairable length, must be last
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*======================================================================

 Function:     CPSCAckHeader::CPSCAckHeader

 Description:  constructor for transmitted message

 =======================================================================*/

inline CPSCAckHeader::CPSCAckHeader( const unsigned char ucVersion,
                               const unsigned char ucOperation,
                               const GUID *        pguidPSCMasterId,
                               const DWORD         dwPSCNameLength,
                               const LPWSTR        pwcsPSCName,
                               const GUID *        pguidAckedMasterId,
                               const CSeqNum  &    snAcked) :
                               m_BasicHeader( ucVersion,  pguidPSCMasterId, ucOperation)
{
    ASSERT( CSeqNum::GetSerializeSize() == sizeof(_SEQNUM));
    memcpy(&m_guidPSCMasterId, pguidPSCMasterId, sizeof(GUID));
    memcpy(&m_guidAckedMasterId, pguidAckedMasterId, sizeof(GUID));
    snAcked.Serialize( m_snAcked);
    memcpy(m_PSCName, pwcsPSCName, dwPSCNameLength);
}
/*======================================================================

 Function:     CPSCAckHeader::CPSCAckHeader

 Description:  constructor for received message

 =======================================================================*/
inline CPSCAckHeader::CPSCAckHeader()
{
}
/*======================================================================

 Function:     CPSCAckHeader::CalcSize

 Description:  calculates message size

 =======================================================================*/

inline ULONG CPSCAckHeader::CalcSize(  DWORD dwPSCNameLength)
{
    return( dwPSCNameLength + sizeof(CPSCAckHeader) );
}
/*======================================================================

 Function:     CPSCAckHeader::GetPSCMasterId

 Description:  returns the master id

 =======================================================================*/

inline const GUID * CPSCAckHeader::GetPSCMasterId() const
{
    return(&m_guidPSCMasterId);
}
/*======================================================================

 Function:     CPSCAckHeader::GetPSCNameSize

 Description:  returns the PSC name size

 =======================================================================*/
inline const DWORD CPSCAckHeader::GetPSCNameSize() const
{
    return( (1 + UnalignedWcslen( m_PSCName)) * sizeof(WCHAR));
}
/*======================================================================

 Function:     CPSCAckHeader::GetPSCName

 Description:  returns the PSC name

 =======================================================================*/

inline void CPSCAckHeader::GetPSCName(  char * pBuf, DWORD size) const
{
    memcpy( pBuf, m_PSCName, size);
}

/*======================================================================

 Function:     CPSCAckHeader::GetAckedMasterId

 Description:  returns the master id

 =======================================================================*/

inline const GUID * CPSCAckHeader::GetAckedMasterId() const
{
    return(&m_guidAckedMasterId);
}
/*======================================================================

 Function:     CPSCAckHeader::GetAckedSN

 Description:  returns the "from sn"

 =======================================================================*/
inline void CPSCAckHeader::GetAckedSN(CSeqNum * pAckedSN) const
{
    pAckedSN->SetValue(m_snAcked);
}


//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//
// struct CBSCAckHeader
//
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CBSCAckHeader {
public:

    inline CBSCAckHeader( const unsigned char ucVersion,
                          const unsigned char ucOperation,
                          const GUID *        pguidSiteId,
                          const GUID *        pguidBSCMachineId,
                          const DWORD         dwBSCNameLength,
                          const LPWSTR        pwcsBSCName);

    inline  CBSCAckHeader();

    static ULONG CalcSize(  DWORD dwBSCNameLength);

    inline const GUID * GetBSCMachineId() const;
    inline const DWORD GetBSCNameSize() const;
    inline void GetBSCName( char * pBuf, DWORD size) const;


private:
//
// BEGIN Network Monitor tag
//
    CBasicMQISHeader  m_BasicHeader;
    GUID            m_guidBSCMachineId;
    WCHAR           m_BSCName[0]; //vairable length, must be last
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*======================================================================

 Function:     CBSCAckHeader::CBSCAckHeader

 Description:  constructor for transmitted message

 =======================================================================*/

inline CBSCAckHeader::CBSCAckHeader( const unsigned char ucVersion,
                               const unsigned char ucOperation,
                               const GUID *        pguidSiteId,
                               const GUID *        pguidBSCMachineId,
                               const DWORD         dwBSCNameLength,
                               const LPWSTR        pwcsBSCName) :
                               m_BasicHeader( ucVersion,  pguidSiteId, ucOperation)
{
    memcpy(&m_guidBSCMachineId, pguidBSCMachineId, sizeof(GUID));
    memcpy(m_BSCName, pwcsBSCName, dwBSCNameLength);
}
/*======================================================================

 Function:     CBSCAckHeader::CBSCAckHeader

 Description:  constructor for received message

 =======================================================================*/
inline CBSCAckHeader::CBSCAckHeader()
{
}
/*======================================================================

 Function:     CBSCAckHeader::CalcSize

 Description:  calculates message size

 =======================================================================*/

inline ULONG CBSCAckHeader::CalcSize(  DWORD  dwBSCNameLength)
{
    return( dwBSCNameLength + sizeof(CBSCAckHeader) );
}
/*======================================================================

 Function:     CBSCAckHeader::GetPSCMasterId

 Description:  returns the BSC machine id

 =======================================================================*/

inline const GUID * CBSCAckHeader::GetBSCMachineId() const
{
    return(&m_guidBSCMachineId);
}
/*======================================================================

 Function:     CBSCAckHeader::GetBSCNameSize

 Description:  returns the BSC name size

 =======================================================================*/
inline const DWORD CBSCAckHeader::GetBSCNameSize() const
{
    return( (1 + UnalignedWcslen( m_BSCName)) * sizeof(WCHAR));
}
/*======================================================================

 Function:     CBSCAckHeader::GetBSCName

 Description:  returns the BSC name

 =======================================================================*/

inline void CBSCAckHeader::GetBSCName(  char * pBuf, DWORD size) const
{
    memcpy( pBuf, m_BSCName, size);
}



//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//
// struct CSyncReplyHeader
//
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

#define COMPLETE_SYNC0_NONE 0
#define COMPLETE_SYNC0_SOON 1
#define COMPLETE_SYNC0_NOW  2

struct CSyncReplyHeader {
public:

    inline CSyncReplyHeader( const unsigned char ucVersion,
                               const GUID *        pguidSiteId,
                               const unsigned char ucOperation,
                               const GUID *        pguidMasterId,
                               const CSeqNum  &    FromSN,
                               const CSeqNum  &    ToSN,
							   const CSeqNum  &    PurgeSN,
                               const DWORD         dwCount);

    inline  CSyncReplyHeader();

    static ULONG CalcSize( );

    inline void SetToSeqNum( CSeqNum & ToSN);

    inline const GUID * GetMasterId( ) const;
    inline void GetFromSeqNum( CSeqNum * pFromSN) const;
    inline void GetToSeqNum( CSeqNum * pToSN) const;
    inline void GetPurgeSeqNum( CSeqNum * pPurgeSN) const;
    inline void GetCount( DWORD * pdwCount) const;
	inline DWORD GetCompleteSync0() const;
	inline void SetCompleteSync0(DWORD dw);

private:
//
// BEGIN Network Monitor tag
//

    CBasicMQISHeader  m_BasicHeader;
    GUID            m_guidMasterId;
    unsigned char   m_FromSN[sizeof(_SEQNUM)];
    unsigned char   m_ToSN[sizeof(_SEQNUM)];
    unsigned char   m_PurgeSN[sizeof(_SEQNUM)];
    DWORD           m_dwCount;
    DWORD           m_dwCompleteSync0;
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*======================================================================

 Function:     CSyncReplyHeader::CSyncReplyHeader

 Description:  constructor for transmitted messages

 =======================================================================*/
inline CSyncReplyHeader::CSyncReplyHeader( const unsigned char ucVersion,
                               const GUID *        pguidSiteId,
                               const unsigned char ucOperation,
                               const GUID *        pguidMasterId,
                               const CSeqNum   &   FromSN,
                               const CSeqNum   &   ToSN,
                               const CSeqNum   &   PurgeSN,
                               const DWORD         dwCount):
                               m_BasicHeader( ucVersion, pguidSiteId, ucOperation),
							   m_dwCompleteSync0(COMPLETE_SYNC0_NONE)
{
    memcpy( &m_guidMasterId, pguidMasterId, sizeof(GUID));
    FromSN.Serialize( m_FromSN);
    ToSN.Serialize( m_ToSN);
    PurgeSN.Serialize( m_PurgeSN);
    memcpy( &m_dwCount, &dwCount, sizeof(DWORD));

}
/*======================================================================

 Function:     CSyncReplyHeader::CSyncReplyHeader

 Description:  constructor for received messages

 =======================================================================*/
inline CSyncReplyHeader::CSyncReplyHeader( )
{
}

/*======================================================================

 Function:     CSyncReplyHeader::CalcSize

 Description:  calculates message size

 =======================================================================*/
inline ULONG CSyncReplyHeader::CalcSize( )
{
    return( sizeof(CSyncReplyHeader) );
}
/*======================================================================

 Function:     CSyncReplyHeader::SetToSeqNum

 Description:  sets "to SN"

 =======================================================================*/

inline void CSyncReplyHeader::SetToSeqNum( CSeqNum & ToSN)
{
    ToSN.Serialize( m_ToSN);
}

/*======================================================================

 Function:     CSyncReplyHeader::GetMasterId

 Description:  returns master id

 =======================================================================*/
inline const GUID * CSyncReplyHeader::GetMasterId() const
{
    return(&m_guidMasterId);
}
/*======================================================================

 Function:     CSyncReplyHeader::GetFromSeqNum

 Description:  returns "from sn"

 =======================================================================*/
inline void CSyncReplyHeader::GetFromSeqNum( CSeqNum * pFromSN) const
{
    pFromSN->SetValue( m_FromSN);
}
/*======================================================================

 Function:     CSyncReplyHeader::GetToSeqNum

 Description:  returns "to sn"

 =======================================================================*/
inline void CSyncReplyHeader::GetToSeqNum( CSeqNum * pToSN) const
{
    pToSN->SetValue( m_ToSN);
}
/*======================================================================

 Function:     CSyncReplyHeader::GetPurgeSeqNum

 Description:  returns "purge sn"

 =======================================================================*/
inline void CSyncReplyHeader::GetPurgeSeqNum( CSeqNum * pPurgeSN) const
{
    pPurgeSN->SetValue( m_PurgeSN);
}
/*======================================================================

 Function:     CSyncReplyHeader::GetCount

 Description:  returns count

 =======================================================================*/
inline void CSyncReplyHeader::GetCount( DWORD * pdwCount) const
{
    memcpy( pdwCount, &m_dwCount, sizeof(DWORD));
}
/*======================================================================

 Function:     CSyncReplyHeader::IsCompleteSync0

 Description:  returns count

 =======================================================================*/
inline DWORD CSyncReplyHeader::GetCompleteSync0() const
{
	return m_dwCompleteSync0;
}

/*======================================================================

 Function:     CSyncReplyHeader::SetCompleteSync0

 Description:  returns count

 =======================================================================*/
inline void CSyncReplyHeader::SetCompleteSync0(DWORD dw)
{
	m_dwCompleteSync0 = dw;
}
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//
// struct CAlreadyPurgedReplyHeader
//
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CAlreadyPurgedReplyHeader {
public:

    inline CAlreadyPurgedReplyHeader( const unsigned char ucVersion,
                               const GUID *        pguidSiteId,
                               const unsigned char ucOperation,
                               const GUID *        pguidMasterId,
                               const CSeqNum  &    PurgedSN);

    inline  CAlreadyPurgedReplyHeader();

    static ULONG CalcSize( );

    inline const GUID * GetMasterId( ) const;
    inline void GetPurgedSeqNum( CSeqNum * pPurgedSN) const;

private:
//
// BEGIN Network Monitor tag
//

    CBasicMQISHeader  m_BasicHeader;
    GUID            m_guidMasterId;
    unsigned char   m_PurgedSN[sizeof(_SEQNUM)];
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*======================================================================

 Function:     CAlreadyPurgedReplyHeader::CAlreadyPurgedReplyHeader

 Description:  constructor for transmitted messages

 =======================================================================*/
inline CAlreadyPurgedReplyHeader::CAlreadyPurgedReplyHeader( const unsigned char ucVersion,
                               const GUID *        pguidSiteId,
                               const unsigned char ucOperation,
                               const GUID *        pguidMasterId,
                               const CSeqNum   &   PurgedSN):
                               m_BasicHeader( ucVersion, pguidSiteId, ucOperation)
{
    memcpy( &m_guidMasterId, pguidMasterId, sizeof(GUID));
    PurgedSN.Serialize( m_PurgedSN);
}
/*======================================================================

 Function:     CAlreadyPurgedReplyHeader::CAlreadyPurgedReplyHeader

 Description:  constructor for received messages

 =======================================================================*/
inline CAlreadyPurgedReplyHeader::CAlreadyPurgedReplyHeader( )
{
}

/*======================================================================

 Function:     CAlreadyPurgedReplyHeader::CAlreadyPurgedReplyHeader

 Description:  calculates message size

 =======================================================================*/
inline ULONG CAlreadyPurgedReplyHeader::CalcSize( )
{
    return( sizeof(CAlreadyPurgedReplyHeader) );
}
/*======================================================================

 Function:     CAlreadyPurgedReplyHeader::GetMasterId

 Description:  returns master id

 =======================================================================*/
inline const GUID * CAlreadyPurgedReplyHeader::GetMasterId() const
{
    return(&m_guidMasterId);
}
/*======================================================================

 Function:     CAlreadyPurgedReplyHeader::GetPurgedSeqNum

 Description:  returns "purged sn"

 =======================================================================*/
inline void CAlreadyPurgedReplyHeader::GetPurgedSeqNum( CSeqNum * pPurgedSN) const
{
    pPurgedSN->SetValue( m_PurgedSN);
}
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//
// struct CWriteRequestHeader
//
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CWriteRequestHeader {
public:

    inline CWriteRequestHeader( const unsigned char ucVersion,
                                const GUID *        pguidSiteId,
                                const unsigned char ucOperation,
                                const GUID *        pguidMasterId,
                                const DWORD         dwHandle,
                                const DWORD         dwRequesterNamesize,
                                const WCHAR *       pwcsRequesterName,
                                const DWORD         dwPSCNameSize,
                                const WCHAR *       pwcsPSCName);
    inline  CWriteRequestHeader();

    static ULONG CalcSize(  DWORD             dwRequesterNameLength,
                            DWORD             dwIntermidiatePSCNameLength);

    inline const DWORD GetRequesterNameSize() const;
    inline const DWORD GetIntermidiatePSCNameSize() const;
    inline const GUID * GetOwnerId() const;
    inline void GetHandle( DWORD * pdwHandle) const;
    inline void GetRequesterName(  WCHAR * pBuf, DWORD size) const;
    inline void GetPSCName(  WCHAR * pBuf, DWORD size) const;
private:

//
// BEGIN Network Monitor tag
//
    CBasicMQISHeader  m_BasicHeader;
    GUID              m_guidOwnerId;
    DWORD             m_hInternal;
    DWORD             m_OffsetPSCName;  // if zero, than PSC name not included
    WCHAR             m_wcsNames[0];    //must be last
                                        //includes requester name, and PSC name if required
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)


/*======================================================================

 Function:     CWriteRequestHeader::CWriteRequestHeader

 Description:  constructor for transmitted messages

 =======================================================================*/
inline CWriteRequestHeader::CWriteRequestHeader(
                                const unsigned char ucVersion,
                                const GUID *        pguidSiteId,
                                const unsigned char ucOperation,
                                const GUID *        pguidMasterId,
                                const DWORD         dwHandle,
                                const DWORD         dwRequesterNamesize,
                                const WCHAR *       pwcsRequesterName,
                                const DWORD         dwPSCNameSize,
                                const WCHAR *       pwcsPSCName) :
                                m_BasicHeader( ucVersion,  pguidSiteId, ucOperation)
{
    memcpy(&m_guidOwnerId, pguidMasterId, sizeof(GUID));
    memcpy(&m_hInternal, &dwHandle, sizeof(DWORD));
    memcpy(m_wcsNames, pwcsRequesterName, dwRequesterNamesize);
    if ( dwPSCNameSize)
    {
        m_OffsetPSCName = dwRequesterNamesize / sizeof(WCHAR);
        memcpy( &m_wcsNames[ m_OffsetPSCName], pwcsPSCName, dwPSCNameSize);
    }
    else
    {
        //
        //  No intermidiate PSC name
        //
        m_OffsetPSCName = 0;
    }

}
/*======================================================================

 Function:     CWriteRequestHeader::CWriteRequestHeader

 Description:  constructor for received messages

 =======================================================================*/
inline CWriteRequestHeader::CWriteRequestHeader()
{
}
/*======================================================================

 Function:     CWriteRequestHeader::CalcSize

 Description:  calculates message size

 =======================================================================*/

inline  ULONG CWriteRequestHeader::CalcSize(  DWORD             dwRequesterNameLength,
                            DWORD             dwIntermidiatePSCNameLength)
{
    return( dwRequesterNameLength +
        dwIntermidiatePSCNameLength +
        sizeof(CWriteRequestHeader) );
}

/*======================================================================

 Function:     CWriteRequestHeader::GetRequesterNameSize

 Description:  return requester name size

 =======================================================================*/
inline const DWORD CWriteRequestHeader::GetRequesterNameSize() const
{
    return( ( 1 + UnalignedWcslen( m_wcsNames)) * sizeof(WCHAR));
}
/*======================================================================

 Function:     CWriteRequestHeader::GetIntermidiatePSCNameSize

 Description:  return intermidiate psc name size

 =======================================================================*/
inline const DWORD CWriteRequestHeader::GetIntermidiatePSCNameSize() const
{
    if ( m_OffsetPSCName)
    {
        return( ( 1 + UnalignedWcslen( &m_wcsNames[m_OffsetPSCName])) * sizeof(WCHAR));
    }
    else
    {
        return(0);
    }
}
/*======================================================================

 Function:     CWriteRequestHeader::GetOwnerId

 Description:  return owner id

 =======================================================================*/
inline const GUID * CWriteRequestHeader::GetOwnerId( ) const
{
    return(&m_guidOwnerId);
}
/*======================================================================

 Function:     CWriteRequestHeader::GetHandle

 Description:  return handle

 =======================================================================*/
inline void CWriteRequestHeader::GetHandle( DWORD * pdwHandle) const
{
    memcpy( pdwHandle, &m_hInternal, sizeof(DWORD));
}
/*======================================================================

 Function:     CWriteRequestHeader::GetRequesterName

 Description:  return requester name

 =======================================================================*/
inline void CWriteRequestHeader::GetRequesterName(  WCHAR * pBuf, DWORD size) const
{
    memcpy( pBuf, m_wcsNames, size);
}
/*======================================================================

 Function:     CWriteRequestHeader::GetPSCName

 Description:  return intermidiate psc name

 =======================================================================*/
inline void CWriteRequestHeader::GetPSCName(  WCHAR * pBuf, DWORD size) const
{
    ASSERT(m_OffsetPSCName != 0);
    memcpy( pBuf, &m_wcsNames[ m_OffsetPSCName], size);
}

//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//
// struct CWriteReplyHeader
//
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CWriteReplyHeader {
public:

    inline CWriteReplyHeader( const unsigned char ucVersion,
                                const GUID *        pguidSiteId,
                                const unsigned char ucOperation,
                                const DWORD         hInternal,
                                const HRESULT       hr,
                                const DWORD         dwRequesterNameSize,
                                LPCWSTR             pwcsRequesterName);
    inline  CWriteReplyHeader();

    static ULONG CalcSize(  DWORD             dwRequesterNameLength);

    inline const DWORD GetRequesterNameSize() const;
    inline const DWORD GetRequesterNameSizeW() const;
    inline void GetRequesterName(  WCHAR * pBuf, DWORD size) const;
    inline void GetHandle( DWORD * pdwHandle) const;
    inline void GetResult( HRESULT * pResult) const;

private:

//
// BEGIN Network Monitor tag
//
    CBasicMQISHeader  m_BasicHeader;
    DWORD             m_hInternal;
    HRESULT           m_result;
    WCHAR             m_wcsRequesterName[0]; //must be last

//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*======================================================================

 Function:     CWriteReplyHeader::CWriteReplyHeader

 Description:  constructor for transmitted message

 =======================================================================*/
inline CWriteReplyHeader::CWriteReplyHeader(
                                const unsigned char ucVersion,
                                const GUID *        pguidSiteId,
                                const unsigned char ucOperation,
                                const DWORD         hInternal,
                                const HRESULT       hr,
                                const DWORD         dwRequesterNameSize,
                                LPCWSTR             pwcsRequesterName) :
                                m_BasicHeader( ucVersion,  pguidSiteId, ucOperation)
{
    memcpy(&m_hInternal, &hInternal, sizeof(DWORD));
    memcpy(&m_result, &hr, sizeof(DWORD));
    memcpy(m_wcsRequesterName, pwcsRequesterName, dwRequesterNameSize);

}

/*======================================================================

 Function:     CWriteReplyHeader::CWriteReplyHeader

 Description:  constructor for received message

 =======================================================================*/
inline CWriteReplyHeader::CWriteReplyHeader()
{
}

/*======================================================================

 Function:     CWriteReplyHeader::CalcSize

 Description:  calculates message size

 =======================================================================*/
inline  ULONG CWriteReplyHeader::CalcSize(  DWORD             dwRequesterNameLength)
{
    return( dwRequesterNameLength +
        sizeof(CWriteReplyHeader) );
}
/*======================================================================

 Function:     CWriteReplyHeader::GetRequesterName

 Description:  returns requester name

 =======================================================================*/
inline void CWriteReplyHeader::GetRequesterName(  WCHAR * pBuf, DWORD size) const
{
    memcpy( pBuf, m_wcsRequesterName, size);
}

/*======================================================================

 Function:     CWriteReplyHeader::GetRequesterNameSize

 Description:  returns requester name  size, in bytes

 =======================================================================*/

inline const DWORD CWriteReplyHeader::GetRequesterNameSize() const
{
    return( ( 1 + UnalignedWcslen( m_wcsRequesterName)) * sizeof(WCHAR));
}

/*======================================================================

 Function:     CWriteReplyHeader::GetRequesterNameSizeW

 Description:  returns requester name  size, in wide characters.

 =======================================================================*/

inline const DWORD CWriteReplyHeader::GetRequesterNameSizeW() const
{
    return( 1 + UnalignedWcslen(m_wcsRequesterName) ) ;
}

/*======================================================================

 Function:     CWriteReplyHeader::GetHandle

 Description:  returns handle

 =======================================================================*/
inline void CWriteReplyHeader::GetHandle( DWORD * pdwHandle) const
{
    memcpy( pdwHandle, &m_hInternal, sizeof(DWORD));
}
/*======================================================================

 Function:     CWriteReplyHeader::GetResult

 Description:  returns result parameter

 =======================================================================*/
inline void CWriteReplyHeader::GetResult( HRESULT * pResult) const
{
    memcpy( pResult, &m_result, sizeof(DWORD));
}


//*******************************************************************************
//*******************************************************************************
//*******************************************************************************
//
// struct CReplicationHeader
//
//*******************************************************************************
//*******************************************************************************
//*******************************************************************************

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CReplicationHeader {
public:

    inline CReplicationHeader( const unsigned char ucVersion,
                                const GUID *        pguidSiteId,
                                const unsigned char ucOperation,
                                const unsigned char ucFlush,
                                const short         Count);
    inline  CReplicationHeader();

    static ULONG CalcSize( );
    inline const unsigned char GetFlush() const;
    inline void GetCount( short * pCount) const;


private:

//
// BEGIN Network Monitor tag
//
    CBasicMQISHeader  m_BasicHeader;
    unsigned char     m_ucFlush;
    short             m_Count;


//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*======================================================================

 Function:     CReplicationHeader::CReplicationHeader

 Description:  constructor for transmitted messages

 =======================================================================*/
inline CReplicationHeader::CReplicationHeader(
                                const unsigned char ucVersion,
                                const GUID *        pguidSiteId,
                                const unsigned char ucOperation,
                                const unsigned char ucFlush,
                                const short         Count) :
                                m_BasicHeader( ucVersion, pguidSiteId, ucOperation),
                                m_ucFlush( ucFlush)
{
        memcpy( &m_Count, &Count, sizeof(short));
}
/*======================================================================

 Function:     CReplicationHeader::CReplicationHeader

 Description:  constructor for received messages

 =======================================================================*/
inline  CReplicationHeader::CReplicationHeader()
{
}

/*======================================================================

 Function:     CReplicationHeader::CalcSize

 Description:  calculates message size

 =======================================================================*/
inline  ULONG CReplicationHeader::CalcSize(  )
{
    return( sizeof(CReplicationHeader));
}
/*======================================================================

 Function:     CReplicationHeader::GetFlush

 Description:  returns flush parameter

 =======================================================================*/
inline const unsigned char CReplicationHeader::GetFlush() const
{
    return( m_ucFlush);
}
/*======================================================================

 Function:     CReplicationHeader::GetCount

 Description:  returns count parameter

 =======================================================================*/
inline void CReplicationHeader::GetCount( short * pCount) const
{
    memcpy( pCount, &m_Count, sizeof(short));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\replldap.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

File Name: replldap.h

Abstract: NT5-DS and LDAP related header file.

Author:

    Doron Juster  (DoronJ)   06-Apr-98

--*/

#include <winldap.h>

//+---------------------------------
//
// Functions prototypes
//
//+---------------------------------

HRESULT  InitLDAP( PLDAP *ppLdap, BOOL fSetData = FALSE ) ;

HRESULT  QueryRootDSE(LDAPMessage **ppRes, PLDAP pLdap) ;

TCHAR   *pGetNameContext(BOOL fRealDefaultContext = TRUE) ;

HRESULT  ReadDSHighestUSN( OUT LPTSTR pszHighestCommitted ) ;

void     GuidToLdapFilter( GUID *pGuid,
                           TCHAR **ppBuf ) ;

HRESULT  GetGuidAndUsn( IN  PLDAP       pLdap,
                        IN  LDAPMessage *pRes,
                        IN  __int64     i64Delta,
                        OUT GUID        *pGuid,
                        OUT __int64     *pi64SeqNum ) ;

HRESULT ModifyAttribute(
             WCHAR       wszPath[],             
             WCHAR       pAttr[],                          
             PLDAP_BERVAL *ppBVals             
             );

HRESULT InitOtherPSCs( BOOL fNT4Site );

HRESULT  InitMyNt4BSCs(GUID *pMasterGuid) ;

HRESULT InitNT5Sites ();

HRESULT  ServerNameFromSetting( IN  PLDAP       pLdap,
                                IN  LDAPMessage *pRes,
                                OUT TCHAR       **ppszServerName ) ;

HRESULT  CreateMsmqContainer(TCHAR wszContainerName[]);

HRESULT  QueryMSMQServerOnLDAP(DWORD       dwService,
                               UINT        uiNt4Attribute, 
                               LDAPMessage **ppRes,
                               int         *piCount,
                               GUID        *pMasterGuid,
                               TCHAR       *tszPrevUsn,
                               TCHAR       *tszCurrentUsn);

//+-------------------------------------------------------------
//
// Attribute names in NT5 DS (non MSMQ attributes)
//
//+-------------------------------------------------------------

#define  DSATTR_DN_NAME        (TEXT("distinguishedName"))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\replrpc.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: replrpc.cpp

Abstract: rpc related code.


Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

#include "mq1repl.h"
#include "replrpc.h"
#include "qmrepl.h"

#include "replrpc.tmh"

//+------------------------------
//
//  HRESULT InitRpcClient()
//
//+------------------------------

HRESULT GetRpcClientHandle(handle_t *phBind)
{
    static handle_t s_hBind = NULL ;
    if (s_hBind)
    {
        *phBind = s_hBind ;
        return MQSync_OK ;
    }

    WCHAR *wszStringBinding = NULL;

    RPC_STATUS status = RpcStringBindingCompose( NULL,
                                                 QMREPL_PROTOCOL,
                                                 NULL,
                                                 QMREPL_ENDPOINT,
                                                 QMREPL_OPTIONS,
                                                 &wszStringBinding);
    if (status != RPC_S_OK)
    {
        HRESULT hr = MQSync_E_RPC_BIND_COMPOSE ;
        LogReplicationEvent( ReplLog_Error,
                             hr,
                             status ) ;
        return hr ;
    }

    status = RpcBindingFromStringBinding(wszStringBinding,
                                         &s_hBind);
    if (status != RPC_S_OK)
    {
        HRESULT hr = MQSync_E_RPC_BIND_BINDING ;
        LogReplicationEvent( ReplLog_Error,
                             hr,
                             status ) ;
        return hr ;
    }

    LogReplicationEvent( ReplLog_Trace,
                         MQSync_I_RPC_BINDING,
                         wszStringBinding ) ;

    status = RpcStringFree(&wszStringBinding);

    *phBind = s_hBind ;
    return MQSync_OK ;
}

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return (new BYTE[ len ]) ;
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    delete ptr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mq1repl.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\replrpc.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: replrpc.h

Abstract: rpc related code.


Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

#define  QMREPL_PROTOCOL   (TEXT("ncalrpc"))
#define  QMREPL_ENDPOINT   (TEXT("QmReplService"))
#define  QMREPL_OPTIONS    (TEXT("Security=Impersonation Dynamic True"))

#define  REPLPERF_ENDPOINT (TEXT("ReplPerfEP"))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\replsend.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: replsend.cpp

Abstract:
    Send replication to MSMQ1.0 servers.

Author:

    Doron Juster  (DoronJ)   19-Mar-98

--*/

#include "mq1repl.h"

#include "replsend.tmh"

/*====================================================

RoutineName: PrepareNeighborsUpdate

Arguments:

Return Value:

=====================================================*/

HRESULT PrepareNeighborsUpdate( IN  unsigned char   bOperationType,
                                IN  DWORD           dwObjectType,
                                IN  LPCWSTR         pwcsPathName,
                                IN  CONST GUID *    pguidIdentifier,
                                IN  DWORD           cp,
                                IN  PROPID          aProp[  ],
                                IN  PROPVARIANT     apVar[  ],
                                IN  const GUID *    pguidMasterId,
                                IN  const CSeqNum & sn,
                                IN  const CSeqNum & snPrevInterSiteLSN,
                                IN  unsigned char   ucScope,
                                IN  BOOL            fNeedFlush,
                                IN  CDSUpdateList  *pReplicationList )
{
    CDSUpdate *     pUpdate;
    HRESULT         hr;

    //
    // Prepare an update ( keep the information about the change )
    //
    pUpdate = new CDSUpdate();

    P<CDSUpdate> pUpd = pUpdate; // save from exception

    if (pwcsPathName)
    {
        //
        //  pwcsPathName will be used only for copy in Init, thus safe
        //  to cast away constness.
        //
        hr = pUpdate->Init( pguidMasterId,
                            sn,
                            snPrevInterSiteLSN,
                            sn,
                            TRUE,
                            bOperationType,
                            UPDATE_COPY,
                            const_cast<LPWSTR>(pwcsPathName),
                            cp,
                            aProp,
                            apVar);
    }
    else
    {
        //
        //  Special handling of USER and SiteLink object (these objects are created without
        //  a pthaname)
        //
        GUID * pguidObjectId = NULL;

        if ( (pguidIdentifier == NULL ) &&
             (( dwObjectType == MQDS_USER) || (dwObjectType == MQDS_SITELINK)))
        {
            for ( DWORD index = 0; index < cp; index++)
            {
                if ( (aProp[index] == PROPID_U_ID) || (aProp[index] == PROPID_L_ID))
                {
                    pguidObjectId = apVar[index].puuid;
                    break;
                }
            }
            ASSERT( pguidObjectId != NULL);
        }
        else
        {
            pguidObjectId = (GUID *)pguidIdentifier;
        }
        hr = pUpdate->Init( pguidMasterId,
                            sn,
                            snPrevInterSiteLSN,
                            sn,
                            TRUE,
                            bOperationType,
                            UPDATE_COPY,
                            pguidObjectId,
                            cp,
                            aProp,
                            apVar);
    }
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error PrepareNeighborsUpdate failed")));
        //
        // This update is not replicated yet
        //  Sync solves it later
        //
         return(hr);
    }

    //
    // Keep the update. Reset the autorelease pointer.
    //
    pUpd.detach();

    //
    // Add this update to all other replication updates.
    //
    pReplicationList->AddUpdateSorted(pUpdate) ;

    return MQSync_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\replrecv.cpp ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name: replrecv.cpp

Abstract: handle all replication messages.

Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

#include "mq1repl.h"

#include "replrecv.tmh"

extern class crpDispatchWaitingList  g_cDispatchWaitingList ;

extern CCriticalSection g_csJobProcessing ;

/*====================================================

RoutineName
    ReceiveHello()

Arguments:
    IN unsigned char *pBuf  : stream of sync updates
    IN DWORD        TotalSize: size of stream in bytes

Return Value:

Threads:Receive

=====================================================*/

void ReceiveHello(
        IN  const unsigned char *   pBuf,
        IN  DWORD           dwTotalSize)
{
    const unsigned char *ptr,*pName;
    unsigned short i,count;

    ptr = pBuf;
    memcpy(&count, ptr, sizeof(unsigned short));
    if (count == 0)
    {
        return;
    }
    ptr+=sizeof(unsigned short);

    pName=ptr;
    DWORD size = sizeof(WCHAR) * (UnalignedWcslen((const unsigned short*)pName) + 1);
    ptr = pName + size;


    GUID guidMasterId;
    CSeqNum snHello;
    CSeqNum snAllowedPurge;

    for(i=0;i<count;i++)
    {
        memcpy(&guidMasterId,ptr,sizeof(GUID));
        ptr+=sizeof(GUID);

        ptr+= snHello.SetValue( ptr);
        ptr+= snAllowedPurge.SetValue( ptr);

#ifdef _DEBUG

        WCHAR wcsHello[30];
        snHello.GetValueForPrint( wcsHello);

        WCHAR wcsAllowedPurge[30];
        snAllowedPurge.GetValueForPrint( wcsAllowedPurge);

        DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO,
          TEXT("ReceiveHello: master = %!guid! HelloLSN %ls AllowedPurge %ls"),
                                &guidMasterId, wcsHello, wcsAllowedPurge ));
#endif

        g_pMasterMgr->Hello(&guidMasterId, pName, snHello, snAllowedPurge) ;
        if (!g_IsPSC)
        {
            pName = NULL;
        }
    }
}

/*====================================================

RoutineName
    ReceiveSyncRequestMessage()

Arguments:

Return Value:

Threads:Receive

=====================================================*/

HRESULT ReceiveSyncRequestMessage( IN  const unsigned char *   pBuf,
                                   IN  DWORD                   TotalSize)
{
    P<HEAVY_REQUEST_PARAMS> pSyncRequestParams;

    pSyncRequestParams = new HEAVY_REQUEST_PARAMS;

    pSyncRequestParams->dwType = SCHED_SYNC_REPLY;
    //
    //  It is the requester responsability to re-issue
    //  another sync request, incase allocation fails
    //

#ifdef _DEBUG
#undef new
#endif

    CSyncRequestHeader * pMessage =
                    new((unsigned char *)pBuf) CSyncRequestHeader();

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    memcpy( &pSyncRequestParams->guidSourceMasterId,
            pMessage->GetMasterId( ),
            sizeof(GUID));

    DWORD size = pMessage->GetRequesterNameSize();

    P<WCHAR> pwszRequesterName = (WCHAR*) new char[size];
    pSyncRequestParams->pwszRequesterName= pwszRequesterName;

    WCHAR *pTemp = pwszRequesterName;
    pMessage->GetRequesterName((char *)pTemp, size) ;

    pMessage->GetFromSN( &pSyncRequestParams->snFrom );

    pMessage->GetToSN( &pSyncRequestParams->snTo );

    pMessage->GetKnownPurgedSN( &pSyncRequestParams->snKnownPurged );

    pSyncRequestParams->bIsSync0 = pMessage->IsSync0();

    pSyncRequestParams->bScope = pMessage->GetScope();

#ifdef _DEBUG
    WCHAR wcsFrom[30];
    WCHAR wcsTo[30];
    pSyncRequestParams->snFrom.GetValueForPrint( wcsFrom);
    pSyncRequestParams->snTo.GetValueForPrint( wcsTo);

    unsigned short *lpszGuid ;
    UuidToString( &pSyncRequestParams->guidSourceMasterId,
                  &lpszGuid ) ;

    DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO, TEXT(
         "RcvSyncRequestMsg: from %ls (for %ls), sn from %ls to %ls"),
        pSyncRequestParams->pwszRequesterName, lpszGuid, wcsFrom, wcsTo)) ;

    RpcStringFree( &lpszGuid ) ;
#endif

    HRESULT hr = g_pMasterMgr->ReceiveSyncRequestMessage( pSyncRequestParams ) ;

    return hr;
}

/*====================================================

RoutineName
    ReceiveSyncReplyMessage()

Arguments:
    IN unsigned char *pBuf  : stream of sync updates
    IN DWORD        TotalSize: size of stream in bytes

Return Value:

Threads:Receive

=====================================================*/

HRESULT ReceiveSyncReplyMessage( IN  const unsigned char *   pBuf,
                                 IN  DWORD           dwTotalSize )
{
    const unsigned char *ptr;
    GUID   guidMasterId;

#ifdef _DEBUG
#undef new
#endif
    CSyncReplyHeader * pReply = new((unsigned char *)pBuf) CSyncReplyHeader();

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    memcpy( &guidMasterId, pReply->GetMasterId(), sizeof(GUID));
    CSeqNum snUpper;
    pReply->GetToSeqNum(&snUpper);

    DWORD  dwCount;
    pReply->GetCount( &dwCount);

    CSeqNum snPurge;
    pReply->GetPurgeSeqNum(&snPurge);
    DWORD dwCompleteSync0 = pReply->GetCompleteSync0();

#ifdef _DEBUG
    CSeqNum   snLower;
    pReply->GetFromSeqNum( &snLower);

    WCHAR wcsFrom[30];
    WCHAR wcsTo[30];
    WCHAR wcsPurge[30];
    snLower.GetValueForPrint( wcsFrom);
    snUpper.GetValueForPrint( wcsTo);
    snPurge.GetValueForPrint( wcsPurge);

    DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO, TEXT(
    "ReceiveSyncReplyMessage: master = %!guid! from %ls to %ls purge is %ls compSync0 is %1d"),
                  &guidMasterId, wcsFrom, wcsTo, wcsPurge, dwCompleteSync0)) ;

#endif

    ptr = pBuf + CSyncReplyHeader::CalcSize();
    return( g_pMasterMgr->ReceiveSyncReplyMessage( &guidMasterId,
                                                   dwCount,
                                                   snUpper,
                                                   snPurge,
                                                   dwCompleteSync0,
                                                   ptr,
                                 dwTotalSize-CSyncReplyHeader::CalcSize()));
}

//+--------------------------------
//
//   ReceiveReplicationMessage()
//
//+--------------------------------

HRESULT ReceiveReplicationMessage(
                        IN  const unsigned char *   pBuf,
                        IN  DWORD                   TotalSize )
{
    HRESULT hr;
    const unsigned char *ptr;
    DWORD   sum,size;

#ifdef _DEBUG
#undef new
#endif

    CReplicationHeader * pMessage =
                       new ((unsigned char *)pBuf) CReplicationHeader() ;

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    BOOL fNeedFlush = (pMessage->GetFlush() == DS_REPLICATION_MESSAGE_FLUSH);

    short count ;
    pMessage->GetCount( &count);

    sum = CReplicationHeader::CalcSize();
    ptr = pBuf + sum;

    for ( short i = 0 ; i < count ; i++ )
    {
        ASSERT (sum < TotalSize);
        CDSUpdate *pUpdate = new CDSUpdate;

        hr = pUpdate->Init(ptr, &size, TRUE);
        if (FAILED(hr))
        {
            //
            // We don't want to read junked values
            // Sync will support the missing updates if there are any
            //
            DBGMSG((DBGMOD_DS, DBGLVL_ERROR,
                     TEXT("ReceiveReplicationMessage, Error in parsing"))) ;
            delete pUpdate;
            break;
        }
        sum+=size;
        ptr+=size;

        //
        //  Pass the update to that source master object.
        //  The master object tracks sequence numbers, initiaites sync requests
        //  when required, and forwards the update to relevant neighbors
        //
        hr = g_pMasterMgr->AddUpdate(pUpdate, !fNeedFlush);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_DS, DBGLVL_ERROR, TEXT(
              "ReceiveReplicationMessage, AddUpdate return hr- %lxh"), hr)) ;
            continue;
        }
    }

    if (fNeedFlush)
    {
        NOT_YET_IMPLEMENTED(TEXT("NeighborMgr.Flush"), s_fFlash) ;
        return MQ_OK ; //(g_NeighborMgr.Flush(DS_FLUSH_TO_BSCS_ONLY));
    }

    ASSERT(sum < TotalSize);
    ReceiveHello(ptr, TotalSize-sum) ;

    return MQ_OK ;
}

//+-------------------------------------------------------
//
//  HRESULT _ProcessANormalMessage()
//
//+-------------------------------------------------------

static HRESULT _ProcessANormalMessage( MQMSGPROPS  *paProps )
{
    HRESULT hr = MQ_OK ;

    const unsigned char *pBuf =
                        paProps->aPropVar[ MSG_BODY_INDEX ].caub.pElems ;
    DWORD dwTotalSize = paProps->aPropVar[ MSG_BODYSIZE_INDEX ].ulVal ;

#ifdef _DEBUG
#undef new
#endif

    CBasicMQISHeader * pMessage =
                           new((unsigned char *)pBuf) CBasicMQISHeader() ;

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    unsigned char ucOpr = pMessage->GetOperation() ;
    switch (ucOpr)
    {
        case DS_REPLICATION_MESSAGE:

            hr = ReceiveReplicationMessage(pBuf, dwTotalSize);
            break;

        case DS_WRITE_REQUEST:

            ReceiveWriteRequestMessage(pBuf, dwTotalSize);
            break;

        case DS_SYNC_REQUEST:

            ReceiveSyncRequestMessage( pBuf, dwTotalSize);
            break;

        case DS_SYNC_REPLY:

            ReceiveSyncReplyMessage( pBuf, dwTotalSize);
            break;

        case DS_ALREADY_PURGED:

            ASSERT(("case DS_ALREADY_PURGED:", 0)) ;
            //ReceiveAlreadyPurgedMessage( pBuf, TotalSize);
            break;

        default:

            ASSERT(("hr = MQSync_E_NORMAL_OPRATION", 0)) ;
            hr = MQSync_E_NORMAL_OPRATION ;
            break;
    }

    return hr ;
}

//+-------------------------------------------------------
//
//  HRESULT _ProcessAMessage()
//
//+-------------------------------------------------------

static HRESULT _ProcessAMessage( MQMSGPROPS  *paProps,
                                 DWORD        dwThreadNum,
                                 BOOL         fAfterWait )
{
    HRESULT hr = MQ_ERROR ;
    WORD wClass = paProps->aPropVar[ MSG_CLASS_INDEX ].uiVal ;
    LPWSTR wszRespQueue = paProps->aPropVar[ MSG_RESP_INDEX ].pwszVal ;

    LogReplicationEvent( ReplLog_Info,
                         MQSync_I_PROCESS_MESSAGE,
                         dwThreadNum,
                         fAfterWait,
                         wClass,
                         paProps->aPropVar[ MSG_BODYSIZE_INDEX ].ulVal,
                         wszRespQueue ) ;

    if ( wClass == MQMSG_CLASS_NORMAL)
    {
        hr = _ProcessANormalMessage( paProps ) ;
    }
    else if(MQCLASS_NACK(wClass))
    {
        NOT_YET_IMPLEMENTED(TEXT("RecevieAck"), s_fAck) ;
/////////ReceiveAck(pmp, pqf);
    }
    else
    {
        LogReplicationEvent( ReplLog_Warning,
                             MQSync_E_WRONG_MSG_CLASS,
                             (ULONG) wClass ) ;
    }

    return hr ;
}

//+------------------------
//
//  _ProcessAJob()
//
//+------------------------

static HRESULT
 _ProcessAJob( struct _WorkingThreadStruct *psWorkingThreadData,
               DWORD                        dwThreadNum,
               BOOL                         fAfterWait = FALSE )
{
    ASSERT(psWorkingThreadData->fBusy) ;

    MQMSGPROPS aProps = psWorkingThreadData->aWorkingProps ;
    HRESULT hr = _ProcessAMessage( &aProps, dwThreadNum, fAfterWait ) ;

    FreeMessageProps( &aProps ) ;

    return hr ;
}

//+-------------------------------------------------------
//
//  DWORD WINAPI  ReplicationWorkingThread(LPVOID lpV)
//
//+-------------------------------------------------------

DWORD WINAPI  ReplicationWorkingThread(LPVOID lpV)
{
    HRESULT hr = RpSetPrivilege( TRUE,     // fSecurityPrivilege,
                                 TRUE,     // fRestorePrivilege,
                                 TRUE ) ;  // fForceThread )
    if (FAILED(hr))
    {
        DWORD dwErr = GetLastError() ;
        ASSERT(FALSE) ;
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_SET_PRIV,
                             hr, dwErr, dwErr ) ;

        return hr ;
    }

    struct _WorkingThreadStruct *psWorkingThreadData =
                                    (struct _WorkingThreadStruct *) lpV ;

    DWORD  dwThreadNum = psWorkingThreadData->dwThreadNum ;
    HANDLE hWakeEvent = psWorkingThreadData->hEvent ;

    while(TRUE)
    {
        DWORD dwWait = WaitForSingleObject( hWakeEvent, INFINITE ) ;
        if (dwWait == WAIT_OBJECT_0)
        {
            hr = _ProcessAJob( psWorkingThreadData, dwThreadNum ) ;
        }

        //
        // check if there is job in the waiting list that has to process message
        // from the same NT4 Master.
        //
        BOOL fGet = g_cDispatchWaitingList.GetNextJob(
                                &(psWorkingThreadData->guidNT4Master),
                                &(psWorkingThreadData->aWorkingProps));
        while (fGet)
        {
            hr = _ProcessAJob( psWorkingThreadData, dwThreadNum, TRUE ) ;
            fGet = g_cDispatchWaitingList.GetNextJob(
                                    &(psWorkingThreadData->guidNT4Master),
                                    &(psWorkingThreadData->aWorkingProps));
        }

        //
        // See if there are jobs in the waiting list.
        // If there are, peek first one,
        // verify that there is no active thread with the same GUID
        // if it is TRUE, process this job
        // otherwise peek the next one
        //
        GUID  guidCurMaster ;
        while (TRUE)
        {
            {
                psWorkingThreadData->guidNT4Master = GUID_NULL ;
                CS Lock(g_csJobProcessing) ;
                BOOL fPeek = g_cDispatchWaitingList.PeekNextJob(&guidCurMaster);
                if (!fPeek)
                {
                    break;
                }
              
                //
                // If we reach this point, and guidCurMaster is not GUID_NULL,
                // then we know for sure that no other thread is working
                // on replication from this master. Also, because of the
                // g_csJobProcessing critical section, the dispatcher thread
                // can not assign a free thread to this master. So next call
                // must retrieve the job and return TRUE.
                // For the case of GUID_NULL, several threads can process
                // messages with that guid (these are not replication
                // messages, they are write requests), so a FALSE is
                // legitimate.
                //
                fGet = g_cDispatchWaitingList.GetNextJob(
                                    &guidCurMaster,
                                    &(psWorkingThreadData->aWorkingProps));
                ASSERT(fGet || (!fGet && (guidCurMaster == GUID_NULL))) ;

                psWorkingThreadData->guidNT4Master = guidCurMaster ;
            }   //CS

            if (fGet)
            {
                hr = _ProcessAJob( psWorkingThreadData, dwThreadNum, TRUE ) ;
            }
        }   //while (TRUE)

        psWorkingThreadData->fBusy = FALSE ;
        psWorkingThreadData->guidNT4Master = GUID_NULL ;

    }   //while (TRUE)
    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpcclistub.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    rpcclistub.cpp

Abstract:
    Rpc client stub function

Author:
    Ilan Herbst (ilanh) 25-July-2000

Environment:
    Platform-independent,

--*/

#include "mq1repl.h"
#include "mqmacro.h"

#include "rpcclistub.tmh"

HRESULT 
QMRpcSendMsg(
    IN handle_t hBind,
    IN LPWSTR lpwszDestination,
    IN DWORD dwSize,
    IN const unsigned char *pBuffer,
    IN DWORD dwTimeout,
    IN unsigned char bAckMode,
    IN unsigned char bPriority,
    IN LPWSTR lpwszAdminResp
	)
{
	DBG_USED(hBind);
	DBG_USED(lpwszDestination);
	DBG_USED(dwSize);
	DBG_USED(pBuffer);
	DBG_USED(dwTimeout);
	DBG_USED(bAckMode);
	DBG_USED(bPriority);
	DBG_USED(lpwszAdminResp);
    ASSERT(("Replication service  dont suppose to call QMRpcSendMsg", 0));
    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpcns.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpcns.cpp

Abstract: replication of cn to NT4 MSMQ1.0 servers.

Author:

    Tatiana Shubin  (TatianaS)   21-Apr-98

--*/

#include "mq1repl.h"

#include "rpcns.tmh"

HRESULT HandleACN (
             CDSUpdateList *pReplicationList,
             GUID          *pNeighborId,
             GUID           CNGuid,
             UINT           uiAddressType,
             LPWSTR         pwcsName,
             CSeqNum        *psn,
             DWORD          dwLenSD,
             BYTE           *pSD
             )
{
    #define     PROPS_SIZE  5
    PROPID      propIDs[ PROPS_SIZE ];
    PROPVARIANT propVariants[ PROPS_SIZE ] ;
    DWORD       iProps = 0 ;

    propIDs[ iProps ] = PROPID_CN_MASTERID ;
	propVariants[ iProps ].vt = VT_CLSID ;
    propVariants[ iProps ].puuid = &g_PecGuid ;
	iProps++;

    propIDs[ iProps ] = PROPID_CN_GUID ;
	propVariants[ iProps ].vt = VT_CLSID ;
    propVariants[ iProps ].puuid = &CNGuid ;
	iProps++;

    BYTE    *pBuf = NULL;
    DWORD dwLen;
    HRESULT hr = MQSync_OK;

    P<BYTE> pDefaultSecurityDescriptor ;
    if (dwLenSD == 0)
    {
        hr = MQSec_GetDefaultSecDescriptor(
                    MQDS_CN,
                    (PSECURITY_DESCRIPTOR*) &pDefaultSecurityDescriptor,
                    FALSE,    // fImpersonate
                    NULL,     // pInSecurityDescriptor
                    0,        // seInfoToRemove
                    e_UseDefaultDacl ) ;

        if (FAILED(hr))
        {
            //
            // what to do ?
            //
            return hr;
        }

        ASSERT(pDefaultSecurityDescriptor) ;
        ASSERT(IsValidSecurityDescriptor(pDefaultSecurityDescriptor)) ;

        dwLen = GetSecurityDescriptorLength ( pDefaultSecurityDescriptor );
        ASSERT(dwLen != 0) ;
        pBuf = pDefaultSecurityDescriptor;
    }
    else
    {
        //
        // security descriptor was given as parameter
        //
        ASSERT (pSD);
        pBuf = pSD;
        dwLen = dwLenSD;
    }

    propIDs[ iProps ] = PROPID_CN_SECURITY ;
	propVariants[ iProps ].vt = VT_BLOB ;
    propVariants[ iProps ].blob.cbSize = dwLen ;
    propVariants[ iProps ].blob.pBlobData = pBuf ;
	iProps++;

    propIDs[ iProps ] = PROPID_CN_PROTOCOLID ;
	propVariants[ iProps ].vt = VT_UI1 ;
    propVariants[ iProps ].bVal = (unsigned char) uiAddressType ;
	iProps++;

    propIDs[ iProps ] = PROPID_CN_NAME;
    propVariants[ iProps ].vt = VT_LPWSTR;
    propVariants[ iProps ].pwszVal = pwcsName;
    DWORD dwNameIndex = iProps;
    UNREFERENCED_PARAMETER(dwNameIndex);
    iProps++;

    ASSERT(iProps <= PROPS_SIZE) ;
    #undef  PROPS_SIZE

    CSeqNum sn, snPrev ;
    if (psn == NULL)
    {
        GetSNForReplication (0, g_pThePecMaster, pNeighborId, &sn);
    }
    else
    {
        sn = *psn;
    }

    NOT_YET_IMPLEMENTED(TEXT("PrepNeighbor, no OUT update, LSN"), s_fPrep) ;
    hr = PrepareNeighborsUpdate( DS_UPDATE_SYNC,
                                 MQDS_CN,
                                 NULL, // pwName,
                                 &CNGuid,
                                 iProps,
                                 propIDs,
                                 propVariants,
                                 &g_PecGuid,
                                 sn,
                                 snPrev,
                                 ENTERPRISE_SCOPE,
                                 TRUE, //  fNeedFlush,
                                 pReplicationList ) ;


#ifdef _DEBUG
            TCHAR  tszSn[ SEQ_NUM_BUF_LEN ] ;
            sn.GetValueForPrint(tszSn) ;

            LogReplicationEvent(ReplLog_Info, MQSync_I_REPLICATE_CN,
                                 propVariants[ dwNameIndex ].pwszVal, tszSn) ;
#endif

    return hr;

}

HRESULT ReplicateCNs (
            IN  CDSUpdateList *pReplicationList,
            IN  GUID          *pNeighborId,
            OUT int           *piCount
            )
{
    if (g_ulIpCount + g_ulIpxCount == 0)
    {
        //
        // there is no CNs. It is strange, we checked this in InitCNs (syncinit.cpp)
        //
        ASSERT(0);
    }

    HRESULT hr;
    BOOL fFailed = FALSE;
    for (UINT i = 0; i < g_ulIpCount; i++)
    {
        WCHAR wcsName[256];
        wsprintf (wcsName, L"IP%d", i+1);

        hr =  HandleACN (pReplicationList,
                         pNeighborId,
                         g_pIpCNs[i],
                         IP_ADDRESS_TYPE,
                         wcsName,
                         NULL,  //seq num
                         0,     //length of security descriptor
                         NULL   //security descriptor
                         );
        if (FAILED(hr))
        {
            fFailed = TRUE ;
        }
    }

    for (i = 0; i < g_ulIpxCount; i++)
    {
        WCHAR wcsName[256];
        wsprintf (wcsName, L"IPX%d", i+1);

        hr =  HandleACN (pReplicationList,
                         pNeighborId,
                         g_pIpxCNs[i],
                         IPX_ADDRESS_TYPE,
                         wcsName,
                         NULL,  //seq num
                         0,     //length of security descriptor
                         NULL   //security descriptor
                         );
        if (FAILED(hr))
        {
            fFailed = TRUE ;
        }
    }

    //
    // foreign CNs were sent as foreign sites together with site object replication
    //

    *piCount += g_ulIpCount + g_ulIpxCount ;
    return MQSync_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpcreate.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rpcreate.cpp

Abstract:

    Create/delete/update objects in the NT5 DS.

Author:

    Doron Juster  (DoronJ)


--*/

#include "mq1repl.h"
#include <mixmode.h>
#include "..\..\src\ds\h\mqattrib.h"

#include "rpcreate.tmh"

#define MAX_OLD_PROPS  8

//+--------------------------------------
//
//  _PathNameFromGuid()
//
//+--------------------------------------

static LPWSTR  _PathNameFromGuid( DWORD  dwObjectType,
                                  GUID  *pGuid )
{
    PROPID      aPropPath[1] ;
    PROPVARIANT apVarPath[1] ;

    if (dwObjectType == MQDS_QUEUE)
    {
        aPropPath[0] = PROPID_Q_PATHNAME ;
    }
    else if (dwObjectType == MQDS_MACHINE)
    {
        aPropPath[0] = PROPID_QM_PATHNAME ;
    }
    else if (dwObjectType == MQDS_SITELINK)
    {
        apVarPath[0].pwszVal = new WCHAR [2];
        wcscpy (apVarPath[0].pwszVal, L"");
        return apVarPath[0].pwszVal;
    }
    else
    {
        ASSERT(("sync wrong object type", 0)) ;
    }
    apVarPath[0].vt = VT_NULL ;
    apVarPath[0].pwszVal = NULL ;

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant

    HRESULT hr = DSCoreGetProps( dwObjectType,
                                 NULL,
                                 pGuid,
                                 1,
                                 aPropPath,
                                 &requestContext,
                                 apVarPath ) ;
    if (SUCCEEDED(hr))
    {
        return apVarPath[0].pwszVal ;
    }
    return NULL ;
}

//+----------------------------------------------------------------------
//
//  _CreateComputerAndDefaultContainer ()
//
//  Create the computer object, and if necessary, create also a default
//  container for these msmq computer objects.
//  This case happens for Win95 machines, or for NT machines from NT4
//  domains, which do not have a computer object in the NT5 DS.
//
//+----------------------------------------------------------------------

static HRESULT _CreateComputerAndDefaultContainer (
                                           IN  LPCWSTR  pwcsPathName )
{
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;
    ASSERT(pGetNameContext()) ;

    //
    // The computer object not found. Create s default container
    // and create a computer object in it.
    //
    hr = MQSync_OK ;
    static BOOL s_fContainerCreated = FALSE ;
    if (!s_fContainerCreated)
    {
        hr = CreateMsmqContainer(MIG_DEFAULT_COMPUTERS_CONTAINER) ;
    }

    if (FAILED(hr))
    {
        return hr ;
    }

    s_fContainerCreated = TRUE ;
    //
    // Now that container object exist, it's time to
    // create the computer object.
    //
	DWORD iComProperty =0;
    PROPID propComIDs[1] ;
    PROPVARIANT propComVariants[1] ;

    //
    // Ronit says that sam account should end with a $.
    //
    // The PROPID_COM_SAM_ACCOUNT contains the first MAX_COM_SAM_ACCOUNT_LENGTH (19)
    // characters of the computer name, as unique ID. (6295 - ilanh - 03-Jan-2001)
    //
    DWORD dwNetBiosNameLen = __min(wcslen( pwcsPathName ), MAX_COM_SAM_ACCOUNT_LENGTH);
    AP<TCHAR> tszAccount = new TCHAR[2 + dwNetBiosNameLen];
    _tcsncpy(tszAccount, pwcsPathName, dwNetBiosNameLen);
    tszAccount[dwNetBiosNameLen] = L'$';
    tszAccount[dwNetBiosNameLen + 1] = 0;

    propComIDs[iComProperty] = PROPID_COM_SAM_ACCOUNT ;
    propComVariants[iComProperty].vt = VT_LPWSTR ;
    propComVariants[iComProperty].pwszVal = tszAccount ;
    iComProperty++;

	DWORD iComPropertyEx =0;
    PROPID propComIDsEx[1] ;
    PROPVARIANT propComVariantsEx[1] ;

    DWORD dwSize = _tcslen(pGetNameContext()) +
                   _tcslen(MIG_DEFAULT_COMPUTERS_CONTAINER) +
                   OU_PREFIX_LEN + 2 ;
    P<TCHAR> tszContainer = new TCHAR[ dwSize ] ;
    _tcscpy(tszContainer, OU_PREFIX) ;
    _tcscat(tszContainer, MIG_DEFAULT_COMPUTERS_CONTAINER) ;
    _tcscat(tszContainer, LDAP_COMMA) ;
    _tcscat(tszContainer, pGetNameContext()) ;

    propComIDsEx[iComPropertyEx] = PROPID_COM_CONTAINER ;
    propComVariantsEx[iComPropertyEx].vt = VT_LPWSTR ;
    propComVariantsEx[iComPropertyEx].pwszVal = tszContainer ;
    iComPropertyEx++;

    ASSERT( iComProperty ==
            (sizeof(propComIDs) / sizeof(propComIDs[0])) ) ;
    ASSERT( iComPropertyEx ==
            (sizeof(propComIDsEx) / sizeof(propComIDsEx[0])) ) ;

    //
    // The migrated computer objects (not the mSMQConfiguration, but the
    // computer itself) are always created on local domain, so no need to
    // call DSCoreCreateMigratedObject.
    //
    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant

    hr = DSCoreCreateObject(
               MQDS_COMPUTER,
               pwcsPathName,
               iComProperty,
               propComIDs,
               propComVariants,
               iComPropertyEx,
               propComIDsEx,
               propComVariantsEx,
               &requestContext,
               NULL, /* pObjInfoRequest */
               NULL /* pParentInfoRequest */) ;


    return hr;
}

//+----------------------------------------------------------------
//
//  DWORD __HandleCN()
//
//+----------------------------------------------------------------
static DWORD _HandleCN (IN OUT  DWORD	*pdwObjectType,							
						IN  DWORD        cp,
						IN OUT PROPID    aProp[],
						IN OUT PROPVARIANT  apVar[],
						OUT DWORD        aIndexs[],
						OUT PROPID       aOldProp[]
						)
{
	DWORD cIndexs = 0;
	
	for (DWORD j = 0 ; j < cp ; j++ )
	{
		if (aProp[j] == PROPID_CN_PROTOCOLID)
		{
			if (apVar[j].uiVal != FOREIGN_ADDRESS_TYPE)
			{
				return cIndexs;
			}
			else
			{
				break;
			}
		}
	}

	//
	// we are here if this CN is foreign CN.
	//
	*pdwObjectType = MQDS_SITE;
	for (j = 0 ; j < cp ; j++ )
	{
		switch (aProp[j])
		{
		case PROPID_CN_PROTOCOLID:
			ASSERT(cIndexs < MAX_OLD_PROPS) ;
            aIndexs[ cIndexs ] = j ;
            aOldProp[ cIndexs ] = aProp[ j ] ;
            cIndexs++ ;

			aProp[j] = PROPID_S_FOREIGN;		
			break;

		case PROPID_CN_NAME:
			ASSERT(cIndexs < MAX_OLD_PROPS) ;
            aIndexs[ cIndexs ] = j ;
            aOldProp[ cIndexs ] = aProp[ j ] ;
            cIndexs++ ;

			aProp[j] = PROPID_S_PATHNAME;			
			break;

		case PROPID_CN_GUID:
			ASSERT(cIndexs < MAX_OLD_PROPS) ;
            aIndexs[ cIndexs ] = j ;
            aOldProp[ cIndexs ] = aProp[ j ] ;
            cIndexs++ ;

			aProp[j] = PROPID_S_SITEID;
			break;
			
		case PROPID_CN_SEQNUM:
			ASSERT(cIndexs < MAX_OLD_PROPS) ;
            aIndexs[ cIndexs ] = j ;
            aOldProp[ cIndexs ] = aProp[ j ] ;
            cIndexs++ ;

			aProp[j] = PROPID_S_DONOTHING;			
			break;

		case PROPID_CN_MASTERID:
			ASSERT(cIndexs < MAX_OLD_PROPS) ;
            aIndexs[ cIndexs ] = j ;
            aOldProp[ cIndexs ] = aProp[ j ] ;
            cIndexs++ ;

			aProp[j] = PROPID_S_MASTERID;
			break;

		case PROPID_CN_SECURITY:
			ASSERT(cIndexs < MAX_OLD_PROPS) ;
            aIndexs[ cIndexs ] = j ;
            aOldProp[ cIndexs ] = aProp[ j ] ;
            cIndexs++ ;

			aProp[j] = PROPID_S_SECURITY;
			break;

		default:
			ASSERT(0);
			break;
		}
	}
	ASSERT(cp == cIndexs);
	return cIndexs;
}

//+----------------------------------------------------------------
//
//  DWORD _PreparePropertiesForNT5()
//
//  Arguments:   fCreate - TRUE for CreateObj, FALSE for SetProps
//
//+----------------------------------------------------------------

static DWORD  _PreparePropertiesForNT5(
                IN  BOOL                    fCreate,
                IN  DWORD                   dwObjectType,
                IN  DWORD                   cp,
                IN OUT PROPID               aProp[],
                IN  PROPVARIANT             apVar[],
                OUT DWORD                   aIndexs[],
                OUT PROPID                  aOldProp[],
                OUT BOOL                    *pfAddMasterId,
                OUT DWORD                   *pdwService )
{
    //
    // The following loop replace several NT4 properties with newer ones,
    // which are specific for NT5.
    // PROPID_X_DONOTHING mean the NT5 mqads code should ignore them.
    //
    DWORD cIndexs = 0;
    for (DWORD j = 0 ; j < cp ; j++ )
    {
        if (aProp[j] == s_aMasterPropid[ dwObjectType ])
        {
            //
            // this property should not appear in a replication message
            // or write request. If it do appear, then use it.
            // The Assert is just for debug, to see when it appears.
            //
            ASSERT(0) ;
            *pfAddMasterId = FALSE ;
        }
        else if (aProp[j] == PROPID_Q_INSTANCE)
        {
            ASSERT(cIndexs < MAX_OLD_PROPS) ;
            aIndexs[ cIndexs ] = j ;
            aOldProp[ cIndexs ] = aProp[ j ] ;
            cIndexs++ ;

            aProp[j] = PROPID_Q_NT4ID ;
        }
        else if (aProp[j] == PROPID_QM_MACHINE_ID)
        {
            ASSERT(cIndexs < MAX_OLD_PROPS) ;
            aIndexs[ cIndexs ] = j ;
            aOldProp[ cIndexs ] = aProp[ j ] ;
            cIndexs++ ;

            aProp[j] = PROPID_QM_NT4ID ;
        }
        else if ((aProp[j] == PROPID_Q_CREATE_TIME)   ||
                 (aProp[j] == PROPID_Q_MODIFY_TIME)   ||
                 (aProp[j] == PROPID_Q_SEQNUM)        ||
                 (aProp[j] == PROPID_QM_CREATE_TIME)  ||
                 (aProp[j] == PROPID_QM_MODIFY_TIME)  ||
                 (aProp[j] == PROPID_QM_SEQNUM) )
        {
            //
            // These properties are internal to NT5 DS, and it updates them
            // by its own algorithms.
            //
            ASSERT(cIndexs < MAX_OLD_PROPS) ;
            aIndexs[ cIndexs ] = j ;
            aOldProp[ cIndexs ] = aProp[ j ] ;
            cIndexs++ ;

            aProp[j] = s_aDoNothingPropid[ dwObjectType ] ;
        }
        else if (aProp[j] == PROPID_QM_SERVICE)
        {
            //
            // if this object is machine and its service = 0
            // we (maybe) will have to create computer object in the DS NT5
            //
            *pdwService = apVar[j].ulVal;
            if (!fCreate)
            {
                //
                // It's not allowed to set this property.
                //
                ASSERT(cIndexs < MAX_OLD_PROPS) ;
                aIndexs[ cIndexs ] = j ;
                aOldProp[ cIndexs ] = aProp[ j ] ;
                cIndexs++ ;

                aProp[j] = s_aDoNothingPropid[ dwObjectType ] ;
            }
        }
        else if (aProp[j] == PROPID_S_GATES)
        {
            aIndexs[ cIndexs ] = j ;
            aOldProp[ cIndexs ] = aProp[ j ] ;
            cIndexs++ ;

            aProp[j] = PROPID_S_DONOTHING;
        }
    }
    return cIndexs;
}

//+------------------------------------------
//
//   HRESULT  _ConvertPublicKeys()
//
//+------------------------------------------

static HRESULT  _ConvertAPublicKey( IN  PROPVARIANT     *pVar,
                                    OUT MQDSPUBLICKEYS **ppPublicKeys )
{
    HRESULT  hr = MQSec_PackPublicKey( pVar->blob.pBlobData,
                                       pVar->blob.cbSize,
                                       x_MQ_Encryption_Provider_40,
                                       x_MQ_Encryption_Provider_Type_40,
                                       ppPublicKeys ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    pVar->vt = VT_BLOB;
    pVar->blob.pBlobData = (BYTE*) *ppPublicKeys ;
    pVar->blob.cbSize = 0 ;
    if (*ppPublicKeys)
    {
        pVar->blob.cbSize = (*ppPublicKeys)->ulLen ;
    }

    return MQSync_OK ;
}

//+----------------------------------------------
//
//   HRESULT _ConvertPublicKeys()
//
//+----------------------------------------------

static  HRESULT _ConvertPublicKeys( IN  DWORD            dwObjectType,
                                    IN  DWORD            cp,
                                    IN  PROPID           aProp[],
                                    IN  PROPVARIANT      apVar[],
                                    OUT MQDSPUBLICKEYS **ppPublicSignKeys,
                                    OUT MQDSPUBLICKEYS **ppPublicExchKeys,
                                    OUT PROPVARIANT     *pvarSign,
                                    OUT PROPVARIANT     *pvarExch )
{
    HRESULT hr = MQSync_OK ;

    if (dwObjectType == MQDS_MACHINE)
    {
        for ( ULONG i = 0 ; i < cp ; i++ )
        {
            if (aProp[i] == PROPID_QM_SIGN_PK)
            {
                *pvarSign = apVar[i] ;
                hr = _ConvertAPublicKey( &apVar[i],
                                         ppPublicSignKeys ) ;
                if (FAILED(hr))
                {
                    apVar[i] = *pvarSign ;
                    return hr ;
                }
                aProp[i] = PROPID_QM_SIGN_PKS ;
            }
            else if (aProp[i] == PROPID_QM_ENCRYPT_PK)
            {
                *pvarExch = apVar[i] ;
                hr = _ConvertAPublicKey( &apVar[i],
                                         ppPublicExchKeys ) ;
                if (FAILED(hr))
                {
                    apVar[i] = *pvarExch ;
                    return hr ;
                }
                aProp[i] = PROPID_QM_ENCRYPT_PKS ;
            }
        }
    }

    return hr ;
}

//+--------------------------------------
//
//  HRESULT ReplicationGetComputerProps()
//
//+--------------------------------------
HRESULT ReplicationGetComputerProps(
                    IN  LPCWSTR              pwcsPathName,
                    IN  DWORD                cp,
                    IN  PROPID               aComputerProp[],
                    IN  PROPVARIANT          aComputerVar[]
                    )
{

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);

    return( DSCoreGetProps( MQDS_COMPUTER,
                                 pwcsPathName,
                                 NULL,
                                 cp,
                                 aComputerProp,
                                &requestContext,
                                 aComputerVar));
}


//+--------------------------------------
//
//  HRESULT ReplicationCreateObject()
//
//+--------------------------------------

HRESULT ReplicationCreateObject(
                    IN  DWORD                dwObjectType,
                    IN  LPCWSTR              pwcsPathName,
                    IN  DWORD                cp,
                    IN  PROPID               aProp[],
                    IN  PROPVARIANT          apVar[],
                    IN  BOOL                 fAddMasterSeq,
	    			IN	const GUID *		 pguidMasterId,
                    IN  CSeqNum *            psn,
                    IN  unsigned char        ucScope )
{
    ASSERT(dwObjectType < MAX_MQIS_TYPES) ;

    HRESULT hr = MQSync_OK ;
    DWORD  cIndexs = 0 ;
    DWORD  aIndexs[ MAX_OLD_PROPS ] ;
    PROPID aOldProp[ MAX_OLD_PROPS ] ;
    BOOL   fAddMasterId = TRUE ;
    DWORD  dwService = 0;

    MQDSPUBLICKEYS  *pPublicSignKeys = NULL ;
    MQDSPUBLICKEYS  *pPublicExchKeys = NULL ;
    PROPVARIANT      varSign ;
    PROPVARIANT      varExch ;    
	
    varSign.vt = VT_NULL ;
    varSign.blob.cbSize = 0 ;
    varExch.vt = VT_NULL ;
    varExch.blob.cbSize = 0 ;


	DWORD dwOldObjectType = dwObjectType;

    __try
    {    
        cIndexs = _PreparePropertiesForNT5( TRUE,
                                            dwObjectType,
                                            cp,
                                            aProp,
                                            apVar,
                                            aIndexs,
                                            aOldProp,
                                            &fAddMasterId,
                                            &dwService );
        ASSERT(cIndexs <= 5) ;


        hr = _ConvertPublicKeys( dwObjectType,
                                 cp,
                                 aProp,
                                 apVar,
                                 &pPublicSignKeys,
                                 &pPublicExchKeys,
                                 &varSign,
                                 &varExch ) ;
        if (FAILED(hr))
        {
            return hr ;
        }

        if ((dwObjectType == MQDS_SITE) && (cIndexs > 0))
        {
            for ( ULONG i=0 ; i < cIndexs ; i++ )
            {
                if (aOldProp[ i ] == PROPID_S_GATES)
                {
                    //
                    // can we create site with defined site gates properties?
                    //
                    ASSERT (0);
                }
            }
        }
		
		if (dwObjectType == MQDS_CN)
		{			
			cIndexs = _HandleCN (&dwObjectType,							
								 cp,
								 aProp,
								 apVar,
								 aIndexs,
								 aOldProp
								);
		}

        hr = MQSync_E_UNKNOWN ;

        //
        // Add the master ID property, if exist.
        //
        if (fAddMasterId && pguidMasterId)
        {
            aProp[ cp ] = s_aMasterPropid[ dwObjectType ] ;
            apVar[ cp ].vt = VT_CLSID ;
            apVar[ cp ].puuid = const_cast<GUID *> (pguidMasterId) ;
            cp++ ;
        }

        if ((dwObjectType == MQDS_MACHINE)  &&
            (dwService    == SERVICE_NONE))
        {
            //
            //  Verify that computer object exists, if not create one
            //
            PROPID      aComputerProp;
            PROPVARIANT aComputerVar;

            aComputerProp = PROPID_COM_ACCOUNT_CONTROL;
            aComputerVar.vt = VT_NULL;

            hr = ReplicationGetComputerProps(
                                 pwcsPathName,
                                 1,
                                &aComputerProp,
                                &aComputerVar);


            if ( hr == MQDS_OBJECT_NOT_FOUND)
            {
                hr = _CreateComputerAndDefaultContainer ( pwcsPathName );
            }
        }

        hr = DSCoreCreateMigratedObject( dwObjectType,
                                         pwcsPathName,
                                         cp,
                                         aProp,
                                         apVar,
                                         0,        // ex prop
                                         NULL,     // ex prop
                                         NULL,     // ex prop
                                         NULL,
                                         NULL,
                                         NULL,
                                         FALSE,
                                         FALSE,
                                         NULL,
                                         NULL) ;        

        if (FAILED(hr))
        {
            if (hr != MQ_ERROR_QUEUE_EXISTS             &&      //queue
                hr != MQDS_E_SITELINK_EXISTS            &&      //sitelink
                hr != MQ_ERROR_INTERNAL_USER_CERT_EXIST &&      //user
                hr != MQDS_CREATE_ERROR                 &&      //user
                hr != MQ_ERROR_MACHINE_EXISTS           &&      //machine
                hr != MQDS_E_COMPUTER_OBJECT_EXISTS     &&      //computer
                hr != HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)  &&
                hr != HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS)
                )
            {
                if (dwObjectType == MQDS_CN && hr == MQ_ERROR_ILLEGAL_PROPERTY_VALUE)
                {
                    //
                    // Bug 4963.
                    // we tried to create non-foreign CN and MQADS returned this error
                    // it is OK to fail here, so log error and prevent assert.                    
                    //                    
                }
                else
                {
                    ASSERT (0);
                }
                LogReplicationEvent(ReplLog_Error, MQSync_E_CREATE,
                                                  pwcsPathName, cp, hr) ;
            }
        }
        LogReplicationEvent(ReplLog_Info, MQSync_I_CREATE,
                                              pwcsPathName, cp, hr) ;
    }
    __finally
    {
        //
        // always restore old properties before leaving.
        //
        if (cIndexs > 0)
        {
			if (dwOldObjectType != dwObjectType)
			{
				dwObjectType = dwOldObjectType;
			}

            for ( DWORD j = 0 ; j < cIndexs ; j++ )
            {
                aProp[ aIndexs[ j ]] = aOldProp[ j ] ;
            }
        }

        if (dwObjectType == MQDS_MACHINE)
        {
            for ( ULONG i = 0 ; i < cp ; i++ )
            {
                if (aProp[i] == PROPID_QM_SIGN_PKS)
                {
                    apVar[i] = varSign ;
                    aProp[i] = PROPID_QM_SIGN_PK ;
                }
                else if (aProp[i] == PROPID_QM_ENCRYPT_PKS)
                {
                    apVar[i] = varExch ;
                    aProp[i] = PROPID_QM_ENCRYPT_PK ;
                }
            }
        }

        if (pPublicSignKeys)
        {
            delete pPublicSignKeys  ;
        }
        if (pPublicExchKeys)
        {
            delete pPublicSignKeys ;
        }
    }

    return hr ;
}

//+-------------------------------------
//
//  HRESULT IsGateFromOtherSite()
//
//+-------------------------------------

HRESULT IsGateFromOtherSite( IN  LPWSTR  lpwcsSiteGate,
                             IN  GUID    *pSiteGuid,
                             OUT BOOL    *pfFromOtherSite )
{
    HRESULT hr;
    //
    // build Path from Full Path Name
    //
    ASSERT(_tcsstr(lpwcsSiteGate, MACHINE_PATH_PREFIX) - lpwcsSiteGate == 0);
    WCHAR *ptr = lpwcsSiteGate + MACHINE_PATH_PREFIX_LEN - 1;
    ULONG ulPathLen = _tcsstr(ptr, LDAP_COMMA) - ptr;
    P<WCHAR> pwcsPath = new WCHAR[ulPathLen + 1];
    wcsncpy(pwcsPath, ptr, ulPathLen);
    pwcsPath[ulPathLen] = L'\0';

    //
    // get owner id and machine id by path
    //
    PROPID      MachinePropID  = PROPID_QM_SITE_ID;
    PROPVARIANT MachineVar;
    MachineVar.vt = VT_NULL ;
    MachineVar.puuid = NULL ;

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant

    hr = DSCoreGetProps (
                MQDS_MACHINE,
                pwcsPath,
                NULL,
                1,
                &MachinePropID,
                &requestContext,
                &MachineVar
                );

    if (SUCCEEDED(hr))
    {
        if (memcmp (pSiteGuid, MachineVar.puuid, sizeof(GUID)) == 0)
        {
            //
            // site contains this server
            //
            *pfFromOtherSite = FALSE;
        }
        else
        {
            *pfFromOtherSite = TRUE;
        }
    }

    delete MachineVar.puuid;
    return hr;

}

HRESULT SetSiteGates (
           IN   ULONG   ulNumOfGates,
           IN   LPWSTR  *ppNewSiteGates,
           IN   GUID    *pSiteGuid
           )
{
    HRESULT hr;

    LONG cAlloc = 4;
	P<PROPID> columnsetPropertyIDs  = new PROPID[ cAlloc ];
	columnsetPropertyIDs[0] = PROPID_L_NEIGHBOR1;
	columnsetPropertyIDs[1] = PROPID_L_NEIGHBOR2;
	columnsetPropertyIDs[2] = PROPID_L_GATES_DN;
	columnsetPropertyIDs[3] = PROPID_L_ID;

    MQCOLUMNSET columnsetSiteLink;
    columnsetSiteLink.cCol = cAlloc;
    columnsetSiteLink.aCol = columnsetPropertyIDs;

    HANDLE hQuery;
    DWORD dwCount = cAlloc;
	
    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant

    hr = DSCoreLookupBegin (
    		NULL,
            NULL,
            &columnsetSiteLink,
            NULL,
            &requestContext,
            &hQuery
    		) ;

	if (FAILED(hr))
    {
        return hr;
    }

	P<PROPVARIANT> paVariant = new PROPVARIANT[ cAlloc ];

    while (SUCCEEDED(hr))
    {

		hr = DSCoreLookupNext (
				hQuery,
				&dwCount,
				paVariant
				) ;

		if (FAILED(hr))
        {
            return hr;
        }
		if (dwCount == 0)
		{
			//there is no result
			break;
		}        

        if (memcmp (pSiteGuid, paVariant[0].puuid, sizeof(GUID)) == 0 ||
			memcmp (pSiteGuid, paVariant[1].puuid, sizeof(GUID)) == 0)
		{
            //
            // given site is one of the neighbors
            //

            //
            // the first, we have to remove all site gates that belong to the given site
            //
            LPWSTR *ppGatesOfOtherSites = NULL;
            if (paVariant[2].calpwstr.cElems > 0)
            {
                ppGatesOfOtherSites = new LPWSTR[paVariant[2].calpwstr.cElems];
            }

            ULONG ulCount = 0;
            for (ULONG i=0; i<paVariant[2].calpwstr.cElems; i++)
            {
                BOOL fFromOtherSite = FALSE;
                hr = IsGateFromOtherSite (
                        paVariant[2].calpwstr.pElems[i],
                        pSiteGuid,
                        &fFromOtherSite
                        );
                if (FAILED(hr))
                {
                    //???
                    // to continue with the next site gate or free & return
                    continue;
                }

                if (fFromOtherSite)
                {
                    ppGatesOfOtherSites[ulCount] =
                        new WCHAR [wcslen(paVariant[2].calpwstr.pElems[i]) + 1];
                    wcscpy(ppGatesOfOtherSites[ulCount], paVariant[2].calpwstr.pElems[i]);
                    ulCount++;
                }
            }

            //
            // now we add Site Gates of the given site to the array of site gates of other sites
            //
            PROPID      aGateProp = PROPID_L_GATES_DN;
            PROPVARIANT aGateVar;
	
	        aGateVar.vt = VT_LPWSTR | VT_VECTOR;
	        aGateVar.calpwstr.cElems = ulCount + ulNumOfGates;
            if (ulCount + ulNumOfGates > 0)
            {
	            aGateVar.calpwstr.pElems = new LPWSTR[ulCount + ulNumOfGates];
            }
            else
            {
                aGateVar.calpwstr.pElems = NULL;
            }

            for (i=0; i < ulCount; i++)
            {
                aGateVar.calpwstr.pElems[i] =
                    new WCHAR [wcslen(ppGatesOfOtherSites[i]) + 1];
			    wcscpy (aGateVar.calpwstr.pElems[i], ppGatesOfOtherSites[i]);
            }

            for (i=0; i < ulNumOfGates; i++)
            {
                aGateVar.calpwstr.pElems[ulCount + i] =
                    new WCHAR [wcslen(ppNewSiteGates[i]) + 1];
                wcscpy (aGateVar.calpwstr.pElems[ulCount + i], ppNewSiteGates[i]);
            }

            CDSRequestContext requestContext( e_DoNotImpersonate,
                                        e_ALL_PROTOCOLS);  // not relevant

            hr = DSCoreSetObjectProperties (
						MQDS_SITELINK,
                        NULL,
						paVariant[3].puuid,
						1,
						&aGateProp,
						&aGateVar,
                        &requestContext,
                        NULL ) ;	

            if (ppGatesOfOtherSites)
            {
                delete [] ppGatesOfOtherSites;
            }
            if (aGateVar.calpwstr.pElems)
            {
                delete [] aGateVar.calpwstr.pElems;
            }
        }

        delete paVariant[0].puuid;
        delete paVariant[1].puuid;
        delete [] paVariant[2].calpwstr.pElems;
		delete paVariant[3].puuid;

        if (FAILED(hr))
        {
            return hr;
        }
    }

    HRESULT hr1 = DSCoreLookupEnd (hQuery) ;
    UNREFERENCED_PARAMETER(hr1);
    return hr;

}

HRESULT HandleSiteGates (
            IN  ULONG   ulNumOfGates,
            IN  GUID    *pGatesID,
            IN  LPCWSTR pwcsPathName
            )
{
    HRESULT hr;
    //
    // get site id by the name
    //
    PROPID      aSiteIdProp = PROPID_S_SITEID;
    PROPVARIANT aSiteIdVar;
    aSiteIdVar.vt = VT_NULL;
    aSiteIdVar.puuid = NULL;

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant

    hr = DSCoreGetProps (
            MQDS_SITE,
            pwcsPathName ,
            NULL,
            1,
            &aSiteIdProp,
            &requestContext,
            &aSiteIdVar
            );
    if (FAILED(hr))
    {
        delete aSiteIdVar.puuid;
        return hr;
    }

    LPWSTR *ppNewGates = NULL;
    if (ulNumOfGates)
    {
        ppNewGates = new LPWSTR[ulNumOfGates];
    }

    for (ULONG i=0; i<ulNumOfGates; i++)
    {
        //
        // get full path name of the current gate
        //
        PROPID      aFullPathProp = PROPID_QM_FULL_PATH;
        PROPVARIANT aFullPathVar;
        aFullPathVar.vt = VT_NULL ;
        aFullPathVar.pwszVal = NULL ;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  // not relevant

        hr = DSCoreGetProps(  MQDS_MACHINE,
                              NULL,
                              &pGatesID[i],
                              1,
                              &aFullPathProp,
                              &requestContext,
                              &aFullPathVar ) ;
        if (FAILED(hr))
        {
            delete aFullPathVar.pwszVal ;
            delete [] ppNewGates;
            delete aSiteIdVar.puuid;
            return hr;
        }

        ppNewGates[i] = new WCHAR[wcslen( aFullPathVar.pwszVal ) + 1];
        wcscpy (ppNewGates[i], aFullPathVar.pwszVal);
        delete aFullPathVar.pwszVal ;
    }

    hr = SetSiteGates (
            ulNumOfGates,
            ppNewGates,
            aSiteIdVar.puuid
            );

    if (ulNumOfGates)
    {
        delete [] ppNewGates;
    }
    delete aSiteIdVar.puuid;
    return hr;
}

//+--------------------------------------
//
//  HRESULT ReplicationSetProps()
//
//+--------------------------------------

HRESULT ReplicationSetProps( IN  DWORD               dwObjectType,
                             IN  LPCWSTR             pwcsPathName,
                             IN  CONST GUID *        pguidIdentifier,
                             IN  DWORD               cp,
                             IN  PROPID              aProp[],
                             IN  PROPVARIANT         apVar[],
                             IN  BOOL                fAddMasterSeq,
				             IN  const GUID *        pguidMasterId,
                             IN  CSeqNum *           psn,
                             IN  CSeqNum *           psnPrevious,
                             IN  unsigned char       ucScope,
                             IN  BOOL                fWhileDemotion,
                             IN  BOOL                fMyObject,
                             OUT LPWSTR *            ppwcsOldPSC)
{
    DWORD  cIndexs = 0 ;
    DWORD  aIndexs[ MAX_OLD_PROPS ] ;
    PROPID aOldProp[ MAX_OLD_PROPS ] ;
    BOOL   fAddMasterId = TRUE ;
    DWORD dwService = 0;

    cIndexs = _PreparePropertiesForNT5( FALSE,
                                        dwObjectType,
                                        cp,
                                        aProp,
                                        apVar,
                                        aIndexs,
                                        aOldProp,
                                        &fAddMasterId,
                                        &dwService );

    P<MQDSPUBLICKEYS>  pPublicSignKeys = NULL ;
    P<MQDSPUBLICKEYS>  pPublicExchKeys = NULL ;
    PROPVARIANT        varSign ;
    PROPVARIANT        varExch ;

    HRESULT hr = _ConvertPublicKeys( dwObjectType,
                                     cp,
                                     aProp,
                                     apVar,
                                    &pPublicSignKeys,
                                    &pPublicExchKeys,
                                    &varSign,
                                    &varExch ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    if (dwObjectType == MQDS_SITE && cIndexs > 0)
    {
        //
        // if there is site gate for this site, we have to first set
        // site gate properties to site link object
        //
        for (ULONG i=0; i<cIndexs; i++)
        {
            if (aOldProp[ i ] == PROPID_S_GATES)
            {
                hr = HandleSiteGates (
                        apVar[aIndexs[ i ]].cauuid.cElems,  //number of gates
                        apVar[aIndexs[ i ]].cauuid.pElems,  //site gates
                        pwcsPathName
                        );
                if (FAILED(hr))
                {
                    LogReplicationEvent(ReplLog_Error, MQSync_E_SET_SITEGATES,
                                                pwcsPathName, hr) ;
                //
                // BUGBUG: return or continue to set properties of site?
                //
                }
            }
        }
    }

	DWORD dwOldObjectType = dwObjectType;
	if (dwObjectType == MQDS_CN)
	{		
		cIndexs = _HandleCN (&dwObjectType,							
							 cp,
							 aProp,
							 apVar,
							 aIndexs,
							 aOldProp
							);
	}


    CDSRequestContext requestContext( e_DoNotImpersonate,
                                      e_ALL_PROTOCOLS ) ;
#ifdef _DEBUG
	unsigned short *lpszDbgGuid = NULL ;
	LPWSTR lpszDbgPath   = const_cast<LPWSTR> (pwcsPathName) ;
	ReplLogLevel eLevel  = ReplLog_Info ;
	DWORD        dwMsgId = MQSync_I_SET_PROPS ;
#endif

	if (pguidIdentifier)
    {
        hr = DSCoreSetObjectProperties( dwObjectType,
                                        NULL,
                                        pguidIdentifier,
                                        cp,
                                        aProp,
                                        apVar,
                                        &requestContext,
                                        NULL ) ;
#ifdef _DEBUG
        UuidToString( const_cast<GUID*> (pguidIdentifier), &lpszDbgGuid ) ;
        lpszDbgPath = lpszDbgGuid ;
#endif
    }
    else if (pwcsPathName && (pwcsPathName[0] != L'\0'))
    {
        hr = DSCoreSetObjectProperties( dwObjectType,
                                        pwcsPathName,
                                        NULL, /* pguidIdentifier */
                                        cp,
                                        aProp,
                                        apVar,
                                        &requestContext,
                                        NULL /* pObjInfoRequest */ ) ;
    }
    else
    {
        ASSERT(0);
        hr = MQSync_E_SET_PROPS ;
    }

#ifdef _DEBUG
    if (FAILED(hr))
    {
        eLevel = ReplLog_Warning ;
        dwMsgId = MQSync_E_SET_PROPS ;
    }

    LogReplicationEvent(eLevel, dwMsgId, lpszDbgPath, cp, hr) ;
    if (lpszDbgGuid )
    {
        RpcStringFree( &lpszDbgGuid ) ;
    }
#endif

    //
    // always restore old properties before leaving.
    //
    if (cIndexs > 0)
    {
		if (dwOldObjectType != dwObjectType)
		{
			dwObjectType = dwOldObjectType;
		}

        for ( DWORD j = 0 ; j < cIndexs ; j++ )
        {
            aProp[ aIndexs[ j ]] = aOldProp[ j ] ;
        }
    }

    if (dwObjectType == MQDS_MACHINE)
    {
        for ( ULONG i = 0 ; i < cp ; i++ )
        {
            if (aProp[i] == PROPID_QM_SIGN_PKS)
            {
                apVar[i] = varSign ;
                aProp[i] = PROPID_QM_SIGN_PK ;
            }
            else if (aProp[i] == PROPID_QM_ENCRYPT_PKS)
            {
                apVar[i] = varExch ;
                aProp[i] = PROPID_QM_ENCRYPT_PK ;
            }
        }
    }

    return hr ;
}

//+--------------------------------------
//
//  HRESULT ReplicationDeleteObject()
//
//+--------------------------------------

HRESULT ReplicationDeleteObject(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  CONST GUID *            pguidIdentifier,
                IN  unsigned char           ucScope,
				IN	const GUID *			pguidMasterId,
                IN  CSeqNum *               psn,
                IN  CSeqNum *               psnPrevious,
                IN  BOOL                    fMyObject,
				IN  BOOL					fSync0,
                OUT CList<CDSUpdate *, CDSUpdate *> ** pplistUpdatedMachines)
{
    //
    // BUGBUG, see MSMQ1.0 code for more functionality, after deleting
    // the object.
    //

    HRESULT hr ;
    LPTSTR  lpDbgPath = NULL ;

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);

	if (dwObjectType == MQDS_CN &&
		IsForeignSiteInIniFile(*pguidIdentifier))
	{
		dwObjectType = MQDS_SITE;
	}

    if (pguidIdentifier)
    {
        hr = DSCoreDeleteObject( dwObjectType,
                                 NULL, /*  pwcsPathName */
                                 pguidIdentifier,
                                 &requestContext,
                                 NULL  /* pParentInfoRequest */) ;
        lpDbgPath = TEXT("(guid)") ;
    }
    else if (pwcsPathName)
    {
        hr = DSCoreDeleteObject( dwObjectType,
                                 pwcsPathName,
                                 NULL, /* pguidIdentifier */
                                 &requestContext,
                                 NULL  /* pParentInfoRequest */) ;
        lpDbgPath = const_cast<TCHAR*> (pwcsPathName) ;
    }
    else
    {
        ASSERT(0) ;
        hr = MQSync_E_CANT_DELETE_NOID ;
    }

#ifdef _DEBUG
    if (lpDbgPath)
    {
        LogReplicationEvent( ReplLog_Info,
                             MQSync_I_DELETE,
                             lpDbgPath,
                             dwObjectType,
                             hr ) ;
    }
#endif

    if ((hr == MQDS_OBJECT_NOT_FOUND)      ||
        (hr == MQ_ERROR_QUEUE_NOT_FOUND)   ||
        (hr == MQ_ERROR_MACHINE_NOT_FOUND))
    {
        LogReplicationEvent( ReplLog_Warning,
                             MQSync_E_DELETE_NOT_FOUND,
                             lpDbgPath,
                             dwObjectType ) ;
        //
        // Maybe already deleted. continue.
        //
        hr = MQSync_OK ;
    }

    return hr ;
}

//+--------------------------------------
//
//   hr = ReplicationSyncObject()
//
//+--------------------------------------

HRESULT  ReplicationSyncObject(
                IN  DWORD                   dwObjectType,
                IN  LPWSTR                  pwcsPathName,
                IN  GUID *                  pguidIdentifier,
                IN  DWORD                   cp,
                IN  PROPID                  aPropSync[],
                IN  PROPVARIANT             apVarSync[],
				IN	const GUID *			pguidMasterId,
                IN  CSeqNum *               psn,
                OUT BOOL *                  pfIsObjectCreated)
{
    ASSERT(dwObjectType < MAX_MQIS_TYPES) ;

    PROPID aPropID = s_aSelfIdPropid[ dwObjectType ] ;
    PROPID aPropPath = s_aPathPropid[ dwObjectType ] ;

    LPWSTR lpPath = NULL ;
    BOOL fNoId = TRUE ;

    *pfIsObjectCreated = FALSE;

    for ( DWORD j = 0 ; j < cp ; j++ )
    {
        if (aPropSync[j] == aPropPath)
        {
            lpPath = apVarSync[j].pwszVal ;
        }
        else if (aPropSync[j] == aPropID)
        {
            fNoId = FALSE ;
        }
    }

    if (pwcsPathName && lpPath==NULL)
    {
        lpPath = pwcsPathName;
    }

    if (lpPath)
    {
	    DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO, TEXT(
                        "Syncing %ls, with %lut properties"), lpPath, cp)) ;
    }
    else
    {
	    DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO, TEXT(
                        "Syncing (no path), with %lut properties"), cp)) ;
    }

#ifdef _DEBUG
    BOOL fNT4 = ReadDebugIntFlag(TEXT("NT4MQIS"), 0) ;
    if (fNT4)
    {
        return MQSync_OK ;
    }
#endif

    //
    // Query the DS to find if the object exist. If so, update it.
    // If not exist, create it.
    //
    HRESULT hr = MQSync_OK ;

    LPWSTR lpwszPath;
    if (pguidIdentifier)
    {
        lpwszPath =  _PathNameFromGuid( dwObjectType,
                                    pguidIdentifier ) ;
    }
    else if (pwcsPathName)
    {
        //
        // write request for set gives path object, guid object is NULL
        //
        lpwszPath = new WCHAR [wcslen(pwcsPathName) + 1];
        wcscpy (lpwszPath, pwcsPathName);
    }
    else
    {
        ASSERT(0);
        return MQSync_E_CANT_SYNC_NO_PATH_ID;
    }

    if (lpwszPath)
    {
        //
        // update
        //
        NOT_YET_IMPLEMENTED(TEXT("ReplicationSyncObject()"), s_fReplUpdate) ;

        hr = ReplicationSetProps(
                dwObjectType,
                lpwszPath,
                pguidIdentifier,
                cp,
                aPropSync,
                apVarSync,
                TRUE,               //IN  BOOL fAddMasterSeq,
				pguidMasterId,
                psn,
                NULL,               //IN  CSeqNum *psnPrevious,
                ENTERPRISE_SCOPE,
                FALSE,              //IN  BOOL fWhileDemotion,
                TRUE,               //IN  BOOL fMyObject,
                NULL                //OUT LPWSTR *ppwcsOldPSC
                );

        delete lpwszPath ;

#ifdef _DEBUG
        BOOL fFail = ReadDebugIntFlag(TEXT("FailToUpdateSync"), 0) ;
        if (fFail)
        {
            return MQSync_E_DEBUG_FAILURE ;
        }
#endif
    }
    else
    {
        //
        // Create new object.
        //
        ASSERT(lpPath) ;
        if (!lpPath)
        {
            //
            // Can't create an object without its path.
            //
            return MQSync_E_CANT_REPLIN_NO_PATH ;
        }
        if (fNoId)
        {
            //
            // When a NT4 MSMQ1.0 PSC prepare sync reply, it does NOT include
            // the object guid as a property. Instead, the guid is serialized
            // in the packet and passed as a parameter to this function.
            // see MSMQ1.0 code, src\ds\mqis\replmsg.cpp, line ~885
            // (calling pUpdate->Init() with "aProp + 2". the first two
            //  properties are seqnum and guid).
            //
            aPropSync[ cp ] = aPropID ;
            apVarSync[ cp ].vt = VT_CLSID ;
            apVarSync[ cp ].puuid = pguidIdentifier ;
            cp++ ;
        }

#ifdef _DEBUG
        BOOL fFail = ReadDebugIntFlag(TEXT("FailToCreateSync"), 0) ;
        if (fFail)
        {
            return MQSync_E_DEBUG_FAILURE ;
        }
#endif

        hr =  ReplicationCreateObject( dwObjectType,
                                       lpPath,
                                       cp,
                                       aPropSync,
                                       apVarSync,
                                       TRUE, //      fAddMasterSeq
				                       pguidMasterId,
                                       psn,
                                       ENTERPRISE_SCOPE ) ;
        *pfIsObjectCreated = TRUE;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpcsrv.cpp ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name: rpcsrv.cpp

Abstract: rpc related code for performance counters

Author:

    Tatiana Shubin (TatianaS)

--*/

#include "mq1repl.h"
#include <stdio.h>
#include "rpperf.h"
#include <tchar.h>
#include "replrpc.h"

#include "rpcsrv.tmh"

HRESULT InitRPCConnection()
{
	HRESULT hr = MQSync_OK;

    ULONG ulMaxCalls = 1000 ;
 
	//
	//RpcServerUseProtseqEp - protocol configurating
	//
    RPC_STATUS status = RpcServerUseProtseqEp( QMREPL_PROTOCOL,
                                               ulMaxCalls,
                                               REPLPERF_ENDPOINT, 
                                               NULL ) ;  // Security descriptor    
    if (status != RPC_S_OK)
    {
        hr = MQSync_E_RPC_USE_PROTOCOL;
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_RPC_USE_PROTOCOL,
                             QMREPL_PROTOCOL, REPLPERF_ENDPOINT, status) ;                         
    
        return hr ;
    }  
    LogReplicationEvent( ReplLog_Info,
                         MQSync_I_RPC_USE_PROTOCOL,
                         QMREPL_PROTOCOL, REPLPERF_ENDPOINT) ;          

	//
	//RpcServerRegisterIf - register the interface
	//   
    status = RpcServerRegisterIfEx( rpperf_v1_0_s_ifspec,
                                    NULL,
                                    NULL,
                                    RPC_IF_AUTOLISTEN,
                                    ulMaxCalls,
                                    NULL);

    if (status != RPC_S_OK)
    {
        hr = MQSync_E_RPC_REGISTER;
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_RPC_REGISTER,
                             status) ; 
        return hr;
    }
    LogReplicationEvent( ReplLog_Info, MQSync_I_RPC_REGISTER );
                         
    return hr ;
} 

/*====================================================

Function getCounterData is called from performance dll
by RPC connection

=====================================================*/
void getCounterData( handle_t  hBind , pPerfDataObject pData)
{        
    pPerfDataObject pDataObject = g_Counters.GetDataObject();
    for (UINT i=0; i<eNumPerfCounters; i++)
    {
        pData->PerfCounterArray[i] = pDataObject->PerfCounterArray[i];
    }
    
    pData->dwMasterInstanceNum = pDataObject->dwMasterInstanceNum;
    for (i=0; i<pDataObject->dwMasterInstanceNum; i++)
    {
        pData->NT4MasterArray[i].dwNameLen = pDataObject->NT4MasterArray[i].dwNameLen;
        _tcscpy (pData->NT4MasterArray[i].pszMasterName, 
                 pDataObject->NT4MasterArray[i].pszMasterName);
        for (UINT count = 0; count<eNumNT4MasterCounter; count ++)
        {
            pData->NT4MasterArray[i].NT4MasterCounterArray[count] = 
                    pDataObject->NT4MasterArray[i].NT4MasterCounterArray[count];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpdsptch.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpdsptch.cpp

Abstract: The code in this file implement a dispatcher. Basically,
          it read messages from the mqis queue and do the following:
          1. dispatch them for processing to an available thread.
          2. insert them in a list, to be processed later.
          3. send them to other queues, as necessary.

Author:

    Doron Juster  (DoronJ)   10-Jun-98

--*/

#include "mq1repl.h"

#include "rpdsptch.tmh"

class crpDispatchWaitingList  g_cDispatchWaitingList ;
struct _WorkingThreadStruct *g_psWorkingThreadData = NULL;
DWORD g_dwNumThreads;
CCriticalSection g_csJobProcessing ;

//+=========================================================
//
// implementation of the  "crpDispatchWaitingList" class
//
//+=========================================================

crpDispatchWaitingList::crpDispatchWaitingList() :
                                        m_pFirstJob(NULL),
                                        m_pLastJob(NULL),                                
                                        m_cWaitingJobs(0),
                                        m_dwSerialNumberInsert(0),
                                        m_dwSerialNumberRemove(0)
{
}

crpDispatchWaitingList::~crpDispatchWaitingList()
{
    struct _WaitingJob  *pJob = m_pFirstJob ;
    while (pJob)
    {
        struct _WaitingJob  *pNextJob = pJob->pNextJob  ;
        delete pJob ;
        pJob = pNextJob ;
    }
}

//+----------------------------------------------
//
//  BOOL crpDispatchWaitingList::InsertJob()
//
//+----------------------------------------------

BOOL crpDispatchWaitingList::InsertJob( IN  MQMSGPROPS  *pProps,
                                        IN  GUID        *pguidCurMaster )
{
    CS Lock(m_cs) ;
    m_cWaitingJobs++ ;

    struct _WaitingJob *pJob = (struct _WaitingJob*) new struct _WaitingJob ;
    pJob->aWorkingProps = *pProps ;
    pJob->eJobStatus = eWaiting ;
    pJob->guidNT4Master = *pguidCurMaster ;
    pJob->pNextJob = NULL ;

    pJob->dwSerialNumber = m_dwSerialNumberInsert ;
    m_dwSerialNumberInsert++ ;

    if (!m_pLastJob)
    {
        //
        // First job in the waiting list
        //
        m_pFirstJob = pJob ;
        m_pLastJob = pJob ;

        LogReplicationEvent( ReplLog_Trace,
                             MQSync_I_FIRST_WAITING_JOB ) ;
    }
    else
    {
        //
        // Add new job to end of list.
        //
        m_pLastJob->pNextJob = pJob ;
        m_pLastJob = pJob ;
    }

    return TRUE ;
}

//+------------------------------------------------
//
//  BOOL crpDispatchWaitingList::GetNextJob()
//
//  Find the first job with given GUID and return it.
//
//  return TRUE if a job was found. Otherwise, if there isn't any job
//  waiting for processing, return FALSE.
//
//+------------------------------------------------

BOOL crpDispatchWaitingList::GetNextJob (
                                 IN     GUID       *pguidCurMaster,
                                 OUT    MQMSGPROPS *pProps
                                 )
{
    CS Lock(m_cs) ;

    if (!m_pFirstJob)
    {
        //
        // the list is empty
        //
        ASSERT(!m_pLastJob) ;
        return FALSE ;
    }

    struct _WaitingJob *pJob = NULL ;

    //
    // skip jobs which were already merged.
    //
    while (m_pFirstJob && (m_pFirstJob->eJobStatus == eAlreadyMerged))
    {
        ASSERT(m_pFirstJob->dwSerialNumber == m_dwSerialNumberRemove) ;
        m_dwSerialNumberRemove++ ;

        pJob = m_pFirstJob->pNextJob ;
        delete m_pFirstJob ;
        m_pFirstJob = pJob ;
    }

    if (!m_pFirstJob)
    {
        ASSERT(m_cWaitingJobs == 0) ;
        //
        // list become empty.
        //
        m_pLastJob = NULL ;    
        return FALSE ;
    }

    pJob = m_pFirstJob ;
    struct _WaitingJob *pPrevJob = pJob ;
    while (pJob && pJob->guidNT4Master != *pguidCurMaster)
    {
        pPrevJob = pJob;
        pJob = pJob->pNextJob ;
    }
    if (!pJob)
    {
        return FALSE;
    }

    //
    // we found the job with the given guid
    //
    *pProps = pJob->aWorkingProps ;

    if (pJob == m_pLastJob)
    {
        m_pLastJob = pPrevJob ;
    }

    if (pJob == m_pFirstJob)
    {
        m_pFirstJob = pJob->pNextJob;        
    }
    else
    {
        pPrevJob->pNextJob = pJob->pNextJob;        
    }

    delete pJob;
    m_dwSerialNumberRemove++ ;
    m_cWaitingJobs-- ;

    if (!m_pFirstJob)
    {
        ASSERT(m_cWaitingJobs == 0) ;
        //
        // list become empty.
        //
        m_pFirstJob = NULL ;
        m_pLastJob = NULL ;  

        LogReplicationEvent( ReplLog_Trace,
                             MQSync_I_LAST_WAITING_JOB ) ;
    }

    return TRUE ;
}

//+------------------------------------------------
//
//  BOOL crpDispatchWaitingList::PeekNextJob()
//
//  return TRUE if a job was found. Otherwise, if there isn't any
//  suitable job, return FALSE.
//
//+------------------------------------------------
BOOL crpDispatchWaitingList::PeekNextJob(OUT GUID *pguidCurMaster)
{
    CS Lock(m_cs) ;

    if (!m_pFirstJob)
    {
        //
        // the list is empty
        //
        ASSERT(!m_pLastJob) ;
        return FALSE ;
    }


    struct _WaitingJob *pJob = m_pFirstJob ;    
    while (pJob)
    {
        *pguidCurMaster = pJob->guidNT4Master ;
        if (*pguidCurMaster == GUID_NULL)
        {
            return TRUE;
        }
        BOOL fIsAlreadyProcessing = FALSE;        
        for (DWORD j = 0 ; j < g_dwNumThreads ; j++ )
        {
            if (g_psWorkingThreadData[j].fBusy &&
                g_psWorkingThreadData[j].guidNT4Master == *pguidCurMaster)
            {
                fIsAlreadyProcessing = TRUE;
                break;
            }
        }        
        if (!fIsAlreadyProcessing)
        {
            //
            // there is no active thread with this GUID
            //
            return TRUE;
        }

        pJob = pJob->pNextJob ;
    }    

    if (!pJob)
    {
        //
        // we pass over the whole list and do not find the suitable job
        //
        return FALSE;
    }

    ASSERT(pJob == NULL);

    return FALSE;    
}

//+-------------------------------------------------------
//
//  HRESULT _ProcessImmediateRequest()
//
//  This function validate the message is OK (version and authentication)
//  and process it here if needed. Long operation are dispatched to the
//  working threads and are not processed here.
//
//+-------------------------------------------------------

static HRESULT _ProcessImmediateRequest( MQMSGPROPS  *paProps,
                                         QUEUEHANDLE  hMyNt5PecQueue,
                                         OUT GUID    *pguidNT4Master)
{
    HRESULT hr = MQSync_I_MSG_NEED_DISPATCH ;

    const unsigned char *pBuf =
                        paProps->aPropVar[ MSG_BODY_INDEX ].caub.pElems ;
    DWORD dwTotalSize = paProps->aPropVar[ MSG_BODYSIZE_INDEX ].ulVal ;
    UNREFERENCED_PARAMETER(dwTotalSize);

#ifdef _DEBUG
#undef new
#endif

    CBasicMQISHeader * pMessage =
                           new((unsigned char *)pBuf) CBasicMQISHeader() ;

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    //
    //  Verify correct version
    //
    unsigned char ucVersion = pMessage->GetVersion() ;
    if (ucVersion != DS_PACKET_VERSION)
    {
        hr =  MQSync_E_PKT_VERSION ;
        LogReplicationEvent( ReplLog_Error,
                             hr,
                             (ULONG) ucVersion ) ;
        return hr ;
    }

    //
    // Verify packet is valid and from correct QM.
    //
    if (paProps->aPropVar[ MSG_AUTHENTICATED_INDEX ].bVal != 1)
    {
        //
        // See MSMQ1.0 code, falcon\src\ds\mqis\recvrepl.cpp, function
        // Receive(), line ~1134, for explanation of MSMQ1.0 algorithm
        // for that case.
        // With MSMQ2.0 replication service, we should fail here and not
        // perform any of the operation done in MSMQ1.0.
        // When a MSMQ1.0 server renew its crypto key, the MSMQ2.0 ex-PEC
        // will write the key directly in the msmqConfiguration object, so
        // standard replication authentication can always be done.
        // See also MSMQ2.0 code, mqads\mqdsapi.cpp, MQDSSetObjectSecurity(),
        // for how this is handled.
        //
        hr =  MQSync_E_PKT_NOT_VALID ;
        LogReplicationEvent( ReplLog_Error,
                             hr ) ;
        return hr ;
    }

    //
    // See that we indeed got the message from a QM service of MSMQ server.
    //    
    GUID *pguid = (GUID *) paProps->aPropVar[ MSG_SENDERID_INDEX ].caub.pElems;
    if (!g_pNeighborMgr->IsMQISServer (pguid))
    {
        //
        // it is neither PSC or PEC's BSC, check if it is NT5 server
        //				
        DWORD dwService = 0;
        if (!g_pNT5ServersMgr->IsNT5Server(pguid, &dwService))		
        {		
            //
            // it is unknown server, get its service from DS 
            //
            PROPID PropId = PROPID_QM_SERVICE;
            PROPVARIANT PropVar;
            PropVar.vt = VT_UI4;

            CDSRequestContext requestContext( e_DoNotImpersonate,
                                              e_ALL_PROTOCOLS);

            hr = DSCoreGetProps( MQDS_MACHINE,
                                 NULL,
                                 pguid,
                                 1,
                                &PropId,
                                &requestContext,
                                &PropVar);
            if (FAILED(hr))
            {				
	            return hr ;
            }

            //
            // add this server to the NT5Servers mapping
            //			
            g_pNT5ServersMgr->AddNT5Server(pguid, PropVar.ulVal);

            dwService = PropVar.ulVal;            	            
        }

        //
        // we are here if 
        // - this NT5 server is found in map
        // - it is new NT5 server and we found its service in DS
        //
        if ((dwService != SERVICE_PSC) &&
            (dwService != SERVICE_BSC))
        {
	        ASSERT (0);
	        hr =  MQSync_E_PKT_WRONG_QM ;
	        LogReplicationEvent( ReplLog_Error,
						         hr ) ;
	        return hr ;
        }	        
    }

    //
    // OK!,
    // Packet is validated. It's time to process it.
    //

    hr = MQSync_I_MSG_NEED_DISPATCH ;
    unsigned char ucOpr = pMessage->GetOperation() ;

    CSyncRequestHeader * pSyncReqMessage;
    DWORD size;
    P<WCHAR> pwszRequesterName = NULL;
    CDSNeighbor  *pNeighbor = NULL ;

    *pguidNT4Master = GUID_NULL;

    switch (ucOpr)
    {
        case DS_REPLICATION_MESSAGE:
        case DS_SYNC_REPLY:
            //
            // to save GUID of the master which sent replication message
            //
            pMessage->GetSiteId(pguidNT4Master);
            break ;

        case DS_WRITE_REQUEST:
        case DS_ALREADY_PURGED:
            //
            // Dispatch.
            //
            LogReplicationEvent( ReplLog_Info, 
                MQSync_I_WRITE_REQUEST_START, GetTickCount() ) ;
            break ;

        case DS_SYNC_REQUEST:
        {
            //
            // check if we are processing sync request from this requster
            // about the specific master
            //
#ifdef _DEBUG
#undef new
#endif

            pSyncReqMessage = new ((unsigned char *)pBuf) CSyncRequestHeader();

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

            size = pSyncReqMessage->GetRequesterNameSize();
            pwszRequesterName = (WCHAR *) new char[size];
            WCHAR *pTemp = pwszRequesterName;
            pSyncReqMessage->GetRequesterName((char *)pTemp, size) ;

            if (g_pNeighborMgr->LookupNeighbor( pwszRequesterName, pNeighbor ))
            {
                const GUID *pMasterId = pSyncReqMessage->GetMasterId();
                const GUID *pNeighborId = pNeighbor->GetMachineId();
                if ( *pMasterId == PEC_MASTER_ID)
                {
                    if (g_pThePecMaster->IsProcessPreMigSyncRequest (pNeighborId))
                    {
                        //
                        // we are processing now sync request of pre-migration object
                        // put this request to the waiting list
                        //
                        hr = MQSync_I_TO_WAITING_LIST;
                    }
                }
                else
                {
                    if (g_pMasterMgr->IsProcessingPreMigSyncRequest (pMasterId, pNeighborId))
                    {
                        //
                        // we are processing now sync request of pre-migration object
                        // put this request to the waiting list
                        //
                        hr = MQSync_I_TO_WAITING_LIST;
                    }
                }
            }
            break;
        }
        case DS_PSC_ACK:
        case DS_BSC_ACK:
            //
            // Ignore. We're not handling this message. MSMQ1.0 need it for
            // the purge algorithm. On MSMQ2.0, purge is done by NT5 DS
            // without any intervention from MSMQ.
            //
            hr = MQSync_OK ;
            break ;

        case DS_WRITE_REPLY:

            hr = ReceiveWriteReplyMessage( paProps,
                                           hMyNt5PecQueue ) ;
            break;

        default:

            ASSERT(("hr = MQSync_E_NORMAL_OPRATION", 0)) ;
            hr = MQSync_E_NORMAL_OPRATION ;
            break;
    }

    return hr ;
}

//+-------------------------------------------------------
//
//  HRESULT _ReceiveAMessage()
//
//+-------------------------------------------------------

static HRESULT _ReceiveAMessage( QUEUEHANDLE  hQueue,
                                 MQMSGPROPS  *paProps )
{
    //
    // Because of the peek/receive method of reading messages, we must
    // be thread safe. Otherwise, one thread will peek, and another one
    // may receive with a small buffer.
    //
    static CCriticalSection s_cs ;
    CS Lock(s_cs) ;

    BYTE buf[2] ;

    paProps->cProp = NUMOF_RECV_MSG_PROPS ;
    paProps->aPropID = new MSGPROPID[ paProps->cProp ] ;
    paProps->aPropVar = new MQPROPVARIANT[ paProps->cProp ] ;
    paProps->aStatus = new HRESULT[ paProps->cProp ] ;

    UINT iIndex = 0 ;

    paProps->aPropID[ iIndex ] = PROPID_M_CLASS ;
    paProps->aPropVar[ iIndex ].vt = VT_UI2 ;
    ASSERT(MSG_CLASS_INDEX == iIndex) ;
    iIndex++ ;

    paProps->aPropID[ iIndex ] = PROPID_M_BODY_SIZE ;
    paProps->aPropVar[ iIndex ].vt = VT_UI4 ;
    ASSERT(MSG_BODYSIZE_INDEX == iIndex) ;
    iIndex++ ;

    paProps->aPropID[ iIndex ] = PROPID_M_BODY ;
    paProps->aPropVar[ iIndex ].vt = VT_VECTOR | VT_UI1 ;         //Type
    paProps->aPropVar[ iIndex ].caub.pElems = buf ;
    paProps->aPropVar[ iIndex ].caub.cElems = 1 ;
    ASSERT(MSG_BODY_INDEX == iIndex) ;
    iIndex++ ;

    paProps->aPropID[ iIndex ] = PROPID_M_CONNECTOR_TYPE ;
    paProps->aPropVar[ iIndex ].vt = VT_CLSID ;
    paProps->aPropVar[ iIndex ].puuid = new CLSID ;
    ASSERT(MSG_CONNECTOR_TYPE_INDEX == iIndex) ;
    iIndex++ ;

    paProps->aPropID[ iIndex ] = PROPID_M_RESP_QUEUE_LEN ;
    paProps->aPropVar[ iIndex ].vt = VT_UI4 ;
    paProps->aPropVar[ iIndex ].ulVal = 1 ;
    ASSERT(MSG_RESPLEN_INDEX == iIndex) ;
    iIndex++ ;

    paProps->aPropID[ iIndex ] = PROPID_M_RESP_QUEUE ;
    paProps->aPropVar[ iIndex ].vt = VT_LPWSTR ;
    paProps->aPropVar[ iIndex ].pwszVal = (LPWSTR) buf ;
    ASSERT(MSG_RESP_INDEX == iIndex) ;
    iIndex++ ;

    paProps->aPropID[ iIndex ] = PROPID_M_AUTHENTICATED ;
    paProps->aPropVar[ iIndex ].vt = VT_UI1 ;
    ASSERT(MSG_AUTHENTICATED_INDEX == iIndex) ;
    iIndex++ ;

    paProps->aPropID[ iIndex ] = PROPID_M_SENDERID_TYPE ;
    paProps->aPropVar[ iIndex ].vt = VT_UI4 ;
    ASSERT(MSG_SENDERID_TYPE_INDEX == iIndex) ;
    iIndex++ ;

    paProps->aPropID[ iIndex ] = PROPID_M_SENDERID_LEN ;
    paProps->aPropVar[ iIndex ].vt = VT_UI4 ;
    ASSERT(MSG_SENDERID_LEN_INDEX == iIndex) ;
    iIndex++ ;

    paProps->aPropID[ iIndex ] = PROPID_M_SENDERID ;
    paProps->aPropVar[ iIndex ].vt = VT_VECTOR | VT_UI1 ;         //Type
    paProps->aPropVar[ iIndex ].caub.pElems = buf ;
    paProps->aPropVar[ iIndex ].caub.cElems = 1 ;
    ASSERT(MSG_SENDERID_INDEX == iIndex) ;
    iIndex++ ;

    ASSERT(iIndex == paProps->cProp) ;

    HRESULT hr = MQReceiveMessage ( hQueue,
                                    INFINITE,
                                    MQ_ACTION_PEEK_CURRENT,
                                    paProps,
                                    NULL,
                                    NULL, // fReceiveCallback,
                                    NULL,
                                    NULL ) ;
    if (hr == MQ_ERROR_BUFFER_OVERFLOW)
    {
        //
        //  Allocate buffer for body.
        //
        ULONG ulSize = paProps->aPropVar[ MSG_BODYSIZE_INDEX ].ulVal ;

        paProps->aPropVar[ MSG_BODY_INDEX ].caub.pElems =
                                                     new BYTE[ ulSize ] ;
        paProps->aPropVar[ MSG_BODY_INDEX ].caub.cElems = ulSize ;

        //
        //  Allocate buffer for sender id.
        //
        ulSize = paProps->aPropVar[ MSG_SENDERID_LEN_INDEX ].ulVal ;
        ASSERT(ulSize == sizeof(GUID)) ;

        paProps->aPropVar[ MSG_SENDERID_INDEX ].caub.pElems =
                                                      new BYTE[ ulSize ] ;
        paProps->aPropVar[ MSG_SENDERID_INDEX ].caub.cElems = ulSize ;

        //
        //  Allocate buffer for response queue.
        //
        paProps->aPropVar[ MSG_RESP_INDEX ].pwszVal = NULL ;
        ulSize = paProps->aPropVar[ MSG_RESPLEN_INDEX ].ulVal ;
        if (ulSize > 0)
        {
            paProps->aPropVar[ MSG_RESP_INDEX ].pwszVal =
                                                     new WCHAR[ ulSize ] ;
        }

        hr = MQReceiveMessage ( hQueue,
                                0,
                                MQ_ACTION_RECEIVE,
                                paProps,
                                NULL,
                                NULL, // fReceiveCallback,
                                NULL,
                                NULL ) ;
    }

    return hr ;
}

//+-------------------------------------------------------
//
//  DWORD WINAPI  RpServiceDispatcheThread()
//
//+-------------------------------------------------------

DWORD WINAPI  RpServiceDispatcherThread(LPVOID lpV)
{
    struct _DispatchThreadStruct *psDispatchData =
                                (struct _DispatchThreadStruct *) lpV ;
    ASSERT(psDispatchData->hInitEvent) ;
    ASSERT(psDispatchData->hRunEvent) ;

    QUEUEHANDLE  hMyMQISQueue = psDispatchData->hMyMQISQueue ;
    QUEUEHANDLE  hMyNt5PecQueue = psDispatchData->hMyNt5PecQueue ;
    ASSERT(hMyMQISQueue) ;
    ASSERT(hMyNt5PecQueue) ;

    //
    // Read number of threads from registry.
    //
    g_dwNumThreads = RP_DEFAULT_REPL_NUM_THREADS ;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwDefault = RP_DEFAULT_REPL_NUM_THREADS ;
    LONG rc = GetFalconKeyValue( RP_REPL_NUM_THREADS_REGNAME,
                                 &dwType,
                                 &g_dwNumThreads,
                                 &dwSize,
                                 (LPCTSTR) &dwDefault );
    if (rc != ERROR_SUCCESS)
    {
        g_dwNumThreads = RP_DEFAULT_REPL_NUM_THREADS ;
    }

    struct _WorkingThreadStruct *psWorkingThreadData =
            (struct _WorkingThreadStruct *)
                        new struct _WorkingThreadStruct[ g_dwNumThreads ] ;
    if (!psWorkingThreadData)
    {
        return 0 ;
    }
    g_psWorkingThreadData = psWorkingThreadData ;

    //
    // Initialization completed OK.
    //
    HANDLE hRunEvent = psDispatchData->hRunEvent ;
    BOOL f = SetEvent(psDispatchData->hInitEvent) ;
    ASSERT(f) ;
    psDispatchData = NULL ;

    memset(psWorkingThreadData, 0,
                    (g_dwNumThreads * sizeof(struct _WorkingThreadStruct)) ) ;

    //
    // Wait until service manager start the service.
    //
    DWORD dwWait = WaitForSingleObject( hRunEvent,
                                        INFINITE ) ;
    DBG_USED(dwWait);
    ASSERT(dwWait == WAIT_OBJECT_0) ;
    CloseHandle(hRunEvent) ;

    if (!g_pNT5ServersMgr)
    {
        g_pNT5ServersMgr = new CDSNT5ServersMgr ;
    }

    while(TRUE)
    {
        MQMSGPROPS aProps ;

        HRESULT hr = _ReceiveAMessage( hMyMQISQueue,
                                       &aProps ) ;
        if (FAILED(hr))
        {
            LogReplicationEvent( ReplLog_Error,
                                 MQSync_E_RECEIVE_MSG,
                                 hr ) ;
            continue ;
        }

        //
        // First check if message should be processed by a working
        // threads. Several high-priority and short operation are
        // processed by the dispatcher thread itself.
        //
        GUID guidCurMaster;
        hr = _ProcessImmediateRequest( &aProps, hMyNt5PecQueue, &guidCurMaster ) ;

        {
            CS Lock(g_csJobProcessing);

            if (hr == MQSync_I_TO_WAITING_LIST)
            {
                //
                // This message must unconditionally wait for other job to
                // terminate before it can continue.
                //
                BOOL f = g_cDispatchWaitingList.InsertJob( &aProps, &guidCurMaster) ;
                DBG_USED(f);
                ASSERT(f) ;
                continue;
            }

            if (hr != MQSync_I_MSG_NEED_DISPATCH)
            {
                FreeMessageProps( &aProps ) ;
                continue ;
            }

            //
            // If more than one thread would process replication messages
            // and sync reply from the same NT4 master then we may insert
            // objects in the active directory or set their properties in
            // wrong order. That will destroy the sync between NT4 MQIS
            // and Windows 2000 active directory.
            // So, before dispatching this message to a free thread, check
            // if we are already processing replication messages from the
            // current master. If yes, then insert the message in the waiting
            // list.
            //
            BOOL fIsAlreadyProcessing = FALSE;
            if (guidCurMaster != GUID_NULL)
            {
                for ( DWORD j = 0 ; j < g_dwNumThreads ; j++ )
                {
                    if (psWorkingThreadData[j].fBusy &&
                        psWorkingThreadData[j].guidNT4Master == guidCurMaster)
                    {
                        //
                        // Insert request in a waiting list.
                        //
                        BOOL f = g_cDispatchWaitingList.InsertJob( &aProps, &guidCurMaster) ;
                        DBG_USED(f);
                        ASSERT(f) ;
                        fIsAlreadyProcessing = TRUE;
                        break;
                    }
                }
                if (fIsAlreadyProcessing)
                {
                    continue;
                }
            }

            //
            // look for an available thread.
            //
            BOOL  fThreadFound = FALSE ;
            DWORD dwThreadIndex = 0 ;

            for ( DWORD j = 0 ; j < g_dwNumThreads ; j++ )
            {
                if (psWorkingThreadData[j].hEvent)
                {
                    if (!psWorkingThreadData[j].fBusy)
                    {
                        fThreadFound = TRUE ;
                        dwThreadIndex = j ;
                        break ;
                    }
                }
                else
                {
                    //
                    // Create a new thread. All threads are busy.
                    // First create the event for this thread.
                    //
                    HANDLE hEvent = CreateEvent( NULL,
                                                 FALSE,
                                                 FALSE,
                                                 NULL ) ;
                    if (!hEvent)
                    {
                        LogReplicationEvent( ReplLog_Error,
                                             MQSync_E_CREATE_EVENT,
                                             GetLastError()) ;
                        break ;
                    }

                    psWorkingThreadData[j].hEvent = hEvent ;
                    psWorkingThreadData[j].dwThreadNum = j ;

                    DWORD dwID ;
                    HANDLE hThread = CreateThread( NULL,
                                                   0,
                          (LPTHREAD_START_ROUTINE) ReplicationWorkingThread,
                                         (LPVOID) &psWorkingThreadData[j],
                                                   0,
                                                  &dwID ) ;
                    if (hThread)
                    {
                        CloseHandle(hThread) ;
                        fThreadFound = TRUE ;
                        dwThreadIndex = j ;
                    }
                    else
                    {
                        LogReplicationEvent( ReplLog_Error,
                                             MQSync_E_CREATE_WORK_THREAD,
                                             GetLastError() ) ;
                        break ;
                    }
                }
            }   //for

            if (fThreadFound)
            {
                psWorkingThreadData[ dwThreadIndex ].aWorkingProps = aProps ;
                psWorkingThreadData[ dwThreadIndex ].fBusy = TRUE ;
                psWorkingThreadData[ dwThreadIndex ].guidNT4Master = guidCurMaster;

                f = SetEvent(psWorkingThreadData[ dwThreadIndex ].hEvent) ;
                ASSERT(f) ;
            }
            else
            {
                //
                // Insert request in a waiting list.
                //
                BOOL f = g_cDispatchWaitingList.InsertJob( &aProps, &guidCurMaster) ;
                DBG_USED(f);
                ASSERT(f) ;
            }
        }   //CS
    }   //while (TRUE)

    return 0 ;
}

//+------------------------------------------------
//
//  void FreeMessageProps( MQMSGPROP *pProps )
//
//+------------------------------------------------

void FreeMessageProps( MQMSGPROPS *pProps )
{
    delete pProps->aPropVar[ MSG_BODY_INDEX ].caub.pElems ;
    delete pProps->aPropVar[ MSG_SENDERID_INDEX ].caub.pElems ;
    delete pProps->aPropVar[ MSG_RESP_INDEX ].pwszVal ;
    delete pProps->aPropVar[ MSG_CONNECTOR_TYPE_INDEX ].puuid ;

    delete pProps->aPropID ;
    delete pProps->aPropVar ;
    delete pProps->aStatus ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpdelete.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpdelete.cpp

Abstract: Handle deleted objects.


Author:

    Doron Juster  (DoronJ)   24-Mar-98

--*/

#include "mq1repl.h"
#include "..\..\src\ds\h\mqattrib.h"

#include "rpdelete.tmh"

//+----------------------------------------
//
//  HRESULT  HandleADeletedObject()
//
//+----------------------------------------
HRESULT  HandleADeletedObject(
			   DWORD		   dwObjectType,
			   PLDAP           pLdap,
               LDAPMessage    *pRes,
               CDSMaster      *pMaster,
               CDSUpdateList  *pReplicationList,
               GUID           *pNeighborId)
{
	__int64 i64SeqNum = 0 ;
    GUID  ObjectGuid ;
	
    HRESULT hr =  GetGuidAndUsn( pLdap,
								 pRes,
								 pMaster->GetDelta(),
								 &ObjectGuid,
								 &i64SeqNum ) ; // i64SeqNum is equal to zero iff
												// the function failed OR
												// we asked USN of pre-migration object        
    ASSERT(SUCCEEDED(hr)) ;

    CSeqNum sn, snPrev ;       
    GetSNForReplication (i64SeqNum, pMaster, pNeighborId, &sn);
    
    //
    // handle Foreign Site and native NT5 site
    //        
    if (dwObjectType == MQDS_SITE )
    {
        if (IsForeignSiteInIniFile(ObjectGuid))
        {
            //
            // it was foreign site
            //
            dwObjectType = MQDS_CN;            
        }
        else
        {
            //
            // it was probably native NT5 site, try to remove it from map
            //
            g_pNativeNT5SiteMgr->RemoveNT5NativeSite (&ObjectGuid);
        }
    }

    #define     PROPS_SIZE  2
    PROPID      propIDs[ PROPS_SIZE ];
    PROPVARIANT propVariants[ PROPS_SIZE ] ;
    DWORD       iProps = 0 ;

    propIDs[ iProps ] = PROPID_D_SCOPE ;
	propVariants[ iProps ].vt = VT_UI1 ;
    propVariants[ iProps ].bVal = ENTERPRISE_SCOPE ;
    iProps++;

    propIDs[ iProps ] = PROPID_D_OBJTYPE ;
	propVariants[ iProps ].vt = VT_UI1 ;
    propVariants[ iProps ].bVal = (unsigned char) dwObjectType ;
    iProps++;

    ASSERT(iProps <= PROPS_SIZE) ;
    #undef  PROPS_SIZE

    NOT_YET_IMPLEMENTED(TEXT("PrepNeighbor(delete), no OUT update, LSN"), s_fPrep) ;

	const GUID *pMasterId = pMaster->GetMasterId();
    hr = PrepareNeighborsUpdate( DS_UPDATE_DELETE,
                                 dwObjectType,
                                 NULL, // pwName,
                                 &ObjectGuid,
                                 iProps,
                                 propIDs,
                                 propVariants,
                                 pMasterId,
                                 sn,
                                 snPrev,
                                 ENTERPRISE_SCOPE,
                                 TRUE, //  fNeedFlush,
                                 pReplicationList ) ;

#ifdef _DEBUG
    TCHAR  tszSn[ SEQ_NUM_BUF_LEN ] ;
    sn.GetValueForPrint(tszSn) ;

    LogReplicationEvent(ReplLog_Info, MQSync_I_DELETED_OBJECT,
                                                dwObjectType, tszSn) ;
#endif

	if (dwObjectType == MQDS_CN)
    {
        dwObjectType = MQDS_SITE;
    }

	return hr;
}

//+----------------------------------------
//
//  HRESULT  _HandleDeletedObject()
//
//+----------------------------------------

static HRESULT _HandleDeletedObjects( IN  DWORD          dwObjectType,
                                      IN  TCHAR         *pszDN,
                                      IN  TCHAR         *pszFilterIn,
                                      IN  CDSMaster     *pMaster,
                                      IN  CDSUpdateList *pReplicationList,
                                      IN  GUID          *pNeighborId,
                                      OUT int           *piCount )
{
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;
    
    LM<LDAPMessage> pRes = NULL ;

    LDAPControl ldapcDeleted = { NULL, 0, 0, 0 } ;
    ldapcDeleted.ldctl_oid = TEXT("1.2.840.113556.1.4.417") ;
    //ldapcDeleted.ldctl_iscritical = 0 ;
    LDAPControl *ppldapcDeleted[2] = {&ldapcDeleted, NULL} ;

	hr = QueryDS(
			pLdap,
			pszDN,
			pszFilterIn,
			pMaster,
            pReplicationList,
            pNeighborId,
			dwObjectType,
            piCount ,
			//special parameters for deleted object
			TRUE,
			ppldapcDeleted,
			//special parameters for user object
			FALSE,
			NULL
			);
	
    return hr ;
}

//+----------------------------------------
//
//  HRESULT  HandleDeletedQueues()
//
//+----------------------------------------

HRESULT HandleDeletedQueues( IN  TCHAR         *pszDN,
                             IN  TCHAR         *pszFilterIn,
                             IN  CDSMaster     *pMaster,
                             IN  CDSUpdateList *pReplicationList,
                             IN  GUID          *pNeighborId,
                             OUT int           *piCount )
{
    DWORD dwLen = _tcslen(pszFilterIn) + 
                  ISDELETED_FILTER_LEN + 
                  // '\0' and ')' after the object class and ')' at the end of filter
                  3 +                                               
                  OBJECTCLASS_FILTER_LEN + 
                  _tcslen (MSMQ_QUEUE_CLASS_NAME) ;

    P<TCHAR> tszFilter = new TCHAR[ dwLen ] ;
    _tcscpy(tszFilter, pszFilterIn) ;
    _tcscat(tszFilter, ISDELETED_FILTER) ;
    _tcscat(tszFilter, OBJECTCLASS_FILTER) ;    
    _tcscat(tszFilter, MSMQ_QUEUE_CLASS_NAME) ;
    _tcscat(tszFilter, TEXT("))"));

    HRESULT hr = _HandleDeletedObjects( MQDS_QUEUE,
                                        pszDN,
                                        tszFilter,
                                        pMaster,
                                        pReplicationList,
                                        pNeighborId,
                                        piCount ) ;
    return hr ;
}

//+----------------------------------------
//
//  HRESULT HandleDeletedSites()
//
//+----------------------------------------

HRESULT HandleDeletedSites( IN  TCHAR         *pszPrevUsn,
                            IN  TCHAR         *pszCurrentUsn,
                            IN  CDSUpdateList *pReplicationList,
                            IN  GUID          *pNeighborId,
                            OUT int           *piCount )
{
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;
    //
    // we are looking from CN=Configuration...
    //
    ASSERT(pGetNameContext()) ;

    DWORD dwDNSize = wcslen(CN_CONFIGURATION) + wcslen(pGetNameContext()) ;
    P<WCHAR> pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    wcscpy(pwszDN, CN_CONFIGURATION) ;
    wcscat(pwszDN, pGetNameContext());

    TCHAR  wszFilter[ 512 ] ;

    _tcscpy(wszFilter,
            TEXT("(&(objectClass=Site)(IsDeleted=TRUE)(usnChanged>=")) ;
    _tcscat(wszFilter, pszPrevUsn) ;
    if (pszCurrentUsn)
    {
        _tcscat(wszFilter, TEXT(")(usnChanged<=")) ;
        _tcscat(wszFilter, pszCurrentUsn) ;
    }
    _tcscat(wszFilter, TEXT("))")) ;
    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

    ASSERT(g_pThePecMaster) ;
    hr = _HandleDeletedObjects( MQDS_SITE,
                                pwszDN,
                                wszFilter,
                                g_pThePecMaster,
                                pReplicationList,
                                pNeighborId,
                                piCount ) ;
    return hr ;
}

//+----------------------------------------
//
//  HRESULT  HandleDeletedMachines()
//
//+----------------------------------------

HRESULT HandleDeletedMachines( 
             IN  TCHAR         *pszDN,
             IN  TCHAR         *pszFilterIn,
             IN  CDSMaster     *pMaster,
             IN  CDSUpdateList *pReplicationList,
             IN  GUID          *pNeighborId,
             OUT int           *piCount 
             )
{   
    DWORD dwLen = _tcslen(pszFilterIn) + 
                  ISDELETED_FILTER_LEN + 
                  // '\0' and ')' after the object class and ')' at the end of filter
                  3 +                                               
                  OBJECTCLASS_FILTER_LEN + 
                  _tcslen (MSMQ_COMPUTER_CONFIGURATION_CLASS_NAME) ;

    P<TCHAR> tszFilter = new TCHAR[ dwLen ] ;
    _tcscpy(tszFilter, pszFilterIn) ;
    _tcscat(tszFilter, ISDELETED_FILTER) ;
    _tcscat(tszFilter, OBJECTCLASS_FILTER) ;    
    _tcscat(tszFilter, MSMQ_COMPUTER_CONFIGURATION_CLASS_NAME) ;
    _tcscat(tszFilter, TEXT("))"));

    HRESULT hr = _HandleDeletedObjects( MQDS_MACHINE,
                                        pszDN,
                                        tszFilter,
                                        pMaster,
                                        pReplicationList,
                                        pNeighborId,
                                        piCount ) ;
    return hr ;
}

//+----------------------------------------
//
//  HRESULT  HandleDeletedSiteLinks()
//
//+----------------------------------------

HRESULT HandleDeletedSiteLinks(                 
                IN  TCHAR         *pszFilterIn,
                IN  CDSUpdateList *pReplicationList,
                IN  GUID          *pNeighborId,
                OUT int           *piCount 
                )
{
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;
    //
    // we are looking from CN=Configuration...
    //
    ASSERT(pGetNameContext()) ;

    DWORD dwDNSize = wcslen(CN_CONFIGURATION) + wcslen(pGetNameContext()) ;
    P<WCHAR> pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    wcscpy(pwszDN, CN_CONFIGURATION) ;
    wcscat(pwszDN, pGetNameContext());
   
    DWORD dwLen = _tcslen(pszFilterIn) + 
                  ISDELETED_FILTER_LEN + 
                  // '\0' and ')' after the object class and ')' at the end of filter
                  3 +                                               
                  OBJECTCLASS_FILTER_LEN + 
                  _tcslen (MSMQ_SITELINK_CLASS_NAME) ;

    P<TCHAR> tszFilter = new TCHAR[ dwLen ] ;
    _tcscpy(tszFilter, pszFilterIn) ;
    _tcscat(tszFilter, ISDELETED_FILTER) ;
    _tcscat(tszFilter, OBJECTCLASS_FILTER) ;    
    _tcscat(tszFilter, MSMQ_SITELINK_CLASS_NAME) ;
    _tcscat(tszFilter, TEXT("))"));

    hr = _HandleDeletedObjects( MQDS_SITELINK,
                                pwszDN,
                                tszFilter,
                                g_pThePecMaster,
                                pReplicationList,
                                pNeighborId,
                                piCount ) ;
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpdebug.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpdebug.cpp

Abstract:


Author:

    Doron Juster  (DoronJ)   22-Feb-98

--*/

#include "mq1repl.h"

#include "rpdebug.tmh"

//+------------------------------------
//
//  UINT  ReadDebugIntFlag()
//
//+------------------------------------

UINT  ReadDebugIntFlag(WCHAR *pwcsDebugFlag, UINT iDefault)
{
    static BOOL   s_fInitialized = FALSE ;
    static TCHAR  s_szIniName[ MAX_PATH ] = {TEXT('\0')} ;

    if (!s_fInitialized)
    {
        DWORD dw = GetModuleFileName( NULL,
                                      s_szIniName,
                       (sizeof(s_szIniName) / sizeof(s_szIniName[0]))) ;
        if (dw != 0)
        {
            TCHAR *p = _tcsrchr(s_szIniName, TEXT('\\')) ;
            if (p)
            {
                p++ ;
                _tcscpy(p, TEXT("mq1sync.ini")) ;
            }
        }
        s_fInitialized = TRUE ;
    }

    UINT uiDbg = GetPrivateProfileInt( TEXT("Debug"),
                                       pwcsDebugFlag,
                                       iDefault,
                                       s_szIniName ) ;
    return uiDbg ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpdsptch.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpdsptch.h

Author:

    Doron Juster  (DoronJ)   10-Jun-98

--*/

//
// This structure is passed to the dispatcher thread, when it is created.
// Dispatcher thread is created in service initialization phase.
//
struct _DispatchThreadStruct
{
    //
    // This event is used to signal that the dispatch thread is initialzied.
    //
    HANDLE       hInitEvent ;

    //
    // This event is used to signal the dispatch thread that it can start
    // receive messages from queue.
    //
    HANDLE       hRunEvent ;

    //
    // Handle of replication queues.
    //
    QUEUEHANDLE  hMyMQISQueue ;
    QUEUEHANDLE  hMyNt5PecQueue ;
} ;

DWORD WINAPI  RpServiceDispatcherThread(LPVOID lpV) ;

//
// This structure is passed by the dispatcher to the working threads, when
// each working thread is created.
//
struct _WorkingThreadStruct
{
    //
    // This flag, when TRUE, indicate that the thread is busy. When FALSE,
    // the working thread free and available to process a message.
    //
    BOOL  fBusy ;

    //
    // This handle wake up the working thread. The thread wait on it until
    // it's signalled by the dispatcher.
    //
    HANDLE  hEvent ;

    //
    // Message properties
    //
    MQMSGPROPS aWorkingProps ;

    //
    // Serial number of thread. This is mainly for debug and logging.
    //
    DWORD  dwThreadNum ;

    //
    // for replication and sync reply messages:
    // GUID of the NT4 master that sends this message
    //
    GUID guidNT4Master;    
} ;


DWORD WINAPI  ReplicationWorkingThread(LPVOID lpV) ;

//
// Define the waiting list.
//
enum _eJobStatus
{
    eWaiting,       // wait for a free thread
    eAlreadyMerged  // merge within another job. ignore it.
} ;

struct _WaitingJob
{
    MQMSGPROPS          aWorkingProps ;
    enum _eJobStatus    eJobStatus ;
    DWORD               dwSerialNumber ;
    GUID                guidNT4Master ;
    struct _WaitingJob *pNextJob ;
} ;

class crpDispatchWaitingList
{
public:

    crpDispatchWaitingList() ;
    ~crpDispatchWaitingList() ;

    BOOL  InsertJob( MQMSGPROPS *pProps, GUID *pguidCurMaster ) ;
    BOOL  GetNextJob( GUID *pguidCurMaster, MQMSGPROPS *pProps ) ;
    BOOL  PeekNextJob(GUID *pguidCurMaster) ;

private:

    CCriticalSection m_cs ;

    struct _WaitingJob  *m_pFirstJob ;
    struct _WaitingJob  *m_pLastJob ; 

    DWORD  m_cWaitingJobs ; // number of waiting jobs

    DWORD  m_dwSerialNumberInsert ; // for debug
    DWORD  m_dwSerialNumberRemove ; // for debug
} ;

//+--------------------------------
//
//  class CDSNT5ServersMgr
//
//+--------------------------------

class CDSNT5ServersMgr
{
    public:
        CDSNT5ServersMgr();
        ~CDSNT5ServersMgr();

        void    AddNT5Server (IN const GUID * pguid, IN const DWORD dwService);
        BOOL    IsNT5Server( IN const GUID * pguid, OUT DWORD *pdwService);

    private:
        CCriticalSection    m_cs;
        CMap< GUID, const GUID&, DWORD, DWORD> m_MapNT5ServerIdToService;
};

inline  CDSNT5ServersMgr::CDSNT5ServersMgr()
{
};

inline  CDSNT5ServersMgr::~CDSNT5ServersMgr()
{
};

inline  BOOL CDSNT5ServersMgr::IsNT5Server( const GUID * pguid, OUT DWORD *pdwService)
{    
    CS lock(m_cs);

    return (m_MapNT5ServerIdToService.Lookup( *pguid, *pdwService));    
}

inline  void CDSNT5ServersMgr::AddNT5Server (IN const GUID * pguid, IN const DWORD dwService)
{
    CS lock(m_cs);
    m_MapNT5ServerIdToService[ *pguid ] = dwService ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpent.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rppec.cpp

Abstract: replication of pec properties to NT4 MSMQ1.0 servers.

Author:

    Tatiana Shubin  (TatianaS)   21-Apr-98

--*/

#include "mq1repl.h"

#include <activeds.h>
#include "..\..\src\ds\h\mqattrib.h"

#include "rpent.tmh"

#define DEFAULT_CRL_SIZE    0
#define DEFAULT_CRL_DATA    NULL
#define DEFAULT_CSP_TYPE    0
#define DEFAULT_ENCRYPT_ALG 0
#define DEFAULT_SIGN_ALG    0
#define DEFAULT_HASH_ALG    0
#define DEFAULT_CIPHER_MODE 0
	       
//+-------------------------------------------------------
//
//  HRESULT HandleAEnterprise()
//
//+-------------------------------------------------------
HRESULT _HandleAEnterprise( 
                PLDAP           pLdap,
                LDAPMessage    *pRes,
                CDSUpdateList  *pReplicationList,
                GUID          *pNeighborId
                ) 
{        
    HRESULT hr;
    DWORD dwLen = 0 ;
    P<BYTE>  pBuf = NULL ;
    hr = RetrieveSecurityDescriptor( MQDS_ENTERPRISE,
                                     pLdap,
                                     pRes,
                                     &dwLen,
                                     &pBuf ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    //
    // Get CN of enterprise.
    //
    WCHAR **ppValue = ldap_get_values( pLdap,
                                       pRes,
                                       TEXT("cn") ) ;
    if (ppValue && *ppValue)
    {
        //
        // Retrieve server name from the DN.
        //
        P<WCHAR> pwName = new TCHAR[ 1 + _tcslen(*ppValue) ] ;
        _tcscpy(pwName, *ppValue) ;

        __int64 i64SeqNum = 0 ;
        GUID  EntGuid ;
        hr =  GetGuidAndUsn( pLdap,
                             pRes,
                             g_pThePecMaster->GetDelta(),
                             &EntGuid,
                             &i64SeqNum ) ;
        ASSERT(SUCCEEDED(hr)) ;
        
        CSeqNum sn, snPrev ;
        GetSNForReplication (i64SeqNum, g_pThePecMaster, pNeighborId, &sn);
        
        #define     PROPS_SIZE  15
        PROPID      propIDs[ PROPS_SIZE ];
        PROPVARIANT propVariants[ PROPS_SIZE ] ;
        DWORD       iProps = 0 ;
             
        propIDs[ iProps ] = PROPID_E_LONG_LIVE ;     
	    propVariants[ iProps ].vt = VT_UI4 ;                
	    iProps++;
                     
        propIDs[ iProps ] = PROPID_E_NAMESTYLE  ;    
	    propVariants[ iProps ].vt = VT_UI1 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_E_CSP_NAME ;     
	    propVariants[ iProps ].vt = VT_NULL ;        
        propVariants[ iProps ].pwszVal = NULL ;         
        DWORD dwCSPNameIndex = iProps ;
	    iProps++;
        
        propIDs[ iProps ] = PROPID_E_VERSION ;     
	    propVariants[ iProps ].vt = VT_UI2 ;                
	    iProps++;

        propIDs[ iProps ] = PROPID_E_S_INTERVAL1 ;     
	    propVariants[ iProps ].vt = VT_UI2 ;                
	    iProps++;

        propIDs[ iProps ] = PROPID_E_S_INTERVAL2 ;     
	    propVariants[ iProps ].vt = VT_UI2 ;                
	    iProps++;       

        propIDs[ iProps ] = PROPID_E_NAME ;     
	    propVariants[ iProps ].vt = VT_NULL ;        
        propVariants[ iProps ].pwszVal = NULL ;         
        DWORD dwNameIndex = iProps ;
	    iProps++;        

        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  // not relevant 

        hr =  DSCoreGetProps( MQDS_ENTERPRISE,
                              NULL,
                              &EntGuid,
                              iProps,
                              propIDs,
                              &requestContext,
                              propVariants ) ;
        
        if (SUCCEEDED(hr))
        {
			P<BYTE> pCRLData = DEFAULT_CRL_DATA;

            propIDs[ iProps ] = PROPID_E_CRL ;     
	        propVariants[ iProps ].vt = VT_BLOB ;                
            propVariants[ iProps ].blob.cbSize = DEFAULT_CRL_SIZE ;
            propVariants[ iProps ].blob.pBlobData = pCRLData ;            
	        iProps++;

            propIDs[ iProps ] = PROPID_E_CSP_TYPE ;     
	        propVariants[ iProps ].vt = VT_UI4 ;   
            propVariants[ iProps ].ulVal = DEFAULT_CSP_TYPE;
	        iProps++;

            propIDs[ iProps ] = PROPID_E_ENCRYPT_ALG ;     
	        propVariants[ iProps ].vt = VT_UI4 ;  
            propVariants[ iProps ].ulVal = DEFAULT_ENCRYPT_ALG ;
	        iProps++;

            propIDs[ iProps ] = PROPID_E_SIGN_ALG ;     
	        propVariants[ iProps ].vt = VT_UI4 ;
            propVariants[ iProps ].ulVal = DEFAULT_SIGN_ALG ;
	        iProps++;

            propIDs[ iProps ] = PROPID_E_HASH_ALG ;     
	        propVariants[ iProps ].vt = VT_UI4 ;   
            propVariants[ iProps ].ulVal = DEFAULT_HASH_ALG ;
	        iProps++;

            propIDs[ iProps ] = PROPID_E_CIPHER_MODE ;     
	        propVariants[ iProps ].vt = VT_UI4 ;  
            propVariants[ iProps ].ulVal = DEFAULT_CIPHER_MODE ;
	        iProps++;

            ASSERT(pBuf) ;
            ASSERT(dwLen != 0) ;
            ASSERT(IsValidSecurityDescriptor(pBuf)) ;

            propIDs[ iProps ] = PROPID_E_SECURITY ;
	        propVariants[ iProps ].vt = VT_BLOB ;
            propVariants[ iProps ].blob.cbSize = dwLen ;
            propVariants[ iProps ].blob.pBlobData = pBuf ;
	        iProps++;

            propIDs[ iProps ] = PROPID_E_PECNAME ;
            propVariants[ iProps ].vt = VT_LPWSTR ;
            propVariants[ iProps ].pwszVal = g_pwszMyMachineName ;
	        iProps++;

            ASSERT(iProps <= PROPS_SIZE) ;
            #undef  PROPS_SIZE      
     
            NOT_YET_IMPLEMENTED(TEXT("PrepNeighbor, no OUT update, LSN"), s_fPrep) ;
           
            hr = PrepareNeighborsUpdate( 
                         DS_UPDATE_SYNC,
                         MQDS_ENTERPRISE,
                         NULL, // pwName,
                         &EntGuid,
                         iProps,
                         propIDs,
                         propVariants,
                         &g_PecGuid,
                         sn,
                         snPrev,
                         ENTERPRISE_SCOPE,
                         TRUE, //  fNeedFlush,
                         pReplicationList ) ;//OUT CDSUpdate **  ppUpdate    

#ifdef _DEBUG
                TCHAR  tszSn[ SEQ_NUM_BUF_LEN ] ;
                sn.GetValueForPrint(tszSn) ;

                unsigned short *lpszGuid ;
                UuidToString( &EntGuid, &lpszGuid ) ;       

                LogReplicationEvent(ReplLog_Info, MQSync_I_REPLICATE_ENTERPRISE,
                                     lpszGuid, tszSn) ;

                RpcStringFree( &lpszGuid ) ;
#endif  
			//
			// free buffer of enterprise properties.
			//        
			delete propVariants[ dwCSPNameIndex ].pwszVal ;   
			delete propVariants[ dwNameIndex ].pwszVal ; 
        
        }        
        int i = ldap_value_free(ppValue) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;
    }
    else
    {
        ASSERT(0) ;
    }
    
    return hr;
}

HRESULT ReplicateEnterprise (
            IN  TCHAR         *pszPrevUsn,
            IN  TCHAR         *pszCurrentUsn,
            IN  CDSUpdateList *pReplicationList,
            IN  GUID          *pNeighborId,
            OUT int           *piCount
            )
{
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;
    ASSERT(pGetNameContext()) ;

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwDNSize = wcslen(SITE_LINK_ROOT) + wcslen(pGetNameContext()) ;
    P<WCHAR> pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    wcscpy(pwszDN, SITE_LINK_ROOT) ;
    wcscat(pwszDN, pGetNameContext());

    TCHAR *pszCategoryName = const_cast<LPTSTR> (x_ServiceCategoryName);
    
    TCHAR wszFullName[256];    
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName, pszSchemaDefName);

     TCHAR  wszFilter[ 512 ] ;    
    _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;    
    _tcscat(wszFilter, wszFullName);   
   
    _tcscat(wszFilter, TEXT(")(usnChanged>=")) ;
    _tcscat(wszFilter, pszPrevUsn) ;     
   
    if (pszCurrentUsn)
    {
        _tcscat(wszFilter, TEXT(")(usnChanged<=")) ;
        _tcscat(wszFilter, pszCurrentUsn) ;
    }
    _tcscat(wszFilter, TEXT(")")) ;
    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

    //
    // handle deleted enterprise: to do nothing
    //    
    _tcscat(wszFilter, TEXT(")")) ;
    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

    //
    // handle enterprise
    //    
    LM<LDAPMessage> pRes = NULL ;
    ULONG ulRes = ldap_search_s( pLdap,
                                 pwszDN,
                                 LDAP_SCOPE_SUBTREE,
                                 wszFilter,
                                 NULL, //ppAttributes,
                                 0,
                                 &pRes ) ;
    if (ulRes != LDAP_SUCCESS)
    {
        hr = MQSync_E_LDAP_SEARCH_FAILED ;
        LogReplicationEvent(ReplLog_Error, hr, pwszDN, wszFilter, ulRes) ;
        return hr ;
    }
    ASSERT(pRes) ;
        
    int iCount = ldap_count_entries(pLdap, pRes) ;

    LogReplicationEvent(ReplLog_Info, MQSync_I_LDAP_SEARCH,
                                             iCount, pwszDN, wszFilter) ;

    if (iCount == 0)
    {
        //
        // No results. That's OK.
        //        
        return MQSync_I_LDAP_NO_RESULTS ;
    }
    ASSERT( iCount == 1);
    //
    // OK, we have results. 
    //
    BOOL fFailed = FALSE ;
    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    while(pEntry)
    {
        hr = _HandleAEnterprise( 
                    pLdap,
                    pEntry,
                    pReplicationList,
                    pNeighborId
                    ) ;
        if (FAILED(hr))
        {
            fFailed = TRUE ;
        }        
        LDAPMessage *pPrevEntry = pEntry ;
        pEntry = ldap_next_entry(pLdap, pPrevEntry) ;        
    }

    *piCount += iCount ;    
    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpmachn.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpmachine.cpp

Abstract: replication of NT5 machine to NT4 MSMQ1.0 servers.

Author:

    Tatiana Shubin  (TatianaS)   21-Apr-98

--*/

#include "mq1repl.h"
#include <activeds.h>
#include "..\..\src\ds\h\mqattrib.h"

#include "rpmachn.tmh"

HRESULT PrepareCNsAndAddress (
		OUT	GUID		**ppCNsGuid,
		OUT	ULONG		*pulCNsNum,
		IN OUT ULONG	*pulAddrSize,
		IN OUT BYTE		**ppAddrData
		)
{
    //
    // define size of AllCNs array
    //
    ULONG ulAllCNs = 0;
    TA_ADDRESS* pAddr;

    ULONG ulAllForeignAddr = 0;

    for ( DWORD len = 0 ;
          len < *pulAddrSize ;
          len += TA_ADDRESS_SIZE + pAddr->AddressLength )
    {
        pAddr = (TA_ADDRESS*) (*ppAddrData + len);

		switch (pAddr->AddressType)
		{
			case IP_ADDRESS_TYPE:
			case IP_RAS_ADDRESS_TYPE:
				ulAllCNs += g_ulIpCount;				
				break;

			case IPX_ADDRESS_TYPE:
			case IPX_RAS_ADDRESS_TYPE:
				ulAllCNs += g_ulIpxCount;			
				break;

            case FOREIGN_ADDRESS_TYPE:
                ulAllCNs ++;
                ulAllForeignAddr ++;
                break;

			default:
				ASSERT(0) ;
				return MQSync_E_READ_CNS;				
		}
    }

    if (ulAllCNs == 0)
    {
        ASSERT(0) ;
		return MQSync_E_READ_CNS;
    }
    GUID *pAllCNsGuid = new GUID [ulAllCNs];

    //
    // maximal size for new address = 
    //          current size * (number of all CNs + all foreign CN of this machine)
    //
	P<BYTE> pNewAddress = new BYTE[*pulAddrSize * (g_ulIpCount+g_ulIpxCount + ulAllForeignAddr)];
	BYTE *ptrNewAddr = pNewAddress;
	
	ULONG ulCurProtocolCount = 0;
	GUID *pCurGuids = NULL;
	
	ULONG ulAllSize = 0;
    ULONG ulCurCNsCount = 0;

    GUID ForeignCNGuid = GUID_NULL;

    for ( len = 0 ;
          len < *pulAddrSize ;
          len += TA_ADDRESS_SIZE + pAddr->AddressLength )
    {
		pAddr = (TA_ADDRESS*) (*ppAddrData + len);

		switch (pAddr->AddressType)
		{
			case IP_ADDRESS_TYPE:
			case IP_RAS_ADDRESS_TYPE:
				ulCurProtocolCount = g_ulIpCount;
				pCurGuids = g_pIpCNs;
				break;

			case IPX_ADDRESS_TYPE:
			case IPX_RAS_ADDRESS_TYPE:
				ulCurProtocolCount = g_ulIpxCount;
				pCurGuids = g_pIpxCNs;
				break;

			case FOREIGN_ADDRESS_TYPE:
				ulCurProtocolCount = 1;
				memcpy (&ForeignCNGuid, pAddr->Address, sizeof(GUID)); 
				pCurGuids = &ForeignCNGuid;
				break;

			default:
				ASSERT(0) ;
				return MQSync_E_READ_CNS;				
		}			

		for (ULONG i=0; i<ulCurProtocolCount; i++)
		{
			memcpy(	ptrNewAddr,
					pAddr,
					pAddr->AddressLength + TA_ADDRESS_SIZE);
			ptrNewAddr += pAddr->AddressLength + TA_ADDRESS_SIZE;
			ulAllSize += pAddr->AddressLength + TA_ADDRESS_SIZE;
			
			memcpy (&pAllCNsGuid[i + ulCurCNsCount],
					&pCurGuids[i],
					sizeof(GUID));
		}
		ulCurCNsCount += ulCurProtocolCount;		
	}
        	
	*pulCNsNum = ulAllCNs;
	*ppCNsGuid = pAllCNsGuid;

    ASSERT (ulAllSize <= *pulAddrSize * (g_ulIpCount+g_ulIpxCount + ulAllForeignAddr));
	*pulAddrSize = ulAllSize;
	delete (*ppAddrData);
	*ppAddrData = pNewAddress.detach() ;

    return MQSync_OK;
}

//+-------------------------------------------------------
//
//  HRESULT _HandleAMachine()
//
//+-------------------------------------------------------

HRESULT HandleAMachine(
               PLDAP           pLdap,
               LDAPMessage    *pRes,
               CDSMaster      *pMaster,
               CDSUpdateList  *pReplicationList,
               GUID           *pNeighborId
               )
{
    DWORD dwLen = 0 ;
    P<BYTE> pBuf = NULL ;
    HRESULT hr = RetrieveSecurityDescriptor( MQDS_MACHINE,
                                             pLdap,
                                             pRes,
                                             &dwLen,
                                             &pBuf ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    GUID *pMasterId = const_cast<GUID *> (pMaster->GetMasterId()) ;

    //
    // Get CN of site.
    //
    WCHAR **ppValue = ldap_get_values( pLdap,
                                       pRes,
                                       TEXT("cn") ) ;
    if (ppValue && *ppValue)
    {
        __int64 i64SeqNum = 0 ;
        GUID  MachineGuid ;
        hr =  GetGuidAndUsn( pLdap,
                             pRes,
                             pMaster->GetDelta(),
                             &MachineGuid,
                             &i64SeqNum ) ; // i64SeqNum is equal to zero iff
                                            // the function failed OR
                                            // we asked USN of pre-migration object
        ASSERT(SUCCEEDED(hr)) ;

        CSeqNum sn, snPrev ;
        GetSNForReplication (i64SeqNum, pMaster, pNeighborId, &sn);

        #define     PROPS_SIZE  23
        PROPID      propIDs[ PROPS_SIZE ];
        PROPVARIANT propVariants[ PROPS_SIZE ] ;
        DWORD       iProps = 0 ;

        propIDs[ iProps ] = PROPID_QM_SITE_ID ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].puuid = NULL ;
        DWORD dwSiteIdIndex = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_PATHNAME ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].pwszVal = NULL ;
        DWORD dwPathIndex = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_ADDRESS ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].blob.cbSize = 0 ;
        propVariants[ iProps ].blob.pBlobData = NULL ;
        DWORD dwAddressIndex = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_OUTFRS ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].cauuid.cElems = 0 ;
        propVariants[ iProps ].cauuid.pElems = NULL ;
        DWORD dwOutFRSIndex = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_INFRS ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].cauuid.cElems = 0 ;
        propVariants[ iProps ].cauuid.pElems = NULL ;
        DWORD dwInFRSIndex = iProps ;
	    iProps++;

        //
        // PROPID_QM_SERVICE is calculated property and function MQADSpRetrieveQMService
        // returns SERVICE_PSC, SERVICE_SRV or SERVICE_NONE.
        // to get from DS ServiceType as it was in NT4, we have to ask
        // PROPID_QM_OLDSERVICE. Later, to replicate this value
        // to NT4 we'll replace this property name to PROPID_QM_SERVICE.
        // It is fine, but what to do with NT5 MSMQ Servers? Setup has to define
        // this attribute for those servers. What does setup do now?
        //
        propIDs[ iProps ] = PROPID_QM_OLDSERVICE ;   // [adsrv] no change - treated by DS
	    propVariants[ iProps ].vt = VT_UI4 ;
        DWORD dwService = iProps;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_QUOTA ;
	    propVariants[ iProps ].vt = VT_UI4 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_JOURNAL_QUOTA ;
	    propVariants[ iProps ].vt = VT_UI4 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_MACHINE_TYPE;
        propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].pwszVal = NULL ;
        DWORD dwTypeIndex = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_CREATE_TIME ;
	    propVariants[ iProps ].vt = VT_UI4 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_MODIFY_TIME ;
	    propVariants[ iProps ].vt = VT_UI4 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_FOREIGN ;
	    propVariants[ iProps ].vt = VT_UI1 ;
        DWORD dwForeignIndex = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_OS ;
	    propVariants[ iProps ].vt = VT_UI4 ;
		DWORD dwOS = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_SIGN_PKS ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].blob.cbSize = 0 ;
        DWORD dwSignKeyIndex = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_ENCRYPT_PKS ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].blob.cbSize = 0 ;
        DWORD dwExchKeyIndex = iProps ;
	    iProps++;
        DWORD dwNextNT4Property = iProps;
        UNREFERENCED_PARAMETER(dwNextNT4Property);

        //
        // The next properties will not be sent to NT4 world.
        // We construct from them another NT4 properties:
        // PROPID_QM_SERVICE, PROPID_QM_OS, PROPID_QM_CNS
        // Please leave them immediately before DSCoreGetProps!
        //
        propIDs[ iProps ] = PROPID_QM_SITE_IDS;
        propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].cauuid.cElems = 0 ;
        propVariants[ iProps ].cauuid.pElems = NULL ;
        DWORD dwSiteIDsIndex = iProps ;
	    iProps++;

		// [adsrv] Asking for exact server functionality
		// NOTE: these 2 should be last in query
        propIDs[ iProps ] = PROPID_QM_SERVICE_ROUTING;
	    propVariants[ iProps ].vt = VT_NULL ;
        DWORD dwRoutService = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_QM_SERVICE_DSSERVER;
	    propVariants[ iProps ].vt = VT_NULL ;
        DWORD dwDsService = iProps ;
	    iProps++;

/*
PROPID_QM_CONNECTION
*/
        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);

        hr =  DSCoreGetProps( MQDS_MACHINE,
                              NULL,
                              &MachineGuid,
                              iProps,
                              propIDs,
                              &requestContext,
                              propVariants ) ;

        P<MQDSPUBLICKEYS> pPublicSignKeys = NULL ;
        P<MQDSPUBLICKEYS> pPublicExchKeys = NULL ;

        if (SUCCEEDED(hr) && propVariants[ dwSignKeyIndex ].blob.pBlobData)
        {
            //
            // Extract msmq1.0 public key from Windows 2000 ADS blob.
            //
            BYTE *pSignKey = NULL ;
            DWORD dwKeySize = 0 ;
            pPublicSignKeys = (MQDSPUBLICKEYS *)
                           propVariants[ dwSignKeyIndex ].blob.pBlobData ;

            HRESULT hr1 =  MQSec_UnpackPublicKey(
                                         pPublicSignKeys,
                                         x_MQ_Encryption_Provider_40,
                                         x_MQ_Encryption_Provider_Type_40,
                                        &pSignKey,
                                        &dwKeySize ) ;
            if (SUCCEEDED(hr1))
            {
                ASSERT(pSignKey && dwKeySize) ;
                propVariants[ dwSignKeyIndex ].blob.pBlobData = pSignKey ;
                propVariants[ dwSignKeyIndex ].blob.cbSize = dwKeySize ;
            }
            else
            {
                propVariants[ dwSignKeyIndex ].blob.pBlobData = NULL ;
                propVariants[ dwSignKeyIndex ].blob.cbSize = 0 ;
            }
        }
        propIDs[ dwSignKeyIndex ] = PROPID_QM_SIGN_PK ;

        if (SUCCEEDED(hr) && propVariants[ dwExchKeyIndex ].blob.pBlobData)
        {
            //
            // Extract msmq1.0 public key from Windows 2000 ADS blob.
            //
            BYTE *pExchKey = NULL ;
            DWORD dwKeySize = 0 ;
            pPublicExchKeys = (MQDSPUBLICKEYS *)
                           propVariants[ dwExchKeyIndex ].blob.pBlobData ;

            HRESULT hr1 =  MQSec_UnpackPublicKey(
                                         pPublicExchKeys,
                                         x_MQ_Encryption_Provider_40,
                                         x_MQ_Encryption_Provider_Type_40,
                                        &pExchKey,
                                        &dwKeySize ) ;
            if (SUCCEEDED(hr1))
            {
                ASSERT(pExchKey && dwKeySize) ;
                propVariants[ dwExchKeyIndex ].blob.pBlobData = pExchKey ;
                propVariants[ dwExchKeyIndex ].blob.cbSize = dwKeySize ;
            }
            else
            {
                propVariants[ dwExchKeyIndex ].blob.pBlobData = NULL ;
                propVariants[ dwExchKeyIndex ].blob.cbSize = 0 ;
            }
        }
        propIDs[ dwExchKeyIndex ] = PROPID_QM_ENCRYPT_PK ;

        if (SUCCEEDED(hr))
        {
			// [adsrv] Using and erasing exact server functionality props
			// We need to recognize one ugly case: NT5 EE non-routing DS server:

			iProps -= 2; // we don't want to pass these to NT4

			if (propVariants[dwDsService].bVal && !propVariants[dwRoutService].bVal)
			{
				// A hack!!! We write that it is NTS (maybe wrong)
				// The reason is that we want NT4 query for FRS to skip this

				// TBD BUGBUG To speak with Doron
			    propVariants[ dwOS ].ulVal = MSMQ_OS_NTS;
			}

			// [adsrv] end

            propIDs[ dwService ] = PROPID_QM_SERVICE ;
            //
            // if we install new NT4 FRS/BSC property PROPID_QM_OLDSERVICE
            // is not set in mixed mode. We have to calculate right value for Service.
            //
            // It is impossible to install new PSC NT4 in mixed mode. So, we can select
            // one of two values: either SERVICE_BSC, or SERVICE_SRV
            //
            // For all FRSs/ BSCs/ PSCs are installed before migration property 
            // PROPID_QM_OLDSERVICE is defined (it means > SERVICE_NONE) 
            //
            if ( propVariants[ dwService ].ulVal == SERVICE_NONE )    // service is not defined                                   
            {
                if (propVariants[dwDsService].bVal)                 // it is DS server
                {
                    propVariants[ dwService ].ulVal = SERVICE_BSC;
                }
                else if (propVariants[dwRoutService].bVal)          // it is routing server 
                {
                    propVariants[ dwService ].ulVal = SERVICE_SRV;
                }
            }

            P<GUID> pCNsGuid = NULL;
            ULONG ulCNsNum = 0;

            if (!propVariants[dwForeignIndex].bVal)
            {
                hr = PrepareCNsAndAddress (
					    &pCNsGuid,
					    &ulCNsNum,
					    &propVariants[ dwAddressIndex ].blob.cbSize,
					    &propVariants[ dwAddressIndex ].blob.pBlobData
					    );
            }
            else
            {
                //
                // this is a foreign computer
                //
                ulCNsNum = propVariants[dwSiteIDsIndex].cauuid.cElems;
                ASSERT(ulCNsNum);

                pCNsGuid = new GUID [ulCNsNum];
                memcpy (pCNsGuid,
                        propVariants[dwSiteIDsIndex].cauuid.pElems,					
					    sizeof(GUID) * ulCNsNum);
                delete propVariants[ dwSiteIDsIndex ].cauuid.pElems;

				//
				// replace site id to master id in order to see foreign
				// computer in PEC's site on NT4
				//				
				ASSERT(propVariants[ dwSiteIdIndex ].vt == VT_CLSID);
				propVariants[ dwSiteIdIndex ].vt = VT_CLSID ;				
				memcpy (propVariants[ dwSiteIdIndex ].puuid, pMasterId, sizeof(GUID)) ;				
            }
            iProps--;   // we don't want to pass this to NT4

            ASSERT(dwNextNT4Property == iProps);
            propIDs[ iProps ] = PROPID_QM_CNS ;
	        propVariants[ iProps ].vt = VT_CLSID|VT_VECTOR ;
            propVariants[ iProps ].cauuid.cElems = ulCNsNum ;
            propVariants[ iProps ].cauuid.pElems = pCNsGuid ;
	        iProps++;


            propIDs[ iProps ] = PROPID_QM_MASTERID ;
	        propVariants[ iProps ].vt = VT_CLSID ;
            propVariants[ iProps ].puuid = pMasterId ;
	        iProps++;

            ASSERT(pBuf) ;
            ASSERT(dwLen != 0) ;
            ASSERT(IsValidSecurityDescriptor(pBuf)) ;

            propIDs[ iProps ] = PROPID_QM_SECURITY ;
	        propVariants[ iProps ].vt = VT_BLOB ;
            propVariants[ iProps ].blob.cbSize = dwLen ;
            propVariants[ iProps ].blob.pBlobData = pBuf ;
	        iProps++;

            propIDs[ iProps ] = PROPID_QM_HASHKEY ;
	        propVariants[ iProps ].vt = VT_UI4 ;
	        propVariants[ iProps ].ulVal =
                            CalHashKey( propVariants[ dwPathIndex ].pwszVal ) ;
	        iProps++;

            ASSERT(iProps <= PROPS_SIZE) ;
            #undef  PROPS_SIZE

            NOT_YET_IMPLEMENTED(TEXT("PrepNeighbor, no OUT update, LSN"), s_fPrep) ;

            if (SUCCEEDED(hr))
            {
                ASSERT(pCNsGuid) ;

                hr = PrepareNeighborsUpdate(  DS_UPDATE_SYNC,
                                              MQDS_MACHINE,
                                              NULL, // pwName,
                                              &MachineGuid,
                                              iProps,
                                              propIDs,
                                              propVariants,
                                              pMasterId,
                                              sn,
                                              snPrev,
                                              ENTERPRISE_SCOPE,
                                              TRUE, //  fNeedFlush,
                                              pReplicationList ) ;
            }

#ifdef _DEBUG
            TCHAR  tszSn[ SEQ_NUM_BUF_LEN ] ;
            sn.GetValueForPrint(tszSn) ;

            LogReplicationEvent(ReplLog_Info, MQSync_I_REPLICATE_MACHINE,
                                 propVariants[ dwPathIndex ].pwszVal, tszSn) ;
#endif	
			//
			// free buffer of machine properties.
			//
			delete propVariants[ dwSiteIdIndex ].puuid ;
			delete propVariants[ dwPathIndex ].pwszVal ;
			delete propVariants[ dwTypeIndex ].pwszVal ;

			if (propVariants[ dwAddressIndex ].blob.cbSize)
			{
				delete propVariants[ dwAddressIndex ].blob.pBlobData;
			}

			if (propVariants[ dwOutFRSIndex ].cauuid.cElems)
			{
				delete propVariants[ dwOutFRSIndex ].cauuid.pElems;
			}
			if (propVariants[ dwInFRSIndex ].cauuid.cElems)
			{
				delete propVariants[ dwInFRSIndex ].cauuid.pElems;
			}
        }    //if SUCCEEDED(hr)

        int i = ldap_value_free(ppValue) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;
    }
    else
    {
        ASSERT(0) ;
    }

    return hr ;
}

//+-------------------------------------------------------
//
//  HRESULT _QueryForMachines()
//
//+-------------------------------------------------------

static HRESULT _QueryForMachines(
                    IN  TCHAR           tszFilterID[],
                    IN  TCHAR          *pszPrevUsn,
                    IN  TCHAR          *pszCurrentUsn,
                    IN  CDSMaster      *pMaster,
                    IN  CDSUpdateList  *pReplicationList,
                    IN  GUID           *pNeighborId,
                    OUT int            *piCount
                    )
{
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;
    //
    // we are looking in GC from the root, so we need empty default context
    //
    ASSERT(pGetNameContext(FALSE)) ;

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwDNSize = wcslen(pGetNameContext(FALSE)) ;
    P<TCHAR> pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    _tcscpy(pwszDN, pGetNameContext(FALSE));
    
    TCHAR  wszFilter[ 512 ] ;  

    _tcscpy(wszFilter, TEXT("(&(usnChanged>=")) ;
    _tcscat(wszFilter, pszPrevUsn) ;
    if (pszCurrentUsn)
    {
        _tcscat(wszFilter, TEXT(")(usnChanged<=")) ;
        _tcscat(wszFilter, pszCurrentUsn) ;
    }
    _tcscat(wszFilter, TEXT(")")) ;
    _tcscat(wszFilter, tszFilterID) ;

    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

    hr = HandleDeletedMachines(
                  pwszDN,
                  wszFilter,
                  pMaster,
                  pReplicationList,
                  pNeighborId,
                  piCount
                  ) ;

    ASSERT(SUCCEEDED(hr)) ;

    TCHAR *pszCategoryName = const_cast<LPTSTR> (x_ComputerConfigurationCategoryName);
        
    TCHAR wszFullName[256];    
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName, pszSchemaDefName);
       
    _tcscat(wszFilter, TEXT("(objectCategory=")) ;    
    _tcscat(wszFilter, wszFullName); 

    _tcscat(wszFilter, TEXT("))")) ;

    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;
	
	hr = QueryDS(
			pLdap,
			pwszDN,
			wszFilter,
			pMaster,
			pReplicationList,
			pNeighborId,
			MQDS_MACHINE,
			piCount,
			//special parameters for deleted object
			FALSE,
			NULL,
			//special parameters for user object
			FALSE,
			NULL
			);

	ASSERT(SUCCEEDED(hr)) ;

    return hr ;
}

//+-------------------------------------------------------
//
//  HRESULT ReplicateMachines()
//
// Machines which were created during migration, and machines which are
// created by replication from NT4, do have the msmqMasterId property.
// However, machines which were originally created on NT5 servers do not
// have this property.
// So when we (we == NT5 MSMQ2 servers) replicate machines from NT4 sites
// to our NT4 BSCs, we query them using the NT4 master id as filter.
// When we replicate our own queues to NT4 PSCs, we can't use master id
// in the filter. So in replication of our own queues we have two queries:
// 1. first query with our masterid in filter (to get machines which were
//    already exist before migration).
// 2. then query machines which do not have the masterid field.
//
//+-------------------------------------------------------

HRESULT ReplicateMachines (
             TCHAR          *pszPrevUsn,
             TCHAR          *pszCurrentUsn,
             CDSMaster      *pMaster,
             CDSUpdateList  *pReplicationList,
             GUID           *pNeighborId,
             int            *piCount,
             BOOL            fReplicateNoID
             )
{
    //
    // first query with my guid in filter.
    //
    TCHAR  wszFilter[ 512 ] ;
    P<TCHAR> pGuidString ;
    GUID *pMasterId = const_cast<GUID *> (pMaster->GetMasterId()) ;

    _tcscpy(wszFilter, TEXT("(")) ;
    _tcscat(wszFilter, MQ_QM_MASTERID_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=")) ;
    GuidToLdapFilter( pMasterId,
                      &pGuidString ) ;
    _tcscat(wszFilter, pGuidString) ;
    _tcscat(wszFilter, TEXT(")")) ;

    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

    HRESULT hr = _QueryForMachines(
                      wszFilter,
                      pszPrevUsn,
                      pszCurrentUsn,
                      pMaster,
                      pReplicationList,
                      pNeighborId,
                      piCount
                      ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    if (!fReplicateNoID)
    {
        return hr ;
    }

    //
    // Next query machines which do not have the msmqMasterId property.
    //

    _tcscpy(wszFilter, TEXT("(!(")) ;
    _tcscat(wszFilter, MQ_QM_MASTERID_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=*))")) ;

    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

    hr = _QueryForMachines(
             wszFilter,
              pszPrevUsn,
              pszCurrentUsn,
              pMaster,
              pReplicationList,
              pNeighborId,
              piCount
              ) ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpperf_s_.c ===
#pragma warning(push, 3)
#include <rpperf_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rploger.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rploger.cpp

Abstract:

    Log errors and other messages of the replication service.

Author:

    Doron Juster  (DoronJ)  14-Apr-1998

--*/

#include "mq1repl.h"

#include "rploger.tmh"

extern HINSTANCE  g_MyModuleHandle  ;

static TCHAR *s_pszPrefix[] = { TEXT("Error: "),
                                TEXT("Warning: "),
                                TEXT("Trace: "),
                                TEXT("Info: ") } ;

//+--------------------------------
//
//  void LogReplicationEvent()
//
//+--------------------------------

void LogReplicationEvent(ReplLogLevel eLevel, DWORD dwMsgId, ...)
{
	try
	{
		va_list Args;
		va_list *pArgs = &Args ;
		va_start(Args, dwMsgId);
			
		TCHAR tszBuf[ 1024 ] ;

		DWORD dwMessageSize = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
											 g_MyModuleHandle,
											 dwMsgId,
											 0,
											 tszBuf,
											 sizeof(tszBuf) / sizeof(TCHAR),
											 pArgs) ;
        DBG_USED(dwMessageSize);

		#ifdef _DEBUG
            TCHAR *tszDisplay = NULL ;
            P<TCHAR> tszMessage = NULL ;
			if (dwMessageSize == 0)
			{
				_stprintf(tszBuf,
				 TEXT("ERROR: Failed to format message (id- %lxh), err- %lut"),
														  dwMsgId, GetLastError()) ;
				tszDisplay = tszBuf ;
			}
			else
			{
				DWORD dwLen = _tcslen(tszBuf) ;
				tszBuf[ dwLen - 1 ] = TEXT('\0') ; // remove newline

				dwLen += _tcslen(s_pszPrefix[ eLevel - 1 ]) ;
				tszMessage = new TCHAR[ dwLen + 3 ] ;
				_tcscpy(tszMessage, s_pszPrefix[ eLevel - 1 ]) ;
				_tcscat(tszMessage, tszBuf) ;
				tszDisplay = tszMessage ;
			}
            //
            // ISSUE-2001/04/22-erezh  Removed, use RBT. This funciton will be removed completly.
            //
			//Report.DebugMsg(DBGMOD_REPLSERV, eLevel, TEXT("%s"), tszDisplay) ;
		#endif
	}
	catch(const bad_alloc&)
	{
		//
		//  Not enough resources; try later
		//
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpldutil.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpldutil.cpp

Abstract: LDAP related utility code.

Author:

    Doron Juster  (DoronJ)   05-Apr-98

--*/

#include "mq1repl.h"

#include "rpldutil.tmh"

//+-----------------------------------------------------------------
//
//  void  GuidToLdapFilter()
//
//  convert a guid to a string which can be used in LDAP filter.
//
//+-----------------------------------------------------------------

void  GuidToLdapFilter( GUID *pGuid,
                        TCHAR **ppBuf )
{
    *ppBuf = new TCHAR[ (sizeof(GUID) * 3) + 1 ] ;
    TCHAR *pBuf = *ppBuf ;
    BYTE *pByte = (BYTE*) pGuid ;

    for ( int j = 0 ; j < sizeof(GUID) ; j++ )
    {
        _stprintf(pBuf, TEXT("\\%02lx"), (DWORD) *pByte) ;
        pBuf += 3 ;
        pByte++ ;
    }
    *pBuf = TEXT('\0') ;
}

//+---------------------------------------------------------------
//
//  HRESULT GetGuidAndUsn()
//
//  Get the LDAP values of  objectGuid and usnChanged for this result.
//  As a side effect, compute the seqnumber value for replication.
//
//  result:  "pi64SeqNum" is the seqnumber to be used in the replication
//           message to NT4 MSMQ1.0 servers.
//
//+---------------------------------------------------------------

HRESULT  GetGuidAndUsn( IN  PLDAP       pLdap,
                        IN  LDAPMessage *pRes,
                        IN  __int64     i64Delta,
                        OUT GUID        *pGuid,
                        OUT __int64     *pi64SeqNum )
{
    if (pGuid)
    {
        berval **ppGuidVal = ldap_get_values_len( pLdap,
                                                  pRes,
                                                  TEXT("objectGuid") ) ;
        ASSERT(ppGuidVal) ;

        if (ppGuidVal)
        {
            memcpy(pGuid, (GUID*) ((*ppGuidVal)->bv_val), sizeof(GUID)) ;

            int i = ldap_value_free_len( ppGuidVal ) ;
            DBG_USED(i);
            ASSERT(i == LDAP_SUCCESS) ;
        }
    }

    if (pi64SeqNum)
    {
        berval **ppUsn = ldap_get_values_len( pLdap,
                                              pRes,
                                              TEXT("usnChanged") ) ;
        ASSERT(ppUsn) ;

        if (ppUsn)
        {
            //
            // Result are always ANSI.
            //
#ifdef _DEBUG
            ULONG ulLen = (*ppUsn)->bv_len ;
            ASSERT(ulLen < SEQ_NUM_BUF_LEN) ;
#endif

            char szSeqNum[ SEQ_NUM_BUF_LEN ] ;
            strcpy(szSeqNum, ((*ppUsn)->bv_val)) ;

            __int64 i64Seq = 0 ;
            sscanf(szSeqNum, "%I64d", &i64Seq) ;
            ASSERT(i64Seq > 0) ;

            if (i64Seq > g_i64LastMigHighestUsn)
            {
                i64Seq += i64Delta ;
                *pi64SeqNum = i64Seq ;
            }

            int i = ldap_value_free_len( ppUsn ) ;
            DBG_USED(i);
            ASSERT(i == LDAP_SUCCESS) ;
        }
    }

    return MQSync_OK ;
}

//+---------------------------------------------------------------
//
//   HRESULT  ReadDSHighestUSN()
//
//  Read HighestCommittedUSN from local DS.
//  The Replication service will handle now all new objects with
//  usnChanged between previous highestCommitted and new value
//  which is read here.
//
//+-----------------------------------------------------------------

HRESULT  ReadDSHighestUSN( LPTSTR pszHighestCommitted)
{
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;

    LM<LDAPMessage> pRes = NULL ;
    hr = QueryRootDSE(&pRes, pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pRes) ;

    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    WCHAR **ppValue = ldap_get_values( pLdap,
                                       pEntry,
                                       TEXT("highestCommittedUSN" )) ;
    if (ppValue && *ppValue)
    {
        _tcscpy(pszHighestCommitted, *ppValue) ;
        ldap_value_free(ppValue) ;
    }
    else
    {
        return MQSync_E_CANT_LDAP_HIGHESTUSN ;
    }

    return MQSync_OK ;
}

//+---------------------------------------
//
//  HRESULT  ServerNameFromSetting()
//
//  Given a LDAPMessage pRes which represent a MSMQSetting object,
//  retrieve the server name from object distinguished name.
//
//+---------------------------------------

HRESULT  ServerNameFromSetting( IN  PLDAP       pLdap,
                                IN  LDAPMessage *pRes,
                                OUT TCHAR       **ppszServerName )
{
    HRESULT hr = MQSync_OK ;

    //
    // Get distinguished name, to retrieve the server name.
    //
    TCHAR **ppValue = ldap_get_values( pLdap,
                                       pRes,
                                       DSATTR_DN_NAME ) ;
    if (ppValue && *ppValue)
    {
        //
        // Retrieve server name from the DN.
        //
        TCHAR *pwS = *ppValue + SERVER_DN_PREFIX_LEN - 1 ;
        TCHAR *pTmp = pwS ;
        while (*pTmp != TEXT(','))
        {
            pTmp++ ;
        }
        TCHAR wTmp = *pTmp ;
        *pTmp = TEXT('\0') ;

        *ppszServerName = new TCHAR[ 1 + wcslen(pwS) ] ;

        _tcscpy(*ppszServerName, pwS) ;
        *pTmp = wTmp ;

	    DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO, TEXT(
                        "ServerNameFromString, DN- %ls"), *ppValue)) ;

        int i = ldap_value_free(ppValue) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;
    }
    else
    {
	    DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
                                "ERROR: ServerNameFromString failed"))) ;

        hr = MQSync_E_CANT_GET_DN ;
    }

    return hr ;
}

//+------------------------------
//
//  HRESULT ModifyAttribute()
//
//+------------------------------

HRESULT ModifyAttribute(
             WCHAR       wszPath[],
             WCHAR       pAttr[],
             PLDAP_BERVAL *ppBVals
             )
{
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap, TRUE) ; //we'll modify attribute => init with fSetData = TRUE
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;
    ASSERT(pGetNameContext()) ;

    DWORD           dwIndex = 0 ;
    PLDAPMod        rgMods[2];
    LDAPMod         ModAttr ;

    rgMods[ dwIndex ] = &ModAttr;
    dwIndex++ ;
    rgMods[ dwIndex ] = NULL;

    if (ppBVals)
    {
        ModAttr.mod_op      = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    }
    else
    {
        ModAttr.mod_op      = LDAP_MOD_DELETE | LDAP_MOD_BVALUES;
    }

    ModAttr.mod_type    = pAttr ;

    ModAttr.mod_values  = (PWSTR *)ppBVals;

    //
    // Now, we'll do the write...
    //
    ULONG ulRes = ldap_modify_s( pLdap,
                                 wszPath,
                                 rgMods ) ;

    if (ulRes != LDAP_SUCCESS)
    {
        LogReplicationEvent( ReplLog_Error, MQSync_E_MODIFY_MIG_ATTRIBUTE, wszPath, ulRes) ;
        return MQSync_E_MODIFY_MIG_ATTRIBUTE;
    }
    else
    {
        LogReplicationEvent( ReplLog_Info, MQSync_I_MODIFY_MIG_ATTRIBUTE, wszPath, ulRes) ;
    }

    return MQSync_OK ;
}

//+------------------------------
//
//  HRESULT QueryDS()
//
//+------------------------------
HRESULT QueryDS(
			IN	PLDAP			pLdap,
			IN	TCHAR			*pszDN,
			IN  TCHAR			*pszFilter,
			IN  CDSMaster		*pMaster,
            IN  CDSUpdateList	*pReplicationList,
            IN  GUID			*pNeighborId,
			IN	DWORD			dwObjectType,
            OUT int				*piCount ,
			//special parameters for deleted object
			IN	BOOL			fDeletedObject,
			IN	PLDAPControl	*ppServerControls,
			//special parameters for user object
			IN	BOOL            fMSMQUserContainer,
            IN	TCHAR			*pszPrevUsn 			
			
			)
{
	if (fDeletedObject)
	{
		ASSERT (ppServerControls != NULL);
	}
	else
	{
		ASSERT (ppServerControls == NULL);
	}
			
	CLdapPageHandle hPage(pLdap);
	hPage = ldap_search_init_page(
                    pLdap,
					pszDN,                   //pwszDN
					LDAP_SCOPE_SUBTREE,     //scope
					pszFilter,              //search filter
					NULL,                   //attribute list
					0,                      //attributes only
					ppServerControls,   	//ServerControls
					NULL,                   //PLDAPControlW   *ClientControls,
                    0,						//PageTimeLimit,
                    0,                      //TotalSizeLimit
					NULL                    //PLDAPSortKey SortKeys
                    );

	ULONG ulRes;
	HRESULT hr = MQSync_OK;
    if (hPage == NULL)
    {
        ulRes = LdapGetLastError();
		hr = MQSync_E_LDAP_SEARCH_INITPAGE_FAILED;
		LogReplicationEvent(ReplLog_Error, hr, pszDN, pszFilter, ulRes) ;
        return hr;
    }
	
	ULONG ulTotalCount;     	
	LM<LDAPMessage> pRes = NULL ;

    ulRes = ldap_get_next_page_s(
                        pLdap,
                        hPage,
                        NULL,						//timeout,
                        g_dwObjectPerLdapPage,      //ULONG ulPageSize
                        &ulTotalCount,
                        &pRes);

    LogReplicationEvent(ReplLog_Info,
						MQSync_I_NEXTPAGE,
						ulRes, pszDN, pszFilter) ;

	ULONG ulPageCount = 0;
	
	DWORD dwDeletedObjectType = dwObjectType;
	if (fDeletedObject)
	{
		dwObjectType = MQDS_DELETEDOBJECT;
	}

    while (ulRes == LDAP_SUCCESS)
	{
		ASSERT(pRes);

		ulPageCount++;
        LogReplicationEvent (ReplLog_Info, MQSync_I_PAGE_NUMBER, ulPageCount);

        //
        // pass through results on the current page
        //
        int iCount = ldap_count_entries(pLdap, pRes) ;
        LogReplicationEvent(ReplLog_Info, MQSync_I_LDAP_SEARCH,
                                             iCount, pszDN, pszFilter) ;
		*piCount += iCount ;      	
		
		BOOL fFailed = FALSE ;
		LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;		

		while(pEntry)
		{												
			switch(dwObjectType)
			{
			case MQDS_QUEUE:
				hr = HandleAQueue(
							pLdap,
							pEntry,
							pMaster,
							pReplicationList,
							pNeighborId
							) ;
				break;

			case MQDS_MACHINE:
				hr = HandleAMachine(
							pLdap,
							pEntry,
							pMaster,
							pReplicationList,
							pNeighborId
							);
				break;

			case MQDS_DELETEDOBJECT:
				hr = HandleADeletedObject(
							dwDeletedObjectType,
							pLdap,
							pEntry,
							pMaster,
							pReplicationList,
							pNeighborId
							);
				break;
			
			case MQDS_USER:
				hr = HandleAUser(
							fMSMQUserContainer,
							pszPrevUsn,
							pLdap,
							pEntry,
							pReplicationList,
							pNeighborId,
							piCount
							);
				break;

			default:
				ASSERT(0);
				break;
			}
			
			if (FAILED(hr))
			{
				fFailed = TRUE ;
			}

			LDAPMessage *pPrevEntry = pEntry ;
			pEntry = ldap_next_entry(pLdap, pPrevEntry) ;
		}

        ldap_msgfree(pRes) ;
        pRes = NULL ;

		ulRes = ldap_get_next_page_s(
							pLdap,
							hPage,
							NULL,
							g_dwObjectPerLdapPage,      //ULONG ulPageSize
							&ulTotalCount,
							&pRes
							);
        LogReplicationEvent(ReplLog_Info,
						MQSync_I_NEXTPAGE,
						ulRes, pszDN, pszFilter) ;
	}

	if (ulRes != LDAP_NO_RESULTS_RETURNED)
	{
		hr = MQSync_E_LDAP_GET_NEXTPAGE_FAILED;
		LogReplicationEvent(ReplLog_Error,
						hr, pszDN, pszFilter, ulRes) ; 		
	}	

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpldap.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpldap.cpp

Abstract: LDAP related code.

Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

#include "mq1repl.h"
#include <activeds.h>
#include "..\..\src\ds\h\mqattrib.h"
#include "mqads.h"

#include "rpldap.tmh"

static TCHAR *s_pwszDefNameContext = NULL ;
static TCHAR s_pwszDefNameContextEmpty[] = TEXT("") ;

static P<TCHAR> s_tszSchemaNamingContext = NULL ;

//+----------------------------------------------
//
//   HRESULT  GetSchemaNamingContext()
//
//+----------------------------------------------
HRESULT  GetSchemaNamingContext ( TCHAR **ppszSchemaDefName )
{    
    static BOOL s_fAlreadyInit = FALSE ;    

    if (s_fAlreadyInit)
    {        
        *ppszSchemaDefName = s_tszSchemaNamingContext ;

        return MQSync_OK ;
    }
    
    //
    // look for schema naming context with LDAP port
    //
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap, TRUE) ; 
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;

    LM<LDAPMessage> pRes = NULL ;
    hr = QueryRootDSE(&pRes, pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pRes);

    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    WCHAR **ppValue = ldap_get_values( pLdap,
                                       pEntry,
                                       TEXT("schemaNamingContext")) ;
    if (ppValue && *ppValue)
    {
        ASSERT(s_tszSchemaNamingContext == NULL) ;
        s_tszSchemaNamingContext = new TCHAR[ 1 + _tcslen(*ppValue) ] ;
        _tcscpy(s_tszSchemaNamingContext, *ppValue) ;
        ldap_value_free(ppValue) ;

        LogReplicationEvent(ReplLog_Info, MQSync_I_SCHEMA_CONTEXT,
                                                     s_tszSchemaNamingContext) ;
    }
    else
    {
        return MQSync_E_CANT_READ_SCHEMA_CONTEXT ;
    }    

    *ppszSchemaDefName = s_tszSchemaNamingContext ;
    s_fAlreadyInit = TRUE;

    return MQSync_OK ;
}

//+--------------------------------------
//
//  TCHAR *pGetNameContext()
//
//+--------------------------------------

TCHAR *pGetNameContext(BOOL fRealDefaultContext)
{
    if (fRealDefaultContext)
    {
        return s_pwszDefNameContext ;
    }
    else
    {
        return s_pwszDefNameContextEmpty ;
    }
}

//+----------------------------------------------
//
//   HRESULT  QueryRootDSE()
//
//+----------------------------------------------

HRESULT  QueryRootDSE(LDAPMessage **ppRes, PLDAP pLdap)
{
    HRESULT hr = MQSync_OK ;

    ULONG ulRes = ldap_search_s( pLdap,
                                 NULL,
                                 LDAP_SCOPE_BASE,
                                 L"(objectClass=*)",
                                 NULL,
                                 0,
                                 ppRes ) ;
    if (ulRes != LDAP_SUCCESS)
    {
        hr = MQSync_E_CANT_QUERY_ROOTDSE ;
        LogReplicationEvent( ReplLog_Error,
                             hr,
                             ulRes ) ;
        return hr ;
    }

    int iCount = ldap_count_entries(pLdap, *ppRes) ;
    if (iCount != 1)
    {
        hr = MQSync_E_TOOMANY_ROOTDSE ;
        LogReplicationEvent( ReplLog_Error,
                             hr,
                             iCount ) ;
        return hr ;
    }

    return hr ;
}

//+----------------------------------------------
//
//   HRESULT  _GetDefaultNamingContext()
//
//+----------------------------------------------

static HRESULT  _GetDefaultNamingContext(PLDAP pLdap)
{
    LM<LDAPMessage> pRes = NULL ;
    HRESULT hr = QueryRootDSE(&pRes, pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pRes);

    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    WCHAR **ppValue = ldap_get_values( pLdap,
                                       pEntry,
                                       TEXT("defaultNamingContext")) ;
    if (ppValue && *ppValue)
    {
        s_pwszDefNameContext = new
                             WCHAR[ 1 + wcslen((LPWSTR) *ppValue) ] ;
        wcscpy(s_pwszDefNameContext, *ppValue) ;
        ldap_value_free(ppValue) ;
    }
    else
    {
        return MQSync_E_CANT_READ_CONTEXT ;
    }

    return MQSync_OK ;
}

//+----------------------------------------------
//
//   HRESULT  InitLDAP()
//
//+----------------------------------------------

HRESULT  InitLDAP(PLDAP *ppLdap, BOOL fSetData)
{
    static PLDAP s_pLdapGet = NULL;
    static BOOL s_fAlreadyInitGet = FALSE;

    static PLDAP s_pLdapSet = NULL;
    static BOOL s_fAlreadyInitSet = FALSE;

    if (fSetData && s_fAlreadyInitSet)
    {
        ASSERT(s_pLdapSet) ;
        ASSERT(s_pwszDefNameContext);

        *ppLdap = s_pLdapSet;
        return MQSync_OK;
    }

    if (!fSetData && s_fAlreadyInitGet)
    {
        ASSERT(s_pLdapGet);
        ASSERT(s_pwszDefNameContext);

        *ppLdap = s_pLdapGet;
        return MQSync_OK;
    }

    WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH + 2];
    DWORD dwSize = sizeof(wszComputerName) / sizeof(wszComputerName[0]);
    GetComputerName( 
		wszComputerName,
		&dwSize 
		);

    PLDAP pLdap = NULL;
    if (fSetData)
    {
        pLdap = ldap_init(wszComputerName, LDAP_PORT);
    }
    else
    {
        pLdap = ldap_init(wszComputerName, LDAP_GC_PORT);
    }

    if (!pLdap)
    {
        return MQSync_E_CANT_INIT_LDAP;
    }

    int iLdapVersion;
    int iret = ldap_get_option( 
					pLdap,
					LDAP_OPT_PROTOCOL_VERSION,
					(void*) &iLdapVersion 
					);
    if (iLdapVersion != LDAP_VERSION3)
    {
        iLdapVersion = LDAP_VERSION3;
        iret = ldap_set_option( 
					pLdap,
					LDAP_OPT_PROTOCOL_VERSION,
					(void*) &iLdapVersion 
					);
    }

    iret = ldap_set_option( 
				pLdap,
				LDAP_OPT_AREC_EXCLUSIVE,
				LDAP_OPT_ON  
				);

    ULONG ulRes = ldap_bind_s(pLdap, L"", NULL, LDAP_AUTH_NEGOTIATE);

    if (ulRes != LDAP_SUCCESS)
    {
        HRESULT hr =  MQSync_E_CANT_BIND_LDAP;
        LogReplicationEvent(ReplLog_Error, hr, ulRes);
        return hr;
    }

    HRESULT hr =  _GetDefaultNamingContext(pLdap);
    if (FAILED(hr))
    {
        return hr;
    }

    LogReplicationEvent( 
			ReplLog_Trace,
			MQSync_I_LDAP_INIT,
			wszComputerName,
			s_pwszDefNameContext,
			pLdap->ld_version 
			);

    *ppLdap = pLdap;

    if (fSetData)
    {
        s_pLdapSet = pLdap;
        s_fAlreadyInitSet = TRUE;
    }
    else
    {
        s_pLdapGet = pLdap;
        s_fAlreadyInitGet = TRUE;
    }

    return MQSync_OK;
}

//+-----------------------------------------------------------------
//
//  HRESULT QueryMSMQServerOnLDAP()
//
//  Query MSMQ servers under CN=Sites,CN=Configuration.
//  We look for the masterID attribute which exist in object class
//  "msmq setting". This object must exist for each MSMQ servr.
//  "pMasterGuid" is used when looking for BSCs of local DS server.
//  tszPrevUsn, tszCurrentUsn is used when we are looking for a new
//  migrated sites periodically
//
//+-----------------------------------------------------------------

HRESULT QueryMSMQServerOnLDAP( DWORD       dwService,
                               UINT        uiNt4Attribute,
                               LDAPMessage **ppRes,
                               int         *piCount,
                               GUID        *pMasterGuid = NULL,
                               TCHAR       *tszPrevUsn = NULL,
                               TCHAR       *tszCurrentUsn = NULL )
{
    //
    // Although here we only query, not setting any data, we bind to
    // LDAP and not to GC. That's because the msmqSetting attributes are not
    // "replicated" to GC. The configuration container exist on all DC
    // machines, so these attributes are not marked as "replicated to GC".
    //
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap, TRUE /* LDAP, not GC */) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwDNSize = wcslen(SITES_ROOT) + wcslen(s_pwszDefNameContext) ;
    P<WCHAR> pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    wcscpy(pwszDN, SITES_ROOT) ;
    wcscat(pwszDN, s_pwszDefNameContext) ;
    
    TCHAR  tszService[ 8 ] ;
    _itot((int) dwService, tszService, 10) ;

    TCHAR tszNt4Attribute[ 8 ];
    _itot(uiNt4Attribute, tszNt4Attribute, 10) ;

    TCHAR *pszCategoryName = const_cast<LPTSTR> (x_SettingsCategoryName);
    
    TCHAR wszFullName[256];    
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName, pszSchemaDefName);

     TCHAR  wszFilter[ 512 ] ;    
    _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;    
    _tcscat(wszFilter, wszFullName);   
       
    _tcscat(wszFilter, TEXT(")(")) ;
    _tcscat(wszFilter, MQ_SET_NT4_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=")) ;
    _tcscat(wszFilter, tszNt4Attribute) ;
    _tcscat(wszFilter, TEXT(")(")) ;

    if (pMasterGuid)
    {
        P<TCHAR> pGuidString ;
        GuidToLdapFilter( pMasterGuid,
                          &pGuidString ) ;
        _tcscat(wszFilter, MQ_SET_MASTERID_ATTRIBUTE) ;
        _tcscat(wszFilter, TEXT("=")) ;
        _tcscat(wszFilter, pGuidString) ;
        _tcscat(wszFilter, TEXT(")(")) ;
    }
    else
    {
        _tcscat(wszFilter, MQ_SET_MASTERID_ATTRIBUTE) ;
        _tcscat(wszFilter, TEXT("=*)(")) ;
    }
    _tcscat(wszFilter, MQ_SET_SERVICE_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=")) ;
    _tcscat(wszFilter, tszService) ;

    if (tszPrevUsn)
    {
        _tcscat(wszFilter, TEXT(")(usnChanged>=")) ;
        _tcscat(wszFilter, tszPrevUsn) ;
    }

    if (tszCurrentUsn)
    {
        _tcscat(wszFilter, TEXT(")(usnChanged<=")) ;
        _tcscat(wszFilter, tszCurrentUsn) ;
    }
    _tcscat(wszFilter, TEXT("))")) ;

    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

    ULONG ulRes = ldap_search_s( pLdap,
                                 pwszDN,
                                 LDAP_SCOPE_SUBTREE,
                                 wszFilter,
                                 NULL, //ppAttributes,
                                 0,
                                 ppRes ) ;
    if (ulRes != LDAP_SUCCESS)
    {
        DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
         "ERROR: QueryServers, ldap_search_s(%ls, filter- %ls) return %lxh"),
                                              pwszDN, wszFilter, ulRes)) ;
        return MQSync_E_LDAP_SEARCH_FAILED ;
    }

    int iCount = ldap_count_entries(pLdap, *ppRes) ;

    DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO, TEXT(
    "QueryServers: ldap_search_s(%ls, filter- %ls) succeed with %lut results"),
                                                pwszDN, wszFilter, iCount)) ;

    if (iCount == 0)
    {
        //
        // No results. That's OK.
        //
        return MQSync_I_NO_SERVERS_RESULTS ;
    }

    *piCount = iCount ;
    return MQSync_OK ;
}

//+-----------------------------
//
//  HRESULT QueryNT5SiteOnLDAP()
//
//+-----------------------------

HRESULT QueryNT5SiteOnLDAP(  OUT LDAPMessage **ppRes,
                             OUT int         *piCount) 
{
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap, TRUE /* LDAP, not GC */) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }           

    DWORD dwDNSize = wcslen(SITES_ROOT) + wcslen(s_pwszDefNameContext) ;
    P<WCHAR> pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    wcscpy(pwszDN, SITES_ROOT) ;
    wcscat(pwszDN, s_pwszDefNameContext) ;

    TCHAR *pszCategoryName = const_cast<LPTSTR> (x_SiteCategoryName);
    
    TCHAR wszFullName[256];    
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName, pszSchemaDefName);
          
    TCHAR  wszFilter[ 512 ] ;    
    _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;    
    _tcscat(wszFilter, wszFullName);   
   
    _tcscat(wszFilter, TEXT(")(!(")) ;
    _tcscat(wszFilter, MQ_S_FOREIGN_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=TRUE)")) ; // NOT foreign site    

    _tcscat(wszFilter, TEXT(")(!(")) ;
    _tcscat(wszFilter, MQ_S_NT4_STUB_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=1)")) ; // NOT NT4 site
    _tcscat(wszFilter, TEXT("))")) ;

    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

    ULONG ulRes = ldap_search_s( pLdap,
                                 pwszDN,
                                 LDAP_SCOPE_SUBTREE,
                                 wszFilter,
                                 NULL, //ppAttributes,
                                 0,
                                 ppRes ) ;
    if (ulRes != LDAP_SUCCESS)
    {
        DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
         "ERROR: QueryNT5Sites, ldap_search_s(%ls, filter- %ls) return %lxh"),
                                              pwszDN, wszFilter, ulRes)) ;
        return MQSync_E_LDAP_SEARCH_FAILED ;
    }

    int iCount = ldap_count_entries(pLdap, *ppRes) ;

    DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO, TEXT(
    "QueryNT5Sites: ldap_search_s(%ls, filter- %ls) succeed with %lut results"),
                                                pwszDN, wszFilter, iCount)) ;
    
    *piCount = iCount ;
    return MQSync_OK ;
}

//+-----------------------------
//
//  HRESULT _InitaPSConLDAP()
//
//+-----------------------------

static HRESULT _InitaPSConLDAP( PLDAP       pLdap,
                                LDAPMessage *pRes,
                                BOOL        fNT4Site)
{
    P<TCHAR> pwServer ;
    HRESULT hr =  ServerNameFromSetting( pLdap,
                                         pRes,
                                         &pwServer ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    //
    // Get site GUID (our MSMQ ownerID).
    //
    berval **ppGuidVal = ldap_get_values_len( pLdap,
                                              pRes,
                       const_cast<LPWSTR> (MQ_SET_MASTERID_ATTRIBUTE) ) ;
    ASSERT(ppGuidVal) ;

    if (ppGuidVal)
    {
        GUID *pSiteGuid = (GUID*) ((*ppGuidVal)->bv_val) ;
        if ( *pSiteGuid != g_MySiteMasterId )
        {
            //
            // Init any site except mine.
            // my site was already init, _InitMyPSC().
            //
            hr = InitPSC( &pwServer,
                          pSiteGuid,
                          NULL,      //pcauuidSiteGates
                          fNT4Site );

#ifdef _DEBUG
            TCHAR *pwszGuid = NULL ;
            RPC_STATUS status = UuidToString( pSiteGuid,
                                              &pwszGuid ) ;
            ASSERT(status == RPC_S_OK) ;

	        DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO, TEXT(
               "InitPSC(%ls), return %lxh"), pwszGuid, hr)) ;

            status = RpcStringFree( &pwszGuid ) ;
            ASSERT(status == RPC_S_OK) ;
#endif
        }
        else
        {
            //
            // Error. We retrieve only NT4 server, so we can't get back
            // our own guid. Assert and ignore.
            // No, now we retrieve both NT4 and NT5 servers. If it is my site,
            // do nothing
            //
            //ASSERT(0) ;
            hr = MQSync_OK ;
        }

        int i = ldap_value_free_len( ppGuidVal ) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;
    }

    return hr ;
}

//+-----------------------------
//
//  HRESULT _InitaBSConLDAP()
//
//+-----------------------------

static HRESULT _InitaBSConLDAP( PLDAP       pLdap,
                                LDAPMessage *pRes )
{
    P<TCHAR> pwServer ;
    HRESULT hr =  ServerNameFromSetting( pLdap,
                                         pRes,
                                         &pwServer ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    //
    // Get machine GUID (GUID of BSC machine).
    //
    berval **ppGuidVal = ldap_get_values_len( pLdap,
                                              pRes,
                           const_cast<LPWSTR> (MQ_SET_QM_ID_ATTRIBUTE) ) ;
    ASSERT(ppGuidVal) ;

    if (ppGuidVal)
    {
        GUID *pBSCGuid = (GUID*) ((*ppGuidVal)->bv_val) ;

        //
        // Init any site except mine.
        // my site was already init, _InitMyPSC().
        //
        hr = InitBSC( pwServer,
                      pBSCGuid ) ;

#ifdef _DEBUG
        TCHAR *pwszGuid = NULL ;
        RPC_STATUS status = UuidToString( pBSCGuid,
                                          &pwszGuid ) ;
        ASSERT(status == RPC_S_OK) ;

	    DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO, TEXT(
             "InitBSC(%ls, %ls), return %lxh"), pwServer, pwszGuid, hr)) ;

        status = RpcStringFree( &pwszGuid ) ;
        ASSERT(status == RPC_S_OK) ;
#endif

        int i = ldap_value_free_len( ppGuidVal ) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;
    }

    return hr ;
}

//+------------------------------------------------------------------
//
//  HRESULT InitOtherPSCs()
//
//  Look for all "MSMQ Setting" objects, with "msmqNT4Flags == fNT4Site".
//
//+------------------------------------------------------------------

HRESULT InitOtherPSCs( BOOL fNT4Site)
{
    int iCount = 0 ;
    LM<LDAPMessage> pRes = NULL ;
    HRESULT hr = QueryMSMQServerOnLDAP(  SERVICE_PSC,
                                         fNT4Site,         // msmqNT4Flags
                                        &pRes,
                                        &iCount ) ;
    if (hr != MQSync_OK)
    {
        return hr ;
    }
    ASSERT(pRes && iCount > 0) ;

    PLDAP pLdap = NULL ;
    hr =  InitLDAP(&pLdap) ;
    ASSERT(pLdap && SUCCEEDED(hr)) ;

    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    while(pEntry)
    {
        hr = _InitaPSConLDAP( pLdap,
                              pEntry,
                              fNT4Site ) ; //NT4Site

        LDAPMessage *pPrevEntry = pEntry ;
        pEntry = ldap_next_entry(pLdap, pPrevEntry) ;
    }

    return hr ;
}

//+------------------------------------------------------------------
//
//  HRESULT InitMyNt4BSCs()
//
//  Find all NT4 BSCs which are registered in NT5 DS and belong to the
//  PEC.  Look for all "MSMQ Setting" objects, with "msmqNT4Flags == 1".
//
//+------------------------------------------------------------------

HRESULT InitMyNt4BSCs(GUID *pMasterGuid)
{
    int iCount = 0 ;
    LM<LDAPMessage> pRes = NULL ;
    HRESULT hr = QueryMSMQServerOnLDAP(  SERVICE_BSC,
                                         1,            // msmqNT4Flags = 1
                                        &pRes,
                                        &iCount,
                                         pMasterGuid ) ;
    if (hr != MQSync_OK)
    {
        return hr ;
    }
    ASSERT(pRes && iCount > 0) ;

    PLDAP pLdap = NULL ;
    hr =  InitLDAP(&pLdap) ;
    ASSERT(pLdap && SUCCEEDED(hr)) ;

    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    while(pEntry)
    {
        hr = _InitaBSConLDAP( pLdap,
                              pEntry ) ;

        LDAPMessage *pPrevEntry = pEntry ;
        pEntry = ldap_next_entry(pLdap, pPrevEntry) ;
    }

    return hr ;
}

//+-----------------------------------------
//
//  HRESULT  InitNT5Sites()
//  Find all Native non-foreign NT5 sites
//
//+-----------------------------------------

HRESULT InitNT5Sites ()
{
    int iCount = 0 ;
    LM<LDAPMessage> pRes = NULL ;
    HRESULT hr = QueryNT5SiteOnLDAP(  &pRes,
                                      &iCount ) ;
    if (hr != MQSync_OK)
    {
        return hr ;
    }
    ASSERT(pRes && iCount > 0) ;

    PLDAP pLdap = NULL ;
    hr =  InitLDAP(&pLdap) ;
    ASSERT(pLdap && SUCCEEDED(hr)) ;

    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    while(pEntry)
    {
        WCHAR **ppValue = ldap_get_values( pLdap,
                                           pEntry,
                                           TEXT("cn") ) ;    

        WCHAR *pwName = NULL;

        if (ppValue && *ppValue)
        {
            //
            // Retrieve site name
            //
            pwName = new TCHAR[ 1 + _tcslen(*ppValue) ] ;
            _tcscpy(pwName, *ppValue) ;
            
            int i = ldap_value_free(ppValue) ;
            DBG_USED(i);
            ASSERT(i == LDAP_SUCCESS) ;
        }

        berval **ppGuidVal = ldap_get_values_len( pLdap,
                                                  pEntry,
                                                  TEXT("objectGuid") ) ;
        ASSERT(ppGuidVal) ;

        GUID guidSite = GUID_NULL;
        if (ppGuidVal)
        {
            //
            // Retrieve site guid
            //
            memcpy(&guidSite, (GUID*) ((*ppGuidVal)->bv_val), sizeof(GUID)) ;

            int i = ldap_value_free_len( ppGuidVal ) ;
            DBG_USED(i);
            ASSERT(i == LDAP_SUCCESS) ;
        }
        
        if (guidSite != GUID_NULL && pwName)
        {
            //
            // add this site to the map
            //
            g_pNativeNT5SiteMgr->AddNT5NativeSite (&guidSite, pwName);                      
        }
                
        delete pwName; 

        LDAPMessage *pPrevEntry = pEntry ;
        pEntry = ldap_next_entry(pLdap, pPrevEntry) ;
    }

    return hr ;
}

//+-----------------------------------------
//
//  HRESULT  CreateMsmqContainer()
//
//+-----------------------------------------

HRESULT  CreateMsmqContainer(TCHAR wszContainerName[])
{
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;
    ASSERT(pGetNameContext()) ;

    #define PATH_LEN  1024
    WCHAR  wszPath[ PATH_LEN ] ;

    _tcscpy(wszPath, OU_PREFIX) ;
    _tcscat(wszPath, wszContainerName) ;
    _tcscat(wszPath, LDAP_COMMA) ;
    _tcscat(wszPath, pGetNameContext()) ;

    ASSERT(wcslen(wszPath) < PATH_LEN) ;
    #undef PATH_LEN

    //
    // first check if container already exist.
    //
    TCHAR  wszFilter[ 512 ] ;

    _tcscpy(wszFilter, TEXT("(&(objectClass=")) ;
    _tcscat(wszFilter, CONTAINER_OBJECT_CLASS) ;

    LM<LDAPMessage> pRes = NULL ;

    ULONG ulResExist = ldap_search_s( pLdap,
                                      wszPath,
                                      LDAP_SCOPE_BASE,
                                      wszFilter,
                                      NULL, //ppAttributes,
                                      0,
                                      &pRes ) ;
    if (ulResExist == LDAP_SUCCESS)
    {
        int iCount = ldap_count_entries(pLdap, pRes) ;
        if (iCount == 1)
        {
            //
            // OK, container already exist.
            // Note that if object does not exist than LDAP may return
            // LDAP_SUCCESS on the search, but with 0 results.
            //
            return MQSync_OK ;
        }
    }

    #define         cAlloc  3
    PLDAPMod        rgMods[ cAlloc ];
    WCHAR           *ppwszObjectClassVals[2];
    WCHAR           *ppwszOuVals[2];
    LDAPMod         ModObjectClass;
    LDAPMod         ModOu;

    DWORD  dwIndex = 0 ;
    rgMods[ dwIndex ] = &ModOu;
    dwIndex++ ;
    rgMods[ dwIndex ] = &ModObjectClass;
    dwIndex++ ;
    rgMods[ dwIndex ] = NULL ;
    dwIndex++ ;
    ASSERT(dwIndex == cAlloc) ;
    #undef  cAlloc

    //
    // objectClass
    //
    ppwszObjectClassVals[0] = CONTAINER_OBJECT_CLASS;
    ppwszObjectClassVals[1] = NULL ;

    ModObjectClass.mod_op      = LDAP_MOD_ADD ;
    ModObjectClass.mod_type    = TEXT("objectClass") ;
    ModObjectClass.mod_values  = (PWSTR *) ppwszObjectClassVals ;

    //
    // OU (container name)
    //
    ppwszOuVals[0] = wszContainerName ;
    ppwszOuVals[1] = NULL ;

    ModOu.mod_op      = LDAP_MOD_ADD ;
    ModOu.mod_type    = TEXT("ou") ;
    ModOu.mod_values  = (PWSTR *) ppwszOuVals ;

    //
    // Now, we'll do the write...
    //
    PLDAP pLdapSet = NULL ;
    hr =  InitLDAP(&pLdapSet, TRUE) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdapSet) ;
    ASSERT(pGetNameContext()) ;

    ULONG ulRes = ldap_add_s( pLdapSet,
                              wszPath,
                              rgMods ) ;

    if (ulRes == LDAP_ALREADY_EXISTS)
    {
        hr = MQSync_I_CONTAINER_ALREADY_EXIST ;
        LogReplicationEvent( ReplLog_Info,
                             hr,
                             wszPath ) ;
    }
    else if (ulRes != LDAP_SUCCESS)
    {
        hr = MQSync_E_CANT_CREATE_CONTAINER ;
        LogReplicationEvent( ReplLog_Error,
                             hr,
                             wszPath,
                             ulRes ) ;
        return hr ;
    }
    else
    {
        LogReplicationEvent( ReplLog_Info,
                             MQSync_I_CREATE_CONTAINER,
                             wszPath ) ;
        hr = MQSync_OK ;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rplinks.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rplinks.cpp

Abstract: replication of site link to NT4 MSMQ1.0 servers.

Author:

    Tatiana Shubin  (TatianaS)   21-Apr-98

--*/

#include "mq1repl.h"
#include <activeds.h>
#include "..\..\src\ds\h\mqattrib.h"

#include "rplinks.tmh"

BOOL IsSiteGatesModified (
                    PLDAP           pLdap,
                    LDAPMessage     *pRes
                    )
{
    PLDAP_BERVAL *ppNewSiteGates = ldap_get_values_len( pLdap,
                                                   pRes,
                       const_cast<LPWSTR> (MQ_L_SITEGATES_ATTRIBUTE) ) ;

    UINT NewSiteGatesCount = ldap_count_values_len( ppNewSiteGates );

    PLDAP_BERVAL *ppOldSiteGates = ldap_get_values_len( pLdap,
                                                     pRes,
                       const_cast<LPWSTR> (MQ_L_SITEGATES_MIG_ATTRIBUTE) ) ;
    UINT OldSiteGatesCount = ldap_count_values_len( ppOldSiteGates );

    if (NewSiteGatesCount != OldSiteGatesCount)
    {
        //
        // there are changes in Site Gates
        //
        int i = ldap_value_free_len(ppNewSiteGates) ;
        ASSERT(i == LDAP_SUCCESS) ;
        i = ldap_value_free_len(ppOldSiteGates) ;
        ASSERT(i == LDAP_SUCCESS) ;

        return TRUE;
    }

    if (NewSiteGatesCount == 0)
    {
        //
        // there is no Site Gate
        //
        int i = ldap_value_free_len(ppNewSiteGates) ;
        ASSERT(i == LDAP_SUCCESS) ;
        i = ldap_value_free_len(ppOldSiteGates) ;
        ASSERT(i == LDAP_SUCCESS) ;
        return FALSE;
    }

    PLDAP_BERVAL *pTmpNew = ppNewSiteGates;
    PLDAP_BERVAL *pTmpOld = ppOldSiteGates;
    for (UINT i=0; i<NewSiteGatesCount; i++)
    {
        BOOL fFound = FALSE;
        for (UINT j=0; j<NewSiteGatesCount; j++)
        {
            if ((*pTmpNew)->bv_len != (*pTmpOld)->bv_len)
            {
                pTmpOld++;
                break;
            }
            if (memcmp ( (*pTmpNew)->bv_val,
                         (*pTmpOld)->bv_val,
                         (*pTmpNew)->bv_len ) == 0)
            {
                //
                // we found Current New Site Gate in list of
                // the old Site Gates
                //
                pTmpOld = ppOldSiteGates;
                fFound = TRUE;
                break;
            }
            pTmpOld++;
        }
        if (!fFound)
        {
            //
            // we did not find Current New Site Gate in the list of
            // the old Site Gates. It means that at least one
            // Site Gate was changes
            //
            int i = ldap_value_free_len(ppNewSiteGates) ;
            ASSERT(i == LDAP_SUCCESS) ;
            i = ldap_value_free_len(ppOldSiteGates) ;
            ASSERT(i == LDAP_SUCCESS) ;
            return TRUE;
        }
        pTmpNew++;
    }

    //
    // there are no changes in SiteGates
    //
    i = ldap_value_free_len(ppNewSiteGates) ;
    ASSERT(i == LDAP_SUCCESS) ;
    i = ldap_value_free_len(ppOldSiteGates) ;
    ASSERT(i == LDAP_SUCCESS) ;
    return FALSE;
}

HRESULT PrepareNextStepReplication(
                    GUID            *pNeighbor1Id,
                    GUID            *pNeighbor2Id,
                    PLDAP           pLdap,
                    LDAPMessage     *pRes
                    )
{
    HRESULT hr;
    //
    // get and set NT4STUB for boths neighbors in order to increase SN
    // for these sites and send site gates together with replication
    // message for site in the next time.
    //
    PROPID      aSiteProp = PROPID_S_NT4_STUB;
    PROPVARIANT aSiteVar;
    aSiteVar.vt = VT_UI2;

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant 

    hr = DSCoreGetProps (
            MQDS_SITE,
            NULL,
            pNeighbor1Id,
            1,
            &aSiteProp,
            &requestContext,
            &aSiteVar
            );

    if (FAILED(hr))
    {
       aSiteVar.uiVal  = 0;
    }

    PROPVARIANT tmpVar;
    tmpVar.vt = VT_UI2;
    tmpVar.uiVal  = 2;

    hr = DSCoreSetObjectProperties ( MQDS_SITE,
                                     NULL,
                                     pNeighbor1Id,
                                     1,
                                    &aSiteProp,
                                    &tmpVar,
                                    &requestContext,
                                     NULL ) ;

    hr = DSCoreSetObjectProperties ( MQDS_SITE,
                                     NULL,
                                     pNeighbor1Id,
                                     1,
                                     &aSiteProp,
                                     &aSiteVar,
                                     &requestContext,
                                     NULL ) ;

    hr = DSCoreGetProps ( MQDS_SITE,
                          NULL,
                          pNeighbor2Id,
                          1,
                          &aSiteProp,
                          &requestContext,
                          &aSiteVar ) ;
    if (FAILED(hr))
    {
       aSiteVar.uiVal  = 0;
    }

    hr = DSCoreSetObjectProperties ( MQDS_SITE,
                                     NULL,
                                     pNeighbor2Id,
                                     1,
                                    &aSiteProp,
                                    &tmpVar,
                                    &requestContext,
                                     NULL ) ;

    hr = DSCoreSetObjectProperties ( MQDS_SITE,
                                     NULL,
                                     pNeighbor2Id,
                                     1,
                                    &aSiteProp,
                                    &aSiteVar,
                                    &requestContext,
                                     NULL ) ;

    //
    // modify SiteGatesMig => SN will be increased and we'll send
    // site link replication in the next time
    //
    WCHAR **ppPath = ldap_get_values( pLdap,
                                      pRes,
                    const_cast<LPWSTR> (MQ_L_FULL_PATH_ATTRIBUTE) ) ;
    ASSERT(ppPath) ;

    PLDAP_BERVAL *ppNewSiteGates = ldap_get_values_len( pLdap,
                                                   pRes,
                       const_cast<LPWSTR> (MQ_L_SITEGATES_ATTRIBUTE) ) ;

    hr = ModifyAttribute(
                 *ppPath,
                 const_cast<WCHAR*> (MQ_L_SITEGATES_MIG_ATTRIBUTE),
                 ppNewSiteGates
                 );

    if (FAILED(hr))
    {
        // what to do if we failed to modify attribute?
    }
    int i = ldap_value_free( ppPath ) ;
    ASSERT(i == LDAP_SUCCESS) ;
    i = ldap_value_free_len(ppNewSiteGates) ;
    ASSERT(i == LDAP_SUCCESS) ;

    return hr;
}

//+-------------------------------------------------------
//
//  HRESULT HandleASiteLink()
//
//+-------------------------------------------------------
HRESULT _HandleASiteLink(
                    PLDAP           pLdap,
                    LDAPMessage    *pRes,
                    CDSUpdateList  *pReplicationList,
                    GUID           *pNeighborId,
                    int            *piCount
                    )
{
    HRESULT hr = MQ_ERROR;
    //
    // Get CN of site link.
    //
    WCHAR **ppValue = ldap_get_values( pLdap,
                                       pRes,
                                       TEXT("cn") ) ;
    if (ppValue && *ppValue)
    {
        BOOL fWasModified = IsSiteGatesModified (pLdap, pRes);

        //
        // Retrieve server name from the DN.
        //
        P<WCHAR> pwName = new TCHAR[ 1 + _tcslen(*ppValue) ] ;
        _tcscpy(pwName, *ppValue) ;

        __int64 i64SeqNum = 0 ;
        GUID  SiteLinkGuid ;
        hr =  GetGuidAndUsn( pLdap,
                             pRes,
                             g_pThePecMaster->GetDelta(),
                             &SiteLinkGuid,
                             &i64SeqNum ) ;
        ASSERT(SUCCEEDED(hr)) ;

        CSeqNum sn, snPrev ;
        GetSNForReplication (i64SeqNum, g_pThePecMaster, pNeighborId, &sn);

        #define     PROPS_SIZE  5
        PROPID      propIDs[ PROPS_SIZE ];
        PROPVARIANT propVariants[ PROPS_SIZE ] ;
        DWORD       iProps = 0 ;

        propIDs[ iProps ] = PROPID_L_NEIGHBOR1 ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].puuid = NULL ;
        DWORD dwNeighbor1Index = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_L_NEIGHBOR2 ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].puuid = NULL ;
        DWORD dwNeighbor2Index = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_L_COST  ;
	    propVariants[ iProps ].vt = VT_UI4 ;
	    iProps++;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  // not relevant 

        hr =  DSCoreGetProps( MQDS_SITELINK,
                              NULL,
                              &SiteLinkGuid,
                              iProps,
                              propIDs,
                              &requestContext,
                              propVariants ) ;

        if (FAILED(hr))
        {
            delete propVariants[ dwNeighbor1Index ].puuid ;
            delete propVariants[ dwNeighbor2Index ].puuid ;
            int i = ldap_value_free(ppValue) ;
            DBG_USED(i);
            ASSERT(i == LDAP_SUCCESS) ;
            return hr;
        }


        if (fWasModified)
        {
            hr = PrepareNextStepReplication(
                    propVariants[ dwNeighbor1Index ].puuid,
                    propVariants[ dwNeighbor2Index ].puuid,
                    pLdap,
                    pRes
                    );
            if (SUCCEEDED(hr))
            {
                delete propVariants[ dwNeighbor1Index ].puuid ;
                delete propVariants[ dwNeighbor2Index ].puuid ;
                int i = ldap_value_free(ppValue) ;
                DBG_USED(i);
                ASSERT(i == LDAP_SUCCESS) ;
                //
                // there were changes in Site Gate, we changed SiteGateMig
                // attribute and send site link replicaton in the next time
                //
                (*piCount)--;
                return hr;
            }
        }

        //
        // we are here if
        // - there were no changes in Site Gates or
        // - we failed to prepare next replication (modify attribute failed)
        // => we'll send site link replication now
        // (if in the second case we'll not send replication now,
        // we can create situation in which site link replication
        // will not be sent at all)
        //
        propIDs[ iProps ] = PROPID_L_ID  ;
	    propVariants[ iProps ].vt = VT_CLSID ;
        propVariants[ iProps ].puuid = &SiteLinkGuid ;
	    iProps++;

        propIDs[ iProps ] = PROPID_L_MASTERID  ;
	    propVariants[ iProps ].vt = VT_CLSID ;
        propVariants[ iProps ].puuid = &g_PecGuid ;
	    iProps++;

        ASSERT(iProps <= PROPS_SIZE) ;
        #undef  PROPS_SIZE

        NOT_YET_IMPLEMENTED(TEXT("PrepNeighbor, no OUT update, LSN"), s_fPrep) ;

        hr = PrepareNeighborsUpdate(
                     DS_UPDATE_SYNC,
                     MQDS_SITELINK,
                     NULL, // pwName,
                     &SiteLinkGuid,
                     iProps,
                     propIDs,
                     propVariants,
                     &g_PecGuid,
                     sn,
                     snPrev,
                     ENTERPRISE_SCOPE,
                     TRUE, //  fNeedFlush,
                     pReplicationList ) ;//OUT CDSUpdate **  ppUpdate
#ifdef _DEBUG
        TCHAR  tszSn[ SEQ_NUM_BUF_LEN ] ;
        sn.GetValueForPrint(tszSn) ;

        unsigned short *lpszGuid ;
        UuidToString( &SiteLinkGuid, &lpszGuid ) ;

        LogReplicationEvent(ReplLog_Info, MQSync_I_REPLICATE_SITELINK,
                             lpszGuid, tszSn) ;

        RpcStringFree( &lpszGuid ) ;
#endif

        //
        // free buffer of site link properties.
        //
        delete propVariants[ dwNeighbor1Index ].puuid ;
        delete propVariants[ dwNeighbor2Index ].puuid ;
        int i = ldap_value_free(ppValue) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;
    }
    else
    {
        ASSERT(0) ;
    }

    return hr;
}

//+-------------------------------------------------------
//
//  HRESULT ReplicateSiteLinks()
//
//+-------------------------------------------------------
HRESULT ReplicateSiteLinks(
            IN  TCHAR         *pszPrevUsn,
            IN  TCHAR         *pszCurrentUsn,
            IN  CDSUpdateList *pReplicationList,
            IN  GUID          *pNeighborId,
            OUT int           *piCount
            )
{
    PLDAP pLdap = NULL ;
	//
	// we do not set new values but we are looking for attributes 
	// those are not "replicated" to GC :
	// MQ_L_SITEGATES_ATTRIBUTE and MQ_L_SITEGATES_MIG_ATTRIBUTE
	//
    HRESULT hr =  InitLDAP(&pLdap, TRUE) ;	//bind to LDAP and not to GC
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;
    ASSERT(pGetNameContext()) ;

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwDNSize = wcslen(SITE_LINK_ROOT) + wcslen(pGetNameContext()) ;
    P<WCHAR> pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    wcscpy(pwszDN, SITE_LINK_ROOT) ;
    wcscat(pwszDN, pGetNameContext());
        
    TCHAR  wszFilter[ 512 ] ;  

    _tcscpy(wszFilter, TEXT("(&(usnChanged>=")) ;
    _tcscat(wszFilter, pszPrevUsn) ;
    if (pszCurrentUsn)
    {
        _tcscat(wszFilter, TEXT(")(usnChanged<=")) ;
        _tcscat(wszFilter, pszCurrentUsn) ;
    }
    _tcscat(wszFilter, TEXT(")")) ; 
    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;    

    //
    // handle deleted site link
    //
    hr = HandleDeletedSiteLinks(                
                wszFilter,
                pReplicationList,
                pNeighborId,
                piCount
                );

    ASSERT(SUCCEEDED(hr)) ;

    TCHAR *pszCategoryName = const_cast<LPTSTR> (x_LinkCategoryName);
    
    TCHAR wszFullName[256];    
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName, pszSchemaDefName);

    _tcscat(wszFilter, TEXT("(objectCategory=")) ;    
    _tcscat(wszFilter, wszFullName); 

    _tcscat(wszFilter, TEXT("))")) ;
    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;    

    //
    // handle site link
    //
    LM<LDAPMessage> pRes = NULL ;
    ULONG ulRes = ldap_search_s( pLdap,
                                 pwszDN,
                                 LDAP_SCOPE_SUBTREE,
                                 wszFilter,
                                 NULL, //ppAttributes,
                                 0,
                                 &pRes ) ;
    if (ulRes != LDAP_SUCCESS)
    {
        hr = MQSync_E_LDAP_SEARCH_FAILED ;
        LogReplicationEvent(ReplLog_Error, hr, pwszDN, wszFilter, ulRes) ;
        return hr ;
    }
    ASSERT(pRes);

    int iCount = ldap_count_entries(pLdap, pRes) ;

    LogReplicationEvent(ReplLog_Info, MQSync_I_LDAP_SEARCH,
                                             iCount, pwszDN, wszFilter) ;

    if (iCount == 0)
    {
        //
        // No results. That's OK.
        //
        return MQSync_I_LDAP_NO_RESULTS ;
    }

    //
    // OK, we have results. Now query for sites names.
    //
    BOOL fFailed = FALSE ;
    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    while(pEntry)
    {
        hr = _HandleASiteLink(
                    pLdap,
                    pEntry,
                    pReplicationList,
                    pNeighborId,
                    &iCount
                    ) ;
        if (FAILED(hr))
        {
            fFailed = TRUE ;
        }
        LDAPMessage *pPrevEntry = pEntry ;
        pEntry = ldap_next_entry(pLdap, pPrevEntry) ;
    }

    *piCount += iCount ;
    return hr ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpqueue.cpp ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name: rpqueue.cpp

Abstract: replication of NT5 queues to NT4 MSMQ1.0 servers.

Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

#include "mq1repl.h"
#include <activeds.h>
#include "..\..\src\ds\h\mqattrib.h"

#include "rpqueue.tmh"

//+-------------------------------------------------------
//
//  HRESULT _HandleAQueue()
//
//+-------------------------------------------------------

HRESULT  HandleAQueue( PLDAP           pLdap,
                       LDAPMessage    *pRes,
                       CDSMaster      *pMaster,
                       CDSUpdateList  *pReplicationList,
                       IN  GUID       *pNeighborId)
{
    DWORD dwLen = 0 ;
    P<BYTE>  pBuf = NULL ;
    HRESULT hr = RetrieveSecurityDescriptor( MQDS_QUEUE,
                                             pLdap,
                                             pRes,
                                             &dwLen,
                                             &pBuf ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    GUID *pMasterId = const_cast<GUID *> (pMaster->GetMasterId()) ;

    //
    // Get CN of site.
    //
    WCHAR **ppValue = ldap_get_values( pLdap,
                                       pRes,
                                       TEXT("cn") ) ;
    if (ppValue && *ppValue)
    {        
        __int64 i64SeqNum = 0 ;
        GUID  QueueGuid ;
        hr =  GetGuidAndUsn( pLdap,
                             pRes,
                             pMaster->GetDelta(),
                             &QueueGuid,
                             &i64SeqNum ) ; // i64SeqNum is equal to zero iff
                                            // the function failed OR
                                            // we asked USN of pre-migration object
        ASSERT(SUCCEEDED(hr)) ;

        CSeqNum sn, snPrev ;
        GetSNForReplication (i64SeqNum, pMaster, pNeighborId, &sn);
        
        #define     PROPS_SIZE  18
        PROPID      propIDs[ PROPS_SIZE ];
        PROPVARIANT propVariants[ PROPS_SIZE ] ;
        DWORD       iProps = 0 ;

        propIDs[ iProps ] = PROPID_Q_TYPE ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].puuid = NULL ;
        DWORD dwTypeIndex = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_Q_PATHNAME ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].pwszVal = NULL ;
        DWORD dwPathIndex = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_Q_JOURNAL ;
	    propVariants[ iProps ].vt = VT_UI1 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_Q_QUOTA ;
	    propVariants[ iProps ].vt = VT_UI4 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_Q_BASEPRIORITY ;
	    propVariants[ iProps ].vt = VT_I2 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_Q_JOURNAL_QUOTA ;
	    propVariants[ iProps ].vt = VT_UI4 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_Q_LABEL ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].pwszVal = NULL ;
        DWORD dwLabelIndex = iProps ;
	    iProps++;

        propIDs[ iProps ] = PROPID_Q_CREATE_TIME ;
	    propVariants[ iProps ].vt = VT_UI4 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_Q_MODIFY_TIME ;
	    propVariants[ iProps ].vt = VT_UI4 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_Q_AUTHENTICATE ;
	    propVariants[ iProps ].vt = VT_UI1 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_Q_PRIV_LEVEL ;
	    propVariants[ iProps ].vt = VT_UI4 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_Q_TRANSACTION ;
	    propVariants[ iProps ].vt = VT_UI1 ;
	    iProps++;

        propIDs[ iProps ] = PROPID_Q_QMID ;
	    propVariants[ iProps ].vt = VT_NULL ;
        propVariants[ iProps ].puuid = NULL ;
        DWORD dwQMIDIndex = iProps ;
	    iProps++;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  // not relevant 

        hr =  DSCoreGetProps( MQDS_QUEUE,
                              NULL,
                              &QueueGuid,
                              iProps,
                              propIDs,
                              &requestContext,
                              propVariants ) ;

        if (SUCCEEDED(hr))
        {
            propIDs[ iProps ] = PROPID_Q_MASTERID ;
	        propVariants[ iProps ].vt = VT_CLSID ;
            propVariants[ iProps ].puuid = pMasterId ;
	        iProps++;

            propIDs[ iProps ] = PROPID_Q_INSTANCE ;
	        propVariants[ iProps ].vt = VT_CLSID ;
            propVariants[ iProps ].puuid = &QueueGuid ;
	        iProps++;

            ASSERT(pBuf) ;
            ASSERT(dwLen != 0) ;
            ASSERT(IsValidSecurityDescriptor(pBuf)) ;

            propIDs[ iProps ] = PROPID_Q_SECURITY ;
	        propVariants[ iProps ].vt = VT_BLOB ;
            propVariants[ iProps ].blob.cbSize = dwLen ;
            propVariants[ iProps ].blob.pBlobData = pBuf ;
	        iProps++;

            //
            // Compute hashs.
            //
            propIDs[ iProps ] = PROPID_Q_HASHKEY ;
	        propVariants[ iProps ].vt = VT_UI4 ;
	        propVariants[ iProps ].ulVal =
                            CalHashKey( propVariants[ dwPathIndex ].pwszVal ) ;
	        iProps++;

            propIDs[ iProps ] = PROPID_Q_LABEL_HASHKEY ;
	        propVariants[ iProps ].vt = VT_UI4 ;
	        propVariants[ iProps ].ulVal =
                            CalHashKey( propVariants[ dwLabelIndex ].pwszVal ) ;
	        iProps++;

            ASSERT(iProps <= PROPS_SIZE) ;
            #undef  PROPS_SIZE

            NOT_YET_IMPLEMENTED(TEXT("PrepNeighbor, no OUT update, LSN"), s_fPrep) ;                                             

            hr = PrepareNeighborsUpdate( DS_UPDATE_SYNC,
                                         MQDS_QUEUE,
                                         NULL, // pwName,
                                         &QueueGuid,
                                         iProps,
                                         propIDs,
                                         propVariants,
                                         pMasterId,
                                         sn,
                                         snPrev,
                                         ENTERPRISE_SCOPE,
                                         TRUE, //  fNeedFlush,
                                         pReplicationList ) ;

#ifdef _DEBUG
            TCHAR  tszSn[ SEQ_NUM_BUF_LEN ] ;
            sn.GetValueForPrint(tszSn) ;

            LogReplicationEvent(ReplLog_Info, MQSync_I_REPLICATE_QUEUE,
                                 propVariants[ dwPathIndex ].pwszVal, tszSn) ;
#endif
        }
        //
        // free buffer of queue properties.
        //
        //
        // BUGBUG! If DSGetObjectProperties failed, did it allocate anyway?
        //
        delete propVariants[ dwTypeIndex ].puuid ;
        delete propVariants[ dwPathIndex ].pwszVal ;
        delete propVariants[ dwLabelIndex ].pwszVal ;
        delete propVariants[ dwQMIDIndex ].puuid ;

        int i = ldap_value_free(ppValue) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;
    }
    else
    {
        ASSERT(0) ;
    }

    return hr ;
}

//+-------------------------------------------------------
//
//  HRESULT _QueryForQueues()
//
//+-------------------------------------------------------

static HRESULT _QueryForQueues( IN  TCHAR           tszFilterID[],
                                IN  TCHAR          *pszPrevUsn,
                                IN  TCHAR          *pszCurrentUsn,
                                IN  CDSMaster      *pMaster,
                                IN  CDSUpdateList  *pReplicationList,
                                IN  GUID           *pNeighborId,
                                OUT int            *piCount )
{
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;
    //
    // we are looking in GC from the root, so we need empty default context
    //
    ASSERT(pGetNameContext(FALSE)) ;

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwDNSize = wcslen(pGetNameContext(FALSE)) ;
    P<TCHAR> pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    _tcscpy(pwszDN, pGetNameContext(FALSE));
    
    TCHAR  wszFilter[ 512 ] ;  

    _tcscpy(wszFilter, TEXT("(&(usnChanged>=")) ;
    _tcscat(wszFilter, pszPrevUsn) ;
    if (pszCurrentUsn)
    {
        _tcscat(wszFilter, TEXT(")(usnChanged<=")) ;
        _tcscat(wszFilter, pszCurrentUsn) ;
    }
    _tcscat(wszFilter, TEXT(")")) ;
    _tcscat(wszFilter, tszFilterID) ;

    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

    hr = HandleDeletedQueues( pwszDN,
                              wszFilter,
                              pMaster,
                              pReplicationList,
                              pNeighborId,
                              piCount ) ;
    ASSERT(SUCCEEDED(hr)) ;

    TCHAR *pszCategoryName = const_cast<LPTSTR> (x_QueueCategoryName);
    
    TCHAR wszFullName[256];    
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName, pszSchemaDefName);
       
    _tcscat(wszFilter, TEXT("(objectCategory=")) ;    
    _tcscat(wszFilter, wszFullName); 

    _tcscat(wszFilter, TEXT("))")) ;
    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

	hr = QueryDS(
			pLdap,
			pwszDN,
			wszFilter,
			pMaster,
            pReplicationList,
            pNeighborId,
			MQDS_QUEUE,
            piCount,
			//special parameters for deleted object
			FALSE,
			NULL,
			//special parameters for user object
			FALSE,
			NULL
			);

	ASSERT(SUCCEEDED(hr)) ;

    return hr ;
}

//+-------------------------------------------------------
//
//  HRESULT ReplicateQueues()
//
// Queues which were created during migration, and queues which are
// created by replication from NT4, do have the msmqMasterId property.
// However, queues which were originally created on NT5 servers do not
// have this property.
// So when we (we == NT5 MSMQ2 servers) replicate queues from NT4 sites
// to our NT4 BSCs, we query them using the NT4 master id as filter.
// When we replicate our own queues to NT4 PSCs, we can't use master id
// in the filter. So in replication of our own queues we have two queries:
// 1. first query with our masterid in filter (to get queues which were
//    already exist before migration).
// 2. then query queues which do not have the masterid field.
//
//+-------------------------------------------------------

HRESULT ReplicateQueues( TCHAR          *pszPrevUsn,
                         TCHAR          *pszCurrentUsn,
                         CDSMaster      *pMaster,
                         CDSUpdateList  *pReplicationList,
                         GUID           *pNeighborId,
                         int            *piCount,
                         BOOL            fReplicateNoID )
{
    //
    // first query with my guid in filter.
    //
    TCHAR  wszFilter[ 512 ] ;
    P<TCHAR> pGuidString ;
    GUID *pMasterId = const_cast<GUID *> (pMaster->GetMasterId()) ;

    _tcscpy(wszFilter, TEXT("(")) ;
    _tcscat(wszFilter, MQ_Q_MASTERID_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=")) ;
    GuidToLdapFilter( pMasterId,
                      &pGuidString ) ;
    _tcscat(wszFilter, pGuidString) ;
    _tcscat(wszFilter, TEXT(")")) ;

    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

    HRESULT hr = _QueryForQueues( wszFilter,
                                  pszPrevUsn,
                                  pszCurrentUsn,
                                  pMaster,
                                  pReplicationList,
                                  pNeighborId,
                                  piCount ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    if (!fReplicateNoID)
    {
        return hr ;
    }

    //
    // Next query queues which do not have the msmqMasterId property.
    //
    _tcscpy(wszFilter, TEXT("(!(")) ;
    _tcscat(wszFilter, MQ_Q_MASTERID_ATTRIBUTE) ;
    _tcscat(wszFilter, TEXT("=*))")) ;

    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

    hr = _QueryForQueues( wszFilter,
                          pszPrevUsn,
                          pszCurrentUsn,
                          pMaster,
                          pReplicationList,
                          pNeighborId,
                          piCount ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpmaster.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpmaster.cpp

Abstract:


Author:

    Doron Juster  (DoronJ)   11-Feb-98

--*/

#include "mq1repl.h"

#include "rpmaster.tmh"

//+----------------------------------------------------------------------
//
//  _FindLargestSeqNumAndDelta()
//
//  Find the highest seqnumber we already got from that master and
//  already updated in local DS.
//  At present (Mar-98, pre beta2) the seq numbers and delta values are
//  kept in a INI file.
//
//+----------------------------------------------------------------------

static HRESULT _FindLargestSeqNumAndDelta( IN const GUID  *pguidMasterId,
                                           OUT __int64    *pi64Delta,
                                           OUT CSeqNum    *psnIn,
                                           OUT CSeqNum    *psnOut)
{
    HRESULT hr = MQSync_OK ;
    //
    // Determine path of ini file.
    //
    static BOOL   s_fIniRead = FALSE ;

    if (!s_fIniRead)
    {
        DWORD dw = GetModuleFileName( NULL,
                                      g_wszIniName,
                         (sizeof(g_wszIniName) / sizeof(g_wszIniName[0]))) ;
        if (dw != 0)
        {
            TCHAR *p = _tcsrchr(g_wszIniName, TEXT('\\')) ;
            if (p)
            {
                p++ ;
                _tcscpy(p, SEQ_NUMBERS_FILE_NAME) ;
            }
        }
        s_fIniRead = TRUE ;
    }

    unsigned short *lpszGuid ;
    UuidToString( const_cast<GUID*> (pguidMasterId),
                  &lpszGuid ) ;
    P<TCHAR> wszGuid = new TCHAR[ _tcslen(lpszGuid) + 1 ] ;
    _tcscpy(wszGuid, lpszGuid) ;
    RpcStringFree( &lpszGuid ) ;
    lpszGuid = NULL ;

    TCHAR wszSeq[ SEQ_NUM_BUF_LEN ] ;
    memset(wszSeq, 0, sizeof(wszSeq)) ;

    GetPrivateProfileString( RECENT_SEQ_NUM_SECTION_IN,
                             wszGuid,
                             TEXT(""),
                             wszSeq,
                             (sizeof(wszSeq) / sizeof(wszSeq[0])),
                             g_wszIniName ) ;

    if (_tcslen(wszSeq) != 16)
    {
        //
        // all seq numbers are saved in the ini file as strings of 16
        // chatacters
        //
        hr = MQSync_E_READ_INI_FILE ;
        LogReplicationEvent( ReplLog_Error,
                             hr,
                             RECENT_SEQ_NUM_SECTION_IN,
                             wszGuid ) ;
        ASSERT(0) ;
    }
    if (FAILED(hr))
    {
        return hr ;
    }

    StringToSeqNum( wszSeq,
                    psnIn ) ;

    memset(wszSeq, 0, sizeof(wszSeq)) ;

    GetPrivateProfileString( RECENT_SEQ_NUM_SECTION_OUT,
                             wszGuid,
                             TEXT(""),
                             wszSeq,
                             (sizeof(wszSeq) / sizeof(wszSeq[0])),
                             g_wszIniName ) ;

    if (_tcslen(wszSeq) != 16)
    {
        //
        // all seq numbers are saved in the ini file as strings of 16
        // chatacters
        //
        hr = MQSync_E_READ_INI_FILE ;
        LogReplicationEvent( ReplLog_Error,
                             hr,
                             RECENT_SEQ_NUM_SECTION_OUT,
                             wszGuid ) ;
        ASSERT(0) ;
    }
    if (FAILED(hr))
    {
        return hr ;
    }

    StringToSeqNum( wszSeq,
                    psnOut ) ;

    memset(wszSeq, 0, sizeof(wszSeq)) ;
    GetPrivateProfileString( MIGRATION_DELTA_SECTION,
                             wszGuid,
                             TEXT(""),
                             wszSeq,
                             (sizeof(wszSeq) / sizeof(wszSeq[0])),
                             g_wszIniName ) ;

    if (_tcslen(wszSeq) == 0)
    {
        hr = MQSync_E_READ_INI_FILE ;
        LogReplicationEvent( ReplLog_Error,
                             hr,
                             MIGRATION_DELTA_SECTION,
                             wszGuid ) ;
        ASSERT(0) ;
    }
    if (FAILED(hr))
    {
        return hr ;
    }

    _stscanf(wszSeq, TEXT("%I64d"), pi64Delta) ;
    ASSERT(*pi64Delta != 0) ;
    //
    // Actually, in theory, the delta value can be 0.
    // But it's extremenly unlikely it will indeed be 0.
    //

    return hr ;
}

//+---------------------
//
//  InitBSC()
//
//+---------------------

HRESULT InitBSC( IN LPWSTR          pwcsPathName,
                 IN const GUID *    pBSCMachineGuid )
{
    LPWSTR  pwcsDupName = DuplicateLPWSTR(pwcsPathName);
    if (!g_pNeighborMgr)
    {
        g_pNeighborMgr = new  CDSNeighborMgr ;
    }
    HRESULT hr = g_pNeighborMgr->AddBSCNeighbor( pwcsDupName,
                                                 pBSCMachineGuid,
                                                 0 ) ;
    g_fBSCExists = TRUE;
    return hr ;
}

//+---------------------
//
//  InitPSC()
//
//+---------------------

HRESULT InitPSC( IN LPWSTR *        ppwcsPathName,
                 IN const GUID *    pguidMasterId,
                 IN CACLSID *       pcauuidSiteGates,
                 IN BOOL            fNT4Site,
                 IN BOOL            fMyPSC )
{
    HRESULT  hr;
    __int64  i64Delta = 0 ;
    CSeqNum  snMaxLsnIn;
    CSeqNum  snMaxLsnOut;
    CSeqNum  snPurgeDummy;

#ifdef _DEBUG
    unsigned short *lpszGuid ;
    UuidToString( const_cast<GUID*> (pguidMasterId),
                  &lpszGuid ) ;

    LogReplicationEvent( ReplLog_Info,
                         MQSync_I_START_INIT_PSC,
                         *ppwcsPathName, lpszGuid ) ;

    RpcStringFree( &lpszGuid ) ;
#endif

    hr = _FindLargestSeqNumAndDelta(pguidMasterId, &i64Delta, &snMaxLsnIn, &snMaxLsnOut) ;
    if (FAILED(hr))
    {
        return hr ;
    }

#ifdef _DEBUG
    TCHAR wszSeq[ SEQ_NUM_BUF_LEN ] ;
    snMaxLsnIn.GetValueForPrint( wszSeq ) ;

    TCHAR wszDelta[ SEQ_NUM_BUF_LEN ] ;
    _stprintf(wszDelta, TEXT("%I64d"), i64Delta) ;

    LogReplicationEvent( ReplLog_Info, MQSync_I_SEQ_NUM,
                                          *ppwcsPathName, wszSeq, wszDelta) ;
#endif

    CSeqNum    snAcked ;
    CSeqNum    snAckedPEC ;
    CSeqNum    *psnAcked = NULL ;
    CSeqNum    *psnAckedPEC = NULL ;
    PURGESTATE Sync0State = PURGE_STATE_NORMAL;

    //
    // PSC are interested in received acks
    //
    psnAcked = &snAcked;
    if (g_IsPEC)
    {
        //
        // PEC is interested in received acks for PEC info
        //
        psnAckedPEC = &snAckedPEC;
    }

    hr = g_pMasterMgr->AddPSCMaster( *ppwcsPathName,
                                     pguidMasterId,
                                     i64Delta,
                                     snMaxLsnIn,
                                     snMaxLsnOut,
                                     snPurgeDummy,
                                     Sync0State,
                                     snAcked,
                                     snAckedPEC,
                                     pcauuidSiteGates,
                                     fNT4Site) ;
    if (FAILED(hr))
    {
        return(hr);
    }

    LogReplicationEvent( ReplLog_Info,
                         MQSync_I_INIT_PSC,
                         *ppwcsPathName ) ;
        
    //
    // *ppwcsPathName is auto pointer, if everything is OK 
    // we have to keep it (not delete)
    //
    *ppwcsPathName = NULL;

    return MQ_OK ;
}

//+------------------------------------------------------------------------
//
//  _InitMyPSC
//
//  Description:  Init local PSC (local NT5 DS machine).
//      On NT4 machines, this code run also on BSCs and initialize the
//      structure for the site PSC.
//      NT5 replication services run only on "PSC". (i.e., PSC in the
//      NT4 sense). So here we initialize ourselves.
//      One machine, the ex-PEC may be the master of many NT5 sites.
//      So here we initialize ourselves for all these sites.
//
//+------------------------------------------------------------------------

static HRESULT  _InitMyPSC()
{
    ASSERT(g_IsPSC) ;

    P<WCHAR> pwszMyName = NULL ;
    pwszMyName = new WCHAR[ 1 + wcslen( g_pwszMyMachineName ) ] ;
    wcscpy(pwszMyName, g_pwszMyMachineName) ;
     
    HRESULT hr = InitPSC( &pwszMyName,
                          &g_MySiteMasterId,
                          NULL,
                          FALSE,   //it is NT5 site because it is PEC
                          TRUE );  //it is MyPSC 

	DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO,
                         TEXT("InitMyPSC, %ls, hr- %lxh"), g_pwszMyMachineName, hr)) ;

    if (g_IsPEC)
    {
        //
        // I'm also the PEC. Init PEc seq numbers and delta
        //
        CSeqNum  snMaxLsnIn;
        CSeqNum  snMaxLsnOut;
        CSeqNum  snPurgeDummy;
        __int64  i64Delta = 0 ;

        hr = _FindLargestSeqNumAndDelta(&g_PecGuid, &i64Delta, &snMaxLsnIn, &snMaxLsnOut) ;

        ASSERT(!g_pThePecMaster) ;
        g_pThePecMaster = new CDSMaster( pwszMyName, 
                                         &g_PecGuid,
                                         i64Delta,
                                         snMaxLsnIn,
                                         snMaxLsnOut,
	    					             snPurgeDummy,
                                         PURGE_STATE_NORMAL,
                                         NULL,
                                         FALSE ) ;  //this site is NT5 site, NT4Site = FALSE
    }
   
    return hr ;
}

//+-------------------------------------------------------------------------
//
//  HRESULT InitMasters()
//
//  Description: Init the masters data structures. These are used to track
//      replication messages which arrive from other master. Before updating
//      local DS we must verify there weren't any holes. In case of holes,
//      (i.e., replication messages from other masters which were lost),
//      we'll ask for Sync from the remote master.
//      Here a "master" is a NT4 PSC.
//
//+-------------------------------------------------------------------------

HRESULT InitMasters()
{
    g_pMasterMgr = new CDSMasterMgr ;
    if (!g_pMasterMgr)
    {
        return MQSync_E_NO_MEMORY ;
    }

    //
    //  First get the enterprise id. It is required for transmission of
    //  sync request message.
    //
    HRESULT hr = InitEnterpriseID() ;
    if (FAILED(hr))
    {
        return hr ;
    }

    //
    //  Next init the local site PSC (i.e., the local machine).
    //
    hr = _InitMyPSC();
    if (FAILED(hr))
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_INIT_MY_PSC,
                             hr ) ;
        return hr ;
    }

    hr = InitOtherPSCs(TRUE) ;  // init NT4PSCs => NT4Site flag = TRUE
    if (FAILED(hr))
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_INIT_NT4_PSC,
                             hr ) ;
        return hr ;
    }
	
	HRESULT hr1 = MQSync_OK;
	if (hr == MQSync_I_NO_SERVERS_RESULTS)
	{
		//
		// it means that there is no more NT4 PSCs in Enterprise
		//
		hr1 = hr;
	}

    hr = InitOtherPSCs(FALSE) ; // init NT5PSCs => NT5Site flag = FALSE
    if (FAILED(hr))
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_INIT_NT5_PSC,
                             hr ) ;
        return hr ;
    }

    if (g_pMySiteMaster == NULL)
    {
        hr =  MQSync_E_MY_MASTER ;
        LogReplicationEvent( ReplLog_Error,
                             hr ) ;
        return hr ;
    }

    return hr1 ;
}

//+----------------------
//
//  HRESULT InitBSCs()
//
//+----------------------

HRESULT InitBSCs()
{
    HRESULT hr = InitMyNt4BSCs(&g_MySiteMasterId) ;

    return hr ;
}

HRESULT InitNativeNT5Site ()
{
    g_pNativeNT5SiteMgr = new CDSNativeNT5SiteMgr ;
    if (!g_pNativeNT5SiteMgr)
    {
        return MQSync_E_NO_MEMORY ;
    }

    HRESULT hr = InitNT5Sites ();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpservc.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpservc.h

Abstract: export functions which are required to enable the
          replication dll to be called from a WinNT service.

Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

BOOL APIENTRY  InitReplicationService() ;
typedef BOOL (APIENTRY  *InitReplicationService_ROUTINE) () ;

void APIENTRY  RunReplicationService() ;
typedef void (APIENTRY  *RunReplicationService_ROUTINE) () ;

void APIENTRY  StopReplicationService() ;
typedef void (APIENTRY  *StopReplicationService_ROUTINE) () ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpsites.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpsites.cpp

Abstract: replication of NT5 sites to NT4 MSMQ1.0 servers.

Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

#include "mq1repl.h"
#include "..\ds\h\mqattrib.h"

#include "rpsites.tmh"

//+-----------------------------------------------------------------------
//
//   HRESULT _HandleForeignSite()
//
//  Foreign sites in NT5 DS (sites with the attribute "mSMQSiteForeign" set
//  to TRUE) represent MSMQ1.0 foreign CNs. Those need to be replicated to
//  MSMQ1.0 world as CNs, not as sites.
//
//+-----------------------------------------------------------------------

static HRESULT _HandleForeignSite( PLDAP          pLdap,
                                   LDAPMessage   *pRes,
                                   CDSUpdateList *pReplicationList,
                                   GUID          *pNeighborId,
                                   int           *piCount,
                                   LPWSTR         pwName,
                                   GUID           ForeignSiteGuid,
                                   CSeqNum        *psn
                                  )
{
    HRESULT hr = MQSync_OK ;
    WCHAR **ppValue = ldap_get_values( pLdap,
                                       pRes,
                             const_cast<WCHAR*> (MQ_S_FOREIGN_ATTRIBUTE) ) ;
    if (ppValue && *ppValue)
    {
        if (_tcsicmp(*ppValue, TEXT("TRUE")) == 0)
        {        
            //
            // Handle foreign site.
            //
            DWORD dwLen = 0 ;
            P<BYTE>  pBuf = NULL ;
            hr = RetrieveSecurityDescriptor( MQDS_CN,
                                             pLdap,
                                             pRes,
                                             &dwLen,
                                             &pBuf ) ;
            if (FAILED(hr))
            {
                return hr ;
            }

            ASSERT(pBuf) ;
            ASSERT(dwLen != 0) ;
            ASSERT(IsValidSecurityDescriptor(pBuf)) ;

            hr = HandleACN (
                        pReplicationList,
                        pNeighborId,
                        ForeignSiteGuid,
                        FOREIGN_ADDRESS_TYPE,
                        pwName,
                        psn,
                        dwLen,
                        pBuf
                        );

            if (SUCCEEDED(hr))
            {
                (*piCount)++ ;

                #ifdef _DEBUG
                            TCHAR  tszSn[ SEQ_NUM_BUF_LEN ] ;
                            psn->GetValueForPrint(tszSn) ;

                            LogReplicationEvent(ReplLog_Info, MQSync_I_REPLICATE_SITE,
                                                                         pwName, tszSn) ;
                #endif
                
                //
                // put foreign cn to the ini file if needed
                //                
                if (!IsForeignSiteInIniFile(ForeignSiteGuid))
                {
                    AddToIniFile(ForeignSiteGuid);
                }

                hr = MQSync_I_SITE_IS_FOREIGN_CN ;
            }
            else
            {
            }                
        }
        int i = ldap_value_free(ppValue) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;
    }

    return hr ;
}

//+-------------------------------------------------------
//
//  HRESULT GetAllSiteGates()
//
//+-------------------------------------------------------

HRESULT GetAllSiteGates (
                    IN GUID     *pSiteGuid,
                    OUT ULONG   *pulNumSiteGates,
                    OUT GUID    **pparGuids
                    )
{
    HRESULT hr = MQSync_OK;

    //
    // Lookup the Neighbors Id and Gates of the object Site Link
    //
	LONG cAlloc = 4;
	P<PROPID> columnsetPropertyIDs  = new PROPID[ cAlloc ];
	columnsetPropertyIDs[0] = PROPID_L_NEIGHBOR1;
	columnsetPropertyIDs[1] = PROPID_L_NEIGHBOR2;
	columnsetPropertyIDs[2] = PROPID_L_GATES_DN;
	columnsetPropertyIDs[3] = PROPID_L_ID;

    MQCOLUMNSET columnsetSiteLink;
    columnsetSiteLink.cCol = cAlloc;
    columnsetSiteLink.aCol = columnsetPropertyIDs;

    HANDLE hQuery;
    DWORD dwCount = cAlloc;
	
    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant 

    hr = DSCoreLookupBegin (
    		NULL,
            NULL,
            &columnsetSiteLink,
            NULL,
            &requestContext,
            &hQuery
    		) ;

	if (FAILED(hr))
    {
        return hr;
    }

	P<PROPVARIANT> paVariant = new PROPVARIANT[ cAlloc ];

    GUID *pNewGuids = NULL;

    while (SUCCEEDED(hr))
    {

		hr = DSCoreLookupNext (
				hQuery,
				&dwCount,
				paVariant
				) ;

		if (FAILED(hr))
        {
            return hr;
        }
		if (dwCount == 0)
		{
			//there is no result
			break;
		}
        if (paVariant[2].calpwstr.cElems != 0)
        {
            //
            // there are site gates in that site link
            //
            if (memcmp (pSiteGuid, paVariant[0].puuid, sizeof(GUID)) == 0 ||
			    memcmp (pSiteGuid, paVariant[1].puuid, sizeof(GUID)) == 0)
		    {
                //
                // given site is one of the neighbors
                //
                for (ULONG i=0; i<paVariant[2].calpwstr.cElems; i++)
                {
                    //
                    // build Path from Full Path Name
                    //
                    ASSERT(_tcsstr(paVariant[2].calpwstr.pElems[i], MACHINE_PATH_PREFIX) -
                                paVariant[2].calpwstr.pElems[i] == 0);
                    WCHAR *ptr = paVariant[2].calpwstr.pElems[i] + MACHINE_PATH_PREFIX_LEN - 1;
                    ULONG ulPathLen = _tcsstr(ptr, LDAP_COMMA) - ptr;
                    WCHAR *pwcsPath = new WCHAR[ulPathLen + 1];
                    wcsncpy(pwcsPath, ptr, ulPathLen);
                    pwcsPath[ulPathLen] = L'\0';

                    //
                    // get owner id and machine id by full path
                    //
                    #define MACHINE_PROPS_SIZE  2
                    P<PROPID> pMachinePropID  = new PROPID[ MACHINE_PROPS_SIZE  ];
                    P<PROPVARIANT> pMachineVariant = new PROPVARIANT[ MACHINE_PROPS_SIZE ];

                    pMachinePropID[0] = PROPID_QM_SITE_ID;
                    pMachineVariant[ 0 ].vt = VT_NULL ;
                    pMachineVariant[ 0 ].puuid = NULL ;

	                pMachinePropID[1] = PROPID_QM_MACHINE_ID;
                    pMachineVariant[ 1 ].vt = VT_NULL ;
                    pMachineVariant[ 1 ].puuid = NULL ;

                    CDSRequestContext requestContext( e_DoNotImpersonate,
                                                e_ALL_PROTOCOLS);  // not relevant 

                    hr = DSCoreGetProps (
                                MQDS_MACHINE,
                                pwcsPath,
                                NULL,
                                MACHINE_PROPS_SIZE,
                                pMachinePropID,
                                &requestContext,
                                pMachineVariant
                                );

                    if (SUCCEEDED(hr))
                    {
                        if (memcmp (pSiteGuid, pMachineVariant[ 0 ].puuid, sizeof(GUID)) == 0)
                        {
                            //
                            // site contains this server, add server's guid to the array of guids
                            //

                            //
                            // first, check if we already added that site gate
                            //
                            BOOL fAlreadyAdded = FALSE;
                            ULONG count;
                            if (*pulNumSiteGates > 0)
                            {                                
                                for (count = 0; count<*pulNumSiteGates; count++)
                                {
                                    if (memcmp( pMachineVariant[ 1 ].puuid, 
                                                &pNewGuids[count], 
                                                sizeof(GUID)) == 0)
                                    {
                                        fAlreadyAdded = TRUE;
                                        break;
                                    }
                                }                                
                            }

                            if (!fAlreadyAdded)
                            {
                                GUID *pOldGuids = NULL;                                
                                if (*pulNumSiteGates > 0)
                                {
                                    pOldGuids = new GUID [*pulNumSiteGates];
                                    for (count = 0; count<*pulNumSiteGates; count++)
                                    {
                                        memcpy(&pOldGuids[count], &pNewGuids[count], sizeof(GUID));
                                    }
                                    delete pNewGuids;
                                }

                                *pulNumSiteGates += 1;
                                pNewGuids = new GUID[*pulNumSiteGates];

                                for (count = 0; count < *pulNumSiteGates-1; count++)
                                {
                                    memcpy (&pNewGuids[count], &pOldGuids[count], sizeof(GUID));
                                }
                                if (pOldGuids)
                                {
                                    delete pOldGuids;
                                }

                                memcpy( &pNewGuids[*pulNumSiteGates-1],
                                        pMachineVariant[ 1 ].puuid,
                                        sizeof(GUID) );
                            }
                        }
                    }

                    delete pwcsPath;
                    delete pMachineVariant[0].puuid;
                    delete pMachineVariant[1].puuid;
                    #undef MACHINE_PROPS_SIZE
                }
            }
        }

        delete paVariant[0].puuid;
        delete paVariant[1].puuid;
        delete [] paVariant[2].calpwstr.pElems;
		delete paVariant[3].puuid;

        if (FAILED(hr))
        {
            return hr;
        }
    }

    *pparGuids = pNewGuids;
    HRESULT hr1 = DSCoreLookupEnd (hQuery) ;
    UNREFERENCED_PARAMETER(hr1);

    return hr;
}
//+-------------------------------------------------------
//
//  static HRESULT _HandleASite()
//
//+-------------------------------------------------------

HRESULT _HandleASite( PLDAP          pLdap,
                      LDAPMessage   *pRes,
                      CDSUpdateList *pReplicationList,
                      GUID          *pNeighborId,
                      int           *piCount )
{        
    HRESULT hr = MQSync_OK;
    //
    // Get CN of site.
    //
    WCHAR **ppValue = ldap_get_values( pLdap,
                                       pRes,
                                       TEXT("cn") ) ;    

    if (ppValue && *ppValue)
    {
        //
        // Retrieve site name.
        //
        P<WCHAR> pwName = new TCHAR[ 1 + _tcslen(*ppValue) ] ;
        _tcscpy(pwName, *ppValue) ;

        __int64 i64SeqNum = 0 ;
        GUID  SiteGuid ;
        hr =  GetGuidAndUsn( pLdap,
                             pRes,
                             g_pThePecMaster->GetDelta(),
                             &SiteGuid,
                             &i64SeqNum ) ;
        ASSERT(SUCCEEDED(hr)) ;
      
        CSeqNum sn, snPrev ;
        GetSNForReplication (i64SeqNum, g_pThePecMaster, pNeighborId, &sn);

        hr = _HandleForeignSite( pLdap,
                                 pRes,
                                 pReplicationList,
                                 pNeighborId,
                                 piCount,
                                 pwName,
                                 SiteGuid,
                                 &sn) ;
        if (FAILED(hr) ||
            hr == MQSync_I_SITE_IS_FOREIGN_CN)
        {
            //
            // free all and return
            //
            int i = ldap_value_free(ppValue) ;
            DBG_USED(i);
            ASSERT(i == LDAP_SUCCESS) ;
            return hr;
        }

        DWORD dwLen = 0 ;
        P<BYTE>  pBuf = NULL ;
        hr = RetrieveSecurityDescriptor( MQDS_SITE,
                                         pLdap,
                                         pRes,
                                         &dwLen,
                                         &pBuf ) ;
        if (FAILED(hr))
        {
            return hr ;
        }

        LPWSTR pwcsPSCName = NULL;
        //
        // check if this site is already migrated to NT5
        //
        BOOL fNT4SiteFlag = TRUE;
        hr = g_pMasterMgr->GetNT4SiteFlag (&SiteGuid, &fNT4SiteFlag );
        if (FAILED(hr))
        {            
            //
            // we can be here if it is NT5 non-migrated site. It is not defined
            // in MasterMgr (do we have to add it to MasterMgr?)
            // Anyway we have to replicate it to NT4, so my workaround 
            // is to define MyMachineName (PEC Name) as PSC for this site
            //
            pwcsPSCName = g_pwszMyMachineName;

            //
            // add this NT5 site to map if needed
            //
            if (!g_pNativeNT5SiteMgr->IsNT5NativeSite (&SiteGuid))
            {
                g_pNativeNT5SiteMgr->AddNT5NativeSite (&SiteGuid, pwName);
            }
        }
        else if (fNT4SiteFlag == FALSE)
        {
            //
            // this site is already migrated to NT5, but maybe we miss out this change.
            // scenario: PEC was down, PSC migrated to NT5, PEC is up and get from DS
            // zero-value of NT4Flag, but PSC name was not change
            //           
            pwcsPSCName = g_pwszMyMachineName;
        }
        else
        {           
            hr = g_pMasterMgr->GetPathName(&SiteGuid, &pwcsPSCName); 
            if (FAILED(hr))
            {
                // ??? what to do ???
                ASSERT(0);
            }          
        }

        #define     PROPS_SIZE  9
        PROPID      propIDs[ PROPS_SIZE ];
        PROPVARIANT propVariants[ PROPS_SIZE ] ;
        DWORD       iProps = 0 ;

        propIDs[ iProps ] = PROPID_S_INTERVAL1 ;
        propVariants[ iProps ].vt = VT_UI2;
        DWORD dwInterval1Prop = iProps;
        iProps++;

        propIDs[ iProps ] = PROPID_S_INTERVAL2 ;
        propVariants[ iProps ].vt = VT_UI2;
        DWORD dwInterval2Prop = iProps;
        iProps++;

        CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  // not relevant 

        hr = DSCoreGetProps (
                MQDS_SITE,
                NULL,
                &SiteGuid,
                iProps,
                propIDs,
                &requestContext,
                propVariants);

        if (FAILED(hr))
        {
            //
            // free all and return
            //
            int i = ldap_value_free(ppValue) ;
            DBG_USED(i);
            ASSERT(i == LDAP_SUCCESS) ;
            return hr;
        }
        
        //
        // DSCoreGetProps returns VT_UI4
        //
        propVariants[ dwInterval1Prop ].vt = VT_UI2;
        propVariants[ dwInterval2Prop ].vt = VT_UI2;
       
        propIDs[ iProps ] = PROPID_S_MASTERID ;
	    propVariants[ iProps ].vt = VT_CLSID ;
        propVariants[ iProps ].puuid = &g_PecGuid ;
	    iProps++;

        propIDs[ iProps ] = PROPID_S_PATHNAME ;
	    propVariants[ iProps ].vt = VT_LPWSTR ;
        propVariants[ iProps ].pwszVal = pwName ;
	    iProps++;

        propIDs[ iProps ] = PROPID_S_PSC ;
	    propVariants[ iProps ].vt = VT_LPWSTR ;
        propVariants[ iProps ].pwszVal = pwcsPSCName ;
	    iProps++;

        ULONG ulNumSiteGates = 0;
        GUID *arGuids = NULL;

        hr = GetAllSiteGates (
                    &SiteGuid,
                    &ulNumSiteGates,
                    &arGuids
                    );
        if (FAILED(hr))
        {
            //
            // free all and return
            //
            int i = ldap_value_free(ppValue) ;
            DBG_USED(i);
            ASSERT(i == LDAP_SUCCESS) ;
            if (arGuids)
            {
                delete [] arGuids;
            }
            return hr;
        }

        propIDs[ iProps ] = PROPID_S_GATES ;
	    propVariants[ iProps ].vt = VT_CLSID | VT_VECTOR ;
        propVariants[ iProps ].cauuid.cElems = ulNumSiteGates ;
        propVariants[ iProps ].cauuid.pElems = arGuids ;
	    iProps++;

        ASSERT(pBuf) ;
        ASSERT(dwLen != 0) ;
        ASSERT(IsValidSecurityDescriptor(pBuf)) ;

        propIDs[ iProps ] = PROPID_S_SECURITY ;
	    propVariants[ iProps ].vt = VT_BLOB ;
        propVariants[ iProps ].blob.cbSize = dwLen ;
        propVariants[ iProps ].blob.pBlobData = pBuf ;
	    iProps++;

        PROPID PscSignPk = PROPID_QM_SIGN_PK;

        P<PROPVARIANT> pPscSignPkVar = new PROPVARIANT[1];
	    pPscSignPkVar[0].vt = VT_NULL ;	

        CDSRequestContext requestContext1( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  // not relevant 

        hr =  DSCoreGetProps( MQDS_MACHINE,
                              pwcsPSCName,
                              NULL,
                              1,
                              &PscSignPk,
                              &requestContext1,
                              pPscSignPkVar ) ;

        if (FAILED(hr))
        {
            //
            // free all and return
            //
            int i = ldap_value_free(ppValue) ;
            DBG_USED(i);
            ASSERT(i == LDAP_SUCCESS) ;
            if (arGuids)
            {
                delete [] arGuids;
            }
            return hr;
        }

        propIDs[ iProps ] = PROPID_S_PSC_SIGNPK ;	
        propVariants[ iProps ].vt = VT_BLOB ;
        propVariants[ iProps ].blob.cbSize = pPscSignPkVar[0].blob.cbSize ;
        propVariants[ iProps ].blob.pBlobData = pPscSignPkVar[0].blob.pBlobData;
	    iProps++;

        ASSERT(iProps <= PROPS_SIZE) ;
        #undef  PROPS_SIZE

        NOT_YET_IMPLEMENTED(
             TEXT("PrepNeighbor, no OUT update, NO cleanup, LSN"), s_fPrep) ;
  
        hr = PrepareNeighborsUpdate( DS_UPDATE_SYNC,
                                     MQDS_SITE,
                                     NULL, // pwName,
                                     &SiteGuid,
                                     iProps,
                                     propIDs,
                                     propVariants,
                                     &g_PecGuid,
                                     sn,
                                     snPrev,
                                     ENTERPRISE_SCOPE,
                                     TRUE, //  fNeedFlush,
                                     pReplicationList ) ;
        if (SUCCEEDED(hr))
        {
            (*piCount)++ ;

#ifdef _DEBUG
            TCHAR  tszSn[ SEQ_NUM_BUF_LEN ] ;
            sn.GetValueForPrint(tszSn) ;

            LogReplicationEvent(ReplLog_Info, MQSync_I_REPLICATE_SITE,
                                                         pwName, tszSn) ;
#endif
        }
        else
        {
        }

        if (ulNumSiteGates)
        {
            delete [] arGuids ;
        }

        int i = ldap_value_free(ppValue) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;
    }
    else
    {
        ASSERT(0) ;
    }

    return hr ;
}

//+-------------------------------------------------------
//
//  HRESULT HandleSites()
//
//+-------------------------------------------------------

HRESULT HandleSites( TCHAR         *pszPrevUsn,
                     TCHAR         *pszCurrentUsn,
                     CDSUpdateList *pReplicationList,
                     GUID          *pNeighborId,
                     int           *piCount )
{
    if (!g_IsPEC)
    {
        //
        // Only PEC (ex NT4 PEC) is the owner if sites.
        //
        return MQSync_OK ;
    }

    PLDAP pLdap = NULL ;
	//
	// we do not set new values but we are looking for the attributes 
	// that are not "replicated" to GC:
	// MQ_S_FOREIGN_ATTRIBUTE
	//
    HRESULT hr =  InitLDAP(&pLdap, TRUE) ;	//bind to LDAP and not to GC
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;
    ASSERT(pGetNameContext()) ;

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwDNSize = wcslen(SITES_ROOT) + wcslen(pGetNameContext()) ;
    P<WCHAR> pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    wcscpy(pwszDN, SITES_ROOT) ;
    wcscat(pwszDN, pGetNameContext());

    TCHAR *pszCategoryName = const_cast<LPTSTR> (x_SiteCategoryName);
        
    TCHAR wszFullName[256];    
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName,pszSchemaDefName);

    TCHAR  wszFilter[ 512 ] ;    
    _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;    
    _tcscat(wszFilter, wszFullName);    

    _tcscat(wszFilter, TEXT(")(usnChanged>=")) ;
    _tcscat(wszFilter, pszPrevUsn) ;
   
    if (pszCurrentUsn)
    {
        _tcscat(wszFilter, TEXT(")(usnChanged<=")) ;
        _tcscat(wszFilter, pszCurrentUsn) ;
    }
    _tcscat(wszFilter, TEXT("))")) ;
    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;
    
    LM<LDAPMessage> pRes = NULL ;
    ULONG ulRes = ldap_search_s( pLdap,
                                 pwszDN,
                                 LDAP_SCOPE_SUBTREE,
                                 wszFilter,
                                 NULL, //ppAttributes,
                                 0,
                                 &pRes ) ;
    if (ulRes != LDAP_SUCCESS)
    {
        hr = MQSync_E_LDAP_SEARCH_FAILED ;
        LogReplicationEvent(ReplLog_Error, hr, pwszDN, wszFilter, ulRes) ;
        return hr ;
    }
    ASSERT(pRes);

    int iCount = ldap_count_entries(pLdap, pRes) ;

    LogReplicationEvent(ReplLog_Info, MQSync_I_LDAP_SEARCH,
                                             iCount, pwszDN, wszFilter) ;

    if (iCount == 0)
    {
        //
        // No results. That's OK.
        //        
        return MQSync_I_LDAP_NO_RESULTS ;
    }

    //
    // OK, we have results. Now query for sites names.
    //
    BOOL fFailed = FALSE ;
    LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
    while(pEntry)
    {
        hr = _HandleASite( pLdap,
                           pEntry,
                           pReplicationList,
                           pNeighborId,
                           piCount ) ;

        if (FAILED(hr))
        {
            fFailed = TRUE ;
        }
        LDAPMessage *pPrevEntry = pEntry ;
        pEntry = ldap_next_entry(pLdap, pPrevEntry) ;
    }
    
    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpservc.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpservc.cpp

Abstract: export functions which are required to enable the
          replication dll to be called from a WinNT service.

Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

#include "mq1repl.h"

#include "rpservc.tmh"

static  HANDLE       s_hRunEvent = NULL ;

//+------------------------------------------------
//
//  BOOL APIENTRY  InitReplicationService()
//
//+------------------------------------------------

BOOL APIENTRY  InitReplicationService()
{	
    //
    // Create event. used when initializing the receive threads.
    //
    HANDLE hInitEvent = CreateEvent( NULL,
                                     FALSE,
                                     FALSE,
                                     NULL ) ;
    if (!hInitEvent)
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_CREATE_EVENT,
                             GetLastError()) ;
        return FALSE ;
    }

    //
    // Create event. used when initializing the receive threads.
    //
    s_hRunEvent = CreateEvent( NULL,
                               FALSE,
                               FALSE,
                               NULL ) ;
    if (!s_hRunEvent)
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_CREATE_EVENT,
                             GetLastError()) ;
        return FALSE ;
    }

    //
    // Initialize masters data structures.
    //
    HRESULT hr = InitDirSyncService() ;
    if (FAILED(hr))
    {
        LogReplicationEvent(ReplLog_Error, MQSync_E_INIT_SYNC, hr) ;
        return FALSE ;
    }
	if (hr == MQSync_I_NO_SERVERS_RESULTS)
	{
		return FALSE;
	}

    //
    // Open the mqis replication private queue.
    //
    QUEUEHANDLE  hMyMQISQueue ;
    QUEUEHANDLE  hMyNt5PecQueue ;

    hr = InitQueues( &hMyMQISQueue, &hMyNt5PecQueue) ;
    if (FAILED(hr))
    {
        LogReplicationEvent( ReplLog_Error, MQSync_E_INIT_QUEUE, hr ) ;
        return  FALSE ;
    }

    ASSERT(hMyMQISQueue) ;
    ASSERT(hMyNt5PecQueue) ;

    DWORD dwID ;
    HANDLE hTimerThread = CreateThread( NULL,
                                        0,
                           (LPTHREAD_START_ROUTINE) ReplicationTimerThread,
                                       (LPVOID) NULL,
                                        0,
                                        &dwID ) ;
    if (hTimerThread == NULL)
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_TIMER_THREAD_NULL,
                             GetLastError() ) ;

        return FALSE ;
    }
    CloseHandle(hTimerThread) ;

    //
    // Create the dispatcher thread.
    //
    struct _DispatchThreadStruct sData = { hInitEvent,
                                           s_hRunEvent,
                                           hMyMQISQueue,
                                           hMyNt5PecQueue } ;

    dwID ;
    HANDLE hDispatcherThread = CreateThread( NULL,
                                             0,
                       (LPTHREAD_START_ROUTINE) RpServiceDispatcherThread,
                                             (LPVOID) &sData,
                                             0,
                                             &dwID ) ;
    if (hDispatcherThread == NULL)
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_DISPATCH_THREAD_NULL,
                             GetLastError() ) ;

        return FALSE ;
    }

    HANDLE hEvents[2] = { hInitEvent, hDispatcherThread } ;
    DWORD dwWait = WaitForMultipleObjects(  2,
                                            hEvents,
                                            FALSE,
                                            600000 ) ;
    CloseHandle(hInitEvent) ;
    if ((dwWait - WAIT_OBJECT_0) != 0)
    {
        //
        // Thread failed to initialized.
        //
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_DISPATCH_THREAD_INIT ) ;
        return FALSE ;
    }

    return TRUE ;
}

//+---------------------------------------------------
//
//  void APIENTRY  RunReplicationService()
//
//+---------------------------------------------------

void APIENTRY  RunReplicationService()
{
    ASSERT( s_hRunEvent ) ;
    RunMSMQ1Replication( s_hRunEvent ) ;
}

//+---------------------------------------------------
//
//  void APIENTRY  StopReplicationService()
//
//+---------------------------------------------------

void APIENTRY  StopReplicationService()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpsecutl.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpsecutl.cpp

Abstract: Security related code.


Author:

    Doron Juster  (DoronJ)   24-Mar-98

--*/

#include "mq1repl.h"

#include "rpsecutl.tmh"

static  PACL   s_pDacl = NULL ;
static  PSID   s_pWorldSid = NULL ;

//+------------------------------------------------------------------------
//
//  HRESULT RetrieveSecurityDescriptor()
//
//  This function retrieve the object security descriptor from NT5 DS
//  and convert it to NT4 compatible format. It allocate the memory for the
//  security descriptor.  The caller should free it.
//
//+------------------------------------------------------------------------

HRESULT RetrieveSecurityDescriptor( IN  DWORD        dwObjectType,
                                    IN  PLDAP        pLdap,
                                    IN  LDAPMessage *pRes,
                                    OUT DWORD       *pdwLen,
                                    OUT BYTE        **ppBuf )
{
    HRESULT hr = MQSync_E_CANT_GET_DN ;

    WCHAR **ppValue = ldap_get_values( pLdap,
                                       pRes,
                                       TEXT("distinguishedName") ) ;
    if (ppValue && *ppValue)
    {
        WCHAR *pwDName = *ppValue ;

        SECURITY_INFORMATION   SeInfo = MQSEC_SD_ALL_INFO ;

        BYTE      berValue[8];

        berValue[0] = 0x30;
        berValue[1] = 0x03;
        berValue[2] = 0x02;
        berValue[3] = 0x01;
        berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);

        LDAPControl     SeInfoControl =
                    {
                        L"1.2.840.113556.1.4.801",
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };
        LDAPControl *ppldapcSD[2] = {&SeInfoControl, NULL} ;

        PWSTR           rgAttribs[2] = {NULL, NULL} ;
        rgAttribs[0] = DSATTR_SD ;

        LM<LDAPMessage> pResSD = NULL ;

        ULONG ulRes = ldap_search_ext_s( pLdap,
                                         pwDName,
                                         LDAP_SCOPE_BASE,
                                         L"(objectclass=*)",
                                         rgAttribs,
                                         0,
                                         ppldapcSD,      // PLDAPControlW   *ServerControls,
                                         NULL,           // PLDAPControlW   *ClientControls,
                                         NULL,           // struct l_timeval  *timeout,
                                         0,              // ULONG             SizeLimit,
                                         &pResSD ) ;
        if (ulRes == LDAP_SUCCESS)
        {
            WCHAR *pAttr = DSATTR_SD ;
            berval **ppVal = ldap_get_values_len( pLdap,
                                                  pResSD,
                                                  pAttr ) ;
            if (ppVal)
            {
                SECURITY_DESCRIPTOR *pSD =
                             (SECURITY_DESCRIPTOR *) ((*ppVal)->bv_val) ;
                SECURITY_DESCRIPTOR_CONTROL SDControl ;
                DWORD                       dwRevision ;
                BOOL f = GetSecurityDescriptorControl( pSD,
                                                       &SDControl,
                                                       &dwRevision ) ;
                if (f)
                {
                    if (!(SDControl & SE_SELF_RELATIVE))
                    {
                        //
                        // conver to self relative ?
                        //
                        ASSERT(0) ;
                    }
                }
                else
                {
                    ASSERT(0) ;
                }

                hr = MQSec_ConvertSDToNT4Format(          dwObjectType,
                                 (SECURITY_DESCRIPTOR *) (*ppVal)->bv_val,
                                                          pdwLen,
                                 (SECURITY_DESCRIPTOR **) ppBuf ) ;
                ASSERT(SUCCEEDED(hr)) ;

                if (hr == MQSec_I_SD_CONV_NOT_NEEDED)
                {
                    //
                    // copy SD to ppBuf.
                    // this is an unexpected conditions. All SD should
                    // be retrieved from DS as NT5 format and converted
                    // to NT4 format.
                    //
                    ASSERT(0) ;

                    *pdwLen = (*ppVal)->bv_len ;
                    *ppBuf = new BYTE[ *pdwLen ] ;
                    memcpy ( *ppBuf,
                             (BYTE *) (*ppVal)->bv_val,
                             *pdwLen ) ;
                }

                int i = ldap_value_free_len( ppVal ) ;
                DBG_USED(i);
                ASSERT(i == LDAP_SUCCESS) ;
            }
            else
            {
                DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
                          "ERROR: Failed to retrieve SD (get_values)"))) ;

                hr = MQSync_E_CANT_GET_SD_VAL ;
            }
        }
        else
        {
            DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
             "ERROR: Failed to retrieve SD (search), ulRes- %lxh"), ulRes)) ;

            hr = MQSync_E_CANT_GET_SD_SEARCH ;
        }

        int i = ldap_value_free(ppValue) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;
    }
    else
    {
        DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
                             "ERROR: Failed to retrieve SD (get DN)"))) ;
    }

    return hr ;
}

//+----------------------------------
//
//   HRESULT  RpSetPrivilege()
//
//+----------------------------------

HRESULT  RpSetPrivilege( BOOL fSecurityPrivilege,
                         BOOL fRestorePrivilege,
                         BOOL fForceThread )
{
    HRESULT hr = MQSync_OK ;
    SetLastError(0) ;

    if ( fForceThread )
    {
        //
        // The "ImpersonateSelf()" is called to guarantee that only the
        // thread token is affected.
        //
        BOOL f = ImpersonateSelf( SecurityImpersonation ) ;
        if (!f)
        {
            return MQSync_E_IMPERSONATE_SELD ;
        }
    }

    if ( fSecurityPrivilege )
    {
        hr = MQSec_SetPrivilegeInThread( SE_SECURITY_NAME,
                                         TRUE ) ;
        if (FAILED(hr))
        {
            return hr ;
        }
    }

    if ( fRestorePrivilege )
    {
        hr = MQSec_SetPrivilegeInThread( SE_RESTORE_NAME,
                                         TRUE ) ;
        if (FAILED(hr))
        {
            return hr ;
        }
    }

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpseqnum.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpseqnum.cpp

Abstract: Code to handle seq numbers.

Author:

    Doron Juster  (DoronJ)   23-Mar-98

--*/

#include "mq1repl.h"

#include "rpseqnum.tmh"

//+-------------------------
//
//  void StringToSeqNum()
//
//+-------------------------

void StringToSeqNum( IN TCHAR    pszSeqNum[],
                     OUT CSeqNum *psn )
{
    BYTE *pSN = const_cast<BYTE*> (psn->GetPtr()) ;
    DWORD dwSize = psn->GetSerializeSize() ;
    ASSERT(dwSize == 8) ;

    WCHAR wszTmp[3] ;

    for ( DWORD j = 0 ; j < dwSize ; j++ )
    {
        memcpy(wszTmp, &pszSeqNum[ j * 2 ], (2 * sizeof(TCHAR))) ;
        wszTmp[2] = 0 ;

        DWORD dwTmp ;
        _stscanf(wszTmp, TEXT("%2x"), &dwTmp) ;
        *pSN = (BYTE) dwTmp ;
        pSN++ ;
    }
}

//+-------------------------
//
//  void i64ToSeqNum()
//
//+-------------------------

void i64ToSeqNum( IN  __int64 i64SeqNum,
                  OUT CSeqNum *psn )
{
    TCHAR wszSeq[ SEQ_NUM_BUF_LEN ] ;
    _stprintf(wszSeq, TEXT("%016I64x"), i64SeqNum) ;

    StringToSeqNum( wszSeq,
                    psn ) ;
}

//+-------------------------
//
//  void GetSNForReplication
//
//+-------------------------

void GetSNForReplication (IN  __int64 i64SeqNum,
                          IN  CDSMaster   *pMaster,
                          IN  GUID        *pNeighborId,  
                          OUT CSeqNum *psn )
{
    CSeqNum sn;
    if ( i64SeqNum )
    {                       
        i64ToSeqNum(i64SeqNum, &sn) ;
    }
    else
    {
        //
        // it is sync request about pre-migration object
        //
        ASSERT(i64SeqNum == 0) ;
        ASSERT(pNeighborId);
        
        SYNC_REQUEST_SNS *pSyncReqSNs;
        pSyncReqSNs = pMaster->GetSyncRequestSNs(pNeighborId); 
        ASSERT (pSyncReqSNs);
        sn = pSyncReqSNs->snFrom;

        ASSERT( sn < pSyncReqSNs->snTo );
        ASSERT(!sn.IsInfiniteLsn());  //if we are here sn must be finite number!          
        
        sn.Increment();
        pSyncReqSNs->snFrom = sn;
        pMaster->SetSyncRequestSNs (pNeighborId, pSyncReqSNs);
    }   
    *psn = sn;
}

//+-------------------------
//
//  void SeqNumToUsn()
//
//  Convert a MQIS seqnum to a DS usn, after subtracting the delta.
//  Return as string, decimal.
//
//+-------------------------

void SeqNumToUsn( IN CSeqNum    *psn,
                  IN __int64    i64Delta,
                  IN BOOL       fIsFromUsn,
                  OUT BOOL      *pfIsPreMig,                  
                  OUT TCHAR     *ptszUsn )
{        
    TCHAR wszSeq[ SEQ_NUM_BUF_LEN ] ;
    psn->GetValueForPrint(wszSeq) ;

    __int64 i64Seq = 0 ;
    _stscanf(wszSeq, TEXT("%I64x"), &i64Seq) ;
    
    //
    // in case of sync0 request *psn can be equal to 0 => i64Seq will be 0
    //
    if (!psn->IsSmallestValue())
    {
        ASSERT(i64Seq > 0) ;
    }

    i64Seq -= i64Delta ;
    ASSERT(i64Seq > 0) ;

    _stprintf(ptszUsn, TEXT("%I64d"), i64Seq) ;
    
    if (i64Seq < g_i64LastMigHighestUsn)
    {
        //
        // we got SN smaller than last highest migration USN        
        // It means that it is sync of pre-migration objects or sync0 request
        // but we know to answer only about SN greater than s_wszFirstHighestUsn        
        //
        *pfIsPreMig = TRUE;
        if (fIsFromUsn)
        {
            _stprintf(ptszUsn, TEXT("%I64d"), g_i64FirstMigHighestUsn) ;                       
        }
        else
        {
            _stprintf(ptszUsn, TEXT("%I64d"), g_i64LastMigHighestUsn) ;           
            //
            // we have to redefine upper limit of SN.
            // Upper limit is the first USN suitable for replication
            // of objects are changed after migration.
            // ToSN = LastHighestUsn + Delta
            //
            __int64 i64ToSN = g_i64LastMigHighestUsn ;            
            ASSERT(i64ToSN > 0) ;

            i64ToSN += i64Delta ;        
            i64ToSeqNum( i64ToSN, psn );
        }        
    }
}

//+-------------------------
//
//  HRESULT  SaveSeqNum()
//
//+-------------------------

HRESULT SaveSeqNum( IN CSeqNum     *psn,
                    IN CDSMaster   *pMaster,
                    IN BOOL         fInSN)
{
	try
	{
		GUID *pSiteGuid = const_cast<GUID *> ( pMaster->GetMasterId() ) ;

		unsigned short *lpszGuid ;
		UuidToString( pSiteGuid,
					  &lpszGuid ) ;

		TCHAR  tszSn[ SEQ_NUM_BUF_LEN ] ;
		psn->GetValueForPrint(tszSn) ;
    
		BOOL f;
		if (fInSN)
		{
			f = WritePrivateProfileString(  RECENT_SEQ_NUM_SECTION_IN,
											lpszGuid,
											tszSn,
											g_wszIniName ) ;
			ASSERT(f) ;
		}
		else
		{
			f = WritePrivateProfileString(  RECENT_SEQ_NUM_SECTION_OUT,
											lpszGuid,
											tszSn,
											g_wszIniName ) ;
			ASSERT(f) ;
		}

		RpcStringFree( &lpszGuid ) ;

		HRESULT hr = MQSync_OK;

		BOOL fNt4 = pMaster->GetNT4SiteFlag() ;
		if (!fNt4)
		{
			//
			// It's a NT5 master. Update the "purge" sn in the master object.
			// We need this for the proper operation of the "PrepareHello"
			// method. For NT5 servers, the NT5 DS handle purging of deleted
			// objects. We can't control it's purge algorithm. So we'll
			// arbitrarily set the "purge" number to equal (sn - PurgeBuffer).
			//
			pMaster->SetNt5PurgeSn() ;
		}
		else
		{
			//
			// change performance counter for NT4 master
			//
			LPTSTR pszName = pMaster->GetPathName();
			__int64 i64Seq = 0 ;
			_stscanf(tszSn, TEXT("%I64x"), &i64Seq) ;
			BOOL f;
			if (fInSN)
			{
				f = g_Counters.SetInstanceCounter(pszName, eLastSNIn, (DWORD) i64Seq);
			}
			else
			{
				f = g_Counters.SetInstanceCounter(pszName, eLastSNOut, (DWORD) i64Seq);
			}
		}
		return hr ;
	}
	catch(...)
	{
		//
		//  Not enough resources; try later
		//
		return(MQ_ERROR_INSUFFICIENT_RESOURCES);
	}    
}

//+-------------------------
//
// void IncrementUsn()
//
// Increment inplace.
//
//+-------------------------

void IncrementUsn(TCHAR tszUsn[])
{
    __int64 i64Usn = 0 ;
    _stscanf(tszUsn, TEXT("%I64d"), &i64Usn) ;
    ASSERT(i64Usn != 0) ;

    i64Usn++ ;
    _stprintf(tszUsn, TEXT("%I64d"), i64Usn) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpsettin.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpsettin.cpp

Abstract: looking for a new migrated site

Author:

    Doron Juster  (DoronJ)   25-Jun-98

--*/
#include "mq1repl.h"

#include <activeds.h>
#include "..\..\src\ds\h\mqattrib.h"
#include "..\..\src\ds\h\mqads.h"

#include "rpsettin.tmh"

//+-------------------------------------------------
//
//  HRESULT _HandleAMSMQSetting
//
//+-------------------------------------------------
HRESULT _HandleAMSMQSetting(
                PLDAP           pLdap,
                LDAPMessage    *pRes
                )
{
    //
    // If we fail right on start, we want to continue with replication
    // (YoelA & TatianaS - 8/18/99)
    //
    HRESULT hr = MQSync_OK;
    //
    // Get CN of msmq setting.
    //
    WCHAR **ppValue = ldap_get_values( pLdap,
                                       pRes,
                                       TEXT("cn") ) ;
    if (ppValue && *ppValue)
    {
        //
        // Get site GUID (our MSMQ ownerID).
        //
        berval **ppGuidVal = ldap_get_values_len( pLdap,
                                                  pRes,
                           const_cast<LPWSTR> (MQ_SET_MASTERID_ATTRIBUTE) ) ;
        ASSERT(ppGuidVal) ;

        if (ppGuidVal)
        {
            GUID *pSiteGuid = (GUID*) ((*ppGuidVal)->bv_val) ;
            hr = g_pMasterMgr->SetNT4SiteFlag (pSiteGuid, FALSE );
            //
            // we need to change something for this master in order to replace
            // PSC's machine name by PEC's name
            //
            PROPID      aSiteProp = PROPID_S_NT4_STUB;
            PROPVARIANT aSiteVar;
            aSiteVar.vt = VT_UI2;

            CDSRequestContext requestContext( e_DoNotImpersonate,
                                    e_ALL_PROTOCOLS);  // not relevant 

            hr = DSCoreGetProps (
                    MQDS_SITE,
                    NULL,
                    pSiteGuid,
                    1,
                    &aSiteProp,
                    &requestContext,
                    &aSiteVar
                    );

            if (FAILED(hr))
            {
               aSiteVar.uiVal  = 0;
            }

            PROPVARIANT tmpVar;
            tmpVar.vt = VT_UI2;
            tmpVar.uiVal  = 2;

            hr = DSCoreSetObjectProperties ( MQDS_SITE,
                                             NULL,
                                             pSiteGuid,
                                             1,
                                            &aSiteProp,
                                            &tmpVar,
                                            &requestContext,
                                             NULL ) ;

            hr = DSCoreSetObjectProperties ( MQDS_SITE,
                                             NULL,
                                             pSiteGuid,
                                             1,
                                            &aSiteProp,
                                            &aSiteVar,
                                            &requestContext,
                                             NULL ) ;

        }

        int i = ldap_value_free(ppValue) ;
        DBG_USED(i);
        ASSERT(i == LDAP_SUCCESS) ;
    }
    else
    {
        ASSERT(0) ;
    }

    return hr;
}

//+-------------------------------------------------
//
//  HRESULT CheckMSMQSetting()
//
//  Check if in the period after InitMasters if there are new Masters
//  that moved to NT5. If yes, reset NT4Site for that Master
//
//+-------------------------------------------------

HRESULT CheckMSMQSetting( TCHAR        *tszPrevUsn,
                          TCHAR        *tszCurrentUsn )
{
    int iCount = 0 ;
    LM<LDAPMessage> pRes = NULL ;

    HRESULT hr = QueryMSMQServerOnLDAP(
                       SERVICE_PSC,
                       0,           //we are looking for migrated PSC => msmqNT4Flags = 0
                       &pRes,
                       &iCount,
                       NULL,        //for all masters => MasterGuid = NULL
                       tszPrevUsn,
                       tszCurrentUsn
                       );

    if (FAILED(hr))
    {
        return hr ;
    }
    //
    // we can continue if query succeeded or 
    // returned warning MQSync_I_NO_SERVERS_RESULTS
    //
    
    if (iCount > 0)
    {
        ASSERT(pRes);
        //
        // there are new migrated PSCs, handle them
        //
        PLDAP pLdap = NULL ;
        hr =  InitLDAP(&pLdap) ;
        ASSERT(pLdap && SUCCEEDED(hr)) ;

        BOOL fFailed = FALSE ;
        LDAPMessage *pEntry = ldap_first_entry(pLdap, pRes) ;
        while(pEntry)
        {
            hr = _HandleAMSMQSetting(
			            pLdap,
			            pEntry
			            ) ;

            if (FAILED(hr))
            {
	            fFailed = TRUE ;
            }
            LDAPMessage *pPrevEntry = pEntry ;
            pEntry = ldap_next_entry(pLdap, pPrevEntry) ;
        }
    }

    //
    // We are here in any case: either there is new migrated PSC or there is no.
    // If there is new migrated PSC, we have to check: maybe this PSC was last NT4 PSC
    // and there is no BSC in PEC site, so replication service can exit.
    // But it is possible situation that Enterprise did not contain PSCs at all,
    // or all PSCs are already upgraded. It means, anyway we have to check 
    // if there is NT4 BSC in PEC site.
    //

    //
    // check if there is at least one NT4 PSC.
    // If no, delete replication service and exit process.
    //
    POSITION  pos = g_pMasterMgr->GetStartPosition();  
    while ( pos != NULL)
    {
        CDSMaster *pMaster = NULL;        
        g_pMasterMgr->GetNextMaster(&pos, &pMaster);
        if (pMaster->GetNT4SiteFlag () == TRUE)
        {
            //
            // there is at least one NT4 master in Enterprise
            // continue as usual
            //
            return hr;                                
        }            
    } 

    //
    // we are here iff there is no more NT4 Masters in Enterprise
    // we have to check if there is NT4 BSCs of PEC
    //	
    LM<LDAPMessage> pResBSC = NULL ;
    HRESULT hr1 = QueryMSMQServerOnLDAP( SERVICE_BSC,
                                         1,            // msmqNT4Flags = 1
                                         &pResBSC,
                                         &iCount,
                                         &g_MySiteMasterId,
                                         NULL,
                                         NULL) ;

    if (hr1 != MQSync_I_NO_SERVERS_RESULTS)
    {
        //
        // continue as usual: probably we have NT4 BSC
        // 
        return hr;
    }

    //
    // Enterprise does not contain NT4 PSCs and BSCs. 
    // We can delete replication service and exit process
    //
    DeleteReplicationService();

    ExitProcess (0);

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rptimer.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rptimer.cpp

Abstract: Timer thread which perform periodic tasks.
          (emulate the QM scheduler in MSMQ1.0. This scheduler was
           used by MQIS replication code).


Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

#include "mq1repl.h"

#include "rptimer.tmh"

//+-------------------------------------------------
//
//  HRESULT ReplicatePECObjects()
//
//  Replicate PEC objects (objects which traditionally are owned by
//  MSMQ1.0 PEC): sites, users
//
//+-------------------------------------------------

HRESULT ReplicatePECObjects( TCHAR        *tszPrevUsn,
                             TCHAR        *tszCurrentUsn,
                             CDSNeighbor  *pNeighbor,
                             HEAVY_REQUEST_PARAMS *pSyncRequestParams )
{
    if (!g_IsPEC)
    {
        return MQSync_OK ;
    }

    int iCount = 0 ;
    P<CDSUpdateList> pReplicationList = new CDSUpdateList(TRUE) ;
    GUID *pNeighborId = NULL;
    if (pNeighbor)
    {
        pNeighborId = const_cast<GUID *> (pNeighbor->GetMachineId());
    }

    HRESULT hr = ReplicateEnterprise (
                    tszPrevUsn,
                    tszCurrentUsn,
                    pReplicationList,
                    pNeighborId,
                    &iCount
                    );

    if (FAILED(hr))
    {
        ASSERT(iCount == 0) ;
        return hr ;
    }

    hr = ReplicateSiteLinks (
                tszPrevUsn,
                tszCurrentUsn,
                pReplicationList,
                pNeighborId,
                &iCount
                );

    if (FAILED(hr))
    {
        ASSERT(iCount == 0) ;
        return hr ;
    }

    hr = HandleSites( tszPrevUsn,
                      tszCurrentUsn,
                      pReplicationList,
                      pNeighborId,
                      &iCount ) ;
    if (FAILED(hr))
    {
        ASSERT(iCount == 0) ;
        return hr ;
    }

    hr = HandleDeletedSites( tszPrevUsn,
                             tszCurrentUsn,
                             pReplicationList,
                             pNeighborId,
                             &iCount ) ;

    if (FAILED(hr))
    {
        ASSERT(iCount == 0) ;
        return hr ;
    }

    //
    // Replicate User Objects
    //
    hr = ReplicateUsers (
            FALSE,
            tszPrevUsn,
            tszCurrentUsn,
            pReplicationList,
            pNeighborId,
            &iCount
            );

    if (FAILED(hr))
    {
        ASSERT(iCount == 0) ;
        return hr ;
    }    

    //
    // Replicate MQUser Objects
    //
    hr = ReplicateUsers (
            TRUE,
            tszPrevUsn,
            tszCurrentUsn,
            pReplicationList,
            pNeighborId,
            &iCount
            );

    if (FAILED(hr))
    {
        ASSERT(iCount == 0) ;
        return hr ;
    }    

    if (pNeighbor && g_pThePecMaster->GetSyncRequestSNs (pNeighborId) )    
    {
        //
        // we got sync request about pre-migration objects
        // it is opportunity to send all CN objects
        //
        hr = ReplicateCNs (                
                pReplicationList,
                pNeighborId,
                &iCount
                );

        if (FAILED(hr))
        {
            ASSERT(iCount == 0) ;
            return hr ;
        }
    }

    if (iCount > 0  ||  // there were changes in DS
        pNeighbor )     // we was asked for SyncRequest, so we have to send
                        // SyncReply message in any case
    {        
        g_Counters.AddToCounter(eReplObj, iCount);

        hr = g_pNeighborMgr->CommitReplication( g_pThePecMaster,
                                                pReplicationList,
                                                pNeighbor,
                                                pSyncRequestParams ) ;
        if ( pNeighbor && g_pThePecMaster->GetSyncRequestSNs (pNeighborId) )
        {
            g_pThePecMaster->RemoveSyncRequestSNs (pNeighborId);            
        }
    }

    return hr ;
}

//+-------------------------------------------------------------
//
//  HRESULT ReplicateSitesObjects()
//
//+-------------------------------------------------------------

HRESULT ReplicateSitesObjects(   CDSMaster    *pMaster,
                                 TCHAR        *tszPrevUsn,
                                 TCHAR        *tszCurrentUsn,
                                 CDSNeighbor  *pNeighbor,
                                 HEAVY_REQUEST_PARAMS *pSyncRequestParams,
                                 BOOL          fReplicateNoID,
                                 UINT          uiFlush)
{
    //
    // This list is built during replication query. All updates are
    // accumulated here. When query terminate, updates are sorted
    // according to seq number and propagated to all neighbors.
    //
    P<CDSUpdateList> pReplicationList = new CDSUpdateList(TRUE) ;
    GUID *pNeighborId = NULL;
    if (pNeighbor)
    {
        pNeighborId = const_cast<GUID *> (pNeighbor->GetMachineId());
    }

    int iCount = 0 ;

    HRESULT hr = ReplicateQueues( tszPrevUsn,
                                  tszCurrentUsn,
                                  pMaster,
                                  pReplicationList,
                                  pNeighborId,
                                  &iCount,
                                  fReplicateNoID ) ;
    if (FAILED(hr))
    {
        ASSERT(iCount == 0) ;
        return hr ;
    }

    hr = ReplicateMachines(
              tszPrevUsn,
              tszCurrentUsn,
              pMaster,
              pReplicationList,
              pNeighborId,
              &iCount,
              fReplicateNoID
              ) ;

    if (FAILED(hr))
    {
        ASSERT(iCount == 0) ;
        return hr ;
    }

    if (iCount > 0  ||  // there were changes in DS
        pNeighbor )     // we was asked for SyncRequest, so we have to send
                        // SyncReply message in any case
    {        
        g_Counters.AddToCounter(eReplObj, iCount);

        hr = g_pNeighborMgr->CommitReplication( pMaster,
                                                pReplicationList,
                                                pNeighbor,
                                                pSyncRequestParams,
                                                uiFlush) ;
        if ( pNeighbor && pMaster->GetSyncRequestSNs (pNeighborId) )
        {
            pMaster->RemoveSyncRequestSNs (pNeighborId);            
        }         
    }

    return hr ;
}

//+-------------------------------------------------------------
//
//  HRESULT ReplicationAfterRecovery ()
//
//+-------------------------------------------------------------

HRESULT ReplicationAfterRecovery ()
{
    HRESULT hr = MQSync_OK ;

    TCHAR tszToUsn[ 36 ] ;
    tszToUsn[0] = TEXT('\0') ;

    TCHAR tszFromUsn[ 36 ] ;
    tszFromUsn[0] = TEXT('\0') ;

    _stprintf(tszFromUsn, TEXT("%I64d"), g_i64FirstMigHighestUsn) ;
    _stprintf(tszToUsn, TEXT("%I64d"), g_i64LastMigHighestUsn) ;

    //
    // we create sync0 situation. It means, that FromSN is Zero
    // and ToSN = the first USN suitable for replication
    // of objects are changed after migration.
    // ToSN = LastHighestUsn + Delta    
    //    
    CSeqNum snFrom, snTo;
    snFrom.SetSmallestValue();

    HEAVY_REQUEST_PARAMS SyncRequestParams;      

    SyncRequestParams.dwType = SCHED_SYNC_REPLY;
    SyncRequestParams.snFrom = snFrom;    
    SyncRequestParams.bIsSync0 = FALSE;
    SyncRequestParams.bScope = ENTERPRISE_SCOPE_FLAG;

    POSITION  pos = g_pNeighborMgr->GetStartPosition();
    while ( pos != NULL)
    {
        CDSNeighbor  *pNeighbor = NULL ;     
        g_pNeighborMgr->GetNextNeighbor(&pos, &pNeighbor);
        
        __int64 i64ToSN = g_i64LastMigHighestUsn ;            
        ASSERT(i64ToSN > 0) ;

        i64ToSN += g_pThePecMaster->GetDelta() ;        
        i64ToSeqNum( i64ToSN, &snTo );

        SyncRequestParams.pwszRequesterName = 
                const_cast<LPWSTR> (g_pNeighborMgr->GetName(pNeighbor));

        SyncRequestParams.guidSourceMasterId = g_PecGuid;
        SyncRequestParams.snTo = snTo;        

        SYNC_REQUEST_SNS *pSyncReqSNs = new SYNC_REQUEST_SNS;
        pSyncReqSNs->snFrom = snFrom;
        pSyncReqSNs->snTo = snTo;       
        g_pThePecMaster->SetSyncRequestSNs (pNeighbor->GetMachineId(), pSyncReqSNs);
        
        hr = ReplicatePECObjects(
                         tszFromUsn, 
                         tszToUsn,
                         pNeighbor,
                         &SyncRequestParams
                         );

        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
                       "Replication of PEC objects failed, hr- %lxh"), hr)) ;
    
        }

        //
        // loop for each site with fNT4SiteFlag = FALSE
        //   
        POSITION  posMaster = g_pMasterMgr->GetStartPosition();
        while ( posMaster != NULL)
        {
            CDSMaster *pMaster = NULL;        
            g_pMasterMgr->GetNextMaster(&posMaster, &pMaster);
            if (pMaster->GetNT4SiteFlag () == FALSE)
            {            
                i64ToSN = g_i64LastMigHighestUsn ;            
                ASSERT(i64ToSN > 0) ;

                i64ToSN += pMaster->GetDelta() ;        
                i64ToSeqNum( i64ToSN, &snTo );

                SyncRequestParams.guidSourceMasterId = * (pMaster->GetMasterId());
                SyncRequestParams.snTo = snTo;

                BOOL fReplicateNoId = (pMaster == g_pMySiteMaster);                

                SYNC_REQUEST_SNS *pSyncReqSNs = new SYNC_REQUEST_SNS;
                pSyncReqSNs->snFrom = snFrom;
                pSyncReqSNs->snTo = snTo;  
                pMaster->SetSyncRequestSNs (pNeighbor->GetMachineId(), pSyncReqSNs);

                HRESULT hr1 = ReplicateSitesObjects( pMaster,
                                                     tszFromUsn,
                                                     tszToUsn,
                                                     pNeighbor,
                                                     &SyncRequestParams,
                                                     fReplicateNoId
                                                    ) ;
                if (FAILED(hr1))
                {                
                    const GUID *pGuid = pMaster->GetMasterId();
                    unsigned short *lpszGuid ;
                    UuidToString( const_cast<GUID *>(pGuid), &lpszGuid ) ;       
                
                    DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
                       "Site- %ls. Replication of sites objects failed, hr- %lxh"), lpszGuid, hr)) ;
                    RpcStringFree( &lpszGuid ) ;
                
                    //
                    // continue with the next site and save error code
                    //
                    hr = hr1;

                }
            }
        }   // end while (pMaster)
        
    } // end while (pNeighbor)

    return hr;
}

//+---------------------------------------------
//
//  static HRESULT _DoReplicationCycle()
//
//  Arguments: tszPrevUsn- in/out parameter.
//       On input, This is the highest usn value used in previous replication
//       cycle.
//       On out, this is the current highest usn value used in present cycle.
//
//  if dwSendHelloMsgOnly equals to 0 we have to send both hello and replication messages
//  otherwise we have to send only Hello Message
//
//+---------------------------------------------

static HRESULT _DoReplicationCycle(IN   OUT TCHAR   *tszPrevUsn,
                                   IN   DWORD       dwSendHelloMsgOnly,    
                                   OUT  BOOL        *pfSendReplMsg)
{
    HRESULT hr;
      
	*pfSendReplMsg = FALSE;

    if(dwSendHelloMsgOnly)
    {
        //
        // Send Hello Message Only
        //
        hr = g_pNeighborMgr->Flush(DS_FLUSH_TO_ALL_NEIGHBORS);
        if (FAILED(hr))
        {
            LogReplicationEvent( ReplLog_Error,
                                 MQSync_E_SEND_HELLO,
                                 hr) ;
            // what to do?
            //return hr ;
            g_Counters.IncrementCounter(eErrorHelloSent);
        }
        return MQSync_OK;
    }
    
    //
    // if there are changes, the hello message will be sent together 
    // with replication message; otherwise we have to send Hello and return
    //
    TCHAR tszCurrentUsn[ 36 ] ;
    tszCurrentUsn[0] = TEXT('\0') ;

    hr =  ReadDSHighestUSN( tszCurrentUsn ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    ASSERT(_tcslen(tszCurrentUsn) > 1) ;
    if (_tcsicmp(tszCurrentUsn, tszPrevUsn) == 0)
    {
        //
        // Nothing changed. Send Hello
        //
        hr = g_pNeighborMgr->Flush(DS_FLUSH_TO_ALL_NEIGHBORS);
        if (FAILED(hr))
        {
            LogReplicationEvent( ReplLog_Error,
                                 MQSync_E_SEND_HELLO,
                                 hr) ;
            // what to do?
            //return hr ;
            g_Counters.IncrementCounter(eErrorHelloSent);
        }
        return MQSync_OK ;
    }

    *pfSendReplMsg = TRUE;  // we'll try to send replication message

    //
    // Increment tszPrev before using it. This is because
    // ldap queries can use only >=. Present value of "prev" was
    // already handled in previous queries, so increment it now.
    //
    IncrementUsn(tszPrevUsn) ;
    
    //
    // check how many objects we have to replicate
    // if the count is more than QUOTA_TO_REPLICATE
    // decrease the current USN
    //
    __int64 i64CurrentSeq = 0 ;
    _stscanf(tszCurrentUsn, TEXT("%I64d"), &i64CurrentSeq) ;    
    __int64 i64PrevSeq = 0 ;
    _stscanf(tszPrevUsn, TEXT("%I64d"), &i64PrevSeq) ;

    LogReplicationEvent( ReplLog_Trace,
                         MQSync_I_START_REPL_CYCLE,
                         tszPrevUsn,
                         tszCurrentUsn ) ;

    hr = CheckMSMQSetting(tszPrevUsn, tszCurrentUsn) ;
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
                   "Check MSMQSetting failed, hr- %lxh"), hr)) ;

        return hr ;
    }

    hr = ReplicatePECObjects(tszPrevUsn, tszCurrentUsn) ;
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
                   "Replication of PEC objects failed, hr- %lxh"), hr)) ;

        return hr ;
    }

    //
    // loop for each site with fNT4SiteFlag = FALSE
    //   
    POSITION  pos = g_pMasterMgr->GetStartPosition();
    while ( pos != NULL)
    {
        CDSMaster *pMaster = NULL;        
        g_pMasterMgr->GetNextMaster(&pos, &pMaster);
        if (pMaster->GetNT4SiteFlag () == FALSE)
        {            
            BOOL fReplicateNoId = (pMaster == g_pMySiteMaster);
            HRESULT hr1 = ReplicateSitesObjects( pMaster,
                                                 tszPrevUsn,
                                                 tszCurrentUsn,
                                                 NULL,
                                                 NULL,
                                                 fReplicateNoId
                                                ) ;
            if (FAILED(hr1))
            {                
                const GUID *pGuid = pMaster->GetMasterId();
                unsigned short *lpszGuid ;
                UuidToString( const_cast<GUID *>(pGuid), &lpszGuid ) ;       
                
                DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
                   "Site- %ls. Replication of sites objects failed, hr- %lxh"), lpszGuid, hr)) ;
                RpcStringFree( &lpszGuid ) ;
                
                //
                // continue with the next site and save error code
                //
                hr = hr1;

            }
        } 
        else if (g_fBSCExists)
        {
            //
            // replicate NT4 master to BSCs
            //
            HRESULT hr1 = ReplicateSitesObjects(  pMaster,
                                                  tszPrevUsn,
                                                  tszCurrentUsn,
                                                  NULL,
                                                  NULL,
                                                  FALSE,
                                                  DS_FLUSH_TO_BSCS_ONLY 
                                                ) ;
            if (FAILED(hr1))
            {                
                const GUID *pGuid = pMaster->GetMasterId();
                unsigned short *lpszGuid ;
                UuidToString( const_cast<GUID *>(pGuid), &lpszGuid ) ;       
                
                DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
                   "Site- %ls. Replication of sites objects failed, hr- %lxh"), lpszGuid, hr)) ;
                RpcStringFree( &lpszGuid ) ;
                
                //
                // continue with the next site and save error code
                //
                hr = hr1;

            }
        }
    }

    LogReplicationEvent( ReplLog_Trace,
                         MQSync_I_END_REPL_CYCLE,
                         tszPrevUsn,
                         tszCurrentUsn ) ;

    _tcscpy(tszPrevUsn, tszCurrentUsn) ;
    DWORD dwSize = _tcslen(tszPrevUsn) * sizeof(TCHAR) ;
    DWORD dwType = REG_SZ;

    LONG rc = SetFalconKeyValue( HIGHESTUSN_REPL_REG,
                                 &dwType,
                                 tszPrevUsn,
                                 &dwSize ) ;
    UNREFERENCED_PARAMETER(rc);

    return hr ;
}

//+-------------------------------------------------------
//
//  DWORD WINAPI  ReplicationTimerThread(LPVOID lpV)
//
//  This thread is created after initialization is completed.
//  It periodically query the local NT5 DS and replicates changes
//  to MSMQ1.0 MQIS servers.
//
//+-------------------------------------------------------

DWORD WINAPI  ReplicationTimerThread(LPVOID lpV)
{
    //
    // Grant myself the privilege to handle SACLs in a security descriptor.
    //
    HRESULT hr = RpSetPrivilege( TRUE,     // fSecurityPrivilege,
                                 FALSE,    // fRestorePrivilege,
                                 TRUE ) ;  // fForceThread )
    if (FAILED(hr))
    {
        DWORD dwErr = GetLastError() ;
        ASSERT(FALSE) ;
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_SET_PRIV,
                             hr, dwErr, dwErr ) ;

        return hr ;
    }

    TCHAR tszPrevUsn[ SEQ_NUM_BUF_LEN ] ;
    //
    // Read last USN we handled (at present, we read it from registry).
    //
    DWORD dwSize = sizeof(tszPrevUsn) / sizeof(tszPrevUsn[0]) ;
    DWORD dwType = REG_SZ;

    LONG rc = GetFalconKeyValue( HIGHESTUSN_REPL_REG,
                                 &dwType,
                                 tszPrevUsn,
                                 &dwSize ) ;
    if (rc != ERROR_SUCCESS)
    {
        DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR,
                        TEXT("ERROR: _GetKey(%ls) failed, rc=%lu"), HIGHESTUSN_REPL_REG, rc)) ;
        return MQSync_E_REG_HIGHUSN_RPEL ;
    }

    DBGMSG((DBGMOD_REPLSERV, DBGLVL_TRACE,
           TEXT("Starting the timer thread, last usn- %ls"), tszPrevUsn)) ;

    NOT_YET_IMPLEMENTED(TEXT("Replicate other sites to my BSCs"), s_fBSCs) ;

    DWORD dwTimesHello = g_dwReplicationInterval / g_dwHelloInterval;
    DWORD dwCount = 0;

    //
    // the first thing is to handle "after-recovery" situation
    //
    if (g_fAfterRecovery)
    {
        hr = ReplicationAfterRecovery ();
        g_fAfterRecovery = FALSE;
        DeleteFalconKeyValue(AFTER_RECOVERY_MIG_REG);                  
    }
   
    BOOL fSendReplMsg = FALSE;
    while(TRUE)
    {
        HRESULT hr = _DoReplicationCycle(
							tszPrevUsn, 
							dwCount, 
							&fSendReplMsg) ;

        if (SUCCEEDED(hr))
        {
            //
            // If number of changes in DS is more than quota_to_replicate 
            // next cycle will start after g_dwHelloInterval / 2 interval.
            //
            if (fSendReplMsg)
            {
                g_Counters.IncrementCounter(eReplSent);
            }
            else
            {
                //we sent hello message only
                g_Counters.IncrementCounter(eHelloSent);                
            }
            
			Sleep(g_dwHelloInterval) ;

            dwCount++;
            if (dwCount >= dwTimesHello)
            {
                dwCount = 0;
            }            
        }
        else
        {
            //
            // This replication cycle failed. Try again later.
            //

            //
            // BUGBUG: IncrementCounter for Hello Message called from DoReplicationCycle
            // since we don't return error if we failed to send hello message.
            // So, we are here only if replication message sending failed.
            //
            g_Counters.IncrementCounter(eErrorReplSent);
            DBGMSG((DBGMOD_REPLSERV, DBGLVL_ERROR, TEXT(
                                  "Replication failed, hr- %lxh"), hr)) ;

            Sleep(g_dwFailureReplInterval) ;
        }
    }

    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rptempl.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    rptempl.h

Abstract:
    Useful templates for Auto pointer and auto Release

Author:
    Erez Haba    (erezh)   11-Mar-96
    Doron Juster (DoronJ)  30-June-98

Revision History:
--*/

#ifndef _RPTEMPL_H
#define _RPTEMPL_H

//
//  return type for 'identifier::operator >' is not a UDT or reference to a UDT.
//  Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)

#include <winldap.h>
//-----------------------------
//
//  Auto relese LDAP message.
//
//-----------------------------

template<class T>
class LM {
private:
    T* m_p;

public:
    LM()     : m_p(NULL)     {}
    LM(T* p) : m_p(p)        {}
   ~LM()                     { if(m_p) ldap_msgfree(m_p) ; }

    operator T*() const     { return m_p; }
    T** operator&()         { return &m_p;}
    T* operator->() const   { return m_p; }
    LM<T>& operator=(T* p)  { m_p = p; return *this; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
};

//-----------------------------
//
//  Auto relese LDAP Page handle.
//
//-----------------------------
class CLdapPageHandle {
private:
    PLDAPSearch	m_p;
	PLDAP		m_pLdap;

public:
    CLdapPageHandle(PLDAP pLdap) : m_p(NULL), m_pLdap(pLdap)     {}
    CLdapPageHandle(PLDAPSearch p, PLDAP pLdap)	: m_p(p), m_pLdap(pLdap) {}
    ~CLdapPageHandle()                     
    {
	   if(m_p) ldap_search_abandon_page(m_pLdap, m_p);
    }

    operator PLDAPSearch() const     { return m_p; }
	CLdapPageHandle & operator=(PLDAPSearch p)  { m_p = p; return *this; }  
};

//-----------------------------
//
//  Auto relese Handle.
//
//-----------------------------
class CServiceHandle
{
public:
    explicit CServiceHandle(SC_HANDLE h = NULL) { m_h = h; };
    ~CServiceHandle() { if (m_h) CloseServiceHandle(m_h); };

    operator SC_HANDLE() const { return m_h; };
    //CServiceHandle& operator=(SC_HANDLE h)   { m_h = h; return *this; }

private:
    //
    // Prevent copy
    //
    CServiceHandle(const CServiceHandle & );
    CServiceHandle& operator=(const CServiceHandle &);

private:
    SC_HANDLE m_h;

}; //CServiceHandle

#endif // _RPTEMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\stdh.cpp ===
//
// File:  stdh.cpp
//

#include "mq1repl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rputils.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rputils.cpp

Abstract: Utility code.


Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

#include "mq1repl.h"

#include "rputils.tmh"

/*====================================================

CalHashKey()

Arguments:

Return Value:

=====================================================*/

DWORD CalHashKey( IN LPCWSTR pwcsPathName )
{
    ASSERT( pwcsPathName ) ;

    DWORD   dwHashKey = 0;
    WCHAR * pwcsTmp;

    AP<WCHAR> pwcsUpper = new WCHAR[ lstrlen(pwcsPathName) + 1];
    lstrcpy( pwcsUpper, pwcsPathName);
    CharUpper( pwcsUpper);
    pwcsTmp = pwcsUpper;


    while (*pwcsTmp)
        dwHashKey = (dwHashKey<<5) + dwHashKey + *pwcsTmp++;

    return(dwHashKey);
}

//+---------------------------------
//
//  HRESULT  InitEnterpriseID()
//
//+---------------------------------

HRESULT  InitEnterpriseID()
{
    PROPVARIANT PecResult[ 4];
    DWORD       dwPecProps = 4;
    HANDLE      hQuery = NULL ;
    CColumns    ColsetPec;

    //
    //  query the Enterprise table and get the PEC name and enterprise guid.
    //
    ColsetPec.Add( PROPID_E_NAME );
    ColsetPec.Add( PROPID_E_ID );

    CDSRequestContext requestContext( e_DoNotImpersonate,
                                e_ALL_PROTOCOLS);  // not relevant

    HRESULT hr = DSCoreLookupBegin( 0,
                                NULL,
                                ColsetPec.CastToStruct(),
                                0,
                                &requestContext,
                                &hQuery ) ;
    if (FAILED(hr))
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_INIT_ENTERID,
                             hr ) ;
        return hr ;
    }
    ASSERT(hQuery) ;


    hr = DSCoreLookupNext( hQuery, &dwPecProps, PecResult ) ;
    if (SUCCEEDED(hr))
    {
        if (dwPecProps)
        {
            //
            //  Keep The enterprise Id ( it is part of mqis messages )
            //
            g_guidEnterpriseId = *PecResult[1].puuid;
            delete PecResult[1].puuid;

#ifdef _DEBUG
            unsigned short *lpszGuid ;
            UuidToString( const_cast<GUID*> (&g_guidEnterpriseId),
                          &lpszGuid ) ;

            LogReplicationEvent( ReplLog_Trace,
                                 MQSync_I_INIT_ENTERID,
                                 PecResult[0].pwszVal,
                                 lpszGuid ) ;

            RpcStringFree( &lpszGuid ) ;
#endif
            delete PecResult[0].pwszVal ;
        }
        else
        {
            return MQSync_E_PEC_GUID_QUERY ;
        }
    }
    else
    {
        return hr ;
    }

    //
    // close the query handle
    //
    hr = DSCoreLookupEnd( hQuery );
    ASSERT(SUCCEEDED(hr)) ;

    return MQSync_OK ;
}

//+-----------------------------
//
//  GetMQISQueueName()
//
//+-----------------------------

HRESULT  GetMQISQueueName( WCHAR **ppwQueueFormatName,
                           BOOL    fDirect,
                           BOOL    fPecQueue )
{
    WCHAR *pQueueName = MQIS_QUEUE_NAME ;
    if (fPecQueue)
    {
        pQueueName = NT5PEC_QUEUE_NAME ;
    }

    WCHAR *pwszGuid = NULL ;
    DWORD LenMachine = 0 ;

    DWORD Length = 2 ; // '=' + '\'

    if (fDirect)
    {
        LenMachine = wcslen(g_pwszMyMachineName) ;

        Length += FN_DIRECT_TOKEN_LEN;
        Length += FN_DIRECT_OS_TOKEN_LEN;
        Length += LenMachine ;
        Length += lstrlen(pQueueName) +1 ;
    }
    else
    {
        Length += FN_PRIVATE_TOKEN_LEN;
        RPC_STATUS status = UuidToString( &g_guidMyQMId,
                                          &pwszGuid ) ;
        if (status != RPC_S_OK)
        {
            return MQSync_E_GUID_STR ;
        }
        Length += wcslen(pwszGuid) + 1 ;
    }

    P<WCHAR> lpwFormatName = new WCHAR[ Length + 4 ];

    WCHAR pNum[2] = {0,0} ;
    if (fDirect)
    {
        pNum[0] = PN_DELIMITER_C ;

        wcscpy(lpwFormatName, FN_DIRECT_TOKEN);
        wcscat(lpwFormatName, FN_EQUAL_SIGN);
        wcscat(lpwFormatName, FN_DIRECT_OS_TOKEN);
        wcscat(lpwFormatName, g_pwszMyMachineName);
        wcscat(lpwFormatName, pNum) ;
        wcscat(lpwFormatName, pQueueName);
    }
    else
    {
        if (fPecQueue)
        {
            pNum[0] = L'0' + NT5PEC_REPLICATION_QUEUE_ID ;
        }
        else
        {
            pNum[0] = L'0' + REPLICATION_QUEUE_ID ;
        }

        wcscpy(lpwFormatName, FN_PRIVATE_TOKEN);
        wcscat(lpwFormatName, FN_EQUAL_SIGN);
        wcscat(lpwFormatName, pwszGuid) ;
        wcscat(lpwFormatName, FN_PRIVATE_SEPERATOR) ;
        wcscat(lpwFormatName, pNum) ;

        RpcStringFree( &pwszGuid ) ;
    }

    *ppwQueueFormatName = lpwFormatName.detach();

    return MQSync_OK ;
}


//+-----------------------------
//
//  GetMQISAdminQueueName()
//
//+-----------------------------

HRESULT  GetMQISAdminQueueName(
              WCHAR **ppwQueueFormatName
                               )
{
    WCHAR *pQueueName = MQIS_QUEUE_NAME ;

    static DWORD s_LenMachine = 0 ;

    DWORD Length = 1 ; //  '\'

    //
    //  Always prepares direct format
    //
    if ( s_LenMachine == 0)
    {
        s_LenMachine = wcslen(g_pwszMyMachineName) ;
    }

    Length += FN_DIRECT_OS_TOKEN_LEN;
    Length += s_LenMachine ;
    Length += lstrlen(pQueueName) +1 ;

    AP<WCHAR> lpwFormatName = new WCHAR[ Length + 4 ];
    WCHAR pNum[2] = {PN_DELIMITER_C,0} ;

    wcscpy(lpwFormatName, FN_DIRECT_OS_TOKEN);
    wcscat(lpwFormatName, g_pwszMyMachineName);
    wcscat(lpwFormatName, pNum) ;
    wcscat(lpwFormatName, pQueueName);

    *ppwQueueFormatName = lpwFormatName.detach() ;

    return MQSync_OK ;
}

//+----------------------------------
//
//  void ReadReplicationTimes()
//
//+----------------------------------

void ReadReplicationTimes()
{
    //
    // Read timeout value for replication message. keep in seconds.
    //
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType = REG_DWORD;
    DWORD dwDefault = RP_DEFAULT_REPL_MSG_TIMEOUT ;
    LONG rc = GetFalconKeyValue( RP_REPL_MSG_TIMEOUT_REGNAME,
                                 &dwType,
                                 &g_dwReplicationMsgTimeout,
                                 &dwSize,
                                 (LPCTSTR) &dwDefault );
    if (rc != ERROR_SUCCESS)
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_READ_MSG_TIMEOUT,
                             rc ) ;

        g_dwReplicationMsgTimeout = RP_DEFAULT_REPL_MSG_TIMEOUT ;
    }

    //
    // Read the hello interval.
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    dwDefault = RP_DEFAULT_HELLO_INTERVAL ;
    rc = GetFalconKeyValue( RP_HELLO_INTERVAL_REGNAME,
                            &dwType,
                            &g_dwHelloInterval,
                            &dwSize,
                            (LPCTSTR) &dwDefault );
    if (rc != ERROR_SUCCESS)
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_READ_HELLO_INTERVAL,
                             rc ) ;

        g_dwHelloInterval = RP_DEFAULT_HELLO_INTERVAL ;
    }
    g_dwHelloInterval *= 1000 ; // turn to milliseconds.

    //
    // ReplicationInterval = HelloInterval * TimesHello
    // Read TimesHello
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    dwDefault = RP_DEFAULT_TIMES_HELLO ;
    DWORD dwTimesHello;
    rc = GetFalconKeyValue( RP_TIMES_HELLO_FOR_REPLICATION_INTERVAL_REGNAME,
                            &dwType,
                            &dwTimesHello,
                            &dwSize,
                            (LPCTSTR) &dwDefault );
    if (rc != ERROR_SUCCESS)
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_READ_TIMES_HELLO,
                             rc ) ;

        dwTimesHello = RP_DEFAULT_TIMES_HELLO ;
    }
    g_dwReplicationInterval = g_dwHelloInterval * dwTimesHello;

    //
    // read failure interval and keep it in milliseconds.
    // In case of replication failure, we'll wait this interval
    // until next replication cycle. Failure here mean failing to query
    // local DS, not failure in communication to other PSCs.
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    dwDefault = RP_DEFAULT_FAIL_REPL_INTERVAL ;
    rc = GetFalconKeyValue( RP_FAIL_REPL_INTERVAL_REGNAME,
                            &dwType,
                            &g_dwFailureReplInterval,
                            &dwSize,
                            (LPCTSTR) &dwDefault);
    if (rc != ERROR_SUCCESS)
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_READ_FAIL_REPL_INTERVAL,
                             rc ) ;

        g_dwFailureReplInterval = RP_DEFAULT_FAIL_REPL_INTERVAL ;
    }
    g_dwFailureReplInterval *= 1000 ; // convert to milliseconds

    LogReplicationEvent( ReplLog_Info,
                             MQSync_I_REPLICATION_TIMES,
                             g_dwHelloInterval,
                             g_dwReplicationInterval,
                             g_dwFailureReplInterval ) ;
    //
    // Read the purge buffer
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    dwDefault = RP_DEFAULT_PURGE_BUFFER ;
    rc = GetFalconKeyValue( RP_PURGE_BUFFER_REGNAME,
                            &dwType,
                            &g_dwPurgeBufferSN,
                            &dwSize,
                            (LPCTSTR) &dwDefault );
    if (rc != ERROR_SUCCESS)
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_READ_PURGE_BUFFER,
                             rc ) ;

        g_dwPurgeBufferSN = RP_DEFAULT_PURGE_BUFFER ;
    }
    //
    // Read PSC Ack Frequency SN
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    dwDefault = RP_DEFAULT_PSC_ACK_FREQUENCY ;
    rc = GetFalconKeyValue( RP_PSC_ACK_FREQUENCY_REGNAME,
                            &dwType,
                            &g_dwPSCAckFrequencySN,
                            &dwSize,
                            (LPCTSTR) &dwDefault );
    if (rc != ERROR_SUCCESS)
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_READ_PSC_ACK_FREQUENCY,
                             rc ) ;

        g_dwPSCAckFrequencySN = RP_DEFAULT_PSC_ACK_FREQUENCY ;
    }

    //
    // Read number of objects per ldap page
    //
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    dwDefault = RP_DEFAULT_OBJECT_PER_LDAPPAGE ;
    rc = GetFalconKeyValue( RP_OBJECT_PER_LDAPPAGE_REGNAME,
                            &dwType,
                            &g_dwObjectPerLdapPage,
                            &dwSize,
                            (LPCTSTR) &dwDefault );
    if (rc != ERROR_SUCCESS)
    {
        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_READ_OBJECT_PER_LDAPPAGE,
                             rc ) ;

        g_dwObjectPerLdapPage = RP_DEFAULT_OBJECT_PER_LDAPPAGE ;
    }
}


BOOL IsForeignSiteInIniFile(IN   GUID ObjectGuid)
{
    unsigned short *lpszGuid ;
    UuidToString( &ObjectGuid, &lpszGuid ) ;

    TCHAR szValue[50];
    DWORD dwRetSize;
    dwRetSize =  GetPrivateProfileString(
                      MIGRATION_FOREIGN_SECTION,     // points to section name
                      lpszGuid,                 // points to key name
                      TEXT(""),                 // points to default string
                      szValue,                  // points to destination buffer
                      50,                       // size of destination buffer
                      g_wszIniName              // points to initialization filename);
                      );

    RpcStringFree( &lpszGuid ) ;

    if (_tcscmp(szValue, TEXT("")) == 0)
    {
        //
        // the entry does not exist
        //
        return FALSE;
    }

    return TRUE;
}

void AddToIniFile (IN   GUID ObjectGuid)
{
    ULONG ulForeignCount = GetPrivateProfileInt(
                                  MIGRATION_FOREIGN_CNNUM_SECTION,// address of section name
                                  MIGRATION_CNNUM_KEY,      // address of key name
                                  0,                        // return value if key name is not found
                                  g_wszIniName              // address of initialization filename);
                                  );
    ulForeignCount++;

    unsigned short *lpszGuid ;
    UuidToString( &ObjectGuid, &lpszGuid ) ;

    TCHAR tszKeyName[50];
    _stprintf(tszKeyName, TEXT("%s%lu"), MIGRATION_CN_KEY, ulForeignCount);
    BOOL f = WritePrivateProfileString( MIGRATION_FOREIGN_SECTION,
                                        lpszGuid,
                                        tszKeyName,
                                        g_wszIniName ) ;
    ASSERT(f) ;

    TCHAR szBuf[20];
    _ltot( ulForeignCount, szBuf, 10 );
    f = WritePrivateProfileString(  MIGRATION_FOREIGN_CNNUM_SECTION,
                                    MIGRATION_CNNUM_KEY,
                                    szBuf,
                                    g_wszIniName ) ;
    ASSERT(f);
    RpcStringFree( &lpszGuid ) ;
}

//+----------------------------------
//
//  HRESULT RemoveReplicationService()
//
//	This function deletes replication service from Service Manager
//
//+----------------------------------
HRESULT RemoveReplicationService()
{
	//
	// get service control manager handle
	//
	CServiceHandle hServiceCtrlMgr(
						OpenSCManager(
							NULL,
							NULL,
							SC_MANAGER_ALL_ACCESS
							)
						);

	if (!hServiceCtrlMgr)
    {		
		LogReplicationEvent( ReplLog_Error,
                             MQSync_E_CANT_OPEN_CTRLMNGR,
							 GetLastError());
		return MQSync_E_CANT_OPEN_CTRLMNGR ;
	}

	//
	// get service handle
	//
	CServiceHandle hService(
						OpenService(
							hServiceCtrlMgr,
							MQ1SYNC_SERVICE_NAME,
							SERVICE_ALL_ACCESS
							)
						);
	if (!hService)
    {		    	
		LogReplicationEvent( ReplLog_Error,
                             MQSync_E_CANT_OPEN_SERVICE,
							 GetLastError());
		return MQSync_E_CANT_OPEN_SERVICE ;
	}

	//
	// delete service
	//
	BOOL f = DeleteService(hService);
	if (!f)
	{
		LogReplicationEvent( ReplLog_Error,
                             MQSync_E_CANT_DELETE_SERVICE,
							 GetLastError());
		return MQSync_E_CANT_DELETE_SERVICE ;
	}

	return MQSync_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:  RunProcess
//
//  Synopsis:  Creates and starts a process
//
//+-------------------------------------------------------------------------
BOOL
RunProcess(
	IN  const LPTSTR szCommandLine,
    OUT       DWORD  *pdwExitCode
	)
{
    //
    // Initialize the process and startup structures
    //
    PROCESS_INFORMATION infoProcess;
    STARTUPINFO	infoStartup;
    memset(&infoStartup, 0, sizeof(STARTUPINFO)) ;
    infoStartup.cb = sizeof(STARTUPINFO) ;
    infoStartup.dwFlags = STARTF_USESHOWWINDOW ;
    infoStartup.wShowWindow = SW_MINIMIZE ;

    //
    // Create the process
    //
    if (!CreateProcess( NULL,
                        szCommandLine,
                        NULL,
                        NULL,
                        FALSE,
                        DETACHED_PROCESS,
                        NULL,
                        NULL,
                        &infoStartup,
                        &infoProcess ))
    {
		*pdwExitCode = GetLastError();
        return FALSE;
    }

    if (WaitForSingleObject(infoProcess.hProcess, 0) == WAIT_FAILED)
    {
       *pdwExitCode = GetLastError();
       return FALSE;
    }

    //
    // Close the thread and process handles
    //
    CloseHandle(infoProcess.hThread);
    CloseHandle(infoProcess.hProcess);

    return TRUE;

} //RunProcess


//+-------------------------------------------------------------------------
//
//  void DeleteReplicationService()
//
// We have to
//		- disable and remove replication service
//		- remove migration registry
//		- remove mq1sync registry
//		- unlodctr mq1sync
//		- change MQS registry to 2
//
//  Note: it's important to keep PROPID_SET_OLDSERVICE with its PEC value
//        (8). This is needed for upgraded machines to be able to find
//        their ex-PEc and ask it to update the machine security descriptor.
//        see qm\setup.cpp, UpgradeMachineSecurity().
//
//+-------------------------------------------------------------------------

void DeleteReplicationService()
{
	HRESULT hr = MQSync_OK;
	//
	// remove replication service
	//
	hr = RemoveReplicationService();
	if (FAILED(hr))
	{
		LogReplicationEvent( ReplLog_Error,
                             MQSync_E_CANT_REMOVE_REPLSRV,
							 hr );
		return;
	}

	//
	// remove migration registry
	//
	TCHAR szMigrationRegKey[256];
	_stprintf(szMigrationRegKey, TEXT("%s\\%s"), FALCON_REG_KEY, TEXT("Migration"));
	ULONG ulRes = RegDeleteKey(FALCON_REG_POS, szMigrationRegKey) ;
	if (ulRes != ERROR_SUCCESS)
	{
		LogReplicationEvent( ReplLog_Error,
                             MQSync_E_CANT_DELETE_REGKEY,
							 szMigrationRegKey,
							 ulRes);		
	}
	
	//
	// unlodctr mq1sync
	//
	TCHAR szCommandLine[256];
	_stprintf(szCommandLine, TEXT("unlodctr %s"), MQ1SYNC_SERVICE_NAME);

	if (!RunProcess(szCommandLine, &ulRes))
	{
		LogReplicationEvent( ReplLog_Error,
                             MQSync_E_FAILED_RUN_PROCESS,
							 szCommandLine,
							 ulRes);		
	}

	//
	// remove performance key for service
	//	
	_TCHAR szPerfKey [256];
    _stprintf (szPerfKey,_T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"),
               MQ1SYNC_SERVICE_NAME);
	ulRes = RegDeleteKey(FALCON_REG_POS, szPerfKey) ;
	if (ulRes != ERROR_SUCCESS)
	{
		LogReplicationEvent( ReplLog_Error,
                             MQSync_E_CANT_DELETE_REGKEY,
							 szPerfKey,
							 ulRes);		
	}

    //
    // save PEC flag in registry. We need it in CompleteMachineUpgrade(),
    // in qm\setup.cpp.
    //
    DWORD dwValue = SERVICE_PEC;
    DWORD dwSize  = sizeof(DWORD);
    DWORD dwType  = REG_DWORD;

    ulRes = SetFalconKeyValue(
                     MSMQ_PREMIG_MQS_REGNAME,
                    &dwType,
                    &dwValue,
                    &dwSize
					) ;	
	if (ulRes != ERROR_SUCCESS)
	{
		LogReplicationEvent( ReplLog_Error,
                             MQSync_E_CANT_SET_REGKEY,
                             MSMQ_PREMIG_MQS_REGNAME,
							 ulRes);		
	}

	//
	// set registry
	//	
    dwValue = SERVICE_BSC;
    dwSize  = sizeof(DWORD);
    dwType  = REG_DWORD;

    ulRes = SetFalconKeyValue(
					MSMQ_MQS_REGNAME,
                    &dwType,
                    &dwValue,
                    &dwSize
					) ;	
	if (ulRes != ERROR_SUCCESS)
	{
		LogReplicationEvent( ReplLog_Error,
                             MQSync_E_CANT_SET_REGKEY,
							 MSMQ_MQS_REGNAME,
							 ulRes);		
	}

	//
	// put event to event logger
	//	
	REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, REPLICATION_SERVICE_REMOVED, 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpusers.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpusers.cpp

Abstract: replication of users certificates to NT4 MSMQ1.0 servers.

Relevant bugs: 5369, 5248

Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

#include "mq1repl.h"
#include "..\..\src\ds\h\mqattrib.h"
#include <mixmode.h>

#include "rpusers.tmh"

//+-------------------------------------------------------
//
//  HRESULT _GetDigestsDelta()
//
//+-------------------------------------------------------
static HRESULT _GetDigestsDelta (
                    IN  DWORD           dwFirstNum,
                    IN  PLDAP_BERVAL    *ppFirst,
                    IN  DWORD           dwSecondNum,
                    IN  PLDAP_BERVAL    *ppSecond,
                    OUT DWORD           *pdwFoundNum,
                    OUT GUID            **ppFoundDigests
                    )
{
    //
    // we are looking for the elements of the first array in the second array
    // we return all elements that belong to the first array and do not belong
    // to the second one
    //

    if (ppFirst == NULL)
    {
        return MQSync_OK;
    }

    GUID *pCurFoundDigests = *ppFoundDigests;
    PLDAP_BERVAL *pTmp1 = ppFirst;

    if (ppSecond == NULL)
    {
        *pdwFoundNum = dwFirstNum;
        for (UINT count=0; count<dwFirstNum; count++)
        {
            memcpy (&(pCurFoundDigests[count]), (GUID *)((*pTmp1)->bv_val), sizeof (GUID));
            pTmp1++;
        }
        return MQSync_OK;
    }

    PLDAP_BERVAL *pTmp2 = ppSecond;

    for (DWORD i = 0; i<dwFirstNum; i++)
    {
        BOOL fFound = FALSE;
        for (DWORD j = 0; j<dwSecondNum; j++)
        {
            if (memcmp ( (GUID *)((*pTmp1)->bv_val),
                         (GUID *)((*pTmp2)->bv_val),
                         sizeof(GUID)) == 0)
            {
                fFound = TRUE;
                break;
            }
            pTmp2++;
        }
        if (!fFound)
        {
            memcpy (&(pCurFoundDigests[*pdwFoundNum]),
                    (GUID *)((*pTmp1)->bv_val) , sizeof(GUID));
            (*pdwFoundNum)++;
        }
        pTmp1++;
        pTmp2 = ppSecond;
    }

    return MQSync_OK;
}

//+-------------------------------------------------------
//
//  HRESULT _GetAllInfoByDigest
//  pbBuffer has the following structure
//  DWORD   Number Of Certificate
//  array that contains NumOfCert Elements. Each of them
//  has the following structure:
//      Digest  (GUID)
//      UserId  (GUID)
//      Length of Certificate (DWORD)
//      Certificate (length of certificate bytes)
//
//+-------------------------------------------------------
static BOOL _GetAllInfoByDigest (
                    IN  GUID *pDigest,
                    IN  BYTE *pbBuffer,
                    OUT GUID *pUserId,
                    OUT BLOB *pbCert
                    )
{
    BYTE * pCur = pbBuffer;

    DWORD NumOfCert;
    memcpy (&NumOfCert, pCur, sizeof(DWORD));
    pCur += sizeof(DWORD);

    for (DWORD i=0; i<NumOfCert; i++)
    {
        GUID CurDigest;
        memcpy( &CurDigest, pCur, sizeof(GUID));
        pCur += sizeof(GUID);

        if (memcmp(&CurDigest, pDigest, sizeof(GUID)) ==0)
        {
            //
            // we found it!
            //
            memcpy( pUserId, pCur, sizeof(GUID));
            pCur += sizeof(GUID);

            memcpy (&(pbCert->cbSize), pCur, sizeof(DWORD));
            pCur += sizeof(DWORD);

            pbCert->pBlobData = new BYTE[pbCert->cbSize];
            memcpy (pbCert->pBlobData, pCur, pbCert->cbSize);
            pCur += pbCert->cbSize;

            return TRUE;
        }

        //
        // skip UserId
        //
        pCur += sizeof(GUID);


        //
        // skip Certificate Length
        //
        DWORD dwCertLen;
        memcpy (&dwCertLen, pCur, sizeof(DWORD));
        pCur += sizeof(DWORD);

        //
        // skip Certificate
        //
        pCur += dwCertLen;
    }

    //
    // we didn't find the digest in the CertBlob array. Why?
    //
    unsigned short *lpszDigest ;
    UuidToString( pDigest, &lpszDigest ) ;
    LogReplicationEvent(ReplLog_Error, MQSync_E_WRONG_USER_DATA, lpszDigest) ;
    RpcStringFree( &lpszDigest ) ;

    return FALSE;
}

//+-------------------------------------------------------
//
//  HRESULT _HandleAUser()
//
//+-------------------------------------------------------
HRESULT HandleAUser(
            BOOL            fMSMQUserContainer,
            TCHAR          *pszPrevUsn,
            PLDAP           pLdap,
            LDAPMessage    *pRes,
            CDSUpdateList  *pReplicationList,
            GUID           *pNeighborId,
            int            *piCount
            )
{
    HRESULT hr = MQSync_OK;

    PLDAP_BERVAL *ppSid;
    if (fMSMQUserContainer)
    {
        ppSid = ldap_get_values_len( pLdap,
                                     pRes,
                         const_cast<LPWSTR> (MQ_MQU_SID_ATTRIBUTE) ) ;
    }
    else
    {
        ppSid = ldap_get_values_len( pLdap,
                                     pRes,
                         const_cast<LPWSTR> (MQ_U_SID_ATTRIBUTE) ) ;
    }

    PLDAP_BERVAL *ppNewDigest = ldap_get_values_len( pLdap,
                                                   pRes,
                       const_cast<LPWSTR> (MQ_U_DIGEST_ATTRIBUTE) ) ;

    UINT NewDigestsCount = ldap_count_values_len( ppNewDigest );

    PLDAP_BERVAL *ppOldDigest = ldap_get_values_len( pLdap,
                                                     pRes,
                       const_cast<LPWSTR> (MQ_U_DIGEST_MIG_ATTRIBUTE) ) ;
    UINT OldDigestsCount = ldap_count_values_len( ppOldDigest );

    if ( (ppNewDigest && *ppNewDigest) ||
         (ppOldDigest && *ppOldDigest) )
    {
        ASSERT (ppSid);
        char *pSid;
        ULONG ulSidSize = (*ppSid)->bv_len;
        pSid = (*ppSid)->bv_val;

        PLDAP_BERVAL *ppNewCertBlob = ldap_get_values_len( pLdap,
                                                           pRes,
                       const_cast<LPWSTR> (MQ_U_SIGN_CERT_ATTRIBUTE) ) ;

        PLDAP_BERVAL *ppOldCertBlob = ldap_get_values_len( pLdap,
                                                           pRes,
                       const_cast<LPWSTR> (MQ_U_SIGN_CERT_MIG_ATTRIBUTE) ) ;
#ifdef  _DEBUG
        //
        // Verify number of array items match.
        //
        DWORD *pdwNewNum = NULL ;
        DWORD *pdwOldNum = NULL ;

        if (ppNewCertBlob)
        {
            pdwNewNum = (DWORD *) ((*ppNewCertBlob)->bv_val);
            ASSERT (NewDigestsCount == *pdwNewNum);
        }
        else
        {
            ASSERT (NewDigestsCount == 0) ;
        }

        if (ppOldCertBlob)
        {
            pdwOldNum = (DWORD *) ((*ppOldCertBlob)->bv_val) ;
            ASSERT (OldDigestsCount == *pdwOldNum);
        }
        else
        {
            ASSERT (OldDigestsCount == 0) ;
        }
#endif

        __int64 i64SeqNum = 0 ;
        hr =  GetGuidAndUsn( pLdap,
                             pRes,
                             g_pThePecMaster->GetDelta(),
                             NULL,
                             &i64SeqNum ) ;
        ASSERT(SUCCEEDED(hr)) ;

        CSeqNum sn, snMin, snPrev ;
        GetSNForReplication (i64SeqNum, g_pThePecMaster, pNeighborId, &sn);
        BOOL fPreMigSync = FALSE;

        __int64 i64MinSeq = 0 ;
        if (i64SeqNum)
        {
            swscanf(pszPrevUsn, L"%I64d", &i64MinSeq) ;
            ASSERT(i64MinSeq > 0) ;
            i64MinSeq += g_pThePecMaster->GetDelta();
            GetSNForReplication (i64MinSeq, g_pThePecMaster, pNeighborId, &snMin);
        }
        else
        {
            snMin = sn;
            fPreMigSync = TRUE;
        }

        BOOL fWasModifying = FALSE;
        //
        // check if there are created users
        //
        GUID *pFoundDigests = new GUID[NewDigestsCount];
        DWORD dwFoundNum = 0;
        hr = _GetDigestsDelta (
                NewDigestsCount,
                ppNewDigest,    //pNewDigests,
                OldDigestsCount,
                ppOldDigest,    //pOldDigests,
                &dwFoundNum,
                &pFoundDigests
                );

        //
        // if dwFoundNum is equal to zero, but fPreMigSync is TRUE
        // it means that we need info about all users at this moment
        // it can be sync0 or sync of pre-migration object
        // So, despite on the fact that there is no difference
        // we'll send all users
        //
        // ????? If there is difference and fPreMigSync is TRUE
        // what do we have to send? (only difference/ all; in one step/several steps)
        // what about deleted users?
        //
        if (dwFoundNum == 0 && fPreMigSync)
        {
            dwFoundNum = NewDigestsCount;
            PLDAP_BERVAL *pTmp = ppNewDigest;
            for (DWORD i=0; i<dwFoundNum; i++)
            {
                memcpy (&(pFoundDigests[i]), (GUID *)((*pTmp)->bv_val), sizeof (GUID));
                pTmp++;
            }
        }

        if (dwFoundNum)
        {
            fWasModifying = TRUE;
            //
            // created users
            //
            for (DWORD i=0; i<dwFoundNum; i++)
            {
                //
                // get SN for this change
                //
                CSeqNum HoleSN;

                hr = pReplicationList->GetHoleSN (snMin, sn, &HoleSN);
                if (HoleSN.IsInfiniteLsn())
                {
                    //
                    // there is no holes in the replication list
                    // what to do here? New data will not replicated.
                    // Bug 5248.
                    //
                    hr = MQSync_E_NO_HOLE_IN_REPLLIST ;
                    LogReplicationEvent(ReplLog_Error, hr) ;
                }
                else if (HoleSN > sn)
                {
                    ASSERT (0);
                    //
                    // we find hole but with SN greater than SN of this change
                    // what to do here?
                    //
                    hr = MQSync_E_NO_HOLE_IN_REPLLIST  ;
                    LogReplicationEvent(ReplLog_Error, hr) ;
                }

                if (fPreMigSync)
                {
                    //
                    // if it sync of pre-migration object we have to get such HoleSN
                    // that is equal exactly to calculated sn.
                    //
                    ASSERT(sn == HoleSN);
                }

                if (SUCCEEDED(hr))
                {
                    #define     PROPS_SIZE  5
                    PROPID      propIDs[ PROPS_SIZE ];
                    PROPVARIANT propVariants[ PROPS_SIZE ] ;
                    DWORD       iProps = 0 ;

                    propIDs[ iProps ] = PROPID_U_MASTERID ;
	                propVariants[ iProps ].vt = VT_CLSID ;
                    propVariants[ iProps ].puuid = &g_PecGuid ;
	                iProps++;

                    propIDs[ iProps ] = PROPID_U_DIGEST  ;
	                propVariants[ iProps ].vt = VT_CLSID ;
                    propVariants[ iProps ].puuid = &pFoundDigests[i] ;
	                iProps++;

                    propIDs[ iProps ] = PROPID_U_SID  ;
	                propVariants[ iProps ].vt = VT_BLOB ;
                    propVariants[ iProps ].blob.cbSize = ulSidSize ;
                    propVariants[ iProps ].blob.pBlobData = (unsigned char *) pSid;
	                iProps++;

                    GUID UserId;
                    BLOB bCert;

                    BOOL f = _GetAllInfoByDigest (
                                    &pFoundDigests[i],
                                    (BYTE *) ((*ppNewCertBlob)->bv_val),
                                    &UserId,
                                    &bCert
                                    );
                    DBG_USED(f);
                    ASSERT (f);
                    propIDs[ iProps ] = PROPID_U_ID  ;
	                propVariants[ iProps ].vt = VT_CLSID ;
                    propVariants[ iProps ].puuid = &UserId;
	                iProps++;

                    propIDs[ iProps ] = PROPID_U_SIGN_CERT  ;
	                propVariants[ iProps ].vt = VT_BLOB ;
                    propVariants[ iProps ].blob.cbSize = bCert.cbSize ;
                    propVariants[ iProps ].blob.pBlobData = bCert.pBlobData;
	                iProps++;

                    ASSERT(iProps <= PROPS_SIZE) ;
                    #undef  PROPS_SIZE

                    hr = PrepareNeighborsUpdate(  DS_UPDATE_SYNC,
                                                  MQDS_USER,
                                                  NULL, // pwName,
                                                  NULL, // pguidIdentifier
                                                  iProps,
                                                  propIDs,
                                                  propVariants,
                                                  &g_PecGuid,
                                                  HoleSN,
                                                  snPrev,
                                                  ENTERPRISE_SCOPE,
                                                  TRUE, //  fNeedFlush,
                                                  pReplicationList ) ;
                    if (bCert.cbSize)
                    {
                        delete bCert.pBlobData;
                    }
#ifdef _DEBUG
                    TCHAR  tszSn[ SEQ_NUM_BUF_LEN ] ;
                    HoleSN.GetValueForPrint(tszSn) ;

                    unsigned short *lpszGuid ;
                    UuidToString( &UserId, &lpszGuid ) ;

                    LogReplicationEvent(ReplLog_Info, MQSync_I_REPLICATE_USER,
										 lpszGuid, tszSn) ;

                    RpcStringFree( &lpszGuid ) ;
#endif
                    if (fPreMigSync && i<dwFoundNum-1)
                    {	
                        //
                        // to increase sn in SyncRequest for next user 						
                        // if this user is the last we don't need to increase
                        // the sn. In the code for next PEC object which we have to
                        // replicate (CN, for example) sn will be increased
                        //
                        GetSNForReplication (i64SeqNum, g_pThePecMaster, pNeighborId, &sn);
                        snMin = sn;
                        //						
                        // in this pre-migration sync mode we have to replicate
                        // several (dwFoundNum) users although in ADS only one (f.e.)
                        // change may be found
                        // 						
                        (*piCount)++;
                    }
                }
            }
        }

        delete pFoundDigests;

        //
        // check if there are deleted users
        //
        dwFoundNum = 0;
        pFoundDigests = new GUID[OldDigestsCount];
        hr = _GetDigestsDelta (
                OldDigestsCount,
                ppOldDigest,    //pOldDigests,
                NewDigestsCount,
                ppNewDigest,    //pNewDigests,
                &dwFoundNum,
                &pFoundDigests
                );

        if (dwFoundNum)
        {
            fWasModifying = TRUE;
            //
            // deleted users
            //
            for (DWORD i=0; i<dwFoundNum; i++)
            {
                //
                // prepare all properties (get all info from ppNewOldBlob
                // according to CurDigests)
                #define     PROPS_SIZE  2
                PROPID      propIDs[ PROPS_SIZE ];
                PROPVARIANT propVariants[ PROPS_SIZE ] ;
                DWORD       iProps = 0 ;

                propIDs[ iProps ] = PROPID_D_SCOPE ;
	            propVariants[ iProps ].vt = VT_UI1 ;
                propVariants[ iProps ].bVal = ENTERPRISE_SCOPE ;
                iProps++;

                propIDs[ iProps ] = PROPID_D_OBJTYPE ;
	            propVariants[ iProps ].vt = VT_UI1 ;
                propVariants[ iProps ].bVal = (unsigned char) MQDS_USER ;
                iProps++;

                ASSERT(iProps <= PROPS_SIZE) ;
                #undef  PROPS_SIZE

                CSeqNum HoleSN;

                hr = pReplicationList->GetHoleSN (snMin, sn, &HoleSN);
                if (HoleSN.IsInfiniteLsn())
                {
                    //
                    // there is no holes in the replication list
                    // it is bug, 5248.
                    //
                    hr = MQSync_E_NO_HOLE_IN_REPLLIST  ;
                    LogReplicationEvent(ReplLog_Error, hr) ;
                }
                else if (HoleSN > sn)
                {
                    ASSERT (0);
                    //
                    // we find hole but with SN greater than SN of this change
                    // what to do here?
                    //
                    hr = MQSync_E_NO_HOLE_IN_REPLLIST  ;
                    LogReplicationEvent(ReplLog_Error, hr) ;
                }

                if (SUCCEEDED(hr))
                {
                    GUID UserId;
                    BLOB bCert;

                    BOOL f = _GetAllInfoByDigest (
                                    &pFoundDigests[i],
                                    (BYTE *) ((*ppOldCertBlob)->bv_val),
                                    &UserId,
                                    &bCert
                                    );
                    DBG_USED(f);
                    ASSERT (f);

                    hr = PrepareNeighborsUpdate(
                                         DS_UPDATE_DELETE,
                                         MQDS_USER,
                                         NULL, // pwName,
                                         &UserId,
                                         iProps,
                                         propIDs,
                                         propVariants,
                                         &g_PecGuid,
                                         HoleSN,
                                         snPrev,
                                         ENTERPRISE_SCOPE,
                                         TRUE, //  fNeedFlush,
                                         pReplicationList ) ;

                    if (bCert.cbSize)
                    {
                        delete bCert.pBlobData;
                    }					
                }
            }
        }

        delete pFoundDigests;

        if (fWasModifying && SUCCEEDED(hr))
        {
            //
            // copy values from new attributes to the old ones
            //
            WCHAR **ppPath = ldap_get_values( pLdap,
                                              pRes,
                            const_cast<LPWSTR> (MQ_U_FULL_PATH_ATTRIBUTE) ) ;
            ASSERT(ppPath) ;
            hr = ModifyAttribute(
                         *ppPath,
                         const_cast<WCHAR*> (MQ_U_DIGEST_MIG_ATTRIBUTE),
                         ppNewDigest
                         );

            hr = ModifyAttribute(
                         *ppPath,
                         const_cast<WCHAR*> (MQ_U_SIGN_CERT_MIG_ATTRIBUTE),
                         ppNewCertBlob
                         );

            if (FAILED(hr))
            {
                // what to do if we failed to modify attribute?
            }
            int i = ldap_value_free( ppPath ) ;
            DBG_USED(i);
            ASSERT(i == LDAP_SUCCESS) ;
        }
        else
        {
            (*piCount)--;
        }

        int i = ldap_value_free_len(ppNewDigest) ;
        ASSERT(i == LDAP_SUCCESS) ;
        i = ldap_value_free_len(ppOldDigest) ;
        ASSERT(i == LDAP_SUCCESS) ;
        i = ldap_value_free_len(ppNewCertBlob) ;
        ASSERT(i == LDAP_SUCCESS) ;
        i = ldap_value_free_len(ppOldCertBlob) ;
        ASSERT(i == LDAP_SUCCESS) ;
        i = ldap_value_free_len(ppSid) ;
        ASSERT(i == LDAP_SUCCESS) ;

    }
    else
    {
        //
        // we are here if
        // - in the previous step we deleted the last user and modified attributes.
        // - it was not user object (contact object, for example)
        // We have to do nothing except decrease count
        //
        int i = ldap_value_free_len(ppNewDigest) ;
        ASSERT(i == LDAP_SUCCESS) ;
        i = ldap_value_free_len(ppOldDigest) ;
        ASSERT(i == LDAP_SUCCESS) ;
        i = ldap_value_free_len(ppSid) ;
        ASSERT(i == LDAP_SUCCESS) ;
        (*piCount)--;
    }

    return hr;
}

//+-------------------------------------------------------
//
//  HRESULT ReplicateUsers()
//
//+-------------------------------------------------------
HRESULT ReplicateUsers(
            IN  BOOL           fMSMQUserContainer,
            IN  TCHAR         *pszPrevUsn,
            IN  TCHAR         *pszCurrentUsn,
            IN  CDSUpdateList *pReplicationList,
            IN  GUID          *pNeighborId,
            OUT int           *piCount
            )
{
    PLDAP pLdap = NULL ;
    HRESULT hr =  InitLDAP(&pLdap) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(pLdap) ;
    //
    // we are looking in GC from the root, so we need empty default context
    //
    ASSERT(pGetNameContext(FALSE)) ;

    TCHAR *pszSchemaDefName = NULL ;
    hr = GetSchemaNamingContext ( &pszSchemaDefName ) ;
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwDNSize = wcslen(pGetNameContext(FALSE));
    P<WCHAR> pwszDN = new WCHAR[ 1 + dwDNSize ] ;
    wcscpy(pwszDN, pGetNameContext(FALSE));

    TCHAR *pszCategoryName;
    if (fMSMQUserContainer)
    {
        pszCategoryName = const_cast<LPTSTR> (x_MQUserCategoryName);
    }
    else
    {
        pszCategoryName = const_cast<LPTSTR> (x_UserCategoryName);
    }

    TCHAR wszFullName[256];
    _stprintf(wszFullName, TEXT("%s,%s"), pszCategoryName,pszSchemaDefName);

    TCHAR  wszFilter[ 512 ] ;
    _tcscpy(wszFilter, TEXT("(&(objectCategory=")) ;
    _tcscat(wszFilter, wszFullName);

    _tcscat(wszFilter, TEXT(")(usnChanged>=")) ;
    _tcscat(wszFilter, pszPrevUsn) ;

    if (pszCurrentUsn)
    {
        _tcscat(wszFilter, TEXT(")(usnChanged<=")) ;
        _tcscat(wszFilter, pszCurrentUsn) ;
    }
    _tcscat(wszFilter, TEXT("))")) ;
    ASSERT(_tcslen(wszFilter) < (sizeof(wszFilter) / sizeof(wszFilter[0]))) ;

    //
    // handle users
    //
	hr = QueryDS(
			pLdap,
			pwszDN,
			wszFilter,
			g_pThePecMaster,
            pReplicationList,
            pNeighborId,
			MQDS_USER,
            piCount ,
			//special parameters for deleted object
			FALSE,
			NULL,
			//special parameters for user object
			fMSMQUserContainer,
            pszPrevUsn 			
			);

    return hr ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpwrtreq.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: rpwrtreq.cpp

Abstract: handle write requests and write replys messages.

Author:

    Doron Juster  (DoronJ)   10-Jun-98

--*/

#include "mq1repl.h"

#include "rpwrtreq.tmh"

//+----------------------------------------------
//
//  HRESULT  SendMsgToMsmqServer()
//
//+----------------------------------------------

HRESULT SendMsgToMsmqServer( IN LPWSTR pwcsServerName,
                             IN const unsigned char * pBuf,
                             IN DWORD dwTotalSize,
                             IN DWORD dwTimeOut,
                             IN unsigned char bPriority)
{
    //
    //  Create format name for the destination server
    //
    AP<WCHAR> phConnection;
    g_pTransport->CreateConnection(pwcsServerName, &phConnection);

    return( g_pTransport->SendReplication( phConnection,
                                           pBuf,
                                           dwTotalSize,
                                           dwTimeOut,
                                           MQMSG_ACKNOWLEDGMENT_NONE,
                                           bPriority,
                                           NULL)) ;
}


//+----------------------------------------------
//
//  HRESULT  ReceiveWriteReplyMessage()
//
//+----------------------------------------------

HRESULT  ReceiveWriteReplyMessage( MQMSGPROPS  *psProps,
                                   QUEUEHANDLE  hMyNt5PecQueue )
{
    HRESULT hr = MQSync_OK ;
    const unsigned char *pBuf =
                        psProps->aPropVar[ MSG_BODY_INDEX ].caub.pElems ;
    DWORD dwTotalSize = psProps->aPropVar[ MSG_BODYSIZE_INDEX ].ulVal ;

    //
    //  See if this machine (the NT5 ex-PEC) was the originator of the write
    //  request. If yes, then pass the message to the MSMQ service which
    //  wait for it (it was the MSMQ service which send the write reqquest).
    //  If no, route it to the originator BSC.
    //
#ifdef _DEBUG
#undef new
#endif
    CWriteReplyHeader * pReply =
                        new((unsigned char *)pBuf) CWriteReplyHeader();
    UNREFERENCED_PARAMETER(pReply);
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    DWORD len = pReply->GetRequesterNameSizeW();
    AP<WCHAR> pwcsOriginator = new WCHAR[ len ];

    pReply->GetRequesterName( pwcsOriginator,  (len * sizeof(WCHAR)) );

    if (lstrcmpi( pwcsOriginator, g_pwszMyMachineName ) == 0)
    {
        psProps->cProp =  NUMOF_SEND_MSG_PROPS ;
        if (psProps->aPropVar[ MSG_RESPLEN_INDEX ].ulVal == 0)
        {
            //
            // Response queue property not available. ignore the two
            // resp properties and don't pass them to MQSend().
            //
            psProps->cProp = psProps->cProp - 2 ;
        }

        //
        // We're the originator. Pass to MSMQ.
        //
        hr = MQSendMessage( hMyNt5PecQueue,
                            psProps,
                            NULL ) ;
        if (FAILED(hr))
        {
            LogReplicationEvent( ReplLog_Error,
                                 MQSync_E_WRITE_REPLY_TO_MSMQ,
                                 hr ) ;
        }
        else
        {
            LogReplicationEvent( ReplLog_Info,
                                 MQSync_I_WRITE_REPLY ) ;
        }
    }
    else
    {
        //
        // Pass to BSC.
        //
        hr = g_pNeighborMgr->SendMsg( pwcsOriginator,
                                      pBuf,
                                      dwTotalSize,
                                      g_dwWriteMsgTimeout,
                                      DS_WRITE_REQ_PRIORITY ) ;
        if (FAILED(hr))
        {
            if (hr != MQDS_UNKNOWN_SOURCE)
            {
                LogReplicationEvent( ReplLog_Error,
                                     MQSync_E_WRITE_REPLY_TO_BSC,
                                     pwcsOriginator, hr ) ;
            }
            else
            {
                //
                //  the originator of the write request was not a BSC, but
                //  an NT5 MSMQ DS server, that issued a write request to
                //  an NT4 PSC. We send the reply to the NT5 MSMQ DS server
                //  directly, w/o caching of format names.
                //
                hr = SendMsgToMsmqServer(pwcsOriginator,
                                         pBuf,
                                         dwTotalSize,
                                         g_dwWriteMsgTimeout,
                                         DS_WRITE_REQ_PRIORITY);
                if (FAILED(hr))
                {
                    LogReplicationEvent(
                                    ReplLog_Error,
                                    MQSync_E_WRITE_REPLY_TO_NT5_DS_SERVER,
                                    pwcsOriginator, hr ) ;
                }
            }
        }
    }

    return hr ;
}


//+-----------------------------------------------------------------------
//
//  Function:  ReceiveWriteRequestMessage()
//
//  Description: Process a write request from other master and update
//               local DS.
//
//  Arguments:
//
//  Return Value:
//
//  Threads:Receive
//
//+-----------------------------------------------------------------------

HRESULT ReceiveWriteRequestMessage( IN  const unsigned char *   pBuf,
                                    IN  DWORD                   TotalSize )
{
    LogReplicationEvent( ReplLog_Info, MQSync_I_WRITE_REQUEST_FUNCTION, GetTickCount()) ;

    const unsigned char  *ptr ;
    const GUID           *pguidOwnerId ;
    DWORD                 dwHandle;
    HRESULT               hr = MQSync_OK ;

#ifdef _DEBUG
#undef new
#endif

    CWriteRequestHeader * pRequest =
                     new ((unsigned char *)pBuf) CWriteRequestHeader() ;

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

    DWORD dwRequesterNameSize = pRequest->GetRequesterNameSize();
    DWORD dwPSCNameSize = pRequest->GetIntermidiatePSCNameSize();
    pguidOwnerId = pRequest->GetOwnerId( );
    
    g_Counters.IncrementCounter(eWriteReq);

    //
    //  Is the request for this server or for any NT4 Site PSC
    //
    BOOL fNT4SiteFlag = TRUE;
    if (PEC_MASTER_ID != *pguidOwnerId)
    {
        hr = g_pMasterMgr->GetNT4SiteFlag (pguidOwnerId, &fNT4SiteFlag );
        if (FAILED(hr))
        {
            // ???? what to do???????
            ASSERT(0);
        }
    }
    if (((!fNT4SiteFlag) && g_IsPSC) ||
        ((PEC_MASTER_ID == *pguidOwnerId) && g_IsPEC))
    {
        pRequest->GetHandle( &dwHandle);

        //
        //  Prepare the request propids and variants
        //
        P<CDSUpdate> pUpdate = new CDSUpdate;
        DWORD size;
        ptr = pBuf + CWriteRequestHeader::CalcSize( dwRequesterNameSize,
                                                    dwPSCNameSize );

        hr = pUpdate->Init(ptr, &size, TRUE);
        //
        //  Execute the request
        //
        AP<WCHAR> pwcsOldPSC = NULL;
        switch ( pUpdate->GetCommand() )
        {
            case DS_UPDATE_CREATE:

                hr =  ReplicationCreateObject( pUpdate->GetObjectType(),
                                               pUpdate->GetPathName(),
                                               pUpdate->getNumOfProps(),
                                               pUpdate->GetProps(),
                                               pUpdate->GetVars() ) ;
                if (FAILED(hr))
                {
                    g_Counters.IncrementCounter(eErrorCreated);
                }
                else
                {
                    g_Counters.IncrementCounter(eCreatedObj);
                }
                break;

            case DS_UPDATE_SET:
                {
                    BOOL fIsObjectCreated = FALSE;
                    hr = ReplicationSyncObject(
                                pUpdate->GetObjectType(),   //dwObjectType,
                                pUpdate->GetPathName(),
                                pUpdate->GetGuidIdentifier(),
                                pUpdate->getNumOfProps(),   //ulNumOfProp,
                                pUpdate->GetProps(),        //pPropSync,
                                pUpdate->GetVars(),         //pVarSync,
				                pguidOwnerId,
                              const_cast<CSeqNum *>(&(pUpdate->GetSeqNum())),
                                &fIsObjectCreated) ;

                    if (FAILED(hr))
                    {
                        if (fIsObjectCreated)
                        {
                            g_Counters.IncrementCounter(eErrorCreated);
                        }
                        else
                        {
                            g_Counters.IncrementCounter(eErrorSetObj);
                        }
                    }
                    else
                    {
                        if (fIsObjectCreated)
                        {
                            g_Counters.IncrementCounter(eCreatedObj);
                        }
                        else
                        {
                            g_Counters.IncrementCounter(eSetObj);
                        }
                    }
                }
                break;

            case DS_UPDATE_DELETE:

                CList<CDSUpdate *, CDSUpdate *> *plistUpdatedObjects;

                hr = ReplicationDeleteObject(
                            pUpdate->GetObjectType(),
                            pUpdate->GetPathName(),
                            pUpdate->GetGuidIdentifier(),
                            pUpdate->GetVars()[0].bVal,      //Scope
                            pguidOwnerId,
                            const_cast<CSeqNum *>(&pUpdate->GetSeqNum()),
                            NULL,                           // no need to know previous sn
                            TRUE,                           // an object owned by this server
					    	FALSE,                          //???? fSync0
                            &plistUpdatedObjects );
                if (FAILED(hr))
                {
                    g_Counters.IncrementCounter(eErrorDeleted);
                }
                else
                {
                    g_Counters.IncrementCounter(eDeletedObj);
                }
                break;

            default:
                hr = MQ_ERROR;
                break;
        }

        //
        //  Send reply
        //
        DWORD dwReplySize = CWriteReplyHeader::CalcSize(dwRequesterNameSize);
        AP< unsigned char> pReplyBuffer = new unsigned char[ dwReplySize ];
        AP< WCHAR> wcsRequesterName = new
                              WCHAR[ dwRequesterNameSize / sizeof(WCHAR) ];
        pRequest->GetRequesterName( wcsRequesterName, dwRequesterNameSize );
        
        g_Counters.IncrementInstanceCounter(wcsRequesterName, eRcvWriteReq);

#ifdef _DEBUG
#undef new
#endif
        CWriteReplyHeader * pReply =
               new((unsigned char *)pReplyBuffer) CWriteReplyHeader(
                                                       DS_PACKET_VERSION,
                                                       &g_MySiteMasterId,
                                                       DS_WRITE_REPLY,
                                                       dwHandle,
                                                       hr,
                                                       dwRequesterNameSize,
                                                       wcsRequesterName);
        UNREFERENCED_PARAMETER(pReply);
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

        //
        //  Let see if the requester is a neighbor
        //
        ASSERT(g_pNeighborMgr) ;
        hr = g_pNeighborMgr->SendMsg( wcsRequesterName,
                                      pReplyBuffer,
                                      dwReplySize,
                                      g_dwWriteMsgTimeout,
                                      DS_WRITE_REQ_PRIORITY) ;
        DBGMSG((DBGMOD_REPLSERV, DBGLVL_INFO,
                 TEXT("RecvWriteReq- Send Reply to %ls, hr- %lxh"),
                                                    wcsRequesterName, hr)) ;
        if (FAILED(hr))
        {
            if(hr == MQDS_UNKNOWN_SOURCE)
            {
                //
                //  Is the PSC a neighbor
                //
                if  ( dwPSCNameSize )
                {
                    AP<WCHAR> pwcsPSCName = new
                                     WCHAR[ dwPSCNameSize / sizeof(WCHAR)];
                    pRequest->GetPSCName( pwcsPSCName, dwPSCNameSize);
                    hr = g_pNeighborMgr->SendMsg( pwcsPSCName,
                                                  pReplyBuffer,
                                                  dwReplySize,
                                                  g_dwWriteMsgTimeout,
                                                  DS_WRITE_REQ_PRIORITY );
                }
            }
        }
        if (pwcsOldPSC != NULL)
        {
            //
            // PSC has been changed
            // we are PEC, we have to remove it
            //
            ASSERT(g_IsPEC);
            g_pNeighborMgr->RemoveNeighbor(TRUE, pwcsOldPSC) ;
        }
        if (FAILED(hr))
        {
            //
            //  Bugbug - what to do if not finding to whom to send the reply?
            //
        }
    }
    else
    {
        //
        // The request come from a BSC and is for a NT4 PSC. Send it to the
        // NT4 machine.
        //
        P<WCHAR> pwszAdminQueue = NULL ;

        hr = GetMQISAdminQueueName(&pwszAdminQueue) ;
        if (FAILED(hr))
        {
            return(hr);
        }

        //
        //  Send it to the object master (PSC) .
        //
        hr = g_pMasterMgr->Send( pguidOwnerId,
                                 pBuf,
                                 TotalSize,
                                 g_dwWriteMsgTimeout,
                                 MQMSG_ACKNOWLEDGMENT_NACK_REACH_QUEUE,
                                 DS_WRITE_REQ_PRIORITY,
                                 pwszAdminQueue ) ;
    }

    LogReplicationEvent( ReplLog_Info, 
                MQSync_I_WRITE_REQUEST_FINISH, GetTickCount() ) ;

    return MQSync_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\update.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	update.h

Abstract:
	DS update class

	This class includes all the information of the update performed on the DS

Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __UPDATE_H__
#define __UPDATE_H__

#include "bupdate.h"


#define UPDATE_OK				0x00000000	// everything is fine
#define UPDATE_DUPLICATE		0x00000001	// receiving an old update
#define UPDATE_OUT_OF_SYNC		0x00000002	// we need a sync, probably we missed information
#define UPDATE_UNKNOWN_SOURCE	0x00000003	// we need a sync, probably we missed information

//
//  dwNeedCopy values
//
#define UPDATE_COPY             0x00000000
#define UPDATE_DELETE_NO_COPY   0x00000001
#define UPDATE_NO_COPY_NO_DELETE    0x00000002

class CDSUpdate : public CInterlockedSharedObject, public CDSBaseUpdate
{
public:
    CDSUpdate();
	~CDSUpdate();

	HRESULT UpdateDB(IN BOOL fSync0,
					 OUT BOOL *pfNeedFlush);



private:


};


inline CDSUpdate::CDSUpdate()
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\syncinit.cpp ===
/*++

Copyright (c) 1998-99  Microsoft Corporation

Module Name: syncinit.cpp

Abstract:
    Initialize the sync/replication process.

Author:

    Doron Juster  (DoronJ)   09-Feb-98

--*/

#include "mq1repl.h"

//+-------------------------------------
//
//   _GetThisServerInfo()
//
//+-------------------------------------

static HRESULT
_GetThisServerInfo()
{
    static WCHAR  s_wzServerName[ MAX_COMPUTERNAME_LENGTH + 1 ] ;
    HRESULT hr;

    //
    // Retrieve name of the machine (Always UNICODE)
    //
    DWORD  dwSize = sizeof(s_wzServerName) / sizeof(s_wzServerName[0]) ;
    hr = GetComputerNameInternal( s_wzServerName, &dwSize);
    if (FAILED(hr))
    {
        return(hr);
    }
    g_pwszMyMachineName = s_wzServerName;
    g_dwMachineNameSize = (wcslen(g_pwszMyMachineName)+1) * sizeof(WCHAR);

    //
    // GetInformation from the Registry
    //
    DWORD dwType;

    //
    // QMId
    //
    dwSize = sizeof(GUID);
    dwType = REG_BINARY;

    LONG rc = GetFalconKeyValue( MSMQ_QMID_REGNAME,
                                 &dwType,
                                 &g_guidMyQMId,
                                 &dwSize ) ;
    if (rc != ERROR_SUCCESS)
    {
        hr = MQSync_E_REG_QMID ;
        LogReplicationEvent( ReplLog_Error, hr, rc ) ;
        return hr ;
    }

    //
    // is PEC ?
    //
    DWORD dwService = 0 ;
    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    rc = GetFalconKeyValue( MSMQ_MQS_REGNAME,
                            &dwType,
                            &dwService,
                            &dwSize);
    if (rc != ERROR_SUCCESS)
    {
        hr = MQSync_E_REG_SERVICE ;
        LogReplicationEvent( ReplLog_Error, hr, rc ) ;
        return hr ;
    }

    g_IsPEC = (dwService == SERVICE_PEC) ;

    if (!g_IsPEC && (dwService != SERVICE_PSC))
    {
        //
        // the replication service can run only on a (ex NT4) PEc or PSC
        //
        return MQSync_E_WRONG_MACHINE ;
    }

    //
    // MasterId
    //
    dwSize = sizeof(GUID);
    dwType = REG_BINARY;
    rc = GetFalconKeyValue( MSMQ_MQIS_MASTERID_REGNAME,
                            &dwType,
                            &g_MySiteMasterId,
                            &dwSize);
    if (rc != ERROR_SUCCESS)
    {
		//
		// maybe migration tool created this registry key
		//
		rc = GetFalconKeyValue( MIGRATION_MQIS_MASTERID_REGNAME,
                            &dwType,
                            &g_MySiteMasterId,
                            &dwSize);
		
		if (rc != ERROR_SUCCESS)
		{
			hr = MQSync_E_REG_MASTERID ;
			LogReplicationEvent( ReplLog_Error, hr, rc ) ;
			return hr ;
		}
    }

    //
    //  Read the replication intervals values.
    //
    ReadReplicationTimes() ;

    //
    // read first and last highest migration USN
    //
    TCHAR tszUsn[ SEQ_NUM_BUF_LEN ] ;
    dwSize = sizeof(tszUsn) / sizeof(tszUsn[0]) ;
    dwType = REG_SZ;

    rc = GetFalconKeyValue(  FIRST_HIGHESTUSN_MIG_REG,
                             &dwType,
                             tszUsn,
                             &dwSize) ;

    ASSERT(rc == ERROR_SUCCESS) ;
    g_i64FirstMigHighestUsn = 0 ;

    if (rc == ERROR_SUCCESS)
    {
        _stscanf(tszUsn, TEXT("%I64d"), &g_i64FirstMigHighestUsn) ;
        ASSERT(g_i64FirstMigHighestUsn > 0) ;
    }

    dwSize = sizeof(tszUsn) / sizeof(tszUsn[0]) ;
    dwType = REG_SZ;

    rc = GetFalconKeyValue(  LAST_HIGHESTUSN_MIG_REG,
                             &dwType,
                             tszUsn,
                             &dwSize) ;

    ASSERT(rc == ERROR_SUCCESS) ;
    g_i64LastMigHighestUsn = 0 ;

    if (rc == ERROR_SUCCESS)
    {
        _stscanf(tszUsn, TEXT("%I64d"), &g_i64LastMigHighestUsn) ;
        ASSERT(g_i64LastMigHighestUsn > 0) ;
    }

    //
    // check if we are after recovery mode
    //
    g_fAfterRecovery = FALSE;

    dwSize = sizeof(DWORD);
    dwType = REG_DWORD;
    rc = GetFalconKeyValue( AFTER_RECOVERY_MIG_REG,
                            &dwType,
                            &g_fAfterRecovery,
                            &dwSize);
    return MQ_OK ;
}

//+-------------------------------------
//
//   _InitCNs()
//
//+-------------------------------------

static HRESULT
_InitCNs()
{
    //
    // build array of GUIDs for IP protocol
    //
    g_ulIpCount = GetPrivateProfileInt(
                      MIGRATION_IP_CNNUM_SECTION,// address of section name
                      MIGRATION_CNNUM_KEY,      // address of key name
                      0,                        // return value if key name is not found
                      g_wszIniName              // address of initialization filename);
                      );

    if (g_ulIpCount)
    {
        g_pIpCNs = new GUID[g_ulIpCount];
        for (ULONG i=0; i<g_ulIpCount; i++)
        {
            TCHAR szKey[50];
            _stprintf(szKey, TEXT("%s%lu"), MIGRATION_CN_KEY, i+1);

            TCHAR szGuid[50];
            DWORD dwRetSize;
            dwRetSize =  GetPrivateProfileString(
                              MIGRATION_IP_SECTION,     // points to section name
                              szKey,                    // points to key name
                              TEXT(""),                 // points to default string
                              szGuid,                   // points to destination buffer
                              50,                       // size of destination buffer
                              g_wszIniName              // points to initialization filename);
                              );
            if (_tcscmp(szGuid, TEXT("")) == 0)
            {
                ASSERT(0);	
                LogReplicationEvent( ReplLog_Error,
                                     MQSync_E_READ_CNS,
                                     MIGRATION_IP_SECTION ) ;
                return MQSync_E_READ_CNS;
            }
            UuidFromString(&(szGuid[0]), &g_pIpCNs[i]);
        }
    }

    //
    // build array of GUIDs for IPX protocol
    //
    g_ulIpxCount = GetPrivateProfileInt(
                      MIGRATION_IPX_CNNUM_SECTION,// address of section name
                      MIGRATION_CNNUM_KEY,        // address of key name
                      0,                          // return value if key name is not found
                      g_wszIniName                // address of initialization filename);
                      );

    if (g_ulIpxCount)
    {
        g_pIpxCNs = new GUID[g_ulIpxCount];
        for (ULONG i=0; i<g_ulIpxCount; i++)
        {
            TCHAR szKey[50];
            _stprintf(szKey, TEXT("%s%lu"), MIGRATION_CN_KEY, i+1);

            TCHAR szGuid[50];
            DWORD dwRetSize;
            dwRetSize =  GetPrivateProfileString(
                              MIGRATION_IPX_SECTION,    // points to section name
                              szKey,                    // points to key name
                              TEXT(""),                 // points to default string
                              szGuid,                   // points to destination buffer
                              50,                       // size of destination buffer
                              g_wszIniName              // points to initialization filename);
                              );
            if (_tcscmp(szGuid, TEXT("")) == 0)
            {
                ASSERT(0);	
                LogReplicationEvent( ReplLog_Error,
                                     MQSync_E_READ_CNS,
                                     MIGRATION_IPX_SECTION ) ;
                return MQSync_E_READ_CNS;
            }
            UuidFromString(&(szGuid[0]), &g_pIpxCNs[i]);
        }
    }

    if (g_ulIpCount+g_ulIpxCount == 0)
    {
        ASSERT(0);		
        return MQSync_E_READ_CNS;
    }

    return MQSync_OK;
}

//+-----------------------------
//
//  HRESULT InitQueues()
//
//+-----------------------------

HRESULT InitQueues( OUT QUEUEHANDLE *phMqisQueue,
                    OUT QUEUEHANDLE *phNT5PecQueue )
{
    P<WCHAR>  lpQueueFormatName = NULL ;
    HRESULT hr = GetMQISQueueName(&lpQueueFormatName, FALSE);
    if (FAILED(hr))
    {
        return hr ;
    }

    ASSERT(lpQueueFormatName) ;
    LogReplicationEvent( ReplLog_Info,
                         MQSync_I_QUEUE_FNAME,
                         lpQueueFormatName) ;

    hr = MQOpenQueue( lpQueueFormatName,
                      MQ_RECEIVE_ACCESS,
                      MQ_DENY_RECEIVE_SHARE,
                      phMqisQueue ) ;
    if (FAILED(hr))
    {
        TCHAR szRes[20];
        _ltot( hr, szRes, 16 );

        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                        REPLSERV_OPEN_QUEUE_ERROR,2,MQIS_QUEUE_NAME, szRes));

        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_OPEN_QUEUE,
                             MQIS_QUEUE_NAME,
                             hr) ;
        return hr ;
    }

    //
    // Now open the special queue which is used to pass write_reply messages
    // to the QM. We're sending messages to this queue.
    //
    P<WCHAR>  lpQueueWRFormatName = NULL ;
    hr = GetMQISQueueName(&lpQueueWRFormatName, FALSE, TRUE) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    ASSERT(lpQueueWRFormatName) ;
    LogReplicationEvent( ReplLog_Info,
                         MQSync_I_QUEUE_FNAME,
                         lpQueueWRFormatName) ;

    hr = MQOpenQueue( lpQueueWRFormatName,
                      MQ_SEND_ACCESS,
                      0,
                      phNT5PecQueue ) ;
    if (FAILED(hr))
    {
        TCHAR szRes[20];
        _ltot( hr, szRes, 16 );

        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL,
                        REPLSERV_OPEN_QUEUE_ERROR,2,NT5PEC_QUEUE_NAME,szRes));

        LogReplicationEvent( ReplLog_Error,
                             MQSync_E_OPEN_QUEUE,
                             NT5PEC_QUEUE_NAME,
                             hr) ;
        return hr ;
    }

    return hr ;
}

//+--------------------------------
//
//  RESULT InitDirSyncService() ;
//
//+--------------------------------

HRESULT InitDirSyncService()
{
    memset(&g_PecGuid, 0, sizeof(GUID));

    g_pTransport = new  CDSTransport;
    if (!g_pTransport)
    {
        return  MQSync_E_NO_MEMORY;
    }
    HRESULT hr = g_pTransport->Init();
    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Init the mqdscli dll.
    //
    hr = DSCoreInit( 
			FALSE,  // setup
			TRUE	// replication service
			);   
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Get name of local machine and read from registry some IDs.
    //
    hr = _GetThisServerInfo();
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Init the masters data structures.
    //
    hr = InitMasters();
    if (FAILED(hr))
    {
        return hr;
    }
	HRESULT hr1 = hr;

    hr = InitBSCs();
    if (FAILED(hr))
    {
        return(hr);
    }
	if (hr1 == MQSync_I_NO_SERVERS_RESULTS &&	//there is no NT4 PSCs in Enterprise
		hr == MQSync_I_NO_SERVERS_RESULTS)		//there is no NT4 BSCs
	{
		//
		// we have to clean-up all and delete replication service
		//
		DeleteReplicationService();
		return MQSync_I_NO_SERVERS_RESULTS;
	}	

    hr = InitNativeNT5Site();

    hr = _InitCNs();
    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // RPC connection to performance dll
    //
    hr = InitRPCConnection();
    if (FAILED(hr))
    {
        return(hr);
    }

    return MQSync_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\rpupdate.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rpupdate.cpp (copied from Falcon tree, update.cpp).

Abstract:

    DS Update Class Implementation

Author:

    Lior Moshaiov (LiorM)


--*/

#include "mq1repl.h"

#include "rpupdate.tmh"

//+--------------------------------
//
// CDSUpdate::~CDSUpdate()
//
//+--------------------------------

CDSUpdate::~CDSUpdate()
{
}

/*====================================================

RoutineName
    CDSUpdate::UpdateDB()

Arguments:

Return Value:

Threads:Receive

  Update the DB with received update

=====================================================*/

HRESULT CDSUpdate::UpdateDB( IN  BOOL fSync0,
							 OUT BOOL *pfNeedFlush)
{
    ASSERT(WasInc()) ;

    HRESULT hr = MQ_OK ;
    DWORD dwObjectType;
    P< CList<CDSUpdate *, CDSUpdate *> > plistUpdatedObjects = NULL;

    if (pfNeedFlush != NULL)
    {
        *pfNeedFlush = FALSE;
    }

    dwObjectType = PROPID_TO_OBJTYPE(GetObjectType());

    LPWSTR pwcsPathName = NULL;
    hr = g_pMasterMgr->GetPathName (GetMasterId(), &pwcsPathName);  
    ASSERT(SUCCEEDED(hr));

    switch (GetCommand())
    {
        case DS_UPDATE_CREATE:

            hr = ReplicationCreateObject(
                               GetObjectType(),
                               GetPathName(),
                               getNumOfProps(),
                               GetProps(),
                               GetVars(),
                               TRUE,
                               GetMasterId(),
                               const_cast<CSeqNum *>(&GetSeqNum()),
                               ENTERPRISE_SCOPE ) ;            
            if (FAILED(hr))
            {
                g_Counters.IncrementInstanceCounter(pwcsPathName, eRcvCreateError);
            }
            else
            {
                g_Counters.IncrementInstanceCounter(pwcsPathName, eRcvCreate);
            }            
            return(hr);

        case DS_UPDATE_SET:

            hr = ReplicationSetProps(
                                  GetObjectType(),
                                  GetPathName(),
                                  GetGuidIdentifier(),
                                  getNumOfProps(),
                                  GetProps(),
                                  GetVars(),
                                  TRUE,
                                  GetMasterId(),
                                  const_cast<CSeqNum *>(&GetSeqNum()),
                                  NULL,    // no need to know previous sn
                                  ENTERPRISE_SCOPE,
                                  FALSE,
                                  FALSE,   // an object not owned by this server
                                  NULL);            
            if (FAILED(hr))
            {
                g_Counters.IncrementInstanceCounter(pwcsPathName, eRcvSetError);
            }
            else
            {
                g_Counters.IncrementInstanceCounter(pwcsPathName, eRcvSet);
            }          
            return(hr);

        case DS_UPDATE_DELETE:

            //
            // The format of deleted object update is
            // one property which defines its scope
            //
            ASSERT(getNumOfProps() == 2 && GetProps()[0] == PROPID_D_SCOPE && GetProps()[1] == PROPID_D_OBJTYPE);

            hr = ReplicationDeleteObject(
                                    GetVars()[1].bVal,
                                    GetPathName(),
                                    GetGuidIdentifier(),
                                    GetVars()[0].bVal,
                                    GetMasterId(),
                                    const_cast<CSeqNum *>(&GetSeqNum()),
                                    NULL,       // no need to know previous sn
                                    FALSE,   // an object not owned by this server
									fSync0,
                                    &plistUpdatedObjects);

            //
            //  If any other machines were updated because of a deleted machines
            //  propogate the updates and send notifications
            //
            if (plistUpdatedObjects)
            {
                ASSERT(0) ;
////////////////PropogateUpdatedObjects( plistUpdatedObjects);
            }            
            if (FAILED(hr))
            {
                g_Counters.IncrementInstanceCounter(pwcsPathName, eRcvDeleteError);
            }
            else
            {
                g_Counters.IncrementInstanceCounter(pwcsPathName, eRcvDelete);
            }            
            return(hr);

        case DS_UPDATE_SYNC:
            {
                BOOL fIsObjectCreated = FALSE;
                hr = ReplicationSyncObject(
                                      CDSBaseUpdate::GetObjectType(),
                                      GetPathName(),
                                      GetGuidIdentifier(),
                                      getNumOfProps(),
                                      GetProps(),
                                      GetVars(),
                                      GetMasterId(),
                                      const_cast<CSeqNum *>(&GetSeqNum()),
                                      &fIsObjectCreated
                                      ) ;             
                if (FAILED(hr))
                {
                    if (fIsObjectCreated)
                    {
                        g_Counters.IncrementInstanceCounter(pwcsPathName, eRcvCreateError);
                    }
                    else
                    {
                        g_Counters.IncrementInstanceCounter(pwcsPathName, eRcvSetError);
                    }
                }
                else
                {
                    if (fIsObjectCreated)
                    {
                        g_Counters.IncrementInstanceCounter(pwcsPathName, eRcvCreate);
                    }
                    else
                    {
                        g_Counters.IncrementInstanceCounter(pwcsPathName, eRcvSet);
                    }
                }      
            }
            return(hr);            
        default:
            return(MQDS_WRONG_UPDATE_DATA);

    }

    return MQ_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\updtlist.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dstrnspr.h

Abstract:

    DS Update List Class Implementation

Author:

    Lior Moshaiov (LiorM)


--*/

#include "mq1repl.h"

#include "updtlist.tmh"

//+-----------------------------------
//
//  CDSUpdateList::AddUpdate()
//
//+-----------------------------------

HRESULT CDSUpdateList::AddUpdate(IN CDSUpdate* pUpdate)
{
    pUpdate->AddRef();

    {   // CS scope
        CS Lock(m_cs);
        m_UpdateList.AddTail(pUpdate);
    }   // End CS scope

    return(MQ_OK);
}

//+-----------------------------------
//
//  CDSUpdateList::AddUpdateSorted()
//
//  That's not an optimal implementation. If time permit after NT5 beta2,
//  I'll improve it  (DoronJ, 05-Apr-98).
//
//+-----------------------------------

HRESULT CDSUpdateList::AddUpdateSorted(IN CDSUpdate* pUpdateIn)
{
    //
    //  Increment the ref count of the update, this guarantees it won't be
    //  destructed  while in the list.
    //
    pUpdateIn->AddRef();

    {   // CS scope
        CS Lock(m_cs);

        POSITION pos = m_UpdateList.GetHeadPosition();
        if (pos == NULL)
        {
            m_UpdateList.AddTail(pUpdateIn);
        }
        else
        {
            POSITION posPrev = pos ;
            CSeqNum snIn = pUpdateIn->GetSeqNum() ;
            CDSUpdate *pUpdate = m_UpdateList.GetNext(pos);

            do
            {
                CSeqNum snCurrent = pUpdate->GetSeqNum() ;
                if (snIn < snCurrent)
                {
                    m_UpdateList.InsertBefore(posPrev, pUpdateIn) ;
                    break ;
                }

                posPrev = pos ;
                if (pos)
                {
                    pUpdate = m_UpdateList.GetNext(pos);
                }
            }
            while (posPrev != NULL) ;

            if (posPrev == NULL)
            {
                m_UpdateList.AddTail(pUpdateIn);
            }
        }

    }   // End CS scope

    return(MQ_OK);
}

/*====================================================

RoutineName
    CDSUpdateList::Send()

Arguments:

Return Value:

Threads:Scheduler

=====================================================*/

HRESULT CDSUpdateList::Send(IN LPWSTR        pszConnection,
                            IN unsigned char bFlush,
                            IN DWORD         dwHelloSize,
                            IN unsigned char * pHelloBuf,
                            IN HEAVY_REQUEST_PARAMS* pSyncRequestParams)
{

    POSITION pos, pos1;
    CDSUpdate * pUpdate;
    unsigned char *ptr;
    DWORD   Size;
    HRESULT status = MQ_OK;
    unsigned short count;
    int ref;

    CS lock(m_cs);

    pos = m_UpdateList.GetHeadPosition();
    pos1 = pos;
    DWORD dwNow = GetTickCount();

    if ((dwNow - m_dwLastTimeHello) < g_dwHelloInterval)
    {
        //
        // don't send hello
        // unless enough time have passed
        //
        pHelloBuf = NULL;
    }

    if (pos == NULL && pHelloBuf == NULL && pSyncRequestParams == NULL)
    {
        //
        // empty list of updates
        // no need to send hello
        // no need to send sync reply
        //
        return (MQ_OK);
    }

    //
    //  Build the replication messages. Each message has a size limit.
    //
    do
    {
        //
        // Calculate needed size
        //
        DWORD TotalSize;
        if (pSyncRequestParams)
        {
            TotalSize = CSyncReplyHeader::CalcSize();
        }
        else
        {
            TotalSize = CReplicationHeader::CalcSize();
        }
        count = 0;

        //
        // updates
        //
        while ((pos != NULL) &&
               ( TotalSize < MAX_REPL_MSG_SIZE))
        {
            pUpdate = m_UpdateList.GetNext(pos);
            status = pUpdate->GetSerializeSize(&Size);
            if (FAILED(status))
            {
                return(status);
            }
            TotalSize += Size;
            count++;
        }

        //
        // allocate
        //
        TotalSize += (pos == NULL && pHelloBuf != NULL) ? dwHelloSize : sizeof(unsigned short);
        AP<unsigned char> pBuf = new unsigned char[TotalSize];

        //
        // Write Replication header
        //
#ifdef _DEBUG
#undef new
#endif
        CSyncReplyHeader   * pSyncReplyMsg = NULL;
        CReplicationHeader * pReplicationMsg;

        if (pSyncRequestParams)
        {
            pSyncReplyMsg = new((unsigned char *)pBuf) CSyncReplyHeader(
                                      DS_PACKET_VERSION,
                                      &g_MySiteMasterId,
                                      DS_SYNC_REPLY,
                                      &pSyncRequestParams->guidSourceMasterId,
                                      pSyncRequestParams->snFrom,
                                      pSyncRequestParams->snTo,
									  pSyncRequestParams->snKnownPurged,
                                      count);
        }
        else
        {
            pReplicationMsg = new((unsigned char *)pBuf) CReplicationHeader(
                                         DS_PACKET_VERSION,
                                         &g_MySiteMasterId,
                                         DS_REPLICATION_MESSAGE,
                                         bFlush,
                                         count );
        }
#ifdef _DEBUG
#define new DEBUG_NEW
#endif


        //
        // write updates
        //
        if (pSyncRequestParams)
        {
            //
            // sync reply message
            //
            TotalSize = CSyncReplyHeader::CalcSize();
            if (pSyncRequestParams->bIsSync0)
            {
                ASSERT(pSyncReplyMsg);
                pSyncReplyMsg->SetCompleteSync0(COMPLETE_SYNC0_NOW);
            }
        }
        else
        {
            TotalSize = CReplicationHeader::CalcSize();
        }

        ptr = pBuf + TotalSize;

        while ((pos1 != NULL) &&
               ( TotalSize < MAX_REPL_MSG_SIZE))
        {
            pUpdate = m_UpdateList.GetNext(pos1);
            pUpdate->Serialize(ptr,&Size,m_fInterSite);
            TotalSize += Size;
            ptr += Size;

        }

        if (!pSyncRequestParams)
        {
            //
            // sync reply message does not include Hello
            //
            if (pos == NULL && pHelloBuf != NULL)
            {
                //
                // last segment of replication, concatanate the hello packet
                //
                memcpy(ptr,pHelloBuf,dwHelloSize);
                ptr += dwHelloSize;
                TotalSize += dwHelloSize;
                m_dwLastTimeHello = dwNow;
            }
            else
            {
                //
                // no Hellos
                //
                memset(ptr,0,sizeof(unsigned short));
                ptr += sizeof(unsigned short);
                TotalSize += sizeof(unsigned short);
            }
        }
        
        //
        // send replication
        //
        status = g_pTransport->SendReplication( pszConnection,
                                                pBuf,
                                                TotalSize,
                                                g_dwReplicationMsgTimeout,
                                                MQMSG_ACKNOWLEDGMENT_NONE,
                                                DS_REPLICATION_PRIORITY,
                                                NULL) ;
        if (FAILED(status))
        {
            return(status);
        }

        //
        //  Continue if there more updates to send
        //
    }
    while ( pos != NULL);

    //
    // release update instance
    //
    pos = m_UpdateList.GetHeadPosition();

    while (pos != NULL)
    {
        pUpdate = m_UpdateList.GetNext(pos);
        ref = pUpdate->Release();
        ASSERT(ref >= 0) ;
        if (ref == 0)
        {
            //
            // not exist in other destination lists
            //
            delete pUpdate;
        }
    }

    m_UpdateList.RemoveAll();

    return(status);
}

//+----------------------------------------------------------
//
//  HRESULT CDSUpdateList::ComputePrevAndPropagate()
//
//  If "pNeighbor" and "psnPrev" are not NULL than it's a sync request
//  from that neighbor.
//
//+----------------------------------------------------------

HRESULT CDSUpdateList::ComputePrevAndPropagate( IN  CDSMaster   *pMaster,
                                                IN  CDSNeighbor *pNeighbor,
                                                IN  UINT         uiFlush,
                                                IN  CSeqNum     *psnPrev,
                                                OUT CSeqNum     *psn )
{
    CSeqNum sn ;
    POSITION pos = m_UpdateList.GetHeadPosition();

    if (pos == NULL && pNeighbor)
    {
        //
        // we was asked for SyncRequest but there were no changes in DS
        // the only thing we have to do is increment psnPrev and put result to *psn
        // it will be ToSN for empty SyncReply message
        // in MSMQ1.0, master.cpp, line 1246 (function CDSMaster:ReceiveSyncReplyMessage)
        // we check if the SyncReply message is empty using two conditions:
        // - count of changes dwCount is equal to 0
        // - (ToSN-PrevSN) is equal to 1
        //
        ASSERT(psnPrev);
        *psn = *psnPrev;
        psn->Increment();
        return MQSync_OK ;
    }

    ASSERT(pos != NULL) ;

    CSeqNum snPrev ;
    if (psnPrev)
    {
        ASSERT(pNeighbor) ;
        snPrev = *psnPrev ;
    }
    else
    {
        ASSERT(!pNeighbor) ;
    }

    while (pos != NULL)
    {
        CDSUpdate *pUpdate = m_UpdateList.GetNext(pos);

        //
        // Compute prev seq num.
        //
        sn = pUpdate->GetSeqNum() ;
        if (!psnPrev)
        {
            sn = pMaster->IncrementLSN( &snPrev,
                                        ENTERPRISE_SCOPE,
                                        &sn ) ;
        }
        pUpdate->SetPrevSeqNum(snPrev) ;

        if (pNeighbor)
        {
            //
            // These updates are targeted only to this specific neighbor.
            //
            pNeighbor->AddUpdate(pUpdate) ;
        }
        else
        {
            //
            // Propagate this update to all neighbors.
            //
            g_pNeighborMgr->PropagateUpdate( ENTERPRISE_SCOPE,
                                             pUpdate,
                                             uiFlush );
        }

        //
        // Release pUpdate. It was AddRefed while propagated.
        //
        int ref = pUpdate->Release();
        if (ref == 0)
        {
            delete pUpdate ;
        }

        if (psnPrev)
        {
            snPrev = sn ;
        }
    }

    m_UpdateList.RemoveAll();

    *psn = sn ;

    return MQSync_OK ;
}

//+-------------------------------------------
//
//  HRESULT CDSUpdateList::GetHoleSN ()
//
//+-------------------------------------------

HRESULT CDSUpdateList::GetHoleSN (
                            IN  CSeqNum     MinSN,
                            IN  CSeqNum     MaxSN,
                            OUT CSeqNum     *pHoleSN
                            )
{
    POSITION pos = m_UpdateList.GetHeadPosition();
  //  ASSERT(pos != NULL) ;

    CSeqNum PrevSN;
    PrevSN.SetInfiniteLSN() ; // for the first time

    pHoleSN->SetInfiniteLSN() ;

    CSeqNum CurSN;
    CurSN.SetSmallestValue();

    while (pos != NULL)
    {
        CDSUpdate *pUpdate = m_UpdateList.GetNext(pos);
        CurSN = pUpdate->GetSeqNum() ;

        //
        // the first step
        //
        if (PrevSN.IsInfiniteLsn() &&
            CurSN > MaxSN)
        {
            //
            // it means that we have to assign the MaxSN to hole
            // since all SN in the list more than given MaxSN
            // If there is no hole in the list we'll return error
            // although we have free SN smaller than in the list
            //
            *pHoleSN = MaxSN;
            return MQSync_OK ;
        }

        //
        // the next steps
        //
        if (!PrevSN.IsInfiniteLsn() &&
            PrevSN.IsSmallerByMoreThanOne(CurSN) )
        {
            //
            // it is hole
            //
            *pHoleSN = PrevSN;
            pHoleSN->Increment();
            return MQSync_OK ;
        }

        PrevSN = CurSN;
    }

    if (CurSN.IsSmallestValue())
    {
        *pHoleSN = MinSN;
        return MQSync_OK ;
    }

    if (CurSN < MaxSN)
    {
        *pHoleSN = CurSN;
        pHoleSN->Increment();
    }

    return MQSync_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1sync\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1sync\service.h ===
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//      Filename :  Service.h                                                //
//      Purpose  :  A service API's encapsulator.                            //
//                                                                           //
//      Project  :  GenServ (GenericServic)                                  //
//                                                                           //
//      Author   :  t-urib                                                   //
//                                                                           //
//      Log:                                                                 //
//          22/1/96 t-urib Creation                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef SERVICE_H
#define SERVICE_H

#include <Windows.h>
#include <lmcons.h>
#include <lmServer.h>
#include "tracer.h"

// The three encapsulators defined in this file.
class CServiceStatus;   // Used to report a service status - derived from the
                        //   SERVICE_STATUS struct.
class CService;         // An encapsulator for a service object.
class CSCManager;       // An encapsulator for a Service control object.
                        //   By calling methods on CSCManager you get a pointer
                        //   for CService objects.


///////////////////////////////////////////////////////////////////////////////
//
// class CServiceStatus
//
//      purpose : A object that reports a service status.
//
//
//
///////////////////////////////////////////////////////////////////////////////
class  CServiceStatus : public CTraced, public SERVICE_STATUS {
  public:
    // Constructor - uses a status handle to create the object.
    //   Another way to create this object is to call
    //   RegisterServiceCtrlHandler on a CService.
    CServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus);

    // An overload that returns the object's service status handle.
    operator SERVICE_STATUS_HANDLE();

    // Report the status set in CServiceStatus to the service control manager.
    //   This class inherits from SERVICE_STATUS structure and therefore acts
    //   the same. So in order to change a SERVICE_STATUS field call
    //   pServiceStatus->dwCheckPoint = 45;
    virtual BOOL Set();

    // Returns the dwCurrentState field of the SERVICE_STATUS structure.
    virtual DWORD Get();

    // Enables and Disables the accepted controls
    void EnableControls();
    void DisableControls();

  private:
    // The handle.
    SERVICE_STATUS_HANDLE   m_hServiceStatus;

    // a place to save the default
    DWORD                   m_dwControlsAcceptedDefault;
    BOOL                    m_fControlsAccepted;
};


///////////////////////////////////////////////////////////////////////////////
//
// class CService
//
//      purpose : A object that encapsulates a service.
//
//
//
///////////////////////////////////////////////////////////////////////////////
class  CService : public CTraced {
  public:
    // Constructed by CSCManager or by a derived class.
    ~CService();

    // Data access routines
    //----------------------------------------------------------
    // Returns the service handle.
    operator SC_HANDLE();

    // Encapsulated API's.
    //----------------------------------------------------------
    BOOL StartService(
        DWORD   dwNumServiceArgs,       // number of arguments
        LPCTSTR * lpServiceArgVectors); // address of array of argument string pointers

    BOOL ControlService(
        DWORD            dwControl,         // control code
        LPSERVICE_STATUS lpServiceStatus);  // pointer to service status structure

    BOOL DeleteService();

    BOOL QueryServiceConfig(
        LPQUERY_SERVICE_CONFIG  lpServiceConfig,// address of service config. structure
        DWORD   cbBufSize,          // size of service configuration buffer
        LPDWORD pcbBytesNeeded);    // address of variable for bytes needed

    BOOL ChangeServiceConfig(
        DWORD    dwServiceType,     // type of service
        DWORD    dwStartType,       // when to start service
        DWORD    dwErrorControl,    // severity if service fails to start
        LPCTSTR  lpBinaryPathName,  // pointer to service binary file name
        LPCTSTR  lpLoadOrderGroup,  // pointer to load ordering group name
        LPDWORD  lpdwTagId,         // pointer to variable to get tag identifier
        LPCTSTR  lpDependencies,    // pointer to array of dependency names
        LPCTSTR  lpServiceStartName,// pointer to account name of service
        LPCTSTR  lpPassword,        // pointer to password for service account
        LPCTSTR  lpDisplayName);    // pointer to display name

    BOOL QueryServiceStatus(
        LPSERVICE_STATUS  lpServiceStatus); // address of service status structure

    BOOL EnumDependentServices(
        DWORD  dwServiceState,      // state of services to enumerate
        LPENUM_SERVICE_STATUS  lpServices,  // pointer to service status buffer
        DWORD  cbBufSize,           // size of service status buffer
        LPDWORD  pcbBytesNeeded,    // pointer to variable for bytes needed
        LPDWORD  lpServicesReturned);// pointer to variable for number returned

    BOOL GetServiceDisplayName(
        LPCTSTR  lpServiceName, // the service name
        LPTSTR   lpDisplayName, // buffer to receive the service's display name
        LPDWORD  lpcchBuffer);  // size of display name buffer and display name

    BOOL QueryServiceObjectSecurity(
        SECURITY_INFORMATION  dwSecurityInformation,// type of security information requested
        PSECURITY_DESCRIPTOR  lpSecurityDescriptor, // address of security descriptor
        DWORD    cbBufSize,     // size of security descriptor buffer
        LPDWORD  pcbBytesNeeded);// address of variable for bytes needed

    BOOL SetServiceObjectSecurity(
        SECURITY_INFORMATION  dwSecurityInformation,    // type of security information requested
        PSECURITY_DESCRIPTOR  lpSecurityDescriptor);    // address of security descriptor

  protected:
    // Constructor - called from CSCManager or from derived classes.
    CService(SC_HANDLE hService = NULL);

    friend class CSCManager;

  private:
    // The service handle -
    SC_HANDLE   m_hService;
};

class  CSCManager : public CTraced{
  public:
    CSCManager(
        LPCTSTR  lpMachineName,     // address of machine name string
        LPCTSTR  lpDatabaseName,    // address of database name string
        DWORD    dwDesiredAccess);  // type of access

    ~CSCManager();

    // Data access routines
    //----------------------------------------------------------
    // Returns the service control handle.
    operator SC_HANDLE();

    // Encapsulated API's.
    //----------------------------------------------------------
    CService* CreateService(
        LPCTSTR  lpServiceName,     // pointer to name of service to start
        LPCTSTR  lpDisplayName,     // pointer to display name
        DWORD    dwDesiredAccess,   // type of access to service
        DWORD    dwServiceType,     // type of service
        DWORD    dwStartType,       // when to start service
        DWORD    dwErrorControl,    // severity if service fails to start
        LPCTSTR  lpBinaryPathName,  // pointer to name of binary file
        LPCTSTR  lpLoadOrderGroup,  // pointer to name of load ordering group
        LPDWORD  lpdwTagId,         // pointer to variable to get tag identifier
        LPCTSTR  lpDependencies,    // pointer to array of dependency names
        LPCTSTR  lpServiceStartName,// pointer to account name of service
        LPCTSTR  lpPassword);       // pointer to password for service account


    CService* OpenService(
        LPCTSTR  lpServiceName,     // address of name of service to start
        DWORD    dwDesiredAccess);  // type of access to service

    BOOL EnumServicesStatus(
        DWORD    dwServiceType,     // type of services to enumerate
        DWORD    dwServiceState,    // state of services to enumerate
        LPENUM_SERVICE_STATUS  lpServices,  // pointer to service status buffer
        DWORD    cbBufSize,         // size of service status buffer
        LPDWORD  pcbBytesNeeded,    // pointer to variable for bytes needed
        LPDWORD  lpServicesReturned,// pointer to variable for number returned
        LPDWORD  lpResumeHandle);   // pointer to variable for next entry

    BOOL GetServiceKeyName(
        LPCTSTR  lpDisplayName, // the service's display name
        LPTSTR   lpServiceName, // buffer to receive the service name
        LPDWORD  lpcchBuffer);  // size of service name buffer and service name

    SC_LOCK LockServiceDatabase();
    BOOL  UnlockServiceDatabase();

    BOOL QueryServiceLockStatus(
        LPQUERY_SERVICE_LOCK_STATUS  lpLockStatus,  // address of lock status structure
        DWORD  cbBufSize,       // size of service configuration buffer
        LPDWORD  pcbBytesNeeded);// address of variable for bytes needed
  private:
    // A handle for the Service controler
    SC_HANDLE   m_hServiceControlManager;
    // A handle to the service db lock.
    SC_LOCK     m_Lock;
};

inline
CServiceStatus::CServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus)
{
    // Set the tracer strings
    SetTracer(new CTracer("CServiceStatus", DeleteTracer));

    m_hServiceStatus = hServiceStatus;
    m_dwControlsAcceptedDefault = 0xFFFFFFFF;
    m_fControlsAccepted = TRUE;

    dwServiceType       = SERVICE_WIN32_OWN_PROCESS;
    dwCurrentState      = SERVICE_STOPPED;
    dwControlsAccepted  = SERVICE_ACCEPT_STOP|
                          SERVICE_ACCEPT_PAUSE_CONTINUE|
                          SERVICE_ACCEPT_SHUTDOWN;
    dwWin32ExitCode     = NO_ERROR;
    dwServiceSpecificExitCode = 0;
    dwCheckPoint        = 0;
    dwWaitHint          = 5 * 60 * 1000; // 5 minutes
}

inline
CServiceStatus::operator SERVICE_STATUS_HANDLE()
{
    return m_hServiceStatus;
}

inline
DWORD CServiceStatus::Get()
{
    return dwCurrentState;
}

inline
BOOL CServiceStatus::Set()
{
    BOOL fSuccess;

    AssertSZ(m_hServiceStatus, "Service status handle is not valid");

	if ((SERVICE_START_PENDING == dwCurrentState)||
		(SERVICE_STOP_PENDING == dwCurrentState )||
		(SERVICE_PAUSE_PENDING == dwCurrentState)||
		(SERVICE_CONTINUE_PENDING == dwCurrentState))
		dwCheckPoint++;
	else
		dwCheckPoint = 0;
		
	fSuccess = ::SetServiceStatus(m_hServiceStatus,
                                    (LPSERVICE_STATUS)this);
    IS_FAILURE(fSuccess);
    return fSuccess;
}

inline
void CServiceStatus::EnableControls()
{
    Assert(!m_fControlsAccepted);

    dwControlsAccepted  = m_dwControlsAcceptedDefault;
    m_fControlsAccepted = TRUE;
}

inline
void CServiceStatus::DisableControls()
{
    Assert(m_fControlsAccepted);

    m_dwControlsAcceptedDefault = dwControlsAccepted;
    m_fControlsAccepted = FALSE;
}


inline
CService::CService(SC_HANDLE hService)
{
	SetTracer(new CTracer("CService", DeleteTracer));
    m_hService = hService;
	IS_BAD_HANDLE(hService);
}

inline
CService::~CService()
{
    BOOL fSuccess = TRUE;

    if(m_hService)
        fSuccess = ::CloseServiceHandle(m_hService);
    IS_FAILURE(fSuccess);
}

inline
CService::operator SC_HANDLE()
{
    return m_hService;
}

inline
BOOL CService::StartService(
        DWORD   dwNumServiceArgs,       // number of arguments
        LPCTSTR * lpServiceArgVectors)  // address of array of argument string pointers
{
    BOOL fSuccess;

    AssertSZ(m_hService, "The service is not open");

    fSuccess = ::StartService(m_hService, dwNumServiceArgs, lpServiceArgVectors);

    IS_FAILURE(fSuccess);
    return fSuccess;
}

inline
BOOL CService::ControlService(
        DWORD            dwControl,         // control code
        LPSERVICE_STATUS lpServiceStatus)   // pointer to service status structure
{
    BOOL fSuccess;

    AssertSZ(m_hService, "The service is not open");

    fSuccess = ::ControlService(m_hService, dwControl, lpServiceStatus);

    IS_FAILURE(fSuccess);
    return fSuccess;
}


inline
BOOL CService::DeleteService()
{
    BOOL fSuccess;

    AssertSZ(m_hService, "The service is not open");

    fSuccess = ::DeleteService(m_hService);

    IS_FAILURE(fSuccess);
    return fSuccess;
}

inline
BOOL CService::QueryServiceConfig(
        LPQUERY_SERVICE_CONFIG  lpServiceConfig,// address of service config. structure
        DWORD   cbBufSize,          // size of service configuration buffer
        LPDWORD pcbBytesNeeded)     // address of variable for bytes needed
{
    BOOL fSuccess;

    AssertSZ(m_hService, "The service is not open");

    fSuccess = ::QueryServiceConfig(m_hService, lpServiceConfig, cbBufSize, pcbBytesNeeded);

    IS_FAILURE(fSuccess);
    return fSuccess;
}

inline
BOOL CService::ChangeServiceConfig(
        DWORD    dwServiceType,     // type of service
        DWORD    dwStartType,       // when to start service
        DWORD    dwErrorControl,    // severity if service fails to start
        LPCTSTR  lpBinaryPathName,  // pointer to service binary file name
        LPCTSTR  lpLoadOrderGroup,  // pointer to load ordering group name
        LPDWORD  lpdwTagId,         // pointer to variable to get tag identifier
        LPCTSTR  lpDependencies,    // pointer to array of dependency names
        LPCTSTR  lpServiceStartName,// pointer to account name of service
        LPCTSTR  lpPassword,        // pointer to password for service account
        LPCTSTR  lpDisplayName)     // pointer to display name
{
    BOOL fSuccess;

    AssertSZ(m_hService, "The service is not open");

    fSuccess = ::ChangeServiceConfig(m_hService, dwServiceType, dwStartType,
        dwErrorControl, lpBinaryPathName, lpLoadOrderGroup, lpdwTagId,
        lpDependencies, lpServiceStartName, lpPassword, lpDisplayName);

    IS_FAILURE(fSuccess);
    return fSuccess;
}

inline
BOOL CService::QueryServiceStatus(
            LPSERVICE_STATUS  lpServiceStatus)  // address of service status structure
{
    BOOL fSuccess;

    AssertSZ(m_hService, "The service is not open");

    fSuccess = ::QueryServiceStatus(m_hService, lpServiceStatus);

    IS_FAILURE(fSuccess);
    return fSuccess;
}

inline
BOOL CService::EnumDependentServices(
        DWORD  dwServiceState,      // state of services to enumerate
        LPENUM_SERVICE_STATUS  lpServices,  // pointer to service status buffer
        DWORD  cbBufSize,           // size of service status buffer
        LPDWORD  pcbBytesNeeded,    // pointer to variable for bytes needed
        LPDWORD  lpServicesReturned)// pointer to variable for number returned
{
    BOOL fSuccess;

    AssertSZ(m_hService, "The service is not open");

    fSuccess = ::EnumDependentServices(m_hService, dwServiceState, lpServices,
        cbBufSize, pcbBytesNeeded, lpServicesReturned);

    IS_FAILURE(fSuccess);
    return fSuccess;
}

inline
BOOL CService::GetServiceDisplayName(
        LPCTSTR  lpServiceName, // the service name
        LPTSTR   lpDisplayName, // buffer to receive the service's display name
        LPDWORD  lpcchBuffer)   // size of display name buffer and display name
{
    BOOL fSuccess;

    AssertSZ(m_hService, "The service is not open");

    fSuccess = ::GetServiceDisplayName(m_hService, lpServiceName,
        lpDisplayName, lpcchBuffer);

    IS_FAILURE(fSuccess);
    return fSuccess;
}

inline
BOOL CService::QueryServiceObjectSecurity(
        SECURITY_INFORMATION  dwSecurityInformation,// type of security information requested
        PSECURITY_DESCRIPTOR  lpSecurityDescriptor, // address of security descriptor
        DWORD    cbBufSize,     // size of security descriptor buffer
        LPDWORD  pcbBytesNeeded)// address of variable for bytes needed
{
    BOOL fSuccess;

    AssertSZ(m_hService, "The service is not open");

    fSuccess = ::QueryServiceObjectSecurity(m_hService, dwSecurityInformation,
        lpSecurityDescriptor, cbBufSize, pcbBytesNeeded);

    IS_FAILURE(fSuccess);
    return fSuccess;
}

inline
BOOL CService::SetServiceObjectSecurity(
        SECURITY_INFORMATION  dwSecurityInformation,    // type of security information requested
        PSECURITY_DESCRIPTOR  lpSecurityDescriptor)     // address of security descriptor
{
    BOOL fSuccess;

    AssertSZ(m_hService, "The service is not open");

    fSuccess = ::SetServiceObjectSecurity(m_hService, dwSecurityInformation,
                                            lpSecurityDescriptor);
    IS_FAILURE(fSuccess);
    return fSuccess;
}

inline
CSCManager::CSCManager(
        LPCTSTR  lpMachineName,     // address of machine name string
        LPCTSTR  lpDatabaseName,    // address of database name string
        DWORD  dwDesiredAccess)     // type of access
{
    SetTracer(new CTracer("CSCManager - Service Control Manager", DeleteTracer));

    m_hServiceControlManager = ::OpenSCManager(
                                lpMachineName, lpDatabaseName, dwDesiredAccess);
    if(IS_BAD_HANDLE(m_hServiceControlManager))
    {
        Trace(tagError, "CSCManager could not initialize!");
    }
}

inline
CSCManager::~CSCManager()
{
    BOOL fSuccess = ::CloseServiceHandle(m_hServiceControlManager);
    IS_FAILURE(fSuccess);
}

inline
CSCManager::operator SC_HANDLE()
{
    return m_hServiceControlManager;
}

inline
CService* CSCManager::CreateService(
        LPCTSTR  lpServiceName,     // pointer to name of service to start
        LPCTSTR  lpDisplayName,     // pointer to display name
        DWORD    dwDesiredAccess,   // type of access to service
        DWORD    dwServiceType,     // type of service
        DWORD    dwStartType,       // when to start service
        DWORD    dwErrorControl,    // severity if service fails to start
        LPCTSTR  lpBinaryPathName,  // pointer to name of binary file
        LPCTSTR  lpLoadOrderGroup,  // pointer to name of load ordering group
        LPDWORD  lpdwTagId,         // pointer to variable to get tag identifier
        LPCTSTR  lpDependencies,    // pointer to array of dependency names
        LPCTSTR  lpServiceStartName,// pointer to account name of service
        LPCTSTR  lpPassword)        // pointer to password for service account
{
    SC_HANDLE hService;
    CService* s;

    hService = ::CreateService(m_hServiceControlManager, lpServiceName, lpDisplayName,
        dwDesiredAccess, dwServiceType, dwStartType, dwErrorControl, lpBinaryPathName,
        lpLoadOrderGroup, lpdwTagId, lpDependencies, lpServiceStartName, lpPassword);
    if(IS_BAD_HANDLE(hService))
    {
        switch (GetLastError())
        {
        case ERROR_INVALID_PARAMETER:
            Trace(tagError,
                "CreateService: could not create a service! - invalid parameter");
            break;
        case ERROR_ACCESS_DENIED:
            Trace(tagError,
                "CreateService: could not create a service! - Access denied");
            break;
        case ERROR_CIRCULAR_DEPENDENCY:
            Trace(tagError,
                "CSCManager::CreateService: could not create a service! - Circular dependency");
            break;
        case ERROR_DUP_NAME:
            Trace(tagError,
                "CSCManager::CreateService: could not create a service! - Duplicate name");
            break;
        case ERROR_INVALID_HANDLE:
            Trace(tagError,
                "CSCManager::CreateService: could not create a service! - Bad SC handle");
            break;
        case ERROR_INVALID_NAME:
            Trace(tagError,
                "CSCManager::CreateService: could not create a service! - Bad name");
            break;
        case ERROR_INVALID_SERVICE_ACCOUNT:
            Trace(tagError,
                "CSCManager::CreateService: could not create a service! - Bad account");
            break;
        case ERROR_SERVICE_EXISTS:
            Trace(tagError,
                "CSCManager::CreateService: could not create a service! - Service exists");
            break;

        default:
            Trace(tagError,
                "CSCManager::CreateService: could not create a service! - Unknown error");
            break;
        }
        return NULL;
    }

    // alocate a service object
    s = new CService(hService);
    if(IS_BAD_ALLOC(s))
    {
        Trace(tagError, "CSCManager::CreateService: could not allocate memory !");
    }
    return s;
}

inline
CService* CSCManager::OpenService(
        LPCTSTR  lpServiceName,     // address of name of service to start
        DWORD    dwDesiredAccess)   // type of access to service
{
    SC_HANDLE hService;
    CService* s;

    hService = ::OpenService(m_hServiceControlManager, lpServiceName, dwDesiredAccess);
    if(IS_BAD_HANDLE(hService))
    {
        Trace(tagError, "CSCManager::OpenService: could not open a service !");
        return NULL;
    }

    s = new CService(hService);
    if(IS_BAD_ALLOC(s))
    {
        Trace(tagError, "CSCManager::OpenService: could not allocate memory !");
    }
    return s;
}

inline
BOOL CSCManager::EnumServicesStatus(
        DWORD    dwServiceType,     // type of services to enumerate
        DWORD    dwServiceState,    // state of services to enumerate
        LPENUM_SERVICE_STATUS  lpServices,  // pointer to service status buffer
        DWORD    cbBufSize,         // size of service status buffer
        LPDWORD  pcbBytesNeeded,    // pointer to variable for bytes needed
        LPDWORD  lpServicesReturned,// pointer to variable for number returned
        LPDWORD  lpResumeHandle)    // pointer to variable for next entry
{
    BOOL fSuccess = ::EnumServicesStatus(m_hServiceControlManager, dwServiceType,
        dwServiceState, lpServices, cbBufSize, pcbBytesNeeded,
        lpServicesReturned, lpResumeHandle);
    IS_FAILURE(fSuccess);
    return fSuccess;
}

inline
BOOL CSCManager::GetServiceKeyName(
        LPCTSTR  lpDisplayName, // the service's display name
        LPTSTR   lpServiceName, // buffer to receive the service name
        LPDWORD  lpcchBuffer)   // size of service name buffer and service name
{
    BOOL fSuccess;
    fSuccess = ::GetServiceKeyName(m_hServiceControlManager, lpDisplayName,
                                 lpServiceName, lpcchBuffer);
    IS_FAILURE(fSuccess);
    return fSuccess;
}

inline
SC_LOCK CSCManager::LockServiceDatabase()
{
    m_Lock = ::LockServiceDatabase(m_hServiceControlManager);
    IS_BAD_HANDLE(m_Lock);

    return m_Lock;
}

inline
BOOL  CSCManager::UnlockServiceDatabase()
{
    BOOL fSuccess;

    fSuccess = ::UnlockServiceDatabase(m_Lock);
    IS_FAILURE(fSuccess);

    return fSuccess;
}

inline
BOOL CSCManager::QueryServiceLockStatus(
        LPQUERY_SERVICE_LOCK_STATUS  lpLockStatus,  // address of lock status structure
        DWORD  cbBufSize,       // size of service configuration buffer
        LPDWORD  pcbBytesNeeded)// address of variable for bytes needed
{
    BOOL fSuccess;

    fSuccess = ::QueryServiceLockStatus(m_hServiceControlManager, lpLockStatus,
                                        cbBufSize, pcbBytesNeeded);
    IS_FAILURE(fSuccess);

    return fSuccess;
}

#endif //SERVICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1repl\updtlist.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dstrnspr.h

Abstract:

	DS Update List Class definition
		
Author:

	Lior Moshaiov (LiorM)


--*/

#ifndef __UPDSLIST_H__
#define __UPDSLIST_H__

#include "cs.h"
#include "update.h"

class CDSNeighbor ;

class CDSUpdateList
{
	public:
		CDSUpdateList(BOOL fInterSite);
  		~CDSUpdateList();

		HRESULT	AddUpdate(IN CDSUpdate* pUpdate);
		HRESULT	AddUpdateSorted(IN CDSUpdate* pUpdate);

		HRESULT	ComputePrevAndPropagate( IN  CDSMaster   *pMaster,
                                         IN  CDSNeighbor *pNeighbor,
                                         IN  UINT         uiFlush,
                                         IN  CSeqNum     *psnPrev,
                                         OUT CSeqNum     *psn ) ;

		HRESULT	Send(IN LPWSTR        pszConnection,
                     IN unsigned char bFlush,
                     IN DWORD         dwHelloSize,
                     IN unsigned char * pHelloBuf,
                     IN HEAVY_REQUEST_PARAMS* pSyncRequestParams = NULL);

        HRESULT CDSUpdateList::GetHoleSN (
                            IN  CSeqNum     MinSN,
                            IN  CSeqNum     MaxSN,
                            OUT CSeqNum     *pHoleSN
                            );

	private:

		CList<CDSUpdate *, CDSUpdate *>	m_UpdateList;

		CCriticalSection m_cs;			// synchronize access to UpdateList

        BOOL    m_fInterSite;
        DWORD   m_dwLastTimeHello;
};

inline	CDSUpdateList::CDSUpdateList(BOOL fInterSite) :
                                            m_fInterSite(fInterSite)
{
    m_dwLastTimeHello = GetTickCount();
}

inline	CDSUpdateList::~CDSUpdateList()
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1sync\syncmain.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    syncmain.cpp

Abstract:
    Basic service of QM

Author:
    Raphi Renous (raphir)

--*/
#include <windows.h>

#include <string.h>
#include <stdio.h>

//
//  BUGBUG: no standard header file is included.
//          thus ASSERT is not defined. ASSERT is used in inc\qformat.h
//
#define ASSERT(x)

#include "..\mq1repl\rpservc.h"
#include "GenServ.h"
#include "mqnames.h"

#include "syncmain.tmh"

BOOL g_ServiceDbg = 0;
BOOL g_ServiceNorun = 0;

HINSTANCE g_hReplDll = NULL ;


class MQService: public CGenericService
{
public:
   MQService(
             LPSERVICE_MAIN_FUNCTION   pfuncServiceMain,
             LPHANDLER_FUNCTION        pfuncHandler,
             CServiceSet*              pSet
             );
   BOOL Starting();
   void Run();
   void Stop();
   void Pause();
   void Continue();
   void Shutdown();

};


//
// Constructor
//
MQService::MQService(
             LPSERVICE_MAIN_FUNCTION   pfuncServiceMain,
             LPHANDLER_FUNCTION        pfuncHandler,
             CServiceSet*           pSet
             )
   :CGenericService(pfuncServiceMain, pfuncHandler, pSet, "MQ1Sync")
{
}


//
// Initialization of Replication service
//
BOOL MQService::Starting()
{
    //
    //  do not accept pause control
    //
    m_pServiceStatus->dwControlsAccepted =
       SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;

    CGenericService::Starting();

    ASSERT(g_hReplDll == NULL) ;
    g_hReplDll = LoadLibrary(MQ1REPL_DLL_NAME) ;
    ASSERT(g_hReplDll) ;

    if (!g_hReplDll)
    {
        return FALSE ;
    }

    InitReplicationService_ROUTINE pfnInit =
         (InitReplicationService_ROUTINE)
                  GetProcAddress(g_hReplDll, "InitReplicationService") ;
    ASSERT(pfnInit) ;

    BOOL fRes = FALSE ;
    if (pfnInit)
    {
        fRes = (*pfnInit) () ;
    }

    return fRes ;
}

//
// Run the replication service.
//
void MQService::Run()
{
   m_pServiceStatus->Set();

   if (g_hReplDll)
   {
       RunReplicationService_ROUTINE pfnRun =
         (RunReplicationService_ROUTINE)
                    GetProcAddress(g_hReplDll, "RunReplicationService") ;
       ASSERT(pfnRun) ;

       if (pfnRun)
       {
           (*pfnRun) () ;
       }
   }
}

//
// Stopping
//
void MQService::Stop()
{
    m_pServiceStatus->dwCurrentState = SERVICE_STOPPED;

    if (g_hReplDll)
    {
        StopReplicationService_ROUTINE pfnStop =
                 (StopReplicationService_ROUTINE)
                   GetProcAddress(g_hReplDll, "StopReplicationService") ;
        ASSERT(pfnStop) ;

        if (pfnStop)
        {
            (*pfnStop) () ;
        }

        FreeLibrary(g_hReplDll) ;
        g_hReplDll = NULL ;
    }
}


//
// Pausing
//
void MQService::Pause()
{
}


//
// Continue
//
void MQService::Continue()
{
}


//
// Shutdown
//
void MQService::Shutdown()
{
}



///////////////////////////////////////////////////////////////////////////////
//
//  Global parameter
//
///////////////////////////////////////////////////////////////////////////////

DECLARE_SERVICE_SET();

DECLARE_SERVICE(server, MQService);


///////////////////////////////////////////////////////////////////////////////
//
//  Main module
//
///////////////////////////////////////////////////////////////////////////////

int __cdecl main(int argc, char* argv[])
{
   char * * parg;

#ifdef _CHECKED
    // Send asserts to message box
    _set_error_mode(_OUT_TO_MSGBOX);
#endif

   //
   // Parse flags
   //
   parg = &argv[0];
   for(; argc--; parg++)
   {
      if(!strcmp(*parg, "/debug"))
         g_ServiceDbg = 1;

      else if(!strcmp(*parg, "/norun"))
         g_ServiceNorun = 1;

   }

   START_SERVICE_CONTROL_DISPATCHER();

   ExitProcess(1);  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1sync\servset.cpp ===
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//      Filename :  ServSet.cpp                                              //
//      Purpose  :  Implementation to the CGenericService class.			 //
//                                                                           //
//      Project  :  GenServ (GenericService)                                 //
//                                                                           //
//      Author   :  t-urib                                                   //
//                                                                           //
//      Log:                                                                 //
//          22/1/96 t-urib Creation                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include "GenServ.h"

#include "servset.tmh"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
//	ServiceSet class implementation
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  CServiceSet - Constructor to the CServiceSet class.
//					Finds out if we are running as service and cache it,
//					initializes the array of services.
//						
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
CServiceSet::CServiceSet()
    :m_ulUsedEntries(0),
     m_ulAlocatedEntries(10)
{
    SetTracer(new CTracer("CServiceSet", DeleteTracer));

    m_fRunningAsService = ::IsRunningAsService();

    m_pServiceTable = (LPSERVICE_TABLE_ENTRY)
            malloc(m_ulAlocatedEntries*sizeof(SERVICE_TABLE_ENTRY));
    IS_BAD_ALLOC(m_pServiceTable);

    m_pHandlerFunction = (LPHANDLER_FUNCTION*)
            malloc(m_ulAlocatedEntries*sizeof(LPHANDLER_FUNCTION));
    IS_BAD_ALLOC(m_pHandlerFunction);

    m_ppServiceStatus = (CDummyServiceStatus**)
            malloc(m_ulAlocatedEntries*sizeof(CDummyServiceStatus*));
    IS_BAD_ALLOC(m_ppServiceStatus);
}

///////////////////////////////////////////////////////////////////////////////
//
//  CServiceSet - Destructor - release the Services table
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
CServiceSet::~CServiceSet()
{
    free(m_pServiceTable);
    free(m_pHandlerFunction);
    free(m_ppServiceStatus);
}

///////////////////////////////////////////////////////////////////////////////
//
//  CServiceSet - Access method to the cached info about running as service.
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CServiceSet::IsRunningAsService()
{
    return m_fRunningAsService;
}

///////////////////////////////////////////////////////////////////////////////
//
//  CServiceSet - Adds a service to the service table.
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CServiceSet::Add(CGenericService& s)
{
    // check we have room in the table and expand it if needed
    if(m_ulUsedEntries == m_ulAlocatedEntries)
    {
        LPSERVICE_TABLE_ENTRY   pTempEntry;
        LPHANDLER_FUNCTION*     pTmpHandler;
        CDummyServiceStatus**   ppTmpDummyStatus;

        pTempEntry = (LPSERVICE_TABLE_ENTRY) realloc(m_pServiceTable,
                    2 * m_ulAlocatedEntries * sizeof(SERVICE_TABLE_ENTRY));
        if(IS_BAD_ALLOC(pTempEntry))
        {
            Assert(pTempEntry);
            exit(0); // this function is called from the service constructor.
        }            //  which may be global. therefor an error in this
                     //  allocation is fatal

        pTmpHandler = (LPHANDLER_FUNCTION*) realloc(m_pHandlerFunction,
                    2 * m_ulAlocatedEntries * sizeof(LPHANDLER_FUNCTION));
        if(IS_BAD_ALLOC(pTmpHandler))
        {
            Assert(pTmpHandler);
            exit(0); // this function is called from the service constructor.
        }            //  which may be global. therefor an error in this
                     //  allocation is fatal

        ppTmpDummyStatus = (CDummyServiceStatus**) realloc(m_ppServiceStatus,
                    2 * m_ulAlocatedEntries * sizeof(CDummyServiceStatus*));
        if(IS_BAD_ALLOC(ppTmpDummyStatus))
        {
            Assert(ppTmpDummyStatus);
            exit(0); // this function is called from the service constructor.
        }            //  which may be global. therefor an error in this
                     //  allocation is fatal

        m_ulAlocatedEntries = 2 * m_ulAlocatedEntries;

        m_pServiceTable    = pTempEntry;
        m_pHandlerFunction = pTmpHandler;
        m_ppServiceStatus  = ppTmpDummyStatus;
    }

    // set the proper entry
    m_pHandlerFunction[m_ulUsedEntries] = NULL;
    m_ppServiceStatus[m_ulUsedEntries] = NULL;
    m_pServiceTable[m_ulUsedEntries].lpServiceName = (LPTSTR) s.Name();
    m_pServiceTable[m_ulUsedEntries++].lpServiceProc = s.MainProcedure();

    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  RegisterServiceCtrlHandler -
//		Registers the service control handler in the our private services table
//        if running as exe, or in the system using
//		  ::RegisterServiceCtrlHandler API.
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
CServiceStatus* CServiceSet::RegisterServiceCtrlHandler(
            LPCTSTR             lpName,         // Name of service
            LPHANDLER_FUNCTION  lpHandlerProc)  // address of handler function
{
    CServiceStatus          *pss;

    if (IsRunningAsService())
    {	// register the service control handler in the system.
        SERVICE_STATUS_HANDLE   hStatus;

        hStatus = ::RegisterServiceCtrlHandler(lpName, lpHandlerProc);
        IS_BAD_HANDLE(hStatus);

		// Return a CServiceStatus with which the service will report progress to
		//   the system.
        pss = new CServiceStatus(hStatus);
        IS_BAD_ALLOC(pss);
    }
    else
    {	// register the service control handler in our private table.
        ULONG ulService = GetServiceIndex(lpName);

        if(ulService < m_ulUsedEntries)
        {
            m_pHandlerFunction[ulService] = lpHandlerProc;

			// Return a CDummyServiceStatus with which the service will report
			//   progress to US but will think he is reporting to the system.
            m_ppServiceStatus[ulService] = new CDummyServiceStatus();
            pss = m_ppServiceStatus[ulService];
            IS_BAD_ALLOC(pss);
        }
        else
        {
            AssertSZ(0, "This should not happen!");
            return NULL;
        }
    }

    return pss;
}

///////////////////////////////////////////////////////////////////////////////
//
//  StartServiceCtrlDispatcher -
//		If we are running as a service register the service table in the system
//        and call the StartServiceCtrlDispatcher API. If running as an exe we
//		  start a dummy control dispatcher. FillTerminatingEntry must
//		  be called before this call so the API will not cause a GP.
//
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CServiceSet::StartServiceCtrlDispatcher()
{
    BOOL fSuccess;

    Assert(m_pServiceTable);

    FillTerminatingEntry();

    Trace(tagInformation, "Starting services");

    if(!IsRunningAsService())
        // if we do it ourself
        fSuccess = StartDummyServiceCtrlDispatcher();
    else
        // be serious - we run as a service!
        fSuccess = ::StartServiceCtrlDispatcher(m_pServiceTable);

    IS_FAILURE(fSuccess);

    Trace(tagInformation, "Services stopped");

    return fSuccess;
}

///////////////////////////////////////////////////////////////////////////////
//
//  StartDummyServiceCtrlDispatcher -
//		We are running as an exe so we have to act like the system as far as
//		  the service feels and act as the control panel as far as the user
//		  feels.
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CServiceSet::StartDummyServiceCtrlDispatcher()
{
    BOOL    fQuit = FALSE;
    char    rchBuff[256];
    ULONG   ulService;
    DWORD   dwID;
    HANDLE  hThread;


   printf("Running as an executable !\n\n");
   //
   // Run the first service (by default)
   //
   ulService = 0;
   hThread = CreateThread(
            NULL, 0,
            (LPTHREAD_START_ROUTINE)m_pServiceTable[ulService].lpServiceProc,
            NULL, 0,
            &dwID);
    if(!IS_BAD_HANDLE(hThread))
    {
        printf("Initializing service %s",m_pServiceTable[ulService].lpServiceName);
        Sleep(1000);

        while (SERVICE_RUNNING != m_ppServiceStatus[ulService]->Get())
            printf(".");

        printf("\nService %s is running\n\n", m_pServiceTable[ulService].lpServiceName);
    }
    else
        printf("Cannot create thread to start default service\n");


	// Print a small usage message to stdout
    printf("Starting Dummy Service Control manager\n");
    printf("---------------------------------------\n");
    printf("Commands:\n");
    printf(" List\n");
    printf(" Start service_name\n");
    printf(" Stop  service_name\n");
    printf(" quit exit q\n");
    printf("---------------------------------------\n");

	// Parse user commands.
    while (!fQuit)
    {
        char    *pchCommand;
        char    *pchService;
        ULONG   ulService;

		// Print the prompt
        printf("Generic service command prompt >");
        // XP SP1 bug 594247 (although not relevant for XP).
        if(fgets(rchBuff, sizeof(rchBuff), stdin) == NULL)
        	continue;

		rchBuff[sizeof(rchBuff) - 1] = 0;

		// Analize command

		// Find where the command starts
        for (pchCommand = rchBuff;
                (*pchCommand != '\0') &&
                !isalpha(*pchCommand);
             pchCommand++)
		{
			NULL;
		}

		// Find where the command ends
        for (pchService = pchCommand;
             (*pchService  != '\0') &&
             isalpha(*pchService );
             pchService++)
		{
			 NULL;
		}

		// Find where the service name starts
        for (;
             (*pchService  != '\0') &&
             !isalpha(*pchService );
             pchService++)
		{
			 NULL;
		}

        if(!_strnicmp("list", pchCommand, strlen("list")))
        {
            for (ulService = 0;
                 (ulService < m_ulUsedEntries) && m_pServiceTable[ulService].lpServiceName;
                 ulService++)
                printf("\t%s\t%s\n",
                       m_pServiceTable[ulService].lpServiceName,
                       IsServiceRunning(ulService) ? "running": "");
        }
        else if(!_strnicmp("start", pchCommand, strlen("start")))
        {
            DWORD dwID;
            HANDLE hThread;

            ulService = GetServiceIndex(pchService);
            if (ulService >= m_ulUsedEntries)
            {
                printf("Can't find service - %s.\n", pchService);
                continue;
            }

            if(IsServiceRunning(ulService))
            {
                printf("Service already running - %s.\n", pchService);
                continue;
            }

            printf("starting service - %s.\n", pchService);
            hThread = CreateThread(
                NULL, 0,
                (LPTHREAD_START_ROUTINE)m_pServiceTable[ulService].lpServiceProc,
                NULL, 0,
                &dwID);
            if(IS_BAD_HANDLE(hThread))
            {
                printf("Cannot create thread to start service - %s.\n", pchService);
                continue;
            }

            Sleep(1000);
            while (SERVICE_RUNNING != m_ppServiceStatus[ulService]->Get())
            {
                printf(".");
            }

            printf("\nservice - %s started.\n", pchService);
        }
        else if(!_strnicmp("stop", pchCommand, strlen("stop")))
        {
            ulService = GetServiceIndex(pchService);
            if (ulService >= m_ulUsedEntries)
            {
                printf("Can't find service - %s.\n", pchService);
                continue;
            }
            if(!IsServiceRunning(ulService))
            {
                printf("Service already stopped - %s.\n", pchService);
                continue;
            }
            printf("stopping service - %s.\n", pchService);

            (*m_pHandlerFunction[ulService])(SERVICE_CONTROL_STOP);

            while (SERVICE_STOPPED != m_ppServiceStatus[ulService]->Get())
			{
				NULL;
			}

            printf("service - %s. stopped\n", pchService);
        }
        else if(!_strnicmp("quit", pchCommand, strlen("quit")) ||
                !_strnicmp("quit", pchCommand, strlen("exit")) ||
                !_strnicmp("q", pchCommand, strlen("q")))
        {
            fQuit = TRUE;
            printf("Exiting...\n");
        }
        else
        {
            printf("Error:Unknown command!\n");
        }
    }

    return TRUE;
}

ULONG CServiceSet::GetServiceIndex(LPCTSTR lpName)
{
    ULONG   ulService;

    for (ulService = 0;
        (ulService < m_ulUsedEntries) &&
        (_stricmp(lpName, m_pServiceTable[ulService].lpServiceName));
        ulService++)
	{
		NULL;
	}
    return ulService;
}

BOOL  CServiceSet::IsServiceRunning(ULONG ulService)
{
    return
        m_ppServiceStatus[ulService] &&
        (SERVICE_STOPPED != m_ppServiceStatus[ulService]->dwCurrentState);
}

void CServiceSet::FillTerminatingEntry()
{
    m_pHandlerFunction[m_ulUsedEntries] = NULL;
    m_ppServiceStatus[m_ulUsedEntries] = NULL;
    m_pServiceTable[m_ulUsedEntries].lpServiceName = NULL;
    m_pServiceTable[m_ulUsedEntries].lpServiceProc = NULL;
}

BOOL CServiceSet::HasOnlyOneService()
{
    return (1 == m_ulUsedEntries );
}



    /*++

        Routine Description:

            This routine returns if the service specified is running
            interactively (not invoked by the service controller).

        Arguments:

            None

        Return Value:

            BOOL - TRUE if the program is running interactively.


        Note:

    --*/
BOOL
IsRunningAsService()
{

    HANDLE hProcessToken;
    DWORD groupLength = 50;

    PTOKEN_GROUPS groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);

    SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
    PSID InteractiveSid;
    PSID ServiceSid;
    DWORD i;


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
    {
        LocalFree(groupInfo);
        return(FALSE);
    }


    if (groupInfo == NULL)
    {
        CloseHandle(hProcessToken);
        LocalFree(groupInfo);
        return(FALSE);
    }


    if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
        groupLength, &groupLength))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            CloseHandle(hProcessToken);
            LocalFree(groupInfo);
            return(FALSE);
        }


        LocalFree(groupInfo);

        groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);

        if (groupInfo == NULL)
        {
            CloseHandle(hProcessToken);
            return(FALSE);
        }


        if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
            groupLength, &groupLength))
        {
            CloseHandle(hProcessToken);
            LocalFree(groupInfo);
            return(FALSE);
        }
    }


    //
    //  We now know the groups associated with this token.  We want to look to see if
    //  the interactive group is active in the token, and if so, we know that
    //  this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know we're a service.
    //
    //  The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).
    //


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID,
        0, 0, 0, 0, 0, 0, 0, &InteractiveSid))
    {
        LocalFree(groupInfo);
        CloseHandle(hProcessToken);
        return(FALSE);
    }


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID,
        0, 0, 0, 0, 0, 0, 0, &ServiceSid))
    {
        FreeSid(InteractiveSid);
        LocalFree(groupInfo);
        CloseHandle(hProcessToken);
        return(FALSE);
    }


    for (i = 0; i < groupInfo->GroupCount ; i += 1)
    {
        SID_AND_ATTRIBUTES sanda = groupInfo->Groups[i];
        PSID Sid = sanda.Sid;

        //
        //      Check to see if the group we're looking at is one of
        //      the 2 groups we're interested in.
        //

        if (EqualSid(Sid, InteractiveSid))
        {

            //
            //  This process has the Interactive SID in its
            //  token.  This means that the process is running as
            //  an EXE.
            //

            FreeSid(InteractiveSid);
            FreeSid(ServiceSid);
            LocalFree(groupInfo);
            CloseHandle(hProcessToken);
            return(FALSE);
        }
        else if (EqualSid(Sid, ServiceSid))
        {
            //
            //  This process has the Service SID in its
            //  token.  This means that the process is running as
            //  a service running in a user account.
            //

            FreeSid(InteractiveSid);
            FreeSid(ServiceSid);
            LocalFree(groupInfo);
            CloseHandle(hProcessToken);
            return(TRUE);
        }
    }

    //
    //  Neither Interactive or Service was present in the current users token,
    //  This implies that the process is running as a service, most likely
    //  running as LocalSystem.
    //

    FreeSid(InteractiveSid);
    FreeSid(ServiceSid);
    LocalFree(groupInfo);
    CloseHandle(hProcessToken);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1sync\genserv.h ===
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//      Filename :  GenServ.h                                                //
//      Purpose  :  Interface to the GenericService DLL. Declare classes     //
//                    CGenericService CServiceSet and CDummyServiceStatus.   //
//                                                                           //
//      Project  :  GenServ (GenericService)                                 //
//                                                                           //
//      Author   :  t-urib                                                   //
//                                                                           //
//      Log:                                                                 //
//          22/1/96 t-urib Creation                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#ifndef GENSERV_H
#define GENSERV_H

#include <Windows.h>
#include "tracer.h"
#include "Service.h"

// classes declared in this file
class CServiceSet;
class CGenericService;
class CDummyServiceStatus;

 BOOL IsRunningAsService();

class  CGenericService : public CTraced {
  public:
    // Constructor
    CGenericService(LPSERVICE_MAIN_FUNCTION, LPHANDLER_FUNCTION, CServiceSet*, LPCTSTR lpName = "GenericService");
    ~CGenericService();

    // Returns a pointer to the service's ServiceMain procedure
    LPSERVICE_MAIN_FUNCTION MainProcedure();

    // Returns a pointer to the service name(does not allocate).
    LPCTSTR Name();           // - NOT display name!!!!!

    // Calls Name()
    operator LPCTSTR();

    // Returns TRUE if the exe was run as a service
    BOOL IsRunningAsService();

    // Virtual functions - override those to
    //  change functionality
    //------------------------------------------
    // Called by the system when starting the service.
    //  Overriding this function disables all the GenericService functionality.
    virtual void ServiceMain(DWORD, PSZ*);

    // A default handler
    virtual void Handler(DWORD);

    // The GenericService class supplies a mechnism that bypass the need to
    //  report progress when starting or stopping the service. An additional
    //  thread is reporting progress to the service control manager without
    //  having the user do it specifically. That helps to start writing a
    //  service. One should not use this feature in a product because the
    //  purpose of the progress reporting mechanism is to report progress
    //  and not to cheat like this class does! The report thread is running
    //  this function. The report progress thread is running between the calls
    //  to Starting and ServiceStarted and between the calls
    //  to Stopping and ServiceStopped.
    //  The thread also runs after calls to Pause or Continue from the handler
    //  and stops when the status changes from pending to a static state.
    virtual void ReportThread(DWORD);

    // A boolean function that returns TRUE if the service is supposed to run.
    virtual BOOL IsRunning();

    // These functions are called from the handler function according to the control
    //   and should not be overridden as we see it now.
    virtual void Stop();
    virtual void Pause();
    virtual void Continue();
    virtual void Shutdown();

    // The following functions are called by ServiceMain in this order
    //-------------------------------------------------------------------------
    // Initialize the service.
    //  the base class version starts a report thread that reports progres
    //  automatically until IsRunning() returns true.
    //  The function returns TRUE if the service was successfuly initialized.
    //  Else it should report SERVICE_STOPPED with a proper error code using
    //  the m_pServiceStatus class.
    //  If a user override this function (that's the place for the
    //  initialization steps) he can still activate the reporting mechanism
    //  by calling GenericService::Starting() at the BEGINNING of his function.
    //  If he does not call the base class version he should override
    //  ServiceStarted as well.
    virtual BOOL Starting();

    // Receives the result of Starting. Closes the reporting thread and returs
    //  the same value as Starting.
    virtual BOOL ServiceStarted(BOOL fStarted);

    // The service main loop or whatever the user wants the service to do.
    //   Base class version does nothing(Sleep). This function MUST periodicaly
    //   call the IsRunning function. If IsRunning returns FALSE the Run
    //   function should return as fast as it can. Clean up should be done
    //   in Stopping function.
    virtual void Run();

    // The things to do before exiting.
    //  the base class version starts a report thread that reports progres
    //  automatically while IsStopping() returns FALSE.
    //  The function returns FALSE if the service was successfuly initialized.
    //  Else it should report SERVICE_STOPPED with a proper error code using
    //  the m_pServiceStatus class.
    //  If a user override this function (that's the place for the
    //  cleanup steps) he can still activate the reporting mechanism
    //  by calling GenericService::Stopping() at the BEGINNING of his function.
    //  If he does not call the base class version he should override
    //  ServiceStopped as well.
    virtual BOOL Stopping();

    // Receives the result of Stopping. Closes the reporting thread.
    virtual void ServiceStopped(BOOL fStopped);

  protected:

    // A class that is used to report status to the Service control manager.
    CServiceStatus          *m_pServiceStatus;


  private:
    // pointers for the automatically created global functions that call
    // GenericService::ServcieMain and GenericService::Handler.
    LPSERVICE_MAIN_FUNCTION m_pfuncServiceMain;
    LPHANDLER_FUNCTION      m_pfuncHandler;

    // A pointer to the service set object. Its data is not set yet at
    //   GenericService constructing time so we must keep a pointer.
    CServiceSet             *m_pServiceSet;

    // A handle to the reporting thread.
    HANDLE                  m_hThread;

    // A handle to pause event. it always signaled, unless the service
    //   should pause.
    HANDLE                  m_hPaused;

    // The service name - NOT display name!!!!!
    LPTSTR                  m_lpName;

    // A flag that holds if we are running as a service
    BOOL                    m_fRunningAsService;

	// A critical section to protect IsRunning
	CRITICAL_SECTION		m_csIsRunning;
};

class  CServiceSet: public CTraced {
  public:
    // Constructor
    CServiceSet();
    ~CServiceSet();

    // Returns TRUE if the exe was run as a service
    BOOL IsRunningAsService();

    // Adds a service to the SERVICE_TABLE used later in
    //  StartServiceCtrlDispatcher.
    BOOL Add(CGenericService&);

    // Encapsulates the API function.
    BOOL StartServiceCtrlDispatcher();

    // Encapsulates this API - replacing it if not running as a service.
    CServiceStatus* RegisterServiceCtrlHandler(
            LPCTSTR             lpName,
            LPHANDLER_FUNCTION  lpHandlerProc); // address of handler function

    // return TRUE if there is only one service in the exe.
    BOOL HasOnlyOneService();

  private:

    // Our version for not running as a service.
    BOOL StartDummyServiceCtrlDispatcher();

	// Fills the entry after the last filled one with Zeros
	//  (NULL terminating the Service table)
    void FillTerminatingEntry();

	// Returns a service index in the private table.
    ULONG GetServiceIndex(LPCTSTR lpName);

	// Finds if a specified service is running
    BOOL  IsServiceRunning(ULONG ulService);
	
	// The service table
    LPSERVICE_TABLE_ENTRY   m_pServiceTable;
    LPHANDLER_FUNCTION*     m_pHandlerFunction;
    CDummyServiceStatus**   m_ppServiceStatus;

	// Counters of the table
    ULONG                   m_ulUsedEntries;
    ULONG                   m_ulAlocatedEntries;

    // A flag that holds if we are running as a service
    BOOL                    m_fRunningAsService;
};

class CDummyServiceStatus :public CServiceStatus {
  public:
    // initializes the CServiceStatus
    CDummyServiceStatus():CServiceStatus(NULL)
    {
        m_hSemaphore = CreateSemaphore(NULL, 0, 1000, NULL);
    }

    // Tell the exe's main thread that a Set call was made 
    BOOL Set()
    {
        ReleaseSemaphore(m_hSemaphore, 1, NULL);
        return TRUE;
    }

	// Wait for a Set callso we will know the service is starting 
	//   properly.
    DWORD Get()
    {
		DWORD dwResult;
        dwResult = WaitForSingleObject(m_hSemaphore, dwWaitHint);
		IS_BAD_RESULT(dwResult);

        return CServiceStatus::Get();
    }

  private:
    HANDLE m_hSemaphore;
};


// A simple macro instaciates the service set globaly
#define DECLARE_SERVICE_SET()                                               \
CServiceSet  Set;

// This macro instanciates a new service and registers it in the set.
//   It also creates two functions to serve as connectors to the handler
//	 and ServiceMain.
#define DECLARE_SERVICE(id, type)                                           \
                                                                            \
void _stdcall id##ServiceMain(DWORD, PSZ*);                                 \
void _stdcall id##Handler(DWORD);                                           \
                                                                            \
type    id(id##ServiceMain, id##Handler, &Set);                             \
                                                                            \
void _stdcall id##ServiceMain(DWORD dwArgc, PSZ *ppszArgv)                  \
{                                                                           \
    id.ServiceMain(dwArgc, ppszArgv);                                       \
}                                                                           \
void _stdcall id##Handler(DWORD  fdwControl)                                \
{                                                                           \
    id.Handler(fdwControl);                                                 \
}

// This macro starts the services.
#define START_SERVICE_CONTROL_DISPATCHER() Set.StartServiceCtrlDispatcher();

#endif //GENSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1sync\genserv.cpp ===
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//      Filename :  GenServ.cpp                                              //
//      Purpose  :  Implementation to the GenericService class.				 //
//                                                                           //
//      Project  :  GenServ (GenericService)                                 //
//                                                                           //
//      Author   :  t-urib                                                   //
//                                                                           //
//      Log:                                                                 //
//          22/1/96 t-urib Creation                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include "GenServ.h"

#include "genserv.tmh"

///////////////////////////////////////////////////////////////////////////////
//
//   Four static functions for thread running
//
///////////////////////////////////////////////////////////////////////////////
static void StaticReportStartingThread(void* p)
{
    ((CGenericService*)p)->ReportThread(SERVICE_START_PENDING);
}

static void StaticReportPausingThread(void* p)
{
    ((CGenericService*)p)->ReportThread(SERVICE_PAUSE_PENDING);
}

static void StaticReportContinuingThread(void* p)
{
    ((CGenericService*)p)->ReportThread(SERVICE_CONTINUE_PENDING);
}

static void StaticReportStoppingThread(void* p)
{
    ((CGenericService*)p)->ReportThread(SERVICE_STOP_PENDING);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
//  class CGenericService
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

void GsDeleteTracer(CTracer *Tracer)
{
    delete Tracer;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Constructor - destructor
//
///////////////////////////////////////////////////////////////////////////////
CGenericService::CGenericService(
                 LPSERVICE_MAIN_FUNCTION    pfuncServiceMain,
                 LPHANDLER_FUNCTION         pfuncHandler,
                 CServiceSet*               pSet,
                 LPCTSTR                    lpName
                 )
    :CTraced()
{
    SetTracer(new CTracer("CGenericService", GsDeleteTracer));

    Assert(pfuncServiceMain);
    Assert(pfuncHandler);
    Assert(pSet);

    m_pServiceSet = pSet;
    m_pServiceStatus = NULL;
    m_pfuncServiceMain = pfuncServiceMain;
    m_pfuncHandler = pfuncHandler;
    m_fRunningAsService = m_pServiceSet->IsRunningAsService();


    m_lpName = (PSZ) malloc (strlen(lpName) * sizeof(char) + 1);
    if (IS_BAD_ALLOC(m_lpName))
    {
        Trace(tagError, "CGenericService::CGenericService: could not allocate name !");
        AssertSZ(m_lpName, "CGenericService::CGenericService:Could not allocate a service name storage, exiting!");
        exit(0);
    }
    else
        strcpy(m_lpName, lpName);

    pSet->Add(*this);

    // no thread is running
    m_hThread = NULL;

    // create the Pause event.
    m_hPaused = CreateEvent(NULL, TRUE, TRUE, NULL);
    if(IS_BAD_HANDLE(m_hPaused))
    {
        Trace(tagError, "CGenericService::CGenericService:Could not create event");
    }

	InitializeCriticalSection(&m_csIsRunning);
}

CGenericService::~CGenericService()
{
    Assert(m_hThread == NULL);
    CloseHandle(m_hPaused);
    SetTracer(NULL);

    if(m_pServiceStatus)
    {
        delete(m_pServiceStatus);
        m_pServiceStatus = NULL;
    }

	DeleteCriticalSection(&m_csIsRunning);
}

///////////////////////////////////////////////////////////////////////////////
//
//  Access routines
//
///////////////////////////////////////////////////////////////////////////////
LPSERVICE_MAIN_FUNCTION CGenericService::MainProcedure()
{
    return m_pfuncServiceMain;
}

LPCTSTR CGenericService::Name()
{
    return m_lpName;
}

CGenericService::operator LPCTSTR()
{
    return Name();
}

BOOL CGenericService::IsRunningAsService()
{
    return m_fRunningAsService;
}

///////////////////////////////////////////////////////////////////////////////
//
//  ServiceMain - Starting a service calls this function.
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
void CGenericService::ServiceMain(DWORD, PSZ*)
{
    // Clean previous ServiceStatus ( if you ran, stopped and now ran again
    //   without reloading - maybe another service is in this exe and it was
    //   running during the time you were down?
    if(m_pServiceStatus)
    {
        delete(m_pServiceStatus);
        m_pServiceStatus = NULL;
    }

    // Register your handler at the system(or in ServiceSet if not running as service)
    m_pServiceStatus = m_pServiceSet->RegisterServiceCtrlHandler(Name(), m_pfuncHandler);
    if (IS_BAD_ALLOC(m_pServiceStatus))
    {
        Trace(tagError,
            "CGenericService: ServiceMain: RegisterServiceCtrlHandler returned bad CServiceStatus");
        return;
    }

    // we do this initialization now because all services were already registered
    //  otherwise ServiceMain would not have been called.
    // initialization is here and not in CService::CService because a service
    //  can be stopped and reactivated and CService::CService is called only once
    //  when the process was run.
    // the state of a service that did not start yet is stopped.
    m_pServiceStatus->dwServiceType = (m_pServiceSet->HasOnlyOneService()?
            SERVICE_WIN32_OWN_PROCESS : SERVICE_WIN32_SHARE_PROCESS);


    // Realy run - functions are called in this order:
    //      Starting
    //      ServiceStarted
    //      Run
    //      Stopping
    //      ServiceStopped
    //
    // These functions were meant to be overridden.
    Trace(tagInformation, "CGenericService: Service starting");
    if(ServiceStarted(Starting()))
    {
        Trace(tagInformation, "CGenericService: Service started successfully");

        Run(); // Run should periodically call

        Trace(tagInformation, "CGenericService: Service stopping");

        ServiceStopped(Stopping());

        Trace(tagInformation, "CGenericService: Service stopped");
    }
    else
    {
        Trace(tagError, "CGenericService: Service failed to start");
    }
}


///////////////////////////////////////////////////////////////////////////////
//
//  Handler - The default control handler. If overridden - should remain short
//              and must call m_pServiceStatus->Set() on the end.
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
void CGenericService::Handler(DWORD dwControl)
{
    switch(dwControl)
    {
    case SERVICE_CONTROL_STOP:
        AssertSZ(SERVICE_RUNNING == m_pServiceStatus->dwCurrentState,
			"CGenericService::Handler: Can't stop a service that is not running");
        Stop();
        break;

    case SERVICE_CONTROL_PAUSE:
        AssertSZ(SERVICE_RUNNING == m_pServiceStatus->dwCurrentState,
                 "CGenericService::Handler: Can't pause a service that is not running");
        Pause();
        break;

    case SERVICE_CONTROL_CONTINUE:
        AssertSZ(SERVICE_PAUSED == m_pServiceStatus->dwCurrentState,
                 "CGenericService::Handler: Can't continue a service that is not paused");
        Continue();
        break;

    case SERVICE_CONTROL_SHUTDOWN:
        AssertSZ(SERVICE_RUNNING == m_pServiceStatus->dwCurrentState,
                 "CGenericService::Handler: Can't shut down a service that is not running");
        Shutdown();
        break;

    case SERVICE_CONTROL_INTERROGATE:
        break;
    default:
        Trace(tagError, "CGenericService::Handler: Unknown service control");
        break;
    }

    // After proper dwCurrentState was set by the functions
    //   report it to the service control manager.
    m_pServiceStatus->Set();
}

///////////////////////////////////////////////////////////////////////////////
//
//  Starting - Starts the reporting thread. If overridden - user should call
//               call the CGenericService::Starting at the beggining of his
//               function or report progress by himself.
//             If CGenericService::Starting is not called - one should override
//               ServiceStarted also.
//             Function returns TRUE if initalization is successfull.
//
//                  Generally should be overridden.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CGenericService::Starting()
{
    DWORD   tid;

    // Don't listen for new controls now.
    m_pServiceStatus->DisableControls();

    // Signal that the service is starting
    m_pServiceStatus->dwCurrentState = SERVICE_START_PENDING;

    // Set service status (to tell the control manager what it needs to know)
    m_pServiceStatus->Set();

    // Start the reporting thread.
    m_hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)StaticReportStartingThread,
                    (LPVOID)this,
                    0,
                    &tid);
    if(IS_BAD_HANDLE(m_hThread))
    {
        Trace(tagError, "CGenericService::Starting: Finished the GenericService initialization with errors");
        return FALSE;
    }
    else
    {
        Trace(tagInformation, "CGenericService::Starting: Successfuly finished the GenericService initialization");
        return TRUE;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  ServiceStarted -
//              Stops the reporting thread. If overridden - user should
//                call the CGenericService::ServiceStarted at the end of his
//                function or report progress by himself.
//              Function returns TRUE if initalization is successfull.
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CGenericService::ServiceStarted(BOOL fStarted)
{

    if(fStarted)
    {
        // Signal that the service has initialized successfully
        m_pServiceStatus->dwCurrentState = SERVICE_RUNNING;

        // Wait for the reporting thread to die (because of the signal)
        if(m_hThread)
            if (WAIT_FAILED == WaitForSingleObject(m_hThread, 20*1000))
            {
				Trace(tagError, "CGenericService::ServiceStarted: Waiting for the reporting thread to die failed!");
            }
        m_hThread = NULL;

        // Now wait for new controls.
        m_pServiceStatus->EnableControls();

        // Report current state
        m_pServiceStatus->Set();

        Trace(tagInformation, "CGenericService::ServiceStarted: Successfuly finished the Service initialization");
        return TRUE;
    }
    else
    {
        // Signal that the service has stopped
        m_pServiceStatus->dwCurrentState = SERVICE_STOPPED;

        // Wait for the reporting thread to die (because of the signal)
        if(m_hThread)
            if (WAIT_FAILED == WaitForSingleObject(m_hThread, 20*1000))
            {
                Trace(tagError, "CGenericService::ServiceStarted: Waiting for the reporting thread to die failed!");
            }
        m_hThread = NULL;

        // Report current state
        m_pServiceStatus->Set();

        Trace(tagError, "CGenericService::ServiceStarted: Initialization failed: service not started");

        return FALSE;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  Run -
//          The service is in this function when it runs. When you override
//            this function you should call IsRunning periodically.
//
//                  Usually overridden.
//
///////////////////////////////////////////////////////////////////////////////
void CGenericService::Run()
{
    while(IsRunning())
    {
        Beep(1000, 500);
        Sleep(5000);
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  IsRunning -
//              This function is called periodically when the service is
//                running. It handles all the control commands a standard
//                service gets. When the function returns TRUE the service is
//                running. If the service got a stop command - IsRunning starts
//                the reporting thread to report SERVICE_STOP_PENDING and
//                return FALSE. If a pause command was handled the function
//                will not return until a continue command arrived.
//                  Usually overridden.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CGenericService::IsRunning()
{
	BOOL fResult;

	EnterCriticalSection(&m_csIsRunning);

    switch (m_pServiceStatus->dwCurrentState)
    {
    case SERVICE_START_PENDING:
    case SERVICE_PAUSED:
    case SERVICE_CONTINUE_PENDING:
        Trace(tagWarning, "CGenericService::IsRunning: This function should not be called now");
    case SERVICE_STOP_PENDING:
    case SERVICE_STOPPED:
        fResult = FALSE;
		break;

    case SERVICE_PAUSE_PENDING:
        // If we are here - the service called IsRunning and we can pause now.
        //   So we're no long pending
        m_pServiceStatus->dwCurrentState = SERVICE_PAUSED;

        // Now wait for new controls.
        m_pServiceStatus->EnableControls();

        // Tell the system
        m_pServiceStatus->Set();

        // now wait for the pause report thread to finish
        if(m_hThread)
            if (WAIT_FAILED == WaitForSingleObject(m_hThread, 20*1000))
            {
                Trace(tagError, "CGenericService::IsRunning: Waiting for the pause reporting thread to die failed!");
            }
        m_hThread = NULL;

        // Now pause
        WaitForSingleObject(m_hPaused, INFINITE);

        // Continue was called apparently so we're no long pending
        m_pServiceStatus->dwCurrentState = SERVICE_RUNNING;

        // now wait for the continue report thread to finish
        if(m_hThread)
            if (WAIT_FAILED == WaitForSingleObject(m_hThread, 20*1000))
            {
                Trace(tagError, "CGenericService::IsRunning: Waiting for the continue reporting thread to die failed!");
            }
        m_hThread = NULL;

        // Now wait for new controls.
        m_pServiceStatus->EnableControls();

        // Now we are running so fall through
        m_pServiceStatus->dwCurrentState = SERVICE_RUNNING;

        // Tell the system
        m_pServiceStatus->Set();

    case SERVICE_RUNNING:
        fResult = TRUE;
		break;

    default:
        AssertSZ(0, "CGenericService::IsRunning: Unknown service status");
        fResult = FALSE;
		break;
    }
	
	LeaveCriticalSection(&m_csIsRunning);

	return fResult;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Stopping -
//              The base class version is empty. override id to do
//                uninitialization stuff.
//              The function return TRUE if service stopped successfully.
//
//                  Generally should be overridden.
//
///////////////////////////////////////////////////////////////////////////////
BOOL CGenericService::Stopping()
{
    // base class version has no unclosed items.
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  ServiceStopped - This function stops the report stopping thread by changing
//                     the dwCurrentStatus. After waiting for it to stop, the
//                     function sets the ServiceStatus
//
//                  Generally should be overridden.
//
///////////////////////////////////////////////////////////////////////////////
void CGenericService::ServiceStopped(BOOL fStopped)
{
    if(fStopped)
    {
        // Signal that the service has initialized successfully
        m_pServiceStatus->dwCurrentState = SERVICE_STOPPED;


        // Wait for the reporting thread to die (because of the signal)
        if(m_hThread)
            if (WAIT_FAILED == WaitForSingleObject(m_hThread, 20*1000))
            {
				Trace(tagError,
					"CGenericService::ServiceStopped: Waiting for the reporting thread to die failed!");
            }
        m_hThread = NULL;

        Trace(tagInformation, "CGenericService::ServiceStopped: Successfuly stopped the service");

        // Report current state
        m_pServiceStatus->Set();

    }
    else
    {
        // Signal that the service has stopped
        m_pServiceStatus->dwCurrentState = SERVICE_STOPPED;

        // Wait for the reporting thread to die (because of the signal)
        if(m_hThread)
            if (WAIT_FAILED == WaitForSingleObject(m_hThread, 20*1000))
            {
                Trace(tagError, "Waiting for the reporting thread to die failed!");
            }
        m_hThread = NULL;

        Trace(tagError, "CGenericService::ServiceStopped: Initialization failed: service did not stop correctly");

        // Report current state
        m_pServiceStatus->Set();
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  Stop - This function starts the report stopping thread. It
//           changes the dwCurrentStatus so the threads calling
//           IsRunning will get FALSE.
//         This function is called from the handler and should be
//           small and fast because the system expect a response
//           (SetServiceStatus). So if you override it, be short.
//           Lenghty operations should take place in Stopping().
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
void CGenericService::Stop()
{
    DWORD   tid;

    // Don't listen for new controls now.
    m_pServiceStatus->DisableControls();

    // Signal that the service is stopping.
    m_pServiceStatus->dwCurrentState = SERVICE_STOP_PENDING;

    // Start reporting the current status.
    m_hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)StaticReportStoppingThread,
                    (LPVOID)this,
                    0,
                    &tid);
    if(IS_BAD_HANDLE(m_hThread))
    {
        Trace(tagError, "GenericService::Stop: unable to create thread");
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  Pause - This function starts the report pausing thread. It
//           changes the dwCurrentStatus so the threads calling
//           IsRunning will not return until a continue was given.
//          This function is called from the handler and should be
//           small and fast because the system expect a response
//           (SetServiceStatus). So if you override it, be short.
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
void CGenericService::Pause()
{
    DWORD   tid;

    // Don't listen for new controls now.
    m_pServiceStatus->DisableControls();

    // Signal that the service is pausing.
    m_pServiceStatus->dwCurrentState = SERVICE_PAUSE_PENDING;

    // Start reporting the current status.
    m_hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)StaticReportPausingThread,
                    (LPVOID)this,
                    0,
                    &tid);
    if(IS_BAD_HANDLE(m_hThread))
    {
        Trace(tagError, "GenericService::Pause: unable to create thread");
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  Continue - This function starts the report continuing thread. It
//               changes the dwCurrentStatus and set the paused event so thread
//               in IsRunning will finish it's wait and return.
//             This function is called from the handler and should be
//               small and fast because the system expect a response
//               (SetServiceStatus). So if you override it, be short.
//
//                  Generally should not be overridden.
//
///////////////////////////////////////////////////////////////////////////////
void CGenericService::Continue()
{
    DWORD   tid;

    // Don't listen for new controls now.
    m_pServiceStatus->DisableControls();

    // Signal that the service is continuing.
    m_pServiceStatus->dwCurrentState = SERVICE_CONTINUE_PENDING;

    // Start reporting the current status.
    m_hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)StaticReportContinuingThread,
                    (LPVOID)this,
                    0,
                    &tid);
    if(IS_BAD_HANDLE(m_hThread))
    {
        Trace(tagError, "CGenericService: Continue: unable to create thread");
    }

    // Release the pausing IsRunning
    SetEvent(m_hPaused);
}


///////////////////////////////////////////////////////////////////////////////
//
//  ShutDown - same as stop.
//
///////////////////////////////////////////////////////////////////////////////
void CGenericService::Shutdown()
{
    Stop();
}


///////////////////////////////////////////////////////////////////////////////
//
//  ReportThread - While the status stays as specified report it.
//                 Called from the appropriate static function in the
//                   begining of the file.
//
///////////////////////////////////////////////////////////////////////////////
void CGenericService::ReportThread(DWORD dwCurrentStatus)
{
    while (dwCurrentStatus == m_pServiceStatus->dwCurrentState)
    {
        Sleep(1*1000);
		Trace(tagInformation, "CGenericService::ReportThread: Reporting progress");
        m_pServiceStatus->Set();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1sync\tracer.cpp ===
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//      Filename :  Tracer.cpp                                               //
//      Purpose  :  Implement the standard tracer.                           //
//                                                                           //
//      Project  :  Tracer                                                   //
//                                                                           //
//      Author   :  t-urib                                                   //
//                                                                           //
//      Log:                                                                 //
//          22/1/96 t-urib Creation                                          //
//          27/2/96 t-urib Add release/debug support.                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "Tracer.h"
#include <mqmacro.h>

#include "tracer.tmh"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//  class  -  CTracer
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  CTracer static fields
//
///////////////////////////////////////////////////////////////////////////////
BOOL CTracer::m_fFirstInstance = TRUE;

///////////////////////////////////////////////////////////////////////////////
//
//  Constructors - Distructors
//
///////////////////////////////////////////////////////////////////////////////
CTracer::CTracer(PSZ pszProgramName, DEALLOCATOR pfuncDealloc, PSZ pszFileName)
{
    DBG_USED(pszProgramName);
    DBG_USED(pszFileName);

#if defined(DEBUG) || defined(_DEBUG)
    m_pTraceFile = NULL;
    m_pszDiskFile = _strdup(pszFileName);
    m_pszProgramName = (pszProgramName?_strdup(pszProgramName):"");

    if(m_fFirstInstance )
    {
        m_fFirstInstance  = FALSE;
        DeleteFile(m_pszDiskFile);
    }

    for (TAG tag = tagFirst; tag < tagLast; ((int&)tag)++)
        m_rfTagEnabled[tag] = TRUE;

#endif // DEBUG

    // save deallocator.
    m_pfuncDeallocator = pfuncDealloc;
}

CTracer::CTracer(PSZ pszProgramName, DEALLOCATOR pfuncDealloc, FILE* pTraceFile)
{
    DBG_USED(pszProgramName);
    DBG_USED(pTraceFile);

#if defined(DEBUG) || defined(_DEBUG)
    m_pTraceFile = pTraceFile;
    m_pszDiskFile = NULL;
    m_pszProgramName =  (pszProgramName?_strdup(pszProgramName):"");

    for (TAG tag = tagFirst; tag < tagLast; ((int&)tag)++)
        m_rfTagEnabled[tag] = TRUE;

#endif // DEBUG

    // save deallocator.
    m_pfuncDeallocator = pfuncDealloc;
}

CTracer::~CTracer()
{
#if defined(DEBUG) || defined(_DEBUG)
    free(m_pszDiskFile);
    free(m_pszProgramName);
#endif // DEBUG
}

void CTracer::Free()
{
    if(m_pfuncDeallocator)
        (*m_pfuncDeallocator)(this);
}

///////////////////////////////////////////////////////////////////////////////
//
//  Trace function
//
///////////////////////////////////////////////////////////////////////////////
void    CTracer::TraceSZ(TAG tag, const PSZ pszText)
{
    DBG_USED(tag);
    DBG_USED(pszText);
#if defined(DEBUG) || defined(_DEBUG)
    char    rchBuffer[1000];

    // if the specified tag is disabled do nothing
    if(!IsEnabled(tag))
        return;

    rchBuffer[0] = '\0';
    strncat(rchBuffer, m_pszProgramName, 254);
    strcat(rchBuffer, " : ");
    strncat(rchBuffer, pszText, 254);
    strcat(rchBuffer, "\n");

    // debug trace
    OutputDebugString(rchBuffer);

    // Disk file trace
    if (m_pszDiskFile)
    {
        FILE* pfile;
        pfile = fopen(m_pszDiskFile, "a+");
        if (pfile)
            fprintf(pfile,  rchBuffer);
        fclose(pfile);
    }

    // stream trace
    if (m_pTraceFile)
        fprintf(m_pTraceFile,  rchBuffer);
#endif // DEBUG
}


///////////////////////////////////////////////////////////////////////////////
//
//  Tags manipulation functions
//
///////////////////////////////////////////////////////////////////////////////
void CTracer::Enable(TAG tag, BOOL fEnable)
{
    m_rfTagEnabled[tag] = fEnable;
}

BOOL CTracer::IsEnabled(TAG tag)
{
    return  m_rfTagEnabled[tag];
}

///////////////////////////////////////////////////////////////////////////////
//
//  Assert functions - Asserts and traces the data
//
///////////////////////////////////////////////////////////////////////////////
void    CTracer::TraceAssertSZ(int i, PSZ pszText,PSZ pszFile,int iLine)
{
    DBG_USED(i);
    UNREFERENCED_PARAMETER(pszText);
    DBG_USED(pszFile);
    DBG_USED(iLine);

#if defined(DEBUG) || defined(_DEBUG) 
    if(!i)
    {
        char    buff[200];
        char    buff2[400];

        sprintf(buff, "Assertion failed : %i : line %i file %s",
                i, iLine, pszFile);

        MessageBox(NULL, buff, m_pszProgramName, MB_ICONSTOP|MB_OK );

        strcpy(buff2, m_pszProgramName);
        strcat(buff2, ":");
        strcat(buff2, buff);

        TraceSZ(tagError, buff2);
    }
#endif // DEBUG
}

void    CTracer::TraceAssert(int i,PSZ pszFile,int iLine)
{
    DBG_USED(i);
    DBG_USED(pszFile);
    DBG_USED(iLine);

#if defined(DEBUG) || defined(_DEBUG)
    TraceAssertSZ(i, "", pszFile, iLine);
#endif // DEBUG
}

///////////////////////////////////////////////////////////////////////////////
//
//  Is bad functions - return TRUE if the expression checked is bad!
//
///////////////////////////////////////////////////////////////////////////////
BOOL    CTracer::IsBadAlloc(void* ptr, PSZ pszFile,int iLine)
{
    DBG_USED(pszFile);
    DBG_USED(iLine);

    if(BAD_POINTER(ptr))
    {
#if defined(DEBUG) || defined(_DEBUG)
        char    buff[256];

        sprintf(buff, "Memory allocation failed : in line %d file %s",
                iLine, pszFile);
        TraceSZ(tagError, buff);
#endif // DEBUG
        return(TRUE);
    }
    return(FALSE);
}

BOOL CTracer::IsBadHandle(HANDLE h, PSZ pszFile,int iLine)
{
    DBG_USED(pszFile);
    DBG_USED(iLine);

    if(BAD_HANDLE(h))
    {
#if defined(DEBUG) || defined(_DEBUG)
        char    buff[200];
        DWORD   dwError = GetLastError();

        sprintf(buff, "Handle is not valid : GetLastError - %d: in line %d file %s",
                dwError, iLine, pszFile);

        TraceSZ(tagWarning, buff);
#endif // DEBUG
        return(TRUE);
    }
    return(FALSE);
}

BOOL CTracer::IsFailure(BOOL fSuccess, PSZ pszFile,int iLine)
{
    DBG_USED(pszFile);
    DBG_USED(iLine);
#if defined(DEBUG) || defined(_DEBUG)
    if(!fSuccess)
    {
        char    buff[200];

        DWORD   dwError = GetLastError();

        sprintf(buff, "Error encountered : return code is %s, GetLastError returned %d in line %d file %s",
                (fSuccess ? "TRUE" : "FALSE"),
                dwError, iLine, pszFile);

        TraceSZ(tagWarning, buff);
    }
#endif // DEBUG
    return(!fSuccess);
}

BOOL CTracer::IsBadResult(HRESULT hr, PSZ pszFile,int iLine)
{
    DBG_USED(pszFile);
    DBG_USED(iLine);

    if(BAD_RESULT(hr))
    {
#if defined(DEBUG) || defined(_DEBUG)
        char    buff[200];

        DWORD   dwError = GetLastError();
        UNREFERENCED_PARAMETER(dwError);

        sprintf(buff, "Error encountered : return code is %x\
                       \nin line %d file %s",
                hr, iLine, pszFile);

        TraceSZ(tagWarning, buff);
#endif // DEBUG

        return(TRUE);
    }
    return(FALSE);
}

BOOL    CTracer::IsBadScode(SCODE sc, PSZ pszFile,int iLine)
{
    DBG_USED(pszFile);
    DBG_USED(iLine);
    if(BAD_SCODE(sc))
    {
#if defined(DEBUG) || defined(_DEBUG)
        char    buff[200];

        DWORD   dwError = GetLastError();
        UNREFERENCED_PARAMETER(dwError);

        sprintf(buff, "Error encountered : return code is %x\
                       \nin line %d file %s",
                sc, iLine, pszFile);

        TraceSZ(tagWarning, buff);
#endif // DEBUG

        return(TRUE);
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mq1sync\tracer.h ===
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//      Filename :  Tracer.h                                                 //
//      Purpose  :  A tracer class definition.                               //
//                                                                           //
//      Project  :  Tracer                                                   //
//                                                                           //
//      Author   :  t-urib                                                   //
//                                                                           //
//      Log:                                                                 //
//          22/1/96 t-urib Creation                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#ifndef  TRACER_H
#define  TRACER_H

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <wtypes.h>

class CTracer;
class CTraced;


///////////////////////////////////////////////////////////////////////////////
//
// Define the Tracer deallocator - since a user can specify a different tracer
//   then mine, he will probably allocate it himself. in order to handle
//   inconsistencies between thr CRT the dll uses and the CRT the EXE uses,
//   in every tracer object there is a pointer to it's deleter.
//   Since DeleteTracer is an inline function, the following code
//   new Tracer("asda" , DeleteTracer, "sdf") will assure that the Tracer will
//   be deallocated with a delete from the same package of the new with whom
//   it was allocated.
//
///////////////////////////////////////////////////////////////////////////////
typedef void (*DEALLOCATOR)(CTracer*);

// an inline exmple which you can use !
void DeleteTracer(CTracer *Tracer);


///////////////////////////////////////////////////////////////////////////////
//
// Enum the basic tags
//
///////////////////////////////////////////////////////////////////////////////

enum TAG {
    tagFirst = 0,
    tagCrash,
    tagError,
    tagWarning,
    tagInformation,
    tagLast,
};


///////////////////////////////////////////////////////////////////////////////
//
// class Tracer
//
//      purpose : A base class for tracers
//
//
///////////////////////////////////////////////////////////////////////////////

class CTracer {
  public:
    // Constructors - szProgramName prefix for all traces,
    //  second parameter - log file or stream
    CTracer(PSZ pszProgramName, DEALLOCATOR pfuncDealloc, PSZ   pszTraceFile);
    CTracer(PSZ pszProgramName, DEALLOCATOR pfuncDealloc, FILE* pTraceFile = NULL);
    virtual ~CTracer();

    // This function deallocates the tracer! it calls the Function pointer
    //   passed in the constructor or if not given - the default
    //   delete operator for the dll.
    virtual void Free();


    // The TraceSZ function output is defined by the tags mode
    //  one can change the tags mode by calling Enable tag and
    //  get the mode by calling IsEnabled.
    //-------------------------------------------------------------------------
    // accepts printf format for traces
    virtual void    TraceSZ(TAG, const PSZ);

    // Enable disable tags
    virtual void Enable(TAG, BOOL);
    virtual BOOL IsEnabled(TAG);

    // Two Assert functions one allows attaching a string.
    //-------------------------------------------------------------------------
    // assert, different implementations possible - gui or text
    virtual void TraceAssertSZ(int, PSZ, PSZ, int);

    // assert, different implementations possible - gui or text
    virtual void TraceAssert(int, PSZ, int);

    // The following function are used to check return values and validity of
    //   pointers and handles. If the item checked is bad the function will
    //   return TRUE and a trace will be made for that.
    //-------------------------------------------------------------------------
    // Verify a boolean function return code
    virtual BOOL IsFailure(BOOL, PSZ, int);

    // verify allocation
    virtual BOOL IsBadAlloc(void*, PSZ, int);

    // Verify a Handle
    virtual BOOL IsBadHandle(HANDLE, PSZ, int);

    // Verify an OLE hresult function
    virtual BOOL IsBadResult(HRESULT, PSZ, int);

    // Verify a SCODE function
    virtual BOOL IsBadScode(SCODE, PSZ, int);

  private:
    // The Trace file. If it is not NULL then it means that we should not
    //   close it or open it because it is not our's.
    FILE*   m_pTraceFile;

    // A Trace file name. If it is NULL then we do not work with a disk file.
    PSZ     m_pszDiskFile;

    // A prefix to all traces and asserts that distinguishes one tracer's
    //   output from another's.
    PSZ     m_pszProgramName;

    // A boolean array to store which tags are being traced.
    BOOL    m_rfTagEnabled[tagLast];

    // The Tracer deallocator.
    DEALLOCATOR m_pfuncDeallocator;

    // Used to decide if to delete the log file or not
    static BOOL m_fFirstInstance;

};

///////////////////////////////////////////////////////////////////////////////
//
// A deleter function for class Tracer
//
//      purpose : given as parameter in CTracer constructor
//
///////////////////////////////////////////////////////////////////////////////
inline
void DeleteTracer(CTracer *Tracer)
{
    delete Tracer;
}

///////////////////////////////////////////////////////////////////////////////
//
// class Traced
//
//  pupose : A base class for every class who wants to use the tracer.
//
//
///////////////////////////////////////////////////////////////////////////////
class  CTraced {
  public:
    // A Constructor - sets a default Tracer. replace it by calling SetTracer
    //   in the derived class constructor.
    CTraced()
	{
	    m_pTracer = new CTracer("Tracer", DeleteTracer);
	}

    // The destructor deletes the existing tracer.
    ~CTraced()
	{
		if (m_pTracer)
			m_pTracer->Free();
	}

    // replace the current tracer while erasing it.
    boolean SetTracer(CTracer* pTracer)
	{
		CTracer* pTempTracer = m_pTracer;
		m_pTracer = pTracer;

		if (pTempTracer)
			pTempTracer->Free();

		return TRUE;
	}

    // Return a pointer to the tracer this function is called by the macro's so
    //   if one wants to supply a different mechanism he can override it.
    virtual CTracer* GetTracer()
	{
		    return m_pTracer;
	}

  protected:
    // A pointer to the tracer.
    CTracer *m_pTracer;
};


///////////////////////////////////////////////////////////////////////////////
//
// MACROS
//
///////////////////////////////////////////////////////////////////////////////

#define BAD_POINTER(ptr)    (NULL == (ptr))
#define BAD_HANDLE(h)       ((0 == (h))||(INVALID_HANDLE_VALUE == (h)))
#define BAD_RESULT(hr)      (FAILED(hr))
#define BAD_SCODE(sc)       (FAILED(sc))




#if defined(DEBUG) || defined(_DEBUG)
// this macro can be redefined any way you want to redirect to a specific tracer.
#ifndef TRACER
#define TRACER (*GetTracer())
#define GTRACER (*::GetTracer())
CTracer *GetTracer();
#endif


#define Assert(x)           TRACER.TraceAssert((int)(x), __FILE__, __LINE__)
#define AssertSZ(x, psz)    TRACER.TraceAssertSZ((int)(x), (PSZ)(psz), __FILE__, __LINE__)

#define IS_FAILURE(x)       TRACER.IsFailure((x), __FILE__, __LINE__)
#define IS_BAD_ALLOC(x)     TRACER.IsBadAlloc((void*)(x), __FILE__, __LINE__)
#define IS_BAD_HANDLE(x)    TRACER.IsBadHandle((HANDLE)(x), __FILE__, __LINE__)
#define IS_BAD_RESULT(x)    TRACER.IsBadResult((x), __FILE__, __LINE__)
#define IS_BAD_SCODE(x)     TRACER.IsBadScode((x), __FILE__, __LINE__)
#define Trace               TRACER.TraceSZ

#define GAssert(x)          GTRACER.TraceAssert((int)(x), __FILE__, __LINE__)
#define GAssertSZ(x, psz)   GTRACER.TraceAssertSZ((int)(x), (PSZ)(psz), __FILE__, __LINE__)

#define GIS_FAILURE(x)      GTRACER.IsFailure((x), __FILE__, __LINE__)
#define GIS_BAD_ALLOC(x)    GTRACER.IsBadAlloc((void*)(x), __FILE__, __LINE__)
#define GIS_BAD_HANDLE(x)   GTRACER.IsBadHandle((HANDLE)(x), __FILE__, __LINE__)
#define GIS_BAD_RESULT(x)   GTRACER.IsBadResult((x), __FILE__, __LINE__)
#define GIS_BAD_SCODE(x)    GTRACER.IsBadScode((x), __FILE__, __LINE__)
#define GTrace              GTRACER.TraceSZ


#else  // DEBUG

#define Assert(x)
#define AssertSZ(x, psz)

#define IS_FAILURE(x)       (!(x))
#define IS_BAD_ALLOC(x)     BAD_POINTER((void*)(x))
#define IS_BAD_HANDLE(x)    BAD_HANDLE((HANDLE)(x))
#define IS_BAD_RESULT(x)    BAD_RESULT(x)
#define IS_BAD_SCODE(x)     BAD_SCODE(x)
#define Trace(x, y)

#define GAssert(x)
#define GAssertSZ(x, psz)

#define GIS_FAILURE(x)      !x
#define GIS_BAD_ALLOC(x)    BAD_POINTER((void*)(x))
#define GIS_BAD_HANDLE(x)   BAD_HANDLE((HANDLE)(x))
#define GIS_BAD_RESULT(x)   BAD_RESULT(x)
#define GIS_BAD_SCODE(x)    BAD_SCODE(x)
#define GTrace(x, y)

#endif // DEBUG

///////////////////////////////////////////////////////////////////////////////
//
// If you have a global tracer init it using this macro.
//   The only other way to use the Tracer is by inheriting from CTraced.
//
///////////////////////////////////////////////////////////////////////////////

#define INIT_TRACER(psz1, psz2)     \
CTracer tracer(psz1, NULL, psz2);   \
CTracer *GetTracer()                \
{                                   \
    return &tracer;                 \
}


#endif /* TRACER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mqrpperf\mqrepst.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    mqRepSt.h

Abstract:

	Several usefull macroes and definitions for handling the perfornece monitor
	structures.

Author:

    Erez Vizel (t-erezv) 14-Feb-99

--*/

#ifndef _MQ_REP_ST_
#define _MQ_REP_ST_

#include "rpperf.h" //RPC interface header file.

//
//this macro is the short way to calculate the size of all the 
//data that is being returned to the perfmon, NOTE:  this data
//is only valid for one instance object system.
//
#define DATA_BLOCK_SIZE(num)    (sizeof(PERF_OBJECT_TYPE )+\
							     sizeof(PERF_COUNTER_DEFINITION )*num +\
							     sizeof(PERF_COUNTER_BLOCK ) +\
							     COUNTER_DATA_SIZE * num)

#define INSTANCE_NAME_LEN_IN_BYTES (INSTANCE_NAME_LEN * sizeof(WCHAR))

#define INSTANCE_SIZE(num)      (COUNTER_DATA_SIZE * num+ \
                                 sizeof (PERF_COUNTER_BLOCK)+ \
                                 INSTANCE_NAME_LEN_IN_BYTES+  \
                                 sizeof (PERF_INSTANCE_DEFINITION))

//
//this macro generate the size of all the configuration blocks
//
#define CONFIG_BLOCK_SIZE(num) (sizeof(PERF_OBJECT_TYPE )+\
							    sizeof(PERF_COUNTER_DEFINITION )*num +\
							    sizeof(PERF_COUNTER_BLOCK ))


#define INST_BLOCK_SIZE         (sizeof (PERF_COUNTER_BLOCK)+ \
                                INSTANCE_NAME_LEN_IN_BYTES+  \
                                sizeof (PERF_INSTANCE_DEFINITION))

#define OBJECT_DEFINITION_SIZE(num) (sizeof (PERF_OBJECT_TYPE)+\
                                     num*sizeof(PERF_COUNTER_DEFINITION))

//
// the num of counters that are defined in the REPLSERV object.
//
#define FIRST_COUNTER_INDEX     NUMOFREPLSENT
#define NUM_COUNTERS_REPLSERV   eNumPerfCounters

//
// the num of counters that are defined in NT4MASTER object
//
#define NUM_COUNTERS_NT4MASTER  eNumNT4MasterCounter

//
//some data sizes macros
//
#define COUNTER_DEFINITION_SIZE sizeof(PERF_COUNTER_DEFINITION)
#define OBJECT_TYPE_SIZE        sizeof(PERF_OBJECT_TYPE)
#define COUNTER_BLOCK_SIZE      sizeof(PERF_COUNTER_BLOCK)
#define COUNTER_DATA_SIZE       sizeof(DWORD)

//
// maximal sizes of objects
//
const DWORD x_dwSizeOfData    = DATA_BLOCK_SIZE(NUM_COUNTERS_REPLSERV);
const DWORD x_dwSizeNT4Master = INSTANCE_SIZE(NUM_COUNTERS_NT4MASTER) * MAX_INSTANCE_NUM +
                                OBJECT_DEFINITION_SIZE(NUM_COUNTERS_NT4MASTER);

//
//this structure hold all the configuration objects;
//
typedef struct  {
					PERF_OBJECT_TYPE        objectType;
					PERF_COUNTER_DEFINITION counterArray[NUM_COUNTERS_REPLSERV];                    
					PERF_COUNTER_BLOCK      counterBlock;                 
}	DataConfig ,* pDataConfig;	

typedef struct  {
                    PERF_INSTANCE_DEFINITION    instDef;
                    TCHAR                       szInstName[INSTANCE_NAME_LEN];
                    PERF_COUNTER_BLOCK          counterBlock;
} InstBlockData, * pInstBlockData;

typedef struct  {
					PERF_OBJECT_TYPE        objectType;
					PERF_COUNTER_DEFINITION counterArray[NUM_COUNTERS_NT4MASTER];                    					
} ObjectBlockData, * pObjectBlockData;

//
//RPC reference functions
//
int initRpcConnection();
BOOL getData(pPerfDataObject pD);
int closeRpcConnection();



#endif _MQ_REP_ST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mqrpperf\perfdll.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    perfDll

Abstract:

    Common function for presenting the replication service data on the
	performance monitor utility.

Author:

    Erez Vizel (t-erezv) 14-Feb-99

--*/

#include <_stdh.h>
#include <assert.h>
#include <winperf.h>
#include "mqrperf.h"
#include "mqRepSt.h"
#include "..\..\setup\msmqocm\service.h"
#include <mqreport.h>//for the REPORT_CATEGORY macro 

#include "perfdll.tmh"


//#define APP_NAME MQ1SYNC_SERVICE_NAME //source name for the event viewer (must be writen to the registry)

void initializeObType(
                PERF_OBJECT_TYPE* ob, 
                DWORD dwObjIndex,               
                DWORD dwNumCounters);

void initializeCountDef(PERF_COUNTER_DEFINITION* ct , 
                        DWORD index, 
                        DWORD CurNum);

void initializeCountBlk(PERF_COUNTER_BLOCK* cbl, 
                        DWORD dwNumCounters);

void initializeInstanceDef(PERF_INSTANCE_DEFINITION* idef );

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    fInitOk = FALSE;        // true = DLL initialized OK
BOOL	fEventLogOpen = FALSE;	// TRUE = registration the dll with the event log succeded	
HANDLE hEventLog = NULL;        // event log handle for reporting events
                                // initialized in perfOpen()

DataConfig g_dc;
ObjectBlockData g_ObjBlock;
InstBlockData g_InstBlock;


/*++

Routine Description:
	The function handels all the  procedures that must be taken 
	when the performance monitor establish a connection with the replication
	service.
	The following steps are being performed:
	1.Initialze RPC local connection with the rplication service server.
	2.Get counter and help index base values from registry.
	3.Update perf data strucutures . 
 
	Note: Every error is (FUTURE !!!!!!!!!) writen to the event viewer.

Arguments:
	lpDeviceNames - names of devices managed by this applicalion, 
	Null in this Application .

Return Value:
    DWORD - exiting status.

--*/
DWORD APIENTRY				 
    RPPerfOpen(
    LPWSTR lpDeviceNames
    )
{
    UNREFERENCED_PARAMETER(lpDeviceNames);

	LONG status;
    HKEY hKeyDriverPerf;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;

    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread 
    //  at a time so synchronization (i.e. reentrancy) should not be 
    //  a problem
    //

   if (!dwOpenCount) 
   {        
		//
	    //initialize RPC connetion
		//
		status = initRpcConnection();
		if(status != ERROR_SUCCESS)
		{
			//
			//could not initialize RPC Connetion - no use in continuing
			//
			goto OpenExitPoint;
		}

		//
        //		get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //

         _TCHAR szPerfKey [255];

        _stprintf (szPerfKey,_T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"), 
                   MQ1SYNC_SERVICE_NAME);

        status = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
    	    szPerfKey,
            0L,
	        KEY_READ,
            &hKeyDriverPerf);

        if (status != ERROR_SUCCESS)
		{
           //
			// this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
			//
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf, 
		            L"First Counter",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstCounter,
                    &size);

        if (status != ERROR_SUCCESS)
		{
			//
            // this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
			//
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf, 
        		    L"First Help",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstHelp,
		    &size);

        if (status != ERROR_SUCCESS) 
		{
			//
            // this is fatal, if we can't get the base values of the 
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
			//
            goto OpenExitPoint;
        }
 
		
		//
		//Initialize dat in all perf objects
		//	      

        //
        // performance monitor: define "MSMQ Replication Service" object
        // in the drop-down list box "Performance object:"
        //
        initializeObType( &g_dc.objectType, REPLOBJECT, NUM_COUNTERS_REPLSERV);

        //
        // performance monitor: define all counters of "MSMQ Replication Service" object
        // in the left list box "Performance counters:"        
        //
        for (UINT i=0; i<NUM_COUNTERS_REPLSERV; i++)
        {
            initializeCountDef(&g_dc.counterArray[i], 
                               REPLOBJECT + FIRST_COUNTER_INDEX*(i+1), i);
        }       		
        initializeCountBlk(&g_dc.counterBlock, NUM_COUNTERS_REPLSERV);
        
        //
        // performance monitor: define "MSMQ NT4 Masters" object
        // in the drop-down list box "Performance object:"
        //
        initializeObType( &g_ObjBlock.objectType, NT4MASTEROBJECT, NUM_COUNTERS_NT4MASTER);

        //
        // performance monitor: define all counters of "MSMQ NT4 Masters" object
        // in the left list box "Performance counters:"        
        //
        for (i=0; i<NUM_COUNTERS_NT4MASTER; i++)
        {
            initializeCountDef(&g_ObjBlock.counterArray[i],
                               NT4MASTEROBJECT + FIRST_COUNTER_INDEX*(i+1), i);
        }
      
        //
        // performance monitor: define all instances of "MSMQ NT4 Masters" object
        // in the right list box under check-box "Select instances from list:"
        //
        initializeInstanceDef(&g_InstBlock.instDef);
        g_InstBlock.szInstName[0] = 0;
        initializeCountBlk(&g_InstBlock.counterBlock, NUM_COUNTERS_NT4MASTER); 
       
		//
		//update static data strucutures by adding base to 
        //offset value in structure.
		//
		
        g_dc.objectType.ObjectNameTitleIndex += dwFirstCounter;
        g_dc.objectType.ObjectHelpTitleIndex += dwFirstHelp;

        for (i=0; i<NUM_COUNTERS_REPLSERV; i++)
        {            
            g_dc.counterArray[i].CounterNameTitleIndex += dwFirstCounter;
            g_dc.counterArray[i].CounterHelpTitleIndex += dwFirstHelp;
        }

        g_ObjBlock.objectType.ObjectNameTitleIndex += dwFirstCounter;
        g_ObjBlock.objectType.ObjectHelpTitleIndex += dwFirstHelp;

        for (i=0; i<NUM_COUNTERS_NT4MASTER; i++)
        {
            g_ObjBlock.counterArray[i].CounterNameTitleIndex += dwFirstCounter;
            g_ObjBlock.counterArray[i].CounterHelpTitleIndex += dwFirstHelp;
        }        

        RegCloseKey (hKeyDriverPerf); // close key to registry

		fInitOk = TRUE; // ok to use the collect function
    }

    dwOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:
    return status;

}





/*++

Routine Description:
	The function handels all the procedures that must be taken 
	when the performance monitor try to collect counter data.
	The following steps are being performed:
	1.Check wether the perfOpen failed.
	2.Check if the lppData buffer  is big enough.
	3.Write configuration data.
	4.Get counter data via RPC and write it.

	
Arguments:
	lpValueName - Pointer to a string that specify the perfmon request 
    lppData -   IN - a pointer to a location in a buffer, where the data should be placed
				OUT - a pointer to a location in a buffer,who is the next free byte.	
    lpcbTotalBytes - IN - available size of the lppData buffer.
					 OUT - total bytes that were writen.
	lpNumObjectTypes - the ni=umber of object that were written.
)
Return Value:
    DWORD - exiting status.

--*/
	DWORD APIENTRY
    RPPerfCollect(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
	{  
	

		//
		// before doing anything else, see if Open went OK
	    //
		if (!fInitOk) 
		{
			// unable to continue because open failed.
			*lpcbTotalBytes = (DWORD) 0;
			*lpNumObjectTypes = (DWORD) 0;
			return ERROR_SUCCESS; // yes, this is a successful exit
		}

		// see if this is a foreign (i.e. non-NT) computer data request 
		//
	
		WCHAR FOREIGN_STRING[] = L"Foreign";
		int equal;
		equal = wcscmp(FOREIGN_STRING , lpValueName);


		if (equal == 0) {
			// this routine does not service requests for data from
			// Non-NT computers
			*lpcbTotalBytes = (DWORD) 0;
			*lpNumObjectTypes = (DWORD) 0;
			return ERROR_SUCCESS;
		}

    
		if (*lpcbTotalBytes < x_dwSizeOfData + x_dwSizeNT4Master )
		//
		//not enough space in the buffer
		//
		{			
			*lpcbTotalBytes = (DWORD) 0;
			*lpNumObjectTypes =(DWORD)0;
			return ERROR_MORE_DATA;
		}		
			
		//
		//get Counter Data via RPC
		//        
		PerfDataObject D;
		pPerfDataObject pD = &D;
              
		BOOL fSucc = getData(pD);
		if(!fSucc)
		{
			//
			//RPC remote function failed reset the counters
			//			                        
            for (UINT i=0; i<NUM_COUNTERS_REPLSERV; i++)
            {
                pD->PerfCounterArray[i] = 0;
            }            
            pD->dwMasterInstanceNum = 0;            
		}                       


        LPVOID pDstBuff = *lppData;
		pDataConfig pdc = &g_dc;
	
		//
		//copy the first object to the buffer
		//and advance the buffer pointer accordinly
		//        
		memcpy( pDstBuff,
                pdc,
                CONFIG_BLOCK_SIZE(NUM_COUNTERS_REPLSERV));
        pDstBuff =  (PCHAR)pDstBuff + 
            CONFIG_BLOCK_SIZE(NUM_COUNTERS_REPLSERV) ;        
      
        for (UINT i=0; i<NUM_COUNTERS_REPLSERV; i++)
        {           
		    *((DWORD*)pDstBuff) = pD->PerfCounterArray[i];
		    pDstBuff = (PCHAR)pDstBuff + COUNTER_DATA_SIZE;        
        }
                         
        //
        // copy the second object with all instances
        //
        g_ObjBlock.objectType.NumInstances = pD->dwMasterInstanceNum;
        g_ObjBlock.objectType.TotalByteLength = 
                                INSTANCE_SIZE(NUM_COUNTERS_NT4MASTER) * pD->dwMasterInstanceNum +
                                OBJECT_DEFINITION_SIZE(NUM_COUNTERS_NT4MASTER);
        DWORD dwTotalSize = g_ObjBlock.objectType.TotalByteLength;

        memcpy( pDstBuff,
                &g_ObjBlock,
                OBJECT_DEFINITION_SIZE(NUM_COUNTERS_NT4MASTER) ); 

		pDstBuff =  (PCHAR)pDstBuff + 
                    OBJECT_DEFINITION_SIZE(NUM_COUNTERS_NT4MASTER);        
      
        for (UINT inst = 0; inst<pD->dwMasterInstanceNum; inst++)
        {         
            g_InstBlock.instDef.NameLength = pD->NT4MasterArray[inst].dwNameLen;
            _tcscpy(g_InstBlock.szInstName, pD->NT4MasterArray[inst].pszMasterName);

            memcpy( pDstBuff,
                    &g_InstBlock,
                    INST_BLOCK_SIZE ); 
            pDstBuff =  (PCHAR)pDstBuff + INST_BLOCK_SIZE;            
            
            for (i=0; i<NUM_COUNTERS_NT4MASTER; i++)
            {
                *((DWORD*)pDstBuff) = pD->NT4MasterArray[inst].NT4MasterCounterArray[i];
                pDstBuff = (PCHAR)pDstBuff + COUNTER_DATA_SIZE;                
            }
        }

		*lppData = pDstBuff;//setting the new positon of the lppData 
        
        //total bytes that were written
		*lpcbTotalBytes = (DWORD) ( x_dwSizeOfData + dwTotalSize) ; 
                            
        *lpNumObjectTypes = (DWORD) 2;//two object type is being returned
		return ERROR_SUCCESS;
	}


/*++

Routine Description:
	The function handels all the closing procedures that must be taken 
	when the performance monitor close the connection with the replication
	service.
	The RPC connection is being terminated.

Arguments:
	None.

Return Value:
    DWORD - exiting status.

--*/
	DWORD APIENTRY RPPerfClose()
	{
		//
		//we perform this function when the last thread terminates
		//(i.e. wish to clode the connection).
		//
		if(--dwOpenCount == 0)
		{
			//
			//close RPC connection
			//
			 closeRpcConnection();           
		}
        
		return ERROR_SUCCESS;
	}




/*++

Routine Description:
	Initialize a PERF_COUNTER_BLOCK  data structure

Arguments:
	cbl - a pointer to a PERF_COUNTER_BLOCK data structure

Return Value:
	None.
    
--*/
	void initializeCountBlk(PERF_COUNTER_BLOCK* cbl, DWORD dwNumCounters)
	{
		cbl->ByteLength =COUNTER_BLOCK_SIZE + dwNumCounters * COUNTER_DATA_SIZE;

	}



/*++

Routine Description:
	Initialize a PERF_OBJECT_TYPE  data structure

Arguments:
	ob - a pointer to a PERF_OBJECT_TYPE data structure

Return Value:
	None.
    
--*/
	void initializeObType(
                PERF_OBJECT_TYPE* ob, 
                DWORD dwObjIndex,                
                DWORD dwNumCounters)
	{		
		//
		//PLEASE READ:
		//In order to avoid any misunderstanding Note that this field (i.e. DefinitionLength)
		//is the total size of the PERF_OBJECT_TYPE struct and all the PERF_COUNTER_DEFINITION 
		//structures .
		//		
		ob->HeaderLength  = OBJECT_TYPE_SIZE;
		ob->ObjectNameTitleIndex = dwObjIndex;
		ob->ObjectNameTitle = NULL;
		ob->ObjectHelpTitleIndex = dwObjIndex;
		ob->ObjectHelpTitle = NULL;
		ob->DetailLevel = PERF_DETAIL_NOVICE;
        ob->NumCounters = dwNumCounters;
        ob->DefinitionLength  = OBJECT_DEFINITION_SIZE(dwNumCounters);
        if (dwObjIndex == REPLOBJECT)
        {        
            ob->TotalByteLength = x_dwSizeOfData;		    
        }        
        else
        {
            ob->TotalByteLength = x_dwSizeNT4Master;                      
        }
        
		ob->DefaultCounter = 0;
		ob->NumInstances = PERF_NO_INSTANCES;
		ob->CodePage = 0;
	}



/*++

Routine Description:
	Initialize a PERF_COUNTER_DEFINITION  data structure 
	using the counter's index

Arguments:
	ot - a pointer to a PERF_COUNTER_DEFINITION data structure
	index - the offset of counter as definrd in the symbols file (symFile,h)

Return Value:
	None.
    
--*/
	void initializeCountDef(PERF_COUNTER_DEFINITION* ct , DWORD index, DWORD CurNum)
	{
		ct->ByteLength = COUNTER_DEFINITION_SIZE;
		ct->CounterNameTitleIndex  = index;
		ct->CounterNameTitle = NULL;
		ct->CounterHelpTitleIndex  = index;
		ct->CounterHelpTitle = NULL;
		ct->DefaultScale = 0;
		ct->DetailLevel = PERF_DETAIL_NOVICE;
		ct->CounterType = PERF_COUNTER_RAWCOUNT;
		ct->CounterSize = COUNTER_DATA_SIZE;		
		ct->CounterOffset = CurNum * COUNTER_DATA_SIZE + COUNTER_BLOCK_SIZE;
	}

    /*++

Routine Description:
	Initialize a PERF_INSTANCE_DEFINITION  data structure 

Arguments:
	idef - a pointer to a PERF_INSTANCE_DEFINITION data structure

Return Value:
	None.
    
--*/
void initializeInstanceDef(PERF_INSTANCE_DEFINITION* idef )
{    
    idef->ByteLength = sizeof (PERF_INSTANCE_DEFINITION) + INSTANCE_NAME_LEN_IN_BYTES;
                                    // Length in bytes of this structure,
                                    // including the subsequent name
    
    idef->ParentObjectTitleIndex = 0;
                                    // Title Index to name of "parent"
                                    // object (e.g., if thread, then
                                    // process is parent object type);
                                    // if logical drive, the physical
                                    // drive is parent object type
    idef->ParentObjectInstance = 0;
                                    // Index to instance of parent object
                                    // type which is the parent of this
                                    // instance.
    idef->UniqueID = PERF_NO_UNIQUE_ID;           
                                    // A unique ID used instead of
                                    // matching the name to identify
                                    // this instance, -1 = none
    idef->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
                                    // Offset from beginning of
                                    // this struct to the Unicode name
                                    // of this instance
    idef->NameLength = INSTANCE_NAME_LEN_IN_BYTES;         
                                    // Length in bytes of name; 0 = none
                                    // this length includes the characters
                                    // in the string plus the size of the
                                    // terminating NULL char. It does not
                                    // include any additional pad bytes to
                                    // correct structure alignment
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mqrpperf\mqrperf.h ===
//symbol file for perfDll

#define REPLOBJECT          0
#define NUMOFREPLSENT       2
#define NUMOFERRREPLSENT    4
#define NUMOFHELLOSENT      6
#define NUMOFERRHELLOSENT   8
#define NUMOFCREATE         10
#define NUMOFERRCREATE      12
#define NUMOFSET            14
#define NUMOFERRSET         16
#define NUMOFDELETE         18
#define NUMOFERRDELETE      20
#define NUMOFREPLOBJ        22
#define NUMOFWRITEREQ       24


#define NT4MASTEROBJECT     26
#define LASTSNOUT           28
#define LASTSNIN            30
#define NUMOFSYNCREQSENT    32
#define NUMOFNT4CREATE      34
#define NUMOFERRNT4CREATE   36
#define NUMOFNT4SET         38
#define NUMOFERRNT4SET      40
#define NUMOFNT4DELETE      42
#define NUMOFERRNT4DELETE   44
#define NUMOFNT4WRITEREQ    46
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mqrpperf\rpperf_c_.c ===
#pragma warning(push, 3)
#include <rpperf_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mqrpperf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqrpperf.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\mqrpperf\perfrpc.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    perfRpc

Abstract:

    RPC Client end for the dll.
	function implementation.

Author:

    Erez Vizel (t-erezv) 14-Feb-99

--*/

#include "..\mq1repl\replrpc.h"
#include "windows.h"
#include "winperf.h"
#include "mqRepSt.h"
#include <tchar.h>

#include "perfrpc.tmh"

handle_t hBind = NULL ;
RPC_STATUS status;

/*++

Routine Description:
	Initialize the connection to the server.
	1.composing a binding string.
	2.creating a binding handle.

Arguments:
	None.

Return Value:
    int - exiting status.

--*/
int initRpcConnection()
{
	//
	//Get computer name
	//
	UCHAR wszComputerName [MAX_COMPUTERNAME_LENGTH + 1 ];

	WCHAR wszServerName[ MAX_COMPUTERNAME_LENGTH + 1] ;
    mbstowcs( wszServerName,
              (char*) (const_cast<unsigned char*> (wszComputerName)),
              sizeof(wszServerName)/sizeof(WCHAR)) ;

	DWORD size = MAX_COMPUTERNAME_LENGTH + 1  ;
	BOOL fSucc = GetComputerName( wszServerName, &size);

	if (!fSucc)
	{
		return 1;
	}

	//
	//RpcStringBindingCompose - compose a bind string
	//
	WCHAR *wszStringBinding = NULL;
    status = RpcStringBindingCompose(NULL,  // pszUuid,
                                     QMREPL_PROTOCOL, 
                                     wszServerName,
                                     REPLPERF_ENDPOINT, 
                                     QMREPL_OPTIONS, 
                                     &wszStringBinding);

    if (status != RPC_S_OK)
    {
        return status ;
    }
	//
	//RpcBindingFromStringBinding - create a bind handle
	//
    status = RpcBindingFromStringBinding( wszStringBinding,&hBind);
  
    if (status != RPC_S_OK)
    {
        return status ;
    }
	//
	//RpcStringFree - free the  binding string
	//
    status = RpcStringFree(&wszStringBinding);  
    
	return status;
	
}//initRpcConnection




/*++

Routine Description:
	Retrieve the counter data from the server end.

Arguments:
	pd - data structure pointer.

Return Value:
    BOOL - TRUE if data was retrieved successfully FALSE otherwise.

--*/
BOOL getData(pPerfDataObject pData)
{    
	//
	//remote function call
	//	
	RpcTryExcept 
	{     
		getCounterData(hBind, pData);
	}
    RpcExcept(TRUE) 
	{	
		//
		//An acception has occured while performing the remote function
		//return FALSE to indicate failure
		//	
		return FALSE;
	}
    RpcEndExcept

	return TRUE;
	
}


/*++

Routine Description:
	close the connection to the server.

Arguments:
	None.

Return Value:
    int - exiting status.

--*/
int closeRpcConnection()
{
	//
	//RpcBindingFree - free the bind handle
	//
    status = RpcBindingFree( &hBind ) ;


	return status;

}


/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return (new BYTE[ len ]) ;
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    delete ptr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\replctrl\cusndlg.cpp ===
// cusnDlg.cpp : implementation file
//

#include "stdafx.h"
#include "replctrl.h"
#include "cusnDlg.h"

#include "cusndlg.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// cusnDlg property page

IMPLEMENT_DYNCREATE(cusnDlg, CPropertyPage)

cusnDlg::cusnDlg() : CPropertyPage(cusnDlg::IDD)
{
	//{{AFX_DATA_INIT(cusnDlg)
	m_usn = _T("");
	//}}AFX_DATA_INIT
}

cusnDlg::~cusnDlg()
{
}

void cusnDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(cusnDlg)
	DDX_Text(pDX, IDC_USN, m_usn);
	DDV_MaxChars(pDX, m_usn, 24);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(cusnDlg, CPropertyPage)
	//{{AFX_MSG_MAP(cusnDlg)
	ON_EN_CHANGE(IDC_USN, OnChangeUsn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// cusnDlg message handlers

static BOOL s_fApply = FALSE ;

void cusnDlg::OnChangeUsn()
{
    if (!s_fApply)
    {
    	SetModified() ;
        s_fApply = TRUE ;
    }
}

BOOL cusnDlg::OnApply()
{
	// TODO: Add your specialized code here and/or call the base class

    if (s_fApply)
    {
        BOOL fBad = FALSE ;
        int l = strlen(m_usn) ;

        for ( int i = 0 ; i < l ; i++ )
        {
            if ((m_usn[i] < '0') || (m_usn[i] > '9'))
            {
                fBad = TRUE ;
                break ;
            }
        }

        if (fBad)
        {
            ::MessageBox(NULL, "You must enter a numeric value", "Error", MB_OK) ;
        }
        else
        {
            DWORD dwType  = REG_SZ;
            WCHAR wszName[ 128 ] ;
            mbstowcs(wszName, HIGHESTUSN_REPL_REG, 128) ;
            WCHAR wszValue[ 128 ] ;
            mbstowcs(wszValue, m_usn, 128) ;
            DWORD dwSize  = wcslen(wszValue) * sizeof(WCHAR) ;

            LONG rc = SetFalconKeyValue( wszName,
                                         &dwType,
                                         wszValue,
                                         &dwSize ) ;
        }
        s_fApply = FALSE ;
    }

	return CPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\replctrl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	replctrl.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\replctrl\replctrl.cpp ===
// replctrl.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "replctrl.h"
#include "rptimes.h"
#include "cusndlg.h"
#include "threads.h"

#include "replctrl.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CReplctrlApp

BEGIN_MESSAGE_MAP(CReplctrlApp, CWinApp)
	//{{AFX_MSG_MAP(CReplctrlApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReplctrlApp construction

CReplctrlApp::CReplctrlApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CReplctrlApp object

CReplctrlApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CReplctrlApp initialization

BOOL CReplctrlApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CPropertySheet MySheet;
    CrpTimes       rpTimesPage ;
    cusnDlg        usnPage ;
    CThreads       cThreadsPage ;

    MySheet.m_psh.dwFlags &= (~PSH_NOAPPLYNOW) ;
    MySheet.m_psh.dwFlags &= (~PSH_HASHELP) ;

    DWORD dwSize  = sizeof(DWORD);
    DWORD dwType  = REG_DWORD;
    DWORD dwValue = 0 ;
    DWORD dwDefault = RP_DEFAULT_TIMES_HELLO ;
    WCHAR wszName[ 128 ] ;
    mbstowcs(wszName, RP_TIMES_HELLO_FOR_REPLICATION_INTERVAL_REGNAME, 128) ;
    LONG rc = GetFalconKeyValue( wszName,
                                 &dwType,
                                 &dwValue,
                                 &dwSize,
                                 (LPCWSTR) &dwDefault ) ;

    rpTimesPage.m_ulReplTime = dwValue ;

    dwSize  = sizeof(DWORD);
    dwType  = REG_DWORD;
    dwValue = 0 ;
    dwDefault = RP_DEFAULT_HELLO_INTERVAL ;
    mbstowcs(wszName, RP_HELLO_INTERVAL_REGNAME, 128) ;
    rc = GetFalconKeyValue( wszName,
                            &dwType,
                            &dwValue,
                            &dwSize,
                            (LPCWSTR) &dwDefault ) ;

    rpTimesPage.m_ulHelloTime = dwValue ;

    dwSize  = sizeof(DWORD);
    dwType  = REG_DWORD;
    dwValue = 0 ;
    dwDefault = RP_DEFAULT_REPL_NUM_THREADS ;
    mbstowcs(wszName, RP_REPL_NUM_THREADS_REGNAME, 128) ;
    rc = GetFalconKeyValue( wszName,
                            &dwType,
                            &dwValue,
                            &dwSize,
                            (LPCWSTR) &dwDefault ) ;

    cThreadsPage.m_cThreads = dwValue ;

    dwSize  = 128 ;
    dwType  = REG_SZ;
    mbstowcs(wszName, HIGHESTUSN_REPL_REG, 128) ;
    WCHAR wszBuf[ 128 ] ;
    char  szBuf[ 128 ] ;
    rc = GetFalconKeyValue( wszName,
                            &dwType,
                            wszBuf,
                            &dwSize,
                            (LPCWSTR) L"" ) ;
    wcstombs(szBuf, wszBuf, 128) ;
    usnPage.m_usn = szBuf ;

	MySheet.AddPage(&rpTimesPage);
	MySheet.AddPage(&cThreadsPage);
	MySheet.AddPage(&usnPage);
    MySheet.SetTitle(TEXT("Replication Service Control")) ;

	int nResponse = MySheet.DoModal();

	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\replctrl\replctrl.h ===
// replctrl.h : main header file for the REPLCTRL application
//

#if !defined(AFX_REPLCTRL_H__71AD7A35_CE17_11D1_B94A_0060081E87F0__INCLUDED_)
#define AFX_REPLCTRL_H__71AD7A35_CE17_11D1_B94A_0060081E87F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CReplctrlApp:
// See replctrl.cpp for the implementation of this class
//

class CReplctrlApp : public CWinApp
{
public:
	CReplctrlApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CReplctrlApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CReplctrlApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REPLCTRL_H__71AD7A35_CE17_11D1_B94A_0060081E87F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\replctrl\rptimes.h ===
#if !defined(AFX_RPTIMES_H__71AD7A3F_CE17_11D1_B94A_0060081E87F0__INCLUDED_)
#define AFX_RPTIMES_H__71AD7A3F_CE17_11D1_B94A_0060081E87F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// rpTimes.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CrpTimes dialog

class CrpTimes : public CPropertyPage
{
	DECLARE_DYNCREATE(CrpTimes)

// Construction
public:
	CrpTimes();
	~CrpTimes();

// Dialog Data
	//{{AFX_DATA(CrpTimes)
	enum { IDD = IDD_RPTIMES };
	UINT	m_ulReplTime;
	UINT	m_ulHelloTime;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CrpTimes)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CrpTimes)
	afx_msg void OnChangeRpTime();
	afx_msg void OnChangeEditHello();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RPTIMES_H__71AD7A3F_CE17_11D1_B94A_0060081E87F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\replctrl\rptimes.cpp ===
// rpTimes.cpp : implementation file
//

#include "stdafx.h"
#include "replctrl.h"
#include "rpTimes.h"

#include "rptimes.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CrpTimes property page

IMPLEMENT_DYNCREATE(CrpTimes, CPropertyPage)

CrpTimes::CrpTimes() : CPropertyPage(CrpTimes::IDD)
{
	//{{AFX_DATA_INIT(CrpTimes)
	m_ulReplTime = 0;
	m_ulHelloTime = 0;
	//}}AFX_DATA_INIT
}

CrpTimes::~CrpTimes()
{
}

void CrpTimes::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CrpTimes)
	DDX_Text(pDX, IDC_RP_TIME, m_ulReplTime);
	DDV_MinMaxUInt(pDX, m_ulReplTime, 1, 99999);
	DDX_Text(pDX, IDC_EDIT_HELLO, m_ulHelloTime);
	DDV_MinMaxUInt(pDX, m_ulHelloTime, 1, 99999);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CrpTimes, CPropertyPage)
	//{{AFX_MSG_MAP(CrpTimes)
	ON_EN_CHANGE(IDC_RP_TIME, OnChangeRpTime)
	ON_EN_CHANGE(IDC_EDIT_HELLO, OnChangeEditHello)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CrpTimes message handlers

static BOOL s_fApply = FALSE ;

void CrpTimes::OnChangeRpTime()
{
    if (!s_fApply)
    {
	    SetModified() ;
        s_fApply = TRUE ;
    }
}

void CrpTimes::OnChangeEditHello()
{
    if (!s_fApply)
    {
	    SetModified() ;
        s_fApply = TRUE ;
    }
}

BOOL CrpTimes::OnApply()
{
	// TODO: Add your specialized code here and/or call the base class
    if (s_fApply)
    {
        DWORD dwSize  = sizeof(DWORD);
        DWORD dwType  = REG_DWORD;
        DWORD dwValue = m_ulReplTime ;
        WCHAR wszName[ 128 ] ;
        mbstowcs(wszName, RP_TIMES_HELLO_FOR_REPLICATION_INTERVAL_REGNAME, 128) ;
        LONG rc = SetFalconKeyValue( wszName,
                                     &dwType,
                                     &dwValue,
                                     &dwSize ) ;

        dwSize  = sizeof(DWORD);
        dwType  = REG_DWORD;
        dwValue = m_ulHelloTime ;
        mbstowcs(wszName, RP_HELLO_INTERVAL_REGNAME, 128) ;
        rc = SetFalconKeyValue( wszName,
                                &dwType,
                                &dwValue,
                                &dwSize ) ;
        s_fApply = TRUE ;
    }

	return CPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\replctrl\cusndlg.h ===
#if !defined(AFX_CUSNDLG_H__71AD7A41_CE17_11D1_B94A_0060081E87F0__INCLUDED_)
#define AFX_CUSNDLG_H__71AD7A41_CE17_11D1_B94A_0060081E87F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// cusnDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// cusnDlg dialog

class cusnDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(cusnDlg)

// Construction
public:
	cusnDlg();
	~cusnDlg();

// Dialog Data
	//{{AFX_DATA(cusnDlg)
	enum { IDD = IDD_USN };
	CString	m_usn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(cusnDlg)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(cusnDlg)
	afx_msg void OnChangeUsn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CUSNDLG_H__71AD7A41_CE17_11D1_B94A_0060081E87F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\replctrl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by replctrl.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_REPLCTRL_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDD_RPTIMES                     129
#define IDD_USN                         130
#define IDD_THREADS                     131
#define IDC_RP_TIME                     1000
#define IDC_USN                         1001
#define IDC_EDIT_HELLO                  1002
#define IDC_EDT_NUM_THREADS             1003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\replctrl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__71AD7A39_CE17_11D1_B94A_0060081E87F0__INCLUDED_)
#define AFX_STDAFX_H__71AD7A39_CE17_11D1_B94A_0060081E87F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__71AD7A39_CE17_11D1_B94A_0060081E87F0__INCLUDED_)

//
// MSMQ headers
//

#include <_mqini.h>
#include "..\migrepl.h"

#define DLL_IMPORT  __declspec(dllimport)
#include <_registr.h>
#undef  DLL_IMPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\replctrl\threads.cpp ===
// Threads.cpp : implementation file
//

#include "stdafx.h"
#include "replctrl.h"
#include "Threads.h"

#include "threads.tmh"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CThreads property page

IMPLEMENT_DYNCREATE(CThreads, CPropertyPage)

CThreads::CThreads() : CPropertyPage(CThreads::IDD)
{
	//{{AFX_DATA_INIT(CThreads)
	m_cThreads = 0;
	//}}AFX_DATA_INIT
}

CThreads::~CThreads()
{
}

void CThreads::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CThreads)
	DDX_Text(pDX, IDC_EDT_NUM_THREADS, m_cThreads);
	DDV_MinMaxUInt(pDX, m_cThreads, 1, 999);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CThreads, CPropertyPage)
	//{{AFX_MSG_MAP(CThreads)
	ON_EN_CHANGE(IDC_EDT_NUM_THREADS, OnChangeEdtNumThreads)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CThreads message handlers

static BOOL s_fApply = FALSE ;

void CThreads::OnChangeEdtNumThreads()
{
    if (!s_fApply)
    {
	    SetModified() ;
        s_fApply = TRUE ;
    }
}

BOOL CThreads::OnApply()
{
    if (s_fApply)
    {
        DWORD dwSize  = sizeof(DWORD);
        DWORD dwType  = REG_DWORD;
        DWORD dwValue = m_cThreads ;
        WCHAR wszName[ 128 ] ;
        mbstowcs(wszName, RP_REPL_NUM_THREADS_REGNAME, 128) ;
        LONG rc = SetFalconKeyValue( wszName,
                                     &dwType,
                                     &dwValue,
                                     &dwSize ) ;
        s_fApply = TRUE ;
    }
	
	return CPropertyPage::OnApply();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\authlevel.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    authlevel.h

Abstract:
    defines for PROPID_M_AUTH_LEVEL

Author:
    Ilan Herbst (ilanh) 05-Nov-2000

Environment:
    Platform-independent,

--*/

#pragma once

#ifndef _AUTHLEVEL_H_
#define _AUTHLEVEL_H_

#define IS_AUTH_LEVEL_ALWAYS_BIT(level)		(((level) & MQMSG_AUTH_LEVEL_ALWAYS) != 0)
#define IS_AUTH_LEVEL_SIG10_BIT(level)		(((level) & MQMSG_AUTH_LEVEL_SIG10) != 0)
#define IS_AUTH_LEVEL_SIG20_BIT(level)		(((level) & MQMSG_AUTH_LEVEL_SIG20) != 0)
#define IS_AUTH_LEVEL_SIG30_BIT(level)		(((level) & MQMSG_AUTH_LEVEL_SIG30) != 0)
#define IS_AUTH_LEVEL_XMLDSIG_BIT(level)	(((level) & MQMSG_AUTH_LEVEL_XMLDSIG_V1) != 0)

#define SET_AUTH_LEVEL_SIG10_BIT(level)	(level) |= MQMSG_AUTH_LEVEL_SIG10
#define SET_AUTH_LEVEL_SIG20_BIT(level)	(level) |= MQMSG_AUTH_LEVEL_SIG20
#define SET_AUTH_LEVEL_SIG30_BIT(level)	(level) |= MQMSG_AUTH_LEVEL_SIG30

#define CLEAR_AUTH_LEVEL_SIG10_BIT(level)	(level) &= ~((ULONG)MQMSG_AUTH_LEVEL_SIG10)
#define CLEAR_AUTH_LEVEL_SIG20_BIT(level)	(level) &= ~((ULONG)MQMSG_AUTH_LEVEL_SIG20)
#define CLEAR_AUTH_LEVEL_SIG30_BIT(level)	(level) &= ~((ULONG)MQMSG_AUTH_LEVEL_SIG30)

#define GET_AUTH_LEVEL_MSMQ_PROTOCOL(level)		((level) & AUTH_LEVEL_MASK)

#endif // _AUTHLEVEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\dllmap.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P R O C M A P . C
//
//  Contents:   Procedure maps for dload.c
//
//  Notes:
//
//  Author:     conradc   12 April 2001
//              Originated from %sdxroot%\MergedComponents\dload\dllmap.c
//
//----------------------------------------------------------------------------

#include "stdh.h"
#include "dld.h"



//
// All of the dll's that dld.lib supports delay-load failure handlers for
// (both by procedure and by ordinal) need both a DECLARE_XXXXXX_MAP below and
// a DLDENTRYX entry in the g_DllEntries list.
//

// alphabetical order (hint hint)

DECLARE_PROCNAME_MAP(mqrtdep)




const DLOAD_DLL_ENTRY g_DllEntries [] =
{
    // must be in alphabetical increasing order 
    DLDENTRYP(mqrtdep)
};


const DLOAD_DLL_MAP g_DllMap =
{
    celems(g_DllEntries),
    g_DllEntries
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\midluser.cpp ===
#include <stdh.h>

#include "..\\common\\midluser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\fnparse.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fnparse.cpp

Abstract:

    Format Name parsing.
    QUEUE_FORMAT <--> Format Name String conversion routines

Author:

    Erez Haba (erezh) 17-Jan-1997

Revision History:

--*/

#include "stdh.h"
#include <mqformat.h>

#include "fnparse.tmh"

static WCHAR *s_FN=L"rt/fnparse";

//=========================================================
//
//  QUEUE_FORMAT -> Format Name String conversion routine
//
//=========================================================

//---------------------------------------------------------
//
//  Function:
//      RTpQueueFormatToFormatName
//
//  Description:
//      Convert QUEUE_FORMAT to a format name string.
//
//---------------------------------------------------------
HRESULT
RTpQueueFormatToFormatName(
    QUEUE_FORMAT* pQueueFormat,
    LPWSTR lpwcsFormatName,
    DWORD dwBufferLength,
    LPDWORD lpdwFormatNameLength
    )
{
    HRESULT hr = MQpQueueFormatToFormatName(
            pQueueFormat,
            lpwcsFormatName,
            dwBufferLength,
            lpdwFormatNameLength,
            false
            );
    return LogHR(hr, s_FN, 10);
}


//+-------------------------------------------
//
//  BOOL  RTpIsLocalPublicQueue()
//
//+-------------------------------------------

BOOL
RTpIsLocalPublicQueue(LPCWSTR lpwcsExpandedPathName)
{
    WCHAR  wDelimiter = lpwcsExpandedPathName[ g_dwComputerNameLen ] ;

    if ((wDelimiter == PN_DELIMITER_C) ||
        (wDelimiter == PN_LOCAL_MACHINE_C))
    {
        //
        // Delimiter OK (either end of NETBios machine name, or dot of
        // DNS name. Continue checking.
        //
    }
    else
    {
        return FALSE ;
    }

    DWORD dwSize = g_dwComputerNameLen + 1 ;
    P<WCHAR> pQueueCompName = new WCHAR[ dwSize ] ;
    lstrcpynW( pQueueCompName.get(), lpwcsExpandedPathName, dwSize ) ;

    BOOL bRet = (lstrcmpi( g_lpwcsComputerName, pQueueCompName.get() ) == 0) ;
    return bRet ;
}


void
RTpRemoteQueueNameToMachineName(
	LPCWSTR RemoteQueueName,
	LPWSTR* MachineName
	)
/*++
Routine description:
    RemoteQueueName as returned by QMGetRemoteQueueName() and R_QMOpenQueue()
	functions from the QM, has a varying format. this function extracts the 
	Machine name from that string
    
Arguments:
	MachineName - Allocated string holding the machine name.
 --*/
{
	LPCWSTR RestOfNodeName;

	try
	{
		//
		// Skip direct token type if it exists (like "OS:" or "HTTP://"...)
		//
		DirectQueueType Dummy;
		RestOfNodeName = FnParseDirectQueueType(RemoteQueueName, &Dummy);
	}
	catch(const exception&)
	{
		RestOfNodeName = RemoteQueueName;
	}

	try
	{
		//
		// Extracts machine name until seperator (one of "/" "\" ":")
		//
		AP<WCHAR> Temp;

		FnExtractMachineNameFromDirectPath(
			RestOfNodeName, 
			Temp
			);

		*MachineName = Temp.detach();
	}
	catch(const exception&)
	{
		//
		// No seperator found, so assume whole string is machine name 
		//
		*MachineName = newwcs(RestOfNodeName);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\machine.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    machine.cpp

Abstract:

    This module contains code involved with Machine APIs.

Author:

    Ronit Hartmann (ronith)

Revision History:

--*/

#include "stdh.h"
#include <ad.h>
#include <mqsec.h>
#include "_registr.h"
#include <_guid.h>
#include "version.h"
#include <mqversion.h>
#include <mqnames.h>
#include <rtdep.h>
#include "rtputl.h"

#include "machine.tmh"

static WCHAR *s_FN=L"rt/machine";

BOOL
IsConnectionRequested(IN MQQMPROPS * pQMProps,
                      IN DWORD* pdwIndex)
{
    for(DWORD i= 0; i < pQMProps->cProp; i++)
    {
        if (pQMProps->aPropID[i] == PROPID_QM_CONNECTION)
        {
            ASSERT(pQMProps-> aPropVar[i].vt == VT_NULL);

            pQMProps->aPropID[i] = PROPID_QM_SITE_IDS;
            *pdwIndex = i;
            return TRUE;
        }
    }
    return FALSE;
}

//+------------------------------------------
//
//  HRESULT  GetEncryptionPublicKey()
//
//+------------------------------------------

HRESULT
GetEncryptionPublicKey(
    IN LPCWSTR          lpwcsMachineName,
    IN const GUID *     pguidMachineId,
    IN OUT HRESULT*     aStatus,
    IN OUT MQQMPROPS   *pQMProps
    )
{
    DWORD i;
    BOOL fFirst = TRUE;
    HRESULT hr = MQ_OK;

    for(i= 0; i < pQMProps->cProp; i++)
    {
        if ((pQMProps->aPropID[i] == PROPID_QM_ENCRYPTION_PK) ||
            (pQMProps->aPropID[i] == PROPID_QM_ENCRYPTION_PK_BASE))
        {
            //
            // Use msmq1.0 code, because our server can be either msmq1.0
            // or msmq2.0.
            //
            // Check if legal VT Value
            //
            if(pQMProps->aPropVar[i].vt != VT_NULL)
            {
                aStatus[i] = MQ_ERROR_PROPERTY;
                return LogHR(MQ_ERROR_PROPERTY, s_FN, 10);
            }
            else
            {
                aStatus[i] = MQ_OK;
            }

            if (fFirst)
            {
                PROPID prop =  PROPID_QM_ENCRYPT_PK;

                if (lpwcsMachineName)
                {
                    hr = ADGetObjectProperties(
								eMACHINE,
								NULL,      // pwcsDomainController
								false,	   // fServerName
								lpwcsMachineName,
								1,
								&prop,
								&pQMProps->aPropVar[i]
								);
                }
                else
                {
                    hr = ADGetObjectPropertiesGuid(
								eMACHINE,
								NULL,      // pwcsDomainController
								false,	   // fServerName
								pguidMachineId,
								1,
								&prop,
								&pQMProps->aPropVar[i]
								);
                }
                if (FAILED(hr))
                {
                    break;
                }

				//
				// PROPID_QM_ENCRYPTION_PK, PROPID_QM_ENCRYPTION_PK_BASE
				// are VT_UI1|VT_VECTOR
				// while PROPID_QM_ENCRYPT_PK is VT_BLOB
				//
                ASSERT(pQMProps-> aPropVar[i].vt == VT_BLOB);
                pQMProps-> aPropVar[i].vt = VT_UI1|VT_VECTOR;
                
                fFirst = FALSE;
            }
            else
            {
                //
                // Duplicate proprerty
                //
                aStatus[i] = MQ_INFORMATION_DUPLICATE_PROPERTY;
            }
        }
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20) ;
    }

    //
    // now see if caller asked for enhanced key (128 bits).
    //
    fFirst = TRUE;

    for(i= 0; i < pQMProps->cProp; i++)
    {
        if (pQMProps->aPropID[i] == PROPID_QM_ENCRYPTION_PK_ENHANCED)
        {
            //
            // Check if legal VT Value
            //
            if(pQMProps->aPropVar[i].vt != VT_NULL)
            {
                aStatus[i] = MQ_ERROR_PROPERTY;
                return LogHR(MQ_ERROR_PROPERTY, s_FN, 30);
            }
            else
            {
                aStatus[i] = MQ_OK;
            }

            if (fFirst)
            {
                P<BYTE> pPbKey ;
                DWORD dwReqLen;

                hr = MQSec_GetPubKeysFromDS( pguidMachineId,
                                             lpwcsMachineName,
                                             eEnhancedProvider,
                                             PROPID_QM_ENCRYPT_PKS,
                                            &pPbKey,
                                            &dwReqLen ) ;
                if (FAILED(hr))
                {
                    break;
                }

                pQMProps-> aPropVar[i].vt = VT_UI1|VT_VECTOR;
                pQMProps-> aPropVar[i].caub.cElems = dwReqLen;
                pQMProps-> aPropVar[i].caub.pElems = new UCHAR[dwReqLen];
                memcpy(pQMProps->aPropVar[i].caub.pElems, pPbKey.get(), dwReqLen);

                fFirst = FALSE;
            }
            else
            {
                //
                // Duplicate proprerty
                //
                aStatus[i] = MQ_INFORMATION_DUPLICATE_PROPERTY;
            }
        }
    }

    return LogHR(hr, s_FN, 40);
}

HRESULT GetCNNameList(IN OUT MQPROPVARIANT* pVar)
{
    ASSERT(pVar->vt == (VT_CLSID|VT_VECTOR));

    //
    // pVar contains the list of sites where the machine reside
    //

    LPWSTR * pElems = new LPWSTR[(pVar->cauuid).cElems];

    for(DWORD i = 0; i < (pVar->cauuid).cElems; i++)
    {
        HRESULT hr;
        PROPID      aProp[2];
        PROPVARIANT aVar[2];
        ULONG       cProps = sizeof(aProp) / sizeof(PROPID);

        aProp[0] = PROPID_S_FOREIGN;
        aProp[1] = PROPID_S_PATHNAME;
        aVar[0].vt = VT_UI1;
        aVar[1].vt = VT_NULL;

        hr = ADGetObjectPropertiesGuid(
                        eSITE,
                        NULL,       // pwcsDomainCOntroller
						false,	    // fServerName
                        &((pVar->cauuid).pElems[i]),
                        cProps,
                        aProp,
                        aVar);   

        if (FAILED(hr))
        {
            for (DWORD j = 0 ; j < i ; j++ )
            {
                delete pElems[j] ;
            }
            delete pElems ;

            return LogHR(hr, s_FN, 50);
        }

        GUID_STRING wszGuid;
        MQpGuidToString(&((pVar->cauuid).pElems[i]), wszGuid);

        DWORD dwTypeSize;
        LPWSTR lpwsTypeNmae;

        switch (aVar[0].bVal)
        {
            case 0:
                //
                //  non foreign site
                //
                dwTypeSize = wcslen(L"IP_CONNECTION");
                lpwsTypeNmae = L"IP_CONNECTION";
                break;
            case 1:
                //
                // foreign site
                //
                dwTypeSize = wcslen(L"FOREIGN_CONNECTION");
                lpwsTypeNmae = L"FOREIGN_CONNECTION";
                break;
            default:
                dwTypeSize = wcslen(L"UNKNOWN_CONNECTION");
                lpwsTypeNmae = L"UNKNOWN_CONNECTION";
                break;
        }

        DWORD CNNameSize = dwTypeSize + 1 +                 // protocol id
                           wcslen(wszGuid) + 1+             // site Guid
                           wcslen(aVar[1].pwszVal) + 1;     // site Name

        pElems[i] = new WCHAR[CNNameSize];
        wsprintf(pElems[i],L"%s %s %s",lpwsTypeNmae, wszGuid, aVar[1].pwszVal);

        delete  [] aVar[1].pwszVal;
    }

    delete [] (pVar->cauuid).pElems;
    (pVar->calpwstr).cElems = (pVar->cauuid).cElems;
    (pVar->calpwstr).pElems = pElems;

    pVar->vt = VT_LPWSTR|VT_VECTOR;

    return MQ_OK;
}

EXTERN_C
HRESULT
APIENTRY
MQGetMachineProperties(
    IN LPCWSTR lpwcsMachineName,
    IN const GUID *    pguidMachineId,
    IN OUT MQQMPROPS * pQMProps)
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepGetMachineProperties(
					lpwcsMachineName, 
					pguidMachineId,
					pQMProps
					);

    CMQHResult rc(MQDS_MACHINE), rc1(MQDS_MACHINE);
    LPWSTR lpwsPathName =  (LPWSTR)lpwcsMachineName;
    MQQMPROPS *pGoodQMProps;
    char *pTmpQPBuff = NULL;
    BOOL fGetConnection = FALSE;
    DWORD dwConnectionIndex = 0;
    HRESULT* aLocalStatus_buff = NULL;


    __try
    {
        __try
        {
            if (( lpwcsMachineName != NULL) &&
                ( pguidMachineId != NULL))
            {
                //
                //  the user cannot specify both machine name
                //  and guid
                //
                return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 60);
            }

            if ( pguidMachineId == NULL)
            {
                //
                //  if machine name is NULL, the calls refers to the
                //  local machine
                //
                if ( lpwcsMachineName == NULL)
                {
                    lpwsPathName = g_lpwcsComputerName;
                }
            }

            //
            // We must have a status array, even if the user didn't pass one. This is in
            // order to be able to tell whether each propery is good or not.
            //
            HRESULT * aLocalStatus;

            if (!pQMProps->aStatus)
            {
                aLocalStatus_buff = new HRESULT[pQMProps->cProp];
                aLocalStatus = aLocalStatus_buff;
            }
            else
            {
                aLocalStatus = pQMProps->aStatus;
            }

            //
            // See if the application wants to retrieve the key exchange
            // public key of the QM.
            //
            DWORD iPbKey;

            for (iPbKey = 0;
                 (iPbKey < pQMProps->cProp) &&
                    (pQMProps->aPropID[iPbKey] != PROPID_QM_ENCRYPTION_PK);
                 iPbKey++)
			{
				NULL;
			}

            //
            //  Check QM properties structure
            //
            rc1 = RTpCheckQMProps( pQMProps,
                                   aLocalStatus,
                                   &pGoodQMProps,
                                   &pTmpQPBuff );

            if (FAILED(rc1))
            {
                return LogHR(rc1, s_FN, 70);
            }

            if ((rc1 == MQ_INFORMATION_PROPERTY) && (iPbKey < pQMProps->cProp))
            {
                //
                // If only PROPID_QM_ENCRYPTION_PK caused the return code
                // of RTpCheckQMProps to return MQ_INFORMATION_PROPERTY, so
                // convert it to MQ_OK.
                //
                rc1 = MQ_OK;

                for (DWORD iProp = 0; iProp < pQMProps->cProp; iProp++)
                {
                    if (aLocalStatus[iProp] != MQ_OK)
                    {
                        rc1 = MQ_INFORMATION_PROPERTY;
                        break;
                    }
                }
            }

            //
            // We may get here with zero properties to retrieve, if the
            // application is only interested in PROPID_QM_ENCRYPTION_PK.
            //
            if (pGoodQMProps->cProp)
            {
                //
                // Check if CN list is requested. If yes return the Index and replace the
                // property to PROPID_QM_CNS
                //
                fGetConnection = IsConnectionRequested(pGoodQMProps,
                                                       &dwConnectionIndex);

                if (lpwsPathName)
                {
                    rc = ADGetObjectProperties(
                                    eMACHINE,
                                    NULL,       // pwcsDomainController
									false,	    // fServerName
                                    lpwsPathName,
                                    pGoodQMProps->cProp,
                                    pGoodQMProps->aPropID,
                                    pGoodQMProps->aPropVar
									);
                }
                else
                {
                    rc = ADGetObjectPropertiesGuid(
                                eMACHINE,
                                NULL,       // PWCSDOmainController
								false,	    // fServerName
                                pguidMachineId,
                                pGoodQMProps->cProp,
                                pGoodQMProps->aPropID,
                                pGoodQMProps->aPropVar
								);
                }
            }
            else
            {
                rc = MQ_OK;
            }

			if ( fGetConnection	)
			{
				//
				//	Replace back the connection propid value ( also in case
				//	of failure)
				//
				pGoodQMProps->aPropID[dwConnectionIndex] = 	PROPID_QM_CONNECTION;
			}

            if (SUCCEEDED(rc))
            {
                rc = GetEncryptionPublicKey(lpwsPathName,
                                            pguidMachineId,
                                            aLocalStatus,
                                            pQMProps);
            }

            if (SUCCEEDED(rc) && fGetConnection)
            {
                rc = GetCNNameList(&(pGoodQMProps->aPropVar[dwConnectionIndex]));
            }
            //
            // Here we have out machindwConnectionIndexe properties, so if the properties were copied to
            // a temporary buffer, copy the resulted prop vars to the application's
            // buffer.
            //
            if (SUCCEEDED(rc) && (pQMProps != pGoodQMProps))
            {
                DWORD i, j;

                for (i = 0, j = 0; i < pGoodQMProps->cProp; i++, j++)
                {
                    while(pQMProps->aPropID[j] != pGoodQMProps->aPropID[i])
                    {
                        j++;
                        ASSERT(j < pQMProps->cProp);
                    }
                    pQMProps->aPropVar[j] = pGoodQMProps->aPropVar[i];

                }

                //
                // Check if there is a real warning or the warning came from
                // the PROPID_QM_ENCRYPTION_PK property
                //
                BOOL fWarn = FALSE;
                for (i = 0; i < pQMProps->cProp; i++)
                {
                    if (aLocalStatus[i] != MQ_OK)
                    {
                        fWarn = TRUE;
                    }
                }

                if (!fWarn && (rc1 != MQ_OK))
                {
                    rc1 = MQ_OK;
                }

            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 80); 
        }
    }
    __finally
    {
        delete[] pTmpQPBuff;
        delete[] aLocalStatus_buff;
    }

    if (!FAILED(rc))
    {
        return LogHR(rc1, s_FN, 90);
    }

    return LogHR(rc, s_FN, 100);
}

//---------------------------------------------------------
//
//  FillPrivateComputerVersion(...)
//
//  Description:
//
//      Retrieve private computer MSMQ version
//
//  Return Value:
//
//      none
//
//---------------------------------------------------------
static void FillPrivateComputerVersion(
			IN OUT MQPROPVARIANT * pvar
			)
{
	struct lcversion
	{
		unsigned short buildNumber;
		unsigned char minor;
		unsigned char major;
	};

	lcversion * plcversion = (lcversion *)&pvar->ulVal;
	plcversion->major = MSMQ_RMJ;
	plcversion->minor = MSMQ_RMM;
	plcversion->buildNumber = rup;
	pvar->vt = VT_UI4;
}

//---------------------------------------------------------
//
//  FillPrivateComputerDsEnabled(...)
//
//  Description:
//
//      Retrieve private computer DS enabled state
//
//  Return Value:
//
//      none
//
//---------------------------------------------------------
static void  FillPrivateComputerDsEnabled(
			IN OUT MQPROPVARIANT * pvar
			)
{
	pvar->boolVal = (IsWorkGroupMode()) ? VARIANT_FALSE : VARIANT_TRUE;
	pvar->vt = VT_BOOL;
}

//---------------------------------------------------------
//
//  MQGetPrivateComputerInformation(...)
//
//  Description:
//
//      Falcon API.
//      Retrieve local computer properties (i.e. calculated properties
//      not ones that are kept in the DS).
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------
EXTERN_C
HRESULT
APIENTRY
MQGetPrivateComputerInformation(
    IN LPCWSTR			lpwcsComputerName,
    IN OUT MQPRIVATEPROPS* pPrivateProps
)
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepGetPrivateComputerInformation(
					lpwcsComputerName, 
					pPrivateProps
					);

    CMQHResult rc(MQDS_MACHINE);

	//
	//	For the time being 	lpwcsComputerName must be NULL
	//
	if ( lpwcsComputerName != NULL)
	{
		return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 110);
	}

    HRESULT* aLocalStatus_buff = NULL;

    __try
    {
		__try
		{
            //
            // We must have a status array, even if the user didn't pass one. This is in
            // order to be able to tell whether each propery is good or not.
            //
            HRESULT * aLocalStatus;

            if (pPrivateProps->aStatus == NULL)
            {
                aLocalStatus_buff = new HRESULT[pPrivateProps->cProp];
                aLocalStatus = aLocalStatus_buff;
            }
            else
            {
                aLocalStatus = pPrivateProps->aStatus;
            }
            //
            //  validate props and variants
            //
			rc = RTpCheckComputerProps(
				pPrivateProps,
				aLocalStatus
				);
			if (FAILED(rc))
			{
				return LogHR(rc, s_FN, 120);
			}

			for ( DWORD i = 0; i < pPrivateProps->cProp; i++)
			{
				if ( aLocalStatus[i] != MQ_OK)
				{
					//
					//	don't fill in response for unsupported properties, or
					//  properties that are duplicate etc.
					//
					continue;
				}
				switch ( pPrivateProps->aPropID[i])
				{
				case PROPID_PC_VERSION:
					FillPrivateComputerVersion( &pPrivateProps->aPropVar[i]);
					break;
				case PROPID_PC_DS_ENABLED:
					FillPrivateComputerDsEnabled(&pPrivateProps->aPropVar[i]);
					break;
				default:
					ASSERT(0);
					return LogHR(MQ_ERROR_PROPERTY, s_FN, 130);
					break;
				}
			}

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 140); 
        }
    }
    __finally
    {
        delete[] aLocalStatus_buff;
    }
    return LogHR(rc, s_FN, 150);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\replserv\replctrl\threads.h ===
#if !defined(AFX_THREADS_H__9DABC4B1_1585_11D2_B971_0060081E87F0__INCLUDED_)
#define AFX_THREADS_H__9DABC4B1_1585_11D2_B971_0060081E87F0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Threads.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CThreads dialog

class CThreads : public CPropertyPage
{
	DECLARE_DYNCREATE(CThreads)

// Construction
public:
	CThreads();
	~CThreads();

// Dialog Data
	//{{AFX_DATA(CThreads)
	enum { IDD = IDD_THREADS };
	UINT	m_cThreads;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CThreads)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CThreads)
	afx_msg void OnChangeEdtNumThreads();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_THREADS_H__9DABC4B1_1585_11D2_B971_0060081E87F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\mc.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    event.cpp

Abstract:
    Simulate Machine configuration

Author:
    Uri Habusha (urih) 04-May-99

Environment:
    Platform-independent,

--*/

#include <stdh.h>
#include <mqmacro.h>
#include <rtp.h>

#include "mc.tmh"

LPCWSTR
McComputerName(
	VOID
	)
/*++

Routine Description:
    Returns the computer name

Arguments:
    None.

Returned Value:
    A pointer to the computer name string buffer.

--*/
{
	return g_lpwcsComputerName;
}



DWORD
McComputerNameLen(
	VOID
	)
{
	return g_dwComputerNameLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\cursor.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    cursor.cpp

Abstract:

    This module contains code involved with Cursor APIs.

Author:

    Erez Haba (erezh) 21-Jan-96
    Doron Juster  16-apr-1996, added MQFreeMemory.
    Doron Juster  30-apr-1996, added support for remote reading.

Revision History:

--*/

#include "stdh.h"
#include "ac.h"
#include "rtprpc.h"
#include "acdef.h"
#include <rtdep.h>
#include <Fn.h>

#include "cursor.tmh"

static WCHAR *s_FN=L"rt/cursor";

inline
HRESULT
MQpExceptionTranslator(
    HRESULT rc
    )
{
    if(FAILED(rc))
    {
        return rc;
    }

    if(rc == ERROR_INVALID_HANDLE)
    {
        return STATUS_INVALID_HANDLE;
    }

    return  MQ_ERROR_SERVICE_NOT_AVAILABLE;
}


EXTERN_C
HRESULT
APIENTRY
MQCreateCursor(
    IN QUEUEHANDLE hQueue,
    OUT PHANDLE phCursor
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepCreateCursor(
					hQueue, 
					phCursor
					);

    CMQHResult rc;
	LPWSTR MachineName = NULL;
    LPTSTR lpRemoteQueueName = NULL;
    HACCursor32 hCursor = 0;
    CCursorInfo* pCursorInfo = 0;

    rc = MQ_OK;

    __try
    {
        __try
        {
            __try
            {
                pCursorInfo = new CCursorInfo;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 40);
            }

            pCursorInfo->hQueue = hQueue;

            //
            //  Call AC driver
            //
            CACCreateLocalCursor cc;
            rc = ACCreateCursor(hQueue, cc);

            //
            //  save local cursor handle for cleanup
            //
            hCursor = cc.hCursor;

            if(rc == MQ_INFORMATION_REMOTE_OPERATION)
            {
                //
                //  For remote operation 'cc' fields are:
                //      srv_hACQueue - holds the remote queue handle
                //      cli_pQMQueue - holds the local QM queue object
                //
                // create a cursor on remote QM.
                ASSERT(cc.srv_hACQueue);
                ASSERT(cc.cli_pQMQueue);

                // Get name of remote queue from local QM.
                rc = QMGetRemoteQueueName(
                        tls_hBindRpc,
                        cc.cli_pQMQueue,
                        &lpRemoteQueueName
                        );

                if(SUCCEEDED(rc) && lpRemoteQueueName)
                {
					//
					// ISSUE-2000/9/03-niraides QM Should return remote Machine name, not remote queue name.
					// lpRemoteQueueName above has a varying format which is of no 
					// interest to the Runtime. 
					//
					RTpRemoteQueueNameToMachineName(lpRemoteQueueName, &MachineName);

                    //
                    // OK, we have a remote name. Now bind to remote machine
                    // and ask it to create a cursor.
                    //
                    DWORD hRCursor = 0;

                    //
                    // Pass the old TransferBuffer to Create Remote Cursor
                    // for MSMQ 1.0 compatibility.
                    //
                    CACTransferBufferV1 tb;
                    ZeroMemory(&tb, sizeof(tb));
                    tb.uTransferType = CACTB_CREATECURSOR;

                    rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;

                    CALL_REMOTE_QM(MachineName, rc,(
                        QMCreateRemoteCursor(
                            hBind,
                            &tb,
                            cc.srv_hACQueue,
                            &hRCursor
                            )
                        ));

                    if(SUCCEEDED(rc))
                    {
                        // set remote cursor handle to local cursor
                        rc = ACSetCursorProperties(hQueue, hCursor, hRCursor);
                        ASSERT(SUCCEEDED(rc));
                    }
                }
            }

            if(SUCCEEDED(rc))
            {
                pCursorInfo->hCursor = hCursor;
                *phCursor = pCursorInfo;
                pCursorInfo = 0;
            }
        }
        __finally
        {
            delete pCursorInfo;
            delete[] lpRemoteQueueName ;
            delete[] MachineName ;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc =  MQpExceptionTranslator(GetExceptionCode());
    }

    if(FAILED(rc) && (hCursor != 0))
    {
        ACCloseCursor(hQueue, hCursor);
    }

    return LogHR(rc, s_FN, 50);
}

EXTERN_C
HRESULT
APIENTRY
MQCloseCursor(
    IN HANDLE hCursor
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepCloseCursor(hCursor);

    CMQHResult rc;
    __try
    {
        rc = ACCloseCursor(
                CI2QH(hCursor),
                CI2CH(hCursor)
                );

        if(SUCCEEDED(rc))
        {
            //
            //  delete the cursor info only when everything is OK. we do not
            //  want to currupt user heap.
            //
            delete hCursor;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        //  The cursor structure is invalid
        //
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 60);
    }

    return LogHR(rc, s_FN, 70);
}


EXTERN_C
void
APIENTRY
MQFreeMemory(
    IN  PVOID pvMemory
    )
{
	if(FAILED(RtpOneTimeThreadInit()))
		return;

	if(g_fDependentClient)
		return DepFreeMemory(pvMemory);

	delete[] pvMemory;
}


EXTERN_C
PVOID
APIENTRY
MQAllocateMemory(
    IN  DWORD size
    )
{
	PVOID ptr = reinterpret_cast<PVOID>(new BYTE[size]);
	return ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\qmmgmt_c_.c ===
#pragma warning(push, 3)
#include <qmmgmt_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\message.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    message.cpp

Abstract:

    This module contains code involved with Message APIs.

Author:

    Erez Haba (erezh) 24-Dec-95

Revision History:

--*/

#include "stdh.h"
#include "ac.h"
#include <_secutil.h>
#include "mqutil.h"
#include <mqcrypt.h>
#include "rtsecutl.h"
#include "acdef.h"
#include "rtprpc.h"
#include "objbase.h"
#define _MTX_NOFORCE_LIBS
#include "comsvcs.h"
#include "TXDTC.H"
#include "xactmq.h"
#include <mqsec.h>
#include <ph.h>
#include <rtdep.h>
#include <SignMqf.h>
#include <autohandle.h>
#include "cry.h"
#include "SignMessageXml.h"
#include "mqformat.h"
#include "mqfutils.h"
#include "authlevel.h"

#include "message.tmh"

extern GUID  g_LicGuid;

static WCHAR *s_FN=L"rt/message";

//
// the following data is used in the async thread which handles async
// MQReceive(). The async thread is created the first time an async
// receive is performed.
//

#define RXTHREAD_HANDLELISTSIZE  MAXIMUM_WAIT_OBJECTS
// At present (Win32 SDK for Nt3.51) it's 64

static BOOL   s_fTerminate       = FALSE;
static HANDLE s_hAsyncRxThread   = NULL;
static DWORD  s_dwRxThreadId     = 0;
static HANDLE *s_pRxEventsHList  = NULL;
static DWORD  s_cRxHandles       = 0;
static LONG   s_cRxPendingReq    = 0;
static HANDLE s_hNewAsyncRx      = NULL;
static HANDLE s_hEndAsyncRx      = NULL;

//
// Critical Section used to control access to structures used by the
// async thread.
// It is initialized with the "pre-allocate resource" flag to prevent it
// from failing in EnterCriticalSection(), as one of these invocations
// occurs in a place where it cannot be handled correctly.
//
static CCriticalSection s_AsyncRxCS(CCriticalSection::xAllocateSpinCount);

//
// Critical section used to control initialization of the async thread, on
// the first MQReceiveMessage() done with a callback function.
//
static CCriticalSection s_InitAsyncRxCS;

typedef struct _MQRXASYNCDESCRIPTOR {
    QUEUEHANDLE   hSource;
    DWORD         dwTimeout;
    DWORD         dwAction;
    MQMSGPROPS*   pMessageProps;
    LPOVERLAPPED  lpOverlapped;
    HANDLE        hCursor;
    PMQRECEIVECALLBACK fnReceiveCallback;
    OVERLAPPED    Overlapped;
} MQRXASYNCDESCRIPTOR, *LPMQRXASYNCDESCRIPTOR;

static LPMQRXASYNCDESCRIPTOR  *s_lpRxAsynDescList = NULL;

//
// Serializes calls to DTC
//
extern HANDLE g_hMutexDTC;

extern HRESULT GetMutex();


static
bool
NeedToSignMqf(
	IN LPCWSTR pwszTargetFormatName
	)
/*++
Routine Description:
	Check if we need to sign with Mqf signature.
	check if Target Queue is MQF or DL.

Arguments:
	pwszTargetFormatName - Target queue FormatName

Returned Value:
	true if we must sign with MQF signature, false if not

--*/
{
	//
	// Check Target Queue FormatName
	//
	AP<QUEUE_FORMAT> pMqf;
	DWORD nMqf;
	CStringsToFree StringsToFree;
	if (!FnMqfToQueueFormats(
			pwszTargetFormatName,
			pMqf,
			&nMqf,
			StringsToFree
			))
	{
		ASSERT(("FnMqfToQueueFormats failed, we should catch this earlier", 0));
		return false;
	}

	ASSERT(nMqf > 0);

	return MQpNeedDestinationMqfHeader(pMqf, nMqf);
}


static
bool
CanSignMqf(
	IN LPCWSTR pwszTargetFormatName,
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Check if we need to sign with Mqf signature.
	Check if Response or Admin queues are MQF
	or if Target Queue is MQF or DL.

Arguments:
	pwszTargetFormatName - Target queue FormatName
    pSendParams - pointer to send params.

Returned Value:
	true if we need to sign with MQF signature, false if not

--*/
{
	//
	// Check Target Queue FormatName
	//
	AP<QUEUE_FORMAT> pMqf;
	DWORD nMqf;
	CStringsToFree StringsToFree;
	if (!FnMqfToQueueFormats(
			pwszTargetFormatName,
			pMqf,
			&nMqf,
			StringsToFree
			))
	{
		ASSERT(("FnMqfToQueueFormats failed, we should catch this earlier", 0));
		return false;
	}

	ASSERT(nMqf > 0);

	return MQpNeedMqfHeaders(pMqf, nMqf, pSendParams);
}


//---------------------------------------------------------
//
// static DWORD   RTpAsyncRxThread( DWORD dwP )
//
//  Description:
//
//    Thread which handles the async calls to MQReceive().
//
//---------------------------------------------------------

DWORD __stdcall  RTpAsyncRxThread( void *dwP )
{
	for(;;)
	{
		DWORD cEvents = s_cRxHandles;

		DWORD dwObjectIndex = WaitForMultipleObjects(
								cEvents,
								s_pRxEventsHList,
								FALSE, // return on any object
								INFINITE
								);

		ASSERT(dwObjectIndex < (WAIT_OBJECT_0 + cEvents));

		dwObjectIndex -= WAIT_OBJECT_0;

		if (dwObjectIndex == 0)
		{
			//
			// dwObjectIndex == 0:
			// The first event in the s_pRxEventsHList[] array is a special
			// event, signaled by an MQReceiveMessage() thread to indicate
			// that the array has been altered (grown), and we need to intiate
			// a new WaitForMultipleObjects(), or by TerminateRxAsyncThread()
			// to indicate it is time to go down.
			//

			ResetEvent(s_hNewAsyncRx);
			if (s_fTerminate)
			{
				// We're closing.
				// CAUTION: don't do any cleanup here. The cleanup is done in
				// "TerminateRxAsyncThread()". I don't know a reliable way
				// to assure that we even reach this point. It all depends on
				// NT scheduling and on whether this dll is implicitly loaded
				// (because of compile-time linking) or is explicitly loaded by
				// LoadLibrary().
				// On the contrary, NT assure us that "TerminateRxAsyncThread()"
				// will always be called from DllMain(PROCESS_DETACH).
				// DoronJ, 16-apr-1996.

				ASSERT(s_hEndAsyncRx);
				BOOL fSet = SetEvent(s_hEndAsyncRx);
				ASSERT(fSet);
				DBG_USED(fSet);

				ExitThread(0);
			}

			//
			// new event in array. intiate a new WaitForMultipleObjects().
			//
			continue;
		}

		LPMQRXASYNCDESCRIPTOR lpDesc = s_lpRxAsynDescList[ dwObjectIndex ];
		ASSERT(lpDesc);
		ASSERT(s_pRxEventsHList[ dwObjectIndex ] == lpDesc->Overlapped.hEvent);

		CMQHResult hr;
		hr = (HRESULT)DWORD_PTR_TO_DWORD(lpDesc->Overlapped.Internal);

		//
		// Call the application callback.
		//
		lpDesc->fnReceiveCallback(
			hr,
			lpDesc->hSource,
			lpDesc->dwTimeout,
			lpDesc->dwAction,
			lpDesc->pMessageProps,
			lpDesc->lpOverlapped,
			lpDesc->hCursor
			);

		//
		// Remove Handled event from s_pRxEventsHList[] array.
		//

		ResetEvent( s_pRxEventsHList[ dwObjectIndex ] );
		CloseHandle( s_pRxEventsHList[ dwObjectIndex ] );
		delete lpDesc;

		{
			CS Lock(s_AsyncRxCS);

			//
			// Shrink the handles list and decrement count of pending requests.
			//
			s_cRxHandles--;
			InterlockedDecrement(&s_cRxPendingReq);

			ASSERT(static_cast<DWORD>(s_cRxPendingReq) >= s_cRxHandles);			

			for (DWORD index = dwObjectIndex; index < s_cRxHandles; index++)
			{
				s_pRxEventsHList[ index ] = s_pRxEventsHList[ index + 1 ];
				s_lpRxAsynDescList[ index ] = s_lpRxAsynDescList[ index + 1 ];
			}
		}
	}

	dwP;
	return 0;
}


//---------------------------------------------------------
//
//  static HRESULT InitRxAsyncThread()
//
//  Description:
//
//    Create the MQReceive() async thread and initialize the
//    relevant data structures.
//
//---------------------------------------------------------

static HRESULT InitRxAsyncThread()
{
    try
    {
        // Create the sync event between this api and the thread.
        // This api sets this event when it inserts a new event in
        // the events handles list. This causes the thread to exit
        // WaitForMultpleObjects and call it again with the updated
        // handles list.

        ASSERT(!s_hNewAsyncRx);
        s_hNewAsyncRx = CreateEvent( NULL,
                                     TRUE,  // manual reset
                                     FALSE, // initially not signalled
                                     NULL );
        if (!s_hNewAsyncRx)
        {
            throw bad_alloc();
        }

        //
        // Create the "end" event which is used ONLY to terminate and
        // cleanup the thread.
        //
        ASSERT(!s_hEndAsyncRx);
        s_hEndAsyncRx = CreateEvent(NULL,
                                    TRUE,  // manual reset
                                    FALSE, // initially not signalled
                                    NULL );
        if (!s_hEndAsyncRx)
        {
            throw bad_alloc();
        }

        // Create the events list. MQReceive() inserts new events handle
        // in this list. The async thread use this list when calling
        // WaitForMultipleObjects.

        s_pRxEventsHList = new HANDLE[ RXTHREAD_HANDLELISTSIZE ];
        s_pRxEventsHList[0] = s_hNewAsyncRx;
        s_cRxHandles = 1;
        s_cRxPendingReq = 1;

        s_lpRxAsynDescList = new LPMQRXASYNCDESCRIPTOR[RXTHREAD_HANDLELISTSIZE];

        // Now create the thread. Make this call the last one in the
        // initialization, so if it fails the cleanup is simpler.

        s_hAsyncRxThread = CreateThread( NULL,
                                         0,       // stack size
                                         RTpAsyncRxThread,
                                         0,
                                         0,       // creation flag
                                         &s_dwRxThreadId );
        if (!s_hAsyncRxThread)
        {
            throw bad_alloc();
        }

        return MQ_OK;
    }
    catch(const bad_alloc&)
    {
        ASSERT(!s_hAsyncRxThread);

        if (s_hNewAsyncRx)
        {
            CloseHandle(s_hNewAsyncRx);
            s_hNewAsyncRx = NULL;
        }

        delete[] s_pRxEventsHList;
        s_pRxEventsHList = NULL;

        delete s_lpRxAsynDescList;
        s_lpRxAsynDescList = NULL;

        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 10);
    }
}

//---------------------------------------------------------
//
//  void  TerminateRxAsyncThread();
//
//  called from DllMain(PROCESS_DETACH) to cleanup the async thread.
//
//---------------------------------------------------------

#define SUSPEND_ERROR  0xffffffff

void  TerminateRxAsyncThread()
{
   if (s_hAsyncRxThread)
   {
      s_fTerminate = TRUE;

      SetLastError(0);
      DWORD dwS = SuspendThread(s_hAsyncRxThread);
      if (dwS == SUSPEND_ERROR)
      {
         //
         // This may happen if application is linked with mqrt. when it
         // exit (the process itself exit), the thread does not run and
         // does not exist anymore. The Suspend call will success if
         // application loaded mqrt by LoadLibrary.
         //
         ASSERT(GetLastError() != 0);
      }
      else
      {
         DWORD dwR = ResumeThread(s_hAsyncRxThread);
         ASSERT(dwR != SUSPEND_ERROR);
		 DBG_USED(dwR);
      }

      //
      // Tell the async thread that we're closing.
      //
      BOOL fSet = SetEvent(s_hNewAsyncRx);
      ASSERT(fSet);
      DBG_USED(fSet);

      if (dwS != SUSPEND_ERROR)
      {
         //
         //  Wait (30 seconds) for async thread to terminate.
         //
         ASSERT(s_hEndAsyncRx);
         DWORD dwResult = WaitForSingleObject( s_hEndAsyncRx,
                                               30000 );
         ASSERT(dwResult == WAIT_OBJECT_0);
		 DBG_USED(dwResult);
      }

      //
      // cleanup the async thread global data.
      //
	  {
		  CS Lock(s_AsyncRxCS);

		  CloseHandle(s_hNewAsyncRx);
		
		  for (DWORD index = 1; index < s_cRxHandles; index++)
		  {
			 ResetEvent( s_pRxEventsHList[ index ] );
			 CloseHandle( s_pRxEventsHList[ index ] );
			 LPMQRXASYNCDESCRIPTOR lpDesc = s_lpRxAsynDescList[ index ];
			 delete lpDesc;
		  }

		  delete[] s_pRxEventsHList;
		  s_pRxEventsHList = NULL;
		  delete[] s_lpRxAsynDescList;
		  s_lpRxAsynDescList = NULL;
	  }

      //
      // finally, close the thread handle.
      //
      CloseHandle(s_hAsyncRxThread);
   }
}

//---------------------------------------------------------
//
//  GetThreadEvent(...)
//
//  Description:
//
//      Get RT event for this thread. Get it either from
//      The TLS or create a new one.
//
//  Return Value:
//
//      The event handle
//
//---------------------------------------------------------

HANDLE GetThreadEvent()
{
    HANDLE hEvent = TlsGetValue(g_dwThreadEventIndex);
    if (hEvent == 0)
    {
        //
        //  Event was never allocated for this thread.
        //
        hEvent = CreateEvent(0, TRUE, TRUE, 0);

        //
        //  Set the Event first bit to disable completion port posting
        //
        hEvent = (HANDLE)((DWORD_PTR)hEvent | (DWORD_PTR)0x1);

        BOOL fSuccess = TlsSetValue(g_dwThreadEventIndex, hEvent);
        ASSERT(fSuccess);
		DBG_USED(fSuccess);
    }
    return hEvent;
}


static
HRESULT
CalcSignutureTypes(
    IN OUT CACSendParameters *pSendParams,
    OUT ULONG*				pulAuthLevel,
	IN LPCWSTR				pwszTargetFormatName,
	IN const CACGetQueueHandleProperties& qhp
	)
/*++

Routine Description:
	
	Decide which signature types(versions) should be sign.

Arguments:
    pSendParams - pointer to send params.
  	pulAuthLevel - authentication level
	pwszTargetFormatName - targert format name
	qhp - queue handle properties, this have the information which protocols are in use

Returned Value:
    MQ_OK, if successful, else error code.

--*/
{
	ASSERT(pSendParams->MsgProps.ulAuthLevel != MQMSG_AUTH_LEVEL_NONE);
	ASSERT(qhp.fProtocolSrmp || qhp.fProtocolMsmq);

	ULONG ulAuthLevelSrmp = MQMSG_AUTH_LEVEL_NONE;
	if(qhp.fProtocolSrmp)
	{
		//
		// for Srmp protocol authentication we currently have only one type
		//
		ulAuthLevelSrmp = MQMSG_AUTH_LEVEL_XMLDSIG_V1;
		DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: SignutureTypes(), ProtocolSrmp signature MQMSG_AUTH_LEVEL_XMLDSIG_V1")));
	}

	ULONG ulAuthLevelMsmq = MQMSG_AUTH_LEVEL_NONE;

	if(qhp.fProtocolMsmq)
	{
		ulAuthLevelMsmq = pSendParams->MsgProps.ulAuthLevel;

		if(pSendParams->MsgProps.ulAuthLevel == MQMSG_AUTH_LEVEL_ALWAYS)
		{
			//
			// See if registry is configured to compute only one signature.
			//
			static DWORD s_dwAuthnLevel =  DEFAULT_SEND_MSG_AUTHN;
			static BOOL  s_fAuthnAlreadyRead = FALSE;

			if (!s_fAuthnAlreadyRead)
			{
				DWORD dwSize = sizeof(DWORD);
				DWORD dwType = REG_DWORD;

				LONG res = GetFalconKeyValue(
									  SEND_MSG_AUTHN_REGNAME,
									 &dwType,
									 &s_dwAuthnLevel,
									 &dwSize
									 );

				if (res != ERROR_SUCCESS)
				{
					s_dwAuthnLevel =  DEFAULT_SEND_MSG_AUTHN;
					DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: SignutureTypes(), registry key not exist using default = %d"), DEFAULT_SEND_MSG_AUTHN));
				}
				else if (!IS_VALID_AUTH_LEVEL(s_dwAuthnLevel))
				{
					//
					// Allow only AUTH_LEVEL_MASK bits to be set
					// Wrong value in registry. Use the default, to have
					// predictable results.
					//
					DBGMSG((DBGMOD_SECURITY, DBGLVL_WARNING, _TEXT("RT: SignutureTypes(), Wrong registry value %d (invalid bits), using default = %d"), s_dwAuthnLevel, DEFAULT_SEND_MSG_AUTHN));
					s_dwAuthnLevel = DEFAULT_SEND_MSG_AUTHN;
				}
				else if (IS_AUTH_LEVEL_ALWAYS_BIT(s_dwAuthnLevel) && (s_dwAuthnLevel != MQMSG_AUTH_LEVEL_ALWAYS))
				{
					//
					// MQMSG_AUTH_LEVEL_ALWAYS bit can not be set with other bits
					// Wrong value in registry. Use the default, to have
					// predictable results.
					//
					DBGMSG((DBGMOD_SECURITY, DBGLVL_WARNING, _TEXT("RT: SignutureTypes(), Wrong registry value %d (ALWAYS bit set with other bits), using default = %d"), s_dwAuthnLevel, DEFAULT_SEND_MSG_AUTHN));
					s_dwAuthnLevel = DEFAULT_SEND_MSG_AUTHN;
				}

				s_fAuthnAlreadyRead = TRUE;

				//
				// This should be the default.
				// by default, authenticate only with old style, to prevent
				// performance hit and to be backward  compatible.
				//
				ASSERT(DEFAULT_SEND_MSG_AUTHN == MQMSG_AUTH_LEVEL_SIG10);
			}
			ulAuthLevelMsmq = s_dwAuthnLevel;
			DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: SignutureTypes(), MQMSG_AUTH_LEVEL_ALWAYS(read registry): ulAuthLevelMsmq = %d"), ulAuthLevelMsmq));
		}

		if(ulAuthLevelMsmq == MQMSG_AUTH_LEVEL_ALWAYS)
		{
			//
			// We were asked to compute all possible signatures.
			// Replace the MQMSG_AUTH_LEVEL_ALWAYS with value that set all the signature bits
			//
			ulAuthLevelMsmq = (MQMSG_AUTH_LEVEL_SIG10 | MQMSG_AUTH_LEVEL_SIG20 | MQMSG_AUTH_LEVEL_SIG30);
		}

		if(IS_AUTH_LEVEL_SIG20_BIT(ulAuthLevelMsmq))
		{
			//
			// The user ask to compute MSMQ20 signature
			// Check if we can sign MSMQ20 signature
			//
			if(NeedToSignMqf(pwszTargetFormatName))
			{
				//
				// ISSUE-2000/11/05-ilanhh should we return error if registry is configured to MQMSG_AUTH_LEVEL_SIG20 ?
				// or just if user application asked for MQMSG_AUTH_LEVEL_SIG20
				// pSendParams->MsgProps.ulAuthLevel is the user application input
				// ulAuthLevel is also the registry setting in case MQMSG_AUTH_LEVEL_ALWAYS
				//
				if(ulAuthLevelMsmq == MQMSG_AUTH_LEVEL_SIG20)		
				{
					//
					// User ask specifically for MSMQ20 signature
					//
					DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT("RT: SignutureTypes(), user (or registry) ask specifically for MSMQ20 signature, but DestinationQueue is Mqf or DL")));
					return MQ_ERROR_CANNOT_SIGN_DATA_EX;
				}

				//
				// MSMQ20 will failes, remove MQMSG_AUTH_LEVEL_SIG20 bit
				//
				CLEAR_AUTH_LEVEL_SIG20_BIT(ulAuthLevelMsmq);

				//
				// Turn on MQMSG_AUTH_LEVEL_SIG10, MQMSG_AUTH_LEVEL_SIG30 signature bits
				//
				SET_AUTH_LEVEL_SIG10_BIT(ulAuthLevelMsmq);
				SET_AUTH_LEVEL_SIG30_BIT(ulAuthLevelMsmq);

				DBGMSG((DBGMOD_SECURITY, DBGLVL_WARNING, _TEXT("RT: SignutureTypes(), DestinationQueue is Mqf or DL, Replace MSMQ20 signature with MSMQ10 and MSMQ30 signatures")));
			}

			//
			// ISSUE-2000/11/05-ilanhh we don't convert MQMSG_AUTH_LEVEL_SIG20 to MQMSG_AUTH_LEVEL_SIG30
			// if we NeedMqfSignature but not MustMqfSignature (Admin, Response queues)
			// in that case the user should ask for MQMSG_AUTH_LEVEL_SIG30 if he wants it.
			//
		}

		if(IS_AUTH_LEVEL_SIG30_BIT(ulAuthLevelMsmq))
		{
			//
			// We will not prepare MSMQ30 signature if we don't have MQF headers
			// BUGBUG: need to support this. ilanh 05-Nov-2000
			//
			if(!CanSignMqf(pwszTargetFormatName, pSendParams))
			{
				//
				// Mqf headers will not be include in the packet
				// Remove MQMSG_AUTH_LEVEL_SIG30 bit
				// and replace it with MQMSG_AUTH_LEVEL_SIG20 signature
				// which in this case is almost the same
				//
				CLEAR_AUTH_LEVEL_SIG30_BIT(ulAuthLevelMsmq);
				SET_AUTH_LEVEL_SIG20_BIT(ulAuthLevelMsmq);

				DBGMSG((DBGMOD_SECURITY, DBGLVL_WARNING, _TEXT("RT: SignutureTypes(), We dont have any MQF headers, Replace MSMQ30 signature with MSMQ20 signatures")));
			}
		}
	}

	ULONG ulAuthLevel = ulAuthLevelMsmq | ulAuthLevelSrmp;
	pSendParams->MsgProps.ulAuthLevel = ulAuthLevel;
	*pulAuthLevel = ulAuthLevel;
	return MQ_OK;
}


static
bool
ShouldSignMessage(
    IN CACMessageProperties* pMsgProps
	)
/*++

Routine Description:
	
	Check if we should sign the message.

Arguments:
    pMsgProps - pointer to message properties.

Returned Value:
    true if the message should be signed, false if not.

--*/
{
	if(pMsgProps->ulAuthLevel == MQMSG_AUTH_LEVEL_NONE)
	{
		DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: ShouldSignMessage() = false")));
		return false;
	}

	ASSERT(IS_VALID_AUTH_LEVEL(pMsgProps->ulAuthLevel));

	DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: ShouldSignMessage() = true")));
	return true;

}


//+-------------------------------------
//
//  HRESULT  _BeginToSignMessage()
//
//+-------------------------------------

static
HRESULT
_BeginToSignMessage(
	IN CACMessageProperties * pMsgProps,
	IN PMQSECURITY_CONTEXT    pSecCtx,
	OUT HCRYPTHASH          * phHash
	)
{
    HRESULT hr;
    DWORD   dwErr;

    ASSERT(pSecCtx);

    if (!pSecCtx->hProv)
    {
        //
        // Import the private key into process hive.
        //
        hr = RTpImportPrivateKey(pSecCtx);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 20);
        }
    }
    ASSERT(pSecCtx->hProv);

    //
    // Create the hash object.
    //
    if (!CryptCreateHash(
            pSecCtx->hProv,
            *pMsgProps->pulHashAlg,
            0,
            0,
            phHash
			))
    {
        dwErr = GetLastError();
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "RT: _BeginToSignMessage(), fail at CryptCreateHash(), err- %lxh"), dwErr));

        LogNTStatus(dwErr, s_FN, 29);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 30);
    }

    return MQ_OK;
}

//-------------------------------------------------------------------------
//
//  HRESULT SignMessage()
//
//  Description:
//
//      Signs the messag body. compute the hash, and sign it with private
//      key. This add a signature section to the packet
//
//  Return Value:
//
//      MQ_OK, if successful, else error code.
//
//-------------------------------------------------------------------------

static
HRESULT
SignMessage(
	IN CACSendParameters * pSendParams,
	IN PMQSECURITY_CONTEXT pSecCtx
	)
{
    HCRYPTHASH  hHash = NULL;

    CACMessageProperties * pMsgProps = &pSendParams->MsgProps;

    HRESULT hr =  _BeginToSignMessage(
						pMsgProps,
						pSecCtx,
						&hHash
						);
    if (FAILED(hr))
    {
        return hr;
    }
    CHCryptHash hAutoRelHash = hHash;

	//
	// Prepare old QueueFormat response and admin queues
	//
    QUEUE_FORMAT   ResponseQueueFormat;
    QUEUE_FORMAT * pResponseQueueFormat = &ResponseQueueFormat;
    MQpMqf2SingleQ(pSendParams->nResponseMqf, pSendParams->ResponseMqf, &pResponseQueueFormat);

    QUEUE_FORMAT   AdminQueueFormat;
    QUEUE_FORMAT * pAdminQueueFormat = &AdminQueueFormat;
    MQpMqf2SingleQ(pSendParams->nAdminMqf, pSendParams->AdminMqf, &pAdminQueueFormat);

	hr = HashMessageProperties( // Compute the hash value for the mesage body.
            hHash,
            pMsgProps->ppCorrelationID ? *pMsgProps->ppCorrelationID : NULL,
            PROPID_M_CORRELATIONID_SIZE,
            pMsgProps->pApplicationTag ? *pMsgProps->pApplicationTag : DEFAULT_M_APPSPECIFIC,
            pMsgProps->ppBody ? *pMsgProps->ppBody : NULL,
            pMsgProps->ulBodyBufferSizeInBytes,
            pMsgProps->ppTitle ? *pMsgProps->ppTitle : NULL,
            pMsgProps->ulTitleBufferSizeInWCHARs * sizeof(WCHAR),
            pResponseQueueFormat,
            pAdminQueueFormat
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 40);
    }

    if (!CryptSignHashA(        // Sign the mesage.
            hHash,
			pSecCtx->dwPrivateKeySpec,
            NULL,
            0,
            *(pMsgProps->ppSignature),
            &pMsgProps->ulSignatureSize
			))
    {
        DWORD dwErr = GetLastError();
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "RT: SignMessage(), fail at CryptSignHash(), err- %lxh"), dwErr));

        LogNTStatus(dwErr, s_FN, 49);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 50);
    }

    //
    // On receiver side, only signature size indicate that message was
    // signed by sender. Verify the size is indeed non-zero
    //
    if (pMsgProps->ulSignatureSize == 0)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "RT: SignMessage(), CryptSignHash return with zero signature size")));

        ASSERT(pMsgProps->ulSignatureSize != 0);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 60);
    }

	DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: SignMessage() MSMQ10 signature complete ok")));
    return(MQ_OK);
}

//---------------------------------------------------------
//
//  _SignMessageEx
//
//  Description:
//
//    Signs properties that were not signed in msmq1.0
//    Properties we sign here:
//    - target queue
//    - source qm guid
//
//  Return Value:
//
//      MQ_OK, if successful, else error code.
//
//---------------------------------------------------------

STATIC
HRESULT
_SignMessageEx(
	IN LPCWSTR				  pwszTargetFormatName,
	IN OUT CACSendParameters  *pSendParams,
	IN PMQSECURITY_CONTEXT     pSecCtx,
	OUT BYTE                  *pSignBufIn,
	OUT DWORD                 *pdwSignSize
	)
{
	//
    // Prepare the necessray structers to be included in packet.
    //
    struct _SecuritySectionEx *pSecEx = (struct _SecuritySectionEx *) pSignBufIn;
    struct _SecuritySubSectionEx *pSubSecEx = (struct _SecuritySubSectionEx *) (&(pSecEx->aData[0]));

    ULONG  ulTestLen = 0;
    USHORT ulTestSections = 0;

#ifdef _DEBUG
{
    //
    // Simulate subsection that precede the signature. To verify that
    // present code is forward compatible if we'll want to add new
    // subsections in future releases.
    //
	BYTE* pSubPtr = NULL;
    static DWORD s_dwPrefixCount = 0;
    static BOOL  s_fPreAlreadyRead = FALSE;

    if (!s_fPreAlreadyRead)
    {
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType = REG_DWORD;

        LONG res = GetFalconKeyValue(
					   PREFIX_SUB_SECTIONS_REGNAME,
					   &dwType,
					   &s_dwPrefixCount,
					   &dwSize
					   );

        if (res != ERROR_SUCCESS)
        {
            s_dwPrefixCount = 0;
        }
        s_fPreAlreadyRead = TRUE;
    }

    for ( USHORT j = 0 ; j < (USHORT) s_dwPrefixCount ; j++ )
    {
        ulTestSections++;
        pSubSecEx->eType = e_SecInfo_Test;
        pSubSecEx->_u.wFlags = 0;
        pSubSecEx->wSubSectionLen = (USHORT) ( (j * 7) + 1 +
                                    sizeof(struct _SecuritySubSectionEx));

        ulTestLen += ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen);
        pSubPtr = ((BYTE*) pSubSecEx) + ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen);
        pSubSecEx = (struct _SecuritySubSectionEx *) pSubPtr;
    }
}
#endif

    pSubSecEx->eType = e_SecInfo_User_Signature_ex;
    pSubSecEx->_u.wFlags = 0;
    pSubSecEx->_u._UserSigEx.m_bfTargetQueue = 1;
    pSubSecEx->_u._UserSigEx.m_bfSourceQMGuid = 1;
    pSubSecEx->_u._UserSigEx.m_bfUserFlags = 1;
    pSubSecEx->_u._UserSigEx.m_bfConnectorType = 1;

    BYTE *pSignBuf = (BYTE*) &(pSubSecEx->aData[0]);

    //
    // start signing (create the hash object).
    //
    HCRYPTHASH hHash;

    CACMessageProperties * pMsgProps = &pSendParams->MsgProps;

    HRESULT hr = _BeginToSignMessage(
					 pMsgProps,
                     pSecCtx,
                     &hHash
					 );

    if (FAILED(hr))
    {
        return hr;
    }
    CHCryptHash hAutoRelHash = hHash;

	//
	// Prepare old QueueFormat response and admin queue
	//
    QUEUE_FORMAT   ResponseQueueFormat;
    QUEUE_FORMAT * pResponseQueueFormat = &ResponseQueueFormat;
    MQpMqf2SingleQ(pSendParams->nResponseMqf, pSendParams->ResponseMqf, &pResponseQueueFormat);

    QUEUE_FORMAT   AdminQueueFormat;
    QUEUE_FORMAT * pAdminQueueFormat = &AdminQueueFormat;
    MQpMqf2SingleQ(pSendParams->nAdminMqf, pSendParams->AdminMqf, &pAdminQueueFormat);

    hr = HashMessageProperties(
             hHash,
             pMsgProps->ppCorrelationID ? *pMsgProps->ppCorrelationID : NULL,
             PROPID_M_CORRELATIONID_SIZE,
             pMsgProps->pApplicationTag ? *pMsgProps->pApplicationTag : DEFAULT_M_APPSPECIFIC,
             pMsgProps->ppBody ? *pMsgProps->ppBody : NULL,
             pMsgProps->ulBodyBufferSizeInBytes,
             pMsgProps->ppTitle ? *pMsgProps->ppTitle : NULL,
             pMsgProps->ulTitleBufferSizeInWCHARs * sizeof(WCHAR),
             pResponseQueueFormat,
             pAdminQueueFormat
			 );

    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Prepare structure of flags.
    //
    struct _MsgFlags sUserFlags;
    memset(&sUserFlags, 0, sizeof(sUserFlags));

    sUserFlags.bDelivery = DEFAULT_M_DELIVERY;
    sUserFlags.bPriority = DEFAULT_M_PRIORITY;
    sUserFlags.bAuditing = DEFAULT_M_JOURNAL;
    sUserFlags.bAck      = DEFAULT_M_ACKNOWLEDGE;
    sUserFlags.usClass   = MQMSG_CLASS_NORMAL;

    if (pMsgProps->pDelivery)
    {
        sUserFlags.bDelivery = *(pMsgProps->pDelivery);
    }
    if (pMsgProps->pPriority)
    {
        sUserFlags.bPriority = *(pMsgProps->pPriority);
    }
    if (pMsgProps->pAuditing)
    {
        sUserFlags.bAuditing = *(pMsgProps->pAuditing);
    }
    if (pMsgProps->pAcknowledge)
    {
        sUserFlags.bAck      = *(pMsgProps->pAcknowledge);
    }
    if (pMsgProps->pClass)
    {
        sUserFlags.usClass   = *(pMsgProps->pClass);
    }
    if (pMsgProps->pulBodyType)
    {
        sUserFlags.ulBodyType = *(pMsgProps->pulBodyType);
    }

    GUID guidConnector = GUID_NULL;
    const GUID *pConnectorGuid = &guidConnector;
    if (pMsgProps->ppConnectorType)
    {
        pConnectorGuid = *(pMsgProps->ppConnectorType);
    }

    //
    // Prepare array of properties to hash.
    // (_MsgHashData already include one property).
    //
    DWORD dwStructSize = sizeof(struct _MsgHashData) +
                            (3 * sizeof(struct _MsgPropEntry));
    P<struct _MsgHashData> pHashData =
                        (struct _MsgHashData *) new BYTE[ dwStructSize ];

    pHashData->cEntries = 4;
    (pHashData->aEntries[0]).dwSize = (1 + wcslen(pwszTargetFormatName)) * sizeof(WCHAR);
    (pHashData->aEntries[0]).pData = (const BYTE*) pwszTargetFormatName;
    (pHashData->aEntries[1]).dwSize = sizeof(GUID);
    (pHashData->aEntries[1]).pData = (const BYTE*) &g_LicGuid;
    (pHashData->aEntries[2]).dwSize = sizeof(sUserFlags);
    (pHashData->aEntries[2]).pData = (const BYTE*) &sUserFlags;
    (pHashData->aEntries[3]).dwSize = sizeof(GUID);
    (pHashData->aEntries[3]).pData = (const BYTE*) pConnectorGuid;

    hr = MQSigHashMessageProperties(hHash, pHashData);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // sign the has with private key.
    //
    if (!CryptSignHashA(
            hHash,
			pSecCtx->dwPrivateKeySpec,
            NULL,
            0,
            pSignBuf,
            pdwSignSize
			))
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "_SignMessageEx(), fail at CryptSignHash(), err- %lxh"), GetLastError()));

        return MQ_ERROR_CANNOT_SIGN_DATA_EX;
    }

    //
    // On receiver side, only signature size indicate that message was
    // signed by sender. Verify the size is indeed non-zero
    //
    if (*pdwSignSize == 0)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "_SignMessageEx(), CryptSignHash return with zero signature size")));

        ASSERT(*pdwSignSize != 0);
        return MQ_ERROR_CANNOT_SIGN_DATA_EX;
    }

    pSubSecEx->wSubSectionLen = (USHORT)
                    (sizeof(struct _SecuritySubSectionEx) + *pdwSignSize);
    ULONG ulSignExLen = ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen);

#ifdef _DEBUG
{
	BYTE* pSubPtr = NULL;
    //
    // Simulate subsection that succeed the signature. To verify that
    // present code is forward compatible if we'll want to add new
    // subsections in future releases.
    //
    static DWORD s_dwPostfixCount = 0;
    static BOOL  s_fPostAlreadyRead = FALSE;

    if (!s_fPostAlreadyRead)
    {
        DWORD dwSize = sizeof(DWORD);
        DWORD dwType = REG_DWORD;

        LONG res = GetFalconKeyValue(
					   POSTFIX_SUB_SECTIONS_REGNAME,
					   &dwType,
					   &s_dwPostfixCount,
					   &dwSize
					   );
        if (res != ERROR_SUCCESS)
        {
            s_dwPostfixCount = 0;
        }
        s_fPostAlreadyRead = TRUE;
    }

    pSubPtr = ((BYTE*) pSubSecEx) + ulSignExLen;

    for ( USHORT j = 0; j < (USHORT) s_dwPostfixCount; j++ )
    {
        ulTestSections++;
        pSubSecEx = (struct _SecuritySubSectionEx *) pSubPtr;
        pSubSecEx->eType = e_SecInfo_Test;
        pSubSecEx->_u.wFlags = 0;
        pSubSecEx->wSubSectionLen = (USHORT) ( (j * 11) + 1 +
                                   sizeof(struct _SecuritySubSectionEx));

        ulTestLen += ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen);
        pSubPtr = ((BYTE*) pSubSecEx) + ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen);
    }
}
#endif

    pSecEx->cSubSectionCount = (USHORT) (1 + ulTestSections);
    pSecEx->wSectionLen = (USHORT) ( sizeof(struct _SecuritySectionEx)   +
                                     ulSignExLen                         +
                                     ulTestLen );

    *pdwSignSize = pSecEx->wSectionLen;

	DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: _SignMessageEx() MSMQ20 signature complete ok")));
    return MQ_OK;
}

//+-------------------------------------------------------
//
//  BOOL  ShouldEncryptMessage()
//
//  Return TRUE, if the message should be encrypted.
//
//+-------------------------------------------------------

static
BOOL
ShouldEncryptMessage(
    CACMessageProperties * pMsgProps,
    enum enumProvider    * peProvider
    )
{
    BOOL bRet = FALSE;

    if (!pMsgProps->ulBodyBufferSizeInBytes)
    {
        //
        // No message body, nothing to encrypt.
        //
        return(FALSE);
    }

    switch (*pMsgProps->pulPrivLevel)
    {
    case MQMSG_PRIV_LEVEL_NONE:
        bRet = FALSE;
        break;

    case MQMSG_PRIV_LEVEL_BODY_BASE:
        *peProvider = eBaseProvider;
        bRet = TRUE;
        break;

    case MQMSG_PRIV_LEVEL_BODY_ENHANCED:
        *peProvider = eEnhancedProvider;
        bRet = TRUE;
        break;
    }

    return(bRet);
}

//=--------------------------------------------------------------------------=
// HELPER: GetCurrentViperTransaction
//
// Gets current COM+ transaction if there is one...
//
// CoGetObjectContext is exported by OLE32.dll
// IObjectContextInfo is defined in the latest COM+ SDK (part of the platform SDK)
//=--------------------------------------------------------------------------=
static ITransaction *GetCurrentViperTransaction(void)
{
    ITransaction *pTransaction = NULL;
    IObjectContextInfo *pInfo  = NULL;

    HRESULT hr = CoGetObjectContext(IID_IObjectContextInfo, (void **)&pInfo);
    if (SUCCEEDED(hr) && pInfo)
    {
    	hr = pInfo -> GetTransaction((IUnknown **)&pTransaction);
	    pInfo -> Release();
        if (FAILED(hr))
        {
            LogHR(hr, s_FN, 70);
            pTransaction = NULL;
        }
    }

    return pTransaction;
}

//=--------------------------------------------------------------------------=
// HELPER: GetCurrentXATransaction
// Gets current XA transaction if there is one...
//=--------------------------------------------------------------------------=
static ITransaction *GetCurrentXATransaction(void)
{
    IXATransLookup *pXALookup = NULL;
    HRESULT         hr = MQ_OK;
    IUnknown       *punkDtc = NULL;
    ITransaction   *pTrans;

    __try
    {
        // Bug 8772.
        hr = GetMutex();  // Isolate export creation from others
        if (SUCCEEDED(hr))
        {
            hr = XactGetDTC(&punkDtc, NULL, NULL);
        }
    }
    __finally

    {
        // Bug 8772.
        if (g_hMutexDTC != NULL)
        {
            BOOL bRet = ReleaseMutex(g_hMutexDTC);
            ASSERT(bRet) ;
            DBG_USED(bRet);
        }
    }

    if (FAILED(hr) || punkDtc==NULL)
    {
        LogHR(hr, s_FN, 80);
        return NULL;
    }

    // Get the DTC  ITransactionImportWhereabouts interface
    hr = punkDtc->QueryInterface (IID_IXATransLookup, (void **)(&pXALookup));
    punkDtc->Release();
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 90);
        return NULL;
    }
    ASSERT(pXALookup);

    hr = pXALookup->Lookup(&pTrans);
    pXALookup->Release();
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 100);
        return NULL;
    }

    return pTrans;
}


static
HRESULT
GetCertAndSecurityContext(
    IN OUT CACMessageProperties *pMsgProps,
	OUT BYTE **ppUserCert,
    IN OUT PMQSECURITY_CONTEXT& pSecCtx,
	OUT P<MQSECURITY_CONTEXT>& pSecCtxToFree
	)
/*++

Routine Description:
	Check and initialize the User Certificate and the security context.
	Note: This function replaced the block in RTpSendMessage that dealt with this

Arguments:
    pMsgProps - pointer to send message properties.
	ppUserCert - pointer to the user certificate.
	pSecCtx - pointer to the security context.
	pSecCtxToFree - auto pointer for releasing the created temporary security context

Returned Value:
    MQ_OK, if successful, else error code.

--*/
{
    BOOL bShouldGetCertInfo = TRUE;

    if (!pSecCtx)
    {
        //
        // Security context NOT provided by caller, in a
        // message property.
        //
        if (!pMsgProps->ppSenderCert)
        {
            //
            // Caller also did not provide a certificate in the
            // message properties array. In this case we take the
            // cached security context of the process.
            //
            if (!g_pSecCntx->pUserCert)
            {
                //
                // The process does not have an internal
                // certificate, there is nothing that we can do
                // but fail.
                //
                return LogHR(MQ_ERROR_NO_INTERNAL_USER_CERT, s_FN, 152);
            }
            *ppUserCert = g_pSecCntx->pUserCert;
            pMsgProps->ppSenderCert = ppUserCert;
            pMsgProps->ulSenderCertLen = g_pSecCntx->dwUserCertLen;
            pSecCtx = g_pSecCntx;
            bShouldGetCertInfo = FALSE;
        }
    }
    else
    {
        if (!pMsgProps->ppSenderCert)
        {
            //
            // Caller provided a security context, but not a
            // certificate. We take the certificate from the
            // security context.
            //
            *ppUserCert = pSecCtx->pUserCert;
            pMsgProps->ppSenderCert = ppUserCert;
            pMsgProps->ulSenderCertLen = pSecCtx->dwUserCertLen;
            bShouldGetCertInfo = FALSE;
        }
        else
        {
            //
            // We have a security context and a certificate in
            // PROPID_M_USER_CERT. In this case, we should use
            // the certificate in PROPID_M_USER_CERT. We can use
            // the cashed certificate information in the security
            // context, if the certificate in the security context
            // is the same as in PROPID_M_USER_CERT.
            //
            bShouldGetCertInfo =
                (pSecCtx->dwUserCertLen != pMsgProps->ulSenderCertLen) ||
                (memcmp(
                     pSecCtx->pUserCert,
                     *pMsgProps->ppSenderCert,
                     pMsgProps->ulSenderCertLen
					 ) != 0);
        }
    }

    if (bShouldGetCertInfo)
    {
        //
        // Caller provided a certificate, but not a security
        // context.  Get all the information for the certificate.
        // We put the certificate information in a temporary
        // security context.
        //
        ASSERT(pMsgProps->ppSenderCert);

	    pSecCtxToFree = AllocSecurityContext();
		PMQSECURITY_CONTEXT pTmpSecCtx = pSecCtxToFree.get();

        HRESULT hr = GetCertInfo(
                         false,
						 pTmpSecCtx->fLocalSystem,
						 pMsgProps->ppSenderCert,
						 &pMsgProps->ulSenderCertLen,
						 &pTmpSecCtx->hProv,
						 &pTmpSecCtx->wszProvName,
						 &pTmpSecCtx->dwProvType,
						 &pTmpSecCtx->bDefProv,
						 &pTmpSecCtx->bInternalCert,
						 &pTmpSecCtx->dwPrivateKeySpec
						 );

        //
        // The caller can not provide the internal certificate as
        // a message property, only his own externel certificate.
        // ASSERT this condition.
        //
        ASSERT(!(pTmpSecCtx->bInternalCert));

		//
		// dwPrivateKeySpec	must be AT_SIGNATURE or AT_KEYEXCHANGE
		//
        ASSERT((pTmpSecCtx->dwPrivateKeySpec == AT_SIGNATURE) ||
			   (pTmpSecCtx->dwPrivateKeySpec == AT_KEYEXCHANGE));

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 160);
        }

        if (pSecCtx)
        {
            //
            // If we got the certificate from PROPID_M_USER_CERT,
            // but we have also a security context, we should get
            // the sender ID from the security context. So copy
            // the sender ID from the security context that we
            // get from the application into the temporary
            // security context.
            //
            pTmpSecCtx->fLocalUser = pSecCtx->fLocalUser;

            if (!pSecCtx->fLocalUser)
            {
                pTmpSecCtx->dwUserSidLen = pSecCtx->dwUserSidLen;
                pTmpSecCtx->pUserSid = new BYTE[pSecCtx->dwUserSidLen];
                BOOL bRet = CopySid(
                                pSecCtx->dwUserSidLen,
                                pTmpSecCtx->pUserSid,
                                pSecCtx->pUserSid
								);
                ASSERT(bRet);
				DBG_USED(bRet);
            }
        }
        else
        {
            pTmpSecCtx->fLocalUser = g_pSecCntx->fLocalUser;
        }

        pSecCtx = pTmpSecCtx;
    }

    ASSERT(pSecCtx);
	return MQ_OK;
}


static
HRESULT
SignMessageMsmq12(
    IN PMQSECURITY_CONTEXT pSecCtx,
    IN ULONG ulAuthLevel,
    IN ULONG* pulProvNameSizeAll,
	IN LPCWSTR pwszTargetFormatName,
	IN OUT CACSendParameters *pSendParams,
	IN OUT BYTE *pabMessageSignature,
	OUT AP<BYTE>& pSignatureMqf
	)
/*++

Routine Description:
	Create the Signature for msmq1.0 and msmq2.0
	Note: This function replaced the block in RTpSendMessage that dealt with this

Arguments:
	pSecCtx - pointer to the security context.
	ppUserCert - pointer to the user certificate.
  	ulAuthLevel - authentication level
	pulProvNameSizeAll - provider name size including the extra sections
	pwszTargetFormatName - targert format name
    pSendParams - pointer to send params.
	pabMessageSignature - pointer to signature buffer.
	pSignatureMqf - auto pointer of byte for the signature mqf

Returned Value:
    MQ_OK, if successful, else error code.

--*/
{
	//
	// Get only the AUTH_LEVEL_MSMQ_PROTOCOL bits
	//
	ULONG ulAuthLevelMsmq = GET_AUTH_LEVEL_MSMQ_PROTOCOL(ulAuthLevel);
	DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: SignMessageMsmq12(), AUTH_LEVEL_MSMQ_PROTOCOL = %d"), ulAuthLevelMsmq));

	//
	// Sign the message.
	//
	ASSERT(ulAuthLevelMsmq != MQMSG_AUTH_LEVEL_ALWAYS);
	ASSERT(ulAuthLevelMsmq != MQMSG_AUTH_LEVEL_NONE);

	if(IS_AUTH_LEVEL_SIG10_BIT(ulAuthLevelMsmq))
	{
		HRESULT hr = SignMessage(pSendParams, pSecCtx);
		if(FAILED(hr))
		{
			return hr;
		}
		ASSERT(pSendParams->MsgProps.ulSignatureSize != 0);
	}
	else
	{
		//
		// Sign only with win2k style or Mqfsignature.
		// make the "msmq1.0" signature dummy, with a single
		// null dword. It's too risky to have a null pointer
		// as msmq1.0 signature, so a dummy value is better.
		// win2k code will ignore it anyway.
		//
		pSendParams->MsgProps.ulSignatureSize = 4;
		memset(pabMessageSignature, 0, pSendParams->MsgProps.ulSignatureSize);
	}

	//
	// Now create the "Extra" signature. Sign all those
	// properties that were not signed on msmq1.0.
	//
	BYTE abMessageSignatureEx[MAX_MESSAGE_SIGNATURE_SIZE_EX];
	DWORD dwSignSizeEx = sizeof(abMessageSignatureEx);

	if (ulAuthLevelMsmq == MQMSG_AUTH_LEVEL_SIG10)
	{
		//
		// enhanced signature (win2k style) not needed.
		//
		dwSignSizeEx = 0;
	}
	else
	{
		ASSERT(IS_AUTH_LEVEL_SIG20_BIT(ulAuthLevelMsmq) || IS_AUTH_LEVEL_SIG30_BIT(ulAuthLevelMsmq));
		
		//
		// Currently if need EX signature check if we need to sign with Mqf Signature
		//
		HRESULT hr;
		if(IS_AUTH_LEVEL_SIG30_BIT(ulAuthLevelMsmq))
		{
			hr = SignMqf(
						pSecCtx,
						pwszTargetFormatName,
						pSendParams,
						pSignatureMqf,							
						&pSendParams->SignatureMqfSize			
						);
			if(FAILED(hr))
			{
				return hr;
			}
		}

		if(!IS_AUTH_LEVEL_SIG20_BIT(ulAuthLevelMsmq))
		{
			return MQ_OK;
		}

		hr = _SignMessageEx(
				 pwszTargetFormatName,
				 pSendParams,
				 pSecCtx,
				 abMessageSignatureEx,
				 &dwSignSizeEx
				 );

		if(FAILED(hr))
		{
			return hr;
		}

		ASSERT(dwSignSizeEx != 0);
	}

	//
	// Copy the Ex signature to the standard signature buffer.
	// The driver will separate them and insert them in the
	// packet in the proper place. This is necessary to keep
	// the send parameters buffer without changes.
	//
	if (dwSignSizeEx == 0)
	{
		//
		// Signature not created. That's ok.
		//
	}
	else if ((dwSignSizeEx + pSendParams->MsgProps.ulSignatureSize) <=
								 MAX_MESSAGE_SIGNATURE_SIZE_EX)
	{
		memcpy(
			&(pabMessageSignature[pSendParams->MsgProps.ulSignatureSize ]),
			abMessageSignatureEx,
			dwSignSizeEx
			);

		pSendParams->MsgProps.ulSignatureSize += dwSignSizeEx;

		//
		// Compute size of authentication "provider" field. This
		// field contain the provider name and extra authentication
		// data that was added for post win2k rtm.
		//
		*pulProvNameSizeAll = dwSignSizeEx +
					 ALIGNUP4_ULONG(ComputeAuthProvNameSize(&pSendParams->MsgProps));
		pSendParams->MsgProps.pulAuthProvNameLenProp = pulProvNameSizeAll;
	}
	else
	{
		ASSERT(("Total size of msmq2.0 signature_ex > MAX_MESSAGE_SIGNATURE_SIZE_EX", 0));
		LogHR(MQ_ERROR, s_FN, 170);
	}
	return MQ_OK;
}


static
HRESULT
HandleSignature(
    IN QUEUEHANDLE  hQueue,
	IN OUT CACSendParameters *pSendParams,
    OUT PMQSECURITY_CONTEXT& pSecCtx,
	OUT P<MQSECURITY_CONTEXT>& pSecCtxToFree,
	OUT BYTE **ppUserCert,
    OUT ULONG *pulAuthLevel,
    OUT ULONG *pulProvNameSizeAll,
	OUT WCHAR **ppProvName,
	OUT BYTE **ppabMessageSignature,
	IN ULONG abMessageSignatureSize,
	OUT AP<char>& pSignatureElement,
	OUT AP<BYTE>& pSignatureMqf
	)
/*++

Routine Description:
	Handle the Signature
	Note: This function replaced the block in RTpSendMessage that dealt with the signature

Arguments:
	hQueue - queue handle
    pSendParams - pointer to send params.
	pSecCtx - pointer to the security context.
	pSecCtxToFree - auto pointer for releasing the created temporary security context
	ppUserCert - pointer to the user certificate.
  	pulAuthLevel - pointer to long, authentication level
	pulProvNameSizeAll - pointer to long, provider name size including the extra sections
	ppProvName - pointer to provider name wstring.
	ppabMessageSignature - pointer to pointer of the signature buffer.
	abMessageSignatureSize - Signature buffer size
	pSignatureElement - auto pointer of char for the XMLDSIG signature element string
	pSignatureMqf - auto pointer of byte for the mqf signature

Returned Value:
    MQ_OK, if successful, else error code.

--*/
{
	//
	// Signature is given by the user
	//
    if (pSendParams->MsgProps.ppSignature)
    {
        if (!pSecCtx && !pSendParams->MsgProps.ppSenderCert)
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 140);
        }
        if (!pSendParams->MsgProps.ppSenderCert)
        {
            //
            // We have a security context and no certificate. We
            // take the certificate from the security context.
            //
            *ppUserCert = pSecCtx->pUserCert;
            pSendParams->MsgProps.ppSenderCert = ppUserCert;
            pSendParams->MsgProps.ulSenderCertLen = pSecCtx->dwUserCertLen;
        }

        if (pSendParams->MsgProps.ppwcsProvName)
        {
            ASSERT(pSendParams->MsgProps.pulProvType);
            pSendParams->MsgProps.fDefaultProvider = FALSE;
        }

		return MQ_OK;
    }

	//
	// Should not sign the message --> signature length = 0
	//
	if (!ShouldSignMessage(&pSendParams->MsgProps))
	{
        pSendParams->MsgProps.ulSignatureSize = 0;
		return MQ_OK;
	}

	//
	// Get Target Queue name and decide whether it is Http message
	//
	DWORD dwTargetFormatNameLength = 0;
	HRESULT hr = ACHandleToFormatName(
					 hQueue,
					 NULL,
					 &dwTargetFormatNameLength
					 );

	if(hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
	{
		//
		// We got other error then the expected MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL
		// e.g. MQ_ERROR_STALE_HANDLE
		//
		ASSERT(FAILED(hr));
        return LogHR(hr, s_FN, 144);
	}

	ASSERT(hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL);
	ASSERT(dwTargetFormatNameLength > 0);

	AP<WCHAR> pwszTargetFormatName = new WCHAR[dwTargetFormatNameLength];

	hr = ACHandleToFormatName(
			 hQueue,
			 pwszTargetFormatName.get(),
			 &dwTargetFormatNameLength
			 );

	ASSERT(hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 145);
    }

	//
	// Call ACGetQueueHandleProperties to get the types of signatures needed
	// this is based on the queue types we have in the handle.
	//
	CACGetQueueHandleProperties	qhp;
	hr = ACGetQueueHandleProperties(
			 hQueue,
			 qhp
			 );

	ASSERT(SUCCEEDED(hr));

	DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: HandleSignature(), fProtocolSrmp = %d, fProtocolMsmq = %d"), qhp.fProtocolSrmp, qhp.fProtocolMsmq));

	if(!qhp.fProtocolSrmp && !qhp.fProtocolMsmq)
	{
		//
		// Neither of protocols exists!
		// this will be the case for DL= that is empty
		//
		DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: HandleSignature(), We have no protocol (empty DL)")));
		return LogHR(MQ_OK, s_FN, 147);
	}
	
	hr = CalcSignutureTypes(
			pSendParams,
			pulAuthLevel,
			pwszTargetFormatName.get(),
			qhp
			);

	if (FAILED(hr))
	{
		return LogHR(hr, s_FN, 148);
	}

	//
	// pSecCtx is reference parameters
	//
	hr = GetCertAndSecurityContext(
			 &pSendParams->MsgProps,
			 ppUserCert,
			 pSecCtx,
			 pSecCtxToFree
			 );

	if (FAILED(hr))
	{
		return LogHR(hr, s_FN, 150);
	}

    //
    // Fill the SendParam with the provider information for the
    // certificate.
    //
    if (pSecCtx->wszProvName == NULL)
    {
        //
        // we don't have a provider, so we can't sign.
        //
        ASSERT(pSecCtx->hProv == NULL);
        if (pSendParams->MsgProps.ppSenderCert == NULL)
        {
            //
            // we don't have a certificate. That's a
            // user error.
            //
            return LogHR(MQ_ERROR_CERTIFICATE_NOT_PROVIDED, s_FN, 162);
        }
        else
        {
            return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 164);
        }
    }

    *ppProvName = pSecCtx->wszProvName;
    pSendParams->MsgProps.ppwcsProvName = ppProvName;
    pSendParams->MsgProps.ulProvNameLen = wcslen(pSecCtx->wszProvName) + 1;
    pSendParams->MsgProps.pulProvType = &pSecCtx->dwProvType;
    pSendParams->MsgProps.fDefaultProvider = pSecCtx->bDefProv;

	if(qhp.fProtocolMsmq)
	{
		//
		// msmq1.0 and msmq2.0 signature treatment.
		//
		// Set the buffer for the signature.
		//
		pSendParams->MsgProps.ppSignature = ppabMessageSignature;
		pSendParams->MsgProps.ulSignatureSize = abMessageSignatureSize;

		hr = SignMessageMsmq12(
				 pSecCtx,
				 *pulAuthLevel,
				 pulProvNameSizeAll,
				 pwszTargetFormatName.get(),
				 pSendParams,
				 *ppabMessageSignature,
				 pSignatureMqf
				 );

		if(FAILED(hr))
		{
			return LogHR(hr, s_FN, 168);
		}
	}	
	
	if(!qhp.fProtocolSrmp)
	{
		return LogHR(MQ_OK, s_FN, 169);
	}

	//
	// Handle Srmp message signature
	//
	try
	{
		BYTE** ppSignatureElementByte = reinterpret_cast<BYTE **>(&pSignatureElement);

		hr = SignMessageXmlDSig(
				 pSecCtx,
				 pSendParams,
				 pSignatureElement
				 );


		if(FAILED(hr))
		{
			return LogHR(hr, s_FN, 166);
		}

		pSendParams->ulXmldsigSize = strlen(pSignatureElement.get());
		pSendParams->ppXmldsig = ppSignatureElementByte;

		return MQ_OK;
	}
	catch (const bad_CryptoApi& exp)
	{
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT("RT: SignMessageXmlDSig(), bad Crypto Class Api Excption ErrorCode = %x"), exp.error()));
		DBG_USED(exp);

		return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 167);
	}
	catch (const bad_alloc&)
	{
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT("RT: SignMessageXmlDSig(), bad_alloc Excption")));
		return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 268);
	}
}


//---------------------------------------------------------
//
//  RTpSendMessage(...)
//
//  Description:
//
//      Helper function for MQSendMessage
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------
static
HRESULT
RTpSendMessage(
    IN QUEUEHANDLE  hQueue,
    IN MQMSGPROPS*  pmp,
    IN ITransaction *pTransaction
    )
{
    HRESULT hr;
    XACTUOW Uow;


    BYTE* pUserSid;
    BYTE* pUserCert;
    WCHAR* pProvName;

    CMQHResult rc , rc1;
    rc = MQ_OK;
    rc1 = MQ_OK;

    CACSendParameters SendParams;
    BOOL         fSingleTransaction = FALSE;

    //
    // Set defaults.
	//
    ULONG ulDefHashAlg = PROPID_M_DEFUALT_HASH_ALG;
    ULONG ulDefEncryptAlg = PROPID_M_DEFUALT_ENCRYPT_ALG;
    ULONG ulDefPrivLevel = DEFAULT_M_PRIV_LEVEL;
    ULONG ulDefSenderIdType = DEFAULT_M_SENDERID_TYPE;
    ULONG ulSenderIdTypeNone = MQMSG_SENDERID_TYPE_NONE;

    SendParams.MsgProps.pulHashAlg = &ulDefHashAlg;
    SendParams.MsgProps.pulPrivLevel = &ulDefPrivLevel;
    SendParams.MsgProps.pulEncryptAlg = &ulDefEncryptAlg;
    SendParams.MsgProps.pulSenderIDType = &ulDefSenderIdType;
    SendParams.MsgProps.fDefaultProvider = TRUE;
    SendParams.MsgProps.ulAuthLevel = DEFAULT_M_AUTH_LEVEL;

    //
    //  Parse message properties
    //
    PMQSECURITY_CONTEXT pSecCtx;
    CStringsToFree ResponseStringsToFree, AdminStringsToFree;
    rc1 = RTpParseSendMessageProperties(
            SendParams,
            pmp->cProp,
            pmp->aPropID,
            pmp->aPropVar,
            pmp->aStatus,
            &pSecCtx,
            ResponseStringsToFree,
            AdminStringsToFree
			);

    if(FAILED(rc1))
    {
        return LogHR(rc1, s_FN, 110);
    }

    //
    // Look for Viper transaction if any
    //

    //
    // Ref - wrapper to ensure autorelease of the transaction
    //
    R<ITransaction> ref;
    if (pTransaction == MQ_MTS_TRANSACTION)
    {
        pTransaction = GetCurrentViperTransaction();
		if(pTransaction != NULL)
		{
	        ref = pTransaction;
		}
	}
    else if (pTransaction == MQ_XA_TRANSACTION)
    {
        pTransaction = GetCurrentXATransaction();
		if(pTransaction != NULL)
		{
	        ref = pTransaction;
		}
    }
    else if (pTransaction == MQ_SINGLE_MESSAGE)
    {
        hr = MQBeginTransaction(&pTransaction);
        if(FAILED(hr))
        {
            return LogHR(hr, s_FN, 120);
        }

        fSingleTransaction    = TRUE;
		if(pTransaction != NULL)
		{
	        ref = pTransaction;
		}
    }

    //
    // Enlist QM in the transaction (with caching);
    //
    if (pTransaction)
    {
        hr = RTpProvideTransactionEnlist(pTransaction, &Uow);
        SendParams.MsgProps.pUow = &Uow;

        if(FAILED(hr))
        {
            LogHR(hr, s_FN, 130);
            return hr;
        }
    }

	//
    // Change values for the transaction case
	//
    static UCHAR Delivery;
    static UCHAR Priority;

    if (pTransaction)
    {
        Delivery = MQMSG_DELIVERY_RECOVERABLE;
        Priority = 0;

        SendParams.MsgProps.pDelivery = &Delivery;
        SendParams.MsgProps.pPriority = &Priority;
    }

    //
    // Treat security
    //
    if (!g_pSecCntx)
    {
        //
        //  It might not be initialized if the queue was
        //  not opened for send;
        //
        InitSecurityContext();
    }

    BYTE abMessageSignature[MAX_MESSAGE_SIGNATURE_SIZE_EX];
    BYTE* pabMessageSignature = abMessageSignature;
	AP<char> pSignatureElement;
	AP<BYTE> pSignatureMqf;
    ULONG ulProvNameSizeAll = 0;
    ULONG ulAuthLevel = 0;
	P<MQSECURITY_CONTEXT> pSecCtxToFree;

	hr = HandleSignature(
			 hQueue,
			 &SendParams,
			 pSecCtx,
			 pSecCtxToFree,
			 &pUserCert,
			 &ulAuthLevel,
			 &ulProvNameSizeAll,
			 &pProvName,
			 &pabMessageSignature,
			 TABLE_SIZE(abMessageSignature),
			 pSignatureElement,
			 pSignatureMqf
			 );

	if(FAILED(hr))
	{
		return LogHR(hr, s_FN, 269);
	}

    if(!SendParams.MsgProps.ppSenderID && *SendParams.MsgProps.pulSenderIDType == MQMSG_SENDERID_TYPE_SID)
    {
        if ((pSecCtx && pSecCtx->fLocalUser) ||
            (!pSecCtx && g_pSecCntx->fLocalUser))
        {
            //
            // In case this is a local user, we do not send the user's
            // SID with the message, eventhough the application asked
            // to send it.
            //
            SendParams.MsgProps.pulSenderIDType = &ulSenderIdTypeNone;
        }
        else
        {
            //
            // We should pass the sender ID. Either get it from the
            // security context, if available, or get it from the
            // cached process security context.
            //
            if (!pSecCtx || !pSecCtx->pUserSid)
            {
                if (!g_pSecCntx->pUserSid)
                {
                    //
                    // The cahced process context does not contain the
                    // sender's SID. There is nothing that we can do but
                    // fail.
                    //
                    return LogHR(MQ_ERROR_COULD_NOT_GET_USER_SID, s_FN, 172);
                }
                pUserSid = g_pSecCntx->pUserSid;
                SendParams.MsgProps.uSenderIDLen = (USHORT)g_pSecCntx->dwUserSidLen;
            }
            else
            {
                pUserSid = pSecCtx->pUserSid;
                SendParams.MsgProps.uSenderIDLen = (USHORT)pSecCtx->dwUserSidLen;
            }
            SendParams.MsgProps.ppSenderID = &pUserSid;
        }
    }

    if (SendParams.MsgProps.ppSymmKeys)
    {
        //
        // the application supplied the symmetric key. In such a case
        // doesn't do any encryption
        //
        //
        // When the symm key is supplied, we assume that the body is encrypted and
        // we mark it as such and ignore PROPID_M_PRIV_LEVEL.
        //
        if (SendParams.MsgProps.pulPrivLevel &&
            (*(SendParams.MsgProps.pulPrivLevel) == MQMSG_PRIV_LEVEL_BODY_ENHANCED))
        {
            //
            // priv level supplied by caller.
            //
        }
        else
        {
            //
            // use default.
            //
            ulDefPrivLevel = MQMSG_PRIV_LEVEL_BODY;
            SendParams.MsgProps.pulPrivLevel = &ulDefPrivLevel;
        }
        SendParams.MsgProps.bEncrypted = TRUE;
    }
    else
    {
        enum enumProvider eProvider;
        if (ShouldEncryptMessage(&SendParams.MsgProps, &eProvider))
        {
            //
            // If we should use a block cypher enlarge the allocated
            // space for the message body, so it will be able to accomodate
            // the encrypted data.
            //

            if (*SendParams.MsgProps.pulEncryptAlg == CALG_RC2)
            {
                //
                // Make more room for RC2 encryption.
                //
                DWORD dwBlockSize;
                hr = MQSec_GetCryptoProvProperty( eProvider,
                                                  eBlockSize,
                                                  NULL,
                                                 &dwBlockSize );
                if (FAILED(hr))
                {
                    return LogHR(hr, s_FN, 180);
                }

                SendParams.MsgProps.ulAllocBodyBufferInBytes +=
                                          ((2 * dwBlockSize) - 1);
                SendParams.MsgProps.ulAllocBodyBufferInBytes &= ~(dwBlockSize - 1);
            }

            DWORD dwSymmSize;
            hr = MQSec_GetCryptoProvProperty( eProvider,
                                              eSessionKeySize,
                                              NULL,
                                             &dwSymmSize );
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 190);
            }

            SendParams.MsgProps.ulSymmKeysSize = dwSymmSize;
        }
    }

    //
    //  Call AC driver
    //
    OVERLAPPED ov = {0};
    ov.hEvent = GetThreadEvent();

    rc = ACSendMessage(
            hQueue,
            SendParams,
            &ov
            );
    LogHR(rc, s_FN, 298);

    if (rc == MQ_INFORMATION_OPERATION_PENDING)
    {
        //
        //  Wait for send completion
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(
                        ov.hEvent,
                        INFINITE
                        );

        //
        //  BUGBUG: MQSendMessage, must succeed in WaitForSingleObject
        //
        ASSERT(dwResult == WAIT_OBJECT_0);

        rc = DWORD_PTR_TO_DWORD(ov.Internal);
    }

	delete [] SendParams.AdminMqf;
	delete [] SendParams.ResponseMqf;

    if(FAILED(rc))
    {
        //
        //  ACSendMessage failed (immidiatly or after waiting)
        //
        return LogHR(rc, s_FN, 200);
    }


    if (fSingleTransaction)
    {
		//
        // RPC call to QM for prepare/commit
		//
        rc = pTransaction->Commit(0,0,0);
        if(FAILED(rc))
        {
            return LogHR(rc, s_FN, 210);
        }
    }

	//
	// Bugfix of bug 5588. niraides 18-Jul-2000
	//
    return rc1;

}  // RTpSendMessage


//---------------------------------------------------------
//
//  MQSendMessage(...)
//
//  Description:
//
//      Falcon API.
//      Send a message to a queue
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------
EXTERN_C
HRESULT
APIENTRY
MQSendMessage(
    IN QUEUEHANDLE  hQueue,
    IN MQMSGPROPS*  pmp,
    IN ITransaction *pTransaction
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepSendMessage(
					hQueue,
					pmp,
					pTransaction
					);

    CMQHResult rc;

    __try
    {
        rc = RTpSendMessage(hQueue, pmp, pTransaction);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        //  The exception is due to invalid parameter
        //
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 220);
    }

    return LogHR(rc, s_FN, 15);
}



//
// This class is used to increment a value in an abortable manner.
// If the scope where the incrementation has taken place is exited
// without calling Detach() first, the value is decremented back.
//
class CIncrementor
{
public:
	CIncrementor(LPLONG ptr) :
		m_pValue(ptr),
		m_TimesIncremented(0)
	{	
	}

	~CIncrementor()
	{
		if(m_pValue == NULL)
			return;
		
		InterlockedExchangeAdd (m_pValue, -m_TimesIncremented);
	}

	LONG Increment()
	{
		m_TimesIncremented++;
		return InterlockedIncrement(m_pValue);
	}

	void Detach()
	{
		m_TimesIncremented = 0;
		m_pValue = NULL;
	}

private:
	LPLONG m_pValue;
	LONG m_TimesIncremented;
};


//---------------------------------------------------------
//
//  RtpReceiveMessage(...)
//
//  Description:
//
//      Rt Internal - Receive a message from a queue.
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

HRESULT
RtpReceiveMessage(
    IN HANDLE hQueue,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN MQMSGPROPS* pmp,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction *pTransaction,
    ULONGLONG ullLookupId,
    bool fUseLookupId
    )
{
    CMQHResult rc, rc1;
    XACTUOW Uow;
    HRESULT hr;

    R<ITransaction> TransactionGenerated;
    CHandle hCallback;
    P<MQRXASYNCDESCRIPTOR> lpDesc;
	CIncrementor PendingReqCounter = &s_cRxPendingReq;

    rc = MQ_OK;
    rc1 = MQ_OK;

	//
	// Look for Viper transaction if any
	//
	if (pTransaction == MQ_MTS_TRANSACTION)
	{
		TransactionGenerated = GetCurrentViperTransaction();
		pTransaction = TransactionGenerated.get();
	}
	else if (pTransaction == MQ_XA_TRANSACTION)
	{
		TransactionGenerated = GetCurrentXATransaction();
		pTransaction = TransactionGenerated.get();
	}
	else if (pTransaction == MQ_SINGLE_MESSAGE)
	{
		pTransaction = NULL;
	}

	if ((dwAction & MQ_ACTION_PEEK_MASK) == MQ_ACTION_PEEK_MASK ||
		(dwAction & MQ_LOOKUP_PEEK_MASK) == MQ_LOOKUP_PEEK_MASK)
	{
		// PEEK cannot be transacted, but can work with transacted queue
		if (pTransaction != NULL)
		{
			return LogHR(MQ_ERROR_TRANSACTION_USAGE, s_FN, 295);
		}
	}

	// Check usage: transaction urges synchronous operation
	if (pTransaction)
	{
		if (lpOverlapped || (fnReceiveCallback!=NULL))  // Transacted Receive is synchronous only
		{
			return LogHR(MQ_ERROR_TRANSACTION_USAGE, s_FN, 296);
		}
	}

	CACReceiveParameters ReceiveParams;
	ReceiveParams.RequestTimeout = dwTimeout;
	ReceiveParams.Action = dwAction;
	ReceiveParams.Cursor = (hCursor != 0) ? CI2CH(hCursor) : 0;
	ReceiveParams.LookupId = ullLookupId;

	// Enlist QM in the transaction (for the first time);
	// Check that the transaction state is correct
	if (pTransaction)
	{
		// Enlist QM in transaction, if it isn't enlisted already
		hr = RTpProvideTransactionEnlist(pTransaction, &Uow);
		ReceiveParams.MsgProps.pUow = &Uow;

		if(FAILED(hr))
		{
			return LogHR(hr, s_FN, 240);
		}
	}

	//
	//  Parse properties
	//
	if(pmp !=0)
	{
		//
		//  Parse message properties, an exception can be raised on access to
		//  pmp fields
		//
		rc1 = RTpParseReceiveMessageProperties(
				ReceiveParams,
				pmp->cProp,
				pmp->aPropID,
				pmp->aPropVar,
				pmp->aStatus);

		if(FAILED(rc1))
		{
			return LogHR(rc1, s_FN, 250);
		}
	}

	OVERLAPPED ov = {0};
	LPOVERLAPPED pov;

	if (fnReceiveCallback)
	{
		//
		//  Async Rx with Callback
		//
		//  do HERE all allocation of resources so that allocation
		//  failure won't happen after returning from ACReceiveMessage.
		//
		
		{
			CS Lock(s_InitAsyncRxCS);
			// This critical section prevent two threads from running the
			// initialization twice.
			if (!s_hAsyncRxThread)
			{
			   rc = InitRxAsyncThread();
			}
		}

		if(FAILED(rc))
		{
		   return LogHR(rc, s_FN, 260);
		}

		if (PendingReqCounter.Increment() > RXTHREAD_HANDLELISTSIZE)
		{
			// Reached Async MQReceive() limit.
			//
			return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 360);
		}

		*&hCallback = CreateEvent(
							NULL,
							TRUE,  // manual reset
							FALSE, // not signalled
							NULL
							);
		
		if (hCallback == NULL)
		{
		   return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 265);
		}

		*&lpDesc = new MQRXASYNCDESCRIPTOR;
		memset(lpDesc.get(), 0, sizeof(MQRXASYNCDESCRIPTOR));
		lpDesc->Overlapped.hEvent = hCallback;
		pov = &(lpDesc->Overlapped);
	}
	else if(lpOverlapped != 0)
	{
		//
		//  Asynchronous (event or completion port)
		//
		pov = lpOverlapped;
	}
	else
	{
		//
		//  Synchronous, uses the TLS event
		//
		ov.hEvent = GetThreadEvent();
		pov = &ov;
	}

	//
	//  Call AC driver
	//
	ReceiveParams.Asynchronous = (pov != &ov);

	if (fUseLookupId)
	{
		ASSERT(ReceiveParams.Cursor == 0);
		ASSERT(ReceiveParams.RequestTimeout == 0);

		rc = ACReceiveMessageByLookupId(
				hQueue,
				ReceiveParams,
				pov
				);
	}
	else
	{
		rc = ACReceiveMessage(
				hQueue,
				ReceiveParams,
				pov
				);
	}

	LogHR(rc, s_FN, 297);

	if((rc == MQ_INFORMATION_OPERATION_PENDING) && (pov == &ov))
	{
		//
		//  Wait for receive completion
		//
		DWORD dwResult;
		dwResult = WaitForSingleObject(
						ov.hEvent,
						INFINITE
						);

		//
		//  BUGBUG: MQReceiveMessage, must succeed in WaitForSingleObject
		//
		ASSERT(dwResult == WAIT_OBJECT_0);

		rc = DWORD_PTR_TO_DWORD(ov.Internal);
	}

	if(FAILED(rc))
	{
		//
		//  ACReceiveMessage failed (immidiatly or after waiting)
		//
		return LogHR(rc, s_FN, 270);
	}
	else if(fnReceiveCallback)
	{
		//
		// Async Rx with callback.
		//
		ASSERT(hCallback != NULL);
		ASSERT(lpDesc.get() != NULL);

		lpDesc->hSource = hQueue;
		lpDesc->dwTimeout = dwTimeout;
		lpDesc->dwAction = dwAction;
		lpDesc->pMessageProps = pmp;
		lpDesc->lpOverlapped = lpOverlapped;
		lpDesc->hCursor = hCursor;

		lpDesc->fnReceiveCallback = fnReceiveCallback;

		{
			CS Lock(s_AsyncRxCS);

			s_pRxEventsHList[ s_cRxHandles ] = hCallback.detach();
			s_lpRxAsynDescList[ s_cRxHandles ] = lpDesc.detach();
			s_cRxHandles++;
		}

		// Tell the async thread that there is a new async MQReceive().
		BOOL fSet = SetEvent(s_hNewAsyncRx);
		ASSERT(fSet);
		DBG_USED(fSet);

		PendingReqCounter.Detach();
	}

    if (rc == MQ_OK)
    {
        //
        //  return message parsing return code
        //  NOTE: only if rc == MQ_OK otherwise PENDING will not pass through
        //
        return LogHR(rc1, s_FN, 300);
    }

    return LogHR(rc, s_FN, 310);
}

//---------------------------------------------------------
//
//  MQReceiveMessage(...)
//
//  Description:
//
//      Falcon API.
//      Receive a message from a queue.
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
MQReceiveMessage(
    IN HANDLE hQueue,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN MQMSGPROPS* pmp,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction *pTransaction
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepReceiveMessage(
					hQueue,
					dwTimeout,
					dwAction,
					pmp,
					lpOverlapped,
					fnReceiveCallback,
					hCursor,
					pTransaction
					);

    __try
	{
		return RtpReceiveMessage(
					hQueue,
					dwTimeout,
					dwAction,
					pmp,
					lpOverlapped,
					fnReceiveCallback,
					hCursor,
					pTransaction,
					0,
					false
					);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{		
		HRESULT rc = GetExceptionCode();
		return LogHR(HRESULT_FROM_WIN32(rc), s_FN, 315);
	}
}


//---------------------------------------------------------
//
//  MQReceiveMessageByLookupId(...)
//
//  Description:
//
//      Falcon API.
//      Receive a message from a queue.using a lookup ID
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
MQReceiveMessageByLookupId(
    IN HANDLE hQueue,
    IN ULONGLONG ullLookupId,
    IN DWORD dwLookupAction,
    IN MQMSGPROPS* pmp,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN ITransaction *pTransaction
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS;

    switch (dwLookupAction)
    {
        case MQ_LOOKUP_PEEK_FIRST:
            if (ullLookupId != 0)
            {
                return MQ_ERROR_INVALID_PARAMETER;
            }
            ullLookupId = 0;
            dwLookupAction = MQ_LOOKUP_PEEK_NEXT;
            break;

        case MQ_LOOKUP_PEEK_LAST:
            if (ullLookupId != 0)
            {
                return MQ_ERROR_INVALID_PARAMETER;
            }
            ullLookupId = 0xFFFFFFFFFFFFFFFFui64;
            dwLookupAction = MQ_LOOKUP_PEEK_PREV;
            break;

        case MQ_LOOKUP_RECEIVE_FIRST:
            if (ullLookupId != 0)
            {
                return MQ_ERROR_INVALID_PARAMETER;
            }
            ullLookupId = 0;
            dwLookupAction = MQ_LOOKUP_RECEIVE_NEXT;
            break;

        case MQ_LOOKUP_RECEIVE_LAST:
            if (ullLookupId != 0)
            {
                return MQ_ERROR_INVALID_PARAMETER;
            }
            ullLookupId = 0xFFFFFFFFFFFFFFFFui64;
            dwLookupAction = MQ_LOOKUP_RECEIVE_PREV;
            break;

        default:
            NULL;
            break;
    }

    __try
	{
		return RtpReceiveMessage(
					hQueue,
					0,
					dwLookupAction,
					pmp,
					lpOverlapped,
					fnReceiveCallback,
					0,
					pTransaction,
					ullLookupId,
					true
					);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{		
		HRESULT rc = GetExceptionCode();
		return LogHR(HRESULT_FROM_WIN32(rc), s_FN, 316);
	}
}

//---------------------------------------------------------
//
//  MQGetOverlappedResult(...)
//
//  Description:
//
//      Falcon API.
//      Translate and overlapping operation result code.
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
MQGetOverlappedResult(
    IN LPOVERLAPPED lpOverlapped
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepGetOverlappedResult(lpOverlapped);

	return LogHR(RTpConvertToMQCode(DWORD_PTR_TO_DWORD(lpOverlapped->Internal)), s_FN, 320);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\qmrt_c_.c ===
#pragma warning(push, 3)
#include <qmrt_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\property.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    property.cxx

Abstract:



Author:

    Erez Haba (erezh) 2-Jan-96

Revision History:

    RonitH - Queue properties validation.
    BoazF (26-May-96) - Message properties validation.

--*/

#include "stdh.h"
#include <mqtime.h>
#include "rtprpc.h"
#include "authlevel.h"
#include <xml.h>
#include <ad.h>

#include "property.tmh"

#define ONE_KB 1024
#define HRESULT_SEVIRITY(hr) (((hr) >> 30) & 0x3)

static WCHAR *s_FN=L"rt/property";

extern DWORD  g_dwTimeToReachQueueDefault ;

//+----------------------------------------------
//
//  HRESULT  RTpCheckColumnsParameter()
//
//+----------------------------------------------

HRESULT
RTpCheckColumnsParameter(
    IN MQCOLUMNSET* pColumns)
{
    HRESULT hr = MQ_OK;

    if (( pColumns == NULL) ||
        ( pColumns->cCol == 0))
    {
        return LogHR(MQ_ERROR_ILLEGAL_MQCOLUMNS, s_FN, 60);
    }

    __try
    {
        PROPID * pPropid = pColumns->aCol;
        for ( DWORD i = 0; i < pColumns->cCol; i++, pPropid++)
        {
            //
            //  make sure that the property id is with-in queue property ids range
            //
            if (((*pPropid) > LAST_Q_PROPID)  || ((*pPropid) <= PROPID_Q_BASE))
            {
                return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 70);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing column structure")));
        DWORD dw = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(dw), s_FN, 90); 
        hr = dw;
    }

    return LogHR(hr, s_FN, 100);
}


static
void
SetStatus(
    HRESULT* pStatusSummary,
    HRESULT* pStatus,
    HRESULT Status
    )
{
    DWORD dwSummarySevirity = HRESULT_SEVIRITY(*pStatusSummary);
    DWORD dwStatusSevirity = HRESULT_SEVIRITY(Status);

    if (dwSummarySevirity < dwStatusSevirity)
    {
        switch(dwStatusSevirity)
        {
        case 1:
            *pStatusSummary = MQ_INFORMATION_PROPERTY;
            break;

        case 2:
            ASSERT(FALSE);
			break;

        case 3:
            *pStatusSummary = MQ_ERROR_PROPERTY;
            break;
        }
    }

    if(pStatus)
    {
        *pStatus = Status;
    }
}


typedef struct {
    PROPID  propId;
    BOOL    fAllow_VT_NULL;
    BOOL    fAllow_VT_EMPTY;
    BOOL    fMustAppear;
    BOOL    fShouldNotAppear;
    BOOL    fPossiblyIgnored;
    HRESULT (* pfValidateProperty)(PROPVARIANT * pVar, PVOID pvContext);
} propValidity;

static
DWORD
CalNumberOfMust(
    IN propValidity * ppropValidity,
    IN DWORD          dwNumberOfProps
    )
{
    DWORD dwNumberOfMust = 0;

    for ( DWORD i =0; i < dwNumberOfProps; i++, ppropValidity++ )
    {
        if (ppropValidity->fMustAppear)
        {
            dwNumberOfMust++;
        }
    }
    return(dwNumberOfMust);
}

static
HRESULT
CheckProps(
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus,
    IN PROPID propidMinPropId,
    IN PROPID propidMaxPropId,
    IN propValidity *ppropValidity,
    IN VARTYPE *vartypePropVts,
    IN BOOL fCheckForIgnoredProps,
    IN DWORD dwNumberOfMustProps,
    IN PVOID pvContext
    )
{
    HRESULT hr = MQ_OK;
    HRESULT dummyStatus;
    BOOL fAdvanceStatusPointer;
    char duplicate[ PROPID_OBJ_GRANULARITY ];
    DWORD index;
    DWORD dwNumberOfMustPropsSupplied = 0;

    memset( duplicate, 0, sizeof(duplicate));

    if ( !pStatus )
    {
        pStatus = &dummyStatus;
        fAdvanceStatusPointer = FALSE;
    }
    else
    {
        fAdvanceStatusPointer = TRUE;
    }

    for ( DWORD i = 0;
          i < cProp;
          i++, pPropid++, pVar++, fAdvanceStatusPointer ? pStatus++ : 0)
    {
        //
        //  Is it a valid propid
        //
        if (((*pPropid) <= propidMinPropId)  || (propidMaxPropId < (*pPropid)))
        {
            //
            // a non-valid propid. The property is ignored, and a warning
            // is returned in aStatus
            //
            SetStatus(&hr, pStatus, MQ_INFORMATION_UNSUPPORTED_PROPERTY);
            continue;
        }

        index = (*pPropid) - propidMinPropId;

		if(ppropValidity[index].propId == 0)
        {
            //
            // a non-valid propid. The property is ignored, and a warning
            // is returned in aStatus
            //
            SetStatus(&hr, pStatus, MQ_INFORMATION_UNSUPPORTED_PROPERTY);
            continue;
        }

        ASSERT(ppropValidity[index].propId == *pPropid);

        //
        //  Is it a duplicate property
        //
        if ( duplicate[ index ] )
        {
            //
            //  The duplicate property is ignored, and a warning is returned
            //  in aStatus
            //
            SetStatus(&hr, pStatus, MQ_INFORMATION_DUPLICATE_PROPERTY);
            continue;
        }
        duplicate[ index ] = 1;

        //
        //  Is it ok for the user to specify this property
        //
        if ( ppropValidity[index].fShouldNotAppear)
        {
            SetStatus(&hr, pStatus, MQ_ERROR_PROPERTY_NOTALLOWED);
            continue;
        }

        //
        // If an ignored property was supplied then raise a warning.
        //
        if (fCheckForIgnoredProps && (ppropValidity[index].fPossiblyIgnored))
        {
            SetStatus(&hr, pStatus, MQ_INFORMATION_PROPERTY_IGNORED);
            continue;
        }

        //
        // Checking propvariant's vartype.
        //
        if ((pVar->vt != vartypePropVts[index]) &&
            !(ppropValidity[index].fAllow_VT_NULL && pVar->vt == VT_NULL) &&
            !(ppropValidity[index].fAllow_VT_EMPTY && pVar->vt == VT_EMPTY))
        {
            SetStatus(&hr, pStatus, MQ_ERROR_ILLEGAL_PROPERTY_VT);
            continue;
        }

        //
        //  Checking propvariant's value and size
        //
        if ( ppropValidity[index].pfValidateProperty != NULL)
        {
            SetStatus(&hr, pStatus, ppropValidity[index].pfValidateProperty(pVar, pvContext));
        }
        else
        {
            *pStatus = MQ_OK;
        }

        //
        //  Count the number of "must-appear" properties
        //
        if ( (*pStatus == MQ_OK) && ppropValidity[index].fMustAppear )
        {
            dwNumberOfMustPropsSupplied++;
        }
    }

    //
    //  where all the "must appear" properties passed in
    //
    if ( dwNumberOfMustPropsSupplied < dwNumberOfMustProps )
    {
        hr = MQ_ERROR_INSUFFICIENT_PROPERTIES;
    }

    return LogHR(hr, s_FN, 110);
}

static HRESULT qJournalValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->bVal != MQ_JOURNAL) && ( pVar->bVal != MQ_JOURNAL_NONE))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 120);
    }
    return(MQ_OK);
}


static HRESULT qLabelValidation( PROPVARIANT * pVar, LPVOID )
{
    __try
    {
        if ( wcslen( pVar->pwszVal) > MQ_MAX_Q_LABEL_LEN )
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 130);
        }


    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 140);
    }

    return(MQ_OK);
}


static HRESULT qMulticastValidation( PROPVARIANT * pVar, LPVOID )
{
	if(pVar->vt == VT_EMPTY)
		return MQ_OK;

    if (wcslen( pVar->pwszVal) >= MAX_PATH)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 143);
    }

    MULTICAST_ID id;
    try
    {
        LPCWSTR p = FnParseMulticastString(pVar->pwszVal, &id);
		if(*p != L'\0')
			return MQ_ERROR_ILLEGAL_PROPERTY_VALUE;
    }
    catch (const exception&)
    {
        return MQ_ERROR_ILLEGAL_PROPERTY_VALUE;
    }

    return MQ_OK;
}


static HRESULT qAuthValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->bVal != MQ_AUTHENTICATE_NONE) &&
         (pVar->bVal != MQ_AUTHENTICATE))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 150);
    }
    return(MQ_OK);
}

static HRESULT qPrivLevelValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->ulVal != MQ_PRIV_LEVEL_NONE) &&
         (pVar->ulVal != MQ_PRIV_LEVEL_OPTIONAL) &&
         (pVar->ulVal != MQ_PRIV_LEVEL_BODY))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 160);
    }
    return(MQ_OK);
}

static HRESULT qXactionValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->bVal != MQ_TRANSACTIONAL_NONE) &&
         (pVar->bVal != MQ_TRANSACTIONAL))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 170);
    }
    return(MQ_OK);
}

static HRESULT qTypeValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 180);
    }
    return(MQ_OK);
}

static HRESULT qInstanceValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 190);
    }
    return(MQ_OK);
}

static HRESULT qmMachineIdValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 200);
    }
    return(MQ_OK);
}

static HRESULT qmSiteIdValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 210);
    }
    return(MQ_OK);
}

//
//  The offset of property in this array must be equal to
//  PROPID value - PROPID_Q_BASE
//
propValidity    QueueCreateValidation[] =
{
    //                                                ust
    // Property              Allow   Allow    Must    Not     Maybe   Parsing
    // Ientifier             VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //----------------------------------------------------------------------------------
    { 0,                     FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_INSTANCE,      FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_TYPE,          FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_PATHNAME,      FALSE,  FALSE,   TRUE,   FALSE,  FALSE,  NULL},
    {PROPID_Q_JOURNAL,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qJournalValidation},
    {PROPID_Q_QUOTA,         FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_BASEPRIORITY,  FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_JOURNAL_QUOTA, FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_LABEL,         FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qLabelValidation},
    {PROPID_Q_CREATE_TIME,   FALSE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_MODIFY_TIME,   FALSE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_AUTHENTICATE,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qAuthValidation},
    {PROPID_Q_PRIV_LEVEL,    FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qPrivLevelValidation},
    {PROPID_Q_TRANSACTION,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qXactionValidation},
    {PROPID_Q_SCOPE,         FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_QMID,          FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_MASTERID,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SEQNUM,        FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_HASHKEY,       FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_LABEL_HASHKEY, FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NT4ID,         FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_FULL_PATH,     FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_DONOTHING,     FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NAME_SUFFIX,   FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_PATHNAME_DNS,  FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
	{PROPID_Q_MULTICAST_ADDRESS,  
							 FALSE,  TRUE,    FALSE,  FALSE,  FALSE,  qMulticastValidation},
    {PROPID_Q_ADS_PATH,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL}
};

//
//  The offset of property in this array must be equal to
//  PROPID value - PROPID_Q_BASE
//

propValidity    QueueSetValidation[] =
{
    //                                                Must
    // Property              Allow   Allow    Must    Not     Maybe   Parsing
    // Ientifier             VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //----------------------------------------------------------------------------------
    { 0,                     FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_INSTANCE,      FALSE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_TYPE,          FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_PATHNAME,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_JOURNAL,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qJournalValidation},
    {PROPID_Q_QUOTA,         FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_BASEPRIORITY,  FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_JOURNAL_QUOTA, FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_LABEL,         FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qLabelValidation},
    {PROPID_Q_CREATE_TIME,   FALSE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_MODIFY_TIME,   FALSE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_AUTHENTICATE,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qAuthValidation},
    {PROPID_Q_PRIV_LEVEL,    FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  qPrivLevelValidation},
    {PROPID_Q_TRANSACTION,   FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SCOPE,         FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_QMID,          FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_MASTERID,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SEQNUM,        FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_HASHKEY,       FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_LABEL_HASHKEY, FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NT4ID,         FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_FULL_PATH,     FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_DONOTHING,     FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NAME_SUFFIX,   FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_PATHNAME_DNS,  FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
	{PROPID_Q_MULTICAST_ADDRESS,  
							 FALSE,  TRUE,    FALSE,  FALSE,  FALSE,  qMulticastValidation},
    {PROPID_Q_ADS_PATH,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL}
};

//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_Q_BASE
//

propValidity    QueueGetValidation[] =
{
    //                                                Must
    // Property              Allow   Allow    Must    Not     Maybe   Parsing
    // Ientifier             VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //----------------------------------------------------------------------------------
    { 0,                     TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_INSTANCE,      TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   qInstanceValidation},
    {PROPID_Q_TYPE,          TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  qTypeValidation},
    {PROPID_Q_PATHNAME,      TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_JOURNAL,       TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_QUOTA,         TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_BASEPRIORITY,  TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_JOURNAL_QUOTA, TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_LABEL,         TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_CREATE_TIME,   TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_MODIFY_TIME,   TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_AUTHENTICATE,  TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_PRIV_LEVEL,    TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_TRANSACTION,   TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_SCOPE,         FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_QMID,          FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_MASTERID,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SEQNUM,        FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_HASHKEY,       FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_LABEL_HASHKEY, FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NT4ID,         FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_FULL_PATH,     FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_DONOTHING,     FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NAME_SUFFIX,   FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_PATHNAME_DNS,  TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
	{PROPID_Q_MULTICAST_ADDRESS,  
							 TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_ADS_PATH,      TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL}
};

VARTYPE QueueVarTypes[] =
{
    0,
    VT_CLSID,   //PROPID_Q_INSTANCE
    VT_CLSID,   //PROPID_Q_TYPE
    VT_LPWSTR,  //PROPID_Q_PATHNAME
    VT_UI1,     //PROPID_Q_JOURNAL
    VT_UI4,     //PROPID_Q_QUOTA
    VT_I2,      //PROPID_Q_BASEPRIORITY
    VT_UI4,     //PROPID_Q_JOURNAL_QUOTA
    VT_LPWSTR,  //PROPID_Q_LABEL
    VT_I4,      //PROPID_Q_CREATE_TIME
    VT_I4,      //PROPID_Q_MODIFY_TIME
    VT_UI1,     //PROPID_Q_AUTHENTICATE
    VT_UI4,     //PROPID_Q_PRIV_LEVEL
    VT_UI1,     //PROPID_Q_TRANSACTION
    VT_UI1,     //PROPID_Q_SCOPE
    VT_CLSID,   //PROPID_Q_QMID
    VT_CLSID,   //PROPID_Q_MASTERID
    VT_BLOB,    //PROPID_Q_SEQNUM
    VT_UI4,     //PROPID_Q_HASHKEY
    VT_UI4,     //PROPID_Q_LABEL_HASHKEY
    VT_CLSID,   //PROPID_Q_NT4ID
    VT_LPWSTR,  //PROPID_Q_FULL_PATH
    VT_UI1,     //PROPID_Q_DONOTHING
    VT_LPWSTR,  //PROPID_Q_NAME_SUFFIX
    VT_LPWSTR,  //PROPID_Q_PATHNAME_DNS
	VT_LPWSTR,	//PROPID_Q_MULTICAST_ADDRESS
    VT_LPWSTR   //PROPID_Q_ADS_PATH
};

VARTYPE GetQueuePropsVarTypes[] =
{
    0,
    VT_CLSID,   //PROPID_Q_INSTANCE
    VT_CLSID,   //PROPID_Q_TYPE
    VT_NULL,    //PROPID_Q_PATHNAME
    VT_UI1,     //PROPID_Q_JOURNAL
    VT_UI4,     //PROPID_Q_QUOTA
    VT_I2,      //PROPID_Q_BASEPRIORITY
    VT_UI4,     //PROPID_Q_JOURNAL_QUOTA
    VT_NULL,    //PROPID_Q_LABEL
    VT_I4,      //PROPID_Q_CREATE_TIME
    VT_I4,      //PROPID_Q_MODIFY_TIME
    VT_UI1,     //PROPID_Q_AUTHENTICATE
    VT_UI4,     //PROPID_Q_PRIV_LEVEL
    VT_UI1,     //PROPID_Q_TRANSACTION
    VT_UI1,     //PROPID_Q_SCOPE
    VT_CLSID,   //PROPID_Q_QMID
    VT_CLSID,   //PROPID_Q_MASTERID
    VT_NULL,    //PROPID_Q_SEQNUM
    VT_UI4,     //PROPID_Q_HASHKEY
    VT_UI4,     //PROPID_Q_LABEL_HASHKEY
    VT_CLSID,   //PROPID_Q_NT4ID
    VT_NULL,    //PROPID_Q_FULL_PATH
    VT_UI1,     //PROPID_Q_DONOTHING
    VT_NULL,    //PROPID_Q_NAME_SUFFIX
    VT_NULL,    //PROPID_Q_PATHNAME_DNS
	VT_NULL,	//PROPID_Q_MULTICAST_ADDRESS
    VT_NULL     //PROPID_Q_ADS_PATH
};

static
void
RemovePropWarnings(
    IN  MQQUEUEPROPS*  pqp,
    IN  HRESULT*       aStatus,
    OUT MQQUEUEPROPS** ppGoodProps,
    OUT char**         ppTmpBuff)
{
    DWORD i;
    DWORD cGoodProps;
    char *pTmpBuff;
    MQQUEUEPROPS *pGoodProps;
    HRESULT *pStatus;
    QUEUEPROPID *pPropId;
    MQPROPVARIANT *pPropVar;

    // See how many good properties do we have.
    for (i = 0, cGoodProps = 0, pStatus = aStatus;
         i < pqp->cProp;
         i++, pStatus++)
    {
        if (*pStatus != MQ_OK)
        {
            ASSERT(!FAILED(*pStatus));
        }
        else
        {
            cGoodProps++;
        }
    }

    // Allocate the temporary buffer, the buffer contains everything in it.
    // It contains the MQQUEUEPROPS structure, the QUEUEPROPID and
    // MQPROPVARIANT arrays.
    pTmpBuff = new char[sizeof(MQQUEUEPROPS) +
                        cGoodProps * sizeof(QUEUEPROPID) +
                        cGoodProps * sizeof(MQPROPVARIANT)];
    *ppTmpBuff = pTmpBuff;

    pGoodProps = (MQQUEUEPROPS*)pTmpBuff;
    *ppGoodProps = pGoodProps;

    //
    // Initialize the MQQUEUEPROPS structure.
    //
    // N.B. To avoid alignment fault the MQPROPVARIANT array is alocated before
    //      The QUEUEPROPID.
    //
    pGoodProps->cProp = cGoodProps;
    pGoodProps->aPropID = (QUEUEPROPID*)(pTmpBuff + sizeof(MQQUEUEPROPS) + cGoodProps * sizeof(MQPROPVARIANT));
    pGoodProps->aPropVar = (MQPROPVARIANT*)(pTmpBuff + sizeof(MQQUEUEPROPS));

    // Copy the array entries of the good properties to the arrays in the
    // temporary buffer.
    for (i = 0, cGoodProps = 0, pStatus = aStatus,
            pPropId = pqp->aPropID, pPropVar = pqp->aPropVar;
         i < pqp->cProp;
         i++, pStatus++, pPropId++, pPropVar++)
    {
        if (*pStatus == MQ_OK)
        {
            pGoodProps->aPropID[cGoodProps] = *pPropId;
            pGoodProps->aPropVar[cGoodProps] = *pPropVar;
            cGoodProps++;
        }
    }
}

static DWORD g_dwNumberOfMustPropsInCreate = 0xffff;
static DWORD g_dwNumberOfMustPropsInSet = 0xffff;

HRESULT
RTpCheckQueueProps(
    IN  MQQUEUEPROPS*  pqp,
    IN  DWORD          dwOp,
    IN  BOOL           fPrivateQueue,
    OUT MQQUEUEPROPS** ppGoodQP,
    OUT char**         ppTmpBuff
    )
{
    HRESULT hr = MQ_OK;
    propValidity *ppropValidity = 0;
    DWORD dwNumberOfMustProps = 0;
    VARTYPE *QueuePropVars = 0;

    if (!pqp)
    {
        return LogHR(MQ_ERROR_ILLEGAL_MQQUEUEPROPS, s_FN, 220);
    }

    //
    //  Calculating the number of "must" properties for create and set
    //  this is done only once for each operation.
    //

    switch (dwOp)
    {
    case QUEUE_CREATE:
        ppropValidity = QueueCreateValidation;
        if (g_dwNumberOfMustPropsInCreate == 0xffff)
        {
            g_dwNumberOfMustPropsInCreate =
                CalNumberOfMust( QueueCreateValidation,
                                 LAST_Q_PROPID - PROPID_Q_BASE + 1);
        }
        dwNumberOfMustProps = g_dwNumberOfMustPropsInCreate;
        QueuePropVars = QueueVarTypes;
        break;

    case QUEUE_SET_PROPS:
        ppropValidity = QueueSetValidation;
        if (g_dwNumberOfMustPropsInSet == 0xffff)
        {
            g_dwNumberOfMustPropsInSet =
                CalNumberOfMust( QueueSetValidation,
                                 LAST_Q_PROPID - PROPID_Q_BASE + 1);
        }
        dwNumberOfMustProps = g_dwNumberOfMustPropsInSet;
        QueuePropVars = QueueVarTypes;
        break;

    case QUEUE_GET_PROPS:
        {
            //
            //  Clear all the pointers of VT_NULL variants
            //  and make the structure ready for RPC call
            //
            for (UINT i = 0; i < pqp->cProp; i++)
            {
                if (pqp->aPropVar[i].vt == VT_NULL)
                {
                    memset(&pqp->aPropVar[i].caub, 0, sizeof(CAUB));
                }
            }
        }

        ppropValidity = QueueGetValidation;
        dwNumberOfMustProps = 0;
        QueuePropVars = GetQueuePropsVarTypes;
        break;

    default:
        ASSERT(0);
        return MQ_ERROR;
    }

    HRESULT *aLocalStatus_buff = NULL;

    __try
    {
        __try
        {
            HRESULT *aLocalStatus;

            // We must have a status array, even if the user didn't pass one. This is in
            // order to be able to tell whether each propery is good or not.
            if (!pqp->aStatus)
            {
                aLocalStatus_buff = new HRESULT[pqp->cProp];
                aLocalStatus = aLocalStatus_buff;
            }
            else
            {
                aLocalStatus = pqp->aStatus;
            }

            hr = CheckProps(pqp->cProp,
                            pqp->aPropID,
                            pqp->aPropVar,
                            aLocalStatus,
                            PROPID_Q_BASE,
                            LAST_Q_PROPID,
                            ppropValidity,
                            QueuePropVars,
                            fPrivateQueue,
                            dwNumberOfMustProps,
                            NULL);

            if (SUCCEEDED(hr))
            {
                if (hr != MQ_OK)
                {
                    // We have wornings, copy all the good properties to a temporary
                    // buffer so the DS will not have to handle duplicate properties etc.
                    RemovePropWarnings(pqp, aLocalStatus, ppGoodQP, ppTmpBuff);
                }
                else
                {
                    // All is perfectly well, we do not need a temporary buffer and all
                    // that overhead.
                    *ppGoodQP = pqp;
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing MQQUEUEPROPS structure")));
            DWORD dw = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(dw), s_FN, 230); 
            hr = dw;
        }
    }
    __finally
    {
        delete[] aLocalStatus_buff;
    }

    return LogHR(hr, s_FN, 240);
}

#define VALIDATION_SEND_FLAG_MASK           1
#define VALIDATION_SECURITY_CONTEXT_MASK    2
#define VALIDATION_RESP_QUEUE_MASK          4
#define VALIDATION_ADMIN_QUEUE_MASK         8
#define VALIDATION_RESP_FORMAT_MASK         16

#define SEND_FLAG ((PVALIDATION_CONTEXT)pvContext)->GetSendFlag()
#define SECURITY_CONTEXT_FLAG (((PVALIDATION_CONTEXT)pvContext)->dwFlags & VALIDATION_SECURITY_CONTEXT_MASK)

#define FLAGS (((PVALIDATION_CONTEXT)pvContext)->dwFlags)
#define PMP (((PVALIDATION_CONTEXT)pvContext)->GetMessageProperties())
#define PSENDP (((PVALIDATION_CONTEXT)pvContext)->pSendParams)
#define PRECEIVEP (((PVALIDATION_CONTEXT)pvContext)->pReceiveParams)

#define PSECCTX (((PVALIDATION_CONTEXT)pvContext)->pSecCtx)

class VALIDATION_CONTEXT
{
public:
    VALIDATION_CONTEXT();
    PMQSECURITY_CONTEXT pSecCtx;
    DWORD dwFlags;

    BOOL GetSendFlag()
    {
        return dwFlags & VALIDATION_SEND_FLAG_MASK;
    }

    CACMessageProperties *GetMessageProperties()
    {
        if (GetSendFlag())
        {
            ASSERT(pSendParams);
            return &pSendParams->MsgProps;
        }
        else
        {
            ASSERT(pReceiveParams);
            return &pReceiveParams->MsgProps;
        }
    }

    union
    {
        //
        // Send
        //
        struct
        {
            CACSendParameters *pSendParams;
            CStringsToFree * pResponseStringsToFree;
            CStringsToFree * pAdminStringsToFree;
        };

        //
        // Receive
        //
        CACReceiveParameters *pReceiveParams;
    };

};

typedef VALIDATION_CONTEXT *PVALIDATION_CONTEXT;

VALIDATION_CONTEXT::VALIDATION_CONTEXT() :
    dwFlags(0)
{
}

static HRESULT ParseMsgClass( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        //
        // Check if legal calss
        //
        if(!MQCLASS_IS_VALID(pVar->uiVal))
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 250);
        }
    }
    else
    {
        pVar->vt = VT_UI2;
    }
    PMP->pClass = &pVar->uiVal;

    return (MQ_OK);
}

static HRESULT ParseMsgId(PROPVARIANT* pVar, PVOID pvContext)
{
    if (pVar->caub.cElems != PROPID_M_MSGID_SIZE)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_SIZE, s_FN, 260);
    }

    PMP->ppMessageID = (OBJECTID**) &pVar->caub.pElems;

    return (MQ_OK);
}

static HRESULT ParseMsgCorrelationId(PROPVARIANT* pVar, PVOID pvContext)
{
    if (pVar->caub.cElems != PROPID_M_CORRELATIONID_SIZE)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_SIZE, s_FN, 270);
    }

    PMP->ppCorrelationID = &pVar->caub.pElems;

    return (MQ_OK);
}

static HRESULT ParseMsgPrio( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if ((pVar->bVal < MQ_MIN_PRIORITY) || (MQ_MAX_PRIORITY < pVar->bVal))
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 280);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PMP->pPriority = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSentTime( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PMP->pSentTime = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgVersion( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PMP->pulVersion = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgArrivedTime( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PMP->pArrivedTime = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDelivery( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if ((pVar->bVal != MQMSG_DELIVERY_EXPRESS) &&
            (pVar->bVal != MQMSG_DELIVERY_RECOVERABLE))
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 290);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PMP->pDelivery = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAck( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if(!MQMSG_ACKNOWLEDGMENT_IS_VALID(pVar->bVal))
        {
            //
            // Unknown ACK bits are on.
            //
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 300);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PMP->pAcknowledge = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgJoural( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if (pVar->bVal & ~(MQMSG_JOURNAL_NONE | MQMSG_DEADLETTER | MQMSG_JOURNAL))
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 310);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PMP->pAuditing = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAppSpec( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_UI4;
    }
    PMP->pApplicationTag = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgBody( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->ppBody = &pVar->caub.pElems;
    PMP->ulBodyBufferSizeInBytes = pVar->caub.cElems;
    PMP->ulAllocBodyBufferInBytes = PMP->ulBodyBufferSizeInBytes;

    return (MQ_OK);
}

static HRESULT ParseMsgBodySize( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pBodySize = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLabelSend( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(SEND_FLAG);

    DWORD dwSize = wcslen(pVar->pwszVal) +1;
    if ( dwSize > MQ_MAX_MSG_LABEL_LEN)
    {
        return LogHR(MQ_ERROR_LABEL_TOO_LONG, s_FN, 330);
    }

    PMP->ulTitleBufferSizeInWCHARs = dwSize;
    PMP->ppTitle = &pVar->pwszVal;

    return (MQ_OK);
}


static HRESULT ParseMsgLabelReceive( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    PMP->ppTitle = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLabelLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pulTitleBufferSizeInWCHARs = &pVar->ulVal;

    return (MQ_OK);
}

static 
HRESULT 
RtpParseMsgFormatNamesSend(
    PROPVARIANT* pVar,
    QUEUE_FORMAT **ppMqf,
    DWORD   *pnQueues,
    CStringsToFree &strsToFree,
    BOOL fSupportMqf
    )
{
    AP<QUEUE_FORMAT> pMqf;
    DWORD nQueues;

    BOOL fSuccess;
    fSuccess = FnMqfToQueueFormats(
                    pVar->pwszVal,
                    pMqf,
                    &nQueues,
                    strsToFree
                    );

    if(!fSuccess)
    {
        return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 340);
    }

    if (!fSupportMqf && nQueues > 1)
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 345);
    }

    if (!fSupportMqf && (pMqf[0].GetType() == QUEUE_FORMAT_TYPE_DL || pMqf[0].GetType() == QUEUE_FORMAT_TYPE_MULTICAST))
    {
        return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 346);
    }

    for (DWORD i = 0; i < nQueues; i++)
    {
        QUEUE_FORMAT_TYPE qft = pMqf[i].GetType();
        if( (qft == QUEUE_FORMAT_TYPE_CONNECTOR) ||
            (pMqf[i].Suffix() != QUEUE_SUFFIX_TYPE_NONE)
           )
        {
            return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 350);
        }
    }

    *ppMqf = pMqf.detach();
    *pnQueues = nQueues;

    return(MQ_OK);
}

static HRESULT ParseMsgRespFormatSend(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(SEND_FLAG);

    if (FLAGS & VALIDATION_RESP_QUEUE_MASK)
    {
        //
        // PROPID_M_RESP_QUEUE and PROPID_M_RESP_FORMAT_NAME both exist
        //
        return LogHR(MQ_ERROR_PROPERTIES_CONFLICT, s_FN, 335);
    }

    HRESULT hr = RtpParseMsgFormatNamesSend(
                    pVar,
                    &PSENDP->ResponseMqf,
                    &PSENDP->nResponseMqf,
                    *((PVALIDATION_CONTEXT)pvContext)->pResponseStringsToFree,
                    TRUE
                    );

    if FAILED(hr)
    {
        return hr;
    }
 
    FLAGS |= VALIDATION_RESP_FORMAT_MASK;
    return MQ_OK;
}

static HRESULT ParseMsgRespQueueSend(PROPVARIANT* pVar, PVOID pvContext)
{
    if (FLAGS & VALIDATION_RESP_FORMAT_MASK)
    {
        //
        // PROPID_M_RESP_QUEUE and PROPID_M_RESP_FORMAT_NAME both exist
        //
        return LogHR(MQ_ERROR_PROPERTIES_CONFLICT, s_FN, 800);
    }

    HRESULT hr = RtpParseMsgFormatNamesSend(
                    pVar,
                    &PSENDP->ResponseMqf,
                    &PSENDP->nResponseMqf,
                    *((PVALIDATION_CONTEXT)pvContext)->pResponseStringsToFree,
                    FALSE
                    );

    if FAILED(hr)
    {
        return hr;
    }
 
    FLAGS |= VALIDATION_RESP_QUEUE_MASK;
    return MQ_OK;
}

static HRESULT ParseMsgRespQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    PRECEIVEP->ppResponseFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgRespQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PRECEIVEP->pulResponseFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgRespFormatReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    PRECEIVEP->ppResponseMqf = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgRespFormatLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PRECEIVEP->pulResponseMqfLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAdminQueueSend(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(SEND_FLAG);

    HRESULT hr = RtpParseMsgFormatNamesSend(
                    pVar,
                    &PSENDP->AdminMqf,
                    &PSENDP->nAdminMqf,
                    *((PVALIDATION_CONTEXT)pvContext)->pResponseStringsToFree,
                    FALSE
                    );

    if FAILED(hr)
    {
        return hr;
    }

    FLAGS |= VALIDATION_ADMIN_QUEUE_MASK;
    return(MQ_OK);
}

static HRESULT ParseMsgAdminQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    PRECEIVEP->ppAdminFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAdminQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PRECEIVEP->pulAdminFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!(SEND_FLAG));

    PRECEIVEP->ppDestFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG));

    pVar->vt = VT_UI4;
    PRECEIVEP->pulDestFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestFormatReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!(SEND_FLAG));

    PRECEIVEP->ppDestMqf = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestFormatLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG));

    pVar->vt = VT_UI4;
    PRECEIVEP->pulDestMqfLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLookupId( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG));

    pVar->vt = VT_UI8;
    PMP->pLookupId = &pVar->uhVal.QuadPart;

    return (MQ_OK);
}

static HRESULT ParseMsgXactStatusQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!(SEND_FLAG));

    PRECEIVEP->ppOrderingFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgXactStatusQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG));

    pVar->vt = VT_UI4;
    PRECEIVEP->pulOrderingFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSrcMachineId( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;
    PMP->ppSrcQMID = &pVar->puuid;

    return (MQ_OK);
}

static HRESULT ParseMsgTimeToLive( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        PMP->ulRelativeTimeToLive = pVar->ulVal ;
    }
    else
    {
        pVar->vt = VT_UI4;
        PMP->pulRelativeTimeToLive = &pVar->ulVal;
    }
    return (MQ_OK);
}

static HRESULT ParseMsgTimeToQueue( PROPVARIANT * pVar, PVOID pvContext )
{
    if(SEND_FLAG)
    {
        PMP->ulAbsoluteTimeToQueue = pVar->ulVal ;
    }
    else
    {
        pVar->vt = VT_UI4;
        PMP->pulRelativeTimeToQueue = &pVar->ulVal;
    }
    return (MQ_OK);
}

static HRESULT ParseMsgTrace( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if (pVar->bVal & ~(MQMSG_TRACE_NONE | MQMSG_SEND_ROUTE_TO_REPORT_QUEUE))
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 375);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PMP->pTrace = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestSymmKey( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->ppSymmKeys = &pVar->caub.pElems;
    PMP->ulSymmKeysSize = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgDestSymmKeyLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pulSymmKeysSizeProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSignature( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->ppSignature = &pVar->caub.pElems;
    PMP->ulSignatureSize = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgSignatureLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pulSignatureSizeProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderId( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->ppSenderID = &pVar->caub.pElems;
    PMP->uSenderIDLen = (WORD)((pVar->caub.cElems > 0xffff) ? 0xffff : pVar->caub.cElems);

    return (MQ_OK);
}

static HRESULT ParseMsgSenderIdLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pulSenderIDLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderIdType( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if ((pVar->ulVal != MQMSG_SENDERID_TYPE_NONE) &&
            (pVar->ulVal != MQMSG_SENDERID_TYPE_SID))
        {
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 380);
        }
    }
    else
    {
        pVar->vt = VT_UI4;
    }

    PMP->pulSenderIDType = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderCert( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->ppSenderCert = &pVar->caub.pElems;
    PMP->ulSenderCertLen = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderCertLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pulSenderCertLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgPrivLevel( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        switch (pVar->ulVal)
        {
        case MQMSG_PRIV_LEVEL_NONE:
        case MQMSG_PRIV_LEVEL_BODY_BASE:
        case MQMSG_PRIV_LEVEL_BODY_ENHANCED:
            break;

        default:
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 400);
        }
    }
    else
    {
        pVar->vt = VT_UI4;
    }

    PMP->pulPrivLevel = &pVar->ulVal;

    return(MQ_OK);
}

static HRESULT ParseMsgEncryptAlg( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        switch (pVar->ulVal)
        {
        case CALG_RC2:
        case CALG_RC4:
            break;

        default:
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 410);
            break;
        }
    }

    PMP->pulEncryptAlg = &pVar->ulVal;

    return(MQ_OK);
}

static HRESULT ParseMsgAuthLevel( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(SEND_FLAG);

	
	if((!IS_VALID_AUTH_LEVEL(pVar->ulVal)) ||
	   (IS_AUTH_LEVEL_ALWAYS_BIT(pVar->ulVal) && (pVar->ulVal != MQMSG_AUTH_LEVEL_ALWAYS)))
	{
		//
		// Allow only AUTH_LEVEL_MASK bits to be set
		// and MQMSG_AUTH_LEVEL_ALWAYS bit can not be set with other bits
		//
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 420);
	}

    PMP->ulAuthLevel = pVar->ulVal;

    return MQ_OK;
}

static HRESULT ParseMsgHashAlg( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->pulHashAlg = &pVar->ulVal;

    return(MQ_OK);
}

static HRESULT ParseMsgAuthenticated( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    if (PMP->pAuthenticated)
    {
        //
        // can not request both m_authenticated and m_authenticated_Ex
        //
        return MQ_ERROR_PROPERTY ;
    }

    pVar->vt = VT_UI1;
    PMP->pAuthenticated = &pVar->bVal;
    //
    // Tell driver we want only the m_authenticated property
    //
    *(PMP->pAuthenticated) = MQMSG_AUTHENTICATION_REQUESTED ;

    return (MQ_OK);
}

static HRESULT ParseMsgAuthenticatedEx( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    if (PMP->pAuthenticated)
    {
        //
        // can not request both m_authenticated and m_authenticated_Ex
        //
        return MQ_ERROR_PROPERTY ;
    }

    pVar->vt = VT_UI1;
    PMP->pAuthenticated = &pVar->bVal;
    //
    // Tell driver we want the m_authenticated_ex property
    //
    *(PMP->pAuthenticated) = MQMSG_AUTHENTICATION_REQUESTED_EX ;

    return (MQ_OK);
}

static HRESULT ParseMsgExtension( PROPVARIANT * pVar, PVOID pvContext)
{
    PMP->ppMsgExtension = &pVar->caub.pElems;
    PMP->ulMsgExtensionBufferInBytes = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgExtensionLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PMP->pMsgExtensionSize = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSecurityContext( PROPVARIANT *pVar, PVOID pvContext )
{
    ASSERT(SEND_FLAG);

    // NULL security context is ignored...
    if (pVar->ulVal == NULL) {
      return LogHR(MQ_INFORMATION_PROPERTY_IGNORED, s_FN, 430);
    }

    PMQSECURITY_CONTEXT pSecCtx;
    try
    {
        pSecCtx = (PMQSECURITY_CONTEXT)
            GET_FROM_CONTEXT_MAP(g_map_RT_SecCtx, pVar->ulVal, s_FN, 431);//this may throw on win64
    }
    catch(...)
    {
        return LogHR(MQ_ERROR_BAD_SECURITY_CONTEXT, s_FN, 435);
    }

    if (pSecCtx->dwVersion != SECURITY_CONTEXT_VER)
    {
        return LogHR(MQ_ERROR_BAD_SECURITY_CONTEXT, s_FN, 440);
    }

    PSECCTX = pSecCtx;
    FLAGS |= VALIDATION_SECURITY_CONTEXT_MASK;

    return(MQ_OK);
}

static HRESULT ParseMsgConnectorType( PROPVARIANT * pVar, PVOID pvContext )
{
    PMP->ppConnectorType = &pVar->puuid;

    return (MQ_OK);
}

static HRESULT ParseMsgBodyType( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_UI4;
    }
    PMP->pulBodyType = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgProviderType( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_UI4;
    }

    PMP->pulProvType = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgProviderName( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_LPWSTR;
    }

    PMP->ppwcsProvName = &pVar->pwszVal;
    return (MQ_OK);
}

static HRESULT ParseMsgProviderNameLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pulAuthProvNameLenProp = &pVar->ulVal;
    PMP->ulProvNameLen = pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgFirstInXact( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI1;
    PMP->pbFirstInXact = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLastInXact( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI1;
    PMP->pbLastInXact = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgXactId( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    if (pVar->caub.cElems != PROPID_M_XACTID_SIZE)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_SIZE, s_FN, 450);
    }

    PMP->ppXactID = (OBJECTID**) &pVar->caub.pElems;

    return (MQ_OK);
}
  
static HRESULT ParseMsgEnvelopeReceive(PROPVARIANT * pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    PMP->ppSrmpEnvelope = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgEnvelopeLenReceive(PROPVARIANT * pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pSrmpEnvelopeBufferSizeInWCHARs = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseCompoundMessageReceive(PROPVARIANT *pVar, PVOID pvContext)
{
    PMP->ppCompoundMessage = &pVar->caub.pElems;
    PMP->CompoundMessageSizeInBytes = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseCompoundMessageSizeReceive(PROPVARIANT *pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PMP->pCompoundMessageSizeInBytes = &pVar->ulVal;

    return (MQ_OK);
}


static HRESULT ValidateXmlFormat(LPCWSTR pStr)
{
    CAutoXmlNode pTree;
    try
    {
       int len  = wcslen(pStr);
       XmlParseDocument(xwcs_t(pStr, len), &pTree);
       return MQ_OK;
    }
    catch(const bad_document& )
    {
        return MQ_ERROR_BAD_XML_FORMAT;
    }
}


static HRESULT ParseSoapHeader(PROPVARIANT *pVar, PVOID pvContext)
{
    ASSERT(SEND_FLAG);
    HRESULT hr = ValidateXmlFormat(pVar->pwszVal);
    if(FAILED(hr))
        return LogHR(hr, s_FN, 455);
    
    PSENDP->ppSoapHeader = &pVar->pwszVal;
    return MQ_OK;

}


static HRESULT ParseSoapBody(PROPVARIANT *pVar, PVOID pvContext)
{
    ASSERT(SEND_FLAG);
   
    PSENDP->ppSoapBody = &pVar->pwszVal;
    return MQ_OK;

}


//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_M_BASE
//

propValidity    MessageSendValidation[] =
{
    //                                                   Must
    // Property                 Allow   Allow    Must    Not     Maybe   Parsing
    // Identifier               VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_CLASS,           FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgClass},
    { PROPID_M_MSGID,           FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgId},
    { PROPID_M_CORRELATIONID,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgCorrelationId},
    { PROPID_M_PRIORITY,        FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgPrio},
    { PROPID_M_DELIVERY,        FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDelivery},
    { PROPID_M_ACKNOWLEDGE,     FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAck},
    { PROPID_M_JOURNAL,         FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgJoural},
    { PROPID_M_APPSPECIFIC,     FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAppSpec},
    { PROPID_M_BODY,            FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgBody},
    { PROPID_M_BODY_SIZE,       FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_LABEL,           FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgLabelSend},
    { PROPID_M_LABEL_LEN,       FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_TIME_TO_REACH_QUEUE,
								FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgTimeToQueue},
    { PROPID_M_TIME_TO_BE_RECEIVED,
								FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgTimeToLive},
    { PROPID_M_RESP_QUEUE,      FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgRespQueueSend},
    { PROPID_M_RESP_QUEUE_LEN,  FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_ADMIN_QUEUE,     FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAdminQueueSend},
    { PROPID_M_ADMIN_QUEUE_LEN, FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_VERSION,         FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SENDERID,        FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderId},
    { PROPID_M_SENDERID_LEN,    FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SENDERID_TYPE,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderIdType},
    { PROPID_M_PRIV_LEVEL,      FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgPrivLevel},
    { PROPID_M_AUTH_LEVEL,      FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAuthLevel},
    { PROPID_M_AUTHENTICATED,   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_HASH_ALG,        FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgHashAlg},
    { PROPID_M_ENCRYPTION_ALG,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgEncryptAlg},
    { PROPID_M_SENDER_CERT,     FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderCert},
    { PROPID_M_SENDER_CERT_LEN, FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SRC_MACHINE_ID,  FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SENTTIME,        FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_ARRIVEDTIME,     FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_DEST_QUEUE,      FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_DEST_QUEUE_LEN,  FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_EXTENSION,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgExtension},
    { PROPID_M_EXTENSION_LEN,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_M_SECURITY_CONTEXT,FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSecurityContext},
    { PROPID_M_CONNECTOR_TYPE,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgConnectorType},

    //                                                          Must
    // Property                        Allow   Allow    Must    Not     Maybe   Parsing
    // Identifier                      VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------
    { PROPID_M_XACT_STATUS_QUEUE,      FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_XACT_STATUS_QUEUE_LEN,  FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_TRACE,                  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgTrace},
    { PROPID_M_BODY_TYPE,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgBodyType},
    { PROPID_M_DEST_SYMM_KEY,          FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestSymmKey},
    { PROPID_M_DEST_SYMM_KEY_LEN,      FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SIGNATURE,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSignature},
    { PROPID_M_SIGNATURE_LEN,          FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_PROV_TYPE,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderType},
    { PROPID_M_PROV_NAME,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderName},
    { PROPID_M_PROV_NAME_LEN,          FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_FIRST_IN_XACT,          FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_LAST_IN_XACT,           FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_XACTID,                 FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_AUTHENTICATED_EX,       FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_RESP_FORMAT_NAME,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgRespFormatSend},
    { PROPID_M_RESP_FORMAT_NAME_LEN,   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { 0,							   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL}, //Place holder for future property
    { 0,							   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL}, //Place holder for future property
    { PROPID_M_DEST_FORMAT_NAME,       FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_DEST_FORMAT_NAME_LEN,   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_LOOKUPID,               FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SOAP_ENVELOPE,          FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    { PROPID_M_SOAP_ENVELOPE_LEN,      FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    { PROPID_M_COMPOUND_MESSAGE,       FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    { PROPID_M_COMPOUND_MESSAGE_SIZE,  FALSE,  FALSE,   FALSE,  TRUE,   FALSE,  NULL},
    { PROPID_M_SOAP_HEADER,            FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseSoapHeader}, 
    { PROPID_M_SOAP_BODY,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseSoapBody},

};

//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_M_BASE
//

propValidity    MessageReceiveValidation[] =
{
    //                                                   Must
    // Property                 Allow   Allow    Must    Not     Maybe   Parsing
    // Identifier               VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_CLASS,           TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgClass},
    { PROPID_M_MSGID,           FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgId},
    { PROPID_M_CORRELATIONID,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgCorrelationId},
    { PROPID_M_PRIORITY,        TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgPrio},
    { PROPID_M_DELIVERY,        TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDelivery},
    { PROPID_M_ACKNOWLEDGE,     TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAck},
    { PROPID_M_JOURNAL,         TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgJoural},
    { PROPID_M_APPSPECIFIC,     TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAppSpec},
    { PROPID_M_BODY,            FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgBody},
    { PROPID_M_BODY_SIZE,       TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgBodySize},
    { PROPID_M_LABEL,           FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgLabelReceive},
    { PROPID_M_LABEL_LEN,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgLabelLen},
    { PROPID_M_TIME_TO_REACH_QUEUE,
								FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgTimeToQueue},
    { PROPID_M_TIME_TO_BE_RECEIVED,
								FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgTimeToLive},
    { PROPID_M_RESP_QUEUE,      FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgRespQueueReceive},
    { PROPID_M_RESP_QUEUE_LEN,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgRespQueueLen},
    { PROPID_M_ADMIN_QUEUE,     FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAdminQueueReceive},
    { PROPID_M_ADMIN_QUEUE_LEN, FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAdminQueueLen},
    { PROPID_M_VERSION,         FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgVersion},
    { PROPID_M_SENDERID,        FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderId},
    { PROPID_M_SENDERID_LEN,    TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderIdLen},
    { PROPID_M_SENDERID_TYPE,   TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderIdType},
    { PROPID_M_PRIV_LEVEL,      TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgPrivLevel},
    { PROPID_M_AUTH_LEVEL,      TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_AUTHENTICATED,   TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAuthenticated},
    { PROPID_M_HASH_ALG,        TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgHashAlg},
    { PROPID_M_ENCRYPTION_ALG,  TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgEncryptAlg},
    { PROPID_M_SENDER_CERT,     FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderCert},
    { PROPID_M_SENDER_CERT_LEN, TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderCertLen},
    { PROPID_M_SRC_MACHINE_ID,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSrcMachineId},
    { PROPID_M_SENTTIME,        TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSentTime},
    { PROPID_M_ARRIVEDTIME,     TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgArrivedTime},
    { PROPID_M_DEST_QUEUE,      FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestQueueReceive},
    { PROPID_M_DEST_QUEUE_LEN,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestQueueLen},
    { PROPID_M_EXTENSION,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgExtension},
    { PROPID_M_EXTENSION_LEN,   TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgExtensionLen},
    { PROPID_M_SECURITY_CONTEXT,TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_CONNECTOR_TYPE,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgConnectorType},
    //                                                          Must
    // Property                        Allow   Allow    Must    Not     Maybe   Parsing
    // Identifier                      VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------
    { PROPID_M_XACT_STATUS_QUEUE,      FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgXactStatusQueueReceive},
    { PROPID_M_XACT_STATUS_QUEUE_LEN,  FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgXactStatusQueueLen},
    { PROPID_M_TRACE,                  TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgTrace},
    { PROPID_M_BODY_TYPE,              TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgBodyType},
    { PROPID_M_DEST_SYMM_KEY,          FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestSymmKey},
    { PROPID_M_DEST_SYMM_KEY_LEN,      TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestSymmKeyLen},
    { PROPID_M_SIGNATURE,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSignature},
    { PROPID_M_SIGNATURE_LEN,          TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgSignatureLen},
    { PROPID_M_PROV_TYPE,              TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderType},
    { PROPID_M_PROV_NAME,              FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderName},
    { PROPID_M_PROV_NAME_LEN,          TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderNameLen},
    { PROPID_M_FIRST_IN_XACT,          TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgFirstInXact},
    { PROPID_M_LAST_IN_XACT,           TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgLastInXact},
    { PROPID_M_XACTID,                 TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgXactId},
    { PROPID_M_AUTHENTICATED_EX,       TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgAuthenticatedEx},
    { PROPID_M_RESP_FORMAT_NAME,	   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgRespFormatReceive},
    { PROPID_M_RESP_FORMAT_NAME_LEN,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgRespFormatLen},
    { 0,							   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL}, //Place holder for future property
    { 0,							   FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL}, //Place holder for future property
    { PROPID_M_DEST_FORMAT_NAME,	   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestFormatReceive},
    { PROPID_M_DEST_FORMAT_NAME_LEN,   FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgDestFormatLen},
    { PROPID_M_LOOKUPID,               TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgLookupId},
    { PROPID_M_SOAP_ENVELOPE,          FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgEnvelopeReceive},
    { PROPID_M_SOAP_ENVELOPE_LEN,      TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseMsgEnvelopeLenReceive},
    { PROPID_M_COMPOUND_MESSAGE,       FALSE,  FALSE,   FALSE,  FALSE,  FALSE,  ParseCompoundMessageReceive},
    { PROPID_M_COMPOUND_MESSAGE_SIZE,  TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  ParseCompoundMessageSizeReceive},
    { PROPID_M_SOAP_HEADER,            TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL}, 
    { PROPID_M_SOAP_BODY,              TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL},
};


VARTYPE MessageVarTypes[] =
{
    0,
    VT_UI2,                 //PROPID_M_CLASS
    VT_VECTOR | VT_UI1,     //PROPID_M_MSGID
    VT_VECTOR | VT_UI1,     //PROPID_M_CORRELATIONID
    VT_UI1,                 //PROPID_M_PRIORITY
    VT_UI1,                 //PROPID_M_DELIVERY
    VT_UI1,                 //PROPID_M_ACKNOWLEDGE
    VT_UI1,                 //PROPID_M_JOURNAL
    VT_UI4,                 //PROPID_M_APPSPECIFIC
    VT_VECTOR | VT_UI1,     //PROPID_M_BODY
    VT_UI4,                 //PROPID_M_BODY_SIZE
    VT_LPWSTR,              //PROPID_M_LABEL
    VT_UI4,                 //PROPID_M_LABEL_LEN  // BUGBUG not implemented yet
    VT_UI4,                 //PROPID_M_TIME_TO_REACH_QUEUE
    VT_UI4,                 //PROPID_M_TIME_TO_BE_RECEIVED
    VT_LPWSTR,              //PROPID_M_RESP_QUEUE
    VT_UI4,                 //PROPID_M_RESP_QUEUE_LEN
    VT_LPWSTR,              //PROPID_M_ADMIN_QUEUE
    VT_UI4,                 //PROPID_M_ADMIN_QUEUE_LEN
    VT_UI4,                 //PROPID_M_VERSION
    VT_VECTOR | VT_UI1,     //PROPID_M_SENDERID
    VT_UI4,                 //PROPID_M_SENDERID_LEN
    VT_UI4,                 //PROPID_M_SENDERID_TYPE
    VT_UI4,                 //PROPID_M_PRIV_LEVEL
    VT_UI4,                 //PROPID_M_AUTH_LEVEL
    VT_UI1,                 //PROPID_M_AUTHENTICATED
    VT_UI4,                 //PROPID_M_HASH_ALG
    VT_UI4,                 //PROPID_M_ENCRYPTION_ALG
    VT_VECTOR | VT_UI1,     //PROPID_M_SENDER_CERT
    VT_UI4,                 //PROPID_M_SENDER_CERT_LEN
    VT_CLSID,               //PROPID_M_SRC_MACHINE_ID
    VT_UI4,                 //PROPID_M_SENTTIME
    VT_UI4,                 //PROPID_M_ARRIVEDTIME
    VT_LPWSTR,              //PROPID_M_DEST_QUEUE
    VT_UI4,                 //PROPID_M_DEST_QUEUE_LEN
    VT_VECTOR | VT_UI1,     //PROPID_M_EXTENSION
    VT_UI4,                 //PROPID_M_EXTENSION_LEN
    VT_UI4,                 //PROPID_M_SECURITY_CONTEXT
    VT_CLSID,               //PROPID_M_CONNECTOR_TYPE
    VT_LPWSTR,              //PROPID_M_XACT_STATUS_QUEUE
    VT_UI4,                 //PROPID_M_XACT_STATUS_QUEUE_LEN
    VT_UI1,                 //PROPID_M_TRACE
    VT_UI4,                 //PROPID_M_BODY_TYPE
    VT_VECTOR | VT_UI1,     //PROPID_M_DEST_SYMM_KEY
    VT_UI4,                 //PROPID_M_DEST_SYMM_KEY_LEN
    VT_VECTOR | VT_UI1,     //PROPID_M_SIGNATURE
    VT_UI4,                 //PROPID_M_SIGNATURE_LEN
    VT_UI4,                 //PROPID_M_PROV_TYPE
    VT_LPWSTR,              //PROPID_M_PROV_NAME
    VT_UI4,                 //PROPID_M_PROV_NAME_LEN
    VT_UI1,                 //PROPID_M_FIRST_IN_XACT
    VT_UI1,                 //PROPID_M_LAST_IN_XACT
    VT_UI1|VT_VECTOR,       //PROPID_M_XACTID
    VT_UI1,                 //PROPID_M_AUTHENTICATED_EX
    VT_LPWSTR,              //PROPID_M_RESP_FORMAT_NAME.
    VT_UI4,                 //PROPID_M_RESP_FORMAT_NAME_LEN
	0,						//Place holder for future property
	0,						//Place holder for future property
    VT_LPWSTR,              //PROPID_M_DEST_FORMAT_NAME
    VT_UI4,                 //PROPID_M_DEST_FORMAT_NAME_LEN
    VT_UI8,                 //PROPID_M_LOOKUPID
    VT_LPWSTR,              //PROPID_M_SOAP_ENVELOPE
    VT_UI4,                 //PROPID_M_SOAP_ENVELOPE_LEN
    VT_VECTOR | VT_UI1,     //PROPID_M_COMPOUND_MESSAGE
    VT_UI4,                 //PROPID_M_COMPOUND_MESSAGE_SIZE
    VT_LPWSTR,              //PROPID_M_SOAP_HEADER 
    VT_LPWSTR,              //PROPID_M_SOAP_BODY 
};

#ifdef _DEBUG
//
// the following are complie time asserts, to verify the arrays size are
// correct and arrays include all properties.
//
#define _EXPECTEDSIZE  (LAST_M_PROPID - PROPID_M_BASE + 1)
#define _SENDSIZE  (sizeof(MessageSendValidation) / sizeof(propValidity))
#define _RCVSIZE   (sizeof(MessageReceiveValidation) / sizeof(propValidity))
#define _VARSIZE   (sizeof(MessageVarTypes) / sizeof(VARTYPE))
static int MyAssert1[ _SENDSIZE == _EXPECTEDSIZE ] ;
static int MyAssert2[ _RCVSIZE  == _EXPECTEDSIZE ] ;
static int MyAssert3[ _VARSIZE  == _EXPECTEDSIZE ] ;
#undef _SENDSIZE
#undef _EXPECTEDSIZE
#undef _RCVSIZE
#undef _VARSIZE

#endif // _DEBUG

static DWORD g_dwNumberOfMustPropsInSend = 0xffff;
static DWORD g_dwNumberOfMustPropsInReceive = 0xffff;

HRESULT
RTpParseSendMessageProperties(
    CACSendParameters &SendParams,
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus,
    OUT PMQSECURITY_CONTEXT *ppSecCtx,
    CStringsToFree &ResponseStringsToFree,
    CStringsToFree &AdminStringsToFree
    )
{
    HRESULT hr;
    propValidity *ppropValidity;
    DWORD dwNumberOfMustProps;
    VALIDATION_CONTEXT ValidationContext;

    *ppSecCtx = NULL;

    //
    //  Calculating the number of "must" properties for create and set
    //  this is done only once for each operation.
    //

    ValidationContext.dwFlags = VALIDATION_SEND_FLAG_MASK;
    ValidationContext.pResponseStringsToFree = &ResponseStringsToFree;
    ValidationContext.pAdminStringsToFree = &AdminStringsToFree;
    ValidationContext.pSendParams = &SendParams;

    ppropValidity = MessageSendValidation;
    if (g_dwNumberOfMustPropsInSend == 0xffff)
    {
        g_dwNumberOfMustPropsInSend =
            CalNumberOfMust( MessageSendValidation,
                             LAST_M_PROPID - PROPID_M_BASE + 1);
    }
    dwNumberOfMustProps = g_dwNumberOfMustPropsInSend;

    CACMessageProperties *pmp = &SendParams.MsgProps;

    pmp->ulRelativeTimeToLive  = INFINITE ;
    pmp->ulAbsoluteTimeToQueue = g_dwTimeToReachQueueDefault ;

    if(IsBadReadPtr(pVar, cProp * sizeof(PROPVARIANT)))
    {
        return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 460);
    }

    hr = CheckProps(cProp,
                    pPropid,
                    pVar,
                    pStatus,
                    PROPID_M_BASE,
                    LAST_M_PROPID,
                    ppropValidity,
                    MessageVarTypes,
                    TRUE,
                    dwNumberOfMustProps,
                    &ValidationContext);

    if (SUCCEEDED(hr))
    {
        //
        // Special handling for class. If the calss is specified on send the
        // Connector type property is mandatory.
        //
        if ((pmp->pClass ||  pmp->ppSenderID || pmp->ppSymmKeys || pmp->ppSignature || pmp->ppwcsProvName) &&
            !pmp->ppConnectorType)
        {
            return LogHR(MQ_ERROR_MISSING_CONNECTOR_TYPE, s_FN, 470);
        }

        if ((pmp->ppwcsProvName && !pmp->pulProvType) ||
            (!pmp->ppwcsProvName && pmp->pulProvType))
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 480);
        }
        //
        // If TimeToQueue is greater then TimeToLive then decrement
        // it to equal TimeToLive.
        //
        if ((pmp->ulAbsoluteTimeToQueue == INFINITE) ||
           (pmp->ulAbsoluteTimeToQueue == LONG_LIVED))
        {
          pmp->ulAbsoluteTimeToQueue = g_dwTimeToReachQueueDefault ;
        }

        if (pmp->ulRelativeTimeToLive != INFINITE)
        {
          if (pmp->ulAbsoluteTimeToQueue > pmp->ulRelativeTimeToLive)
          {
             pmp->ulAbsoluteTimeToQueue = pmp->ulRelativeTimeToLive ;
             pmp->ulRelativeTimeToLive = 0 ;
          }
          else
          {
             pmp->ulRelativeTimeToLive -= pmp->ulAbsoluteTimeToQueue ;
          }
        }

        //
        // Conver TimeToQueue, which was relative until now,
        // to absolute
        //
        ULONG utime = MqSysTime() ;
        if (utime > (pmp->ulAbsoluteTimeToQueue + utime))
        {
          //
          // overflow. timeout too long.
          //
          ASSERT(INFINITE == 0xffffffff) ;
          ASSERT(LONG_LIVED == 0xfffffffe) ;

          pmp->ulAbsoluteTimeToQueue = LONG_LIVED - 1 ;
        }
        else
        {
		  pmp->ulAbsoluteTimeToQueue += utime ;
        }

	
		//
		// make sure that trq or tbr(ulRelativeTimeToLive  + ulAbsoluteTimeToQueue)
		// is not more then LONG_MAX. It cause crt time api's to fail.
		//
		if( pmp->ulAbsoluteTimeToQueue  > LONG_MAX)
		{
			pmp->ulAbsoluteTimeToQueue =  LONG_MAX;
			pmp->ulRelativeTimeToLive = 0;
		}	
	 	else
		if(pmp->ulRelativeTimeToLive  + pmp->ulAbsoluteTimeToQueue > LONG_MAX)
		{
			pmp->ulRelativeTimeToLive =  LONG_MAX -  pmp->ulAbsoluteTimeToQueue;
		}




        if (ValidationContext.dwFlags & VALIDATION_SECURITY_CONTEXT_MASK)
        {
          *ppSecCtx = ValidationContext.pSecCtx;
        }

        if (! (ValidationContext.dwFlags & (VALIDATION_RESP_FORMAT_MASK | VALIDATION_RESP_QUEUE_MASK)))
        {
           SendParams.ResponseMqf = 0;
           SendParams.nResponseMqf = 0;
        }
        if (! (ValidationContext.dwFlags & VALIDATION_ADMIN_QUEUE_MASK))
        {
           SendParams.AdminMqf = 0;
           SendParams.nAdminMqf = 0;
        }
    }

    return LogHR(hr, s_FN, 726);
}



HRESULT
RTpParseReceiveMessageProperties(
    CACReceiveParameters &ReceiveParams,
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus
    )
{
    HRESULT hr;
    propValidity *ppropValidity;
    DWORD dwNumberOfMustProps;
    VALIDATION_CONTEXT ValidationContext;

    //
    //  Calculating the number of "must" properties for create and set
    //  this is done only once for each operation.
    //

    ValidationContext.dwFlags = 0;
    ValidationContext.pReceiveParams = &ReceiveParams;

    ppropValidity = MessageReceiveValidation;
    if (g_dwNumberOfMustPropsInReceive == 0xffff)
    {
        g_dwNumberOfMustPropsInReceive =
            CalNumberOfMust( MessageReceiveValidation,
                             LAST_M_PROPID - PROPID_M_BASE + 1);
    }
    dwNumberOfMustProps = g_dwNumberOfMustPropsInReceive;


    __try
    {
        if(IsBadReadPtr(pVar, cProp * sizeof(PROPVARIANT)))
        {
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 760);
        }

        hr = CheckProps(cProp,
                        pPropid,
                        pVar,
                        pStatus,
                        PROPID_M_BASE,
                        LAST_M_PROPID,
                        ppropValidity,
                        MessageVarTypes,
                        TRUE,
                        dwNumberOfMustProps,
                        &ValidationContext);

        if (SUCCEEDED(hr))
        {
            CACMessageProperties *pmp = &ReceiveParams.MsgProps;

            if(ReceiveParams.ppResponseFormatName)
            {
                if(!ReceiveParams.pulResponseFormatNameLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 490);
                }
            }

            if(ReceiveParams.ppAdminFormatName)
            {
                if(!ReceiveParams.pulAdminFormatNameLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 500);
                }
            }

            if(ReceiveParams.ppDestFormatName)
            {
                if(!ReceiveParams.pulDestFormatNameLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 510);
                }
            }

            if(ReceiveParams.ppOrderingFormatName)
            {
                if(!ReceiveParams.pulOrderingFormatNameLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 719);
                }
            }

            if(ReceiveParams.ppDestMqf)
            {
                if(!ReceiveParams.pulDestMqfLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 721);
                }
            }

            if(ReceiveParams.ppResponseMqf)
            {
                if(!ReceiveParams.pulResponseMqfLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 723);
                }
            }

            if(pmp->ppTitle)
            {
                if(!pmp->pulTitleBufferSizeInWCHARs)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 530);
                }
            }

            if(pmp->ppSrmpEnvelope)
            {
                if(!pmp->pSrmpEnvelopeBufferSizeInWCHARs)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 724);
                }
            }

            //
            // in case the provider name is required, the provider name
            // len property is a must.
            //
            if (pmp->ppwcsProvName)
            {
                if (!pmp->pulAuthProvNameLenProp)
                {
                    return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 540);
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing message properties.")));
        DWORD dw = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(dw), s_FN, 550); 
        hr = dw;
    }

    return LogHR(hr, s_FN, 560);
}
//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_QM_BASE
//

propValidity    GetQMValidation[] =
{
    //                                                   Must
    // Property                 Allow   Allow    Must    Not     Maybe   Parsing
    // Ientifier                VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_SITE_ID,        TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  qmSiteIdValidation},
    { PROPID_QM_MACHINE_ID,     TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  qmMachineIdValidation},
    { PROPID_QM_PATHNAME,       TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_QM_CONNECTION,     TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_QM_ENCRYPTION_PK,  TRUE,   FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_ADDRESS,        TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_CNS,            TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OUTFRS,         TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_INFRS,          TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SERVICE,        TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_MASTERID,       TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_HASHKEY,        TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SEQNUM,         TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_QUOTA,          TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_JOURNAL_QUOTA,  TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_MACHINE_TYPE,   TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_CREATE_TIME,    TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_MODIFY_TIME,    TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_FOREIGN,        TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OS,             TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_FULL_PATH,      TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SITE_IDS,       TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OUTFRS_DN,      TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_INFRS_DN,       TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_NT4ID,          TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_DONOTHING,      TRUE,   FALSE,   FALSE,  TRUE,   TRUE,   NULL},

    //                                                          Must
    // Property                        Allow   Allow    Must    Not     Maybe   Parsing
    // Identifier                      VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------

    { PROPID_QM_SERVICE_ROUTING,        TRUE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SERVICE_DSSERVER,       TRUE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SERVICE_DEPCLIENTS,     TRUE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OLDSERVICE,             TRUE,  FALSE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_ENCRYPTION_PK_BASE,     TRUE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_ENCRYPTION_PK_ENHANCED, TRUE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_PATHNAME_DNS,           TRUE,  FALSE,   FALSE,  FALSE,  FALSE,  NULL}
};

VARTYPE GetQMVarTypes[] =
{
    0,
    VT_CLSID,               //PROPID_QM_SITE_ID
    VT_CLSID,               //PROPID_QM_MACHINE_ID
    VT_NULL,                //PROPID_QM_PATHNAME
    VT_NULL,                //PROPID_QM_CONNECTION
    VT_NULL,                //PROPID_QM_ENCRYPTION_PK
    VT_BLOB,                //PROPID_QM_ADDRESS
    VT_CLSID|VT_VECTOR,     //PROPID_QM_CNS
    VT_CLSID|VT_VECTOR,     //PROPID_QM_OUTFRS
    VT_CLSID|VT_VECTOR,     //PROPID_QM_INFRS
    VT_UI4,                 //PROPID_QM_SERVICE
    VT_CLSID,               //PROPID_QM_MASTERID
    VT_UI4,                 //PROPID_QM_HASHKEY
    VT_BLOB,                //PROPID_QM_SEQNUM
    VT_UI4,                 //PROPID_QM_QUOTA
    VT_UI4,                 //PROPID_QM_JOURNAL_QUOTA
    VT_LPWSTR,              //PROPID_QM_MACHINE_TYPE
    VT_I4,                  //PROPID_QM_CREATE_TIME
    VT_I4,                  //PROPID_QM_MODIFY_TIME
    VT_UI1,                 //PROPID_QM_FOREIGN
    VT_UI4,                 //PROPID_QM_OS
    VT_LPWSTR,              //PROPID_QM_FULL_PATH
    VT_CLSID|VT_VECTOR,     //PROPID_QM_SITE_IDS
    VT_LPWSTR|VT_VECTOR,    //PROPID_QM_OUTFRS_DN
    VT_LPWSTR|VT_VECTOR,    //PROPID_QM_INFRS_DN
    VT_CLSID,               //PROPID_QM_NT4ID
    VT_UI1,                 //PROPID_QM_DONOTHING
    VT_UI1,                 //PROPID_QM_SERVICE_ROUTING
    VT_UI1,                 //PROPID_QM_SERVICE_DSSERVER
    VT_UI1,                 //PROPID_QM_SERVICE_DEPCLIENTS
    VT_UI4,                 //PROPID_QM_OLDSERVICE
    VT_NULL,                //PROPID_QM_ENCRYPTION_PK_BASE
    VT_NULL,                //PROPID_QM_ENCRYPTION_PK_ENHANCED
    VT_NULL                 //PROPID_QM_PATHNAME_DNS
};


HRESULT
RTpCheckQMProps(
    IN      MQQMPROPS * pQMProps,
    IN OUT  HRESULT*    aStatus,
    OUT     MQQMPROPS** ppGoodQMP,
    OUT     char**      ppTmpBuff)
{
    HRESULT hr = MQ_OK;

    __try
    {
        //
        //  The user must ask for atleast one property
        //
        if ( (pQMProps == NULL) ||
             (pQMProps->cProp == 0))
        {
            return LogHR(MQ_ERROR_ILLEGAL_MQQMPROPS, s_FN, 570);
        }

        hr = CheckProps(pQMProps->cProp,
                        pQMProps->aPropID,
                        pQMProps->aPropVar,
                        aStatus,
                        PROPID_QM_BASE,
                        LAST_QM_PROPID,
                        GetQMValidation,
                        GetQMVarTypes,
                        TRUE,
                        0,      // zero must properties
                        NULL);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing MQQMPROPS structure")));
        DWORD dw = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(dw), s_FN, 580); 
        hr = dw;
    }

    if (SUCCEEDED(hr))
    {
        if (hr != MQ_OK)
        {
            // We have wornings, copy all the good properties to a temporary
            // buffer so the DS will not have to handle duplicate properties etc.
            RemovePropWarnings(
                (MQQUEUEPROPS*)pQMProps,
                aStatus,
                (MQQUEUEPROPS**)ppGoodQMP,
                ppTmpBuff);
        }
        else
        {
            // All is perfectly well, we do not need a temporary buffer and all
            // that overhead.
            *ppGoodQMP = pQMProps;
        }
    }

    return LogHR(hr, s_FN, 590);

}


HRESULT
RTpCheckRestrictionParameter(
    IN MQRESTRICTION* pRestriction)
{
    HRESULT hr = MQ_OK;

    if ( pRestriction == NULL)
    {
        return(MQ_OK);
    }

    __try
    {

        MQPROPERTYRESTRICTION * pPropRestriction = pRestriction->paPropRes;
        for ( DWORD i = 0; i < pRestriction->cRes; i++, pPropRestriction++)
        {
            if (( pPropRestriction->prop > LAST_Q_PROPID) || ( pPropRestriction->prop <= PROPID_Q_BASE ))
            {
                return LogHR(MQ_ERROR_ILLEGAL_RESTRICTION_PROPID, s_FN, 600);
            }
            switch ( pPropRestriction->prop)
            {
                case PROPID_Q_LABEL:
                    hr = qLabelValidation( &pPropRestriction->prval, NULL);
                    break;
                case PROPID_Q_PATHNAME:
                case PROPID_Q_ADS_PATH:
                    //
                    //  Multiple column props, not supported in restriction
                    //
                    hr =  MQ_ERROR_ILLEGAL_RESTRICTION_PROPID;
                    break;
                default:
                    break;
            }
            if (FAILED(hr))
            {
                break;
            }

            //
            // SP4- bug# 3009, SP4SS: exception on server when call MQlocatebegin
            // Fix: validate Restriction VT.
            //                      Uri Habusha, 17-Jun-98
			//
			// Enable prop vt = VT_EMPTY if Allowed VT_EMPTY by set
			// This is the case for PROPID_Q_MULTICAST_ADDRESS
			// Its enable the restriction PROPID_Q_MULTICAST_ADDRESS with vt = VT_EMPTY
			// Ilan Herbst, 15-Nov-2000
			//
            DWORD Index = pPropRestriction->prop - PROPID_Q_BASE;
            if ((pPropRestriction->prval.vt != QueueVarTypes[Index]) &&
				!((pPropRestriction->prval.vt == VT_EMPTY) && 
				  (QueueSetValidation[Index].fAllow_VT_EMPTY == TRUE))) 
            {
                hr = MQ_ERROR_ILLEGAL_PROPERTY_VT;
                break;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing restriction structure")));
        DWORD dw = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(dw), s_FN, 610); 
        hr = dw;
    }

    return LogHR(hr, s_FN, 620);
}

HRESULT
RTpCheckSortParameter(
    IN MQSORTSET* pSort
	)
{
    HRESULT hr = MQ_OK;

    if ( pSort == NULL)
    {
        return(MQ_OK);
    }

	if((ADGetEnterprise() == eAD) && (pSort->cCol > 1))
	{
		//
		// Multiple MQSORTKEY is not supported.
		// Active Directory supports only a single sort key
		//
		return LogHR(MQ_ERROR_MULTI_SORT_KEYS, s_FN, 625);
	}

    __try
    {

        MQSORTKEY * pSortKey = pSort->aCol;
        for ( DWORD i = 0; i < pSort->cCol; i++, pSortKey++)
        {
            if (( pSortKey->propColumn > LAST_Q_PROPID) || ( pSortKey->propColumn <= PROPID_Q_BASE ))
            {
                return LogHR(MQ_ERROR_ILLEGAL_SORT_PROPID, s_FN, 630);
            }
            switch ( pSortKey->propColumn)
            {
                case PROPID_Q_PATHNAME:
                    //
                    //  Multiple column props, not supported in sort
                    //
                    return LogHR(MQ_ERROR_ILLEGAL_SORT_PROPID, s_FN, 640);
                    break;
                default:
                    break;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing sort structure")));
        DWORD dw = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(dw), s_FN, 650); 
        hr = dw;
    }

    return LogHR(hr, s_FN, 660);
}

HRESULT
RTpCheckLocateNextParameter(
    IN DWORD		cPropsRead,
    IN PROPVARIANT  aPropVar[]
	)
{
	//
	//	validate that the aPropVar buffer supplied by the
	//	user match the size it had specified
	//
	HRESULT hr = MQ_OK;
    __try
    {
        if(IsBadWritePtr(aPropVar, cPropsRead * sizeof(PROPVARIANT)))
        {
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 670);
        }
	}
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while Locate Next parameters.")));
        hr = MQ_ERROR_INVALID_PARAMETER;
        LogHR(hr, s_FN, 680);
    }
	return LogHR(hr, s_FN, 690);

}

//
//  The offset of property in this array must be equal to
//  PROPID value - starting with  FIRST_PRIVATE_COMPUTER_PROPID
//

propValidity    GetPrivateComputerValidation[] =
{
    //                                                   Must
    // Property                 Allow   Allow    Must    Not     Maybe   Parsing
    // Ientifier                VT_NULL VT_EMPTY Appear  Appear  Ignored Procedure
    //---------------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_PC_VERSION,        TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_PC_DS_ENABLED,     TRUE,   FALSE,   FALSE,  FALSE,  FALSE,  NULL},
};

VARTYPE GetPrivateComputerVarTypes[] =
{
    0,
    VT_UI4,                 //PROPID_PC_VERSION
    VT_BOOL,                //PROPID_PC_DS_ENABLED
};


//---------------------------------------------------------
//
//  RTpCheckComputerProps(...)
//
//  Description:
//
//  validates pLocalProps parameter values
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------
HRESULT
RTpCheckComputerProps(
    IN      MQPRIVATEPROPS * pPrivateProps,
    IN OUT  HRESULT*    aStatus
	)
{
    HRESULT hr = MQ_OK;

    __try
    {
        //
        //  The user must ask for atleast one property
        //
        if ( (pPrivateProps == NULL) ||
             (pPrivateProps->cProp == 0))
        {
            return LogHR(MQ_ERROR_ILLEGAL_MQPRIVATEPROPS, s_FN, 700);
        }

        hr = CheckProps(pPrivateProps->cProp,
                        pPrivateProps->aPropID,
                        pPrivateProps->aPropVar,
                        aStatus,
                        FIRST_PRIVATE_COMPUTER_PROPID,
                        LAST_PRIVATE_COMPUTER_PROPID,
                        GetPrivateComputerValidation,
                        GetPrivateComputerVarTypes,
                        TRUE,	// fCheckForIgnoredProps
                        0,      // zero must properties
                        NULL);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing MQPRIVATEPROPS structure")));
        DWORD dw = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(dw), s_FN, 710); 
        hr = dw;
    }

    return LogHR(hr, s_FN, 720);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\qmrt.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qmrt.cpp

Abstract:



Author:

    Boaz Feldbaum (BoazF) Mar 5, 1996

Revision History:

--*/

#include "stdh.h"
#include "rtprpc.h"
#include "_registr.h"
#include "acdef.h"

#include "qmrt.tmh"

static WCHAR *s_FN=L"rt/qmrt";

static
void
GetSecurityDescriptorSize(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpdwSecurityDescriptorSize)
{
    if (pSecurityDescriptor)
    {
        ASSERT(IsValidSecurityDescriptor(pSecurityDescriptor));
        *lpdwSecurityDescriptorSize = GetSecurityDescriptorLength(pSecurityDescriptor);
    }
    else
    {
        *lpdwSecurityDescriptorSize = 0;
    }
}

HRESULT
QMCreateObject(
    /* in */ DWORD dwObjectType,
    /* in */ LPCWSTR lpwcsPathName,
    /* in */ PSECURITY_DESCRIPTOR pSecurityDescriptor,
    /* in */ DWORD cp,
    /* in */ PROPID aProp[],
    /* in */ PROPVARIANT apVar[])
{
    DWORD dwSecurityDescriptorSize;

    GetSecurityDescriptorSize(pSecurityDescriptor, &dwSecurityDescriptorSize);

    ASSERT(tls_hBindRpc) ;
    HRESULT hr = QMCreateObjectInternal(tls_hBindRpc,
                                  dwObjectType,
                                  lpwcsPathName,
                                  dwSecurityDescriptorSize,
                                  (unsigned char *)pSecurityDescriptor,
                                  cp,
                                  aProp,
                                  apVar);
    return LogHR(hr, s_FN, 10);
}

HRESULT
QMCreateDSObject(
    /* in  */ DWORD dwObjectType,
    /* in  */ LPCWSTR lpwcsPathName,
    /* in  */ PSECURITY_DESCRIPTOR pSecurityDescriptor,
    /* in  */ DWORD cp,
    /* in  */ PROPID aProp[],
    /* in  */ PROPVARIANT apVar[],
    /* out */ GUID       *pObjGuid )
{
    DWORD dwSecurityDescriptorSize;

    GetSecurityDescriptorSize(pSecurityDescriptor, &dwSecurityDescriptorSize);

    ASSERT(tls_hBindRpc) ;
    HRESULT hr = QMCreateDSObjectInternal( tls_hBindRpc,
                                           dwObjectType,
                                           lpwcsPathName,
                                           dwSecurityDescriptorSize,
                                   (unsigned char *)pSecurityDescriptor,
                                           cp,
                                           aProp,
                                           apVar,
                                           pObjGuid );
    return LogHR(hr, s_FN, 20);
}

HRESULT
QMSetObjectSecurity(
    /* in */ OBJECT_FORMAT* pObjectFormat,
    /* in */ SECURITY_INFORMATION SecurityInformation,
    /* in */ PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    DWORD dwSecurityDescriptorSize;

    GetSecurityDescriptorSize(pSecurityDescriptor, &dwSecurityDescriptorSize);

    ASSERT(tls_hBindRpc) ;
    HRESULT hr = QMSetObjectSecurityInternal(tls_hBindRpc,
                                       pObjectFormat,
                                       SecurityInformation,
                                       dwSecurityDescriptorSize,
                                       (unsigned char *)pSecurityDescriptor);
    return LogHR(hr, s_FN, 30);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtcert.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rtcert.cpp

Abstract:

    MQ internal certificate store management.

Author:

    Boaz Feldbaum (BoazF) 15-Oct-1996

--*/

#include "stdh.h"
#include <mqtempl.h>
#include <ad.h>
#include <mqutil.h>
#include <_secutil.h>
#include <rtcert.h>
#include "rtputl.h"

#include "rtcert.tmh"

static WCHAR *s_FN=L"rt/rtcert";

/*************************************************************************
*
*  Function:  RTOpenInternalCertStore( HCERTSTORE *phStore )
*
*  Parameters
*      BOOL fWriteAccess - TRUE if caller want write access, i.e.,
*                   if user want to add a certificate to the store.
*
*  Descruption: Get a handle to the certificate store which contain
*               the internal certificates.
*
**************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTOpenInternalCertStore( OUT CMQSigCertStore **ppStore,
                         IN  LONG            *pnCerts,
                         IN  BOOL            fWriteAccess,
                         IN  BOOL            fMachine,
                         IN  HKEY            hKeyUser )
{
	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    struct MQSigOpenCertParams OpenParams ;
    memset(&OpenParams, 0, sizeof(OpenParams)) ;
    OpenParams.bCreate = !!fWriteAccess ;
    OpenParams.bWriteAccess = !!fWriteAccess ;
    OpenParams.bMachineStore = !!fMachine ;
    OpenParams.hCurrentUser = hKeyUser ;

    HRESULT hr = MQSigOpenUserCertStore( ppStore,
                                         MQ_INTERNAL_CERT_STORE_REG,
                                        &OpenParams ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 10) ;
    }

    if (pnCerts)
    {
        HCERTSTORE hStore = (*ppStore)->GetHandle() ;
        //
        // count the number of certificates in store.
        //
        *pnCerts = 0 ;

        PCCERT_CONTEXT pCertContext;
        PCCERT_CONTEXT pPrevCertContext;

        pCertContext = CertEnumCertificatesInStore(hStore, NULL);
        while (pCertContext)
        {
            pPrevCertContext = pCertContext,

            (*pnCerts)++ ;
            pCertContext = CertEnumCertificatesInStore( hStore,
                                                        pPrevCertContext ) ;
        }

        ASSERT(!pCertContext) ;
        ASSERT((*pnCerts == 0) || (*pnCerts == 1)) ;
    }

    DBGMSG((DBGMOD_SECURITY, DBGLVL_INFO,
                  _TEXT("rtcert: RTOpenInternalCertStore successful"))) ;

    return MQ_OK ;
}

/*************************************************************************
*
*  Function:
*    RTGetInternalCert
*
*  Parameters -
*    ppCert - On return, pointer to The certificate object.
*
*  Return value-
*    MQ_OK if successful, else an error code.
*
*  Comments -
*    Returns the internal certificate. The function fails if the
*    certificate does not exist.
*
*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTGetInternalCert( OUT CMQSigCertificate **ppCert,
                   OUT CMQSigCertStore   **ppStore,
                   IN  BOOL              fGetForDelete,
                   IN  BOOL              fMachine,
                   IN  HKEY              hKeyUser )
{
	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    LONG nCerts = 0 ;

    *ppCert = NULL ;
    *ppStore = NULL ;

    HRESULT hr = RTOpenInternalCertStore( ppStore,
                                          &nCerts,
                                          fGetForDelete,
                                          fMachine,
                                          hKeyUser ) ;
    if (FAILED(hr) || (nCerts == 0))
    {
        return LogHR(MQ_ERROR_NO_INTERNAL_USER_CERT, s_FN, 20) ;
    }

    PCCERT_CONTEXT pCertContext =
                CertEnumCertificatesInStore((*ppStore)->GetHandle(), NULL);

    if (!pCertContext)
    {
        return LogHR(MQ_ERROR_NO_INTERNAL_USER_CERT, s_FN, 30) ;
    }

    hr = MQSigCreateCertificate( ppCert, pCertContext) ;

    return LogHR(hr, s_FN, 40) ;
}

/*************************************************************************

  Function:
    RTRegisterUserCert

  Parameters -
    pCert - The certificate object.

  Return value-
    S_OK if successful, else an error code.

  Comments -

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTRegisterUserCert(
    IN CMQSigCertificate *pCert,
    IN BOOL               fMachine )
{
	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    ASSERT(pCert) ;

    PROPID propIDU[] = {PROPID_U_ID, PROPID_U_SIGN_CERT, PROPID_U_DIGEST};
    PROPID propIDCom[] = {PROPID_COM_ID, PROPID_COM_SIGN_CERT, PROPID_COM_DIGEST};
    DWORD dwArraySize = sizeof(propIDU) / sizeof(propIDU[0]) ;

    PROPID *pPropIDs = propIDU ;
    if (fMachine)
    {
        pPropIDs = propIDCom ;
    }

    PROPVARIANT propVar[3];
    GUID guidCert;

    propVar[0].vt = VT_CLSID;
    propVar[0].puuid = &guidCert;
    UuidCreate(&guidCert);

    propVar[1].vt = VT_BLOB;

    DWORD dwCertSize = 0 ;
    BYTE  *pBuf = NULL ;

    HRESULT hr = pCert->GetCertBlob(&pBuf, &dwCertSize) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50) ;
    }

    propVar[1].blob.cbSize =  dwCertSize ;
    propVar[1].blob.pBlobData  = pBuf ;

    GUID guidHash;

    hr = pCert->GetCertDigest(&guidHash) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60) ;
    }

    propVar[2].vt = VT_CLSID;
    propVar[2].puuid = &guidHash;

    switch (hr = ADCreateObject( 
						eUSER,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						NULL,
						NULL,
						dwArraySize,
						pPropIDs,
						propVar,
						NULL 
						))
    {
        case MQDS_CREATE_ERROR:
            hr = MQ_ERROR_INTERNAL_USER_CERT_EXIST;
            break;

        case MQ_OK:
            hr = MQ_OK;
            break;
    }

    return LogHR(hr, s_FN, 70) ;
}


bool IsWorkGroupMode(void)
/*++

Routine Description:
	Retrieve WorkGroup Mode from registry.
	the read from registry is done only in the first call to this function.

Arguments:
	None.

Returned Value:
	true for WorkGroup mode, false otherwise

--*/
{
	static bool s_fWorkGroupModeInitialize = false;
	static bool s_fWorkGroupMode = false;

    if (s_fWorkGroupModeInitialize)
		return s_fWorkGroupMode;

	DWORD dwWorkGroup;
	DWORD dwSize = sizeof(DWORD);
	DWORD dwType = REG_DWORD;

	LONG rc = GetFalconKeyValue( 
					MSMQ_WORKGROUP_REGNAME,
					&dwType,
					&dwWorkGroup,
					&dwSize 
					);

	if ((rc == ERROR_SUCCESS) && (dwWorkGroup != 0))
	{
		s_fWorkGroupMode = true;	
	}

	s_fWorkGroupModeInitialize = true;

    DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("WorkGroupMode registry status = %d"), s_fWorkGroupMode));

	return s_fWorkGroupMode;
}


/*************************************************************************

  Function:
    RTGetUserCerts

  Parameters -
    ppCert - A pointer to an array that receives the ponters to the user's
        certificates.
    pnCerts - A pointer to a buffer that points to the number of entries in
        pp509. Upon return, the buffer contains the number of certificates
        that the user has.
    pSidIn - An optiona lparameter that points to a user SID. If this
        parameter equals NULL, the certificates for the user of the current
        thread are retrieved.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -
    If the array in pp509 is too small, it is being filled up until there
    is no more place in it. All certificates should be released in any
    case. If upon return pnCerts points to a value that is greater than
    the value when entering the function, it means that pp509 is too
    small.

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTGetUserCerts(
    CMQSigCertificate **ppCert,
    DWORD              *pnCerts,
    PSID                pSidIn
    )
{
	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr;
    AP<BYTE> pUserSid;
    DWORD dwSidLen;
    PSID pSid;
    DWORD nCertsIn = *pnCerts;

	if(IsWorkGroupMode())
	{
		//
		// For Workgroup return UNSUPPORTED_OPERATION
		//
		return LogHR(MQ_ERROR_UNSUPPORTED_OPERATION, s_FN, 75);
	}

    if (pSidIn)
    {
        pSid = pSidIn;
        dwSidLen = GetLengthSid(pSid);
    }
    else
    {
        //
        // Local users are not let in.
        //
        BOOL fLocalUser;
        BOOL fLocalSystem;

        hr = RTpGetThreadUserSid( &fLocalUser,
                                  &fLocalSystem,
                                  &pUserSid,
                                  &dwSidLen );
        if(FAILED(hr))
        {
            return LogHR(hr, s_FN, 80) ;
        }

        if (fLocalUser)
        {
		    return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 90);
        }

        pSid = pUserSid;
    }

    MQCOLUMNSET Cols;
    PROPID ColId = PROPID_U_SIGN_CERT;
    HANDLE hEnum;

    Cols.cCol = 1;
    Cols.aCol = &ColId;

    BLOB blobUserSid;
    blobUserSid.cbSize = dwSidLen;
    blobUserSid.pBlobData = (BYTE *)pSid;

    hr = ADQueryUserCert(
                NULL,       // pwcsDomainController,
				false,		// fServerName
                &blobUserSid,
                &Cols,
                &hEnum
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100) ;
    }

    DWORD nCerts = 0 ;

    while (1)
    {
        DWORD cProps = 1;
        PROPVARIANT propVar;

        propVar.vt = VT_NULL;
        hr = ADQueryResults(hEnum, &cProps, &propVar);
        if (FAILED(hr) || !cProps)
        {
            break;
        }

        if (nCerts < nCertsIn)
        {
            CMQSigCertificate *pSigCert = NULL ;
            HRESULT hr = MQSigCreateCertificate( &pSigCert,
                                                 NULL,
                                                 propVar.blob.pBlobData,
                                                 propVar.blob.cbSize ) ;
            if (SUCCEEDED(hr))
            {
                ppCert[ nCerts ] = pSigCert ;
                nCerts++;
            }
        }
        else
        {
            nCerts++;
        }

        MQFreeMemory(propVar.blob.pBlobData);
    }

    ADEndQuery(hEnum);

    *pnCerts = nCerts;

    return LogHR(hr, s_FN, 110) ;
}

/*************************************************************************

  Function:
    RTRemoveUserCert

  Parameters -
    p509 - A pointer to the certificate that should be removed from the DS.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTRemoveUserCert(
    IN CMQSigCertificate *pCert
    )
{
	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr;
    GUID guidHash;

    hr = pCert->GetCertDigest(&guidHash) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120) ;
    }

    hr = ADDeleteObjectGuid(
                eUSER,
				NULL,       // pwcsDomainController
				false,	    // fServerName
                &guidHash
                );
    return LogHR(hr, s_FN, 130) ;
}

/*************************************************************************

  Function:
    GetCertInfo

  Parameters -
    ppbCert - A pointer to a pointer to a buffer that holds the cert bits.
    dwCertLen - A pointer to the length of *ppbCert.
    phProv - A pointer to a buffer that receives the handle to the cert CSP.
    wszProvName - A pointer to a buffer that receives a pointer to the name
        of the cert CSP.
    pdwProvType - A poinrter to a buffer the receives the type of the cert CSP.
    pbDefProv - A pointer to a buffer that reveices TRUE, if the cert CSP is
        the default CSP, else FALSE.
    pbInternalCert - A pointer to a buffer that receives TRUE, if the cert
        is an internl MSMQ cert, else FALSE.
    pdwPrivateKeySpec - A pointer to a buffer that receives the private key type
        AT_SIGNATURE or AT_KEYEXCHANGE.

  Return value-
    MQ_OK if successful, else error code.

  Comments -
    The function receives a buffer that contains the bits of some
    certificate and returns various information about the certificate.

*************************************************************************/

HRESULT
GetCertInfo(
    IN     BOOL        fUseCurrentUser,
	IN     BOOL        fMachine,
	IN OUT BYTE      **ppbCert,
	OUT    DWORD      *pdwCertLen,
	OUT    HCRYPTPROV *phProv,
	OUT    LPWSTR     *wszProvName,
	OUT    DWORD      *pdwProvType,
	OUT    BOOL       *pbDefProv,
	OUT    BOOL       *pbInternalCert,
	OUT	   DWORD      *pdwPrivateKeySpec
	)
{
    HRESULT hr;

    //
    // Note: it's important that pStore be defined before
    //       pCert, so it will be the last one to be released.
    //
    R<CMQSigCertStore>   pStore;
    R<CMQSigCertificate> pCert;

    ASSERT(ppbCert);

    *pbInternalCert = (*ppbCert == NULL);

    CAutoCloseRegHandle  hKeyUser (NULL) ;
    if ( fUseCurrentUser )
    {
	    ASSERT(!fMachine) ;

        LONG rc = RegOpenCurrentUser( KEY_READ,
                                     &hKeyUser ) ;
        if (rc != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32(rc) ;
        }
    }

    if (*pbInternalCert)
    {
		//
		// Internal Certificate are using Signature Key
		//
		*pdwPrivateKeySpec = AT_SIGNATURE;

        //
        // We should get the information for the internal certificate.
        //
        hr = RTGetInternalCert(
				&pCert.ref(),
				&pStore.ref(),
				FALSE, // fGetForDelete
				fMachine,
                hKeyUser
				);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 140);
        }

        BYTE  *pCertBlob = NULL;
        DWORD dwCertSize = 0;

        hr = pCert->GetCertBlob(
				&pCertBlob,
				&dwCertSize
				);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 150);
        }

        try
        {
            //
            // We must free b.pBlobData, so do not use memory allocation
            // faliure excpetions.
            //
            *ppbCert = new BYTE[dwCertSize];
        }
        catch(const bad_alloc&)
        {
            //
            // We failed to allocate a buffer for the cert. Free the blob and
            // return an error.
            //
            *ppbCert = NULL;
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 160);
        }

        //
        // Copy the certificate to "our" memory.
        //
        *pdwCertLen = dwCertSize;
        memcpy(*ppbCert, pCertBlob, dwCertSize);

        //
        // The CSP context for the internal certificate is always of the
        // base RSA provider.
        //
        DWORD   dwMachineFlag = 0;
        LPSTR lpszContainerNameA  = MSMQ_INTCRT_KEY_CONTAINER_A;
        LPWSTR lpszContainerNameW = MSMQ_INTCRT_KEY_CONTAINER_W;

        if (fMachine)
        {
            lpszContainerNameA = MSMQ_SERVICE_INTCRT_KEY_CONTAINER_A;
            lpszContainerNameW = MSMQ_SERVICE_INTCRT_KEY_CONTAINER_W;
            dwMachineFlag = CRYPT_MACHINE_KEYSET;
        }

        if (!CryptAcquireContextA(
				phProv,
				lpszContainerNameA,
				MS_DEF_PROV_A,
				PROV_RSA_FULL,
				dwMachineFlag
				))
        {
            return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 170);
        }

        *wszProvName = new WCHAR[sizeof(MS_DEF_PROV_A)];
        wcscpy((LPWSTR)*wszProvName, MS_DEF_PROV_W);

        *pdwProvType = PROV_RSA_FULL;
    }
    else
    {
        //
        // We have a "real" (non-internal) cetificate.
        //
        AP<WCHAR> wszKeySet;
        ASSERT(pdwCertLen && *pdwCertLen);

        CHCryptProv hProv;

        if (!CryptAcquireContextA(
				&hProv,
				NULL,
				NULL,
				PROV_RSA_FULL,
				CRYPT_VERIFYCONTEXT
				))
        {
            return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 180);
        }

        CHCertStore  hSysStore =  CertOpenSystemStoreA(
										hProv,
										x_szPersonalSysProtocol
										);
        if (!hSysStore)
        {
            return LogHR(MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE, s_FN, 190);
        }

        BOOL fFound;
        CPCCertContext pCertContext;

        for ( fFound = FALSE,
              pCertContext = CertEnumCertificatesInStore(hSysStore, NULL);
              pCertContext && !fFound; )
        {
            PCCERT_CONTEXT pCtx = pCertContext;
            fFound = (*pdwCertLen == pCtx->cbCertEncoded) &&
                     (memcmp(
						*ppbCert,
						pCtx->pbCertEncoded,
						pCtx->cbCertEncoded
						) == 0);
            if (!fFound)
            {
                pCertContext = CertEnumCertificatesInStore(
									hSysStore,
									pCtx
									);
            }
        }

        if (!pCertContext)
        {
            return LogHR(MQ_ERROR_INVALID_CERTIFICATE, s_FN, 200);
        }

        BYTE abShortCertInfo[256];
        DWORD dwCertInfoSize = sizeof(abShortCertInfo);
        AP<BYTE> pLongCertInfo = NULL;
        PBYTE pCertInfo = abShortCertInfo;

        if (!CertGetCertificateContextProperty(
				pCertContext,
				CERT_KEY_PROV_INFO_PROP_ID,
				pCertInfo,
				&dwCertInfoSize
				))
        {
			DWORD dwErr = GetLastError();

            if (dwErr == ERROR_MORE_DATA)
            {
                pLongCertInfo = new BYTE[dwCertInfoSize];
                pCertInfo = pLongCertInfo;
                if (!CertGetCertificateContextProperty(
						pCertContext,
						CERT_KEY_PROV_INFO_PROP_ID,
						pCertInfo,
						&dwCertInfoSize
						))
                {
                    return LogHR(MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE, s_FN, 210);
                }
            }
            else
            {
				DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT("rtcert: CertGetCertificateContextProperty failed, error = 0x%x"), dwErr)) ;

                return LogHR(MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE, s_FN, 220);
            }
        }

        PCRYPT_KEY_PROV_INFO pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) pCertInfo;

        DWORD dwKeySetLen = wcslen(pKeyProvInfo->pwszContainerName);
        wszKeySet = new WCHAR[dwKeySetLen + 1];
        wcscpy(wszKeySet, pKeyProvInfo->pwszContainerName);

        DWORD dwProvNameLen = wcslen(pKeyProvInfo->pwszProvName);
        *wszProvName = new WCHAR[dwProvNameLen + 1];
        wcscpy(*wszProvName, pKeyProvInfo->pwszProvName);

        *pdwProvType = pKeyProvInfo->dwProvType;

		//
		// For external certificate we are getting the PrivateKeySpec from the certificate	
		// bug 5626 25-June-2000 ilanh
		//
		*pdwPrivateKeySpec = pKeyProvInfo->dwKeySpec;

		//
		// *pdwPrivateKeySpec must be AT_SIGNATURE or AT_KEYEXCHANGE
		//
        ASSERT((*pdwPrivateKeySpec == AT_SIGNATURE) ||
			   (*pdwPrivateKeySpec == AT_KEYEXCHANGE));


        BOOL fAcq = CryptAcquireContext(
						phProv,
						wszKeySet,
						*wszProvName,
						*pdwProvType,
						0
						);

        if (!fAcq)
        {
            return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 230);
        }
    }

    //
    // Find out whether the CSP is the default CSP.
    //
    *pbDefProv = (*pdwProvType == PROV_RSA_FULL) &&
                 (wcscmp(*wszProvName, MS_DEF_PROV_W) == 0);

#ifdef _DEBUG
    if (*pbDefProv)
    {
        static BOOL s_fAlreadyRead = FALSE;
        static BOOL s_fMakeNonDefault = FALSE;

        if (!s_fAlreadyRead)
        {
        	DWORD dwUseNonDef = 0;
            DWORD dwSize = sizeof(DWORD);
            DWORD dwType = REG_DWORD;

            LONG res = GetFalconKeyValue(
							USE_NON_DEFAULT_AUTHN_PROV_REGNAME,
							&dwType,
							&dwUseNonDef,
							&dwSize
							);

            if ((res == ERROR_SUCCESS) && (dwUseNonDef == 1))
            {
                s_fMakeNonDefault = TRUE;
            }
            s_fAlreadyRead = TRUE;
        }

        if (s_fMakeNonDefault)
        {
            *pbDefProv = FALSE;
            wcscpy(
				*wszProvName,
				L"MiCrOsOfT BaSe CrYpToGrApHiC PrOvIdEr v1.0"
				);
        }
    }
#endif

    return(MQ_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtctxex.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: rtctxex.cpp

Abstract:

    This module implements the MQGetSecurityContextEx().

Author:

    Doron Juster (DoronJ)  13-Apr-2000

Revision History:

--*/

#include "stdh.h"
#include <autorel.h>
#include <_secutil.h>
#include <rtdep.h>

#include "rtctxex.tmh"

static WCHAR *s_FN=L"rt/rtctxex";

BOOL     SameAsProcessSid( PSID pSid ) ; // from rtsecctx.cpp
HRESULT  RTpExportSigningKey(MQSECURITY_CONTEXT *pSecCtx) ;

/***********************************************************************
*
*   Function - MQGetSecurityContextEx()
*
*    Parameters -
*
*    lpCertBuffer - A buffer that contains the user's certificate in
*        ASN.1 DER encoded format.  This parameter can be set to NULL. If
*        set to NULL, the internal MSMQ certificate is used.
*
*    dwCertBufferLength - The length of the buffer pointed by lpCertBuffer.
*        This parameter is ignored if lpCertBuffer is set to NULL.
*
*    lplpSecurityContextBuffer - A pointer to a buffer that receives the
*        address of the allocated buffer for the security context.
*
*    Description -
*
*        This function should be called in the context of the
*        user that owns the passed certificate. The function
*        allocates the required security buffer and fills it
*        with data that will be used later in MQSendMessage().
*        The purpose of this function is to accelerate the
*        security operations of MQSendMessage(), by caching
*        the security information in the buffer. The
*        application is responsible to pass the security
*        context buffer to MQSendMessage() in
*        PROPID_M_SECURITY_CONTEXT.
*
*        If the user uses more than one certificate, this function
*        should be called for each certificate.
*
*        The application should call MQFreeSecurityContext() and pass the
*        pointer to the security context buffer, when the security
*        buffer is not required anymore.
*
*       Impersonation- It's possible for a process to impersonate a user,
*        then call this function to cache the user data, and then revert
*        to itself and send messages on behalf of that user.
*        To do so, the process must LogonUser() for the user, then load its
*        hive (RegLoadKey()), impersonate the logged on user and finally
*        call this function. Then revert and send messages.
*        With MSMQ1.0 which shipped with NTEE and NTOP, this function used
*        an unsupported and undocumented feature which enabled you just to
*        call CryptAcquireContext() while impersonated, then use the handle
*        after process revert to itself. This feature is not available on IE4
*        and above. The supported way to implement this functionality is to
*        export the private key from the user hive, then (after reverting) to
*        import it into the process hive. See MSMQ bug 2955
*        We'll keep the CryptAcquireContext() code for the case of same user
*        (i.e., thread run in the context of the process user. There was no
*        impersonation). In that case it's legal and enhance performance.
*
*    Return Value -
*        MQ_OK  - If successful, else - Error code.
*
**************************************************************************/

EXTERN_C HRESULT APIENTRY
MQGetSecurityContextEx( LPVOID  lpCertBuffer,
                        DWORD   dwCertBufferLength,
                        HANDLE *phSecurityContext )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepGetSecurityContextEx(lpCertBuffer, dwCertBufferLength, phSecurityContext);

    P<MQSECURITY_CONTEXT> pSecCtx = AllocSecurityContext();
    //
    // the line below may throw bad_alloc on win64, like the allocation above.
    // we return a HANDLE that can be safely cast to 32 bits (for VT_I4 property
    // PROPID_M_SECURITY_CONTEXT).
    //
    HANDLE hSecurityContext = (HANDLE) DWORD_TO_HANDLE(
        ADD_TO_CONTEXT_MAP(g_map_RT_SecCtx, (PMQSECURITY_CONTEXT)pSecCtx, s_FN, 55));

    P<BYTE>    pSid = NULL ;
    CHCryptKey hKey = NULL ;

    try
    {
        //
        // Get the user SID out from the thread (or process) token.
        //
        hr = RTpGetThreadUserSid( &pSecCtx->fLocalUser,
                                  &pSecCtx->fLocalSystem,
                                  &pSecCtx->pUserSid,
                                  &pSecCtx->dwUserSidLen ) ;

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60);
        }

        if (lpCertBuffer)
        {
            //
            // Copy the certificate and point to the copy from the security
            // context.
            //
            pSecCtx->pUserCert = new BYTE[dwCertBufferLength];
            pSecCtx->dwUserCertLen = dwCertBufferLength;
            memcpy(pSecCtx->pUserCert, lpCertBuffer, dwCertBufferLength);
        }

        //
        // See if process sid match thread sid. We call again
        // GetThreadUserSid() to get sid even for local user.
        // RTpGetThreadUserSid() does not return a sid for local user.
        //
        DWORD dwLen = 0 ;
        hr = GetThreadUserSid( &pSid, &dwLen ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 90);
        }

        BOOL fAsProcess = SameAsProcessSid( pSid ) ;

        //
        // Get all the required information about the certificate and
        // put it in the security context.
        //
		BYTE* pUserCert = pSecCtx->pUserCert.get();
		BYTE** ppUserCert = pUserCert == NULL ? &pSecCtx->pUserCert : &pUserCert;

        hr  = GetCertInfo(  !fAsProcess,
                            pSecCtx->fLocalSystem,
		        			ppUserCert,
                           &pSecCtx->dwUserCertLen,
                           &pSecCtx->hProv,
                           &pSecCtx->wszProvName,
                           &pSecCtx->dwProvType,
                           &pSecCtx->bDefProv,
                           &pSecCtx->bInternalCert,
                           &pSecCtx->dwPrivateKeySpec ) ;

        if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
        {
            return LogHR(hr, s_FN, 120);
        }

        if (hr == MQ_ERROR_NO_INTERNAL_USER_CERT)
        {
            //
            // If the user does not have an internal certificate,
            // this is not a reason to fail MQGetSecurityContext().
            // MQSendMessage() should fail in case the application
            // tries to use this security context to send an
            // authenticated messages.
            //
            *phSecurityContext = hSecurityContext ;
            pSecCtx.detach() ; // Prevent from the security context to be freed.

            return MQ_OK;
        }

        if (fAsProcess)
        {
            //
            // Thread run under context of process credentials.
            // The Crypto context acquired here is valid for using when
            // calling MQSend().
            //
            *phSecurityContext = hSecurityContext ;
            pSecCtx.detach() ; // Prevent from the security context to be freed.

            return MQ_OK;
        }

        //
        // Calling code impersonated another user.
        // It's time to export the private key. Later, when calling
        // MQSend(), we'll import it into process hive.
        // We export the private key without encryption, because it
        // dones't leave the machine or the process boundaries.
        //
        hr = RTpExportSigningKey(pSecCtx) ;
        if (SUCCEEDED(hr))
        {
            //
            // Pass the result to the caller.
            //
            *phSecurityContext = hSecurityContext ;
            pSecCtx.detach() ; // Prevent from the security context to be freed.
        }
    }
    catch(...)
    {
        hr = MQ_ERROR_INVALID_PARAMETER;
    }

    return LogHR(hr, s_FN, 150);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\queue.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    queue.cpp

Abstract:

    This module contains code involved with Queue APIs.

Author:

    Erez Haba (erezh) 24-Dec-95

Revision History:

--*/

#include "stdh.h"
#include "ac.h"
#include <ad.h>
#include "rtprpc.h"
#include "rtsecutl.h"
#include <mqdsdef.h>
#include <rtdep.h>
#include <tr.h>

#include "queue.tmh"

static WCHAR *s_FN=L"rt/queue";

const TraceIdEntry Queue = L"QUEUE";

#define MQ_VALID_ACCESS (MQ_RECEIVE_ACCESS | MQ_PEEK_ACCESS | MQ_SEND_ACCESS | MQ_ADMIN_ACCESS)

//
// Data needed for licensing
//
extern GUID   g_LicGuid ;
extern BOOL   g_fLicGuidInit ;
extern DWORD  g_dwOperatingSystem;


inline
BOOL
IsLegalDirectFormatNameOperation(
    const QUEUE_FORMAT* pQueueFormat
    )
//
// Function Description:
//      The routines checks if the queue operation is leggal with
//      the direct format name. Due "Workgroup" support, we allowed
//      direct format name for local private queue.
//
// Arguments:
//      pQueueFormat - pointer to format name object
//
// Returned value:
//      TRUE if the format name is valid, FALSE otherwise
//
{
    ASSERT(pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT);

    if (pQueueFormat->Suffix() != QUEUE_SUFFIX_TYPE_NONE)
        return FALSE;

	//
	// The APIs that call this function don't support HTTP format name.
	// Thus the HTTP and HTTPS types are not valid.
	//
	DirectQueueType dqt;
	FnParseDirectQueueType(pQueueFormat->DirectID(), &dqt);

	if(dqt == dtHTTP || dqt == dtHTTPS)
		return FALSE;

    //
    // check that the direct format name is for private queue. Queue
    // locallity will be checked by the QM
    //
    LPWSTR pTemp = wcschr(pQueueFormat->DirectID(), L'\\');
    ASSERT(pTemp != NULL);

    return (_wcsnicmp(pTemp+1,
                      PRIVATE_QUEUE_PATH_INDICATIOR,
                      PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH) == 0);
}


//
//  This function is called whenever really path name is needed.
//
//  It appears in the path of the following functions only:
//  MQDeleteQueue, MQSetQueueProperties, MQGetQueueProperties
//  MQGetQueueSecurity, MQSetQueueSecurity
//
inline BOOL IsLegalFormatNameOperation(const QUEUE_FORMAT* pQueueFormat)
{
    switch(pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PRIVATE:
        case QUEUE_FORMAT_TYPE_PUBLIC:
            return (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_NONE);

        case QUEUE_FORMAT_TYPE_DIRECT:
            return IsLegalDirectFormatNameOperation(pQueueFormat);

        default:
            return FALSE;
    }
}

HRESULT
RtpOpenRemoteQueue(
    LPWSTR lpRemoteQueueName,
    PCTX_OPENREMOTE_HANDLE_TYPE __RPC_FAR *pphContext,
    DWORD __RPC_FAR *pdwContext,
    QUEUE_FORMAT* pQueueFormat,
    DWORD dwCallingProcessID,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    GUID __RPC_FAR *pLicGuid,
    DWORD dwMQS,
    DWORD __RPC_FAR *dwpQueue,
    DWORD __RPC_FAR *phQueue
    )
{
    CMQHResult rc;
    CALL_REMOTE_QM(lpRemoteQueueName,
                  rc, (QMOpenRemoteQueue(
                             hBind,
                             pphContext,
                             pdwContext,
                             pQueueFormat,
                             dwCallingProcessID,
                             dwDesiredAccess,
                             dwShareMode,
                             pLicGuid,
                             dwMQS,
                             dwpQueue,
                             phQueue)) ) ;

    return rc;
}


HRESULT
RtpOpenQueue(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    OUT DWORD* phQueue
    )
{
    *phQueue = NULL ;
    //
    // Check validity of access mode.
    // 1. Check that only legal bits are turned on.
    // 2. Check that only legal access combinations are used.
    //
    if ((dwDesiredAccess & ~MQ_VALID_ACCESS) ||
        !(dwDesiredAccess & MQ_VALID_ACCESS))

    {
       //
       // Ilegal bits are turned on.
       //
       return MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;
    }
    else if (dwDesiredAccess != MQ_SEND_ACCESS)
    {
       if (dwDesiredAccess & MQ_SEND_ACCESS)
       {
          //
          // A queue can't be open for both send and receive.
          //
          return MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;
       }
    }

   if ((dwShareMode & MQ_DENY_RECEIVE_SHARE) &&
       (dwDesiredAccess & MQ_SEND_ACCESS))
   {
       //
       // not supporting SEND_ACCESS with DENY_RECEIVE.
       //
       return MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;
    }


    if (dwDesiredAccess & MQ_SEND_ACCESS)
    {
       if (!g_pSecCntx)
       {
          InitSecurityContext() ;
       }
    }

    AP<QUEUE_FORMAT> pMqf;
    DWORD        nMqf;
    CStringsToFree StringsToFree;
    if (!FnMqfToQueueFormats(
            lpwcsFormatName,
            pMqf,
            &nMqf,
            StringsToFree
            ))
    {
        LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 40);
        return MQ_ERROR_ILLEGAL_FORMATNAME;
    }

    ASSERT(nMqf > 0);

    //
    // Multiple queues or DL can be opened for send only
    //
    if ((dwDesiredAccess & MQ_SEND_ACCESS) == 0)
    {
        if (nMqf > 1 ||
            pMqf[0].GetType() == QUEUE_FORMAT_TYPE_DL)
        {
            LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 45);
            return MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION;
        }
    }

    ASSERT(tls_hBindRpc) ;
    AP<WCHAR> lpRemoteQueueName;
    DWORD  dwpRemoteQueue = 0 ;
    CMQHResult rc;
    rc = R_QMOpenQueue(
            tls_hBindRpc,
            nMqf,
            pMqf,
            GetCurrentProcessId(),
            dwDesiredAccess,
            dwShareMode,
            NULL, //hRemoteQueue
            &lpRemoteQueueName,
            &dwpRemoteQueue,
            phQueue,
            0
            );

    if ((rc == MQ_OK) && lpRemoteQueueName)
    {
		AP<WCHAR> MachineName;
		RTpRemoteQueueNameToMachineName(lpRemoteQueueName.get(), &MachineName);

		//
       // Must be read operation - one queue only
       //
       ASSERT(nMqf == 1);

       *phQueue = NULL;
       //
       // remote reader. Call remote QM.
       //
       DWORD hRemoteQueue = 0 ;
       PCTX_OPENREMOTE_HANDLE_TYPE phContext = NULL ;
       DWORD  dwpContext = 0 ;
       dwpRemoteQueue = 0 ;
       rc = MQ_ERROR_SERVICE_NOT_AVAILABLE ;

       rc = RtpOpenRemoteQueue(
                MachineName,
                &phContext,
                &dwpContext,
                pMqf,
                GetCurrentProcessId(),
                dwDesiredAccess,
                dwShareMode,
                &g_LicGuid,
                g_dwOperatingSystem,
                &dwpRemoteQueue,
                &hRemoteQueue
                ) ;


       // Now open a local queue which will point to the
       // remote one.
       //
       if (rc == MQ_OK)
       {
          ASSERT(dwpRemoteQueue) ;
          ASSERT(hRemoteQueue) ;
          ASSERT(dwpContext) ;

          ASSERT(tls_hBindRpc) ;
          rc = R_QMOpenQueue(
                tls_hBindRpc,
                nMqf,
                pMqf,
                GetCurrentProcessId(),
                dwDesiredAccess,
                dwShareMode,
                hRemoteQueue,
                NULL, // lplpRemoteQueueName
                &dwpRemoteQueue,
                phQueue,
                dwpContext
                );

          QMCloseRemoteQueueContext( &phContext ) ;
       }
    }
    return rc;
}

EXTERN_C
HRESULT
APIENTRY
MQOpenQueue(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    OUT QUEUEHANDLE* phQueue
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepOpenQueue(
					lpwcsFormatName,
					dwDesiredAccess,
					dwShareMode,
					phQueue
					);

    CMQHResult rc;
    DWORD  hQueue = NULL;

    __try
    {
        rc = RtpOpenQueue(lpwcsFormatName, dwDesiredAccess, dwShareMode, &hQueue);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 50);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }
    }

    if (SUCCEEDED(rc))
    {
        ASSERT(hQueue) ;
        *phQueue = DWORD_TO_HANDLE(hQueue); //enlarge to HANDLE
    }

    return LogHR(rc, s_FN, 60);
}

EXTERN_C
HRESULT
APIENTRY
MQDeleteQueue(
    IN LPCWSTR lpwcsFormatName
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepDeleteQueue(lpwcsFormatName);

    CMQHResult rc;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {

            QUEUE_FORMAT QueueFormat;

            if (!FnFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 70);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 80);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    ASSERT(tls_hBindRpc) ;
                    rc = QMDeleteObject( tls_hBindRpc,
                                         &ObjectFormat);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                rc = ADDeleteObjectGuid(
                        eQUEUE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
                        &QueueFormat.PublicID()
                        );
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 90);

            if(SUCCEEDED(rc)) {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete [] pStringToFree;
    }

    return LogHR(rc, s_FN, 100);
}

EXTERN_C
HRESULT
APIENTRY
MQCloseQueue(
    IN QUEUEHANDLE hQueue
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepCloseQueue(hQueue);

    //
    // do not add try except here
    // The API is implemented by NtClose() which returns an
    // error on invalid handle (we return MQ_ERROR_INVALID_HANDLE)
    // and throws exception on purpose when running under a debugger to help
    // find errors at development time.
    //
    hr = RTpConvertToMQCode(ACCloseHandle(hQueue));
    return LogHR(hr, s_FN, 110);
}


EXTERN_C
HRESULT
APIENTRY
MQCreateQueue(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT MQQUEUEPROPS* pqp,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepCreateQueue(
					pSecurityDescriptor,
					pqp,
					lpwcsFormatName,
					lpdwFormatNameLength
					);

    CMQHResult rc, rc1;
    LPWSTR lpwcsPathName;
    LPWSTR pStringToFree = NULL;
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor = NULL;
    char *pTmpQPBuff = NULL;

    __try
    {
        __try
        {
            //
            // check that output parameters are writeable before creating the Queue
            // we check lpwcsFormatName and lpdwFormatNameLength
            // pqp is refered before the creation and handled by the try except
            //
            if (IsBadWritePtr(lpdwFormatNameLength,sizeof(DWORD)) ||
                IsBadWritePtr(lpwcsFormatName, (*lpdwFormatNameLength) * sizeof(WCHAR)))
            {
                return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 120);
            }

            // Serialize the security descriptor.
            rc = RTpMakeSelfRelativeSDAndGetSize(
                &pSecurityDescriptor,
                &pSelfRelativeSecurityDescriptor,
                NULL);
            if (!SUCCEEDED(rc))
            {
                return LogHR(rc, s_FN, 130);
            }

            lpwcsPathName = RTpGetQueuePathNamePropVar(pqp);
            if(lpwcsPathName == 0)
            {
                return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 140);
            }

            LPCWSTR lpwcsExpandedPathName;
            QUEUE_PATH_TYPE QueuePathType;
            QueuePathType = FnValidateAndExpandQueuePath(
                                lpwcsPathName,
                                &lpwcsExpandedPathName,
                                &pStringToFree
                                );

            MQQUEUEPROPS *pGoodQP;

            // Check queue props
            rc1 = RTpCheckQueueProps(pqp,
                                     QUEUE_CREATE,
                                     QueuePathType == PRIVATE_QUEUE_PATH_TYPE,
                                     &pGoodQP,
                                     &pTmpQPBuff);
            if (!SUCCEEDED(rc1) || !pGoodQP->cProp)
            {
                return LogHR(rc1, s_FN, 150);
            }

            switch (QueuePathType)
            {
            case PRIVATE_QUEUE_PATH_TYPE:
                rc = QMCreateObject(MQQM_QUEUE,
                                    lpwcsExpandedPathName,
                                    pSecurityDescriptor,
                                    pGoodQP->cProp,
                                    pGoodQP->aPropID,
                                    pGoodQP->aPropVar);

                if (rc == MQ_ERROR_ACCESS_DENIED)
                {
                    //
                    // See case of public queues for explanations.
                    //
                    rc = QMCreateObject(
                                MQQM_QUEUE_LOCAL_PRIVATE,
                                lpwcsExpandedPathName,
                                pSecurityDescriptor,
                                pGoodQP->cProp,
                                pGoodQP->aPropID,
                                pGoodQP->aPropVar);
                }

                if (SUCCEEDED(rc))
                {
                    rc = MQPathNameToFormatName(lpwcsExpandedPathName,
                                                lpwcsFormatName,
                                                lpdwFormatNameLength);

                }
                break;

            case PUBLIC_QUEUE_PATH_TYPE:

                {
                    GUID QGuid;

                    rc = ADCreateObject(
								eQUEUE,
								NULL,       // pwcsDomainController
								false,	    // fServerName
								lpwcsExpandedPathName,
								pSecurityDescriptor,
								pGoodQP->cProp,
								pGoodQP->aPropID,
								pGoodQP->aPropVar,
								&QGuid
								);

                    if (SUCCEEDED(rc)                   ||
                        (rc == MQ_ERROR_NO_DS)          ||
                        (rc == MQ_ERROR_QUEUE_EXISTS)   ||
                        (rc == MQ_ERROR_UNSUPPORTED_OPERATION) ||
                        (rc == MQ_ERROR_NO_RESPONSE_FROM_OBJECT_SERVER))
                    {
                        //
                        // For these errors we don't try again to call
                        // DS through the local msmq service.
                        //
                        // ERROR_NO_RESPONSE may happen when talking with a
                        // win2k msmq server that issue a write request to a
                        // nt4 MQIS server.
                        //
                    }
                    else if (!RTpIsLocalPublicQueue(lpwcsExpandedPathName))
                    {
                        //
                        // Not local queue. don't call local msmq service.
                        //
                    }
                    else
                    {
                        //
                        // Calling the DS failed. We don't check the error
                        // code, and unconditionally call the local service.
                        // this is to prevent anomalies, where you can't
                        // create a local queue although you're allowed to do
                        // so (but provided a wrong parameter, like security
                        // descriptor, or had any other problem) but will be
                        // able to create it through the service is you're
                        // not allow to create directly in the DS.
                        //
                        // call local msmq service, and ask it to create
                        // the queue. default security descriptor of
                        // msmqConfiguration object on win2000 is that only
                        // object owner and local machine account can create
                        // queues.
                        //
                        HRESULT rcFail = rc ;

                        rc = QMCreateDSObject(
                                        MQDS_LOCAL_PUBLIC_QUEUE,
                                        lpwcsExpandedPathName,
                                        pSecurityDescriptor,
                                        pGoodQP->cProp,
                                        pGoodQP->aPropID,
                                        pGoodQP->aPropVar,
                                       &QGuid );

                        if (SUCCEEDED(rc))
                        {
                            //
                            // Just assert that we called the service
                            // for the right reason...
                            //
							// Currently MQ_ERROR_INVALID_OWNER is returned when the user
							// is logon to another forest. in this case the RT failed to search
							// the computer object and MQ_ERROR_INVALID_OWNER is returned from ADCreateObject().
							// (mqad convert MQDS_OBJECT_NOT_FOUND to MQ_ERROR_INVALID_OWNER for backward compatability)
							// We get MQ_ERROR_DS_LOCAL_USER in case of Local User
							//
							TrTRACE(Queue, "QMCreateDSObject() SUCCEEDED while ADCreateObject() failed, hr = 0x%x", rcFail);
                            ASSERT((rcFail == MQ_ERROR_INVALID_OWNER) ||
								   (rcFail == MQ_ERROR_ACCESS_DENIED) ||
                                   (rcFail == HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION)) ||
                                   (rcFail == MQ_ERROR_DS_LOCAL_USER) ||
								   ADProviderType() == eMqdscli);
							
							DBG_USED(rcFail);
                        }
                    }

                    if (SUCCEEDED(rc))
                    {
                        rc = MQInstanceToFormatName(&QGuid,
                                                    lpwcsFormatName,
                                                    lpdwFormatNameLength);

                    }
                }
                break;

            default:
                rc = MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
                break;

            }
            if ( rc == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
            {
                //
                //  Change into information status ( queue
                //  creation succeeded
                //
                rc = MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL;
            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 160);
            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {

        // Free the extended path name and the serialized security descriptor.
        delete[] pStringToFree;
        delete[] (char*) pSelfRelativeSecurityDescriptor;
        delete[] pTmpQPBuff;

    }

    if (SUCCEEDED(rc) && ((ULONG)(rc) >> 30 != 1)) // no warnning
    {
        return LogHR(rc1, s_FN, 170);
    }
    return LogHR(rc, s_FN, 180);
}


EXTERN_C
HRESULT
APIENTRY
MQLocateBegin(
    IN  LPCWSTR lpwcsContext,
    IN MQRESTRICTION* pRestriction,
    IN MQCOLUMNSET* pColumns,
    IN MQSORTSET* pSort,
    OUT PHANDLE phEnum
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepLocateBegin(
					lpwcsContext,
					pRestriction,
					pColumns,
					pSort,
					phEnum
					);

    CMQHResult rc;

    __try
    {
        if  ( lpwcsContext != NULL)
        {
            return LogHR(MQ_ERROR_ILLEGAL_CONTEXT, s_FN, 190);
        }

        rc = RTpCheckColumnsParameter(pColumns);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 200);
        }

        // If the application passes a valid pointer to a MQRESTRICTION
        // structure with zero rescritctions, pass a null restrictios pointer
        // to the DS, this makes the DS's life much easier.
        if (pRestriction && !pRestriction->cRes)
        {
            pRestriction = NULL;
        }

        rc = RTpCheckRestrictionParameter(pRestriction);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 210);
        }

        rc = RTpCheckSortParameter( pSort);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 220);
        }

        rc = ADQueryQueues(
                NULL,       // pwcsDomainController
				false,		// fServerName
                pRestriction,
                pColumns,
                pSort,
                phEnum
                );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 230);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }
    }

    return LogHR(rc, s_FN, 240);
}

EXTERN_C
HRESULT
APIENTRY
MQLocateNext(
    IN HANDLE hEnum,
    OUT DWORD *pcPropsRead,
    OUT PROPVARIANT aPropVar[]
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepLocateNext(
					hEnum,
					pcPropsRead,
					aPropVar
					);

    CMQHResult rc;

    __try
    {
		rc = RTpCheckLocateNextParameter(
				*pcPropsRead,
				aPropVar);
		if( FAILED(rc))
		{
			return LogHR(rc, s_FN, 250);
		}

        rc = ADQueryResults(
                          hEnum,
                          pcPropsRead,
                          aPropVar);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 260);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }
    }

    // If failed, zero the numer of props.
    if (FAILED(rc))
    {
        __try
        {
            *pcPropsRead = 0;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // Do not modify the original error code.
        }
    }

    return LogHR(rc, s_FN, 270);
}

EXTERN_C
HRESULT
APIENTRY
MQLocateEnd(
    IN HANDLE hEnum
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepLocateEnd(hEnum);

    CMQHResult rc;

    __try
    {

        rc = ADEndQuery(hEnum);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {

        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 280);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

    }

    return LogHR(rc, s_FN, 290);
}

EXTERN_C
HRESULT
APIENTRY
MQSetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pqp
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepSetQueueProperties(
					lpwcsFormatName,
					pqp
					);

    CMQHResult rc, rc1;
    char *pTmpQPBuff = NULL;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            MQQUEUEPROPS *pGoodQP;
            QUEUE_FORMAT QueueFormat;

            if (!FnFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 300);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 310);
            }

            // Check queue props
            rc1 = RTpCheckQueueProps(pqp,
                                     QUEUE_SET_PROPS,
                                     QueueFormat.GetType() != QUEUE_FORMAT_TYPE_PUBLIC,
                                     &pGoodQP,
                                     &pTmpQPBuff);
            if (!SUCCEEDED(rc1) || !pGoodQP->cProp)
            {
                return LogHR(rc1, s_FN, 320);
            }


            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    ASSERT(tls_hBindRpc) ;
                    rc = QMSetObjectProperties(tls_hBindRpc,
                                               &ObjectFormat,
                                               pGoodQP->cProp,
                                               pGoodQP->aPropID,
                                               pGoodQP->aPropVar);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                rc = ADSetObjectPropertiesGuid(
							eQUEUE,
							NULL,       // pwcsDomainController
							false,		// fServerName
							&QueueFormat.PublicID(),
							pGoodQP->cProp,
							pGoodQP->aPropID,
							pGoodQP->aPropVar
							);
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 330);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] pTmpQPBuff;
        delete [] pStringToFree;

    }

    if (SUCCEEDED(rc))
    {
        return LogHR(rc1, s_FN, 340);
    }
    return LogHR(rc, s_FN, 350);
}


EXTERN_C
HRESULT
APIENTRY
MQGetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pqp
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepGetQueueProperties(
					lpwcsFormatName,
					pqp
					);

    CMQHResult rc, rc1;
    char *pTmpQPBuff = NULL;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            MQQUEUEPROPS *pGoodQP;
            QUEUE_FORMAT QueueFormat;

            if (!FnFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 360);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 370);
            }

            // Check queue props
            rc1 = RTpCheckQueueProps(pqp,
                                     QUEUE_GET_PROPS,
                                     QueueFormat.GetType() != QUEUE_FORMAT_TYPE_PUBLIC,
                                     &pGoodQP,
                                     &pTmpQPBuff);
            if (!SUCCEEDED(rc1) || !pGoodQP->cProp)
            {
                return LogHR(rc1, s_FN, 380);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    ASSERT(tls_hBindRpc) ;
                    rc = QMGetObjectProperties(tls_hBindRpc,
                                               &ObjectFormat,
                                               pGoodQP->cProp,
                                               pGoodQP->aPropID,
                                               pGoodQP->aPropVar);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:

                rc = ADGetObjectPropertiesGuid(
							eQUEUE,
							NULL,        // pwcsDomainCOntroller
							false,	     // fServerName
							&QueueFormat.PublicID(),
							pGoodQP->cProp,
							pGoodQP->aPropID,
							pGoodQP->aPropVar
							);
                break;

            default:
                ASSERT(FALSE);
            }

            // Here we have out queue properties, so if the properties were copied to
            // a temporary buffer, copy the resulted prop vars to the application's
            // buffer.
            if (SUCCEEDED(rc) && (pqp != pGoodQP))
            {
                DWORD i, j;

                for (i = 0, j = 0; i < pGoodQP->cProp; i++, j++)
                {
                    while(pqp->aPropID[j] != pGoodQP->aPropID[i])
                    {
                        j++;
                        ASSERT(j < pqp->cProp);
                    }
                    pqp->aPropVar[j] = pGoodQP->aPropVar[i];
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 390);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] pTmpQPBuff;
        delete [] pStringToFree;
    }

    if (SUCCEEDED(rc))
    {
        return LogHR(rc1, s_FN, 400);
    }
    return LogHR(rc, s_FN, 410);
}

EXTERN_C
HRESULT
APIENTRY
MQGetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pInSecurityDescriptor,
    IN DWORD nLength,
    OUT LPDWORD lpnLengthNeeded
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

    //
    // bug 8113.
    // If input buffer is NULL, replace it with 1 byte
    // temporary buffer. Otherwise, call fail with
    // error SERVICE_NOT_AVAILABLE. This is because of
    // using /robust in midl. NULL pointer is not allowed.
    //
    BYTE  tmpBuf[1] ;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL ;

    if (pInSecurityDescriptor || (nLength != 0))
    {
        pSecurityDescriptor =  pInSecurityDescriptor ;
    }
    else
    {
        //
        // this is the fix for 8113.
        //
        pSecurityDescriptor =  tmpBuf ;
    }

	if(g_fDependentClient)
		return DepGetQueueSecurity(
					lpwcsFormatName,
					RequestedInformation,
					pSecurityDescriptor,
					nLength,
					lpnLengthNeeded
					);

    CMQHResult rc;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            QUEUE_FORMAT QueueFormat;

            if (!FnFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 420);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 430);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    ASSERT(tls_hBindRpc) ;
                    rc = QMGetObjectSecurity(tls_hBindRpc,
                                             &ObjectFormat,
                                             RequestedInformation,
                                             pSecurityDescriptor,
                                             nLength,
                                             lpnLengthNeeded);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                {

                    MQPROPVARIANT var = {{VT_NULL, 0,0,0,0}};

                    rc = ADGetObjectSecurityGuid(
                            eQUEUE,
                            NULL,       // pwcsDomainController
							false,	    // fServerName
                            &QueueFormat.PublicID(),
                            RequestedInformation,
                            PROPID_Q_SECURITY,
                            &var
                            );
                    if (FAILED(rc))
                    {
                        break;
                    }

                    ASSERT( var.vt == VT_BLOB);
                    if ( var.blob.cbSize <= nLength )
                    {
                        //
                        //  Copy the buffer
                        //
                        memcpy(pSecurityDescriptor, var.blob.pBlobData, var.blob.cbSize);
                    }
                    else
                    {
                        rc = MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL;
                    }
                    delete [] var.blob.pBlobData;
                    *lpnLengthNeeded = var.blob.cbSize;

                }
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 440);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete [] pStringToFree;
    }

    return LogHR(rc, s_FN, 450);
}

EXTERN_C
HRESULT
APIENTRY
MQSetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepSetQueueSecurity(
					lpwcsFormatName,
					SecurityInformation,
					pSecurityDescriptor
					);

    CMQHResult rc;
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor = NULL;
    LPWSTR pStringToFree = NULL;


    __try
    {

        // Serialize the security descriptor.
        rc = RTpMakeSelfRelativeSDAndGetSize(
            &pSecurityDescriptor,
            &pSelfRelativeSecurityDescriptor,
            NULL);
        if (!SUCCEEDED(rc))
        {
            return LogHR(rc, s_FN, 470);
        }

        __try
        {
            QUEUE_FORMAT QueueFormat;

            if (!FnFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 480);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 490);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    rc = QMSetObjectSecurity(
                            &ObjectFormat,
                            SecurityInformation,
                            pSecurityDescriptor);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                {

                    PROPID prop = PROPID_Q_SECURITY;
                    MQPROPVARIANT var;

                    var.vt = VT_BLOB;
					if(pSecurityDescriptor != NULL)
					{
						var.blob.cbSize = GetSecurityDescriptorLength( pSecurityDescriptor);
						var.blob.pBlobData = reinterpret_cast<unsigned char *>(pSecurityDescriptor);
					}
					else
					{
						var.blob.cbSize = 0;
						var.blob.pBlobData = NULL;
					}

                    rc = ADSetObjectSecurityGuid(
								eQUEUE,
								NULL,		// pwcsDomainController
								false,		// fServerName
								&QueueFormat.PublicID(),
								SecurityInformation,
								prop,
								&var
								);
                }
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 500);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {

        // Free the serialized security descriptor.
        delete[] (char*) pSelfRelativeSecurityDescriptor;
        delete [] pStringToFree;
    }

    return LogHR(rc, s_FN, 510);
}

EXTERN_C
HRESULT
APIENTRY
MQPathNameToFormatName(
    IN LPCWSTR lpwcsPathName,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepPathNameToFormatName(
					lpwcsPathName,
					lpwcsFormatName,
					lpdwFormatNameLength
					);

    CMQHResult rc;
    QUEUE_FORMAT QueueFormat;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            LPCWSTR lpwcsExpandedPathName;
            QUEUE_PATH_TYPE qpt;
            qpt = FnValidateAndExpandQueuePath(
                    lpwcsPathName,
                    &lpwcsExpandedPathName,
                    &pStringToFree
                    );

            switch (qpt)
            {

                case PRIVATE_QUEUE_PATH_TYPE:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    ASSERT(tls_hBindRpc) ;
                    rc = QMObjectPathToObjectFormat(
                            tls_hBindRpc,
                            lpwcsExpandedPathName,
                            &ObjectFormat
                            );
                    ASSERT(!SUCCEEDED(rc) ||
                           (QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
                           (QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DIRECT));
                }
                break;

                case PUBLIC_QUEUE_PATH_TYPE:
                {
                    GUID guidPublic;
                    ULONG QueueGuidPropID[1] = {PROPID_Q_INSTANCE};
                    PROPVARIANT QueueGuidPropVar[1];

                    QueueGuidPropVar[0].vt = VT_CLSID;
                    QueueGuidPropVar[0].puuid = &guidPublic;
                    rc = ADGetObjectProperties(
                            eQUEUE,
                            NULL,       // pwcsDomainController
							false,	    // fServerName
                            lpwcsExpandedPathName,
                            1,
                            QueueGuidPropID,
                            QueueGuidPropVar
                            );

                    if (FAILED(rc) &&
                        (rc != MQ_ERROR_NO_DS) &&
                        (rc != MQ_ERROR_UNSUPPORTED_OPERATION))
                    {
                        rc = MQ_ERROR_QUEUE_NOT_FOUND;
                    }

                    QueueFormat.PublicID(guidPublic);
                }
                break;

                default:
                {
                    rc = MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
                }
                break;

            }

            if (SUCCEEDED(rc))
            {
                rc = RTpQueueFormatToFormatName(
                        &QueueFormat,
                        lpwcsFormatName,
                        *lpdwFormatNameLength,
                        lpdwFormatNameLength
                        );
            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 530);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        QueueFormat.DisposeString();
        delete[] pStringToFree;

    }

    return LogHR(rc, s_FN, 540);
}

EXTERN_C
HRESULT
APIENTRY
MQHandleToFormatName(
    IN QUEUEHANDLE hQueue,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepHandleToFormatName(
					hQueue,
					lpwcsFormatName,
					lpdwFormatNameLength
					);

    CMQHResult rc;
    rc = ACHandleToFormatName(
            hQueue,
            lpwcsFormatName,
            lpdwFormatNameLength
            );

    return LogHR(rc, s_FN, 560);
}

EXTERN_C
HRESULT
APIENTRY
MQInstanceToFormatName(
    IN GUID * pGuid,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepInstanceToFormatName(
					pGuid,
					lpwcsFormatName,
					lpdwFormatNameLength
					);

    CMQHResult rc;

    __try
    {

        QUEUE_FORMAT QueueFormat(*pGuid);

        rc = RTpQueueFormatToFormatName(
                &QueueFormat,
                lpwcsFormatName,
                *lpdwFormatNameLength,
                lpdwFormatNameLength
                );

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {

        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 570);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

    }

    return LogHR(rc, s_FN, 580);
}

EXTERN_C
HRESULT
APIENTRY
MQPurgeQueue(
    IN QUEUEHANDLE hQueue
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepPurgeQueue(hQueue);

    CMQHResult rc;
    rc = ACPurgeQueue(hQueue);
    return LogHR(rc, s_FN, 600);
}

EXTERN_C
HRESULT
APIENTRY
MQADsPathToFormatName(
    IN LPCWSTR lpwcsADsPath,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return MQ_ERROR_NOT_SUPPORTED_BY_DEPENDENT_CLIENTS;

    CMQHResult rc;
    QUEUE_FORMAT QueueFormat;
    LPWSTR pStringToFree = NULL;
    LPWSTR pVarStringToFree = NULL;

    __try
    {
        __try
        {
            MQPROPVARIANT var;
            eAdsClass AdsClass;
            var.vt = VT_NULL;

            rc = ADGetADsPathInfo(
                    lpwcsADsPath,
                    &var,
                    &AdsClass);
            if (FAILED(rc))
            {
                return rc;
            }

            switch( AdsClass)
            {
            case eQueue:
                ASSERT(var.vt == VT_CLSID);
                ASSERT(var.puuid != NULL);
                QueueFormat.PublicID(*var.puuid);
                delete var.puuid;
                break;
            case eGroup:
                ASSERT(var.vt == VT_CLSID);
                ASSERT(var.puuid != NULL);

                DL_ID id;
                id.m_DlGuid =*var.puuid;
                id.m_pwzDomain = RTpExtractDomainNameFromDLPath( lpwcsADsPath);

                QueueFormat.DlID(id);
                delete var.puuid;
                break;
            case eAliasQueue:
                ASSERT(var.vt == VT_LPWSTR);
                pVarStringToFree =  var.pwszVal;
                if (!FnFormatNameToQueueFormat(var.pwszVal, &QueueFormat, &pStringToFree))
                {
                    return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 3770);
                }
                if (!((QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
                      (QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PUBLIC)  ||
                      (QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DIRECT)))
                {
                    return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 3771);
                }

                break;
            default:
                ASSERT(("Should not get other object class types", 0));
                break;
            }
            rc = RTpQueueFormatToFormatName(
                    &QueueFormat,
                    lpwcsFormatName,
                    *lpdwFormatNameLength,
                    lpdwFormatNameLength
                    );


        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 530);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        QueueFormat.DisposeString();
        delete[] pStringToFree;
        delete[] pVarStringToFree;

    }

    return LogHR(rc, s_FN, 540);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtfrebnd.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    rtfrebnd.h

Abstract:
    Free binding handles

Author:
    Doron Juster  (DoronJ)

--*/

#ifndef __FREEBIND_H
#define __FREEBIND_H

#include "cs.h"


//---------------------------------------------------------
//
//  class CFreeRPCHandles
//
//---------------------------------------------------------

class CFreeRPCHandles
{
public:
	~CFreeRPCHandles();

    void Add(handle_t hBind);
    void Remove(handle_t  hBind);

private:
    CCriticalSection      m_cs;
    std::vector<handle_t>   m_handles;
};


inline  CFreeRPCHandles::~CFreeRPCHandles()
{
	for(std::vector<handle_t>::const_iterator it = m_handles.begin(); it != m_handles.end();++it)
	{
      handle_t h = *it;
      RpcBindingFree(&h);
	}
}

inline void CFreeRPCHandles::Add(handle_t hBind)
{
    CS Lock(m_cs); 
    m_handles.push_back(hBind);
}

inline void CFreeRPCHandles::Remove(handle_t hBind)
{
    CS Lock(m_cs);
	for(std::vector<handle_t>::iterator it = m_handles.begin(); it != m_handles.end();++it)
	{
      handle_t h = *it;
      if (h == hBind)
      {
          RpcBindingFree(&h);
          m_handles.erase(it);
          break;
      }
	}
}


#endif  //  __FREEBIND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtintcrt.cpp ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    rtintcrt.h

Abstract:

    Create and delete an internal certificate.

Author:

    Original code from MSMQ1.0 rt, then MSMQ2.0 cpl.
    Doron Juster  (DoronJ)  20-Aug-1998

--*/

#include "stdh.h"
#include <mqtempl.h>
#include <mqutil.h>
#include <_secutil.h>
#include <rtcert.h>
#include <mqsec.h>
#include <rtdep.h>
#include "rtputl.h"

#include "rtintcrt.tmh"

static WCHAR *s_FN=L"rt/rtintcrt";

//
// exported from mqrt.dll
//
LPWSTR rtpGetComputerNameW() ;


static CAutoCloseRegHandle s_hMqUserReg;
 

static HKEY GetUserRegHandle()
/*++

Routine Description:
    Get handle to msmq user key.

Arguments:
	None

Return Value:
	HKEY
--*/
{
	bool s_fInitialize = false;
	if(s_fInitialize)
	{
		return s_hMqUserReg;
	}

    DWORD dwDisposition;
    LONG lRes = RegCreateKeyEx( 
						FALCON_USER_REG_POS,
						FALCON_USER_REG_MSMQ_KEY,
						0,
						TEXT(""),
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&s_hMqUserReg,
						&dwDisposition 
						);

    ASSERT(lRes == ERROR_SUCCESS);
	if(lRes == ERROR_SUCCESS)
	{
		s_fInitialize = true;
	}

	return s_hMqUserReg;
}


static 
DWORD 
GetDWORDKeyValue(
	LPCWSTR RegName
	)
/*++

Routine Description:
    Read DWORD registry key.

Arguments:
	RegName - Registry name (under HKLU\msmq)

Return Value:
	DWORD key value (0 if the key not exist)
--*/
{
    DWORD dwValue = 0;
    HKEY hMqUserReg = GetUserRegHandle();
    if (hMqUserReg != NULL)
    {
		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(dwValue);
        LONG lRes = RegQueryValueEx( 
						hMqUserReg,
						RegName,
						0,
						&dwType,
						(LPBYTE) &dwValue,
						&dwSize 
						);

        if (lRes != ERROR_SUCCESS)
        {
            return 0;
        }
    }
	return dwValue;
}



static 
void 
SetDWORDKeyValue(
	 LPCWSTR RegName, 
	 DWORD Value
	 )
/*++

Routine Description:
    Set DWORD registry key value.

Arguments:
	RegName - Registry name (under HKLU\msmq)
	Value - the value to set

Return Value:
	None
--*/
{
    HKEY hMqUserReg = GetUserRegHandle();
    if (hMqUserReg != NULL)
    {
		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(Value);

		LONG lRes = RegSetValueEx( 
						hMqUserReg,
						RegName,
						0,
						dwType,
						(LPBYTE) &Value,
						dwSize 
						);

		DBG_USED(lRes);
		ASSERT(lRes == ERROR_SUCCESS);
		TrTRACE(rtintcrt, "Set registry %ls = %d", RegName, Value);
	}
}



static bool ShouldRegisterCertInDs()
/*++

Routine Description:
    Check if SHOULD_REGISTERD_IN_DS_REGNAME is Set.

Arguments:
	None

Return Value:
	true if CERTIFICATE_SHOULD_REGISTERD_IN_DS_REGNAME is set.
--*/
{
	DWORD ShouldRegisterdInDs = GetDWORDKeyValue(CERTIFICATE_SHOULD_REGISTERD_IN_DS_REGNAME);
	return (ShouldRegisterdInDs != 0);
}



//---------------------------------------------------------
//
//  Function:
//      _GetUserAccountNameAndDomain(
//
//  Parameters:
//     fLocalSyste - TRUE if called in the context of a localSystem service.
//     szAccountName - A pointer to a buffer that receicves the address of an
//         allocated buffer that contains the account name of the user of the
//         current thread.
//     szDomainName - A pointer to a buffer that receicves the address of an
//         allocated buffer that contains the domain name of the user of the
//         current thread.
//
//  Description:
//     The function allocates and fills two buffers, one for the account name
//     of the user of the current thread, and the second buffer for the
//     domain name of the user of the current thread.
//
//---------------------------------------------------------

static HRESULT
_GetUserAccountNameAndDomain( IN BOOL    fLocalSystem,
                              IN LPTSTR *szAccountName,
                              IN LPTSTR *szDomainName )
{
    HRESULT hr = MQ_OK;
    TCHAR   szLocAccountName[64];
    DWORD   dwLocAccountNameLen = sizeof(szLocAccountName) /
                                         sizeof(szLocAccountName[0]) ;
    LPTSTR  pszLocAccountName = szLocAccountName;
    P<TCHAR>  pszLocLongAccountName = NULL;
    TCHAR   szLocDomainName[64];
    DWORD   dwLocDomainNameLen = sizeof(szLocDomainName) /
                                             sizeof(szLocDomainName[0]) ;
    LPTSTR  pszLocDomainName = szLocDomainName;
    P<TCHAR>  pszLocLongDomainName = NULL;

    P<BYTE>  pbSidAR = NULL ;
    DWORD   dwSidLen;

    try
    {
        //
        // Win NT.
        //
        PSID pSid = NULL ;

        if (fLocalSystem)
        {
            pSid = MQSec_GetLocalMachineSid( FALSE, NULL ) ;
            if (!pSid)
            {
                return LogHR(MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO, s_FN, 10);
            }
        }
        else
        {
            //
            // Get the SID of the user of the current thread.
            //
            hr = GetThreadUserSid(&pbSidAR, &dwSidLen);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 20);
            }
            pSid = pbSidAR ;
        }

        SID_NAME_USE eUse;
        //
        //  Try to get the account and domain names in to a
        //  fixed size buffers.
        //
        if (!LookupAccountSid( NULL,
                               pSid,
                               pszLocAccountName,
                               &dwLocAccountNameLen,
                               pszLocDomainName,
                               &dwLocDomainNameLen,
                               &eUse))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                //
                // The fixed size buffer are not large enough.
                // Allocate larger buffers.
                //
                if (dwLocAccountNameLen > (sizeof(szLocAccountName) /
                                           sizeof(szLocAccountName[0])))
                {
                    pszLocLongAccountName =
                                     new TCHAR[ dwLocAccountNameLen ];
                    pszLocAccountName = pszLocLongAccountName;
                }

                if (dwLocDomainNameLen > (sizeof(szLocDomainName) /
                                          sizeof(szLocDomainName[0])))
                {
                    pszLocLongDomainName = new TCHAR[ dwLocDomainNameLen ];
                    pszLocDomainName = pszLocLongDomainName;
                }

                //
                // Re-call LookupAccountSid, now with the lrger buffer(s).
                //
                if (!LookupAccountSid(  NULL,
                                        pSid,
                                        pszLocAccountName,
                                       &dwLocAccountNameLen,
                                        pszLocDomainName,
                                       &dwLocDomainNameLen,
                                       &eUse ))
                {
                    return LogHR(MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO, s_FN, 30);
                }
            }
            else
            {
                return LogHR(MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO, s_FN, 40);
            }
        }

        //
        // Allocate the buffers for the returned results, and fill the
        // allocated buffer with the result strings.
        //
        *szAccountName = new TCHAR[ dwLocAccountNameLen + 1 ];
        _tcscpy(*szAccountName, pszLocAccountName);

        *szDomainName = new TCHAR[ dwLocDomainNameLen + 1 ];
        _tcscpy(*szDomainName, pszLocDomainName);
    }
    catch(...)
    {
        LogIllegalPoint(s_FN, 60);
    }

    return LogHR(hr, s_FN, 70);
}

/*************************************************************************

  Function:
     RTCreateInternalCertificate

  Parameters -
    ppCert - On return, get the certificate object.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -
    If the store already contain a certificate, the function falis.

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTCreateInternalCertificate(
    OUT CMQSigCertificate **ppCert
    )
{
	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

	if(IsWorkGroupMode())
	{
		//
		// For Workgroup return UNSUPPORTED_OPERATION
		//
		return LogHR(MQ_ERROR_UNSUPPORTED_OPERATION, s_FN, 75);
	}

    HRESULT hr;
    BOOL fLocalUser;
    BOOL fLocalSystem;

    if (ppCert)
    {
        *ppCert = NULL;
    }

    //
    // Local users are not let in.
    //
    hr = MQSec_GetUserType( NULL,
                           &fLocalUser,
                           &fLocalSystem ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 80);
    }
    if (fLocalUser)
    {
	    return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 90);
    }

    LONG nCerts;
    R<CMQSigCertStore> pStore ;
    //
    // Get the internal certificate store.
    //
    hr = RTOpenInternalCertStore( &pStore.ref(),
                                  &nCerts,
                                  TRUE,
                                  fLocalSystem,
                                  FALSE ) ;  // fUseCurrentUser
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100);
    }

    if (nCerts)
    {
        return LogHR(MQ_ERROR_INTERNAL_USER_CERT_EXIST, s_FN, 110);
    }
    HCERTSTORE  hStore = pStore->GetHandle() ;

    //
    // Get the user's account name and domain name.
    //
    AP<TCHAR> szAccountName;
    AP<TCHAR> szDomainName;

    hr = _GetUserAccountNameAndDomain( fLocalSystem,
                                      &szAccountName,
                                      &szDomainName );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 180);
    }

    //
    // Get the name of the computer.
    //
    #define COMPUTER_NAME_LEN  256
    WCHAR szHostNameW[ COMPUTER_NAME_LEN ];
    DWORD dwHostNameLen = sizeof(szHostNameW) / sizeof(szHostNameW[0]) ;

    if (FAILED(GetComputerNameInternal(szHostNameW, &dwHostNameLen)))
    {
        return LogHR(MQ_ERROR, s_FN, 190);
    }

    P<TCHAR> szComputerName = new TCHAR[ dwHostNameLen + 2 ] ;
#ifdef UNICODE
    wcscpy(szComputerName, szHostNameW) ;
#else
    SecConvertFromWideCharString(szHostNameW,
                                 szComputerName,
                                 (dwHostNameLen + 2)) ;
#endif

    R<CMQSigCertificate> pSigCert = NULL ;
    hr = MQSigCreateCertificate (&pSigCert.ref()) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 200);
    }
    else if (pSigCert.get() == NULL)
    {
        return LogHR(MQ_ERROR, s_FN, 210);
    }

    hr = pSigCert->PutValidity( INTERNAL_CERT_DURATION_YEARS ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 220);
    }

    hr = pSigCert->PutIssuer( MQ_CERT_LOCALITY,
                              _T("-"),
                              _T("-"),
                              szDomainName,
                              szAccountName,
                              szComputerName ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 230);
    }

    hr = pSigCert->PutSubject( MQ_CERT_LOCALITY,
                               _T("-"),
                               _T("-"),
                               szDomainName,
                               szAccountName,
                               szComputerName ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 240);
    }

    //
    // When renewing the internal certificate, always renew the
    // private/public keys pair.
    //
    BOOL fCreated = FALSE ;
    hr = pSigCert->PutPublicKey( TRUE,
                                 fLocalSystem,
                                &fCreated) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 250);
    }
    ASSERT(fCreated) ;

    hr = pSigCert->EncodeCert( fLocalSystem,
                               NULL,
                               NULL) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 260);
    }

    hr = pSigCert->AddToStore(hStore) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 270);
    }

    if (ppCert)
    {
        *ppCert = pSigCert.detach();
    }

    return(MQ_OK);
}

/*************************************************************************

  Function:
     RTDeleteInternalCert( IN CMQSigCertificate *pCert )

  Parameters -
    pCert - Certificate object.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
RTDeleteInternalCert(
    IN CMQSigCertificate *pCert
    )
{
	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr = pCert->DeleteFromStore() ;
    return LogHR(hr, s_FN, 280);
}


//+------------------------------------------------------------------------
//
//  MQRegisterCertificate()
//
//  Description: Create an internal certificate and register it in the DS.
//
//  Input:
//      IN DWORD   dwFlags- one of the followings:
//          MQCERT_REGISTER_IF_NOT_EXIST- create a new internal certificate
//              only if there is not a previous one on local machine. The
//              test for existing certificate is local and no access to
//              remote DS server is made. So this check can be safely made
//              if machine is offline, without hanging it.
//      IN PVOID   lpCertBuffer- NULL for internal certificate.
//          Otherwise, pointer to external certificate buffer. In this case,
//          the api only register the external certificate in the DS and
//          flag "MQCERT_REGISTER_IF_NOT_EXIST" must not be specified.
//      IN DWORD   dwCertBufferLength- Size, in bytes, of buffer of external
//          certificate.
//
//+------------------------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
MQRegisterCertificate( 
	IN DWORD   dwFlags,
	IN PVOID   lpCertBuffer,
	IN DWORD   dwCertBufferLength 
	)
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(IsWorkGroupMode())
	{
		//
		// For Workgroup return UNSUPPORTED_OPERATION
		//
		TrTRACE(rtintcrt, "register certificate is not supported in workgroup mode");
		return LogHR(MQ_ERROR_UNSUPPORTED_OPERATION, s_FN, 285);
	}

	if(g_fDependentClient)
		return DepRegisterCertificate(
					dwFlags, 
					lpCertBuffer, 
					dwCertBufferLength
					);

    //
    // First check validity of input parameters.
    //
    if (lpCertBuffer)
    {
        if (dwFlags & MQCERT_REGISTER_IF_NOT_EXIST)
        {
            //
            // The "if_not_exist" flag is relevant only for internal
            // certificate, because we create it.
            //
			TrERROR(rtintcrt, "MQCERT_REGISTER_IF_NOT_EXIST flag is valid only for Internal certificate");
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 290);
        }
        else if (dwCertBufferLength == 0)
        {
            //
            // Length must be specified for the external certificate.
            //
			TrERROR(rtintcrt, "Invalid parameter, dwCertBufferLength = 0");
            return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 300);
        }
    }

    //
    // Next, check if local user. They are not let in. the SID of a local
    // user is not meaningful outside of his local machine. There is no
    // user object in the DS for a local user, so we don't have a place to
    // register his certificate.
    //
    BOOL fLocalUser =  FALSE;
    BOOL fLocalSystem = FALSE;

    hr = MQSec_GetUserType( 
				NULL,
				&fLocalUser,
				&fLocalSystem 
				);

    if (FAILED(hr))
    {
		TrERROR(rtintcrt, "MQSec_GetUserType failed, hr = 0x%x", hr);
        return LogHR(hr, s_FN, 310);
    }
    else if (fLocalUser)
    {
		TrERROR(rtintcrt, "register certificate is not supported for local user");
	    return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 320);
    }

    //
    // Next, check if an internal certificate already exist.
    //

    R<CMQSigCertStore> pStore = NULL;
    if (dwFlags & MQCERT_REGISTER_IF_NOT_EXIST)
    {
        LONG nCerts = 0;
        hr = RTOpenInternalCertStore( 
					&pStore.ref(),
					&nCerts,
					TRUE,
					fLocalSystem,
					FALSE   // fUseCurrectUser
					); 
        if (FAILED(hr))
        {
			TrERROR(rtintcrt, "Failed to open internal store, hr = 0x%x", hr);
            return LogHR(hr, s_FN, 330);
        }
        else if ((nCerts) && !ShouldRegisterCertInDs())
        {
            //
            // OK, we already have an internal certificate and it is register in the DS.
            //
			TrTRACE(rtintcrt, "internal user certificate already exist in the local store and is registered in the DS");
            return LogHR(MQ_INFORMATION_INTERNAL_USER_CERT_EXIST, s_FN, 340);
        }

		TrTRACE(rtintcrt, "number of certificate that were found in the local store = %d", nCerts);
        pStore.free();
    }

    BOOL fIntCreated = FALSE;
    R<CMQSigCertificate> pCert = NULL;
    if (!lpCertBuffer)
    {
        //
        // Creating an internal certificate also mean to recreate the user
        // private key. So before destroying previous keys, let's check
        // if the user has permission to register his certificate and if
        // local machine can access the DS at present. We'll do this by
        // trying to register previous internal certificate.
        //
        // Open the certificates store with write access, so we can later
        // delete the internal certificate, before creating a new one.
        //
        hr = RTGetInternalCert( 
					&pCert.ref(),
					&pStore.ref(),
					TRUE,
					fLocalSystem,
					FALSE	//  fUseCurrentUser 
					);  

        if (SUCCEEDED(hr))
        {
            //
            // Try to register in the DS.
            //
    		hr = RTRegisterUserCert( 
						pCert.get(),
						fLocalSystem 
						);

			if(FAILED(hr) && (hr != MQ_ERROR_INTERNAL_USER_CERT_EXIST))
	    	{
				TrERROR(rtintcrt, "register user certificate in the DS failed, hr = 0x%x", hr);
                return LogHR(hr, s_FN, 350);
    		}

            //
            // Remove the internal certificate from MQIS.
            //
            hr = RTRemoveUserCert(pCert.get()) ;
            if (FAILED(hr) && (hr != MQDS_OBJECT_NOT_FOUND))
            {
				TrERROR(rtintcrt, "Failed to remove user certificate from the DS, hr = 0x%x", hr);
                return LogHR(hr, s_FN, 360);
            }
            //
            // Remove the internal certificate from the local certificate
            // store.
            //
            hr = RTDeleteInternalCert(pCert.get());
            if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
            {
				//
				// The certificate was deleted from the DS
				// but we failed to delete it from the local store
				// so we should try again to register the certificate
				// Mark that we have a certificate in the local store that is not registered in the DS
				//
				SetDWORDKeyValue(CERTIFICATE_SHOULD_REGISTERD_IN_DS_REGNAME, true);
				TrERROR(rtintcrt, "Failed to delete internal user certificate from local store, hr = 0x%x", hr);
                return LogHR(hr, s_FN, 370);
            }

            pCert.free();
        }

        //
        // It's time to create the internal certificate.
        //
        ASSERT(pCert.get() == NULL);
        hr = RTCreateInternalCertificate(&pCert.ref());
		if (FAILED(hr))
		{
			TrERROR(rtintcrt, "Failed to create internal certificate, hr = 0x%x", hr);
			return LogHR(hr, s_FN, 380);
		}

        fIntCreated = TRUE;
    }
    else
    {
        hr = MQSigCreateCertificate( 
					&pCert.ref(),
					NULL,
					(LPBYTE) lpCertBuffer,
					dwCertBufferLength 
					);
		if (FAILED(hr))
		{
			TrERROR(rtintcrt, "MQSigCreateCertificate() failed, hr = 0x%x", hr);
			return LogHR(hr, s_FN, 390);
		}
    }

    if (lpCertBuffer == NULL)
    {
		//
		// For internal certificate, reset SHOULD_REGISTERD_IN_DS flag before 
		// the actual certificate register in the DS succeeded.
		// This is for the following rare crash scenario:
		// 1) Register the certificate in the DS completed
		// 2) SHOULD_REGISTERD_IN_DS was true
		// 3) We crashed
		// in that case setting the registry before the actual writing to the DS
		// will make sure that next time we will not create a new certificate.
		//
		SetDWORDKeyValue(CERTIFICATE_SHOULD_REGISTERD_IN_DS_REGNAME, false);
	}

	hr = RTRegisterUserCert(pCert.get(), fLocalSystem);
    if (SUCCEEDED(hr) && (lpCertBuffer == NULL))
    {
		TrERROR(rtintcrt, "Certificate registered successfully in the DS");
	    return LogHR(hr, s_FN, 395);
    }

	if (fIntCreated)
    {
		ASSERT(FAILED(hr));

        //
        // We created a new certificate in registry but failed to register
        // it in DS. delete from local registry.
        //
		TrERROR(rtintcrt, "We failed to register internal certificate in the DS, hr = 0x%x", hr);
        pCert.free();
        pStore.free();

        HRESULT hr1 = RTGetInternalCert( 
							&pCert.ref(),
							&pStore.ref(),
							TRUE,
							fLocalSystem,
							FALSE   // fUseCurrentUser
							);
        if (SUCCEEDED(hr1))
        {
            hr1 = RTDeleteInternalCert(pCert.get());
        }

        ASSERT(SUCCEEDED(hr1));

		if (FAILED(hr1))
		{
			//
			// We failed to register the certificate in the DS
			// but also failed to delete it from the local store
			// so we should try again.
			// Mark that we have a certificate in the local store that is not registered in the DS
			//
			SetDWORDKeyValue(CERTIFICATE_SHOULD_REGISTERD_IN_DS_REGNAME, true);
			TrERROR(rtintcrt, "Failed to delete internal certificate from local store");
		}
    }

    return LogHR(hr, s_FN, 400);
}


//+-------------------------------------------------------------------------
//
//  STDAPI DllRegisterServer()
//
//  this code is run on every logon, from regsvr32. It's the reponsibility
//  of setup to insert the regsvr32 command in the "run" registry. This
//  code will register an internal certificate for each new domain user
//  that logon the machine.
//
//+-------------------------------------------------------------------------

STDAPI DllRegisterServer()
{
	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

	if(IsWorkGroupMode())
	{
		//
		// For Workgroup do nothing
		// This enable setup to always insert regsvr32 command in the "run" registry
		// regardless of workgroup or domain.
		//
		return MQ_OK;
	}

    //
    // First see if auto registration was disabled by user.
    //
    DWORD dwEnableRegister = DEFAULT_AUTO_REGISTER_INTCERT;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(dwEnableRegister);
    LONG rc = GetFalconKeyValue( 
					AUTO_REGISTER_INTCERT_REGNAME,
					&dwType,
					&dwEnableRegister,
					&dwSize 
					);

    if ((rc == ERROR_SUCCESS) && (dwEnableRegister == 0))
    {
		TrTRACE(rtintcrt, "enable register internal certificate is blocked by registry key");
        return MQ_OK;
    }

    //
    // Next see if auto-registration was already done for this user
    //
    DWORD dwRegistered = GetDWORDKeyValue(CERTIFICATE_REGISTERD_REGNAME);
    if (dwRegistered == INTERNAL_CERT_REGISTERED)
    {
        //
        // Certificate already registered.
        //
		TrTRACE(rtintcrt, "Internal certificate already registered");
        return MQ_OK;
    }

    //
    // Read number of 15 seconds intervals to wait for MSMQ DS server.
    //
    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    DWORD dwDef = DEFAULT_AUTO_REGISTER_WAIT_DC;
    DWORD dwWaitIntervals = DEFAULT_AUTO_REGISTER_WAIT_DC;

    READ_REG_DWORD( 
			dwWaitIntervals,
			AUTO_REGISTER_WAIT_DC_REGNAME,
			&dwDef 
			);

    //
    // OK, now it's time to resiter the certificate.
    //
    DWORD iCount = 0;
    BOOL  fTryAgain = FALSE;
    HRESULT hr = MQ_OK;

    do
    {
        fTryAgain = FALSE;
        hr = MQRegisterCertificate( 
				MQCERT_REGISTER_IF_NOT_EXIST,
				NULL,
				0 
				);

        if (SUCCEEDED(hr))
        {
            //
            // Save success status in registry.
            //
			SetDWORDKeyValue(CERTIFICATE_REGISTERD_REGNAME, INTERNAL_CERT_REGISTERED);
        }
        else if (hr == MQ_ERROR_NO_DS)
        {
            //
            // MSMQ DS server not yet found.
            // wait 15 seconds and try again.
            //
            if (iCount < dwWaitIntervals)
            {
                iCount++;
                Sleep(15000);
                fTryAgain = TRUE;
            }
        }
    } while (fTryAgain);

    if (FAILED(hr))
    {
		SetDWORDKeyValue(AUTO_REGISTER_ERROR_REGNAME, hr); 
		TrERROR(rtintcrt, "MQRegisterCertificate failed hr = 0x%x", hr);
	}

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtmgmt.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    rtmgmt.cpp

Abstract:

    Management.

Author:

    RaphiR

Revision History:

--*/

#include "stdh.h"
#include "fntoken.h"
#include "mgmtrpc.h"
#include "qmmgmt.h"
#include "rtprpc.h"
#include <mqutil.h>
#include <rtdep.h>

#include "rtmgmt.tmh"

static WCHAR *s_FN=L"rt/rtmgmt";

//---------------------------------------------------------
//
//  Function:
//      RTpMgmtObjectNameToMgmtObject
//
//  Description:
//      Convert a format name string to a Management Object union.
//
//    This function allocates a MGMT_OBJECT, which must
//    be free with RTpMgmtFreeMgmtObject function
//
//---------------------------------------------------------
static
BOOL
RTpMgmtObjectNameToMgmtObject(
    LPCWSTR lpwstrObjectName,
    LPWSTR* ppStringToFree,
    MGMT_OBJECT* pObj,
    QUEUE_FORMAT* pqf
    )
{

    //
    // Handle MACHINE= case
    //
    if(_wcsnicmp(lpwstrObjectName, MO_MACHINE_TOKEN, STRLEN(MO_MACHINE_TOKEN)) == 0)
    {
        pObj->type = MGMT_MACHINE;
        pObj->dwMachineInfo = 0;
        return TRUE;
    }

    //
    // Handle QUEUE= case
    // 
    if(_wcsnicmp(lpwstrObjectName, MO_QUEUE_TOKEN, STRLEN(MO_QUEUE_TOKEN)) == 0)
    {
        pObj->type = MGMT_QUEUE;
        pObj->pQueueFormat = pqf;
        return FnFormatNameToQueueFormat(
                    &lpwstrObjectName[STRLEN(MO_QUEUE_TOKEN) + 1],
                    pqf,
                    ppStringToFree
                    );
    }

    return FALSE;
}


//---------------------------------------------------------
//
//  Function:
//      GetRpcClientHandle
//
//  Description:
//      
//---------------------------------------------------------
static 
HRESULT 
GetRpcClientHandle(   
    handle_t* phBind
    )
{

    WCHAR *wcsStringBinding = NULL;

    RPC_STATUS status = RpcStringBindingCompose( NULL,
                                                 QMMGMT_PROTOCOL,
                                                 NULL,
                                                 g_pwzQmmgmtEndpoint,
                                                 QMMGMT_OPTIONS,
                                                 &wcsStringBinding);
    LogRPCStatus(status, s_FN, 10);

    if (status != RPC_S_OK)
    {
        return MQ_ERROR ;
    }

    status = RpcBindingFromStringBinding(wcsStringBinding, phBind);
    LogRPCStatus(status, s_FN, 20);
    if (status != RPC_S_OK)
    {
        return MQ_ERROR ;
    }

    status = RpcStringFree(&wcsStringBinding);
    LogRPCStatus(status, s_FN, 30);

    return MQ_OK ;
}


static
HRESULT
RTpMgmtAction(
    HANDLE hBind,
    const MGMT_OBJECT* pMgmtObj,
    LPCWSTR pAction
    )
{
    __try
    {
    	HRESULT hr = R_QMMgmtAction(
                hBind,
                pMgmtObj, 
                pAction
                );
        return LogHR(hr, s_FN, 40);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        HRESULT rc;
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 50); 

        if(SUCCEEDED(rc))
        {
            return MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

        return rc;
    }
}


HRESULT
LocalMgmtAction(
    const MGMT_OBJECT* pMgmtObj, 
    LPCWSTR pAction
    )
{
    //
    // Get local  RPC binding Handle
    //
    HRESULT hr ;
    handle_t hBind = NULL;
    hr = GetRpcClientHandle(&hBind) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60);
    }
    ASSERT(hBind != NULL);

    hr =  RTpMgmtAction(
                hBind,
                pMgmtObj,
                pAction
                );

    RpcBindingFree(&hBind);

    return LogHR(hr, s_FN, 70);
}


HRESULT
RemoteMgmtAction(
    LPCWSTR pMachineName,
    const MGMT_OBJECT* pMgmtObj, 
    LPCWSTR pAction
    )
{
    //
    // Call remote administrator
    //
    HRESULT hr;
    hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;

    CALL_REMOTE_QM(
        const_cast<LPWSTR>(pMachineName), 
        hr, 
        RTpMgmtAction(hBind, pMgmtObj, pAction)
        );

    return LogHR(hr, s_FN, 80);
}


EXTERN_C
HRESULT
APIENTRY
MQMgmtAction(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN LPCWSTR pAction
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepMgmtAction(pMachineName, pObjectName, pAction);

    CMQHResult rc;

    ASSERT(pObjectName);
    ASSERT(pAction);

    QUEUE_FORMAT qf;
    MGMT_OBJECT MgmtObj;

    //
    // Parse the object name
    //
    AP<WCHAR> pStringToFree = NULL;
    if(!RTpMgmtObjectNameToMgmtObject(pObjectName, &pStringToFree, &MgmtObj, &qf))
    {
        return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 90);
    }

    if (pMachineName == NULL)
    {
        hr = LocalMgmtAction(&MgmtObj, pAction);
        return LogHR(hr, s_FN, 100);
    }
    else
    {
        hr = RemoteMgmtAction(pMachineName, &MgmtObj, pAction);
        return LogHR(hr, s_FN, 110);
    }
}


static
HRESULT
RTpMgmtGetInfo(
    HANDLE hBind,
    const MGMT_OBJECT* pMgmtObj,
    MQMGMTPROPS* pMgmtProps
    )
{
    __try
    {
        HRESULT hr = R_QMMgmtGetInfo(
                hBind,
                pMgmtObj, 
                pMgmtProps->cProp,
                pMgmtProps->aPropID,
                pMgmtProps->aPropVar
                );
        return LogHR(hr, s_FN, 120);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        HRESULT rc;
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 130); 

        if(SUCCEEDED(rc))
        {
            return LogHR(MQ_ERROR_SERVICE_NOT_AVAILABLE, s_FN, 140);
        }

        return rc;
    }
}


static
HRESULT
LocalMgmtGetInfo(
    const MGMT_OBJECT* pMgmtObj, 
    MQMGMTPROPS* pMgmtProps
    )
{
    HRESULT hr ;

    //
    // Get local  RPC binding Handle
    //
    handle_t hBind = NULL;
    hr = GetRpcClientHandle(&hBind) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 150);
    }
    ASSERT(hBind != NULL);

    hr =  RTpMgmtGetInfo(
                hBind,
                pMgmtObj, 
                pMgmtProps
                );

    RpcBindingFree(&hBind);

    return LogHR(hr, s_FN, 160);
}


static
HRESULT
RemoteMgmtGetInfo(
    LPCWSTR pMachineName,
    const MGMT_OBJECT* pMgmtObj, 
    MQMGMTPROPS* pMgmtProps
    )
{
    HRESULT hr;

    //
    // Call remote administrator
    //
    hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;

    CALL_REMOTE_QM(
        const_cast<LPWSTR>(pMachineName), 
        hr, 
        RTpMgmtGetInfo(hBind, pMgmtObj, pMgmtProps)
        );

    return LogHR(hr, s_FN, 170);
}


EXTERN_C
HRESULT
APIENTRY
MQMgmtGetInfo(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN OUT MQMGMTPROPS* pMgmtProps
    )
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepMgmtGetInfo(pMachineName, pObjectName, pMgmtProps);

    CMQHResult rc;

    ASSERT(pObjectName);
    ASSERT(pMgmtProps);

    QUEUE_FORMAT qf;
    MGMT_OBJECT MgmtObj;

    //
    // Parse the object name
    //
    AP<WCHAR> pStringToFree = NULL;
    if(!RTpMgmtObjectNameToMgmtObject(pObjectName, &pStringToFree, &MgmtObj, &qf))
    {
        return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 180);
    }

    //
    // Make sure the propvar is set to VT_NULL 
    // (we dont support anything else)
    //
    memset(pMgmtProps->aPropVar, 0, pMgmtProps->cProp * sizeof(PROPVARIANT));
    for (DWORD i = 0; i < pMgmtProps->cProp; ++i)
    {
        pMgmtProps->aPropVar[i].vt = VT_NULL;
    }

    if (pMachineName == NULL)
    {
        hr = LocalMgmtGetInfo(&MgmtObj, pMgmtProps);
        return LogHR(hr, s_FN, 190);
    }
    else
    {
        hr = RemoteMgmtGetInfo(pMachineName, &MgmtObj, pMgmtProps);
        return LogHR(hr, s_FN, 200);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtmain.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtmain.cpp

Abstract:

    This module contains code involved with Dll initialization.

Author:

    Erez Haba (erezh) 24-Dec-95

Revision History:

--*/

#include "stdh.h"
#include "mqutil.h"
#include "_mqrpc.h"
#include "cs.h"
#include "rtsecutl.h"
#include "rtprpc.h"
#include "verstamp.h"
#include "rtfrebnd.h"
//
// mqwin64.cpp may be included only once in a module
//
#include <mqwin64.cpp>

#include <Xds.h>
#include <Cry.h>
#include <dld.h>

#include "rtmain.tmh"

static WCHAR *s_FN=L"rt/rtmain";

//
//  Holds MSMQ version for debugging purposes
//
CHAR *g_szMsmqBuildNo = VER_PRODUCTVERSION_STR;  

void InitErrorLogging();

BOOL  g_fDependentClient = FALSE ;   // TRUE if running as dependent Client

//
// TLS index for per-thread event.
//
DWORD  g_dwThreadEventIndex = 0;

// QM computer name (for the client - server's name)
LPWSTR  g_lpwcsComputerName = NULL;
DWORD   g_dwComputerNameLen = 0;

AP<char> g_pQmSid_buff;

#define g_pQmSid ((PSID)(char*)g_pQmSid_buff)

//
//  Default for PROPID_M_TIME_TO_REACH_QUEUE
//
DWORD  g_dwTimeToReachQueueDefault = MSMQ_DEFAULT_LONG_LIVE ;

//
// RPC related data.
//
CFreeRPCHandles g_FreeQmLrpcHandles;
BOOL InitRpcGlobals() ;

//
// Serializes calls to DTC
//
extern HANDLE g_hMutexDTC;

//
// Type of Falcon machine (client, server)
//
DWORD  g_dwOperatingSystem;

//
// There is a separate rpc binding handle for each thread. This is necessary
// for handling impersonation, where each thread can impersonate another
// user.
//
// The handle is stored in a TLS slot because we can't use declspec(thread)
// because the dll is dynamically loaded (by LoadLibrary()).
//
// This is the index of the slot.
//
DWORD  g_hBindIndex = UNINIT_TLSINDEX_VALUE ;

extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;

static HRESULT OneTimeThreadInit()
{
    //
    //  Init per thread local RPC binding handle 
    //
    if (tls_hBindRpc != 0)
        return MQ_OK;

    handle_t hBind = RTpGetQMServiceBind();

    if (hBind == 0)
    {
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
    //
    //  Keep handle for cleanup
    //
    try
    {
        g_FreeQmLrpcHandles.Add(hBind);
    }
    catch(const bad_alloc&)
    {
        RpcBindingFree(&hBind);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    BOOL fSet = TlsSetValue(g_hBindIndex, hBind);
    ASSERT(fSet);
	DBG_USED(fSet);
    return MQ_OK;
}

//---------------------------------------------------------
//
//  InitializeQM(...)
//
//  Description:
//
//      Per process QM initialization.
//      Currently the only initialization is to allow the QM to open the application's
//      process in order to duplicate handles for the application.
//
//  Return Value:
//
//      MQ_OK, if successful, else MQ error code.
//
//---------------------------------------------------------

static HRESULT InitializeQM(void)
{
    //
    // Get the cumputer name, we need this value in several places.
    //
    g_dwComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
    AP<WCHAR> lpwcsComputerName = new WCHAR[MAX_COMPUTERNAME_LENGTH + 1];
    HRESULT hr= GetComputerNameInternal(
        lpwcsComputerName,
        &g_dwComputerNameLen
        );

    ASSERT(SUCCEEDED(hr) );
    g_lpwcsComputerName = lpwcsComputerName.detach();

    RTpInitXactRingBuf();

    g_dwOperatingSystem = MSMQGetOperatingSystem();


    ASSERT(tls_hBindRpc == NULL) ;
    hr = OneTimeThreadInit();
    if (FAILED(hr))
    {
        return hr;
    }

    DWORD cSid;
    HANDLE hProcess = GetCurrentProcess();
    AP<char> pSD_buff;
    SECURITY_DESCRIPTOR AbsSD;
    DWORD cSD;
    AP<char> pNewDacl_buff;
    BOOL bRet;
    BOOL bPresent;
    PACL pDacl;
    BOOL bDefaulted;
    DWORD dwAceSize;

#define pSD ((PSECURITY_DESCRIPTOR)(char*)pSD_buff)
#define pNewDacl ((PACL)(char*)pNewDacl_buff)

    try
    {
        ASSERT( tls_hBindRpc ) ;

        //
        // In multi-qm environment we want to access registry section
        // of the correct QM only. Cluster guarantees that this code runs
        // only when the correct QM is running, so we should not fail.
        // On non cluster systems it doesn't matter if we fail here. (ShaiK)
        //
        AP<WCHAR> lpServiceName = 0;
        hr = QMGetMsmqServiceName( tls_hBindRpc, &lpServiceName );
		if (FAILED(hr))
		{
			return (hr);
		}

        SetFalconServiceName(lpServiceName);

        // Get the SID of the user that runs the QM.
        // First see how bug is the SID.
        hr = QMAttachProcess( tls_hBindRpc, GetCurrentProcessId(), 0, NULL, &cSid);
    }
    catch(...)
    {
        //
        //  The QM is not running, let us load, all APIs
        //  will return no QM, no DS
        //
        LogIllegalPoint(s_FN, 10);
        return MQ_OK;
    }

    if (SUCCEEDED(hr))
    {
        //
        // The QM can duplicate handles to us, no need to worry anymore!
        //
        return MQ_OK;
    }

    if (hr != MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
    {
        return LogHR(hr, s_FN, 20);
    }

    // Allocate a buffer for the SID.
    g_pQmSid_buff = new char[cSid];
    // Get the SID.
    ASSERT( tls_hBindRpc ) ;
    hr = QMAttachProcess( tls_hBindRpc,
                          0,
                          cSid,
                          (unsigned char *)g_pQmSid,
                          &cSid);
    if (hr != MQ_OK)
    {
        return LogHR(hr, s_FN, 30);
    }

    // Get the process security descriptor.
    // First see how big is the security descriptor.
    GetKernelObjectSecurity(hProcess, DACL_SECURITY_INFORMATION, NULL, 0, &cSD);
    
    DWORD gle = GetLastError();
    if (gle != ERROR_INSUFFICIENT_BUFFER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR,
               TEXT("Failed to get process security descriptor (NULL buffer), error %d"),
               gle));

        LogNTStatus(gle, s_FN, 40);
        return(MQ_ERROR);
    }

    // Allocate a buffer for the securiy descriptor.
    pSD_buff = new char[cSD];
    // Get the security descriptor.
    if (!GetKernelObjectSecurity(hProcess, DACL_SECURITY_INFORMATION, pSD, cSD, &cSD))
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR,
               TEXT("Failed to get process security descriptor, error %d"),
               GetLastError()));

        return LogHR(MQ_ERROR, s_FN, 50);
    }

    // Get the DACL from the security descriptor.
    bRet = GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted);
    ASSERT(bRet);
    // Calculate the size of the new ACE.
    dwAceSize = sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(g_pQmSid) - sizeof(DWORD);

    if (bPresent)
    {
        // The security descriptor contains a DACL. Append our new ACE to this DACL.

        ACL_SIZE_INFORMATION AclSizeInfo;

        bRet = GetAclInformation(pDacl, &AclSizeInfo, sizeof(AclSizeInfo), AclSizeInformation);
        ASSERT(bRet);
        if (AclSizeInfo.AclBytesFree < dwAceSize)
        {
            // The currect DACL is not large enough.
            LPVOID pAce;
            // Calculate the size for the new DACL.
            DWORD dwNewDaclSize = AclSizeInfo.AclBytesInUse + dwAceSize;

            // Allocate a buffer for a new DACL.
            pNewDacl_buff = new char[dwNewDaclSize];
            // Initialize the new DACL.
            bRet = InitializeAcl(pNewDacl, dwNewDaclSize, ACL_REVISION);
            ASSERT(bRet);
            // Copy the current ACEs to the new DACL.
            bRet = GetAce(pDacl, 0, &pAce);
            ASSERT(bRet); // Get current ACEs
            bRet = AddAce(pNewDacl, ACL_REVISION, 0, pAce, AclSizeInfo.AclBytesInUse - sizeof(ACL));
            ASSERT(bRet);
            pDacl = pNewDacl;
        }
    }
    else
    {
        // The security descriptor does not contain a DACL.
        // Calculate the size for the DACL.
        DWORD dwNewDaclSize = sizeof(ACL) + dwAceSize;

        // Allocate a buffer for the DACL.
        pNewDacl_buff = new char[dwNewDaclSize];
        // Initialize the DACL.
        bRet = InitializeAcl(pNewDacl, dwNewDaclSize, ACL_REVISION);
        ASSERT(bRet);
        pDacl = pNewDacl;
    }

    // Add a new ACE that gives permission for the QM to duplicatge handles for the
    // application.
    bRet = AddAccessAllowedAce(pDacl, ACL_REVISION, PROCESS_DUP_HANDLE, g_pQmSid);
    ASSERT(bRet);

    // Initialize a new absolute security descriptor.
    bRet = InitializeSecurityDescriptor(&AbsSD, SECURITY_DESCRIPTOR_REVISION);
    ASSERT(bRet);
    // Set the DACL of the new absolute security descriptor.
    bRet = SetSecurityDescriptorDacl(&AbsSD, TRUE, pDacl, FALSE);
    ASSERT(bRet);

    // Set the security descriptor of the process.
    if (!SetKernelObjectSecurity(hProcess, DACL_SECURITY_INFORMATION, &AbsSD))
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR,
               TEXT("Failed to set process security descriptor, error %d"),
               GetLastError()));

        return LogHR(MQ_ERROR, s_FN, 60);
    }

#undef pSD
#undef pNewDacl

    return(MQ_OK);
}

//---------------------------------------------------------
//
//  LPWSTR rtpGetComputerNameW()
//
//  Note: this function is exported, to be used by the control panel
//
//---------------------------------------------------------

LPWSTR rtpGetComputerNameW()
{
    return  g_lpwcsComputerName ;
}

//---------------------------------------------------------
//
//  FreeGlobals(...)
//
//  Description:
//
//      Release allocated globals
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

void  TerminateRxAsyncThread() ;
extern TBYTE* g_pszStringBinding ;

static void FreeGlobals()
{
    TerminateRxAsyncThread() ;

    delete[] g_lpwcsComputerName;
    delete g_pSecCntx;

    BOOL fFree = TlsFree( g_hBindIndex ) ;
    ASSERT(fFree) ;
    fFree = TlsFree( g_dwThreadEventIndex ) ;
    ASSERT(fFree) ;

    mqrpcUnbindQMService( NULL, &g_pszStringBinding) ;

    if (g_hMutexDTC)
    {
        CloseHandle(g_hMutexDTC);
    }

    fFree = TlsFree( g_hThreadIndex ) ;
    ASSERT(fFree) ;
}

//---------------------------------------------------------
//
//  FreeThreadGlobals(...)
//
//  Description:
//
//      Release per-thread allocated globals
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

static void  FreeThreadGlobals()
{
   HANDLE hEvent = TlsGetValue(g_dwThreadEventIndex);
   if (hEvent)
   {
      CloseHandle(hEvent) ;
   }

   if (g_hThreadIndex != UNINIT_TLSINDEX_VALUE)
   {
        HANDLE hThread = TlsGetValue(g_hThreadIndex);
        if ( hThread)
        {
            CloseHandle( hThread);
        }
   }

   //
   //   Free this thread local-qm RPC binding handle
   //
   handle_t hLocalQmBind = tls_hBindRpc;
   if (hLocalQmBind != 0)
   {
        g_FreeQmLrpcHandles.Remove(hLocalQmBind);
   }
}

//---------------------------------------------------------
//
//  RTIsDependentClient(...)
//
//  Description:
//
//      Returns an internal indication whether this MSMQ client is a dependent client or not
//
//  Return Value:
//
//      True if a dependent client, false otherwise
//
//  Notes:
//
//      Used by mqoa.dll
// 
//---------------------------------------------------------

EXTERN_C
BOOL
APIENTRY
RTIsDependentClient()
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return FALSE;

    return g_fDependentClient;
}

//---------------------------------------------------------
//
//  RTpIsMsmqInstalled(...)
//
//  Description:
//
//      Check if MSMQ is installed on the local machine
//
//  Return Value:
//
//      TRUE if MSMQ is installed, FALSE otherwise
//
//---------------------------------------------------------
static
bool
RTpIsMsmqInstalled(
    void
    )
{
    WCHAR BuildInformation[255];
    DWORD type = REG_SZ;
    DWORD size = sizeof(BuildInformation) ;
    LONG rc = GetFalconKeyValue( 
                  MSMQ_CURRENT_BUILD_REGNAME,
				  &type,
				  static_cast<PVOID>(BuildInformation),
				  &size 
                  );

    return (rc == ERROR_SUCCESS);
}

static void OneTimeInit()
{	
	//
	// Initialize static library
	//
	XdsInitialize();
	CryInitialize();
	FnInitialize();
	XmlInitialize();
    DldInitialize();


	WCHAR wszRemoteQMName[ MQSOCK_MAX_COMPUTERNAME_LENGTH ] = {0} ;

	//
	// Read name of remote QM (if exist).
	//
	DWORD dwType = REG_SZ ;
	DWORD dwSize = sizeof(wszRemoteQMName) ;
	LONG rc = GetFalconKeyValue( RPC_REMOTE_QM_REGNAME,
								 &dwType,
								 (PVOID) wszRemoteQMName,
								 &dwSize ) ;
	g_fDependentClient = (rc == ERROR_SUCCESS) ;

	//
	// In dependent client mode the mqrtdep.dll's DLLMain will do all 
	// the initializations.
	//
	if(g_fDependentClient)
		return;

    //
    //  Allocate TLS index for synchronic event.
    //
    g_dwThreadEventIndex = TlsAlloc();
    ASSERT(g_dwThreadEventIndex != UNINIT_TLSINDEX_VALUE) ;

    //
    // Initialize  RPC related data.
    //
    BOOL fRet = InitRpcGlobals() ;
    if (!fRet)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR,
               TEXT("Failed inside RpcGlobals(), error %d"),
               GetLastError()));
		throw bad_alloc();
    }
    
    //
    // Initialize error logging
    //
    InitErrorLogging();

    //
    // RPC cancel is supported on NT only
    //
    g_CancelRpc.Init();

    //
    //  Initialize the QM per this process.
    //  Call this ONLY after initializing the RPC globals.
    //
    HRESULT hr = InitializeQM();
    if(FAILED(hr))
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR,
               TEXT("Failed inside InitializeQM(), error %d"),
               GetLastError()));
		throw bad_hresult(hr);
    }

    DWORD dwDef = g_dwTimeToReachQueueDefault ;
    READ_REG_DWORD(g_dwTimeToReachQueueDefault,
        MSMQ_LONG_LIVE_REGNAME,
        &dwDef ) ;
}

static CCriticalSection s_OneTimeInitLock(CCriticalSection::xAllocateSpinCount);
static bool s_fOneTimeInitSucceeded = false;

static HRESULT RtpOneTimeProcessInit()
{
	if(s_fOneTimeInitSucceeded)
		return MQ_OK;

	CS lock(s_OneTimeInitLock);
		
	try
	{
		if(s_fOneTimeInitSucceeded)
			return MQ_OK;

		OneTimeInit();
		s_fOneTimeInitSucceeded = true;

		return MQ_OK;
	}
	catch(const bad_hresult& hr)
	{
		return hr.error();
	}
	catch(const bad_alloc&)
	{
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
	catch(const exception&)
	{
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
}


HRESULT RtpOneTimeThreadInit()
{
    HRESULT hr = RtpOneTimeProcessInit();

    if (FAILED(hr))
    {
        return hr;
    }

	if(g_fDependentClient)
		return MQ_OK;

    return OneTimeThreadInit();
}


//---------------------------------------------------------
//
//  DllMain(...)
//
//  Description:
//
//      Main entry point to Falcon Run Time Dll.
//
//  Return Value:
//
//      TRUE on success
//
//---------------------------------------------------------

BOOL
APIENTRY
DllMain(
    HINSTANCE   /*hInstance */,
    ULONG     ulReason,
    LPVOID            /*lpvReserved*/
    )
{
    switch (ulReason)
    {

        case DLL_PROCESS_ATTACH:
        {
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");

            if (!RTpIsMsmqInstalled())
            {
                return FALSE;
            }


            break ;
        }

        case DLL_PROCESS_DETACH:
			if(!s_fOneTimeInitSucceeded)
				return TRUE;

			//
			// In dependent client mode the mqrtdep.dll's DLLMain will do all 
			// the initializations.
			//
			if(g_fDependentClient)
				return TRUE;

            //
            // First free whatever is free in THREAD_DETACH.
            //
            FreeThreadGlobals() ;

            FreeGlobals();

            //
            //  Terminate all working threads
            //
            ShutDownDebugWindow();

            WPP_CLEANUP();
            break;

        case DLL_THREAD_ATTACH:
			if(!s_fOneTimeInitSucceeded)
				return TRUE;

			//
			// In dependent client mode the mqrtdep.dll's DLLMain will do all 
			// the initializations.
			//
			if(g_fDependentClient)
				return TRUE;

            ASSERT(g_hBindIndex != UNINIT_TLSINDEX_VALUE) ;
            break;

        case DLL_THREAD_DETACH:
			if(!s_fOneTimeInitSucceeded)
				return TRUE;

			//
			// In dependent client mode the mqrtdep.dll's DLLMain will do all 
			// the initializations.
			//
			if(g_fDependentClient)
				return TRUE;

            FreeThreadGlobals() ;
            break;

    }
    return TRUE;
}

void InitErrorLogging()
{
    // OS info
    OSVERSIONINFO verOsInfo;
    verOsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&verOsInfo))
    {
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogRT,
                         LOG_RT_ERRORS,
                         L"*** OS: %d.%d  Build: %d Platform: %d %s",
                         verOsInfo.dwMajorVersion, verOsInfo.dwMinorVersion,
                         verOsInfo.dwBuildNumber,  verOsInfo.dwPlatformId,
                         verOsInfo.szCSDVersion )) ;

    }

    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogRT,
                     LOG_RT_ERRORS,
                     L"*** Process: %d.  Invoked as: %s",
                     GetCurrentProcessId(),
                     GetCommandLine())) ;

}

void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((e_LogRT, wszFileName, usPoint, hr));
    
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogRT,
                     LOG_RT_ERRORS,
                     L"RT Error: %s/%d, HR: 0x%x",
                     wszFileName,
                     usPoint,
                     hr)) ;
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((e_LogRT, wszFileName, usPoint, status));
    
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogRT,
                     LOG_RT_ERRORS,
                     L"RT Error: %s/%d, NTStatus: 0x%x",
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((e_LogRT, wszFileName, usPoint, status));

    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogRT,
                     LOG_RT_ERRORS,
                     L"RT Error: %s/%d, RPCStatus: 0x%x",
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint)
{
    KEEP_ERROR_HISTORY((e_LogRT, wszFileName, usPoint, b));
    
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogRT,
                     LOG_RT_ERRORS,
                     L"RT Error: %s/%d, BOOL: %x",
                     wszFileName,
                     usPoint,
                     b)) ;
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT dwLine)
{
        KEEP_ERROR_HISTORY((e_LogRT, wszFileName, dwLine, 0));
        
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogRT,
                         LOG_RT_ERRORS,
                         L"RT Error: %s/%d, Point",
                         wszFileName,
                         dwLine)) ;
}

#ifdef _WIN64
	void LogIllegalPointValue(DWORD64 dw64, LPCWSTR wszFileName, USHORT usPoint)
	{
		KEEP_ERROR_HISTORY((e_LogRT, wszFileName, usPoint, 0));
    
		WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
						 e_LogRT,
						 LOG_RT_ERRORS,
						 L"RT Error: %s/%d, Value: 0x%I64x",
						 wszFileName,
						 usPoint,
						 dw64)) ;
	}
#else
	void LogIllegalPointValue(DWORD dw, LPCWSTR wszFileName, USHORT usPoint)
	{
		KEEP_ERROR_HISTORY((e_LogRT, wszFileName, usPoint, 0));
    
		WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
						 e_LogRT,
						 LOG_RT_ERRORS,
						 L"RT Error: %s/%d, Value: 0x%x",
						 wszFileName,
						 usPoint,
						 dw)) ;
	}
#endif //_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtprpc.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    rtprpc.h

Abstract:

    RT DLL, RPC related stuff.

Author:

    Doron Juster  (DoronJ)  18-Nov-1996

--*/

#ifndef __RTPRPC_H
#define __RTPRPC_H

#include "_mqrpc.h"
#include "mqsocket.h"
#include "cancel.h"

//
//  Cancel RPC globals
//
extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;
extern DWORD g_hThreadIndex;
#define tls_hThread  ((handle_t) TlsGetValue( g_hThreadIndex ))


//
// Local endpoints to QM
//
extern AP<WCHAR> g_pwzQmsvcEndpoint;
extern AP<WCHAR> g_pwzQmmgmtEndpoint;

/*====================================================

RegisterRpcCallForCancel

Arguments:

Return Value:

  Register the call for cancel if its duration is too long
=====================================================*/

inline  void RegisterRpcCallForCancel(IN  HANDLE  *phThread,
                                      IN  DWORD    dwRecvTimeout )
{
    handle_t hThread = tls_hThread;
    if ( hThread == NULL)
    {
        //
        //  First time
        //
        //  Get the thread handle
        //
        HANDLE hT = GetCurrentThread();
        BOOL fResult = DuplicateHandle(
            GetCurrentProcess(),
            hT,
            GetCurrentProcess(),
            &hThread,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);
        ASSERT( fResult == TRUE);
        ASSERT(hThread);

        fResult = TlsSetValue( g_hThreadIndex, hThread);
        ASSERT( fResult == TRUE);

        //
        // Set the lower bound on the time to wait before timing
        // out after forwarding a cancel.
        //
        RPC_STATUS status;
        status = RpcMgmtSetCancelTimeout(0);
        ASSERT( status == RPC_S_OK);

    }
    *phThread = hThread;
    //
    //  Register the thread
    //
    TIME32 tPresentTime = DWORD_PTR_TO_DWORD(time(NULL)) ;
    TIME32  tTimeToWake = tPresentTime + (dwRecvTimeout / 1000) ;
    if ((dwRecvTimeout == INFINITE) || (tTimeToWake < tPresentTime))
    {
        //
        // Overflow
        // Note that time_t is a long, not unsigned. On the other hand
        // INFINITE is defined as 0xffffffff (i.e., -1). If we'll use
        // INFINITE here, then cancel routine, CCancelRpc::CancelRequests(),
        // will cancel this call immediately.
        // so use the bigest long value.
        //
        tTimeToWake = MAXLONG ;
    }
    g_CancelRpc.Add( hThread, tTimeToWake) ;
}


/*====================================================

UnregisterRpcCallForCancel

Arguments:

Return Value:

  Register the call for cancel if its duration is too long
=====================================================*/
inline  void UnregisterRpcCallForCancel(IN HANDLE hThread)
{
    ASSERT( hThread != NULL);

    //
    //  unregister the thread
    //
    g_CancelRpc.Remove( hThread);
}



HRESULT
RTpBindRemoteQMService(
    IN  LPWSTR     lpwNodeName,
    OUT handle_t*  lphBind,
    IN  OUT MQRPC_AUTHENTICATION_LEVEL *peAuthnLEvel
    );

handle_t RTpGetQMServiceBind(VOID);


#define  RTP_CALL_REMOTE_QM(lpServer, rc, command)              \
{                                                               \
       handle_t hBind = NULL ;                                  \
                                                                \
       rc = MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE ;             \
                                                                \
       HRESULT rpcs =  RTpBindRemoteQMService(                  \
                                lpServer,                       \
                                &hBind,                         \
                                &_eAuthnLevel                   \
                                );                              \
                                                                \
       if (rpcs == MQ_OK)                                       \
       {                                                        \
          HANDLE hThread;                                       \
          RegisterRpcCallForCancel( &hThread, 0) ;              \
                                                                \
          __try                                                 \
          {                                                     \
             rc = command ;                                     \
          }                                                     \
          __except(EXCEPTION_EXECUTE_HANDLER)                   \
          {                                                     \
             rc = MQ_ERROR_SERVICE_NOT_AVAILABLE ;              \
          }                                                     \
          UnregisterRpcCallForCancel( hThread);                 \
       }                                                        \
                                                                \
       if (hBind)                                               \
       {                                                        \
          mqrpcUnbindQMService( &hBind, NULL ) ;                \
       }                                                        \
}

#define  CALL_REMOTE_QM(lpServer, rc, command)                          \
{                                                                       \
    BOOL  fTryAgain = FALSE ;                                           \
    MQRPC_AUTHENTICATION_LEVEL _eAuthnLevel = MQRPC_SEC_LEVEL_MAX ;     \
                                                                        \
    do                                                                  \
    {                                                                   \
        fTryAgain = FALSE ;                                             \
        RTP_CALL_REMOTE_QM(lpServer, rc, command)                       \
        if (rc == MQ_ERROR_SERVICE_NOT_AVAILABLE)                       \
        {                                                               \
           if (_eAuthnLevel != MQRPC_SEC_LEVEL_NONE)                    \
           {                                                            \
               _eAuthnLevel = MQRPC_SEC_LEVEL_NONE;                     \
               fTryAgain = TRUE ;                                       \
           }                                                            \
        }                                                               \
    } while (fTryAgain) ;                                               \
}

#endif // __RTPRPC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtputl.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    rtputl.h

Abstract:
    functions to signed Mqf format name

Author:
    Ilan Herbst (ilanh) 21-Nov-2000

Environment:
    Platform-independent,

--*/

#pragma once

#ifndef _RTPUTL_H_
#define _RTPUTL_H_

bool IsWorkGroupMode(void);

#endif // _RTPUTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rtp.h

Abstract:

    RT DLL private internal functions

Author:

    Erez Haba (erezh) 24-Dec-95

--*/

#ifndef __RTP_H
#define __RTP_H

#include "rtpsec.h"
#include "_mqrpc.h"
#include <acdef.h>
#include <fn.h>

#define SEND_PARSE  1
#define RECV_PARSE  2

#define QUEUE_CREATE    1
#define QUEUE_SET_PROPS 2
#define QUEUE_GET_PROPS 3

#define CPP_EXCEPTION_CODE 0xe06d7363

extern DWORD g_dwThreadEventIndex;
extern LPWSTR g_lpwcsComputerName;
extern DWORD g_dwComputerNameLen;
extern BOOL  g_fDependentClient;



HRESULT
RTpConvertToMQCode(
    HRESULT hr,
    DWORD dwObjectType =MQDS_QUEUE
    );

//
// The CMQHResult class is used in order to automatically convert the various
// error codes to Falcon error codes. This is done by defining the assignment
// operator of this class so it converts whatever error code that is assigned
// to objects of this class to a Falcon error code. The casting operator
// from this class to HRESULT, returns the converted error code.
//
class CMQHResult
{
public:
    CMQHResult(DWORD =MQDS_QUEUE); // Default constructor.
    CMQHResult(const CMQHResult &); // Copy constructor
    CMQHResult& operator =(HRESULT); // Assignment operator.
    operator HRESULT(); // Casting operator to HRESULT type.
    HRESULT GetReal(); // A method that returns the real error code.

private:
    HRESULT m_hr; // The converted error code.
    HRESULT m_real; // The real error code.
    DWORD m_dwObjectType; // The type of object (can be only queue, or machine).
};

//---------- CMQHResult implementation ----------------------------------

inline CMQHResult::CMQHResult(DWORD dwObjectType)
{
    ASSERT((dwObjectType == MQDS_QUEUE) || (dwObjectType == MQDS_MACHINE));
    m_dwObjectType = dwObjectType;
}

inline CMQHResult::CMQHResult(const CMQHResult &hr)
{
    m_hr = hr.m_hr;
    m_real = hr.m_real;
    m_dwObjectType = hr.m_dwObjectType;
}

inline CMQHResult& CMQHResult::operator =(HRESULT hr)
{
    m_hr = RTpConvertToMQCode(hr, m_dwObjectType);
    m_real = hr;

    return *this;
}

inline CMQHResult::operator HRESULT()
{
    return m_hr;
}

inline HRESULT CMQHResult::GetReal()
{
    return m_real;
}

//---------- CMQHResult implementation end ------------------------------

//---------- Function declarations --------------------------------------

HRESULT
RTpParseSendMessageProperties(
    CACSendParameters &SendParams,
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus,
    OUT PMQSECURITY_CONTEXT *ppSecCtx,
    CStringsToFree &ResponseStringsToFree,
    CStringsToFree &AdminStringsToFree
    );

HRESULT
RTpParseReceiveMessageProperties(
    CACReceiveParameters &ReceiveParams,
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus
    );

LPWSTR
RTpGetQueuePathNamePropVar(
    MQQUEUEPROPS *pqp
    );

GUID*
RTpGetQueueGuidPropVar(
    MQQUEUEPROPS *pqp
    );
                    
BOOL
RTpIsLocalPublicQueue(LPCWSTR lpwcsExpandedPathName) ;

void
RTpRemoteQueueNameToMachineName(
	LPCWSTR RemoteQueueName,
	LPWSTR* MachineName
	);

HRESULT
RTpQueueFormatToFormatName(
    QUEUE_FORMAT* pQueueFormat,
    LPWSTR lpwcsFormatName,
    DWORD dwBufferLength,
    LPDWORD lpdwFormatNameLength
    );

HRESULT
RTpMakeSelfRelativeSDAndGetSize(
    PSECURITY_DESCRIPTOR *pSecurityDescriptor,
    PSECURITY_DESCRIPTOR *pSelfRelativeSecurityDescriptor,
    DWORD *pSDSize
    );

HRESULT
RTpCheckColumnsParameter(
    IN MQCOLUMNSET* pColumns
    );

HRESULT
RTpCheckQueueProps(
    IN  MQQUEUEPROPS* pqp,
    IN  DWORD         dwOp,
    IN  BOOL          fPrivateQueue,
    OUT MQQUEUEPROPS **ppGoodQP,
    OUT char **ppTmpBuff
    );

HRESULT
RTpCheckQMProps(
    IN  MQQMPROPS * pQMProps,
    IN OUT HRESULT* aStatus,
    OUT MQQMPROPS **ppGoodQMP,
    OUT char      **ppTmpBuff
    );
  
HRESULT
RTpCheckRestrictionParameter(
    IN MQRESTRICTION* pRestriction
    );

HRESULT
RTpCheckSortParameter(
    IN MQSORTSET* pSort
    );

HRESULT
RTpCheckLocateNextParameter(
    IN DWORD		cPropsRead,
    IN PROPVARIANT  aPropVar[]
	);

HRESULT
RTpCheckComputerProps(
    IN      MQPRIVATEPROPS * pPrivateProps,
    IN OUT  HRESULT*    aStatus
	);


HRESULT
RTpProvideTransactionEnlist(
    ITransaction *pTrans,
    XACTUOW *pUow
    );

VOID
RTpInitXactRingBuf(
    VOID
    );

HANDLE
GetThreadEvent(
    VOID
    );

HRESULT 
RtpOneTimeThreadInit();

WCHAR *
RTpExtractDomainNameFromDLPath(
    LPCWSTR pwcsADsPath
    );




//
//  cursor information
//
struct CCursorInfo {
    HANDLE hQueue;
    HACCursor32 hCursor;
};
  

//
//  CCursorInfo to cursor handle
//
inline HACCursor32 CI2CH(HANDLE hCursor)
{
    return ((CCursorInfo*)hCursor)->hCursor;
}
  

//
//  CCursorInfo to queue handle
//
inline HANDLE CI2QH(HANDLE hCursor)
{
    return ((CCursorInfo*)hCursor)->hQueue;
}

    
//
//  Macro for extracting the explicit rpc binding handle from tls
//
#define UNINIT_TLSINDEX_VALUE   0xffffffff

extern DWORD  g_hBindIndex ;
#define tls_hBindRpc  ((handle_t) TlsGetValue( g_hBindIndex ))

extern void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint);
extern void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint);
extern void LogIllegalPoint(LPWSTR wszFileName, USHORT dwLine);
#ifdef _WIN64
extern void LogIllegalPointValue(DWORD64 dw64, LPCWSTR wszFileName, USHORT usPoint);
#else
extern void LogIllegalPointValue(DWORD dw, LPCWSTR wszFileName, USHORT usPoint);
#endif //_WIN64
             
#endif // __RTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtpsec.h ===
//
// file:  rtpsec.h
//
#ifndef _RTPSEC_H_
#define _RTPSEC_H_

#include <mqcrypt.h>
#include <cs.h>

//
// The security context.
//

#define SECURITY_CONTEXT_VER    1

class MQSECURITY_CONTEXT
{
public:
    MQSECURITY_CONTEXT();
    ~MQSECURITY_CONTEXT();

    DWORD       dwVersion;       // The version of the security context.
    BOOL        fLocalUser;      // Indicates whether the user is a local user.
    BOOL        fLocalSystem;    // Indicates whether the user is a localSystem account.
    P<BYTE>     pUserSid;        // A pointer to the user SID. Undefined for a local user.
    DWORD       dwUserSidLen;    // The length of the user SID. Undefined for a local user.
    CHCryptProv hProv;           // A context handle to the cert CSP.
    P<BYTE>     pUserCert;       // A pointer to the user cert.
    DWORD       dwUserCertLen;   // The length of the user cert.
    P<WCHAR>    wszProvName;     // The name of the cert CSP.
    DWORD       dwProvType;      // The type of the cert CSP.
    BOOL        bDefProv;        // True if the cert CSP is the default CSP.
    BOOL        bInternalCert;   // True if the cert is an internal MSMQ cert.

    //
    // Member variable added to support all kinds of external certificate
	// and not assuming AT_KEYEXCHANGE for external certificate bug 5626 ilanh 25-June-2000
    //
    DWORD dwPrivateKeySpec;		// The Private key type, AT_SIGNATURE or AT_KEYEXCHANGE.

    //
    // Member variables added to fix MSMQ bug 2955
    //

    CCriticalSection CS ;      // critical section for multi-threaded.
    BOOL     fAlreadyImported ;  // Private key already imported.
    P<BYTE>  pPrivateKey ;       // Blob of private key.
    DWORD    dwPrivateKeySize ;  // size of private key blob.
    WCHAR    wszContainerName[ 28 ] ;  // Name of container for keys.
};

typedef MQSECURITY_CONTEXT *PMQSECURITY_CONTEXT;

PMQSECURITY_CONTEXT AllocSecurityContext() ;

HRESULT  RTpImportPrivateKey( PMQSECURITY_CONTEXT pSecCtx ) ;

HRESULT
GetCertInfo(
    IN    BOOL        bUseCurrentUser,
    IN    BOOL        fMachine,
    IN OUT BYTE     **ppbCert,
    OUT   DWORD      *pdwCertLen,
    OUT   HCRYPTPROV *phProv,
    OUT   LPWSTR     *wszProvName,
    OUT   DWORD      *pdwProvType,
    OUT   BOOL       *pbDefProv,
    OUT   BOOL       *pbInternalCert,
	OUT	   DWORD     *pdwPrivateKeySpec
    );

HRESULT
RTpGetThreadUserSid( BOOL   *pfLocalUser,
                     BOOL   *pfLocalSystem,
                     LPBYTE *ppUserSid,
                     DWORD  *pdwUserSidLen ) ;

extern CContextMap g_map_RT_SecCtx; //ptr to DWORD map for PROPID_M_SECURITY_CONTEXT

#endif //_RTPSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtrpc.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rtrpc.cpp

Abstract:

    Rpc related stuff.

Author:

    Doron Juster (DoronJ)  04-Jun-1997

Revision History:

--*/

#include "stdh.h"
#include <mqutil.h>
#include "_mqrpc.h"
#include "mqsocket.h"
#include "rtprpc.h"
#include "mgmtrpc.h"
#include <mqsec.h>
#include <Fn.h>

#include "rtrpc.tmh"

static WCHAR *s_FN=L"rt/rtrpc";

//
// FASLE (default) when using dynamic endpoints.
// TRUE in debug mode, multiple QMs on a machine, when using fix endpoints.
//
static BOOL  s_fUsePredefinedEP = RPC_DEFAULT_PREDEFINE_QM_EP ;

//
// Fix rpc ports (debug mode), read from registry.
//
#define  MAX_RPC_PORT_LEN  12
static TCHAR   s_wszRpcIpPort[ MAX_RPC_PORT_LEN ] ;

static TCHAR   s_wszRpcIpPort2[ MAX_RPC_PORT_LEN ] ;

//
// The binding string MUST be global and kept valid all time.
// If we create it on stack and free it after each use then we can't
// create more then one binding handle.
// Don't ask me (DoronJ) why, but this is the case.
//
TBYTE* g_pszStringBinding = NULL ;

//
//  Critical Section to make RPC thread safe.
//
CCriticalSection CRpcCS ;

//
//  License related data.
//
GUID  g_LicGuid ;
BOOL  g_fLicGuidInit = FALSE ;

//
//  Tls index for canceling RPC calls
//
#define UNINIT_TLSINDEX_VALUE   0xffffffff
DWORD  g_hThreadIndex = UNINIT_TLSINDEX_VALUE ;


//
// Local endpoints to QM
//
AP<WCHAR> g_pwzQmsvcEndpoint = 0;
AP<WCHAR> g_pwzQmmgmtEndpoint = 0;

//---------------------------------------------------------
//
//  RTpGetLocalQMBind(...)
//
//  Description:
//
//      Create RPC binding handle to a local QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

handle_t RTpGetLocalQMBind( TBYTE** ppStringBinding,
                            LPTSTR  pEndpoint)
{
    RPC_STATUS rc;

    if(!*ppStringBinding)
    {
        rc = RpcStringBindingCompose(
            0,
            RPC_LOCAL_PROTOCOL,
            0,
            pEndpoint,
            RPC_LOCAL_OPTION,
            ppStringBinding
            );

        ASSERT(rc == RPC_S_OK);
    }

    handle_t hBind = 0;
    rc = RpcBindingFromStringBinding(*ppStringBinding, &hBind);
    ASSERT((rc == RPC_S_OK) ||
	       ((rc == RPC_S_OUT_OF_MEMORY) && (hBind == NULL)));

    rc = mqrpcSetLocalRpcMutualAuth(&hBind) ;

    if (rc != RPC_S_OK)
    {
        mqrpcUnbindQMService( &hBind, NULL ) ;
        hBind = NULL ;
    }

    return hBind;
}

//---------------------------------------------------------
//
//  RTpGetQMServiceBind(...)
//
//  Description:
//
//      Create RPC binding handle to the QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

handle_t RTpGetQMServiceBind(VOID)
{
    return RTpGetLocalQMBind(&g_pszStringBinding, g_pwzQmsvcEndpoint);

}


//---------------------------------------------------------
//
//  RTpBindRemoteQMService(...)
//
//  Description:
//
//      Create RPC binding handle to a remote QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------
HRESULT
RTpBindRemoteQMService(
    IN  LPWSTR     lpwNodeName,
    OUT handle_t*  lphBind,
    IN  OUT MQRPC_AUTHENTICATION_LEVEL *peAuthnLevel
    )
{
    HRESULT hr = MQ_ERROR ;
    BOOL fWin95 = FALSE ;

    TCHAR *pPort ;
    DWORD dwPortType = (DWORD) -1 ;

    pPort = s_wszRpcIpPort;
    dwPortType = (DWORD) IP_HANDSHAKE ;

    GetPort_ROUTINE pfnGetPort = QMGetRTQMServerPort ;
    if (!s_fUsePredefinedEP)
    {
       pPort = NULL ;
    }

    BOOL fProtocolNotSupported ;

    //
    // Choose authentication service. For LocalSystem services, chose
    // "negotiate" and let mqutil select between Kerberos or ntlm.
    // For all other cases, use ntlm.
    // LocalSystem service go out to network without any credentials
    // if using ntlm, so only for it we're interested in Kerberos.
    // All other are fine with ntlm. For remote read we do not need
    // delegation, so we'll stick to ntlm.
    // The major issue here is a bug in rpc/security, whereas a nt4
    // user on a win2k machine can successfully call
    //  status = RpcBindingSetAuthInfoEx( ,, RPC_C_AUTHN_GSS_KERBEROS,,)
    // although it's clear he can't obtain any Kerberos ticket (he's
    // nt4 user, defined only in nt4 PDC).
    //
    ULONG   ulAuthnSvc = RPC_C_AUTHN_WINNT ;
    BOOL fLocalUser =  FALSE ;
    BOOL fLocalSystem = FALSE ;

    hr = MQSec_GetUserType( NULL,
                           &fLocalUser,
                           &fLocalSystem ) ;
    if (SUCCEEDED(hr) && fLocalSystem)
    {
        ulAuthnSvc = MSMQ_AUTHN_NEGOTIATE ;
    }

    hr = mqrpcBindQMService(lpwNodeName,
                            IP_ADDRESS_TYPE,
                            pPort,
                            peAuthnLevel,
                            &fProtocolNotSupported,
                            lphBind,
                            dwPortType,
                            pfnGetPort,
                            &fWin95,
                            ulAuthnSvc ) ;

    return LogHR(hr, s_FN, 50);
}

//---------------------------------------------------------
//
//  InitRpcGlobals(...)
//
//  Description:
//
//      Initialize RPC related names and other constant data
//
//  Return Value:
//
//---------------------------------------------------------

BOOL InitRpcGlobals()
{
    //
    //  Allocate TLS for  RPC connection with local QM service
    //
    g_hBindIndex = TlsAlloc() ;
    ASSERT(g_hBindIndex != UNINIT_TLSINDEX_VALUE) ;
    if (g_hBindIndex == UNINIT_TLSINDEX_VALUE)
    {
       return FALSE ;
    }
    else
    {
       BOOL fSet = TlsSetValue( g_hBindIndex, NULL ) ;
       ASSERT(fSet) ;
	   DBG_USED(fSet);
    }

    //
    // Initialize local endpoints to QM
    //

    ComposeLocalEndPoint(QMMGMT_ENDPOINT, &g_pwzQmmgmtEndpoint);

    READ_REG_STRING(wzEndpoint, RPC_LOCAL_EP_REGNAME, RPC_LOCAL_EP);
    ComposeLocalEndPoint(wzEndpoint, &g_pwzQmsvcEndpoint);

    //
    // Read QMID. Needed for licensing.
    //
    DWORD dwValueType = REG_BINARY ;
    DWORD dwValueSize = sizeof(GUID);

    LONG rc = GetFalconKeyValue( MSMQ_QMID_REGNAME,
                            &dwValueType,
                            &g_LicGuid,
                            &dwValueSize);

    if (rc == ERROR_SUCCESS)
    {
        g_fLicGuidInit = TRUE ;
        ASSERT((dwValueType == REG_BINARY) &&
               (dwValueSize == sizeof(GUID)));
    }

    //
    // Read the IP ports for RPC.
    // First see if we use dynamic or predefined endpoints.
    //
    //
    DWORD ulDefault =  RPC_DEFAULT_PREDEFINE_QM_EP ;
    READ_REG_DWORD( s_fUsePredefinedEP,
                    RPC_PREDEFINE_QM_EP_REGNAME,
                    &ulDefault );

    if (s_fUsePredefinedEP)
    {
       READ_REG_STRING( wzQMIPEp,
                        FALCON_QM_RPC_IP_PORT_REGNAME,
                        FALCON_DEFAULT_QM_RPC_IP_PORT ) ;
       ASSERT(wcslen(wzQMIPEp) < MAX_RPC_PORT_LEN) ;
       wcscpy(s_wszRpcIpPort, wzQMIPEp) ;

       READ_REG_STRING( wzQMIPEp2,
                        FALCON_QM_RPC_IP_PORT_REGNAME2,
                        FALCON_DEFAULT_QM_RPC_IP_PORT2 ) ;
       ASSERT(wcslen(wzQMIPEp2) < MAX_RPC_PORT_LEN) ;
       wcscpy(s_wszRpcIpPort2, wzQMIPEp2) ;

    }

    //
    //  Allocate TLS for  cancel remote-read RPC calls
    //
    g_hThreadIndex = TlsAlloc() ;
    ASSERT(g_hThreadIndex != UNINIT_TLSINDEX_VALUE) ;
    if (g_hThreadIndex == UNINIT_TLSINDEX_VALUE)
    {
       return FALSE ;
    }
    else
    {
       BOOL fSet = TlsSetValue( g_hThreadIndex, NULL ) ;
       ASSERT(fSet) ;
       DBG_USED(fSet);
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtsecutl.h ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    rtsecutl.h

Abstract:

    Security related utility functions.

Author:

    Doron Juster  (DoronJ)  Feb 19, 1997

--*/

extern PMQSECURITY_CONTEXT g_pSecCntx ;

extern void  InitSecurityContext() ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\signmessagexml.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    SignMessageXml.h

Abstract:
    functions to signed via xml digital signature in the RunTime

Author:
    Ilan Herbst (ilanh) 15-May-2000

Environment:
    Platform-independent,

--*/

#pragma once

#ifndef _SIGNMESSAGEXML_H_
#define _SIGNMESSAGEXML_H_

HRESULT  
CheckInitProv( 
	IN PMQSECURITY_CONTEXT pSecCtx
	);

HRESULT 
SignMessageXmlDSig( 
	IN PMQSECURITY_CONTEXT  pSecCtx,
	IN OUT CACSendParameters *pSendParams,
	OUT AP<char>& pSignatureElement
	);


#endif // _SIGNMESSAGEXML_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\signmessagexml.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    SignMessageXml.cpp

Abstract:
    functions to signed via xml in the RunTime

Author:
    Ilan Herbst (ilanh) 15-May-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "ac.h"
#include <mqsec.h>
#include <ph.h>
#include <mqformat.h>
#include "mqstl.h"
#include "Xds.h"
#include "tr.h"
#include "authlevel.h"
#include "mpnames.h"

#include "signmessagexml.tmh"

static WCHAR *s_FN=L"rt/SignMessageXml";

extern GUID  g_LicGuid;

HRESULT  
CheckInitProv( 
	IN PMQSECURITY_CONTEXT pSecCtx
	)
/*++
Routine Description:
	Import the private key into procss hive
	this is subset of _BeginToSignMessage() function,
	only the part that check the provider initialization.

Arguments:
	pSecCtx - pointer to the security context

Returned Value:
	MQ_OK, if successful, else error code.

--*/
{
    ASSERT(pSecCtx != NULL);

    if(pSecCtx->hProv)
	    return MQ_OK;
		
    //
    // Import the private key into process hive.
    //
	HRESULT hr = RTpImportPrivateKey(pSecCtx);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    ASSERT(pSecCtx->hProv);

    return MQ_OK;
}


static
CXdsReferenceInput* 
NewXdsReference( 
	IN DWORD BufferSizeInBytes,
	IN BYTE** ppBuffer,
	IN ALG_ID HashAlg,
	IN HCRYPTPROV hCsp,
	IN LPCSTR Uri,
	IN LPCSTR Type = NULL
	)
/*++
Routine Description:
	Create XMLDSIG reference.

Arguments:
	BufferSize - buffer size in bytes
	ppBuffer - pointer to the buffer
	HashAlg - hash algoritem
    hCsp - handle to crypto service provider.
	Uri - Uri of the refernce data. 
	Type - Type of the refernce. 

Returned Value:
    pointer to CXdsReferenceInput, NULL if BufferSize = 0.

--*/
{
	if(BufferSizeInBytes == 0)
	{
	    TrTRACE(XMLDSIG, "RT: Reference is not created, BufferSizeInBytes = 0");
		return NULL;
	}

	ASSERT(ppBuffer != NULL);

	//
	// Message Body Digest
	//
	AP<char> pBufferHash = XdsCalcDataDigest(
								 *ppBuffer,
								 BufferSizeInBytes,
								 HashAlg,
								 hCsp
								 );

	TrTRACE(XMLDSIG, "RT: Reference Data BufferSizeInBytes = %d, Uri = %hs", BufferSizeInBytes, Uri);

	//
	// RefBody - Message Body Reference
	//
	return new CXdsReferenceInput(
					 HashAlg,
					 pBufferHash,
					 Uri,
					 Type
					 );

}


static
LPSTR
ComposeMimeAttachmentUri(
	LPCSTR Str
	)
/*++
Routine Description:
	Compose Mime Attacment Uri.
	cid:"Str"QmGuid

Arguments:
	Str - the constant string id of the reference (body@ or extension@)

Returned Value:
	Mime Attachment Reference Uri string

--*/
{
	ASSERT(Str != NULL);

	AP<char> pMimeUri = new char[xPrefixMimeAttachmentLen + GUID_STR_LENGTH + strlen(Str) + 1];
	sprintf(pMimeUri, "%s" MIME_ID_FMT_A, xPrefixMimeAttachment, strlen(Str), Str, GUID_ELEMENTS(&g_LicGuid));
	return pMimeUri.detach();
}


HRESULT 
SignMessageXmlDSig( 
	IN PMQSECURITY_CONTEXT  pSecCtx,
	IN OUT CACSendParameters *pSendParams,
	OUT AP<char>& pSignatureElement
	)
/*++
Routine Description:
	Sign message with XML digital signature.

Arguments:
	pSecCtx - pointer to the security context
    pSendParams - pointer to send params.
	pSignatureElement - auto pointer of char for the signature element wstring 

Returned Value:
    change the value in the transfer buffer of
	create the SignatureElement (xml digital signature) and store it 
	in the transfer buffer

	MQ_OK, if successful, else error code.

--*/
{
	ASSERT(IS_AUTH_LEVEL_XMLDSIG_BIT(pSendParams->MsgProps.ulAuthLevel));
	ASSERT(pSendParams->MsgProps.pulHashAlg != NULL);

	//
	// This check if the CSP is initialize correctly
	//
    HRESULT hr =  CheckInitProv(pSecCtx);

    if (FAILED(hr))
    {
        return hr;
    }

	//
	// Body References
	//
	AP<char> pBodyUri = ComposeMimeAttachmentUri(xMimeBodyId); 

    TrTRACE(XMLDSIG, "XMLDSIG, Meesage Body Reference, Uri = %hs", pBodyUri.get());

	P<CXdsReferenceInput> pRefBody = NewXdsReference( 
											pSendParams->MsgProps.ulBodyBufferSizeInBytes,
											pSendParams->MsgProps.ppBody,
											*pSendParams->MsgProps.pulHashAlg,
											pSecCtx->hProv,
											pBodyUri
											);

	//
	// Extension References
	//
	AP<char> pExtensionUri = ComposeMimeAttachmentUri(xMimeExtensionId);

    TrTRACE(XMLDSIG, "XMLDSIG, Meesage Extension Reference, Uri = %hs", pExtensionUri.get());

	P<CXdsReferenceInput> pRefExtension = NewXdsReference( 
												pSendParams->MsgProps.ulMsgExtensionBufferInBytes,
												pSendParams->MsgProps.ppMsgExtension,
												*pSendParams->MsgProps.pulHashAlg,
												pSecCtx->hProv,
												pExtensionUri
												);

	//
	// Create pReferenceInputs vector
	//
	ReferenceInputVectorType pReferenceInputs;

	if(pRefBody != NULL)
	{
		ASSERT(pSendParams->MsgProps.ulBodyBufferSizeInBytes != 0);
		pReferenceInputs.push_back(pRefBody);
		pRefBody.detach();
	}

	if(pRefExtension != NULL)
	{
		ASSERT(pSendParams->MsgProps.ulMsgExtensionBufferInBytes != 0);
		pReferenceInputs.push_back(pRefExtension);
		pRefExtension.detach();
	}

	//
	// Signature element with the signature value as input - no need to calucate it only to build the element
	//
	CXdsSignedInfo::SignatureAlgorithm SignatureAlg = CXdsSignedInfo::saDsa;

	CXdsSignature SignatureXds(
					  SignatureAlg,
					  NULL,		// SignedInfo Id
					  pReferenceInputs,
					  NULL,		// Signature Id
					  pSecCtx->hProv,
					  pSecCtx->dwPrivateKeySpec,
					  NULL /* KeyValue */
					  );

	ASSERT(pSignatureElement == NULL);
	pSignatureElement = SignatureXds.SignatureElement();

	DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: SignMessageXmlDSig() XmlDsig complete ok")));
    return(MQ_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtsecutl.cpp ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    rtsecutl.cpp

Abstract:

    Security related utility functions.

Author:

    Doron Juster  (DoronJ)  Feb 18, 1997
	Ilan Herbst   (ilanh)   Jun 25, 2000

--*/

#include "stdh.h"
#include "cs.h"

#include "rtsecutl.tmh"

PMQSECURITY_CONTEXT g_pSecCntx = NULL ;

static WCHAR *s_FN=L"rt/rtsecutl";

static CCriticalSection s_security_cs;

void InitSecurityContext()
{

    CS lock(s_security_cs);

    if(g_pSecCntx != 0)
    {
        return;
    }

    //
    // Allocate the structure for the chached process security context.
    //
    MQSECURITY_CONTEXT* pSecCntx = new MQSECURITY_CONTEXT;

    //
    //  Get the user's SID and put it in the chaed process security context.
    //
    RTpGetThreadUserSid(
		&pSecCntx->fLocalUser,
		&pSecCntx->fLocalSystem,
		&pSecCntx->pUserSid,
		&pSecCntx->dwUserSidLen
		);

    //
    // Get the internal certificate of the process and place all the
    // information for this certificate in the chached process security
    // context.
    //
    GetCertInfo(
        FALSE,
		pSecCntx->fLocalSystem,
		&pSecCntx->pUserCert,
		&pSecCntx->dwUserCertLen,
		&pSecCntx->hProv,
		&pSecCntx->wszProvName,
		&pSecCntx->dwProvType,
		&pSecCntx->bDefProv,
		&pSecCntx->bInternalCert,
		&pSecCntx->dwPrivateKeySpec	
		);

    //
    //  Set the global security context only after getting all information
    //  it is checked outside the critical (in other scope) seciton to get
    //  better performance
    //
    g_pSecCntx = pSecCntx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\signmqf.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    SignMqf.cpp

Abstract:
    functions to signed Mqf format name

Author:
    Ilan Herbst (ilanh) 29-Oct-2000

Environment:
    Platform-independent,

--*/

#include "stdh.h"
#include "ac.h"
#include <mqsec.h>
#include <ph.h>
#include <mqformat.h>
#include <mqf2format.h>
#include "tr.h"
#include "cry.h"
#include "_guid.h"
#include "SignMessageXml.h"

#include "signmqf.tmh"

extern GUID  g_LicGuid;

//
// A buffer that contains only zeroes. This is the default value for the
// correleation ID. The buffer is used when the passed pointer to the message
// correlation ID is NULL.
//
const BYTE xDefCorrelationId[PROPID_M_CORRELATIONID_SIZE] = {0};

static WCHAR *s_FN=L"rt/SignMqf";


static
void 
MsgBodyHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Message Body hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// Body
	//
	if(pSendParams->MsgProps.ppBody != NULL)
	{
		CryHashData(
			*pSendParams->MsgProps.ppBody, 
			pSendParams->MsgProps.ulBodyBufferSizeInBytes,
			hHash
			);

        DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: MsgBodyHash(), BodySize = %d"), pSendParams->MsgProps.ulBodyBufferSizeInBytes));

	}
}


static
void 
CorrelationIdHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	CorrelationId hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// CorrelationID
	//
	if(pSendParams->MsgProps.ppCorrelationID != NULL)
	{
		CryHashData(
			reinterpret_cast<const BYTE*>(*pSendParams->MsgProps.ppCorrelationID), 
			PROPID_M_CORRELATIONID_SIZE,
			hHash
			);
	}
	else
	{
		CryHashData(
			xDefCorrelationId, 
			PROPID_M_CORRELATIONID_SIZE,
			hHash
			);
	}

    DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: CorrelationIdHash(), CorrelationIdSize = %d"), PROPID_M_CORRELATIONID_SIZE));
}


static
void 
ApplicationTagHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Application Tag hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// Application tag
	//
	if(pSendParams->MsgProps.pApplicationTag != NULL)
	{
		CryHashData(
			reinterpret_cast<const BYTE*>(pSendParams->MsgProps.pApplicationTag), 
			sizeof(DWORD),
			hHash
			);

        DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: ApplicationTagHash(), ApplicationTag = %d"), *pSendParams->MsgProps.pApplicationTag));
	}
	else
	{
		ULONG ApplicationTag = DEFAULT_M_APPSPECIFIC;

		CryHashData(
			reinterpret_cast<const BYTE*>(&ApplicationTag), 
			sizeof(DWORD),
			hHash
			);

        DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: ApplicationTagHash(), ApplicationTag = %d"), ApplicationTag));
	}
}


static
void 
TitleHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Title hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// Title
	//
	if(pSendParams->MsgProps.ppTitle != NULL)
	{
		CryHashData(
			reinterpret_cast<const BYTE*>(*pSendParams->MsgProps.ppTitle), 
			pSendParams->MsgProps.ulTitleBufferSizeInWCHARs * sizeof(WCHAR),
			hHash
			);

        DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: TitleHash(),  TitleLength = %d"), pSendParams->MsgProps.ulTitleBufferSizeInWCHARs));

        DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: TitleHash(),  Title = %ls"), *pSendParams->MsgProps.ppTitle));
	}
}


static
void 
MqfHash(
	IN HCRYPTHASH hHash, 	
    IN const QUEUE_FORMAT*	pqf,
	IN ULONG			    nMqf
	)
/*++
Routine Description:
	Mqf hash.

Arguments:
	hHash - hash object.
	pqf - pointer to QUEUE_FORMAT array.
	nMqf - pqf array size.

Returned Value:
	none.

--*/
{
	ULONG FormatNameLength = 0;
	AP<WCHAR> pFormatName = MQpMqfToFormatName(
								pqf, 
								nMqf, 
								&FormatNameLength 
								);

	ASSERT(("Failed to get Mqf format name", pFormatName != NULL)); 

	CryHashData(
		reinterpret_cast<const BYTE*>(pFormatName.get()), 
		FormatNameLength * sizeof(WCHAR),
		hHash
		);

	DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: MqfHash(),  nMqf = %d"), nMqf));

	DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: MqfHash(),  FormatNameLength(mqf) = %d"), FormatNameLength));

	DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: MqfHash(),  FormatName(mqf) = %ls"), pFormatName.get()));
}


static
void 
ResponseMqfHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	ResponseMqf hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// Get the string representation for the responce queue FormatName.
	// BUGBUG: Currently mp lib not support response mqf
 	//
	if(pSendParams->ResponseMqf != NULL)
	{
		ASSERT(pSendParams->nResponseMqf >= 1);

		DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: ResponseMqfHash(),  ResponseMqf:")));

		MqfHash(
			hHash,
			pSendParams->ResponseMqf, 
			pSendParams->nResponseMqf
			);
	}
}


static
void 
AdminMqfHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	AdminMqf hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
    //
    // Get the string representation for the admin queue FormatName.
    //
    if (pSendParams->AdminMqf != NULL) 
    {
		ASSERT(pSendParams->nAdminMqf >= 1);

		DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: AdminMqfHash(),  AdminMqf:")));

		MqfHash(
			hHash,
			pSendParams->AdminMqf, 
			pSendParams->nAdminMqf 
			);
	}
}


static
void 
ExtensionHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Extension hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// Extension
	//
	if(pSendParams->MsgProps.ppMsgExtension != NULL)
	{
		CryHashData(
			reinterpret_cast<const BYTE*>(*pSendParams->MsgProps.ppMsgExtension), 
			pSendParams->MsgProps.ulMsgExtensionBufferInBytes,
			hHash
			);

        DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: ExtensionHash(), ExtensionLen = %d"), pSendParams->MsgProps.ulMsgExtensionBufferInBytes));
	}
}


static
void 
TargetFormatNameHash(
	IN HCRYPTHASH hHash, 	
	IN LPCWSTR pwszTargetFormatName
	)
/*++
Routine Description:
	TargetFormatName hash.

Arguments:
	hHash - hash object
	pwszTargetFormatName - Target queue format name (LPWSTR)

Returned Value:
	none.

--*/
{
	//
	// Target queue Format Name
	//
	CryHashData(
		reinterpret_cast<const BYTE*>(pwszTargetFormatName), 
		(1 + wcslen(pwszTargetFormatName)) * sizeof(WCHAR),
		hHash
		);

    DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: TargetFormatNameHash(), TargetFormatNameLen = %d"), (1 + wcslen(pwszTargetFormatName)))) ;

    DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: TargetFormatNameHash(), TargetFormatName = %ls"), pwszTargetFormatName)) ;
}


static
void 
SourceQmHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Source Qm hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
    // Guid of local qm.
    //
    GUID *pGuidQM = &g_LicGuid;

	CryHashData(
		reinterpret_cast<const BYTE*>(pGuidQM), 
		sizeof(GUID),
		hHash
		);

	DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: SourceQmHash(), SourceGuid = %!guid!"), pGuidQM)) ;
}


static
void 
MsgAckFlag(
	IN const CACSendParameters* pSendParams,
	OUT struct _MsgFlags* pUserFlags
	)
/*++
Routine Description:
	Message Ack Flag.

Arguments:
    pSendParams - pointer to send params.
	pUserFlags - pointer to structure of user flags

Returned Value:
	none.

--*/
{
    if (pSendParams->MsgProps.pAcknowledge) 
    {
        pUserFlags->bAck = *(pSendParams->MsgProps.pAcknowledge);
    }
}


static
void 
MsgFlags(
	IN const CACSendParameters* pSendParams,
	OUT struct _MsgFlags* pUserFlags
	)
/*++
Routine Description:
	Prepare Message Flags.

Arguments:
    pSendParams - pointer to send params.
	pUserFlags - pointer to structure of user flags

Returned Value:
	none.

--*/
{
    pUserFlags->bDelivery = DEFAULT_M_DELIVERY;
    pUserFlags->bPriority = DEFAULT_M_PRIORITY;
    pUserFlags->bAuditing = DEFAULT_M_JOURNAL;
    pUserFlags->bAck      = DEFAULT_M_ACKNOWLEDGE;
    pUserFlags->usClass   = MQMSG_CLASS_NORMAL;

    if (pSendParams->MsgProps.pDelivery)
    {
        pUserFlags->bDelivery = *(pSendParams->MsgProps.pDelivery);
    }

    if (pSendParams->MsgProps.pPriority)
    {
        pUserFlags->bPriority = *(pSendParams->MsgProps.pPriority);
    }

    if (pSendParams->MsgProps.pAuditing)
    {
        pUserFlags->bAuditing = *(pSendParams->MsgProps.pAuditing);
    }

    if (pSendParams->MsgProps.pClass)
    {
        pUserFlags->usClass = *(pSendParams->MsgProps.pClass);
    }

    if (pSendParams->MsgProps.pulBodyType)
    {
        pUserFlags->ulBodyType = *(pSendParams->MsgProps.pulBodyType);
    }
}


static
void 
MsgFlagsHash(
	IN HCRYPTHASH hHash, 	
	IN const struct _MsgFlags* pUserFlags
	)
/*++
Routine Description:
	Message Flags hash.

Arguments:
	hHash - hash object
	pUserFlags - pointer to structure of user flags

Returned Value:
	none.

--*/
{
	CryHashData(
		reinterpret_cast<const BYTE*>(pUserFlags), 
		sizeof(_MsgFlags),
		hHash
		);

    DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: MsgFlagsHash(), bDelivery = %d"), pUserFlags->bDelivery)) ;

    DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: MsgFlagsHash(), bPriority = %d"), pUserFlags->bPriority)) ;

    DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: MsgFlagsHash(), bAuditing = %d"),  pUserFlags->bAuditing)) ;

    DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: MsgFlagsHash(), bAck = %d"), pUserFlags->bAck)) ;

    DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: MsgFlagsHash(), usClass = %d"), pUserFlags->usClass)) ;

    DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: MsgFlagsHash(), ulBodyType = %d"), pUserFlags->ulBodyType)) ;
}


static
void 
MsgFlagsHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Message Flags hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
    //
    // Prepare structure of flags.
    //
    struct _MsgFlags sUserFlags;
    memset(&sUserFlags, 0, sizeof(sUserFlags));

	MsgFlags(pSendParams, &sUserFlags);
	MsgAckFlag(pSendParams, &sUserFlags);
	MsgFlagsHash(hHash, &sUserFlags);
}


static
void 
ConnectorHash(
	IN HCRYPTHASH hHash, 	
	IN const CACSendParameters* pSendParams
	)
/*++
Routine Description:
	Connector hash.

Arguments:
	hHash - hash object
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	//
	// Connector Type
	//
    GUID guidConnector = GUID_NULL;
    const GUID *pConnectorGuid = &guidConnector;
    if (pSendParams->MsgProps.ppConnectorType)
    {
        pConnectorGuid = *(pSendParams->MsgProps.ppConnectorType);
    }

	CryHashData(
		reinterpret_cast<const BYTE*>(pConnectorGuid), 
		sizeof(GUID),
		hHash
		);

	DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: CalcPropHash(), ConnectorGuid = %!guid!"), pConnectorGuid)) ;
}


static
void 
CalcPropHash(
	IN HCRYPTHASH hHash, 	
	IN LPCWSTR pwszTargetFormatName,
	IN const CACSendParameters *pSendParams
	)
/*++
Routine Description:
	Calc the hash value of Message property

Arguments:
	hHash - hash object
	pwszTargetFormatName - Target queue format name (LPWSTR)
    pSendParams - pointer to send params.

Returned Value:
	none.

--*/
{
	MsgBodyHash(hHash, pSendParams); 
	CorrelationIdHash(hHash, pSendParams);
	ApplicationTagHash(hHash, pSendParams);
	TitleHash(hHash, pSendParams);
	ResponseMqfHash(hHash, pSendParams);
	AdminMqfHash(hHash, pSendParams);
	ExtensionHash(hHash, pSendParams);
	TargetFormatNameHash(hHash, pwszTargetFormatName);
	SourceQmHash(hHash, pSendParams);
	MsgFlagsHash(hHash, pSendParams);
	ConnectorHash(hHash, pSendParams);
}


HRESULT 
SignMqf( 
	IN PMQSECURITY_CONTEXT  pSecCtx,
	IN LPCWSTR pwszTargetFormatName,
	IN OUT CACSendParameters* pSendParams,
	OUT AP<BYTE>& pSignatureMqf,
	OUT DWORD* pSignatureMqfLen
	)
/*++
Routine Description:
	Sign message with XML digital signature.

Arguments:
	pSecCtx - pointer to the security context
	pwszTargetFormatName - Target queue format name (LPWSTR)
    pSendParams - pointer to send params.
	pSignatureMqf - auto pointer of bytes for the mqf signature 
	pSignatureMqfLen - length of mqf signature

Returned Value:
    change the value in the transfer buffer of
	create the SignatureElement (xml digital signature) and store it 
	in the transfer buffer

	MQ_OK, if successful, else error code.

--*/
{
	//
	// This check if the CSP is initialize correctly
	//
    HRESULT hr = CheckInitProv(pSecCtx);

    if (FAILED(hr))
    {
        return hr;
    }
	

	try
	{
		//
		// Sign properies
		//

		CHashHandle hHash = CryCreateHash(
								pSecCtx->hProv, 
								*pSendParams->MsgProps.pulHashAlg
								);

		CalcPropHash(
			 hHash, 
			 pwszTargetFormatName,
			 pSendParams
			 );

		BYTE** ppSignatureMqf = &pSignatureMqf;
		pSignatureMqf = CryCreateSignature(
							hHash,
							pSecCtx->dwPrivateKeySpec,
							pSignatureMqfLen
							);

		pSendParams->ppSignatureMqf = ppSignatureMqf;

		DBGMSG((DBGMOD_SECURITY, DBGLVL_TRACE, _TEXT("RT: SignMqf() SignatureMqf (MSMQ30 signature) complete ok")));
		return MQ_OK;
	}
	catch (const bad_CryptoApi& exp)
	{
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT("RT: SignMqf(), bad Crypto Class Api Excption ErrorCode = %x"), exp.error()));
		DBG_USED(exp);

		return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 50);
	}
	catch (const bad_alloc&)
	{
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT("RT: SignMqf(), bad_alloc Excption")));
		return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 60);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtsecctx.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: rtsecctx.cpp

Abstract:

    This module implements the MQGetSecurityContext() and
    MQFreeSecurityContext() apis.

Author:

    Original version from message.cpp.
    Doron Juster (DoronJ)  12-Aug-1998
    Ilan Herbst  (ilanh)   25-June-2000

Revision History:

--*/

#include "stdh.h"
#include <autorel.h>
#include <_secutil.h>
#include <rtdep.h>

#include "rtsecctx.tmh"

static WCHAR *s_FN=L"rt/rtsecctx";

//
// Each security context get its own unique serial number. This is used
// when creating the name for a key container for MQGetSecurityContext().
// Having a unique name enable us to run multi-threaded without critical
// sections.
//
static LONG s_lCtxSerialNumber = 0 ;

#ifdef _DEBUG
#define REPORT_CTX_ERROR(pt) { DWORD dwErr = GetLastError() ;  LogNTStatus(dwErr, s_FN, pt); }
#else
#define REPORT_CTX_ERROR(pt)
#endif

//
// PROPID_M_SECURITY_CONTEXT is a VT_UI4 property, but the value is
// a pointer to MQSECURITY_CONTEXT class. On win64 the ptr cannot fit
// into a VT_UI4 property, so we need to map between this PTR and a DWORD.
// The object below performs the mapping
//
CContextMap g_map_RT_SecCtx;

//+--------------------------------------------
//
// The constractor for MQSECURITY_CONTEXT.
//
//+--------------------------------------------

MQSECURITY_CONTEXT::MQSECURITY_CONTEXT() :
	dwVersion(SECURITY_CONTEXT_VER),
	dwUserSidLen(0),
	dwUserCertLen(0),
	dwProvType(0),
	bDefProv(TRUE),
	bInternalCert(TRUE),
	dwPrivateKeySpec(AT_SIGNATURE),
	fAlreadyImported(FALSE),
	dwPrivateKeySize(0),
	fLocalSystem(FALSE),
	fLocalUser(FALSE)
{
}

//+--------------------------------------------
//
// The destractor for MQSECURITY_CONTEXT.
//
//+--------------------------------------------

MQSECURITY_CONTEXT::~MQSECURITY_CONTEXT()
{
    if (fAlreadyImported)
    {
        CryptReleaseContext(hProv, 0);
        hProv = NULL;

        //
        // delete the temporary keyset which was created before
        // importing the private key.
        //
        CryptAcquireContext(
			&hProv,
			wszContainerName,
			wszProvName,
			dwProvType,
			CRYPT_DELETEKEYSET
			);
        hProv = NULL;
    }
}

//+-------------------------------
//
//  AllocSecurityContext()
//
//+-------------------------------

PMQSECURITY_CONTEXT
AllocSecurityContext()
{
    PMQSECURITY_CONTEXT pSecCtx =  new MQSECURITY_CONTEXT;
    return pSecCtx;
}

//+---------------------------------------------------------------
//
//  BOOL SameAsProcessSid( PSID pSid )
//
//  Return TRUE if input sid is equal to sid of process token.
//
//+---------------------------------------------------------------

BOOL SameAsProcessSid(PSID pSid)
{
    P<BYTE>  ptu = NULL;
    CAutoCloseHandle  hAccessToken = NULL;

    BOOL f = OpenProcessToken(
				GetCurrentProcess(),
				TOKEN_QUERY,
				&hAccessToken
				);
    if (!f)
    {
        //
        // return false.
        // if thread can't open the process token then it's probably
        // impersonating a user that don't have the permission to do that.
        // so it's not the process user.
        //
        REPORT_CTX_ERROR(9);
        LogIllegalPoint(s_FN, 10);
        return FALSE;
    }

    DWORD dwLen = 0;
    GetTokenInformation(hAccessToken, TokenUser, NULL, 0, &dwLen);
    DWORD dwErr = GetLastError();
    LogNTStatus(dwErr, s_FN, 11);

    if (dwErr == ERROR_INSUFFICIENT_BUFFER)
    {
        ptu = new BYTE[ dwLen ];
        f = GetTokenInformation(
				hAccessToken,
				TokenUser,
				ptu,
				dwLen,
				&dwLen
				);

        ASSERT(f);
        if (!f)
        {
            REPORT_CTX_ERROR(12);
            return FALSE;
        }

        PSID pUser = ((TOKEN_USER*)(BYTE*)ptu)->User.Sid;
        f = EqualSid(pSid, pUser);
        return f;
    }

    return FALSE;
}

//+----------------------------------------------------------------
//
//  HRESULT  RTpImportPrivateKey( PMQSECURITY_CONTEXT pSecCtx )
//
//+----------------------------------------------------------------

HRESULT  RTpImportPrivateKey(PMQSECURITY_CONTEXT pSecCtx)
{
    CS Lock(pSecCtx->CS);

    if (pSecCtx->fAlreadyImported)
    {
        //
        // this condition may happen if two threads call MQSend() at the
        // same time, using a new security context which was not yet
        // imported.
        //
        return MQ_OK;
    }

    if (!(pSecCtx->pPrivateKey))
    {
        //
        // there is no private key to import.
        //
        REPORT_CTX_ERROR(29);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 30);
    }

    //
    // Build name of key container. Combine ProcessID with SID.
    //
    LONG lNum = InterlockedIncrement(&s_lCtxSerialNumber);
    swprintf( pSecCtx->wszContainerName,
              L"P-%lu-C-%lu", GetCurrentProcessId(), (DWORD) lNum);
    //
    // Delete key container if already exist. That's something left
    // from previous processes which didn't clean up.
    //
    HCRYPTPROV hProv = NULL;
    CryptAcquireContext(
		&hProv,
		pSecCtx->wszContainerName,
		pSecCtx->wszProvName,
		pSecCtx->dwProvType,
		CRYPT_DELETEKEYSET
		);

    //
    // Create the key container.
    //
    BOOL f = CryptAcquireContext(
				&pSecCtx->hProv,
				pSecCtx->wszContainerName,
				pSecCtx->wszProvName,
				pSecCtx->dwProvType,
				CRYPT_NEWKEYSET
				);
    if (!f)
    {
        REPORT_CTX_ERROR(39);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 40);
    }

    //
    // Import the private key into the container.
    //
    HCRYPTKEY hKey = NULL;
    f = CryptImportKey(
			pSecCtx->hProv,
			pSecCtx->pPrivateKey,
			pSecCtx->dwPrivateKeySize,
			0,
			0,
			&hKey
			);
    if (!f)
    {
        REPORT_CTX_ERROR(49);
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 50);
    }
    CryptDestroyKey(hKey);

    pSecCtx->fAlreadyImported = TRUE;
    return MQ_OK;
}

//+--------------------------------------
//
//  HRESULT  RTpExportSigningKey()
//
//+--------------------------------------

HRESULT  RTpExportSigningKey(MQSECURITY_CONTEXT *pSecCtx)
{
    CHCryptKey hKey = NULL ;

    BOOL f = CryptGetUserKey(
                              pSecCtx->hProv,
		                      pSecCtx->dwPrivateKeySpec,
                              &hKey
                             ) ;
    if (!f)
    {
        REPORT_CTX_ERROR(99) ;
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 100);
    }

    //
    // Get size need for exporting the private key blob.
    //
    pSecCtx->dwPrivateKeySize = 0 ;
    f = CryptExportKey(
                        hKey,
                        NULL,
                        PRIVATEKEYBLOB,
                        0,
                        NULL,
                        &pSecCtx->dwPrivateKeySize
                      ) ;
    if (!f)
    {
        REPORT_CTX_ERROR(109) ;
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 110);
    }

    pSecCtx->pPrivateKey = new BYTE[ pSecCtx->dwPrivateKeySize ] ;
    f = CryptExportKey(
                        hKey,
                        NULL,
                        PRIVATEKEYBLOB,
                        0,
                        pSecCtx->pPrivateKey,
                       &pSecCtx->dwPrivateKeySize
                      ) ;
    if (!f)
    {
        REPORT_CTX_ERROR(119) ;
        return LogHR(MQ_ERROR_CORRUPTED_SECURITY_DATA, s_FN, 120);
    }

    //
    // Release the CSP context handle. We don't need it anymore.
    // We'll acquire it again when importing the key.
    //
    CryptReleaseContext( pSecCtx->hProv, 0 ) ;
    pSecCtx->hProv = NULL ;

    return MQ_OK ;
}

/***********************************************************************
*
*   Function - MQGetSecurityContext()
*
*    Parameters -
*
*    lpCertBuffer - A buffer that contains the user's certificate in
*        ASN.1 DER encoded format.  This parameter can be set to NULL. If
*        set to NULL, the internal MSMQ certificate is used.
*
*    dwCertBufferLength - The length of the buffer pointed by lpCertBuffer.
*        This parameter is ignored if lpCertBuffer is set to NULL.
*
*    lplpSecurityContextBuffer - A pointer to a buffer that receives the
*        address of the allocated buffer for the security context.
*
*    Description -
*
*        This function should be called in the context of the
*        user that owns the passed certificate. The function
*        allocates the required security buffer and fills it
*        with data that will be used later in MQSendMessage().
*        The purpose of this function is to accelerate the
*        security operations of MQSendMessage(), by caching
*        the security information in the buffer. The
*        application is responsible to pass the security
*        context buffer to MQSendMessage() in
*        PROPID_M_SECURITY_CONTEXT.
*
*        If the user uses more than one certificate, this function
*        should be called for each certificate.
*
*        The application should call MQFreeSecurityContext() and pass the
*        pointer to the security context buffer, when the security
*        buffer is not required anymore.
*
*       Impersonation- It's possible for a process to impersonate a user,
*        then call this function to cache the user data, and then revert
*        to itself and send messages on behalf of that user.
*        To do so, the process must LogonUser() for the user, then load its
*        hive (RegLoadKey()), impersonate the logged on user and finally
*        call this function. Then revert and send messages.
*        With MSMQ1.0 which shipped with NTEE and NTOP, this function used
*        an unsupported and undocumented feature which enabled you just to
*        call CryptAcquireContext() while impersonated, then use the handle
*        after process revert to itself. This feature is not available on IE4
*        and above. The supported way to implement this functionality is to
*        export the private key from the user hive, then (after reverting) to
*        import it into the process hive. See MSMQ bug 2955
*        We'll keep the CryptAcquireContext() code for the case of same user
*        (i.e., thread run in the context of the process user. There was no
*        impersonation). In that case it's legal and enhance performance.
*
*    Return Value -
*        MQ_OK  - If successful, else - Error code.
*
**************************************************************************/

EXTERN_C
HRESULT
APIENTRY
MQGetSecurityContext(
	LPVOID  lpCertBuffer,
	DWORD   dwCertBufferLength,
	HANDLE *phSecurityContext
	)
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepGetSecurityContext(
					lpCertBuffer,
					dwCertBufferLength,
					phSecurityContext
					);

    P<MQSECURITY_CONTEXT> pSecCtx = AllocSecurityContext();
    //
    // the line below may throw bad_alloc on win64, like the allocation above.
    // we return a HANDLE that can be safely cast to 32 bits (for VT_I4 property
    // PROPID_M_SECURITY_CONTEXT).
    //
    HANDLE hSecurityContext = (HANDLE) DWORD_TO_HANDLE(
        ADD_TO_CONTEXT_MAP(g_map_RT_SecCtx, (PMQSECURITY_CONTEXT)pSecCtx, s_FN, 55));
    P<BYTE>    pSid = NULL;
    CHCryptKey hKey = NULL;

    try
    {
        //
        // Get the user SID out from the thread (or process) token.
        //
        hr = RTpGetThreadUserSid(
				&pSecCtx->fLocalUser,
				&pSecCtx->fLocalSystem,
				&pSecCtx->pUserSid,
				&pSecCtx->dwUserSidLen
				);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60);
        }

        if (lpCertBuffer)
        {
            //
            // Copy the certificate and point to the copy from the security
            // context.
            //
            pSecCtx->pUserCert = new BYTE[dwCertBufferLength];
            pSecCtx->dwUserCertLen = dwCertBufferLength;
            memcpy(pSecCtx->pUserCert, lpCertBuffer, dwCertBufferLength);
        }

        //
        // Get all the required information about the certificate and
        // put it in the security context.
        //
		BYTE* pUserCert = pSecCtx->pUserCert.get();
		BYTE** ppUserCert = pUserCert == NULL ? &pSecCtx->pUserCert : &pUserCert;

        hr  = GetCertInfo(
                    false,
					pSecCtx->fLocalSystem,
					ppUserCert,
					&pSecCtx->dwUserCertLen,
					&pSecCtx->hProv,
					&pSecCtx->wszProvName,
					&pSecCtx->dwProvType,
					&pSecCtx->bDefProv,
					&pSecCtx->bInternalCert,
					&pSecCtx->dwPrivateKeySpec	
					);

        if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
        {
            return LogHR(hr, s_FN, 70);
        }

        if (hr == MQ_ERROR_NO_INTERNAL_USER_CERT)
        {
            //
            // If the user does not have an internal certificate,
            // this is not a reason to fail MQGetSecurityContext().
            // MQSendMessage() should fail in case the application
            // tries to use this security context to send an
            // authenticated messages.
            //
            *phSecurityContext = hSecurityContext;
            pSecCtx.detach(); // Prevent from the security context to be freed.

            return MQ_OK;
        }

        //
        // See if process sid match thread sid. We call again
        // GetThreadUserSid() to get sid even for local user.
        // RTpGetThreadUserSid() does not return a sid for local user.
        //
        DWORD dwLen = 0;
        hr = GetThreadUserSid( &pSid, &dwLen );
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 80);
        }

        BOOL fAsProcess = SameAsProcessSid( pSid );

        if (fAsProcess)
        {
            //
            // Thread run under context of process credentials.
            // The Crypto context acquired here is valid for using when
            // calling MQSend().
            //
            *phSecurityContext = hSecurityContext;
            pSecCtx.detach(); // Prevent from the security context to be freed.

            return MQ_OK;
        }

        //
        // Calling code impersonated another user.
        // It's time to export the private key. Later, when calling
        // MQSend(), we'll import it into process hive.
        // We export the private key without encryption, because it
        // dones't leave the machine or the process boundaries.
        //
        hr = RTpExportSigningKey(pSecCtx) ;
        if (SUCCEEDED(hr))
        {
            //
            // Pass the result to the caller.
            //
            *phSecurityContext = hSecurityContext;
            pSecCtx.detach(); // Prevent from the security context to be freed.
        }
    }
    catch(...)
    {
        LogIllegalPoint(s_FN, 130);
        hr = MQ_ERROR_INVALID_PARAMETER;
    }

    return LogHR(hr, s_FN, 140);
}

/*************************************************************************
*
*    Function -  MQFreeSecurityContext()
*
*    Parameters -
*        lpSecurityContextBuffer - A pointer to a security context that was
*        previously allocated by MQGetSecurityContext.
*
*    Description -
*        The function frees the security context that was previously
*        allocated by MQGetSecurityContext().
*
**************************************************************************/

void
APIENTRY
MQFreeSecurityContext(
	HANDLE hSecurityContext
	)
{
	if(FAILED(RtpOneTimeThreadInit()))
		return;

	if(g_fDependentClient)
		return DepFreeSecurityContext(hSecurityContext);

    if (hSecurityContext == 0)
    {
        return;
    }

    PMQSECURITY_CONTEXT pSecCtx;
    try
    {
        pSecCtx = (PMQSECURITY_CONTEXT)
            GET_FROM_CONTEXT_MAP(g_map_RT_SecCtx, (DWORD)HANDLE_TO_DWORD(hSecurityContext), s_FN, 145); //this may throw on win64
    }
    catch(...)
    {
        return;
    }

    delete pSecCtx;
    DELETE_FROM_CONTEXT_MAP(g_map_RT_SecCtx, (DWORD)HANDLE_TO_DWORD(hSecurityContext), s_FN, 146);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\rtutil.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtutil.cpp

Abstract:

    Contains various utility functions.

Author:

    Boaz Feldbaum (BoazF) Mar 5, 1996

Revision History:

    Erez Haba (erezh) 17-Jan-1997

--*/

#include "stdh.h"
#include "ac.h"
#include <mqdbmgr.h>
#include <_secutil.h>
#include <mqsec.h>

#include "rtutil.tmh"

static WCHAR *s_FN=L"rt/rtutil";


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueuePropVar
//
//  Description:
//      Find a queue property in the properties array
//
//---------------------------------------------------------
PROPVARIANT*
RTpGetQueuePropVar(
    PROPID PropID,
    MQQUEUEPROPS *pqp
    )
{
    DWORD i;
    DWORD cProp;
    PROPID *aPropID;

    for (i = 0, cProp = pqp->cProp, aPropID = pqp->aPropID;
         i < cProp;
         i++, aPropID++) {

        if (*aPropID == PropID) {
            return(&(pqp->aPropVar[i]));
        }

    }

    return(NULL);
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueuePathNamePropVar
//
//  Description:
//      Find a the queue path name property in the properties array
//
//---------------------------------------------------------
LPWSTR
RTpGetQueuePathNamePropVar(
    MQQUEUEPROPS *pqp
    )
{
    PROPVARIANT *p;

    if ((p = RTpGetQueuePropVar(PROPID_Q_PATHNAME, pqp)) != NULL)
        return(p->pwszVal);
    else
        return(NULL);
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueueGuidPropVar
//
//  Description:
//      Find the queue guid (instance) property in the properties array
//
//---------------------------------------------------------
GUID*
RTpGetQueueGuidPropVar(
    MQQUEUEPROPS *pqp
    )
{
    PROPVARIANT *p;

    if ((p = RTpGetQueuePropVar(PROPID_Q_INSTANCE, pqp)) != NULL)
        return(p->puuid);
    else
        return(NULL);
}


//---------------------------------------------------------
//
//  Function:
//      RTpMakeSelfRelativeSDAndGetSize
//
//  Parameters:
//      pSecurityDescriptor - The input security descriptor.
//      pSelfRelativeSecurityDescriptor - A pointer to a temporary buffer
//          that holds the converted security descriptor.
//      pSDSize - A pointer to a variable that receives the length of the
//          self relative security descriptor. This is an optional parameter.
//
//  Description:
//      Convert an absolute security descriptor to a self relative security
//      descriptor and get the size of the self relative security descriptor.
//      This function should be call before passing a security descriptor to
//      a function that passes the security descriptor to an RPC function.
//
//      If the input security descriptor is already a self relative security
//      descriptor, the function only computes the length of the security
//      descriptor and returns. If the input security descriptor is an absolute
//      security descriptor, the function allocates a buffer large enough to
//      accomodate the self relative security descripr, converts the absolute
//      security descriptor to a self relative security descriptor and modifies
//      the pointer of the input security descriptor to point to the self relative
//      security descriptor.
//
//      The temporar buffer that is being allocated for the self relative
//      security descriptor should be freed by the calling code.
//
//---------------------------------------------------------
HRESULT
RTpMakeSelfRelativeSDAndGetSize(
    PSECURITY_DESCRIPTOR *pSecurityDescriptor,
    PSECURITY_DESCRIPTOR *pSelfRelativeSecurityDescriptor,
    DWORD *pSDSize)
{
    SECURITY_DESCRIPTOR_CONTROL sdcSDControl;
    DWORD dwSDRevision;

    ASSERT(pSecurityDescriptor);
    ASSERT(pSelfRelativeSecurityDescriptor);

    *pSelfRelativeSecurityDescriptor = NULL;

    if (!*pSecurityDescriptor)
    {
        // Set the security descriptor size.
        if (pSDSize)
        {
            *pSDSize = 0;
        }
        return(MQ_OK);
    }

    // Verify that this is a valid security descriptor.
    if (!IsValidSecurityDescriptor(*pSecurityDescriptor))
    {
        return LogHR(MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR, s_FN, 10);
    }

    // Check whether this is a self relative or absolute security
    // descriptor.
    if (!GetSecurityDescriptorControl(*pSecurityDescriptor,
                                      &sdcSDControl,
                                      &dwSDRevision))
    {
        ASSERT(FALSE);
    }

    if (!(sdcSDControl & SE_SELF_RELATIVE))
    {
        // This is an absolute security descriptor, we should convert it
        // to a self relative one.
        DWORD dwBufferLength = 0;

#ifdef _DEBUG
        SetLastError(0);
#endif
        // Get the buffer size.
        MakeSelfRelativeSD(*pSecurityDescriptor, NULL, &dwBufferLength);
        ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);

        // Allocate the buffer for the self relative security descriptor.
        *pSelfRelativeSecurityDescriptor =
            (PSECURITY_DESCRIPTOR) new char[dwBufferLength];

        // Convert the security descriptor.
        if (!MakeSelfRelativeSD(
                *pSecurityDescriptor,
                *pSelfRelativeSecurityDescriptor,
                &dwBufferLength))
        {
            ASSERT(FALSE);
        }
        ASSERT(IsValidSecurityDescriptor(*pSelfRelativeSecurityDescriptor));
        *pSecurityDescriptor = *pSelfRelativeSecurityDescriptor;

        // Set the security descriptor size.
        if (pSDSize)
        {
            *pSDSize = dwBufferLength;
        }

    }
    else
    {

        // The security descriptor is already in self relative format, just
        // set the security descriptor size.
        if (pSDSize)
        {
            *pSDSize = GetSecurityDescriptorLength(*pSecurityDescriptor);
        }

    }

    return(MQ_OK);
}


//---------------------------------------------------------
//
//  Function:
//     RTpConvertToMQCode
//
//  Parameters:
//      hr - Error vode that is generated by any kind of module.
//
// Return value:
//      The imput parameter convetrted to some equivalent MQ_ERROR constant.
//
//---------------------------------------------------------
HRESULT
RTpConvertToMQCode(
    HRESULT hr,
    DWORD dwObjectType
    )
{

    if ((hr == MQ_OK)                                   ||
        (hr == MQ_INFORMATION_REMOTE_OPERATION)         ||
        (hr == MQ_ERROR_Q_DNS_PROPERTY_NOT_SUPPORTED)   ||
        ((MQ_E_BASE <= hr) && (hr < MQ_E_BASE + 0x100)) ||
        ((MQ_I_BASE <= hr) && (hr < MQ_I_BASE + 0x100)))
    {
        // This is our codes, do not modify it.
        return LogHR(hr, s_FN, 20);
    }

    if (hr == MQDS_OK_REMOTE)
    {
        //
        // success - we use MQDS_OK_REMOTE for internal use, e.g. explorer
        //
        return(MQ_OK);
    }

    if (HRESULT_FACILITY(MQ_E_BASE) == HRESULT_FACILITY(hr))
    {
        switch (hr)
        {
        case MQDB_E_NO_MORE_DATA:
        case MQDS_GET_PROPERTIES_ERROR:
        case MQDS_OBJECT_NOT_FOUND:
            hr = (dwObjectType ==  MQDS_QUEUE) ?
                    MQ_ERROR_QUEUE_NOT_FOUND :
                    MQ_ERROR_MACHINE_NOT_FOUND;
            break;

        case MQDS_NO_RSP_FROM_OWNER:
            hr = MQ_ERROR_NO_RESPONSE_FROM_OBJECT_SERVER;
            break;

        case MQDS_OWNER_NOT_REACHED:
            hr = MQ_ERROR_OBJECT_SERVER_NOT_AVAILABLE;
            break;

        case MQDB_E_NON_UNIQUE_SORT:
            hr = MQ_ERROR_ILLEGAL_SORT;
            break;

        default:
            // Some DS error occured. This should not happen, but anyway...
            DBGMSG((DBGMOD_API, DBGLVL_WARNING,
                TEXT("A DS error (%x) has propagated to the RT DLL. Converting to MQ_ERROR_DS_ERROR"), hr));
            hr = MQ_ERROR_DS_ERROR;
            break;
        }

        return LogHR(hr, s_FN, 30);
    }

    if (hr == CPP_EXCEPTION_CODE)
    {
        // A C++ exception occured. This can happen only when in an allocation failure.
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 40);
    }

    // Now we hope that we know how to convert an NTSTATUS to some of our error
    // codes. Good luck...
    switch(hr)
    {
    case STATUS_INVALID_HANDLE:
    case STATUS_OBJECT_TYPE_MISMATCH:
    case STATUS_HANDLE_NOT_CLOSABLE:
        hr = MQ_ERROR_INVALID_HANDLE;
        break;

    case STATUS_ACCESS_DENIED:
        hr = MQ_ERROR_ACCESS_DENIED;
        break;

    case STATUS_ACCESS_VIOLATION:
    case STATUS_INVALID_PARAMETER:
        hr = MQ_ERROR_INVALID_PARAMETER;
        break;

    case STATUS_SHARING_VIOLATION:
        hr = MQ_ERROR_SHARING_VIOLATION;
        break;

    case STATUS_PENDING:
        hr = MQ_INFORMATION_OPERATION_PENDING;
        break;

    case STATUS_CANCELLED:
        hr = MQ_ERROR_OPERATION_CANCELLED;
        break;

    case STATUS_INSUFFICIENT_RESOURCES:
        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
        break;

    case STATUS_INVALID_DEVICE_REQUEST:
        hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        break;

    default:
       DBGMSG((DBGMOD_API, DBGLVL_WARNING,
           TEXT("Unfamiliar error code:%x, not converted to a MQ error"), hr));
       break;
    }

    return LogHR(hr, s_FN, 50);
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetThreadUserSid
//
//  Parameters:
//      pUserSid - A pointer to a buffer that receives the address of a buffer
//          that contains the SID of the user of the current thread.
//      pdwUserSidLen - A pointer to a DWORD that receives the length of the
//          SID.
//
//  Description:
//      The function allocates the buffer for the SID and fils it with the SID
//      of the user of the current thread. The calling code is responsible for
//      freeing the allocated buffer.
//
//---------------------------------------------------------

HRESULT
RTpGetThreadUserSid( BOOL    *pfLocalUser,
                     BOOL    *pfLocalSystem,
                     LPBYTE  *pUserSid,
                     DWORD   *pdwUserSidLen )
{
    HRESULT hr;

    hr = MQSec_GetUserType( NULL,
                            pfLocalUser,
                            pfLocalSystem );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60);
    }

    if (*pfLocalSystem)
    {
        *pUserSid = (LPBYTE) MQSec_GetLocalMachineSid( TRUE, // allocate
                                                       pdwUserSidLen ) ;
        if (!(*pUserSid))
        {
            //
            // this may happen if the machine belong to a NT4 domain
            // and it doesn't have any computer account and sid.
            // In that case, make it a local user.
            //
            ASSERT(*pdwUserSidLen == 0) ;
            *pdwUserSidLen = 0 ;

            *pfLocalSystem = FALSE ;
            if (pfLocalUser)
            {
                ASSERT(!(*pfLocalUser)) ;
                *pfLocalUser = TRUE ;
            }
        }
    }
    else if (!(*pfLocalUser))
    {
        hr = GetThreadUserSid(pUserSid, pdwUserSidLen);
    }

    return LogHR(hr, s_FN, 70);
}

//---------------------------------------------------------
//
//  Function:
//      RTpExtractDomainNameFromDLPath
//
//  Parameters:
//      pwcsADsPath - string containg ADS path of an object
//
//  Description:
//      The function extracts the domain name from the ADS path
//      for the purpose of building DL format name
//      
//
//---------------------------------------------------------
WCHAR * RTpExtractDomainNameFromDLPath(
            LPCWSTR pwcsADsPath
            )
{
    //
    //  ASSUMPTION - pwcsADsPath contains valid ADS path string
    //               otherwise this routine is not called
    //
const WCHAR x_LdapProvider[] = L"LDAP";
const DWORD x_LdapProviderLen = (sizeof(x_LdapProvider)/sizeof(WCHAR)) - 1;
const WCHAR x_MiddleDcPrefix[] = L",DC=";
const DWORD x_MiddleDcPrefixLength = (sizeof( x_MiddleDcPrefix)/sizeof(WCHAR)) - 1;

    //
    //  Does the ADsPath starts with LDAP:
    //
    if (0 != _wcsnicmp( pwcsADsPath, x_LdapProvider, x_LdapProviderLen))
    {
        //
        //  For ADsPath that start with GC: we don't add the domain name.
        //
        return NULL;
    }
    DWORD len = wcslen(pwcsADsPath);
    AP<WCHAR> pwcsUpperCaseADsPath = new WCHAR[ len +1];
    wcscpy( pwcsUpperCaseADsPath, pwcsADsPath);
    CharUpper(pwcsUpperCaseADsPath);
    WCHAR * pszFirst = wcsstr(pwcsUpperCaseADsPath, x_MiddleDcPrefix);
    if (pszFirst == NULL)
    {
        return NULL;
    }
    bool fAddDelimiter = false;

    AP<WCHAR> pwcsDomainName = new WCHAR[ wcslen(pwcsADsPath) + 1];
    WCHAR* pwcsNextToFill =  pwcsDomainName;
    //
    // skip the DC=
    //
    pszFirst += x_MiddleDcPrefixLength;

    while (true)
    {
        WCHAR * pszLast = wcsstr(pszFirst, x_MiddleDcPrefix);
        if ( pszLast == NULL)
        {
            //
            //  Copy the last section of domain name
            //
            if ( fAddDelimiter)
            {
                *pwcsNextToFill = L'.';
                pwcsNextToFill++;
            }
            *pwcsNextToFill = L'\0';  
            wcscat( pwcsNextToFill, pszFirst);
            break;
        }
        //
        // Copy this section of the domain name
        //
        if ( fAddDelimiter)
        {
            *pwcsNextToFill = L'.';  
            pwcsNextToFill++;
        }
        wcsncpy( pwcsNextToFill, pszFirst, (pszLast - pszFirst));
        pwcsNextToFill +=  (pszLast - pszFirst);
        fAddDelimiter = true;
        pszFirst =  pszLast + x_MiddleDcPrefixLength;
    }

    return( pwcsDomainName.detach());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\signmqf.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    SignMqf.h

Abstract:
    functions to signed Mqf format name

Author:
    Ilan Herbst (ilanh) 29-Oct-2000

Environment:
    Platform-independent,

--*/

#pragma once

#ifndef _SIGNMQF_H_
#define _SIGNMQF_H_


HRESULT 
SignMqf( 
	IN PMQSECURITY_CONTEXT  pSecCtx,
	IN LPCWSTR pwszTargetFormatName,
	IN OUT CACSendParameters* pSendParams,
	OUT AP<BYTE>& pSignatureMqf,
	OUT DWORD* pSignatureMqfLen
	);


#endif // _SIGNMQF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    stdh.h

Abstract:

Author:

    Erez Haba (erezh) 24-Dec-95

--*/

#ifndef __STDH_H
#define __STDH_H

#include <_stdh.h>

#include <qformat.h>
#include <transact.h>
#include <qmrt.h>
#include <mqlog.h>
#include <rt.h>

#include "rtp.h"

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\xactmq.cpp ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactMq.cpp

Abstract:
    This module implements CMQTransaction object

Author:
    Alexander Dadiomov (AlexDad)

--*/
#include "stdh.h"
#include "txdtc.h"
#include "rtprpc.h"
#include "XactMq.h"
#include <rtdep.h>

#include "xactmq.tmh"

static WCHAR *s_FN=L"rt/XactMq";

//---------------------------------------------------------------------
// CMQTransaction::CMQTransaction
//---------------------------------------------------------------------
CMQTransaction::CMQTransaction()
{
    m_cRefs = 1;
    m_fCommitedOrAborted = FALSE;
    m_hXact = NULL;
    UuidCreate((UUID *)&m_Uow);
}

//---------------------------------------------------------------------
// CMQTransaction::~CMQTransaction
//---------------------------------------------------------------------
CMQTransaction::~CMQTransaction(void)
{
    if (!m_fCommitedOrAborted)
    {
        Abort(NULL, FALSE, FALSE);
    }
}

//---------------------------------------------------------------------
// CMQTransaction::QueryInterface
//---------------------------------------------------------------------
STDMETHODIMP CMQTransaction::QueryInterface(REFIID i_iid,LPVOID *ppv)
{
    *ppv = 0;                       // Initialize interface pointer.

    if (IID_IUnknown == i_iid)
    {
        *ppv = (IUnknown *)((ITransaction *)this);
    }
    else if (IID_ITransaction == i_iid)
    {
        *ppv = (ITransaction *)this;
    }
    else if (IID_IMSMQTransaction == i_iid)
    {
        *ppv = (IMSMQTransaction *)this;
    }


    if (0 == *ppv)                  // Check for null interface pointer.
    {
        return E_NOINTERFACE;       // from winerror.h
                                    // Neither IUnknown nor IResourceManagerSink
    }
    ((LPUNKNOWN) *ppv)->AddRef();   // Interface is supported. Increment
                                    // its usage count.

    return S_OK;
}


//---------------------------------------------------------------------
// CMQTransaction::AddRef
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CMQTransaction::AddRef(void)
{
    return InterlockedIncrement(&m_cRefs);               // Increment interface usage count.
}


//---------------------------------------------------------------------
// CMQTransaction::Release
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CMQTransaction::Release(void)
{
    // Is anyone using the interface?
    if (InterlockedDecrement(&m_cRefs))
    {                               // The interface is in use.
        return m_cRefs;             // Return the number of references.
    }

    delete this;                    // Interface not in use -- delete!

    return 0;                       // Zero references returned.
}

//+--------------------------------------------------------
//
//    CMQTransaction::CannotUseThisTransaction()
//
//  return TRUE if this transaction object cannot be used anymore for
//  send and receive operations. Bug 4741.
//
//+--------------------------------------------------------

inline BOOL  CMQTransaction::CannotUseThisTransaction()
{
    if (m_fCommitedOrAborted)
    {
        //
        // The transaction object can not be used after commit/abort.
        // It must be released and new one created and initialized.
        //
        return TRUE ;
    }

    return FALSE ;
}

#pragma warning(disable: 4100)  // unreferenced formal parameter
//---------------------------------------------------------------------
// CMQTransaction::Commit
//---------------------------------------------------------------------
HRESULT CMQTransaction::Commit(BOOL fRetaining, DWORD grfTC, DWORD grfRM)
{
   //------------------------------------------------------------
   // RPC call to QM for prepare/commit
   //------------------------------------------------------------
   HRESULT rc;

   if ((grfTC != 0 && grfTC != XACTTC_SYNC) ||
        grfRM != 0 || fRetaining != FALSE)
   {
       return LogHR(XACT_E_NOTSUPPORTED, s_FN, 10);
   }

    if (CannotUseThisTransaction())
    {
        return MQ_ERROR_TRANSACTION_SEQUENCE ;
    }

   __try
   {
        rc = QMCommitTransaction(&m_hXact);
        m_fCommitedOrAborted = TRUE;
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
       LogIllegalPoint(s_FN, 20);
       rc = E_FAIL;
   }

   return LogHR(rc, s_FN, 30);
}

//---------------------------------------------------------------------
// CMQTransaction::Abort
//---------------------------------------------------------------------
HRESULT CMQTransaction::Abort(BOID *pboidReason, BOOL fRetaining, BOOL fAsync)
{
   if (fAsync || fRetaining)
   {
       return LogHR(XACT_E_NOTSUPPORTED, s_FN, 40);
   }

    if (CannotUseThisTransaction())
    {
        return MQ_ERROR_TRANSACTION_SEQUENCE ;
    }

   //------------------------------------------------------------
   // RPC call to QM for prepare/commit
   //------------------------------------------------------------
   HRESULT rc;

   __try
   {
        rc = QMAbortTransaction(&m_hXact);
        m_fCommitedOrAborted = TRUE;
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
       LogIllegalPoint(s_FN, 50);
       rc = E_FAIL;
   }

   return LogHR(rc, s_FN, 60);
}

//---------------------------------------------------------------------
// CMQTransaction::GetTransactionInfo
//---------------------------------------------------------------------
HRESULT CMQTransaction::GetTransactionInfo(XACTTRANSINFO *pinfo)
{
    ZeroMemory((PVOID)pinfo, sizeof(XACTTRANSINFO));
    CopyMemory((PVOID)&pinfo->uow, (PVOID)&m_Uow, sizeof(XACTUOW));
    return MQ_OK;
}

//---------------------------------------------------------------------
// CMQTransaction::EnlistTransaction
//---------------------------------------------------------------------
HRESULT CMQTransaction::EnlistTransaction(XACTUOW *pUow)
{

    HRESULT hr;

    // No need for several enlistments
    if (m_hXact)
    {
        return MQ_OK;
    }

    if (CannotUseThisTransaction())
    {
        return MQ_ERROR_TRANSACTION_SEQUENCE ;
    }

    // RPC call to QM for enlistment
    __try
    {
        ASSERT( tls_hBindRpc ) ;
        hr = QMEnlistInternalTransaction(tls_hBindRpc, pUow, &m_hXact);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
       DWORD rc = GetExceptionCode();
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT(
           "CMQTransaction::EnlistTransaction failed: RPC code=%x "), rc));

       LogHR(HRESULT_FROM_WIN32(rc), s_FN, 70);
       hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
       m_hXact = NULL;
    }

    if(FAILED(hr))
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT
                      ("QMEnlistInternalTransaction failed: %x "), hr));
    }
    return LogHR(hr, s_FN, 80);
}

#pragma warning(default: 4100)  // unreferenced formal parameter

//---------------------------------------------------------------------
//    MQBeginTransaction() - Generates new MSMQ internal transaction
//---------------------------------------------------------------------
EXTERN_C
HRESULT
APIENTRY
MQBeginTransaction(OUT ITransaction **ppTransaction)
{
	HRESULT hr = RtpOneTimeThreadInit();
	if(FAILED(hr))
		return hr;

	if(g_fDependentClient)
		return DepBeginTransaction(ppTransaction);

    hr = MQ_OK;
	ITransaction* pTransaction = NULL;
    try
    {
        pTransaction = new CMQTransaction;
    }
    catch(const bad_alloc&)
    {
        LogIllegalPoint(s_FN, 90);
        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }


    if (SUCCEEDED(hr))
    {
        // We are not obliged to enlist immediately, but otherwise Commit for empty xact will fail
        XACTUOW Uow;

        hr = RTpProvideTransactionEnlist(pTransaction, &Uow);
        if(FAILED(hr))
        {
		    delete pTransaction;
            DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("RTpProvideTransactionEnlist failed: %x "), hr));
        }
		else
		{
			*ppTransaction = pTransaction;
		}
    }

    return LogHR(hr, s_FN, 100);
}

//---------------------------------------------------------------------
//    MQGetTmWhereabouts() - brings controlling DTC whereabouts
//    This is a private non-published function which we need outside of the DLL
//---------------------------------------------------------------------
HRESULT
MQGetTmWhereabouts(IN  DWORD  cbBufSize,
                   OUT UCHAR *pbWhereabouts,
                   OUT DWORD *pcbWhereabouts)
{
    HRESULT hr = MQ_OK;

    // RPC call to QM for getting whereabouts
    __try
    {
        ASSERT( tls_hBindRpc ) ;
        hr = QMGetTmWhereabouts(tls_hBindRpc,
                                cbBufSize,
                                pbWhereabouts,
                                pcbWhereabouts);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
       DWORD rc = GetExceptionCode();
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT(
                        "MQGetTmWhereabouts failed: RPC code=%x "), rc));

       LogHR(HRESULT_FROM_WIN32(rc), s_FN, 110);
       hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }

    if (FAILED(hr))
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR,
                      TEXT("QMGetTmWhereabouts failed: %x "), hr));
    }
    return LogHR(hr, s_FN, 120);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\xactdata.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactData.cpp

Abstract:
    Static GUID definitions for xact processing

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"
 
#define   INITGUID
#include "initguid.h"
 
#define _MTX_NOFORCE_LIBS 
#include "comsvcs.h"
#include "TXDTC.H"
 
#include "xactmq.h"

#include "xactdata.tmh"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\xactmq.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactMq.h

Abstract:
    This module defines CMQTransaction object

Author:
    Alexander Dadiomov (AlexDad)

--*/

#ifndef __XACTMQ_H__
#define __XACTMQ_H__

//IID_IMSMQTransaction 2f221ca0-d1de-11d0-9215-0060970536a0
DEFINE_GUID(IID_IMSMQTransaction,
		    0x2f221ca0,
		    0xd1de,
		    0x11d0,
		    0x92, 0x15, 0x00, 0x60, 0x97, 0x05, 0x36, 0xa0);

interface IMSMQTransaction : public IUnknown
{
public:
    virtual HRESULT __stdcall EnlistTransaction(XACTUOW *pUow) = 0;
};


//---------------------------------------------------------------------
// CMQTransaction: Transaction Object in Falcon RT
//---------------------------------------------------------------------
class CMQTransaction: public ITransaction,
                      public IMSMQTransaction
{
public:

    // Construction and COM
    //
    CMQTransaction();
    ~CMQTransaction( void );

    STDMETHODIMP    QueryInterface( REFIID i_iid, void **ppv );
    STDMETHODIMP_   (ULONG) AddRef( void );
    STDMETHODIMP_   (ULONG) Release( void );

    STDMETHODIMP Commit(
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM);

    STDMETHODIMP Abort(
            /* [in] */ BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync);

    STDMETHODIMP  GetTransactionInfo(
            /* [out] */ XACTTRANSINFO *pinfo);

    STDMETHODIMP   EnlistTransaction(
            /* in]  */  XACTUOW *pUow);

private:
    LONG    m_cRefs;
    BOOL    m_fCommitedOrAborted;
    XACTUOW m_Uow;

    RPC_INT_XACT_HANDLE m_hXact;

    BOOL  CannotUseThisTransaction() ;
};

#endif __XACTMQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rt\xactrt.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    XactRT.cpp

Abstract:

    This module contains RT code involved with transactions.

Author:

    Alexander Dadiomov (alexdad) 19-Jun-96

Revision History:

--*/

#include "stdh.h"
#include "TXDTC.H"
#include "txcoord.h"
#include "cs.h"
#include "mqutil.h"
#include "rtprpc.h"
#include "xactmq.h"

#include "xactrt.tmh"

static WCHAR *s_FN=L"rt/XactRT";

//RT transactions cache:  ring buffer of transaction UOWs
#define XACT_RING_BUF_SIZE   16                        // size of the transactions ring buffer

static  XACTUOW  s_uowXactRingBuf[XACT_RING_BUF_SIZE];   // transaction ring buffer

ULONG   s_ulXrbFirst =  XACT_RING_BUF_SIZE;  // First used element in transaction ring buffer
ULONG   s_ulXrbLast  =  XACT_RING_BUF_SIZE;  // Last  used element in transaction ring buffer

static CCriticalSection s_RingBufCS;

// Whereabouts of the controlling DTC for the QM
ULONG     g_cbQmTmWhereabouts = 0;      // length of DTC whereabouts
AP<BYTE>  g_pbQmTmWhereabouts;   // DTC whereabouts

static ITransactionExport *g_pExport = NULL;  // cached DTC export object

HANDLE g_hMutexDTC = NULL;   // Serializes calls to DTC

extern HRESULT MQGetTmWhereabouts(
                   IN  DWORD  cbBufSize,
                   OUT UCHAR *pbWhereabouts,
                   OUT DWORD *pcbWhereabouts);

/*====================================================
GetMutex
    Internal: creates/opens global mutex and waits for it
=====================================================*/
HRESULT GetMutex()
{
    if (!g_hMutexDTC)
    {
         g_hMutexDTC = CreateMutexA(NULL, FALSE, "MSMQ_DTC");
    }

    if (!g_hMutexDTC)
    {
        DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("CreateMutex failed: %x "), 0));
        return LogHR(MQ_ERROR_DTC_CONNECT, s_FN, 10);
    }

    WaitForSingleObject(g_hMutexDTC, 5 * 60 * 1000);
    return MQ_OK;
}

//---------------------------------------------------------
//  BOOL FindTransaction( XACTUOW *pUow )
//
//  Description:
//
//    Linear search in the ring buffer;  *not* adds
//    returns TRUE if xaction was found, FALSE - if not
//---------------------------------------------------------
static BOOL FindTransaction(XACTUOW *pUow)
{
    CS lock(s_RingBufCS);

    // Look for the UOW in the ring buffer
    for (ULONG i = s_ulXrbFirst; i <= s_ulXrbLast && i < XACT_RING_BUF_SIZE; i++)
    {
        if (memcmp(&s_uowXactRingBuf[i], pUow, sizeof(XACTUOW))==0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//---------------------------------------------------------
//  BOOL RememberTransaction( XACTUOW *pUow )
//
//  Description:
//
//    Linear search in the ring buffer;  adds there if not found;
//    returns TRUE if xaction was found, FALSE - if it was added
//---------------------------------------------------------
static BOOL RememberTransaction(XACTUOW *pUow)
{
    CS lock(s_RingBufCS);

    // Look for the UOW in the ring buffer
    for (ULONG i = s_ulXrbFirst; i <= s_ulXrbLast && i < XACT_RING_BUF_SIZE; i++)
    {
        if (memcmp(&s_uowXactRingBuf[i], pUow, sizeof(XACTUOW))==0)
        {
            return TRUE;
        }
    }

    // No check for ring buffer overflow, because it is not dangerous (maximum RT will go to QM)

    // adding transaction to the ring buffer

    if (s_ulXrbFirst == XACT_RING_BUF_SIZE)
    {
        // Ring buffer is empty
        s_ulXrbFirst = s_ulXrbLast = 0;
        memcpy(&s_uowXactRingBuf[s_ulXrbFirst], pUow, sizeof(XACTUOW));
    }
    else
    {
        s_ulXrbLast = (s_ulXrbLast == XACT_RING_BUF_SIZE-1 ? 0 : s_ulXrbLast+1);
        memcpy(&s_uowXactRingBuf[s_ulXrbLast], pUow, sizeof(XACTUOW));
    }

    return FALSE;
}

//---------------------------------------------------------
// HRESULT RTpGetExportObject
//
//  Description:
//
//    Creates and caches the DTC export object
//---------------------------------------------------------
HRESULT RTpGetExportObject(IUnknown  *punkDtc,
                           ULONG     cbTmWhereabouts,
                           BYTE      *pbTmWhereabouts)
{
    HRESULT                          hr = MQ_OK;
    R<ITransactionExportFactory>     pTxExpFac   = NULL;

    if (g_pExport)
    {
        g_pExport->Release();
        g_pExport = NULL;
    }

    // Get the DTC's ITransactionExportFactory interface
    hr = punkDtc->QueryInterface (IID_ITransactionExportFactory, (void **)(&pTxExpFac.ref()));
    if (FAILED(hr))
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("QueryInterface failed: %x "), hr));
       return LogHR(hr, s_FN, 20);
    }


    // Create Export object
    hr = pTxExpFac->Create (cbTmWhereabouts, pbTmWhereabouts, &g_pExport);
    if (FAILED(hr))
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("Create Export Object failed: %x "), hr));
       return LogHR(hr, s_FN, 30);
    }

    return(MQ_OK);
}

//---------------------------------------------------------
// HRESULT RTpBuildTransactionCookie
//
//  Description:
//
//    Builds transaction Cookie
//---------------------------------------------------------
HRESULT RTpBuildTransactionCookie(ITransaction *pTrans,
                                  ULONG        *pcbCookie,
                                  BYTE        **ppbCookie)
{
    HRESULT                          hr = MQ_OK;
    ULONG                            cbUsed;
    R<IUnknown>                      punkTx = NULL;

    *pcbCookie = 0;
    *ppbCookie = NULL;

    // Get transaction's Unknown
    hr = pTrans->QueryInterface (IID_IUnknown, (void **)(&punkTx.ref()));
    if (FAILED(hr))
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("QueryInterface failed: %x "), hr));
       return LogHR(hr, s_FN, 40);
    }
    // Get transaction cookie size
    hr = g_pExport->Export (punkTx.get(), pcbCookie);
    if (FAILED(hr) || *pcbCookie == 0)
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("Export failed: %x "), hr));
       return LogHR(hr, s_FN, 50);
    }

    // Allocate memory for transaction Cookie
    try
    {
        *ppbCookie =  new BYTE[*pcbCookie];
    }
    catch(const bad_alloc&)
    {
        DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("Allocation failed: %x "), hr));
        LogIllegalPoint(s_FN, 60);
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    // Get transaction Cookie itself
    hr = g_pExport->GetTransactionCookie(punkTx.get(), *pcbCookie, *ppbCookie, &cbUsed);
    if (FAILED(hr))
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("GetTransactionCookie failed: %x "), hr));
       return LogHR(hr, s_FN, 70);
    }

    return(MQ_OK);
}


//---------------------------------------------------------
// HRESULT RTXactGetDTC
//
//  Description:
//
//  Obtains DTC transaction manager.  Defers to mqutil
//
//  Outputs:
//    ppunkDTC      pointers to DTC transaction manager
//---------------------------------------------------------
EXTERN_C
HRESULT
APIENTRY
RTXactGetDTC(
    IUnknown **ppunkDTC
    )
{
	HRESULT hri = RtpOneTimeThreadInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr =  MQ_ERROR;

    __try
    {
        //
        // Bug 8772. Test success of GetMutex().
        //
        hr = GetMutex();  // Isolate export creation from others
        LogHR(hr, s_FN, 78);
        if (SUCCEEDED(hr))
        {
            hr = XactGetDTC(ppunkDTC, NULL, NULL) ;
            LogHR(hr, s_FN, 80);
        }
    }
    __finally

    {
        if (g_hMutexDTC != NULL)
        {
            BOOL bRet = ReleaseMutex(g_hMutexDTC);
            ASSERT(bRet) ;
            DBG_USED(bRet);
        }
    }
    return (SUCCEEDED(hr) ? MQ_OK : hr);
}


//---------------------------------------------------------
// HRESULT RTpProvideTransactionEnlist
//
//  Description:
//
//    Provides that QM is enlisted in this transaction,
//    checks the transaction state
//---------------------------------------------------------
HRESULT RTpProvideTransactionEnlist(ITransaction *pTrans, XACTUOW *pUow)
{
    HRESULT                         hr = MQ_OK;
    IUnknown                       *punkDtc  = NULL;
    IMSMQTransaction               *pIntXact = NULL;
    ULONG                           cbTmWhereabouts;
    BYTE                           *pbTmWhereabouts = NULL;
    ULONG                           cbCookie;
    BYTE                           *pbCookie = NULL;
    XACTTRANSINFO                   xinfo;
    BOOL                            fMutexTaken = FALSE;

    __try
    {
        //
        // Get the transaction info. UOW resides there.
        //
        hr = pTrans->GetTransactionInfo(&xinfo);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("GetTransactionInfo failed: %x "), hr));
            hr = MQ_ERROR_TRANSACTION_ENLIST;
            __leave;
        }

        // Put pointer to UOW in the output parameter
        CopyMemory(pUow, &xinfo.uow, sizeof(XACTUOW));

        //
        // Is it internal transaction?
        //
        pTrans->QueryInterface (IID_IMSMQTransaction, (void **)(&pIntXact));

        if (pIntXact)
        {
           // Internal transactions
           //------------------------
           hr = pIntXact->EnlistTransaction(pUow);
           if (FAILED(hr))
           {
                DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("EnlistTransaction failed: %x "), hr));
           }
        }
        else
        {
            // External transactions
            //------------------------

            // Look for the transaction in the cache
            //
            if (FindTransaction(pUow))     // this xaction is known already; QM must have been enlisted
            {
                hr = MQ_OK;
                __leave;
            }

            // Get global mutex to isolate enlistment
            //
            hr = GetMutex();  // Isolate export creation from others
            if (FAILED(hr))
            {
                //
                // Bug 8772. Test success of GetMutex().
                //
                __leave;
            }
            fMutexTaken = TRUE;

            // Get the DTC IUnknown and TM whereabouts
            //
            hr = XactGetDTC(&punkDtc, &cbTmWhereabouts, &pbTmWhereabouts);
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("XactGetDTC failed: %x "), hr));
                __leave;
            }

            // XactGetDTC could return success code of 1 if it reconnected to DTC
            if (hr == 1)
            {
                // No Release: DTC object is not alive anymore
                hr = MQ_OK;
                g_pExport = NULL;
            }

            // Get the QM's controlling DTC whereabouts
            //
            if (!g_pbQmTmWhereabouts.get())
            {
                g_cbQmTmWhereabouts = 128;
                g_pbQmTmWhereabouts = new BYTE[128];
                DWORD cbNeeded;

                hr = MQGetTmWhereabouts(g_cbQmTmWhereabouts, g_pbQmTmWhereabouts, &cbNeeded);

                if (hr == MQ_ERROR_USER_BUFFER_TOO_SMALL)
                {
                    g_pbQmTmWhereabouts.free();
                    g_cbQmTmWhereabouts = cbNeeded;
                    g_pbQmTmWhereabouts = new BYTE[cbNeeded];
                    hr = MQGetTmWhereabouts(g_cbQmTmWhereabouts, g_pbQmTmWhereabouts, &cbNeeded);
                }

                if (FAILED(hr))
                {
		            g_pbQmTmWhereabouts.free();	
                    g_cbQmTmWhereabouts = 0;
                    DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("MQGetTmWhereabouts failed: %x "), hr));
                    __leave;
                }
                else
                {
                    g_cbQmTmWhereabouts = cbNeeded;
                }
            }

            //
            // Get and cache Export object
            //

            if (g_pExport == NULL)
            {
                hr = RTpGetExportObject(
                               punkDtc,
                               g_cbQmTmWhereabouts,
                               g_pbQmTmWhereabouts);
                if (FAILED(hr))
                {
                    DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("RTpGetExportObject failed: %x "), hr));
                    hr = MQ_ERROR_TRANSACTION_ENLIST;
                    __leave;
                }
            }

            //
            // Prepare the transaction Cookie
            //
            hr = RTpBuildTransactionCookie(
                        pTrans,
                        &cbCookie,
                        &pbCookie);
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("RTpBuildTransactionCookie failed: %x "), hr));
                hr = MQ_ERROR_TRANSACTION_ENLIST;
                __leave;
            }

            //
            // RPC call to QM for enlistment
            //
            __try
            {
                ASSERT( tls_hBindRpc ) ;
                hr = QMEnlistTransaction(tls_hBindRpc, pUow, cbCookie, pbCookie);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
               DWORD rc = GetExceptionCode();
               DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("RTpProvideTransactionEnlist failed: RPC code=%x "), rc));
               LogHR(HRESULT_FROM_WIN32(rc), s_FN, 90);

               hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }

            //Now that transaction is actually enlisted we remember it in ring buffer
            if (SUCCEEDED(hr))
            {
                RememberTransaction(pUow);
            }
            else
            {
                DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("QMEnlistTransaction failed: %x "), hr));
            }
        }

        if (FAILED(hr)) {
            __leave;
        }
        hr = MQ_OK;
    }

    __finally

    {
        if (SUCCEEDED(hr) && AbnormalTermination())
            hr = MQ_ERROR;

        #ifdef _DEBUG
        DWORD cRef = 0;
        if (punkDtc)
            cRef = punkDtc->Release();
        #else
        if (punkDtc)
            punkDtc->Release();
        #endif

        if (pIntXact)
            pIntXact->Release();

        if (pbCookie)
            delete pbCookie;

        if (fMutexTaken)
        {
            ASSERT(g_hMutexDTC != NULL);
            if (g_hMutexDTC != NULL)
            {
                BOOL bRet = ReleaseMutex(g_hMutexDTC);
                ASSERT(bRet) ;
                DBG_USED(bRet);
            }
        }
    }

    return LogHR(hr, s_FN, 100);
}


//---------------------------------------------------------
// void RTpInitXactRingBuf()
//
//  Description:
//
//    Initiates the ring buffer data
//---------------------------------------------------------
void RTpInitXactRingBuf()
{
    CS lock(s_RingBufCS);

    s_ulXrbFirst =  XACT_RING_BUF_SIZE;
    s_ulXrbLast  =  XACT_RING_BUF_SIZE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\midluser.cpp ===
#include <stdh.h>

#include "..\\common\\midluser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\acrpc.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    acrpc.cpp

Abstract:
    Simulate AC interface using RPC to QM

Author:
    Erez Haba (erezh) 1-Oct-96

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include "acrt.h"
#include "rtp.h"
#include "_mqrpc.h"
#include "rtprpc.h"
#include <acdef.h>

#include "acrpc.tmh"

#define ONE_KB 1024


inline
HRESULT
DeppExceptionFilter(
    HRESULT rc
    )
{
    if(FAILED(rc))
    {
        return rc;
    }

    if(rc == ERROR_INVALID_HANDLE)
    {
        return STATUS_INVALID_HANDLE;
    }

    return  MQ_ERROR_SERVICE_NOT_AVAILABLE;
}

HRESULT
ACDepCloseHandle(
    HANDLE hQueue
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    __try
    {
        //
        //  Use address of hQueue rather than hQueue, since it is an
        //
        LPMQWIN95_QHANDLE ph95 = (LPMQWIN95_QHANDLE) hQueue ;
        HANDLE hContext = ph95->hContext ;

        hr = rpc_ACCloseHandle(&hContext);

        //
        // Free the binding handle
        //
        mqrpcUnbindQMService( &ph95->hBind,
                              NULL ) ;
        delete ph95 ;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = DeppExceptionFilter(GetExceptionCode());
    }

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}


HRESULT
ACDepCreateCursor(
    HANDLE hQueue,
    CACCreateLocalCursor& cc
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    __try
    {
        hr = rpc_ACCreateCursorEx(
                    HRTQUEUE(hQueue),
                    (CACCreateRemoteCursor*)&cc
                    );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = DeppExceptionFilter(GetExceptionCode());
    }

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}

HRESULT
ACDepCloseCursor(
    HANDLE hQueue,
    HACCursor32 hCursor
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    __try
    {
        hr = rpc_ACCloseCursor(
                    HRTQUEUE(hQueue),
                    (ULONG)hCursor
                    );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = DeppExceptionFilter(GetExceptionCode());
    }

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}

HRESULT
ACDepSetCursorProperties(
    HANDLE hProxy,
    HACCursor32 hCursor,
    ULONG  hRemoteCursor
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    __try
    {
        hr = rpc_ACSetCursorProperties(
                    HRTQUEUE(hProxy),
                    (ULONG)hCursor,
                    hRemoteCursor
                    );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = DeppExceptionFilter(GetExceptionCode());
    }

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}

HRESULT
ACDepSendMessage(
    HANDLE hQueue,
    CACTransferBufferV2& tb,
    LPOVERLAPPED /*lpOverlapped*/
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    __try
    {
        OBJECTID* pMessageID = 0;
        if(tb.old.ppMessageID)
        {
            pMessageID = *tb.old.ppMessageID;
        }

        hr = rpc_ACSendMessageEx(HRTQUEUE(hQueue), &tb, pMessageID);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = DeppExceptionFilter(GetExceptionCode());
    }

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}

struct AR_CONTEXT {
    HANDLE hEvent;
    HANDLE hQueue;
    CACTransferBufferV2* ptb;
    LPOVERLAPPED lpOverlapped;
};

DWORD
APIENTRY
DeppAsynchronousReceiverThread(
    PVOID pContext
    )
{
    AR_CONTEXT* par = static_cast<AR_CONTEXT*>(pContext);

    HANDLE hQueue = par->hQueue;
    CACTransferBufferV2 tb = *par->ptb;
    LPOVERLAPPED lpOverlapped = par->lpOverlapped;

    //
    //  initialization completed. Release the dispatcher thread
    //
    SetEvent(par->hEvent);

    HANDLE hThread ;
    //
    // note that the cancel routine add five more minutes to this timeout.
    // The five minutes will be applied if server side die and client side
    // has to cancel the rpc call.
    //
    RegisterRpcCallForCancel( &hThread, tb.old.Receive.RequestTimeout) ;

    HRESULT rc = MQ_ERROR;
    __try
    {
        LPMQWIN95_QHANDLE ph95 = (LPMQWIN95_QHANDLE) hQueue ;
        rc = rpc_ACReceiveMessageEx(ph95->hBind, ph95->hQMContext, &tb);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = DeppExceptionFilter(GetExceptionCode());
    }

    UnregisterRpcCallForCancel( hThread ) ;

    //
    //  The next code can cause exception, if the user release the overlapped
    //  structure; or due to incorrect release order of DLLs in Win95. it may
    //  happen that msvcrt is released before we do freeing the heap, thus
    //  causing the exception on process shut down.
    //
    __try
    {
        lpOverlapped->Internal = rc;
        if(lpOverlapped->hEvent)
        {
            SetEvent(lpOverlapped->hEvent);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
    }

    return rc;
}

HRESULT
ACDepReceiveMessage(
    HANDLE hQueue,
    CACTransferBufferV2& tb,
    LPOVERLAPPED lpOverlapped
    )
{
    if (tb.old.Receive.Asynchronous == FALSE)
    {
        //
        //  Synchronous recieve, no need to create thread
        //
        HRESULT hr ;
        HANDLE hThread ;
        //
        // note that the cancel routine add five more minutes to this wake
        // time.
        //
        RegisterRpcCallForCancel( &hThread, tb.old.Receive.RequestTimeout) ;

        __try
        {
            LPMQWIN95_QHANDLE ph95 = (LPMQWIN95_QHANDLE) hQueue ;
            hr = rpc_ACReceiveMessageEx(ph95->hBind, ph95->hQMContext, &tb);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            hr = DeppExceptionFilter(GetExceptionCode());
        }

        UnregisterRpcCallForCancel( hThread ) ;
        return hr ;
    }

    __try
    {
        //
        //  Asynchronous recieve, init context and create receving thread
        //
        AR_CONTEXT ar = {GetThreadEvent(), hQueue, &tb, lpOverlapped};
        ResetEvent(ar.hEvent);

        if(lpOverlapped->hEvent)
        {
            ResetEvent(lpOverlapped->hEvent);
        }

        HANDLE hThread;
        DWORD dwThreadID;
        hThread = CreateThread(
                    0,
                    0,
                    DeppAsynchronousReceiverThread,
                    &ar,
                    0,
                    &dwThreadID
                    );

        if(hThread == 0)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Wait for thread initalization
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(
                        ar.hEvent,
                        INFINITE
                        );

        ASSERT(dwResult == WAIT_OBJECT_0);
        CloseHandle(hThread);

        return STATUS_PENDING;

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return DeppExceptionFilter(GetExceptionCode());
    }
}

HRESULT
ACDepHandleToFormatName(
    HANDLE hQueue,
    LPWSTR lpwcsFormatName,
    LPDWORD lpdwFormatNameLength
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    __try
    {
        hr = rpc_ACHandleToFormatName(
                    HRTQUEUE(hQueue),
                    min( *lpdwFormatNameLength, ONE_KB),
                    lpwcsFormatName,
                    lpdwFormatNameLength
                    );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = DeppExceptionFilter(GetExceptionCode());
    }

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}

HRESULT
ACDepPurgeQueue(
    HANDLE hQueue,
    BOOL /*fDelete*/
    )
{
    HRESULT hr ;
    HANDLE hThread ;
    RegisterRpcCallForCancel( &hThread, 0) ;

    __try
    {
        hr = rpc_ACPurgeQueue(HRTQUEUE(hQueue));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = DeppExceptionFilter(GetExceptionCode());
    }

    UnregisterRpcCallForCancel( hThread ) ;
    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\qmmgmt_c_.c ===
#pragma warning(push, 3)
#include <qmmgmt_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\acrt.h ===
/*++

Copyright (c) 1995-97 Microsoft Corporation

Module Name:
    acrt.h

Abstract:
    wrapper functions for calling driver or RPC on NT

Author:
    Doron Juster  (DoronJ)  07-Apr-1997   Created

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#ifndef _ACRT_H_
#define _ACRT_H_

#include <acdef.h>

#include <acioctl.h>
#include <acdef.h>

//
// RPC between RT and local QM is used on Win95 and on NT clients.
// The following macro check for this condition.
//

#define IF_USING_RPC  \
   if ((g_fDependentClient) || (g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS))

//
// On Win95 and on NT client, a queue handle which is returned to
// application is a pointer to this structure. The reason we keep the three
// handles is that doing RPC with context handle serialzes the calls. This is
// OK for all calls except MQReceive(). (a pending receive will block all
// future calls with the same handle, so we can't even close the queue).
// So, MQReceive() uses the binding handle and give the QM the context it
// expects as a DWORD.  Rt get this QM context when opening the queue.
//
typedef struct _tagMQWIN95_QHANDLE {
  handle_t hBind ;
  HANDLE   hContext ;
  DWORD    hQMContext ;
} MQWIN95_QHANDLE, *LPMQWIN95_QHANDLE ;



HRESULT
ACDepCloseHandle(
    HANDLE hQueue
    );

HRESULT
ACDepCreateCursor(
    HANDLE hQueue,
    CACCreateLocalCursor& tb
    );

HRESULT
ACDepCloseCursor(
    HANDLE hQueue,
    HACCursor32 hCursor
    );

HRESULT
ACDepSetCursorProperties(
    HANDLE hProxy,
    HACCursor32 hCursor,
    ULONG hRemoteCursor
    );

HRESULT
ACDepSendMessage(
    HANDLE hQueue,
    CACTransferBufferV2& tb,
    LPOVERLAPPED lpOverlapped
    );

HRESULT
ACDepReceiveMessage(
    HANDLE hQueue,
    CACTransferBufferV2& tb,
    LPOVERLAPPED lpOverlapped
    );

HRESULT
ACDepHandleToFormatName(
    HANDLE hQueue,
    LPWSTR lpwcsFormatName,
    LPDWORD lpdwFormatNameLength
    );

HRESULT
ACDepPurgeQueue(
    HANDLE hQueue,
    BOOL fDelete
    );

#define HRTQUEUE(hQueue)  (((LPMQWIN95_QHANDLE)hQueue)->hContext)




#endif // _ACRT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\qmrt_c_.c ===
#pragma warning(push, 3)
#include <qmrt_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\cursor.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    cursor.cpp

Abstract:

    This module contains code involved with Cursor APIs.

Author:

    Erez Haba (erezh) 21-Jan-96
    Doron Juster  16-apr-1996, added MQFreeMemory.
    Doron Juster  30-apr-1996, added support for remote reading.

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include "acrt.h"
#include "rtprpc.h"
#include <acdef.h>

#include "cursor.tmh"

inline
HRESULT
MQpExceptionTranslator(
    HRESULT rc
    )
{
    if(FAILED(rc))
    {
        return rc;
    }

    if(rc == ERROR_INVALID_HANDLE)
    {
        return STATUS_INVALID_HANDLE;
    }

    return  MQ_ERROR_SERVICE_NOT_AVAILABLE;
}



EXTERN_C
HRESULT
APIENTRY
DepCreateCursor(
    IN QUEUEHANDLE hQueue,
    OUT PHANDLE phCursor
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;
    LPTSTR lpRemoteQueueName = NULL;
    HACCursor32 hCursor = 0;
    CCursorInfo* pCursorInfo = 0;

    rc = MQ_OK;

    __try
    {
        __try
        {
            __try
            {
                pCursorInfo = new CCursorInfo;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                return MQ_ERROR_INSUFFICIENT_RESOURCES;
            }

            pCursorInfo->hQueue = hQueue;

            CACCreateLocalCursor cc;

            //
            //  Call AC driver with transfer buffer
            //
            rc = ACDepCreateCursor(hQueue, cc);

            //
            //  save local cursor handle for cleanup
            //
            hCursor = cc.hCursor;

            if(rc == MQ_INFORMATION_REMOTE_OPERATION)
            {
				//
				//  For remote operation 'cc' fields are:
				//      srv_hACQueue - holds the remote queue handle
				//      cli_pQMQueue - holds the local QM queue object
				//
				// create a cursor on remote QM.
				ASSERT(cc.srv_hACQueue);
				ASSERT(cc.cli_pQMQueue);

				INIT_RPC_HANDLE;

				if(tls_hBindRpc == 0)
					return MQ_ERROR_SERVICE_NOT_AVAILABLE;

                // Get name of remote queue from local QM.
				rc = QMGetRemoteQueueName(
                        tls_hBindRpc,
                        cc.cli_pQMQueue,
                        &lpRemoteQueueName
                        );

                if(SUCCEEDED(rc) && lpRemoteQueueName)
                {
                    //
                    // OK, we have a remote name. Now bind to remote machine
                    // and ask it to create a cursor.
                    //
                    DWORD hRCursor = 0;

					//
					// Pass the old TransferBuffer to Create Remote Cursor
					// for MSMQ 1.0 compatibility.
					//
					CACTransferBufferV1 tb;
					memset(&tb, 0, sizeof(CACTransferBufferV1));
					tb.uTransferType = CACTB_CREATECURSOR;

                    //
                    //  BUGBUG: ask doronj why setting rc value; it will not
                    //          help if exception occure
                    //
                    rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
                    DWORD dwProtocol = 0 ;

                    CALL_REMOTE_QM(lpRemoteQueueName, rc,(
                        QMCreateRemoteCursor(
                            hBind,
                            &tb,
                            cc.srv_hACQueue,
                            &hRCursor
                            )
                        ));

                    if(SUCCEEDED(rc))
                    {
                        // set remote cursor handle to local cursor
                        rc = ACDepSetCursorProperties(hQueue, hCursor, hRCursor);
                        ASSERT(SUCCEEDED(rc));
                    }
                }
            }

            if(SUCCEEDED(rc))
            {
                pCursorInfo->hCursor = hCursor;
                *phCursor = pCursorInfo;
                pCursorInfo = 0;
            }
        }
        __finally
        {
            delete pCursorInfo;
            delete[] lpRemoteQueueName ;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc =  MQpExceptionTranslator(GetExceptionCode());
    }

    if(FAILED(rc) && (hCursor != 0))
    {
        ACDepCloseCursor(hQueue, hCursor);
    }

    return rc;
}

EXTERN_C
HRESULT
APIENTRY
DepCloseCursor(
    IN HANDLE hCursor
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    IF_USING_RPC
    {
        if (!tls_hBindRpc)
        {
            INIT_RPC_HANDLE ;
        }

		if(tls_hBindRpc == 0)
			return MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }

    CMQHResult rc;
    __try
    {
        rc = ACDepCloseCursor(
                CI2QH(hCursor),
                CI2CH(hCursor)
                );

        if(SUCCEEDED(rc))
        {
            //
            //  delete the cursor info only when everything is OK. we do not
            //  want to currupt user heap.
            //
            delete hCursor;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //
        //  The cursor structure is invalid
        //
        return MQ_ERROR_INVALID_HANDLE;
    }

    return rc;
}


EXTERN_C
void
APIENTRY
DepFreeMemory(
    IN  PVOID pvMemory
    )
{
	ASSERT(g_fDependentClient);

	if(FAILED(DeppOneTimeInit()))
		return;

	delete[] pvMemory;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\message.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    message.cpp

Abstract:

    This module contains code involved with Message APIs.

Author:

    Erez Haba (erezh) 24-Dec-95

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include "acrt.h"
#include <_secutil.h>
#include "mqutil.h"
#include <mqcrypt.h>
#include "rtsecutl.h"
#include "rtprpc.h"
#include "objbase.h"
#define _MTX_NOFORCE_LIBS
#include "comsvcs.h"
#include "TXDTC.H"
#include "xactmq.h"
#include <mqsec.h>
#include <ph.h>
#include <autohandle.h>

#include "message.tmh"

extern GUID  g_LicGuid ;
extern GUID  g_guidSupportQmGuid ;

// the following data is used in the async thread which handles async
// MQReceive(). The async thread is created the first time an async
// receive is performed.

#define RXTHREAD_HANDLELISTSIZE  MAXIMUM_WAIT_OBJECTS
// At present (Win32 SDK for Nt3.51) it's 64

static BOOL   s_fTerminate       = FALSE ;
static HANDLE s_hAsyncRxThread   = NULL ;
static DWORD  s_dwRxThreadId     = 0 ;
static HANDLE *s_pRxEventsHList  = NULL ;
static DWORD  s_cRxHandles       = 0 ;
static LONG   s_cRxPendingReq    = 0;
static HANDLE s_hNewAsyncRx      = NULL ;
static HANDLE s_hEndAsyncRx      = NULL ;

//
// Critical Section used to control access to structures used by the 
// async thread.
// It is initialized with the "pre-allocate resource" flag to prevent it
// from failing in EnterCriticalSection(), as one of these invocations
// occurs in a place where it cannot be handled correctly.
//
static CCriticalSection s_AsyncRxCS(0x80000000); //SpinCount.

//
// Critical section used to control initialization of the async thread, on 
// the first MQReceiveMessage() done with a callback function.
//
static CCriticalSection s_InitAsyncRxCS; 

typedef struct _MQRXASYNCDESCRIPTOR {
    QUEUEHANDLE   hSource ;
    DWORD         dwTimeout ;
    DWORD         dwAction ;
    MQMSGPROPS*   pMessageProps ;
    LPOVERLAPPED  lpOverlapped ;
    HANDLE        hCursor ;
    PMQRECEIVECALLBACK fnReceiveCallback ;
    OVERLAPPED    Overlapped ;
} MQRXASYNCDESCRIPTOR, *LPMQRXASYNCDESCRIPTOR ;

static LPMQRXASYNCDESCRIPTOR  *s_lpRxAsynDescList = NULL ;

//
// Serializes calls to DTC
//
extern HANDLE g_hMutexDTC;

extern HRESULT GetMutex();

//---------------------------------------------------------
//
// static DWORD   RTpAsyncRxThread( DWORD dwP )
//
//  Description:
//
//    Thread which handles the async calls to MQReceive().
//
//---------------------------------------------------------

DWORD __stdcall  RTpAsyncRxThread( void *dwP )
{
	for(;;)
	{
		DWORD cEvents = s_cRxHandles;

		DWORD dwObjectIndex = WaitForMultipleObjects(
                                    cEvents,
                                    s_pRxEventsHList,
                                    FALSE, // return on any object
								INFINITE 
								);

      ASSERT(dwObjectIndex < (WAIT_OBJECT_0 + cEvents));

      dwObjectIndex -= WAIT_OBJECT_0 ;

      if (dwObjectIndex == 0)
      {
			//
			// dwObjectIndex == 0: 
			// The first event in the s_pRxEventsHList[] array is a special 
			// event, signaled by an MQReceiveMessage() thread to indicate 
			// that the array has been altered (grown), and we need to intiate
			// a new WaitForMultipleObjects(), or by TerminateRxAsyncThread()
			// to indicate it is time to go down.
         //

         ResetEvent(s_hNewAsyncRx) ;
         if (s_fTerminate)
         {
            // We're closing.
            // CAUTION: don't do any cleanup here. The cleanup is done in
            // "TerminateRxAsyncThread()". I don't know a reliable way
            // to assure that we even reach this point. It all depends on
            // NT scheduling and on whether this dll is implicitly loaded
            // (because of compile-time linking) or is explicitly loaded by
            // LoadLibrary().
            // On the contrary, NT assure us that "TerminateRxAsyncThread()"
            // will always be called from DllMain(PROCESS_DETACH).
            // DoronJ, 16-apr-1996.

            ASSERT(s_hEndAsyncRx) ;
            BOOL fSet = SetEvent(s_hEndAsyncRx) ;
            ASSERT(fSet) ;
			DBG_USED(fSet);

            ExitThread(0) ;
         }

			//
			// new event in array. intiate a new WaitForMultipleObjects().
			// 
			continue;
      }

         LPMQRXASYNCDESCRIPTOR lpDesc = s_lpRxAsynDescList[ dwObjectIndex ] ;
         ASSERT(lpDesc) ;
		ASSERT(s_pRxEventsHList[ dwObjectIndex ] == lpDesc->Overlapped.hEvent);

		CMQHResult hr;
		hr = (HRESULT)DWORD_PTR_TO_DWORD(lpDesc->Overlapped.Internal);

		//
         // Call the application callback.
		//
		lpDesc->fnReceiveCallback(
			hr,
                           lpDesc->hSource,
                           lpDesc->dwTimeout,
                           lpDesc->dwAction,
                           lpDesc->pMessageProps,
                           lpDesc->lpOverlapped,
			lpDesc->hCursor
			);

		// 
		// Remove Handled event from s_pRxEventsHList[] array.
		//

         ResetEvent( s_pRxEventsHList[ dwObjectIndex ] ) ;
         CloseHandle( s_pRxEventsHList[ dwObjectIndex ] ) ;
         delete lpDesc ;

		{
			CS Lock(s_AsyncRxCS);

			//
			// Shrink the handles list and decrement count of pending requests.
			//
			s_cRxHandles--;
			InterlockedDecrement(&s_cRxPendingReq);

			ASSERT(static_cast<DWORD>(s_cRxPendingReq) >= s_cRxHandles);			

			for (DWORD index = dwObjectIndex; index < s_cRxHandles; index++)
			{
				s_pRxEventsHList[ index ] = s_pRxEventsHList[ index + 1 ];
				s_lpRxAsynDescList[ index ] = s_lpRxAsynDescList[ index + 1 ];
			}
      }
   }

   dwP ;
   return 0 ;
}


//---------------------------------------------------------
//
//  static HRESULT InitRxAsyncThread()
//
//  Description:
//
//    Create the MQReceive() async thread and initialize the
//    relevant data structures.
//
//---------------------------------------------------------

static HRESULT InitRxAsyncThread()
{
    try
    {
        // Create the sync event between this api and the thread.
        // This api sets this event when it inserts a new event in
        // the events handles list. This causes the thread to exit
        // WaitForMultpleObjects and call it again with the updated
        // handles list.

        ASSERT(!s_hNewAsyncRx) ;
        s_hNewAsyncRx = CreateEvent( NULL,
                                     TRUE,  // manual reset
                                     FALSE, // initially not signalled
                                     NULL ) ;
        if (!s_hNewAsyncRx)
        {
            throw bad_alloc();
        }

        //
        // Create the "end" event which is used ONLY to terminate and
        // cleanup the thread.
        //
        ASSERT(!s_hEndAsyncRx) ;
        s_hEndAsyncRx = CreateEvent(NULL,
                                    TRUE,  // manual reset
                                    FALSE, // initially not signalled
                                    NULL ) ;
        if (!s_hEndAsyncRx)
        {
            throw bad_alloc();
        }

        // Create the events list. MQReceive() inserts new events handle
        // in this list. The async thread use this list when calling
        // WaitForMultipleObjects.

        s_pRxEventsHList = new HANDLE[ RXTHREAD_HANDLELISTSIZE ] ;
        s_pRxEventsHList[0] = s_hNewAsyncRx ;
        s_cRxHandles = 1 ;
        s_cRxPendingReq = 1 ;

        s_lpRxAsynDescList = new LPMQRXASYNCDESCRIPTOR[RXTHREAD_HANDLELISTSIZE];

        // Now create the thread. Make this call the last one in the
        // initialization, so if it fails the cleanup is simpler.

        s_hAsyncRxThread = CreateThread( NULL,
                                         0,       // stack size
                                         RTpAsyncRxThread,
                                         0,
                                         0,       // creation flag
                                         &s_dwRxThreadId ) ;
        if (!s_hAsyncRxThread)
        {
            throw bad_alloc();
        }

        return MQ_OK;
    }
    catch(const bad_alloc&)
    {
        ASSERT(!s_hAsyncRxThread) ;

        if (s_hNewAsyncRx)
        {
            CloseHandle(s_hNewAsyncRx) ;
            s_hNewAsyncRx = NULL ;
        }

        delete[] s_pRxEventsHList ;
        s_pRxEventsHList = NULL ;

        delete s_lpRxAsynDescList ;
        s_lpRxAsynDescList = NULL ;

        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }
}

//---------------------------------------------------------
//
//  void  TerminateRxAsyncThread() ;
//
//  called from DllMain(PROCESS_DETACH) to cleanup the async thread.
//
//---------------------------------------------------------

#define SUSPEND_ERROR  0xffffffff

void  TerminateRxAsyncThread()
{
   if (s_hAsyncRxThread)
   {
      s_fTerminate = TRUE ;

      SetLastError(0) ;
      DWORD dwS = SuspendThread(s_hAsyncRxThread) ;
      if (dwS == SUSPEND_ERROR)
      {
         //
         // This may happen if application is linked with mqrt. when it
         // exit (the process itself exit), the thread does not run and
         // does not exist anymore. The Suspend call will success if
         // application loaded mqrt by LoadLibrary.
         //
         ASSERT(GetLastError() != 0) ;
      }
      else
      {
         DWORD dwR = ResumeThread(s_hAsyncRxThread) ;
         ASSERT(dwR != SUSPEND_ERROR) ;
		 DBG_USED(dwR);
      }

      //
      // Tell the async thread that we're closing.
      //
      BOOL fSet = SetEvent(s_hNewAsyncRx) ;
      ASSERT(fSet) ;
      DBG_USED(fSet);

      if (dwS != SUSPEND_ERROR)
      {
         //
         //  Wait (30 seconds) for async thread to terminate.
         //
         ASSERT(s_hEndAsyncRx) ;
         DWORD dwResult = WaitForSingleObject( s_hEndAsyncRx,
                                               30000 );
         ASSERT(dwResult == WAIT_OBJECT_0);
		 DBG_USED(dwResult);
      }

      //
      // cleanup the async thread global data.
      //
	  {
		  CS Lock(s_AsyncRxCS);

		  CloseHandle(s_hNewAsyncRx);
		  
		  for (DWORD index = 1; index < s_cRxHandles; index++)
      {
         ResetEvent( s_pRxEventsHList[ index ] ) ;
         CloseHandle( s_pRxEventsHList[ index ] ) ;
         LPMQRXASYNCDESCRIPTOR lpDesc = s_lpRxAsynDescList[ index ] ;
         delete lpDesc ;
      }

      delete[] s_pRxEventsHList ;
		  s_pRxEventsHList = NULL;
      delete[] s_lpRxAsynDescList ;
		  s_lpRxAsynDescList = NULL;
	  }

      //
      // finally, close the thread handle.
      //
      CloseHandle(s_hAsyncRxThread) ;
   }
}

//---------------------------------------------------------
//
//  GetThreadEvent(...)
//
//  Description:
//
//      Get RT event for this thread. Get it either from
//      The TLS or create a new one.
//
//  Return Value:
//
//      The event handle
//
//---------------------------------------------------------

HANDLE GetThreadEvent()
{
    HANDLE hEvent = TlsGetValue(g_dwThreadEventIndex);
    if (hEvent == 0)
    {
        //
        //  Event was never allocated for this thread.
        //
        hEvent = CreateEvent(0, TRUE, TRUE, 0);

        //
        //  Set the Event first bit to disable completion port posting
        //
        hEvent = (HANDLE)((DWORD_PTR)hEvent | (DWORD_PTR)0x1);

        BOOL fSuccess = TlsSetValue(g_dwThreadEventIndex, hEvent);
        ASSERT(fSuccess);
		DBG_USED(fSuccess);
    }
    return hEvent;
}

//---------------------------------------------------------
//
//  _ShouldSignMessage
//
//  Description:
//
//      Determines whether the message should be signed.
//
//  Return Value:
//
//      TRUE, if the message should be signed.
//
//---------------------------------------------------------

static
BOOL
_ShouldSignMessage(
    IN QUEUEHANDLE /*hQueue*/,
    IN CACTransferBufferV2 *tb,
    OUT ULONG            *pulAuthLevel )
{
    BOOL bRet;

    switch(tb->old.ulAuthLevel)
    {
    case MQMSG_AUTH_LEVEL_ALWAYS:
    {
        bRet = TRUE;

        //
        // See if registry is configured to compute only one signature.
        //
        static DWORD s_dwAuthnLevel =  DEFAULT_SEND_MSG_AUTHN ;
        static BOOL  s_fAuthnAlreadyRead = FALSE ;

        if (!s_fAuthnAlreadyRead)
        {
            DWORD dwSize = sizeof(DWORD) ;
            DWORD dwType = REG_DWORD ;

            LONG res = GetFalconKeyValue(
                                  SEND_MSG_AUTHN_REGNAME,
                                 &dwType,
                                 &s_dwAuthnLevel,
                                 &dwSize ) ;
            if (res != ERROR_SUCCESS)
            {
                s_dwAuthnLevel =  DEFAULT_SEND_MSG_AUTHN ;
            }
            else if ((s_dwAuthnLevel != MQMSG_AUTH_LEVEL_MSMQ10) &&
                     (s_dwAuthnLevel != MQMSG_AUTH_LEVEL_MSMQ20) &&
                     (s_dwAuthnLevel != MQMSG_AUTH_LEVEL_ALWAYS))
            {
                //
                // Wrong value in registry. Use the default, to have
                // predictable results.
                //
                s_dwAuthnLevel =  DEFAULT_SEND_MSG_AUTHN ;
            }
            s_fAuthnAlreadyRead = TRUE ;

            //
            // This should be the default.
            // by default, authenticate only with old style, to prevent
            // performance hit and to be backward  compatible.
            //
            ASSERT(DEFAULT_SEND_MSG_AUTHN == MQMSG_AUTH_LEVEL_MSMQ10) ;
        }
        *pulAuthLevel = s_dwAuthnLevel ;

        break;
    }

    case MQMSG_AUTH_LEVEL_MSMQ10:
    case MQMSG_AUTH_LEVEL_MSMQ20:
        bRet = TRUE;
        *pulAuthLevel = tb->old.ulAuthLevel ;
        tb->old.ulAuthLevel =  MQMSG_AUTH_LEVEL_ALWAYS ;
        break;

    case MQMSG_AUTH_LEVEL_NONE:
        bRet = FALSE;
        break;

    default:
        ASSERT(0);
        bRet = FALSE;
    }

    return(bRet);
}

//+-------------------------------------
//
//  HRESULT  _BeginToSignMessage()
//
//+-------------------------------------

STATIC HRESULT  _BeginToSignMessage( IN CACTransferBufferV2  *tb,
                                     IN PMQSECURITY_CONTEXT pSecCtx,
                                     OUT HCRYPTHASH        *phHash )
{
    HRESULT hr;
    DWORD   dwErr ;

    ASSERT(pSecCtx);

    if (!pSecCtx->hProv)
    {
        //
        // Import the private key into process hive.
        //
        hr = RTpImportPrivateKey( pSecCtx ) ;
        if (FAILED(hr))
        {
            return hr ;
        }
    }
    ASSERT(pSecCtx->hProv) ;

    //
    // Create the hash object.
    //
    if (!CryptCreateHash(
            pSecCtx->hProv,
            *tb->old.pulHashAlg,
            0,
            0,
            phHash))
    {
        dwErr = GetLastError() ;
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "RT: _BeginToSignMessage(), fail at CryptCreateHash(), err- %lxh"), dwErr)) ;

        return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
    }

    return MQ_OK ;
}

//-------------------------------------------------------------------------
//
//  HRESULT SignMessage()
//
//  Description:
//
//      Signs the messag body. compute the hash, and sign it with private
//      key. This add a signature section to the packet
//
//  Return Value:
//
//      MQ_OK, if successful, else error code.
//
//-------------------------------------------------------------------------

static
HRESULT
SignMessage( IN CACTransferBufferV2   *tb,
             IN PMQSECURITY_CONTEXT  pSecCtx)
{
    HCRYPTHASH  hHash = NULL ;

    HRESULT hr =  _BeginToSignMessage( tb,
                                       pSecCtx,
                                      &hHash ) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    CHCryptHash hAutoRelHash = hHash ;

    hr = HashMessageProperties(
            hHash,
            tb->old.ppCorrelationID ? *tb->old.ppCorrelationID : NULL,
            PROPID_M_CORRELATIONID_SIZE,
            tb->old.pApplicationTag ? *tb->old.pApplicationTag : DEFAULT_M_APPSPECIFIC,
            tb->old.ppBody ? *tb->old.ppBody : NULL,
            tb->old.ulBodyBufferSizeInBytes,
            tb->old.ppTitle ? *tb->old.ppTitle : NULL,
            tb->old.ulTitleBufferSizeInWCHARs * sizeof(WCHAR),
            tb->old.Send.pResponseQueueFormat,
            tb->old.Send.pAdminQueueFormat
			);
    if (FAILED(hr))
    {
        return(hr);
    }

    if (!CryptSignHashA(        // Sign the mesage.
            hHash,
            pSecCtx->bInternalCert ? AT_SIGNATURE : AT_KEYEXCHANGE,
            NULL,
            0,
            *(tb->old.ppSignature),
            &tb->old.ulSignatureSize))
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "RT: SignMessage(), fail at CryptSignHash(), err- %lxh"), GetLastError())) ;

        return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
    }

    //
    // On receiver side, only signature size indicate that message was
    // signed by sender. Verify the size is indeed non-zero
    //
    if (tb->old.ulSignatureSize == 0)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "RT: SignMessage(), CryptSignHash return with zero signature size"))) ;

        ASSERT(tb->old.ulSignatureSize != 0) ;
        return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
    }

    return(MQ_OK);
}

//---------------------------------------------------------
//
//  _SignMessageEx
//
//  Description:
//
//    Signs properties that were not signed in msmq1.0
//    Properties we sign here:
//    - target queue
//    - source qm guid
//
//  Return Value:
//
//      MQ_OK, if successful, else error code.
//
//---------------------------------------------------------

STATIC HRESULT _SignMessageEx( IN QUEUEHANDLE             hQueue,
                               IN OUT CACTransferBufferV2  *tb,
                               IN PMQSECURITY_CONTEXT     pSecCtx,
                               OUT BYTE                  *pSignBufIn,
                               OUT DWORD                 *pdwSignSize )
{
    //
    // Retrieve guid of local qm.
    //
    GUID *pGuidQM = NULL ;

    if (g_fDependentClient)
    {
        //
        // We can generate the "ex" signature only if supporting server
        // is win2k (rtm) and it can give us its QM guid.
        // Otherwise, return.
        //
        if (g_guidSupportQmGuid == GUID_NULL)
        {
            //
            // guid of supporting server is not available.
            //
            *pdwSignSize = 0 ;
            return MQ_OK ;
        }
        pGuidQM = &g_guidSupportQmGuid ;
    }
    else
    {
        pGuidQM = &g_LicGuid ;
    }

    //
    // First retrieve format name of the queue, from driver.
    //
    #define TARGET_NAME_SIZE  512
    WCHAR wszTargetFormatName[ TARGET_NAME_SIZE ] ;
    DWORD dwTargetFormatNameLength = TARGET_NAME_SIZE ;
    WCHAR *pwszTargetFormatName = wszTargetFormatName ;
    P<WCHAR>  pwszClean = NULL ;

    HRESULT hr = ACDepHandleToFormatName( hQueue,
                                       wszTargetFormatName,
                                      &dwTargetFormatNameLength ) ;
    if (hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
    {
        pwszClean = new WCHAR[ dwTargetFormatNameLength ] ;
        pwszTargetFormatName = pwszClean.get() ;

        hr = ACDepHandleToFormatName( hQueue,
                                   pwszTargetFormatName,
                                  &dwTargetFormatNameLength ) ;
        ASSERT(hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL) ;
    }
    #undef TARGET_NAME_SIZE

    if (FAILED(hr))
    {
        return hr ;
    }
    dwTargetFormatNameLength =
                      (1 + wcslen(pwszTargetFormatName)) * sizeof(WCHAR) ;
    //
    // Prepare the necessray structers to be included in packet.
    //
    struct _SecuritySectionEx *pSecEx =
                                (struct _SecuritySectionEx *) pSignBufIn ;
    struct _SecuritySubSectionEx *pSubSecEx =
                  (struct _SecuritySubSectionEx *) (&(pSecEx->aData[0])) ;

    ULONG  ulTestLen = 0 ;
    USHORT ulTestSections = 0 ;

#ifdef _DEBUG
{
	BYTE* pSubPtr = NULL;

    //
    // Simulate subsection that precede the signature. To verify that
    // present code is forward compatible if we'll want to add new
    // subsections in future releases.
    //
    static DWORD s_dwPrefixCount = 0 ;
    static BOOL  s_fPreAlreadyRead = FALSE ;

    if (!s_fPreAlreadyRead)
    {
        DWORD dwSize = sizeof(DWORD) ;
        DWORD dwType = REG_DWORD ;

        LONG res = GetFalconKeyValue(
                                  PREFIX_SUB_SECTIONS_REGNAME,
                                 &dwType,
                                 &s_dwPrefixCount,
                                 &dwSize ) ;
        if (res != ERROR_SUCCESS)
        {
            s_dwPrefixCount = 0 ;
        }
        s_fPreAlreadyRead = TRUE ;
    }

    for ( USHORT j = 0 ; j < (USHORT) s_dwPrefixCount ; j++ )
    {
        ulTestSections++ ;
        pSubSecEx->eType = e_SecInfo_Test ;
        pSubSecEx->_u.wFlags = 0 ;
        pSubSecEx->wSubSectionLen = (USHORT) ( (j * 7) + 1 +
                                    sizeof(struct _SecuritySubSectionEx)) ;

        ulTestLen += ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen) ;
        pSubPtr = ((BYTE*) pSubSecEx) + ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen) ;
        pSubSecEx = (struct _SecuritySubSectionEx *) pSubPtr ;
    }
}
#endif

    pSubSecEx->eType = e_SecInfo_User_Signature_ex ;
    pSubSecEx->_u.wFlags = 0 ;
    pSubSecEx->_u._UserSigEx.m_bfTargetQueue = 1 ;
    pSubSecEx->_u._UserSigEx.m_bfSourceQMGuid = 1 ;
    pSubSecEx->_u._UserSigEx.m_bfUserFlags = 1 ;
    pSubSecEx->_u._UserSigEx.m_bfConnectorType = 1 ;

    BYTE *pSignBuf = (BYTE*) &(pSubSecEx->aData[0]) ;

    //
    // start signing (create the hash object).
    //
    HCRYPTHASH hHash;

    hr =  _BeginToSignMessage( tb,
                               pSecCtx,
                              &hHash ) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    CHCryptHash hAutoRelHash = hHash ;

    hr = HashMessageProperties(
            hHash,
            tb->old.ppCorrelationID ? *tb->old.ppCorrelationID : NULL,
            PROPID_M_CORRELATIONID_SIZE,
            tb->old.pApplicationTag ? *tb->old.pApplicationTag : DEFAULT_M_APPSPECIFIC,
            tb->old.ppBody ? *tb->old.ppBody : NULL,
            tb->old.ulBodyBufferSizeInBytes,
            tb->old.ppTitle ? *tb->old.ppTitle : NULL,
            tb->old.ulTitleBufferSizeInWCHARs * sizeof(WCHAR),
            tb->old.Send.pResponseQueueFormat,
            tb->old.Send.pAdminQueueFormat
			);
    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Prepare structure of flags.
    //
    struct _MsgFlags sUserFlags ;
    memset(&sUserFlags, 0, sizeof(sUserFlags)) ;

    sUserFlags.bDelivery = DEFAULT_M_DELIVERY;
    sUserFlags.bPriority = DEFAULT_M_PRIORITY ;
    sUserFlags.bAuditing = DEFAULT_M_JOURNAL ;
    sUserFlags.bAck      = DEFAULT_M_ACKNOWLEDGE ;
    sUserFlags.usClass   = MQMSG_CLASS_NORMAL ;

    if (tb->old.pDelivery)
    {
        sUserFlags.bDelivery = *(tb->old.pDelivery) ;
    }
    if (tb->old.pPriority)
    {
        sUserFlags.bPriority = *(tb->old.pPriority) ;
    }
    if (tb->old.pAuditing)
    {
        sUserFlags.bAuditing = *(tb->old.pAuditing) ;
    }
    if (tb->old.pAcknowledge)
    {
        sUserFlags.bAck      = *(tb->old.pAcknowledge) ;
    }
    if (tb->old.pClass)
    {
        sUserFlags.usClass   = *(tb->old.pClass) ;
    }
    if (tb->old.pulBodyType)
    {
        sUserFlags.ulBodyType = *(tb->old.pulBodyType) ;
    }

    GUID guidConnector = GUID_NULL ;
    const GUID *pConnectorGuid = &guidConnector ;
    if (tb->old.ppConnectorType)
    {
        pConnectorGuid = *(tb->old.ppConnectorType) ;
    }

    //
    // Prepare array of properties to hash.
    // (_MsgHashData already include one property).
    //
    DWORD dwStructSize = sizeof(struct _MsgHashData) +
                            (3 * sizeof(struct _MsgPropEntry)) ;
    P<struct _MsgHashData> pHashData =
                        (struct _MsgHashData *) new BYTE[ dwStructSize ] ;

    pHashData->cEntries = 4 ;
    (pHashData->aEntries[0]).dwSize = dwTargetFormatNameLength ;
    (pHashData->aEntries[0]).pData = (const BYTE*) pwszTargetFormatName ;
    (pHashData->aEntries[1]).dwSize = sizeof(GUID) ;
    (pHashData->aEntries[1]).pData = (const BYTE*) pGuidQM ;
    (pHashData->aEntries[2]).dwSize = sizeof(sUserFlags) ;
    (pHashData->aEntries[2]).pData = (const BYTE*) &sUserFlags ;
    (pHashData->aEntries[3]).dwSize = sizeof(GUID) ;
    (pHashData->aEntries[3]).pData = (const BYTE*) pConnectorGuid ;
    ASSERT(pGuidQM) ;

    hr = MQSigHashMessageProperties( hHash, pHashData.get() ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    //
    // sign the has with private key.
    //
    if (!CryptSignHashA(
            hHash,
            pSecCtx->bInternalCert ? AT_SIGNATURE : AT_KEYEXCHANGE,
            NULL,
            0,
            pSignBuf,
            pdwSignSize ))
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "_SignMessageEx(), fail at CryptSignHash(), err- %lxh"), GetLastError())) ;

        return MQ_ERROR_CANNOT_SIGN_DATA_EX ;
    }

    //
    // On receiver side, only signature size indicate that message was
    // signed by sender. Verify the size is indeed non-zero
    //
    if (*pdwSignSize == 0)
    {
        DBGMSG((DBGMOD_SECURITY, DBGLVL_ERROR, _TEXT(
          "_SignMessageEx(), CryptSignHash return with zero signature size"))) ;

        ASSERT(*pdwSignSize != 0) ;
        return MQ_ERROR_CANNOT_SIGN_DATA_EX ;
    }

    pSubSecEx->wSubSectionLen = (USHORT)
                    (sizeof(struct _SecuritySubSectionEx) + *pdwSignSize) ;
    ULONG ulSignExLen = ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen) ;

#ifdef _DEBUG
{
    //
    // Simulate subsection that succeed the signature. To verify that
    // present code is forward compatible if we'll want to add new
    // subsections in future releases.
    //
    static DWORD s_dwPostfixCount = 0 ;
    static BOOL  s_fPostAlreadyRead = FALSE ;
	BYTE* pSubPtr = NULL;

    if (!s_fPostAlreadyRead)
    {
        DWORD dwSize = sizeof(DWORD) ;
        DWORD dwType = REG_DWORD ;

        LONG res = GetFalconKeyValue(
                                  POSTFIX_SUB_SECTIONS_REGNAME,
                                 &dwType,
                                 &s_dwPostfixCount,
                                 &dwSize ) ;
        if (res != ERROR_SUCCESS)
        {
            s_dwPostfixCount = 0 ;
        }
        s_fPostAlreadyRead = TRUE ;
    }

    pSubPtr = ((BYTE*) pSubSecEx) + ulSignExLen ;

    for ( USHORT j = 0 ; j < (USHORT) s_dwPostfixCount ; j++ )
    {
        ulTestSections++ ;
        pSubSecEx = (struct _SecuritySubSectionEx *) pSubPtr ;
        pSubSecEx->eType = e_SecInfo_Test ;
        pSubSecEx->_u.wFlags = 0 ;
        pSubSecEx->wSubSectionLen = (USHORT) ( (j * 11) + 1 +
                                   sizeof(struct _SecuritySubSectionEx)) ;

        ulTestLen += ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen) ;
        pSubPtr = ((BYTE*) pSubSecEx) + ALIGNUP4_ULONG(pSubSecEx->wSubSectionLen) ;
    }
}
#endif

    pSecEx->cSubSectionCount = (USHORT) (1 + ulTestSections) ;
    pSecEx->wSectionLen = (USHORT) ( sizeof(struct _SecuritySectionEx)   +
                                     ulSignExLen                         +
                                     ulTestLen ) ;

    *pdwSignSize = pSecEx->wSectionLen ;
    return MQ_OK ;
}

//+-------------------------------------------------------
//
//  BOOL  ShouldEncryptMessage()
//
//  Return TRUE, if the message should be encrypted.
//
//+-------------------------------------------------------

static
BOOL
ShouldEncryptMessage( IN CACTransferBufferV2  *tb,
                      OUT enum enumProvider *peProvider )
{
    BOOL bRet = FALSE ;

    if (!tb->old.ulBodyBufferSizeInBytes)
    {
        //
        // No message body, nothing to encrypt.
        //
        return(FALSE);
    }

    switch (*tb->old.pulPrivLevel)
    {
    case MQMSG_PRIV_LEVEL_NONE:
        bRet = FALSE;
        break;

    case MQMSG_PRIV_LEVEL_BODY_BASE:
        *peProvider = eBaseProvider ;
        bRet = TRUE;
        break;

    case MQMSG_PRIV_LEVEL_BODY_ENHANCED:
        *peProvider = eEnhancedProvider ;
        bRet = TRUE;
        break;
    }

    return(bRet);
}

//=--------------------------------------------------------------------------=
// HELPER: GetCurrentViperTransaction
//
// Gets current COM+ transaction if there is one...
//
// CoGetObjectContext is exported by OLE32.dll
// IObjectContextInfo is defined in the latest COM+ SDK (part of the platform SDK)
//=--------------------------------------------------------------------------=
static ITransaction *GetCurrentViperTransaction(void)
{
    ITransaction *pTransaction = NULL;
    IObjectContextInfo *pInfo  = NULL;

    HRESULT hr = CoGetObjectContext(IID_IObjectContextInfo, (void **)&pInfo);
    if (SUCCEEDED(hr) && pInfo)
    {
    	hr = pInfo -> GetTransaction((IUnknown **)&pTransaction);
	    pInfo -> Release();
        if (FAILED(hr))
        {
            pTransaction = NULL;
        }
    }

    return pTransaction;
}

//=--------------------------------------------------------------------------=
// HELPER: GetCurrentXATransaction
// Gets current XA transaction if there is one...
//=--------------------------------------------------------------------------=
static ITransaction *GetCurrentXATransaction(void)
{
    IXATransLookup *pXALookup = NULL;
    HRESULT         hr = MQ_OK;
    IUnknown       *punkDtc = NULL;
    ITransaction   *pTrans;

    __try
    {
        GetMutex();  // Isolate export creation from others
        hr = XactGetDTC(&punkDtc, NULL, NULL);
    }
    __finally

    {
        ReleaseMutex(g_hMutexDTC);
    }

    if (FAILED(hr) || punkDtc==NULL)
    {
        return NULL;
    }

    // Get the DTC  ITransactionImportWhereabouts interface
    hr = punkDtc->QueryInterface (IID_IXATransLookup, (void **)(&pXALookup));
    punkDtc->Release();
    if (FAILED(hr))
    {
        return NULL;
    }
    ASSERT(pXALookup);

    hr = pXALookup->Lookup(&pTrans);
    pXALookup->Release();
    if (FAILED(hr))
    {
        return NULL;
    }

    return pTrans;
}

//+----------------------------------------------------------------------
//
// Helper code to computer size (in bytes) of provider name in packet.
//
//+----------------------------------------------------------------------

inline ULONG  OldComputeAuthProvNameSize( const IN CACTransferBufferV2  *ptb )
{
    ULONG ulSize = 0 ;

    if ( (ptb->old.ulSignatureSize != 0) && (!(ptb->old.fDefaultProvider)) )
    {
        ulSize = sizeof(ULONG) +
                 ((wcslen(*(ptb->old.ppwcsProvName)) + 1) * sizeof(WCHAR)) ;
    }

    return ulSize ;
}
//---------------------------------------------------------
//
//  DepSendMessage(...)
//
//  Description:
//
//      Falcon API.
//      Send a message to a queue
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
DepSendMessage(
    IN QUEUEHANDLE  hQueue,
    IN MQMSGPROPS*  pmp,
    IN ITransaction *pTransaction
)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    BYTE* pUserSid;
    BYTE* pUserCert;
    WCHAR* pProvName;

    HRESULT hr ;
    CMQHResult rc, rc1;
    LPWSTR pwcsResponseStringToFree = NULL;
    LPWSTR pwcsAdminStringToFree = NULL;
    XACTUOW Uow;
    PMQSECURITY_CONTEXT pSecCtx = NULL;
    PMQSECURITY_CONTEXT pTmpSecCtx = NULL;
    BOOL fTransactionGenerated = FALSE;

    rc = MQ_OK;
    rc1 = MQ_OK;

    __try
    {
        __try
        {
            CACTransferBufferV2 tb;
		    memset(&tb, 0, sizeof(CACTransferBufferV2));
			tb.old.uTransferType = CACTB_SEND;

            QUEUE_FORMAT ResponseQueueFormat;
            QUEUE_FORMAT AdminQueueFormat;
            BOOL         fSingleTransaction = FALSE;

            tb.old.Send.pResponseQueueFormat = &ResponseQueueFormat;
            tb.old.Send.pAdminQueueFormat = &AdminQueueFormat;

            //
            // Set defaults.
            //
            ULONG ulDefHashAlg = PROPID_M_DEFUALT_HASH_ALG;
            ULONG ulDefEncryptAlg = PROPID_M_DEFUALT_ENCRYPT_ALG;
            ULONG ulDefPrivLevel = DEFAULT_M_PRIV_LEVEL;
            ULONG ulDefSenderIdType = DEFAULT_M_SENDERID_TYPE;
            ULONG ulSenderIdTypeNone = MQMSG_SENDERID_TYPE_NONE;

            tb.old.pulHashAlg = &ulDefHashAlg;
            tb.old.pulPrivLevel = &ulDefPrivLevel;
            tb.old.pulEncryptAlg = &ulDefEncryptAlg;
            tb.old.pulSenderIDType = &ulDefSenderIdType;
            tb.old.fDefaultProvider = TRUE;
            tb.old.ulAuthLevel = DEFAULT_M_AUTH_LEVEL;

            //
            //  Parse message properties
            //
            rc1 = RTpParseMessageProperties(
                    SEND_PARSE,
                    &tb,
                    pmp->cProp,
                    pmp->aPropID,
                    pmp->aPropVar,
                    pmp->aStatus,
                    &pSecCtx,
                    &pwcsResponseStringToFree,
                    &pwcsAdminStringToFree);

            if(FAILED(rc1))
            {
                return(rc1);
            }

            //
            // Look for Viper transaction if any
            //
            if (pTransaction == MQ_MTS_TRANSACTION)
            {
                pTransaction = GetCurrentViperTransaction();
                if (pTransaction != NULL)
                {
                    fTransactionGenerated = TRUE;
                }
            }
            else if (pTransaction == MQ_XA_TRANSACTION)
            {
                pTransaction = GetCurrentXATransaction();
                if (pTransaction != NULL)
                {
                    fTransactionGenerated = TRUE;
                }
            }
            else if (pTransaction == MQ_SINGLE_MESSAGE)
            {
                hr = DepBeginTransaction(&pTransaction);
                if(FAILED(hr))
                {
                    rc = hr;
                    __leave;
                }

                fSingleTransaction    = TRUE;
                fTransactionGenerated = TRUE;
            }

            //
            //Enlist QM in the transaction (with caching);
            //
            if (pTransaction)
            {
                hr = RTpProvideTransactionEnlist(pTransaction, &Uow);
                tb.old.pUow = &Uow;

                if(FAILED(hr))
                {
                    rc = MQ_ERROR_TRANSACTION_ENLIST;
                    __leave;
                }
            }

            // Change values for the transaction case
            static UCHAR Delivery;
            static UCHAR Priority;

            if (pTransaction)
            {
                Delivery = MQMSG_DELIVERY_RECOVERABLE;
                Priority = 0;

                tb.old.pDelivery = &Delivery;
                tb.old.pPriority = &Priority;
            }

            //
            // Treat security
            //
            if (!g_pSecCntx)
            {
                //
                //  It might not be initialized if the queue was
                //  not opened for send;
                //
                InitSecurityContext();
            }

            BYTE abMessageSignature[ MAX_MESSAGE_SIGNATURE_SIZE_EX ];
            BYTE* pabMessageSignature = abMessageSignature;
            ULONG ulProvNameSizeAll = 0 ;
            ULONG ulAuthLevel = 0 ;

            if (tb.old.ppSignature)
            {
                if (!pSecCtx && !tb.old.ppSenderCert)
                {
                    return MQ_ERROR_INSUFFICIENT_PROPERTIES;
                }
                if (!tb.old.ppSenderCert)
                {
                    //
                    // We have a security context and no certificate. We
                    // take the certificate from the security context.
                    //
					pUserCert = pSecCtx->pUserCert.get();
                    tb.old.ppSenderCert = &pUserCert;
                    tb.old.ulSenderCertLen = pSecCtx->dwUserCertLen;
                }

                if (tb.old.ppwcsProvName)
                {
                    ASSERT(tb.old.pulProvType);
                    tb.old.fDefaultProvider = FALSE;
                }
            }
            else if (_ShouldSignMessage(hQueue, &tb, &ulAuthLevel))
            {
                BOOL bShouldGetCertInfo = TRUE;

                if (!pSecCtx)
                {
                    //
                    // Security context NOT provided by caller, in a
                    // message property.
                    //
                    if (!tb.old.ppSenderCert)
                    {
                        //
                        // Caller also did not provide a certificate in the
                        // message properties array. In this case we take the
                        // cached security context of the process.
                        //
                        if (!g_pSecCntx->pUserCert.get())
                        {
                            //
                            // The process does not have an internal
                            // certificate, there is nothing that we can do
                            // but fail.
                            //
                            return(MQ_ERROR_NO_INTERNAL_USER_CERT);
                        }
                        pUserCert = g_pSecCntx->pUserCert.get();
                        tb.old.ppSenderCert = &pUserCert;
                        tb.old.ulSenderCertLen = g_pSecCntx->dwUserCertLen;
                        pSecCtx = g_pSecCntx;
                        bShouldGetCertInfo = FALSE;
                    }
                }
                else
                {
                    if (!tb.old.ppSenderCert)
                    {
                        //
                        // Caller provided a security context, but not a
                        // certificate. We take the certificate from the
                        // security context.
                        //
                        pUserCert = pSecCtx->pUserCert.get();
                        tb.old.ppSenderCert = &pUserCert;
                        tb.old.ulSenderCertLen = pSecCtx->dwUserCertLen;
                        bShouldGetCertInfo = FALSE;
                    }
                    else
                    {
                        //
                        // We have a security context and a certificate in
                        // PROPID_M_USER_CERT. In this case, we should use
                        // the certificate in PROPID_M_USER_CERT. We can use
                        // the cashed certificate information in the security
                        // context, if the certificate in the security context
                        // is the same as in PROPID_M_USER_CERT.
                        //
                        bShouldGetCertInfo =
                            (pSecCtx->dwUserCertLen != tb.old.ulSenderCertLen) ||
                            (memcmp(
                                pSecCtx->pUserCert.get(),
                                *tb.old.ppSenderCert,
                                tb.old.ulSenderCertLen) != 0);
                    }
                }

                if (bShouldGetCertInfo)
                {
                    //
                    // Caller provided a certificate, but not a security
                    // context.  Get all the information for the certificate.
                    // We put the certificate information in a temporary
                    // security context.
                    //
                    ASSERT(tb.old.ppSenderCert);

                    pTmpSecCtx = AllocSecurityContext();

                    hr = GetCertInfo(
                             false,
                             pTmpSecCtx->fLocalSystem,
                            tb.old.ppSenderCert,
                            &tb.old.ulSenderCertLen,
                            &pTmpSecCtx->hProv,
                            &pTmpSecCtx->wszProvName,
                            &pTmpSecCtx->dwProvType,
                            &pTmpSecCtx->bDefProv,
                            &pTmpSecCtx->bInternalCert);

                    //
                    // The caller can not provide the internal certificate as
                    // a message property, only his own externel certificate.
                    // ASSERT this condition.
                    //
                    ASSERT(!(pTmpSecCtx->bInternalCert)) ;

                    if (FAILED(hr))
                    {
                        return(hr);
                    }

                    if (pSecCtx)
                    {
                        //
                        // If we got the certificate from PROPID_M_USER_CERT,
                        // but we have also a security context, we should get
                        // the sender ID from the security context. So copy
                        // the sender ID from the security context that we
                        // get from the application into the temporary
                        // security context.
                        //
                        pTmpSecCtx->fLocalUser = pSecCtx->fLocalUser;

                        if (!pSecCtx->fLocalUser)
                        {
                            pTmpSecCtx->dwUserSidLen = pSecCtx->dwUserSidLen;
                            pTmpSecCtx->pUserSid = new BYTE[pSecCtx->dwUserSidLen];
                            BOOL bRet = CopySid(
                                            pSecCtx->dwUserSidLen,
                                            pTmpSecCtx->pUserSid.get(),
                                            pSecCtx->pUserSid.get());
                            ASSERT(bRet);
							DBG_USED(bRet);
                        }
                    }
                    else
                    {
                        pTmpSecCtx->fLocalUser = g_pSecCntx->fLocalUser;
                    }

                    pSecCtx = pTmpSecCtx;
                }

                ASSERT(pSecCtx);

                //
                // Fill the tranfer buffer with the provider information for the
                // certificate.
                //
                if (pSecCtx->wszProvName.get() == NULL)
                {
                    //
                    // we don't have a provider, so we can't sign.
                    //
                    ASSERT(pSecCtx->hProv == NULL) ;
                    if (tb.old.ppSenderCert == NULL)
                    {
                        //
                        // we don't have a certificate. That's a
                        // user error.
                        //
                        rc = MQ_ERROR_CERTIFICATE_NOT_PROVIDED ;
                    }
                    else
                    {
                        rc = MQ_ERROR_CORRUPTED_SECURITY_DATA ;
                    }
                    __leave ;
                }

                pProvName = pSecCtx->wszProvName.get();
                tb.old.ppwcsProvName = &pProvName;
                tb.old.ulProvNameLen = wcslen(pProvName) + 1;
                tb.old.pulProvType = &pSecCtx->dwProvType;
                tb.old.fDefaultProvider = pSecCtx->bDefProv;

                //
                // Set the buffer for the signature.
                //
                tb.old.ppSignature = &pabMessageSignature;
                tb.old.ulSignatureSize = sizeof(abMessageSignature);
                //
                // Sign the message.
                //
                if ((ulAuthLevel == MQMSG_AUTH_LEVEL_MSMQ10) ||
                    (ulAuthLevel == MQMSG_AUTH_LEVEL_ALWAYS))
                {
                    rc = SignMessage(&tb, pSecCtx);
                    if(FAILED(rc))
                    {
                        __leave;
                    }
                    ASSERT(tb.old.ulSignatureSize != 0);
                }
                else
                {
                    //
                    // Sign only with win2k style.
                    // make the "msmq1.0" signature dummy, with a single
                    // null dword. It's too risky to have a null pointer
                    // as msmq1.0 signature, so a dummy value is better.
                    // win2k code will ignore it anyway.
                    //
                    tb.old.ulSignatureSize = 4 ;
                    memset(abMessageSignature, 0, tb.old.ulSignatureSize) ;
                }

                //
                // Now create the "Extra" signature. Sign all those
                // properties that were not signed on msmq1.0.
                //
                BYTE abMessageSignatureEx[ MAX_MESSAGE_SIGNATURE_SIZE_EX ];
                DWORD dwSignSizeEx = sizeof(abMessageSignatureEx) ;

                if (ulAuthLevel == MQMSG_AUTH_LEVEL_MSMQ10)
                {
                    //
                    // enhanced signature (win2k style) not needed.
                    //
                    dwSignSizeEx = 0 ;
                }
                else
                {
                    rc = _SignMessageEx( hQueue,
                                        &tb,
                                         pSecCtx,
                                         abMessageSignatureEx,
                                        &dwSignSizeEx );
                    if(FAILED(rc))
                    {
                        __leave;
                    }

                    if (dwSignSizeEx == 0)
                    {
                        //
                        // Signature not created.
                        // That's ok for dependent client.
                        //
                        ASSERT(g_fDependentClient) ;
                    }
                }

                //
                // Copy the Ex signature to the standard signature buffer.
                // The driver will separate them and insert them in the
                // packet in the proper place. This is necessary to keep
                // the transfer buffer without changes.
                //
                if (dwSignSizeEx == 0)
                {
                    //
                    // Signature not created. That's ok.
                    //
                }
                else if ((dwSignSizeEx + tb.old.ulSignatureSize) <=
                                             MAX_MESSAGE_SIGNATURE_SIZE_EX)
                {
                    memcpy( &(abMessageSignature[ tb.old.ulSignatureSize ]),
                            abMessageSignatureEx,
                            dwSignSizeEx ) ;
                    tb.old.ulSignatureSize += dwSignSizeEx ;

                    //
                    // Compute size of authentication "provider" field. This
                    // field contain the provider name and extra authentication
                    // data that was added for post win2k rtm.
                    //
                    ulProvNameSizeAll = dwSignSizeEx +
                                 ALIGNUP4_ULONG(OldComputeAuthProvNameSize( &tb )) ;

                    tb.old.pulAuthProvNameLenProp = &ulProvNameSizeAll ;
                }
                else
                {
                    ASSERT(0) ;
                }
            }
            else
            {
                tb.old.ulSignatureSize = 0;
            }

            if(!tb.old.ppSenderID && *tb.old.pulSenderIDType == MQMSG_SENDERID_TYPE_SID)
            {
                if ((pSecCtx && pSecCtx->fLocalUser) ||
                    (!pSecCtx && g_pSecCntx->fLocalUser))
                {
                    //
                    // In case this is a local user, we do not send the user's
                    // SID with the message, eventhough the application asked
                    // to send it.
                    //
                    tb.old.pulSenderIDType = &ulSenderIdTypeNone;
                }
                else
                {
                    //
                    // We should pass the sender ID. Either get it from the
                    // security context, if available, or get it from the
                    // cached process security context.
                    //
                    if (!pSecCtx || !pSecCtx->pUserSid.get())
                    {
                        if (!g_pSecCntx->pUserSid.get())
                        {
                            //
                            // The cahced process context does not contain the
                            // sender's SID. There is nothing that we can do but
                            // fail.
                            //
                            rc = MQ_ERROR_COULD_NOT_GET_USER_SID;
                            __leave;
                        }

                        pUserSid = (PUCHAR)g_pSecCntx->pUserSid.get();
                        tb.old.uSenderIDLen = (USHORT)g_pSecCntx->dwUserSidLen;
                    }
                    else
                    {
                        pUserSid = (PUCHAR)pSecCtx->pUserSid.get();
                        tb.old.uSenderIDLen = (USHORT)pSecCtx->dwUserSidLen;
                    }
					tb.old.ppSenderID = &pUserSid;
                }
            }

            if (tb.old.ppSymmKeys)
            {
                //
                // the application supplied the symmetric key. In such a case
                // doesn't do any encryption
                //
                //
                // When the symm key is supplied, we assume that the body is encrypted and
                // we mark it as such and ignore PROPID_M_PRIV_LEVEL.
                //
                if (tb.old.pulPrivLevel &&
                    (*(tb.old.pulPrivLevel) == MQMSG_PRIV_LEVEL_BODY_ENHANCED))
                {
                    //
                    // priv level supplied by caller.
                    //
                }
                else
                {
                    //
                    // use default.
                    //
                    ulDefPrivLevel = MQMSG_PRIV_LEVEL_BODY;
                    tb.old.pulPrivLevel = &ulDefPrivLevel;
                }
                tb.old.bEncrypted = TRUE;
            }
            else
            {
                enum enumProvider eProvider ;
                if (ShouldEncryptMessage(&tb, &eProvider))
                {
                    //
                    // If we should use a block cypher enlarge the allocated
                    // space for the message body, so it will be able to accomodate
                    // the encrypted data.
                    //

                    if (*tb.old.pulEncryptAlg == CALG_RC2)
                    {
                        //
                        // Make more room for RC2 encryption.
                        //
                        DWORD dwBlockSize ;
                        hr = MQSec_GetCryptoProvProperty( eProvider,
                                                          eBlockSize,
                                                          NULL,
                                                         &dwBlockSize ) ;
                        if (FAILED(hr))
                        {
                            return hr ;
                        }

                        tb.old.ulAllocBodyBufferInBytes +=
                                                  ((2 * dwBlockSize) - 1) ;
                        tb.old.ulAllocBodyBufferInBytes &= ~(dwBlockSize - 1) ;
                    }

                    DWORD dwSymmSize ;
                    hr = MQSec_GetCryptoProvProperty( eProvider,
                                                      eSessionKeySize,
                                                      NULL,
                                                     &dwSymmSize ) ;
                    if (FAILED(hr))
                    {
                        return hr ;
                    }

                    tb.old.ulSymmKeysSize = dwSymmSize ;
                }
            }

            //
            //  Call AC driver with transfer buffer
            //
            OVERLAPPED ov = {0};
            ov.hEvent = GetThreadEvent();

            rc = ACDepSendMessage(
                    hQueue,
                    tb,
                    &ov
                    );

            switch (rc)
            {
            case MQ_INFORMATION_OPERATION_PENDING:
                //
                //  Wait for send completion
                //
                DWORD dwResult;
                dwResult = WaitForSingleObject(
                                ov.hEvent,
                                INFINITE
                                );

                //
                //  BUGBUG: MQSendMessage, must succeed in WaitForSingleObject
                //
                ASSERT(dwResult == WAIT_OBJECT_0);

                rc = DWORD_PTR_TO_DWORD(ov.Internal);
                break;

            case STATUS_RETRY:
                //
                // This error code is returned when the message is sent
                // localy and there are security operations that should
                // be performed on the message before the it can be put
                // in the queue. These security operations can only be
                // performed by the QM. So the message is tranfered to
                // the QM, the QM will do the security operations and will
                // then call a special device driver entry point, telling
                // the device driver that the security operations were
                // done and the result of those operations.
                //
                if (!tls_hBindRpc)
                {
                    INIT_RPC_HANDLE ;
                }
                rc = QMSendMessage(tls_hBindRpc, hQueue, &tb);
                break;
            }

            if(FAILED(rc))
            {
                //
                //  ACDepSendMessage failed (immidiatly or after waiting)
                //
                __leave;
            }


            if (fSingleTransaction)
            {
                // RPC call to QM for prepare/commit
                rc = pTransaction->Commit(0,0,0);
                if(FAILED(rc))
                {
                    __leave;
                }
            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            //
            //  The exception is due to invalid parameter
            //
            rc = GetExceptionCode();
        }
    }
    __finally
    {
        delete[] pwcsResponseStringToFree;
        delete[] pwcsAdminStringToFree;
        delete pTmpSecCtx;

        if (fTransactionGenerated)
        {
            pTransaction->Release();
        }
    }

    if(rc == MQ_OK)
    {
        //
        //  return message parsing return code
        //  NOTE: only if rc == MQ_OK otherwise PENDING will not pass through
        //
        return(rc1);
    }


    return(rc);
}




//
// This class is used to increment a value in an abortable manner.
// If the scope where the incrementation has taken place is exited
// without calling Detach() first, the value is decremented back.
//
class CIncrementor
{
public:
	CIncrementor(LPLONG ptr) :
		m_pValue(ptr),
		m_TimesIncremented(0)
	{	
	}

	~CIncrementor()
	{
		if(m_pValue == NULL)
			return;
		
		InterlockedExchangeAdd (m_pValue, -m_TimesIncremented);
	}

	LONG Increment()
	{
		m_TimesIncremented++;
		return InterlockedIncrement(m_pValue);
	}

	void Detach()
	{
		m_TimesIncremented = 0;
		m_pValue = NULL;
	}

private:
	LPLONG m_pValue;
	LONG m_TimesIncremented;
};


static
HRESULT
DeppReceiveMessage(
    IN HANDLE hQueue,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN MQMSGPROPS* pmp,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction *pTransaction
    )
{
	ASSERT(g_fDependentClient);

    CMQHResult rc, rc1;
    XACTUOW Uow;
    HRESULT hr;

    R<ITransaction> TransactionGenerated;
    CHandle hCallback;
    P<MQRXASYNCDESCRIPTOR> lpDesc;
	CIncrementor PendingReqCounter = &s_cRxPendingReq;

    rc = MQ_OK;
    rc1 = MQ_OK;

    //
    // Look for Viper transaction if any
    //
    if (pTransaction == MQ_MTS_TRANSACTION)
    {
	TransactionGenerated = GetCurrentViperTransaction();
	pTransaction = TransactionGenerated.get();
    }
    else if (pTransaction == MQ_XA_TRANSACTION)
    {
	TransactionGenerated = GetCurrentXATransaction();
	pTransaction = TransactionGenerated.get();
    }
    else if (pTransaction == MQ_SINGLE_MESSAGE)
    {
        pTransaction = NULL;
    }

    if (dwAction & MQ_ACTION_PEEK_MASK)
    {
        // PEEK cannot be transacted, but can work with transacted queue
        if (pTransaction != NULL)
        {
            return MQ_ERROR_TRANSACTION_USAGE;
        }
    }

    // Check usage: transaction urges synchronous operation
    if (pTransaction)
    {
        if (lpOverlapped || (fnReceiveCallback!=NULL))  // Transacted Receive is synchronous only
        {
            return MQ_ERROR_TRANSACTION_USAGE;
        }
    }

    CACTransferBufferV2 tb;
	memset(&tb, 0, sizeof(CACTransferBufferV2));
	tb.old.uTransferType = CACTB_RECEIVE;

    tb.old.Receive.RequestTimeout = dwTimeout;
    tb.old.Receive.Action = dwAction;

	//
	// ISSUE: handle to ulong casting should be handled
	//
    tb.old.Receive.Cursor = (hCursor != 0) ? (ULONG)CI2CH(hCursor) : 0;

    // Enlist QM in the transaction (for the first time);
    // Check that the transaction state is correct
    if (pTransaction)
    {
        // Enlist QM in transaction, if it isn't enlisted already
        hr = RTpProvideTransactionEnlist(pTransaction, &Uow);
        tb.old.pUow = &Uow;

        if(FAILED(hr))
        {
            return MQ_ERROR_TRANSACTION_ENLIST;
        }
    }

    //
    //  Parse properties
    //
    if(pmp !=0)
    {
        //
        //  Parse message properties, an exception can be raised on access to
        //  pmp fields
        //
        rc1 = RTpParseMessageProperties(
                RECV_PARSE,
                &tb,
                pmp->cProp,
                pmp->aPropID,
                pmp->aPropVar,
                pmp->aStatus,
                NULL,
                NULL,
                NULL);

        if(FAILED(rc1))
        {
            return(rc1);
        }
    }

    OVERLAPPED ov = {0};
    LPOVERLAPPED pov;

    if (fnReceiveCallback)
    {
        //
        //  Async Rx with Callback
        //
        //  do HERE all allocation of resources so that allocation
        //  failure won't happen after returning from ACDepReceiveMessage.
        //
	
	{
		CS Lock(s_InitAsyncRxCS);
        // This critical section prevent two threads from running the
        // initialization twice.
        if (!s_hAsyncRxThread)
        {
           rc = InitRxAsyncThread() ;
        }
	}

        if(FAILED(rc))
        {
           return rc;
        }

	if (PendingReqCounter.Increment() > RXTHREAD_HANDLELISTSIZE)
        {
           // Reached Async MQReceive() limit.
           //
           return MQ_ERROR_INSUFFICIENT_RESOURCES ;
        }

	*&hCallback = CreateEvent( 
						NULL,
                                 TRUE,  // manual reset
                                 FALSE, // not signalled
						NULL 
						);

	if (hCallback == NULL) 
	{
	   return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}

	*&lpDesc = new MQRXASYNCDESCRIPTOR;
	memset(lpDesc.get(), 0, sizeof(MQRXASYNCDESCRIPTOR));
        lpDesc->Overlapped.hEvent = hCallback ;
	pov = &(lpDesc->Overlapped);
    }
    else if(lpOverlapped != 0)
    {
        //
        //  Asynchronous (event or completion port)
        //
        pov = lpOverlapped;
    }
    else
    {
        //
        //  Synchronous, uses the TLS event
        //
        ov.hEvent = GetThreadEvent();
        pov = &ov;
    }

    //
    //  Call AC driver with transfer buffer
    //
    tb.old.Receive.Asynchronous = (pov != &ov);
    rc = ACDepReceiveMessage(
            hQueue,
            tb,
            pov
            );

    if((rc == MQ_INFORMATION_OPERATION_PENDING) && (pov == &ov))
    {
        //
        //  Wait for receive completion
        //
        DWORD dwResult;
        dwResult = WaitForSingleObject(
                        ov.hEvent,
                        INFINITE
                        );

        //
        //  BUGBUG: MQReceiveMessage, must succeed in WaitForSingleObject
        //
        ASSERT(dwResult == WAIT_OBJECT_0);

        rc = DWORD_PTR_TO_DWORD(ov.Internal);
    }

    if(FAILED(rc))
    {
        //
        //  ACDepReceiveMessage failed (immidiatly or after waiting)
        //
        return rc;
    }
    else if(fnReceiveCallback)
    {
        //
        // Async Rx with callback.
        //
		ASSERT(hCallback != NULL);
		ASSERT(lpDesc.get() != NULL);

        lpDesc->hSource = hQueue ;
        lpDesc->dwTimeout = dwTimeout ;
        lpDesc->dwAction = dwAction ;
        lpDesc->pMessageProps = pmp ;
        lpDesc->lpOverlapped = lpOverlapped ;
        lpDesc->hCursor = hCursor ;

        lpDesc->fnReceiveCallback = fnReceiveCallback ;

		{
			CS Lock(s_AsyncRxCS);

			s_pRxEventsHList[ s_cRxHandles ] = hCallback.detach();
			s_lpRxAsynDescList[ s_cRxHandles ] = lpDesc.detach();
            s_cRxHandles++ ;
		}

        // Tell the async thread that there is a new async MQReceive().
        BOOL fSet = SetEvent(s_hNewAsyncRx) ;
        ASSERT(fSet) ;
		DBG_USED(fSet);

		PendingReqCounter.Detach();
    }

    if (rc == MQ_OK)
    {
        //
        //  return message parsing return code
        //  NOTE: only if rc == MQ_OK otherwise PENDING will not pass through
        //
        return(rc1);
    }

    return(rc);
}


//---------------------------------------------------------
//
//  DepReceiveMessage(...)
//
//  Description:
//
//      Falcon API.
//      Receive a message from a queue.
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
DepReceiveMessage(
    IN HANDLE hQueue,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN MQMSGPROPS* pmp,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction *pTransaction
    )
{
	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

	__try
	{
		return DeppReceiveMessage(
					hQueue,
					dwTimeout,
					dwAction,
					pmp,
					lpOverlapped,
					fnReceiveCallback,
					hCursor,
					pTransaction
					);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return GetExceptionCode();
	}
}



//---------------------------------------------------------
//
//  DepGetOverlappedResult(...)
//
//  Description:
//
//      Falcon API.
//      Translate and overlapping operation result code.
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
DepGetOverlappedResult(
    IN LPOVERLAPPED lpOverlapped
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

	return RTpConvertToMQCode(DWORD_PTR_TO_DWORD(lpOverlapped->Internal));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\fnparse.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fnparse.cpp

Abstract:

    Format Name parsing.
    QUEUE_FORMAT <--> Format Name String conversion routines

Author:

    Erez Haba (erezh) 17-Jan-1997

Revision History:

--*/

#include "stdh.h"
#include <mqformat.h>
#include <fntoken.h>

#include "fnparse.tmh"

//=========================================================
//
//  QUEUE_FORMAT -> Format Name String conversion routine
//
//=========================================================

//---------------------------------------------------------
//
//  Function:
//      RTpQueueFormatToFormatName
//
//  Description:
//      Convert QUEUE_FORMAT to a format name string.
//
//---------------------------------------------------------
HRESULT
RTpQueueFormatToFormatName(
    QUEUE_FORMAT* pQueueFormat,
    LPWSTR lpwcsFormatName,
    DWORD dwBufferLength,
    LPDWORD lpdwFormatNameLength
    )
{
    return MQpQueueFormatToFormatName(
            pQueueFormat,
            lpwcsFormatName,
            dwBufferLength,
            lpdwFormatNameLength,
			false
            );
}


//=========================================================
//
//  Format Name String -> QUEUE_FORMAT conversion routines
//
//=========================================================

//---------------------------------------------------------
//
//  Skip white space characters, return next non ws char
//
//  N.B. if no white space is needed uncomment next line
//#define skip_ws(p) (p)
inline LPCWSTR skip_ws(LPCWSTR p)
{
    //
    //  Don't skip first non white space
    //
    while(iswspace(*p))
    {
        ++p;
    }

    return p;
}


//---------------------------------------------------------
//
//  Skip white space characters, return next non ws char
//
inline LPCWSTR FindPathNameDelimiter(LPCWSTR p)
{
    return wcschr(p, PN_DELIMITER_C);
}


//---------------------------------------------------------
//
//  Parse Format Name Type prefix string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParsePrefixString(LPCWSTR p, QUEUE_FORMAT_TYPE& qft)
{
    const int unique = 1;
    //----------------0v-------------------------
    ASSERT(L'U' == FN_PUBLIC_TOKEN    [unique]);
    ASSERT(L'R' == FN_PRIVATE_TOKEN   [unique]);
    ASSERT(L'O' == FN_CONNECTOR_TOKEN [unique]);
    ASSERT(L'A' == FN_MACHINE_TOKEN   [unique]);
    ASSERT(L'I' == FN_DIRECT_TOKEN    [unique]);
    //----------------0^-------------------------

    //
    //  accelarate token recognition by checking 3rd character
    //
    switch(towupper(p[unique]))
    {
        //  pUblic
        case L'U':
            qft = QUEUE_FORMAT_TYPE_PUBLIC;
            if(_wcsnicmp(p, FN_PUBLIC_TOKEN, FN_PUBLIC_TOKEN_LEN) == 0)
                return (p + FN_PUBLIC_TOKEN_LEN);
            break;

        //  pRivate
        case L'R':
            qft = QUEUE_FORMAT_TYPE_PRIVATE;
            if(_wcsnicmp(p, FN_PRIVATE_TOKEN, FN_PRIVATE_TOKEN_LEN) == 0)
                return (p + FN_PRIVATE_TOKEN_LEN);
            break;

        //  cOnnector
        case L'O':
            qft = QUEUE_FORMAT_TYPE_CONNECTOR;
            if(_wcsnicmp(p, FN_CONNECTOR_TOKEN, FN_CONNECTOR_TOKEN_LEN) == 0)
                return (p + FN_CONNECTOR_TOKEN_LEN);
            break;

        //  mAchine
        case L'A':
            qft = QUEUE_FORMAT_TYPE_MACHINE;
            if(_wcsnicmp(p, FN_MACHINE_TOKEN, FN_MACHINE_TOKEN_LEN) == 0)
                return (p + FN_MACHINE_TOKEN_LEN);
            break;

        //  dIrect
        case L'I':
            qft = QUEUE_FORMAT_TYPE_DIRECT;
            if(_wcsnicmp(p, FN_DIRECT_TOKEN, FN_DIRECT_TOKEN_LEN) == 0)
                return (p + FN_DIRECT_TOKEN_LEN);
            break;
    }

    return 0;
}


//---------------------------------------------------------
//
//  Parse a guid string, into guid.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseGuidString(LPCWSTR p, GUID* pg)
{
    //
    //  N.B. scanf stores the results in an int, no matter what the field size
    //      is. Thus we store the result in tmp variabes.
    //
    int n;
    UINT w2, w3, d[8];
    if(swscanf(
            p,
            GUID_FORMAT L"%n",
            &pg->Data1,
            &w2, &w3,                       //  Data2, Data3
            &d[0], &d[1], &d[2], &d[3],     //  Data4[0..3]
            &d[4], &d[5], &d[6], &d[7],     //  Data4[4..7]
            &n                              //  number of characters scaned
            ) != 11)
    {
        //
        //  not all 11 fields where not found.
        //
        return 0;
    }

    pg->Data2 = (WORD)w2;
    pg->Data3 = (WORD)w3;
    for(int i = 0; i < 8; i++)
    {
        pg->Data4[i] = (BYTE)d[i];
    }

    return (p + n);
}


//---------------------------------------------------------
//
//  Parse private id uniquifier, into guid.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParsePrivateIDString(LPCWSTR p, ULONG* pUniquifier)
{
    int n;
    if(swscanf(
            p,
            FN_PRIVATE_ID_FORMAT L"%n",
            pUniquifier,
            &n                              //  number of characters scaned
            ) != 1)
    {
        //
        //  private id field was not found.
        //
        return 0;
    }

    return (p + n);
}

enum DIRECT_TOKEN_TYPE {
    DT_OS,
    DT_TCP,
    DT_SPX,
};


//---------------------------------------------------------
//
//  Parse direct token type infix string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseDirectTokenString(LPCWSTR p, DIRECT_TOKEN_TYPE& dtt)
{
    const int unique = 0;
    //-----------------------v-------------------
    ASSERT(L'O' == FN_DIRECT_OS_TOKEN   [unique]);
    ASSERT(L'T' == FN_DIRECT_TCP_TOKEN  [unique]);
    //-----------------------^-------------------

    //
    //  accelarate token recognition by checking 1st character
    //
    switch(towupper(p[unique]))
    {
        // Os:
        case L'O':
            dtt = DT_OS;
            if(_wcsnicmp(p, FN_DIRECT_OS_TOKEN, FN_DIRECT_OS_TOKEN_LEN) == 0)
                return (p + FN_DIRECT_OS_TOKEN_LEN);
            break;

        // Tcp:
        case L'T':
            dtt = DT_TCP;
            if(_wcsnicmp(p, FN_DIRECT_TCP_TOKEN, FN_DIRECT_TCP_TOKEN_LEN) == 0)
                return (p + FN_DIRECT_TCP_TOKEN_LEN);
            break;
    }

    return 0;
}

//---------------------------------------------------------
//
//  Parse queue name string, (private, public)
//  N.B. queue name must end with either format name suffix
//      delimiter aka ';' or with end of string '\0'
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseQueueNameString(LPCWSTR p, QUEUE_PATH_TYPE* pqpt)
{
    if(_wcsnicmp(p, SYSTEM_QUEUE_PATH_INDICATIOR, SYSTEM_QUEUE_PATH_INDICATIOR_LENGTH) == 0)
    {
        p += SYSTEM_QUEUE_PATH_INDICATIOR_LENGTH;
        *pqpt = SYSTEM_QUEUE_PATH_TYPE;
        return p;
    }

    if(_wcsnicmp(p, PRIVATE_QUEUE_PATH_INDICATIOR, PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH) == 0)
    {
        *pqpt = PRIVATE_QUEUE_PATH_TYPE;
        p += PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH;
    }
    else
    {
        *pqpt = PUBLIC_QUEUE_PATH_TYPE;
    }

    //
    //  Zero length queue name is illegal
    //
    if(*p == L'\0')
        return 0;

    while(
        (*p != L'\0') &&
        (*p != PN_DELIMITER_C) &&
        (*p != FN_SUFFIX_DELIMITER_C)
        )
    {
        ++p;
    }

    //
    //  Path name delimiter is illegal in queue name
    //
    if(*p == PN_DELIMITER_C)
        return 0;


    return p;
}


//---------------------------------------------------------
//
//  Parse machine name in a path name
//  N.B. machine name must end with a path name delimiter aka slash '\\'
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseMachineNameString(LPCWSTR p)
{
    //
    //  Zero length machine name is illegal
    //  don't fall off the string (p++)
    //
    if(*p == PN_DELIMITER_C)
        return 0;

    if((p = FindPathNameDelimiter(p)) == 0)
        return 0;

    return (p + 1);
}


//---------------------------------------------------------
//
//  Check if this is an expandable machine path. i.e., ".\\"
//
inline BOOL IsExpandableMachinePath(LPCWSTR p)
{
    return ((p[0] == PN_LOCAL_MACHINE_C) && (p[1] == PN_DELIMITER_C));
}

//---------------------------------------------------------
//
//  Optionally expand a path name with local machine name.
//  N.B. expansion is done if needed.
//  return pointer to new/old string
//
static LPCWSTR ExpandPathName(LPCWSTR pStart, ULONG_PTR offset, LPWSTR* ppStringToFree)
{
    if((ppStringToFree == 0) || !IsExpandableMachinePath(&pStart[offset]))
        return pStart;

    int len = wcslen(pStart);
    LPWSTR pCopy = new WCHAR[len + g_dwComputerNameLen + 1 - 1];

    //
    //  copy prefix, till offset '.'
    //
    memcpy(
        pCopy,
        pStart,
        offset * sizeof(WCHAR)
        );

    //
    //  copy computer name to offset
    //
    memcpy(
        pCopy + offset,
        g_lpwcsComputerName,
        g_dwComputerNameLen * sizeof(WCHAR)
        );

    //
    //  copy rest of string not including dot '.'
    //
    memcpy(
        pCopy + offset + g_dwComputerNameLen,
        pStart + offset + 1,                        // skip dot
        (len - offset - 1 + 1) * sizeof(WCHAR)      // skip dot, include '\0'
        );

    *ppStringToFree = pCopy;
    return pCopy;
}


//---------------------------------------------------------
//
//  Parse OS direct format string. (check validity of path
//  name and optionally expand it)
//  ppDirectFormat - expended direct format string. (in out)
//  ppStringToFree - return string to free if needed.
//  Return next char to parse on success, 0 on failure.
//
static
LPCWSTR
ParseDirectOSString(
    LPCWSTR p, 
    LPCWSTR* ppDirectFormat, 
    LPWSTR* ppStringToFree,
    QUEUE_PATH_TYPE* pqpt
    )
{
    LPCWSTR pMachineName = p;
    LPCWSTR pStringToCopy = *ppDirectFormat;

    if((p = ParseMachineNameString(p)) == 0)
        return 0;

    if((p = ParseQueueNameString(p, pqpt)) == 0)
        return 0;


    *ppDirectFormat = ExpandPathName(pStringToCopy, (pMachineName - pStringToCopy), ppStringToFree);

    return p;
}


//---------------------------------------------------------
//
//  Parse net (tcp/spx) address part of direct format string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseNetAddressString(LPCWSTR p)
{
    //
    //  Zero length address string is illegal
    //  don't fall off the string (p++)
    //
    if(*p == PN_DELIMITER_C)
        return 0;

    if((p = FindPathNameDelimiter(p)) == 0)
        return 0;

    return (p + 1);
}


//---------------------------------------------------------
//
//  Parse net (tcp/spx) direct format string. (check validity of queue name)
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseDirectNetString(LPCWSTR p, QUEUE_PATH_TYPE* pqpt)
{
    if((p = ParseNetAddressString(p)) == 0)
        return 0;

    if((p = ParseQueueNameString(p, pqpt)) == 0)
        return 0;

    return p;
}

static void RemoveSuffixFromDirect(LPCWSTR p, LPCWSTR* ppDirectFormat, LPWSTR* ppStringToFree)
{
    ASSERT(ppStringToFree != NULL);
    ASSERT(*p == FN_SUFFIX_DELIMITER_C);

    LPCWSTR pSuffixDelimiter = wcschr(*ppDirectFormat, FN_SUFFIX_DELIMITER_C);
    ASSERT(pSuffixDelimiter != NULL);

    INT_PTR len = pSuffixDelimiter - *ppDirectFormat;
    LPWSTR pCopy = new WCHAR[len + 1];
    wcsncpy(pCopy, *ppDirectFormat, len);
    pCopy[len] = '\0';

    if (*ppStringToFree != NULL)
    {
        delete [] *ppStringToFree;
    }

    *ppDirectFormat = *ppStringToFree = pCopy;
}

//---------------------------------------------------------
//
//  Parse direct format string.
//  return expended direct format string.
//  return string to free if needed.
//  Return next char to parse on success, 0 on failure.
//
static 
LPCWSTR 
ParseDirectString(
    LPCWSTR p, 
    LPCWSTR* ppExpandedDirectFormat, 
    LPWSTR* ppStringToFree,
    QUEUE_PATH_TYPE* pqpt
    )
{
    *ppExpandedDirectFormat = p;

    DIRECT_TOKEN_TYPE dtt;
    if((p = ParseDirectTokenString(p, dtt)) == 0)
        return 0;

    switch(dtt)
    {
        case DT_OS:
            p = ParseDirectOSString(p, ppExpandedDirectFormat, ppStringToFree, pqpt);
            break;

        case DT_TCP:
        case DT_SPX:
            p = ParseDirectNetString(p, pqpt);
            break;

        default:
            ASSERT(0);
    }

    p = skip_ws(p);


    //
    // Remove suffix (like ;Journal)
    //
    if(*p == FN_SUFFIX_DELIMITER_C)
    {
        RemoveSuffixFromDirect(p, ppExpandedDirectFormat, ppStringToFree);
    }
    return p;
}


//---------------------------------------------------------
//
//  Parse format name suffix string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseSuffixString(LPCWSTR p, QUEUE_SUFFIX_TYPE& qst)
{
    const int unique = 5;
    //---------------01234v----------------------
    ASSERT(L'N' == FN_JOURNAL_SUFFIX    [unique]);
    ASSERT(L'L' == FN_DEADLETTER_SUFFIX [unique]);
    ASSERT(L'X' == FN_DEADXACT_SUFFIX   [unique]);
    ASSERT(L'O' == FN_XACTONLY_SUFFIX   [unique]);
    //---------------01234^----------------------

    //
    //  we already know that first character is ";"
    //
    ASSERT(*p == FN_SUFFIX_DELIMITER_C);

    //
    //  accelarate token recognition by checking 6th character
    //
    switch(towupper(p[unique]))
    {
        // ;jourNal
        case L'N':
            qst = QUEUE_SUFFIX_TYPE_JOURNAL;
            if(_wcsnicmp(p, FN_JOURNAL_SUFFIX, FN_JOURNAL_SUFFIX_LEN) == 0)
                return (p + FN_JOURNAL_SUFFIX_LEN);
            break;

        // ;deadLetter
        case L'L':
            qst = QUEUE_SUFFIX_TYPE_DEADLETTER;
            if(_wcsnicmp(p, FN_DEADLETTER_SUFFIX, FN_DEADLETTER_SUFFIX_LEN) == 0)
                return (p + FN_DEADLETTER_SUFFIX_LEN);
            break;

        // ;deadXact
        case L'X':
            qst = QUEUE_SUFFIX_TYPE_DEADXACT;
            if(_wcsnicmp(p, FN_DEADXACT_SUFFIX, FN_DEADXACT_SUFFIX_LEN) == 0)
                return (p + FN_DEADXACT_SUFFIX_LEN);
            break;

        // ;xactOnly
        case L'O':
            qst = QUEUE_SUFFIX_TYPE_XACTONLY;
            if(_wcsnicmp(p, FN_XACTONLY_SUFFIX, FN_XACTONLY_SUFFIX_LEN) == 0)
                return (p + FN_XACTONLY_SUFFIX_LEN);
            break;
    }

    return 0;
}


//---------------------------------------------------------
//
//  Function:
//      RTpFormatNameToQueueFormat
//
//  Description:
//      Convert a format name string to a QUEUE_FORMAT union.
//
//---------------------------------------------------------
BOOL
RTpFormatNameToQueueFormat(
    LPCWSTR pfn,            // pointer to format name string
    QUEUE_FORMAT* pqf,      // pointer to QUEUE_FORMAT
    LPWSTR* ppStringToFree  // pointer to allocated string need to free at end of use
    )                       // if null, format name will not get expanded
{
    LPCWSTR p = pfn;
    QUEUE_FORMAT_TYPE qft;

    if((p = ParsePrefixString(p, qft)) == 0)
        return FALSE;

    p = skip_ws(p);

    if(*p++ != FN_EQUAL_SIGN_C)
        return FALSE;

    p = skip_ws(p);

    GUID guid;
    switch(qft)
    {
        //
        //  "PUBLIC=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_PUBLIC:
            if((p = ParseGuidString(p, &guid)) == 0)
                return FALSE;

            pqf->PublicID(guid);
            break;

        //
        //  "PRIVATE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\xxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_PRIVATE:
            if((p = ParseGuidString(p, &guid)) == 0)
                return FALSE;

            p = skip_ws(p);

            if(*p++ != FN_PRIVATE_SEPERATOR_C)
                return FALSE;

            p = skip_ws(p);

            ULONG uniquifier;
            if((p = ParsePrivateIDString(p, &uniquifier)) == 0)
                return FALSE;

            pqf->PrivateID(guid, uniquifier);
            break;

        //
        //  "DIRECT=OS:bla-bla\0"
        //
        case QUEUE_FORMAT_TYPE_DIRECT:
            LPCWSTR pExpandedDirectFormat;
            QUEUE_PATH_TYPE qpt;
            if((p = ParseDirectString(p, &pExpandedDirectFormat, ppStringToFree, &qpt)) == 0)
                return FALSE;

            if (qpt == SYSTEM_QUEUE_PATH_TYPE)
            {
                pqf->DirectID(const_cast<LPWSTR>(pExpandedDirectFormat), QUEUE_FORMAT_FLAG_SYSTEM);
            }
            else
            {
                pqf->DirectID(const_cast<LPWSTR>(pExpandedDirectFormat));
            }
            break;

        //
        //  "MACHINE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_MACHINE:
           if((p = ParseGuidString(p, &guid)) == 0)
                return FALSE;

            pqf->MachineID(guid);
            break;

        //
        //  "CONNECTOR=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_CONNECTOR:
           if((p = ParseGuidString(p, &guid)) == 0)
                return FALSE;

            pqf->ConnectorID(guid);
            break;

        default:
            ASSERT(0);
    }

    p = skip_ws(p);

    //
    //  We're at end of string, return now.
    //  N.B. Machine format name *must* have a suffix
    //
    if(*p == L'\0')
        return (qft != QUEUE_FORMAT_TYPE_MACHINE);

    if(*p != FN_SUFFIX_DELIMITER_C)
        return FALSE;

    QUEUE_SUFFIX_TYPE qst;
    if((p = ParseSuffixString(p, qst)) == 0)
        return FALSE;

    p = skip_ws(p);

    //
    //  Only white space padding is allowed.
    //
    if(*p != L'\0')
        return FALSE;

    pqf->Suffix(qst);

    return pqf->Legal();
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueuePathType
//
//  Description:
//      Validate, Expand and return type for Path Name.
//
//---------------------------------------------------------
QUEUE_PATH_TYPE
RTpValidateAndExpandQueuePath(
    LPCWSTR pwcsPathName,
    LPCWSTR* ppwcsExpandedPathName,
    LPWSTR* ppStringToFree
    )
{
    ASSERT(ppStringToFree != 0);

    LPCWSTR pwcsPathNameNoSpaces = pwcsPathName;
    P<WCHAR> pStringToFree;
    *ppStringToFree = 0;

    //
    // Remove leading white spaces
    //
    while (*pwcsPathNameNoSpaces != 0 && iswspace(*pwcsPathNameNoSpaces))
    {
        pwcsPathNameNoSpaces++;
    }

    //
    // Remove trailing white spaces
    //
    DWORD dwLen = wcslen(pwcsPathNameNoSpaces);
    if (iswspace(pwcsPathNameNoSpaces[dwLen-1]))
    {
        pStringToFree = new WCHAR[dwLen+1];
        wcscpy(pStringToFree.get(), pwcsPathNameNoSpaces);
        for (DWORD i = dwLen; i-- > 0; )
        {
            if (iswspace(pStringToFree.get()[i]))
            {
                pStringToFree.get()[i] = 0;
            }
            else
            {
                break;
            }
        }
        pwcsPathNameNoSpaces = pStringToFree.get();
    }

    LPCWSTR p = pwcsPathNameNoSpaces;

    if((p = ParseMachineNameString(p)) == 0)
        return ILLEGAL_QUEUE_PATH_TYPE;

    QUEUE_PATH_TYPE qpt;
    if((p = ParseQueueNameString(p, &qpt)) == 0)
        return ILLEGAL_QUEUE_PATH_TYPE;

    //
    //  No characters are allowed at end of queue name.
    //
    if(*p != L'\0')
        return ILLEGAL_QUEUE_PATH_TYPE;

    *ppwcsExpandedPathName = ExpandPathName(pwcsPathNameNoSpaces, 0, ppStringToFree);

    //
    // if ExpandPathName does not return a string to free, we will
    // give the caller the string we allocated, so the caller will free it.
    // Otherwise, we will do nothing and "our" string will be auto-release.
    //
    if (*ppStringToFree == 0)
    {
        *ppStringToFree = pStringToFree.detach();
    }

    return (qpt);
}

//+-------------------------------------------
//
//  BOOL  RTpIsLocalPublicQueue()
//
//+-------------------------------------------

BOOL
RTpIsLocalPublicQueue(LPCWSTR lpwcsExpandedPathName)
{
    WCHAR  wDelimiter = lpwcsExpandedPathName[ g_dwComputerNameLen ] ;

    if ((wDelimiter == PN_DELIMITER_C) ||
        (wDelimiter == PN_LOCAL_MACHINE_C))
    {
        //
        // Delimiter OK (either end of NETBios machine name, or dot of
        // DNS name. Continue checking.
        //
    }
    else
    {
        return FALSE ;
    }

    DWORD dwSize = g_dwComputerNameLen + 1 ;
    P<WCHAR> pQueueCompName = new WCHAR[ dwSize ] ;
    lstrcpynW( pQueueCompName.get(), lpwcsExpandedPathName, dwSize ) ;

    BOOL bRet = (lstrcmpi( g_lpwcsComputerName, pQueueCompName.get() ) == 0) ;
    return bRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\machine.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    machine.cpp

Abstract:

    This module contains code involved with Machine APIs.

Author:

    Ronit Hartmann (ronith)

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include <ad.h>
#include <mqsec.h>
#include "_registr.h"
#include <_guid.h>
#include "version.h"
#include <mqversion.h>
#include <mqnames.h>

#include "machine.tmh"

static WCHAR *s_FN=L"rtdep/machine";

BOOL
IsConnectionRequested(IN MQQMPROPS * pQMProps,
                      IN DWORD* pdwIndex)
{
    for(DWORD i= 0; i < pQMProps->cProp; i++)
    {
        if (pQMProps->aPropID[i] == PROPID_QM_CONNECTION)
        {
            ASSERT(pQMProps-> aPropVar[i].vt == VT_NULL);

            pQMProps->aPropID[i] = PROPID_QM_SITE_IDS;
            *pdwIndex = i;
            return TRUE;
        }
    }
    return FALSE;
}

//+------------------------------------------
//
//  HRESULT  GetEncryptionPublicKey()
//
//+------------------------------------------

HRESULT
GetEncryptionPublicKey(
    IN LPCWSTR          lpwcsMachineName,
    IN const GUID *     pguidMachineId,
    IN OUT HRESULT*     aStatus,
    IN OUT MQQMPROPS   *pQMProps
    )
{
    DWORD i;
    BOOL fFirst = TRUE;
    HRESULT hr = MQ_OK;

    for(i= 0; i < pQMProps->cProp; i++)
    {
        if ((pQMProps->aPropID[i] == PROPID_QM_ENCRYPTION_PK) ||
            (pQMProps->aPropID[i] == PROPID_QM_ENCRYPTION_PK_BASE))
        {
            //
            // Use msmq1.0 code, because our server can be either msmq1.0
            // or msmq2.0.
            //
            // Check if legal VT Value
            //
            if(pQMProps->aPropVar[i].vt != VT_NULL)
            {
                aStatus[i] = MQ_ERROR_PROPERTY;
                return LogHR(MQ_ERROR_PROPERTY, s_FN, 10);
            }
            else
            {
                aStatus[i] = MQ_OK;
            }

            if (fFirst)
            {
                PROPID prop =  PROPID_QM_ENCRYPT_PK;

                if (lpwcsMachineName)
                {
                    hr = ADGetObjectProperties(
								eMACHINE,
								NULL,      // pwcsDomainController
								false,	   // fServerName
								lpwcsMachineName,
								1,
								&prop,
								&pQMProps->aPropVar[i]
								);
                }
                else
                {
                    hr = ADGetObjectPropertiesGuid(
								eMACHINE,
								NULL,      // pwcsDomainController
								false,	   // fServerName
								pguidMachineId,
								1,
								&prop,
								&pQMProps->aPropVar[i]
								);
                }
                if (FAILED(hr))
                {
                    break;
                }

				//
				// PROPID_QM_ENCRYPTION_PK, PROPID_QM_ENCRYPTION_PK_BASE
				// are VT_UI1|VT_VECTOR
				// while PROPID_QM_ENCRYPT_PK is VT_BLOB
				//
                ASSERT(pQMProps-> aPropVar[i].vt == VT_BLOB);
                pQMProps-> aPropVar[i].vt = VT_UI1|VT_VECTOR;

                fFirst = FALSE;
            }
            else
            {
                //
                // Duplicate proprerty
                //
                aStatus[i] = MQ_INFORMATION_DUPLICATE_PROPERTY;
            }
        }
    }

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20) ;
    }

    //
    // now see if caller asked for enhanced key (128 bits).
    //
    fFirst = TRUE;

    for(i= 0; i < pQMProps->cProp; i++)
    {
        if (pQMProps->aPropID[i] == PROPID_QM_ENCRYPTION_PK_ENHANCED)
        {
            //
            // Check if legal VT Value
            //
            if(pQMProps->aPropVar[i].vt != VT_NULL)
            {
                aStatus[i] = MQ_ERROR_PROPERTY;
                return LogHR(MQ_ERROR_PROPERTY, s_FN, 30);
            }
            else
            {
                aStatus[i] = MQ_OK;
            }

            if (fFirst)
            {
                P<BYTE> pPbKey ;
                DWORD dwReqLen;

                hr = MQSec_GetPubKeysFromDS( pguidMachineId,
                                             lpwcsMachineName,
                                             eEnhancedProvider,
                                             PROPID_QM_ENCRYPT_PKS,
                                            &pPbKey,
                                            &dwReqLen ) ;
                if (FAILED(hr))
                {
                    break;
                }

                pQMProps-> aPropVar[i].vt = VT_UI1|VT_VECTOR;
                pQMProps-> aPropVar[i].caub.cElems = dwReqLen;
                pQMProps-> aPropVar[i].caub.pElems = new UCHAR[dwReqLen];
                memcpy(pQMProps->aPropVar[i].caub.pElems, pPbKey.get(), dwReqLen);

                fFirst = FALSE;
            }
            else
            {
                //
                // Duplicate proprerty
                //
                aStatus[i] = MQ_INFORMATION_DUPLICATE_PROPERTY;
            }
        }
    }

    return LogHR(hr, s_FN, 40);
}

HRESULT GetCNNameList(IN OUT MQPROPVARIANT* pVar)
{
    ASSERT(pVar->vt == (VT_CLSID|VT_VECTOR));

    //
    // pVar contains the list of sites where the machine reside
    //

    LPWSTR * pElems = new LPWSTR[(pVar->cauuid).cElems];

    for(DWORD i = 0; i < (pVar->cauuid).cElems; i++)
    {
        HRESULT hr;
        PROPID      aProp[2];
        PROPVARIANT aVar[2];
        ULONG       cProps = sizeof(aProp) / sizeof(PROPID);

        aProp[0] = PROPID_S_FOREIGN;
        aProp[1] = PROPID_S_PATHNAME;
        aVar[0].vt = VT_UI1;
        aVar[1].vt = VT_NULL;

        hr = ADGetObjectPropertiesGuid(
                        eSITE,
                        NULL,       // pwcsDomainCOntroller
						false,	    // fServerName
                        &((pVar->cauuid).pElems[i]),
                        cProps,
                        aProp,
                        aVar);   

        if (FAILED(hr))
        {
            for (DWORD j = 0 ; j < i ; j++ )
            {
                delete pElems[j] ;
            }
            delete pElems ;

            return LogHR(hr, s_FN, 50);
        }

        GUID_STRING wszGuid;
        MQpGuidToString(&((pVar->cauuid).pElems[i]), wszGuid);

        DWORD dwTypeSize;
        LPWSTR lpwsTypeNmae;

        switch (aVar[0].bVal)
        {
            case 0:
                //
                //  non foreign site
                //
                dwTypeSize = wcslen(L"IP_CONNECTION");
                lpwsTypeNmae = L"IP_CONNECTION";
                break;
            case 1:
                //
                // foreign site
                //
                dwTypeSize = wcslen(L"FOREIGN_CONNECTION");
                lpwsTypeNmae = L"FOREIGN_CONNECTION";
                break;
            default:
                dwTypeSize = wcslen(L"UNKNOWN_CONNECTION");
                lpwsTypeNmae = L"UNKNOWN_CONNECTION";
                break;
        }

        DWORD CNNameSize = dwTypeSize + 1 +                 // protocol id
                           wcslen(wszGuid) + 1 +            // site Guid
                           wcslen(aVar[1].pwszVal) + 1;     // site Name

        pElems[i] = new WCHAR[CNNameSize];
        wsprintf(pElems[i],L"%s %s %s",lpwsTypeNmae, wszGuid, aVar[1].pwszVal);

        delete  [] aVar[1].pwszVal;
    }

    delete [] (pVar->cauuid).pElems;
    (pVar->calpwstr).cElems = (pVar->cauuid).cElems;
    (pVar->calpwstr).pElems = pElems;

    pVar->vt = VT_LPWSTR|VT_VECTOR;

    return MQ_OK;
}

EXTERN_C
HRESULT
APIENTRY
DepGetMachineProperties(
    IN LPCWSTR lpwcsMachineName,
    IN const GUID *    pguidMachineId,
    IN OUT MQQMPROPS * pQMProps)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc(MQDS_MACHINE), rc1(MQDS_MACHINE);
    LPWSTR lpwsPathName =  (LPWSTR)lpwcsMachineName;
    MQQMPROPS *pGoodQMProps;
    char *pTmpQPBuff = NULL;
    BOOL fGetConnection = FALSE;
    DWORD dwConnectionIndex = 0;
    HRESULT* aLocalStatus_buff = NULL;


    __try
    {
        __try
        {
            if (( lpwcsMachineName != NULL) &&
                ( pguidMachineId != NULL))
            {
                //
                //  the user cannot specify both machine name
                //  and guid
                //
                return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 60);
            }

            if ( pguidMachineId == NULL)
            {
                //
                //  if machine name is NULL, the calls refers to the
                //  local machine
                //
                if ( lpwcsMachineName == NULL)
                {
                    lpwsPathName = g_lpwcsComputerName;
                }
            }

            //
            // We must have a status array, even if the user didn't pass one. This is in
            // order to be able to tell whether each propery is good or not.
            //
            HRESULT * aLocalStatus;

            if (!pQMProps->aStatus)
            {
                aLocalStatus_buff = new HRESULT[pQMProps->cProp];
                aLocalStatus = aLocalStatus_buff;
            }
            else
            {
                aLocalStatus = pQMProps->aStatus;
            }

            //
            // See if the application wants to retrieve the key exchange
            // public key of the QM.
            //
            DWORD iPbKey;

            for (iPbKey = 0;
                 (iPbKey < pQMProps->cProp) &&
                    (pQMProps->aPropID[iPbKey] != PROPID_QM_ENCRYPTION_PK);
                 iPbKey++)
			{
				NULL;
			}

            //
            //  Check QM properties structure
            //
            rc1 = RTpCheckQMProps( pQMProps,
                                   aLocalStatus,
                                   &pGoodQMProps,
                                   &pTmpQPBuff );

            if (FAILED(rc1))
            {
                return LogHR(rc1, s_FN, 70);
            }

            if ((rc1 == MQ_INFORMATION_PROPERTY) && (iPbKey < pQMProps->cProp))
            {
                //
                // If only PROPID_QM_ENCRYPTION_PK caused the return code
                // of RTpCheckQMProps to return MQ_INFORMATION_PROPERTY, so
                // convert it to MQ_OK.
                //
                rc1 = MQ_OK;

                for (DWORD iProp = 0; iProp < pQMProps->cProp; iProp++)
                {
                    if (aLocalStatus[iProp] != MQ_OK)
                    {
                        rc1 = MQ_INFORMATION_PROPERTY;
                        break;
                    }
                }
            }

            //
            // We may get here with zero properties to retrieve, if the
            // application is only interested in PROPID_QM_ENCRYPTION_PK.
            //
            if (pGoodQMProps->cProp)
            {
                //
                // Check if CN list is requested. If yes return the Index and replace the
                // property to PROPID_QM_CNS
                //
                fGetConnection = IsConnectionRequested(pGoodQMProps,
                                                       &dwConnectionIndex);

                if (lpwsPathName)
                {
                    rc = ADGetObjectProperties(
								eMACHINE,
								NULL,      // pwcsDomainController
								false,	   // fServerName
								lpwsPathName,
								pGoodQMProps->cProp,
								pGoodQMProps->aPropID,
								pGoodQMProps->aPropVar
								);
                }
                else
                {
                    rc = ADGetObjectPropertiesGuid(
								eMACHINE,
								NULL,      // PWCSDOmainController
								false,	   // fServerName
								pguidMachineId,
								pGoodQMProps->cProp,
								pGoodQMProps->aPropID,
								pGoodQMProps->aPropVar
								);
                }
            }
            else
            {
                rc = MQ_OK;
            }

			if ( fGetConnection	)
			{
				//
				//	Replace back the connection propid value ( also in case
				//	of failure)
				//
				pGoodQMProps->aPropID[dwConnectionIndex] = 	PROPID_QM_CONNECTION;
			}

            if (SUCCEEDED(rc))
            {
                rc = GetEncryptionPublicKey(lpwsPathName,
                                            pguidMachineId,
                                            aLocalStatus,
                                            pQMProps);
            }

            if (SUCCEEDED(rc) && fGetConnection)
            {
                rc = GetCNNameList(&(pGoodQMProps->aPropVar[dwConnectionIndex]));
            }
            //
            // Here we have out machindwConnectionIndexe properties, so if the properties were copied to
            // a temporary buffer, copy the resulted prop vars to the application's
            // buffer.
            //
            if (SUCCEEDED(rc) && (pQMProps != pGoodQMProps))
            {
                DWORD i, j;

                for (i = 0, j = 0; i < pGoodQMProps->cProp; i++, j++)
                {
                    while(pQMProps->aPropID[j] != pGoodQMProps->aPropID[i])
                    {
                        j++;
                        ASSERT(j < pQMProps->cProp);
                    }
                    pQMProps->aPropVar[j] = pGoodQMProps->aPropVar[i];

                }

                //
                // Check if there is a real warning or the warning came from
                // the PROPID_QM_ENCRYPTION_PK property
                //
                BOOL fWarn = FALSE;
                for (i = 0; i < pQMProps->cProp; i++)
                {
                    if (aLocalStatus[i] != MQ_OK)
                    {
                        fWarn = TRUE;
                    }
                }

                if (!fWarn && (rc1 != MQ_OK))
                {
                    rc1 = MQ_OK;
                }

            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 80); 
        }
    }
    __finally
    {
        delete[] pTmpQPBuff;
        delete[] aLocalStatus_buff;
    }

    if (!FAILED(rc))
    {
        return LogHR(rc1, s_FN, 90);
    }

    return LogHR(rc, s_FN, 100);
}

//---------------------------------------------------------
//
//  FillPrivateComputerVersion(...)
//
//  Description:
//
//      Retrieve private computer MSMQ version
//
//  Return Value:
//
//      none
//
//---------------------------------------------------------
static void FillPrivateComputerVersion(
			IN OUT MQPROPVARIANT * pvar
			)
{
	struct lcversion
	{
		unsigned short buildNumber;
		unsigned char minor;
		unsigned char major;
	};

	lcversion * plcversion = (lcversion *)&pvar->ulVal;
	plcversion->major = MSMQ_RMJ;
	plcversion->minor = MSMQ_RMM;
	plcversion->buildNumber = rup;
	pvar->vt = VT_UI4;
}

//---------------------------------------------------------
//
//  FillPrivateComputerDsEnabled(...)
//
//  Description:
//
//      Retrieve private computer DS enabled state
//
//  Return Value:
//
//      none
//
//---------------------------------------------------------
static void  FillPrivateComputerDsEnabled(
			IN OUT MQPROPVARIANT * pvar
			)
{
    //
    // Read from registery if the machine is in WorkGroup mode
    //
	DWORD dwWorkGroup;
    DWORD dwSize = sizeof(DWORD) ;
    DWORD dwType = REG_DWORD ;

    LONG res = GetFalconKeyValue( MSMQ_WORKGROUP_REGNAME,
                                 &dwType,
                                 &dwWorkGroup,
                                 &dwSize ) ;
    if (res != ERROR_SUCCESS)
    {
        //
        // workgroup flag not present in registry. that's OK.
        //
        dwWorkGroup = 0;
    }

	pvar->boolVal = (dwWorkGroup > 0) ? VARIANT_FALSE : VARIANT_TRUE;
	pvar->vt = VT_BOOL;
}

//---------------------------------------------------------
//
//  DepGetPrivateComputerInformation(...)
//
//  Description:
//
//      Falcon API.
//      Retrieve local computer properties (i.e. calculated properties
//      not ones that are kept in the DS).
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------
EXTERN_C
HRESULT
APIENTRY
DepGetPrivateComputerInformation(
    IN LPCWSTR			lpwcsComputerName,
    IN OUT MQPRIVATEPROPS* pPrivateProps
)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc(MQDS_MACHINE);

	//
	//	For the time being 	lpwcsComputerName must be NULL
	//
	if ( lpwcsComputerName != NULL)
	{
		return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 110);
	}

    HRESULT* aLocalStatus_buff = NULL;

    __try
    {
		__try
		{
            //
            // We must have a status array, even if the user didn't pass one. This is in
            // order to be able to tell whether each propery is good or not.
            //
            HRESULT * aLocalStatus;

            if (pPrivateProps->aStatus == NULL)
            {
                aLocalStatus_buff = new HRESULT[pPrivateProps->cProp];
                aLocalStatus = aLocalStatus_buff;
            }
            else
            {
                aLocalStatus = pPrivateProps->aStatus;
            }
            //
            //  validate props and variants
            //
			rc = RTpCheckComputerProps(
				pPrivateProps,
				aLocalStatus
				);
			if (FAILED(rc))
			{
				return LogHR(rc, s_FN, 120);
			}

			for ( DWORD i = 0; i < pPrivateProps->cProp; i++)
			{
				if ( aLocalStatus[i] != MQ_OK)
				{
					//
					//	don't fill in response for unsupported properties, or
					//  properties that are duplicate etc.
					//
					continue;
				}
				switch ( pPrivateProps->aPropID[i])
				{
				case PROPID_PC_VERSION:
					FillPrivateComputerVersion( &pPrivateProps->aPropVar[i]);
					break;
				case PROPID_PC_DS_ENABLED:
					FillPrivateComputerDsEnabled(&pPrivateProps->aPropVar[i]);
					break;
				default:
					ASSERT(0);
					return LogHR(MQ_ERROR_PROPERTY, s_FN, 130);
					break;
				}
			}

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 140); 
        }
    }
    __finally
    {
        delete[] aLocalStatus_buff;
    }
    return LogHR(rc, s_FN, 150);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqrt.rc
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\property.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    property.cxx

Abstract:



Author:

    Erez Haba (erezh) 2-Jan-96

Revision History:

    RonitH - Queue properties validation.
    BoazF (26-May-96) - Message properties validation.
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include <mqtime.h>
#include "acrt.h"
#include "rtprpc.h"

#include "property.tmh"

#define ONE_KB 1024
#define HRESULT_SEVIRITY(hr) (((hr) >> 30) & 0x3)

extern DWORD  g_dwTimeToReachQueueDefault ;

//+-------------------------------------------------------------------
//
//   HRESULT  _SupportingServerNotMSMQ1()
//   HRESULT  _TrySupportingServer(LPWSTR *ppString)
//
// Determine if supporting server is MSMQ1.0 (NT4) or MSMQ2.0 (NT5)
// We can't do this when loading the mqrt.dll because this need RPC over
// network and we can't initialize RPC on PROCESS_ATTACH.
// For independent client always return MQ_OK ;
//
//+-------------------------------------------------------------------

static HRESULT _TrySupportingServer(LPWSTR *ppString)
{
    HRESULT hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;

    INIT_RPC_HANDLE ;

	if(tls_hBindRpc == 0)
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;

    __try
    {
        hr = QMQueryQMRegistryInternal( tls_hBindRpc,
                                        QueryRemoteQM_QMVersion,
                                        ppString ) ;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;
    }

    //
    // MQ_OK is returned only if supporting server is online and is MSMQ2.0
    //
    return hr ;
}

static HRESULT  _SupportingServerNotMSMQ1()
{
    if (!g_fDependentClient)
    {
        return MQ_OK ;
    }

    static HRESULT  s_hrSupportingServerNotMSMQ1 = MQ_OK ;
    static BOOL     s_fAlreadyInitialized = FALSE ;

    if (s_fAlreadyInitialized)
    {
        return s_hrSupportingServerNotMSMQ1 ;
    }

    P<WCHAR> lpStr = NULL ;
    HRESULT hr =  _TrySupportingServer(&lpStr) ;

    if (FAILED(hr))
    {
        if (hr == MQ_ERROR_SERVICE_NOT_AVAILABLE)
        {
            //
            // supporting server not online now, so we can't determine.
            //
            return hr ;
        }

        //
        // Supporting server is MSMQ1.0.
        // It doesn't support new properties.
        //
        s_hrSupportingServerNotMSMQ1 = MQ_ERROR_PROPERTY_NOTALLOWED ;
    }

    s_fAlreadyInitialized = TRUE ;
    return s_hrSupportingServerNotMSMQ1 ;
}

//+----------------------------------------------
//
//  HRESULT  RTpCheckColumnsParameter()
//
//+----------------------------------------------

HRESULT
RTpCheckColumnsParameter(
    IN MQCOLUMNSET* pColumns)
{
    HRESULT hr = MQ_OK;

    if (( pColumns == NULL) ||
        ( pColumns->cCol == 0))
    {
        return(MQ_ERROR_ILLEGAL_MQCOLUMNS);
    }

    __try
    {
        PROPID * pPropid = pColumns->aCol;
        for ( DWORD i = 0; i < pColumns->cCol; i++, pPropid++)
        {
            //
            //  make sure that the property id is with-in queue property ids range
            //
            if (((*pPropid) > PROPID_Q_PATHNAME_DNS)  || ((*pPropid) <= PROPID_Q_BASE))
            {
                return(MQ_ERROR_ILLEGAL_PROPID);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing column structure")));
        hr = GetExceptionCode();
    }

    return(hr);
}


static
void
SetStatus(
    HRESULT* pStatusSummary,
    HRESULT* pStatus,
    HRESULT Status
    )
{
    DWORD dwSummarySevirity = HRESULT_SEVIRITY(*pStatusSummary);
    DWORD dwStatusSevirity = HRESULT_SEVIRITY(Status);

    if (dwSummarySevirity < dwStatusSevirity)
    {
        switch(dwStatusSevirity)
        {
        case 1:
            *pStatusSummary = MQ_INFORMATION_PROPERTY;
            break;

        case 2:
            ASSERT(FALSE);
			break;

        case 3:
            *pStatusSummary = MQ_ERROR_PROPERTY;
            break;
        }
    }

    if(pStatus)
    {
        *pStatus = Status;
    }
}


typedef struct {
    PROPID  propId;
    BOOL    fAllow_VT_NULL;
    BOOL    fMustAppear;
    BOOL    fShouldNotAppear;
    BOOL    fPossiblyIgnored;
    HRESULT (* pfValidateProperty)(PROPVARIANT * pVar, PVOID pvContext);
} propValidity;

static
DWORD
CalNumberOfMust(
    IN propValidity * ppropValidity,
    IN DWORD          dwNumberOfProps
    )
{
    DWORD dwNumberOfMust = 0;

    for ( DWORD i =0; i < dwNumberOfProps; i++, ppropValidity++ )
    {
        if (ppropValidity->fMustAppear)
        {
            dwNumberOfMust++;
        }
    }
    return(dwNumberOfMust);
}

static
HRESULT
CheckProps(
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus,
    IN PROPID propidMinPropId,
    IN PROPID propidMaxPropId,
    IN propValidity *ppropValidity,
    IN VARTYPE *vartypePropVts,
    IN BOOL fCheckForIgnoredProps,
    IN DWORD dwNumberOfMustProps,
    IN PVOID pvContext
    )
{
    HRESULT hr = MQ_OK;
    HRESULT dummyStatus;
    BOOL fAdvanceStatusPointer;
    char duplicate[ PROPID_OBJ_GRANULARITY ];
    DWORD index;
    DWORD dwNumberOfMustPropsSupplied = 0;

    memset( duplicate, 0, sizeof(duplicate));

    if ( !pStatus )
    {
        pStatus = &dummyStatus;
        fAdvanceStatusPointer = FALSE;
    }
    else
    {
        fAdvanceStatusPointer = TRUE;
    }

    for ( DWORD i = 0;
          i < cProp;
          i++, pPropid++, pVar++, fAdvanceStatusPointer ? pStatus++ : 0)
    {
        //
        //  Is it a valid propid
        //
        if (((*pPropid) <= propidMinPropId)  || (propidMaxPropId < (*pPropid)))
        {
            //
            // a non-valid propid. The property is ignored, and a warning
            // is returned in aStatus
            //
            SetStatus(&hr, pStatus, MQ_INFORMATION_UNSUPPORTED_PROPERTY);
            continue;
        }

        index = (*pPropid) - propidMinPropId;
        ASSERT(ppropValidity[index].propId == *pPropid);

        //
        //  Is it a duplicate property
        //
        if ( duplicate[ index ] )
        {
            //
            //  The duplicate property is ignored, and a warning is returned
            //  in aStatus
            //
            SetStatus(&hr, pStatus, MQ_INFORMATION_DUPLICATE_PROPERTY);
            continue;
        }
        duplicate[ index ] = 1;

        //
        //  Is it ok for the user to specify this property
        //
        if ( ppropValidity[index].fShouldNotAppear)
        {
            SetStatus(&hr, pStatus, MQ_ERROR_PROPERTY_NOTALLOWED);
            continue;
        }

        //
        // If an ignored property was supplied then raise a warning.
        //
        if (fCheckForIgnoredProps && (ppropValidity[index].fPossiblyIgnored))
        {
            SetStatus(&hr, pStatus, MQ_INFORMATION_PROPERTY_IGNORED);
            continue;
        }

        //
        // Checking propvariant's vartype.
        //
        if ((pVar->vt != vartypePropVts[index]) &&
            !(ppropValidity[index].fAllow_VT_NULL && pVar->vt == VT_NULL))
        {
            SetStatus(&hr, pStatus, MQ_ERROR_ILLEGAL_PROPERTY_VT);
            continue;
        }

        //
        //  Checking propvariant's value and size
        //
        if ( ppropValidity[index].pfValidateProperty != NULL)
        {
            SetStatus(&hr, pStatus, ppropValidity[index].pfValidateProperty(pVar, pvContext));
        }
        else
        {
            *pStatus = MQ_OK;
        }

        //
        //  Count the number of "must-appear" properties
        //
        if ( (*pStatus == MQ_OK) && ppropValidity[index].fMustAppear )
        {
            dwNumberOfMustPropsSupplied++;
        }
    }

    //
    //  where all the "must appear" properties passed in
    //
    if ( dwNumberOfMustPropsSupplied < dwNumberOfMustProps )
    {
        hr = MQ_ERROR_INSUFFICIENT_PROPERTIES;
    }

    return(hr);
}

static HRESULT qJournalValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->bVal != MQ_JOURNAL) && ( pVar->bVal != MQ_JOURNAL_NONE))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}


static HRESULT qLabelValidation( PROPVARIANT * pVar, LPVOID )
{
    __try
    {
        if ( wcslen( pVar->pwszVal) > MQ_MAX_Q_LABEL_LEN )
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }


    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }

    return(MQ_OK);
}


static HRESULT qAuthValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->bVal != MQ_AUTHENTICATE_NONE) &&
         (pVar->bVal != MQ_AUTHENTICATE))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

static HRESULT qPrivLevelValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->ulVal != MQ_PRIV_LEVEL_NONE) &&
         (pVar->ulVal != MQ_PRIV_LEVEL_OPTIONAL) &&
         (pVar->ulVal != MQ_PRIV_LEVEL_BODY))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

static HRESULT qXactionValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->bVal != MQ_TRANSACTIONAL_NONE) &&
         (pVar->bVal != MQ_TRANSACTIONAL))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

static HRESULT qTypeValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

static HRESULT qInstanceValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

static HRESULT qmMachineIdValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

static HRESULT qmSiteIdValidation( PROPVARIANT * pVar, LPVOID )
{
    if ( (pVar->vt == VT_CLSID) &&
         (pVar->puuid == NULL))
    {
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
    }
    return(MQ_OK);
}

//
//  The offset of property in this array must be equal to
//  PROPID value - PROPID_Q_BASE
//
propValidity    QueueCreateValidation[] =
{
    //                                       Must
    // Property              Allow   Must    Not     Maybe   Parsing
    // Ientifier             VT_NULL Appear  Appear  Ignored Procedure
    //-------------------------------------------------------------------------
    { 0,                     FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_INSTANCE,      FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_TYPE,          FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_PATHNAME,      FALSE,  TRUE,   FALSE,  FALSE,  NULL},
    {PROPID_Q_JOURNAL,       FALSE,  FALSE,  FALSE,  FALSE,  qJournalValidation},
    {PROPID_Q_QUOTA,         FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_BASEPRIORITY,  FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_JOURNAL_QUOTA, FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_LABEL,         FALSE,  FALSE,  FALSE,  FALSE,  qLabelValidation},
    {PROPID_Q_CREATE_TIME,   FALSE,  FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_MODIFY_TIME,   FALSE,  FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_AUTHENTICATE,  FALSE,  FALSE,  FALSE,  FALSE,  qAuthValidation},
    {PROPID_Q_PRIV_LEVEL,    FALSE,  FALSE,  FALSE,  FALSE,  qPrivLevelValidation},
    {PROPID_Q_TRANSACTION,   FALSE,  FALSE,  FALSE,  FALSE,  qXactionValidation},
    {PROPID_Q_SCOPE,         FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_QMID,          FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_MASTERID,      FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SEQNUM,        FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_HASHKEY,       FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_LABEL_HASHKEY, FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NT4ID,         FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_FULL_PATH,     FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_DONOTHING,     FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NAME_SUFFIX,   FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_PATHNAME_DNS,  FALSE,  FALSE,  TRUE,   FALSE,  NULL}
};

//
//  The offset of property in this array must be equal to
//  PROPID value - PROPID_Q_BASE
//

propValidity    QueueSetValidation[] =
{
    //                                       Must
    // Property              Allow   Must    Not     Maybe   Parsing
    // Ientifier             VT_NULL Appear  Appear  Ignored Procedure
    //-------------------------------------------------------------------------
    { 0,                     FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_INSTANCE,      FALSE,  FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_TYPE,          FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_PATHNAME,      FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_JOURNAL,       FALSE,  FALSE,  FALSE,  FALSE,  qJournalValidation},
    {PROPID_Q_QUOTA,         FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_BASEPRIORITY,  FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_JOURNAL_QUOTA, FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_LABEL,         FALSE,  FALSE,  FALSE,  FALSE,  qLabelValidation},
    {PROPID_Q_CREATE_TIME,   FALSE,  FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_MODIFY_TIME,   FALSE,  FALSE,  TRUE,   TRUE,   NULL},
    {PROPID_Q_AUTHENTICATE,  FALSE,  FALSE,  FALSE,  FALSE,  qAuthValidation},
    {PROPID_Q_PRIV_LEVEL,    FALSE,  FALSE,  FALSE,  FALSE,  qPrivLevelValidation},
    {PROPID_Q_TRANSACTION,   FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SCOPE,         FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_QMID,          FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_MASTERID,      FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SEQNUM,        FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_HASHKEY,       FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_LABEL_HASHKEY, FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NT4ID,         FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_FULL_PATH,     FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_DONOTHING,     FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NAME_SUFFIX,   FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_PATHNAME_DNS,  FALSE,  FALSE,  TRUE,   FALSE,  NULL}
};

//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_Q_BASE
//

propValidity    QueueGetValidation[] =
{
    //                                       Must
    // Property              Allow   Must    Not     Maybe   Parsing
    // Ientifier             VT_NULL Appear  Appear  Ignored Procedure
    //-------------------------------------------------------------------------
    { 0,                     TRUE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_INSTANCE,      TRUE,   FALSE,  FALSE,  TRUE,   qInstanceValidation},
    {PROPID_Q_TYPE,          TRUE,   FALSE,  FALSE,  FALSE,  qTypeValidation},
    {PROPID_Q_PATHNAME,      TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_JOURNAL,       TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_QUOTA,         TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_BASEPRIORITY,  TRUE,   FALSE,  FALSE,  TRUE,   NULL},
    {PROPID_Q_JOURNAL_QUOTA, TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_LABEL,         TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_CREATE_TIME,   TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_MODIFY_TIME,   TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_AUTHENTICATE,  TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_PRIV_LEVEL,    TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_TRANSACTION,   TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    {PROPID_Q_SCOPE,         FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_QMID,          FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_MASTERID,      FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_SEQNUM,        FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_HASHKEY,       FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_LABEL_HASHKEY, FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NT4ID,         FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_FULL_PATH,     FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_DONOTHING,     FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_NAME_SUFFIX,   FALSE,  FALSE,  TRUE,   FALSE,  NULL},
    {PROPID_Q_PATHNAME_DNS,  TRUE,   FALSE,  FALSE,  FALSE,  NULL}
};

VARTYPE QueueVarTypes[] =
{
    0,
    VT_CLSID,   //PROPID_Q_INSTANCE
    VT_CLSID,   //PROPID_Q_TYPE
    VT_LPWSTR,  //PROPID_Q_PATHNAME
    VT_UI1,     //PROPID_Q_JOURNAL
    VT_UI4,     //PROPID_Q_QUOTA
    VT_I2,      //PROPID_Q_BASEPRIORITY
    VT_UI4,     //PROPID_Q_JOURNAL_QUOTA
    VT_LPWSTR,  //PROPID_Q_LABEL
    VT_I4,      //PROPID_Q_CREATE_TIME
    VT_I4,      //PROPID_Q_MODIFY_TIME
    VT_UI1,     //PROPID_Q_AUTHENTICATE
    VT_UI4,     //PROPID_Q_PRIV_LEVEL
    VT_UI1,     //PROPID_Q_TRANSACTION
    VT_UI1,     //PROPID_Q_SCOPE
    VT_CLSID,   //PROPID_Q_QMID
    VT_CLSID,   //PROPID_Q_MASTERID
    VT_BLOB,    //PROPID_Q_SEQNUM
    VT_UI4,     //PROPID_Q_HASHKEY
    VT_UI4,     //PROPID_Q_LABEL_HASHKEY
    VT_CLSID,   //PROPID_Q_NT4ID
    VT_LPWSTR,  //PROPID_Q_FULL_PATH
    VT_UI1,     //PROPID_Q_DONOTHING
    VT_LPWSTR,  //PROPID_Q_NAME_SUFFIX
    VT_LPWSTR   //PROPID_Q_PATHNAME_DNS
};

VARTYPE GetQueuePropsVarTypes[] =
{
    0,
    VT_CLSID,   //PROPID_Q_INSTANCE
    VT_CLSID,   //PROPID_Q_TYPE
    VT_NULL,    //PROPID_Q_PATHNAME
    VT_UI1,     //PROPID_Q_JOURNAL
    VT_UI4,     //PROPID_Q_QUOTA
    VT_I2,      //PROPID_Q_BASEPRIORITY
    VT_UI4,     //PROPID_Q_JOURNAL_QUOTA
    VT_NULL,    //PROPID_Q_LABEL
    VT_I4,      //PROPID_Q_CREATE_TIME
    VT_I4,      //PROPID_Q_MODIFY_TIME
    VT_UI1,     //PROPID_Q_AUTHENTICATE
    VT_UI4,     //PROPID_Q_PRIV_LEVEL
    VT_UI1,     //PROPID_Q_TRANSACTION
    VT_UI1,     //PROPID_Q_SCOPE
    VT_CLSID,   //PROPID_Q_QMID
    VT_CLSID,   //PROPID_Q_MASTERID
    VT_NULL,    //PROPID_Q_SEQNUM
    VT_UI4,     //PROPID_Q_HASHKEY
    VT_UI4,     //PROPID_Q_LABEL_HASHKEY
    VT_CLSID,   //PROPID_Q_NT4ID
    VT_NULL,    //PROPID_Q_FULL_PATH
    VT_UI1,     //PROPID_Q_DONOTHING
    VT_NULL,    //PROPID_Q_NAME_SUFFIX
    VT_NULL     //PROPID_Q_PATHNAME_DNS
};

static
void
RemovePropWarnings(
    IN  MQQUEUEPROPS*  pqp,
    IN  HRESULT*       aStatus,
    OUT MQQUEUEPROPS** ppGoodProps,
    OUT char**         ppTmpBuff)
{
    DWORD i;
    DWORD cGoodProps;
    char *pTmpBuff;
    MQQUEUEPROPS *pGoodProps;
    HRESULT *pStatus;
    QUEUEPROPID *pPropId;
    MQPROPVARIANT *pPropVar;

    // See how many good properties do we have.
    for (i = 0, cGoodProps = 0, pStatus = aStatus;
         i < pqp->cProp;
         i++, pStatus++)
    {
        if (*pStatus != MQ_OK)
        {
            ASSERT(!FAILED(*pStatus));
        }
        else
        {
            cGoodProps++;
        }
    }

    // Allocate the temporary buffer, the buffer contains everything in it.
    // It contains the MQQUEUEPROPS structure, the QUEUEPROPID and
    // MQPROPVARIANT arrays.
    pTmpBuff = new char[sizeof(MQQUEUEPROPS) +
                        cGoodProps * sizeof(QUEUEPROPID) +
                        cGoodProps * sizeof(MQPROPVARIANT)];
    *ppTmpBuff = pTmpBuff;

    pGoodProps = (MQQUEUEPROPS*)pTmpBuff;
    *ppGoodProps = pGoodProps;

    // Initialize the MQQUEUEPROPS structure.
    pGoodProps->cProp = cGoodProps;
    pGoodProps->aPropID = (QUEUEPROPID*)(pTmpBuff + sizeof(MQQUEUEPROPS));
    pGoodProps->aPropVar = (MQPROPVARIANT*)(pTmpBuff + sizeof(MQQUEUEPROPS) +
                           cGoodProps * sizeof(QUEUEPROPID));

    // Copy the array entries of the good properties to the arrays in the
    // temporary buffer.
    for (i = 0, cGoodProps = 0, pStatus = aStatus,
            pPropId = pqp->aPropID, pPropVar = pqp->aPropVar;
         i < pqp->cProp;
         i++, pStatus++, pPropId++, pPropVar++)
    {
        if (*pStatus == MQ_OK)
        {
            pGoodProps->aPropID[cGoodProps] = *pPropId;
            pGoodProps->aPropVar[cGoodProps] = *pPropVar;
            cGoodProps++;
        }
    }
}

static DWORD g_dwNumberOfMustPropsInCreate = 0xffff;
static DWORD g_dwNumberOfMustPropsInSet = 0xffff;

HRESULT
RTpCheckQueueProps(
    IN  MQQUEUEPROPS*  pqp,
    IN  DWORD          dwOp,
    IN  BOOL           fPrivateQueue,
    OUT MQQUEUEPROPS** ppGoodQP,
    OUT char**         ppTmpBuff
    )
{
    HRESULT hr = MQ_OK;
    propValidity *ppropValidity = 0;
    DWORD dwNumberOfMustProps = 0;
    VARTYPE *QueuePropVars = 0;

    if (!pqp)
    {
        return(MQ_ERROR_ILLEGAL_MQQUEUEPROPS);
    }

    //
    //  Calculating the number of "must" properties for create and set
    //  this is done only once for each operation.
    //

    switch (dwOp)
    {
    case QUEUE_CREATE:
        ppropValidity = QueueCreateValidation;
        if (g_dwNumberOfMustPropsInCreate == 0xffff)
        {
            g_dwNumberOfMustPropsInCreate =
                CalNumberOfMust( QueueCreateValidation,
                                 PROPID_Q_PATHNAME_DNS - PROPID_Q_BASE + 1);
        }
        dwNumberOfMustProps = g_dwNumberOfMustPropsInCreate;
        QueuePropVars = QueueVarTypes;
        break;

    case QUEUE_SET_PROPS:
        ppropValidity = QueueSetValidation;
        if (g_dwNumberOfMustPropsInSet == 0xffff)
        {
            g_dwNumberOfMustPropsInSet =
                CalNumberOfMust( QueueSetValidation,
                                 PROPID_Q_PATHNAME_DNS - PROPID_Q_BASE + 1);
        }
        dwNumberOfMustProps = g_dwNumberOfMustPropsInSet;
        QueuePropVars = QueueVarTypes;
        break;

    case QUEUE_GET_PROPS:
        {
            //
            //  Clear all the pointers of VT_NULL variants
            //  and make the structure ready for RPC call
            //
            for (UINT i = 0; i < pqp->cProp; i++)
            {
                if (pqp->aPropVar[i].vt == VT_NULL)
                {
                    memset(&pqp->aPropVar[i].caub, 0, sizeof(CAUB));
                }
            }
        }

        ppropValidity = QueueGetValidation;
        dwNumberOfMustProps = 0;
        QueuePropVars = GetQueuePropsVarTypes;
        break;

    default:
        ASSERT(0);
        return MQ_ERROR;
    }

    HRESULT *aLocalStatus_buff = NULL;

    __try
    {
        __try
        {
            HRESULT *aLocalStatus;

            // We must have a status array, even if the user didn't pass one. This is in
            // order to be able to tell whether each propery is good or not.
            if (!pqp->aStatus)
            {
                aLocalStatus_buff = new HRESULT[pqp->cProp];
                aLocalStatus = aLocalStatus_buff;
            }
            else
            {
                aLocalStatus = pqp->aStatus;
            }

            hr = CheckProps(pqp->cProp,
                            pqp->aPropID,
                            pqp->aPropVar,
                            aLocalStatus,
                            PROPID_Q_BASE,
                            PROPID_Q_PATHNAME_DNS,
                            ppropValidity,
                            QueuePropVars,
                            fPrivateQueue,
                            dwNumberOfMustProps,
                            NULL);

            if (SUCCEEDED(hr))
            {
                if (hr != MQ_OK)
                {
                    // We have wornings, copy all the good properties to a temporary
                    // buffer so the DS will not have to handle duplicate properties etc.
                    RemovePropWarnings(pqp, aLocalStatus, ppGoodQP, ppTmpBuff);
                }
                else
                {
                    // All is perfectly well, we do not need a temporary buffer and all
                    // that overhead.
                    *ppGoodQP = pqp;
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing MQQUEUEPROPS structure")));
            hr = GetExceptionCode();
        }
    }
    __finally
    {
        delete[] aLocalStatus_buff;
    }

    return(hr);
}

class VALIDATION_CONTEXT
{
public:
    VALIDATION_CONTEXT();

    DWORD dwFlags;
    LPWSTR pwcsResponseStringToFree;
    LPWSTR pwcsAdminStringToFree;
    CACTransferBufferV2 *ptb;
    PMQSECURITY_CONTEXT pSecCtx;
};

typedef VALIDATION_CONTEXT *PVALIDATION_CONTEXT;

VALIDATION_CONTEXT::VALIDATION_CONTEXT() :
    dwFlags(0)
{
}

#define VALIDATION_SEND_FLAG_MASK           1
#define VALIDATION_SECURITY_CONTEXT_MASK    2
#define VALIDATION_RESP_FORMAT_MASK         4
#define VALIDATION_ADMIN_FORMAT_MASK        8

#define SEND_FLAG (((PVALIDATION_CONTEXT)pvContext)->dwFlags & VALIDATION_SEND_FLAG_MASK)
#define SECURITY_CONTEXT_FLAG (((PVALIDATION_CONTEXT)pvContext)->dwFlags & VALIDATION_SECURITY_CONTEXT_MASK)

#define FLAGS (((PVALIDATION_CONTEXT)pvContext)->dwFlags)
#define PTB (((PVALIDATION_CONTEXT)pvContext)->ptb)
#define PSECCTX (((PVALIDATION_CONTEXT)pvContext)->pSecCtx)

static HRESULT ParseMsgClass( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        //
        // Check if legal calss
        //
        if(!MQCLASS_IS_VALID(pVar->uiVal))
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI2;
    }
    PTB->old.pClass = &pVar->uiVal;

    return (MQ_OK);
}

static HRESULT ParseMsgId(PROPVARIANT* pVar, PVOID pvContext)
{
    if (pVar->caub.cElems != PROPID_M_MSGID_SIZE)
    {
        return (MQ_ERROR_ILLEGAL_PROPERTY_SIZE);
    }

    PTB->old.ppMessageID = (OBJECTID**) &pVar->caub.pElems;

    return (MQ_OK);
}

static HRESULT ParseMsgCorrelationId(PROPVARIANT* pVar, PVOID pvContext)
{
    if (pVar->caub.cElems != PROPID_M_CORRELATIONID_SIZE)
    {
        return (MQ_ERROR_ILLEGAL_PROPERTY_SIZE);
    }

    PTB->old.ppCorrelationID = &pVar->caub.pElems;

    return (MQ_OK);
}

static HRESULT ParseMsgPrio( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if ((pVar->bVal < MQ_MIN_PRIORITY) || (MQ_MAX_PRIORITY < pVar->bVal))
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PTB->old.pPriority = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSentTime( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PTB->old.pSentTime = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgVersion( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PTB->old.pulVersion = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgArrivedTime( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PTB->old.pArrivedTime = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDelivery( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if ((pVar->bVal != MQMSG_DELIVERY_EXPRESS) &&
            (pVar->bVal != MQMSG_DELIVERY_RECOVERABLE))
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PTB->old.pDelivery = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAck( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if(!MQMSG_ACKNOWLEDGMENT_IS_VALID(pVar->bVal))
        {
            //
            // Unknown ACK bits are on.
            //
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PTB->old.pAcknowledge = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgJoural( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if (pVar->bVal & ~(MQMSG_JOURNAL_NONE | MQMSG_DEADLETTER | MQMSG_JOURNAL))
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PTB->old.pAuditing = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAppSpec( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_UI4;
    }
    PTB->old.pApplicationTag = &pVar->ulVal;

    return (MQ_OK);
}


static HRESULT ParseMsgBody( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.ppBody = &pVar->caub.pElems;
    PTB->old.ulBodyBufferSizeInBytes = pVar->caub.cElems;
    PTB->old.ulAllocBodyBufferInBytes = PTB->old.ulBodyBufferSizeInBytes;

    return (MQ_OK);
}

static HRESULT ParseMsgBodySize( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pBodySize = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLabelSend( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(SEND_FLAG);

    DWORD dwSize = wcslen(pVar->pwszVal) +1;
    if ( dwSize > MQ_MAX_MSG_LABEL_LEN)
    {
        return MQ_ERROR_LABEL_TOO_LONG;
    }

    PTB->old.ulTitleBufferSizeInWCHARs = dwSize;
    PTB->old.ppTitle = &pVar->pwszVal;

    return (MQ_OK);
}


static HRESULT ParseMsgLabelReceive( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    PTB->old.ppTitle = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLabelLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pulTitleBufferSizeInWCHARs = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgRespQueueSend(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(SEND_FLAG);

    BOOL fSuccess;
    fSuccess = RTpFormatNameToQueueFormat(
                    pVar->pwszVal,
                    PTB->old.Send.pResponseQueueFormat,
                    &((PVALIDATION_CONTEXT)pvContext)->pwcsResponseStringToFree
                    );

    if(!fSuccess)
    {
        return(MQ_ERROR_ILLEGAL_FORMATNAME);
    }

    QUEUE_FORMAT_TYPE qft = PTB->old.Send.pResponseQueueFormat->GetType();
    if( (qft == QUEUE_FORMAT_TYPE_CONNECTOR) ||
        (PTB->old.Send.pResponseQueueFormat->Suffix() != QUEUE_SUFFIX_TYPE_NONE)
       )
    {
        return MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION;
    }

    FLAGS |= VALIDATION_RESP_FORMAT_MASK;
    return(MQ_OK);
}

static HRESULT ParseMsgRespQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    PTB->old.Receive.ppResponseFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgRespQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.Receive.pulResponseFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAdminQueueSend(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(SEND_FLAG);

    BOOL fSuccess;
    fSuccess = RTpFormatNameToQueueFormat(
                    pVar->pwszVal,
                    PTB->old.Send.pAdminQueueFormat,
                    &((PVALIDATION_CONTEXT)pvContext)->pwcsAdminStringToFree
                    );

    if(!fSuccess)
    {
        return(MQ_ERROR_ILLEGAL_FORMATNAME);
    }

    QUEUE_FORMAT_TYPE qft = PTB->old.Send.pAdminQueueFormat->GetType();
    if( (qft == QUEUE_FORMAT_TYPE_CONNECTOR) ||
        (PTB->old.Send.pAdminQueueFormat->Suffix() != QUEUE_SUFFIX_TYPE_NONE)
       )
    {
        return MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION;
    }

    FLAGS |= VALIDATION_ADMIN_FORMAT_MASK;
    return(MQ_OK);
}

static HRESULT ParseMsgAdminQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!SEND_FLAG);

    PTB->old.Receive.ppAdminFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgAdminQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.Receive.pulAdminFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!(SEND_FLAG));

    PTB->old.Receive.ppDestFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG));

    pVar->vt = VT_UI4;
    PTB->old.Receive.pulDestFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgXactStatusQueueReceive(PROPVARIANT* pVar, PVOID pvContext)
{
    ASSERT(!(SEND_FLAG));

    PTB->old.Receive.ppOrderingFormatName = &pVar->pwszVal;

    return (MQ_OK);
}

static HRESULT ParseMsgXactStatusQueueLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG));

    pVar->vt = VT_UI4;
    PTB->old.Receive.pulOrderingFormatNameLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSrcMachineId( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;
    PTB->old.ppSrcQMID = &pVar->puuid;

    return (MQ_OK);
}

static HRESULT ParseMsgTimeToLive( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        PTB->old.ulRelativeTimeToLive = pVar->ulVal ;
    }
    else
    {
        pVar->vt = VT_UI4;
        PTB->old.pulRelativeTimeToLive = &pVar->ulVal;
    }
    return (MQ_OK);
}

static HRESULT ParseMsgTimeToQueue( PROPVARIANT * pVar, PVOID pvContext )
{
    if(SEND_FLAG)
    {
        PTB->old.ulAbsoluteTimeToQueue = pVar->ulVal ;
    }
    else
    {
        pVar->vt = VT_UI4;
        PTB->old.pulRelativeTimeToQueue = &pVar->ulVal;
    }
    return (MQ_OK);
}

static HRESULT ParseMsgTrace( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if (pVar->bVal & ~(MQMSG_TRACE_NONE | MQMSG_SEND_ROUTE_TO_REPORT_QUEUE))
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI1;
    }
    PTB->old.pTrace = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgDestSymmKey( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.ppSymmKeys = &pVar->caub.pElems;
    PTB->old.ulSymmKeysSize = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgDestSymmKeyLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pulSymmKeysSizeProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSignature( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.ppSignature = &pVar->caub.pElems;
    PTB->old.ulSignatureSize = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgSignatureLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pulSignatureSizeProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderId( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.ppSenderID = &pVar->caub.pElems;
    PTB->old.uSenderIDLen = (WORD)((pVar->caub.cElems > 0xffff) ? 0xffff : pVar->caub.cElems);

    return (MQ_OK);
}

static HRESULT ParseMsgSenderIdLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pulSenderIDLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderIdType( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        if ((pVar->ulVal != MQMSG_SENDERID_TYPE_NONE) &&
            (pVar->ulVal != MQMSG_SENDERID_TYPE_SID))
        {
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        }
    }
    else
    {
        pVar->vt = VT_UI4;
    }

    PTB->old.pulSenderIDType = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderCert( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.ppSenderCert = &pVar->caub.pElems;
    PTB->old.ulSenderCertLen = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgSenderCertLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pulSenderCertLenProp = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgPrivLevel( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        switch (pVar->ulVal)
        {
        case MQMSG_PRIV_LEVEL_NONE:
        case MQMSG_PRIV_LEVEL_BODY_BASE:
            break;

        case MQMSG_PRIV_LEVEL_BODY_ENHANCED:
        {
            HRESULT hr = _SupportingServerNotMSMQ1() ;
            if (FAILED(hr))
            {
                return hr ;
            }
            break;
        }

        default:
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
            break;
        }
    }
    else
    {
        pVar->vt = VT_UI4;
    }

    PTB->old.pulPrivLevel = &pVar->ulVal;

    return(MQ_OK);
}

static HRESULT ParseMsgEncryptAlg( PROPVARIANT * pVar, PVOID pvContext )
{
    if (SEND_FLAG)
    {
        switch (pVar->ulVal)
        {
        case CALG_RC2:
        case CALG_RC4:
            break;

        default:
            return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
            break;
        }
    }

    PTB->old.pulEncryptAlg = &pVar->ulVal;

    return(MQ_OK);
}

static HRESULT ParseMsgAuthLevel( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(SEND_FLAG);

    switch (pVar->ulVal)
    {
    case MQMSG_AUTH_LEVEL_NONE:
    case MQMSG_AUTH_LEVEL_ALWAYS:
    case MQMSG_AUTH_LEVEL_MSMQ10:
    case MQMSG_AUTH_LEVEL_MSMQ20:
        break;

    default:
        return(MQ_ERROR_ILLEGAL_PROPERTY_VALUE);
        break;
    }

    PTB->old.ulAuthLevel = pVar->ulVal;

    return MQ_OK;
}

static HRESULT ParseMsgHashAlg( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.pulHashAlg = &pVar->ulVal;

    return(MQ_OK);
}

static HRESULT ParseMsgAuthenticated( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    if (PTB->old.pAuthenticated)
    {
        //
        // can not request both m_authenticated and m_authenticated_Ex
        //
        return MQ_ERROR_PROPERTY ;
    }

    pVar->vt = VT_UI1;
    PTB->old.pAuthenticated = &pVar->bVal;
    //
    // Tell driver we want only the m_authenticated property
    //
    *(PTB->old.pAuthenticated) = MQMSG_AUTHENTICATION_REQUESTED ;

    return (MQ_OK);
}

static HRESULT ParseMsgAuthenticatedEx( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    if (PTB->old.pAuthenticated)
    {
        //
        // can not request both m_authenticated and m_authenticated_Ex
        //
        return MQ_ERROR_PROPERTY ;
    }

    pVar->vt = VT_UI1;
    PTB->old.pAuthenticated = &pVar->bVal;
    //
    // Tell driver we want the m_authenticated_ex property
    //
    *(PTB->old.pAuthenticated) = MQMSG_AUTHENTICATION_REQUESTED_EX ;

    return (MQ_OK);
}

static HRESULT ParseMsgExtension( PROPVARIANT * pVar, PVOID pvContext)
{
    PTB->old.ppMsgExtension = &pVar->caub.pElems;
    PTB->old.ulMsgExtensionBufferInBytes = pVar->caub.cElems;

    return (MQ_OK);
}

static HRESULT ParseMsgExtensionLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI4;
    PTB->old.pMsgExtensionSize = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgSecurityContext( PROPVARIANT *pVar, PVOID pvContext )
{
    ASSERT(SEND_FLAG);

    //
    // RTDEP.DLL is not running on Win64 bit platform, so the fix below is just
    // for the 64 bit compiler, not to issue a warning. 
    //

    PMQSECURITY_CONTEXT pSecCtx = (PMQSECURITY_CONTEXT)(ULONG_PTR)pVar->ulVal;

    // NULL security context is ignored...
    if (pSecCtx == NULL) {
      return MQ_INFORMATION_PROPERTY_IGNORED;
    }
    else if (pSecCtx->dwVersion != SECURITY_CONTEXT_VER)
    {
        return(MQ_ERROR_BAD_SECURITY_CONTEXT);
    }

    PSECCTX = pSecCtx;
    FLAGS |= VALIDATION_SECURITY_CONTEXT_MASK;

    return(MQ_OK);
}

static HRESULT ParseMsgConnectorType( PROPVARIANT * pVar, PVOID pvContext )
{
    PTB->old.ppConnectorType = &pVar->puuid;

    return (MQ_OK);
}

static HRESULT ParseMsgBodyType( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_UI4;
    }
    PTB->old.pulBodyType = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgProviderType( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_UI4;
    }

    PTB->old.pulProvType = &pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgProviderName( PROPVARIANT * pVar, PVOID pvContext )
{
    if (!SEND_FLAG)
    {
        pVar->vt = VT_LPWSTR;
    }

    PTB->old.ppwcsProvName = &pVar->pwszVal;
    return (MQ_OK);
}

static HRESULT ParseMsgProviderNameLen( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!SEND_FLAG);

    pVar->vt = VT_UI4;
    PTB->old.pulAuthProvNameLenProp = &pVar->ulVal;
    PTB->old.ulProvNameLen = pVar->ulVal;

    return (MQ_OK);
}

static HRESULT ParseMsgFirstInXact( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI1;
    PTB->pbFirstInXact = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgLastInXact( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    pVar->vt = VT_UI1;
    PTB->pbLastInXact = &pVar->bVal;

    return (MQ_OK);
}

static HRESULT ParseMsgXactId( PROPVARIANT * pVar, PVOID pvContext )
{
    ASSERT(!(SEND_FLAG)) ;

    if (pVar->caub.cElems != PROPID_M_XACTID_SIZE)
    {
        return (MQ_ERROR_ILLEGAL_PROPERTY_SIZE);
    }

    PTB->ppXactID = (OBJECTID**) &pVar->caub.pElems;

    return (MQ_OK);
}

//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_M_BASE
//

propValidity    MessageSendValidation[] =
{
    //                                          Must
    // Property                 Allow   Must    Not     Maybe   Parsing
    // Identifier               VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_CLASS,           FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgClass},
    { PROPID_M_MSGID,           FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgId},
    { PROPID_M_CORRELATIONID,   FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgCorrelationId},
    { PROPID_M_PRIORITY,        FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgPrio},
    { PROPID_M_DELIVERY,        FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgDelivery},
    { PROPID_M_ACKNOWLEDGE,     FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgAck},
    { PROPID_M_JOURNAL,         FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgJoural},
    { PROPID_M_APPSPECIFIC,     FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgAppSpec},
    { PROPID_M_BODY,            FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgBody},
    { PROPID_M_BODY_SIZE,       FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_LABEL,           FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgLabelSend},
    { PROPID_M_LABEL_LEN,       FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_TIME_TO_REACH_QUEUE,FALSE,FALSE, FALSE,  FALSE,  ParseMsgTimeToQueue},
    { PROPID_M_TIME_TO_BE_RECEIVED,FALSE,FALSE, FALSE,  FALSE,  ParseMsgTimeToLive},
    { PROPID_M_RESP_QUEUE,      FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgRespQueueSend},
    { PROPID_M_RESP_QUEUE_LEN,  FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_ADMIN_QUEUE,     FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgAdminQueueSend},
    { PROPID_M_ADMIN_QUEUE_LEN, FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_VERSION,         FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SENDERID,        FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSenderId},
    { PROPID_M_SENDERID_LEN,    FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SENDERID_TYPE,   FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSenderIdType},
    { PROPID_M_PRIV_LEVEL,      FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgPrivLevel},
    { PROPID_M_AUTH_LEVEL,      FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgAuthLevel},
    { PROPID_M_AUTHENTICATED,   FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_HASH_ALG,        FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgHashAlg},
    { PROPID_M_ENCRYPTION_ALG,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgEncryptAlg},
    { PROPID_M_SENDER_CERT,     FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSenderCert},
    { PROPID_M_SENDER_CERT_LEN, FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SRC_MACHINE_ID,  FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SENTTIME,        FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_ARRIVEDTIME,     FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_DEST_QUEUE,      FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_DEST_QUEUE_LEN,  FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_EXTENSION,       FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgExtension},
    { PROPID_M_EXTENSION_LEN,   FALSE,  FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_M_SECURITY_CONTEXT,FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSecurityContext},
    { PROPID_M_CONNECTOR_TYPE,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgConnectorType},
    //                                          Must
    // Property                       Allow   Must    Not     Maybe   Parsing
    // Identifier                     VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------
    { PROPID_M_XACT_STATUS_QUEUE,      FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_XACT_STATUS_QUEUE_LEN,  FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_TRACE,                  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgTrace},
    { PROPID_M_BODY_TYPE,              FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgBodyType},
    { PROPID_M_DEST_SYMM_KEY,          FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgDestSymmKey},
    { PROPID_M_DEST_SYMM_KEY_LEN,      FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_SIGNATURE,              FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSignature},
    { PROPID_M_SIGNATURE_LEN,          FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_PROV_TYPE,              FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgProviderType},
    { PROPID_M_PROV_NAME,              FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgProviderName},
    { PROPID_M_PROV_NAME_LEN,          FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_FIRST_IN_XACT,          FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_LAST_IN_XACT,           FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_XACTID,                 FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_AUTHENTICATED_EX,       FALSE,  FALSE,  FALSE,  TRUE,   NULL}
};

//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_M_BASE
//

propValidity    MessageReceiveValidation[] =
{
    //                                          Must
    // Property                 Allow   Must    Not     Maybe   Parsing
    // Identifier               VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_CLASS,           TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgClass},
    { PROPID_M_MSGID,           FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgId},
    { PROPID_M_CORRELATIONID,   FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgCorrelationId},
    { PROPID_M_PRIORITY,        TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgPrio},
    { PROPID_M_DELIVERY,        TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgDelivery},
    { PROPID_M_ACKNOWLEDGE,     TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgAck},
    { PROPID_M_JOURNAL,         TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgJoural},
    { PROPID_M_APPSPECIFIC,     TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgAppSpec},
    { PROPID_M_BODY,            FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgBody},
    { PROPID_M_BODY_SIZE,       TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgBodySize},
    { PROPID_M_LABEL,           FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgLabelReceive},
    { PROPID_M_LABEL_LEN,       FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgLabelLen},
    { PROPID_M_TIME_TO_REACH_QUEUE,FALSE,FALSE,  FALSE,  FALSE, ParseMsgTimeToQueue},
    { PROPID_M_TIME_TO_BE_RECEIVED,FALSE,FALSE,  FALSE,  FALSE, ParseMsgTimeToLive},
    { PROPID_M_RESP_QUEUE,      FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgRespQueueReceive},
    { PROPID_M_RESP_QUEUE_LEN,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgRespQueueLen},
    { PROPID_M_ADMIN_QUEUE,     FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgAdminQueueReceive},
    { PROPID_M_ADMIN_QUEUE_LEN, FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgAdminQueueLen},
    { PROPID_M_VERSION,         FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgVersion},
    { PROPID_M_SENDERID,        FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSenderId},
    { PROPID_M_SENDERID_LEN,    TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderIdLen},
    { PROPID_M_SENDERID_TYPE,   TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderIdType},
    { PROPID_M_PRIV_LEVEL,      TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgPrivLevel},
    { PROPID_M_AUTH_LEVEL,      TRUE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_AUTHENTICATED,   TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgAuthenticated},
    { PROPID_M_HASH_ALG,        TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgHashAlg},
    { PROPID_M_ENCRYPTION_ALG,  TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgEncryptAlg},
    { PROPID_M_SENDER_CERT,     FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSenderCert},
    { PROPID_M_SENDER_CERT_LEN, TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgSenderCertLen},
    { PROPID_M_SRC_MACHINE_ID,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSrcMachineId},
    { PROPID_M_SENTTIME,        TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgSentTime},
    { PROPID_M_ARRIVEDTIME,     TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgArrivedTime},
    { PROPID_M_DEST_QUEUE,      FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgDestQueueReceive},
    { PROPID_M_DEST_QUEUE_LEN,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgDestQueueLen},
    { PROPID_M_EXTENSION,       FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgExtension},
    { PROPID_M_EXTENSION_LEN,   TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgExtensionLen},
    { PROPID_M_SECURITY_CONTEXT,TRUE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_M_CONNECTOR_TYPE,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgConnectorType},
    //                                          Must
    // Property                        Allow   Must    Not     Maybe   Parsing
    // Identifier                      VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------
    { PROPID_M_XACT_STATUS_QUEUE,      FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgXactStatusQueueReceive},
    { PROPID_M_XACT_STATUS_QUEUE_LEN,  FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgXactStatusQueueLen},
    { PROPID_M_TRACE,                  TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgTrace},
    { PROPID_M_BODY_TYPE,              TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgBodyType},
    { PROPID_M_DEST_SYMM_KEY,          FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgDestSymmKey},
    { PROPID_M_DEST_SYMM_KEY_LEN,      TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgDestSymmKeyLen},
    { PROPID_M_SIGNATURE,              FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgSignature},
    { PROPID_M_SIGNATURE_LEN,          TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgSignatureLen},
    { PROPID_M_PROV_TYPE,              TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderType},
    { PROPID_M_PROV_NAME,              FALSE,  FALSE,  FALSE,  FALSE,  ParseMsgProviderName},
    { PROPID_M_PROV_NAME_LEN,          TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgProviderNameLen},
    { PROPID_M_FIRST_IN_XACT,          TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgFirstInXact},
    { PROPID_M_LAST_IN_XACT,           TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgLastInXact},
    { PROPID_M_XACTID,                 TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgXactId},
    { PROPID_M_AUTHENTICATED_EX,       TRUE,   FALSE,  FALSE,  FALSE,  ParseMsgAuthenticatedEx}
};

VARTYPE MessageVarTypes[] =
{
    0,
    VT_UI2,                 //PROPID_M_CLASS
    VT_VECTOR | VT_UI1,     //PROPID_M_MSGID
    VT_VECTOR | VT_UI1,     //PROPID_M_CORRELATIONID
    VT_UI1,                 //PROPID_M_PRIORITY
    VT_UI1,                 //PROPID_M_DELIVERY
    VT_UI1,                 //PROPID_M_ACKNOWLEDGE
    VT_UI1,                 //PROPID_M_JOURNAL
    VT_UI4,                 //PROPID_M_APPSPECIFIC
    VT_VECTOR | VT_UI1,     //PROPID_M_BODY
    VT_UI4,                 //PROPID_M_BODY_SIZE
    VT_LPWSTR,              //PROPID_M_LABEL
    VT_UI4,                 //PROPID_M_LABEL_LEN  // BUGBUG not implemented yet
    VT_UI4,                 //PROPID_M_TIME_TO_REACH_QUEUE
    VT_UI4,                 //PROPID_M_TIME_TO_BE_RECEIVED
    VT_LPWSTR,              //PROPID_M_RESP_QUEUE
    VT_UI4,                 //PROPID_M_RESP_QUEUE_LEN
    VT_LPWSTR,              //PROPID_M_ADMIN_QUEUE
    VT_UI4,                 //PROPID_M_ADMIN_QUEUE_LEN
    VT_UI4,                 //PROPID_M_VERSION
    VT_VECTOR | VT_UI1,     //PROPID_M_SENDERID
    VT_UI4,                 //PROPID_M_SENDERID_LEN
    VT_UI4,                 //PROPID_M_SENDERID_TYPE
    VT_UI4,                 //PROPID_M_PRIV_LEVEL
    VT_UI4,                 //PROPID_M_AUTH_LEVEL
    VT_UI1,                 //PROPID_M_AUTHENTICATED
    VT_UI4,                 //PROPID_M_HASH_ALG
    VT_UI4,                 //PROPID_M_ENCRYPTION_ALG
    VT_VECTOR | VT_UI1,     //PROPID_M_SENDER_CERT
    VT_UI4,                 //PROPID_M_SENDER_CERT_LEN
    VT_CLSID,               //PROPID_M_SRC_MACHINE_ID
    VT_UI4,                 //PROPID_M_SENTTIME
    VT_UI4,                 //PROPID_M_ARRIVEDTIME
    VT_LPWSTR,              //PROPID_M_DEST_QUEUE
    VT_UI4,                 //PROPID_M_DEST_QUEUE_LEN
    VT_VECTOR | VT_UI1,     //PROPID_M_EXTENSION
    VT_UI4,                 //PROPID_M_EXTENSION_LEN
    VT_UI4,                 //PROPID_M_SECURITY_CONTEXT
    VT_CLSID,               //PROPID_M_CONNECTOR_TYPE
    VT_LPWSTR,              //PROPID_M_XACT_STATUS_QUEUE
    VT_UI4,                 //PROPID_M_XACT_STATUS_QUEUE_LEN
    VT_UI1,                 //PROPID_M_TRACE
    VT_UI4,                 //PROPID_M_BODY_TYPE
    VT_VECTOR | VT_UI1,     //PROPID_M_DEST_SYMM_KEY
    VT_UI4,                 //PROPID_M_DEST_SYMM_KEY_LEN
    VT_VECTOR | VT_UI1,     //PROPID_M_SIGNATURE
    VT_UI4,                 //PROPID_M_SIGNATURE_LEN
    VT_UI4,                 //PROPID_M_PROV_TYPE
    VT_LPWSTR,              //PROPID_M_PROV_NAME
    VT_UI4,                 //PROPID_M_PROV_NAME_LEN
    VT_UI1,                 //PROPID_M_FIRST_IN_XACT
    VT_UI1,                 //PROPID_M_LAST_IN_XACT
    VT_UI1|VT_VECTOR,       //PROPID_M_XACTID
    VT_UI1                  //PROPID_M_AUTHENTICATED_EX
};

#ifdef _DEBUG
//
// the following are complie time asserts, to verify the arrays size are
// correct and arrays include all properties.
//
#define _EXPECTEDSIZE  (PROPID_M_AUTHENTICATED_EX - PROPID_M_BASE + 1)
#define _SENDSIZE  (sizeof(MessageSendValidation) / sizeof(propValidity))
#define _RCVSIZE   (sizeof(MessageReceiveValidation) / sizeof(propValidity))
#define _VARSIZE   (sizeof(MessageVarTypes) / sizeof(VARTYPE))

static int MyAssert1[ _SENDSIZE == _EXPECTEDSIZE ] ;
static int MyAssert2[ _RCVSIZE  == _EXPECTEDSIZE ] ;
static int MyAssert3[ _VARSIZE  == _EXPECTEDSIZE ] ;

#undef _SENDSIZE
#undef _EXPECTEDSIZE
#undef _RCVSIZE
#undef _VARSIZE

#endif // _DEBUG

static DWORD g_dwNumberOfMustPropsInSend = 0xffff;
static DWORD g_dwNumberOfMustPropsInReceive = 0xffff;

HRESULT
RTpParseMessageProperties(
    LONG op,
    CACTransferBufferV2* ptb,
    IN DWORD cProp,
    IN PROPID *pPropid,
    IN PROPVARIANT *pVar,
    IN HRESULT *pStatus,
    OUT PMQSECURITY_CONTEXT *ppSecCtx,
    OUT LPWSTR* ppwcsResponseStringToFree,
    OUT LPWSTR* ppwcsAdminStringToFree
    )
{
    HRESULT hr;
    propValidity *ppropValidity;
    DWORD dwNumberOfMustProps;
    VALIDATION_CONTEXT ValidationContext;


    ASSERT((op == SEND_PARSE) || (op == RECV_PARSE));

    if (op == SEND_PARSE)
    {
        *ppSecCtx = NULL;
    }

    //
    //  Calculating the number of "must" properties for create and set
    //  this is done only once for each operation.
    //

    ValidationContext.dwFlags = 0;
    ValidationContext.pwcsResponseStringToFree = 0;
    ValidationContext.pwcsAdminStringToFree = 0;
    ValidationContext.ptb = ptb;

    if (op == SEND_PARSE)
    {
        ppropValidity = MessageSendValidation;
        if (g_dwNumberOfMustPropsInSend == 0xffff)
        {
            g_dwNumberOfMustPropsInSend =
                CalNumberOfMust( MessageSendValidation,
                                 PROPID_M_AUTHENTICATED_EX - PROPID_M_BASE + 1);
        }
        dwNumberOfMustProps = g_dwNumberOfMustPropsInSend;
        ValidationContext.dwFlags |= VALIDATION_SEND_FLAG_MASK;

        ptb->old.ulRelativeTimeToLive  = INFINITE ;
        ptb->old.ulAbsoluteTimeToQueue = g_dwTimeToReachQueueDefault ;
    }
    else
    {
        ppropValidity = MessageReceiveValidation;
        if (g_dwNumberOfMustPropsInReceive == 0xffff)
        {
            g_dwNumberOfMustPropsInReceive =
                CalNumberOfMust( MessageReceiveValidation,
                                 PROPID_M_AUTHENTICATED_EX - PROPID_M_BASE + 1);
        }
        dwNumberOfMustProps = g_dwNumberOfMustPropsInReceive;
    }

    __try
    {
        if(IsBadReadPtr(pVar, cProp * sizeof(PROPVARIANT)))
        {
            return MQ_ERROR_INVALID_PARAMETER;
        }

        hr = CheckProps(cProp,
                        pPropid,
                        pVar,
                        pStatus,
                        PROPID_M_BASE,
                        PROPID_M_AUTHENTICATED_EX,
                        ppropValidity,
                        MessageVarTypes,
                        TRUE,
                        dwNumberOfMustProps,
                        &ValidationContext);

        if (SUCCEEDED(hr))
        {
            //
            //  Special handling for body size and security properties
            //
            if (op == SEND_PARSE)
            {
                ASSERT(ppwcsResponseStringToFree);
                *ppwcsResponseStringToFree = ValidationContext.pwcsResponseStringToFree;
                ASSERT(ppwcsAdminStringToFree);
                *ppwcsAdminStringToFree = ValidationContext.pwcsAdminStringToFree;

                //
                // Special handling for class. If the calss is specified on send the
                // Connector type property is mandatory.
                //
                if ((ptb->old.pClass ||  ptb->old.ppSenderID || ptb->old.ppSymmKeys || ptb->old.ppSignature || ptb->old.ppwcsProvName) &&
                    !ptb->old.ppConnectorType)
                {
                    return MQ_ERROR_MISSING_CONNECTOR_TYPE;
                }

                if ((ptb->old.ppwcsProvName && !ptb->old.pulProvType) ||
                    (!ptb->old.ppwcsProvName && ptb->old.pulProvType))
                {
                    return MQ_ERROR_INSUFFICIENT_PROPERTIES;
                }
                //
                // If TimeToQueue is greater then TimeToLive then decrement
                // it to equal TimeToLive.
                //
                if ((ptb->old.ulAbsoluteTimeToQueue == INFINITE) ||
                   (ptb->old.ulAbsoluteTimeToQueue == LONG_LIVED))
                {
                  ptb->old.ulAbsoluteTimeToQueue = g_dwTimeToReachQueueDefault ;
                }

                if (ptb->old.ulRelativeTimeToLive != INFINITE)
                {
                  if (ptb->old.ulAbsoluteTimeToQueue > ptb->old.ulRelativeTimeToLive)
                  {
                     ptb->old.ulAbsoluteTimeToQueue = ptb->old.ulRelativeTimeToLive ;
                     ptb->old.ulRelativeTimeToLive = 0 ;
                  }
                  else
                  {
                     ptb->old.ulRelativeTimeToLive -= ptb->old.ulAbsoluteTimeToQueue ;
                  }
                }

                //
                // Conver TimeToQueue, which was relative until now,
                // to absolute
                //
                ULONG utime = MqSysTime() ;
                if (utime > (ptb->old.ulAbsoluteTimeToQueue + utime))
                {
                  //
                  // overflow. timeout too long.
                  //
                  ASSERT(INFINITE == 0xffffffff) ;
                  ASSERT(LONG_LIVED == 0xfffffffe) ;

                  ptb->old.ulAbsoluteTimeToQueue = LONG_LIVED - 1 ;
                }
                else
                {
                  ptb->old.ulAbsoluteTimeToQueue += utime ;
                }

                if (ValidationContext.dwFlags & VALIDATION_SECURITY_CONTEXT_MASK)
                {
                  *ppSecCtx = ValidationContext.pSecCtx;
                }

                if (! (ValidationContext.dwFlags & VALIDATION_RESP_FORMAT_MASK))
                {
                   ptb->old.Send.pResponseQueueFormat = 0;
                }
                if (! (ValidationContext.dwFlags & VALIDATION_ADMIN_FORMAT_MASK))
                {
                   ptb->old.Send.pAdminQueueFormat = 0;
                }

            }
            else if (op == RECV_PARSE)
            {
                if(ptb->old.Receive.ppResponseFormatName)
                {
                    if(!ptb->old.Receive.pulResponseFormatNameLenProp)
                    {
                        return(MQ_ERROR_INSUFFICIENT_PROPERTIES);
                    }
                    else  IF_USING_RPC
                    {
                        ptb->old.Receive.ulResponseFormatNameLen = min(
                            *ptb->old.Receive.pulResponseFormatNameLenProp,
                            ONE_KB
                            );
                    }
                }

                if(ptb->old.Receive.ppAdminFormatName)
                {
                    if(!ptb->old.Receive.pulAdminFormatNameLenProp)
                    {
                        return(MQ_ERROR_INSUFFICIENT_PROPERTIES);
                    }
                    else  IF_USING_RPC
                    {
                        ptb->old.Receive.ulAdminFormatNameLen = min(
                            *ptb->old.Receive.pulAdminFormatNameLenProp,
                            ONE_KB
                            );
                    }
                }

                if(ptb->old.Receive.ppDestFormatName)
                {
                    if(!ptb->old.Receive.pulDestFormatNameLenProp)
                    {
                        return(MQ_ERROR_INSUFFICIENT_PROPERTIES);
                    }
                    else  IF_USING_RPC
                    {
                        ptb->old.Receive.ulDestFormatNameLen = min(
                            *ptb->old.Receive.pulDestFormatNameLenProp,
                            ONE_KB
                            );
                    }
                }

                if(ptb->old.Receive.ppOrderingFormatName)
                {
                    if(!ptb->old.Receive.pulOrderingFormatNameLenProp)
                    {
                        return(MQ_ERROR_INSUFFICIENT_PROPERTIES);
                    }
                    else  IF_USING_RPC
                    {
                        ptb->old.Receive.ulOrderingFormatNameLen = min(
                            *ptb->old.Receive.pulOrderingFormatNameLenProp,
                            ONE_KB
                            );
                    }
                }

                if(ptb->old.ppTitle)
                {
                    if(!ptb->old.pulTitleBufferSizeInWCHARs)
                    {
                        return(MQ_ERROR_INSUFFICIENT_PROPERTIES);
                    }
                    else IF_USING_RPC
                    {
                        //
                        //  so title is allocated a buffer in
                        //  server. confine buffer size to our known limit.
                        //
                        ptb->old.ulTitleBufferSizeInWCHARs  = min(
                            *ptb->old.pulTitleBufferSizeInWCHARs,
                            MQ_MAX_MSG_LABEL_LEN
                            );
                    }
                }

                //
                // in case the provider name is required, the provider name
                // len property is a must.
                //
                if (ptb->old.ppwcsProvName)
                {
                    if (!ptb->old.pulAuthProvNameLenProp)
                    {
                        return(MQ_ERROR_INSUFFICIENT_PROPERTIES);
                    }
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing message properties.")));
        hr = GetExceptionCode();
    }

    return(hr);
}

//
//  The offset of property in this array must be equal to
//  PROPID valud - PROPID_QM_BASE
//

propValidity    GetQMValidation[] =
{
    //                                          Must
    // Property                 Allow   Must    Not     Maybe   Parsing
    // Ientifier                VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_SITE_ID,        TRUE,   FALSE,  FALSE,  FALSE,  qmSiteIdValidation},
    { PROPID_QM_MACHINE_ID,     TRUE,   FALSE,  FALSE,  FALSE,  qmMachineIdValidation},
    { PROPID_QM_PATHNAME,       TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_QM_CONNECTION,     TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_QM_ENCRYPTION_PK,  TRUE,   FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_ADDRESS,        TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_CNS,            TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OUTFRS,         TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_INFRS,          TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SERVICE,        TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_MASTERID,       TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_HASHKEY,        TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SEQNUM,         TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_QUOTA,          TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_JOURNAL_QUOTA,  TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_MACHINE_TYPE,   TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_CREATE_TIME,    TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_MODIFY_TIME,    TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_FOREIGN,        TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OS,             TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_FULL_PATH,      TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SITE_IDS,       TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OUTFRS_DN,      TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_INFRS_DN,       TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_NT4ID,          TRUE,   FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_DONOTHING,      TRUE,   FALSE,  TRUE,   TRUE,   NULL},

    //                                                 Must
    // Property                        Allow   Must    Not     Maybe   Parsing
    // Identifier                      VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------

    { PROPID_QM_SERVICE_ROUTING,        TRUE,  FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SERVICE_DSSERVER,       TRUE,  FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_SERVICE_DEPCLIENTS,     TRUE,  FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_OLDSERVICE,             TRUE,  FALSE,  TRUE,   TRUE,   NULL},
    { PROPID_QM_ENCRYPTION_PK_BASE,     TRUE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_ENCRYPTION_PK_ENHANCED, TRUE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_QM_PATHNAME_DNS,           TRUE,  FALSE,  FALSE,  FALSE,  NULL}
};

VARTYPE GetQMVarTypes[] =
{
    0,
    VT_CLSID,               //PROPID_QM_SITE_ID
    VT_CLSID,               //PROPID_QM_MACHINE_ID
    VT_NULL,                //PROPID_QM_PATHNAME
    VT_NULL,                //PROPID_QM_CONNECTION
    VT_NULL,                //PROPID_QM_ENCRYPTION_PK
    VT_BLOB,                //PROPID_QM_ADDRESS
    VT_CLSID|VT_VECTOR,     //PROPID_QM_CNS
    VT_CLSID|VT_VECTOR,     //PROPID_QM_OUTFRS
    VT_CLSID|VT_VECTOR,     //PROPID_QM_INFRS
    VT_UI4,                 //PROPID_QM_SERVICE
    VT_CLSID,               //PROPID_QM_MASTERID
    VT_UI4,                 //PROPID_QM_HASHKEY
    VT_BLOB,                //PROPID_QM_SEQNUM
    VT_UI4,                 //PROPID_QM_QUOTA
    VT_UI4,                 //PROPID_QM_JOURNAL_QUOTA
    VT_LPWSTR,              //PROPID_QM_MACHINE_TYPE
    VT_I4,                  //PROPID_QM_CREATE_TIME
    VT_I4,                  //PROPID_QM_MODIFY_TIME
    VT_UI1,                 //PROPID_QM_FOREIGN
    VT_UI4,                 //PROPID_QM_OS
    VT_LPWSTR,              //PROPID_QM_FULL_PATH
    VT_CLSID|VT_VECTOR,     //PROPID_QM_SITE_IDS
    VT_LPWSTR|VT_VECTOR,    //PROPID_QM_OUTFRS_DN
    VT_LPWSTR|VT_VECTOR,    //PROPID_QM_INFRS_DN
    VT_CLSID,               //PROPID_QM_NT4ID
    VT_UI1,                 //PROPID_QM_DONOTHING
    VT_UI1,                 //PROPID_QM_SERVICE_ROUTING
    VT_UI1,                 //PROPID_QM_SERVICE_DSSERVER
    VT_UI1,                 //PROPID_QM_SERVICE_DEPCLIENTS
    VT_UI4,                 //PROPID_QM_OLDSERVICE
    VT_NULL,                //PROPID_QM_ENCRYPTION_PK_BASE
    VT_NULL,                //PROPID_QM_ENCRYPTION_PK_ENHANCED
    VT_NULL                 //PROPID_QM_PATHNAME_DNS
};


HRESULT
RTpCheckQMProps(
    IN      MQQMPROPS * pQMProps,
    IN OUT  HRESULT*    aStatus,
    OUT     MQQMPROPS** ppGoodQMP,
    OUT     char**      ppTmpBuff)
{
    HRESULT hr = MQ_OK;

    __try
    {
        //
        //  The user must ask for atleast one property
        //
        if ( (pQMProps == NULL) ||
             (pQMProps->cProp == 0))
        {
            return(MQ_ERROR_ILLEGAL_MQQMPROPS);
        }

        hr = CheckProps(pQMProps->cProp,
                        pQMProps->aPropID,
                        pQMProps->aPropVar,
                        aStatus,
                        PROPID_QM_BASE,
                        LAST_QM_PROPID,
                        GetQMValidation,
                        GetQMVarTypes,
                        TRUE,
                        0,      // zero must properties
                        NULL);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing MQQMPROPS structure")));
        hr = GetExceptionCode();
    }

    if (SUCCEEDED(hr))
    {
        if (hr != MQ_OK)
        {
            // We have wornings, copy all the good properties to a temporary
            // buffer so the DS will not have to handle duplicate properties etc.
            RemovePropWarnings(
                (MQQUEUEPROPS*)pQMProps,
                aStatus,
                (MQQUEUEPROPS**)ppGoodQMP,
                ppTmpBuff);
        }
        else
        {
            // All is perfectly well, we do not need a temporary buffer and all
            // that overhead.
            *ppGoodQMP = pQMProps;
        }
    }

    return(hr);

}


HRESULT
RTpCheckRestrictionParameter(
    IN MQRESTRICTION* pRestriction)
{
    HRESULT hr = MQ_OK;

    if ( pRestriction == NULL)
    {
        return(MQ_OK);
    }

    __try
    {

        MQPROPERTYRESTRICTION * pPropRestriction = pRestriction->paPropRes;
        for ( DWORD i = 0; i < pRestriction->cRes; i++, pPropRestriction++)
        {
            if (( pPropRestriction->prop > PROPID_Q_PATHNAME_DNS) || ( pPropRestriction->prop <= PROPID_Q_BASE ))
            {
                return( MQ_ERROR_ILLEGAL_RESTRICTION_PROPID);
            }
            switch ( pPropRestriction->prop)
            {
                case PROPID_Q_LABEL:
                    hr = qLabelValidation( &pPropRestriction->prval, NULL);
                    break;
                case PROPID_Q_PATHNAME:
                    //
                    //  Multiple column props, not supported in restriction
                    //
                    hr =  MQ_ERROR_ILLEGAL_RESTRICTION_PROPID;
                    break;
                default:
                    break;
            }
            if (FAILED(hr))
            {
                break;
            }

            //
            // SP4- bug# 3009, SP4SS: exception on server when call MQlocatebegin
            // Fix: validate Restriction VT.
            //                      Uri Habusha, 17-Jun-98
            //
            DWORD Index = pPropRestriction->prop - PROPID_Q_BASE;
            if (pPropRestriction->prval.vt != QueueVarTypes[Index])
            {
                hr = MQ_ERROR_ILLEGAL_PROPERTY_VT;
                break;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing restriction structure")));
        hr = GetExceptionCode();
    }

    return(hr);
}

HRESULT
RTpCheckSortParameter(
    IN MQSORTSET* pSort)
{
    HRESULT hr = MQ_OK;

    if ( pSort == NULL)
    {
        return(MQ_OK);
    }


    __try
    {

        MQSORTKEY * pSortKey = pSort->aCol;
        for ( DWORD i = 0; i < pSort->cCol; i++, pSortKey++)
        {
            if (( pSortKey->propColumn > PROPID_Q_PATHNAME_DNS) || ( pSortKey->propColumn <= PROPID_Q_BASE ))
            {
                return( MQ_ERROR_ILLEGAL_SORT_PROPID);
            }
            switch ( pSortKey->propColumn)
            {
                case PROPID_Q_PATHNAME:
                    //
                    //  Multiple column props, not supported in sort
                    //
                    return(MQ_ERROR_ILLEGAL_SORT_PROPID);
                    break;
                default:
                    break;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing sort structure")));
        hr = GetExceptionCode();
    }

    return(hr);
}

HRESULT
RTpCheckLocateNextParameter(
    IN DWORD		cPropsRead,
    IN PROPVARIANT  aPropVar[]
	)
{
	//
	//	validate that the aPropVar buffer supplied by the
	//	user match the size it had specified
	//
	HRESULT hr = MQ_OK;
    __try
    {
        if(IsBadWritePtr(aPropVar, cPropsRead * sizeof(PROPVARIANT)))
        {
            return MQ_ERROR_INVALID_PARAMETER;
        }
	}
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while Locate Next parameters.")));
        hr = MQ_ERROR_INVALID_PARAMETER;
    }
	return hr;

}

//
//  The offset of property in this array must be equal to
//  PROPID value - starting with  FIRST_PRIVATE_COMPUTER_PROPID
//

propValidity    GetPrivateComputerValidation[] =
{
    //                                          Must
    // Property                 Allow   Must    Not     Maybe   Parsing
    // Ientifier                VT_NULL Appear  Appear  Ignored Procedure
    //------------------------------------------------------------------------
    { 0,                        FALSE,  FALSE,  FALSE,  TRUE,   NULL},
    { PROPID_PC_VERSION,        TRUE,   FALSE,  FALSE,  FALSE,  NULL},
    { PROPID_PC_DS_ENABLED,     TRUE,   FALSE,  FALSE,  FALSE,  NULL},
};

VARTYPE GetPrivateComputerVarTypes[] =
{
    0,
    VT_UI4,                 //PROPID_PC_VERSION
    VT_BOOL,                //PROPID_PC_DS_ENABLED
};


//---------------------------------------------------------
//
//  RTpCheckComputerProps(...)
//
//  Description:
//
//  validates pLocalProps parameter values
//
//  Return Value:
//
//      HRESULT success code
//
//---------------------------------------------------------
HRESULT
RTpCheckComputerProps(
    IN      MQPRIVATEPROPS * pPrivateProps,
    IN OUT  HRESULT*    aStatus
	)
{
    HRESULT hr = MQ_OK;

    __try
    {
        //
        //  The user must ask for atleast one property
        //
        if ( (pPrivateProps == NULL) ||
             (pPrivateProps->cProp == 0))
        {
            return(MQ_ERROR_ILLEGAL_MQPRIVATEPROPS);
        }

        hr = CheckProps(pPrivateProps->cProp,
                        pPrivateProps->aPropID,
                        pPrivateProps->aPropVar,
                        aStatus,
                        FIRST_PRIVATE_COMPUTER_PROPID,
                        LAST_PRIVATE_COMPUTER_PROPID,
                        GetPrivateComputerValidation,
                        GetPrivateComputerVarTypes,
                        TRUE,	// fCheckForIgnoredProps
                        0,      // zero must properties
                        NULL);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR, TEXT("Exception while parsing MQPRIVATEPROPS structure")));
        hr = GetExceptionCode();
    }

    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\qmrt.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    qmrt.cpp

Abstract:



Author:

    Boaz Feldbaum (BoazF) Mar 5, 1996

Revision History:

--*/

#include "stdh.h"
#include "rtprpc.h"
#include "_registr.h"

#include "qmrt.tmh"

GUID g_guidSupportQmGuid = GUID_NULL ;

static
void
GetSecurityDescriptorSize(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPDWORD lpdwSecurityDescriptorSize)
{
    if (pSecurityDescriptor)
    {
        ASSERT(IsValidSecurityDescriptor(pSecurityDescriptor));
        *lpdwSecurityDescriptorSize = GetSecurityDescriptorLength(pSecurityDescriptor);
    }
    else
    {
        *lpdwSecurityDescriptorSize = 0;
    }
}

HRESULT
QMCreateObject(
    /* in */ DWORD dwObjectType,
    /* in */ LPCWSTR lpwcsPathName,
    /* in */ PSECURITY_DESCRIPTOR pSecurityDescriptor,
    /* in */ DWORD cp,
    /* in */ PROPID aProp[],
    /* in */ PROPVARIANT apVar[])
{
    DWORD dwSecurityDescriptorSize;

    GetSecurityDescriptorSize(pSecurityDescriptor, &dwSecurityDescriptorSize);

	if(tls_hBindRpc == 0)
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;

		return(QMCreateObjectInternal(tls_hBindRpc,
                                  dwObjectType,
                                  lpwcsPathName,
                                  dwSecurityDescriptorSize,
                                  (unsigned char *)pSecurityDescriptor,
                                  cp,
                                  aProp,
                                  apVar));
}

HRESULT
QMCreateDSObject(
    /* in  */ DWORD dwObjectType,
    /* in  */ LPCWSTR lpwcsPathName,
    /* in  */ PSECURITY_DESCRIPTOR pSecurityDescriptor,
    /* in  */ DWORD cp,
    /* in  */ PROPID aProp[],
    /* in  */ PROPVARIANT apVar[],
    /* out */ GUID       *pObjGuid )
{
    DWORD dwSecurityDescriptorSize;

    GetSecurityDescriptorSize(pSecurityDescriptor, &dwSecurityDescriptorSize);

	if(tls_hBindRpc == 0)
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;

		HRESULT hr = QMCreateDSObjectInternal( tls_hBindRpc,
                                           dwObjectType,
                                           lpwcsPathName,
                                           dwSecurityDescriptorSize,
                                   (unsigned char *)pSecurityDescriptor,
                                           cp,
                                           aProp,
                                           apVar,
                                           pObjGuid );
    return hr ;
}

HRESULT
QMSetObjectSecurity(
    /* in */ OBJECT_FORMAT* pObjectFormat,
    /* in */ SECURITY_INFORMATION SecurityInformation,
    /* in */ PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    DWORD dwSecurityDescriptorSize;

    GetSecurityDescriptorSize(pSecurityDescriptor, &dwSecurityDescriptorSize);

	if(tls_hBindRpc == 0)
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;

    return(QMSetObjectSecurityInternal(tls_hBindRpc,
                                       pObjectFormat,
                                       SecurityInformation,
                                       dwSecurityDescriptorSize,
                                       (unsigned char *)pSecurityDescriptor));
}

//+------------------------------------------------------------
//
//  HRESULT RTpGetSupportServerInfo(BOOL *pfRemote)
//
//+------------------------------------------------------------

HRESULT RTpGetSupportServerInfo(BOOL *pfRemote)
{
	DWORD dwSize;
	DWORD dwType;
	LONG  rc;

	ASSERT(pfRemote);
	*pfRemote = g_fDependentClient;

	if (!g_fDependentClient)
	{
		return MQ_OK;
	}

	INIT_RPC_HANDLE ;

	if(tls_hBindRpc == 0)
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;

	LPWSTR  lpStr = NULL;
	HRESULT hr    = MQ_ERROR_SERVICE_NOT_AVAILABLE;

	try
	{
		hr = QMQueryQMRegistryInternal( 
					tls_hBindRpc,
					QueryRemoteQM_MQISServers,
					&lpStr 
					);
	}
	catch(...)
	{
		// Guard against net problem. Do nothing.
		//
		return MQ_ERROR_SERVICE_NOT_AVAILABLE;
	}

	if (hr == MQ_OK)
	{
		ASSERT(lpStr);
		//
		// Write to registry.
		//
		dwSize = wcslen(lpStr) *sizeof(WCHAR);
		dwType = REG_SZ;
		rc = SetFalconKeyValue( 
					MSMQ_DS_SERVER_REGNAME,
					&dwType,
					lpStr,
					&dwSize
					);
		ASSERT(rc == ERROR_SUCCESS);
		delete lpStr;
		lpStr = NULL;
	}

	hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;

	try
	{
		hr = QMQueryQMRegistryInternal( 
					tls_hBindRpc,
					QueryRemoteQM_LongLiveDefault,
					&lpStr 
					);
	}
	catch(...)
	{
		// Guard against net problem. Do nothing.
		//
		return  MQ_ERROR_SERVICE_NOT_AVAILABLE;
	}

	if (hr == MQ_OK)
	{
		ASSERT(lpStr);
		//
		// Write to registry.
		//
		dwSize = sizeof(DWORD);
		dwType = REG_DWORD;
		DWORD dwValue = (DWORD) _wtol(lpStr);
		rc = SetFalconKeyValue( 
				MSMQ_LONG_LIVE_REGNAME,
				&dwType,
				&dwValue,
				&dwSize
				);
		ASSERT(rc == ERROR_SUCCESS);
		delete lpStr;
		lpStr = NULL;
	}

	hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;

	try
	{
		hr = QMQueryQMRegistryInternal( 
				tls_hBindRpc,
				QueryRemoteQM_EnterpriseGUID,
				&lpStr 
				);
	}
	catch(...)
	{
		// Guard against net problem. Do nothing.
		//
		return  MQ_ERROR_SERVICE_NOT_AVAILABLE;
	}

	if (hr == MQ_OK)
	{
		ASSERT(lpStr);
		//
		// Write to registry.
		//
		GUID guidEnterprise;
		RPC_STATUS st = UuidFromString(lpStr, &guidEnterprise);
		if (st == RPC_S_OK)
		{
			dwSize = sizeof(GUID);
			dwType = REG_BINARY;
			rc = SetFalconKeyValue( 
					MSMQ_ENTERPRISEID_REGNAME,
					&dwType,
					&guidEnterprise,
					&dwSize
					);
			ASSERT(rc == ERROR_SUCCESS);
		}
		delete lpStr;
		lpStr = NULL;
	}

	hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;

	try
	{
		hr = QMQueryQMRegistryInternal( 
				tls_hBindRpc,
				QueryRemoteQM_ServerQmGUID,
				&lpStr 
				);
	}
	catch(...)
	{
		// Guard against net problem. Do nothing.
		//
		return  MQ_ERROR_SERVICE_NOT_AVAILABLE;
	}

	if (hr == MQ_OK)
	{
		ASSERT(lpStr);
		RPC_STATUS st = UuidFromString(lpStr, &g_guidSupportQmGuid);

		ASSERT(st == RPC_S_OK);
		DBG_USED(st);

		//
		// Write Supporting Server QmGuid to SUPPORT_SERVER_QMID registry.
		// This value will be used by ad to check the supporting server AD environment.
		//
		dwType = REG_BINARY;
		dwSize = sizeof(GUID);

		rc = SetFalconKeyValue( 
						MSMQ_SUPPORT_SERVER_QMID_REGNAME,
						&dwType,
						&g_guidSupportQmGuid,
						&dwSize
						);

		ASSERT(rc == ERROR_SUCCESS);

		delete lpStr;
		lpStr = NULL;
	}
	else if (hr == MQ_ERROR)
	{
		//
		// don't return error here, as this query is not supported by previous
		// versions of msmq.
		//
		hr = MQ_OK;
	}

	return hr;
}


HRESULT
QMSendMessage(
    IN handle_t hBind,
    IN QUEUEHANDLE  hQueue,
    IN CACTransferBufferV2 *pCacTB)
{
    HRESULT hr = MQ_OK;
    LPWSTR pwcsLongFormatName = NULL;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            WCHAR pwcsShortFormatName[64];
            LPWSTR pwcsFormatName = pwcsShortFormatName;
            DWORD dwFormatNameLen = sizeof(pwcsShortFormatName) / sizeof(WCHAR);

            //
            // The format name of the queue should be passed to the QM
            // because it can't use the handle of the application. The
            // QM will then have to open the queue for each message.
            // But this shouldn't be too expansive because the queue
            // should be already opened and the queue's properties sohuld
            // be cached in the QM.
            //
            hr = DepHandleToFormatName(hQueue, pwcsFormatName, &dwFormatNameLen);
            if (FAILED(hr))
            {
                if (hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
                {
                    pwcsLongFormatName = new WCHAR[dwFormatNameLen];
                    pwcsFormatName = pwcsLongFormatName;
                    hr = DepHandleToFormatName(hQueue, pwcsFormatName, &dwFormatNameLen);
                    if (FAILED(hr))
                    {
                        ASSERT(hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL);
                        return hr;
                    }
                }
                else
                {
                    return hr;
                }
            }

            //
            // Convert the queue format name into a QUEUE_FORMAT
            //
            QUEUE_FORMAT QueueFormat;
            BOOL bRet;

            bRet = RTpFormatNameToQueueFormat(pwcsFormatName,
                                              &QueueFormat,
                                              &pStringToFree);
            //
            // RTpFormatNameToQueueFormat must succeed because we got
            // the format name from DepHandleToFormatName.
            //
            ASSERT(bRet);

            //
            // Now ask the QM to do the security operations and send
            // the message to the device driver.
            //
            ASSERT(hBind) ;
			OBJECTID * pMessageId = ( pCacTB->old.ppMessageID != NULL) ? *pCacTB->old.ppMessageID : NULL;
            hr = QMSendMessageInternalEx(
				hBind,
				&QueueFormat,
				pCacTB,
				pMessageId);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            hr = GetExceptionCode();
            if (SUCCEEDED(hr))
            {
                hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] pwcsLongFormatName;
        delete[] pStringToFree;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtfrebnd.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    rtfrebnd.h

Abstract:
    Free binding handles

Author:
    Doron Juster  (DoronJ)

--*/

#ifndef __FREEBIND_H
#define __FREEBIND_H

#include "cs.h"

#define  MAX_NUMOF_RPC_HANDLES   512

//---------------------------------------------------------
//
//  class CFreeRPCHandles
//
//---------------------------------------------------------

class CFreeRPCHandles
{
public:
    CFreeRPCHandles() ;

    void Add(handle_t hBind) ;
    void FreeAll() ;

private:
    CCriticalSection      m_cs;

    DWORD                 m_dwIndex ;
    handle_t              m_ahBind[ MAX_NUMOF_RPC_HANDLES ] ;
};


inline  CFreeRPCHandles::CFreeRPCHandles()
{
    m_dwIndex = 0 ;
}

inline void CFreeRPCHandles::Add(handle_t hBind)
{
    CS Lock(m_cs) ;

    ASSERT(m_dwIndex < MAX_NUMOF_RPC_HANDLES);
    if (hBind && (m_dwIndex < MAX_NUMOF_RPC_HANDLES))
    {
        m_ahBind[ m_dwIndex ] = hBind ;
        m_dwIndex++ ;
    }
}

inline void CFreeRPCHandles::FreeAll()
{
    DWORD dwIndex ;

    //
    // Use of lock:
    // The "Add" method is called from THREAD_DETACH. We don't want
    // THREAD_DETACH to be locked while this thread run in the loop below.
    // Therefore, we only get the loop count inside a lock and reset it
    // only if not changed.
    //

    {
      CS Lock(m_cs) ;
      dwIndex = m_dwIndex ;
    }

    for ( DWORD i = 0 ; i < dwIndex ; i++ )
    {
        handle_t hBind = m_ahBind[ i ] ;
        if (hBind)
        {
            mqrpcUnbindQMService( &hBind,
                                  NULL ) ;
        }

        m_ahBind[ i ] = NULL ;
    }

    {
      CS Lock(m_cs) ;
      if (dwIndex == m_dwIndex)
      {
         //
         // Index not changed by calling "Add" while this thread run in the
         // above loop.
         //
         m_dwIndex = 0 ;
      }
    }
}

#endif  //  __FREEBIND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\queue.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    queue.cpp

Abstract:

    This module contains code involved with Queue APIs.

Author:

    Erez Haba (erezh) 24-Dec-95

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include "acrt.h"
#include <ad.h>
#include "rtprpc.h"
#include "rtsecutl.h"
#include <mqdsdef.h>

#include "queue.tmh"

static WCHAR *s_FN=L"rtdep/queue";

#define MQ_VALID_ACCESS (MQ_RECEIVE_ACCESS | MQ_PEEK_ACCESS | MQ_SEND_ACCESS | MQ_ADMIN_ACCESS)

//
// Data needed for licensing
//
extern GUID   g_LicGuid ;
extern BOOL   g_fLicGuidInit ;
extern DWORD  g_dwOperatingSystem;


inline
BOOL
IsLegalDirectFormatNameOperation(
    const QUEUE_FORMAT* pQueueFormat
    )
//
// Function Description:
//      The routines checks if the queue operation is leggal with
//      the direct format name. Due "Workgroup" support, we allowed
//      direct format name for local private queue.
//
// Arguments:
//      pQueueFormat - pointer to format name object
//
// Returned value:
//      TRUE if the format name is valid, FALSE otherwise
//
{
    ASSERT(pQueueFormat->GetType() == QUEUE_FORMAT_TYPE_DIRECT);

    if (pQueueFormat->Suffix() != QUEUE_SUFFIX_TYPE_NONE)
        return FALSE;

    //
    // check that the direct format name is for private queue. Queue
    // locallity will be checked by the QM
    //
    LPCWSTR DirectFormatname = pQueueFormat->DirectID();
    LPWSTR pTemp = wcschr(DirectFormatname, L'\\');
    ASSERT(pTemp != NULL);

    return (_wcsnicmp(pTemp+1,
                      PRIVATE_QUEUE_PATH_INDICATIOR,
                      PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH) == 0);

}


//
//  This function is called whenever really path name is needed.
//
//  MQDeleteQueue, MQSetQueueProperties, MQGetQueueProperties
//  MQGetQueueSecurity, MQSetQueueSecurity
//
inline BOOL IsLegalFormatNameOperation(const QUEUE_FORMAT* pQueueFormat)
{
    switch(pQueueFormat->GetType())
    {
        case QUEUE_FORMAT_TYPE_PRIVATE:
        case QUEUE_FORMAT_TYPE_PUBLIC:
            return (pQueueFormat->Suffix() == QUEUE_SUFFIX_TYPE_NONE);

        case QUEUE_FORMAT_TYPE_DIRECT:
            return IsLegalDirectFormatNameOperation(pQueueFormat);

        default:
            return FALSE;
    }
}


HRESULT
rtOpenQueue( handle_t      hBind,
             QUEUE_FORMAT* pQueueFormat,
             DWORD         dwCallingProcessID,
             DWORD         dwDesiredAccess,
             DWORD         dwShareMode,
             HANDLE32     hRemoteQueue,
             LPWSTR*       lplpRemoteQueueName,
             DWORD*        dwpQueue,
             DWORD*            pdwQMContext,
             RPC_QUEUE_HANDLE* phQueue,
             DWORD             dwRemoteProtocol,
             DWORD             dwpRemoteContext = 0)
{
   if (!g_fLicGuidInit)
   {
      //
      // bad initialization. Can't open queue without guid for license.
      //
      ASSERT(0) ;
      return MQ_ERROR ;
   }

   if ((g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ||
       (g_fDependentClient))
   {
      HANDLE hThread ;
      RegisterRpcCallForCancel( &hThread, 0 ) ;

      HRESULT hr = rpc_QMOpenQueueInternal( hBind,
                                            pQueueFormat,
                                            dwDesiredAccess,
                                            dwShareMode,
                                            (DWORD)hRemoteQueue,
                                            lplpRemoteQueueName,
                                            dwpQueue,
                                           &g_LicGuid,
                                            g_lpwcsLocalComputerName,
                                            pdwQMContext,
                                            phQueue,
                                            dwRemoteProtocol,
                                            dwpRemoteContext );

      UnregisterRpcCallForCancel( hThread ) ;
      return hr ;
   }
   else
   {
	   ASSERT(("trying to access a local QM in rtdep.dll", false));
	   return MQ_ERROR;
      //
      //  NT working with local device driver
      //
      /*return  QMOpenQueueInternal(  hBind,
                                    pQueueFormat,
                                    dwCallingProcessID,
                                    dwDesiredAccess,
                                    dwShareMode,
                                    (DWORD) hRemoteQueue,
                                    lplpRemoteQueueName,
                                    dwpQueue,
                                    (DWORD *)phQueue,
                                    dwRemoteProtocol,
                                    dwpRemoteContext );
   */
   }
}


EXTERN_C
HRESULT
APIENTRY
DepOpenQueue(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    OUT QUEUEHANDLE* phQueue
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;
    LPWSTR pStringToFree = NULL;
    LPWSTR lpRemoteQueueName = NULL;
    LPMQWIN95_QHANDLE ph95 = NULL ;
    DWORD  dwQMContext = 0 ;

    __try
    {
        __try
        {
            if ((g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ||
                (g_fDependentClient))
            {
               ph95 = new MQWIN95_QHANDLE ;
               ASSERT(ph95) ;
            }

            *phQueue = NULL ;
            INIT_RPC_HANDLE ;

            //
            // Check validity of access mode.
            // 1. Check that only legal bits are turned on.
            // 2. Check that only legal access combinations are used.
            //
            if ((dwDesiredAccess & ~MQ_VALID_ACCESS) ||
                !(dwDesiredAccess & MQ_VALID_ACCESS))

            {
               //
               // Ilegal bits are turned on.
               //
               rc = MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;
               __leave ;
            }
            else if (dwDesiredAccess != MQ_SEND_ACCESS)
            {
               if (dwDesiredAccess & MQ_SEND_ACCESS)
               {
                  //
                  // A queue can't be open for both send and receive.
                  //
                  rc = MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;
                  __leave ;
               }
            }

           if ((dwShareMode & MQ_DENY_RECEIVE_SHARE) &&
               (dwDesiredAccess & MQ_SEND_ACCESS))
           {
               //
               // not supporting SEND_ACCESS with DENY_RECEIVE.
               //
               rc = MQ_ERROR_UNSUPPORTED_ACCESS_MODE ;
               __leave ;
            }

            QUEUE_FORMAT QueueFormat;
            DWORD  dwpRemoteQueue = 0 ;

            if (dwDesiredAccess & MQ_SEND_ACCESS)
            {
               if (!g_pSecCntx)
               {
                  InitSecurityContext() ;
               }
            }

            if (!RTpFormatNameToQueueFormat(
                    lpwcsFormatName,
                    &QueueFormat,
                    &pStringToFree))
            {
                rc = MQ_ERROR_ILLEGAL_FORMATNAME;
                __leave ;
            }

			if(tls_hBindRpc == 0)
				return MQ_ERROR_SERVICE_NOT_AVAILABLE;

            rc = rtOpenQueue(tls_hBindRpc,
                             &QueueFormat,
                             GetCurrentProcessId(),
                             dwDesiredAccess,
                             dwShareMode,
                             NULL,
                             &lpRemoteQueueName,
                             &dwpRemoteQueue,
                             &dwQMContext,
                             phQueue,
                             0 );

            if ((rc == MQ_OK) && lpRemoteQueueName)
            {
               *phQueue = NULL ;
               //
               // remote reader. Call remote QM.
               //
               HANDLE32 hRemoteQueue = 0 ;
               PCTX_OPENREMOTE_HANDLE_TYPE phContext = NULL ;
               DWORD  dwpContext = 0 ;
               dwpRemoteQueue = 0 ;                                        \
               rc = MQ_ERROR_SERVICE_NOT_AVAILABLE ;
               DWORD dwProtocol = 0 ;

               CALL_REMOTE_QM(lpRemoteQueueName,
                              rc, (QMOpenRemoteQueue(
                                         hBind,
                                         &phContext,
                                         &dwpContext,
                                         &QueueFormat,
                                         GetCurrentProcessId(),
                                         dwDesiredAccess,
                                         dwShareMode,
                                         &g_LicGuid,
                                         g_dwOperatingSystem,
                                         &dwpRemoteQueue,
                                         (DWORD*)&hRemoteQueue)) ) ;

               // Now open a local queue which will point to the
               // remote one.
               //
               if (rc == MQ_OK)
               {
                  ASSERT(dwpRemoteQueue) ;
                  ASSERT(hRemoteQueue) ;
                  ASSERT(dwpContext) ;

                  ASSERT(tls_hBindRpc) ;
                  rc = rtOpenQueue( tls_hBindRpc,
                                    &QueueFormat,
                                    GetCurrentProcessId(),
                                    dwDesiredAccess,
                                    dwShareMode,
                                    hRemoteQueue,
                                    NULL,
                                    &dwpRemoteQueue,
                                    &dwQMContext,
                                    phQueue,
                                    dwProtocol,
                                    dwpContext );

                  QMCloseRemoteQueueContext( &phContext ) ;
               }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] lpRemoteQueueName;
        delete[] pStringToFree;
    }

    if (SUCCEEDED(rc))
    {
        ASSERT(*phQueue) ;

        if ((g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ||
            (g_fDependentClient))
        {
           //
           //  Get a new binding handle for receive operations
           //  This enables rpc rundown to be called on the context handle
           //  since a different binding handles is used in receive
           //
           ph95->hBind = RTpGetQMServiceBind(TRUE);
           ph95->hContext = *phQueue ;
           ph95->hQMContext = dwQMContext ;
           ASSERT(ph95->hQMContext) ;

           *phQueue = (HANDLE) ph95 ;
        }
    }
    else
    {
        ASSERT(!(*phQueue)) ;

        if (ph95)
        {
           delete ph95 ;
        }
    }

    return(rc);
}

EXTERN_C
HRESULT
APIENTRY
DepDeleteQueue(
    IN LPCWSTR lpwcsFormatName
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {

            INIT_RPC_HANDLE ;

            QUEUE_FORMAT QueueFormat;

            if (!RTpFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 70);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 80);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;

					if(tls_hBindRpc == 0)
						return MQ_ERROR_SERVICE_NOT_AVAILABLE;
                    
					rc = QMDeleteObject( tls_hBindRpc,
                                         &ObjectFormat);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                rc = ADDeleteObjectGuid(
                        eQUEUE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
                        &QueueFormat.PublicID()
                        );
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 90);

            if(SUCCEEDED(rc)) {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete [] pStringToFree;
    }

    return LogHR(rc, s_FN, 100);
}

EXTERN_C
HRESULT
APIENTRY
DepCloseQueue(
    IN QUEUEHANDLE hQueue
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    //
    // do not add try except here
    // The API is implemented by NtClose() which returns an
    // error on invalid handle (we return MQ_ERROR_INVALID_HANDLE)
    // and throws exception on purpose when running under a debugger to help
    // find errors at development time.
    //
    return (RTpConvertToMQCode(ACDepCloseHandle(hQueue)));
}


EXTERN_C
HRESULT
APIENTRY
DepCreateQueue(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT MQQUEUEPROPS* pqp,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc, rc1;
    LPWSTR lpwcsPathName;
    LPWSTR pStringToFree = NULL;
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor = NULL;
    char *pTmpQPBuff = NULL;

    __try
    {
        __try
        {
            //
            // check that output parameters are writeable before creating the Queue
            // we check lpwcsFormatName and lpdwFormatNameLength
            // pqp is refered before the creation and handled by the try except
            //
            if (IsBadWritePtr(lpdwFormatNameLength,sizeof(DWORD)) ||
                IsBadWritePtr(lpwcsFormatName, (*lpdwFormatNameLength) * sizeof(WCHAR)))
            {
                return LogHR(MQ_ERROR_INVALID_PARAMETER, s_FN, 120);
            }

            INIT_RPC_HANDLE ;

            // Serialize the security descriptor.
            rc = RTpMakeSelfRelativeSDAndGetSize(
                &pSecurityDescriptor,
                &pSelfRelativeSecurityDescriptor,
                NULL);
            if (!SUCCEEDED(rc))
            {
                return LogHR(rc, s_FN, 130);
            }

            lpwcsPathName = RTpGetQueuePathNamePropVar(pqp);
            if(lpwcsPathName == 0)
            {
                return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 140);
            }

            LPCWSTR lpwcsExpandedPathName;
            QUEUE_PATH_TYPE QueuePathType;
            QueuePathType = RTpValidateAndExpandQueuePath(
                                lpwcsPathName,
                                &lpwcsExpandedPathName,
                                &pStringToFree
                                );

            MQQUEUEPROPS *pGoodQP;

            // Check queue props
            rc1 = RTpCheckQueueProps(pqp,
                                     QUEUE_CREATE,
                                     QueuePathType == PRIVATE_QUEUE_PATH_TYPE,
                                     &pGoodQP,
                                     &pTmpQPBuff);
            if (!SUCCEEDED(rc1) || !pGoodQP->cProp)
            {
                return LogHR(rc1, s_FN, 150);
            }

            switch (QueuePathType)
            {
            case PRIVATE_QUEUE_PATH_TYPE:
                rc = QMCreateObject(MQQM_QUEUE,
                                    lpwcsExpandedPathName,
                                    pSecurityDescriptor,
                                    pGoodQP->cProp,
                                    pGoodQP->aPropID,
                                    pGoodQP->aPropVar);

                if (SUCCEEDED(rc))
                {
                    rc = DepPathNameToFormatName(lpwcsExpandedPathName,
                                                lpwcsFormatName,
                                                lpdwFormatNameLength);

                }
                break;

            case PUBLIC_QUEUE_PATH_TYPE:

                {
                    GUID QGuid;

                    rc = ADCreateObject(
								eQUEUE,
								NULL,       // pwcsDomainController
								false,	    // fServerName
								lpwcsExpandedPathName,
								pSecurityDescriptor,
								pGoodQP->cProp,
								pGoodQP->aPropID,
								pGoodQP->aPropVar,
								&QGuid
								);

                   if (SUCCEEDED(rc))
                    {
                        rc = DepInstanceToFormatName(&QGuid,
                                                    lpwcsFormatName,
                                                    lpdwFormatNameLength);

                    }
                }
                break;

            default:
                rc = MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
                break;

            }
            if ( rc == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)
            {
                //
                //  Change into information status ( queue
                //  creation succeeded
                //
                rc = MQ_INFORMATION_FORMATNAME_BUFFER_TOO_SMALL;
            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 160);
            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {

        // Free the extended path name and the serialized security descriptor.
        delete[] pStringToFree;
        delete[] (char*) pSelfRelativeSecurityDescriptor;
        delete[] pTmpQPBuff;

    }

    if (SUCCEEDED(rc) && ((ULONG)(rc) >> 30 != 1)) // no warnning
    {
        return LogHR(rc1, s_FN, 170);
    }
    return LogHR(rc, s_FN, 180);
}


EXTERN_C
HRESULT
APIENTRY
DepLocateBegin(
    IN  LPCWSTR lpwcsContext,
    IN MQRESTRICTION* pRestriction,
    IN MQCOLUMNSET* pColumns,
    IN MQSORTSET* pSort,
    OUT PHANDLE phEnum
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    __try
    {
        if  ( lpwcsContext != NULL)
        {
            return LogHR(MQ_ERROR_ILLEGAL_CONTEXT, s_FN, 190);
        }

        rc = RTpCheckColumnsParameter(pColumns);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 200);
        }

        // If the application passes a valid pointer to a MQRESTRICTION
        // structure with zero rescritctions, pass a null restrictios pointer
        // to the DS, this makes the DS's life much easier.
        if (pRestriction && !pRestriction->cRes)
        {
            pRestriction = NULL;
        }

        rc = RTpCheckRestrictionParameter(pRestriction);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 210);
        }

        rc = RTpCheckSortParameter( pSort);
        if (FAILED(rc))
        {
            return LogHR(rc, s_FN, 220);
        }

        rc = ADQueryQueues(
                NULL,       // pwcsDomainController
				false,		// fServerName
                pRestriction,
                pColumns,
                pSort,
                phEnum
                );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 230);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }
    }

    return LogHR(rc, s_FN, 240);
}


EXTERN_C
HRESULT
APIENTRY
DepLocateNext(
    IN HANDLE hEnum,
    OUT DWORD *pcPropsRead,
    OUT PROPVARIANT aPropVar[]
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    __try
    {
		rc = RTpCheckLocateNextParameter(
				*pcPropsRead,
				aPropVar);
		if( FAILED(rc))
		{
			return LogHR(rc, s_FN, 250);
		}

        rc = ADQueryResults(
                          hEnum,
                          pcPropsRead,
                          aPropVar);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 260);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }
    }

    // If failed, zero the numer of props.
    if (FAILED(rc))
    {
        __try
        {
            *pcPropsRead = 0;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // Do not modify the original error code.
        }
    }

    return LogHR(rc, s_FN, 270);
}

EXTERN_C
HRESULT
APIENTRY
DepLocateEnd(
    IN HANDLE hEnum
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    __try
    {

        rc = ADEndQuery(hEnum);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {

        rc = GetExceptionCode();
        LogHR(HRESULT_FROM_WIN32(rc), s_FN, 280);

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

    }

    return LogHR(rc, s_FN, 290);
}

EXTERN_C
HRESULT
APIENTRY
DepSetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pqp
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc, rc1;
    char *pTmpQPBuff = NULL;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            MQQUEUEPROPS *pGoodQP;
            QUEUE_FORMAT QueueFormat;

            INIT_RPC_HANDLE ;

            if (!RTpFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 300);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 310);
            }

            // Check queue props
            rc1 = RTpCheckQueueProps(pqp,
                                     QUEUE_SET_PROPS,
                                     QueueFormat.GetType() != QUEUE_FORMAT_TYPE_PUBLIC,
                                     &pGoodQP,
                                     &pTmpQPBuff);
            if (!SUCCEEDED(rc1) || !pGoodQP->cProp)
            {
                return LogHR(rc1, s_FN, 320);
            }


            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;

					if(tls_hBindRpc == 0)
						return MQ_ERROR_SERVICE_NOT_AVAILABLE;

					rc = QMSetObjectProperties(tls_hBindRpc,
                                               &ObjectFormat,
                                               pGoodQP->cProp,
                                               pGoodQP->aPropID,
                                               pGoodQP->aPropVar);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                rc = ADSetObjectPropertiesGuid(
							eQUEUE,
							NULL,       // pwcsDomainController
							false,		// fServerName
							&QueueFormat.PublicID(),
							pGoodQP->cProp,
							pGoodQP->aPropID,
							pGoodQP->aPropVar
							);
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 330);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] pTmpQPBuff;
        delete [] pStringToFree;

    }

    if (SUCCEEDED(rc))
    {
        return LogHR(rc1, s_FN, 340);
    }
    return LogHR(rc, s_FN, 350);
}


EXTERN_C
HRESULT
APIENTRY
DepGetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pqp
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc, rc1;
    char *pTmpQPBuff = NULL;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            MQQUEUEPROPS *pGoodQP;
            QUEUE_FORMAT QueueFormat;

            INIT_RPC_HANDLE ;

            if (!RTpFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 360);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 370);
            }

            // Check queue props
            rc1 = RTpCheckQueueProps(pqp,
                                     QUEUE_GET_PROPS,
                                     QueueFormat.GetType() != QUEUE_FORMAT_TYPE_PUBLIC,
                                     &pGoodQP,
                                     &pTmpQPBuff);
            if (!SUCCEEDED(rc1) || !pGoodQP->cProp)
            {
                return LogHR(rc1, s_FN, 380);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;

					if(tls_hBindRpc == 0)
						return MQ_ERROR_SERVICE_NOT_AVAILABLE;

                    rc = QMGetObjectProperties(tls_hBindRpc,
                                               &ObjectFormat,
                                               pGoodQP->cProp,
                                               pGoodQP->aPropID,
                                               pGoodQP->aPropVar);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:

                rc = ADGetObjectPropertiesGuid(
							eQUEUE,
							NULL,      // pwcsDomainCOntroller
							false,	   // fServerName
							&QueueFormat.PublicID(),
							pGoodQP->cProp,
							pGoodQP->aPropID,
							pGoodQP->aPropVar
							);
                break;

            default:
                ASSERT(FALSE);
            }

            // Here we have out queue properties, so if the properties were copied to
            // a temporary buffer, copy the resulted prop vars to the application's
            // buffer.
            if (SUCCEEDED(rc) && (pqp != pGoodQP))
            {
                DWORD i, j;

                for (i = 0, j = 0; i < pGoodQP->cProp; i++, j++)
                {
                    while(pqp->aPropID[j] != pGoodQP->aPropID[i])
                    {
                        j++;
                        ASSERT(j < pqp->cProp);
                    }
                    pqp->aPropVar[j] = pGoodQP->aPropVar[i];
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 390);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete[] pTmpQPBuff;
        delete [] pStringToFree;
    }

    if (SUCCEEDED(rc))
    {
        return LogHR(rc1, s_FN, 400);
    }
    return LogHR(rc, s_FN, 410);
}

EXTERN_C
HRESULT
APIENTRY
DepGetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN DWORD nLength,
    OUT LPDWORD lpnLengthNeeded
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            QUEUE_FORMAT QueueFormat;

            INIT_RPC_HANDLE ;

            if (!RTpFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 420);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 430);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;

					if(tls_hBindRpc == 0)
						return MQ_ERROR_SERVICE_NOT_AVAILABLE;

                    rc = QMGetObjectSecurity(tls_hBindRpc,
                                             &ObjectFormat,
                                             RequestedInformation,
                                             pSecurityDescriptor,
                                             nLength,
                                             lpnLengthNeeded);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                {

                    MQPROPVARIANT var = {{VT_NULL, 0,0,0,0}};

                    rc = ADGetObjectSecurityGuid(
                            eQUEUE,
                            NULL,       // pwcsDomainController
							false,	    // fServerName
                            &QueueFormat.PublicID(),
                            RequestedInformation,
                            PROPID_Q_SECURITY,
                            &var
                            );
                    if (FAILED(rc))
                    {
                        break;
                    }

                    ASSERT( var.vt == VT_BLOB);
                    if ( var.blob.cbSize <= nLength )
                    {
                        //
                        //  Copy the buffer
                        //
                        memcpy(pSecurityDescriptor, var.blob.pBlobData, var.blob.cbSize);
                    }
                    else
                    {
                        rc = MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL;
                    }
                    delete [] var.blob.pBlobData;
                    *lpnLengthNeeded = var.blob.cbSize;

                }
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 440);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        delete [] pStringToFree;
    }

    return LogHR(rc, s_FN, 450);
}

EXTERN_C
HRESULT
APIENTRY
DepSetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor = NULL;
    LPWSTR pStringToFree = NULL;


    __try
    {

        // Serialize the security descriptor.
        rc = RTpMakeSelfRelativeSDAndGetSize(
            &pSecurityDescriptor,
            &pSelfRelativeSecurityDescriptor,
            NULL);
        if (!SUCCEEDED(rc))
        {
            return LogHR(rc, s_FN, 470);
        }

        __try
        {
            QUEUE_FORMAT QueueFormat;

            INIT_RPC_HANDLE ;

            if (!RTpFormatNameToQueueFormat(lpwcsFormatName, &QueueFormat, &pStringToFree))
            {
                return LogHR(MQ_ERROR_ILLEGAL_FORMATNAME, s_FN, 480);
            }

            if (!IsLegalFormatNameOperation(&QueueFormat))
            {
                return LogHR(MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION, s_FN, 490);
            }

            switch (QueueFormat.GetType())
            {
            case QUEUE_FORMAT_TYPE_PRIVATE:
            case QUEUE_FORMAT_TYPE_DIRECT:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;
                    rc = QMSetObjectSecurity(
                            &ObjectFormat,
                            SecurityInformation,
                            pSecurityDescriptor);
                }
                break;

            case QUEUE_FORMAT_TYPE_PUBLIC:
                {

                    PROPID prop = PROPID_Q_SECURITY;
                    MQPROPVARIANT var;

                    var.vt = VT_BLOB;
					if(pSecurityDescriptor != NULL)
					{
						var.blob.cbSize = GetSecurityDescriptorLength( pSecurityDescriptor);
						var.blob.pBlobData = reinterpret_cast<unsigned char *>(pSecurityDescriptor); 
					}
					else
					{
						var.blob.cbSize = 0;
						var.blob.pBlobData = NULL; 
					}
                    rc = ADSetObjectSecurityGuid(
								eQUEUE,
								NULL,		// pwcsDomainController
								false,		// fServerName
								&QueueFormat.PublicID(),
								SecurityInformation,
								prop,
								&var
								); 
                }
                break;

            default:
                ASSERT(FALSE);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 500);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {

        // Free the serialized security descriptor.
        delete[] (char*) pSelfRelativeSecurityDescriptor;
        delete [] pStringToFree;
    }

    return LogHR(rc, s_FN, 510);
}

EXTERN_C
HRESULT
APIENTRY
DepPathNameToFormatName(
    IN LPCWSTR lpwcsPathName,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;
    QUEUE_FORMAT QueueFormat;
    LPWSTR pStringToFree = NULL;

    __try
    {
        __try
        {
            INIT_RPC_HANDLE ;

            LPCWSTR lpwcsExpandedPathName;
            QUEUE_PATH_TYPE qpt;
            qpt = RTpValidateAndExpandQueuePath(
                    lpwcsPathName,
                    &lpwcsExpandedPathName,
                    &pStringToFree
                    );

            switch (qpt)
            {

                case PRIVATE_QUEUE_PATH_TYPE:
                {
                    OBJECT_FORMAT ObjectFormat;

                    ObjectFormat.ObjType = MQQM_QUEUE;
                    ObjectFormat.pQueueFormat = &QueueFormat;

					if(tls_hBindRpc == 0)
						return MQ_ERROR_SERVICE_NOT_AVAILABLE;

                    rc = QMObjectPathToObjectFormat(
                            tls_hBindRpc,
                            lpwcsExpandedPathName,
                            &ObjectFormat
                            );
                    ASSERT(!SUCCEEDED(rc) ||
                           (QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PRIVATE) ||
                           (QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DIRECT));
                }
                break;

                case PUBLIC_QUEUE_PATH_TYPE:
                {
                    GUID guidPublic;
                    ULONG QueueGuidPropID[1] = {PROPID_Q_INSTANCE};
                    PROPVARIANT QueueGuidPropVar[1];

                    QueueGuidPropVar[0].vt = VT_CLSID;
                    QueueGuidPropVar[0].puuid = &guidPublic;
                    rc = ADGetObjectProperties(
                            eQUEUE,
                            NULL,      // pwcsDomainController
							false,	   // fServerName
                            lpwcsExpandedPathName,
                            1,
                            QueueGuidPropID,
                            QueueGuidPropVar
                            );

                    if (FAILED(rc) &&
                        (rc != MQ_ERROR_NO_DS) &&
                        (rc != MQ_ERROR_UNSUPPORTED_OPERATION))
                    {
                        rc = MQ_ERROR_QUEUE_NOT_FOUND;
                    }

                    QueueFormat.PublicID(guidPublic);
                }
                break;

                default:
                {
                    rc = MQ_ERROR_ILLEGAL_QUEUE_PATHNAME;
                }
                break;

            }

            if (SUCCEEDED(rc))
            {
                rc = RTpQueueFormatToFormatName(
                        &QueueFormat,
                        lpwcsFormatName,
                        *lpdwFormatNameLength,
                        lpdwFormatNameLength
                        );
            }

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            rc = GetExceptionCode();
            LogHR(HRESULT_FROM_WIN32(rc), s_FN, 530);

            if(SUCCEEDED(rc))
            {
                rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }
        }
    }
    __finally
    {
        QueueFormat.DisposeString();
        delete[] pStringToFree;

    }

    return LogHR(rc, s_FN, 540);
}

EXTERN_C
HRESULT
APIENTRY
DepHandleToFormatName(
    IN QUEUEHANDLE hQueue,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    __try
    {
        rc = ACDepHandleToFormatName(
                hQueue,
                lpwcsFormatName,
                lpdwFormatNameLength
                );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
    }

    return(rc);
}

EXTERN_C
HRESULT
APIENTRY
DepInstanceToFormatName(
    IN GUID * pGuid,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    __try
    {

        QUEUE_FORMAT QueueFormat(*pGuid);
        rc = RTpQueueFormatToFormatName(
                &QueueFormat,
                lpwcsFormatName,
                *lpdwFormatNameLength,
                lpdwFormatNameLength
                );

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {

        rc = GetExceptionCode();

        if(SUCCEEDED(rc))
        {
            rc = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

    }

    return(rc);
}

EXTERN_C
HRESULT
APIENTRY
DepPurgeQueue(
    IN HANDLE hQueue
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    __try
    {
        rc = ACDepPurgeQueue(hQueue, FALSE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        rc = GetExceptionCode();
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtcert.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mqcert.h

Abstract:

    MQ internal certificate store management.

Author:

    Boaz Feldbaum (BoazF) 15-Oct-1996

--*/

#include "stdh.h"
#include <mqtempl.h>
#include <ad.h>
#include <mqutil.h>
#include <_secutil.h>
//#include <rtintrnl.h>
#include <mqcert.h>

#include "rtcert.tmh"

static WCHAR *s_FN=L"rtdep/rtcert";

#ifdef _DEBUG
#define REPORT_CERT_ERROR { DWORD dwErr = GetLastError() ; }
#else
#define REPORT_CERT_ERROR
#endif

/*************************************************************************
*
*  Function:  DepOpenInternalCertStore()
*
*  Parameters
*      BOOL fWriteAccess - TRUE if caller want write access, i.e.,
*                   if user want to add a certificate to the store.
*
*  Descruption: Get a handle to the certificate store which contain
*               the internal certificates.
*
**************************************************************************/

EXTERN_C
HRESULT
APIENTRY
DepOpenInternalCertStore( OUT CMQSigCertStore **ppStore,
                          IN  LONG            *pnCerts,
                          IN  BOOL            fWriteAccess,
                          IN  BOOL            fMachine,
                          IN  HKEY            hKeyUser )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    struct MQSigOpenCertParams OpenParams ;
    memset(&OpenParams, 0, sizeof(OpenParams)) ;
    OpenParams.bCreate = !!fWriteAccess ;
    OpenParams.bWriteAccess = !!fWriteAccess ;
    OpenParams.bMachineStore = !!fMachine ;
    OpenParams.hCurrentUser = hKeyUser ;

    HRESULT hr = MQSigOpenUserCertStore( ppStore,
                                         MQ_INTERNAL_CERT_STORE_REG,
                                        &OpenParams ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    if (pnCerts)
    {
        HCERTSTORE hStore = (*ppStore)->GetHandle() ;
        //
        // count the number of certificates in store.
        //
        *pnCerts = 0 ;

        PCCERT_CONTEXT pCertContext;
        PCCERT_CONTEXT pPrevCertContext;

        pCertContext = CertEnumCertificatesInStore(hStore, NULL);
        while (pCertContext)
        {
            pPrevCertContext = pCertContext,

            (*pnCerts)++ ;
            pCertContext = CertEnumCertificatesInStore( hStore,
                                                        pPrevCertContext ) ;
        }

        ASSERT(!pCertContext) ;
        ASSERT((*pnCerts == 0) || (*pnCerts == 1)) ;
    }

    DBGMSG((DBGMOD_SECURITY, DBGLVL_INFO,
                  _TEXT("rtcert: DepOpenInternalCertStore successful"))) ;

    return MQ_OK ;
}

/*************************************************************************
*
*  Function:
*    DepGetInternalCert
*
*  Parameters -
*    ppCert - On return, pointer to The certificate object.
*
*  Return value-
*    MQ_OK if successful, else an error code.
*
*  Comments -
*    Returns the internal certificate. The function fails if the
*    certificate does not exist.
*
*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
DepGetInternalCert( OUT CMQSigCertificate **ppCert,
                   OUT CMQSigCertStore   **ppStore,
                   IN  BOOL              fGetForDelete,
                   IN  BOOL              fMachine,
                   IN  HKEY              hKeyUser )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    LONG nCerts = 0 ;

    *ppCert = NULL ;
    *ppStore = NULL ;

    HRESULT hr = DepOpenInternalCertStore( ppStore,
                                          &nCerts,
                                          fGetForDelete,
                                          fMachine,
                                          hKeyUser ) ;
    if (FAILED(hr) || (nCerts == 0))
    {
        return MQ_ERROR_NO_INTERNAL_USER_CERT;
    }

    PCCERT_CONTEXT pCertContext =
                CertEnumCertificatesInStore((*ppStore)->GetHandle(), NULL);

    if (!pCertContext)
    {
        return MQ_ERROR_NO_INTERNAL_USER_CERT;
    }

    hr = MQSigCreateCertificate( ppCert, pCertContext) ;

    return hr ;
}

/*************************************************************************

  Function:
    DepRegisterUserCert

  Parameters -
    pCert - The certificate object.

  Return value-
    S_OK if successful, else an error code.

  Comments -

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
DepRegisterUserCert(
	IN CMQSigCertificate *pCert,
    IN BOOL fMachine
	)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    ASSERT(pCert) ;

    PROPID propIDU[] = {PROPID_U_ID, PROPID_U_SIGN_CERT, PROPID_U_DIGEST};
    PROPID propIDCom[] = {PROPID_COM_ID, PROPID_COM_SIGN_CERT, PROPID_COM_DIGEST};
    DWORD dwArraySize = sizeof(propIDU) / sizeof(propIDU[0]) ;

    PROPID *pPropIDs = propIDU ;
    if (fMachine)
    {
        pPropIDs = propIDCom ;
    }

    PROPVARIANT propVar[3];
    GUID guidCert;

    propVar[0].vt = VT_CLSID;
    propVar[0].puuid = &guidCert;
    UuidCreate(&guidCert);

    propVar[1].vt = VT_BLOB;

    DWORD dwCertSize = 0 ;
    BYTE  *pBuf = NULL ;

    HRESULT hr = pCert->GetCertBlob(&pBuf, &dwCertSize) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50) ;
    }

    propVar[1].blob.cbSize =  dwCertSize ;
    propVar[1].blob.pBlobData  = pBuf ;

    GUID guidHash;

    hr = pCert->GetCertDigest(&guidHash) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 60) ;
    }

    propVar[2].vt = VT_CLSID;
    propVar[2].puuid = &guidHash;

    switch (hr = ADCreateObject( 
						eUSER,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						NULL,
						NULL,
						dwArraySize,
						pPropIDs,
						propVar,
						NULL 
						))
    {
        case MQDS_CREATE_ERROR:
            hr = MQ_ERROR_INTERNAL_USER_CERT_EXIST;
            break;

        case MQ_OK:
            hr = MQ_OK;
            break;
    }

    return LogHR(hr, s_FN, 70) ;
}


/*************************************************************************

  Function:
    DepGetUserCerts

  Parameters -
    ppCert - A pointer to an array that receives the ponters to the user's
        certificates.
    pnCerts - A pointer to a buffer that points to the number of entries in
        pp509. Upon return, the buffer contains the number of certificates
        that the user has.
    pSidIn - An optiona lparameter that points to a user SID. If this
        parameter equals NULL, the certificates for the user of the current
        thread are retrieved.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -
    If the array in pp509 is too small, it is being filled up until there
    is no more place in it. All certificates should be released in any
    case. If upon return pnCerts points to a value that is greater than
    the value when entering the function, it means that pp509 is too
    small.

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
DepGetUserCerts(
	CMQSigCertificate **ppCert,
    DWORD              *pnCerts,
    PSID                pSidIn
	)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr;
    AP<BYTE> pUserSid;
    DWORD dwSidLen;
    PSID pSid;
    DWORD nCertsIn = *pnCerts;

    if (pSidIn)
    {
        pSid = pSidIn;
        dwSidLen = GetLengthSid(pSid);
    }
    else
    {
        //
        // Local users are not let in.
        //
        BOOL fLocalUser;
        BOOL fLocalSystem;

        hr = RTpGetThreadUserSid( &fLocalUser,
                                  &fLocalSystem,
                                  &pUserSid,
                                  &dwSidLen );
        if(FAILED(hr))
        {
            return LogHR(hr, s_FN, 80) ;
        }

        if (fLocalUser)
        {
            return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 90) ;
        }

        pSid = pUserSid.get();
    }

    MQCOLUMNSET Cols;
    PROPID ColId = PROPID_U_SIGN_CERT;
    HANDLE hEnum;

    Cols.cCol = 1;
    Cols.aCol = &ColId;

    BLOB blobUserSid;
    blobUserSid.cbSize = dwSidLen;
    blobUserSid.pBlobData = (BYTE *)pSid;

    hr = ADQueryUserCert(
                NULL,       // pwcsDomainController,
				false,		// fServerName
                &blobUserSid,
                &Cols,
                &hEnum
                );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 100) ;
    }

    DWORD nCerts = 0 ;

    while (1)
    {
        DWORD cProps = 1;
        PROPVARIANT propVar;

        propVar.vt = VT_NULL;
        hr = ADQueryResults(hEnum, &cProps, &propVar);
        if (FAILED(hr) || !cProps)
        {
            break;
        }

        if (nCerts < nCertsIn)
        {
            CMQSigCertificate *pSigCert = NULL ;
            HRESULT hr = MQSigCreateCertificate( &pSigCert,
                                                 NULL,
                                                 propVar.blob.pBlobData,
                                                 propVar.blob.cbSize ) ;
            if (SUCCEEDED(hr))
            {
                ppCert[ nCerts ] = pSigCert ;
                nCerts++;
            }
        }
        else
        {
            nCerts++;
        }

        DepFreeMemory(propVar.blob.pBlobData);
    }

    ADEndQuery(hEnum);

    *pnCerts = nCerts;

    return LogHR(hr, s_FN, 110) ;
}

/*************************************************************************

  Function:
    DepRemoveUserCert

  Parameters -
    p509 - A pointer to the certificate that should be removed from the DS.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -

*************************************************************************/

EXTERN_C
HRESULT
APIENTRY
DepRemoveUserCert(
	IN CMQSigCertificate *pCert
	)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr;
    GUID guidHash;

    hr = pCert->GetCertDigest(&guidHash) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 120) ;
    }

    hr = ADDeleteObjectGuid(
                eUSER,
				NULL,       // pwcsDomainController
				false,	    // fServerName
                &guidHash
                );
    return LogHR(hr, s_FN, 130) ;
}

/*************************************************************************

  Function:
    GetCertInfo

  Parameters -
    ppbCert - A pointer to a pointer to a buffer that holds the cert bits.
    dwCertLen - A pointer to the length of *ppbCert.
    phProv - A pointer to a buffer that receives the handle to the cert CSP.
    wszProvName - A pointer to a buffer that receives a pointer to the name
        of the cert CSP.
    pdwProvType - A poinrter to a buffer the receives the type of the cert CSP.
    pbDefProv - A pointer to a buffer that reveices TRUE, if the cert CSP is
        the default CSP, else FALSE.
    pbInternalCert - A pointer to a buffer that receives TRUE, if the cert
        is an internl MSMQ cert, else FALSE.

  Return value-
    MQ_OK if successful, else error code.

  Comments -
    The function receives a buffer that contains the bits of some
    certificate and returns various information about the certificate.

*************************************************************************/

HRESULT
GetCertInfo( IN     BOOL        fUseCurrentUser,
             IN     BOOL        fMachine,
             IN OUT BYTE      **ppbCert,
             OUT    DWORD      *pdwCertLen,
             OUT    HCRYPTPROV *phProv,
             OUT    LPWSTR     *wszProvName,
             OUT    DWORD      *pdwProvType,
             OUT    BOOL       *pbDefProv,
             OUT    BOOL       *pbInternalCert )
{
    HRESULT hr;

    //
    // Note: it's important that pStore be defined before
    //       pCert, so it will be the last one to be released.
    //
    R<CMQSigCertStore>   pStore ;
    R<CMQSigCertificate> pCert ;

    ASSERT(ppbCert);

    *pbInternalCert = (*ppbCert == NULL) ;

    CAutoCloseRegHandle  hKeyUser (NULL) ;
    if ( fUseCurrentUser )
    {
        LONG rc = RegOpenCurrentUser( KEY_READ,
                                     &hKeyUser ) ;
        if (rc != ERROR_SUCCESS)
        {
            return HRESULT_FROM_WIN32(rc) ;
        }
    }

    if (*pbInternalCert)
    {
        //
        // We should get the information for the internal certificate.
        //
        hr = DepGetInternalCert( &pCert.ref(),
                                &pStore.ref(),
                                 FALSE, // fGetForDelete
                                 fMachine,
                                 hKeyUser ) ;
        if (FAILED(hr))
        {
            return(hr);
        }

        BYTE  *pCertBlob = NULL ;
        DWORD dwCertSize = 0 ;

        hr = pCert->GetCertBlob( &pCertBlob,
                                 &dwCertSize ) ;
        if (FAILED(hr))
        {
            return(hr);
        }

        try
        {
            //
            // We must free b.pBlobData, so do not use memory allocation
            // faliure excpetions.
            //
            *ppbCert = new BYTE[ dwCertSize ] ;
        }
        catch(const bad_alloc&)
        {
            //
            // We failed to allocate a buffer for the cert. Free the blob and
            // return an error.
            //
            *ppbCert = NULL;
            return(MQ_ERROR_INSUFFICIENT_RESOURCES);
        }

        //
        // Copy the certificate to "our" memory.
        //
        *pdwCertLen = dwCertSize ;
        memcpy(*ppbCert, pCertBlob, dwCertSize) ;

        //
        // The CSP context for the internal certificate is always of the
        // base RSA provider.
        //
        DWORD   dwMachineFlag = 0 ;
        LPSTR lpszContainerNameA  = MSMQ_INTCRT_KEY_CONTAINER_A ;
        LPWSTR lpszContainerNameW = MSMQ_INTCRT_KEY_CONTAINER_W ;

        if (fMachine)
        {
            lpszContainerNameA = MSMQ_SERVICE_INTCRT_KEY_CONTAINER_A ;
            lpszContainerNameW = MSMQ_SERVICE_INTCRT_KEY_CONTAINER_W ;
            dwMachineFlag = CRYPT_MACHINE_KEYSET ;
        }

        if (!CryptAcquireContextA( phProv,
                                   lpszContainerNameA,
                                   MS_DEF_PROV_A,
                                   PROV_RSA_FULL,
                                   dwMachineFlag ))
        {
            return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
        }

        *wszProvName = new WCHAR[sizeof(MS_DEF_PROV_A)];
        wcscpy((LPWSTR)*wszProvName, MS_DEF_PROV_W);

        *pdwProvType = PROV_RSA_FULL;
    }
    else
    {
        //
        // We have a "real" (non-internal) cetificate.
        //
        AP<WCHAR> wszKeySet;
        ASSERT(pdwCertLen && *pdwCertLen);

        CHCryptProv hProv;

        if (!CryptAcquireContextA( &hProv,
                                    NULL,
                                    NULL,
                                    PROV_RSA_FULL,
                                    CRYPT_VERIFYCONTEXT))
        {
            return(MQ_ERROR_INSUFFICIENT_RESOURCES);
        }

        CHCertStore  hSysStore =  CertOpenSystemStoreA(
                                                 hProv,
                                                 x_szPersonalSysProtocol ) ;
        if (!hSysStore)
        {
            return(MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE);
        }

        BOOL fFound;
        CPCCertContext pCertContext ;

        for ( fFound = FALSE,
                pCertContext = CertEnumCertificatesInStore(hSysStore, NULL);
              pCertContext && !fFound ; )
        {
            PCCERT_CONTEXT pCtx = pCertContext ;
            fFound = (*pdwCertLen == pCtx->cbCertEncoded) &&
                     (memcmp(*ppbCert,
                              pCtx->pbCertEncoded,
                              pCtx->cbCertEncoded) == 0);
            if (!fFound)
            {
                pCertContext = CertEnumCertificatesInStore( hSysStore,
                                                            pCtx ) ;
            }
        }

        if (!pCertContext)
        {
            return (MQ_ERROR_INVALID_CERTIFICATE);
        }

        BYTE abShortCertInfo[256];
        DWORD dwCertInfoSize = sizeof(abShortCertInfo);
        AP<BYTE> pLongCertInfo = NULL;
        PBYTE pCertInfo = abShortCertInfo;

        if (!CertGetCertificateContextProperty(pCertContext,
                                               CERT_KEY_PROV_INFO_PROP_ID,
                                               pCertInfo,
                                               &dwCertInfoSize))
        {
            if (GetLastError() == ERROR_MORE_DATA)
            {
                pLongCertInfo = new BYTE[dwCertInfoSize];
                pCertInfo = pLongCertInfo.get();
                if (!CertGetCertificateContextProperty(pCertContext,
                                                       CERT_KEY_PROV_INFO_PROP_ID,
                                                       pCertInfo,
                                                       &dwCertInfoSize))
                {
                    return(MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE);
                }
            }
            else
            {
                return(MQ_ERROR_CORRUPTED_PERSONAL_CERT_STORE);
            }
        }

        PCRYPT_KEY_PROV_INFO pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) pCertInfo;

        DWORD dwKeySetLen = wcslen(pKeyProvInfo->pwszContainerName);
        wszKeySet = new WCHAR[dwKeySetLen + 1];
        wcscpy(wszKeySet.get(), pKeyProvInfo->pwszContainerName);

        DWORD dwProvNameLen = wcslen(pKeyProvInfo->pwszProvName);
        *wszProvName = new WCHAR[dwProvNameLen + 1];
        wcscpy(*wszProvName, pKeyProvInfo->pwszProvName);

        *pdwProvType = pKeyProvInfo->dwProvType;

        BOOL fAcq = CryptAcquireContext( phProv,
                                         wszKeySet.get(),
                                         *wszProvName,
                                         *pdwProvType,
                                         0 ) ;

        if (!fAcq)
        {
            return(MQ_ERROR_CORRUPTED_SECURITY_DATA);
        }
    }

    //
    // Find out whether the CSP is the default CSP.
    //
    *pbDefProv = (*pdwProvType == PROV_RSA_FULL) &&
                 (wcscmp(*wszProvName, MS_DEF_PROV_W) == 0);

#ifdef _DEBUG
    if (*pbDefProv)
    {
        static BOOL s_fAlreadyRead = FALSE ;
        static BOOL s_fMakeNonDefault = FALSE ;

        if (!s_fAlreadyRead)
        {
        	DWORD dwUseNonDef = 0 ;
            DWORD dwSize = sizeof(DWORD) ;
            DWORD dwType = REG_DWORD ;

            LONG res = GetFalconKeyValue(
                                      USE_NON_DEFAULT_AUTHN_PROV_REGNAME,
                                     &dwType,
                                     &dwUseNonDef,
                                     &dwSize ) ;
            if ((res == ERROR_SUCCESS) && (dwUseNonDef == 1))
            {
                s_fMakeNonDefault = TRUE ;
            }
            s_fAlreadyRead = TRUE ;
        }

        if (s_fMakeNonDefault)
        {
            *pbDefProv = FALSE ;
            wcscpy(*wszProvName,
                   L"MiCrOsOfT BaSe CrYpToGrApHiC PrOvIdEr v1.0") ;
        }
    }
#endif

    return(MQ_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtintrnl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    rtintrnl.h

Abstract:
    Non public functions that are exported from MQRT.DLL

--*/


#ifndef _RT_INTERNAL_H_
#define _RT_INTERNAL_H_

#include "mqcert.h"

#ifdef __cplusplus
extern "C"
{
#endif

HRESULT
APIENTRY
DepOpenInternalCertStore( OUT CMQSigCertStore **pStore,
                         IN LONG              *pnCerts,
                         IN BOOL               fWriteAccess,
                         IN BOOL               fMachine,
                         IN HKEY               hKeyUser ) ;

HRESULT
APIENTRY
DepGetInternalCert( OUT CMQSigCertificate **ppCert,
                   OUT CMQSigCertStore   **ppStore,
                   IN  BOOL              fGetForDelete,
                   IN  BOOL              fMachine,
                   IN  HKEY              hKeyUser ) ;
 //
 // if fGetForDelete is TRUE then the certificates store is open with write
 // access. Otherwise the store is opened in read-only mode.
 //

HRESULT
APIENTRY
DepRegisterUserCert( IN CMQSigCertificate *pCert,
                    IN BOOL               fMachine ) ;

HRESULT
APIENTRY
DepGetUserCerts( CMQSigCertificate **ppCert,
                DWORD              *pnCerts,
                PSID                pSidIn) ;

HRESULT
APIENTRY
DepRemoveUserCert( IN CMQSigCertificate *pCert ) ;

#ifdef __cplusplus
}
#endif

#endif // _RT_INTERNAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtctxex.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: rtctxex.cpp

Abstract:

    This module implements the DepGetSecurityContextEx().

Author:

    Doron Juster (DoronJ)  13-Apr-2000

Revision History:

--*/

#include "stdh.h"
#include <autorel.h>
#include <_secutil.h>

#include "rtctxex.tmh"

//
// Each security context get its own unique serial number. This is used
// when creating the name for a key container for DepGetSecurityContext().
// Having a unique name enable us to run multi-threaded without critical
// sections.
//
static LONG s_lCtxSerialNumber = 0 ;

#ifdef _DEBUG
#define REPORT_CTX_ERROR { DWORD dwErr = GetLastError() ; }
#else
#define REPORT_CTX_ERROR
#endif

BOOL     SameAsProcessSid( PSID pSid ) ; // from rtsecctx.cpp
HRESULT  RTpExportSigningKey(MQSECURITY_CONTEXT *pSecCtx) ;

/***********************************************************************
*
*   Function - DepGetSecurityContextEx()
*
*    Parameters -
*
*    lpCertBuffer - A buffer that contains the user's certificate in
*        ASN.1 DER encoded format.  This parameter can be set to NULL. If
*        set to NULL, the internal MSMQ certificate is used.
*
*    dwCertBufferLength - The length of the buffer pointed by lpCertBuffer.
*        This parameter is ignored if lpCertBuffer is set to NULL.
*
*    lplpSecurityContextBuffer - A pointer to a buffer that receives the
*        address of the allocated buffer for the security context.
*
*    Description -
*
*        This function should be called in the context of the
*        user that owns the passed certificate. The function
*        allocates the required security buffer and fills it
*        with data that will be used later in DepSendMessage().
*        The purpose of this function is to accelerate the
*        security operations of DepSendMessage(), by caching
*        the security information in the buffer. The
*        application is responsible to pass the security
*        context buffer to DepSendMessage() in
*        PROPID_M_SECURITY_CONTEXT.
*
*        If the user uses more than one certificate, this function
*        should be called for each certificate.
*
*        The application should call DepFreeSecurityContext() and pass the
*        pointer to the security context buffer, when the security
*        buffer is not required anymore.
*
*       Impersonation- It's possible for a process to impersonate a user,
*        then call this function to cache the user data, and then revert
*        to itself and send messages on behalf of that user.
*        To do so, the process must LogonUser() for the user, then load its
*        hive (RegLoadKey()), impersonate the logged on user and finally
*        call this function. Then revert and send messages.
*        With MSMQ1.0 which shipped with NTEE and NTOP, this function used
*        an unsupported and undocumented feature which enabled you just to
*        call CryptAcquireContext() while impersonated, then use the handle
*        after process revert to itself. This feature is not available on IE4
*        and above. The supported way to implement this functionality is to
*        export the private key from the user hive, then (after reverting) to
*        import it into the process hive. See MSMQ bug 2955
*        We'll keep the CryptAcquireContext() code for the case of same user
*        (i.e., thread run in the context of the process user. There was no
*        impersonation). In that case it's legal and enhance performance.
*
*    Return Value -
*        MQ_OK  - If successful, else - Error code.
*
**************************************************************************/

EXTERN_C HRESULT APIENTRY
DepGetSecurityContextEx( LPVOID  lpCertBuffer,
                        DWORD   dwCertBufferLength,
                        HANDLE *hSecurityContext )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    P<MQSECURITY_CONTEXT> pSecCtx = AllocSecurityContext();
    P<BYTE>    pSid = NULL ;
    CHCryptKey hKey = NULL ;
    HRESULT hr = MQ_OK;

    try
    {
        //
        // Get the user SID out from the thread (or process) token.
        //
        hr = RTpGetThreadUserSid( &pSecCtx->fLocalUser,
                                  &pSecCtx->fLocalSystem,
                                  &pSecCtx->pUserSid,
                                  &pSecCtx->dwUserSidLen ) ;

        if (FAILED(hr))
        {
            return(hr);
        }

        if (lpCertBuffer)
        {
            //
            // Copy the certificate and point to the copy from the security
            // context.
            //
            pSecCtx->pUserCert.detach();
			pSecCtx->pUserCert = new BYTE[dwCertBufferLength];
            pSecCtx->dwUserCertLen = dwCertBufferLength;
            memcpy(pSecCtx->pUserCert.get(), lpCertBuffer, dwCertBufferLength);
        }

        //
        // See if process sid match thread sid. We call again
        // GetThreadUserSid() to get sid even for local user.
        // RTpGetThreadUserSid() does not return a sid for local user.
        //
        DWORD dwLen = 0 ;
        hr = GetThreadUserSid( &pSid, &dwLen ) ;
        if (FAILED(hr))
        {
            return hr ;
        }

        BOOL fAsProcess = SameAsProcessSid( pSid.get() ) ;

		BYTE* pUserCert = pSecCtx->pUserCert.get();
		BYTE** ppUserCert = pUserCert == NULL ? &pSecCtx->pUserCert : &pUserCert;

        //
        // Get all the required information about the certificate and
        // put it in the security context.
        //
        hr  = GetCertInfo(  !fAsProcess,
                            pSecCtx->fLocalSystem,
                           ppUserCert,
                           &pSecCtx->dwUserCertLen,
                           &pSecCtx->hProv,
                           &pSecCtx->wszProvName,
                           &pSecCtx->dwProvType,
                           &pSecCtx->bDefProv,
                           &pSecCtx->bInternalCert ) ;

        if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
        {
            return(hr);
        }

        if (hr == MQ_ERROR_NO_INTERNAL_USER_CERT)
        {
            //
            // If the user does not have an internal certificate,
            // this is not a reason to fail DepGetSecurityContext().
            // DepSendMessage() should fail in case the application
            // tries to use this security context to send an
            // authenticated messages.
            //
            *hSecurityContext = (HANDLE) pSecCtx.get();
            pSecCtx.detach() ; // Prevent from the security context to be freed.

            return MQ_OK;
        }

        if (fAsProcess)
        {
            //
            // Thread run under context of process credentials.
            // The Crypto context acquired here is valid for using when
            // calling MQSend().
            //
            *hSecurityContext = (HANDLE) pSecCtx.get() ;
            pSecCtx.detach() ; // Prevent from the security context to be freed.

            return MQ_OK;
        }

        //
        // Calling code impersonated another user.
        // It's time to export the private key. Later, when calling
        // MQSend(), we'll import it into process hive.
        // We export the private key without encryption, because it
        // dones't leave the machine or the process boundaries.
        //
        hr = RTpExportSigningKey(pSecCtx.get()) ;
        if (SUCCEEDED(hr))
        {
            //
            // Pass the result to the caller.
            //
            *hSecurityContext = (HANDLE) pSecCtx.get();
            pSecCtx.detach(); // Prevent from the security context to be freed.
        }

    }
    catch(...)
    {
        hr = MQ_ERROR_INVALID_PARAMETER;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtintcrt.cpp ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    rtintcrt.h

Abstract:

    Create and delete an internal certificate.

Author:

    Original code from MSMQ1.0 rt, then MSMQ2.0 cpl.
    Doron Juster  (DoronJ)  20-Aug-1998

--*/

#include "stdh.h"
#include <mqtempl.h>
#include <ad.h>
#include <mqutil.h>
#include <_secutil.h>
#include <rtintrnl.h>
#include <mqsec.h>

#include "rtintcrt.tmh"

//
// exported from mqrt.dll
//
LPWSTR rtpGetComputerNameW() ;

//---------------------------------------------------------
//
//  Function:
//      _GetUserAccountNameAndDomain(
//
//  Parameters:
//     fLocalSyste - TRUE if called in the context of a localSystem service.
//     szAccountName - A pointer to a buffer that receicves the address of an
//         allocated buffer that contains the account name of the user of the
//         current thread.
//     szDomainName - A pointer to a buffer that receicves the address of an
//         allocated buffer that contains the domain name of the user of the
//         current thread.
//
//  Description:
//     The function allocates and fills two buffers, one for the account name
//     of the user of the current thread, and the second buffer for the
//     domain name of the user of the current thread.
//
//---------------------------------------------------------

static HRESULT
_GetUserAccountNameAndDomain( IN BOOL    fLocalSystem,
                              IN LPTSTR *szAccountName,
                              IN LPTSTR *szDomainName )
{
    HRESULT hr = MQ_OK;
    TCHAR   szLocAccountName[64];
    DWORD   dwLocAccountNameLen = sizeof(szLocAccountName) /
                                         sizeof(szLocAccountName[0]) ;
    LPTSTR  pszLocAccountName = szLocAccountName;
    P<TCHAR>  pszLocLongAccountName = NULL;
    TCHAR   szLocDomainName[64];
    DWORD   dwLocDomainNameLen = sizeof(szLocDomainName) /
                                             sizeof(szLocDomainName[0]) ;
    LPTSTR  pszLocDomainName = szLocDomainName;
    P<TCHAR>  pszLocLongDomainName = NULL;

    P<BYTE>  pbSidAR = NULL ;
    DWORD   dwSidLen;

    try
    {
        //
        // Win NT.
        //
        PSID pSid = NULL ;

        if (fLocalSystem)
        {
            pSid = MQSec_GetLocalMachineSid( FALSE, NULL ) ;
            if (!pSid)
            {
                return MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO ;
            }
        }
        else
        {
            //
            // Get the SID of the user of the current thread.
            //
            hr = GetThreadUserSid(&pbSidAR, &dwSidLen);
            if (FAILED(hr))
            {
                return(hr);
            }
            pSid = pbSidAR.get() ;
        }

        SID_NAME_USE eUse;
        //
        //  Try to get the account and domain names in to a
        //  fixed size buffers.
        //
        if (!LookupAccountSid( NULL,
                               pSid,
                               pszLocAccountName,
                               &dwLocAccountNameLen,
                               pszLocDomainName,
                               &dwLocDomainNameLen,
                               &eUse))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                //
                // The fixed size buffer are not large enough.
                // Allocate larger buffers.
                //
                if (dwLocAccountNameLen > (sizeof(szLocAccountName) /
                                           sizeof(szLocAccountName[0])))
                {
                    pszLocLongAccountName =
                                     new TCHAR[ dwLocAccountNameLen ];
                    pszLocAccountName = pszLocLongAccountName.get();
                }

                if (dwLocDomainNameLen > (sizeof(szLocDomainName) /
                                          sizeof(szLocDomainName[0])))
                {
                    pszLocLongDomainName = new TCHAR[ dwLocDomainNameLen ];
                    pszLocDomainName = pszLocLongDomainName.get();
                }

                //
                // Re-call LookupAccountSid, now with the lrger buffer(s).
                //
                if (!LookupAccountSid(  NULL,
                                        pSid,
                                        pszLocAccountName,
                                       &dwLocAccountNameLen,
                                        pszLocDomainName,
                                       &dwLocDomainNameLen,
                                       &eUse ))
                {
                    return(MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO);
                }
            }
            else
            {
                return(MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO);
            }
        }

        //
        // Allocate the buffers for the returned results, and fill the
        // allocated buffer with the result strings.
        //
        *szAccountName = new TCHAR[ dwLocAccountNameLen + 1 ];
        _tcscpy(*szAccountName, pszLocAccountName);

        *szDomainName = new TCHAR[ dwLocDomainNameLen + 1 ];
        _tcscpy(*szDomainName, pszLocDomainName);
    }
    catch(...)
    {
    }

    return hr;
}

/*************************************************************************

  Function:
     DepCreateInternalCertificate

  Parameters -
    ppCert - On return, get the certificate object.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -
    If the store already contain a certificate, the function falis.

*************************************************************************/

HRESULT DepCreateInternalCertificate( OUT CMQSigCertificate **ppCert )
{
	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr;
    BOOL fLocalUser;
    BOOL fLocalSystem;

    if (ppCert)
    {
        *ppCert = NULL ;
    }

    //
    // Local users are not let in.
    //
    hr = MQSec_GetUserType( NULL,
                           &fLocalUser,
                           &fLocalSystem ) ;
    if (FAILED(hr))
    {
        return(hr);
    }
    if (fLocalUser)
    {
        return(MQ_ERROR_ILLEGAL_USER);
    }

    LONG nCerts;
    R<CMQSigCertStore> pStore ;
    //
    // Get the internal certificate store.
    //
    hr = DepOpenInternalCertStore( &pStore.ref(),
                                  &nCerts,
                                  TRUE,
                                  fLocalSystem,
                                  FALSE ) ;  // fUseCurrentUser
    if (FAILED(hr))
    {
        return hr;
    }

    if (nCerts)
    {
        return(MQ_ERROR_INTERNAL_USER_CERT_EXIST);
    }
    HCERTSTORE  hStore = pStore->GetHandle() ;

    //
    // Get the user's account name and domain name.
    //
    AP<TCHAR> szAccountName;
    AP<TCHAR> szDomainName;

    hr = _GetUserAccountNameAndDomain( fLocalSystem,
                                      &szAccountName,
                                      &szDomainName );
    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Get the name of the computer.
    //
    #define COMPUTER_NAME_LEN  256
    WCHAR szHostNameW[ COMPUTER_NAME_LEN ];
    DWORD dwHostNameLen = sizeof(szHostNameW) / sizeof(szHostNameW[0]) ;

    if (FAILED(GetComputerNameInternal(szHostNameW, &dwHostNameLen)))
    {
        return MQ_ERROR ;
    }

    AP<TCHAR> szComputerName = new TCHAR[ dwHostNameLen + 2 ] ;
#ifdef UNICODE
    wcscpy(szComputerName.get(), szHostNameW) ;
#else
    SecConvertFromWideCharString(szHostNameW,
                                 szComputerName.get(),
                                 (dwHostNameLen + 2)) ;
#endif

    R<CMQSigCertificate> pSigCert = NULL ;
    hr = MQSigCreateCertificate (&pSigCert.ref()) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    else if (pSigCert.get() == NULL)
    {
        return MQ_ERROR ;
    }

    hr = pSigCert->PutValidity( INTERNAL_CERT_DURATION_YEARS ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    hr = pSigCert->PutIssuer( MQ_CERT_LOCALITY,
                              _T("-"),
                              _T("-"),
                              szDomainName.get(),
                              szAccountName.get(),
                              szComputerName.get() ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    hr = pSigCert->PutSubject( MQ_CERT_LOCALITY,
                               _T("-"),
                               _T("-"),
                               szDomainName.get(),
                               szAccountName.get(),
                               szComputerName.get() ) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    //
    // When renewing the internal certificate, always renew the
    // private/public keys pair.
    //
    BOOL fCreated = FALSE ;
    hr = pSigCert->PutPublicKey( TRUE,
                                 fLocalSystem,
                                &fCreated) ;
    if (FAILED(hr))
    {
        return hr ;
    }
    ASSERT(fCreated) ;

    hr = pSigCert->EncodeCert( fLocalSystem,
                               NULL,
                               NULL) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    hr = pSigCert->AddToStore(hStore) ;
    if (FAILED(hr))
    {
        return hr ;
    }

    if (ppCert)
    {
        *ppCert = pSigCert.detach();
    }

    return(MQ_OK);
}

/*************************************************************************

  Function:
     DepDeleteInternalCert( IN CMQSigCertificate *pCert )

  Parameters -
    pCert - Certificate object.

  Return value-
    MQ_OK if successful, else an error code.

  Comments -

*************************************************************************/

HRESULT  DepDeleteInternalCert( IN CMQSigCertificate *pCert )
{
	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr = pCert->DeleteFromStore() ;
    return hr ;
}

//+------------------------------------------------------------------------
//
//  DepRegisterCertificate()
//
//  Description: Create an internal certificate and register it in the DS.
//
//  Input:
//      IN DWORD   dwFlags- one of the followings:
//          MQCERT_REGISTER_IF_NOT_EXIST- create a new internal certificate
//              only if there is not a previous one on local machine. The
//              test for existing certificate is local and no access to
//              remote DS server is made. So this check can be safely made
//              if machine is offline, without hanging it.
//      IN PVOID   lpCertBuffer- NULL for internal certificate.
//          Otherwise, pointer to external certificate buffer. In this case,
//          the api only register the external certificate in the DS and
//          flag "MQCERT_REGISTER_IF_NOT_EXIST" must not be specified.
//      IN DWORD   dwCertBufferLength- Size, in bytes, of buffer of external
//          certificate.
//
//+------------------------------------------------------------------------

EXTERN_C
HRESULT
APIENTRY
DepRegisterCertificate( IN DWORD   dwFlags,
                       IN PVOID   lpCertBuffer,
                       IN DWORD   dwCertBufferLength )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr = MQ_OK ;
    R<CMQSigCertStore> pStore = NULL ;
    R<CMQSigCertificate> pCert = NULL ;

    //
    // First check validity of input parameters.
    //
    if (lpCertBuffer)
    {
        if (dwFlags & MQCERT_REGISTER_IF_NOT_EXIST)
        {
            //
            // The "if_not_exist" flag is relevant only for internal
            // certificate, because we create it.
            //
            return MQ_ERROR_INVALID_PARAMETER ;
        }
        else if (dwCertBufferLength == 0)
        {
            //
            // Length must be specified for the external certificate.
            //
            return MQ_ERROR_INVALID_PARAMETER ;
        }
    }

    //
    // Next, check if local user. They are not let in. the SID of a local
    // user is not meaningful outside of his local machine. There is no
    // user object in the DS for a local user, so we don't have a place to
    // register his certificate.
    //
    BOOL fLocalUser =  FALSE ;
    BOOL fLocalSystem = FALSE ;

    hr = MQSec_GetUserType( NULL,
                           &fLocalUser,
                           &fLocalSystem ) ;
    if (FAILED(hr))
    {
        return(hr);
    }
    else if (fLocalUser)
    {
        return MQ_ERROR_ILLEGAL_USER ;
    }

    //
    // Next, check if an internal certificate already exist.
    //
    if (dwFlags & MQCERT_REGISTER_IF_NOT_EXIST)
    {
        LONG nCerts = 0 ;
        hr = DepOpenInternalCertStore( &pStore.ref(),
                                      &nCerts,
                                      TRUE,
                                      fLocalSystem,
                                      FALSE ) ; // fUseCurrectUser
        if (FAILED(hr))
        {
            return hr;
        }
        else if (nCerts)
        {
            //
            // OK, we already have an internal certificate.
            //
            return MQ_INFORMATION_INTERNAL_USER_CERT_EXIST ;
        }
        pStore.free() ;
    }

    BOOL fIntCreated = FALSE ;

    if (!lpCertBuffer)
    {
        //
        // Creating an internal certificate also mean to recreate the user
        // private key. So before destroying previous keys, let's check
        // if the user has permission to register his certificate and if
        // local machine can access the DS at present. We'll do this by
        // trying to register previous internal certificate.
        //
        // Open the certificates store with write access, so we can later
        // delete the internal certificate, before creating a new one.
        //
        hr = DepGetInternalCert( &pCert.ref(),
                                &pStore.ref(),
                                 TRUE,
                                 fLocalSystem,
                                 FALSE ) ;  //  fUseCurrentUser

        if (SUCCEEDED(hr))
        {
            //
            // Try to register in the DS.
            //
    		hr = DepRegisterUserCert( pCert.get(), fLocalSystem );
    		if(FAILED(hr) && (hr != MQ_ERROR_INTERNAL_USER_CERT_EXIST))
	    	{
		    	return hr ;
    		}
            //
            // Remove the internal certificate from MQIS.
            //
            hr = DepRemoveUserCert(pCert.get()) ;
            if (FAILED(hr) && (hr != MQDS_OBJECT_NOT_FOUND))
            {
                return hr ;
            }
            //
            // Remove the internal certificate from the local certificate
            // store.
            //
            hr = DepDeleteInternalCert(pCert.get());
            if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
            {
                return hr ;
            }

            pCert.free();
        }

        //
        // It's time to create the internal certificate.
        //
        ASSERT(!pCert.get()) ;
        hr = DepCreateInternalCertificate( &pCert.ref() ) ;
        fIntCreated = TRUE ;
    }
    else
    {
        hr = MQSigCreateCertificate( &pCert.ref(),
                                      NULL,
                                      (LPBYTE) lpCertBuffer,
                                      dwCertBufferLength ) ;
    }

    if (FAILED(hr))
    {
        return hr ;
    }

    hr = DepRegisterUserCert( pCert.get(), fLocalSystem ) ;
    if (FAILED(hr) && fIntCreated)
    {
        //
        // We created a new certificate in registry but failed to register
        // it in DS. delete from local registry.
        //
        pCert.free();
        pStore.free();

        HRESULT hr1 = DepGetInternalCert( &pCert.ref(),
                                         &pStore.ref(),
                                          TRUE,
                                          fLocalSystem,
                                          FALSE ) ; // fUseCurrentUser
        if (SUCCEEDED(hr1))
        {
            hr1 = DepDeleteInternalCert(pCert.get());
        }
        ASSERT(SUCCEEDED(hr1)) ;
    }

    return hr ;
}

//+-------------------------------------------------------------------------
//
//  STDAPI DllRegisterServer()
//
//  this code is run on every logon, from regsvr32. It's the reponsibility
//  of setup to insert the regsvr32 command in the "run" registry. This
//  code will register an internal certificate for each new domain user
//  that logon the machine.
//
//+-------------------------------------------------------------------------

STDAPI DllRegisterServer()
{
	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    //
    // First see if auto registration was disabled by user.
    //
    DWORD dwEnableRegister = DEFAULT_AUTO_REGISTER_INTCERT ;
    DWORD dwType = REG_DWORD ;
    DWORD dwSize = sizeof(dwEnableRegister) ;
    LONG rc = GetFalconKeyValue( AUTO_REGISTER_INTCERT_REGNAME,
                                 &dwType,
                                 &dwEnableRegister,
                                 &dwSize ) ;
    if ((rc == ERROR_SUCCESS) && (dwEnableRegister == 0))
    {
        return MQ_OK ;
    }

    //
    // Next see if auto-registration was already done for this user
    //
    DWORD dwRegistered = 0 ;
    dwType = REG_DWORD ;
    dwSize = sizeof(dwRegistered) ;
    DWORD dwDisposition ;
    CAutoCloseRegHandle hMqUserReg = NULL;

    LONG lRes = RegCreateKeyEx( FALCON_USER_REG_POS,
                                FALCON_USER_REG_MSMQ_KEY,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                               &hMqUserReg,
                               &dwDisposition );
    if (lRes == ERROR_SUCCESS)
    {
        lRes = RegQueryValueEx( hMqUserReg,
                                CERTIFICATE_REGISTERD_REGNAME,
                                0,
                               &dwType,
                                (LPBYTE) &dwRegistered,
                               &dwSize ) ;

        if (lRes != ERROR_SUCCESS)
        {
            dwRegistered = 0 ;
        }
    }

    if (dwRegistered == INTERNAL_CERT_REGISTERED)
    {
        //
        // Certificate already registered.
        //
        return MQ_OK ;
    }

    //
    // Read number of 15 seconds intervals to wait for MSMQ DS server.
    //
    dwType = REG_DWORD ;
    dwSize = sizeof(DWORD) ;
    DWORD dwDef = DEFAULT_AUTO_REGISTER_WAIT_DC ;
    DWORD dwWaitIntervals = DEFAULT_AUTO_REGISTER_WAIT_DC ;

    READ_REG_DWORD( dwWaitIntervals,
                    AUTO_REGISTER_WAIT_DC_REGNAME,
                   &dwDef ) ;

    //
    // OK, now it's time to resiter the certificate.
    //
    DWORD iCount = 0 ;
    BOOL  fTryAgain = FALSE ;
    HRESULT hr = MQ_OK ;

    do
    {
        fTryAgain = FALSE ;
        hr = DepRegisterCertificate( MQCERT_REGISTER_IF_NOT_EXIST,
                                    NULL,
                                    0 ) ;
        if (SUCCEEDED(hr) && hMqUserReg)
        {
            //
            // Save success status in registry.
            //
            dwRegistered = INTERNAL_CERT_REGISTERED ;
            dwType = REG_DWORD ;
            dwSize = sizeof(dwRegistered) ;

            lRes = RegSetValueEx( hMqUserReg,
                                  CERTIFICATE_REGISTERD_REGNAME,
                                  0,
                                  dwType,
                                  (LPBYTE) &dwRegistered,
                                  dwSize ) ;
            ASSERT(lRes == ERROR_SUCCESS) ;
        }
        else if (hr == MQ_ERROR_NO_DS)
        {
            //
            // MSMQ DS server not yet found.
            // wait 15 seconds and try again.
            //
            if (iCount < dwWaitIntervals)
            {
                iCount++ ;
                Sleep(15000) ;
                fTryAgain = TRUE ;
            }
        }
    } while (fTryAgain) ;

    if (FAILED(hr) && hMqUserReg)
    {
        dwType = REG_DWORD ;
        dwSize = sizeof(hr) ;

        lRes = RegSetValueEx( hMqUserReg,
                              AUTO_REGISTER_ERROR_REGNAME,
                              0,
                              dwType,
                              (LPBYTE) &hr,
                              dwSize ) ;
        ASSERT(lRes == ERROR_SUCCESS) ;
    }

    return MQ_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtmgmt.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    rtmgmt.cpp

Abstract:

    Management.

Author:

    RaphiR

Revision History:

--*/

#include "stdh.h"
#include "fntoken.h"
#include "mgmtrpc.h"
#include "qmmgmt.h"
#include "rtprpc.h"
#include <mqutil.h>

#include "rtmgmt.tmh"

//---------------------------------------------------------
//
//  Function:
//      RTpMgmtObjectNameToMgmtObject
//
//  Description:
//      Convert a format name string to a Management Object union.
//
//    This function allocates a MGMT_OBJECT, which must
//    be free with RTpMgmtFreeMgmtObject function
//
//---------------------------------------------------------
static
BOOL
RTpMgmtObjectNameToMgmtObject(
    LPCWSTR lpwstrObjectName,
    LPWSTR* ppStringToFree,
    MGMT_OBJECT* pObj,
    QUEUE_FORMAT* pqf
    )
{

    //
    // Handle MACHINE= case
    //
    if(_wcsnicmp(lpwstrObjectName, MO_MACHINE_TOKEN, STRLEN(MO_MACHINE_TOKEN)) == 0)
    {
        pObj->type = MGMT_MACHINE;
        pObj->dwMachineInfo = 0;
        return TRUE;
    }

    //
    // Handle QUEUE= case
    // 
    if(_wcsnicmp(lpwstrObjectName, MO_QUEUE_TOKEN, STRLEN(MO_QUEUE_TOKEN)) == 0)
    {
        pObj->type = MGMT_QUEUE;
        pObj->pQueueFormat = pqf;
        return RTpFormatNameToQueueFormat(
                    &lpwstrObjectName[STRLEN(MO_QUEUE_TOKEN) + 1],
                    pqf,
                    ppStringToFree
                    );
    }

    return FALSE;
}


//---------------------------------------------------------
//
//  Function:
//      GetRpcClientHandle
//
//  Description:
//      
//---------------------------------------------------------
static 
HRESULT 
GetRpcClientHandle(   
    handle_t* phBind
    )
{

    WCHAR *wcsStringBinding = NULL;

    RPC_STATUS status = RpcStringBindingCompose( NULL,
                                                 QMMGMT_PROTOCOL,
                                                 NULL,
                                                 g_pwzQmmgmtEndpoint,
                                                 QMMGMT_OPTIONS,
                                                 &wcsStringBinding);

    if (status != RPC_S_OK)
    {
        return MQ_ERROR ;
    }

    status = RpcBindingFromStringBinding(wcsStringBinding, phBind);
    if (status != RPC_S_OK)
    {
        return MQ_ERROR ;
    }

    status = RpcStringFree(&wcsStringBinding);

    return MQ_OK ;
}


static
HRESULT
RTpMgmtAction(
    HANDLE hBind,
    const MGMT_OBJECT* pMgmtObj,
    LPCWSTR pAction
    )
{
    __try
    {
    	return R_QMMgmtAction(
                hBind,
                pMgmtObj, 
                pAction
                );

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        HRESULT rc;
        rc = GetExceptionCode();

        if(SUCCEEDED(rc))
        {
            return MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

        return rc;
    }
}


HRESULT
LocalMgmtAction(
    const MGMT_OBJECT* pMgmtObj, 
    LPCWSTR pAction
    )
{
    //
    // Get local  RPC binding Handle
    //
    HRESULT hr ;
    handle_t hBind = NULL;
    hr = GetRpcClientHandle(&hBind) ;
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(hBind != NULL);

    hr =  RTpMgmtAction(
                hBind,
                pMgmtObj,
                pAction
                );

    RpcBindingFree(&hBind);

    return hr;
}


HRESULT
RemoteMgmtAction(
    LPCWSTR pMachineName,
    const MGMT_OBJECT* pMgmtObj, 
    LPCWSTR pAction
    )
{
    //
    // Call remote administrator
    //
    HRESULT hr;
    hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;
    DWORD dwProtocol = 0 ;

    CALL_REMOTE_QM(
        const_cast<LPWSTR>(pMachineName), 
        hr, 
        RTpMgmtAction(hBind, pMgmtObj, pAction)
        );

    return hr;
}


EXTERN_C
HRESULT
APIENTRY
DepMgmtAction(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN LPCWSTR pAction
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    ASSERT(pObjectName);
    ASSERT(pAction);

    QUEUE_FORMAT qf;
    MGMT_OBJECT MgmtObj;

    //
    // Parse the object name
    //
    AP<WCHAR> pStringToFree = NULL;
    if(!RTpMgmtObjectNameToMgmtObject(pObjectName, &pStringToFree, &MgmtObj, &qf))
    {
        return MQ_ERROR_ILLEGAL_FORMATNAME;
    }

    if (pMachineName == NULL)
    {
        return LocalMgmtAction(&MgmtObj, pAction);
    }
    else
    {
        return RemoteMgmtAction(pMachineName, &MgmtObj, pAction);
    }
}


static
HRESULT
RTpMgmtGetInfo(
    HANDLE hBind,
    const MGMT_OBJECT* pMgmtObj,
    MQMGMTPROPS* pMgmtProps
    )
{
    __try
    {
    	return R_QMMgmtGetInfo(
                hBind,
                pMgmtObj, 
                pMgmtProps->cProp,
                pMgmtProps->aPropID,
                pMgmtProps->aPropVar
                );

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        HRESULT rc;
        rc = GetExceptionCode();

        if(SUCCEEDED(rc))
        {
            return MQ_ERROR_SERVICE_NOT_AVAILABLE;
        }

        return rc;
    }
}


static
HRESULT
LocalMgmtGetInfo(
    const MGMT_OBJECT* pMgmtObj, 
    MQMGMTPROPS* pMgmtProps
    )
{
    HRESULT hr ;

    //
    // Get local  RPC binding Handle
    //
    handle_t hBind = NULL;
    hr = GetRpcClientHandle(&hBind) ;
    if (FAILED(hr))
    {
        return hr;
    }
    ASSERT(hBind != NULL);

    hr =  RTpMgmtGetInfo(
                hBind,
                pMgmtObj, 
                pMgmtProps
                );

    RpcBindingFree(&hBind);

    return hr;
}


static
HRESULT
RemoteMgmtGetInfo(
    LPCWSTR pMachineName,
    const MGMT_OBJECT* pMgmtObj, 
    MQMGMTPROPS* pMgmtProps
    )
{
    HRESULT hr;

    //
    // Call remote administrator
    //
    hr = MQ_ERROR_SERVICE_NOT_AVAILABLE ;
    DWORD dwProtocol = 0 ;

    CALL_REMOTE_QM(
        const_cast<LPWSTR>(pMachineName), 
        hr, 
        RTpMgmtGetInfo(hBind, pMgmtObj, pMgmtProps)
        );

    return hr;
}


EXTERN_C
HRESULT
APIENTRY
DepMgmtGetInfo(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN OUT MQMGMTPROPS* pMgmtProps
    )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    CMQHResult rc;

    ASSERT(pObjectName);
    ASSERT(pMgmtProps);

    QUEUE_FORMAT qf;
    MGMT_OBJECT MgmtObj;

    //
    // Parse the object name
    //
    AP<WCHAR> pStringToFree = NULL;
    if(!RTpMgmtObjectNameToMgmtObject(pObjectName, &pStringToFree, &MgmtObj, &qf))
    {
        return MQ_ERROR_ILLEGAL_FORMATNAME;
    }

    //
    // Make sure the propvar is set to VT_NULL 
    // (we dont support anything else)
    //
    memset(pMgmtProps->aPropVar, 0, pMgmtProps->cProp * sizeof(PROPVARIANT));
    for (DWORD i = 0; i < pMgmtProps->cProp; ++i)
    {
        pMgmtProps->aPropVar[i].vt = VT_NULL;
    }

    if (pMachineName == NULL)
    {
        return LocalMgmtGetInfo(&MgmtObj, pMgmtProps);
    }
    else
    {
        return RemoteMgmtGetInfo(pMachineName, &MgmtObj, pMgmtProps);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtprpc.h ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    rtprpc.h

Abstract:

    RT DLL, RPC related stuff.

Author:

    Doron Juster  (DoronJ)  18-Nov-1996

--*/

#ifndef __RTPRPC_H
#define __RTPRPC_H

#include "_mqrpc.h"
#include "mqsocket.h"
#include "cancel.h"

//
//  Cancel RPC globals
//
extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;
extern DWORD g_hThreadIndex;
#define tls_hThread  ((handle_t) TlsGetValue( g_hThreadIndex ))

//
// Local endpoints to QM
//
extern AP<WCHAR> g_pwzQmsvcEndpoint;
extern AP<WCHAR> g_pwzQmmgmtEndpoint;

/*====================================================

RegisterRpcCallForCancel

Arguments:

Return Value:

  Register the call for cancel if its duration is too long
=====================================================*/

inline  void RegisterRpcCallForCancel(IN  HANDLE  *phThread,
                                      IN  DWORD    dwRecvTimeout )
{
    handle_t hThread = tls_hThread;
    if ( hThread == NULL)
    {
        //
        //  First time
        //
        //  Get the thread handle
        //
        HANDLE hT = GetCurrentThread();
        BOOL fResult = DuplicateHandle(
            GetCurrentProcess(),
            hT,
            GetCurrentProcess(),
            &hThread,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);
        ASSERT( fResult == TRUE);
        ASSERT(hThread);

        fResult = TlsSetValue( g_hThreadIndex, hThread);
        ASSERT( fResult == TRUE);

        //
        // Set the lower bound on the time to wait before timing
        // out after forwarding a cancel.
        //
        RPC_STATUS status;
        status = RpcMgmtSetCancelTimeout(0);
        ASSERT( status == RPC_S_OK);

    }
    *phThread = hThread;
    //
    //  Register the thread
    //
    TIME32 tPresentTime = DWORD_PTR_TO_DWORD(time(NULL)) ;
    TIME32  tTimeToWake = tPresentTime + (dwRecvTimeout / 1000) ;

    if ((dwRecvTimeout == INFINITE) || (tTimeToWake < tPresentTime))
    {
        //
        // Overflow
        // Note that time_t is a long, not unsigned. On the other hand
        // INFINITE is defined as 0xffffffff (i.e., -1). If we'll use
        // INFINITE here, then cancel routine, CCancelRpc::CancelRequests(),
        // will cancel this call immediately.
        // so use the bigest long value.
        //
        tTimeToWake = MAXLONG ;
    }
    g_CancelRpc.Add( hThread, tTimeToWake) ;
}


/*====================================================

UnregisterRpcCallForCancel

Arguments:

Return Value:

  Register the call for cancel if its duration is too long
=====================================================*/
inline  void UnregisterRpcCallForCancel(IN HANDLE hThread)
{
    ASSERT( hThread != NULL);

    //
    //  unregister the thread
    //
    g_CancelRpc.Remove( hThread);
}


void RTpUnbindQMService();
void RTpBindQMService();
HRESULT RTpBindRemoteQMService(
    IN  LPWSTR     lpwNodeName,
    IN OUT  DWORD  *pdwProtocol,
    OUT handle_t*  lphBind,
    IN  OUT MQRPC_AUTHENTICATION_LEVEL *peAuthnLEvel,
    IN  BOOL       fUseThisProtocol = FALSE,
    IN  BOOL       fAlternate = FALSE
    );

handle_t RTpGetQMServiceBind(BOOL fAlternate = FALSE);
HRESULT  GetMachineIpxAddress(LPWSTR lpwszMachine, LPWSTR lpwszAddr) ;


#define  RTP_CALL_REMOTE_QM(lpServer, rc, command, dwProtocl)   \
{                                                               \
       handle_t hBind = NULL ;                                  \
                                                                \
       rc = MQ_ERROR_REMOTE_MACHINE_NOT_AVAILABLE ;             \
                                                                \
       HRESULT rpcs =  RTpBindRemoteQMService(                  \
                                lpServer,                       \
                                &dwProtocol,                    \
                                &hBind,                         \
                                &_eAuthnLevel,                  \
                                (dwProtocol != 0) ) ;           \
                                                                \
       if (rpcs == MQ_OK)                                       \
       {                                                        \
          HANDLE hThread;                                       \
          RegisterRpcCallForCancel( &hThread, 0) ;              \
                                                                \
          __try                                                 \
          {                                                     \
             rc = command ;                                     \
          }                                                     \
          __except(EXCEPTION_EXECUTE_HANDLER)                   \
          {                                                     \
             rc = MQ_ERROR_SERVICE_NOT_AVAILABLE ;              \
          }                                                     \
          UnregisterRpcCallForCancel( hThread);                 \
       }                                                        \
                                                                \
       if (hBind)                                               \
       {                                                        \
          mqrpcUnbindQMService( &hBind,                         \
                                NULL ) ;                        \
       }                                                        \
}

#define  CALL_REMOTE_QM(lpServer, rc, command)                          \
{                                                                       \
    BOOL  fTryAgain = FALSE ;                                           \
    MQRPC_AUTHENTICATION_LEVEL _eAuthnLevel = MQRPC_SEC_LEVEL_MAX ;     \
                                                                        \
    do                                                                  \
    {                                                                   \
        fTryAgain = FALSE ;                                             \
        RTP_CALL_REMOTE_QM(lpServer, rc, command, dwProtocol)           \
        if (rc == MQ_ERROR_SERVICE_NOT_AVAILABLE)                       \
        {                                                               \
           if (_eAuthnLevel != MQRPC_SEC_LEVEL_NONE)                    \
           {                                                            \
               _eAuthnLevel = MQRPC_SEC_LEVEL_NONE;                     \
               dwProtocol = 0 ;                                         \
               fTryAgain = TRUE ;                                       \
           }                                                            \
        }                                                               \
    } while (fTryAgain) ;                                               \
}

#define INIT_RPC_HANDLE                      \
{                                            \
    RTpUnbindQMService() ;                   \
    RTpBindQMService() ;                     \
}

#endif // __RTPRPC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtmain.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtmain.cpp

Abstract:

    This module contains code involved with Dll initialization.

	The mqrtdep.dll contains the msmq3 dependent client functionality. 
	This functionality was removed from the mqrt.dll.
	It does not support msmq3's new features like mqf and http messaging.
	It is essentially a modified copy of the msmq2 runtime.

Author:
    Erez Haba (erezh) 24-Dec-95

Revision History:
	Nir Aides (niraides) 23-Aug-2000 - Adaptation for mqrtdep.dll

--*/

#include "stdh.h"
#include "mqutil.h"
#include "_mqrpc.h"
#include "cs.h"
#include "rtsecutl.h"
#include "rtprpc.h"
#include <mqexception.h>

#include "rtmain.tmh"

#ifdef RT_XACT_STUB
#include "txdtc.h"
extern HANDLE g_hCommitThread;
extern DWORD  g_dwCommitThreadId;
extern HANDLE g_hCommitThreadEvent;
extern DWORD __stdcall  RTCommitThread( void *dwP );
#endif

//
// Platform flag. Win95 binaries run on NT if we install Falcon client,
// so in some places we must check at run-time on which platform we are.
//
DWORD  g_dwPlatformId = (DWORD) -1 ;

//
// TLS index for per-thread event.
//
DWORD  g_dwThreadEventIndex = 0;

// QM computer name (for the client - server's name)
LPWSTR  g_lpwcsComputerName = NULL;
DWORD   g_dwComputerNameLen = 0;

// Local computer name (for the client - client's name)
LPWSTR  g_lpwcsLocalComputerName = NULL;

AP<char> g_pQmSid_buff;

#define g_pQmSid ((PSID)(char*)(g_pQmSid_buff.get()))

//
//  Default for PROPID_M_TIME_TO_REACH_QUEUE
//
DWORD  g_dwTimeToReachQueueDefault = MSMQ_DEFAULT_LONG_LIVE ;

//
// RPC related data.
//
BOOL InitRpcGlobals() ;

//
// Name of server for dependent client.
//
BOOL  g_fDependentClient = FALSE ;   // TRUE if running as dependent Client
WCHAR g_wszRemoteQMName[ MQSOCK_MAX_COMPUTERNAME_LENGTH ] = {0} ;

//
// Serializes calls to DTC
//
extern HANDLE g_hMutexDTC;

//
// Type of Falcon machine (client, server)
//
DWORD  g_dwOperatingSystem;

//
// There is a separate rpc binding handle for each thread. This is necessary
// for handling impersonation, where each thread can impersonate another
// user.
//
// The handle is stored in a TLS slot because we can't use declspec(thread)
// because the dll is dynamically loaded (by LoadLibrary()).
//
// This is the index of the slot.
//
DWORD  g_hBindIndex = UNINIT_TLSINDEX_VALUE ;

extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;

//---------------------------------------------------------
//
//  InitializeQM(...)
//
//  Description:
//
//      Per process QM initialization.
//      Currently the only initialization is to allow the QM to open the application's
//      process in order to duplicate handles for the application.
//
//  Return Value:
//
//      MQ_OK, if successful, else MQ error code.
//
//---------------------------------------------------------

static HRESULT InitializeQM(void)
{
    //
    // Get the cumputer name, we need this value in several places.
    //
    g_dwComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
    AP<WCHAR> lpwcsComputerName = new WCHAR[MAX_COMPUTERNAME_LENGTH + 1];
    HRESULT hr= GetComputerNameInternal(
        lpwcsComputerName.get(),
        &g_dwComputerNameLen
        );

    ASSERT(SUCCEEDED(hr) );
    g_lpwcsComputerName = lpwcsComputerName.get();
    lpwcsComputerName.detach();
    g_lpwcsLocalComputerName = new WCHAR[wcslen(g_lpwcsComputerName) + 1];
    wcscpy(g_lpwcsLocalComputerName, g_lpwcsComputerName);

    if(g_fDependentClient)
    {
        //
        // In Client case, make the name of this computer
        // be the name of the remote machine
        //
        delete[] g_lpwcsComputerName;
        g_lpwcsComputerName = g_wszRemoteQMName;
        g_dwComputerNameLen = wcslen(g_wszRemoteQMName);
    }

    RTpInitXactRingBuf();

    g_dwOperatingSystem = MSMQGetOperatingSystem();


    if (g_fDependentClient)
    {
       return MQ_OK ;
    }

    ASSERT(tls_hBindRpc == NULL) ;
    RTpBindQMService();

    DWORD cSid;
    HANDLE hProcess = GetCurrentProcess();
    AP<char> pSD_buff;
    SECURITY_DESCRIPTOR AbsSD;
    DWORD cSD;
    AP<char> pNewDacl_buff;
    BOOL bRet;
    BOOL bPresent;
    PACL pDacl;
    BOOL bDefaulted;
    DWORD dwAceSize;

#define pSD ((PSECURITY_DESCRIPTOR)(char*)pSD_buff.get())
#define pNewDacl ((PACL)(char*)pNewDacl_buff)

    try
    {
        ASSERT( tls_hBindRpc ) ;

        //
        // In multi-qm environment we want to access registry section
        // of the correct QM only. Cluster guarantees that this code runs
        // only when the correct QM is running, so we should not fail.
        // On non cluster systems it doesn't matter if we fail here. (ShaiK)
        //
        AP<WCHAR> lpServiceName = 0;
        hr = QMGetMsmqServiceName( tls_hBindRpc, &lpServiceName );
		if (FAILED(hr))
		{
			return (hr);
		}

        SetFalconServiceName(lpServiceName.get());

        // Get the SID of the user that runs the QM.
        // First see how bug is the SID.
        hr = QMAttachProcess( tls_hBindRpc, GetCurrentProcessId(), 0, NULL, &cSid);
    }
    catch(...)
    {
        //
        //  The QM is not running, let us load, all APIs
        //  will return no QM, no DS
        //
        return MQ_OK;
    }

    if (SUCCEEDED(hr))
    {
        //
        // The QM can duplicate handles to us, no need to worry anymore!
        //
        return MQ_OK;
    }

    if (hr != MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
    {
        return(hr);
    }

    // Allocate a buffer for the SID.
	g_pQmSid_buff.detach();
    g_pQmSid_buff = new char[cSid];
    // Get the SID.
    ASSERT( tls_hBindRpc ) ;
    hr = QMAttachProcess( tls_hBindRpc,
                          0,
                          cSid,
                          (unsigned char *)g_pQmSid,
                          &cSid);
    if (hr != MQ_OK)
    {
        return(hr);
    }

    // Get the process security descriptor.
    // First see how big is the security descriptor.
    GetKernelObjectSecurity(hProcess, DACL_SECURITY_INFORMATION, NULL, 0, &cSD);

    DWORD gle = GetLastError();
    if (gle != ERROR_INSUFFICIENT_BUFFER)
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR,
               TEXT("Failed to get process security descriptor (NULL buffer), error %d"),
               gle));

        return(MQ_ERROR);
    }

    // Allocate a buffer for the securiy descriptor.
	pSD_buff.detach();
    pSD_buff = new char[cSD];
    // Get the security descriptor.
    if (!GetKernelObjectSecurity(hProcess, DACL_SECURITY_INFORMATION, pSD, cSD, &cSD))
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR,
               TEXT("Failed to get process security descriptor, error %d"),
               GetLastError()));

        return(MQ_ERROR);
    }

    // Get the DACL from the security descriptor.
    bRet = GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefaulted);
    ASSERT(bRet);
    // Calculate the size of the new ACE.
    dwAceSize = sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(g_pQmSid) - sizeof(DWORD);

    if (bPresent)
    {
        // The security descriptor contains a DACL. Append our new ACE to this DACL.

        ACL_SIZE_INFORMATION AclSizeInfo;

        bRet = GetAclInformation(pDacl, &AclSizeInfo, sizeof(AclSizeInfo), AclSizeInformation);
        ASSERT(bRet);
        if (AclSizeInfo.AclBytesFree < dwAceSize)
        {
            // The currect DACL is not large enough.
            LPVOID pAce;
            // Calculate the size for the new DACL.
            DWORD dwNewDaclSize = AclSizeInfo.AclBytesInUse + dwAceSize;

            // Allocate a buffer for a new DACL.
			pNewDacl_buff.detach();
            pNewDacl_buff = new char[dwNewDaclSize];
            // Initialize the new DACL.
            bRet = InitializeAcl(pNewDacl, dwNewDaclSize, ACL_REVISION);
            ASSERT(bRet);
            // Copy the current ACEs to the new DACL.
            bRet = GetAce(pDacl, 0, &pAce);
            ASSERT(bRet); // Get current ACEs
            bRet = AddAce(pNewDacl, ACL_REVISION, 0, pAce, AclSizeInfo.AclBytesInUse - sizeof(ACL));
            ASSERT(bRet);
            pDacl = pNewDacl;
        }
    }
    else
    {
        // The security descriptor does not contain a DACL.
        // Calculate the size for the DACL.
        DWORD dwNewDaclSize = sizeof(ACL) + dwAceSize;

        // Allocate a buffer for the DACL.
		pNewDacl_buff.detach();
        pNewDacl_buff = new char[dwNewDaclSize];
        // Initialize the DACL.
        bRet = InitializeAcl(pNewDacl, dwNewDaclSize, ACL_REVISION);
        ASSERT(bRet);
        pDacl = pNewDacl;
    }

    // Add a new ACE that gives permission for the QM to duplicatge handles for the
    // application.
    bRet = AddAccessAllowedAce(pDacl, ACL_REVISION, PROCESS_DUP_HANDLE, g_pQmSid);
    ASSERT(bRet);

    // Initialize a new absolute security descriptor.
    bRet = InitializeSecurityDescriptor(&AbsSD, SECURITY_DESCRIPTOR_REVISION);
    ASSERT(bRet);
    // Set the DACL of the new absolute security descriptor.
    bRet = SetSecurityDescriptorDacl(&AbsSD, TRUE, pDacl, FALSE);
    ASSERT(bRet);

    // Set the security descriptor of the process.
    if (!SetKernelObjectSecurity(hProcess, DACL_SECURITY_INFORMATION, &AbsSD))
    {
        DBGMSG((DBGMOD_API, DBGLVL_ERROR,
               TEXT("Failed to set process security descriptor, error %d"),
               GetLastError()));

        return(MQ_ERROR);
    }

#undef pSD
#undef pNewDacl

    return(MQ_OK);
}

//---------------------------------------------------------
//
//  LPWSTR rtpGetComputerNameW()
//
//  Note: this function is exported, to be used by the control panel
//
//---------------------------------------------------------

LPWSTR rtpGetComputerNameW()
{
    return  g_lpwcsComputerName ;
}

//---------------------------------------------------------
//
//  FreeGlobals(...)
//
//  Description:
//
//      Release allocated globals
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

void  TerminateRxAsyncThread() ;
extern TBYTE* g_pszStringBinding ;
extern TBYTE* g_pszStringBinding2 ;

static void FreeGlobals()
{
    TerminateRxAsyncThread() ;
    if (g_lpwcsComputerName != g_wszRemoteQMName)
    {
       ASSERT(!g_fDependentClient) ;
       delete[] g_lpwcsComputerName;
    }
    delete [] g_lpwcsLocalComputerName;
    delete g_pSecCntx;

    BOOL fFree = TlsFree( g_hBindIndex ) ;
    ASSERT(fFree) ;
    fFree = TlsFree( g_dwThreadEventIndex ) ;
    ASSERT(fFree) ;

    mqrpcUnbindQMService( NULL, &g_pszStringBinding) ;
    mqrpcUnbindQMService( NULL, &g_pszStringBinding2);

    if (g_hMutexDTC)
    {
        CloseHandle(g_hMutexDTC);
    }

    fFree = TlsFree( g_hThreadIndex ) ;
    ASSERT(fFree) ;
}

//---------------------------------------------------------
//
//  FreeThreadGlobals(...)
//
//  Description:
//
//      Release per-thread allocated globals
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

static void  FreeThreadGlobals()
{
   HANDLE hEvent = TlsGetValue(g_dwThreadEventIndex);
   if (hEvent)
   {
      CloseHandle(hEvent) ;
   }

   if (g_hThreadIndex != UNINIT_TLSINDEX_VALUE)
   {
        HANDLE hThread = TlsGetValue(g_hThreadIndex);
        if ( hThread)
        {
            CloseHandle( hThread);
        }
   }

   RTpUnbindQMService() ;
}

static void OneTimeInit()
{
	//
	// Read name of remote QM (if exist).
	//
	DWORD dwType = REG_SZ ;
	DWORD dwSize = sizeof(g_wszRemoteQMName) ;
	LONG rc = GetFalconKeyValue( RPC_REMOTE_QM_REGNAME,
								 &dwType,
								 (PVOID) g_wszRemoteQMName,
								 &dwSize ) ;

	if(rc != ERROR_SUCCESS)
	{
        DBGMSG((DBGMOD_API, DBGLVL_ERROR,
               TEXT("Failed to retrieve remote QM name from registry, error %d"),
               GetLastError()));
		throw bad_hresult(rc);
	}

	//
	// Determine platform (win95/winNT). Use the A version on NT too
	// because we don't need any string, only the platform ID.
	//
	OSVERSIONINFOA osv ;
	osv.dwOSVersionInfoSize = sizeof(osv) ;

	BOOL f = GetVersionExA(&osv) ;
	ASSERT(f) ;
	DBG_USED(f);

	g_dwPlatformId = osv.dwPlatformId ;

	//
	//  Allocate TLS index for synchronic event.
	//
	g_dwThreadEventIndex = TlsAlloc();
	ASSERT(g_dwThreadEventIndex != UNINIT_TLSINDEX_VALUE) ;

	//
	// RPC cancel is supported on NT only
	//
	g_CancelRpc.Init();

	//
	// Initialize  RPC related data.
	//
	BOOL fRet = InitRpcGlobals() ;
	if (!fRet)
	{
        DBGMSG((DBGMOD_API, DBGLVL_ERROR,
               TEXT("Failed inside RpcGlobals(), error %d"),
               GetLastError()));
		throw bad_alloc();
	}

	//
	//  Initialize the QM per this process.
	//  Call this ONLY after initializing the RPC globals.
	//
	HRESULT hr = InitializeQM();
	if(FAILED(hr))
	{
        DBGMSG((DBGMOD_API, DBGLVL_ERROR,
               TEXT("Failed inside InitializeQM(), error %d"),
               GetLastError()));
		throw bad_hresult(hr);
	}

	DWORD dwDef = g_dwTimeToReachQueueDefault ;
	READ_REG_DWORD(g_dwTimeToReachQueueDefault,
		MSMQ_LONG_LIVE_REGNAME,
		&dwDef ) ;

	#ifdef RT_XACT_STUB
	g_hCommitThreadEvent = CreateEvent( NULL,
						   FALSE,  // auto reset
						   FALSE,  // initially not signalled
						   NULL ) ;

	g_hCommitThread = CreateThread( NULL,
							   0,       // stack size
							   RTCommitThread,
							   0,
							   0,       // creation flag
							   &g_dwCommitThreadId ) ;
	#endif

}

static CCriticalSection s_OneTimeInitLock(CCriticalSection::xAllocateSpinCount);
static bool s_fOneTimeInitSucceeded = false;

HRESULT DeppOneTimeInit()
{
	if(s_fOneTimeInitSucceeded)
		return MQ_OK;

	CS lock(s_OneTimeInitLock);
		
	try
	{
		if(s_fOneTimeInitSucceeded)
			return MQ_OK;

		OneTimeInit();
		s_fOneTimeInitSucceeded = true;

		return MQ_OK;
	}
	catch(const bad_hresult& hr)
	{
		return hr.error();
	}
	catch(const bad_alloc&)
	{
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
	catch(const exception&)
	{
		return MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//---------------------------------------------------------
//
//  DllMain(...)
//
//  Description:
//
//      Main entry point to Falcon Run Time Dll.
//
//  Return Value:
//
//      TRUE on success
//
//---------------------------------------------------------

BOOL
APIENTRY
DllMain(
    HINSTANCE   /*hInstance */,
    ULONG     ulReason,
    LPVOID            /*lpvReserved*/
    )
{
    switch (ulReason)
    {

        case DLL_PROCESS_ATTACH:
        {
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");

			g_fDependentClient = TRUE;

            break ;
        }

        case DLL_PROCESS_DETACH:
			if(!s_fOneTimeInitSucceeded)
				return TRUE;

			//
			// Due to delayed loading mechanism in mqrt.dll this dll should be 
			// loaded only in dependent mode
			//
			ASSERT(g_fDependentClient);

            //
            // First free whatever is free in THREAD_DETACH.
            //
            FreeThreadGlobals() ;

            FreeGlobals();

            //
            //  Terminate all working threads
            //
            ShutDownDebugWindow();

            WPP_CLEANUP();
            break;

        case DLL_THREAD_ATTACH:
			if(!s_fOneTimeInitSucceeded)
				return TRUE;

			//
			// Due to delayed loading mechanism in mqrt.dll this dll should be 
			// loaded only in dependent mode
			//
			ASSERT(g_fDependentClient);

            ASSERT(g_hBindIndex != UNINIT_TLSINDEX_VALUE) ;
            break;

        case DLL_THREAD_DETACH:
			if(!s_fOneTimeInitSucceeded)
				return TRUE;

			//
			// Due to delayed loading mechanism in mqrt.dll this dll should be 
			// loaded only in dependent mode
			//
			ASSERT(g_fDependentClient);

            FreeThreadGlobals() ;
            break;

    }
    return TRUE;
}

void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogRT,
                     LOG_RT_ERRORS,
                     L"RT Error: %s/%d, HR: 0x%x",
                     wszFileName,
                     usPoint,
                     hr)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtsecutl.cpp ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    rtsecutl.cpp

Abstract:

    Security related utility functions.

Author:

    Doron Juster  (DoronJ)  Feb 18, 1997

--*/

#include "stdh.h"
#include "cs.h"

#include "rtsecutl.tmh"

PMQSECURITY_CONTEXT g_pSecCntx = NULL ;

static CCriticalSection s_security_cs;

void InitSecurityContext()
{

    CS lock(s_security_cs);

    if(g_pSecCntx != 0)
    {
        return;
    }

    //
    // Allocate the structure for the chached process security context.
    //
    MQSECURITY_CONTEXT* pSecCntx = new MQSECURITY_CONTEXT;

    //
    //  Get the user's SID and put it in the chaed process security context.
    //
    RTpGetThreadUserSid(&pSecCntx->fLocalUser,
                        &pSecCntx->fLocalSystem,
                        &pSecCntx->pUserSid,
                        &pSecCntx->dwUserSidLen);

    //
    // Get the internal certificate of the process and place all the
    // information for this certificate in the chached process security
    // context.
    //
    GetCertInfo( FALSE,
                 pSecCntx->fLocalSystem,
                &pSecCntx->pUserCert,
                &pSecCntx->dwUserCertLen,
                &pSecCntx->hProv,
                &pSecCntx->wszProvName,
                &pSecCntx->dwProvType,
                &pSecCntx->bDefProv,
                &pSecCntx->bInternalCert ) ;
    //
    //  Set the global security context only after getting all information
    //  it is checked outside the critical (in other scope) seciton to get
    //  better performance
    //
    g_pSecCntx = pSecCntx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtsecutl.h ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    rtsecutl.h

Abstract:

    Security related utility functions.

Author:

    Doron Juster  (DoronJ)  Feb 19, 1997

--*/

extern PMQSECURITY_CONTEXT g_pSecCntx ;

extern void  InitSecurityContext() ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rtp.h

Abstract:

    RT DLL private internal functions

Author:

    Erez Haba (erezh) 24-Dec-95

--*/

#ifndef __RTP_H
#define __RTP_H

#include "rtpsec.h"
#include "_mqrpc.h"

#define SEND_PARSE  1
#define RECV_PARSE  2

#define QUEUE_CREATE    1
#define QUEUE_SET_PROPS 2
#define QUEUE_GET_PROPS 3

#define CPP_EXCEPTION_CODE 0xe06d7363

extern DWORD g_dwThreadEventIndex;
extern LPWSTR g_lpwcsComputerName;
extern DWORD g_dwComputerNameLen;
extern LPWSTR  g_lpwcsLocalComputerName;
extern BOOL   g_fDependentClient ;
extern WCHAR g_wszRemoteQMName[] ;
extern DWORD  g_dwPlatformId ;



HRESULT
RTpConvertToMQCode(
    HRESULT hr,
    DWORD dwObjectType =MQDS_QUEUE
    );

//
// The CMQHResult class is used in order to automatically convert the various
// error codes to Falcon error codes. This is done by defining the assignment
// operator of this class so it converts whatever error code that is assigned
// to objects of this class to a Falcon error code. The casting operator
// from this class to HRESULT, returns the converted error code.
//
class CMQHResult
{
public:
    CMQHResult(DWORD =MQDS_QUEUE); // Default constructor.
    CMQHResult(const CMQHResult &); // Copy constructor
    CMQHResult& operator =(HRESULT); // Assignment operator.
    operator HRESULT(); // Casting operator to HRESULT type.
    HRESULT GetReal(); // A method that returns the real error code.

private:
    HRESULT m_hr; // The converted error code.
    HRESULT m_real; // The real error code.
    DWORD m_dwObjectType; // The type of object (can be only queue, or machine).
};

//---------- CMQHResult implementation ----------------------------------

inline CMQHResult::CMQHResult(DWORD dwObjectType)
{
    ASSERT((dwObjectType == MQDS_QUEUE) || (dwObjectType == MQDS_MACHINE));
    m_dwObjectType = dwObjectType;
}

inline CMQHResult::CMQHResult(const CMQHResult &hr)
{
    m_hr = hr.m_hr;
    m_real = hr.m_real;
    m_dwObjectType = hr.m_dwObjectType;
}

inline CMQHResult& CMQHResult::operator =(HRESULT hr)
{
    m_hr = RTpConvertToMQCode(hr, m_dwObjectType);
    m_real = hr;

    return *this;
}

inline CMQHResult::operator HRESULT()
{
    return m_hr;
}

inline HRESULT CMQHResult::GetReal()
{
    return m_real;
}

//---------- CMQHResult implementation end ------------------------------

//---------- Function declarations --------------------------------------

HRESULT
RTpParseMessageProperties(
    LONG                     op,
    CACTransferBufferV2       *ptb,
    ULONG                    cProps,
    PROPID                   aPropID[],
    PROPVARIANT              aPropVar[],
    HRESULT                  aResult[],
    OUT PMQSECURITY_CONTEXT *ppSecCtx,
    OUT LPWSTR*              ppwcsResponseStringToFree,
    OUT LPWSTR*              ppwcsAdminStringToFree
    );

LPWSTR
RTpGetQueuePathNamePropVar(
    MQQUEUEPROPS *pqp
    );

GUID*
RTpGetQueueGuidPropVar(
    MQQUEUEPROPS *pqp
    );

enum QUEUE_PATH_TYPE{
    ILLEGAL_QUEUE_PATH_TYPE = 0,
    PRIVATE_QUEUE_PATH_TYPE,
    PUBLIC_QUEUE_PATH_TYPE,
    SYSTEM_QUEUE_PATH_TYPE
};

QUEUE_PATH_TYPE
RTpValidateAndExpandQueuePath(
    LPCWSTR pwcsPathName,
    LPCWSTR* ppwcsExpandedPathName,
    LPWSTR* ppStringToFree
    );

BOOL
RTpIsLocalPublicQueue(LPCWSTR lpwcsExpandedPathName) ;

BOOL
RTpFormatNameToQueueFormat(
    LPCWSTR lpwcsFormatName,
    QUEUE_FORMAT* pQueueFormat,
    LPWSTR* ppStringToFree
    );

HRESULT
RTpQueueFormatToFormatName(
    QUEUE_FORMAT* pQueueFormat,
    LPWSTR lpwcsFormatName,
    DWORD dwBufferLength,
    LPDWORD lpdwFormatNameLength
    );

HRESULT
RTpMakeSelfRelativeSDAndGetSize(
    PSECURITY_DESCRIPTOR *pSecurityDescriptor,
    PSECURITY_DESCRIPTOR *pSelfRelativeSecurityDescriptor,
    DWORD *pSDSize
    );

HRESULT
RTpCheckColumnsParameter(
    IN MQCOLUMNSET* pColumns
    );

HRESULT
RTpCheckQueueProps(
    IN  MQQUEUEPROPS* pqp,
    IN  DWORD         dwOp,
    IN  BOOL          fPrivateQueue,
    OUT MQQUEUEPROPS **ppGoodQP,
    OUT char **ppTmpBuff
    );

HRESULT
RTpCheckQMProps(
    IN  MQQMPROPS * pQMProps,
    IN OUT HRESULT* aStatus,
    OUT MQQMPROPS **ppGoodQMP,
    OUT char      **ppTmpBuff
    );

HRESULT
RTpCheckRestrictionParameter(
    IN MQRESTRICTION* pRestriction
    );

HRESULT
RTpCheckSortParameter(
    IN MQSORTSET* pSort
    );

HRESULT
RTpCheckLocateNextParameter(
    IN DWORD		cPropsRead,
    IN PROPVARIANT  aPropVar[]
	);

HRESULT
RTpCheckComputerProps(
    IN      MQPRIVATEPROPS * pPrivateProps,
    IN OUT  HRESULT*    aStatus
	);


HRESULT
RTpProvideTransactionEnlist(
    ITransaction *pTrans,
    XACTUOW *pUow
    );

VOID
RTpInitXactRingBuf(
    VOID
    );

HANDLE
GetThreadEvent(
    VOID
    );

HRESULT 
DeppOneTimeInit();


HRESULT
QMSendMessage(
    IN handle_t hBind,
    IN QUEUEHANDLE  hQueue,
    IN struct CACTransferBufferV2 *pCacTB
    );

HRESULT RTpGetSupportServerInfo(BOOL *pfRemote) ;

//
//  cursor information
//
struct CCursorInfo {
    HANDLE hQueue;
    HACCursor32 hCursor;
};
  

//
//  CCursorInfo to cursor handle
//
inline HACCursor32 CI2CH(HANDLE hCursor)
{
    return ((CCursorInfo*)hCursor)->hCursor;
}


//
//  CCursorInfo to queue handle
//
inline HANDLE CI2QH(HANDLE hCursor)
{
    return ((CCursorInfo*)hCursor)->hQueue;
}


//
//  Macro for extracting the explicit rpc binding handle from tls
//
#define UNINIT_TLSINDEX_VALUE   0xffffffff

extern DWORD  g_hBindIndex ;
#define tls_hBindRpc  ((handle_t) TlsGetValue( g_hBindIndex ))

#endif // __RTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtpsec.h ===
//
// file:  rtpsec.h
//
#ifndef _RTPSEC_H_
#define _RTPSEC_H_

#include <mqcrypt.h>
#include <cs.h>

//
// The security context.
//

#define SECURITY_CONTEXT_VER    1

class MQSECURITY_CONTEXT
{
public:
    MQSECURITY_CONTEXT();
    ~MQSECURITY_CONTEXT();

    DWORD       dwVersion;       // The version of the security context.
    BOOL        fLocalUser;      // Indicates whether the user is a local user.
    BOOL        fLocalSystem;    // Indicates whether the user is a localSystem account.
    P<BYTE>     pUserSid;        // A pointer to the user SID. Undefined for a local user.
    DWORD       dwUserSidLen;    // The length of the user SID. Undefined for a local user.
    CHCryptProv hProv;           // A context handle to the cert CSP.
    P<BYTE>     pUserCert;       // A pointer to the user cert.
    DWORD       dwUserCertLen;   // The length of the user cert.
    P<WCHAR>    wszProvName;     // The name of the cert CSP.
    DWORD       dwProvType;      // The type of the cert CSP.
    BOOL        bDefProv;        // True if the cert CSP is the default CSP.
    BOOL        bInternalCert;   // True if the cert is an internal MSMQ cert.

    //
    // Member variables added to fix MSMQ bug 2955
    //

    CCriticalSection CS ;      // critical section for multi-threaded.
    BOOL     fAlreadyImported ;  // Private key already imported.
    P<BYTE>  pPrivateKey ;       // Blob of private key.
    DWORD    dwPrivateKeySize ;  // size of private key blob.
    WCHAR    wszContainerName[ 28 ] ;  // Name of container for keys.

};

typedef MQSECURITY_CONTEXT *PMQSECURITY_CONTEXT;

PMQSECURITY_CONTEXT AllocSecurityContext() ;

HRESULT  RTpImportPrivateKey( PMQSECURITY_CONTEXT pSecCtx ) ;

HRESULT
GetCertInfo(
    IN    BOOL        bUseCurrentUser,
    IN    BOOL        bMachine,
    IN OUT BYTE     **ppbCert,
    OUT   DWORD      *pdwCertLen,
    OUT   HCRYPTPROV *phProv,
    OUT   LPWSTR     *wszProvName,
    OUT   DWORD      *pdwProvType,
    OUT   BOOL       *pbDefProv,
    OUT   BOOL       *pbInternalCert
    );

HRESULT
RTpGetThreadUserSid( BOOL   *pfLocalUser,
                     BOOL   *pfLocalSystem,
                     LPBYTE *ppUserSid,
                     DWORD  *pdwUserSidLen ) ;

#endif //_RTPSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtsecctx.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: rtsecctx.cpp

Abstract:

    This module implements the DepGetSecurityContext() and
    DepFreeSecurityContext() apis.

Author:

    Original version from message.cpp.
    Doron Juster (DoronJ)  12-Aug-1998

Revision History:

--*/

#include "stdh.h"
#include <autorel.h>
#include <_secutil.h>

#include "rtsecctx.tmh"

//
// Each security context get its own unique serial number. This is used
// when creating the name for a key container for DepGetSecurityContext().
// Having a unique name enable us to run multi-threaded without critical
// sections.
//
static LONG s_lCtxSerialNumber = 0 ;

#ifdef _DEBUG
#define REPORT_CTX_ERROR { DWORD dwErr = GetLastError() ; }
#else
#define REPORT_CTX_ERROR
#endif

//+--------------------------------------------
//
// The constractor for MQSECURITY_CONTEXT.
//
//+--------------------------------------------

MQSECURITY_CONTEXT::MQSECURITY_CONTEXT() :
                dwVersion(SECURITY_CONTEXT_VER),
                dwUserSidLen(0),
                dwUserCertLen(0),
                dwProvType(0),
                bDefProv(TRUE),
                bInternalCert(TRUE),
                fAlreadyImported(FALSE),
                dwPrivateKeySize(0),
                fLocalSystem(FALSE),
                fLocalUser(FALSE)
{
}

//+--------------------------------------------
//
// The destractor for MQSECURITY_CONTEXT.
//
//+--------------------------------------------

MQSECURITY_CONTEXT::~MQSECURITY_CONTEXT()
{
    if (fAlreadyImported)
    {
        CryptReleaseContext( hProv, 0 ) ;
        hProv = NULL ;

        //
        // delete the temporary keyset which was created before
        // importing the private key.
        //
        CryptAcquireContext( &hProv,
                              wszContainerName,
                              wszProvName.get(),
                              dwProvType,
                              CRYPT_DELETEKEYSET ) ;
        hProv = NULL ;
    }
}

//+-------------------------------
//
//  AllocSecurityContext()
//
//+-------------------------------

PMQSECURITY_CONTEXT
AllocSecurityContext()
{
    PMQSECURITY_CONTEXT pSecCtx =  new MQSECURITY_CONTEXT;
    return pSecCtx ;
}

//+---------------------------------------------------------------
//
//  BOOL SameAsProcessSid( PSID pSid )
//
//  Return TRUE if input sid is equal to sid of process token.
//
//+---------------------------------------------------------------

BOOL SameAsProcessSid( PSID pSid )
{
    AP<BYTE>  ptu = NULL ;
    CAutoCloseHandle  hAccessToken = NULL ;

    BOOL f = OpenProcessToken( GetCurrentProcess(),
                               TOKEN_QUERY,
                               &hAccessToken ) ;
    if (!f)
    {
        //
        // return false.
        // if thread can't open the process token then it's probably
        // impersonating a user that don't have the permission to do that.
        // so it's not the process user.
        //
        return FALSE ;
    }

    DWORD dwLen = 0 ;
    GetTokenInformation(hAccessToken, TokenUser, NULL, 0, &dwLen);
    DWORD dwErr = GetLastError() ;

    if (dwErr == ERROR_INSUFFICIENT_BUFFER)
    {
        ptu = new BYTE[ dwLen ] ;
        f = GetTokenInformation( hAccessToken,
                                 TokenUser,
                                 ptu.get(),
                                 dwLen,
                                 &dwLen) ;
        ASSERT(f) ;
        if (!f)
        {
            return FALSE ;
        }

        PSID pUser = ((TOKEN_USER*)(BYTE*)(ptu.get()))->User.Sid;
        f = EqualSid(pSid, pUser) ;
        return f ;
    }

    return FALSE ;
}

//+----------------------------------------------------------------
//
//  HRESULT  RTpImportPrivateKey( PMQSECURITY_CONTEXT pSecCtx )
//
//+----------------------------------------------------------------

HRESULT  RTpImportPrivateKey( PMQSECURITY_CONTEXT pSecCtx )
{
    CS Lock(pSecCtx->CS) ;

    if (pSecCtx->fAlreadyImported)
    {
        //
        // this condition may happen if two threads call MQSend() at the
        // same time, using a new security context which was not yet
        // imported.
        //
        return MQ_OK ;
    }

    if (!(pSecCtx->pPrivateKey.get()))
    {
        //
        // there is no private key to import.
        //
        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }

    //
    // Build name of key container. Combine ProcessID with SID.
    //
    LONG lNum = InterlockedIncrement(&s_lCtxSerialNumber) ;
    swprintf( pSecCtx->wszContainerName,
              L"P-%lu-C-%lu", GetCurrentProcessId(), (DWORD) lNum) ;
    //
    // Delete key container if already exist. That's something left
    // from previous processes which didn't clean up.
    //
    HCRYPTPROV hProv = NULL ;
    CryptAcquireContext( &hProv,
                          pSecCtx->wszContainerName,
                          pSecCtx->wszProvName.get(),
                          pSecCtx->dwProvType,
                          CRYPT_DELETEKEYSET ) ;

    //
    // Create the key container.
    //
    BOOL f = CryptAcquireContext( &pSecCtx->hProv,
                                   pSecCtx->wszContainerName,
                                   pSecCtx->wszProvName.get(),
                                   pSecCtx->dwProvType,
                                   CRYPT_NEWKEYSET ) ;
    if (!f)
    {
        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }

    //
    // Import the private key into the container.
    //
    HCRYPTKEY hKey = NULL ;
    f = CryptImportKey( pSecCtx->hProv,
                        pSecCtx->pPrivateKey,
                        pSecCtx->dwPrivateKeySize,
                        0,
                        0,
                        &hKey ) ;
    if (!f)
    {
        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }
    CryptDestroyKey(hKey) ;

    pSecCtx->fAlreadyImported = TRUE ;
    return MQ_OK ;
}

//+--------------------------------------
//
//  HRESULT  RTpExportSigningKey()
//
//+--------------------------------------

HRESULT  RTpExportSigningKey(MQSECURITY_CONTEXT *pSecCtx)
{
    CHCryptKey hKey = NULL ;

    BOOL f = CryptGetUserKey( pSecCtx->hProv,
         pSecCtx->bInternalCert ? AT_SIGNATURE : AT_KEYEXCHANGE,
                              &hKey ) ;
    if (!f)
    {
        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }

    //
    // Get size need for exporting the private key blob.
    //
    pSecCtx->dwPrivateKeySize = 0 ;
    f = CryptExportKey( hKey,
                        NULL,
                        PRIVATEKEYBLOB,
                        0,
                        NULL,
                        &pSecCtx->dwPrivateKeySize ) ;
    if (!f)
    {
        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }

    pSecCtx->pPrivateKey = new BYTE[ pSecCtx->dwPrivateKeySize ] ;
    f = CryptExportKey( hKey,
                        NULL,
                        PRIVATEKEYBLOB,
                        0,
                        pSecCtx->pPrivateKey.get(),
                        &pSecCtx->dwPrivateKeySize ) ;
    if (!f)
    {
        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }

    //
    // Release the CSP context handle. We don't need it anymore.
    // We'll acquire it again when importing the key.
    //
    CryptReleaseContext( pSecCtx->hProv, 0 ) ;
    pSecCtx->hProv = NULL ;

    return MQ_OK ;
}

/***********************************************************************
*
*   Function - DepGetSecurityContext()
*
*    Parameters -
*
*    lpCertBuffer - A buffer that contains the user's certificate in
*        ASN.1 DER encoded format.  This parameter can be set to NULL. If
*        set to NULL, the internal MSMQ certificate is used.
*
*    dwCertBufferLength - The length of the buffer pointed by lpCertBuffer.
*        This parameter is ignored if lpCertBuffer is set to NULL.
*
*    lplpSecurityContextBuffer - A pointer to a buffer that receives the
*        address of the allocated buffer for the security context.
*
*    Description -
*
*        This function should be called in the context of the
*        user that owns the passed certificate. The function
*        allocates the required security buffer and fills it
*        with data that will be used later in DepSendMessage().
*        The purpose of this function is to accelerate the
*        security operations of DepSendMessage(), by caching
*        the security information in the buffer. The
*        application is responsible to pass the security
*        context buffer to DepSendMessage() in
*        PROPID_M_SECURITY_CONTEXT.
*
*        If the user uses more than one certificate, this function
*        should be called for each certificate.
*
*        The application should call DepFreeSecurityContext() and pass the
*        pointer to the security context buffer, when the security
*        buffer is not required anymore.
*
*       Impersonation- It's possible for a process to impersonate a user,
*        then call this function to cache the user data, and then revert
*        to itself and send messages on behalf of that user.
*        To do so, the process must LogonUser() for the user, then load its
*        hive (RegLoadKey()), impersonate the logged on user and finally
*        call this function. Then revert and send messages.
*        With MSMQ1.0 which shipped with NTEE and NTOP, this function used
*        an unsupported and undocumented feature which enabled you just to
*        call CryptAcquireContext() while impersonated, then use the handle
*        after process revert to itself. This feature is not available on IE4
*        and above. The supported way to implement this functionality is to
*        export the private key from the user hive, then (after reverting) to
*        import it into the process hive. See MSMQ bug 2955
*        We'll keep the CryptAcquireContext() code for the case of same user
*        (i.e., thread run in the context of the process user. There was no
*        impersonation). In that case it's legal and enhance performance.
*
*    Return Value -
*        MQ_OK  - If successful, else - Error code.
*
**************************************************************************/

EXTERN_C HRESULT APIENTRY
DepGetSecurityContext( LPVOID  lpCertBuffer,
                      DWORD   dwCertBufferLength,
                      HANDLE *hSecurityContext )
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    P<MQSECURITY_CONTEXT> pSecCtx = AllocSecurityContext();
    P<BYTE>    pSid = NULL ;
    HRESULT hr = MQ_OK;

    try
    {
        //
        // Get the user SID out from the thread (or process) token.
        //
        hr = RTpGetThreadUserSid( &pSecCtx->fLocalUser,
                                  &pSecCtx->fLocalSystem,
                                  &pSecCtx->pUserSid,
                                  &pSecCtx->dwUserSidLen ) ;

        if (FAILED(hr))
        {
            return(hr);
        }

        if (lpCertBuffer)
        {
            //
            // Copy the certificate and point to the copy from the security
            // context.
            //
            pSecCtx->pUserCert.detach();
            pSecCtx->pUserCert = new BYTE[dwCertBufferLength];
            pSecCtx->dwUserCertLen = dwCertBufferLength;
            memcpy(pSecCtx->pUserCert.get(), lpCertBuffer, dwCertBufferLength);
        }

		BYTE* pUserCert = pSecCtx->pUserCert.get();
		BYTE** ppUserCert = pUserCert == NULL ? &pSecCtx->pUserCert : &pUserCert;

        //
        // Get all the required information about the certificate and
        // put it in the security context.
        //
        hr  = GetCertInfo(  false,
                            pSecCtx->fLocalSystem,
                           ppUserCert,
                           &pSecCtx->dwUserCertLen,
                           &pSecCtx->hProv,
                           &pSecCtx->wszProvName,
                           &pSecCtx->dwProvType,
                           &pSecCtx->bDefProv,
                           &pSecCtx->bInternalCert ) ;

        if (FAILED(hr) && (hr != MQ_ERROR_NO_INTERNAL_USER_CERT))
        {
            return(hr);
        }

        if (hr == MQ_ERROR_NO_INTERNAL_USER_CERT)
        {
            //
            // If the user does not have an internal certificate,
            // this is not a reason to fail DepGetSecurityContext().
            // DepSendMessage() should fail in case the application
            // tries to use this security context to send an
            // authenticated messages.
            //
            *hSecurityContext = (HANDLE) pSecCtx.get();
            pSecCtx.detach() ; // Prevent from the security context to be freed.

            return MQ_OK;
        }

        //
        // See if process sid match thread sid. We call again
        // GetThreadUserSid() to get sid even for local user.
        // RTpGetThreadUserSid() does not return a sid for local user.
        //
        DWORD dwLen = 0 ;
        hr = GetThreadUserSid( &pSid, &dwLen ) ;
        if (FAILED(hr))
        {
            return hr ;
        }

        BOOL fAsProcess = SameAsProcessSid( pSid.get() ) ;

        if (fAsProcess)
        {
            //
            // Thread run under context of process credentials.
            // The Crypto context acquired here is valid for using when
            // calling MQSend().
            //
            *hSecurityContext = (HANDLE) pSecCtx.get() ;
            pSecCtx.detach() ; // Prevent from the security context to be freed.

            return MQ_OK;
        }

        //
        // Calling code impersonated another user.
        // It's time to export the private key. Later, when calling
        // MQSend(), we'll import it into process hive.
        // We export the private key without encryption, because it
        // dones't leave the machine or the process boundaries.
        //
        hr = RTpExportSigningKey(pSecCtx.get()) ;
        if (SUCCEEDED(hr))
        {
            //
            // Pass the result to the caller.
            //
            *hSecurityContext = (HANDLE) pSecCtx.get();
            pSecCtx.detach(); // Prevent from the security context to be freed.
        }
    }
    catch(...)
    {
        hr = MQ_ERROR_INVALID_PARAMETER;
    }

    return(hr);
}

/*************************************************************************
*
*    Function -  DepFreeSecurityContext()
*
*    Parameters -
*        lpSecurityContextBuffer - A pointer to a security context that was
*        previously allocated by DepGetSecurityContext.
*
*    Description -
*        The function frees the security context that was previously
*        allocated by DepGetSecurityContext().
*
**************************************************************************/

void APIENTRY
DepFreeSecurityContext( HANDLE hSecurityContext )
{
	ASSERT(g_fDependentClient);

	if(FAILED(DeppOneTimeInit()))
		return;

    PMQSECURITY_CONTEXT pSecCtx = (PMQSECURITY_CONTEXT)hSecurityContext;
    delete pSecCtx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtrpc.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rtrpc.cpp

Abstract:

    Rpc related stuff.

Author:

    Doron Juster (DoronJ)  04-Jun-1997

Revision History:

--*/

#include "stdh.h"
#include "mqutil.h"
#include "_mqrpc.h"
#include "mqsocket.h"
#include "ad.h"
#include "rtfrebnd.h"
#include "rtprpc.h"
#include "mgmtrpc.h"
#include "acrt.h"
#include <mqsec.h>

#include "rtrpc.tmh"

CFreeRPCHandles  g_cFreeRpcHandles ;

//
// These two flags indicate if LOCAL machine support these protocols.
//
static BOOL   s_fIPSupported = TRUE ;
static BOOL   s_fIPxSupported = TRUE ;

//
// FASLE (default) when using dynamic endpoints.
// TRUE in debug mode, multiple QMs on a machine, when using fix endpoints.
//
static BOOL  s_fUsePredefinedEP = RPC_DEFAULT_PREDEFINE_QM_EP ;

//
// Fix rpc ports (debug mode), read from registry.
//
#define  MAX_RPC_PORT_LEN  12
static TCHAR   s_wszRpcIpPort[ MAX_RPC_PORT_LEN ] ;
static TCHAR   s_wszRpcIpxPort[ MAX_RPC_PORT_LEN ] ;

static TCHAR   s_wszRpcIpPort2[ MAX_RPC_PORT_LEN ] ;
static TCHAR   s_wszRpcIpxPort2[ MAX_RPC_PORT_LEN ] ;

//
// The binding string MUST be global and kept valid all time.
// If we create it on stack and free it after each use then we can't
// create more then one binding handle.
// Don't ask me (DoronJ) why, but this is the case.
//
TBYTE* g_pszStringBinding = NULL ;
TBYTE* g_pszStringBinding2= NULL ;

//
//  Critical Section to make RPC thread safe.
//
CCriticalSection CRpcCS ;

DWORD g_dwClientProtocol = 0 ;

//
//  License related data.
//
GUID  g_LicGuid ;
BOOL  g_fLicGuidInit = FALSE ;

//
//  Tls index for canceling RPC calls
//
#define UNINIT_TLSINDEX_VALUE   0xffffffff
DWORD  g_hThreadIndex = UNINIT_TLSINDEX_VALUE ;


//
// Local endpoints to QM
//
AP<WCHAR> g_pwzQmsvcEndpoint = 0;
AP<WCHAR> g_pwzQmsvcEndpoint2 = 0;
AP<WCHAR> g_pwzQmmgmtEndpoint = 0;


//---------------------------------------------------------
//
//  RTpUnbindQMService(...)
//
//  Description:
//
//      Set RPC binding handle to the QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

void RTpUnbindQMService()
{
   handle_t hBind = tls_hBindRpc;
   g_cFreeRpcHandles.Add(hBind);
   BOOL fSet = TlsSetValue( g_hBindIndex, NULL);
   ASSERT(fSet);
   DBG_USED(fSet);
}

//---------------------------------------------------------
//
//  RTpGetLocalQMBind(...)
//
//  Description:
//
//      Create RPC binding handle to a local QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

handle_t RTpGetLocalQMBind( TBYTE** ppStringBinding,
                            LPTSTR  pEndpoint)
{
      RPC_STATUS rc;
      if(!*ppStringBinding)
      {
          rc = RpcStringBindingCompose(
              0,
              RPC_LOCAL_PROTOCOL,
              0,
              pEndpoint,
              RPC_LOCAL_OPTION,
              ppStringBinding
              );

          ASSERT(rc == RPC_S_OK);
      }

      handle_t hBind;
      rc = RpcBindingFromStringBinding(*ppStringBinding, &hBind);
      ASSERT(rc == RPC_S_OK);

      return hBind;
}

//---------------------------------------------------------
//
//  RTpGetQMServiceBind(...)
//
//  Description:
//
//      Create RPC binding handle to the QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

handle_t RTpGetQMServiceBind(BOOL fAlternate /*= FALSE*/)
{
    handle_t hBind = 0;
    CS Lock(CRpcCS) ;

    g_cFreeRpcHandles.FreeAll() ;

    if (g_fDependentClient)
    {
        HRESULT hr ;
        LPWSTR lpServer = &g_wszRemoteQMName[0] ;
        MQRPC_AUTHENTICATION_LEVEL _eAuthnLevel = MQRPC_SEC_LEVEL_MAX ;

        hr =  RTpBindRemoteQMService(
                       lpServer,
                       &g_dwClientProtocol,
                       &hBind,
                       &_eAuthnLevel,
                       (g_dwClientProtocol != 0),
                       fAlternate
                       );

        if (FAILED(hr))
        {
           ASSERT(hBind == 0) ;
           g_dwClientProtocol = 0 ;
           hBind = 0 ;
        }
    }
    else
    {
        if(fAlternate)
        {
            //
            //  Alternate End point is used for receives on win95, so we will
            //  get the correct rundown when the application crashes.
            //  Work only with DCOM95.
            //
            hBind = RTpGetLocalQMBind(&g_pszStringBinding2, g_pwzQmsvcEndpoint2.get());
        }
        else
        {
            hBind = RTpGetLocalQMBind(&g_pszStringBinding, g_pwzQmsvcEndpoint.get());
        }
    }

    return hBind;
}

//---------------------------------------------------------
//
//  RTpBindQMService(...)
//
//  Description:
//
//      Set RPC binding handle to the QM service.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

void RTpBindQMService()
{
    handle_t hBind = RTpGetQMServiceBind();

    BOOL fSet = TlsSetValue(g_hBindIndex, hBind);
    ASSERT(fSet) ;
	DBG_USED(fSet);
}

enum DirectQueueType
{
    dqtNONE = 0,
    dqtTCP  = 1,
    dqtSPX  = 2,
    dqtANY  = 3
};

DirectQueueType
GetDirectQueueType (
    LPWSTR* lpwsDirectQueuePath
    )
{

    if (!_wcsnicmp(*lpwsDirectQueuePath, FN_DIRECT_TCP_TOKEN, FN_DIRECT_TCP_TOKEN_LEN))
    {
        *lpwsDirectQueuePath += FN_DIRECT_TCP_TOKEN_LEN;
        return dqtTCP;
    }
    if (!_wcsnicmp(*lpwsDirectQueuePath, FN_DIRECT_OS_TOKEN, FN_DIRECT_OS_TOKEN_LEN))
    {
        *lpwsDirectQueuePath += FN_DIRECT_OS_TOKEN_LEN;
        return dqtANY;
    }

    return (dqtNONE);

}

static
void ExtractMachineName(
    LPWSTR pQueue,
    AP<WCHAR> &pMachine
    )
{
    //
    // If the remote queue is a direct queue, the routine removes
    // the direct queue type from the queue name. (it keeps with the
    // direct type in the QM to distinguish between different queues).
    // The routine below extract the machine name from the queue name
    // and create the RPC call. If the direct queue type is "TCP" or "SPX"
    // the routine also return the protocol type;
    //
    switch(GetDirectQueueType(&pQueue))
    {
        case dqtTCP:
        case dqtANY:
        case dqtNONE:
            {
                LPWSTR lpwcsSlash = wcschr(pQueue, L'\\') ;
                size_t MachineNameLen = 0 ;
                if (lpwcsSlash)
                {
                    MachineNameLen = lpwcsSlash - pQueue;
                }
                else
                {
                    MachineNameLen = wcslen(pQueue);
                }
                pMachine = new WCHAR[MachineNameLen + 1];
                wcsncpy(pMachine, pQueue, MachineNameLen) ;
                pMachine[MachineNameLen] = '\0';

                break;
            }

        case dqtSPX:
            {

                //
                // For SPX address, remove the ':' from the name
                // need for direct read from SPX direct format name
                //                   Uri Habusha (urih), 15-Sep-98
                //
                size_t size;
                LPWSTR pSeparator;

                pMachine = new WCHAR[wcslen(pQueue) + 2];

                LPWSTR pTempMachine = pMachine;

                wcscpy(pTempMachine, L"~");
                pTempMachine += 1;

                pSeparator  = wcschr(pQueue, L':');
                ASSERT(pSeparator != NULL);
                size = pSeparator - pQueue;

                wcsncpy(pTempMachine, pQueue, size);
                pTempMachine += size;

                pQueue = pSeparator + 1;

                pSeparator = wcschr(pQueue, L'\\') ;
                ASSERT(pSeparator != NULL);
                size = pSeparator - pQueue;

                wcsncpy(pTempMachine, pQueue, size);
                pTempMachine += size;

                *pTempMachine = L'\0';

                break;
            }
        default:
            ASSERT(0);
    }
}

//---------------------------------------------------------
//
//  RTpBindRemoteQMService(...)
//
//  Description:
//
//      Create RPC binding handle to a remote QM service.
//      First try IP then IPx.
//
//  Return Value:
//
//      None
//
//---------------------------------------------------------

HRESULT
RTpBindRemoteQMService(
    IN  LPWSTR     lpwNodeName,
    IN OUT  DWORD  *pdwProtocol,
    OUT handle_t*  lphBind,
    IN  OUT MQRPC_AUTHENTICATION_LEVEL *peAuthnLevel,
    IN  BOOL       fUseThisProtocol /*= FALSE*/,
    IN  BOOL       fAlternate /*= FALSE*/
    )
{
    *pdwProtocol = *pdwProtocol & (~PORTTYPE_WIN95) ;
    MQRPC_AUTHENTICATION_LEVEL originalAuthenLevel = *peAuthnLevel;

    if (*pdwProtocol == 0)
    {
        if (s_fIPSupported)
        {
            *pdwProtocol = IP_ADDRESS_TYPE ;
        }
        else
        {
            ASSERT(s_fIPxSupported) ;
            *pdwProtocol = IPX_ADDRESS_TYPE ;
        }
    }
    else if (fUseThisProtocol)
    {
        if (*pdwProtocol == IPX_ADDRESS_TYPE)
        {
            ASSERT(s_fIPxSupported) ;
        }
        else
        {
            ASSERT(s_fIPSupported) ;
        }
    }
    else
    {
        ASSERT(*pdwProtocol == IP_ADDRESS_TYPE) ;

        if (s_fIPxSupported)
        {
            *pdwProtocol = IPX_ADDRESS_TYPE ;
        }
        else
        {
            return MQ_ERROR_SERVICE_NOT_AVAILABLE ;
        }
    }

    AP<WCHAR> wszServer = NULL ;
    ExtractMachineName(lpwNodeName, wszServer) ;

    HRESULT hr = MQ_ERROR ;
    BOOL fTryBinding = FALSE ;
    BOOL fWin95 = FALSE ;

    do
    {
        fTryBinding = FALSE ;
        TCHAR *pPort ;
        DWORD dwPortType = (DWORD) -1 ;

        if (*pdwProtocol == IP_ADDRESS_TYPE)
        {
            if (fAlternate)
            {
               pPort = s_wszRpcIpPort2 ;
               dwPortType = (DWORD) IP_READ ;
            }
            else
            {
               pPort = s_wszRpcIpPort;
               dwPortType = (DWORD) IP_HANDSHAKE ;
            }
        }
        else
        {
            ASSERT(*pdwProtocol == IPX_ADDRESS_TYPE) ;
            if (fAlternate)
            {
               pPort = s_wszRpcIpxPort2 ;
               dwPortType = (DWORD) IPX_READ ;
            }
            else
            {
               pPort = s_wszRpcIpxPort;
               dwPortType = (DWORD) IPX_HANDSHAKE ;
            }
        }

        GetPort_ROUTINE pfnGetPort = QMGetRTQMServerPort ;
        if (!s_fUsePredefinedEP)
        {
           pPort = NULL ;
        }

        BOOL fProtocolNotSupported ;

        //
        // Choose authentication service. For LocalSystem services, chose
        // "negotiate" and let mqutil select between Kerberos or ntlm.
        // For all other cases, use ntlm.
        // LocalSystem service go out to network without any credentials
        // if using ntlm, so only for it we're interested in Kerberos.
        // All other are fine with ntlm. For remote read we do not need
        // delegation, so we'll stick to ntlm.
        // The major issue here is a bug in rpc/security, whereas a nt4
        // user on a win2k machine can successfully call
        //  status = RpcBindingSetAuthInfoEx( ,, RPC_C_AUTHN_GSS_KERBEROS,,)
        // although it's clear he can't obtain any Kerberos ticket (he's
        // nt4 user, defined only in nt4 PDC).
        //
        ULONG   ulAuthnSvc = RPC_C_AUTHN_WINNT ;
        BOOL fLocalUser =  FALSE ;
        BOOL fLocalSystem = FALSE ;

        hr = MQSec_GetUserType( NULL,
                               &fLocalUser,
                               &fLocalSystem ) ;
        if (SUCCEEDED(hr) && fLocalSystem)
        {
            ulAuthnSvc = MSMQ_AUTHN_NEGOTIATE ;
        }

        hr = mqrpcBindQMService(wszServer,
                                *pdwProtocol,
                                pPort,
                                peAuthnLevel,
                                &fProtocolNotSupported,
                                lphBind,
                                dwPortType,
                                pfnGetPort,
                                &fWin95,
                                ulAuthnSvc ) ;
        if (FAILED(hr))
        {
           if (fProtocolNotSupported)
           {
              //
              // our machine does not support present protocol.
              // Try another one.
              //
              if (*pdwProtocol == IP_ADDRESS_TYPE)
              {
                  s_fIPSupported = FALSE ;
                  *pdwProtocol = IPX_ADDRESS_TYPE ;
                  fTryBinding = TRUE ;
              }
              else
              {
                  s_fIPxSupported = FALSE ;
              }
           }
           else if ((*pdwProtocol == IP_ADDRESS_TYPE) && s_fIPxSupported)
           {
              //
              // Other side is not reachable with tcp/ip. Try ipx.
              //
              *pdwProtocol = IPX_ADDRESS_TYPE ;
              fTryBinding = TRUE ;
           }
        }
        if ( fTryBinding)
        {
            //
            // return to the original authentication level
            //
            *peAuthnLevel = originalAuthenLevel;
        }
    }
    while (fTryBinding) ;

    if (SUCCEEDED(hr) && fWin95)
    {
       *pdwProtocol = *pdwProtocol |  PORTTYPE_WIN95 ;
    }

    return hr ;
}



//---------------------------------------------------------
//
//  InitRpcGlobals(...)
//
//  Description:
//
//      Initialize RPC related names and other constant data
//
//  Return Value:
//
//---------------------------------------------------------

BOOL InitRpcGlobals()
{
    //
    //  Allocate TLS for  RPC connection with local QM service
    //
    g_hBindIndex = TlsAlloc() ;
    ASSERT(g_hBindIndex != UNINIT_TLSINDEX_VALUE) ;
    if (g_hBindIndex == UNINIT_TLSINDEX_VALUE)
    {
       return FALSE ;
    }
    else
    {
       BOOL fSet = TlsSetValue( g_hBindIndex, NULL ) ;
       ASSERT(fSet) ;
	   DBG_USED(fSet);
    }

    if (g_fDependentClient)
    {
		HRESULT hr1 = ADInit(
			NULL,
			RTpGetSupportServerInfo,
			false,
			false,
			false,
			false,
			NULL,
			NULL,
            false   // fDisableDownlevelNotifications
            );

		ASSERT(hr1 == MQ_OK) ;
		DBG_USED(hr1);
    }


    //
    // Initialize local endpoints to QM
    //

    ComposeLocalEndPoint(QMMGMT_ENDPOINT, &g_pwzQmmgmtEndpoint);

    READ_REG_STRING(wzEndpoint, RPC_LOCAL_EP_REGNAME, RPC_LOCAL_EP);
    ComposeLocalEndPoint(wzEndpoint, &g_pwzQmsvcEndpoint);

    if ((g_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) ||
        (g_fDependentClient))
    {
        READ_REG_STRING(wzEndpoint, RPC_LOCAL_EP_REGNAME2, RPC_LOCAL_EP2);
        ComposeLocalEndPoint(wzEndpoint, &g_pwzQmsvcEndpoint2);
    }


    //
    // Read QMID. Needed for licensing.
    //
    DWORD dwValueType = REG_BINARY ;
    DWORD dwValueSize = sizeof(GUID);

    LONG rc = GetFalconKeyValue( MSMQ_QMID_REGNAME,
                            &dwValueType,
                            &g_LicGuid,
                            &dwValueSize);

    if (rc == ERROR_SUCCESS)
    {
        g_fLicGuidInit = TRUE ;
        ASSERT((dwValueType == REG_BINARY) &&
               (dwValueSize == sizeof(GUID)));
    }

    //
    // Read the IP and IPX ports for RPC.
    // First see if we use dynamic or predefined endpoints.
    //
    //
    DWORD ulDefault =  RPC_DEFAULT_PREDEFINE_QM_EP ;
    READ_REG_DWORD( s_fUsePredefinedEP,
                    RPC_PREDEFINE_QM_EP_REGNAME,
                    &ulDefault );

    if (s_fUsePredefinedEP)
    {
       READ_REG_STRING( wzQMIPEp,
                        FALCON_QM_RPC_IP_PORT_REGNAME,
                        FALCON_DEFAULT_QM_RPC_IP_PORT ) ;
       ASSERT(wcslen(wzQMIPEp) < MAX_RPC_PORT_LEN) ;
       wcscpy(s_wszRpcIpPort, wzQMIPEp) ;

       READ_REG_STRING( wzQMIPEp2,
                        FALCON_QM_RPC_IP_PORT_REGNAME2,
                        FALCON_DEFAULT_QM_RPC_IP_PORT2 ) ;
       ASSERT(wcslen(wzQMIPEp2) < MAX_RPC_PORT_LEN) ;
       wcscpy(s_wszRpcIpPort2, wzQMIPEp2) ;

       READ_REG_STRING( wzQMIPxEp,
                        FALCON_QM_RPC_IPX_PORT_REGNAME,
                        FALCON_DEFAULT_QM_RPC_IPX_PORT ) ;
       ASSERT(wcslen(wzQMIPxEp) < MAX_RPC_PORT_LEN) ;
       wcscpy(s_wszRpcIpxPort, wzQMIPxEp) ;

       READ_REG_STRING( wzQMIPxEp2,
                        FALCON_QM_RPC_IPX_PORT_REGNAME2,
                        FALCON_DEFAULT_QM_RPC_IPX_PORT2 ) ;
       ASSERT(wcslen(wzQMIPxEp2) < MAX_RPC_PORT_LEN) ;
       wcscpy(s_wszRpcIpxPort2, wzQMIPxEp2) ;
    }
    //
    //  Allocate TLS for  cancel remote-read RPC calls
    //
    g_hThreadIndex = TlsAlloc() ;
    ASSERT(g_hThreadIndex != UNINIT_TLSINDEX_VALUE) ;
    if (g_hThreadIndex == UNINIT_TLSINDEX_VALUE)
    {
       return FALSE ;
    }
    else
    {
       BOOL fSet = TlsSetValue( g_hThreadIndex, NULL ) ;
       ASSERT(fSet) ;
	   DBG_USED(fSet);
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    stdh.h

Abstract:

Author:

    Erez Haba (erezh) 24-Dec-95

--*/

#ifndef __STDH_H
#define __STDH_H

#include <_stdh.h>

#include <qformat.h>
#include <transact.h>
#include <qmrt.h>
#include <rtdep.h>
#include <mqlog.h>

#include "rtp.h"

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\xactmq.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactMq.h

Abstract:
    This module defines CMQTransaction object

Author:
    Alexander Dadiomov (AlexDad)

--*/

#ifndef __XACTMQ_H__
#define __XACTMQ_H__

//IID_IMSMQTransaction 2f221ca0-d1de-11d0-9215-0060970536a0
DEFINE_GUID(IID_IMSMQTransaction,
		    0x2f221ca0,
		    0xd1de,
		    0x11d0,
		    0x92, 0x15, 0x00, 0x60, 0x97, 0x05, 0x36, 0xa0);

interface IMSMQTransaction : public IUnknown
{
public:
    virtual HRESULT __stdcall EnlistTransaction(XACTUOW *pUow) = 0;
};


//---------------------------------------------------------------------
// CMQTransaction: Transaction Object in Falcon RT
//---------------------------------------------------------------------
class CMQTransaction: public ITransaction, 
                      public IMSMQTransaction
{
public:

    // Construction and COM
    //
    CMQTransaction();
    ~CMQTransaction( void );

    STDMETHODIMP    QueryInterface( REFIID i_iid, void **ppv );
    STDMETHODIMP_   (ULONG) AddRef( void );
    STDMETHODIMP_   (ULONG) Release( void );

    STDMETHODIMP Commit( 
            /* [in] */ BOOL fRetaining,
            /* [in] */ DWORD grfTC,
            /* [in] */ DWORD grfRM);
        
    STDMETHODIMP Abort( 
            /* [in] */ BOID *pboidReason,
            /* [in] */ BOOL fRetaining,
            /* [in] */ BOOL fAsync);
        
    STDMETHODIMP  GetTransactionInfo( 
            /* [out] */ XACTTRANSINFO *pinfo);

    STDMETHODIMP   EnlistTransaction(
            /* in]  */  XACTUOW *pUow);

private:
    LONG    m_cRefs;
    BOOL    m_fCommitedOrAborted;       
    XACTUOW m_Uow;

    RPC_INT_XACT_HANDLE m_hXact;
};

#endif __XACTMQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\xactsink.h ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactSink.h

Abstract:
    This module defines CStubIResourceManagerSink object

Author:
    Alexander Dadiomov (AlexDad)

--*/

//---------------------------------------------------------------------
// CStubIResourceManagerSink:
//---------------------------------------------------------------------

class CStubIResourceManagerSink: public IResourceManagerSink
{
public:
	
	CStubIResourceManagerSink(void);
	~CStubIResourceManagerSink(void);

    STDMETHODIMP			QueryInterface(REFIID i_iid, LPVOID FAR* ppv);
	STDMETHODIMP_ (ULONG)	AddRef(void);
	STDMETHODIMP_ (ULONG)	Release(void);

	// IResourceManagerSink interface:
	// Defines the TMDown interface to notify RM when the transaction
	// transaction manager is down.
	//		TMDown			-- callback received when the TM goes down

	STDMETHODIMP			TMDown(void);
	
private:
	ULONG	m_cRefs;

};

extern HRESULT InitStubRm();

extern HRESULT MQStubRM(ITransaction *pTrans);

class CStub: public ITransactionResourceAsync
{
public:

     CStub();
    ~CStub();

    STDMETHODIMP    QueryInterface( REFIID i_iid, void **ppv );
    STDMETHODIMP_   (ULONG) AddRef( void );
    STDMETHODIMP_   (ULONG) Release( void );

    STDMETHODIMP    PrepareRequest(BOOL fRetaining,
                                   DWORD grfRM,
                                   BOOL fWantMoniker,
                                   BOOL fSinglePhase);
    STDMETHODIMP    CommitRequest (DWORD grfRM,
                                   XACTUOW *pNewUOW);
    STDMETHODIMP    AbortRequest  (BOID *pboidReason,
                                   BOOL fRetaining,
                                   XACTUOW *pNewUOW);
    STDMETHODIMP    TMDown        (void);

    void SetEnlist(ITransactionEnlistmentAsync *pEnlist);

private:
    ULONG  m_cRefs;
    ITransactionEnlistmentAsync *m_pEnlist;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\xactdata.cpp ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactData.cpp

Abstract:
    Static GUID definitions for xact processing

Author:
    Alexander Dadiomov (AlexDad)

--*/

#include "stdh.h"

#define   INITGUID	
#include "initguid.h"

#define _MTX_NOFORCE_LIBS 
#include "comsvcs.h"
#include "TXDTC.H"

#include "xactmq.h"
#include "xactdata.tmh"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\xactrt.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    XactRT.cpp

Abstract:

    This module contains RT code involved with transactions.

Author:

    Alexander Dadiomov (alexdad) 19-Jun-96

Revision History:

--*/

#include "stdh.h"
#include "TXDTC.H"
#include "txcoord.h"
#include "xactsink.h"
#include "cs.h"
#include "mqutil.h"
#include "rtprpc.h"
#include "xactmq.h"

#include "xactrt.tmh"

//RT transactions cache:  ring buffer of transaction UOWs
#define XACT_RING_BUF_SIZE   16                        // size of the transactions ring buffer

static  XACTUOW  s_uowXactRingBuf[XACT_RING_BUF_SIZE];   // transaction ring buffer

ULONG   s_ulXrbFirst =  XACT_RING_BUF_SIZE;  // First used element in transaction ring buffer
ULONG   s_ulXrbLast  =  XACT_RING_BUF_SIZE;  // Last  used element in transaction ring buffer

static BOOL             g_DtcInit = FALSE;
static ULONG            g_StubRmCounter = 0;

static CCriticalSection s_RingBufCS;

// Whereabouts of the controlling DTC for the QM
// For the dependent client it will be non-local
ULONG     g_cbQmTmWhereabouts = 0;      // length of DTC whereabouts
BYTE     *g_pbQmTmWhereabouts = NULL;   // DTC whereabouts

static ITransactionExport *g_pExport = NULL;  // cached DTC export object

HANDLE g_hMutexDTC = NULL;   // Serializes calls to DTC

extern HRESULT DepGetTmWhereabouts(
                   IN  DWORD  cbBufSize,
                   OUT UCHAR *pbWhereabouts,
                   OUT DWORD *pcbWhereabouts);

/*====================================================
GetMutex
    Internal: creates/opens global mutex and waits for it
=====================================================*/
HRESULT GetMutex()
{
    if (!g_hMutexDTC)
    {
         g_hMutexDTC = CreateMutexA(NULL, FALSE, "MSMQ_DTC");
    }

    if (!g_hMutexDTC)
    {
        DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("CreateMutex failed: %x "), 0));
        return MQ_ERROR_DTC_CONNECT;
    }

    WaitForSingleObject(g_hMutexDTC, 5 * 60 * 1000);
    return MQ_OK;
}

//---------------------------------------------------------
//  BOOL FindTransaction( XACTUOW *pUow )
//
//  Description:
//
//    Linear search in the ring buffer;  *not* adds
//    returns TRUE if xaction was found, FALSE - if not
//---------------------------------------------------------
static BOOL FindTransaction(XACTUOW *pUow)
{
    CS lock(s_RingBufCS);

    // Look for the UOW in the ring buffer
    for (ULONG i = s_ulXrbFirst; i <= s_ulXrbLast && i < XACT_RING_BUF_SIZE; i++)
    {
        if (memcmp(&s_uowXactRingBuf[i], pUow, sizeof(XACTUOW))==0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//---------------------------------------------------------
//  BOOL RememberTransaction( XACTUOW *pUow )
//
//  Description:
//
//    Linear search in the ring buffer;  adds there if not found;
//    returns TRUE if xaction was found, FALSE - if it was added
//---------------------------------------------------------
static BOOL RememberTransaction(XACTUOW *pUow)
{
    CS lock(s_RingBufCS);

    // Look for the UOW in the ring buffer
    for (ULONG i = s_ulXrbFirst; i <= s_ulXrbLast && i < XACT_RING_BUF_SIZE; i++)
    {
        if (memcmp(&s_uowXactRingBuf[i], pUow, sizeof(XACTUOW))==0)
        {
            return TRUE;
        }
    }

    // No check for ring buffer overflow, because it is not dangerous (maximum RT will go to QM)

    // adding transaction to the ring buffer

    if (s_ulXrbFirst == XACT_RING_BUF_SIZE)
    {
        // Ring buffer is empty
        s_ulXrbFirst = s_ulXrbLast = 0;
        memcpy(&s_uowXactRingBuf[s_ulXrbFirst], pUow, sizeof(XACTUOW));
    }
    else
    {
        s_ulXrbLast = (s_ulXrbLast == XACT_RING_BUF_SIZE-1 ? 0 : s_ulXrbLast+1);
        memcpy(&s_uowXactRingBuf[s_ulXrbLast], pUow, sizeof(XACTUOW));
    }

    return FALSE;
}

//---------------------------------------------------------
// HRESULT RTpGetExportObject
//
//  Description:
//
//    Creates and caches the DTC export object
//---------------------------------------------------------
HRESULT RTpGetExportObject(IUnknown  *punkDtc,
                           ULONG     cbTmWhereabouts,
                           BYTE      *pbTmWhereabouts)
{
    HRESULT                          hr = MQ_OK;
    R<ITransactionExportFactory>     pTxExpFac   = NULL;

    if (g_pExport)
    {
        g_pExport->Release();
        g_pExport = NULL;
    }

    // Get the DTC's ITransactionExportFactory interface
    hr = punkDtc->QueryInterface (IID_ITransactionExportFactory, (void **)(&pTxExpFac.ref()));
    if (FAILED(hr))
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("QueryInterface failed: %x "), hr));
       return hr;
    }


    // Create Export object
    hr = pTxExpFac->Create (cbTmWhereabouts, pbTmWhereabouts, &g_pExport);
    if (FAILED(hr))
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("Create Export Object failed: %x "), hr));
       return hr;
    }

    return(MQ_OK);
}

//---------------------------------------------------------
// HRESULT RTpBuildTransactionCookie
//
//  Description:
//
//    Builds transaction Cookie
//---------------------------------------------------------
HRESULT RTpBuildTransactionCookie(ITransaction *pTrans,
                                  ULONG        *pcbCookie,
                                  BYTE        **ppbCookie)
{
    HRESULT                          hr = MQ_OK;
    ULONG                            cbUsed;
    R<IUnknown>                      punkTx = NULL;

    *pcbCookie = 0;
    *ppbCookie = NULL;

    // Get transaction's Unknown
    hr = pTrans->QueryInterface (IID_IUnknown, (void **)(&punkTx.ref()));
    if (FAILED(hr))
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("QueryInterface failed: %x "), hr));
       return hr;
    }
    // Get transaction cookie size
    hr = g_pExport->Export (punkTx.get(), pcbCookie);
    if (FAILED(hr) || *pcbCookie == 0)
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("Export failed: %x "), hr));
       return hr;
    }

    // Allocate memory for transaction Cookie
    try
    {
        *ppbCookie =  new BYTE[*pcbCookie];
    }
    catch(const bad_alloc&)
    {
        DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("Allocation failed: %x "), hr));
        return MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    // Get transaction Cookie itself
    hr = g_pExport->GetTransactionCookie (punkTx.get(), *pcbCookie, *ppbCookie, &cbUsed);
    if (FAILED(hr))
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("GetTransactionCookie failed: %x "), hr));
       return hr;
    }

    return(MQ_OK);
}


//---------------------------------------------------------
// HRESULT RTXactGetDTC
//
//  Description:
//
//  Obtains DTC transaction manager.  Defers to mqutil
//
//  Outputs:
//    ppunkDTC      pointers to DTC transaction manager
//---------------------------------------------------------
DLL_EXPORT HRESULT RTXactGetDTC(IUnknown **ppunkDTC)
{
    HRESULT hr =  MQ_ERROR;

    __try
    {
        GetMutex();  // Isolate export creation from others
        hr = XactGetDTC(ppunkDTC, NULL, NULL);//, g_fDependentClient);
    }
    __finally

    {
        ReleaseMutex(g_hMutexDTC);
    }
    return (SUCCEEDED(hr) ? MQ_OK : hr);
}


//---------------------------------------------------------
// HRESULT RTpProvideTransactionEnlist
//
//  Description:
//
//    Provides that QM is enlisted in this transaction,
//    checks the transaction state
//---------------------------------------------------------
HRESULT RTpProvideTransactionEnlist(ITransaction *pTrans, XACTUOW *pUow)
{
    HRESULT                         hr = MQ_OK;
    IUnknown                       *punkDtc  = NULL;
    IMSMQTransaction               *pIntXact = NULL;
    ULONG                           cbTmWhereabouts;
    BYTE                           *pbTmWhereabouts = NULL;
    ULONG                           cbCookie;
    BYTE                           *pbCookie = NULL;
    XACTTRANSINFO                   xinfo;
    BOOL                            fMutexTaken = FALSE;

    __try
    {
        //
        // Get the transaction info. UOW resides there.
        //
        hr = pTrans->GetTransactionInfo(&xinfo);
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("GetTransactionInfo failed: %x "), hr));
            __leave;
        }

        // Put pointer to UOW in the output parameter
        CopyMemory(pUow, &xinfo.uow, sizeof(XACTUOW));

        //
        // Is it internal transaction?
        //
        pTrans->QueryInterface (IID_IMSMQTransaction, (void **)(&pIntXact));

        if (pIntXact)
        {
           // Internal transactions
           //------------------------
           hr = pIntXact->EnlistTransaction(pUow);
           if (FAILED(hr))
           {
                DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("EnlistTransaction failed: %x "), hr));
           }
        }
        else
        {
            // External transactions
            //------------------------

            // Look for the transaction in the cache
            //
            if (FindTransaction(pUow))     // this xaction is known already; QM must have been enlisted
            {
                hr = MQ_OK;
                __leave;
            }

            // Get global mutex to isolate enlistment
            //
            GetMutex();  // Isolate export creation from others
            fMutexTaken = TRUE;

            //
            // Get the DTC IUnknown and TM whereabouts
            //
            hr = XactGetDTC(&punkDtc, &cbTmWhereabouts, &pbTmWhereabouts);//, g_fDependentClient);
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("XactGetDTC failed: %x "), hr));
                __leave;
            }

            // XactGetDTC could return success code of 1 if it reconnected to DTC
            if (hr == 1)
            {
                // No Release: DTC object is not alive anymore
                g_pExport = NULL;
            }

            // Get the QM's controlling DTC whereabouts
            //
            if (!g_pbQmTmWhereabouts)
            {
                g_cbQmTmWhereabouts = 128;
                g_pbQmTmWhereabouts = new BYTE[128];
                DWORD cbNeeded;

                hr = DepGetTmWhereabouts(g_cbQmTmWhereabouts, g_pbQmTmWhereabouts, &cbNeeded);

                if (hr == MQ_ERROR_USER_BUFFER_TOO_SMALL)
                {
                    delete [] g_pbQmTmWhereabouts;
                    g_cbQmTmWhereabouts = cbNeeded;
                    g_pbQmTmWhereabouts = new BYTE[cbNeeded];

                    hr = DepGetTmWhereabouts(g_cbQmTmWhereabouts, g_pbQmTmWhereabouts, &cbNeeded);
                }

                if (FAILED(hr))
                {
                    delete [] g_pbQmTmWhereabouts;
                    g_cbQmTmWhereabouts = 0;
                    g_pbQmTmWhereabouts = NULL;

                    DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("DepGetTmWhereabouts failed: %x "), hr));
                    __leave;
                }
                else
                {
                    g_cbQmTmWhereabouts = cbNeeded;
                }
            }

            //
            // Get and cache Export object
            //

            if (g_pExport == NULL)
            {
                hr = RTpGetExportObject(
                               punkDtc,
                               g_cbQmTmWhereabouts,
                               g_pbQmTmWhereabouts);
                if (FAILED(hr))
                {
                    DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("RTpGetExportObject failed: %x "), hr));
                    __leave;
                }
            }

            //
            // Prepare the transaction Cookie
            //
            hr = RTpBuildTransactionCookie(
                        pTrans,
                        &cbCookie,
                        &pbCookie);
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("RTpBuildTransactionCookie failed: %x "), hr));
                __leave;
            }

            //
            // RPC call to QM for enlistment
            //
            __try
            {
                INIT_RPC_HANDLE ;

				if(tls_hBindRpc == 0)
					return MQ_ERROR_SERVICE_NOT_AVAILABLE;

                hr = QMEnlistTransaction(tls_hBindRpc, pUow, cbCookie, pbCookie);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
               DWORD rc = GetExceptionCode();
               DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("RTpProvideTransactionEnlist failed: RPC code=%x "), rc));
			   DBG_USED(rc);

               hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
            }

            //Now that transaction is actually enlisted we remember it in ring buffer
            if (SUCCEEDED(hr))
            {
                RememberTransaction(pUow);
            }
            else
            {
                DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("QMEnlistTransaction failed: %x "), hr));
            }
        }

        if (FAILED(hr)) {
            __leave;
        }
        hr = MQ_OK;
    }

    __finally

    {
        if (SUCCEEDED(hr) && AbnormalTermination())
            hr = MQ_ERROR;

        #ifdef _DEBUG
        DWORD cRef = 0;
        if (punkDtc)
            cRef = punkDtc->Release();
        #else
        if (punkDtc)
            punkDtc->Release();
        #endif

        if (pIntXact)
            pIntXact->Release();

        if (pbCookie)
            delete pbCookie;

        if (fMutexTaken)
            ReleaseMutex(g_hMutexDTC);
    }

    return(hr);
}

//---------------------------------------------------------
// HRESULT InitStubRm
//
//  Description:
//
//    Initializes stub RM manager - now needed only for performance managements
//
//---------------------------------------------------------

IResourceManager        *g_pIResMgr       = 0;

HRESULT InitStubRm()
{
    HRESULT                      hRc;
    IResourceManagerFactory     *pIRmFactory    = 0;
    CStubIResourceManagerSink   *pIResMgrSink   = 0;
    IUnknown                    *punkDTC        = 0;
    UUID                         guid;

    //CS lock(s_RingBufCS);
    DBGMSG((DBGMOD_XACT, DBGLVL_WARNING, TEXT("InitStubRM called!")));

    if (g_DtcInit)
    {
        return MQ_OK;
    }

    //
    // (1) Establish contact with the MS DTC transaction manager.
    // First the application obtains the IUnknown interface to the DTC TM.
	//
    hRc = XactGetDTC(&punkDTC, NULL, NULL);//, g_fDependentClient);
    if (FAILED(hRc)) {
        return hRc;
    }

    // Get the resource manager factory from the IUnknown
    hRc = punkDTC->QueryInterface(IID_IResourceManagerFactory,(LPVOID *) &pIRmFactory);
    punkDTC->Release();
    if (S_OK != hRc)
    {
        return hRc;
    }

    // (2) Create and instance of the resource manager interface. A
    //     pointer to this interface is retrned to the client appliction
    //     through the pIResMgr member variable.
    //
    // Create a resource manager sink and create an instance of the
    // resource manager through the resource manager factory.

    pIResMgrSink = new CStubIResourceManagerSink;  //stub implementation
    if ( 0 == pIResMgrSink )
    {
        pIRmFactory->Release();
        return E_FAIL;
    }
    //pIResMgrSink->AddRef();

    // Create a new guid for each resource manager.
    hRc = UuidCreate (&guid);
    if ( S_OK != hRc)
    {
        return E_FAIL;
    }

    // Prepare stub RM name (ANSI)
    CHAR szStubBaseName[MAX_REG_DEFAULT_LEN];

    READ_REG_STRING(wszStubBaseName, FALCON_RM_STUB_NAME_REGNAME, FALCON_DEFAULT_STUB_RM_NAME ) ;
    size_t res = wcstombs(szStubBaseName, wszStubBaseName, sizeof(szStubBaseName));
    ASSERT(res != (size_t)(-1));
	DBG_USED(res);

    CHAR szStubRmName[60];
    sprintf(szStubRmName, "%s%d", szStubBaseName, g_StubRmCounter++);

    // Create instance of the resource manager interface.
    hRc = pIRmFactory->Create (&guid,
                               szStubRmName,
                               (IResourceManagerSink *) pIResMgrSink,
                               &g_pIResMgr );
    //pIRmFactory->Release();
    if (S_OK != hRc)
    {
        return hRc;
    }

    //g_pIResMgr->AddRef();  // we want to keep it. BUGBUG: When will we release it ?
    g_DtcInit = TRUE;

    return S_OK;
}

//---------------------------------------------------------
// void RTpInitXactRingBuf()
//
//  Description:
//
//    Initiates the ring buffer data
//---------------------------------------------------------
void RTpInitXactRingBuf()
{
    CS lock(s_RingBufCS);

    s_ulXrbFirst =  XACT_RING_BUF_SIZE;
    s_ulXrbLast  =  XACT_RING_BUF_SIZE;
    g_DtcInit    = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\rtutil.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    rtutil.cpp

Abstract:

    Contains various utility functions.

Author:

    Boaz Feldbaum (BoazF) Mar 5, 1996

Revision History:

    Erez Haba (erezh) 17-Jan-1997

--*/

#include "stdh.h"
#include "acrt.h"
#include <mqdbmgr.h>
#include <ad.h>
#include <_secutil.h>
#include <mqsec.h>

#include "rtutil.tmh"

//---------------------------------------------------------
//
//  Function:
//      RTpGetQueuePropVar
//
//  Description:
//      Find a queue property in the properties array
//
//---------------------------------------------------------
PROPVARIANT*
RTpGetQueuePropVar(
    PROPID PropID,
    MQQUEUEPROPS *pqp
    )
{
    DWORD i;
    DWORD cProp;
    PROPID *aPropID;

    for (i = 0, cProp = pqp->cProp, aPropID = pqp->aPropID;
         i < cProp;
         i++, aPropID++) {

        if (*aPropID == PropID) {
            return(&(pqp->aPropVar[i]));
        }

    }

    return(NULL);
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueuePathNamePropVar
//
//  Description:
//      Find a the queue path name property in the properties array
//
//---------------------------------------------------------
LPWSTR
RTpGetQueuePathNamePropVar(
    MQQUEUEPROPS *pqp
    )
{
    PROPVARIANT *p;

    if ((p = RTpGetQueuePropVar(PROPID_Q_PATHNAME, pqp)) != NULL)
        return(p->pwszVal);
    else
        return(NULL);
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueueGuidPropVar
//
//  Description:
//      Find the queue guid (instance) property in the properties array
//
//---------------------------------------------------------
GUID*
RTpGetQueueGuidPropVar(
    MQQUEUEPROPS *pqp
    )
{
    PROPVARIANT *p;

    if ((p = RTpGetQueuePropVar(PROPID_Q_INSTANCE, pqp)) != NULL)
        return(p->puuid);
    else
        return(NULL);
}


//---------------------------------------------------------
//
//  Function:
//      RTpMakeSelfRelativeSDAndGetSize
//
//  Parameters:
//      pSecurityDescriptor - The input security descriptor.
//      pSelfRelativeSecurityDescriptor - A pointer to a temporary buffer
//          that holds the converted security descriptor.
//      pSDSize - A pointer to a variable that receives the length of the
//          self relative security descriptor. This is an optional parameter.
//
//  Description:
//      Convert an absolute security descriptor to a self relative security
//      descriptor and get the size of the self relative security descriptor.
//      This function should be call before passing a security descriptor to
//      a function that passes the security descriptor to an RPC function.
//
//      If the input security descriptor is already a self relative security
//      descriptor, the function only computes the length of the security
//      descriptor and returns. If the input security descriptor is an absolute
//      security descriptor, the function allocates a buffer large enough to
//      accomodate the self relative security descripr, converts the absolute
//      security descriptor to a self relative security descriptor and modifies
//      the pointer of the input security descriptor to point to the self relative
//      security descriptor.
//
//      The temporar buffer that is being allocated for the self relative
//      security descriptor should be freed by the calling code.
//
//---------------------------------------------------------
HRESULT
RTpMakeSelfRelativeSDAndGetSize(
    PSECURITY_DESCRIPTOR *pSecurityDescriptor,
    PSECURITY_DESCRIPTOR *pSelfRelativeSecurityDescriptor,
    DWORD *pSDSize)
{
    SECURITY_DESCRIPTOR_CONTROL sdcSDControl;
    DWORD dwSDRevision;

    ASSERT(pSecurityDescriptor);
    ASSERT(pSelfRelativeSecurityDescriptor);

    *pSelfRelativeSecurityDescriptor = NULL;

    if (!*pSecurityDescriptor)
    {
        // Set the security descriptor size.
        if (pSDSize)
        {
            *pSDSize = 0;
        }
        return(MQ_OK);
    }

    // Verify that this is a valid security descriptor.
    if (!IsValidSecurityDescriptor(*pSecurityDescriptor))
    {
        return(MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR);
    }

    // Check whether this is a self relative or absolute security
    // descriptor.
    if (!GetSecurityDescriptorControl(*pSecurityDescriptor,
                                      &sdcSDControl,
                                      &dwSDRevision))
    {
        ASSERT(FALSE);
    }

    if (!(sdcSDControl & SE_SELF_RELATIVE))
    {
        // This is an absolute security descriptor, we should convert it
        // to a self relative one.
        DWORD dwBufferLength = 0;

#ifdef _DEBUG
        SetLastError(0);
#endif
        // Get the buffer size.
        MakeSelfRelativeSD(*pSecurityDescriptor, NULL, &dwBufferLength);
        ASSERT(GetLastError() == ERROR_INSUFFICIENT_BUFFER);

        // Allocate the buffer for the self relative security descriptor.
        *pSelfRelativeSecurityDescriptor =
            (PSECURITY_DESCRIPTOR) new char[dwBufferLength];

        // Convert the security descriptor.
        if (!MakeSelfRelativeSD(
                *pSecurityDescriptor,
                *pSelfRelativeSecurityDescriptor,
                &dwBufferLength))
        {
            ASSERT(FALSE);
        }
        ASSERT(IsValidSecurityDescriptor(*pSelfRelativeSecurityDescriptor));
        *pSecurityDescriptor = *pSelfRelativeSecurityDescriptor;

        // Set the security descriptor size.
        if (pSDSize)
        {
            *pSDSize = dwBufferLength;
        }

    }
    else
    {

        // The security descriptor is already in self relative format, just
        // set the security descriptor size.
        if (pSDSize)
        {
            *pSDSize = GetSecurityDescriptorLength(*pSecurityDescriptor);
        }

    }

    return(MQ_OK);
}


//---------------------------------------------------------
//
//  Function:
//     RTpConvertToMQCode
//
//  Parameters:
//      hr - Error vode that is generated by any kind of module.
//
// Return value:
//      The imput parameter convetrted to some equivalent MQ_ERROR constant.
//
//---------------------------------------------------------
HRESULT
RTpConvertToMQCode(
    HRESULT hr,
    DWORD dwObjectType
    )
{

    if ((hr == MQ_OK)                                   ||
        (hr == MQ_INFORMATION_REMOTE_OPERATION)         ||
        (hr == MQ_ERROR_Q_DNS_PROPERTY_NOT_SUPPORTED)   ||
        ((MQ_E_BASE <= hr) && (hr < MQ_E_BASE + 0x100)) ||
        ((MQ_I_BASE <= hr) && (hr < MQ_I_BASE + 0x100)))
    {
        // This is our codes, do not modify it.
        return(hr);
    }

    if (hr == MQDS_OK_REMOTE)
    {
        //
        // success - we use MQDS_OK_REMOTE for internal use, e.g. explorer
        //
        return(MQ_OK);
    }

    if (HRESULT_FACILITY(MQ_E_BASE) == HRESULT_FACILITY(hr))
    {
        switch (hr)
        {
        case MQDB_E_NO_MORE_DATA:
        case MQDS_GET_PROPERTIES_ERROR:
        case MQDS_OBJECT_NOT_FOUND:
            hr = (dwObjectType ==  MQDS_QUEUE) ?
                    MQ_ERROR_QUEUE_NOT_FOUND :
                    MQ_ERROR_MACHINE_NOT_FOUND;
            break;

        case MQDS_NO_RSP_FROM_OWNER:
            hr = MQ_ERROR_NO_RESPONSE_FROM_OBJECT_SERVER;
            break;

        case MQDS_OWNER_NOT_REACHED:
            hr = MQ_ERROR_OBJECT_SERVER_NOT_AVAILABLE;
            break;

        case MQDB_E_NON_UNIQUE_SORT:
            hr = MQ_ERROR_ILLEGAL_SORT;
            break;

        default:
            // Some DS error occured. This should not happen, but anyway...
            DBGMSG((DBGMOD_API, DBGLVL_WARNING,
                TEXT("A DS error (%x) has propagated to the RT DLL. Converting to MQ_ERROR_DS_ERROR"), hr));
            hr = MQ_ERROR_DS_ERROR;
            break;
        }

        return(hr);
    }

    if (hr == CPP_EXCEPTION_CODE)
    {
        // A C++ exception occured. This can happen only when in an allocation failure.
        return(MQ_ERROR_INSUFFICIENT_RESOURCES);
    }

    // Now we hope that we know how to convert an NTSTATUS to some of our error
    // codes. Good luck...
    switch(hr)
    {
    case STATUS_INVALID_HANDLE:
    case STATUS_OBJECT_TYPE_MISMATCH:
        hr = MQ_ERROR_INVALID_HANDLE;
        break;

    case STATUS_ACCESS_DENIED:
        hr = MQ_ERROR_ACCESS_DENIED;
        break;

    case STATUS_ACCESS_VIOLATION:
    case STATUS_INVALID_PARAMETER:
        hr = MQ_ERROR_INVALID_PARAMETER;
        break;

    case STATUS_SHARING_VIOLATION:
        hr = MQ_ERROR_SHARING_VIOLATION;
        break;

    case STATUS_PENDING:
        hr = MQ_INFORMATION_OPERATION_PENDING;
        break;

    case STATUS_CANCELLED:
        hr = MQ_ERROR_OPERATION_CANCELLED;
        break;

    case STATUS_INSUFFICIENT_RESOURCES:
        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
        break;

    case STATUS_INVALID_DEVICE_REQUEST:
        hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
        break;

    default:
       DBGMSG((DBGMOD_API, DBGLVL_WARNING,
           TEXT("Unfamiliar error code:%x, not converted to a MQ error"), hr));
       break;
    }

    return(hr);
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetThreadUserSid
//
//  Parameters:
//      pUserSid - A pointer to a buffer that receives the address of a buffer
//          that contains the SID of the user of the current thread.
//      pdwUserSidLen - A pointer to a DWORD that receives the length of the
//          SID.
//
//  Description:
//      The function allocates the buffer for the SID and fils it with the SID
//      of the user of the current thread. The calling code is responsible for
//      freeing the allocated buffer.
//
//---------------------------------------------------------

HRESULT
RTpGetThreadUserSid( BOOL    *pfLocalUser,
                     BOOL    *pfLocalSystem,
                     LPBYTE  *pUserSid,
                     DWORD   *pdwUserSidLen )
{
    HRESULT hr;

    hr = MQSec_GetUserType( NULL,
                            pfLocalUser,
                            pfLocalSystem );
    if (FAILED(hr))
    {
        return(hr);
    }

    if (*pfLocalSystem)
    {
        *pUserSid = (LPBYTE) MQSec_GetLocalMachineSid( TRUE, // allocate
                                                       pdwUserSidLen ) ;
        if (!(*pUserSid))
        {
            //
            // this may happen if the machine belong to a NT4 domain
            // and it doesn't have any computer account and sid.
            // In that case, make it a local user.
            //
            ASSERT(*pdwUserSidLen == 0) ;
            *pdwUserSidLen = 0 ;

            *pfLocalSystem = FALSE ;
            if (pfLocalUser)
            {
                ASSERT(!(*pfLocalUser)) ;
                *pfLocalUser = TRUE ;
            }
        }
    }
    else if (!(*pfLocalUser))
    {
        hr = GetThreadUserSid(pUserSid, pdwUserSidLen);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\xactmq.cpp ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactMq.cpp

Abstract:
    This module implements CMQTransaction object

Author:
    Alexander Dadiomov (AlexDad)

--*/
#include "stdh.h"
#include "txdtc.h"
#include "rtprpc.h"
#include "XactMq.h"

#include "xactmq.tmh"

extern    BOOL g_fClient;

//---------------------------------------------------------------------
// CMQTransaction::CMQTransaction
//---------------------------------------------------------------------
CMQTransaction::CMQTransaction()
{
    m_cRefs = 1;
    m_fCommitedOrAborted = FALSE;
    m_hXact = NULL;
    UuidCreate((UUID *)&m_Uow);
}

//---------------------------------------------------------------------
// CMQTransaction::~CMQTransaction
//---------------------------------------------------------------------
CMQTransaction::~CMQTransaction(void)
{
    if (!m_fCommitedOrAborted)
    {
        Abort(NULL, FALSE, FALSE);
    }
}

//---------------------------------------------------------------------
// CMQTransaction::QueryInterface
//---------------------------------------------------------------------
STDMETHODIMP CMQTransaction::QueryInterface(REFIID i_iid,LPVOID *ppv)
{
    *ppv = 0;                       // Initialize interface pointer.

    if (IID_IUnknown == i_iid)
    {
        *ppv = (IUnknown *)((ITransaction *)this);
    }
    else if (IID_ITransaction == i_iid)
    {
        *ppv = (ITransaction *)this;
    }
    else if (IID_IMSMQTransaction == i_iid)
    {
        *ppv = (IMSMQTransaction *)this;
    }


    if (0 == *ppv)                  // Check for null interface pointer.
    {
        return E_NOINTERFACE;       // from winerror.h
                                    // Neither IUnknown nor IResourceManagerSink
    }
    ((LPUNKNOWN) *ppv)->AddRef();   // Interface is supported. Increment
                                    // its usage count.

    return S_OK;
}


//---------------------------------------------------------------------
// CMQTransaction::AddRef
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CMQTransaction::AddRef(void)
{
    return InterlockedIncrement(&m_cRefs);               // Increment interface usage count.
}


//---------------------------------------------------------------------
// CMQTransaction::Release
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CMQTransaction::Release(void)
{
    // Is anyone using the interface?
    if (InterlockedDecrement(&m_cRefs))
    {                               // The interface is in use.
        return m_cRefs;             // Return the number of references.
    }

    delete this;                    // Interface not in use -- delete!

    return 0;                       // Zero references returned.
}

#pragma warning(disable: 4100)  // unreferenced formal parameter
//---------------------------------------------------------------------
// CMQTransaction::Commit
//---------------------------------------------------------------------
HRESULT CMQTransaction::Commit(BOOL fRetaining, DWORD grfTC, DWORD grfRM)
{
   //------------------------------------------------------------
   // RPC call to QM for prepare/commit
   //------------------------------------------------------------
   HRESULT rc;

   if ((grfTC != 0 && grfTC != XACTTC_SYNC) ||
        grfRM != 0 || fRetaining != FALSE)
   {
       return XACT_E_NOTSUPPORTED;
   }

   __try
   {
        rc = QMCommitTransaction(&m_hXact);
        m_fCommitedOrAborted = TRUE;
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
       rc = E_FAIL;
   }

   return rc;
}

//---------------------------------------------------------------------
// CMQTransaction::Abort
//---------------------------------------------------------------------
HRESULT CMQTransaction::Abort(BOID *pboidReason, BOOL fRetaining, BOOL fAsync)
{
   if (fAsync || fRetaining)
   {
       return XACT_E_NOTSUPPORTED;
   }

   //------------------------------------------------------------
   // RPC call to QM for prepare/commit
   //------------------------------------------------------------
   HRESULT rc;

   __try
   {
        rc = QMAbortTransaction(&m_hXact);
        m_fCommitedOrAborted = TRUE;
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
       rc = E_FAIL;
   }

   return rc;
}

//---------------------------------------------------------------------
// CMQTransaction::GetTransactionInfo
//---------------------------------------------------------------------
HRESULT CMQTransaction::GetTransactionInfo(XACTTRANSINFO *pinfo)
{
    ZeroMemory((PVOID)pinfo, sizeof(XACTTRANSINFO));
    CopyMemory((PVOID)&pinfo->uow, (PVOID)&m_Uow, sizeof(XACTUOW));
    return MQ_OK;
}

//---------------------------------------------------------------------
// CMQTransaction::EnlistTransaction
//---------------------------------------------------------------------
HRESULT CMQTransaction::EnlistTransaction(XACTUOW *pUow)
{

    HRESULT hr;

    // No need for several enlistments
    if (m_hXact)
    {
        return MQ_OK;
    }

    // RPC call to QM for enlistment
    __try
    {
        INIT_RPC_HANDLE ;

		if(tls_hBindRpc == 0)
			return MQ_ERROR_SERVICE_NOT_AVAILABLE;

        hr = QMEnlistInternalTransaction(tls_hBindRpc, pUow, &m_hXact);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
       DWORD rc = GetExceptionCode();
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT(
           "CMQTransaction::EnlistTransaction failed: RPC code=%x "), rc));
	   DBG_USED(rc);

       hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
       m_hXact = NULL;
    }

    if(FAILED(hr))
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT
                      ("QMEnlistInternalTransaction failed: %x "), hr));
    }
    return hr;
}

#pragma warning(default: 4100)  // unreferenced formal parameter

//---------------------------------------------------------------------
//    DepBeginTransaction() - Generates new MSMQ internal transaction
//---------------------------------------------------------------------
EXTERN_C
HRESULT
APIENTRY
DepBeginTransaction(OUT ITransaction **ppTransaction)
{
	ASSERT(g_fDependentClient);

	HRESULT hri = DeppOneTimeInit();
	if(FAILED(hri))
		return hri;

    HRESULT hr = MQ_OK;
    ITransaction* pTransaction = NULL;
    try
    {
        pTransaction = new CMQTransaction;
    }
    catch(const bad_alloc&)
    {
        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }


    if (SUCCEEDED(hr))
    {
        // We are not obliged to enlist immediately, but otherwise Commit for empty xact will fail
        XACTUOW Uow;

        hr = RTpProvideTransactionEnlist(pTransaction, &Uow);
        if(FAILED(hr))
        {
           delete pTransaction;	
           DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT("RTpProvideTransactionEnlist failed: %x "), hr));
           hr = MQ_ERROR_TRANSACTION_ENLIST;
        }
        else
        {
			*ppTransaction = pTransaction;
        }
    }

    return hr;
}

//---------------------------------------------------------------------
//    DepGetTmWhereabouts() - brings controlling DTC whereabouts
//    This is a private non-published function which we need outside of the DLL
//---------------------------------------------------------------------
DLL_EXPORT
HRESULT
DepGetTmWhereabouts(IN  DWORD  cbBufSize,
                   OUT UCHAR *pbWhereabouts,
                   OUT DWORD *pcbWhereabouts)
{
	ASSERT(g_fDependentClient);

    HRESULT hr = MQ_OK;

    // RPC call to QM for getting whereabouts
    __try
    {
        INIT_RPC_HANDLE ;

		if(tls_hBindRpc == 0)
			return MQ_ERROR_SERVICE_NOT_AVAILABLE;

        hr = QMGetTmWhereabouts(tls_hBindRpc,
                                cbBufSize,
                                pbWhereabouts,
                                pcbWhereabouts);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
       DWORD rc = GetExceptionCode();
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR, TEXT(
                        "MQGetTmWhereabouts failed: RPC code=%x "), rc));
	   DBG_USED(rc);

       hr = MQ_ERROR_SERVICE_NOT_AVAILABLE;
    }

    if (FAILED(hr))
    {
       DBGMSG((DBGMOD_XACT, DBGLVL_ERROR,
                      TEXT("QMGetTmWhereabouts failed: %x "), hr));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\rtdep\xactsink.cpp ===
/*++
    Copyright (c) 1996  Microsoft Corporation

Module Name:
    XactSink.cpp

Abstract:
    This module implements CStubIResourceManagerSink object

Author:
    Alexander Dadiomov (AlexDad)

--*/
#include "stdh.h"
#include "txdtc.h"
#include "xactSink.h"

#include "xactsink.tmh"

/*
RT has inside the doing-nothing stub Resource manager - 
for performance testing.  
The code is not compiled in regular build, but may be gotten easily.

The way to build InProc RM in RT:
---------------------------------
0. out rt.def  rt.mak
1. Add MQStubRM to rt.def
2. Add RT_XACT_STUB to Preprocessor Definitions in rt.mak
    (VC, Build->Settings->C++-.General->
3. Build all
*/


#ifdef RT_XACT_STUB
#include "cs.h"
HANDLE g_hCommitThread      = NULL ;
DWORD  g_dwCommitThreadId   = 0 ;
HANDLE g_hCommitThreadEvent = NULL ;
ITransactionEnlistmentAsync *g_pEnlist[1000];
ULONG  g_ulEnlistCase[1000];
ULONG  g_ulEnlistCounter = 0;
CCriticalSection g_csEnlist;
#endif

//---------------------------------------------------------------------
// CStubIResourceManagerSink::CStubIResourceManagerSink
//---------------------------------------------------------------------

CStubIResourceManagerSink::CStubIResourceManagerSink(void)
{
	m_cRefs = 0;						// Initialize the reference count.
}


//---------------------------------------------------------------------
// CStubIResourceManagerSink::~CStubIResourceManagerSink
//---------------------------------------------------------------------
CStubIResourceManagerSink::~CStubIResourceManagerSink(void)
{
	// Do nothing.
}



//---------------------------------------------------------------------
// CStubIResourceManagerSink::QueryInterface
//---------------------------------------------------------------------
STDMETHODIMP CStubIResourceManagerSink::QueryInterface(REFIID i_iid, LPVOID *ppv)
{
	*ppv = 0;						// Initialize interface pointer.

    if (IID_IUnknown == i_iid || IID_IResourceManagerSink == i_iid)
	{								// IID supported return interface.
		*ppv = this;
	}

	
	if (0 == *ppv)					// Check for null interface pointer.
	{										
		return ResultFromScode (E_NOINTERFACE);
									// Neither IUnknown nor IResourceManagerSink supported--
									// so return no interface.
	}

	((LPUNKNOWN) *ppv)->AddRef();	// Interface is supported. Increment its usage count.
	
	return S_OK;
}


//---------------------------------------------------------------------
// CStubIResourceManagerSink::AddRef
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CStubIResourceManagerSink::AddRef(void)
{
    return ++m_cRefs;				// Increment interface usage count.
}


//---------------------------------------------------------------------
// CStubIResourceManagerSink::Release
//---------------------------------------------------------------------
STDMETHODIMP_ (ULONG) CStubIResourceManagerSink::Release(void)
{

	--m_cRefs;						// Decrement usage reference count.

	if (0 != m_cRefs)				// Is anyone using the interface?
	{								// The interface is in use.
		return m_cRefs;				// Return the number of references.
	}

	delete this;					// Interface not in use -- delete!

	return 0;						// Zero references returned.
}


//---------------------------------------------------------------------
// CStubIResourceManagerSink::TMDown
//---------------------------------------------------------------------
STDMETHODIMP CStubIResourceManagerSink::TMDown(void)
{
	return S_OK;					// TODO: Not sure what is supposed to happen here -- find out!
}


extern IResourceManager *g_pIResMgr;


CStub::CStub()
{
    m_cRefs = 0;
    m_pEnlist = NULL;
}

CStub::~CStub()
{
    m_pEnlist->Release();
}

STDMETHODIMP CStub::QueryInterface( REFIID i_iid, void **ppv )
{
    *ppv = 0;                       // Initialize interface pointer.

    if (IID_IUnknown == i_iid)
    {                      
        *ppv = (IUnknown *)this;
    } 
    else if (IID_ITransactionResourceAsync == i_iid)
    {                      
        *ppv = (ITransactionResourceAsync *)this;
    } 
    
    if (0 == *ppv)                  // Check for null interface pointer.
    {
        return E_NOINTERFACE;       // from winerror.h
                                    // Neither IUnknown nor IResourceManagerSink
    }
    ((LPUNKNOWN) *ppv)->AddRef();   // Interface is supported. Increment
                                    // its usage count.

    return S_OK;

}

STDMETHODIMP_   (ULONG) CStub::AddRef( void )
{
    return ++m_cRefs;
}

STDMETHODIMP_   (ULONG) CStub::Release( void )
{
    --m_cRefs;                      // Decrement usage reference count.

    if (0 != m_cRefs)               // Is anyone using the interface?
    {                               // The interface is in use.
        return m_cRefs;             // Return the number of references.
    }

    delete this;                    // Interface not in use -- delete!

    return 0;                       // Zero references returned.

}

#pragma warning(disable: 4100)          // unreferenced formal parameter

STDMETHODIMP    CStub::PrepareRequest(BOOL  /*fRetaining*/,
                                      DWORD /*grfRM*/,
                                      BOOL  /*fWantMoniker*/,
                                      BOOL  fSinglePhase)
{  
    #ifdef RT_XACT_STUB
    CS lock(g_csEnlist);
    g_pEnlist[g_ulEnlistCounter]        = m_pEnlist;
    g_ulEnlistCase[g_ulEnlistCounter]   = (fSinglePhase ? 1 : 2); // 1=Single Prepare; 2=Multi prepare
    g_ulEnlistCounter++;
    SetEvent(g_hCommitThreadEvent);
    #else
    m_pEnlist->PrepareRequestDone (S_OK, NULL, NULL);
    #endif

    return S_OK;

}

#pragma warning(default: 4100)  // unreferenced formal parameter

STDMETHODIMP    CStub::CommitRequest (DWORD      /* grfRM*/,
                                      XACTUOW *  /* pNewUOW*/)
{
    #ifdef RT_XACT_STUB
    CS lock(g_csEnlist);
    g_pEnlist[g_ulEnlistCounter]        = m_pEnlist;
    g_ulEnlistCase[g_ulEnlistCounter]   = 3; // Commit 
    g_ulEnlistCounter++;
    SetEvent(g_hCommitThreadEvent);
    #else
    m_pEnlist->CommitRequestDone (S_OK);
    #endif

    return S_OK;
}

STDMETHODIMP    CStub::AbortRequest  (BOID *     /*pboidReason*/,
                                      BOOL      /*fRetaining*/,
                                      XACTUOW * /*pNewUOW*/)
{
    #ifdef RT_XACT_STUB
    CS lock(g_csEnlist);
    g_pEnlist[g_ulEnlistCounter]        = m_pEnlist;
    g_ulEnlistCase[g_ulEnlistCounter]   = 4; // Abort 
    g_ulEnlistCounter++;
    SetEvent(g_hCommitThreadEvent);
    #else
    m_pEnlist->AbortRequestDone (S_OK);
    #endif

    return S_OK;
}

STDMETHODIMP    CStub::TMDown        (void)
{
    return S_OK;
}

void CStub::SetEnlist(ITransactionEnlistmentAsync *pEnlist)
{
    m_pEnlist = pEnlist;
}


#ifdef RT_XACT_STUB

DWORD __stdcall  RTCommitThread( void * )
{
    while (1)
    {
        WaitForSingleObject( g_hCommitThreadEvent, INFINITE);
        {
            CS lock(g_csEnlist);

            for (ULONG i=0; i<g_ulEnlistCounter; i++)
            {
                switch(g_ulEnlistCase[i])
                {
                case 1:
                    // Single-phase, Prepare
                    g_pEnlist[i]->PrepareRequestDone (XACT_S_SINGLEPHASE,NULL,NULL);
                    break;
                case 2:
                    // Double-phase, Prepare
                    g_pEnlist[i]->PrepareRequestDone (S_OK, NULL, NULL);
                    break;
                case 3:
                    // Commit
                    g_pEnlist[i]->CommitRequestDone (S_OK);
                    break;
                case 4:
                    // Abort
                    g_pEnlist[i]->AbortRequestDone (S_OK);
                    break;
                }

            }

            g_ulEnlistCounter = 0;
        }
    }
    return 0;
}
#endif

HRESULT MQStubRM(ITransaction *pTrans)
{
    LONG			 lIsoLevel;
    XACTUOW          uow1;
    ITransactionEnlistmentAsync   *pEnlist;
    ITransactionResourceAsync     *pTransResAsync;
    CStub                         *pCStub;

    HRESULT hr = InitStubRm();
    if (FAILED(hr))
    {
        return hr;   // internal failure
    }

    pCStub = new  CStub();
    hr = pCStub->QueryInterface(IID_ITransactionResourceAsync,(LPVOID *) &pTransResAsync);



	hr = g_pIResMgr->Enlist (
                          pTrans,                   // IN
						  pTransResAsync,           // IN
						  (BOID *)&uow1,            // OUT
						  &lIsoLevel,               // OUT: ignoring it
						  &pEnlist);        // OUT
    ASSERT(SUCCEEDED(hr));

    pCStub->SetEnlist(pEnlist);
    //pCStub->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\security\ui\mqcertui\certinfo.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    certinfo.cpp

Abstract:

    A dialog that shows the details of a certificate.

Author:

    Boaz Feldbaum (BoazF)   15-Oct-1996
    Doron Juster  (DoronJ)  15-Dec-1997, replace digsig with crypto2.0

--*/

#include <windows.h>
#include "prcertui.h"
#include "mqcertui.h"
#include "certres.h"
#include <winnls.h>
#include <cryptui.h>

#include <rt.h>
#include "automqfr.h"


extern "C"
void
ShowCertificate( HWND                hParentWnd,
                 CMQSigCertificate  *pCert,
                 DWORD               dwFlags)
{
    CRYPTUI_VIEWCERTIFICATE_STRUCT cryptView ;
    memset(&cryptView, 0, sizeof(cryptView)) ;

    cryptView.dwSize = sizeof(CRYPTUI_VIEWCERTIFICATE_STRUCT) ;
    cryptView.pCertContext = pCert->GetContext() ;

    cryptView.dwFlags = CRYPTUI_DISABLE_EDITPROPERTIES |
                        CRYPTUI_DISABLE_ADDTOSTORE ;
    switch (dwFlags)
    {
        case CERT_TYPE_INTERNAL:
            cryptView.dwFlags |= ( CRYPTUI_IGNORE_UNTRUSTED_ROOT |
                                   CRYPTUI_HIDE_HIERARCHYPAGE ) ;
            break;

        default:
            break ;
    }

    BOOL fChanged = FALSE ;
	CryptUIDlgViewCertificate( &cryptView, &fChanged ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\security\ui\mqcertui\prcertui.h ===
//
// prcertui.h
//

#ifndef _PRCERTUI_H_
#define _PRCERTUI_H_

#include <assert.h>

#define ASSERT(x)  assert(x)

#include <mqwin64a.h>

#include <mqcert.h>

#define INTERNAL_CERT_INDICATOR 0xffff

extern HMODULE		g_hResourceMod;

INT_PTR CALLBACK CertSelDlgProc( HWND   hwndDlg,
                                 UINT   uMsg,
                                 WPARAM wParam,
                                 LPARAM lParam );

struct CertInfoDlgProcStruct
{
    CMQSigCertificate  *pCert;
    DWORD              dwFlags;
};

struct CertSelDlgProcStruct
{
    CMQSigCertificate  **pCertList;
    DWORD              nCerts;
    CMQSigCertificate  **ppCert;
    DWORD              dwType;
};

INT_PTR CALLBACK CertInfoDlgProc( HWND   hwndDlg,
                                  UINT   uMsg,
                                  WPARAM wParam,
                                  LPARAM lParam );

LPWSTR AllocAndLoadString( HINSTANCE hInst,
                           UINT      uID );

#endif //   _PRCERTUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\security\ui\mqcertui\caconfig.cpp ===
/*++

Copyright (c) 1996-98  Microsoft Corporation

Module Name:

    caconfig.cpp

Abstract:

    Handle CA configuration. This code enables a user to chose which
    CA certificates are used for Falcon server authentication.

Author:

    Boaz Feldbaum (BoazF)   15-Oct-1996
    Doron Juster  (DoronJ)  15-Dec-1997, replace digsig with crypto2.0

--*/
#include <windows.h>
#include <commctrl.h>
#include "certres.h"
#include "prcertui.h"
#include <mqtempl.h>
#include <mqcertui.h>
#include <stdlib.h>
#include "mqcast.h"
#include "mqmacro.h"

struct CaConfigParam
{
    DWORD nCerts;
    PBYTE *pbCerts;
    DWORD *dwCertSize;
    LPCWSTR *szCertNames;
    BOOL *fEnabled;
    BOOL *fDeleted;
    BOOL fAllowDeletion;
};

INT_PTR
CALLBACK
CaConfigDlgProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    static HIMAGELIST hCaImageList;
    static HWND hCaListView;
    static struct CaConfigParam *pParam;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            pParam = (struct CaConfigParam *)lParam;

            if (!pParam->fAllowDeletion)
            {
                //
                // Place the cancel button in the place of the delete button
                // and hide the delete button.
                //
                WINDOWPLACEMENT wp;
                HWND hwndDelete = GetDlgItem(hwndDlg, IDC_DELETE_CERT);
                HWND hwndCancel = GetDlgItem(hwndDlg, IDCANCEL);
                HWND hwndSysCerts = GetDlgItem(hwndDlg, IDC_SYSTEM_CERTS);

                GetWindowPlacement(hwndDelete, &wp);
                SetWindowPlacement(hwndCancel, &wp);
                ShowWindow(hwndDelete, SW_HIDE);
                ShowWindow(hwndSysCerts, SW_HIDE);
            }

            //
            // Load the state images.
            //
            HBITMAP hCaListStateImage;

            hCaListStateImage = LoadBitmap(g_hResourceMod, MAKEINTRESOURCE(IDB_CA_LIST_IMAGE));

            //
            // Initialize the list control.
            //
            hCaImageList = ImageList_Create(14, 14, ILC_COLOR, 2, 1);
            ImageList_Add(hCaImageList, hCaListStateImage, NULL);
            hCaListView = GetDlgItem(hwndDlg, IDC_CERTIFICATE_LIST);
            ListView_SetImageList(hCaListView, hCaImageList, LVSIL_STATE);

            //
            // Fill the list control with CAs.
            //
            for (DWORD i = 0; i < pParam->nCerts; i++)
            {
                if (pParam->fDeleted[i])
                {
                    continue;
                }

                LV_ITEM lvItem;
                DWORD dwCaNameLen = numeric_cast<DWORD>(wcslen(pParam->szCertNames[i]));
                AP<WCHAR> wszCaName = new WCHAR[dwCaNameLen + 1];

                wcscpy(wszCaName, pParam->szCertNames[i]);

                lvItem.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
                lvItem.iItem = i;
                lvItem.iSubItem = 0;
                lvItem.pszText = wszCaName;
                lvItem.state = INDEXTOSTATEIMAGEMASK(1+pParam->fEnabled[i]);
                lvItem.stateMask = LVIS_STATEIMAGEMASK;
                lvItem.lParam = (LPARAM)i;
                ListView_InsertItem(hCaListView, &lvItem);
            }

            //
            // Select the first item in the list.
            //
            ListView_SetItemState(hCaListView, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        }
        return TRUE;
        break;

    case WM_NOTIFY:
        {
            NMHDR *pNMHDR = (NMHDR *)lParam;

            switch(pNMHDR->idFrom)
            {
            case IDC_CERTIFICATE_LIST:
                switch (pNMHDR->code)
                {
                case LVN_ITEMCHANGED:
                    {
                        //
                        // Check the current state of selection
                        //
                        int iSel = ListView_GetNextItem(hCaListView, -1, LVNI_SELECTED);

                        //
                        // -1 == nothing selected => nothing to view, nothing to delete.
                        //
                        EnableWindow(GetDlgItem(hwndDlg, IDC_DELETE_CERT), iSel != -1);
                        EnableWindow(GetDlgItem(hwndDlg, IDC_VIEW_CERT), iSel != -1);
                    }
                    break;

                case NM_CLICK:
                    {
                        POINT ptCursor;

                        //
                        // See if the user clicked the icon of the list item.
                        //
                        GetCursorPos(&ptCursor);
                        ScreenToClient(hCaListView, &ptCursor);

                        int nItems = ListView_GetItemCount(hCaListView);

                        for (int i = 0; i < nItems; i++)
                        {
                            RECT r;

                            ListView_GetItemRect(hCaListView, i, &r, LVIR_ICON);
                            r.left = r.right-14; // This appears to workaround some possible bug in the list control (???)
                            if (PtInRect(&r, ptCursor))
                            {
                                //
                                // Toggle the state of the CA.
                                //
                                UINT state = ListView_GetItemState(hCaListView, i, LVIS_STATEIMAGEMASK) >> 12;
                                ListView_SetItemState(hCaListView, i, INDEXTOSTATEIMAGEMASK(state == 1 ? 2 : 1), LVIS_STATEIMAGEMASK);
                                break;
                            }
                        }
                    }
                    break;
                }
                return TRUE;
                break;
            }
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_DELETE_CERT:
        case IDC_VIEW_CERT:
            {
                //
                // Get the indext of the selected item.
                //
                int i = ListView_GetNextItem(hCaListView, 0, LVNI_SELECTED);

                if (i == -1)
                {
                    //
                    // There must be one certificate slected. If the currently
                    // slected  certificate is the first certificate, then
                    // GetNextItem returns -1.
                    //
                    i = 0;
                }

                //
                // Get the certificate of the selected CA into an X509 object.
                //
                WCHAR wszCaName[256];

                ListView_GetItemText(hCaListView, i, 0, wszCaName, TABLE_SIZE(wszCaName));

                LV_ITEM LvItem;

                LvItem.iItem = i;
                LvItem.iSubItem = 0;
                LvItem.mask = LVIF_PARAM;
                ListView_GetItem(hCaListView, &LvItem);

                if (LOWORD(wParam) == IDC_VIEW_CERT)
                {
                    R<CMQSigCertificate> pCert = NULL ;
                    HRESULT hr = MQSigCreateCertificate(
                                       &pCert.ref(),
                                       NULL,
                                       pParam->pbCerts[LvItem.lParam],
                                       pParam->dwCertSize[LvItem.lParam] ) ;
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Show the details of the certificate (calls MQCERTUI.DLL).
                        //
                        ShowCertificate(hwndDlg, pCert.get(), CERT_TYPE_CA);
                    }
                }
                else
                {
                    //
                    // Make sure that the user really wants to delete the
                    // certificate.
                    //
                    WCHAR wszMsgFormat[128];
                    LPWSTR wszMsg;
                    WCHAR wszCaption[128];
                    PBYTE pbCaName = (PBYTE)wszCaName;
                    PBYTE *ParamList = &pbCaName;

                    LoadString(
                        g_hResourceMod,
                        IDS_VERIFY_DELETE_CERT,
                        wszMsgFormat,
                        TABLE_SIZE(wszMsgFormat));
                    FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_FROM_STRING |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        wszMsgFormat,
                        0,
                        0,
                        (LPWSTR)&wszMsg,
                        128,
                        (va_list *)ParamList);
                    LoadString(
                        g_hResourceMod,
                        IDS_VERIFY_CAPTION,
                        wszCaption,
                        TABLE_SIZE(wszCaption));
                    int iAction = MessageBox(hwndDlg,
                                             wszMsg,
                                             wszCaption,
                                             MB_ICONQUESTION | MB_YESNO);
                    LocalFree(wszMsg);
                    if (iAction == IDYES)
                    {
                        pParam->fDeleted[LvItem.lParam] = TRUE;
                        ListView_DeleteItem(hCaListView, i);
                    }
                }
                SetFocus(hCaListView);
            }
            return TRUE;
            break;

        case IDC_SYSTEM_CERTS:
            {
                //
                // Make sure that the user really wants to import the
                // system root certificates.
                //
                WCHAR wszMsg[128];
                WCHAR wszCaption[128];

                LoadString(
                    g_hResourceMod,
                    IDS_VERIFY_SYSCERTS,
                    wszMsg,
                    TABLE_SIZE(wszMsg));
                LoadString(
                    g_hResourceMod,
                    IDS_VERIFY_CAPTION,
                    wszCaption,
                    TABLE_SIZE(wszCaption));
                int iAction = MessageBox(hwndDlg,
                                         wszMsg,
                                         wszCaption,
                                         MB_ICONQUESTION | MB_YESNO);
                if (iAction == IDNO)
                {
                    SetFocus(hCaListView);
                    break;
                }
            }
            //
            // Fall through
            //
        case IDOK:
            {
                //
                // Update the configuration.
                //
                int nItems = ListView_GetItemCount(hCaListView);

                for (int i = 0; i < nItems; i++)
                {
                    UINT state = ListView_GetItemState(hCaListView, i, LVIS_STATEIMAGEMASK) >> 12;

                    LV_ITEM LvItem;

                    LvItem.iItem = i;
                    LvItem.iSubItem = 0;
                    LvItem.mask = LVIF_PARAM;
                    ListView_GetItem(hCaListView, &LvItem);

                    pParam->fEnabled[LvItem.lParam] = (state == 2);
                }
            }
            EndDialog(hwndDlg, LOWORD(wParam) == IDOK ? IDOK : ID_UPDATE_CERTS);
            return TRUE;
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, IDCANCEL);
            return TRUE;
            break;
        }
    }

    return FALSE;
}

extern "C"
INT_PTR
CaConfig(
    HWND hParentWnd,
    DWORD nCerts,
    PBYTE pbCerts[],
    DWORD dwCertSize[],
    LPCWSTR szCertNames[],
    BOOL fEnabled[],
    BOOL fDeleted[],
    BOOL fAllowDeletion)
{
    struct CaConfigParam Param;

    Param.nCerts = nCerts;
    Param.pbCerts = pbCerts;
    Param.dwCertSize = dwCertSize;
    Param.szCertNames = szCertNames;
    Param.fEnabled = fEnabled;
    Param.fDeleted = fDeleted;
    Param.fAllowDeletion = fAllowDeletion;

    return DialogBoxParam(
                g_hResourceMod,
                MAKEINTRESOURCE(IDD_CA_CONFIG),
                hParentWnd,
                CaConfigDlgProc,
                (LPARAM)&Param);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\security\ui\mqcertui\mqcertui.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mqcertui.cpp

Abstract:

    Dialogs for certificate related user interface.

Author:

    Boaz Feldbaum (BoazF) 15-Oct-1996

--*/

#include <windows.h>
#include "certres.h"
#include <commctrl.h>

#include "prcertui.h"
#include "mqcertui.h"
#include "snapres.h"  // include snapres.h for IDS_SHOWCERTINSTR
#include "_mqres.h"	  // include function for the function to use mqutil.dll


//
// get the handle to the resource only dll, i.e. mqutil.dll
//
HMODULE		g_hResourceMod = MQGetResourceHandle();

BOOL WINAPI DllMain(
    HINSTANCE hInst,
    ULONG ul_reason_for_call,
    LPVOID lpReserved
    )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        InitCommonControls();
        break;
    }

	return TRUE;
}

//+-------------------------------------------------------------------------
//
// Function -
//      ShowPersonalCertificates
//
// Paramters -
//      hWndParent - The parent window.
//      p509List - An array that points to X509 certificates. If this
//          parameter is set to NULL, the certificate list is taken from
//          the personal cert store.
//      nCerts - The number of entries in p509List. this parameter is
//          ignored if p509List is set to NULL.
//
// Description -
//      Display a dialog box that contains a list box that shows the
//      common names of the certificates subjects. The user can also
//      view the details of any cert.
//
//+-------------------------------------------------------------------------

extern "C"
BOOL ShowPersonalCertificates( HWND                hWndParent,
                               CMQSigCertificate  *pCertList[],
                               DWORD               nCerts)
{
    struct CertSelDlgProcStruct Param;

    Param.pCertList = pCertList;
    Param.nCerts = nCerts;
    Param.ppCert = NULL;
    Param.dwType = IDS_SHOWCERTINSTR;

    return DialogBoxParam(
                g_hResourceMod,
                MAKEINTRESOURCE(IDD_CERTSEL_DIALOG),
                hWndParent,
                CertSelDlgProc,
                (LPARAM)&Param) == IDOK ;
}

//+-------------------------------------------------------------------------
//
// Function -
//      SelectPersonalCertificateForRemoval
//
// Paramters -
//      hWndParent - The parent window.
//      p509List - An array that points to X509 certificates. If this
//          parameter is set to NULL, the certificate list is taken from
//          the personal cert store.
//      nCerts - The number of entries in p509List. this parameter is
//          ignored if p509List is set to NULL.
//      pp509 - A pointrer to a buffer that receives the address of the
//          selected cert. The application is responsible for releasing
//          the cert.
//
// Description -
//      Display a dialog box that contains a list box that shows the
//      common names of the certificates subjects.  The user selectes
//      a cert. If the user presses Remove, *pp509 points to the selected
//      certificate. The user can also view the details of any cert. The
//      certificate is not removed. The calling code can choose whatever
//      it wants to do with the cert.
//
//+-------------------------------------------------------------------------

extern "C"
BOOL SelectPersonalCertificateForRemoval( HWND                hWndParent,
                                          CMQSigCertificate  *pCertList[],
                                          DWORD               nCerts,
                                          CMQSigCertificate **ppCert )
{
    struct CertSelDlgProcStruct Param;

    Param.pCertList = pCertList;
    Param.nCerts = nCerts;
    Param.ppCert = ppCert;
    Param.dwType = IDS_REMOVECERTINSTR;

    return ((DialogBoxParam(
                g_hResourceMod,
                MAKEINTRESOURCE(IDD_CERTSEL_DIALOG),
                hWndParent,
                CertSelDlgProc,
                (LPARAM)&Param) == IDOK) &&
             (*ppCert != NULL));
}

//+-------------------------------------------------------------------------
//
// Function -
//      SelectPersonalCertificateForRegister
//
// Paramters -
//      hWndParent - The parent window.
//      p509List - An array that points to X509 certificates. If this
//          parameter is set to NULL, the certificate list is taken from
//          the personal cert store.
//      nCerts - The number of entries in p509List. this parameter is
//          ignored if p509List is set to NULL.
//      pp509 - A pointrer to a buffer that receives the address of the
//          selected cert. The application is responsible for releasing
//          the cert.
//
// Description -
//      Display a dialog box that contains a list box that shows the
//      common names of the certificates subjects.  The user selectes
//      a cert. If the user presses Save, *pp509 points to the selected
//      certificate. The user can also view the details of any cert. The
//      certificate is not saved. The calling code can choose whatever
//      it wants to do with the cert.
//
//+-------------------------------------------------------------------------

extern "C"
BOOL SelectPersonalCertificateForRegister(
                                       HWND                hWndParent,
                                       CMQSigCertificate  *pCertList[],
                                       DWORD               nCerts,
                                       CMQSigCertificate **ppCert )
{
    struct CertSelDlgProcStruct Param;

    Param.pCertList = pCertList;
    Param.nCerts = nCerts;
    Param.ppCert = ppCert;
    Param.dwType = IDS_SAVECERTINSTR;

    return ((DialogBoxParam(
                g_hResourceMod,
                MAKEINTRESOURCE(IDD_CERTSEL_DIALOG),
                hWndParent,
                CertSelDlgProc,
                (LPARAM)&Param) == IDOK) &&
             (*ppCert != NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\mqupgrd\cluster.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cluster.cpp

Abstract:
                                                        
    handle upgrade on cluster

Author:

    Shai Kariv  (ShaiK)  14-Sep-98

--*/


#include "stdh.h"
#include "cluster.h"
#include "util.h"
#include "_autorel.h"

#include "ocmnames.h"
#include "setupdef.h"
#include "comreg.h"


VOID
APIENTRY
CleanupOnCluster(
    LPCWSTR pwzMsmqDir
    )
/*++

Routine Description:

    Deletes MSMQ 1.0 old files on shared disk

Arguments:

    pwzMsmqDir - Points to msmq directory on shared disk.

Return Value:

    None.

--*/
{
    //
    // Get the names of the directories to delete from
    //

    wstring szMsmqDir = pwzMsmqDir;
    wstring szMsmqSetupDir = szMsmqDir + OCM_DIR_SETUP;
    wstring szMsmqSdkDebugBinDir = szMsmqDir + OCM_DIR_SDK_DEBUG;
    wstring szMsmqSetupExchconnDir = szMsmqDir + OCM_DIR_MSMQ_SETUP_EXCHN;

    //
    // List of files to delete is in msmqocm.inf
    //

    const wstring x_wcsInf(L"MSMQOCM.INF");
    CAutoCloseInfHandle hInf = SetupOpenInfFile(
                                   x_wcsInf.c_str(),
                                   NULL,
                                   INF_STYLE_WIN4,
                                   NULL
                                   );
    if (INVALID_HANDLE_VALUE == hInf)
    {
        return;
    }

    //
    // Call SetupAPIs to do the work
    //

    if (!SetupSetDirectoryId(hInf, idMsmqDir, szMsmqDir.c_str())                      ||
        !SetupSetDirectoryId(hInf, idMsmq1SetupDir, szMsmqSetupDir.c_str())           ||
        !SetupSetDirectoryId(hInf, idMsmq1SDK_DebugDir, szMsmqSdkDebugBinDir.c_str()) ||
        !SetupSetDirectoryId(hInf, idExchnConDir, szMsmqSetupExchconnDir.c_str())
        )
    {
        return;
    }

    CAutoCloseFileQ hQueue = SetupOpenFileQueue();
    if (INVALID_HANDLE_VALUE == hQueue)
    {
        return;
    }
                                 
    if (!SetupInstallFilesFromInfSection(
            hInf,
            0,
            hQueue,
            UPG_DEL_PROGRAM_SECTION,
            NULL, 
            0 
            ))
    {
        return;
    }

    PVOID context = SetupInitDefaultQueueCallbackEx(NULL,static_cast<HWND>(INVALID_HANDLE_VALUE),0,0,0);
    if (NULL == context)
    {
        return;
    }

    if (!SetupCommitFileQueue(
             NULL,                       // optional; parent window
             hQueue,                     // handle to the file queue
             SetupDefaultQueueCallback,  // callback routine to use
             context                     // passed to callback routine
             ))
    {
        return;
    }

} //CleanupOnCluster
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\security\ui\mqcertui\certsel.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    certsel.cpp

Abstract:

    Certificate selection dialog.

Author:

    Boaz Feldbaum (BoazF) 15-Oct-1996

--*/


#include <windows.h>
#include <winnls.h>
#include <crtdbg.h>
#include "prcertui.h"
#include <mqcertui.h>
#include <rt.h>
#include <rtcert.h>
#include "automqfr.h"
#include "mqmacro.h"

#include "certres.h"
#include "snapres.h"  // include snapres.h for IDS_SHOWCERTINSTR

//
// Function -
//     AllocAndLoadString
//
// Parameters
//      hInst - The module instance.
//      uID - The string ID.
//
// Description-
//      Load a string from the string table. the function allocates the memory
//      required for holding the string. the calling code should free the memory.
//
LPWSTR AllocAndLoadString(HINSTANCE hInst, UINT uID)
{
    AP<WCHAR> pwszTmp;
	DWORD dwBuffLen = 512;
	DWORD dwStrLen;
	
	for(;;)
	{
		pwszTmp.free();
		pwszTmp = new WCHAR[dwBuffLen];
		dwStrLen = LoadString(hInst, uID, pwszTmp, dwBuffLen);

		if (!dwStrLen)
		{
			return NULL;
		}

		if ((dwStrLen+1) < dwBuffLen)
			break;

		dwBuffLen *= 2;
	}

    LPWSTR pwszRet = new WCHAR[dwStrLen + 1];
    wcscpy(pwszRet, pwszTmp);

    return pwszRet;
}

//
// Function -
//      FillCertsList
//
// Parameters -
//      p509list - A pointer to an array. Each array entry points to an X509
//          certificate. If this parameter is NULL, the certificates are taken
//          from the personal certificate store in the local machine.
//      nCerts - The number of entries in p509List. this parameter is ignored if
//          p509List is NULL.
//      hListBox - A list box handle in which the names are to be filled.
//
// Description -
//      Goes over the entries in p509List, for each entry puts the common name
//      of the X509 cert subject in the list box.
//
static
BOOL
FillCertsList(
    CMQSigCertificate  *pCertList[],
    DWORD              nCerts,
    HWND               hListBox)
{
    if (!pCertList)
    {
        //
        // Enumerate all certificate in personal store.
        //
        CHCryptProv  hMyProv = NULL ;
        CHCertStore  hMyStore = NULL ;

        if (CryptAcquireContext( &hMyProv,
                                  NULL,
                                  NULL,
                                  PROV_RSA_FULL,
                                  CRYPT_VERIFYCONTEXT))
        {
            hMyStore = CertOpenSystemStore( hMyProv, &x_wszPersonalSysProtocol[0] ) ;
        }

        if (hMyStore)
        {
            LONG iCert = 0 ;
            PCCERT_CONTEXT pCertContext;
			PCCERT_CONTEXT pCertContextDuplicate;
            PCCERT_CONTEXT pPrevCertContext;

            pCertContext = CertEnumCertificatesInStore(hMyStore, NULL);

            while (pCertContext)
            {
                pCertContextDuplicate = CertDuplicateCertificateContext(pCertContext);

				R<CMQSigCertificate> pCert = NULL ;
                HRESULT hr = MQSigCreateCertificate( &pCert.ref(),
                                                     pCertContextDuplicate,
                                                     NULL,
                                                     0 ) ;
                if (SUCCEEDED(hr))
                {
                    CAutoMQFree<CERT_NAME_INFO> pNameInfo ;
                    if (SUCCEEDED(pCert->GetSubjectInfo( &pNameInfo )))
                    {
                        //
                        // Make sure this is not an Encrypted File System (EFS)
                        // certificate. We don't want these to be displayed
                        // (yoela - 6-17-98 - fix bug 3074)
                        //
                        const WCHAR x_szEncriptedFileSystemLocality[] = L"EFS";
                        BOOL fEfsCertificate = FALSE;
                        CAutoMQFree<WCHAR> wszLocality = NULL ;
                        if (SUCCEEDED(pCert->GetNames(pNameInfo,
                                                      &wszLocality,
                                                      NULL,
                                                      NULL,
                                                      NULL ))
                             && (wszLocality != NULL) )
                        {
                             fEfsCertificate =
                                 (wcscmp(wszLocality, x_szEncriptedFileSystemLocality) == 0);
                        }

                        CAutoMQFree<WCHAR> wszCommonName = NULL ;
                        if (!fEfsCertificate
                            && SUCCEEDED(pCert->GetNames( pNameInfo,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          &wszCommonName) )
                            && (wszCommonName != NULL) )
                        {
                            //
                            // Send the common name to the list box.
                            //
                            LRESULT i = SendMessage( hListBox,
                                                     LB_ADDSTRING,
                                                     0,
													 (LPARAM)(LPCWSTR)wszCommonName);
                            if (i != LB_ERR)
                            {
                                //
                                // Set the cert index as the list box item
                                // data.
                                //
                                SendMessage( hListBox,
                                             LB_SETITEMDATA,
                                             (WPARAM)i,
                                             (LPARAM)iCert);
                            }
                        }
                    }
                }

                //
                // Get next certificate
                //
                pPrevCertContext = pCertContext,
                pCertContext = CertEnumCertificatesInStore( hMyStore,
                                                        pPrevCertContext ) ;

                iCert++ ;
            }
        }

        //
        // Put the internal Falcon cert in the list box.
        // Note: it's important that pIntStore be defined before
        //       pIntCert, so it will be the last one to be released.
        //
        R<CMQSigCertStore> pIntStore = NULL ;
        R<CMQSigCertificate> pIntCert = NULL ;

        HRESULT hr = RTGetInternalCert( &pIntCert.ref(),
                                        &pIntStore.ref(),
                                         FALSE,
                                         FALSE,
                                         NULL ) ;
        if (SUCCEEDED(hr) && pIntCert.get())
        {
            CAutoMQFree<CERT_NAME_INFO> pNameInfo ;
            if (SUCCEEDED(pIntCert->GetSubjectInfo( &pNameInfo )))
            {
                CAutoMQFree<WCHAR> wszCommonName = NULL ;
                if (SUCCEEDED(pIntCert->GetNames( pNameInfo,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  &wszCommonName) )
                     && (wszCommonName != NULL) )
                {

					LRESULT i = SendMessage( hListBox,
                                             LB_ADDSTRING,
                                             0,
                                             (LPARAM)(LPCWSTR)wszCommonName);
                    if (i != LB_ERR)
                    {
                        SendMessage( hListBox,
                                     LB_SETITEMDATA,
                                     (WPARAM)i,
                                     (LPARAM)INTERNAL_CERT_INDICATOR);
                    }
                }
            }
        }
    }
    else
    {
        DWORD i;
        CMQSigCertificate  *pCert ;

        for (i = 0; i < nCerts; i++ )
        {
			pCert = pCertList[i];
            CAutoMQFree<CERT_NAME_INFO> pNameInfo ;
            if (SUCCEEDED(pCert->GetSubjectInfo( &pNameInfo )))
            {
                CAutoMQFree<WCHAR> wszCommonName = NULL ;
                if (SUCCEEDED(pCert->GetNames( pNameInfo,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &wszCommonName) )
                     && (wszCommonName != NULL) )
                {

                    LRESULT j = SendMessage( hListBox,
                                             LB_ADDSTRING,
                                             0,
                                             (LPARAM)(LPCWSTR)wszCommonName);
                    if (j != LB_ERR)
                    {
                        SendMessage( hListBox,
                                     LB_SETITEMDATA,
                                     (WPARAM)j,
                                     (LPARAM)i);
                    }
                }
            }
        }
    }
    //
    // Set the selected item to be the first item in the list box.
    //
    SendMessage(hListBox, LB_SETCURSEL, 0, 0);

    return TRUE;
}

//
// The dialog procedure of the certificate selection dialog.
//
INT_PTR CALLBACK CertSelDlgProc( HWND   hwndDlg,
                                 UINT   uMsg,
                                 WPARAM wParam,
                                 LPARAM lParam )
{
    static CMQSigCertificate **ppCert = NULL ;
    static CMQSigCertificate **pCertList;
    static DWORD dwType;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            struct CertSelDlgProcStruct *pParam =
                                  (struct CertSelDlgProcStruct *) lParam ;

            pCertList = pParam->pCertList ;
            ppCert = pParam->ppCert ;
            dwType = pParam->dwType;
            //
            // Set the instruction field.
            //
            AP<WCHAR> wszCertInstr = AllocAndLoadString(g_hResourceMod, dwType);

            SetWindowText( GetDlgItem(hwndDlg, IDC_CERTSINSTR),
                           wszCertInstr ) ;
            //
            // Get handles to windows in the dialog.
            //
            HWND hListBox = GetDlgItem(hwndDlg, IDC_CERTSLIST);
            HWND hWndShowCert = GetDlgItem(hwndDlg, IDC_SHOWCERT);
            HWND hWndOK = GetDlgItem(hwndDlg, IDOK);
            //
            // Fill the certificate list box.
            //
            FillCertsList(pCertList, pParam->nCerts, hListBox);

            // If there are no certificates, disable some of the buttons.
            if (SendMessage(hListBox, LB_GETCOUNT, 0, 0) == 0)
            {
                if (dwType != IDS_SHOWCERTINSTR)
                {
                    EnableWindow(hWndOK, FALSE);
                }

                EnableWindow(hWndShowCert, FALSE);
            }

            // Do some special initialization acording to the type of dialog.
            switch(dwType)
            {
            case IDS_SHOWCERTINSTR:
                {
                    WINDOWPLACEMENT wp;
                    HWND hCancelWnd = GetDlgItem(hwndDlg, IDCANCEL);

                    // Hide the "Cancel" button and move up the "View Certificate" button.
                    wp.length = sizeof(WINDOWPLACEMENT);
                    GetWindowPlacement(hCancelWnd, &wp);
                    SetWindowPlacement(hWndShowCert, &wp);
                    ShowWindow(hCancelWnd, SW_HIDE);
                }
                break;

            case IDS_REMOVECERTINSTR:
                {
                    // Modify the text of the "OK" button to "Remove"
                    AP<WCHAR> wszRemove = AllocAndLoadString(g_hResourceMod, IDS_REMOVE);
                    SetWindowText(hWndOK, wszRemove);
                }
                break;

            case IDS_SAVECERTINSTR:
                {
                    // Modify the text of the "OK" button to "Remove"
                    AP<WCHAR> wszSave = AllocAndLoadString(g_hResourceMod, IDS_SAVE);
                    SetWindowText(hWndOK, wszSave);
                }
                break;
            }
        }
        break;

    case WM_PAINT:
        {
            //
            // Draw the exclamation icon.
            //
            HWND hIconWnd = GetDlgItem(hwndDlg, IDC_CERTSEL_ICON) ;
            HICON hExclIcon = LoadIcon(NULL, IDI_EXCLAMATION);
            if (hIconWnd && hExclIcon)
            {
                HDC hDC = GetDC(hIconWnd);
                if (hDC)
                {
                    DrawIcon(hDC, 0, 0, hExclIcon);
                    ReleaseDC(hIconWnd, hDC);
                }
            }
        }
        break;

    case WM_COMMAND:
        switch (wParam)
        {
        case IDOK:
            if (ppCert)
            {
                //
                // Copy the selected certificate to the out parameter.
                //
                HWND hListBox = GetDlgItem(hwndDlg, IDC_CERTSLIST);
                INT_PTR i = SendMessage( hListBox, LB_GETCURSEL, 0, 0);
                LONG iCert = INT_PTR_TO_INT (SendMessage( hListBox,
                                                          LB_GETITEMDATA,
                                                          (WPARAM) i,
                                                          0 )) ;

                CMQSigCertificate *pSelCert = NULL;
                *ppCert = NULL;

                //
                // Set pSelCert to point to the selected cert.
                //
                HRESULT hr ;
                if (!pCertList)
                {
                    if (iCert == INTERNAL_CERT_INDICATOR)
                    {
                        //
                        // In this case pSelCert should remain set to NULL.
                        //
                        hr = MQSigCloneCertFromReg(
                                              ppCert,
                                              MQ_INTERNAL_CERT_STORE_REG,
                                              0 ) ;
                    }
                    else
                    {
                        //
                        // The selected cert is in the personal cert store.
                        //
                        hr = MQSigCloneCertFromSysStore(
                                                   &pSelCert,
                                  (const LPSTR) &x_szPersonalSysProtocol[0],
                                                   iCert ) ;
                    }
                }
                else
                {
                    pSelCert = pCertList[iCert];
                }
                //
                // Copy the selected cert to the out parameter.
                //
                if (pSelCert)
                {
                    *ppCert = pSelCert ;
                }
            }
            EndDialog(hwndDlg, IDOK);
            return TRUE;
            break;

        case IDCANCEL:
            // No cert was selected.
            if (ppCert)
            {
                *ppCert = NULL;
            }
            EndDialog(hwndDlg, IDCANCEL);
            return TRUE;
            break;

        case IDC_SHOWCERT:
            {
                HWND hListBox = GetDlgItem(hwndDlg, IDC_CERTSLIST);
                INT_PTR i = SendMessage( hListBox, LB_GETCURSEL, 0, 0 );
                LONG iCert = INT_PTR_TO_INT( SendMessage( hListBox,
                                                          LB_GETITEMDATA,
                                                          (WPARAM) i,
                                                          0));

                R<CMQSigCertificate> pTmpCert = NULL;
                CMQSigCertificate *pCertSel = NULL;
                BOOL bInternal = TRUE ;
                HRESULT hr ;
                //
                // Set pCertSel to point to the cert that should be shown.
                //
                if (!pCertList)
                {
                    if (iCert == INTERNAL_CERT_INDICATOR)
                    {
                        hr = MQSigCloneCertFromReg(
                                              &pTmpCert.ref(),
                                              MQ_INTERNAL_CERT_STORE_REG,
                                              0 ) ;
                    }
                    else
                    {
                        //
                        // The selected cert is in the personal cert store.
                        //
                        bInternal = FALSE ;
                        hr = MQSigCloneCertFromSysStore(
                                                   &pTmpCert.ref(),
                                (const LPSTR) &x_szPersonalSysProtocol[0],
                                                   iCert ) ;
                    }

                    if (FAILED(hr))
                    {
                        AP<WCHAR> wszCantGetCert =
                             AllocAndLoadString(g_hResourceMod, IDS_CANT_GET_CERT);
                        AP<WCHAR> wszError =
                                     AllocAndLoadString(g_hResourceMod, IDS_ERROR);
                        MessageBox( hwndDlg,
                                    wszCantGetCert,
                                    wszError,
                                    (MB_OK | MB_ICONEXCLAMATION)) ;
                    }
                    else
                    {
                        pCertSel = pTmpCert.get();
                    }
                }
                else
                {
                    //
                    // See whether this is an internal cert according to the
                    // subject's locality. If it is "MSMQ", this is an
                    // internal certificate.
                    //
                    bInternal = FALSE ;
                    pCertSel = pCertList[iCert];

                    CAutoMQFree<CERT_NAME_INFO> pNameInfo ;
                    if (SUCCEEDED(pCertSel->GetSubjectInfo( &pNameInfo )))
                    {
                        CAutoMQFree<WCHAR> wszLocality = NULL ;
                        if (SUCCEEDED(pCertSel->GetNames(pNameInfo,
                                                         &wszLocality,
                                                         NULL,
                                                         NULL,
                                                         NULL ))
                             && (wszLocality != NULL) )
                        {
                            bInternal =
                                    (wcscmp(wszLocality, L"MSMQ") == 0);
                        }
                    }
                }

                // Call the cert info dialog.
                if (pCertSel)
                {
                    ShowCertificate( hwndDlg,
                                     pCertSel,
                                     bInternal ? CERT_TYPE_INTERNAL :
                                                 CERT_TYPE_PERSONAL );
                }
            }
           return TRUE;
            break;
        }
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\mqupgrd\creatobj.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    creatobj.h

Abstract:

    Create msmqConfiguration object, first time msmq service boot
    after setup.

Author:

    Doron Juster (DoronJ)  08-Mar-1999

--*/

#define NUMOF_CREATE_OBJ_EVENTS  2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\mqupgrd\mqupgrd.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mqupgrd.cpp

Abstract:

    Helper DLL for mqqm.dll. 

Author:

    Shai Kariv  (ShaiK)  21-Oct-98

--*/


#include "stdh.h"
#include "cluster.h"
#include "mqupgrd.h"
#include "..\msmqocm\setupdef.h"
#include <autorel2.h>
#include <shlobj.h>
#include "_mqres.h"

#include "mqupgrd.tmh"

static WCHAR *s_FN=L"mqupgrd/mqupgrd";

HINSTANCE g_hMyModule = NULL;
HMODULE	  g_hResourceMod = MQGetResourceHandle();


BOOL
WINAPI
DllMain(
    HANDLE hDll,
    DWORD  Reason,
    LPVOID  //Reserved
    )
{
    if (Reason == DLL_PROCESS_ATTACH)
    {
        WPP_INIT_TRACING(L"Microsoft\\MSMQ");

        g_hMyModule = (HINSTANCE) hDll;
    }

    if (Reason == DLL_PROCESS_DETACH)
    {
        WPP_CLEANUP();
    }

    return TRUE;

} //DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\mqupgrd\cluster.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    cluster.h

Abstract:
                                                        
    Declarations for cluster related classes and functions.

Author:

    Shai Kariv  (ShaiK)  21-Oct-98

--*/


#ifndef _MQUPGRD_CLUSTER_H_
#define _MQUPGRD_CLUSTER_H_

#include "util.h"


VOID
APIENTRY
CleanupOnCluster(
    LPCWSTR pwzMsmqDir
    );

#endif //_MQUPGRD_CLUSTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\mqupgrd\stdh.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Standard header file to MQUPGRD

Author:

    Shai Kariv (ShaiK) 14-Sep-1998.

--*/


#ifndef _MQUPGRD_STDH_H_
#define _MQUPGRD_STDH_H_


#include "upgrdres.h"
#include <_stdh.h>
#include <mqutil.h>
#include <_mqdef.h>
#include <mqreport.h>
#include <mqlog.h>


//
//  STL include files are using placment format of new
//
#ifdef new
#undef new
#endif

#include <string>
using std::wstring;

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


extern HINSTANCE g_hMyModule;

extern void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint);
extern void LogIllegalPoint(LPWSTR wszFileName, USHORT usPoint);
extern void LogTraceQuery(LPWSTR wszStr, LPWSTR wszFileName, USHORT usPoint);





#endif //_MQUPGRD_STDH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\mqupgrd\util.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    util.cpp

Abstract:
                                                        
    general utilities and misc

Author:

    Shai Kariv  (ShaiK)  21-Oct-98

--*/


#include "stdh.h"
#include "util.h"

#include "util.tmh"

static WCHAR *s_FN=L"mqupgrd/util";
extern HMODULE g_hResourceMod;

wstring 
FormatErrMsg(
    UINT id,  ...
    )
/*++

Routine Description:

    Generates a description string for a given error

Arguments:

    id - of the error
    ... - list of formatted parameters to include in the description

Return Value:

    std::wstring - the description string

--*/
{
    WCHAR buf[MAX_DESC_LEN] = {L'\0'};

    VERIFY(0 != LoadString(
                    g_hResourceMod,
                    id,
                    buf,
                    sizeof(buf) / sizeof(buf[0]) 
                    ));

    va_list args;
    va_start(args, id);
    
    LOCALP<WCHAR> pwcs;
    VERIFY(0 != FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_STRING,
                    buf,
                    0,
                    0,
                    (LPWSTR)&pwcs,
                    0,
                    (va_list *)&args
                    ));

    va_end(args);

    wstring wcsErr(pwcs);
    return wcsErr;

} //FormatErrMsg



void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"MQUpgrd Error: %s/%d. HR: 0x%x", 
                     wszFileName,
                     usPoint,
                     hr));
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT usPoint)
{
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogDS,
                         LOG_DS_ERRORS,
                         L"MQUpgrd Error: %s/%d. Point", 
                         wszFileName,
                         usPoint));
}

void LogTraceQuery(LPWSTR wszStr, LPWSTR wszFileName, USHORT usPoint)
{
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogDS,
                         LOG_DS_ERRORS,
                         L"MQUpgrd Trace: %s/%d. %s", 
                         wszFileName,
                         usPoint,
                         wszStr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\mqupgrd\creatobj.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    creatobj.cpp

Abstract:

    Create msmqConfiguration object, first time msmq service boot
    after setup.

Author:

    Doron Juster (DoronJ)  08-Mar-1999
    ilan herbst  (ilanh)   27-Aug-2000

--*/

#include "stdh.h"
#include <mqupgrd.h>
#include <autorel.h>
#include <mqprops.h>
#include <mqsec.h>
#include <mqnames.h>
#include "..\..\ds\h\mqdsname.h"
#include <ad.h>

#include "creatobj.tmh"

static WCHAR *s_FN=L"mqupgrd/creatobj";


//+------------------------------------------------
//
//  HRESULT _UpdateMachineSecurityReg()
//
//  Write security properties if newly created
//  msmqConfiguration object in local registry.
//
//+------------------------------------------------

static 
HRESULT 
_UpdateMachineSecurityReg( 
	IN WCHAR       *pwszMachineName,
	IN PSID         pUserSid,
	IN GUID        *pMachineGuid 
	)
{
    //
    // cache machine account sid in registry.
    //
    PROPID propidSid = PROPID_COM_SID;
    MQPROPVARIANT   PropVarSid;
    PropVarSid.vt = VT_NULL;
    PropVarSid.blob.pBlobData = NULL;
    P<BYTE> pSid = NULL;

    HRESULT hr = ADGetObjectProperties(
						eCOMPUTER,
						NULL,  // pwcsDomainController
						false, // fServerName
						pwszMachineName,
						1,
						&propidSid,
						&PropVarSid
						);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    pSid = PropVarSid.blob.pBlobData;
    ASSERT(IsValidSid(pSid));

    DWORD dwSize = GetLengthSid(pSid);
    DWORD dwType = REG_BINARY;

    LONG rc = SetFalconKeyValue( 
					MACHINE_ACCOUNT_REGNAME,
					&dwType,
					pSid,
					&dwSize
					);
    ASSERT(rc == ERROR_SUCCESS);
    if (rc != ERROR_SUCCESS)
    {
        return LogHR(MQ_ERROR_CANNOT_WRITE_REGISTRY, s_FN, 30);
    }

    //
    // Write security descriptor of msmqConfiguration in Registry.
    //
    PSECURITY_DESCRIPTOR pSD;
    DWORD dwSDSize;
    P<BYTE> pReleaseSD = NULL ;

    SECURITY_INFORMATION RequestedInformation =
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION;

    PROPVARIANT varSD;
    varSD.vt = VT_NULL;
    hr = ADGetObjectSecurityGuid(
				eMACHINE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				pMachineGuid,
				RequestedInformation,
				PROPID_QM_OBJ_SECURITY,
				&varSD
				);

    if (hr == MQDS_OBJECT_NOT_FOUND)
    {
        //
        // This may happen because of replication delay.
        // Create a default security descriptor and cache it in registry.
        // Anyway, each time the msmq service boot it updates this value.
        //
        // Build a security descriptor that include only owner and group.
        // Owner is needed to build the DACL.
        //
        pSD = NULL;
        P<BYTE> pDefaultSD = NULL;

        hr = MQSec_GetDefaultSecDescriptor( 
					MQDS_MACHINE,
					(PSECURITY_DESCRIPTOR*) &pDefaultSD,
					FALSE, /*fImpersonate*/
					NULL,
					DACL_SECURITY_INFORMATION,
					e_UseDefaultDacl 
					);

        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 50);
        }

        PSID pOwner = NULL;
        BOOL bOwnerDefaulted = FALSE ;
        BOOL bRet = GetSecurityDescriptorOwner( 
						pDefaultSD,
						&pOwner,
						&bOwnerDefaulted
						);
        ASSERT(bRet);

        PSID pWorldSid = MQSec_GetWorldSid();
        ASSERT(IsValidSid(pWorldSid));

        PSID pComputerSid = pSid;
        //
        // Build the default machine DACL.
        //
        DWORD dwAclSize = sizeof(ACL)                            +
              (3 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))) +
              GetLengthSid(pWorldSid)                            +
              GetLengthSid(pComputerSid)                         +
              GetLengthSid(pOwner);

        if (pUserSid)
        {
            dwAclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                         GetLengthSid(pUserSid);
        }

        AP<char> DACL_buff = new char[dwAclSize];
        PACL pDacl = (PACL)(char*)DACL_buff;
        InitializeAcl(pDacl, dwAclSize, ACL_REVISION);

        DWORD dwWorldAccess = MQSEC_MACHINE_WORLD_RIGHTS;

        BOOL fAdd = AddAccessAllowedAce( 
						pDacl,
						ACL_REVISION,
						dwWorldAccess,
						pWorldSid 
						);
        ASSERT(fAdd);

        //
        // Add the owner with full control.
        //
        fAdd = AddAccessAllowedAce( 
					pDacl,
					ACL_REVISION,
					MQSEC_MACHINE_GENERIC_ALL,
					pOwner
					);
        ASSERT(fAdd);

        //
        // Add the computer account.
        //
        fAdd = AddAccessAllowedAce( 
					pDacl,
					ACL_REVISION,
					MQSEC_MACHINE_SELF_RIGHTS,
					pComputerSid
					);
        ASSERT(fAdd);

        if (pUserSid)
        {
            fAdd = AddAccessAllowedAce( 
						pDacl,
						ACL_REVISION,
						MQSEC_MACHINE_GENERIC_ALL,
						pUserSid
						);
            ASSERT(fAdd);
        }

        //
        // build absolute security descriptor.
        //
        SECURITY_DESCRIPTOR  sd;
        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

        bRet = SetSecurityDescriptorOwner(&sd, pOwner, bOwnerDefaulted);
        ASSERT(bRet);

        PSID pGroup = NULL;
        BOOL bGroupDefaulted = FALSE;

        bRet = GetSecurityDescriptorGroup( 
					pDefaultSD,
					&pGroup,
					&bGroupDefaulted
					);
        ASSERT(bRet && IsValidSid(pGroup));

        bRet = SetSecurityDescriptorGroup(&sd, pGroup, bGroupDefaulted);
        ASSERT(bRet);

        bRet = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, TRUE);
        ASSERT(bRet);

        //
        // Convert the descriptor to a self relative format.
        //
        dwSDSize = 0;

        hr = MQSec_MakeSelfRelative( 
				(PSECURITY_DESCRIPTOR) &sd,
				&pSD,
				&dwSDSize 
				);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 60);
        }
        ASSERT(dwSDSize != 0);
        pReleaseSD = (BYTE*) pSD;
    }
    else if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 70);
    }
    else
    {
        ASSERT(SUCCEEDED(hr));
        ASSERT(varSD.vt == VT_BLOB);
        pReleaseSD = varSD.blob.pBlobData;
        pSD = varSD.blob.pBlobData;
        dwSDSize = varSD.blob.cbSize;
    }

    dwType = REG_BINARY;

    rc = SetFalconKeyValue(
				MSMQ_DS_SECURITY_CACHE_REGNAME,
				&dwType,
				(PVOID) pSD,
				&dwSDSize
				);
    ASSERT(rc == ERROR_SUCCESS);
    if (rc != ERROR_SUCCESS)
    {
        return LogHR(MQ_ERROR_CANNOT_WRITE_REGISTRY, s_FN, 80);
    }

    return MQ_OK ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT _RegisterMachine()
//
//  Query machine properties from ADS and write them in registry.
//
//+-----------------------------------------------------------------------

static 
HRESULT 
_RegisterMachine( 
	IN WCHAR       *pwszMachineName,
	IN GUID        *pMachineGuid,
	IN BOOL         fSupportDepClient,
    IN const GUID * pguidSiteIdOfCreatedObject
	)
{
    //
    // Lookup the GUID of the object
    //
    PROPID columnsetPropertyIDs[] = {PROPID_E_ID};
    PROPVARIANT propVariant;
    propVariant.vt = VT_NULL;
    HRESULT hr = ADGetObjectProperties(
						eENTERPRISE,
						NULL,   // pwcsDomainController
						false,	// fServerName
						L"msmq",
						1,
						columnsetPropertyIDs,
						&propVariant
						);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, TEXT(
         "Failed to get enterpriseID, in ADGetObjectProperties(), hr- %lxh"), hr));

        return LogHR(hr, s_FN, 120);
    }

    DWORD dwType = REG_BINARY;
    DWORD dwSize = sizeof(GUID);
    LONG rc = ERROR_SUCCESS;

    if (propVariant.vt == VT_CLSID)
    {
        rc = SetFalconKeyValue( 
				MSMQ_ENTERPRISEID_REGNAME,
				&dwType,
				propVariant.puuid,
				&dwSize
				);
        ASSERT(rc == ERROR_SUCCESS);
        delete propVariant.puuid;
    }
    else
    {
        ASSERT(0);
    }
    //
    // Get back properties of object that was just created.
    // These properties are generated by the server side.
    //
    GUID guidSite = GUID_NULL;

    const UINT x_nMaxProps = 3;
    PROPID      propIDs[x_nMaxProps];
    PROPVARIANT propVariants[x_nMaxProps];
    DWORD       iProperty = 0;

    propIDs[iProperty] = PROPID_QM_MACHINE_ID;
    propVariants[iProperty].vt = VT_CLSID;
    propVariants[iProperty].puuid = pMachineGuid;
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SITE_ID;
    propVariants[iProperty].vt = VT_CLSID;
    propVariants[iProperty].puuid = &guidSite;
    iProperty++;
      
    propIDs[iProperty] = PROPID_QM_SERVICE_DEPCLIENTS;
    propVariants[iProperty].vt = VT_UI1;
    DWORD dwDepClProp = iProperty;
    iProperty++;


    ASSERT(iProperty == x_nMaxProps);
    DWORD dwSupportDepClient = fSupportDepClient;

    if (memcmp(pMachineGuid, &GUID_NULL, sizeof(GUID)) == 0)
    {
        //
        // In normal case, we expect to get the machine guid from the
        // "CreateObject" call. But if object was already created, then
        // we'll query the DS for the guid and other data. In normal case,
        // it's OK to set the other data to null. The msmq service will
        // update it on initialization.
        //
        hr = ADGetObjectProperties(
					eMACHINE,
					NULL,  // pwcsDomainController
					false, // fServerName
					pwszMachineName,
					iProperty,
					propIDs,
					propVariants 
					);
        if (FAILED(hr))
        {
            //
            // We don't wait for replication delays.
            // In the normal case, the call to DSCreateObject() will return
            // the machine guid and we won't call DSGetObjectProperties().
            // Reaching this point in code, and calling DSGet(), means that
            // the msmq service boot, created the configuration object and
            // then crashd. So user must run it manually. So we can safely
            // assume that user waited for replication to complete. Anyway,
            // the event below mention that user must wait for replication.
            //
            WCHAR wBuf[128];
            swprintf(wBuf, L"%lxh", hr);
            REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, GetMsmqConfig_ERR, 1, wBuf));

            return LogHR(hr, s_FN, 150);
        }
        dwSupportDepClient = propVariants[dwDepClProp].bVal;
    }
    else    // a newly created msmqConfiguration
    {
        //
        //  Write the site-id that was found while creating the object
        //
        guidSite = *pguidSiteIdOfCreatedObject;
    }

    //
    // Write properties to registry.
    //

    dwType = REG_BINARY;
    dwSize = sizeof(GUID);

    rc = SetFalconKeyValue( 
			MSMQ_SITEID_REGNAME,
			&dwType,
			&guidSite,
			&dwSize
			);
    ASSERT(rc == ERROR_SUCCESS);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);

    rc = SetFalconKeyValue( 
			MSMQ_MQS_DEPCLINTS_REGNAME,
			&dwType,
			&dwSupportDepClient,
			&dwSize
			);
    ASSERT(rc == ERROR_SUCCESS);

    //
    // Set same value, 0, in all MQS fields in registry. Automatic setup
    // is applicable only to msmq independent clients.
    //
    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    DWORD dwVal = 0;

    rc = SetFalconKeyValue( 
			MSMQ_MQS_REGNAME,
			&dwType,
			&dwVal,
			&dwSize
			);
    ASSERT(rc == ERROR_SUCCESS);

    rc = SetFalconKeyValue( 
			MSMQ_MQS_DSSERVER_REGNAME,
			&dwType,
			&dwVal,
			&dwSize
			);
    ASSERT(rc == ERROR_SUCCESS);

    rc = SetFalconKeyValue( 
			MSMQ_MQS_ROUTING_REGNAME,
			&dwType,
			&dwVal,
			&dwSize
			);
    ASSERT(rc == ERROR_SUCCESS);         

    return MQ_OK;

} // _RegisterMachine

//+----------------------------
//
//   HRESULT _GetSites()
//
//+----------------------------

static  
HRESULT  
_GetSites( 
	IN WCHAR      *pwszMachineName,
	OUT CACLSID   *pcauuid 
	)
{
    DWORD   dwNumSites = 0;
    GUID   *pguidSites;

    HRESULT hResult = ADGetComputerSites( 
							pwszMachineName,
							&dwNumSites,
							&pguidSites 
							);


	if (FAILED(hResult))
    {
        return LogHR(hResult, s_FN, 190);
    }

    ASSERT(dwNumSites); // Must be > 0
    pcauuid->cElems = dwNumSites;
    pcauuid->pElems = pguidSites;

    return MQ_OK;

} // _GetSites

//+-----------------------------------------------------
//
//  HRESULT  _VerifyComputerObject()
//
//+-----------------------------------------------------

HRESULT _VerifyComputerObject(IN LPCWSTR   pComputerName)
{
    PROPID propId  = PROPID_COM_SID;
    PROPVARIANT propVar;
    propVar.vt = VT_NULL;
    
    HRESULT hr = ADGetObjectProperties(
						eCOMPUTER,
						NULL,    // pwcsDomainController
						false,   // fServerName
						pComputerName,
						1,
						&propId,
						&propVar
						);

    if (FAILED(hr))
    {
        REPORT_CATEGORY(ADS_COMPUTER_OBJECT_NOT_FOUND_ERR, CATEGORY_KERNEL);
        return LogHR(hr, s_FN, 500);
    }

    delete propVar.blob.pBlobData;
    return MQ_OK;

} // _VerifyComputerObject

//+-----------------------------------------------------
//
//  HRESULT  _CreateTheConfigurationObject()
//
//+-----------------------------------------------------

HRESULT  
_CreateTheConfigurationObject( 
	IN  WCHAR      *pwszMachineName,
	OUT GUID       *pMachineGuid,
	OUT PSID       *ppUserSid,
	OUT BOOL       *pfSupportDepClient,
    OUT GUID       *pguidSiteId
	)
{
    //
    // Prepare the properties for object creation.
    //
    const UINT x_nMaxProps = 10;
    PROPID propIDs[x_nMaxProps];
    PROPVARIANT propVariants[x_nMaxProps];
    DWORD iProperty =0;

    propIDs[iProperty] = PROPID_QM_OLDSERVICE;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = SERVICE_NONE;
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_DSSERVER;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal =  0;
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_ROUTING;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal =  0;
    iProperty++;

    DWORD dwOsType;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(dwOsType);
    DWORD dwDefaultOS = MSMQ_OS_NTW;

    LONG rc = GetFalconKeyValue( 
					MSMQ_OS_TYPE_REGNAME,
					&dwType,
					static_cast<PVOID>(&dwOsType),
					&dwSize,
					(LPCWSTR) &dwDefaultOS 
					);
    if (rc != ERROR_SUCCESS)
    {
        return LogHR(HRESULT_FROM_WIN32(rc), s_FN, 210);
    }

    propIDs[iProperty] = PROPID_QM_OS;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = dwOsType;
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_DEPCLIENTS;
    propVariants[iProperty].vt = VT_UI1;
    if (dwOsType > MSMQ_OS_NTW)
    {
        //
        // MSMQ on server always supports Dep. Clients
        //
        propVariants[iProperty].bVal =  1;        
    }
    else
    {
        propVariants[iProperty].bVal =  0;
    }
    *pfSupportDepClient = propVariants[iProperty].bVal;
    iProperty++;

    BLOB blobEncrypt;
    blobEncrypt.cbSize    = 0;
    blobEncrypt.pBlobData = NULL;

    BLOB blobSign;
    blobSign.cbSize       = 0;
    blobSign.pBlobData    = NULL;

    HRESULT hr;
    hr = MQSec_StorePubKeys( 
			FALSE,
			eBaseProvider,
			eEnhancedProvider,
			&blobEncrypt,
			&blobSign 
			);

    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 490);
    }

    P<BYTE> pCleaner1            = blobEncrypt.pBlobData;
    P<BYTE> pCleaner2            = blobSign.pBlobData;

    propIDs[iProperty]           = PROPID_QM_ENCRYPT_PKS;
    propVariants[iProperty].vt   = VT_BLOB;
    propVariants[iProperty].blob = blobEncrypt;
    iProperty++;

    propIDs[iProperty]           = PROPID_QM_SIGN_PKS;
    propVariants[iProperty].vt   = VT_BLOB;
    propVariants[iProperty].blob = blobSign;
    iProperty++;

    //
    // Get sites of this machine.
    //
    CACLSID cauuid;
    hr = _GetSites( 
			pwszMachineName,
			&cauuid
			);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 220);
    }
    if (cauuid.cElems > 0)
    {
        //
        //  Save one of the site-ids, to be written later to registry
        //
        *pguidSiteId = cauuid.pElems[0];
    }

    propIDs[iProperty] = PROPID_QM_SITE_IDS;
    propVariants[iProperty].vt = (VT_CLSID | VT_VECTOR);
    propVariants[iProperty].cauuid.pElems = cauuid.pElems;
    propVariants[iProperty].cauuid.cElems = cauuid.cElems;
    DWORD iSitesIndex = iProperty;
    iProperty++;

    BYTE bSidBuf[256]; // should be enough for every possible SID.
    dwType = REG_BINARY;
    dwSize = sizeof(bSidBuf);

    DWORD ixQmOwnerSid = 0;

    //
    // Read user SID from registry. We'll send it to server, and server
    // add it with full-control to DACL of the msmqConfiguration object.
    //
    rc = GetFalconKeyValue( 
			MSMQ_SETUP_USER_SID_REGNAME,
			&dwType,
			static_cast<PVOID>(bSidBuf),
			&dwSize 
			);

    if (rc != ERROR_SUCCESS)
    {
        //
        // See if setup from local user.
        //
        DWORD dwLocal = 0;
        dwSize = sizeof(dwLocal);

        rc = GetFalconKeyValue( 
				MSMQ_SETUP_USER_LOCAL_REGNAME,
				&dwType,
				&dwLocal,
				&dwSize 
				);

        if ((rc == ERROR_SUCCESS) && (dwLocal == 1))
        {
            // Ok, Local user.
        }
        else
        {
			//
			// Ok, This is the case we JoinDomain from Workgroup, 
			// or move domains when initial installation was workgroup.
            // in that case both MSMQ_SETUP_USER_SID_REGNAME, MSMQ_SETUP_USER_LOCAL_REGNAME
			// are not set 
			// in This case we will give no specific user right like in w2k
            // ilanh 27-Aug-2000
			// 
			DBGMSG((DBGMOD_QM, DBGLVL_WARNING, TEXT(
			 "setup\\UserSid and setup\\LocalUser not found, assuming JoinDomain from workgroup, or first installation was workgroup"))) ;
		}
    }
    else
    {
        PSID pSid = (PSID) bSidBuf;
        ASSERT(IsValidSid(pSid));

        //
        // Caution: This propid is known only to Windows 2000
        // RTM msmq servers and above (not win2k beta3).
        // So if we fail to create the object, we try again w/o it.
        // This propid should be the last one in the list.
        //
        ULONG ulSidSize = GetLengthSid(pSid);
        ASSERT(ulSidSize <= dwSize);

        propIDs[iProperty] = PROPID_QM_OWNER_SID;
        propVariants[iProperty].vt = VT_BLOB;
        propVariants[iProperty].blob.pBlobData = (BYTE*) bSidBuf;
        propVariants[iProperty].blob.cbSize = ulSidSize;
        ixQmOwnerSid = iProperty;
        iProperty++;

        if (ppUserSid)
        {
            *ppUserSid = (PSID) new BYTE[ulSidSize];
            memcpy(*ppUserSid, bSidBuf, ulSidSize);
        }
    }

	ASSERT(iProperty <= x_nMaxProps);

    //
    // Create the msmq Configuration object !
    //
    hr = ADCreateObject(
			eMACHINE,
			NULL,       // pwcsDomainController
			false,	    // fServerName
			pwszMachineName,
			NULL,
			iProperty,
			propIDs,
			propVariants,
			pMachineGuid 
			);

    if (FAILED(hr) && (ixQmOwnerSid > 0))
    {
        ASSERT(("PROPID_QM_OWNDER_SID should be the last propid!",
                    ixQmOwnerSid == (iProperty - 1))) ;
        //
        // If OWNER_SID was used, then try again without it, because this
        // propid is not known to win2k beta3 msmq server (and maybe our
        // server is beta3).
        //
        iProperty--;

        hr = ADCreateObject(
				eMACHINE,
				NULL,       // pwcsDomainController
				false,	    // fServerName
				pwszMachineName,
				NULL,
				iProperty,
				propIDs,
				propVariants,
				pMachineGuid
				);
    }

    delete propVariants[iSitesIndex].cauuid.pElems;
    if (FAILED(hr))
    {
        if (hr == MQDS_OBJECT_NOT_FOUND)
        {
            //
            // We can verify computer object 
            //
            HRESULT hr1 = _VerifyComputerObject(pwszMachineName);
            if (FAILED(hr1))
            {
                return LogHR(hr1, s_FN, 380);
            }
        }
        
        return LogHR(hr, s_FN, 230);
    }

    return hr ;
}

//+------------------------------------------
//
//   HRESULT  _PostCreateProcessing()
//
//+------------------------------------------

static 
HRESULT  
_PostCreateProcessing( 
	IN HRESULT    hrCreate,                                       
	IN GUID      *pMachineGuid,
	IN WCHAR     *pwszMachineName,
	IN BOOL       fSupportDepClient,
    IN const GUID * pguidSiteIdOfCreatedObject
	)
{
    if (hrCreate == MQ_ERROR_MACHINE_EXISTS)
    {
        //
        // that's OK. the msmqConfiguration object already exist.
        // Register it locally.
        //
        *pMachineGuid = GUID_NULL;
    }
    else if (FAILED(hrCreate))
    {
        WCHAR wBuf[128];
        swprintf(wBuf, L"%lxh", hrCreate);
        REPORT_WITH_STRINGS_AND_CATEGORY((CATEGORY_KERNEL, CreateMsmqConfig_ERR, 1, wBuf));

        return LogHR(hrCreate, s_FN, 330);
    }
    else if (memcmp(pMachineGuid, &GUID_NULL, sizeof(GUID)) == 0)
    {
        //
        // That may happen if client on  Windows 2000 RTM is setting up
        // agsinst a beta3 Windows 2000 server. Explicitely query the
        // server for machine guid. On windows 2000 rtm, the machine guid
        // is returned by call to CreateObject().
        //
    }

    HRESULT hr = _RegisterMachine( 
					pwszMachineName,
					pMachineGuid,
					fSupportDepClient,
                    pguidSiteIdOfCreatedObject
					);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 340);
    }

    //
    // update QM guid in registry. We don't need previous values.
    //
    DWORD dwType = REG_BINARY;
    DWORD dwSize = sizeof(GUID);

    LONG rc = SetFalconKeyValue( 
					MSMQ_QMID_REGNAME,
					&dwType,
					pMachineGuid,
					&dwSize
					);
    DBG_USED(rc);
    ASSERT(rc == ERROR_SUCCESS);

    return MQ_OK;
}

//+-------------------------------------------------------------------------
//
//  HRESULT APIENTRY  MqCreateMsmqObj()
//
//  Create the msmqConfiguration object in ADS.
//
//  Parameters:
//
// Algorithm:
//   For Setup - the name of the msmq server is
//   already saved in registry. It was found by the setup process or was
//   given by user. For setup it's enough to use any msmq server (on domain
//   controller) in the client's site as there are no special restrictions
//   on the create process.
//
//+-------------------------------------------------------------------------

extern HINSTANCE  g_hMyModule;

HRESULT APIENTRY  MqCreateMsmqObj()
{
#ifdef _DEBUG
    TCHAR tszFileName[MAX_PATH * 2];
    DWORD dwGet = GetModuleFileName( 
						g_hMyModule,
						tszFileName,
						(MAX_PATH * 2) 
						);
    if (dwGet)
    {
        DWORD dwLen = lstrlen(tszFileName);
        lstrcpy(&tszFileName[dwLen - 3], TEXT("ini"));

        UINT uiDbg = GetPrivateProfileInt( 
						TEXT("Debug"),
						TEXT("StopBeforeRun"),
						0,
						tszFileName 
						);
        if (uiDbg)
        {
            ASSERT(0);
        }
    }
#endif

	//
	// Ignore WorkGroup registry
	//
    HRESULT hr = ADInit (
					NULL,   // pLookDS,
					NULL,   // pGetServers
					false,  // fDSServerFunctionality
					true,   // fSetupMode
					false,  // fQMDll
					true,   // fIgnoreWorkGroup
					NULL,   // pNoServerAuth
					NULL,   // szServerName
                    true    // fDisableDownlevelNotifications
					);  
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 320);
    }

    //
    // Get name of local machine.
    //
    BOOL  fUsingDNS = TRUE;
    DWORD dwNumChars = 0;
    AP<WCHAR> pwszMachineName;
    BOOL fGet = GetComputerNameExW( 
					ComputerNameDnsFullyQualified,
					pwszMachineName,
					&dwNumChars 
					);
    if (dwNumChars > 0)
    {
        pwszMachineName = new WCHAR[dwNumChars];
        fGet = GetComputerNameExW( 
					ComputerNameDnsFullyQualified,
					pwszMachineName,
					&dwNumChars 
					);
    }

    if (!fGet || (dwNumChars == 0))
    {
        ASSERT(!fGet && (dwNumChars == 0));
        //
        // DNS name not available. Retrieve NetBIOS name.
        //
		pwszMachineName.free();
        dwNumChars = MAX_COMPUTERNAME_LENGTH + 2;
        pwszMachineName = new WCHAR[dwNumChars];
        fGet = GetComputerNameW( 
					pwszMachineName,
					&dwNumChars 
					);
        fUsingDNS = FALSE;
    }
    ASSERT(fGet && (dwNumChars > 0));

    hr = MQ_OK;
    GUID MachineGuid = GUID_NULL;
    BOOL fSupportDepClient = 0;
    P<BYTE> pUserSid = NULL;
    GUID guidSiteId = GUID_NULL;

    hr = _CreateTheConfigurationObject(
				pwszMachineName,
				&MachineGuid,
				(PSID*) &pUserSid,
				&fSupportDepClient,
                &guidSiteId
				);

    if ((hr == MQDS_OBJECT_NOT_FOUND) && fUsingDNS)
    {
        //
        // This problem may happen if attribute dnsHostName is not set
        // in the computer object.
        //
        dwNumChars = MAX_COMPUTERNAME_LENGTH + 2;
        delete pwszMachineName ;
        pwszMachineName = new WCHAR[dwNumChars];
        fGet = GetComputerNameW( 
					pwszMachineName,
					&dwNumChars 
					);
        ASSERT(fGet && (dwNumChars > 0));
        fUsingDNS = FALSE;

        if (fGet && (dwNumChars > 0))
        {
            if (pUserSid)
            {
                delete pUserSid.detach();
            }
            MachineGuid = GUID_NULL ;

            hr = _CreateTheConfigurationObject(
						pwszMachineName,
						&MachineGuid,
						(PSID*) &pUserSid,
						&fSupportDepClient,
                        &guidSiteId
						);
        }
    }

    hr = _PostCreateProcessing( 
				hr,
				&MachineGuid,
				pwszMachineName,
				fSupportDepClient,
                &guidSiteId
				);

    if (SUCCEEDED(hr))
    {
        hr = _UpdateMachineSecurityReg( 
					pwszMachineName,
					pUserSid,
					&MachineGuid 
					);
    }

    return LogHR(hr, s_FN, 370);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\mqupgrd\util.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    util.h

Abstract:
                                                        
    declarations for utilities and misc

Author:

    Shai Kariv  (ShaiK)  21-Oct-98

--*/


#ifndef _MQUPGRD_UTIL_H_
#define _MQUPGRD_UTIL_H_

#include "stdh.h"

#define MAX_DESC_LEN (255)

//
// Auto pointer ( freed with LocalFree() )
//
template<class T>
class LOCALP 
{
public:
    LOCALP() : m_p(0)            {}
    LOCALP(T* p) : m_p(p)        {}
   ~LOCALP()                     { if (0 != m_p) LocalFree(m_p); }

    operator T*() const     { return m_p; }
    T** operator&()         { return &m_p;}
    //T* operator->() const   { return m_p; }
    //LOCALP<T>& operator=(T* p)   { m_p = p; return *this; }
    //T* detach()             { T* p = m_p; m_p = 0; return p; }

private:
    T* m_p;
};



wstring 
FormatErrMsg(
    UINT id,    ...
    );





#endif //_MQUPGRD_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\mqupgrd\_autorel.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    _autorel.h

Abstract:

    My auto release classes

Author:

    Shai Kariv (ShaiK) 20-Sep-1998.

--*/

#ifndef _MQUPGRD_AUTOREL_H_
#define _MQUPGRD_AUTOREL_H_

#include <setupapi.h>


class CAutoCloseInfHandle
{
public:
    CAutoCloseInfHandle(HINF h = INVALID_HANDLE_VALUE):m_h(h) {};
    ~CAutoCloseInfHandle() { if (INVALID_HANDLE_VALUE != m_h) SetupCloseInfFile(m_h); };

public:
    CAutoCloseInfHandle & operator =(HINF h) { m_h = h; return(*this); };
    HINF * operator &() { return &m_h; };
    operator HINF() { return m_h; };

private:
    HINF m_h;
};


class CAutoCloseFileQ
{
public:
    CAutoCloseFileQ(HSPFILEQ h = INVALID_HANDLE_VALUE):m_h(h) {};
    ~CAutoCloseFileQ() { if (INVALID_HANDLE_VALUE != m_h) SetupCloseFileQueue(m_h); };

public:
    CAutoCloseFileQ & operator =(HSPFILEQ h) { m_h = h; return(*this); };
    HSPFILEQ * operator &() { return &m_h; };
    operator HSPFILEQ() { return m_h; };

private:
    HSPFILEQ m_h;
};




#endif  //_MQUPGRD_AUTOREL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\dscomm_c_.c ===
#pragma warning(push, 3)
#pragma warning(disable: 4701)
#include <dscomm_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqcomp\msmqcomp.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    msmqcomp.cpp

Abstract:

    Entry point for NT 5.0 upgrade compatibility check

Author:

    Shai Kariv  (ShaiK)  08-Apr-98

--*/

#include <windows.h>
#include <winuser.h>
#include <stdio.h>
#include <tchar.h>
#include <setupapi.h>
#include <assert.h>

#include <mqmacro.h>

#include "uniansi.h"
#include "mqtypes.h"
#include "_mqdef.h"
#include "_mqini.h"
#include "mqprops.h"

#include "..\msmqocm\setupdef.h"
#include "..\msmqocm\comreg.h"
#include "resource.h"

#define COMPFLAG_USE_HAVEDISK 0x00000001

typedef struct _COMPATIBILITY_ENTRY {
	LPTSTR Description;
	LPTSTR HtmlName;
	LPTSTR TextName;       OPTIONAL
	LPTSTR RegKeyName;     OPTIONAL
	LPTSTR RegValName;     OPTIONAL
	DWORD  RegValDataSize; OPTIONAL
	LPVOID RegValData;     OPTIONAL
	LPVOID SaveValue;
	DWORD  Flags;
    LPTSTR InfName;
    LPTSTR InfSection;
} COMPATIBILITY_ENTRY, *PCOMPATIBILITY_ENTRY;

typedef BOOL
(CALLBACK *PCOMPAIBILITYCALLBACK)(
	PCOMPATIBILITY_ENTRY CompEntry,
	LPVOID Context
    );

HMODULE s_hMyModule;

//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//--------------------------------------------------------------------------
BOOL 
DllMain(
    IN const HANDLE DllHandle,
    IN const DWORD  Reason,
    IN const LPVOID Reserved 
    )
{
	UNREFERENCED_PARAMETER(Reserved);

	switch (Reason)
	{
	    case DLL_PROCESS_ATTACH:
            s_hMyModule = (HINSTANCE)DllHandle;
			break;

		case DLL_PROCESS_DETACH:
			break;

		default:
			break;
	}

    return TRUE;

} //DllMain


//+-------------------------------------------------------------------------
//
//  Function:    MqReadRegistryValue
//
//  Description: Reads values from MSMQ registry section
//
//--------------------------------------------------------------------------
static
LONG
MqReadRegistryValue(
    IN     const LPCTSTR szEntryName,
    IN OUT       DWORD   dwNumBytes,
    IN OUT       PVOID   pValueData
	)
{
	// 
	// Parse the entry to detect key name and value name
	//
    TCHAR szKeyName[256] = {_T("")};
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, szEntryName);
    TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));
    TCHAR szValueName[256] = {_T("")};
	lstrcpy(szValueName, _tcsinc(pLastBackslash));
	lstrcpy(pLastBackslash, TEXT(""));

	//
	// Open the key for read
	//
	HKEY  hRegKey;
	LONG rc = RegOpenKeyEx(
		          HKEY_LOCAL_MACHINE,
				  szKeyName,
				  0,
				  KEY_READ,
				  &hRegKey
				  );
	if (ERROR_SUCCESS != rc)
	{
		return rc;
	}

	//
	// Get the value data
	//
    rc = RegQueryValueEx( 
		     hRegKey, 
			 szValueName, 
			 0, 
			 NULL,
             (PBYTE)pValueData, 
			 &dwNumBytes
			 );
	if (ERROR_SUCCESS != rc)
	{
		return rc;
	}

    RegCloseKey(hRegKey);
	return ERROR_SUCCESS;

} // MqReadRegistryValue


//+-------------------------------------------------------------------------
//
//  Function:    CheckMsmqAcmeDsServer
//
//  Description: Detetcs ACME installation of MSMQ 1.0 DS Server
//
//  Parameters:  OUT BOOL *pfDsServer - set to TRUE iff MSMQ1 DS Server found
//
//--------------------------------------------------------------------------
static
LONG
CheckMsmqAcmeDsServer(
	OUT BOOL   *pfDsServer
	)
{

    *pfDsServer = FALSE;

    //
    // Open ACME registry key for read
    //
    HKEY hKey ;
    LONG rc = RegOpenKeyEx( 
                  HKEY_LOCAL_MACHINE,
                  ACME_KEY,
                  0L,
                  KEY_READ,
                  &hKey 
                  );
	if (rc != ERROR_SUCCESS)
    {
		//
		// MSMQ 1.0 (ACME) not installed.
		// Get out of here.
		//
		return rc;
	}

    //
    // Enumerate the values for the first MSMQ entry.
    //
    DWORD dwIndex = 0 ;
    TCHAR szValueName[MAX_STRING_CHARS] ;
    TCHAR szValueData[MAX_STRING_CHARS] ;
    DWORD dwType ;
    TCHAR *pFile ;
    BOOL  bFound = FALSE;
    do
    {
        DWORD dwNameLen = MAX_STRING_CHARS;
        DWORD dwDataLen = sizeof(szValueData) ;

        rc =  RegEnumValue( 
                  hKey,
                  dwIndex,
                  szValueName,
                  &dwNameLen,
                  NULL,
                  &dwType,
                  (BYTE*) szValueData,
                  &dwDataLen 
                  );
        if (rc == ERROR_SUCCESS)
        {
            assert(dwType == REG_SZ) ; // Must be a string
            pFile = _tcsrchr(szValueData, TEXT('\\')) ;
            if (!pFile)
            {
                //
                // Bogus entry. Must have a backslash. Ignore it.
                //
                continue ;
            }

            pFile = CharNext(pFile);
            if (OcmStringsEqual(pFile, ACME_STF_NAME))
            {
                bFound = TRUE;
            }
        }
        dwIndex++ ;

    } while (rc == ERROR_SUCCESS) ;
    RegCloseKey(hKey) ;

    if (!bFound)
    {
        //
        // MSMQ entry was not found (there's no ACME installation
		// of MSMQ 1.0 on this machine).
        //
        return ERROR_NOT_INSTALLED;
    }

    //
    // Get MSMQ type
    //
    DWORD dwMsmqType, dwServerType;
    rc = MqReadRegistryValue(
             MSMQ_ACME_TYPE_REG,
			 sizeof(DWORD),
			 (PVOID) &dwMsmqType
			 );
    if (ERROR_SUCCESS != rc)
    {
        //
        // MSMQ 1.0 (ACME) is installed but MSMQ type is unknown. 
        // Consider ACME installation to be corrupted (not completed successfully).
        //
        return rc;
    }

    if (MSMQ_ACME_TYPE_SRV == dwMsmqType)
    {
        //
        // MSMQ 1.0 (ACME) Server is installed.
        // Check type of server (FRS, PEC, etc.)
        //
        rc = MqReadRegistryValue(
                 MSMQ_MQS_REGNAME,
                 sizeof(DWORD),
                 (PVOID) &dwServerType
                 );
        if (ERROR_SUCCESS != rc)
        {
            //
            // Failed to read server type.
            //
            return rc;
        }

        if (SERVICE_PEC == dwServerType || SERVICE_PSC == dwServerType)
        {
            *pfDsServer = TRUE;
        }
    }

    return ERROR_SUCCESS;

} // CheckMsmqAcmeDsServer


//+-------------------------------------------------------------------------
//
//  Function:    CheckMsmqDsServer
//
//  Description: Detects installation of MSMQ 1.0 (K2) DS Server
// 
//  Parameters:  OUT BOOL *pfDsServer - set to TRUE iff MSMQ1 DS Server found
//
//--------------------------------------------------------------------------
static
LONG
CheckMsmqDsServer(
	OUT BOOL   *pfDsServer
	)
{
    *pfDsServer = FALSE;

    //
    // Look in MSMQ registry section for InstalledComponents value.
    // If it exists, MSMQ 1.0 (K2) or MSMQ 2.0 is installed.
    //
	DWORD dwOriginalInstalled;
	LONG rc = MqReadRegistryValue( 
      		      OCM_REG_MSMQ_SETUP_INSTALLED,
				  sizeof(DWORD),
				  (PVOID) &dwOriginalInstalled
				  );

    if (ERROR_SUCCESS != rc)
    {
        //
		// MSMQ 1.0 (K2) not installed.
        // Check if MSMQ 1.0 (ACME) is installed.
        //
        return CheckMsmqAcmeDsServer(pfDsServer);
    }

    //
    // MSMQ 1.0 (K2) or MSMQ 2.0 is installed. 
    // For MSMQ 2.0 we don't have anything to do.
    //
    TCHAR szMsmqVersion[MAX_STRING_CHARS] = {0};
    rc = MqReadRegistryValue(
        OCM_REG_MSMQ_PRODUCT_VERSION,
        sizeof(szMsmqVersion),
        (PVOID) szMsmqVersion
        );
    if (ERROR_SUCCESS == rc)
    {
        //
        // The ProductVersion value was successfully read from registry,
        // i.e. MSMQ 2.0 is installed on the machine.
        // i.e. MSMQ 1.0 is NOT installed on the machine.
        //
        return ERROR_NOT_INSTALLED;
    }
    
    //
    // Check type of MSMQ 1.0 (K2)
    //
    if (OCM_MSMQ_SERVER_INSTALLED == (dwOriginalInstalled & OCM_MSMQ_INSTALLED_TOP_MASK))
    {
        //
        // Server. Check type of server.
        //
        DWORD dwServerType = dwOriginalInstalled & OCM_MSMQ_SERVER_TYPE_MASK;
        if (OCM_MSMQ_SERVER_TYPE_PEC == dwServerType ||
            OCM_MSMQ_SERVER_TYPE_PSC == dwServerType)
        {
            *pfDsServer = TRUE;
        }
    }

	return ERROR_SUCCESS;

} // CheckMsmqDsServer


//+-------------------------------------------------------------------------
//
//  Function:   CompatibilityProblemFound
//
//  Returns:    TRUE iff MSMQ 1.0 DS Server found on the machine.
//
//--------------------------------------------------------------------------
static
BOOL
CompatibilityProblemFound()
{
    BOOL fDsServer = FALSE;
    LONG rc = CheckMsmqDsServer(&fDsServer);
    UNREFERENCED_PARAMETER(rc);

    return fDsServer;

} // CompatibilityProblemFound


//+-------------------------------------------------------------------------
//
//  Function:   MsmqComp
//
//--------------------------------------------------------------------------
BOOL
MsmqComp(
	PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
{
    if (CompatibilityProblemFound())
    {
        COMPATIBILITY_ENTRY CompEntry;
        ZeroMemory(&CompEntry, sizeof(CompEntry));
        TCHAR szDescription[1024];
        LoadString(  
            s_hMyModule,
            IDS_Description,
            szDescription,
            sizeof(szDescription)/sizeof(szDescription[0])
            );
        CompEntry.Description = szDescription;
        CompEntry.TextName    = L"CompData\\msmqcomp.txt";

        return CompatibilityCallback(
                   &CompEntry,
                   Context
                   );
    }

    return TRUE;

} // MsmqComp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqcomp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by msmqcomp.rc
//
#define IDS_Description                 1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\comreg.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    comreg.h

Abstract:

    Common registry definition.

Author:

    Doron Juster  (DoronJ)  26-Aug-97

--*/

//
// Names of registry values.
//
#define  OCM_REG_STORAGE_XACT_LOG       TEXT("StoreXactLogPath")
#define  OCM_REG_STORAGE_JOURNAL        TEXT("StoreJournalPath")
#define  OCM_REG_STORAGE_LOG            TEXT("StoreLogPath")
#define  OCM_REG_STORAGE_PERSISTENT     TEXT("StorePersistentPath")
#define  OCM_REG_STORAGE_RELIABLE       TEXT("StoreReliablePath")

#define  OCM_REG_LASTPRIVATEQ           TEXT("LastPrivateQueueId")

#define  FALCON_REG_POS_DESC            TEXT("HKLM")
#define  HKLM_DESC                      TEXT("HKLM")

#define  WELCOME_TODOLIST_MSMQ_KEY      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\OCManager\\ToDoList\\MSMQ")
#define  WELCOME_TITLE_NAME             TEXT("Title")
#define  WELCOME_CONFIG_COMMAND_NAME    TEXT("ConfigCommand")
#define  WELCOME_CONFIG_ARGS_NAME       TEXT("ConfigArgs")

#define  MSMQ_FILES_COPIED_REGNAME      TEXT("FilesAlreadyCopied")

//
// Names of MSMQ 1.0 registry values
//
#define  OCM_REG_MSMQ_SHORTCUT_DIR      TEXT("OCMsetup\\ShortcutDirectory")
#define  ACME_KEY   TEXT("SOFTWARE\\Microsoft\\MS Setup (ACME)\\Table Files")
#define  ACME_STF_NAME                  TEXT("MSMQ.STF")
#define  ACME_SETUP_DIR_NAME            TEXT("setup")
#define  MSMQ_ACME_TYPE_REG             TEXT("setup\\Type")
#define  MSMQ_ACME_TYPE_IND             0
#define  MSMQ_ACME_TYPE_SRV             1
#define  MSMQ_ACME_TYPE_RAS             2
#define  MSMQ_ACME_TYPE_DEP             3

//
// MSMQ 1.0 K2 and MSMQ 2.0 Beta 2 values
//
#define  OCM_REG_MSMQ_SETUP_INSTALLED   TEXT("OCMsetup\\InstalledComponents")
#define  OCM_REG_MSMQ_DIRECTORY         TEXT("OCMsetup\\Directory")

//
// MSMQ 2.0 Beta 2 registry values
//
#define  OCM_REG_MSMQ_PRODUCT_VERSION   TEXT("OCMsetup\\ProductVersion")
#define  OCM_REG_MSMQ_BUILD_DESCRIPTION TEXT("OCMsetup\\BuildDescription")

//
// MSMQ 2.0 Beta 3 registry values
//
#define  REG_INSTALLED_COMPONENTS       TEXT("InstalledComponents")
#define  REG_DIRECTORY                  TEXT("Directory")

//
// These values indicate what type of MSMQ 2.0 / MSMQ 1.0 (K2) is installed
//
#define OCM_MSMQ_INSTALLED_TOP_MASK    0xe0000000
#define OCM_MSMQ_SERVER_INSTALLED      0xe0000000
#define OCM_MSMQ_RAS_SERVER_INSTALLED  0xc0000000
#define OCM_MSMQ_IND_CLIENT_INSTALLED  0xa0000000
#define OCM_MSMQ_DEP_CLIENT_INSTALLED  0x80000000
#define OCM_MSMQ_SERVER_TYPE_MASK      0x1e000000
#define OCM_MSMQ_SERVER_TYPE_PEC       0x1e000000
#define OCM_MSMQ_SERVER_TYPE_PSC       0x1c000000
#define OCM_MSMQ_SERVER_TYPE_BSC       0x1a000000
#define OCM_MSMQ_SERVER_TYPE_SUPPORT   0x18000000


#define MSMQ_REG_SETUP_KEY   (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY TEXT("\\Setup"))

//
// These values indicate registry keys for PGM driver
//
#define SERVICES_ROOT_REG   TEXT("System\\CurrentControlSet\\Services")
#define PARAMETERS_REG      TEXT("Parameters")
#define WINSOCK_REG         TEXT("Winsock")

#define PGM_DLL_REGKEY              TEXT("HelperDllName")
#define PGM_MAXSOCKLENGTH_REGKEY    TEXT("MaxSockAddrLength")
#define PGM_MINSOCKLENGTH_REGKEY    TEXT("MinSockAddrLength")
#define PGM_MAPPING_REGKEY          TEXT("Mapping")

#define TRANSPORTS_REGKEY           TEXT("Transports") //under Services\Winsock

//
// Registry key to hide setup tracing: it is located under MSMQ\Setup
//
#define WITHOUT_TRACING_REGKEY      TEXT("SetupWithoutTracing")

//
// Common OC Manager registry to save for subcomponent status
//
//#define OCM_SUBCOMPONENTS_REG TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\activex.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    activex.cpp

Abstract:

    Code to install Falcon activeX dll.

Author:


Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include <mqexception.h>

#include "activex.tmh"

//+--------------------------------------------------------------
//
// Function: RegisterActiveX
//
// Synopsis: Installs or uninstalls MSMQ ActiveX DLL
//
//+--------------------------------------------------------------
void 
RegisterActiveX( 
	BOOL bRegister
	)
{
    //
    // do native registration (e.g. 32 bit on win32, 64 bit on win64)
    //
    try
    {
        RegisterDll(
            bRegister,
            FALSE,
            ACTIVEX_DLL
            );
#ifdef _WIN64
    //
    // do wow64 registration (e.g. 32 bit on win64)
    //
     
        RegisterDll(
            bRegister,
            TRUE,
            ACTIVEX_DLL
            );

#endif //_WIN64

    }
    catch(bad_win32_error e)
    {
        MqDisplayError(
            NULL, 
            IDS_ACTIVEXREGISTER_ERROR,
            e.error(),
            ACTIVEX_DLL
            );
    }
} //Register ActiveX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\comerror.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    comerror.cpp

Abstract:

    Error handling code.

Author:

    Doron Juster  (DoronJ)  26-Jul-97  

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include <lmerr.h>

#include "comerror.tmh"

void
FormatTime(
    IN OUT PTCHAR psz,
    ... 
    )
/*++

Routine Description:

    Generates a string with time variables

Arguments:

    psz - pointer to string buffer
    ... - list of time variables

Return Value:

    None

--*/
{
    va_list args;
    va_start(args, psz );

    LPTSTR pBuf = 0;
    CResString strTime(IDS_TIME_LOG);
    DWORD dw = FormatMessage(
                   FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                   strTime.Get(),
                   0,
                   0,
                   (LPTSTR)&pBuf,
                   MAX_STRING_CHARS,
                   &args
                   );
    ASSERT(("FormatMessage() failed to format time string", 0 != dw));

    if (0 == dw)
        return;

    lstrcpy(psz, pBuf);
    LocalFree(pBuf);

} //FormatTime


//+--------------------------------------------------------------
//
// Function: LogMessage
//
// Synopsis: Writes a message to the log file 
//
//+--------------------------------------------------------------
void
LogMessage(
    IN const TCHAR * pszMessage
    )
{
    TCHAR szMsg[MAX_STRING_CHARS] = {_T("")};

    static TCHAR szLogPath[MAX_PATH] = {_T("")};
    static bool fLogInitialized = false;
    if (!fLogInitialized)
    {
        fLogInitialized = true;
        GetSystemWindowsDirectory(szLogPath, sizeof(szLogPath)/sizeof(szLogPath[0])); 
        lstrcat(szLogPath, _T("\\"));
        lstrcat(szLogPath, LOG_FILENAME);
               
        WCHAR szUnicode[] = {0xfeff, 0x00};
        lstrcpy(szMsg, szUnicode);
        CResString strMsg(IDS_SETUP_START_LOG);        
        lstrcat(szMsg, strMsg.Get());
        
        SYSTEMTIME time;
        GetLocalTime(&time);
        TCHAR szTime[MAX_STRING_CHARS];
        FormatTime(szTime, time.wMonth, time.wDay, time.wYear, time.wHour, time.wMinute, 
            time.wSecond, time.wMilliseconds);
        lstrcat(szMsg, szTime);
        lstrcat(szMsg, TEXT("\r\n"));
    }

    //
    // Open the log file
    //
    HANDLE hLogFile = CreateFile(
                          szLogPath, 
                          GENERIC_WRITE, 
                          FILE_SHARE_READ, 
                          NULL, 
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL, 
                          NULL
                          );
    if (hLogFile != INVALID_HANDLE_VALUE)
    {
        //
        // Append the message to the end of the log file
        //
        lstrcat(szMsg, pszMessage);
        lstrcat(szMsg, TEXT("\r\n"));
        SetFilePointer(hLogFile, 0, NULL, FILE_END);
        DWORD dwNumBytes = lstrlen(szMsg) * sizeof(szMsg[0]);
        WriteFile(hLogFile, szMsg, dwNumBytes, &dwNumBytes, NULL);
        CloseHandle(hLogFile);
    }
} // LogMessage


//+--------------------------------------------------------------
//
// Function: AppendErrorDescription
//
// Synopsis: Translates error code to description string
//
//+--------------------------------------------------------------
static
void
AppendErrorDescription(
    IN OUT   TCHAR * szError,
    IN const DWORD  dwErr
    )
{
    CResString strErrCode(IDS_ERRORCODE_MSG);
    lstrcat(szError,TEXT("\r\n\r\n"));
    lstrcat(szError,strErrCode.Get());
    _stprintf(
        szError, 
        TEXT("%s0x%lX"), 
        szError, 
        dwErr
        );

    //
    // Note: Don't use StpLoadDll() in this routine since it can fail and
    // we could be back here, causing an infinite loop!
    //
    // For MSMQ error code, we will take the message from MQUTIL.DLL based on the full
    // HRESULT. For Win32 error codes, we get the message from the system..
    // For other error codes, we assume they are DS error codes, and get the code
    // from ACTIVEDS dll.
    //

    DWORD dwErrorCode = dwErr;
    HMODULE hLib = 0;
    DWORD dwFlags = FORMAT_MESSAGE_MAX_WIDTH_MASK;
    TCHAR szDescription[MAX_STRING_CHARS] = {0};
    DWORD dwResult = 1;

    switch (HRESULT_FACILITY(dwErr))
    {
        case FACILITY_MSMQ:
            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
            hLib = LoadLibrary(MQUTIL_DLL);
            break;

        case FACILITY_NULL:
        case FACILITY_WIN32:
            dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
            dwErrorCode = HRESULT_CODE(dwErr);
            break;

        default:
            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
            hLib = LoadLibrary(TEXT("ACTIVEDS.DLL"));
            break;
    }
    
    dwResult = FormatMessage( 
                   dwFlags,
                   hLib,
                   dwErr,
                   0,
                   szDescription,
                   sizeof(szDescription)/sizeof(szDescription[0]),
                   NULL 
                   );

    if ( hLib  )
        FreeLibrary( hLib );

    if (dwResult)
    {
        CResString strErrDesc(IDS_ERRORDESC_MSG);
        lstrcat(szError, TEXT("\r\n"));
        lstrcat(szError, strErrDesc.Get());
        lstrcat(szError, szDescription);
    }

} // AppendErrorDescription


//+--------------------------------------------------------------
//
// Function: vsDisplayMessage
//
// Synopsis: Used internally in this module to show message box
//
//+--------------------------------------------------------------
int 
vsDisplayMessage(
    IN const HWND    hdlg,
    IN const UINT    uButtons,
    IN const UINT    uTitleID,
    IN const UINT    uErrorID,
    IN const DWORD   dwErrorCode,
    IN const va_list argList)
{
    UNREFERENCED_PARAMETER(hdlg);
        
    if (REMOVE == g_SubcomponentMsmq[eMSMQCore].dwOperation && 
        !g_fMSMQAlreadyInstalled)
    {
        //
        // Special case. Successfull installation of MSMQ is NOT registered in 
        // the registry, but nevertheless MSMQ is being "removed". All operations
        // are performed as usual, except for error messages - no point to 
        // show them. So in this case, don't message box (ShaiK, 8-Jan-98),
        //
        return IDOK;
    }
    else    
    {
        CResString strTitle(uTitleID);
        CResString strFormat(uErrorID);
        LPTSTR szTmp;
        DWORD dw = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_STRING,
            strFormat.Get(),
            0,
            0,
            (LPTSTR)&szTmp,
            0,
            (va_list *)&argList
            );
        ASSERT(("FormatMessage failed", dw));
        UNREFERENCED_PARAMETER(dw);

        //
        // Append the error code and description
        //
        TCHAR szError[MAX_STRING_CHARS] = {TEXT('\0')};
        lstrcpy(szError, szTmp);
        LocalFree(szTmp);
        if (dwErrorCode)
        {
            AppendErrorDescription(szError, dwErrorCode);
        }

        //
        // Display the error message (or log it in unattended setup)
        //
        if (g_fBatchInstall)
        {
            LogMessage(szError);
            return IDOK; // Must be != IDRETRY here .
        }
        else
        {
            return MessageBox(/*hdlg*/g_hPropSheet, szError, strTitle.Get(), uButtons) ;
        }
    }

} //vsDisplayMessage


//+--------------------------------------------------------------
//
// Function: MqDisplayError
//
// Synopsis: Displays error message
//
//+--------------------------------------------------------------
int 
_cdecl 
MqDisplayError(
    IN const HWND  hdlg, 
    IN const UINT  uErrorID, 
    IN const DWORD dwErrorCode, 
    ...)
{
    va_list argList;
    va_start(argList, dwErrorCode);

    return vsDisplayMessage(
        hdlg,
        (MB_OK | MB_TASKMODAL | MB_ICONHAND),
        g_uTitleID,
        uErrorID,
        dwErrorCode,
        argList);

} //MqDisplayError


//+--------------------------------------------------------------
//
// Function: MqDisplayErrorWithRetry
//
// Synopsis: Displays error message with Retry option
//
//+--------------------------------------------------------------
int 
_cdecl 
MqDisplayErrorWithRetry(
    IN const UINT  uErrorID, 
    IN const DWORD dwErrorCode,
    ...)
{
    va_list argList;
    va_start(argList, dwErrorCode );

    return vsDisplayMessage(
        NULL,
        MB_RETRYCANCEL | MB_TASKMODAL | MB_ICONHAND,
        g_uTitleID,
        uErrorID,
        dwErrorCode,
        argList);

} //MqDisplayErrorWithRetry

//+--------------------------------------------------------------
//
// Function: MqDisplayErrorWithRetryIgnore
//
// Synopsis: Displays error message with Retry and Ignore option
//
//+--------------------------------------------------------------
int 
_cdecl 
MqDisplayErrorWithRetryIgnore(
    IN const UINT  uErrorID, 
    IN const DWORD dwErrorCode,
    ...)
{
    va_list argList;
    va_start(argList, dwErrorCode );

    return vsDisplayMessage(
        NULL,
        MB_ABORTRETRYIGNORE | MB_TASKMODAL | MB_ICONHAND,
        g_uTitleID,
        uErrorID,
        dwErrorCode,
        argList);        

} //MqDisplayErrorWithRetryIgnore


//+--------------------------------------------------------------
//
// Function: MqAskContinue
//
// Synopsis: Asks user if she wants to continue
//
//+--------------------------------------------------------------
BOOL 
_cdecl 
MqAskContinue(
    IN const UINT uProblemID, 
    IN const UINT uTitleID, 
    IN const BOOL bDefaultContinue, 
    ...)
{
    //
    // Form the problem message using the variable arguments
    //

    CResString strFormat(uProblemID);
    CResString strTitle(uTitleID);        
    CResString strContinue(IDS_CONTINUE_QUESTION);

    va_list argList;
    va_start(argList, bDefaultContinue);

    LPTSTR szTmp;
    DWORD dw = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_STRING,
        strFormat.Get(),
        0,
        0,
        (LPTSTR)&szTmp,
        0,
        (va_list *)&argList
        );
    UNREFERENCED_PARAMETER(dw);
    ASSERT(("FormatMessage failed", dw));

    TCHAR szError[MAX_STRING_CHARS] ;
    lstrcpy(szError, szTmp);
    LocalFree(szTmp);

    TCHAR szErrDesc[MAX_STRING_CHARS] ;
    swprintf(szErrDesc, L"%s\r\n\r\n%s", szError, strContinue.Get());

    //
    // In unattended mode, log the problem and the default behaviour of Setup
    //
    if (g_fBatchInstall)
    {
        TCHAR szErrDescEx[MAX_STRING_CHARS];
        CResString strDefaultMsg(IDS_DEFAULT_MSG);
        CResString strDefault(IDS_DEFAULT_YES_MSG);
        if (!bDefaultContinue)
            strDefault.Load(IDS_DEFAULT_NO_MSG);
        lstrcpy(szErrDescEx, szErrDesc);
        lstrcat(szErrDescEx, TEXT("\r\n"));
        lstrcat(szErrDescEx, strDefaultMsg.Get());
        lstrcat(szErrDescEx, strDefault.Get());
        LogMessage(szErrDescEx);
        return bDefaultContinue;
    }
    else
    {
        return (MessageBox(g_hPropSheet ? g_hPropSheet: GetActiveWindow(), szErrDesc, strTitle.Get(),
                       MB_YESNO | MB_DEFBUTTON1 | MB_ICONEXCLAMATION) == IDYES);
    }
} //MqAskContinue

//+--------------------------------------------------------------
//
// Function: MqDisplayWarning
//
// Synopsis: Displays warning
//+--------------------------------------------------------------
int 
_cdecl 
MqDisplayWarning(
    IN const HWND  hdlg, 
    IN const UINT  uErrorID, 
    IN const DWORD dwErrorCode, 
    ...)
{
    va_list argList;
    va_start(argList, dwErrorCode);

    return vsDisplayMessage(
        hdlg,
        (MB_OK | MB_TASKMODAL | MB_ICONEXCLAMATION),
        IDS_WARNING_TITLE, //Message Queuing Setup Warning
        uErrorID,
        dwErrorCode,
        argList);

} //MqDisplayWarning


void
DebugLogMsg(
    IN LPCTSTR psz
    )
{
    static bool s_fIsInitialized = FALSE;
    static bool s_fWithTracing = TRUE;
    if (!s_fIsInitialized)
    {
        s_fIsInitialized = TRUE;
        //
        // check if we need to hide setup tracing
        //
        DWORD dwState = 0;
        if (MqReadRegistryValue(
                    WITHOUT_TRACING_REGKEY,                
                    sizeof(DWORD),
                    (PVOID) &dwState,
                    /* bSetupRegSection = */TRUE
                    ))
        {
            //
            // registry key is found, it means that we have to hide setup tracing
            //
            s_fWithTracing = FALSE;
        }    
    }

    if (!s_fWithTracing) return;

    SYSTEMTIME time;
    GetLocalTime(&time);
    TCHAR szTime[MAX_STRING_CHARS];
    FormatTime(szTime, time.wMonth, time.wDay, time.wYear, time.wHour, time.wMinute, 
        time.wSecond, time.wMilliseconds);
    lstrcat(szTime, _T("  Tracing:  "));
    lstrcat(szTime, psz);
    LogMessage(szTime);    
}


//+-------------------------------------------------------------------------
//
//  Function:   LogMsgHR
//
//  Synopsis:   Allows LogHR use in linked libraries (like ad.lib)
//
//--------------------------------------------------------------------------
void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    WCHAR wszBuff[MAX_PATH];
    _snwprintf(wszBuff, sizeof(wszBuff)/sizeof(WCHAR) - 1,
               L"Error: %ls/%d, HR: 0x%x",
               wszFileName, usPoint, hr);
    wszBuff[sizeof(wszBuff)/sizeof(WCHAR) - 1] = '\0';
	LogMessage(wszBuff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\devdrvr.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    devdrvr.cpp

Abstract:

    Code to install Falcon device driver.

Author:


Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include "mqexception.h"
extern "C"{
#include <wsasetup.h>
}

#include "devdrvr.tmh"

//+--------------------------------------------------------------
//
// Function: RemoveDeviceDriver
//
// Synopsis: Removes MQAC service
//
//+--------------------------------------------------------------
BOOL 
RemoveDeviceDriver(TCHAR *pszDriverName)
{
    //
    // Open a handle to the service
    //   
    SC_HANDLE hService = OpenService(g_hServiceCtrlMgr, pszDriverName, 
                                     SERVICE_ALL_ACCESS);
    if (hService != NULL)
    {
        //
        // Stop the device driver service and mark it for deletion
        //
		SERVICE_STATUS statusService;
		ControlService(hService, SERVICE_CONTROL_STOP, &statusService);
        if (!DeleteService(hService))
        {
            if (ERROR_SERVICE_MARKED_FOR_DELETE != GetLastError())
            {
                MqDisplayError(NULL, IDS_DRIVERDELETE_ERROR, GetLastError(), pszDriverName);
                CloseServiceHandle(hService);
                return FALSE;
            }
        }

        //
        // Close the service handle (and lower its reference count to 0 so
        // the service will get deleted)
        //
        CloseServiceHandle(hService);
    }

    return TRUE;

} //RemoveDeviceDriver

//+--------------------------------------------------------------
//
// Function: RemoveMQACDeviceDriver
//
// Synopsis: Removes MQAC service
//
//+--------------------------------------------------------------
BOOL 
RemoveMQACDeviceDriver()
{    
    DebugLogMsg(L"Removing the Message Queuing access control service...");
    
    TCHAR szDriverName[MAX_PATH];
    lstrcpy(szDriverName, MSMQ_DRIVER_NAME);
    BOOL f = RemoveDeviceDriver(szDriverName);

    return f;
} //RemoveMQACDeviceDriver

//+--------------------------------------------------------------
//
// Function: RemovePGMDeviceDriver
//
// Synopsis: Removes PGM service
//
//+--------------------------------------------------------------
BOOL 
RemovePGMDeviceDriver()
{    
    DebugLogMsg(L"Removing the RMCast device driver...");
    
    BOOL fRegistry = RemovePGMRegistry();

    //
    // Poke winsock to update the Winsock2 config
    //
    WSA_SETUP_DISPOSITION   disposition;
    HRESULT ret = MigrateWinsockConfiguration (&disposition, NULL, 0);
    if (ret != ERROR_SUCCESS)
    {        
        fRegistry = FALSE;
    }

    TCHAR szDriverName[MAX_PATH];
    lstrcpy(szDriverName, PGM_DRIVER_NAME);
    BOOL fDriver = RemoveDeviceDriver(szDriverName);

    return fDriver && fRegistry;
} //RemovePGMDeviceDriver

//+--------------------------------------------------------------
//
// Function: RemoveDeviceDrivers
//
// Synopsis: Removes all needed drivers
//
//+--------------------------------------------------------------
BOOL 
RemoveDeviceDrivers()
{    
    BOOL fMQAC = RemoveMQACDeviceDriver();        

    BOOL fPGM = RemovePGMDeviceDriver();    
    
    return (fMQAC && fPGM);

} //RemoveDeviceDrivers

//+--------------------------------------------------------------
//
// Function: InstallDeviceDriver
//
// Synopsis: Installs driver
//
//+--------------------------------------------------------------
BOOL 
InstallDeviceDriver(
        LPCWSTR pszDisplayName,
        LPCWSTR pszDriverPath,
        LPCWSTR pszDriverName
        )
{
    try
    {
        SC_HANDLE hService = CreateService(
                    		    g_hServiceCtrlMgr, 
                    		    pszDriverName,
                                pszDisplayName, 
                    		    SERVICE_ALL_ACCESS,
                                SERVICE_KERNEL_DRIVER, 
                    		    SERVICE_DEMAND_START,
                                SERVICE_ERROR_NORMAL, 
		                        pszDriverPath, 
		                        NULL, 
                                NULL, 
                                NULL, 
                                NULL, 
                                NULL
                                );
        if (hService != NULL)
        {
            CloseServiceHandle(hService);
            return TRUE;
        }
    
        //
        // CreateService failed.
        //
    
        DWORD err = GetLastError();
        if (err != ERROR_SERVICE_EXISTS)
        {
            throw bad_win32_error(err);
        }

        //
        // Service already exists.
        //
        // This should be ok. But just to be on the safe side,
        // reconfigure the service (ignore errors here).
        //

        hService = OpenService(g_hServiceCtrlMgr, pszDriverName, SERVICE_ALL_ACCESS);
        if (hService == NULL)
            return TRUE;

    
        ChangeServiceConfig(
                hService,
                SERVICE_KERNEL_DRIVER,
                SERVICE_DEMAND_START,
                SERVICE_ERROR_NORMAL,
                pszDriverPath,
                NULL, 
                NULL, 
                NULL, 
                NULL, 
                NULL,
                pszDisplayName
                );
    
        //
        // Close the device driver handle
        //
        CloseServiceHandle(hService);
        return TRUE;

    }
    catch(const bad_win32_error& err)
    {

        if (err.error() == ERROR_SERVICE_MARKED_FOR_DELETE)
        {
            MqDisplayError(
                NULL, 
                IDS_DRIVERCREATE_MUST_REBOOT_ERROR, 
                ERROR_SERVICE_MARKED_FOR_DELETE, 
                pszDriverName
                );
            return FALSE;
        }
        
        MqDisplayError(
            NULL, 
            IDS_DRIVERCREATE_ERROR, 
            err.error(), 
            pszDriverName
            );
        return FALSE;
    }
} //InstallDeviceDriver


//+--------------------------------------------------------------
//
// Function: InstallMQACDeviceDriver
//
// Synopsis: Installs MQAC service
//
//+--------------------------------------------------------------
BOOL 
InstallMQACDeviceDriver()
{      
    DebugLogMsg(L"Installing the Message Queuing access control service...");

    //
    // Form the path to the device driver
    //
    TCHAR szDriverPath[MAX_PATH] = {_T("")};
    _stprintf(szDriverPath, TEXT("%s\\%s"), g_szSystemDir, MSMQ_DRIVER_PATH);

    //
    // Create the device driver
    //
    TCHAR szDriverName[MAX_PATH];
    lstrcpy(szDriverName, MSMQ_DRIVER_NAME);
    LPCWSTR xIDS_DRIVER_DISPLAY_NAME =  L"Message Queuing access control";
    BOOL f = InstallDeviceDriver(
                xIDS_DRIVER_DISPLAY_NAME,
                szDriverPath,
                szDriverName
                );
    
    return f;

} //InstallMQACDeviceDriver

//+--------------------------------------------------------------
//
// Function: InstallPGMDeviceDriver
//
// Synopsis: Installs PGM service
//
//+--------------------------------------------------------------
BOOL 
InstallPGMDeviceDriver()
{   
    DebugLogMsg(L"Installing RMCast device driver...");

    //
    // Form the path to the device driver
    //
    TCHAR szDriverPath[MAX_PATH] = {_T("")};
    _stprintf(szDriverPath, TEXT("%s\\%s"), g_szSystemDir, PGM_DRIVER_PATH);

    //
    // Create the device driver
    //
    TCHAR szDriverName[MAX_PATH];
    lstrcpy(szDriverName, PGM_DRIVER_NAME);    
    LPCWSTR xIDS_PGM_DRIVER_DISPLAY_NAME = L"Reliable Multicast Protocol driver";
    BOOL f = InstallDeviceDriver(
                xIDS_PGM_DRIVER_DISPLAY_NAME,
                szDriverPath,
                szDriverName
                );
    
    if (!f)
    {
        return f;
    }
    g_fDriversInstalled = TRUE;

    //
    // form registry for the driver
    //  
    f = RegisterPGMDriver();
    if (!f)
    {
        return f;
    }

    //
    // Poke winsock to update the Winsock2 config
    //
    WSA_SETUP_DISPOSITION   disposition;
    HRESULT ret = MigrateWinsockConfiguration (&disposition, NULL, 0);
    if (ret != ERROR_SUCCESS)
    {
        MqDisplayError(NULL, IDS_WINSOCK_CONFIG_ERROR, ret, PGM_DRIVER_NAME);
        return FALSE;
    }
  
    return f;

} //InstallPGMDeviceDriver

//+--------------------------------------------------------------
//
// Function: InstallDeviceDrivers
//
// Synopsis: Installs all needed drivers
//
//+--------------------------------------------------------------
BOOL 
InstallDeviceDrivers()
{          
    BOOL f = InstallMQACDeviceDriver();
    if (!f)
    {
        return f;
    }
    g_fDriversInstalled = TRUE;
    
    f = InstallPGMDeviceDriver();
   
    return f;
} //InstallDeviceDrivers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\dslibs.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    dslibs.cpp

Abstract:

    Initialize DS libraries.

Author:


Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "dslibs.tmh"

BOOL g_fAlreadyAnsweredToServerAuthentication = FALSE;
extern BOOL NoServerAuthentication(void);

//
// Store the address of the specified function in the structure
//
#define GetFunctionPointer(hDSDLL, szDLLName, pFunction, szFunctionName, prototype) \
{                                                                       \
    pFunction = (prototype)GetProcAddress(hDSDLL, szFunctionName);      \
    if (pFunction == NULL)                                              \
    {                                                                   \
        MqDisplayError(NULL, IDS_DLLGETADDRESS_ERROR, 0,                \
                       szFunctionName, szDLLName);                      \
        return FALSE;                                                   \
    }                                                                   \
}


//+--------------------------------------------------------------
//
// Function: MQDSSrvLibrary
//
// Synopsis: Loads and initializes DS server DLL
//
//+--------------------------------------------------------------
BOOL
MQDSSrvLibrary(	
	IN const UCHAR uOperation
	)
{
    HRESULT hResult;

    //
    // Determine which operation should be performed
    //
    switch(uOperation)
    {
    case LOAD:

        break;

    case INITIALIZE:
        //
        // Initialize the DLL
        //
        hResult = ADSetupInit((UCHAR)SERVICE_DSSRV, g_wcsMachineName, NULL, false /* fDSServerFunctionality */);
        if (FAILED(hResult))
        {
            MqDisplayError(NULL, IDS_DSSERVERINITIALIZE_ERROR, hResult);
            return FALSE;
        }

        break;

    case FREE:
        //
        // Free the library
        //
        ADTerminate();

        break;
    }

    return TRUE;

} //MQDSSrvLibrary


bool WriteDsEnvRegistry(DWORD dwDsEnv)
/*++
Routine Description:
    Write DsEnvironment registry

Arguments:
	dwDsEnv - value to put in registry

Returned Value:
    true iff successful

--*/
{
	ASSERT(dwDsEnv != MSMQ_DS_ENVIRONMENT_UNKNOWN);
    if (!MqWriteRegistryValue(MSMQ_DS_ENVIRONMENT_REGNAME, sizeof(DWORD), REG_DWORD, &dwDsEnv))
    {
        return false;
    }
	return true;
}


bool DsEnvSetDefaults()
/*++
Routine Description:
    Detect DS environment and initialize DsEnvironment registry

Arguments:
	None

Returned Value:
    true iff successful

--*/
{
    if (IsWorkgroup() || g_fDsLess)
	{
		//
		// For workgroup the environment 
		// putting a default value of PURE_AD
		// we are not supporting join domain to MQIS environment.
		//
		return WriteDsEnvRegistry(MSMQ_DS_ENVIRONMENT_PURE_AD);
	}

	if(g_fUpgrade)
	{
		//
		// Every upgrade will start as MQIS environment
		//
		return WriteDsEnvRegistry(MSMQ_DS_ENVIRONMENT_MQIS);
	}

	if(g_fDependentClient)
	{
		//
		// For dependent client - perform raw detection to decide ds environment
		//
		return WriteDsEnvRegistry(ADRawDetection());
	}

#ifdef _DEBUG

	//
	// Raw Ds environment detection was done earlier in setup
	// check that the registry is indeed initialize 
	//
    DWORD dwDsEnv = MSMQ_DS_ENVIRONMENT_UNKNOWN;
    if(!MqReadRegistryValue( 
			MSMQ_DS_ENVIRONMENT_REGNAME,
            sizeof(dwDsEnv),
            (PVOID) &dwDsEnv 
			))
	{
		ASSERT(("could not read DsEnvironment registry", 0));
	}

	ASSERT(dwDsEnv != MSMQ_DS_ENVIRONMENT_UNKNOWN);
#endif

	return true;

}

//+--------------------------------------------------------------
//
// Function: MQDSCliLibrary
//
// Synopsis: Loads and initializes DS client DLL
//
//+--------------------------------------------------------------
BOOL
MQDSCliLibrary(
	IN const UCHAR uOperation,
	IN const BOOL  fInitServerAuth /* = FALSE*/)
{
    HRESULT hResult;

    //
    // Determine which operation should be performed
    //
    switch(uOperation)
    {
    case LOAD:

        break;

    case INITIALIZE:

		//
        // Initialize the DLL to setup mode.
        ///
        // IMPORTANT -
        // Do not remove the server authentication failure notification callback routine
        // (NoServerAuthentication) from the parameters of ADInit(). The fact that there
        // is a callback function, turns on secured server communications.
        //
        g_fAlreadyAnsweredToServerAuthentication = FALSE;

        hResult = ADInit(
                      NULL,  // pLookDS
                      NULL,   // pGetServers
                      false,  // fDSServerFunctionality
                      true,   // fSetupMode
                      false,  //  fQMDll
					  false,  // fIgnoreWorkGroup
                      fInitServerAuth ? NoServerAuthentication : NULL,
                      NULL,   // szServerName
                      true    // fDisableDownlevelNotifications
                      );

        if FAILED(hResult)                                     
        {                                                      
            MqDisplayError(NULL, IDS_DSCLIENTINITIALIZE_ERROR, hResult);
            return FALSE;
        }

        //
        // Update/Create Falcon CA configuration. If this fail, do not
        // mention it to the user. Server authentication will fail,
        // then the user will be notified and will have to take action.
        //

        MQsspi_UpdateCaConfig(FALSE);
		
        break;

    case FREE:
        //
        // Free the remote directory server library
        //
        ADTerminate();

        break;
    }

    return TRUE;

} //MQDSCliLibrary

//+--------------------------------------------------------------
//
// Function: BOOL LoadDSLibrary(BOOL bUpdate)
//
// Synopsis: Loads and initializes DS client or server DLL
//
//+--------------------------------------------------------------
BOOL LoadDSLibrary(
	BOOL bUpdate /* = TRUE*/
	)
{
    if (g_fServerSetup && g_dwMachineTypeDs)
    {
        if (!MQDSSrvLibrary(LOAD))
            return FALSE ;

        if (!MQDSSrvLibrary(INITIALIZE))
            return FALSE ;
    }
    else
    {
    	if (!MQDSCliLibrary(LOAD))
            return FALSE ;

        if (!MQDSCliLibrary(INITIALIZE, !bUpdate))
        	return FALSE ;
    }

    return TRUE ;
} //LoadDSLibrary
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\list.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    list.h

Abstract:

    List and List::Iterator.
    An intrusive double linked list and iterator template

Author:

    Erez Haba (erezh) 13-Aug-95

Revision History:

--*/

/*++

  DESCRIPTION:
    List is defined as a circular doubble linked list. With actions
    to insert and remove entries.

       List
      +-----+   +-----+ +-----+ +-----+ +-----+ +-----+
      |     |<--|     | |     | |     | |     | |     |
      | head|   | data| | data| | data| | data| | data|
      |     |-->|     | |     | |     | |     | |     |
      +-----+   +-----+ +-----+ +-----+ +-----+ +-----+

                      Linked list diagram

    An iteration is defined for the list using the member type named
    Iterator. To declater an interator variable, use full qualified
    name. e.g., List<T>::Iterator. An iterator variable is analogous
    to type T pointer. Dereference '*' and arrow '->' operators are
    overloaded for this type so you can (allmost) freely use it as a
    T pointer.

      Example:

        for(List<T>::Iterator p = list.begin(); p != list.end(); ++p)
        {
            p->doSomeThing();
        }
--*/

#ifndef _LIST_H
#define _LIST_H

//---------------------------------------------------------
//
//  class List
//
//---------------------------------------------------------
template<class T, int Offset = FIELD_OFFSET(T, m_link)>
class List {

public:

    class Iterator;

public:
    List(void);
   ~List(void);

    void insert(T* pItem);
    void remove(T* pItem);

    int isempty(void) const;

    T* peekhead(void) const;
    T* peektail(void) const;

    T* gethead(void);
    T* gettail(void);

    Iterator begin() const;
    Iterator end() const;

    static LIST_ENTRY* Item2Entry(T*);
    static T* Entry2Item(LIST_ENTRY*);

private:
    LIST_ENTRY m_head;

public:

    //
    // class List<T, Offset>::Iterator
    //
    class Iterator {
    private:
        LIST_ENTRY* m_current;

    public:
        //
        //  Iterator implementation is here due to bug
        //  in VC++ 4.0 compiler. If implementation is not
        //  here, liker looks for some constructor not needed
        //
        explicit Iterator(LIST_ENTRY* pEntry) :
            m_current(pEntry)
        {
        }

        Iterator& operator++()
        {
            m_current = m_current->Flink;
            return *this;
        }

        Iterator& operator--()
        {
            m_current = m_current->Blink;
            return *this;
        }

        T& operator*() const
        {
            return (*List<T, Offset>::Entry2Item(m_current));
        }

        T* operator->() const
        {
            return (&**this);
        }

        BOOL operator==(const Iterator& i)
        {
            return (m_current == i.m_current);
        }

        BOOL operator!=(const Iterator& i)
        {
            return (!(*this == i));
        }
    };
    //
    // end class Iterator decleration
    //
};


//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------
template<class T, int Offset>
inline List<T, Offset>::List(void)
{
    InitializeListHead(&m_head);
}

template<class T, int Offset>
inline List<T, Offset>::~List(void)
{
    ASSERT(isempty());
}

template<class T, int Offset>
inline LIST_ENTRY* List<T, Offset>::Item2Entry(T* t)
{
    return ((LIST_ENTRY*)(PVOID)((PCHAR)t + Offset));
}

template<class T, int Offset>
inline T* List<T, Offset>::Entry2Item(LIST_ENTRY* l)
{
    return ((T*)(PVOID)((PCHAR)l - Offset));
}

template<class T, int Offset>
inline void List<T, Offset>::insert(T* item)
{
    LIST_ENTRY* pEntry = Item2Entry(item);
    InsertTailList(&m_head, pEntry);
}

template<class T, int Offset>
inline void List<T, Offset>::remove(T* item)
{
    LIST_ENTRY* pEntry = Item2Entry(item);
    RemoveEntryList(pEntry);
}

template<class T, int Offset>
inline int List<T, Offset>::isempty(void) const
{
    return IsListEmpty(&m_head);
}

template<class T, int Offset>
inline T* List<T, Offset>::peekhead() const
{
    return (isempty() ? 0 : Entry2Item(m_head.Flink));
}

template<class T, int Offset>
inline T* List<T, Offset>::peektail() const
{
    return (isempty() ? 0 : Entry2Item(m_head.Blink));
}

template<class T, int Offset>
inline T* List<T, Offset>::gethead()
{
    if(isempty())
    {
        return 0;
    }

    //
    // return RemoveHeadList(...) will NOT work here!!! (macro)
    //
    LIST_ENTRY* p = RemoveHeadList(&m_head);
    return Entry2Item(p);
}

template<class T, int Offset>
inline T* List<T, Offset>::gettail()
{
    if(isempty())
    {
        return 0;
    }

    //
    // return RemoveTailList(...) will NOT work here!!! (macro)
    //
    LIST_ENTRY* p = RemoveTailList(&m_head);
    return Entry2Item(p);
}

template<class T, int Offset>
inline List<T, Offset>::Iterator List<T, Offset>::begin() const
{
    return Iterator(m_head.Flink);
}

template<class T, int Offset>
inline List<T, Offset>::Iterator List<T, Offset>::end() const
{
    return Iterator(const_cast<LIST_ENTRY*>(&m_head));
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\iisexten.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iisexten.cpp

Abstract:

    Code to handle iis extension.

Author:

    Tatiana Shubin  (TatianaS)  25-May-00

--*/

#include "msmqocm.h"
#include "initguid.h"
#include <coguid.h>
#include <iadmw.h>
#include <iiscnfg.h>

#pragma warning(disable: 4268)
// error C4268: 'IID_IWamAdmin' : 'const' static/global data initialized
// with compiler generated default constructor fills the object with zeros

#include <iwamreg.h>
#include "msmqocm.h"

#include "iisexten.tmh"

//
// pointers to IIS interfaces
//
IMSAdminBase    *g_pIMSAdminBase;
IWamAdmin       *g_pIWamAdmin;

class CIISPtr
{
public:
    CIISPtr ()
    {
        g_pIMSAdminBase = NULL;
        g_pIWamAdmin = NULL;
        if (SUCCEEDED(CoInitialize(NULL)))
        {
            m_fNeedUninit = TRUE;
        }
        else
        {
            m_fNeedUninit = FALSE;
        }

    }
    ~CIISPtr()
    {
        if (g_pIMSAdminBase) g_pIMSAdminBase->Release();
        if (g_pIWamAdmin) g_pIWamAdmin->Release();
        if (m_fNeedUninit) CoUninitialize();
    }
private:
    BOOL m_fNeedUninit;
};

//
// auto class for meta data handle
//
class CAutoCloseMetaHandle
{
public:
    CAutoCloseMetaHandle(METADATA_HANDLE h =NULL)
    {
        m_h = h;
    };

    ~CAutoCloseMetaHandle()
    {
        if (m_h) g_pIMSAdminBase->CloseKey(m_h);
    };

public:
    METADATA_HANDLE * operator &() { return &m_h; };
    operator METADATA_HANDLE() { return m_h; };

private:
    METADATA_HANDLE m_h;
};

//
// globals for this file
//
WCHAR g_wcsFullPath[MAX_PATH];
WCHAR g_wcsMSMQAppMap[MAX_PATH];

AP<UCHAR> g_wcsAppMap = NULL;
DWORD g_dwAppMapSize = 0;
static const DWORD g_dwIsolatedFlag = 0; //it was 2; 0 for in-process, 2 for pooled process

//+--------------------------------------------------------------
//
// Several functions to handle multi element strings (MultiSz)
// The string elemnents are separated by \0 (NULL char), and at the end there is an extra \0
//
//+--------------------------------------------------------------
//+--------------------------------------------------------------
//
// Function: MultiSzCount
//
// Synopsis: returns number of characters in multisz (without the last NULL terminator)
//
//+--------------------------------------------------------------
unsigned int MultiSzCount(const WCHAR *pwszMultiSzIn)
{
    unsigned int cchOut = 0;
    if (pwszMultiSzIn != NULL)
    {
      const WCHAR *pwszTmp = pwszMultiSzIn;
      while (*pwszTmp != L'\0')
      {
        unsigned int cch = numeric_cast<unsigned int> (wcslen(pwszTmp) + 1);
        cchOut += cch;
        pwszTmp += cch;
      }
    }
    return cchOut;
}

//+--------------------------------------------------------------
//
// Function: AddStrToMultiSz
//
// Synopsis: Adds a string to a multisz and returns the new multisz and the size (INCLUDING the last NULL terminator)
//
//+--------------------------------------------------------------
void AddStrToMultiSz(const WCHAR *pwszStr, const WCHAR *pwszMultiSzIn, WCHAR **ppwszMultiSzOut, unsigned int *pcchMultiSzOut)
{
    unsigned int cchMultiSzIn = MultiSzCount(pwszMultiSzIn);
    unsigned int cchStr = numeric_cast<unsigned int> (wcslen(pwszStr) + 1);
    //
    // Alloc MultiSzOut
    //
    AP<WCHAR> pwszMultiSzOut = new WCHAR[cchMultiSzIn + cchStr + 1];
    WCHAR * pDest = pwszMultiSzOut.get();
    //
    // Copy MultiSzIn
    //
    if (pwszMultiSzIn != NULL)
    {
      memcpy(pDest, pwszMultiSzIn, cchMultiSzIn * sizeof(WCHAR));
      pDest += cchMultiSzIn;
    }
    //
    // Copy Str
    //
    memcpy(pDest, pwszStr, cchStr * sizeof(WCHAR));
    pDest += cchStr;
    //
    // Add terminating NULL
    //
    *pDest = L'\0';
    //
    // Return values
    //
    *ppwszMultiSzOut = pwszMultiSzOut.detach();
    *pcchMultiSzOut = cchMultiSzIn + cchStr + 1;
}

//+--------------------------------------------------------------
//
// Function: RemoveStrFromMultiSz
//
// Synopsis: Removes a string to a multisz. returns true if removed, if so returns the new multisz and the size (INCLUDING the last NULL terminator)
//           Note it removes all occurences of the string (if any), not just the first one
//
//+--------------------------------------------------------------
/* We don't need this function currently!
bool RemoveStrFromMultiSz(const WCHAR *pwszStr, const WCHAR *pwszMultiSzIn, WCHAR **ppwszMultiSzOut, unsigned int *pcchMultiSzOut)
{
    if (pwszMultiSzIn == NULL)
    {
      *ppwszMultiSzOut = NULL;
      *pcchMultiSzOut = 0;
      return false;
    }

    unsigned int cchMultiSzIn = MultiSzCount(pwszMultiSzIn);
    //
    // Alloc MultiSzOut
    //
    AP<WCHAR> pwszMultiSzOut = new WCHAR[cchMultiSzIn + 2];
    WCHAR * pDest = pwszMultiSzOut.get();
    unsigned int cchMultiSzOut = 0;
    bool fRemoved = false;
    //
    // Copy any string that is not Str
    //
    const WCHAR *pwszTmp = pwszMultiSzIn;
    while (*pwszTmp != L'\0')
    {
      unsigned int cch = wcslen(pwszTmp) + 1;
      if (_wcsicmp(pwszTmp, pwszStr) == 0)
      {
        //
        // Found str to remove. Don't copy to destination just remember we removed something
        //
        fRemoved = true;
      }
      else
      {
        //
        // Not the string to remove. Copy to destination
        //
        memcpy(pDest, pwszTmp, cch * sizeof(WCHAR));
        pDest += cch;
        cchMultiSzOut += cch;
      }
      //
      // Go to next string element
      //
      pwszTmp += cch;
    }
    //
    // Add terminating NULL
    //
    if (cchMultiSzOut == 0)
    {
      //
      // We removed last string, add two NULLs, place is allocated already
      //
      *pDest = L'\0';
      *(pDest + 1) = L'\0';
      cchMultiSzOut = 2;
    }
    else
    {
      *pDest = L'\0';
      cchMultiSzOut++;
    }
    //
    // Return values
    //
    if (fRemoved)
    {
      //
      // Set MultiSzOut
      //
      *ppwszMultiSzOut = pwszMultiSzOut.detach();
      *pcchMultiSzOut = cchMultiSzOut;
    }
    else
    {
      //
      // Not removed anything, auto release buffer will be deallocated
      //
      // delete [] pwszMultiSzOut.detach();
      *ppwszMultiSzOut = NULL;
      *pcchMultiSzOut = 0;
    }
    return fRemoved;
}
*/
//+--------------------------------------------------------------
//
// Function: IsStrInMultiSz
//
// Synopsis: Checks if a string is in multisz
//
//+--------------------------------------------------------------
/* We don't need this function currently!
bool IsStrInMultiSz(const WCHAR *pwszStr, const WCHAR *pwszMultiSzIn)
{
    if (pwszMultiSzIn != NULL)
    {
      const WCHAR *pwszTmp = pwszMultiSzIn;
      while (*pwszTmp != L'\0')
      {
        if (_wcsicmp(pwszTmp, pwszStr) == 0)
        {
          return true;
        }
        unsigned int cch = wcslen(pwszTmp) + 1;
        pwszTmp += cch;
      }
    }
    return false;
}
*/
//+--------------------------------------------------------------
//
// End of functions to handle multi element strings (MultiSz)
//
//+--------------------------------------------------------------

//+--------------------------------------------------------------
//
// Function: Init
//
// Synopsis: Init COM and pointer to Interfaces
//
//+--------------------------------------------------------------

HRESULT Init ()
{
    HRESULT hr;
    //
    // get a pointer to the IWamAdmin Object
    //
	hr = CoCreateInstance(
                CLSID_WamAdmin,
                NULL,
                CLSCTX_ALL,
			    IID_IWamAdmin,
                (void **) &g_pIWamAdmin
                );

    if (FAILED(hr))
    {
        DebugLogMsg(L"CoCreateInstance for IID_IWamAdmin failed");
        return hr;
    }

    //
    // get a pointer to the IMSAdmin Object
    //
    hr = CoCreateInstance(
                CLSID_MSAdminBase,
                NULL,
                CLSCTX_ALL,
                IID_IMSAdminBase,
                (void**) &g_pIMSAdminBase
                );

    if (FAILED(hr))
    {
        DebugLogMsg(L"CoCreateInstance for IID_IMSAdminBase failed");
        return hr;
    }

    //
    // init globals here
    //
    //
    // construct full path name to extension
    //
    swprintf (g_wcsFullPath, L"%s%s", PARENT_PATH, MSMQ_IISEXT_NAME);

    WCHAR wszMsg[1000];
    wsprintf(wszMsg, L"The full path to the Message Queuing IIS extension is %s.",
                g_wcsFullPath);
    DebugLogMsg(wszMsg);

    //
    // construct MSMQ mapping
    //
    WCHAR wszMapFlag[10];
    _itow(MD_SCRIPTMAPFLAG_SCRIPT, wszMapFlag, 10);

    wsprintf(g_wcsMSMQAppMap, L"*,%s\\%s,%s,POST",
                    g_szSystemDir,
                    MQISE_DLL,
                    wszMapFlag);


    return hr;
}

//+--------------------------------------------------------------
//
// Function: IsExtensionExist
//
// Synopsis: Return TRUE if MSMQ IIS Extension already exist
//
//+--------------------------------------------------------------

BOOL IsExtensionExist()
{
    HRESULT hr;
    CAutoCloseMetaHandle metaHandle;
    hr = g_pIMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                g_wcsFullPath,
                                METADATA_PERMISSION_READ,
                                5000,
                                &metaHandle);

    if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
    {
        DebugLogMsg(L"The Message Queuing IIS extension does not exist.");
        return FALSE;
    }

    DebugLogMsg(L"The Message Queuing IIS extension exists.");
    return TRUE;
}

//+--------------------------------------------------------------
//
// Function: IsApplicationExist
//
// Synopsis: Return TRUE if application for MSMQ IIS Extension already exist
//
//+--------------------------------------------------------------
HRESULT IsApplicationExist (BOOL *pfAppExist)
{
    HRESULT hr;
    DWORD dwStatus;
    *pfAppExist = FALSE;

    hr = g_pIWamAdmin->AppGetStatus (g_wcsFullPath, &dwStatus);

    if (FAILED(hr))
    {
        DebugLogMsg(L"The application status could not be obtained.");
        return hr;
    }

    if (dwStatus == APPSTATUS_NOTDEFINED)
    {
        *pfAppExist = FALSE;
        DebugLogMsg(L"The application for the Message Queuing IIS extension does not exist.");
    }
    else
    {
        *pfAppExist = TRUE;
        DebugLogMsg(L"The application for the Message Queuing IIS extension exists.");
    }

    return hr;
}

//+--------------------------------------------------------------
//
// Function: OpenRootKey
//
// Synopsis: Open Key
//
//+--------------------------------------------------------------

HRESULT OpenRootKey(METADATA_HANDLE *pmetaHandle)
{
    HRESULT hr;
    hr = g_pIMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                            ROOT,
                            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                            5000,
                            pmetaHandle);

    if (FAILED(hr))
    {
        WCHAR wszMsg[1000];
        wsprintf(wszMsg, L"OpenKey failed, hr %x", hr);
        DebugLogMsg(wszMsg);
    }
    return hr;
}

//+--------------------------------------------------------------
//
// Function: CommitChanges
//
// Synopsis: Commit Changes
//
//+--------------------------------------------------------------

HRESULT CommitChanges()
{
    HRESULT hr;
    //
    // Commit the changes
    //
    hr = g_pIMSAdminBase->SaveData();
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_PATH_BUSY))
        {
            hr = ERROR_SUCCESS;
        }
    }

    DebugLogMsg(L"The changes for the IIS extension are committed.");
    return hr;
}

//+--------------------------------------------------------------
//
// Function: StartDefWebServer
//
// Synopsis: Start default web server if not yet started
//
//+--------------------------------------------------------------

HRESULT StartDefaultWebServer()
{
    HRESULT hr;
    CAutoCloseMetaHandle metaHandle;
    hr = OpenRootKey(&metaHandle);
    if (FAILED(hr))
    {
        DebugLogMsg(L"The key for starting the default web server could not be opened.");
        return hr;
    }

    METADATA_RECORD MDRecord;

    //
    // check server status
    //
    DWORD dwValue;
    MDRecord.dwMDIdentifier = MD_SERVER_STATE;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_SERVER;
    MDRecord.dwMDDataType = DWORD_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = sizeof(DWORD);
    MDRecord.pbMDData = (PBYTE)&dwValue;
    DWORD dwSize;
    hr = g_pIMSAdminBase->GetData(
                            metaHandle,
                            DEFAULT_WEB_SERVER_PATH,
                            &MDRecord,
                            &dwSize
                            );

    if (SUCCEEDED(hr))
    {
        if ((DWORD) (*MDRecord.pbMDData) == MD_SERVER_STATE_STARTED)
        {
            //
            // server started, do nothing
            //
            return hr;
        }
    }

    //
    // We are here iff GetData failed or server is not started.
    // Try to start it.
    //

    //
    // send start command
    //
    dwValue = MD_SERVER_COMMAND_START;
    MDRecord.dwMDIdentifier = MD_SERVER_COMMAND;
    MDRecord.pbMDData = (PBYTE)&dwValue;

    hr = g_pIMSAdminBase->SetData(metaHandle,
                                DEFAULT_WEB_SERVER_PATH,
                                &MDRecord);

    //
    // Commit the changes
    //
    hr = CommitChanges();

    return hr;
}

//+--------------------------------------------------------------
//
// Function: CreateApplication
//
// Synopsis: Create Application for MSMQ IIS Extension
//
//+--------------------------------------------------------------

HRESULT
CreateApplication ()
{
    HRESULT hr;
    //
    // create application
    //
    hr  = g_pIWamAdmin->AppCreate(
                            g_wcsFullPath,
                            FALSE       //in process
                            );
    if (FAILED(hr))
    {
        MqDisplayError(NULL, IDS_EXTEN_APPCREATE_ERROR, hr, g_wcsFullPath);

        WCHAR wszMsg[1000];
        wsprintf(wszMsg, L"The application for the IIS extension with path %s could not be created. Return code: %x.",
                    g_wcsFullPath, hr);
        DebugLogMsg(wszMsg);
    }
    return hr;
}

//+--------------------------------------------------------------
//
// Function: UnloadApplication
//
// Synopsis: Unload Application for MSMQ IIS Extension
//
//+--------------------------------------------------------------

HRESULT
UnloadApplication ()
{
    HRESULT hr;
    //
    // unload application
    //
    hr  = g_pIWamAdmin->AppUnLoad(
                            g_wcsFullPath,
                            TRUE       //recursive
                            );
    return hr;
}
//+--------------------------------------------------------------
//
// Function: GetApplicationMapping
//
// Synopsis: Get existed application mapping
//
//+--------------------------------------------------------------

HRESULT GetApplicationMapping()
{
    HRESULT hr;
    CAutoCloseMetaHandle metaHandle;
    hr = OpenRootKey(&metaHandle);
    if (FAILED(hr))
    {
        DebugLogMsg(L"The key for getting the application mapping could not be opened.");
        return hr;
    }

    //
    // get default application mapping
    //
    METADATA_RECORD mdDef;
    AP<UCHAR>pEmptyAppMap = new UCHAR[2];
    LPWSTR pDefAppMap;
    AP<WCHAR> pBuf;

    mdDef.dwMDIdentifier = MD_SCRIPT_MAPS;
    mdDef.dwMDAttributes = METADATA_INHERIT;
    mdDef.dwMDUserType = IIS_MD_UT_FILE;
    mdDef.dwMDDataType = MULTISZ_METADATA;
    mdDef.dwMDDataTag = 0;
    mdDef.dwMDDataLen = sizeof(UCHAR) * 2;
    mdDef.pbMDData = (UCHAR *)pEmptyAppMap;

    DWORD dwSize = 0;
    hr = g_pIMSAdminBase->GetData(
                            metaHandle,
                            g_wcsFullPath,
                            &mdDef,
                            &dwSize
                            );
    if (dwSize)
    {
        pDefAppMap = new WCHAR[dwSize];
        pBuf = pDefAppMap;

        mdDef.dwMDDataLen = sizeof(WCHAR) * dwSize;
        mdDef.pbMDData = (UCHAR *)pDefAppMap;

        hr = g_pIMSAdminBase->GetData(
                                metaHandle,
                                g_wcsFullPath,
                                &mdDef,
                                &dwSize
                                );
    }

    if (FAILED(hr))
    {
        DebugLogMsg(L"The default application mapping for the IIS extension could not be obtained.");
        return hr;
    }
    DebugLogMsg(L"The default application mapping for the IIS extension was obtained.");

    g_dwAppMapSize = mdDef.dwMDDataLen;
    g_wcsAppMap = new UCHAR[g_dwAppMapSize + 2*sizeof(WCHAR)]; //leave space for two NULL chars
    memcpy(g_wcsAppMap.get(), mdDef.pbMDData, g_dwAppMapSize);
    //
    // Make sure the mapping ends with two NULLs so we don't GP when searching it
    //
    ZeroMemory(g_wcsAppMap.get() + g_dwAppMapSize, 2*sizeof(WCHAR));

    return hr;
}

//+--------------------------------------------------------------
//
// Function: AddMSMQToMapping
//
// Synopsis: Add MSMQ to application mapping
//
//+--------------------------------------------------------------

HRESULT AddMSMQToMapping ()
{
    HRESULT hr;
    CAutoCloseMetaHandle metaHandle;
    hr = OpenRootKey(&metaHandle);
    if (FAILED(hr))
    {
        DebugLogMsg(L"The key for adding the Message Queuing application mapping could not be opened.");
        return hr;
    }

    AP<WCHAR> pwszNewAppMap;
    unsigned int cchNewAppMap;
    AddStrToMultiSz(g_wcsMSMQAppMap, (WCHAR*)g_wcsAppMap.get(), &pwszNewAppMap, &cchNewAppMap);

    METADATA_RECORD MDRecord;
    MDRecord.dwMDIdentifier = MD_SCRIPT_MAPS;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_FILE ;
    MDRecord.dwMDDataType = MULTISZ_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = cchNewAppMap * sizeof(WCHAR);
    MDRecord.pbMDData = (UCHAR*)pwszNewAppMap.get();

    hr = g_pIMSAdminBase->SetData(metaHandle,
                                g_wcsFullPath,
                                &MDRecord);
    if(FAILED(hr))
    {
        DebugLogMsg(L"The application mapping for the IIS extension could not be set.");
        return hr;
    }
    DebugLogMsg(L"The application mapping for the IIS extension was set.");

    return hr;
}

//+--------------------------------------------------------------
//
// Function: SetApplicationProperties
//
// Synopsis: Set application properties
//
//+--------------------------------------------------------------
HRESULT SetApplicationProperties ()
{
    HRESULT hr;

    CAutoCloseMetaHandle metaHandle;
    hr = OpenRootKey(&metaHandle);
    if (FAILED(hr))
    {
        DebugLogMsg(L"The key for setting the application properties could not be opened.");
        return hr;
    }

    METADATA_RECORD MDRecord;
    //
    // friendly application name
    //
    WCHAR wcsAppName[MAX_PATH];
    wcscpy(wcsAppName, MSMQ_IISEXT_NAME);

    MDRecord.dwMDIdentifier = MD_APP_FRIENDLY_NAME;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_WAM;
    MDRecord.dwMDDataType = STRING_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = numeric_cast<DWORD> (sizeof(WCHAR) * (wcslen(wcsAppName) + 1));
    MDRecord.pbMDData = (UCHAR *)wcsAppName;

    hr = g_pIMSAdminBase->SetData(metaHandle,
                                g_wcsFullPath,
                                &MDRecord);
    if (FAILED(hr))
    {
        DebugLogMsg(L"SetData for MD_APP_FRIENDLY_NAME failed.");
        return hr;
    }
    DebugLogMsg(L"SetData for MD_APP_FRIENDLY_NAME succeeded.");

    //
    // isolated flag
    //

    DWORD dwValue = g_dwIsolatedFlag;
    MDRecord.dwMDIdentifier = MD_APP_ISOLATED;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_WAM;
    MDRecord.dwMDDataType = DWORD_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = sizeof(DWORD);
    MDRecord.pbMDData = (PBYTE)&dwValue;

    hr = g_pIMSAdminBase->SetData(metaHandle,
                                g_wcsFullPath,
                                &MDRecord);

    if (FAILED(hr))
    {
        DebugLogMsg(L"SetData for MD_APP_ISOLATED failed.");
        return hr;
    }

    DebugLogMsg(L"SetData for MD_APP_ISOLATED succeeded.");
    return hr;
}

//+--------------------------------------------------------------
//
// Function: SetExtensionProperties
//
// Synopsis: Set data for MSMQ IIS Extension
//
//+--------------------------------------------------------------

HRESULT SetExtensionProperties ()
{
    HRESULT hr;

    CAutoCloseMetaHandle metaHandle;
    hr = OpenRootKey(&metaHandle);
    if (FAILED(hr))
    {
        DebugLogMsg(L"The key for setting all the properties could not be opened.");
        return hr;
    }

    METADATA_RECORD MDRecord;

    //
    // set physical path
    //
    MDRecord.dwMDIdentifier = MD_VR_PATH;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_FILE;
    MDRecord.dwMDDataType = STRING_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = numeric_cast<DWORD> (sizeof(WCHAR) * (wcslen(g_szMsmqWebDir) +1));
    MDRecord.pbMDData = (UCHAR*)g_szMsmqWebDir;

    hr = g_pIMSAdminBase->SetData(metaHandle,
                                g_wcsFullPath,
                                &MDRecord);
    if (FAILED(hr))
    {
        DebugLogMsg(L"The physical path to the IIS extension could not be set.");
        return hr;
    }
    DebugLogMsg(L"The physical path to the IIS extension was set.");

    //
    // set access flag
    //
    DWORD dwValue = MD_ACCESS_SCRIPT | MD_ACCESS_EXECUTE;
    MDRecord.dwMDIdentifier = MD_ACCESS_PERM;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_FILE;
    MDRecord.dwMDDataType = DWORD_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = sizeof(DWORD);
    MDRecord.pbMDData = (PBYTE)&dwValue;

    hr = g_pIMSAdminBase->SetData(metaHandle,
                                g_wcsFullPath,
                                &MDRecord);

    if (FAILED(hr))
    {
        DebugLogMsg(L"The access flag for the IIS extension could not be set.");
        return hr;
    }
    DebugLogMsg(L"The access flag for the IIS extension was set.");

    //
    // set don't log flag
    //
    dwValue = TRUE;
    MDRecord.dwMDIdentifier = MD_DONT_LOG;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_FILE;
    MDRecord.dwMDDataType = DWORD_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = sizeof(DWORD);
    MDRecord.pbMDData = (PBYTE)&dwValue;

    hr = g_pIMSAdminBase->SetData(metaHandle,
                                g_wcsFullPath,
                                &MDRecord);

    if (FAILED(hr))
    {
        DebugLogMsg(L"The DontLog flag for the IIS extension could not be set.");
        return hr;
    }
    DebugLogMsg(L"The DontLog flag for the IIS extension was set.");

    return hr;
}

//+--------------------------------------------------------------
//
// Function: CleanupAll
//
// Synopsis: In case of failure cleanup everything: delete application
//              delete extension etc.
//
//+--------------------------------------------------------------
HRESULT
CleanupAll()
{
    //
    // unload application
    //
    WCHAR wszMsg[1000];
    UNREFERENCED_PARAMETER(wszMsg);

    HRESULT hr = UnloadApplication();
    if (FAILED(hr))
    {
        wsprintf(wszMsg, L"The application was not unloaded, hr %x", hr);
        DebugLogMsg(wszMsg);
    }

    hr = g_pIWamAdmin->AppDelete(g_wcsFullPath, TRUE);
    if (FAILED(hr))
    {
        wsprintf(wszMsg, L"AppDelete failed, hr %x", hr);
        DebugLogMsg(wszMsg);
    }

    CAutoCloseMetaHandle metaHandle;
    hr = g_pIMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                    PARENT_PATH,
                                    METADATA_PERMISSION_WRITE,
                                    5000,
                                    &metaHandle);

    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
        {
            //
            // extension does not exist
            //
            return S_OK;
        }

        wsprintf(wszMsg, L"OpenKey failed, hr %x", hr);
        DebugLogMsg(wszMsg);

        return hr;
    }

    //
    // delete key
    //
    hr = g_pIMSAdminBase->DeleteKey(
                            metaHandle,
                            MSMQ_IISEXT_NAME
                            );
    if (FAILED(hr))
    {
        wsprintf(wszMsg, L"DeleteKey failed, hr %x", hr);
        DebugLogMsg(wszMsg);

        return hr;
    }

    //
    // Commit the changes
    //
    hr = CommitChanges();
    if (FAILED(hr))
    {
        wsprintf(wszMsg, L"SaveData failed, hr %x", hr);
        DebugLogMsg(wszMsg);

        return hr;
    }

    DebugLogMsg(L"The IIS extension was deleted completely.");
    return S_OK;
}

//+--------------------------------------------------------------
//
// Function: CreateIISExtension
//
// Synopsis: Create MSMQ IIS Extension
//
//+--------------------------------------------------------------

BOOL
CreateIISExtension()
{
    HRESULT hr;

    //
    // start default web server if needed
    //
    hr = StartDefaultWebServer();
    if (FAILED(hr))
    {
        DebugLogMsg(L"The default Web server did not start.");
    }

    //
    // create web directory if needed.
    // Even if extension exists maybe directory was removed.
    // So it is the place to create it (bug 6014)...
    //
    if (!StpCreateWebDirectory(g_szMsmqWebDir))
    {
        DWORD gle = GetLastError();

        WCHAR szMsg[1000];
        wsprintf(szMsg, L"StpCreateWebDirectory(%s) failed", g_szMsmqWebDir);
        DebugLogMsg(szMsg);

        return gle;
    }
    DebugLogMsg(L"The Message Queuing Web directory was created.");

    //
    // check if iis extension with MSMQ name already exists
    //
    if (IsExtensionExist())
    {
        hr = CleanupAll();
        if (IsExtensionExist())
        {
            MqDisplayError(NULL, IDS_EXTEN_EXISTS_ERROR,
                           hr, MSMQ_IISEXT_NAME, g_wcsFullPath);
            return FALSE;
        }
    }


    //
    // create application
    //
    hr = CreateApplication();
    if (FAILED(hr))
    {
        return FALSE;
    }

    //
    // set extension properties
    //
    hr = SetExtensionProperties ();
    if (FAILED(hr))
    {
        MqDisplayError(NULL, IDS_CREATE_IISEXTEN_ERROR, hr, g_wcsFullPath);
        return FALSE;
    }

    hr = SetApplicationProperties();
    if (FAILED(hr))
    {
        MqDisplayError(NULL, IDS_CREATE_IISEXTEN_ERROR, hr, g_wcsFullPath);
        return FALSE;
    }

    //
    //set application mapping
    //
    hr = GetApplicationMapping();
    if (FAILED(hr))
    {
        MqDisplayError(NULL, IDS_CREATE_IISEXTEN_ERROR, hr, g_wcsFullPath);
        return FALSE;
    }

    hr = AddMSMQToMapping ();
    if (FAILED(hr))
    {
        MqDisplayError(NULL, IDS_CREATE_IISEXTEN_ERROR, hr, g_wcsFullPath);
        return FALSE;
    }

    //
    // commit changes
    //
    hr = CommitChanges();
    if (FAILED(hr))
    {
        MqDisplayError(NULL, IDS_CREATE_IISEXTEN_ERROR, hr, g_wcsFullPath);
        return FALSE;
    }


    return TRUE;
}

//+--------------------------------------------------------------
//
// Function: UnInstallIISExtension
//
// Synopsis: Remove MSMQ IIS Extension
//
//+--------------------------------------------------------------
BOOL
UnInstallIISExtension()
{
    HRESULT hr;

    TickProgressBar(IDS_PROGRESS_REMOVE_HTTP);	
    //
    // Init COM and pointers
    //
    CIISPtr IISPtr;
    hr = Init ();
    if (FAILED(hr))
    {
        //
        // I don't think we need popup here: maybe Init failed
        // since IIS was removed too. Just return FALSE.
        //MqDisplayError(NULL, IDS_INIT_FOREXTEN_ERROR, hr);
        return FALSE;
    }

    //
    // remove application and extention compltely
    //
    hr = CleanupAll();
    if (FAILED(hr))
    {
        MqDisplayError(NULL, IDS_DELETE_EXT_ERROR, hr, MSMQ_IISEXT_NAME, g_wcsFullPath);
        return FALSE;
    }

    return TRUE;
}

//+--------------------------------------------------------------
//
// Function: InstallIISExtension
//
// Synopsis: Main loop to create IIS Extension
//
//+--------------------------------------------------------------
BOOL
InstallIISExtension()
{
    //
    // verify if IIS service is running. If not, do not try to install
    // MSMQ IIS extension
    //
    // BUGBUG: on Personal IIS installation will be impossible.
    // When this restriction will be added, we need to verify that we are
    // on Personal and do not show popup, event is enough.
    //
    DWORD dwServiceState;
    CResString strWWWServiceLabel(IDS_WWW_SERVICE_LABEL);

    if (!GetServiceState(
                IISADMIN_SERVICE_NAME,
                &dwServiceState
                )
       )
    {
        MqDisplayError(
                NULL,
                IDS_WWW_SERVICE_ERROR,
                GetLastError(),
                MSMQ_IISEXT_NAME,
                strWWWServiceLabel.Get()
                );

        DebugLogMsg(L"Message Queuing will not be able to receive HTTP messages.");
        return FALSE;
    }

    if (dwServiceState == SERVICE_STOPPED)
    {
        MqDisplayError(
                NULL,
                IDS_WWW_SERVICE_ERROR,
                GetLastError(),
                MSMQ_IISEXT_NAME,
                strWWWServiceLabel.Get()
                );

        DebugLogMsg(L"Message Queuing will not be able to receive HTTP messages.");
        return FALSE;
    }

    //
    // Init COM and pointers
    //
    CIISPtr IISPtr;
    HRESULT hr = Init ();
    if (FAILED(hr))
    {
        MqDisplayError(NULL, IDS_INIT_FOREXTEN_ERROR, hr);

        DebugLogMsg(L"Message Queuing will not be able to receive HTTP messages.");
        return FALSE;
    }

    if (!CreateIISExtension())
    {
        CleanupAll();
        DebugLogMsg(L"Message Queuing will not be able to receive HTTP messages.");
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\list_mac.h ===
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\inifile.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    inifile.cpp

Abstract:

     Handles INI files manipulations.

Author:


Revision History:

    Shai Kariv    (ShaiK)   22-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "inifile.tmh"
#include <mqexception.h>

//+--------------------------------------------------------------
//
// Function: ReadINIKey
//
// Synopsis: Reads key in INI file
//
//+--------------------------------------------------------------
VOID 
ReadINIKey(
    LPCWSTR szKey, 
    DWORD  dwNumChars, 
    LPWSTR szKeyValue
    )
{
    //
    // Try obtaining the key value from the machine-specific section
    //
    if (GetPrivateProfileString(
            g_wcsMachineName, 
            szKey, 
            TEXT(""),
            szKeyValue, 
            dwNumChars, 
            g_ComponentMsmq.szUnattendFile
            ) != 0)
    {
        return;
    }
    //
    // Otherwise, obtain the key value from the MSMQ component section
    //
    if (GetPrivateProfileString(
        g_ComponentMsmq.ComponentId,
        szKey, 
        TEXT(""),
        szKeyValue, 
        dwNumChars, 
        g_ComponentMsmq.szUnattendFile) != 0)
    {
        return;
    }
    
    MqDisplayError(
        NULL,
        IDS_INIKEYNOTFOUND,
        0,
        szKey,
        g_ComponentMsmq.szUnattendFile
        );

    throw exception();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\machine.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    machine.cpp

Abstract:

    Handles machine based operations.

Author:


Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include "privque.h"
#include "mqexception.h"
#include "autoreln.h"
#include <lm.h>
#include <lmapibuf.h>
#include "Dsgetdc.h"

#include "machine.tmh"

class CSiteEntry {
public:
    GUID  m_guid;
    TCHAR m_szName[MAX_PATH];
    LIST_ENTRY m_link;
};

static List<CSiteEntry> s_listSites;
static GUID  s_guidUserSite = GUID_NULL;
static TCHAR s_szUserSite[MAX_PATH];

BOOL  PrepareRegistryForClient() ;

//+--------------------------------------------------------------
//
// Function: GetMsmq1ServerSiteGuid
//
// Synopsis: Queries MSMQ1 DS Server for its Site GUID
//
//+--------------------------------------------------------------
static
BOOL
GetMsmq1ServerSiteGuid(
    OUT GUID *pguidMsmq1ServerSite
    )
{
    //
    // We must have g_wcsServerName filled by the user
    //
    ASSERT(g_wcsServerName[0] != '\0');
    //
    // Prepare the Site ID property
    //
    PROPID propID = PROPID_QM_SITE_ID;
    PROPVARIANT propVariant;
    propVariant.vt = VT_NULL;

    //
    // Issue the query
    //
    TickProgressBar();

    HRESULT hResult;
    do
    {
        hResult = ADGetObjectProperties(
                    eMACHINE,
                    NULL,	// pwcsDomainController
					false,	// fServerName
                    g_wcsServerName,
                    1,
                    &propID,
                    &propVariant
                    );
        if(SUCCEEDED(hResult))
            break;

    }while( MqDisplayErrorWithRetry(
                        IDS_MSMQ1SERVER_SITE_GUID_ERROR,
                        hResult
                        ) == IDRETRY);






    if (FAILED(hResult))
    {
        return FALSE;
    }

    //
    // Store the results
    //
    ASSERT(pguidMsmq1ServerSite);
    *pguidMsmq1ServerSite = *propVariant.puuid;

    return(TRUE);

} // GetMsmq1ServerSiteGuid


//+--------------------------------------------------------------
//
// Function: GetGuidCn
//
// Synopsis: Queries MSMQ1 DS Server for its IPCN Guid
//
//+--------------------------------------------------------------
static
BOOL
GetGuidCn(
    OUT GUID* pGuidCn
    )
{
    ASSERT(pGuidCn != NULL);

    //
    // We must have g_wcsServerName filled by the user
    //
    ASSERT(g_wcsServerName[0] != '\0');

    //
    // Prepare properties for query
    //
    PROPID aProp[] = {PROPID_QM_ADDRESS, PROPID_QM_CNS};

    MQPROPVARIANT aVar[TABLE_SIZE(aProp)];

	for(DWORD i = 0; i < TABLE_SIZE(aProp); ++i)
	{
		aVar[i].vt = VT_NULL;
	}

	//
    // Issue the query
    //
    TickProgressBar();
    HRESULT hResult;
    do
    {
        hResult = ADGetObjectProperties(
                    eMACHINE,
                    NULL,	// pwcsDomainController
					false,	// fServerName
                    g_wcsServerName,
		            TABLE_SIZE(aProp),
                    aProp,
                    aVar
                    );
        if(SUCCEEDED(hResult))
            break;

    }while (MqDisplayErrorWithRetry(
                        IDS_MSMQ1SERVER_CN_GUID_ERROR,
                        hResult
                        ) == IDRETRY);

    if (FAILED(hResult))
    {
        return FALSE;
    }

	AP<BYTE> pCleanBlob = aVar[0].blob.pBlobData;
	AP<GUID> pCleanCNS = aVar[1].cauuid.pElems;

	//
	// PROPID_QM_ADDRESS
	//
    ASSERT((aVar[0].vt == VT_BLOB) &&
	       (aVar[0].blob.cbSize > 0) &&
		   (aVar[0].blob.pBlobData != NULL));

	//
	// PROPID_QM_CNS
	//
	ASSERT((aVar[1].vt == (VT_CLSID|VT_VECTOR)) &&
	       (aVar[1].cauuid.cElems > 0) &&
		   (aVar[1].cauuid.pElems != NULL));

	//
	// Process the results - look for ip cns
	//
	BYTE* pAddress = aVar[0].blob.pBlobData;
	BOOL fFoundIPCn = FALSE;
	for(DWORD i = 0; i < aVar[1].cauuid.cElems; ++i)
	{
        TA_ADDRESS* pBuffer = reinterpret_cast<TA_ADDRESS *>(pAddress);

		ASSERT((pAddress + TA_ADDRESS_SIZE + pBuffer->AddressLength) <= 
			   (aVar[0].blob.pBlobData + aVar[0].blob.cbSize)); 

        if(pBuffer->AddressType == IP_ADDRESS_TYPE)
		{
			//
			// Found IP_ADDRESS_TYPE cn
			//
			*pGuidCn = aVar[1].cauuid.pElems[i];
			fFoundIPCn = TRUE;
			break;
		}

		//
		// Advance pointer to the next address
		//
		pAddress += TA_ADDRESS_SIZE + pBuffer->AddressLength;

	}

    return(fFoundIPCn);

} // GetGuidCn


//+--------------------------------------------------------------
//
// Function: NoServerAuthentication
//
// Synopsis: This callback function is called from the DS DLL
//           when there's no secured communication with server.
//
//+--------------------------------------------------------------

BOOL
NoServerAuthentication()
{
    if (g_fAlreadyAnsweredToServerAuthentication)
    {
        return !g_fUseServerAuthen ;
    }

    g_fAlreadyAnsweredToServerAuthentication = TRUE;

    if (g_fUseServerAuthen)
    {
        if (g_hPropSheet)
        {
            //
            // Disable master OCM window.
            //
            ::EnableWindow(g_hPropSheet, FALSE) ;
        }

        g_fUseServerAuthen = !MqAskContinue(
                             IDS_NO_SERVER_AUTHN_OCM,
                             IDS_NO_SERVER_AUTH_TITLE,
                             /* bDefaultContinue = */FALSE
                             );

        MqWriteRegistryValue( MSMQ_SECURE_DS_COMMUNICATION_REGNAME,
                              sizeof(DWORD),
                              REG_DWORD,
                             &g_fUseServerAuthen ) ;

        if (g_hPropSheet)
        {
            ::EnableWindow(g_hPropSheet, TRUE) ;
        }
    }

    //
    // Note: returning FALSE will cause Setup to fail later on when trying
    // to get properties of the server,
    //
    return !g_fUseServerAuthen ;

} //NoServerAuthentication


static
bool
QueryMsmqServerVersion(
    BOOL * pfMsmq1Server
    )
{
    *pfMsmq1Server = FALSE;

    if (g_dwMachineTypeDs)
    {
        return true;
    }

    //
    // We must have g_wcsServerName filled by the user
    //
    ASSERT(g_wcsServerName[0] != '\0');
    //
    // Try to access the MSMQ server / Active Directory.
    //

    PROPID propId = PROPID_QM_MACHINE_TYPE;
    PROPVARIANT propVar;
    propVar.vt = VT_NULL;

    HRESULT hr = ADGetObjectProperties(
						eMACHINE,
						NULL,	// pwcsDomainController
						false,	// fServerName
						g_wcsServerName,
						1,
						&propId,
						&propVar
						);

    if (FAILED(hr))
    {
        MqDisplayError(NULL, IDS_ACCESS_MSMQ_SERVER_ERR, hr, g_wcsServerName);
        return false;
    }


    //
    // Succeeded in accessing MSMQ server / Active Directory.
    // Now try using an MSMQ 2.0 RPC interface to server.
    //

    propId = PROPID_QM_SIGN_PKS;
    propVar.vt = VT_NULL;

    hr = ADGetObjectProperties(
				eMACHINE,
				NULL,	// pwcsDomainController
				false,	// fServerName
				g_wcsServerName,
				1,
				&propId,
				&propVar
				);

    if (MQ_ERROR_NO_DS == hr)
    {
        //
        // MSMQ 1.0 server does not recognize MSMQ 2.0 RPC interface
        //
        *pfMsmq1Server = TRUE;
        return true;
    }

    if (FAILED(hr))
    {
        MqDisplayError(NULL, IDS_ACCESS_MSMQ_SERVER_ERR, hr, g_wcsServerName);
        return false;
    }

    return true;

} //QueryMsmqServerVersion

static LPWSTR FindDCofComputerDomain(LPCWSTR pwcsComputerName)
/*++
Routine Description:
	Find computer domain

Arguments:
	pwcsComputerName - computer name

Returned Value:
	DC of computer domain, NULL if not found

    NOTE - we are not using the domain name of the computer,
           because binding to it failed

--*/
{

	//
	// Get AD server
	//
	PNETBUF<DOMAIN_CONTROLLER_INFO> pDcInfo;
	DWORD dw = DsGetDcName(
					pwcsComputerName, 
					NULL, 
					NULL, 
					NULL, 
					DS_DIRECTORY_SERVICE_REQUIRED, 
					&pDcInfo
					);

	if(dw != NO_ERROR) 
	{
		return NULL;
	}

	ASSERT(pDcInfo->DomainName != NULL);
	AP<WCHAR> pDCofComputerDomain = new WCHAR[wcslen(pDcInfo->DomainControllerName) + 1];
    wcscpy(pDCofComputerDomain, pDcInfo->DomainControllerName+2);
	return pDCofComputerDomain.detach();
}



//+--------------------------------------------------------------
//
// Function: LookupMSMQConfigurationsObject
//
// Synopsis: Tries to find MSMQ Configurations object in the DS
//
//+--------------------------------------------------------------
BOOL
LookupMSMQConfigurationsObject(
    IN OUT BOOL *pbFound,
       OUT GUID *pguidMachine,
       OUT GUID *pguidSite,
       OUT BOOL *pfMsmq1Server,
       OUT LPWSTR * ppMachineName
       )
{  
    if (g_wcsServerName[0] != '\0')
    {
        //
        // user specified a server, check if it is an MSMQ1 server
        //
        if (!QueryMsmqServerVersion(pfMsmq1Server))
        {
            return FALSE;
        }
    }
    else
    {
        //
        // user didn't specify a server name so we have no specific server
        //
        *pfMsmq1Server = FALSE;
    }

    if (g_dwMachineTypeFrs && *pfMsmq1Server)
    {
        //
        // Installing FRS vs MSMQ 1.0 server is not supported
        //
        MqDisplayError(NULL, IDS_FRS_IN_MSMQ1_ENTERPRISE_ERROR, 0);
        return FALSE;
    }

    //
    // Prepare properties for query
    //
    const x_nMaxProps = 10;
    PROPID propIDs[x_nMaxProps];
    PROPVARIANT propVariants[x_nMaxProps];
    DWORD ix =0;
    DWORD ixService = 0,
          ixMachine = 0,
          ixSite = 0;
    DWORD ixDs = 0,
          ixFrs = 0,
          ixDepSrv = 0;

    propIDs[ix] = PROPID_QM_MACHINE_ID;
    propVariants[ix].vt = VT_NULL;
    ixMachine = ix;
    ++ix;

    propIDs[ix] = PROPID_QM_SITE_ID;
    propVariants[ix].vt = VT_NULL;
    ixSite = ix;
    ++ix;

    if (g_dwMachineTypeDs)
    {
        propIDs[ix] = PROPID_QM_SERVICE_DSSERVER;
        propVariants[ix].vt = VT_NULL;
        ixDs = ix;
        ++ix;

        propIDs[ix] = PROPID_QM_SERVICE_ROUTING;
        propVariants[ix].vt = VT_NULL;
        ixFrs = ix;
        ++ix;

        propIDs[ix] = PROPID_QM_SERVICE_DEPCLIENTS;
        propVariants[ix].vt = VT_NULL;
        ixDepSrv = ix;
        ++ix;
    }
    else
    {
        propIDs[ix] = PROPID_QM_SERVICE;
        propVariants[ix].vt = VT_NULL;
        ixService = ix;
        ++ix;
    }

    AP<WCHAR> pwcsDcOfComputerDomainName;
    //
    //  Find out the computer domain and use it as parameter when quering AD.
    //  This will guarnety the AD will not access GC and will look for the
    //  object only in the computer domain
    //
    if ((!*pfMsmq1Server) &&
        (lstrlenW(g_wcsMachineNameDns) > 1))
    {
        pwcsDcOfComputerDomainName = FindDCofComputerDomain(g_wcsMachineNameDns);
    }

    for (;;)
    {
        LPWSTR pwzMachineName = g_wcsMachineNameDns;
        if (*pfMsmq1Server || lstrlenW(g_wcsMachineNameDns) < 1)
        {
            pwzMachineName = g_wcsMachineName;
        }

        HRESULT hResult = ADGetObjectProperties(
								eMACHINE,
								pwcsDcOfComputerDomainName, 
								true,	// fServerName
								pwzMachineName, // DNS name (if server is MSMQ 2.0)
								ix,
								propIDs,
								propVariants
								);
        if (FAILED(hResult) && pwzMachineName != g_wcsMachineName)
        {
            //
            // Try NETBIOS
            //
            pwzMachineName = g_wcsMachineName;

            hResult = ADGetObjectProperties(
							eMACHINE,
							pwcsDcOfComputerDomainName, 
							true,	// fServerName
							pwzMachineName,
							ix,
							propIDs,
							propVariants
							);
        }

        //
        // Assume the object is not found
        //
        *pbFound = FALSE;

        if (FAILED(hResult))
        {
            if (MQDS_OBJECT_NOT_FOUND == hResult)
                return TRUE;   // *pbFound == FALSE here

            if (MQ_ERROR_NO_DS == hResult)
            {                
                //                
                // Maybe it is possible to continue with ds-less mode
                //
                if (g_dwMachineTypeFrs == 0 && // it is ind. client
                    !g_dwMachineTypeDs      && // it is not DC
                    !*pfMsmq1Server)           // not MSMQ1 (NT4) server
                {
                    //
                    // ask Retry Ignore Abort
                    // if retry - continue to try to access AD
                    // if Ignore - return TRUE and continue in ds-less mode
                    // if Abort - return FALSE and cancel the setup
                    //
                    int iButton = MqDisplayErrorWithRetryIgnore(
                                        IDS_ACCESS_AD_ERROR,
                                        hResult
                                        );

                    if (iButton == IDRETRY)
                    {
                        //
                        // try again
                        //
                        continue;
                    } 
                    else if (iButton == IDIGNORE)
                    {
                        //
                        // continue in ds-less mode
                        //
                        g_fContinueWithDsLess = TRUE;
                        return TRUE;
                    }
                    else
                    {
                        return FALSE;
                    }
                }
            }

            if (IDRETRY != MqDisplayErrorWithRetry(
                               g_dwMachineTypeDs ? IDS_MACHINEGETPROPS_ERROR : IDS_MACHINEGETPROPS_MSMQ1_ERROR,
                               hResult
                               ))
            {
                return FALSE;
            }
            //
            // On next try we don't specify the DC name ( it may be old
            // information). To reduce risk we don't try at this point to
            // find another DC name
            //
            pwcsDcOfComputerDomainName.free();
            continue;  // Error accured, retry
        }

        if (//
            // When DS server is local, compare the 3 "new" bits
            //
            (g_dwMachineTypeDs &&
                (g_dwMachineTypeDs == propVariants[ixDs].bVal &&
                 g_dwMachineTypeFrs == propVariants[ixFrs].bVal &&
                 g_dwMachineTypeDepSrv == propVariants[ixDepSrv].bVal))    ||

            //
            // When DS server is remote, compare the "old" propid
            //
            (!g_dwMachineTypeDs &&
                g_dwMachineType == propVariants[ixService].ulVal)
           )
        {
            *pbFound = TRUE;
            *pguidMachine = *propVariants[ixMachine].puuid;
            *pguidSite    = *propVariants[ixSite].puuid;
            *ppMachineName = pwzMachineName;
            return TRUE;
        }

        //
        // MSMQ type mismatch (between what user selected and what's in the DS).
        // Delete the object. It will be re-created by the caller
        //
        for (;;)
        {
            hResult = ADDeleteObjectGuid(
							eMACHINE,
							NULL,       // pwcsDomainController
							false,	    // fServerName
							propVariants[ixMachine].puuid
							);
            if (SUCCEEDED(hResult))
                return TRUE;  // *pbFound == FALSE here

            UINT uErrorId = IDS_TYPE_MISMATCH_MACHINE_DELETE_ERROR;
            if (MQDS_E_MSMQ_CONTAINER_NOT_EMPTY == hResult)
            {
                //
                // The MSMQ Configuration object container is not empty.
                //
                uErrorId = IDS_TYPE_MISMATCH_MACHINE_DELETE_NOTEMPTY_ERROR;
            }
            if (IDRETRY == MqDisplayErrorWithRetry(uErrorId, hResult))
                continue;

            return FALSE; // Fail to delete
        }
    }

    // this line is never reached

} //LookupMSMQConfigurationsObject


//+--------------------------------------------------------------
//
// Function: FormInstallType
//
// Synopsis: Generates installation type information
//
//+--------------------------------------------------------------
static
LPWSTR
FormInstallType()
{
    //
    // Form the version string (from mqutil.dll)
    //

    typedef LPWSTR (*MSMQGetQMTypeString_ROUTINE) ();

    ASSERT(("invalid handle to mqutil.dll", g_hMqutil != NULL));

    MSMQGetQMTypeString_ROUTINE pfnGetVersion =
        (MSMQGetQMTypeString_ROUTINE)GetProcAddress
            (g_hMqutil, "MSMQGetQMTypeString");
    if (pfnGetVersion == NULL)
    {
        MqDisplayError(
            NULL,
            IDS_DLLGETADDRESS_ERROR,
            0,
            TEXT("MSMQGetQMTypeString"),
            MQUTIL_DLL
            );
    }

    LPWSTR pwcsVersion = pfnGetVersion();
    return pwcsVersion;

} //FormInstallType


//+--------------------------------------------------------------
//
// Function: GetMSMQServiceGUID
//
// Synopsis: Reads GUID of MSMQ Service object from the DS
//
//+--------------------------------------------------------------
BOOL
GetMSMQServiceGUID(
    OUT GUID *pguidMSMQService
    )
{
    //
    // Lookup the GUID of the object
    //
    TickProgressBar();
    PROPVARIANT propVariant;
    propVariant.vt = VT_NULL;
    PROPID columnsetPropertyIDs[] = {PROPID_E_ID};
    HRESULT hResult;
    do
    {
        hResult = ADGetObjectProperties(
                    eENTERPRISE,
                    NULL,	// pwcsDomainController
					false,	// fServerName
                    L"msmq",
                    1,
                    columnsetPropertyIDs,
                    &propVariant
                    );
        if(SUCCEEDED(hResult))
            break;

    }while( MqDisplayErrorWithRetry(
                        IDS_MSMQSERVICEGETID_ERROR,
                        hResult
                        ) == IDRETRY);
    
    //
    // Check if there was an error
    //
    if (FAILED(hResult))
    {
        MqDisplayError(NULL, IDS_MSMQSERVICEGETID_ERROR, hResult);
        return FALSE;
    }

    //
    // Store the GUID (if results were found)
    //
    if (propVariant.vt == VT_CLSID) 
    {
        *pguidMSMQService = *(propVariant.puuid);
        delete propVariant.puuid;
    }
    else
    {
        ASSERT(0);
        *pguidMSMQService = GUID_NULL;
    }

    return TRUE;

} //GetMSMQServiceGUID


//+-------------------------------------------------------------------------
//
//  Function:   SitesDlgProc
//
//  Synopsis:   Dialog procedure for selection of MSMQ site
//
//  Returns:    int depending on msg
//
//+-------------------------------------------------------------------------
INT_PTR
CALLBACK
SitesDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam )
{
    int iSuccess = 0;
    TCHAR szSite[MAX_PATH];

    switch( msg )
    {
        case WM_INITDIALOG:
        {
            g_hPropSheet = GetParent(hdlg);

            //
            // Insert the server site to the list box
            //
            SendDlgItemMessage(hdlg, IDC_List, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)s_szUserSite);

            //
            // Insert all the rest of the sites to the list box
            //
            for (List<CSiteEntry>::Iterator p = s_listSites.begin(); p != s_listSites.end(); ++p)
            {
                if (p->m_guid == s_guidUserSite)
                {
                    //
                    // This is the server site, it's already in the list box
                    //
                    continue;
                }

                SendDlgItemMessage(hdlg, IDC_List, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)p->m_szName);
            }

            //
            // Set the first one to be selected
            //
            SendDlgItemMessage(hdlg, IDC_List, LB_SETCURSEL, 0, 0);

            iSuccess = 1;
            break;
        }

        case WM_COMMAND:
        {
            if ( BN_CLICKED == HIWORD(wParam) )
            {
                //
                // Get the selected string from list box
                //
                UINT_PTR ix = SendDlgItemMessage(hdlg, IDC_List, LB_GETCURSEL, 0, 0);
                SendDlgItemMessage(hdlg, IDC_List, LB_GETTEXT, ix, (LPARAM)(LPCTSTR)szSite);

                //
                // Iterate the list to find the selected site's guid
                //
                CSiteEntry *pSiteEntry;
                while((pSiteEntry = s_listSites.gethead()) != 0)
                {
                    if (_tcscmp(pSiteEntry->m_szName, szSite) == 0)
                    {
                        //
                        // This is the selected site. Store its guid.
                        //
                        s_guidUserSite = pSiteEntry->m_guid;
                    }

                    delete pSiteEntry;
                }

                //
                // Kill the dialog page
                //
                EndDialog(hdlg, 0);
            }
            break;
        }

        case WM_NOTIFY:
        {
            switch(((NMHDR *)lParam)->code)
            {
              case PSN_SETACTIVE:
              {
              }

              //
              // fall through
              //
              case PSN_KILLACTIVE:
              case PSN_QUERYCANCEL:

                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    iSuccess = 1;
                    break;

            }
            break;
        }
    }

    return iSuccess;

} // SitesDlgProc


//+--------------------------------------------------------------
//
// Function: CleanList
//
// Synopsis:
//
//+--------------------------------------------------------------
static
void
CleanList()
{
    CSiteEntry *pSiteEntry;
    while((pSiteEntry = s_listSites.gethead()) != 0)
    {
        delete pSiteEntry;
    }
} // CleanList


//+--------------------------------------------------------------
//
// Function: AskUserForSites
//
// Synopsis:
//
//+--------------------------------------------------------------
BOOL
AskUserForSites()
{
    WCHAR szUnattenSite[MAX_STRING_CHARS] = {0};
    if (g_fBatchInstall)
    {
        //
        // Unattended. Read site name from INI file.
        //
        try
        {
            ReadINIKey(
                L"Site",
                sizeof(szUnattenSite)/sizeof(szUnattenSite[0]),
                szUnattenSite
                );
        }
        catch(exception)
        {
            return FALSE;
        }
    }

    PROPID columnsetPropertyIDs[] = {PROPID_S_SITEID, PROPID_S_PATHNAME/*, PROPID_S_FOREIGN*/};
    UINT nCol = sizeof(columnsetPropertyIDs)/sizeof(columnsetPropertyIDs[0]);
    MQCOLUMNSET columnsetSite;
    columnsetSite.cCol = sizeof(columnsetPropertyIDs)/sizeof(columnsetPropertyIDs[0]);
    columnsetSite.aCol = columnsetPropertyIDs;

    //
    // Begin the query
    //
    CADQueryHandle hQuery;
    HRESULT hResult;
    do
    {
        hResult = ADQueryAllSites(
                        NULL,       // pwcsDomainController
						false,	    // fServerName
                        &columnsetSite,
                        &hQuery
                        );
        if(SUCCEEDED(hResult))
            break;

    }while( MqDisplayErrorWithRetry(
                        IDS_SITESLOOKUP_ERROR,
                        hResult
                        ) == IDRETRY);

    if (FAILED(hResult))
        return FALSE;
    //
    // Get all sites
    //
    UINT nSites = 0;
    PROPVARIANT propVars[50];
    DWORD dwProps = sizeof(propVars)/sizeof(propVars[0]);
    for (;;)
    {
        do
        {
            hResult = ADQueryResults(
                        hQuery,
                        &dwProps,
                        propVars
                        );
            if(SUCCEEDED(hResult))
                break;

            }while( MqDisplayErrorWithRetry(
                                IDS_SITESLOOKUP_ERROR,
                                hResult
                                ) == IDRETRY);

       if (FAILED(hResult))
            break;

        if (0 == dwProps)
            break;

        PROPVARIANT *pvar = propVars;
        for ( int i = (dwProps / nCol) ; i > 0 ; i--, pvar+=nCol )
        {
            /*if ((pvar+2)->bVal)
            {
                //
                // Don't count foreign sites
                //
                continue;
            } */

            LPTSTR pszCurrentSite = (pvar+1)->pwszVal;

            if (g_fBatchInstall)
            {
                if (OcmStringsEqual(szUnattenSite, pszCurrentSite))
                {
                    s_guidUserSite = *(pvar->puuid);
                    return TRUE;
                }
            }
            else
            {
                //
                // Push site guid and name to list
                //
                CSiteEntry *pentrySite = new CSiteEntry;
                ASSERT(pentrySite);
                pentrySite->m_guid = *(pvar->puuid);
                lstrcpy(pentrySite->m_szName, pszCurrentSite);
                s_listSites.insert(pentrySite);

                //
                // Store the server site name
                //
                if (pentrySite->m_guid == s_guidUserSite)
                    _tcscpy(s_szUserSite, pentrySite->m_szName);

                nSites++;
            }
        }
    }

    if (FAILED(hResult))
    {
        CleanList();
        return FALSE;
    }

    hResult = ADEndQuery(hQuery.detach());
    ASSERT(0 == hResult);

    //
    // No point showing the page if less than 2 sites found
    //
    if (2 > nSites)
    {
        CleanList();
        return TRUE;
    }

    if (g_fBatchInstall)
    {
        MqDisplayError(NULL, IDS_UNATTEND_SITE_NOT_FOUND_ERROR, 0, szUnattenSite);
        return FALSE;
    }

    //
    // Show the page, wait until user selects a site
    //
    DialogBox(
        g_hResourceMod ,
        MAKEINTRESOURCE(IDD_Sites),
        g_hPropSheet,
        SitesDlgProc
        );

    CleanList();
    return TRUE;

} // AskUserForSites


//+--------------------------------------------------------------
//
// Function: GetSites
//
// Synopsis: Reads GUIDs of Site objects from the DS
//
//+--------------------------------------------------------------
BOOL
GetSites(
    OUT CACLSID *pcauuid)
{
    HRESULT hResult;
    DWORD dwNumSites = 0;
    GUID *pguidSites;

    TickProgressBar();
    for (;;)
    {
        hResult = ADGetComputerSites(
            g_wcsMachineNameDns,  // DNS name
            &dwNumSites,
            &pguidSites
            );
        if (FAILED(hResult))
        {
            //
            // Try NETBIOS name
            //
            hResult = ADGetComputerSites(
                               g_wcsMachineName,  // NETBIOS name
                               &dwNumSites,
                               &pguidSites
                               );
        }

        if (MQDS_INFORMATION_SITE_NOT_RESOLVED == hResult && g_dwMachineTypeFrs && !g_dwMachineTypeDs)
        {
            //
            // Failed to resolve site on FRS. Let user select a site.
            //
            ASSERT(dwNumSites); // must be at least 1
            ASSERT(pguidSites); // must point to a valid site guid
            s_guidUserSite = *pguidSites;

            if (!AskUserForSites())
            {
                return FALSE;
            }

            pcauuid->cElems = 1;
            pcauuid->pElems = &s_guidUserSite;
            return TRUE;
        }

        if FAILED(hResult)
        {
            if (IDRETRY == MqDisplayErrorWithRetry(IDS_SITEGETID_ERROR, hResult))
            {
                continue;
            }
        }
        break;
    }

    if (FAILED(hResult))
    {
        return FALSE;
    }

    ASSERT(dwNumSites); // Must be > 0
    pcauuid->cElems = dwNumSites;
    pcauuid->pElems = pguidSites;

    return TRUE;

} //GetSites


//+--------------------------------------------------------------
//
// Function: RegisterMachine
//
// Synopsis: Writes machine info to registry
//
//+--------------------------------------------------------------
static
BOOL
RegisterMachine(
    IN const BOOL    fIsEnterpriseMsmq1,
    IN const GUID    &guidMachine,
    IN const GUID    &guidSite
    )
{
    //
    // Get the MSMQ Service GUID from the DS
    //
    GUID    guidMSMQService;
    if (!GetMSMQServiceGUID(&guidMSMQService))
    {
        //
        // Failed to read from the DS
        //
        return FALSE;
    }

    if (GUID_NULL == guidMSMQService)
    {
        //
        // Guid of MSMQ Service not found by the DS query
        //
        MqDisplayError( NULL, IDS_MSMQSERVICEGETID_ERROR, 0);
        return FALSE;
    }

    //
    // Write the stuff in the registry
    //
    TickProgressBar();
    if (!MqWriteRegistryValue( MSMQ_ENTERPRISEID_REGNAME, sizeof(GUID),
                               REG_BINARY, &guidMSMQService)                  ||

        !MqWriteRegistryValue( MSMQ_SITEID_REGNAME, sizeof(GUID),
                               REG_BINARY, (PVOID)&guidSite)                  ||

        !MqWriteRegistryValue( MSMQ_MQS_REGNAME, sizeof(DWORD),
                               REG_DWORD, &g_dwMachineType)                   ||

        !MqWriteRegistryValue( MSMQ_MQS_DSSERVER_REGNAME, sizeof(DWORD),
                               REG_DWORD, &g_dwMachineTypeDs)                 ||

        !MqWriteRegistryValue( MSMQ_MQS_ROUTING_REGNAME, sizeof(DWORD),
                               REG_DWORD, &g_dwMachineTypeFrs)                ||

        !MqWriteRegistryValue( MSMQ_MQS_DEPCLINTS_REGNAME, sizeof(DWORD),
                               REG_DWORD, &g_dwMachineTypeDepSrv)             ||

        !MqWriteRegistryValue( MSMQ_QMID_REGNAME, sizeof(GUID),
                               REG_BINARY, (PVOID)&guidMachine))
    {
        return FALSE;
    }

    return TRUE;

} //RegisterMachine


//+--------------------------------------------------------------
//
// Function: StoreMachinePublicKeys
//
// Synopsis:
//
//  The fFreshSetup parameter is passed as fRegenerate parameter to
//  MQsec_StorePubKeysInDS. On fresh setup, we want to regenerate the
//  crytpo keys and not using any leftovers from previous installations
//  of msmq on this machine.
//
//+--------------------------------------------------------------

static
HRESULT
StoreMachinePublicKeys( IN const BOOL fFreshSetup )
{
    if (IsWorkgroup())
        return ERROR_SUCCESS;

    TickProgressBar();

    //
    // Store the public keys of the machine in the directory server
    //	
    DebugLogMsg(L"Calling MQsec_StorePubKeysInDS...");
    HRESULT hResult;

    do{
        hResult = MQSec_StorePubKeysInDS(
                    fFreshSetup,  
                    NULL,
                    MQDS_MACHINE
                    );
        if (hResult != MQ_ERROR_DS_ERROR)
            break;
        }
    while (MqDisplayErrorWithRetry(
                IDS_POSSIBLECOMPROMISE_ERROR,
                hResult
                ) == IDRETRY);

         
	DebugLogMsg(L"return from MQsec_StorePubKeysInDS");
    DebugLogMsg(L"Returning from MQsec_StorePubKeysInDS...");

    if (FAILED(hResult) && (hResult != MQ_ERROR_DS_ERROR))
    {
        MqDisplayError(NULL, IDS_PUBLICKEYSSTORE_WARNING, hResult);
    }
	
    DebugLogMsg(L"Leaving StoreMachinePublicKeys...");
    return hResult;

} //StoreMachinePublicKeys


//+--------------------------------------------------------------
//
// Function: StoreQueueManagerInfo
//
// Synopsis: Writes registry stuff and creates machine queues
//
//+--------------------------------------------------------------

static
BOOL
StoreQueueManagerInfo(
    IN const BOOL     fFreshSetup,
    IN const BOOL     fIsEnterpriseMsmq1,
    IN const GUID    &guidMachine,
    IN const GUID    &guidSite
    )
{
    //
    // Set the registry keys for this machine
    //	
    DebugLogMsg(L"Registering the computer...");
    if (!RegisterMachine( fIsEnterpriseMsmq1, guidMachine, guidSite))
    {
        return FALSE;
    }

    //
    // Store the public keys of this machine in the directory server
    //	
    DebugLogMsg(L"Storing public keys in Active Directory...");
    HRESULT hResult = StoreMachinePublicKeys( fFreshSetup ) ;

    return (hResult == MQ_ERROR_DS_ERROR) ? FALSE : TRUE;

} //StoreQueueManagerInfo


static
bool
DsGetQmInfo(
    BOOL fMsmq1Server,
    LPCWSTR pMachineName,
    GUID * pguidMachine,
    GUID * pguidSite
    )
/*++

Routine Description:

    Get from ADS properties of this QM.
    This routine is called after the properties were set.


Arguments:

    fMsmq1Server - in, indicates if NT4 enterprise
    pguidMachine - out, guid of this QM
    pguidSite - out, guid of best site for this QM

Return Value:

    bool depending on success

--*/
{
    ASSERT(("at least one out param should be valid", pguidMachine != NULL || pguidSite != NULL));

    const UINT x_nMaxProps = 16;
    PROPID propIDs[x_nMaxProps];
    PROPVARIANT propVariants[x_nMaxProps];
    DWORD iProperty = 0;

    if (pguidMachine)
    {
        propIDs[iProperty] = PROPID_QM_MACHINE_ID;
        propVariants[iProperty].vt = VT_CLSID;
        propVariants[iProperty].puuid = pguidMachine;
        iProperty++;
    }

    if (pguidSite)
    {
        propIDs[iProperty] = PROPID_QM_SITE_ID;
        propVariants[iProperty].vt = VT_CLSID;
        propVariants[iProperty].puuid = pguidSite;
        iProperty++;
    }

    ASSERT(("we should request at least one property!", iProperty > 0));

    UINT uCounter = fMsmq1Server ? 2 : 0;
    HRESULT hr = MQ_OK;
    for (;;)
    {
        TickProgressBar();
        hr = ADGetObjectProperties(
                eMACHINE,
                NULL,	// pwcsDomainController
				false,	// fServerName
                pMachineName,
                iProperty,
                propIDs,
                propVariants
                );
        if (!FAILED(hr))
            break;

        uCounter++;
        if (1 == uCounter)
        {
            //
            // First time fail. Sleep for a while and retry.
            //
            TickProgressBar();
            Sleep(20000);
            continue;
        }

        if (2 == uCounter)
        {
            //
            // Second time fail. Sleep a little longer and retry.
            //
            TickProgressBar();
            Sleep(40000);
            continue;
        }

        //
        // Third time fail. Let the user decide.
        //
        UINT uErr = fMsmq1Server ? IDS_MACHINEGETPROPS_MSMQ1_ERROR :IDS_MACHINEGETPROPS_ERROR;
        if (IDRETRY == MqDisplayErrorWithRetry(uErr, hr))
        {
            uCounter = 0;
            continue;
        }

        break;
    }

    if (FAILED(hr))
    {
        return false;
    }

    return true;

} //DsGetQmInfo


//+--------------------------------------------------------------
//
// Function: CreateMSMQConfigurationsObject
//
// Synopsis: Creates MSMQ Configurations object (under computer object)
//           in the DS.
//
//+--------------------------------------------------------------
BOOL
CreateMSMQConfigurationsObject(
    OUT GUID *pguidMachine,
    OUT BOOL *pfObjectCreated,
    IN  BOOL  fMsmq1Server
    )
{   
    *pfObjectCreated = TRUE ;

    if (!g_fServerSetup && !g_fDependentClient && !fMsmq1Server)
    {
        //
        // For MSMQ client setup, that run against a Windows XP msmq
        // server, we're not creating the msmqConfiguration object
        // from setup. Rather, we're caching some values in registry
        // and the msmq service, after first boot, will create the object.
        // This eliminates the need to grant extra permissions in the actvie
        // directory to the user that run setup.
        //
        *pfObjectCreated = FALSE ;

        BOOL fPrepare =  PrepareRegistryForClient() ;
        return fPrepare ;
    }

    //
    // Prepare the properties
    //
    const UINT x_nMaxProps = 16;
    PROPID propIDs[x_nMaxProps];
    PROPVARIANT propVariants[x_nMaxProps];
    DWORD iProperty =0;

    propIDs[iProperty] = PROPID_QM_OLDSERVICE;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = g_dwMachineType;
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_DSSERVER;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal = (UCHAR)(g_dwMachineTypeDs ? 1 : 0);
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_ROUTING;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal = (UCHAR)(g_dwMachineTypeFrs ? 1 : 0);
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_DEPCLIENTS;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal = (UCHAR)(g_dwMachineTypeDepSrv ? 1 : 0);
    iProperty++;

    propIDs[iProperty] = PROPID_QM_MACHINE_TYPE;
    propVariants[iProperty].vt = VT_LPWSTR;
    propVariants[iProperty].pwszVal = FormInstallType();
    iProperty++;

    propIDs[iProperty] = PROPID_QM_OS;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = g_dwOS;
    iProperty++;

    TickProgressBar();
    GUID guidMsmq1ServerSite;
    if (!fMsmq1Server)
    {
        //
        // NT 5.0 enterprise. Get sites IDs for this machine from the DS.
        //
        propIDs[iProperty] = PROPID_QM_SITE_IDS;
        propVariants[iProperty].vt = VT_CLSID|VT_VECTOR;
        CACLSID cauuid;
        if (!GetSites(&cauuid))
            return FALSE;
        propVariants[iProperty].cauuid.pElems = cauuid.pElems;
        propVariants[iProperty].cauuid.cElems = cauuid.cElems;
    }
    else
    {
        //
        // NT 4.0 enterprise. Use the site GUID of the MSMQ1 DS Server
        //
        // We must have g_wcsServerName filled by the user
        //
        ASSERT(g_wcsServerName[0] != '\0');
        propIDs[iProperty] = PROPID_QM_SITE_ID;
        propVariants[iProperty].vt = VT_CLSID;
        if (!GetMsmq1ServerSiteGuid( &guidMsmq1ServerSite))
        {
            //
            // Failed to query the MSMQ1 DS Server
            //
            return FALSE;
        }
        propVariants[iProperty].puuid = &guidMsmq1ServerSite;
    }
    iProperty++;

    //
    // Some extra properties are needed if the DS Server is MSMQ1 DS Server
    //
    GUID guidMachine = GUID_NULL;
    GUID guidCns = MQ_SETUP_CN;
    BYTE Address[TA_ADDRESS_SIZE + IP_ADDRESS_LEN];
    if (fMsmq1Server)
    {
        ASSERT(*pfObjectCreated) ;

        propIDs[iProperty] = PROPID_QM_PATHNAME;
        propVariants[iProperty].vt = VT_LPWSTR;
        propVariants[iProperty].pwszVal = g_wcsMachineName;
        iProperty++;

        propIDs[iProperty] = PROPID_QM_MACHINE_ID;
        propVariants[iProperty].vt = VT_CLSID;
        for (;;)
        {
            RPC_STATUS rc = UuidCreate(&guidMachine);
            if (rc == RPC_S_OK)
            {
                break;
            }

            if (IDRETRY != MqDisplayErrorWithRetry(IDS_CREATE_UUID_ERR, rc))
            {
                return FALSE;
            }
        }
        propVariants[iProperty].puuid = &guidMachine;
        iProperty++;

        if (!GetGuidCn(&guidCns))
        {
            //
            // Failed to query the MSMQ1 DS Server IPCN
            //
            return FALSE;
        }

		ASSERT(guidCns != MQ_SETUP_CN);

        propIDs[iProperty] = PROPID_QM_CNS;
        propVariants[iProperty].vt = VT_CLSID|VT_VECTOR;
        propVariants[iProperty].cauuid.cElems = 1;
        propVariants[iProperty].cauuid.pElems = &guidCns;
        iProperty++;

        TA_ADDRESS * pBuffer = reinterpret_cast<TA_ADDRESS *>(Address);
        pBuffer->AddressType = IP_ADDRESS_TYPE;
        pBuffer->AddressLength = IP_ADDRESS_LEN;
        ZeroMemory(pBuffer->Address, IP_ADDRESS_LEN);

        propIDs[iProperty] = PROPID_QM_ADDRESS;
        propVariants[iProperty].vt = VT_BLOB;
        propVariants[iProperty].blob.cbSize = sizeof(Address);
        propVariants[iProperty].blob.pBlobData = reinterpret_cast<BYTE*>(pBuffer);
        iProperty++;
     }

    //
    // Create the MSMQ Configurations object in the DS
    //
    UINT uCounter = 0;
    HRESULT hResult;
    LPWSTR pwzMachineName = 0;

    for (;;)
    {
        TickProgressBar();

        pwzMachineName = g_wcsMachineNameDns;
        if (fMsmq1Server || lstrlenW(g_wcsMachineNameDns) < 1)
        {
            pwzMachineName = g_wcsMachineName;
        }

        hResult = ADCreateObject(
						eMACHINE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						pwzMachineName,   // DNS name (if server is MSMQ 2.0)
						NULL,
						iProperty,
						propIDs,
						propVariants,
						NULL
						);

        if (FAILED(hResult) && pwzMachineName != g_wcsMachineName)
        {
            //
            // Try NETBIOS name
            //
            pwzMachineName = g_wcsMachineName;

            hResult = ADCreateObject(
							eMACHINE,
							NULL,       // pwcsDomainController
							false,	    // fServerName
							pwzMachineName, // NETBIOS this time
							NULL,
							iProperty,
							propIDs,
							propVariants,
							NULL
							);
        }

        uCounter++;
        if (MQDS_OBJECT_NOT_FOUND == hResult && 1 == uCounter)
        {
            //
            // First try - no computer object in the DS.
            // This is okay on win9x fresh install
            // In these scenarios we have to create computer object in the DS first.
            //
            continue;
        }

        if (FAILED(hResult))
        {
            UINT uErr = fMsmq1Server ? IDS_MACHINECREATE_MSMQ1_ERROR :IDS_MACHINECREATE_ERROR;
            if (!fMsmq1Server)
            {
                if (MQDS_OBJECT_NOT_FOUND == hResult)
                    uErr = IDS_MACHINECREATE_OBJECTNOTFOUND_ERROR;
                if (MQ_ERROR_ACCESS_DENIED == hResult)
                    uErr = g_fServerSetup ? IDS_MACHINECREATE_SERVER_ACCESSDENIED_ERROR : IDS_MACHINECREATE_CLIENT_ACCESSDENIED_ERROR;
                //
                // BUGBUG: the following error code doesn't seem to be declared anywhere
                //         (see bug 3311). ShaiK, 8-Sep-98.
                //
                const UINT x_uInvalidDirectoryPathnameErr = 0xc8000500;
                if (x_uInvalidDirectoryPathnameErr == hResult)
                    uErr = IDS_MACHINECREATE_INVALID_DIR_ERROR;
            }
            if (IDRETRY == MqDisplayErrorWithRetry(uErr, hResult))
                continue;
        }
        break;
    }

    if (FAILED(hResult))
    {
        return FALSE;
    }

    //
    // Get the best site and guid of this QM
    //
    guidMachine = GUID_NULL;
    GUID guidSite = GUID_NULL;
    if (!DsGetQmInfo(fMsmq1Server, pwzMachineName, &guidMachine, &guidSite))
    {
        return FALSE;
    }


    //
    // Store QM stuff in registry
    //
    if (fMsmq1Server)
    {
        if (!StoreQueueManagerInfo(
                 TRUE,  /*fFreshSetup*/
                 fMsmq1Server,
                 guidMachine,
                 guidMsmq1ServerSite
                 ))
        {
            return FALSE;
        }
    }
    else
    {
        if (!StoreQueueManagerInfo(
                 TRUE,  /*fFreshSetup*/
                 fMsmq1Server,
                 guidMachine,
                 guidSite
                 ))
        {
            return FALSE;
        }
    }

    //
    // Store the machine guid on the out parameter
    //
    if (pguidMachine != NULL)
    {
        *pguidMachine = guidMachine;
    }

    return TRUE;

} //CreateMSMQConfigurationsObject

//+--------------------------------------------------------------
//
// Function: UpdateMSMQConfigurationsObject
//
// Synopsis: Updates existing MSMQ Configurations object in the DS
//
//+--------------------------------------------------------------
BOOL
UpdateMSMQConfigurationsObject(
    IN LPCWSTR pMachineName,
    IN const GUID& guidMachine,
    IN const GUID& guidSite,
    IN BOOL fMsmq1Server
    )
{   
    if (!g_dwMachineTypeDs && !g_dwMachineTypeFrs)
    {
        //
        // Independent client. QM does the update from DS.
        //
        
        DebugLogMsg(L"Updating the MSMQ Configuration object for an independent client...");

        return StoreQueueManagerInfo(
                   FALSE,  /*fFreshSetup*/
                   TRUE, // fMsmq1Server - specify TRUE to not query the DS
                   guidMachine,
                   guidSite
                   );
    }

    //
    // Prepare the properties
    //
    const UINT x_nMaxProps = 16;
    PROPID propIDs[x_nMaxProps];
    PROPVARIANT propVariants[x_nMaxProps];
    DWORD ixProperty = 0;

    propIDs[ixProperty] = PROPID_QM_MACHINE_TYPE;
    propVariants[ixProperty].vt = VT_LPWSTR;
    propVariants[ixProperty].pwszVal = FormInstallType();
    ixProperty++;

    propIDs[ixProperty] = PROPID_QM_OS;
    propVariants[ixProperty].vt = VT_UI4;
    propVariants[ixProperty].ulVal = g_dwOS;
    ixProperty++;

    GUID guidCns = MQ_SETUP_CN;
    BYTE Address[TA_ADDRESS_SIZE + IP_ADDRESS_LEN];
    if (fMsmq1Server)
    {
        if (!GetGuidCn(&guidCns))
        {
            //
            // Failed to query the MSMQ1 DS Server IPCN
            //
            return FALSE;
        }

		ASSERT(guidCns != MQ_SETUP_CN);

        propIDs[ixProperty] = PROPID_QM_CNS;
        propVariants[ixProperty].vt = VT_CLSID|VT_VECTOR;
        propVariants[ixProperty].cauuid.cElems = 1;
        propVariants[ixProperty].cauuid.pElems = &guidCns;
        ixProperty++;

        TA_ADDRESS * pBuffer = reinterpret_cast<TA_ADDRESS *>(Address);
        pBuffer->AddressType = IP_ADDRESS_TYPE;
        pBuffer->AddressLength = IP_ADDRESS_LEN;
        ZeroMemory(pBuffer->Address, IP_ADDRESS_LEN);

        propIDs[ixProperty] = PROPID_QM_ADDRESS;
        propVariants[ixProperty].vt = VT_BLOB;
        propVariants[ixProperty].blob.cbSize = sizeof(Address);
        propVariants[ixProperty].blob.pBlobData = reinterpret_cast<BYTE*>(pBuffer);
        ixProperty++;
    }
    else
    {
        //
        // NT 5.0 enterprise.
        // Get up to date list of sites this computer belongs to.
        //
        propIDs[ixProperty] = PROPID_QM_SITE_IDS;
        propVariants[ixProperty].vt = VT_CLSID|VT_VECTOR;
        CACLSID cauuid;
        if (!GetSites(&cauuid))
            return FALSE;
        propVariants[ixProperty].cauuid.pElems = cauuid.pElems;
        propVariants[ixProperty].cauuid.cElems = cauuid.cElems;
        ixProperty++;
    }


    //
    // Update the object properties in the DS
    // Note: Due to replication delay it's possible to fail here.
    // Resolution: sleep for a while and retry, if fail ask user to cancel/retry.
    //
    // BUGBUG: This should not be done for any failure but only
    // failures that can be caused by replication delay.
    //
    HRESULT hResult;
    UINT uCounter = fMsmq1Server ? 2 : 0;
    for (;;)
    {
        TickProgressBar();
        hResult = ADSetObjectPropertiesGuid(
						eMACHINE,
						NULL,		// pwcsDomainController
						false,		// fServerName
						&guidMachine,
						ixProperty,
						propIDs,
						propVariants
						);
        if (!FAILED(hResult))
            break;

        uCounter++;
        if (1 == uCounter)
        {
            //
            // First time fail. Sleep for a while and retry.
            //
            TickProgressBar();
            Sleep(20000);
            continue;
        }

        if (2 == uCounter)
        {
            //
            // Second time fail. Sleep a little longer and retry.
            //
            TickProgressBar();
            Sleep(40000);
            continue;
        }

        //
        // Third time fail. Let the user decide.
        //
        UINT uErr = fMsmq1Server ? IDS_MACHINESETPROPERTIES_MSMQ1_ERROR :IDS_MACHINESETPROPERTIES_ERROR;
        if (IDRETRY == MqDisplayErrorWithRetry(uErr, hResult))
        {
            uCounter = 0;
            continue;
        }

        break;
    }

    if (FAILED(hResult))
    {
        return FALSE;
    }

    //
    // For MSMQ servers on NT5 we also need to recreate all
    // MSMQSetting objects, to recover any inconsistency in ADS.
    // This is invoked by calling Create on the existing
    // MSMQConfiguration object.  (ShaiK, 24-Dec-1998)
    //
    if (g_dwMachineTypeFrs || g_dwMachineTypeDs)
    {
        ASSERT(("msmq servers should not install in NT4 enterprise", !fMsmq1Server));

        BOOL fObjectCreated ;
        if (!CreateMSMQConfigurationsObject(NULL, &fObjectCreated, FALSE /*fMsmq1Server*/))
        {
            return FALSE;
        }

        ASSERT(fObjectCreated) ;
        return TRUE;
    }


    //
    // Store QM stuff in registry
    //
    if (fMsmq1Server)
    {
        if(!StoreQueueManagerInfo(
                FALSE,  /*fFreshSetup*/
                fMsmq1Server,
                guidMachine,
                guidSite
                ))
        {
            return FALSE;
        }
    }
    else
    {
        //
        // Get from ADS the up to date "best" site for this computer.
        //
        GUID guidBestSite = GUID_NULL;
        if (!DsGetQmInfo(false, pMachineName, NULL, &guidBestSite))
        {
            return FALSE;
        }
        if(!StoreQueueManagerInfo(
                FALSE,  /*fFreshSetup*/
                fMsmq1Server,
                guidMachine,
                guidBestSite
                ))
        {
            return FALSE;
        }
    }

    return TRUE;

} //UpdateMSMQConfigurationsObject

//+--------------------------------------------------------------
//
// Function: InstallMachine
//
// Synopsis: Machine installation (driver, storage, etc...)
//
//+--------------------------------------------------------------
BOOL
InstallMachine()
{
    TickProgressBar();
    if (!InstallMSMQService())
    {
        return FALSE ;
    }
    g_fMSMQServiceInstalled = TRUE ;

    //
    // Install the device driver
    //
    if (!InstallDeviceDrivers())
    {
        return FALSE ;
    }    
    
    return TRUE ;

}  //InstallMachine


bool
StoreSecurityDescriptorInRegistry(
    IN PSECURITY_DESCRIPTOR pSd,
    IN DWORD dwSize
    )
/*++

Routine Description:

    Writes the machine security descriptor in Falcon registry

Arguments:

    pSd - pointer to security descriptor
    dwSize - size of the security descriptor

Return Value:

    true iff successfull

--*/
{
    BOOL f = MqWriteRegistryValue(
                MSMQ_DS_SECURITY_CACHE_REGNAME,
                dwSize,
                REG_BINARY,
                pSd
                );

    return (f == TRUE);

} //StoreSecurityDescriptorInRegistry


//+--------------------------------------------------------------
//
// Function: StoreMachineSecurity
//
// Synopsis: Caches security info in registry
//
//+--------------------------------------------------------------
BOOL
StoreMachineSecurity(
    IN const GUID &guidMachine
    )
{
    SECURITY_INFORMATION RequestedInformation =
        OWNER_SECURITY_INFORMATION |
        GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION;

    PROPVARIANT varSD;
    varSD.vt = VT_NULL;
    HRESULT hr = ADGetObjectSecurityGuid(
                            eMACHINE,
                            NULL,       // pwcsDomainController
							false,	    // fServerName
                            &guidMachine,
                            RequestedInformation,
                            PROPID_QM_SECURITY,
                            &varSD
							);
    if (SUCCEEDED(hr))
    {
        ASSERT(varSD.vt == VT_BLOB);
        StoreSecurityDescriptorInRegistry(varSD.blob.pBlobData, varSD.blob.cbSize);
        delete varSD.blob.pBlobData;
    }
    else
    {
        MqDisplayError(
            NULL,
            IDS_CACHE_SECURITY_ERROR,
            hr
            );
    }

    return SUCCEEDED(hr);

} // StoreMachineSecurity
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\machnutl.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    machnutl.cpp

Abstract:

    Utility/helper code for creating the machine objects.

Author:


Revision History:

    Doron Juster  (DoronJ)

--*/

#include "msmqocm.h"
#include <mqsec.h>

#include "machnutl.tmh"

//+----------------------------------------------------------------------
//
//  BOOL  PrepareRegistryForClient()
//
//  Prepare registry for client msmq service that will later create the
//  msmqConfiguration object in the active directory.
//
//+----------------------------------------------------------------------

BOOL  PrepareRegistryForClient()
{
    BOOL fRegistry ;

    //
    // msmqConfiguration object will be created by the msmq service
    // after it boot.
    //
    TickProgressBar();

    DWORD dwCreate = 1 ;
    fRegistry = MqWriteRegistryValue( MSMQ_CREATE_CONFIG_OBJ_REGNAME,
                                      sizeof(DWORD),
                                      REG_DWORD,
                                     &dwCreate ) ;
    ASSERT(fRegistry) ;

    //
    // Save SID of user in registry. The msmq service will read the sid
    // and use it when building the DACL of the msmqConfiguration object.
    //
    HINSTANCE hMQSecDLL;
    HRESULT hResult = StpLoadDll(MQSEC_DLL, &hMQSecDLL);
    if (FAILED(hResult))
    {
        return FALSE ;
    }

    //
    // Obtain pointers to functions in mqsec.dll
    //

    MQSec_GetProcessUserSid_ROUTINE pfnGetUserSid =
            (MQSec_GetProcessUserSid_ROUTINE) GetProcAddress(
                                     hMQSecDLL, "MQSec_GetProcessUserSid") ;
    if (pfnGetUserSid == NULL)
    {
        MqDisplayError(
            NULL,
            IDS_DLLGETADDRESS_ERROR,
            0,
            TEXT("MQSec_GetProcessUserSid"),
            MQSEC_DLL);

        FreeLibrary(hMQSecDLL);
        return FALSE ;
    }

    MQSec_GetUserType_ROUTINE pfnGetUserType =
            (MQSec_GetUserType_ROUTINE) GetProcAddress(
                                         hMQSecDLL, "MQSec_GetUserType") ;
    if (pfnGetUserType == NULL)
    {
        MqDisplayError(
            NULL,
            IDS_DLLGETADDRESS_ERROR,
            0,
            TEXT("MQSec_GetUserTpye"),
            MQSEC_DLL);

        FreeLibrary(hMQSecDLL);
        return FALSE ;
    }

    //
    // Store the public keys of the machine in the directory server
    //	
    DebugLogMsg(L"Calling MQSec_GetProcessUserSid...") ;

    P<BYTE>  pUserSid = NULL ;
    DWORD    dwSidLen = 0 ;

    hResult = (*pfnGetUserSid) ( (PSID*) &pUserSid,
                                  &dwSidLen ) ;
    ASSERT(SUCCEEDED(hResult)) ;

    if (SUCCEEDED(hResult))
    {
        BOOL  fLocalUser = FALSE ;
        hResult = (*pfnGetUserType) ( pUserSid, &fLocalUser, NULL ) ;
        ASSERT(SUCCEEDED(hResult)) ;

        if (SUCCEEDED(hResult))
        {
            if (fLocalUser)
            {
                DWORD dwLocal = 1 ;
                DWORD dwSize = sizeof(dwLocal) ;

                fRegistry = MqWriteRegistryValue(
                                            MSMQ_SETUP_USER_LOCAL_REGNAME,
                                            dwSize,
                                            REG_DWORD,
                                            &dwLocal ) ;
            }
            else
            {
                //
                // Only domain user get full control on the object, not
                // local user. Local user is not known in active directory.
                //
                fRegistry = MqWriteRegistryValue(
                                             MSMQ_SETUP_USER_SID_REGNAME,
                                             dwSidLen,
                                             REG_BINARY,
                                             pUserSid ) ;
            }
            ASSERT(fRegistry) ;
        }
    }

    FreeLibrary(hMQSecDLL) ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\mqmaps.cpp ===
#include "msmqocm.h"

#include "mqmaps.tmh"

//
// please put attention: each line starts by " (quota sign)
// and ends by \r\n" (backslash, letter 'r', backslash, letter 'n' and quota sign)
// if you need quota sign ot back slash in the line please use backslash before the sigh:
// sample:
// if you need to put the line ' .... host="localhost"...' you have to write
// L".... host=\"localhost\" ...." 
// or for '...msmq\internal...' you have to write 
// L"...msmq\\internal..."
// As a result setup will generate file sample_map.xml in msmq\mapping directory.
// The file will look like
/*---------------
<!-- This is a sample XML file that demonstrates queue mapping. Use it as a template to
    create your own queue mapping files. -->


<mapping host="localhost" xmlns="msmq-queue-mapping.xml">

    <!-- Element that maps an internal application queue name to an external one. 
	<queue>
   		<name>http://internal_host\msmq\internal_queue</name> 
   		<alias>http://external_host\msmq\external_queue</alias>
   	</queue>
	--> 

	<!-- Element that maps an internal MSMQ order queue to an external one. It is needed in order
	     to send transactional messages to a destination queue outside the organization. 

	<queue>
   		<name>http://internal_host\msmq\private$\order_queue$</name> 
   		<alias>http://external_host\msmq\private$\order_queue$</alias>
   	</queue>
	--> 
	

</mapping>
-----------------*/

const char g_szMappingSample[] = ""
"<!-- This is a sample XML file that demonstrates queue mapping. Use it as a template to\r\n"
"  create your own queue mapping files. -->\r\n"
"\r\n"
"\r\n"
"<mapping host=\"localhost\" xmlns=\"msmq-queue-mapping.xml\">\r\n"
"\r\n"
"  <!-- Element that maps an internal application queue name to an external one. \r\n"
"  <queue>\r\n"
"      <name>http://internal_host/msmq/internal_queue</name> \r\n"
"      <alias>http://external_host/msmq/external_queue</alias>\r\n"
"  </queue>\r\n"
"	--> \r\n"
"\r\n"
"  <!-- Element that maps an internal MSMQ order queue to an external one. It is needed in order\r\n"
"      to send transactional messages to a destination queue outside the organization. \r\n"
"\r\n"
"  <queue>\r\n"
"      <name>http://internal_host/msmq/private$/order_queue$</name> \r\n"
"      <alias>http://external_host/msmq/private$/order_queue$</alias>\r\n"
"  </queue>\r\n"
"	--> \r\n"
"\r\n"	
"\r\n"
"</mapping>\r\n"
"\r\n";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\msmqocm.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    msmqocm.cpp

Abstract:

    Entry point for OCM.

Author:

    Shai Kariv  (ShaiK)  10-Dec-97

--*/

#include "msmqocm.h"
#include "_mqres.h"

#include "msmqocm.tmh"

//
// Various globals
//
BOOL    g_fServerSetup = TRUE;
BOOL    g_fMSMQAlreadyInstalled;
BOOL    g_fDependentClient = FALSE ;
BOOL    g_fMSMQServiceInstalled = FALSE ;
BOOL    g_fDriversInstalled = FALSE ;
BOOL    g_fCoreSetupSuccess = FALSE;
BOOL    g_fDsLess = FALSE;
BOOL    g_fContinueWithDsLess = FALSE;
//
// we need this flag because of IIS installation bug.
// we have to postpone msmq iis installation to the end of setup
//
BOOL    g_fNeedToCreateIISExtension = FALSE;

//
// Setup mode (install, remove, etc...)
//
BOOL  g_fBatchInstall     = FALSE ;
BOOL  g_fCancelled        = FALSE ;
BOOL  g_fUpgrade          = FALSE ;
DWORD g_dwDsUpgradeType   = 0;
BOOL  g_fWelcome          = FALSE ;
BOOL  g_fOnlyRegisterMode = FALSE ;
BOOL  g_fWrongConfiguration = FALSE;

//
// ID of error messages title
//
UINT  g_uTitleID     = IDS_SETUP_ERROR ;

//
// Machine info
//
WCHAR g_wcsMachineName[MAX_PATH] = {_T("")};
WCHAR g_wcsMachineNameDns[MAX_PATH] = {_T("")};
DWORD g_dwMachineType = SERVICE_NONE ;  // "old" property for msmq type
DWORD g_dwMachineTypeDs = 0;            // boolean: ds server
DWORD g_dwMachineTypeFrs = 1;           // boolean: routing server
DWORD g_dwMachineTypeDepSrv = 0;        // boolean: dependent client supporting server

SC_HANDLE g_hServiceCtrlMgr;

SPerComponentData g_ComponentMsmq;

extern VOID APIENTRY ShutDownDebugWindow(VOID);

//
// DLL handles
// Get the handle to the resource only DLL first, i.e. mqutil.dll
//
HINSTANCE g_hResourceMod = MQGetResourceHandle();
HINSTANCE g_hMqutil = NULL;

SSubcomponentData g_SubcomponentMsmq[] =
{
//=====================================================================
//  szSubcomponentId        ||InitialState  ||IsSelected    ||fIsInstalled  ||dwOperation             PFNINSTALL||            PFNREMOVE
//=====================================================================
    {MSMQ_CORE_SUBCOMP,     FALSE,          FALSE,          FALSE,          DONOTHING,              InstallMsmqCore,        RemoveMSMQCore},
    {LOCAL_STORAGE_SUBCOMP, FALSE,          FALSE,          FALSE,          DONOTHING,              InstallLocalStorage,    UnInstallLocalStorage},
    {TRIGGERS_SUBCOMP,      FALSE,          FALSE,          FALSE,          DONOTHING,              InstallMSMQTriggers,    UnInstallMSMQTriggers},
    {HTTP_SUPPORT_SUBCOMP,  FALSE,          FALSE,          FALSE,          DONOTHING,              InstallIISExtension,    UnInstallIISExtension},
    {AD_INTEGRATED_SUBCOMP, FALSE,          FALSE,          FALSE,          DONOTHING,              InstallADIntegrated,    UnInstallADIntegrated},
    {ROUTING_SUBCOMP,       FALSE,          FALSE,          FALSE,          DONOTHING,              InstallRouting,         UnInstallRouting},
    {MQDSSERVICE_SUBCOMP,   FALSE,          FALSE,          FALSE,          DONOTHING,              InstallMQDSService,     UnInstallMQDSService}
};

//
// number of all subcomponents
//
DWORD g_dwAllSubcomponentNumber = sizeof(g_SubcomponentMsmq)/sizeof(SSubcomponentData);

//
// first server only subcomponent: eRoutingSupport
//
DWORD g_dwClientSubcomponentNumber = eRoutingSupport;
DWORD g_dwSubcomponentNumber;

bool
LoadMsmqCommonDlls(
    VOID
    )
{
    if (g_hMqutil != NULL)
    {
        //
        // DLLs already loaded
        //
        return true;
    }

    HRESULT hr = StpLoadDll(MQUTIL_DLL, &g_hMqutil);
    if (FAILED(hr))
    {
        return false;
    }
    return true;

} //LoadMsmqCommonDlls


VOID
FreeMsmqCommonDlls(
    VOID
    )
{
    if (g_hMqutil == NULL)
    {
        //
        // DLLs not loaded
        //
        return;
    }

    ASSERT(("invalid handle to mqutil.dll", g_hMqutil != NULL));
    BOOL success = FALSE;
    success = FreeLibrary(g_hMqutil);
    ASSERT(success);
    g_hMqutil = NULL;

} //FreeMsmqCommonDlls


//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
    IN const HANDLE DllHandle,
    IN const DWORD  Reason,
    IN const LPVOID Reserved )
{
    UNREFERENCED_PARAMETER(Reserved);

    switch( Reason )
    {
        case DLL_PROCESS_ATTACH:
        {
            break;
        }

        default:
        {
            break;
        }
    }

    return TRUE;

} //DllMain


//+-------------------------------------------------------------------------
//
//  Function:   MsmqOcm
//
//  Synopsis:   Called by the ocmgr when things happen
//
//  Arguments:  ComponentId    -- the MSMQ Component name
//              SubcomponentId -- the .inf section being operated on
//              Function       -- the operation
//              Param1         -- operation paramater
//              Param2         -- operation paramater
//
//  Returns:    Win32 error code (usually), depends on Function
//
//--------------------------------------------------------------------------
DWORD  //POCSETUPPROC
MsmqOcm(
    IN const TCHAR * ComponentId,
    IN const TCHAR * SubcomponentId,
    IN const UINT    Function,
    IN const UINT_PTR  Param1,
    IN OUT PVOID   Param2 )
{
    DWORD dwRetCode = NO_ERROR;

    switch(Function)
    {

      case OC_PREINITIALIZE:
      {
          dwRetCode = OCFLAG_UNICODE;
          break;
      }

      case OC_INIT_COMPONENT:
      {
          dwRetCode = MqOcmInitComponent(ComponentId, Param2) ;
          break;
      }

      case OC_QUERY_STATE:
      {
          dwRetCode = MqOcmQueryState(Param1, SubcomponentId);

          break;
      }

      case OC_SET_LANGUAGE:
      {
          //
          // We don't care what language is used
          //
          dwRetCode = 1;
          break;
      }

      case OC_REQUEST_PAGES:
      {
          dwRetCode = MqOcmRequestPages(
              g_ComponentMsmq.ComponentId,
              (WizardPagesType) Param1,
              (PSETUP_REQUEST_PAGES) Param2 );
          break;
      }

      case OC_QUERY_CHANGE_SEL_STATE:
      {
          if (g_fCancelled)
          {
              //
              // Setup was cancelled. Don't allow changes.
              //
              dwRetCode = 0;
          }
          else
          {
              dwRetCode =
                  MqOcmQueryChangeSelState(SubcomponentId, Param1, (DWORD_PTR)Param2);
          }

          break;
      }

      case OC_QUERY_SKIP_PAGE:
      {
          //
          // for subcomponent setup: we need to show pages if Advanced
          // Option was selected. Otherwise we have sufficient information
          // to run setup without UI. In order
          // - to skip pages return non-0;
          // - do not skip pages return 0;
          //

		  if (g_fWelcome && WizPagesEarly != Param1)
		  {
			  dwRetCode = 1;
		  }
		  else
		  {
              dwRetCode = 0;
		  }

          break ;
      }

      case OC_CALC_DISK_SPACE:
      {
          //
          // Param1 = 0 if for removing component or non-0 if for adding component
          // Param2 = HDSKSPC to operate on
          //
          dwRetCode = MqOcmCalcDiskSpace((Param1 != 0), SubcomponentId, (HDSKSPC)Param2);

          break;
      }

      case OC_QUEUE_FILE_OPS:
      {
          if (0 == SubcomponentId)
          {
              //
              // False notification from OCM, just ignore (we will be called again)
              //
              dwRetCode = NO_ERROR;
              break;
          }

          if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[eMSMQCore].szSubcomponentId) != 0)
          {
              //
              // there is no file operation if it is not CORE subcomponent
              //
              dwRetCode = NO_ERROR;
              break;
          }

          //
          // We can reach this point once, for MSMQ Core subcomponent only.
          // So, it is the time to perform operations that must be done only once
          // when UI is already closed (it does not matter what is subcomponent
          // here, so do all for MSMQ Core)
          //
          MqInit();

          //
          // It is already defined what we have to do, so it is the time
          // to set operation flags for each subcomponent if we did not
          // set operation before, in our wizard page. It can happen if
          // we are in unattended mode.
          // We need to call this function only once (we set operation for
          // all components)
          //
          SetOperationForSubcomponents();

          //
          // Note: this case is always called before removing or installing,
          // so we are using it to initialize some stuff.
          // Don't call it for no-op.
          //
          if ( (g_SubcomponentMsmq[eMSMQCore].dwOperation != DONOTHING) ||
              //
              // or upgrading the OS and msmq is installed
              //
              (0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE) && g_fMSMQAlreadyInstalled))
          {
              //
              // Param2 = HSPFILEQ to operate on
              //
              //
              // file operation only if MSMQ Core subcomponent
              // was selected/ unselected
              //
              dwRetCode = MqOcmQueueFiles(SubcomponentId, Param2);
          }
          else
          {
              DebugLogMsg(L"Operating in DO NOTHING mode, skipping file operation...");
          }

          break;
      }

      case OC_QUERY_STEP_COUNT:
      {
          //
          // BUGBUG: we need to define number of steps for each
          // subcomponent separately. Maybe it is possible to save it
          // in msmqocm.inf.
          //
          const x_nInstallationSteps = 20;
          dwRetCode = 0; // No steps
          if (!g_fCancelled)
          {
              DWORD dwSetupOperation = GetSetupOperationBySubcomponentName(SubcomponentId);
              dwRetCode = (DONOTHING == dwSetupOperation ? 0 : x_nInstallationSteps);
          }

          break;
      }

      case OC_ABOUT_TO_COMMIT_QUEUE :
      {
          dwRetCode = NO_ERROR;

          MqOcmRemoveInstallation(SubcomponentId); // Ignore errors

          break;
      }

      case OC_COMPLETE_INSTALLATION:
      {

          //
          // Install MSMQ. Don't report errors to OCM.
          //
          MqOcmInstall(SubcomponentId) ;
          break;
      }

      case OC_QUERY_IMAGE:
      {
          //
          // we do it in .inf files. Please keep resource ID numbers (118-130)!
          // if you have to change them do not forget to change them in
          // all .inf files!
          //
          break;
      }

      case OC_CLEANUP:
      {
          //
          // the wizard is closed at this moment. We need to call
          // MessageBox with NULL first parameter
          //
          g_hPropSheet = NULL;
          //
          // End of install/upgrade path.
          // We no longer need the MSMQ DLLs loaded.
          //
          FreeMsmqCommonDlls();
          //
          //  Terminate MQUTIL working threads
          //
          ShutDownDebugWindow();

          break;
      }

      default:
      {
          dwRetCode=0;
          break;
      }
    }

    return dwRetCode;

} //MsmqOcm


//+-------------------------------------------------------------------------
//
//  Function:   WelcomeEntryProc
//
//  Synopsis:   Entry point for installing MSMQ from Welcome UI.
//              Wraps MsmqOcm().
//
//--------------------------------------------------------------------------
DWORD
WelcomeEntryProc(
    IN const TCHAR * ComponentId,
    IN const TCHAR * SubcomponentId,
    IN const UINT    Function,
    IN const UINT_PTR    Param1,
    IN OUT PVOID   Param2 )
{
    g_fWelcome = TRUE;

    return MsmqOcm(ComponentId, SubcomponentId, Function, Param1, Param2);

} // WelcomeEntryProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\ocmnames.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmnames.h

Abstract:

    To define names which appear in the inf files.

Author:

    Doron Juster  (DoronJ)   6-Oct-97 

Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/


//
// Names for performance counters entries.
//
#define   OCM_PERF_ADDREG    TEXT("PerfCountInstall")
#define   OCM_PERF_DELREG    TEXT("PerfCountUnInstall")

#define   UPG_DEL_SYSTEM_SECTION    TEXT("MsmqUpgradeDelSystemFiles")
#define   UPG_DEL_PROGRAM_SECTION   TEXT("MsmqUpgradeDelProgramFiles")

//
// These directory ids are referred to in the .inf file,
// under section [DestinationDirs]
//
#define  idSystemDir          97000
#define  idMsmqDir            97001
#define  idSystemDriverDir    97005
#define  idExchnConDir        97010
#define  idStorageDir         97019
#define  idWinHelpDir         97020
#define  idWebDir             97021
#define  idMappingDir         97022

#define  idMsmq1SetupDir      97050
#define  idMsmq1SDK_DebugDir  97055
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\setup\msmqocm\ocmmail.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmmail.cpp

Abstract:

    Handles Exchange connector.

Author:


Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "ocmmail.tmh"

//structure of ini file line
typedef struct MQXPMapiSvcLine_Tag
{
	LPTSTR lpszSection;
	LPTSTR lpszKey;
	LPTSTR lpszValue;
} MQXPMapiSvcLine, *LPMQXPMapiSvcLine;

//ini file lines to maintain in mapisvc.inf
MQXPMapiSvcLine g_MQXPMapiSvcLines[] =
{
	{TEXT("Services"),			    TEXT("MSMQ"),						TEXT("Microsoft Message Queue")},
	{TEXT("MSMQ"),				    TEXT("Providers"),				    TEXT("MSMQ_Transport")},
	{TEXT("MSMQ"),				    TEXT("Sections"),					TEXT("MSMQ_Shared_Section")},
	{TEXT("MSMQ"),				    TEXT("PR_SERVICE_DLL_NAME"),		TEXT("mqxp.dll")},
	{TEXT("MSMQ"),				    TEXT("PR_SERVICE_SUPPORT_FILES"),	TEXT("mqxp.dll")},
	{TEXT("MSMQ"),				    TEXT("PR_SERVICE_DELETE_FILES"),	TEXT("mqxp.dll")},
	{TEXT("MSMQ"),				    TEXT("PR_SERVICE_ENTRY_NAME"),	    TEXT("ServiceEntry")},
	{TEXT("MSMQ"),				    TEXT("PR_RESOURCE_FLAGS"),		    TEXT("SERVICE_SINGLE_COPY")},
	{TEXT("MSMQ_Shared_Section"),	TEXT("UID"),						TEXT("80d245f07092cf11a9060020afb8fb50")},
	{TEXT("MSMQ_Transport"),		TEXT("PR_PROVIDER_DLL_NAME"),		TEXT("mqxp.dll")},
	{TEXT("MSMQ_Transport"),		TEXT("PR_RESOURCE_TYPE"),			TEXT("MAPI_TRANSPORT_PROVIDER")},
	{TEXT("MSMQ_Transport"),		TEXT("PR_RESOURCE_FLAGS"),		    TEXT("STATUS_PRIMARY_IDENTITY")},
	{TEXT("MSMQ_Transport"),		TEXT("PR_PROVIDER_DISPLAY"),		TEXT("Microsoft Message Queue Transport")}
};


//+-------------------------------------------------------------------------
//
//  Function: FGetMapiSvcFile
//
//  Synopsis: Returns the path to mapisvc.inf  
//
//--------------------------------------------------------------------------
static 
BOOL 
FGetMapiSvcFile(
	LPTSTR lpszBuf, 
	ULONG cchBuf)
